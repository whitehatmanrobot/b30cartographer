assword,
            &AuthIdentity->PasswordLength
            );
        if (AuthIdentity->Password == NULL)
            {
            WipeOutAuthIdentity(AuthIdentity);
            return RPC_S_OUT_OF_MEMORY;
            }

        NtStatus = RtlEncryptMemory(AuthIdentity->Password,
            AuthIdentity->PasswordLength * sizeof(RPC_CHAR),
            0);

        if (!NT_SUCCESS(NtStatus))
            {
            ASSERT(NtStatus != STATUS_INVALID_PARAMETER);
            WipeOutAuthIdentity(AuthIdentity);
            return RPC_S_OUT_OF_MEMORY;
            }
        }

    return RPC_S_OK;
}

RPC_STATUS DecryptAuthIdentity (
    IN SEC_WINNT_AUTH_IDENTITY_W *AuthIdentity
    )
/*++

Routine Description:

    Decrypts the important parts of an auth identity structure.
    If decryption fails half way through, the auth identity will
    be wiped out.

Arguments:

    AuthIdentity - the auth identity to decrypt.

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    RPC_STATUS RpcStatus;
    NTSTATUS NtStatus;

    if (AuthIdentity->User != NULL)
        {
        NtStatus = RtlDecryptMemory(AuthIdentity->User,
            AuthIdentity->UserLength * sizeof(RPC_CHAR),
            0);

        if (!NT_SUCCESS(NtStatus))
            {
            WipeOutAuthIdentity(AuthIdentity);
            return RPC_S_OUT_OF_MEMORY;
            }

        AuthIdentity->UserLength = RpcpStringLength(AuthIdentity->User);
        }

    if (AuthIdentity->Domain != NULL)
        {
        NtStatus = RtlDecryptMemory(AuthIdentity->Domain,
            AuthIdentity->DomainLength * sizeof(RPC_CHAR),
            0);

        if (!NT_SUCCESS(NtStatus))
            {
            WipeOutAuthIdentity(AuthIdentity);
            return RPC_S_OUT_OF_MEMORY;
            }

        AuthIdentity->DomainLength = RpcpStringLength(AuthIdentity->Domain);
        }

    if (AuthIdentity->Password != NULL)
        {
        NtStatus = RtlDecryptMemory(AuthIdentity->Password,
            AuthIdentity->PasswordLength * sizeof(RPC_CHAR),
            0);

        if (!NT_SUCCESS(NtStatus))
            {
            WipeOutAuthIdentity(AuthIdentity);
            return RPC_S_OUT_OF_MEMORY;
            }

        AuthIdentity->PasswordLength = RpcpStringLength(AuthIdentity->Password);
        }

    return RPC_S_OK;
}

void FreeAuthIdentity (
    IN SEC_WINNT_AUTH_IDENTITY_W *AuthIdentity
    )
/*++

Routine Description:

    Frees an auth identity structure.

Arguments:

    AuthIdentity - the auth identity to free.

Return Value:

Notes:

    Does not wipe out the auth identity! It must
    have been wiped out by the caller.

--*/
{
    if (AuthIdentity->User != NULL)
        {
        delete [] AuthIdentity->User;
        AuthIdentity->User = NULL;
        }

    if (AuthIdentity->Domain != NULL)
        {
        delete [] AuthIdentity->Domain;
        AuthIdentity->Domain = NULL;
        }

    if (AuthIdentity->Password != NULL)
        {
        delete [] AuthIdentity->Password;
        AuthIdentity->Password = NULL;
        }

    delete AuthIdentity;
}

SEC_WINNT_AUTH_IDENTITY_W *DuplicateAuthIdentity (
    IN SEC_WINNT_AUTH_IDENTITY_W *AuthIdentity
    )
/*++

Routine Description:

    Duplicates an auth identity structure. It works on both
    encrypted and decrypted auth identity.

Arguments:

    AuthIdentity - the auth identity to copy from.

Return Value:

    Duplicated auth identity of NULL for failure

--*/
{
    SEC_WINNT_AUTH_IDENTITY_W *NewAuthIdentity;

    NewAuthIdentity = new SEC_WINNT_AUTH_IDENTITY_W;
    if (NewAuthIdentity == NULL)
        return NULL;

    RpcpMemoryCopy(NewAuthIdentity, AuthIdentity, sizeof(SEC_WINNT_AUTH_IDENTITY_W));
    NewAuthIdentity->User = NULL;
    NewAuthIdentity->Domain = NULL;
    NewAuthIdentity->Password = NULL;

    if (AuthIdentity->User)
        {
        NewAuthIdentity->User = new RPC_CHAR [AuthIdentity->UserLength + 1];
        if (NewAuthIdentity->User == NULL)
            {
            FreeAuthIdentity(NewAuthIdentity);
            return NULL;
            }
        RpcpMemoryCopy(NewAuthIdentity->User, 
            AuthIdentity->User, 
            (AuthIdentity->UserLength + 1) * sizeof(RPC_CHAR));
        }

    if (AuthIdentity->Domain)
        {
        NewAuthIdentity->Domain = new RPC_CHAR [AuthIdentity->DomainLength + 1];
        if (NewAuthIdentity->Domain == NULL)
            {
            WipeOutAuthIdentity(NewAuthIdentity);
            FreeAuthIdentity(NewAuthIdentity);
            return NULL;
            }
        RpcpMemoryCopy(NewAuthIdentity->Domain, 
            AuthIdentity->Domain, 
            (AuthIdentity->DomainLength + 1) * sizeof(RPC_CHAR));
        }

    if (AuthIdentity->Password)
        {
        NewAuthIdentity->Password = new RPC_CHAR [AuthIdentity->PasswordLength + 1];
        if (NewAuthIdentity->Password == NULL)
            {
            WipeOutAuthIdentity(NewAuthIdentity);
            FreeAuthIdentity(NewAuthIdentity);
            return NULL;
            }
        RpcpMemoryCopy(NewAuthIdentity->Password, 
            AuthIdentity->Password, 
            (AuthIdentity->PasswordLength + 1) * sizeof(RPC_CHAR));
        }

    return NewAuthIdentity;
}

int CompareAuthIdentity (
    IN SEC_WINNT_AUTH_IDENTITY_W *AuthIdentity1,
    IN SEC_WINNT_AUTH_IDENTITY_W *AuthIdentity2
    )
/*++

Routine Description:

    Compares 2 auth identity structures. Works on both
    encrypted and decrypted auth identities?

Arguments:

    AuthIdentity1 - first auth identity structure

    AuthIdentity2 - second auth identity structure

Return Value:

    0 if they are equal. non-zero otherwise.

--*/
{
    ASSERT(_NOT_COVERED_);

    if (AuthIdentity1->Flags != AuthIdentity2->Flags)
        return 1;

    if (AuthIdentity1->User)
        {
        if (AuthIdentity2->User == NULL)
            return 1;

        if (AuthIdentity1->UserLength != AuthIdentity2->UserLength)
            return 1;

        if (RpcpMemoryCompare(AuthIdentity1->User, 
            AuthIdentity2->User, 
            AuthIdentity1->UserLength * sizeof(RPC_CHAR)) != 0)
            return 1;
        }
    else if (AuthIdentity2->User != NULL)
        return 1;

    if (AuthIdentity1->Domain)
        {
        if (AuthIdentity2->Domain == NULL)
            return 1;

        if (AuthIdentity1->DomainLength != AuthIdentity2->DomainLength)
            return 1;

        if (RpcpMemoryCompare(AuthIdentity1->Domain, 
            AuthIdentity2->Domain, 
            AuthIdentity1->DomainLength * sizeof(RPC_CHAR)) != 0)
            return 1;
        }
    else if (AuthIdentity2->Domain != NULL)
        return 1;

    if (AuthIdentity1->Password)
        {
        if (AuthIdentity2->Password == NULL)
            return 1;

        if (AuthIdentity1->Password != AuthIdentity2->Password)
            return 1;

        if (RpcpMemoryCompare(AuthIdentity1->Password, 
            AuthIdentity2->Password, 
            AuthIdentity1->PasswordLength * sizeof(RPC_CHAR)) != 0)
            return 1;
        }
    else if (AuthIdentity2->Password != NULL)
        return 1;

    return 0;
}

SEC_WINNT_AUTH_IDENTITY_W *ConvertAuthIdentity (
    IN SEC_WINNT_AUTH_IDENTITY_A *AuthIdentity
    )
/*++

Routine Description:

    Converts an auth identity structure.
    Conversion is done on a separate copy.

Arguments:

    AuthIdentity - the auth identity to convert.

Return Value:

    Pointer to duplicated/converted auth identity. If failure,
    NULL.

--*/
{
    SEC_WINNT_AUTH_IDENTITY_W *NewAuthIdentity;

    ASSERT(AuthIdentity->Flags == SEC_WINNT_AUTH_IDENTITY_ANSI);

    NewAuthIdentity = new SEC_WINNT_AUTH_IDENTITY_W;
    if (NewAuthIdentity == NULL)
        return NULL;

    RpcpMemoryCopy(NewAuthIdentity, AuthIdentity, sizeof(SEC_WINNT_AUTH_IDENTITY_W));
    NewAuthIdentity->User = NULL;
    NewAuthIdentity->Domain = NULL;
    NewAuthIdentity->Password = NULL;
    NewAuthIdentity->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    if (AuthIdentity->User)
        {
        NewAuthIdentity->User = new RPC_CHAR [AuthIdentity->UserLength + 1];
        if (NewAuthIdentity->User == NULL)
            {
            FreeAuthIdentity(NewAuthIdentity);
            return NULL;
            }
        FullAnsiToUnicode((char *)AuthIdentity->User, NewAuthIdentity->User);
        }

    if (AuthIdentity->Domain)
        {
        NewAuthIdentity->Domain = new RPC_CHAR [AuthIdentity->DomainLength + 1];
        if (NewAuthIdentity->Domain == NULL)
            {
            WipeOutAuthIdentity(NewAuthIdentity);
            FreeAuthIdentity(NewAuthIdentity);
            return NULL;
            }
        FullAnsiToUnicode((char *)AuthIdentity->Domain, NewAuthIdentity->Domain);
        }

    if (AuthIdentity->Password)
        {
        NewAuthIdentity->Password = new RPC_CHAR [AuthIdentity->PasswordLength + 1];
        if (NewAuthIdentity->Password == NULL)
            {
            WipeOutAuthIdentity(NewAuthIdentity);
            FreeAuthIdentity(NewAuthIdentity);
            return NULL;
            }
        FullAnsiToUnicode((char *)AuthIdentity->Password, NewAuthIdentity->Password);
        }

    return NewAuthIdentity;
}

void FreeHttpTransportCredentials (
    IN RPC_HTTP_TRANSPORT_CREDENTIALS_W *Credentials
    )
/*++

Routine Description:

    Duplicates Http transport credentials.

Arguments:

    Credentials - the credentials to free.

Return Value:

--*/
{
    if (Credentials->AuthnSchemes != NULL)
        {
        delete [] Credentials->AuthnSchemes;
        Credentials->AuthnSchemes = NULL;
        }

    if (Credentials->ServerCertificateSubject != NULL)
        {
        delete [] Credentials->ServerCertificateSubject;
        Credentials->ServerCertificateSubject = NULL;
        }

    if (Credentials->TransportCredentials != NULL)
        {
        FreeAuthIdentity(Credentials->TransportCredentials);
        Credentials->TransportCredentials = NULL;
        }
}
    
RPC_HTTP_TRANSPORT_CREDENTIALS_W *DuplicateHttpTransportCredentials (
    const IN RPC_HTTP_TRANSPORT_CREDENTIALS_W *SourceCredentials
    )
/*++

Routine Description:

    Duplicates Http transport credentials.

Arguments:

    SourceCredentials - the credentials to duplicate.

Return Value:

    Duplicated credentials or NULL if there was not enough memory.

--*/
{
    RPC_HTTP_TRANSPORT_CREDENTIALS_W *NewCredentials;

    NewCredentials = new RPC_HTTP_TRANSPORT_CREDENTIALS_W;
    if (NewCredentials == NULL)
        return NewCredentials;

    NewCredentials->Flags = SourceCredentials->Flags;
    NewCredentials->AuthenticationTarget = SourceCredentials->AuthenticationTarget;
    NewCredentials->NumberOfAuthnSchemes = SourceCredentials->NumberOfAuthnSchemes;
    NewCredentials->AuthnSchemes = NULL;
    NewCredentials->ServerCertificateSubject = NULL;
    NewCredentials->TransportCredentials = NULL;
    if (SourceCredentials->AuthnSchemes)
        {
        NewCredentials->AuthnSchemes = new ULONG [SourceCredentials->NumberOfAuthnSchemes];
        if (NewCredentials->AuthnSchemes == NULL)
            {
            FreeHttpTransportCredentials(NewCredentials);
            return NULL;
            }

        RpcpMemoryCopy(NewCredentials->AuthnSchemes, 
            SourceCredentials->AuthnSchemes,
            SourceCredentials->NumberOfAuthnSchemes * sizeof(ULONG)
            );
        }

    if (SourceCredentials->ServerCertificateSubject)
        {
        NewCredentials->ServerCertificateSubject 
            = DuplicateString(SourceCredentials->ServerCertificateSubject);

        if (NewCredentials->ServerCertificateSubject == NULL)
            {
            FreeHttpTransportCredentials(NewCredentials);
            return NULL;
            }
        }

    if (SourceCredentials->TransportCredentials)
        {
        NewCredentials->TransportCredentials 
            = DuplicateAuthIdentity(SourceCredentials->TransportCredentials);
        if (NewCredentials->TransportCredentials == NULL)
            {
            FreeHttpTransportCredentials(NewCredentials);
            return NULL;
            }
        }

    return NewCredentials;
}

int CompareHttpTransportCredentials (
    const IN RPC_HTTP_TRANSPORT_CREDENTIALS_W *Credentials1,
    const IN RPC_HTTP_TRANSPORT_CREDENTIALS_W *Credentials2
    )
/*++

Routine Description:

    Compares Http transport credentials.

Arguments:

    Credentials1 - first set of credentials

    Credentials2 - second set of credentials

Return Value:

    0 if they are equal or non-zero if they are different

--*/
{
    ASSERT(_NOT_COVERED_);

    if (Credentials1->Flags != Credentials2->Flags)
        return 1;

    if (Credentials1->AuthenticationTarget != Credentials2->AuthenticationTarget)
        return 1;

    if (Credentials1->NumberOfAuthnSchemes != Credentials2->NumberOfAuthnSchemes)
        return 1;

    if (Credentials1->AuthnSchemes != NULL)
        {
        if (RpcpMemoryCompare(Credentials1->AuthnSchemes, 
            Credentials2->AuthnSchemes, 
            Credentials1->NumberOfAuthnSchemes) != 0)
            {
            return 1;
            }
        }
    else if (Credentials1->AuthnSchemes != NULL)
        return 1;

    if (Credentials1->ServerCertificateSubject != NULL)
        {
        if (RpcpStringCompare(Credentials1->ServerCertificateSubject, 
            Credentials2->ServerCertificateSubject) != 0)
            {
            return 1;
            }
        }
    else if (Credentials1->ServerCertificateSubject != NULL)
        return 1;

    return CompareAuthIdentity(Credentials1->TransportCredentials, Credentials2->TransportCredentials);
}

RPC_HTTP_TRANSPORT_CREDENTIALS_W *ConvertToUnicodeHttpTransportCredentials (
    const IN RPC_HTTP_TRANSPORT_CREDENTIALS_A *SourceCredentials
    )
/*++

Routine Description:

    Converts Http transport credentials from ANSI to Unicode.
    Conversion is done on a separate copy.

Arguments:

    SourceCredentials - the credentials to convert.

Return Value:

    Pointer to duplicated/converted credentials. If failure,
    NULL.

--*/
{
    RPC_HTTP_TRANSPORT_CREDENTIALS_W *NewCredentials;
    ULONG Length;

    NewCredentials = new RPC_HTTP_TRANSPORT_CREDENTIALS_W;
    if (NewCredentials == NULL)
        return NewCredentials;

    NewCredentials->Flags = SourceCredentials->Flags;
    NewCredentials->AuthenticationTarget = SourceCredentials->AuthenticationTarget;
    NewCredentials->NumberOfAuthnSchemes = SourceCredentials->NumberOfAuthnSchemes;
    NewCredentials->AuthnSchemes = NULL;
    NewCredentials->ServerCertificateSubject = NULL;
    NewCredentials->TransportCredentials = NULL;
    if (SourceCredentials->AuthnSchemes)
        {
        NewCredentials->AuthnSchemes = new ULONG [SourceCredentials->NumberOfAuthnSchemes];
        if (NewCredentials->AuthnSchemes == NULL)
            {
            FreeHttpTransportCredentials(NewCredentials);
            return NULL;
            }

        RpcpMemoryCopy(NewCredentials->AuthnSchemes, 
            SourceCredentials->AuthnSchemes,
            SourceCredentials->NumberOfAuthnSchemes * sizeof(ULONG)
            );
        }

    if (SourceCredentials->ServerCertificateSubject)
        {
        Length = RpcpStringLengthA((const char *)SourceCredentials->ServerCertificateSubject) + 1;
        NewCredentials->ServerCertificateSubject = new RPC_CHAR[Length];
        if (NewCredentials->ServerCertificateSubject == NULL)
            {
            FreeHttpTransportCredentials(NewCredentials);
            return NULL;
            }

        FullAnsiToUnicode((char *)SourceCredentials->ServerCertificateSubject,
            NewCredentials->ServerCertificateSubject);
        }

    if (SourceCredentials->TransportCredentials)
        {
        NewCredentials->TransportCredentials 
            = ConvertAuthIdentity(SourceCredentials->TransportCredentials);
        if (NewCredentials->TransportCredentials == NULL)
            {
            FreeHttpTransportCredentials(NewCredentials);
            return NULL;
            }
        }

    return NewCredentials;
}

RPC_HTTP_TRANSPORT_CREDENTIALS_W *
I_RpcTransGetHttpCredentials (
    const IN RPC_HTTP_TRANSPORT_CREDENTIALS_W *SourceCredentials
    )
/*++

Routine Description:

    Takes runtime encrypted credentials and returns a duplicate,
        decrypted credentials.

Arguments:

    SourceCredentials - the encrypted runtime credentials given to the
        transport during Open.

Return Value:

    Pointer to duplicated/converted credentials. If failure,
    NULL.

--*/
{
    RPC_HTTP_TRANSPORT_CREDENTIALS_W *NewCredentials;
    RPC_STATUS RpcStatus;

    NewCredentials = DuplicateHttpTransportCredentials(SourceCredentials);
    if (NewCredentials && NewCredentials->TransportCredentials)
        {
        RpcStatus = DecryptAuthIdentity(NewCredentials->TransportCredentials);
        if (RpcStatus != RPC_S_OK)
            {
            // if Decrypt fails, it will wipe out the auth identity
            FreeHttpTransportCredentials(NewCredentials);
            NewCredentials = NULL;
            }
        }

    return NewCredentials;
}

void I_RpcTransFreeHttpCredentials (
    IN RPC_HTTP_TRANSPORT_CREDENTIALS_W *SourceCredentials
    )
/*++

Routine Description:

    Frees credentials obtained by the transport through 
    I_RpcTransGetHttpCredentials.

Arguments:

    SourceCredentials - the credentials to free.

Return Value:

--*/
{
    ASSERT(SourceCredentials);

    WipeOutAuthIdentity(SourceCredentials->TransportCredentials);
    FreeHttpTransportCredentials(SourceCredentials);
}

/* ====================================================================

GENERIC_OBJECT

==================================================================== */

/* --------------------------------------------------------------------
This routine validates a handle.  The HandleType argument is a set of
flags specifying the valid handle types.  Note that the handle types
defined in handle.hxx are flags rather than being enumerated.
-------------------------------------------------------------------- */
unsigned int
GENERIC_OBJECT::InvalidHandle ( // Validate a handle.
    IN HANDLE_TYPE BaseType
    )
{

    // Checking for a 0 handle should work for all operating environments.  Where
    // we can (such as on NT), we should check for readable and writeable memory.

    if (this == 0)
        {
        return(1);
        }

    // Check the magic long.  This allows us to catch stale handles and handles
    // which are just passed in as arbitray pointers into memory.  It does not
    // handle the case of copying the contents of a handle.

    if (MagicLong != MAGICLONG)
        {
        return(1);
        }

    //
    // Finally, check that the type of handle is one of the allowed ones
    // specified by the HandleType argument.  Remember that the call to Type
    // is a virtual method which each type of handle will implement.
    //
    if (ObjectType & BaseType)
        {
        return 0;
        }

    return(1);
}

RPC_STATUS
MESSAGE_OBJECT::BindingCopy (
    OUT BINDING_HANDLE * PAPI * DestinationBinding,
    IN unsigned int MaintainContext
    )
{
    UNUSED(this);
    UNUSED(DestinationBinding);
    UNUSED(MaintainContext);

    ASSERT( 0 );
    return(RPC_S_INTERNAL_ERROR);
}


void
CLIENT_AUTH_INFO::ReferenceCredentials() const
{

  if (Credentials != 0)
      {
      Credentials->ReferenceCredentials();
      }
}


int
CLIENT_AUTH_INFO::CredentialsMatch(
     SECURITY_CREDENTIALS PAPI * SuppliedCredentials
     ) const
{
  return(Credentials->CompareCredentials(SuppliedCredentials) == 0);
}


CLIENT_AUTH_INFO::CLIENT_AUTH_INFO(
    const CLIENT_AUTH_INFO * myAuthInfo,
    RPC_STATUS __RPC_FAR * pStatus
    )
{
    if (myAuthInfo)
        {
        *this = *myAuthInfo;

        if (myAuthInfo->ServerPrincipalName)
            {
            RPC_CHAR * NewString;

            NewString = DuplicateString(myAuthInfo->ServerPrincipalName);
            ServerPrincipalName = NewString;
            if (0 == NewString)
                {
                *pStatus = RPC_S_OUT_OF_MEMORY;
                }
            }
        ASSERT((AdditionalTransportCredentialsType == RPC_C_AUTHN_INFO_TYPE_HTTP)
            || (AdditionalTransportCredentialsType == 0));

        if (myAuthInfo->AdditionalTransportCredentialsType == RPC_C_AUTHN_INFO_TYPE_HTTP)
            {
            ASSERT(myAuthInfo->AdditionalCredentials != NULL);
            AdditionalCredentials = DuplicateHttpTransportCredentials(
                (const RPC_HTTP_TRANSPORT_CREDENTIALS_W *)myAuthInfo->AdditionalCredentials);
            if (AdditionalCredentials == NULL)
                {
                *pStatus = RPC_S_OUT_OF_MEMORY;
                }
            }
        myAuthInfo->ReferenceCredentials();
        }
    else
        {
        AuthenticationLevel   = RPC_C_AUTHN_LEVEL_NONE;
        AuthenticationService = RPC_C_AUTHN_NONE;
        AuthorizationService  = RPC_C_AUTHZ_NONE;
        ServerPrincipalName   = 0;
        AuthIdentity          = 0;
        Credentials           = 0;
        ImpersonationType     = RPC_C_IMP_LEVEL_IMPERSONATE;
        IdentityTracking      = RPC_C_QOS_IDENTITY_STATIC;
        Capabilities          = RPC_C_QOS_CAPABILITIES_DEFAULT;
        DefaultLogonId        = 1;
        AdditionalTransportCredentialsType = 0;
        AdditionalCredentials = NULL;
        }
}


CLIENT_AUTH_INFO::~CLIENT_AUTH_INFO(
    )
{
    delete ServerPrincipalName;

    if (Credentials)
        {
        Credentials->DereferenceCredentials();
        }

    ASSERT((AdditionalTransportCredentialsType == RPC_C_AUTHN_INFO_TYPE_HTTP)
        || (AdditionalTransportCredentialsType == 0));

    if (AdditionalTransportCredentialsType == RPC_C_AUTHN_INFO_TYPE_HTTP)
        {
        ASSERT(AdditionalCredentials != NULL);
        FreeHttpTransportCredentials((RPC_HTTP_TRANSPORT_CREDENTIALS_W *)AdditionalCredentials);
        AdditionalCredentials = NULL;
        }
}

int
CLIENT_AUTH_INFO::IsSupportedAuthInfo (
    IN const CLIENT_AUTH_INFO * ClientAuthInfo,
    IN BOOL fNamedPipe
    ) const
/*++

Arguments:

    ClientAuthInfo - Supplies the authentication and authorization information
        required of this connection.  A value of zero (the pointer is
        zero) indicates that we want an unauthenticated connection.

Return Value:

    Non-zero indicates that the connection has the requested authentication
    and authorization information; otherwise, zero will be returned.

--*/
{
    if ( ClientAuthInfo == 0 )
        {
        return(AuthenticationLevel
                == RPC_C_AUTHN_LEVEL_NONE);
        }

    if ( ClientAuthInfo->AuthenticationService != AuthenticationService )
        {
        return(0);
        }

    if (ClientAuthInfo->AuthenticationService == RPC_C_AUTHN_NONE)
        {
        if (fNamedPipe)
            {
            if ((ClientAuthInfo->DefaultLogonId != DefaultLogonId)
                || ((ClientAuthInfo->DefaultLogonId == FALSE)
                    && (!FastCompareLUIDAligned(&ClientAuthInfo->ModifiedId, &ModifiedId))))
                {
                return 0;
                }
            }

        return 1;
        }

    if ( ClientAuthInfo->AuthenticationLevel
                != AuthenticationLevel )
        {
        return(0);
        }


    if ( ClientAuthInfo->AuthorizationService != AuthorizationService )
        {
        return(0);
        }

    if (CredentialsMatch(ClientAuthInfo->Credentials) == 0)
        {
        //Credentials Dont Match
        return(0);
        }

    if ( ClientAuthInfo->ImpersonationType != ImpersonationType )
        {
        return (0);
        }

    if ( (ClientAuthInfo->IdentityTracking == RPC_C_QOS_IDENTITY_DYNAMIC)
         && (IdentityTracking == RPC_C_QOS_IDENTITY_DYNAMIC)
         && (
             (ClientAuthInfo->DefaultLogonId != DefaultLogonId)
            || (
                (ClientAuthInfo->DefaultLogonId == FALSE)
              && (!FastCompareLUIDAligned(&ClientAuthInfo->ModifiedId, &ModifiedId))  
               )
            )
       || (ClientAuthInfo->IdentityTracking != IdentityTracking) )
        {
        return (0);
        }

    if ( (ClientAuthInfo->Capabilities != Capabilities)
       &&(ClientAuthInfo->Capabilities != RPC_C_QOS_CAPABILITIES_DEFAULT) )
        {
        return (0);
        }

    if (   ClientAuthInfo->ServerPrincipalName == 0
        || ServerPrincipalName == 0 )
        {
        return(ServerPrincipalName == ClientAuthInfo->ServerPrincipalName);
        }

    if ( RpcpStringCompare(ClientAuthInfo->ServerPrincipalName,
                           ServerPrincipalName) == 0 )
        {
        return(1);
        }

    ASSERT((AdditionalTransportCredentialsType == RPC_C_AUTHN_INFO_TYPE_HTTP)
        || (AdditionalTransportCredentialsType == 0));

    if (AdditionalTransportCredentialsType == RPC_C_AUTHN_INFO_TYPE_HTTP)
        {
        return CompareHttpTransportCredentials((RPC_HTTP_TRANSPORT_CREDENTIALS_W *)AdditionalCredentials,
            (RPC_HTTP_TRANSPORT_CREDENTIALS_W *)ClientAuthInfo->AdditionalCredentials);
        }

    return(0);
}



RPC_STATUS
CALL::Cancel(
    void * ThreadHandle
    )
{
    return RPC_S_OK;
}

unsigned
CALL::TestCancel(
    )
{
    return 0;
}


/* ====================================================================

CCALL

==================================================================== */

RPC_STATUS CCALL::SetDebugClientCallInformation(OUT DebugClientCallInfo **ppClientCallInfo,
                                                OUT CellTag *ClientCallInfoCellTag,
                                                OUT DebugCallTargetInfo **ppCallTargetInfo,
                                                OUT CellTag *CallTargetInfoCellTag,
                                                IN OUT PRPC_MESSAGE Message,
                                                IN DebugThreadInfo *ThreadDebugCell OPTIONAL,
                                                IN CellTag ThreadCellTag OPTIONAL)
{
    RPC_STATUS Status;
    DebugClientCallInfo *ClientCallInfo;
    DebugCallTargetInfo *CallTargetInfo;

    Status = InitializeServerSideCellHeapIfNecessary();

    if (Status != RPC_S_OK)
        return Status;

    ClientCallInfo = (DebugClientCallInfo *) AllocateCell(ClientCallInfoCellTag);
    if (ClientCallInfo == NULL)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    CallTargetInfo = (DebugCallTargetInfo *) AllocateCell(CallTargetInfoCellTag);
    if (CallTargetInfo == NULL)
        {
        FreeCell(ClientCallInfo, ClientCallInfoCellTag);
        return RPC_S_OUT_OF_MEMORY;
        }

    ClientCallInfo->TypeHeader = 0;
    ClientCallInfo->Type = dctClientCallInfo;
    ClientCallInfo->IfStart = *((DWORD *)Message->RpcInterfaceInformation + 1);
    ClientCallInfo->ProcNum = (unsigned short)Message->ProcNum;

    GetDebugCellIDFromDebugCell((DebugCellUnion *)CallTargetInfo,
        CallTargetInfoCellTag, &ClientCallInfo->CallTargetID);

    if (ThreadDebugCell)
        {
        GetDebugCellIDFromDebugCell((DebugCellUnion *)ThreadDebugCell,
            &ThreadCellTag, &ClientCallInfo->ServicingThread);
        }
    else
        {
        ClientCallInfo->ServicingThread.CellID = 0;
        ClientCallInfo->ServicingThread.SectionID = 0;
        }

    CallTargetInfo->TypeHeader = 0;
    CallTargetInfo->Type = dctCallTargetInfo;
    CallTargetInfo->LastUpdateTime = NtGetTickCount();

    *ppClientCallInfo = ClientCallInfo;
    *ppCallTargetInfo = CallTargetInfo;
    return RPC_S_OK;
}

/* ====================================================================

BINDING_HANDLE

==================================================================== */


BINDING_HANDLE::BINDING_HANDLE (
    IN OUT RPC_STATUS *pStatus
    ) : BindingMutex(pStatus)
/*++

Routine Description:

    In addition to initializing a binding handle instance in this
    constructor, we also need to put the binding handle into a global
    set of binding handle.  This is necessary only for windows.

--*/
{
    Timeout = RPC_C_BINDING_DEFAULT_TIMEOUT;
    NullObjectUuidFlag = 1;
    ObjectUuid.SetToNullUuid();
    EntryNameSyntax = 0;
    EntryName = 0;
    EpLookupHandle = 0;

    pvTransportOptions = NULL;
    OptionsVector = NULL;
}

BINDING_HANDLE::~BINDING_HANDLE (
    )
{
    if (EpLookupHandle != 0)
        {
        EpFreeLookupHandle(EpLookupHandle);
        }

    delete EntryName;

    if (pvTransportOptions)
        {
        I_RpcFree(pvTransportOptions);
        }

    if (OptionsVector)
        {
        I_RpcFree(OptionsVector);
        }
}

RPC_STATUS
BINDING_HANDLE::Clone (
                      BINDING_HANDLE * Handle
                      )
{
    RPC_STATUS Status = 0;

    Timeout            = Handle->Timeout;
    ObjectUuid         = Handle->ObjectUuid;
    NullObjectUuidFlag = Handle->NullObjectUuidFlag;

    /*
    All of these duplicate what is done in the constructor.

    EntryName          = 0;
    EntryNameSyntax    = 0;
    EpLookupHandle     = 0;
    pvTransportOptions = 0;
    OptionsVector      = 0;
    */

    if (Handle->OptionsVector)
        {
        OptionsVector = new ULONG_PTR[ RPC_C_OPT_MAX_OPTIONS ];
        if (OptionsVector == 0)
            {
            return RPC_S_OUT_OF_MEMORY;
            }

        RpcpMemoryCopy( OptionsVector, Handle->OptionsVector, RPC_C_OPT_MAX_OPTIONS * sizeof( ULONG_PTR) );
        }

    CLIENT_AUTH_INFO * AuthInfo;
    if ((AuthInfo = Handle->InquireAuthInformation()) != 0)
        {
        Status = SetAuthInformation(
                                AuthInfo->ServerPrincipalName,
                                AuthInfo->AuthenticationLevel,
                                AuthInfo->AuthenticationService,
                                AuthInfo->AuthIdentity,
                                AuthInfo->AuthorizationService,
                                AuthInfo->Credentials,
                                AuthInfo->ImpersonationType,
                                AuthInfo->IdentityTracking,
                                AuthInfo->Capabilities,
                                FALSE,      // bAcquireNewCredentials
                                AuthInfo->AdditionalTransportCredentialsType,
                                AuthInfo->AdditionalCredentials
                                );

        if (Status != RPC_S_OK)
            {
            ASSERT(Status == RPC_S_OUT_OF_MEMORY);
            //
            // Previous code maps all security errors to this.
            //
            return RPC_S_OUT_OF_MEMORY;
            }
        }

    return Status;
}

void
BINDING_HANDLE::InquireObjectUuid (
    OUT RPC_UUID PAPI * ObjectUuid
    )
/*++

Routine Description:

    This routine copies the object uuid from the binding handle into
    the supplied ObjectUuid argument.

Arguments:

    ObjectUuid - Returns a copy of the object uuid in the binding handle.

--*/
{
    ObjectUuid->CopyUuid(&(this->ObjectUuid));
}


void
BINDING_HANDLE::SetObjectUuid (
    IN RPC_UUID PAPI * ObjectUuid
    )
/*++

Routine Description:

    This routine copies the object uuid supplied in the ObjectUuid argument
    into the binding handle.

Arguments:

    ObjectUuid - Supplies the object uuid to copy into the binding handle.

--*/
{
    if (   ( ObjectUuid == 0 )
    || ( ObjectUuid->IsNullUuid() != 0 ) )
    {
    NullObjectUuidFlag = 1;
    this->ObjectUuid.SetToNullUuid();
    }
    else
    {
    this->ObjectUuid.CopyUuid(ObjectUuid);
    NullObjectUuidFlag = 0;
    }
}


RPC_STATUS
BINDING_HANDLE::SetComTimeout (
    IN unsigned int Timeout
    )
/*++

Routine Description:

    This routine sets the communications timeout value in this binding
    handle.  The specified timeout is range checked.

Arguments:

    Timeout - Supplies the new communications timeout value for this
    binding handle.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_INVALID_TIMEOUT - The specified timeout value is not in the
    correct range.

--*/
{
    // We just need to check to see if the timeout value is too large,
    // since the timeout is unsigned and the lowest value is zero.

    if (Timeout > RPC_C_BINDING_INFINITE_TIMEOUT)
    return(RPC_S_INVALID_TIMEOUT);

    this->Timeout = Timeout;
    return(RPC_S_OK);
}

RPC_CHAR *pNS_DLL_NAME = RPC_STRING_LITERAL("RPCNS4");
const char *pNS_ENTRYPOINT_NAME = "I_GetDefaultEntrySyntax";


typedef unsigned long (RPC_ENTRY * GET_DEFAULT_ENTRY_FN)();




RPC_STATUS
BINDING_HANDLE::InquireEntryName (
    IN unsigned long EntryNameSyntax,
    OUT RPC_CHAR PAPI * PAPI * EntryName
    )
/*++

Routine Description:

    This method is used to obtain the entry name for the binding handle,
    if it has one.  The entry name is the name of the name service object
    from which a binding handle is imported or looked up.  If the binding
    handle was not imported or looked up, then it has no entry name.

Arguments:

    EntryNameSyntax - Supplies the entry name syntax which the caller
    wants the entry name to be returned in.  This may require that
    we convert the entry name in the binding handle into a different
    syntax.

    EntryName - Returns the entry name of the binding handle in the
    requested entry name syntax.

Return Value:

    RPC_S_OK - This binding handle has an entry name, and we were able
    to convert the entry name in the binding handle into the requested
    entry name syntax.

    RPC_S_NO_ENTRY_NAME - The binding handle does not have an entry
    name.  If this value is returned, the entry name return value
    will be set to point to a newly allocated empty string.

    RPC_S_INVALID_NAME_SYNTAX - The entry name in the binding handle
    can not be converted to the entry name syntax requested.

    RPC_S_UNSUPPORTED_NAME_SYNTAX - The entry name syntax requested
    is not supported by the current configuration.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete
    the operation.

--*/
{

    if ( this->EntryName == 0 )
        {
        *EntryName = AllocateEmptyStringPAPI();
        if (*EntryName == 0)
            return(RPC_S_OUT_OF_MEMORY);
        return(RPC_S_NO_ENTRY_NAME);
        }

    //
    // If he chose the default syntax and the binding has an entry,
    // ask the name service for the default entry syntax.
    // The NS dll should already be loaded because otherwise we'd not have an
    // associated entry.
    //
    if (EntryNameSyntax == RPC_C_NS_SYNTAX_DEFAULT)
        {
        HINSTANCE NsDll = GetModuleHandle((const RPC_SCHAR *)pNS_DLL_NAME);
        if (NsDll)
            {
            GET_DEFAULT_ENTRY_FN GetDefaultEntry =
                       (GET_DEFAULT_ENTRY_FN)
                       GetProcAddress(NsDll,
                              pNS_ENTRYPOINT_NAME
                              );

            if (GetDefaultEntry)
                {
                EntryNameSyntax = (*GetDefaultEntry)();
                }
            else
                {
                //
                // leave EntryNameSyntax zero; the fn will fail
                // with invalid_name_syntax
                //
                }
            }
        else
            {
            //
            // leave EntryNameSyntax zero; the fn will fail
            // with invalid_name_syntax
            //
            }
        }

    if (EntryNameSyntax == this->EntryNameSyntax)
        {
        *EntryName = DuplicateStringPAPI(this->EntryName);
        if (*EntryName == 0)
            return(RPC_S_OUT_OF_MEMORY);
        return(RPC_S_OK);
        }

    return(RPC_S_INVALID_NAME_SYNTAX);
}


RPC_STATUS
BINDING_HANDLE::SetEntryName (
    IN unsigned long EntryNameSyntax,
    IN RPC_CHAR PAPI * EntryName
    )
/*++

Routine Description:

    This method is used to set the entry name and entry name syntax
    for a binding handle.

Arguments:

    EntryNameSyntax - Supplies the syntax of the entry name argument.

    EntryName - Supplies the entry name for this binding handle.

Return Value:

    RPC_S_OK - We successfully set the entry name (and entry name syntax)
    for this binding handle.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to set the
    entry name.

--*/
{
    RPC_CHAR * NewEntryName;

    NewEntryName = DuplicateString(EntryName);
    if (NewEntryName == 0)
        return(RPC_S_OUT_OF_MEMORY);

    this->EntryNameSyntax = EntryNameSyntax;
    if (this->EntryName != 0)
        delete this->EntryName;
    this->EntryName = NewEntryName;
    return(RPC_S_OK);
}


RPC_STATUS
BINDING_HANDLE::InquireDynamicEndpoint (
    OUT RPC_CHAR PAPI * PAPI * DynamicEndpoint
    )
/*++

Routine Description:

    This routine is used to obtain the dynamic endpoint from a binding
    handle which was created from an rpc address.  For all other binding
    handles, we just return the fact that there is no dynamic endpoint.

Arguments:

    DynamicEndpoint - Returns a pointer to the dynamic endpoint, if there
    is one, or zero.

Return Value:

    RPC_S_OK - This value will always be returned.

--*/
{
    *DynamicEndpoint = 0;
    return(RPC_S_OK);
}


int
BINDING_HANDLE::SetServerPrincipalName (
    IN RPC_CHAR PAPI * ServerPrincipalName
    )
/*++

Routine Description:

    A protocol module will use this routine to set the principal name of
    a server if it is not yet known.

Arguments;

    ServerPrincipalName - Supplies the new principal name of the server.

Return Value:

    Zero will be returned if this operation completes successfully; otherwise,
    non-zero will be returned indicating that insufficient memory is available
    to make a copy of the server principal name.

--*/
{
    RequestGlobalMutex();

    if ( ClientAuthInfo.ServerPrincipalName == 0 )
        {
        ClientAuthInfo.ServerPrincipalName = DuplicateString(ServerPrincipalName);
        if ( ClientAuthInfo.ServerPrincipalName == 0 )
            {
            ClearGlobalMutex();
            return(1);
            }
        }

    ClearGlobalMutex();
    return(0);
}


unsigned long
BINDING_HANDLE::MapAuthenticationLevel (
    IN unsigned long AuthenticationLevel
    )
/*++

Routine Description:

    This method is to provide a way for a protocol module to map a requested
    authentication level into one supported by that protocol module.

Arguments:

    AuthenticationLevel - Supplies the proposed authentication level; this
    value has already been validated.

Return Value:

    The authentication level to be used is returned.

--*/
{

    return(AuthenticationLevel);
}

BOOL
BINDING_HANDLE::SetTransportAuthentication(
    IN  unsigned long  ulAuthenticationLevel,
    IN  unsigned long  ulAuthenticationService,
    OUT RPC_STATUS    *pStatus )
/*
 Routine Descritpion:

    Called inside of SetAuthInformation(), this function allows for
    transport level authentication to be set. If this function is not
    overridden then it returns RPC_S_NOT_SUPPORTED and the normal RPC
    level authentication is used.
*/
{
   *pStatus = RPC_S_CANNOT_SUPPORT;

   return TRUE;
}

RPC_STATUS
BINDING_HANDLE::SendReceive (
    IN OUT PRPC_MESSAGE Message
    )
{
    UNUSED(Message);

    ASSERT( 0 );
    return(RPC_S_INTERNAL_ERROR);
}




RPC_STATUS
BINDING_HANDLE::Send (
    IN OUT PRPC_MESSAGE Message
    )
{
    UNUSED(Message);

    ASSERT( 0 );
    return(RPC_S_INTERNAL_ERROR);
}



RPC_STATUS
BINDING_HANDLE::Receive (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned int Size
    )
{
    UNUSED(Message);

    ASSERT( 0 );
    return(RPC_S_INTERNAL_ERROR);
}

void
BINDING_HANDLE::FreeBuffer (
    IN PRPC_MESSAGE Message
    )
{
    UNUSED(Message);

    ASSERT( 0 );
}

RPC_STATUS
BINDING_HANDLE::ReAcquireCredentialsIfNecessary(
         )
{
    LUID CurrentModifiedId;
    RPC_STATUS Status = CaptureModifiedId(&CurrentModifiedId);
    SECURITY_CREDENTIALS * SecurityCredentials;
    BOOL MyDefaultLogonId;

    if (Status == RPC_S_OK)
        {
        MyDefaultLogonId = FALSE;
        }
    else
        {
        MyDefaultLogonId = TRUE;
        }

    if (MyDefaultLogonId != ClientAuthInfo.DefaultLogonId
        || (MyDefaultLogonId == FALSE
         && (FastCompareLUIDAligned(&CurrentModifiedId,
                              &ClientAuthInfo.ModifiedId) == FALSE)))
       {
        ClientAuthInfo.DefaultLogonId = MyDefaultLogonId;
        Status = RPC_S_OK;

        SecurityCredentials = new SECURITY_CREDENTIALS(&Status);
        if ((SecurityCredentials == 0) || (Status != RPC_S_OK))
            {
            if (SecurityCredentials == 0)
                {
                Status = RPC_S_OUT_OF_MEMORY;
                }
            delete SecurityCredentials;
            return (Status);
            }

        // Dynamic identity tracking - need to get the current credentials.
        Status = SecurityCredentials->AcquireCredentialsForClient(
                                        ClientAuthInfo.AuthIdentity,
                                        ClientAuthInfo.AuthenticationService,
                                        ClientAuthInfo.AuthenticationLevel
                                        );
        if ( Status != RPC_S_OK )
            {
            VALIDATE(Status)
                {
                RPC_S_OUT_OF_MEMORY,
                RPC_S_UNKNOWN_AUTHN_SERVICE,
                RPC_S_UNKNOWN_AUTHN_LEVEL,
                RPC_S_SEC_PKG_ERROR,
                ERROR_SHUTDOWN_IN_PROGRESS,
                RPC_S_INVALID_AUTH_IDENTITY
                } END_VALIDATE;

            delete SecurityCredentials;
            return(Status);
            }

        if (ClientAuthInfo.CredentialsMatch(SecurityCredentials) != 0)
            {
            SecurityCredentials->DereferenceCredentials();
            }
        else
            {
            BindingMutex.Request();

            if (ClientAuthInfo.Credentials != 0)
                {
                ClientAuthInfo.Credentials->DereferenceCredentials();
                }

            ClientAuthInfo.Credentials = SecurityCredentials;
            BindingMutex.Clear();
            }

        FastCopyLUIDAligned(&ClientAuthInfo.ModifiedId, &CurrentModifiedId);
        }

      return (RPC_S_OK);

}

RPC_STATUS
BINDING_HANDLE::SetTransportOption( IN unsigned long option,
                                    IN ULONG_PTR     optionValue )
{
    if (option > RPC_C_OPT_MAX_OPTIONS)
        {
        return RPC_S_INVALID_ARG;
        }

    if (OptionsVector == NULL)
        {
        BindingMutex.Request();
        if (OptionsVector == NULL)
            {
            OptionsVector = new ULONG_PTR[ RPC_C_OPT_MAX_OPTIONS ];
            if (OptionsVector == 0)
                {
                BindingMutex.Clear();

                return RPC_S_OUT_OF_MEMORY;
                }

            RpcpMemorySet(OptionsVector, 0, RPC_C_OPT_MAX_OPTIONS * sizeof(OptionsVector[0]) );
            }
        BindingMutex.Clear();
        }

    OptionsVector[option] = optionValue;

    return RPC_S_OK;
}


RPC_STATUS
BINDING_HANDLE::InqTransportOption( IN  unsigned long option,
                                    OUT ULONG_PTR   * pOptionValue )
{
    if (OptionsVector == NULL)
        {
        *pOptionValue = 0;
        }
    else
        {
        *pOptionValue = OptionsVector[option];
        }

    return RPC_S_OK;
}



RPC_STATUS
CALL::Send (
    IN OUT PRPC_MESSAGE Message
    )
/*++
Function Name:Send

Parameters:

Description:

Returns:

--*/
{
    ASSERT(!"improper CCALL member called\n");
    return (RPC_S_CANNOT_SUPPORT) ;
}



RPC_STATUS
CALL::Receive (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned int Size
    )
/*++
Function Name:Receive

Parameters:

Description:

Returns:

--*/
{
    ASSERT(!"improper CCALL member called\n");
    return (RPC_S_CANNOT_SUPPORT) ;
}


RPC_STATUS
CALL::AsyncSend (
    IN OUT PRPC_MESSAGE Message
    )
/*++
Function Name:AsyncSend

Parameters:

Description:

Returns:

--*/
{
    ASSERT(!"improper CCALL member called\n");
    return (RPC_S_CANNOT_SUPPORT) ;
}

RPC_STATUS
CALL::AsyncReceive (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned int Size
    )
/*++
Function Name:AsyncReceive

Parameters:

Description:

Returns:

--*/
{
    ASSERT(!"improper CCALL member called\n");
    return (RPC_S_CANNOT_SUPPORT) ;
}

RPC_STATUS
CALL::AbortAsyncCall (
    IN PRPC_ASYNC_STATE pAsync,
    IN unsigned long ExceptionCode
    )
/*++
Function Name:AbortAsyncCall

Parameters:

Description:

Returns:

--*/
{
    ASSERT(!"improper CCALL member called\n");
    return (RPC_S_CANNOT_SUPPORT) ;
}

void
CALL::ProcessResponse (
    IN BOOL fDirectCall
    )
/*++
Function Name:ProcessResponse

Parameters:

Description:

Returns:

--*/
{
}

void
CALL::FreeAPCInfo (
    IN RPC_APC_INFO *pAPCInfo
    )
/*++
Function Name:FreeAPCInfo

Parameters:

Description:

Returns:

--*/
{
    if (pAPCInfo == &CachedAPCInfo)
        {
        CachedAPCInfoAvailable = 1;
        }
    else
        {
        delete pAPCInfo ;
        }
}


BOOL
CALL::QueueAPC (
    IN RPC_ASYNC_EVENT Event,
    IN void *Context
    )
/*++
Function Name:QueueAPC

Parameters:

Description:

Returns:

--*/
{
    RPC_APC_INFO *pAPCInfo ;
    HANDLE hThread ;

    if (CachedAPCInfoAvailable)
        {
        pAPCInfo = &CachedAPCInfo ;
        CachedAPCInfoAvailable = 0;
        }
    else
        {
        pAPCInfo = new RPC_APC_INFO ;
        }

    if (pAPCInfo == 0)
        {
        return 0 ;
        }

    pAPCInfo->Context = Context;
    pAPCInfo->Event = Event ;
    pAPCInfo->pAsync = pAsync ;
    pAPCInfo->hCall = this ;

    if (pAsync->u.APC.hThread)
        {
        hThread = pAsync->u.APC.hThread ;
        }
    else
        {
        hThread = CallingThread->ThreadHandle() ;
        }

    if (!QueueUserAPC(
            (PAPCFUNC) I_RpcAPCRoutine,
            hThread,
            (ULONG_PTR) pAPCInfo))
        {
#if DBG
        PrintToDebugger("RPC: QueueUserAPC failed: %d\n", GetLastError());
#endif
        return 0 ;
        }

    return 1;
}


BOOL
RpcPostMessageWrapper (
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);

typedef BOOL (*RPCPOSTMESSAGE) (
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
RPCPOSTMESSAGE RpcPostMessage = RpcPostMessageWrapper;

BOOL
RpcPostMessageWrapper (
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam)
/*++
Function Name:RpcPostMessageWrapper

Parameters:

Description:

Returns:

--*/
{
    HMODULE hLibrary;

    if (RpcPostMessage == RpcPostMessageWrapper)
        {
        GlobalMutexRequest();
        if (RpcPostMessage == RpcPostMessageWrapper)
            {
            hLibrary = LoadLibrary(RPC_CONST_SSTRING("user32.dll"));
            if (hLibrary == 0)
                {
                GlobalMutexClear();

                return FALSE;
                }

            RpcPostMessage =
                (RPCPOSTMESSAGE) GetProcAddress(hLibrary, "PostMessageW");

            if (RpcPostMessage == 0)
                {
                RpcPostMessage = RpcPostMessageWrapper;
                FreeLibrary(hLibrary);

                GlobalMutexClear();
                return FALSE;
                }
            }
        GlobalMutexClear();
        }

    return RpcPostMessage(hWnd, Msg, wParam, lParam);
}

BOOL
CALL::IssueNotificationEntry (
    IN RPC_ASYNC_EVENT Event
    )
{
    int Retries = 0;

    if (pAsync == 0
        || (Event == RpcCallComplete
            && InterlockedIncrement(&NotificationIssued) > 0))
        {
#if DBG
        PrintToDebugger("RPC: IssueCallCompleteNotification was a no-op\n") ;
#endif
        return 0;
        }

    // an unlikely, but possible race condition - the send thread hasn't
    // reached back the NDR code, which means the NdrLock is still held -
    // we cannot issue a notification until this is released, or the
    // client thread cannot complete the call
    while (TRUE)
        {
        if (pAsync->Lock > 0)
            {
            PauseExecution(200);
            // yes, we don't break if the Retries go through the roof -
            // this is just to figure out how many times we have looped
            // on a checked build
            Retries ++;
            }
        else
            break;
        }

    ASSERT(pAsync->Size == RPC_ASYNC_VERSION_1_0);
    LogEvent(SU_SCALL, EV_NOTIFY, CallingThread, this, (ULONG_PTR) pAsync, 1);

    pAsync->Event = Event;

    return 1;
}

BOOL
CALL::IssueNotificationMain (
    IN RPC_ASYNC_EVENT Event
    )
{
    switch (pAsync->NotificationType)
        {
        case RpcNotificationTypeNone:
            break;

        case RpcNotificationTypeHwnd:
            RpcPostMessage(
                           pAsync->u.HWND.hWnd,
                           pAsync->u.HWND.Msg,
                           0,
                           (LPARAM) pAsync) ;
            break;

        case RpcNotificationTypeCallback:
            pAsync->u.NotificationRoutine(pAsync, 0, Event);
            break;

        case RpcNotificationTypeEvent:
            if (!SetEvent(pAsync->u.hEvent))
                {
#if DBG
                PrintToDebugger("RPC: SetEvent failed: %d\n", GetLastError());
#endif
                return 0;
                }
            break;

        case RpcNotificationTypeApc:
            if (!QueueAPC(Event))
                {
#if DBG
                PrintToDebugger("RPC: QueueAPC failed\n");
#endif
                return 0;
                }
            break;

        case RpcNotificationTypeIoc:
            if (!PostQueuedCompletionStatus(
                    pAsync->u.IOC.hIOPort,
                    pAsync->u.IOC.dwNumberOfBytesTransferred,
                    pAsync->u.IOC.dwCompletionKey,
                    pAsync->u.IOC.lpOverlapped))
                {
#if DBG
                PrintToDebugger("RPC: PostQueuedCompletionStatus failed %d\n",
                                GetLastError());
#endif
                return 0;
                }
            break;

        default:
            ASSERT(!"Invalid notification type") ;
            return 0;
        }

    return 1;
}


BOOL
CALL::IssueNotification (
    IN RPC_ASYNC_EVENT Event
    )
/*++
Function Name:IssueNotification

Parameters:

Description:

Returns:

--*/
{
    if (IssueNotificationEntry(Event))
        return IssueNotificationMain(Event);
    else
        return 0;
}


void
CALL::ProcessEvent (
    )
/*++
Function Name:ProcessEvent

Parameters:

Description:

Returns:

--*/
{
    ASSERT(0) ;
}

RPC_STATUS
DispatchCallback(
    IN PRPC_DISPATCH_TABLE DispatchTableCallback,
    IN OUT PRPC_MESSAGE Message,
    OUT RPC_STATUS PAPI * ExceptionCode
    )
/*++

Routine Description:

    This method is used to dispatch remote procedure calls to the
    appropriate stub and hence to the appropriate manager entry point.
    This routine is used for calls having a null UUID (implicit or
    explicit).

Arguments:

    DispatchTableCallback - Callback table.

    Message - Supplies the response message and returns the reply
    message.

    ExceptionCode - Returns the remote exception code if
    RPC_P_EXCEPTION_OCCURED is returned.

Return Value:

    RPC_S_OK - Everything worked just fine.

    RPC_P_EXCEPTION_OCCURED - An exception of some sort occured.  The
    exact exception code will be returned in the ExceptionCode
    argument.

    RPC_S_PROCNUM_OUT_OF_RANGE - The supplied operation number in the
    message is too large.

--*/
{
    RPC_STATUS RpcStatus = RPC_S_OK;
    void PAPI *OriginalBuffer = Message->Buffer;

    // N.B. We could reset the flag after sendreceive is completed for
    // each protocol engine
    Message->RpcFlags |= RPC_BUFFER_COMPLETE ;

    if ( Message->ProcNum >= DispatchTableCallback->DispatchTableCount )
        {
        return(RPC_S_PROCNUM_OUT_OF_RANGE);
        }

    Message->ManagerEpv = 0;

    RpcpPurgeEEInfo();

    if ( DispatchToStubInC(DispatchTableCallback->DispatchTable[
        Message->ProcNum], Message, ExceptionCode) != 0 )
        {
        RpcStatus = RPC_P_EXCEPTION_OCCURED;
        }

    if (((MESSAGE_OBJECT *) Message->Handle)->IsSyncCall())
        {
        if (OriginalBuffer == Message->Buffer && RpcStatus == RPC_S_OK)
            {
            //
            // If the stub has NO out data, it may skip the call to
            // I_RpcGetBuffer().  If it called I_RpcGetBuffer and
            // still has the same Buffer, we have a bug!
            //

            Message->BufferLength = 0;
            ((MESSAGE_OBJECT *) Message->Handle)->GetBuffer(Message, 0);
            }
        }

    return(RpcStatus);
}


/* ====================================================================

Client DLL initialization routine.

==================================================================== */

int
InitializeClientDLL (void
    )
{
    // We don't want to do this under DOS. The first time
    // LoadableTransportClientInfo (in tranclnt.cxx) is called, it will
    // perform the appropriate initialization. See the first few lines
    // of that routine for more description.

    if (InitializeLoadableTransportClient() != 0)
        return(1);

    if (InitializeRpcProtocolOfsClient() != 0)
        return(1);

    if (InitializeRpcProtocolDgClient() != 0)
        return(1);

    return(0);
}



RPC_STATUS
BINDING_HANDLE::SetAuthInformation (
    IN RPC_CHAR PAPI * ServerPrincipalName, OPTIONAL
    IN unsigned long AuthenticationLevel,
    IN unsigned long AuthenticationService,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthorizationService,
    IN SECURITY_CREDENTIALS * Credentials,
    IN unsigned long ImpersonationType,
    IN unsigned long IdentityTracking,
    IN unsigned long Capabilities,
    IN BOOL bAcquireNewCredentials, OPTIONAL
    IN ULONG AdditionalTransportCredentialsType, OPTIONAL
    IN void *AdditionalCredentials OPTIONAL
    )
/*++

Routine Description:

    We set the authentication and authorization information in this binding
    handle.

Arguments:

    ServerPrincipalName - Optionally supplies the server principal name.

    AuthenticationLevel - Supplies the authentication level to use.

    AuthenticationService - Supplies the authentication service to use.

    AuthIdentity - Optionally supplies the security context to use.

    AuthorizationService - Supplies the authorization service to use.

    AdditionalTransportCredentialsType  - the type of additional credentials
        supplied in AdditionalCredentials

    AdditionalCredentials - pointer to additional credentials if any

Return Value:

    RPC_S_OK - The supplied authentication and authorization information has
    been set in the binding handle.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete the
    operation.

    RPC_S_UNKNOWN_AUTHN_SERVICE - The specified authentication service is
    not supported.

    RPC_S_UNKNOWN_AUTHN_LEVEL - The specified authentication level is
    not supported.

    RPC_S_INVALID_AUTH_IDENTITY - The specified security context (supplied
    by the auth identity argument) is invalid.

    RPC_S_UNKNOWN_AUTHZ_SERVICE - The specified authorization service is
    not supported.

--*/
{
    RPC_CHAR * NewString;
    RPC_STATUS RpcStatus = RPC_S_OK;
    SECURITY_CREDENTIALS * SecurityCredentials = NULL;
    unsigned long MappedAuthenticationLevel;

    if ( AuthenticationLevel == RPC_C_AUTHN_LEVEL_DEFAULT )
        {
        RpcpGetDefaultSecurityProviderInfo();
        AuthenticationLevel = DefaultAuthLevel;
        }

    if ( AuthenticationLevel > RPC_C_AUTHN_LEVEL_PKT_PRIVACY )
        {
        return(RPC_S_UNKNOWN_AUTHN_LEVEL);
        }

    MappedAuthenticationLevel = MapAuthenticationLevel(AuthenticationLevel);

    ASSERT( MappedAuthenticationLevel != RPC_C_AUTHN_LEVEL_DEFAULT &&
            MappedAuthenticationLevel <= RPC_C_AUTHN_LEVEL_PKT_PRIVACY );

    //
    // See if this is transport level authentication:
    //

    if (!SetTransportAuthentication( MappedAuthenticationLevel,
                                     AuthenticationService,
                                     &RpcStatus ))
       {
       return RpcStatus;
       }

    RpcStatus = RPC_S_OK;

    ASSERT((AdditionalTransportCredentialsType == RPC_C_AUTHN_INFO_TYPE_HTTP)
        || (AdditionalTransportCredentialsType == 0));

    if (AdditionalTransportCredentialsType == RPC_C_AUTHN_INFO_TYPE_HTTP)
        {
        ClientAuthInfo.AdditionalCredentials 
            = DuplicateHttpTransportCredentials (
                (const RPC_HTTP_TRANSPORT_CREDENTIALS_W *) AdditionalCredentials);

        if (ClientAuthInfo.AdditionalCredentials == NULL)
            return RPC_S_OUT_OF_MEMORY;

        if (((RPC_HTTP_TRANSPORT_CREDENTIALS_W *)(ClientAuthInfo.AdditionalCredentials))->TransportCredentials)
            {
            RpcStatus = EncryptAuthIdentity(((RPC_HTTP_TRANSPORT_CREDENTIALS_W *)(ClientAuthInfo.AdditionalCredentials))->TransportCredentials);
            if (RpcStatus != RPC_S_OK)
                {
                FreeAuthIdentity(((RPC_HTTP_TRANSPORT_CREDENTIALS_W *)ClientAuthInfo.AdditionalCredentials)->TransportCredentials);
                return RpcStatus;
                }
            }
        }
    else
        {
        ASSERT(AdditionalCredentials == NULL);
        }

    //
    // Clear out stuff for NULL AUTHN_SVC
    //

    if (AuthenticationService == RPC_C_AUTHN_NONE)
        {
        //
        // Dereference Credentials.. ServerPrincipal Name is
        // handled by deleting CLIENT_AUTH_INFO .. Each AUTH_INFO explicitly
        // copy the credentials around...
        //
        if (ClientAuthInfo.Credentials != 0)
            {
            ClientAuthInfo.Credentials->DereferenceCredentials();
            ClientAuthInfo.Credentials = 0;
            }
        }
    else
        {

        if (bAcquireNewCredentials == FALSE)
            {
            ASSERT(Credentials);
            Credentials->ReferenceCredentials();
            SecurityCredentials = Credentials;
            }
         else
            {
            SecurityCredentials = new SECURITY_CREDENTIALS(&RpcStatus);
            if ((SecurityCredentials == 0) || (RpcStatus != RPC_S_OK))
                {
                if (SecurityCredentials == 0)
                    {
                    RpcStatus = RPC_S_OUT_OF_MEMORY;
                    }
                delete SecurityCredentials;
                return (RpcStatus);
                }

            RpcStatus = SecurityCredentials->AcquireCredentialsForClient(
                                        AuthIdentity,
                                        AuthenticationService,
                                        MappedAuthenticationLevel
                                        );
            if ( RpcStatus != RPC_S_OK )
                {
                VALIDATE(RpcStatus)
                    {
                    RPC_S_OUT_OF_MEMORY,
                    RPC_S_UNKNOWN_AUTHN_SERVICE,
                    RPC_S_UNKNOWN_AUTHN_LEVEL,
                    RPC_S_SEC_PKG_ERROR,
                    ERROR_SHUTDOWN_IN_PROGRESS,
                    RPC_S_INVALID_AUTH_IDENTITY
                    } END_VALIDATE;

                delete SecurityCredentials;
                return(RpcStatus);
                }
            }


        if (ARGUMENT_PRESENT(ServerPrincipalName))
            {
            //
            // SSL has unique SPN requirements.
            //
            if (AuthenticationService == RPC_C_AUTHN_GSS_SCHANNEL)
                {
                RpcStatus = ValidateSchannelPrincipalName(ServerPrincipalName);
                if (RpcStatus != RPC_S_OK)
                    {
                    VALIDATE(RpcStatus)
                        {
                        ERROR_INVALID_PARAMETER
                        }
                    END_VALIDATE;

                    if (SecurityCredentials)
                        SecurityCredentials->DereferenceCredentials();

                    return RpcStatus;
                    }
                }

            NewString = DuplicateString(ServerPrincipalName);
            if ( NewString == 0 )
                {
                if (SecurityCredentials)
                    SecurityCredentials->DereferenceCredentials();
                return(RPC_S_OUT_OF_MEMORY);
                }

            RequestGlobalMutex();
            if ( ClientAuthInfo.ServerPrincipalName != 0 )
                {
                delete ClientAuthInfo.ServerPrincipalName;
                }
            ClientAuthInfo.ServerPrincipalName = NewString;
            ClearGlobalMutex();
            }

        if ( (ClientAuthInfo.Credentials != 0 ) &&
             (ClientAuthInfo.CredentialsMatch(SecurityCredentials) != 0) )
            {
            SecurityCredentials->DereferenceCredentials();
            }
        else
            {
            if (ClientAuthInfo.Credentials != 0)
                {
                ClientAuthInfo.Credentials->DereferenceCredentials();
                }
            ClientAuthInfo.Credentials = SecurityCredentials;
            }


        if (IdentityTracking == RPC_C_QOS_IDENTITY_DYNAMIC)
            {

            RpcStatus = CaptureModifiedId(&ClientAuthInfo.ModifiedId);

            //
            // If The Thread is not impersonating CaptureLogonId fails
            // All failures get treated as if this process is using *default*
            // identity. Mark the AuthId as such and proceed
            //

            if (RpcStatus != RPC_S_OK)
                {
                ClientAuthInfo.DefaultLogonId = TRUE;
                }
            else
                {
                ClientAuthInfo.DefaultLogonId = FALSE;
                }
            }

         }

    ClientAuthInfo.AuthenticationService = AuthenticationService;
    ClientAuthInfo.AuthorizationService = AuthorizationService;
    ClientAuthInfo.AuthIdentity = AuthIdentity;
    ClientAuthInfo.AdditionalTransportCredentialsType 
        = AdditionalTransportCredentialsType;

    if (AuthenticationService == RPC_C_AUTHN_NONE)
        {
        ClientAuthInfo.IdentityTracking  =  RPC_C_QOS_IDENTITY_STATIC;
        ClientAuthInfo.AuthenticationLevel = RPC_C_AUTHN_LEVEL_NONE;
        }
    else
        {
        ClientAuthInfo.AuthenticationLevel = MappedAuthenticationLevel;
        ClientAuthInfo.IdentityTracking  =  IdentityTracking;
        }

    ClientAuthInfo.ImpersonationType =  ImpersonationType;
    ClientAuthInfo.Capabilities      = Capabilities;

    return(RPC_S_OK);
}

const RPC_SYNTAX_IDENTIFIER NDR20TransferSyntaxValue
    = {{0x8A885D04, 0x1CEB, 0x11C9, {0x9F, 0xE8, 0x08, 0x00, 0x2B, 0x10, 0x48, 0x60}}, {2, 0}};
const RPC_SYNTAX_IDENTIFIER *NDR20TransferSyntax = &NDR20TransferSyntaxValue;

const RPC_SYNTAX_IDENTIFIER NDR64TransferSyntaxValue
    = {{0x71710533, 0xBEBA, 0x4937, {0x83, 0x19, 0xB5, 0xDB, 0xEF, 0x9C, 0xCC, 0x36}}, {1, 0}};
const RPC_SYNTAX_IDENTIFIER *NDR64TransferSyntax = &NDR64TransferSyntaxValue;

const RPC_SYNTAX_IDENTIFIER NDRTestTransferSyntaxValue
    = {{0xb4537da9, 0x3d03, 0x4f6b, {0xb5, 0x94, 0x52, 0xb2, 0x87, 0x4e, 0xe9, 0xd0}}, {1, 0}};
const RPC_SYNTAX_IDENTIFIER *NDRTestTransferSyntax = &NDRTestTransferSyntaxValue;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\hndlsvr.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1990 - 1999
//
//  File:       hndlsvr.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

                      Microsoft OS/2 LAN Manager
                   Copyright(c) Microsoft Corp., 1990

-------------------------------------------------------------------- */
/* --------------------------------------------------------------------

File : hndlsvr.cxx

Description :

This file contains the implementations of the classes defined in hndlsvr.hxx.
These routines are independent of the actual RPC protocol / transport layer.
In addition, these routines are also independent of the specific operating
system in use.

History :

mikemon    ??-??-??    Beginning of recorded history.
mikemon    10-15-90    Changed the shutdown functionality to PauseExecution
                       rather than suspending and resuming a thread.
mikemon    12-28-90    Updated the comments to match reality.
connieh    17-Feb-94   Created RPC_SERVER::RegisterRpcForwardFunction
Kamen Moutafov (KamenM) Dec 99 - Feb 2000 - Support for cell debugging stuff

-------------------------------------------------------------------- */

#include <precomp.hxx>
#include <queue.hxx>
#include <hndlsvr.hxx>
#include <svrbind.hxx>
#include <thrdctx.hxx>
#include <rpcobj.hxx>
#include <rpccfg.h>
#include <sdict2.hxx>
#include <dispatch.h>

#include <queue.hxx>
#include <lpcpack.hxx>
#include <lpcsvr.hxx>
extern LRPC_SERVER *GlobalLrpcServer ;

#include <ProtBind.hxx>
#include <osfpcket.hxx>
#include <bitset.hxx>
#include <osfclnt.hxx>
#include <secsvr.hxx>
#include <osfsvr.hxx>
#include <dgpkt.hxx>
#include <dgsvr.hxx>

RPC_STATUS RPC_ENTRY
DefaultCallbackFn (
    IN RPC_IF_HANDLE InterfaceUuid,
    IN void *Context
    )
/*++
Function Name:DefaultCallbackFn

Parameters:

Description:

Returns:
    RPC_S_OK: Access is allowed
    other failures: Access is denied

--*/
{
    RPC_CALL_ATTRIBUTES CallAttributes;
    RPC_STATUS Status;

    CallAttributes.Version = RPC_CALL_ATTRIBUTES_VERSION;
    CallAttributes.Flags = 0;

    Status = RpcServerInqCallAttributesW(Context, 
        &CallAttributes);

    if (Status != RPC_S_OK)
        return Status;

    if ((CallAttributes.AuthenticationService == RPC_C_AUTHN_NONE)
        || (CallAttributes.AuthenticationLevel == RPC_C_AUTHN_LEVEL_NONE)
        || (CallAttributes.NullSession)
       )
        {
        return RPC_S_ACCESS_DENIED;
        }

    return RPC_S_OK;
}


RPC_INTERFACE::RPC_INTERFACE (
    IN RPC_SERVER_INTERFACE PAPI * RpcInterfaceInformation,
    IN RPC_SERVER * Server,
    IN unsigned int Flags,
    IN unsigned int MaxCalls,
    IN unsigned int MaxRpcSize,
    IN RPC_IF_CALLBACK_FN PAPI *IfCallbackFn,
    OUT RPC_STATUS *Status
    ) : NullManagerActiveCallCount(0), AutoListenCallCount(0)
/*++

Routine Description:



    This method will get called to construct an instance of the
    RPC_INTERFACE class.  We have got to make a copy of the rpc interface
    information supplied.  The copy is necessary because we do not delete
    interfaces when they are unregistered.  We just mark them as being
    inactive.  In addition, we need to set the NullManagerFlag
    to zero, since this is used as the flag indicating whether we have
    got a manager for the NULL type UUID.

Arguments:

    RpcInterfaceInformation - Supplies the rpc interface information
        which describes this interface.

    Server - Supplies the rpc server which owns this rpc interface.

--*/
{
    ALLOCATE_THIS(RPC_INTERFACE);
    unsigned int Length;

    PipeInterfaceFlag = 0;
    SequenceNumber = 1;

#if DBG
    Strict = iuschDontKnow;
#endif

    if (RpcInterfaceInformation->Length > sizeof(RPC_SERVER_INTERFACE) )
        {
        Length = sizeof(RPC_SERVER_INTERFACE);
        }
    else
        {
        Length = RpcInterfaceInformation->Length;
        }

    if ((RpcInterfaceInformation->Length > NT351_INTERFACE_SIZE)
        && (RpcInterfaceInformation->Flags & RPC_INTERFACE_HAS_PIPES))
        {
        PipeInterfaceFlag = 1;
        }

    RpcpMemoryCopy(&(this->RpcInterfaceInformation), RpcInterfaceInformation, Length);

    NullManagerFlag = 0;
    ManagerCount = 0;
    this->Server = Server;
    this->Flags = Flags ;
    this->MaxCalls = MaxCalls ;
    this->MaxRpcSize = MaxRpcSize;
    fBindingsExported = 0;
    UuidVector = NULL;

    if (Flags & RPC_IF_ALLOW_SECURE_ONLY
        && IfCallbackFn == NULL)
        {
        this->CallbackFn = DefaultCallbackFn;
        }
    else
        {
        this->CallbackFn = IfCallbackFn ;
        }

    if (DoesInterfaceSupportMultipleTransferSyntaxes(RpcInterfaceInformation))
        {
        *Status = NdrServerGetSupportedSyntaxes(RpcInterfaceInformation,
            &NumberOfSupportedTransferSyntaxes,
            &TransferSyntaxesArray, &PreferredTransferSyntax);
        if (*Status != RPC_S_OK)
            return;
        }
    else
        {
        NumberOfSupportedTransferSyntaxes = 0;
        }

    *Status = RPC_S_OK;
}


RPC_STATUS
RPC_INTERFACE::RegisterTypeManager (
    IN RPC_UUID PAPI * ManagerTypeUuid OPTIONAL,
    IN RPC_MGR_EPV PAPI * ManagerEpv OPTIONAL
    )
/*++

Routine Description:

    This method is used to register a type manager with this interface.
    If no type UUID is specified, or it is the NULL type UUID, we
    stick the manager entry point vector right in this instance (assuming
    that there is not already one), otherwise, we put it into the
    dictionary of interface manager objects.

Arguments:

    ManagerTypeUuid - Optionally supplies the type UUID for the manager
        we want to register with this rpc interface.  If no type UUID
        is supplied then the NULL type UUID is assumed.

    ManagerEpv - Supplies then entry point vector for this manager.  This
        vector is used to dispatch from the stub to the application
        code.

Return Values:

    RPC_S_OK - The type manager has been successfully added to this
        rpc interface.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is availabe to add the
        type manager to the rpc interface.

    RPC_S_TYPE_ALREADY_REGISTERED - A manager entry point vector has
        already been registered for the this interface under the
        specified manager type UUID.

--*/
{
    RPC_INTERFACE_MANAGER * InterfaceManager;

    // First we need to check if the null UUID is being specified as
    // the type UUID; either, explicit or implicit by not specifying
    // a type UUID argument.

    RequestGlobalMutex();

    if (   (ARGUMENT_PRESENT(ManagerTypeUuid) == 0)
        || (   (ARGUMENT_PRESENT(ManagerTypeUuid) != 0)
            && (ManagerTypeUuid->IsNullUuid() != 0)))
        {
        if (NullManagerFlag != 0)
            {
            ClearGlobalMutex();
            return(RPC_S_TYPE_ALREADY_REGISTERED);
            }

        NullManagerEpv = ManagerEpv;
        NullManagerFlag = 1;
        ManagerCount += 1;
        ClearGlobalMutex();
        return(RPC_S_OK);
        }

    // If we reach here, a non-NULL type UUID is specified.

    InterfaceManager = FindInterfaceManager(ManagerTypeUuid);

    if (InterfaceManager == 0)
        {
        InterfaceManager = new RPC_INTERFACE_MANAGER(ManagerTypeUuid,
                ManagerEpv);

        if (InterfaceManager == 0)
            {
            ClearGlobalMutex();
            return(RPC_S_OUT_OF_MEMORY);
            }
        if (InterfaceManagerDictionary.Insert(InterfaceManager) == -1)
            {
            ClearGlobalMutex();
            delete InterfaceManager;
            return(RPC_S_OUT_OF_MEMORY);
            }
        ManagerCount += 1;
        ClearGlobalMutex();
        return(RPC_S_OK);
        }

    if (InterfaceManager->ValidManager() == 0)
        {
        InterfaceManager->SetManagerEpv(ManagerEpv);
        ManagerCount += 1;
        ClearGlobalMutex();
        return(RPC_S_OK);
        }

    ClearGlobalMutex();
    return(RPC_S_TYPE_ALREADY_REGISTERED);
}

RPC_INTERFACE_MANAGER *
RPC_INTERFACE::FindInterfaceManager (
    IN RPC_UUID PAPI * ManagerTypeUuid
    )
/*++

Routine Description:

    This method is used to obtain the interface manager corresponding to
    the specified type UUID.  The type UUID must not be the null UUID.

Arguments:

    ManagerTypeUuid - Supplies the type UUID for which we are trying to
        find the interface manager.

Return Value:

    If a interface manager for this type UUID is found, a pointer to it
    will be returned; otherwise, zero will be returned.

--*/
{
    RPC_INTERFACE_MANAGER * InterfaceManager;
    DictionaryCursor cursor;

    InterfaceManagerDictionary.Reset(cursor);
    while ((InterfaceManager = InterfaceManagerDictionary.Next(cursor)) != 0)
        {
        if (InterfaceManager->MatchTypeUuid(ManagerTypeUuid) == 0)
            return(InterfaceManager);
        }
    return(0);
}


RPC_STATUS
RPC_INTERFACE::DispatchToStub (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned int CallbackFlag,
    IN PRPC_DISPATCH_TABLE DispatchTableToUse,
    OUT RPC_STATUS PAPI * ExceptionCode
    )
/*++

Routine Description:

    This method is used to dispatch remote procedure calls to the
    appropriate stub and hence to the appropriate manager entry point.
    This routine is used for calls having a null UUID (implicit or
    explicit).  We go to great pains to insure that we do not grab
    a mutex.

Arguments:

    Message - Supplies the response message and returns the reply
        message.

    CallbackFlag - Supplies a flag indicating whether this is a callback
        or not.  The argument will be zero if this is an original call,
        and non-zero if it is a callback.

    ExceptionCode - Returns the exact exception code if an exception
        occurs.

Return Value:

    RPC_S_OK - This value will be returned if the operation completed
        successfully.

    RPC_S_PROCNUM_OUT_OF_RANGE - If the procedure number for this call is
        too large, this value will be returned.

    RPC_S_UNKNOWN_IF - If this interface does not exist, you will get this
        value back.

    RPC_S_NOT_LISTENING - The rpc server which owns this rpc interface
        is not listening for remote procedure calls right now.

    RPC_S_SERVER_TOO_BUSY - This call will cause there to be too many
        concurrent remote procedure calls for the rpc server which owns
        this interface.

    RPC_P_EXCEPTION_OCCURED - A fault occured, and we need to remote it.  The
        ExceptionCode argument will contain the exception code for the
        fault.

    RPC_S_UNSUPPORTED_TYPE - This interface exists, but does not have a manager
        for the null type.

--*/
{
    RPC_STATUS RpcStatus = RPC_S_OK;

    if ( CallbackFlag == 0 )
        {
        NullManagerActiveCallCount.Increment();
        if ( NullManagerFlag == 0 )
            {
            NullManagerActiveCallCount.Decrement();

            RpcStatus = RPC_S_UNSUPPORTED_TYPE;

            RpcpErrorAddRecord(EEInfoGCRuntime,
                RpcStatus,
                EEInfoDLDispatchToStub10);

            if ( ManagerCount == 0 )
                {
                RpcStatus = RPC_S_UNKNOWN_IF;
                RpcpErrorAddRecord(EEInfoGCRuntime,
                    RpcStatus,
                    EEInfoDLDispatchToStub20);
                }
            }
        }

    if (RpcStatus != RPC_S_OK)
        {
        ((MESSAGE_OBJECT *) Message->Handle)->FreeBuffer(Message);
        return RpcStatus;
        }

    Message->ManagerEpv = NullManagerEpv;

    RpcStatus = DispatchToStubWorker(Message, CallbackFlag, DispatchTableToUse, ExceptionCode);

    if ( RpcStatus != RPC_S_OK
        || (((MESSAGE_OBJECT *) Message->Handle)->IsSyncCall()
        && CallbackFlag == 0 ))
        {
        NullManagerActiveCallCount.Decrement();
        }

    //
    // DispatchToStubWorker freed Message.Buffer if an error occurred.
    //
    return(RpcStatus);
}



RPC_STATUS
RPC_INTERFACE::DispatchToStubWorker (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned int CallbackFlag,
    IN PRPC_DISPATCH_TABLE DispatchTableToUse,
    OUT RPC_STATUS PAPI * ExceptionCode
    )
/*++

Routine Description:

    This method is used to dispatch remote procedure calls to the
    appropriate stub and hence to the appropriate manager entry point.
    It will be used for calls with and without objects specified.
    We go to great pains to insure that we do not grab a mutex.

Arguments:

    Message - Supplies the response message and returns the reply
        message. If this routine returns anything other than RPC_S_OK
        Message->Buffer has already been freed.

    CallbackFlag - Supplies a flag indicating whether this is a callback
        or not.  The argument will be zero if this is an original call,
        and non-zero if it is a callback.

    DispatchTableToUse - a pointer to the dispatch table to use. This is
        used to select b/n stubs for NDR20 and NDR64 transfer syntaxes

    ExceptionCode - Returns the exact exception code if an exception
        occurs.

Return Value:

    RPC_S_OK - This value will be returned if the operation completed
        successfully.

    RPC_S_PROCNUM_OUT_OF_RANGE - If the procedure number for this call is
        too large, this value will be returned.

    RPC_S_NOT_LISTENING - The rpc server which owns this rpc interface
        is not listening for remote procedure calls right now.

    RPC_S_SERVER_TOO_BUSY - This call will cause there to be too many
        concurrent remote procedure calls for the rpc server which owns
        this interface.

    RPC_P_EXCEPTION_OCCURED - A fault occured, and we need to remote it.  The
        ExceptionCode argument will contain the exception code for the
        fault.

--*/
{
    RPC_STATUS RpcStatus = RPC_S_OK;
    void * OldServerContextList;
    unsigned int procnum ;
    THREAD *Self = RpcpGetThreadPointer() ;

    ASSERT(Self);

    if (Flags & RPC_IF_OLE)
        {
        procnum = 0 ;
        }
    else
        {
        procnum = Message->ProcNum ;
        }


    if (CallbackFlag == 0)
        {
        if (IsAutoListenInterface())
            {
            if (AutoListenCallCount.GetInteger() >= (long) MaxCalls)
                {
                RpcStatus = RPC_S_SERVER_TOO_BUSY ;
                RpcpErrorAddRecord(EEInfoGCRuntime,
                    RpcStatus,
                    EEInfoDLDispatchToStubWorker10,
                    (ULONG)AutoListenCallCount.GetInteger(),
                    (ULONG)MaxCalls);
                }
            }
        else
            {
            if (Server->IsServerListening() == 0)
                {
                RpcStatus = RPC_S_NOT_LISTENING;
                RpcpErrorAddRecord(EEInfoGCRuntime,
                    RpcStatus,
                    EEInfoDLDispatchToStubWorker20);
                }
            else if (Server->fAccountForMaxCalls && Server->CallBeginning() == 0)
                {
                RpcStatus = RPC_S_SERVER_TOO_BUSY;
                RpcpErrorAddRecord(EEInfoGCRuntime,
                    RpcStatus,
                    EEInfoDLDispatchToStubWorker30);
                }
            }
        }

    if (procnum >=
            DispatchTableToUse->DispatchTableCount)
        {
        if (RpcStatus != RPC_S_SERVER_TOO_BUSY)
            {
            EndCall(CallbackFlag) ;
            }
        RpcStatus = RPC_S_PROCNUM_OUT_OF_RANGE;
        RpcpErrorAddRecord(EEInfoGCRuntime,
            RpcStatus,
            EEInfoDLDispatchToStubWorker40);
        }

    if (RpcStatus != RPC_S_OK)
        {
        MO(Message)->FreeBuffer(Message);
        return RpcStatus;
        }

    Server->IncomingCall();

    ((PRPC_RUNTIME_INFO) Message->ReservedForRuntime)->OldBuffer =
            Message->Buffer ;

    Message->RpcInterfaceInformation = &RpcInterfaceInformation;
    SCALL(Message)->DoPreDispatchProcessing(Message, CallbackFlag);

    if ( DispatchToStubInC(DispatchTableToUse->DispatchTable[procnum], Message, ExceptionCode) != 0 )
        {
        LogEvent(SU_EXCEPT, EV_STATUS, LongToPtr(*ExceptionCode),
            DispatchTableToUse->DispatchTable[procnum], (ULONG_PTR)Message, 1, 1);
#if defined(DBG) && defined(i386)
#if 1
        RtlCheckForOrphanedCriticalSections(NtCurrentThread());
#endif
#endif
        RpcStatus = RPC_P_EXCEPTION_OCCURED;
        RpcpErrorAddRecord(EEInfoGCApplication,
            *ExceptionCode,
            EEInfoDLRaiseExc,
            GetInterfaceFirstDWORD(),
            (short)procnum,
            Message->RpcFlags,
            GetCurrentThreadId());
        }

    RPC_MESSAGE OriginalMessage ;
    OriginalMessage.ReservedForRuntime = 0;
    OriginalMessage.Buffer =
        ((PRPC_RUNTIME_INFO) Message->ReservedForRuntime)->OldBuffer;
    Self->ResetYield();

    if (Self->IsSyncCall())
        {
        //
        // Since this is a sync call, we know that it has
        // not been freed yet. So we can safely touch it.
        //
        SCALL(Message)->DoPostDispatchProcessing();

        //
        // The dispatched call was a sync call
        //
        if (RPC_S_OK == RpcStatus)
            {

            //
            // If the stub didn't allocate an output buffer, do so now.
            //
            if (OriginalMessage.Buffer == Message->Buffer)
                {
                Message->RpcFlags = 0;
                Message->BufferLength = 0;
                MO(Message)->GetBuffer(Message, 0);
                }

            //
            // Free the [in] buffer that we saved.
            //
            MO(Message)->FreeBuffer(&OriginalMessage);

            EndCall(CallbackFlag) ;
            }
        else
            {
            ASSERT(RpcStatus == RPC_P_EXCEPTION_OCCURED) ;
            //
            // Free the buffer in the caller's message; this can be either
            // the [in] buffer or the [out] buffer, depending upon which
            // line of the stub caused the error.
            //
            // If the exception occurred after allocating the [out] buffer,
            // also free the [in] buffer.
            //
            if (OriginalMessage.Buffer != Message->Buffer)
                {
                MO(Message)->FreeBuffer(&OriginalMessage);
                }

            if (Message->Buffer)
                {
                MO(Message)->FreeBuffer(Message);
                }

            EndCall(CallbackFlag) ;
            }
        }
    else
        {
        //
        // The dispatched call was an async call
        //
        if (RpcStatus != RPC_S_OK
            && OriginalMessage.Buffer != Message->Buffer)
            {
            //
            // The dispatch buffer will be freed during cleanup
            // of the async call
            //
            MO(Message)->FreeBuffer(Message);
            }
        }



    return(RpcStatus);
}


void
RPC_INTERFACE::EndCall(
    IN unsigned int CallbackFlag,
    BOOL fAsync
    )
{
    if (fAsync)
        {
        NullManagerActiveCallCount.Decrement();
        }

    if (CallbackFlag == 0)
        {
        if (!(Flags & RPC_IF_AUTOLISTEN) && Server->fAccountForMaxCalls)
            {
            Server->CallEnding();
            }
        }
}


RPC_STATUS
RPC_INTERFACE::DispatchToStubWithObject (
    IN OUT PRPC_MESSAGE Message,
    IN RPC_UUID * ObjectUuid,
    IN unsigned int CallbackFlag,
    IN PRPC_DISPATCH_TABLE DispatchTableToUse,
    OUT RPC_STATUS PAPI * ExceptionCode
    )
/*++

Routine Description:

    This method is used to dispatch remote procedure calls to the
    appropriate stub and hence to the appropriate manager entry point.
    This routine is used for calls which have an associated object.

Arguments:

    Message - Supplies the response message and returns the reply
        message.

    ObjectUuid - Supplies the object uuid to map into the manager entry
        point for this call.

    CallbackFlag - Supplies a flag indicating whether this is a callback
        or not.  The argument will be zero if this is an original call,
        and non-zero if it is a callback.

    ExceptionCode - Returns the exact exception code if an exception
        occurs.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_PROCNUM_OUT_OF_RANGE - If the procedure number for this call is
        too large, this value will be returned.

    RPC_S_UNKNOWN_IF - If the specified manager is no longer
        valid, you will get this value back.

    RPC_S_NOT_LISTENING - The rpc server which owns this rpc interface
        is not listening for remote procedure calls right now.

    RPC_S_SERVER_TOO_BUSY - This call will cause there to be too many
        concurrent remote procedure calls for the rpc server which owns
        this interface.

    RPC_P_EXCEPTION_OCCURED - A fault occured, and we need to remote it.  The
        ExceptionCode argument will contain the exception code for the
        fault.

    RPC_S_UNSUPPORTED_TYPE - There is no type manager for the object's type
        for this interface.

--*/
{
    RPC_UUID TypeUuid;
    RPC_STATUS RpcStatus;
    RPC_INTERFACE_MANAGER * RpcInterfaceManager;

    RpcStatus = ObjectInqType(ObjectUuid, &TypeUuid);
    VALIDATE(RpcStatus)
        {
        RPC_S_OK,
        RPC_S_OBJECT_NOT_FOUND
        } END_VALIDATE;

    if ( RpcStatus == RPC_S_OK )
        {
        RpcInterfaceManager = FindInterfaceManager(&TypeUuid);

        if (   ( RpcInterfaceManager != 0 )
            && (   ( CallbackFlag != 0 )
                || ( RpcInterfaceManager->ValidManager() != 0 ) ) )
            {
            Message->ManagerEpv = RpcInterfaceManager->QueryManagerEpv();

            if ( CallbackFlag == 0 )
                {
                RpcInterfaceManager->CallBeginning();
                }

            RpcStatus = DispatchToStubWorker(Message, CallbackFlag, DispatchTableToUse,
                    ExceptionCode);

            if ( CallbackFlag == 0 )
                {
                RpcInterfaceManager->CallEnding();
                }

            return(RpcStatus);
            }

        if (this != GlobalManagementInterface)
            {
            // There is a type for this object, but no type manager for
            // this interface.

            RpcStatus = RPC_S_UNSUPPORTED_TYPE;

            if ( ManagerCount == 0 )
                {
                RpcStatus = RPC_S_UNKNOWN_IF;
                }

            ((MESSAGE_OBJECT *) Message->Handle)->FreeBuffer(Message);
            return RpcStatus;
            }
        }

    // There has not been a type registered for this object, so we will
    // just go ahead and try and use the NULL type manager.

    return(DispatchToStub(Message, CallbackFlag, DispatchTableToUse, ExceptionCode));
}


BOOL
RPC_INTERFACE::IsObjectSupported (
    IN RPC_UUID * ObjectUuid
    )
/*++

Routine Description:

    Determines whether the manager for the given object UUID is registered.

Arguments:

    ObjectUuid - the client's object UUID

Return Value:

    RPC_S_OK                if it is OK to dispatch
    RPC_S_UNKNOWN_IF        if the interface is not registered
    RPC_S_UNSUPPORTED_TYPE  if this particular object's type is not registered

--*/

{
    RPC_STATUS Status = RPC_S_OK;

    if (ObjectUuid->IsNullUuid() )
        {
        if ( NullManagerFlag == 0 )
            {
            Status = RPC_S_UNSUPPORTED_TYPE;

            if ( ManagerCount == 0 )
                {
                Status = RPC_S_UNKNOWN_IF;
                }
            }
        }
    else
        {
        RPC_UUID TypeUuid;
        Status = ObjectInqType(ObjectUuid, &TypeUuid);
        if ( Status == RPC_S_OK )
            {
            RPC_INTERFACE_MANAGER * RpcInterfaceManager = 0;

            RpcInterfaceManager = FindInterfaceManager(&TypeUuid);
            if (!RpcInterfaceManager ||
                !RpcInterfaceManager->ValidManager())
                {
                Status = RPC_S_UNSUPPORTED_TYPE;

                if ( ManagerCount == 0 )
                    {
                    Status = RPC_S_UNKNOWN_IF;
                    }
                }
            }
        else
            {
            Status = RPC_S_OK;
            if ( NullManagerFlag == 0 )
                {
                Status = RPC_S_UNSUPPORTED_TYPE;

                if ( ManagerCount == 0 )
                    {
                    Status = RPC_S_UNKNOWN_IF;
                    }
                }
            }

        }

    return Status;
}


RPC_STATUS
RPC_INTERFACE::UpdateBindings (
    IN RPC_BINDING_VECTOR *BindingVector
    )
/*++
Function Name:UpdateEpMapperBindings

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;
    unsigned int Length;
#if !defined(NO_LOCATOR_CODE)
    NS_ENTRY *NsEntry;
#endif
    DictionaryCursor cursor;

    if (fBindingsExported)
        {
        Status = RegisterEntries(&RpcInterfaceInformation,
                    BindingVector,
                    UuidVector,
                    (unsigned char *) Annotation,
                    fReplace);
        if (Status != RPC_S_OK)
            {
            return Status;
            }
        }

#if !defined(NO_LOCATOR_CODE)
    // shortcut the common path and avoid taking and holding
    // unnecessarily the high contention global mutex
    if (NsEntries.Size() == 0)
        return RPC_S_OK;

    RequestGlobalMutex();
    NsEntries.Reset(cursor);
    while ((NsEntry = NsEntries.Next(cursor)) != 0)
        {
        //
        // Actually update the locator bindings
        //
        Status = GlobalRpcServer->NsBindingUnexport(
                                          NsEntry->EntryNameSyntax,
                                          NsEntry->EntryName,
                                          &RpcInterfaceInformation);
        if (Status == RPC_S_OK)
            {
            Status = GlobalRpcServer->NsBindingExport(
                                            NsEntry->EntryNameSyntax,
                                            NsEntry->EntryName,
                                            &RpcInterfaceInformation,
                                            BindingVector);
#if DBG
            if (Status != RPC_S_OK)
                {
                PrintToDebugger("RPC: Bindings were unexported, but could not re-export\n");
                }
#endif
            }
        }
    ClearGlobalMutex();
#endif

    return RPC_S_OK;
}


RPC_STATUS
RPC_INTERFACE::InterfaceExported (
    IN UUID_VECTOR *MyObjectUuidVector,
    IN unsigned char *MyAnnotation,
    IN BOOL MyfReplace
    )
/*++
Function Name:InterfaceExported

Parameters:

Description:
    RpcEpRegister was called on this interface. We need to keep track
    of the parameters, so that if we get a PNP notification, we can update
    the bindings using there params

Returns:
    RPC_S_OK: things went fine
    RPC_S_OUT_OF_MEMORY: ran out of memory
--*/
{
    RequestGlobalMutex();

    if (UuidVector
        && UuidVector != MyObjectUuidVector)
        {
        RpcpFarFree(UuidVector);
        UuidVector = 0;
        }

    if (MyObjectUuidVector)
        {
        if (UuidVector != MyObjectUuidVector)
            {
            int Size = MyObjectUuidVector->Count*(sizeof(UUID)+sizeof(UUID *))
                            +sizeof(unsigned long);
            UUID *Uuids;
            unsigned i;

            UuidVector = (UUID_VECTOR *) RpcpFarAllocate(Size);
            if (UuidVector == 0)
                {
                ClearGlobalMutex();
                return RPC_S_OUT_OF_MEMORY;
                }

            Uuids = (UUID *) ((char *) UuidVector + sizeof(unsigned long)
                        +(sizeof(UUID *) * MyObjectUuidVector->Count));

            UuidVector->Count = MyObjectUuidVector->Count;

            for (i = 0; i < UuidVector->Count; i++)
                {
                Uuids[i] = *(MyObjectUuidVector->Uuid[i]);
                UuidVector->Uuid[i] = &Uuids[i];
                }
            }
        }
    else
        {
        UuidVector = 0;
        }

    if (MyAnnotation)
        {
        strncpy((char *) Annotation, (char *) MyAnnotation, 63);
        Annotation[63]=0;
        }
    else
        {
        Annotation[0] = 0;
        }

    fReplace = MyfReplace;
    fBindingsExported = 1;

    ClearGlobalMutex();

    return RPC_S_OK;
}


#if !defined(NO_LOCATOR_CODE)
NS_ENTRY *
RPC_INTERFACE::FindEntry (
    IN unsigned long EntryNameSyntax,
    IN RPC_CHAR *EntryName
    )
{
    NS_ENTRY *NsEntry;
    DictionaryCursor cursor;

    //
    // This function will always be called with the mutex held
    //
    NsEntries.Reset(cursor);
    while ((NsEntry = NsEntries.Next(cursor)) != 0)
        {
        if (NsEntry->Match(EntryNameSyntax, EntryName))
            {
            return NsEntry;
            }
        }

    return 0;
}


RPC_STATUS
RPC_INTERFACE::NsInterfaceUnexported (
    IN unsigned long EntryNameSyntax,
    IN RPC_CHAR *EntryName
    )
{
    NS_ENTRY *NsEntry;

    RequestGlobalMutex();
    NsEntry = FindEntry(EntryNameSyntax, EntryName);
    if (NsEntry == 0)
        {
        ClearGlobalMutex();

#if DBG
        PrintToDebugger("RPC: No corresponding exported entry\n");
#endif
        return RPC_S_ENTRY_NOT_FOUND;
        }

    NsEntries.Delete(NsEntry->Key);
    ClearGlobalMutex();

    return RPC_S_OK;
}


RPC_STATUS
RPC_INTERFACE::NsInterfaceExported (
    IN unsigned long EntryNameSyntax,
    IN RPC_CHAR *EntryName
    )
{
    RPC_STATUS Status = RPC_S_OK;
    NS_ENTRY *NsEntry;
    int retval;

    RequestGlobalMutex();
    NsEntry = FindEntry(EntryNameSyntax, EntryName);
    ClearGlobalMutex();

    if (NsEntry)
        {
        return RPC_S_OK;
        }

    NsEntry = new NS_ENTRY(
                           EntryNameSyntax,
                           EntryName,
                           &Status);
    if (NsEntry == 0)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    if (Status != RPC_S_OK)
        {
        delete NsEntry;
        return Status;
        }

    RequestGlobalMutex();
    NsEntry->Key = NsEntries.Insert(NsEntry);
    ClearGlobalMutex();

    if (NsEntry->Key == -1)
        {
        delete NsEntry;
        return RPC_S_OUT_OF_MEMORY;
        }

    return RPC_S_OK;
}
#endif

static unsigned int
MatchSyntaxIdentifiers (
    IN PRPC_SYNTAX_IDENTIFIER ServerSyntax,
    IN PRPC_SYNTAX_IDENTIFIER ClientSyntax
    )
/*++

Routine Description:

    This method compares two syntax identifiers (which consist of a
    uuid, a major version number, and a minor version number).  In
    order for the syntax identifiers to match, the uuids must be the
    same, the major version numbers must be the same, and the client
    minor version number must be less than or equal to the server
    minor version number.

Arguments:

    ServerSyntax - Supplies the server syntax identifier.

    ClientSyntax - Supplies the client syntax identifer.

Return Value:

    Zero will be returned if the client syntax identifier matches the
    server syntax identifier; otherwise, non-zero will be returned.

--*/
{
    if (RpcpMemoryCompare(&(ServerSyntax->SyntaxGUID),
            &(ClientSyntax->SyntaxGUID), sizeof(UUID)) != 0)
        return(1);
    if (ServerSyntax->SyntaxVersion.MajorVersion
            != ClientSyntax->SyntaxVersion.MajorVersion)
        return(1);
    if (ServerSyntax->SyntaxVersion.MinorVersion
            < ClientSyntax->SyntaxVersion.MinorVersion)
        return(1);

    return(0);
}


unsigned int
RPC_INTERFACE::MatchInterfaceIdentifier (
    IN PRPC_SYNTAX_IDENTIFIER InterfaceIdentifier
    )
/*++

Routine Description:

    This method compares the supplied interface identifier (which consists
    of the interface uuid and interface version) against that contained
    in this rpc interface.  In order for this rpc interface to match,
    the interface uuids must be the same, the interface major versions
    must be the same, and the supplied interface minor version must be
    less than or equal to the interface minor version contained in this
    rpc interface.

Arguments:

    InterfaceIdentifier - Supplies the interface identifier to compare
        against that contained in this rpc interface.

Return Value:

    Zero will be returned if the supplied interface identifer matches
    (according to the rules described above) the interface identifier
    contained in this rpc interface; otherwise, non-zero will be returned.

--*/
{
    if (ManagerCount == 0)
        return(1);

    return(MatchSyntaxIdentifiers(&(RpcInterfaceInformation.InterfaceId),
            InterfaceIdentifier));
}


unsigned int
RPC_INTERFACE::SelectTransferSyntax (
    IN PRPC_SYNTAX_IDENTIFIER ProposedTransferSyntaxes,
    IN unsigned int NumberOfTransferSyntaxes,
    OUT PRPC_SYNTAX_IDENTIFIER AcceptedTransferSyntax,
    OUT BOOL *fIsInterfaceTransferPreferred,
    OUT int *ProposedTransferSyntaxIndex,
    OUT int *AvailableTransferSyntaxIndex
    )
/*++

Routine Description:

    This method is used to select a transfer syntax from a list of one
    or more transfer syntaxes.  If a transfer syntax is selected, then
    it will be returned in one of the arguments.

Arguments:

    ProposedTransferSyntaxes - Supplies a list of one or more transfer
        syntaxes from which this interface should select one which it
        supports if possible.

    NumberOfTransferSyntaxes - Supplies the number of transfer syntaxes
        in the proposed transfer syntaxes argument.

    AcceptedTransferSyntax - Returns the selected transfer syntax, if
        one is selected.

    fIsInterfaceTransferPreferred - true if the selected transfer syntax
        is preferred by the server

    ProposedTransferSyntaxIndex - the index of the transfer syntax that is
        chosen from the proposed transfer syntaxes array. Zero based.

    AvailableTransferSyntaxIndex - the index of the transfer syntax that is
        chosen from the available transfer syntaxes in the interface. This
        value must be stored in the binding and retrieved when asking for the
        transfer syntax and dispatch table. Zero based.

Return Value:

    Zero will be returned if a transfer syntax is selected; otherwise,
    non-zero will be returned.

--*/
{
    unsigned int ProposedIndex;
    unsigned int AvailableIndex;
    unsigned int NumberOfAvailableSyntaxes;
    BOOL fMultipleTranfserSyntaxesSelected;
    RPC_SYNTAX_IDENTIFIER *CurrentTransferSyntax;
    RPC_SYNTAX_IDENTIFIER *BackupTransferSyntax = NULL;
    int BackupProposedTransferSyntaxIndex;
    int BackupAvailableTransferSyntaxIndex;

    fMultipleTranfserSyntaxesSelected = AreMultipleTransferSyntaxesSupported();
    if (fMultipleTranfserSyntaxesSelected)
        NumberOfAvailableSyntaxes = NumberOfSupportedTransferSyntaxes;
    else
        NumberOfAvailableSyntaxes = 1;

    for (AvailableIndex = 0; AvailableIndex < NumberOfAvailableSyntaxes; AvailableIndex ++)
        {
        if (fMultipleTranfserSyntaxesSelected)
            CurrentTransferSyntax = &(TransferSyntaxesArray[AvailableIndex].TransferSyntax);
        else
            CurrentTransferSyntax = &RpcInterfaceInformation.TransferSyntax;
        for (ProposedIndex = 0; ProposedIndex < NumberOfTransferSyntaxes;
                ProposedIndex++)
            {
            if (MatchSyntaxIdentifiers(CurrentTransferSyntax,
                    &(ProposedTransferSyntaxes[ProposedIndex])) == 0)
                {
                // is this the preferred transfer syntax for the server?
                if (AvailableIndex == PreferredTransferSyntax)
                    {
                    // this is the preferred transfer syntax - just
                    // copy it and return
                    RpcpMemoryCopy(AcceptedTransferSyntax,
                            &(ProposedTransferSyntaxes[ProposedIndex]),
                            sizeof(RPC_SYNTAX_IDENTIFIER));
                    *fIsInterfaceTransferPreferred = TRUE;
                    *ProposedTransferSyntaxIndex = ProposedIndex;
                    *AvailableTransferSyntaxIndex = AvailableIndex;
                    return(0);
                    }
                else
                    {
                    // this is not the preferred syntax - just remeber this
                    // one (if no previous match was found) and continue
                    if (BackupTransferSyntax == NULL)
                        {
                        BackupTransferSyntax = &(ProposedTransferSyntaxes[ProposedIndex]);
                        BackupProposedTransferSyntaxIndex = ProposedIndex;
                        BackupAvailableTransferSyntaxIndex = AvailableIndex;
                        }
                    }
                }
            }
        }

    // if we're here, this means we didn't find the preferred transfer syntax
    // check whether there is a backup syntax
    if (BackupTransferSyntax)
        {
        RpcpMemoryCopy(AcceptedTransferSyntax, BackupTransferSyntax,
                sizeof(RPC_SYNTAX_IDENTIFIER));
        *fIsInterfaceTransferPreferred = FALSE;
        *ProposedTransferSyntaxIndex = BackupProposedTransferSyntaxIndex;
        *AvailableTransferSyntaxIndex = BackupAvailableTransferSyntaxIndex;
        return(0);
        }
    // nada - no transfer syntax matches
    return(1);
}

void RPC_INTERFACE::GetSelectedTransferSyntaxAndDispatchTable(IN int SelectedTransferSyntaxIndex,
    OUT RPC_SYNTAX_IDENTIFIER **SelectedTransferSyntax,
    OUT PRPC_DISPATCH_TABLE *SelectedDispatchTable)
{
    MIDL_SYNTAX_INFO *SelectedSyntaxInfo;

    if (DoesInterfaceSupportMultipleTransferSyntaxes(&RpcInterfaceInformation))
        {
        ASSERT((unsigned int)SelectedTransferSyntaxIndex <= NumberOfSupportedTransferSyntaxes);
        SelectedSyntaxInfo = &TransferSyntaxesArray[SelectedTransferSyntaxIndex];
        *SelectedTransferSyntax = &SelectedSyntaxInfo->TransferSyntax;
        // DCOM has only one dispatch table - they change the dispatch target
        // internally. They will define only the dispatch table in the
        // interface
        if (SelectedSyntaxInfo->DispatchTable)
            *SelectedDispatchTable = SelectedSyntaxInfo->DispatchTable;
        else
            *SelectedDispatchTable = GetDefaultDispatchTable();
        }
    else
        {
        *SelectedTransferSyntax = &RpcInterfaceInformation.TransferSyntax;
        *SelectedDispatchTable = GetDefaultDispatchTable();
        }
}

RPC_STATUS
RPC_INTERFACE::UnregisterManagerEpv (
    IN RPC_UUID PAPI * ManagerTypeUuid, OPTIONAL
    IN unsigned int WaitForCallsToComplete
    )
/*++

Routine Description:

    In this method, we unregister one or all of the manager entry point
    vectors for this interface, depending on what, if anything, is
    specified for the manager type uuid argument.

Arguments:

    ManagerTypeUuid - Optionally supplies the type uuid of the manager
        entry point vector to be removed.  If this argument is not supplied,
        then all manager entry point vectors for this interface will
        be removed.

    WaitForCallsToComplete - Supplies a flag indicating whether or not
        this routine should wait for all calls to complete using the
        interface and manager being unregistered.  A non-zero value
        indicates to wait.

Return Value:

    RPC_S_OK - The manager entry point vector(s) are(were) successfully
        removed from the this interface.

    RPC_S_UNKNOWN_MGR_TYPE - The specified type uuid is not registered
        with this interface.

    RPC_S_UNKNOWN_IF - The specified interface is not registered with
        the rpc server.

--*/
{
    RPC_INTERFACE_MANAGER * InterfaceManager;
    DictionaryCursor cursor;

    RequestGlobalMutex();
    if (ManagerCount == 0)
        {
        ClearGlobalMutex();
        return(RPC_S_UNKNOWN_MGR_TYPE);
        }

    if (ARGUMENT_PRESENT(ManagerTypeUuid) == 0)
        {
        InterfaceManagerDictionary.Reset(cursor);
        while ((InterfaceManager = InterfaceManagerDictionary.Next(cursor)) != 0)
            {
            InterfaceManager->InvalidateManager();
            }

        ManagerCount = 0;
        NullManagerFlag = 0;
        ClearGlobalMutex();

        if ( WaitForCallsToComplete != 0 )
            {
            while ( NullManagerActiveCallCount.GetInteger() > 0 )
                {
                PauseExecution(500L);
                }

            InterfaceManagerDictionary.Reset(cursor);
            while ((InterfaceManager = InterfaceManagerDictionary.Next(cursor)) != 0)
                {
                while ( InterfaceManager->InquireActiveCallCount() > 0 )
                    {
                    PauseExecution(500L);
                    }
                }
            }

        return(RPC_S_OK);
        }

    if (ManagerTypeUuid->IsNullUuid() != 0)
        {
        if (NullManagerFlag == 0)
            {
            ClearGlobalMutex();
            return(RPC_S_UNKNOWN_MGR_TYPE);
            }
        ManagerCount -= 1;
        NullManagerFlag = 0;
        ClearGlobalMutex();

        if ( WaitForCallsToComplete != 0 )
            {
            while ( NullManagerActiveCallCount.GetInteger() > 0 )
                {
                PauseExecution(500L);
                }
            }
        return(RPC_S_OK);
        }

    InterfaceManager = FindInterfaceManager(ManagerTypeUuid);
    if (   (InterfaceManager == 0)
        || (InterfaceManager->ValidManager() == 0))
        {
        ClearGlobalMutex();
        return(RPC_S_UNKNOWN_MGR_TYPE);
        }
    InterfaceManager->InvalidateManager();
    ManagerCount -= 1;
    ClearGlobalMutex();

    if ( WaitForCallsToComplete != 0 )
        {
        while ( InterfaceManager->InquireActiveCallCount() > 0 )
            {
            PauseExecution(500L);
            }
        }

    return(RPC_S_OK);
}


RPC_STATUS
RPC_INTERFACE::InquireManagerEpv (
    IN RPC_UUID PAPI * ManagerTypeUuid, OPTIONAL
    OUT RPC_MGR_EPV PAPI * PAPI * ManagerEpv
    )
/*++

Routine Description:

    This method is used to obtain the manager entry point vector
    with the specified type uuid supported by this interface.

Arguments:

    ManagerTypeUuid - Optionally supplies the type uuid of the manager
        entry point vector we want returned.  If no manager type uuid
        is specified, then the null uuid is assumed.

    ManagerEpv - Returns the manager entry point vector.

Return Value:

    RPC_S_OK - The manager entry point vector has successfully been
        returned.

    RPC_S_UNKNOWN_MGR_TYPE - The specified type uuid is not registered
        with the interface.

    RPC_S_UNKNOWN_IF - The specified interface is not registered with
        the rpc server.

--*/
{
    RPC_INTERFACE_MANAGER * InterfaceManager;

    RequestGlobalMutex();
    if (ManagerCount == 0)
        {
        ClearGlobalMutex();
        return(RPC_S_UNKNOWN_IF);
        }

    if (   (ARGUMENT_PRESENT(ManagerTypeUuid) == 0)
        || (ManagerTypeUuid->IsNullUuid() != 0))
        {
        if (NullManagerFlag == 0)
            {
            ClearGlobalMutex();
            return(RPC_S_UNKNOWN_MGR_TYPE);
            }

        *ManagerEpv = NullManagerEpv;
        ClearGlobalMutex();
        return(RPC_S_OK);
        }

    InterfaceManager = FindInterfaceManager(ManagerTypeUuid);
    if (   (InterfaceManager == 0)
        || (InterfaceManager->ValidManager() == 0))
        {
        ClearGlobalMutex();
        return(RPC_S_UNKNOWN_MGR_TYPE);
        }
    *ManagerEpv = InterfaceManager->QueryManagerEpv();
    ClearGlobalMutex();
    return(RPC_S_OK);
}


RPC_STATUS
RPC_INTERFACE::UpdateRpcInterfaceInformation (
    IN RPC_SERVER_INTERFACE PAPI * RpcInterfaceInformation,
    IN unsigned int Flags,
    IN unsigned int MaxCalls,
    IN unsigned int MaxRpcSize,
    IN RPC_IF_CALLBACK_FN PAPI *IfCallbackFn
    )
/*++

Routine Description:

    We never delete the interface objects from a server; we just invalidate
    them.   This means that if an interface has been complete unregistered
    (ie. it has no managers), we need to update the interface information
    again.

Arguments:

    RpcInterfaceInformation - Supplies the interface information which this
        interface should be using.

--*/
{
    unsigned int Length;
    RPC_STATUS Status;

    Length = RpcInterfaceInformation->Length;

    ASSERT((Length == sizeof(RPC_SERVER_INTERFACE)) ||
        (Length == NT351_INTERFACE_SIZE));

    // make it stick on free builds as well
    if ((Length != sizeof(RPC_SERVER_INTERFACE)) &&
        (Length != NT351_INTERFACE_SIZE))
        return RPC_S_UNKNOWN_IF;

    if ( ManagerCount == 0 )
        {
        if (DoesInterfaceSupportMultipleTransferSyntaxes(RpcInterfaceInformation))
            {
            Status = NdrServerGetSupportedSyntaxes(RpcInterfaceInformation,
                &NumberOfSupportedTransferSyntaxes,
                &TransferSyntaxesArray, &PreferredTransferSyntax);
            if (Status != RPC_S_OK)
                return Status;
            }
        else
            {
            NumberOfSupportedTransferSyntaxes = 0;
            }

        RpcpMemoryCopy(&(this->RpcInterfaceInformation),
                RpcInterfaceInformation, Length);
        }

    if (Flags & RPC_IF_AUTOLISTEN
        && (this->Flags & RPC_IF_AUTOLISTEN) == 0)
        {
        GlobalRpcServer->IncrementAutoListenInterfaceCount() ;
        }

    this->Flags = Flags ;
    this->MaxCalls = MaxCalls ;
    this->MaxRpcSize = MaxRpcSize;
    SequenceNumber++ ;

    if (Flags & RPC_IF_ALLOW_SECURE_ONLY
        && IfCallbackFn == NULL)
        {
        this->CallbackFn = DefaultCallbackFn;
        }
    else
        {
        this->CallbackFn = IfCallbackFn ;
        }

    return RPC_S_OK;
}


RPC_IF_ID __RPC_FAR *
RPC_INTERFACE::InquireInterfaceId (
    )
/*++

Return Value:

    If this interface is active, its interface id will be returned in a
    newly allocated chunk of memory; otherwise, zero will be returned.

--*/
{
    RPC_IF_ID __RPC_FAR * RpcIfId;

    if ( ManagerCount == 0 )
        {
        return(0);
        }

    RpcIfId = (RPC_IF_ID __RPC_FAR *) RpcpFarAllocate(sizeof(RPC_IF_ID));
    if ( RpcIfId == 0 )
        {
        return(0);
        }

    RpcIfId->Uuid = RpcInterfaceInformation.InterfaceId.SyntaxGUID;
    RpcIfId->VersMajor =
            RpcInterfaceInformation.InterfaceId.SyntaxVersion.MajorVersion;
    RpcIfId->VersMinor =
            RpcInterfaceInformation.InterfaceId.SyntaxVersion.MinorVersion;
    return(RpcIfId);
}


RPC_STATUS
RPC_INTERFACE::CheckSecurityIfNecessary(
    IN void * Context
    )
{

//
// If manager count in non-zero, this interface is still registered
// If it has been registered with a call back function, invoke the callback
// function, else return success....

    RPC_IF_ID RpcIfId;
    RPC_STATUS RpcStatus = RPC_S_OK;


    if (CallbackFn != 0)
        {
        RpcIfId.Uuid = RpcInterfaceInformation.InterfaceId.SyntaxGUID;
        RpcIfId.VersMajor =
            RpcInterfaceInformation.InterfaceId.SyntaxVersion.MajorVersion;
        RpcIfId.VersMinor =
            RpcInterfaceInformation.InterfaceId.SyntaxVersion.MinorVersion;

        BeginAutoListenCall();
        if (ManagerCount == 0)
            {
            EndAutoListenCall();
            return (RPC_S_UNKNOWN_IF);
            }

        RpcTryExcept
           {
           RpcStatus = CallbackFn(&RpcIfId, Context);
           }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
           {
           RpcStatus = RPC_S_ACCESS_DENIED;
           }
        RpcEndExcept

        EndAutoListenCall();
        }

    return(RpcStatus);
}


void
RPC_INTERFACE::WaitForCalls(
    )
/*++

Routine Description:

    Waits for the completion of all the calls on a given interface.

--*/
{
    DictionaryCursor cursor;
    RPC_INTERFACE_MANAGER * InterfaceManager;

    while ( NullManagerActiveCallCount.GetInteger() > 0 )
        {
        PauseExecution(500L);
        }

    InterfaceManagerDictionary.Reset(cursor);
    while ((InterfaceManager = InterfaceManagerDictionary.Next(cursor)) != 0)
        {
        while ( InterfaceManager->InquireActiveCallCount() > 0 )
            {
            PauseExecution(500L);
            }
        }
}


RPC_SERVER::RPC_SERVER (
    IN OUT RPC_STATUS PAPI * RpcStatus
    ) : AvailableCallCount(0),
        ServerMutex(RpcStatus,
                    TRUE   // pre-allocate semaphore
                    ),
        StopListeningEvent(RpcStatus),
        ThreadCacheMutex(RpcStatus,
                         TRUE,  // pre-allocate semaphore
                         100
                         ),
        NumAutoListenInterfaces(0)
/*++

Routine Description:

    This routine will get called to construct an instance of the
    RPC_SERVER class.

--*/
{
    ALLOCATE_THIS(RPC_SERVER);

    ServerListeningFlag = 0;
    ListeningThreadFlag = 0;
    WaitingThreadFlag = 0;
    MinimumCallThreads = 1;
    MaximumConcurrentCalls = 1;
    IncomingRpcCount = 0;
    OutgoingRpcCount = 0;
    ReceivedPacketCount = 0;
    SentPacketCount = 0;
    ThreadCache = 0;
    ListenStatusCode = RPC_S_OK;
    fAccountForMaxCalls = TRUE;

    pRpcForwardFunction = (RPC_FORWARD_FUNCTION *)0;
#if !defined(NO_LOCATOR_CODE)
    pNsBindingExport = 0;
    pNsBindingUnexport = 0;
#endif
}


RPC_INTERFACE *
RPC_SERVER::FindInterface (
    IN RPC_SERVER_INTERFACE PAPI * RpcInterfaceInformation
    )
/*++

Routine Description:

    This method is used to find the rpc interface registered with this
    server which matches the supplied rpc interface information.

Arguments:

    RpcInterfaceInformation - Supplies the rpc interface information
        identifying the rpc interface we are looking for.

Return Value:

    The rpc interface matching the supplied rpc interface information
    will be returned if it is found; otherwise, zero will be returned.

--*/
{
    RPC_INTERFACE * RpcInterface;
    DictionaryCursor cursor;

    ServerMutex.VerifyOwned();

    RpcInterfaceDictionary.Reset(cursor);
    while ((RpcInterface = RpcInterfaceDictionary.Next(cursor)) != 0)
        {
        if (RpcInterface->MatchRpcInterfaceInformation(
                RpcInterfaceInformation) == 0)
            {
            return(RpcInterface);
            }
        }

    // The management interface is implicitly registered in all servers.

    if (   (GlobalManagementInterface)
        && (GlobalManagementInterface->MatchRpcInterfaceInformation(
                RpcInterfaceInformation) == 0) )
        {
        return(GlobalManagementInterface);
        }

    return(0);
}


int
RPC_SERVER::AddInterface (
    IN RPC_INTERFACE * RpcInterface
    )
/*++

Routine Description:

    This method will be used to all an rpc interface to the set of
    interfaces known about by this server.

Arguments:

    RpcInterface - Supplies the rpc interface to add to the set of
        interfaces.

Return Value:

    Zero will be returned if the interface is successfully added to
    the set; otherwise, non-zero will be returned indicating that
    insufficient memory is available to complete the operation.

--*/
{
    if (RpcInterfaceDictionary.Insert(RpcInterface) == -1)
        {
        ServerMutex.Clear();
        return(-1);
        }

    return(0);
}

RPC_STATUS
RPC_SERVER::FindInterfaceTransfer (
    IN PRPC_SYNTAX_IDENTIFIER InterfaceIdentifier,
    IN PRPC_SYNTAX_IDENTIFIER ProposedTransferSyntaxes,
    IN unsigned int NumberOfTransferSyntaxes,
    OUT PRPC_SYNTAX_IDENTIFIER AcceptedTransferSyntax,
    OUT RPC_INTERFACE ** AcceptingRpcInterface,
    OUT BOOL *fInterfaceTransferIsPreferred,
    OUT int *ProposedTransferSyntaxIndex,
    OUT int *AvailableTransferSyntaxIndex
    )
/*++

Routine Description:

    This method is used to determine if a client bind request can be
    accepted or not.  All we have got to do here is hand off to the
    server which owns this address.

Arguments:

    InterfaceIdentifier - Supplies the syntax identifier for the
        interface; this is the interface uuid and version.

    ProposedTransferSyntaxes - Supplies a list of one or more transfer
        syntaxes which the client initiating the binding supports.  The
        server should pick one of these which is supported by the
        interface.

    NumberOfTransferSyntaxes - Supplies the number of transfer syntaxes
        specified in the proposed transfer syntaxes argument.

    AcceptedTransferSyntax - Returns the transfer syntax which the
        server accepted.

    AcceptingRpcInterface - Returns a pointer to the rpc interface found
        which supports the requested interface and one of the requested
        transfer syntaxes.

    fInterfaceTransferIsPreferred - non zero if the interface transfer
        returned is preferred.

    TransferSyntaxIndex - the index of the chosen transfer syntax in the
        ProposedTransferSyntaxesArray

Return Value:

    RPC_S_OK - The requested interface exists and it supports at least
        one of the proposed transfer syntaxes.  We are all set, now we
        can make remote procedure calls.

     RPC_S_UNSUPPORTED_TRANSFER_SYNTAX - The requested interface exists,
        but it does not support any of the proposed transfer syntaxes.

     RPC_S_UNKNOWN_IF - The requested interface is not supported
        by this rpc server.

--*/
{
    RPC_INTERFACE * RpcInterface;
    unsigned int InterfaceFound = 0;
    DictionaryCursor cursor;

    ServerMutex.Request();
    RpcInterfaceDictionary.Reset(cursor);
    while ((RpcInterface = RpcInterfaceDictionary.Next(cursor)) != 0)
        {
        if (RpcInterface->MatchInterfaceIdentifier(InterfaceIdentifier) == 0)
            {
            InterfaceFound = 1;
            if (RpcInterface->SelectTransferSyntax(ProposedTransferSyntaxes,
                    NumberOfTransferSyntaxes, AcceptedTransferSyntax,
                    fInterfaceTransferIsPreferred, ProposedTransferSyntaxIndex,
                    AvailableTransferSyntaxIndex) == 0)
                {
                ServerMutex.Clear();
                *AcceptingRpcInterface = RpcInterface;
                return(RPC_S_OK);
                }
            }
        }

    ServerMutex.Clear();

    // The management interface is implicitly registered in all servers.

    if (   (GlobalManagementInterface)
        && (GlobalManagementInterface->MatchInterfaceIdentifier(
                InterfaceIdentifier) == 0 ) )
        {
        InterfaceFound = 1;
        if (GlobalManagementInterface->SelectTransferSyntax(
                ProposedTransferSyntaxes, NumberOfTransferSyntaxes,
                AcceptedTransferSyntax, fInterfaceTransferIsPreferred,
                ProposedTransferSyntaxIndex, AvailableTransferSyntaxIndex) == 0)
            {
            *AcceptingRpcInterface = GlobalManagementInterface;
            return(RPC_S_OK);
            }
        }

    if (InterfaceFound == 0)
        return(RPC_S_UNKNOWN_IF);

    return(RPC_S_UNSUPPORTED_TRANS_SYN);
}


RPC_INTERFACE *
RPC_SERVER::FindInterface (
    IN PRPC_SYNTAX_IDENTIFIER InterfaceIdentifier
    )
/*++

Routine Description:

    The datagram protocol module will use this routine to find the interface
    with out worrying about the transfer syntax.  Datagram RPC does not support
    more than a single transfer syntax.

Arguments:

    InterfaceIdentifier - Supplies the identifier (UUID and version) of the
        interface we are trying to find.

Return Value:

    If the interface is found it will be returned; otherwise, zero will be
    returned.

--*/
{
    RPC_INTERFACE * RpcInterface;
    DictionaryCursor cursor;

    ServerMutex.Request();
    RpcInterfaceDictionary.Reset(cursor);
    while ( (RpcInterface = RpcInterfaceDictionary.Next(cursor)) != 0)
        {
        if ( RpcInterface->MatchInterfaceIdentifier(InterfaceIdentifier)
                    == 0 )
            {
            ServerMutex.Clear();
            return(RpcInterface);
            }
        }
    ServerMutex.Clear();

    // The management interface is implicitly registered in all servers.

    if (   (GlobalManagementInterface)
        && (GlobalManagementInterface->MatchInterfaceIdentifier(
            InterfaceIdentifier) == 0) )
        {
        return(GlobalManagementInterface);
        }

    return(0);
}


RPC_STATUS
RPC_SERVER::ServerListen (
    IN unsigned int MinimumCallThreads,
    IN unsigned int MaximumConcurrentCalls,
    IN unsigned int DontWait
    )
/*++

Routine Description:

    This method is called to start this rpc server listening for remote
    procedure calls.  We do not return until after StopServerListening
    has been called and all active calls complete, or an error occurs.

Arguments:

    MinimumCallThreads - Supplies the minimum number of call threads
        which should be created to service remote procedure calls.

    MaximumConcurrentCalls - Supplies the maximum concurrent calls this
        rpc server is willing to accept at one time.

    DontWait - Supplies a flag indicating whether or not to wait until
        RpcMgmtStopServerListening has been called and all calls have
        completed.  A non-zero value indicates not to wait.

Return Value:

    RPC_S_OK - Everything worked out in the end.  All active calls
        completed successfully after RPC_SERVER::StopServerListening
        was called.  No errors occured in the transports.

    RPC_S_ALREADY_LISTENING - This rpc server is already listening.

    RPC_S_NO_PROTSEQS_REGISTERED - No protocol sequences have been
        registered with this rpc server.  As a consequence it is
        impossible for this rpc server to receive any remote procedure
        calls, hence, the error code.

    RPC_S_MAX_CALLS_TOO_SMALL - MaximumConcurrentCalls is smaller than
        MinimumCallThreads or MaximumConcurrentCalls is zero.


--*/
{
    RPC_ADDRESS * RpcAddress;
    RPC_STATUS Status;
    DictionaryCursor cursor;

    if (   ( MaximumConcurrentCalls < MinimumCallThreads )
        || ( MaximumConcurrentCalls == 0 ) )
        {
        return(RPC_S_MAX_CALLS_TOO_SMALL);
        }

    if ( MaximumConcurrentCalls > 0x7FFFFFFF )
        {
        MaximumConcurrentCalls = 0x7FFFFFFF;
        }

    ServerMutex.Request();

    if ( ListeningThreadFlag != 0 )
        {
        ServerMutex.Clear();
        return(RPC_S_ALREADY_LISTENING);
        }

    if ( RpcAddressDictionary.Size() == 0
         && RpcDormantAddresses.IsQueueEmpty())
        {
        ServerMutex.Clear();
        return(RPC_S_NO_PROTSEQS_REGISTERED);
        }

    this->MaximumConcurrentCalls = MaximumConcurrentCalls;
    // if we are provided the default number, then we don't really care -
    // play for optimal performance
    if (MaximumConcurrentCalls == RPC_C_LISTEN_MAX_CALLS_DEFAULT)
        fAccountForMaxCalls = FALSE;
    this->MinimumCallThreads = MinimumCallThreads;
    AvailableCallCount.SetInteger( MaximumConcurrentCalls );

    RpcAddressDictionary.Reset(cursor);
    while ( (RpcAddress = RpcAddressDictionary.Next(cursor)) != 0 )
        {
        Status = RpcAddress->ServerStartingToListen(
                                                    MinimumCallThreads,
                                                    MaximumConcurrentCalls);
        if (Status)
            {
            ServerMutex.Clear();
            return(Status);
            }
        }

    StopListeningEvent.Lower();
    ServerListeningFlag = 1;
    ListeningThreadFlag = 1;

    if ( DontWait != 0 )
        {
        ServerMutex.Clear();
        return(RPC_S_OK);
        }

    WaitingThreadFlag = 1;

    ServerMutex.Clear();

    return(WaitForStopServerListening());
}


RPC_STATUS
RPC_SERVER::WaitForStopServerListening (
    )
/*++

Routine Description:

    We wait for StopServerListening to be called and then for all active
    remote procedure calls to complete before returning.

Return Value:

    RPC_S_OK - Everything worked out in the end.  All active calls
        completed successfully after RPC_SERVER::StopServerListening
        was called.  No errors occured in the transports.

--*/
{
    RPC_ADDRESS * RpcAddress;
    DictionaryCursor cursor;
    RPC_INTERFACE * RpcInterface;

    StopListeningEvent.Wait();

    if ( ListenStatusCode != RPC_S_OK )
        {
        ListeningThreadFlag = 0;
        return(ListenStatusCode);
        }

    RpcAddressDictionary.Reset(cursor);
    while ( (RpcAddress = RpcAddressDictionary.Next(cursor)) != 0 )
        {
        RpcAddress->ServerStoppedListening();
        }

    RpcAddressDictionary.Reset(cursor);
    while ( (RpcAddress = RpcAddressDictionary.Next(cursor)) != 0 )
        {
        RpcAddress->WaitForCalls();
        }

    // Wait for calls on all interfaces to complete
    RpcInterfaceDictionary.Reset(cursor);
    while ((RpcInterface = RpcInterfaceDictionary.Next(cursor)) != 0)
        {
        RpcInterface->WaitForCalls();
        }

    ServerMutex.Request();
    WaitingThreadFlag = 0;
    ListeningThreadFlag = 0;
    ServerMutex.Clear();

    return(RPC_S_OK);
}


RPC_STATUS
RPC_SERVER::WaitServerListen (
    )
/*++

Routine Description:

    This routine performs the wait that ServerListen normally performs
    when the DontWait flag is not set.  An application must call this
    routine only after RpcServerListen has been called with the DontWait
    flag set.  We do not return until RpcMgmtStopServerListening is called
    and all active remote procedure calls complete, or a fatal error occurs
    in the runtime.

Return Value:

    RPC_S_OK - Everything worked as expected.  All active remote procedure
        calls have completed.  It is now safe to exit this process.

    RPC_S_ALREADY_LISTENING - Another thread has already called
        WaitServerListen and has not yet returned.

    RPC_S_NOT_LISTENING - ServerListen has not yet been called.


--*/
{
    ServerMutex.Request();
    if ( ListeningThreadFlag == 0 )
        {
        ServerMutex.Clear();
        return(RPC_S_NOT_LISTENING);
        }

    if ( WaitingThreadFlag != 0 )
        {
        ServerMutex.Clear();
        return(RPC_S_ALREADY_LISTENING);
        }

    WaitingThreadFlag = 1;
    ServerMutex.Clear();

    return(WaitForStopServerListening());
}


void
RPC_SERVER::InquireStatistics (
    OUT RPC_STATS_VECTOR * Statistics
    )
/*++

Routine Description:

    This method is used to obtain the statistics for this rpc server.

Arguments:

    Statistics - Returns the statistics for this rpc server.

--*/
{
    Statistics->Stats[RPC_C_STATS_CALLS_IN] = IncomingRpcCount;
    Statistics->Stats[RPC_C_STATS_CALLS_OUT] = OutgoingRpcCount;
    Statistics->Stats[RPC_C_STATS_PKTS_IN] = ReceivedPacketCount;
    Statistics->Stats[RPC_C_STATS_PKTS_OUT] = SentPacketCount;
}


RPC_STATUS
RPC_SERVER::StopServerListening (
    )
/*++

Routine Description:

    This method is called to stop this rpc server from listening for
    more remote procedure calls.  Active calls are allowed to complete
    (including callbacks).  The thread which called ServerListen will
    return when all active calls complete.

Return Value:

    RPC_S_OK - The thread that called ServerListen has successfully been
        notified that it should shutdown.

    RPC_S_NOT_LISTENING - There is no thread currently listening.

--*/
{
    if (ListeningThreadFlag == 0)
        return(RPC_S_NOT_LISTENING);

    ListenStatusCode = RPC_S_OK;
    ServerListeningFlag = 0;
    StopListeningEvent.Raise();
    return(RPC_S_OK);
}


RPC_STATUS
RPC_SERVER::UseRpcProtocolSequence (
    IN RPC_CHAR PAPI * NetworkAddress,
    IN RPC_CHAR PAPI * RpcProtocolSequence,
    IN unsigned int PendingQueueSize,
    IN RPC_CHAR PAPI *Endpoint,
    IN void PAPI * SecurityDescriptor,
    IN unsigned long EndpointFlags,
    IN unsigned long NICFlags
    )
/*++

Routine Description:

    This method is who does the work of creating new address (they
    are called protocol sequences in the DCE lingo) and adding them to
    this rpc server.

Arguments:

    RpcProtocolSequence - Supplies the rpc protocol sequence we wish
        to add to this rpc server.

    PendingQueueSize - Supplies the size of the queue of pending
        requests which should be created by the transport.  Some transports
        will not be able to make use of this value, while others will.

    Endpoint - Optionally supplies an endpoint to be used for the new
        address.  If an endpoint is not specified, then we will let
        the transport specify the endpoint.

    SecurityDescriptor - Optionally supplies a security descriptor to
        be placed on the rpc protocol sequence (address) we are adding
        to this rpc server.

Return Value:

    RPC_S_OK - The requested rpc protocol sequence has been added to
        this rpc server.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to add the
        requested rpc protocol sequence to this rpc server.

    RPC_S_PROTSEQ_NOT_SUPPORTED - The specified rpc protocol sequence
        is not supported (but it appears to be valid).

    RPC_S_INVALID_RPC_PROTSEQ - The specified rpc protocol sequence is
        syntactically invalid.

    RPC_S_DUPLICATE_ENDPOINT - The supplied endpoint has already been
        added to this rpc server.

    RPC_S_INVALID_SECURITY_DESC - The supplied security descriptor is
        invalid.

--*/
{
    TRANS_INFO *ServerTransInfo ;
    RPC_STATUS Status;
    RPC_ADDRESS * RpcAddress;
    RPC_ADDRESS * Address;
    NETWORK_ADDRESS_VECTOR *pNetworkAddressVector;
    unsigned int StaticEndpointFlag;
    int Key;
    DictionaryCursor cursor;
    THREAD *ThisThread;

    ThisThread = ThreadSelf();
    if (ThisThread == NULL)
        return RPC_S_OUT_OF_MEMORY;

    // remove old EEInfo
    RpcpPurgeEEInfo();

    if (IsServerSideDebugInfoEnabled())
        {
        Status = InitializeServerSideCellHeapIfNecessary();
        if (Status != RPC_S_OK)
            return Status;
        }

    if ( RpcpStringCompare(RpcProtocolSequence,
                RPC_CONST_STRING("ncalrpc")) == 0 )
        {
        RpcAddress = LrpcCreateRpcAddress();
        }
    else if ( RpcpStringNCompare(
                            RPC_CONST_STRING("ncadg_"),
                            RpcProtocolSequence,
                            6) == 0)
        {

        //
        // Just use the osf mapping...it simply calls the
        // protocol-independent ones.
        //

        Status = OsfMapRpcProtocolSequence(1,
                                           RpcProtocolSequence,
                                           &ServerTransInfo);

        if (Status != RPC_S_OK)
            {
            return Status;
            }

        RpcAddress = DgCreateRpcAddress(ServerTransInfo);
        }
    else if ( RpcpStringNCompare(
                            RPC_CONST_STRING("ncacn_"),
                            RpcProtocolSequence,
                            6) == 0)
        {
        Status = OsfMapRpcProtocolSequence(1,
                                           RpcProtocolSequence,
                                           &ServerTransInfo);
        if (Status != RPC_S_OK)
            {
            return(Status);
            }

        RpcAddress = OsfCreateRpcAddress(ServerTransInfo);
        }
    else
        {
        return(RPC_S_PROTSEQ_NOT_SUPPORTED);
        }

    if (RpcAddress == 0)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    if (ARGUMENT_PRESENT(Endpoint))
        {
        ServerMutex.Request();

        RpcAddressDictionary.Reset(cursor);
        while ((Address = RpcAddressDictionary.Next(cursor)) != 0)
            {
            if ( Address->SameEndpointAndProtocolSequence(
                                                 NetworkAddress,
                                                 RpcProtocolSequence,
                                                 Endpoint) != 0 )
                {
                ServerMutex.Clear();
                delete RpcAddress;
                return(RPC_S_DUPLICATE_ENDPOINT);
                }
            }
        ServerMutex.Clear();

        Endpoint = DuplicateString(Endpoint);
        if (Endpoint == 0)
            {
            delete RpcAddress;
            return(RPC_S_OUT_OF_MEMORY);
            }

        StaticEndpointFlag = 1;
        }
    else
        {
        //
        // MACBUG:
        // We need to include this for Macintosh/Win95 also...
        //
        ServerMutex.Request() ;
        RpcAddressDictionary.Reset(cursor) ;
        while ((Address = RpcAddressDictionary.Next(cursor)) != 0)
            {
            if ( Address->SameProtocolSequence(NetworkAddress,
                RpcProtocolSequence) != 0 )
                {
                ServerMutex.Clear();
                delete RpcAddress;

                return(RPC_S_OK);
                }
            }
        ServerMutex.Clear();

        StaticEndpointFlag = 0;
        } // else

    if (EndpointFlags & RPC_C_DONT_FAIL)
        {
        RpcAddress->PnpNotify();
        }

    Status = RpcAddress->ServerSetupAddress(
                                            NetworkAddress,
                                            &Endpoint,
                                            PendingQueueSize,
                                            SecurityDescriptor,
                                            EndpointFlags,
                                            NICFlags,
                                            &pNetworkAddressVector);

    if (Status == RPC_S_OK)
        {
        RPC_CHAR *MyNetworkAddress = NULL;

        RpcProtocolSequence = DuplicateString(RpcProtocolSequence);

        if (RpcProtocolSequence == 0)
            {
            delete Endpoint;
            delete RpcAddress;

            return(RPC_S_OUT_OF_MEMORY);
            }

        if (ARGUMENT_PRESENT(NetworkAddress))
            {
            MyNetworkAddress = DuplicateString(NetworkAddress);
            if (MyNetworkAddress == 0)
                {
                delete Endpoint;
                delete RpcAddress;
                delete RpcProtocolSequence;

                return(RPC_S_OUT_OF_MEMORY);
                }
            }

        Status = RpcAddress->SetEndpointAndStuff(
                                        MyNetworkAddress,
                                        Endpoint,
                                        RpcProtocolSequence,
                                        this,
                                        StaticEndpointFlag,
                                        PendingQueueSize,
                                        SecurityDescriptor,
                                        EndpointFlags,
                                        NICFlags,
                                        pNetworkAddressVector);
        if (Status != RPC_S_OK)
            {
            delete RpcAddress;

            return Status;
            }
        }
    else
        {
        if (EndpointFlags & RPC_C_DONT_FAIL)
            {
            int retval;

            RPC_CHAR *MyNetworkAddress = NULL;

            RpcProtocolSequence = DuplicateString(RpcProtocolSequence);

            if (RpcProtocolSequence == 0)
                {
                delete Endpoint;
                delete RpcAddress;

                return(RPC_S_OUT_OF_MEMORY);
                }

            if (ARGUMENT_PRESENT(NetworkAddress))
                {
                MyNetworkAddress = DuplicateString(NetworkAddress);
                if (MyNetworkAddress == 0)
                    {
                    delete Endpoint;
                    delete RpcAddress;
                    delete RpcProtocolSequence;

                    return(RPC_S_OUT_OF_MEMORY);
                    }
                }

            Status = RpcAddress->SetEndpointAndStuff(
                                            MyNetworkAddress,
                                            Endpoint,
                                            RpcProtocolSequence,
                                            this,
                                            StaticEndpointFlag,
                                            PendingQueueSize,
                                            SecurityDescriptor,
                                            EndpointFlags,
                                            NICFlags,
                                            NULL);
            if (Status != RPC_S_OK)
                {
                delete Endpoint;
                delete RpcAddress;

                return Status;
                }

            ServerMutex.Request();
            retval = RpcDormantAddresses.PutOnQueue(RpcAddress, 0);
            ServerMutex.Clear();

            if (retval == 1)
                {
                delete Endpoint;
                delete RpcAddress;

                return RPC_S_OUT_OF_MEMORY;
                }

            ServerMutex.Request();
            Status = RpcAddress->ServerStartingToListen(
                                                MinimumCallThreads,
                                                MaximumConcurrentCalls);
            ServerMutex.Clear();

            if (Status)
                {
                return(Status);
                }

            return RPC_S_OK;
            }
        else
            {
            delete RpcAddress;

            return(Status);
            }
        }

    Key = AddAddress(RpcAddress);
    if (Key == -1)
        {
        delete RpcAddress;

        return(RPC_S_OUT_OF_MEMORY);
        }

    RpcAddress->DictKey = Key;

    ServerMutex.Request();
    Status = RpcAddress->ServerStartingToListen(
                                                MinimumCallThreads,
                                                MaximumConcurrentCalls);
    ServerMutex.Clear();

    if (Status)
        {
        return(Status);
        }

    //
    // Inform the transport that it can start.
    //
    RpcAddress->CompleteListen() ;

    return(RPC_S_OK);
}


int
RPC_SERVER::AddAddress (
    IN RPC_ADDRESS * RpcAddress
    )
/*++

Routine Description:

    This method is used to add an rpc address to the dictionary of
    rpc addresses know about by this rpc server.

Arguments:

    RpcAddress - Supplies the rpc address to be inserted into the
        dictionary of rpc addresses.

Return Value:

    RPC_S_OK - The supplied rpc address has been successfully added
        to the dictionary.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to insert
        the rpc address into the dictionary.

--*/
{
    int Key;
    ServerMutex.Request();
    Key = RpcAddressDictionary.Insert(RpcAddress);
    ServerMutex.Clear();
    return(Key);
}


RPC_STATUS
RPC_SERVER::UnregisterIf (
    IN RPC_SERVER_INTERFACE PAPI * RpcInterfaceInformation OPTIONAL,
    IN RPC_UUID PAPI * ManagerTypeUuid OPTIONAL,
    IN unsigned int WaitForCallsToComplete
    )
/*++

Routine Description:

    This method does the work of unregistering an interface from this
    rpc server.  We actually do not remove the interface; what we do
    is to one or all of the manager entry point vector depending upon
    the type uuid argument supplied.

Arguments:

    RpcInterfaceInformation - Supplies a description of the interface
        for which we want to unregister one or all manager entry point
        vectors.

    ManagerTypeUuid - Optionally supplies the type uuid of the manager
        entry point vector to be removed.  If this argument is not supplied,
        then all manager entry point vectors for this interface will
        be removed.

    WaitForCallsToComplete - Supplies a flag indicating whether or not
        this routine should wait for all calls to complete using the
        interface and manager being unregistered.  A non-zero value
        indicates to wait.

Return Value:

    RPC_S_OK - The manager entry point vector(s) are(were) successfully
        removed from the specified interface.

    RPC_S_UNKNOWN_MGR_TYPE - The specified type uuid is not registered
        with the interface.

    RPC_S_UNKNOWN_IF - The specified interface is not registered with
        the rpc server.

--*/
{
    RPC_INTERFACE * RpcInterface;
    RPC_STATUS RpcStatus;
    RPC_STATUS Status;
    int i;
    DictionaryCursor cursor;

    UNUSED(WaitForCallsToComplete);

    if (ARGUMENT_PRESENT(RpcInterfaceInformation))
        {
        ServerMutex.Request();
        RpcInterface = FindInterface(RpcInterfaceInformation);
        ServerMutex.Clear();
        if (RpcInterface == 0)
            return(RPC_S_UNKNOWN_IF);

        if (RpcInterface->IsAutoListenInterface())
            {
            GlobalRpcServer->DecrementAutoListenInterfaceCount() ;

            while ( RpcInterface->InqAutoListenCallCount() )
                {
                RPC_ADDRESS * Address;

                ServerMutex.Request();

                RpcAddressDictionary.Reset(cursor);
                while (0 != (Address = RpcAddressDictionary.Next(cursor)))
                    {
                    Address->EncourageCallCleanup(RpcInterface);
                    }
                ServerMutex.Clear();

                PauseExecution(500);
                }
            }

        return(RpcInterface->UnregisterManagerEpv(ManagerTypeUuid,
                WaitForCallsToComplete));
        }

    Status = RPC_S_UNKNOWN_MGR_TYPE;

    ServerMutex.Request();
    RpcInterfaceDictionary.Reset(cursor);
    while ((RpcInterface = RpcInterfaceDictionary.Next(cursor)) != 0)
        {
        // auto-listen intefaces have to be individually unregistered
        if (RpcInterface->IsAutoListenInterface())
            {
            continue;
            }

        RpcStatus = RpcInterface->UnregisterManagerEpv(ManagerTypeUuid,
                WaitForCallsToComplete);
        if (RpcStatus == RPC_S_OK)
            {
            Status = RPC_S_OK;
            }
        }
    ServerMutex.Clear();

    return(Status);
}


RPC_STATUS
RPC_SERVER::InquireManagerEpv (
    IN RPC_SERVER_INTERFACE PAPI * RpcInterfaceInformation,
    IN RPC_UUID PAPI * ManagerTypeUuid, OPTIONAL
    OUT RPC_MGR_EPV PAPI * PAPI * ManagerEpv
    )
/*++

Routine Description:

    This method is used to obtain the manager entry point vector for
    an interface supported by this rpc server.  A type uuid argument
    specifies which manager entry point vector is to be obtained.

Arguments:

    RpcInterfaceInformation - Supplies a description of the interface.

    ManagerTypeUuid - Optionally supplies the type uuid of the manager
        entry point vector we want returned.  If no manager type uuid
        is specified, then the null uuid is assumed.

    ManagerEpv - Returns the manager entry point vector.

Return Value:

    RPC_S_OK - The manager entry point vector has successfully been
        returned.

    RPC_S_UNKNOWN_MGR_TYPE - The specified type uuid is not registered
        with the interface.

    RPC_S_UNKNOWN_IF - The specified interface is not registered with
        the rpc server.

--*/
{
    RPC_INTERFACE * RpcInterface;

    ServerMutex.Request();
    RpcInterface = FindInterface(RpcInterfaceInformation);
    ServerMutex.Clear();
    if (RpcInterface == 0)
        return(RPC_S_UNKNOWN_IF);

    return(RpcInterface->InquireManagerEpv(ManagerTypeUuid, ManagerEpv));
}





RPC_STATUS
RPC_SERVER::InquireBindings (
    OUT RPC_BINDING_VECTOR PAPI * PAPI * BindingVector
    )
/*++

Routine Description:

    For each rpc protocol sequence registered with this rpc server
    we want to create a binding handle which can be used to make
    remote procedure calls using the registered rpc protocol sequence.
    We return a vector of these binding handles.

Arguments:

    BindingVector - Returns the vector of binding handles.

Return Value:

    RPC_S_OK - At least one rpc protocol sequence has been registered
        with this rpc server, and the operation completed successfully.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete
        the operation.

    RPC_S_NO_BINDINGS - No rpc protocol sequences have been successfully
        registered with this rpc server.

--*/
{
    RPC_BINDING_VECTOR PAPI * RpcBindingVector;
    unsigned int Index, RpcAddressIndex;
    RPC_ADDRESS * RpcAddress;
    BINDING_HANDLE * BindingHandle;
    int i ;
    RPC_CHAR PAPI * LocalNetworkAddress;
    int count = 0 ;
    DictionaryCursor cursor;

    ServerMutex.Request();
    if (RpcAddressDictionary.Size() == 0
        && RpcDormantAddresses.IsQueueEmpty())
        {
        ServerMutex.Clear();
        return(RPC_S_NO_BINDINGS);
        }


    RpcAddressDictionary.Reset(cursor);
    while ((RpcAddress = RpcAddressDictionary.Next(cursor)) != 0)
        {
        count += RpcAddress->InqNumNetworkAddress();
        }

    RpcBindingVector = (RPC_BINDING_VECTOR PAPI *) RpcpFarAllocate(
            sizeof(RPC_BINDING_VECTOR) + (count -1 )
            * sizeof(RPC_BINDING_HANDLE) );
    if (RpcBindingVector == 0)
        {
        ServerMutex.Clear();
        return(RPC_S_OUT_OF_MEMORY);
        }

    RpcBindingVector->Count = count;
    for (Index = 0; Index < RpcBindingVector->Count; Index++)
        RpcBindingVector->BindingH[Index] = 0;

    Index = 0;
    RpcAddressDictionary.Reset(cursor);
    while ((RpcAddress = RpcAddressDictionary.Next(cursor)) != 0)
        {
        RpcAddressIndex = 0;
        LocalNetworkAddress = RpcAddress->
                               GetListNetworkAddress(RpcAddressIndex) ;

        while(LocalNetworkAddress != NULL)
            {
            BindingHandle = RpcAddress->
                             InquireBinding(LocalNetworkAddress);
            if (BindingHandle == 0)
                {
                ServerMutex.Clear();
                RpcBindingVectorFree(&RpcBindingVector);
                return(RPC_S_OUT_OF_MEMORY);
                }
            RpcBindingVector->BindingH[Index] = BindingHandle;
            Index += 1;
            RpcAddressIndex += 1;
            LocalNetworkAddress = RpcAddress->
                                   GetListNetworkAddress(RpcAddressIndex) ;
            }
        }
    ServerMutex.Clear();

    ASSERT(Index == RpcBindingVector->Count);

    *BindingVector = RpcBindingVector;
    return(RPC_S_OK);
}


RPC_STATUS
RPC_SERVER::RegisterAuthInfoHelper (
    IN RPC_CHAR PAPI * ServerPrincipalName,
    IN unsigned long AuthenticationService,
    IN RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFunction, OPTIONAL
    IN void PAPI * Argument OPTIONAL
    )
{
    RPC_AUTHENTICATION * Service;
    RPC_STATUS RpcStatus;
    RPC_CHAR __RPC_FAR * PrincipalName;
    DictionaryCursor cursor;

    if (ServerPrincipalName == NULL)
        {
        ServerPrincipalName = new RPC_CHAR[1];
        if (ServerPrincipalName == NULL)
            {
            return (RPC_S_OUT_OF_MEMORY);
            }
        ServerPrincipalName[0] = '\0';
        }

    if ( AuthenticationService == 0 )
        {
        return(RPC_S_UNKNOWN_AUTHN_SERVICE);
        }

    if (AuthenticationService == RPC_C_AUTHN_DEFAULT)
        {
        RpcpGetDefaultSecurityProviderInfo();
        AuthenticationService = DefaultProviderId;
        }

    ServerMutex.Request();
    AuthenticationDictionary.Reset(cursor);
    while ( (Service = AuthenticationDictionary.Next(cursor)) != 0 )
        {
        if ( Service->AuthenticationService == AuthenticationService &&
             0 == RpcpStringCompare(Service->ServerPrincipalName, ServerPrincipalName))
            {
            Service->GetKeyFunction = GetKeyFunction;
            Service->Argument = Argument;
            ServerMutex.Clear();
            // Flush the server-credentials cache
            RpcStatus = RemoveCredentialsFromCache(AuthenticationService);
            return (RpcStatus);
            }
        }

    RpcStatus = IsAuthenticationServiceSupported(AuthenticationService);
    if ( RpcStatus != RPC_S_OK )
        {
        ServerMutex.Clear();
        if ( (RpcStatus == RPC_S_UNKNOWN_AUTHN_SERVICE) ||
             (RpcStatus == RPC_S_UNKNOWN_AUTHN_LEVEL) )
            {
            return (RPC_S_UNKNOWN_AUTHN_SERVICE);
            }
        else
            {
            return (RPC_S_OUT_OF_MEMORY);
            }
        }

    Service = new RPC_AUTHENTICATION;
    if ( Service == 0 )
        {
        ServerMutex.Clear();
        return(RPC_S_OUT_OF_MEMORY);
        }
    Service->AuthenticationService = AuthenticationService;
    Service->ServerPrincipalName = DuplicateString(ServerPrincipalName);
    Service->GetKeyFunction = GetKeyFunction;
    Service->Argument = Argument;
    if ( Service->ServerPrincipalName == 0 )
        {
        ServerMutex.Clear();
        delete Service;
        return(RPC_S_OUT_OF_MEMORY);
        }
    if ( AuthenticationDictionary.Insert(Service) == -1 )
        {
        ServerMutex.Clear();
        delete Service;
        return(RPC_S_OUT_OF_MEMORY);
        }
    ServerMutex.Clear();
    return(RPC_S_OK);
}


RPC_STATUS
RPC_SERVER::AutoRegisterAuthSvc(
    IN RPC_CHAR * ServerPrincipalName,
    IN unsigned long AuthenticationService
    )
{
    RPC_STATUS Status;
    DictionaryCursor cursor;
    RPC_AUTHENTICATION * Service;

    //
    // Don't need to auto-register the provider if it is already registered
    //
    ServerMutex.Request();
    AuthenticationDictionary.Reset(cursor);
    while ( (Service = AuthenticationDictionary.Next(cursor)) != 0 )
        {
        if ( Service->AuthenticationService == AuthenticationService)
            {
            ServerMutex.Clear();
            return (RPC_S_OK);
            }
        }
    ServerMutex.Clear();

    Status = RegisterAuthInfoHelper(ServerPrincipalName,
                                    AuthenticationService,
                                    NULL,
                                    NULL);
    if (Status == RPC_S_UNKNOWN_AUTHN_SERVICE)
        {
        //
        // Ok to not register provider if it is disabled
        //
        return RPC_S_OK;
        }

    return Status;
}


RPC_STATUS
RPC_SERVER::RegisterAuthInformation (
    IN RPC_CHAR PAPI * ServerPrincipalName,
    IN unsigned long AuthenticationService,
    IN RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFunction, OPTIONAL
    IN void PAPI * Argument OPTIONAL
    )
/*++

Routine Description:

    This method is used to register authentication, authorization, and
    a server principal name to be used for security for this server.  We
    will use this information to authenticate remote procedure calls.

Arguments:

    ServerPrincipalName - Supplies the principal name for the server.

    AuthenticationService - Supplies an authentication service to use when
        the server receives a remote procedure call.

    GetKeyFunction - Optionally supplies a routine to be used when the runtime
        needs an encryption key.

    Argument - Optionally supplies an argument to be passed to the routine used
        to get keys each time it is called.

Return Value:

    RPC_S_OK - The authentication service and server principal name have
        been registered with this RPC server.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete the
        operation.

    RPC_S_UNKNOWN_AUTHN_SERVICE - The specified authentication service is
        not supported.

--*/
{
    RPC_STATUS Status;
    RPC_CHAR *PrincName;

    Status = RegisterAuthInfoHelper(ServerPrincipalName,
                                    AuthenticationService,
                                    GetKeyFunction,
                                    Argument);
    if (Status != RPC_S_OK)
        {
        return Status;
        }

    if (AuthenticationService != RPC_C_AUTHN_GSS_NEGOTIATE)
        {
        return RPC_S_OK;
        }

    Status = AutoRegisterAuthSvc(ServerPrincipalName, RPC_C_AUTHN_WINNT);
    if (Status != RPC_S_OK)
        {
        return Status;
        }

    Status = AutoRegisterAuthSvc(ServerPrincipalName, RPC_C_AUTHN_GSS_KERBEROS);

    return Status;
}


RPC_STATUS
RPC_SERVER::AcquireCredentials (
    IN unsigned long AuthenticationService,
    IN unsigned long AuthenticationLevel,
    OUT SECURITY_CREDENTIALS ** SecurityCredentials
    )
/*++

Routine Description:

    The protocol modules will use this to obtain a set of credentials
    for the specified authentication service, assuming that the server
    supports them.

Arguments:

    AuthenticationService - Supplies the authentication service for which
        we hope to obtain credentials.

    AuthenticationLevel - Supplies the authentication level to be used.

    SecurityCredentials - Returns the security credentials.

Return Value:

    RPC_S_OK - You have been given some security credentials, which you need
         to free using RPC_SERVER::FreeCredentials when you are done with
         them.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete the
        operation.

    RPC_S_UNKNOWN_AUTHN_SERVICE - The specified authentication service is
        not supported by the current configuration.

--*/
{
    RPC_AUTHENTICATION * Service;
    RPC_STATUS RpcStatus = RPC_S_OK;
    DictionaryCursor cursor;

    ServerMutex.Request();
    AuthenticationDictionary.Reset(cursor);
    while ( (Service = AuthenticationDictionary.Next(cursor)) != 0 )
        {
        if ( Service->AuthenticationService == AuthenticationService )
            {
            ServerMutex.Clear();

            RpcStatus = FindServerCredentials(
                            Service->GetKeyFunction,
                            Service->Argument,
                            AuthenticationService,
                            AuthenticationLevel,
                            Service->ServerPrincipalName,
                            SecurityCredentials
                            );

            VALIDATE(RpcStatus)
                {
                RPC_S_OK,
                RPC_S_SEC_PKG_ERROR,
                RPC_S_OUT_OF_MEMORY,
                RPC_S_INVALID_AUTH_IDENTITY,
                ERROR_SHUTDOWN_IN_PROGRESS,
                RPC_S_UNKNOWN_AUTHN_SERVICE
                } END_VALIDATE;
            return(RpcStatus);
            }
        }

    ServerMutex.Clear();
    return(RPC_S_UNKNOWN_AUTHN_SERVICE);
}


void
RPC_SERVER::FreeCredentials (
    IN SECURITY_CREDENTIALS * SecurityCredentials
    )
/*++

Routine Description:

    A protocol module will indicate that it is through using a set of
    security credentials, obtained from RPC_SERVER::AcquireCredentials,
    using this routine.

Arguments:

    SecurityCredentials - Supplies the security credentials to be freed.

--*/
{
    SecurityCredentials->FreeCredentials();
    delete SecurityCredentials;
}


RPC_STATUS
RPC_SERVER::RegisterInterface (
    IN RPC_SERVER_INTERFACE PAPI * RpcInterfaceInformation,
    IN RPC_UUID PAPI * ManagerTypeUuid,
    IN RPC_MGR_EPV PAPI * ManagerEpv,
    IN unsigned int Flags,
    IN unsigned int MaxCalls,
    IN unsigned int MaxRpcSize,
    IN RPC_IF_CALLBACK_FN PAPI *IfCallbackFn
    )
/*++

Routine Description:

    This routine is used by server application to register a manager
    entry point vector and optionally an interface.  If the interface
    has not been registered, then it will be registered.  If it has
    already been registered, the manager entry point vector will be
    added to it under the specified type uuid.

Arguments:

    RpcInterfaceInformation - Supplies a description of the interface to
        be registered.  We will make a copy of this information.

    ManagerTypeUuid - Optionally supplies the type uuid for the specified
        manager entry point vector.  If no type uuid is supplied, then
        the null uuid will be used as the type uuid.

    ManagerEpv - Optionally supplies a manager entry point vector corresponding
        to the type uuid.  If a manager entry point vector is not supplied,
        then the manager entry point vector in the interface will be
        used.

Return Value:

    RPC_S_OK - The specified rpc interface has been successfully
        registered with the rpc server.  It is now ready to accept
        remote procedure calls.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to register
        the rpc interface with the rpc server.

    RPC_S_TYPE_ALREADY_REGISTERED - A manager entry point vector has
        already been registered for the supplied rpc interface and
        manager type UUID.

--*/
{
    RPC_STATUS RpcStatus;
    RPC_INTERFACE * RpcInterface;
    RPC_ADDRESS *RpcAddress ;
    DictionaryCursor cursor;
    BOOL fInterfaceFound;

    if ( ManagerEpv == 0 )
        {

        ManagerEpv = RpcInterfaceInformation->DefaultManagerEpv;

        if ( (PtrToUlong(ManagerEpv)) == 0xFFFFFFFF)
            {
            // Stub compiled with -no_default_epv.
            return (RPC_S_INVALID_ARG);
            }
        }

    ServerMutex.Request();
    RpcInterface = FindOrCreateInterfaceInternal(RpcInterfaceInformation, Flags, MaxCalls,
        MaxRpcSize, IfCallbackFn, &RpcStatus, &fInterfaceFound);
    if (RpcInterface == NULL)
        {
        ServerMutex.Clear();
        return RpcStatus;
        }

    if (fInterfaceFound)
        {
        // if it was found, update the information
        RpcStatus = RpcInterface->UpdateRpcInterfaceInformation(RpcInterfaceInformation,
                                            Flags, MaxCalls, MaxRpcSize, IfCallbackFn);
        if (RpcStatus != RPC_S_OK)
            {
            ServerMutex.Clear();
            return RpcStatus;
            }
        }

    RpcStatus = RpcInterface->RegisterTypeManager(ManagerTypeUuid, ManagerEpv);

    if (Flags & RPC_IF_AUTOLISTEN)
        {

        RpcAddressDictionary.Reset(cursor);
        while ( (RpcAddress = RpcAddressDictionary.Next(cursor)) != 0 )
            {
            RpcStatus = RpcAddress->ServerStartingToListen(
                                       this->MinimumCallThreads,
                                       MaxCalls);
            if (RpcStatus != RPC_S_OK)
                {
                break;
                }
            }
        }

    ServerMutex.Clear();
    return(RpcStatus);
}


void RPC_SERVER::CreateOrUpdateAddresses (void)
/*++
Function Name: CreateOrUpdateAddresses

Parameters:

Description:
    The runtime just received a notification that a new protocol was loaded. We need
    to create an ADDRESS object, listen on it and update the RPCSS bindings
    appropriately.

Returns:

--*/
{
    RPC_STATUS Status;
    RPC_BINDING_VECTOR *BindingVector = 0;
    RPC_INTERFACE * RpcInterface;
    BOOL fChanged = 0;
    RPC_ADDRESS *Address;
    QUEUE tempQueue;
    BOOL fTempQueueHasContents = FALSE;
    int i;
    DictionaryCursor cursor;

    while (1)
        {
        unsigned int Length;

        ServerMutex.Request();
        Address = (RPC_ADDRESS *) RpcDormantAddresses.TakeOffQueue(&Length);
        ServerMutex.Clear();

        if (Address == 0)
            {
            break;
            }

        ASSERT(Length == 0);

        if (Address->RestartAddress(MinimumCallThreads,
                                    MaximumConcurrentCalls) != RPC_S_OK)
            {
            fTempQueueHasContents = TRUE;
            if (tempQueue.PutOnQueue(Address, 0) != 0)
                {
                // putting on the temporary queue failed - out of memory
                // in this case we'd rather cut the PnP process for now, and we'll
                // go with what we have
                // return the address
                ServerMutex.Request();
                // guaranteed to succeed
                RpcDormantAddresses.PutOnQueue(Address, 0);
                ServerMutex.Clear();
                // break into merging the temp queue with the permanent one
                break;
                }
            }
        else
            {
            fChanged = 1;
            }
        }

    if (fTempQueueHasContents)
        {
        ServerMutex.Request();
        // merge back the queues - this should succeed if we have only added protocols. If we have
        // removed protocols, this will fail, and we'll have a bug. Nothing we can do about it here.
        RpcDormantAddresses.MergeWithQueue(&tempQueue);
        ServerMutex.Clear();
        }

    if (fChanged)
        {

        ServerMutex.Request();

        //
        // Inquire the new bindings, and update them in the endpoint mapper
        //
        Status = InquireBindings(&BindingVector);
        if (Status != RPC_S_OK)
            {
            goto Cleanup;
            }

        RpcInterfaceDictionary.Reset(cursor);

        while ((RpcInterface = RpcInterfaceDictionary.Next(cursor)) != 0)
            {
            if (RpcInterface->NeedToUpdateBindings())
                {
                // we know an interface never gets deleted, only marked as
                // unregistered. Therefore, it is safe to release the mutex
                // and do the slow UpdateBindings outside the mutex
                ServerMutex.Clear();
                if ((Status = RpcInterface->UpdateBindings(BindingVector))
                    != RPC_S_OK)
                    {
                    goto Cleanup;
                    }
                ServerMutex.Request();
                }
            }
        ServerMutex.Clear();

        Status = RpcBindingVectorFree(&BindingVector);
        ASSERT(Status == RPC_S_OK);
        }

    return;

Cleanup:
    if (BindingVector)
        {
        Status = RpcBindingVectorFree(&BindingVector);
        ASSERT(Status == RPC_S_OK);
        }
}

RPC_INTERFACE *
RPC_SERVER::FindOrCreateInterfaceInternal (
    IN RPC_SERVER_INTERFACE PAPI * RpcInterfaceInformation,
    IN unsigned int Flags,
    IN unsigned int MaxCalls,
    IN unsigned int MaxRpcSize,
    IN RPC_IF_CALLBACK_FN PAPI *IfCallbackFn,
    OUT RPC_STATUS *Status,
    OUT BOOL *fInterfaceFound
    )
/*++
Function Name: FindOrCreateInterfaceInternal

Parameters:
    RpcInterfaceInformation
    Flags
    MaxCalls
    MaxRpcSize
    IfCallbackFn
    Status - meaningless if the return value is not NULL.
    fInterfaceFound - TRUE if the interface was found, FALSE if it was created

Description:
    Find or creates an interface with the appropriate parameters

Returns:

--*/
{
    RPC_INTERFACE * RpcInterface;

    ServerMutex.VerifyOwned();

    RpcInterface = FindInterface(RpcInterfaceInformation);
    if ( RpcInterface == 0 )
        {
        RpcInterface = new RPC_INTERFACE(RpcInterfaceInformation,
                                            this, Flags, MaxCalls, MaxRpcSize, IfCallbackFn, Status);
        if ( RpcInterface == 0 )
            {
            *Status = RPC_S_OUT_OF_MEMORY;
            return NULL;
            }
        if ( AddInterface(RpcInterface) != 0 )
            {
            delete RpcInterface;
            *Status = RPC_S_OUT_OF_MEMORY;
            return NULL;
            }
        if (Flags & RPC_IF_AUTOLISTEN)
            {
            GlobalRpcServer->IncrementAutoListenInterfaceCount() ;
            }
        *fInterfaceFound = FALSE;
        }
    else
        {
        *fInterfaceFound = TRUE;
        }

    *Status = RPC_S_OK;
    return RpcInterface;

}


RPC_INTERFACE *
RPC_SERVER::FindOrCreateInterface (
    IN RPC_SERVER_INTERFACE PAPI * RpcInterfaceInformation,
    OUT RPC_STATUS *Status
    )
{
    RPC_INTERFACE * RpcInterface;
    BOOL fIgnored;

    ServerMutex.Request();
    RpcInterface = FindOrCreateInterfaceInternal(RpcInterfaceInformation,
        RPC_IF_ALLOW_SECURE_ONLY, 0, gMaxRpcSize, NULL, Status, &fIgnored);
    ServerMutex.Clear();

    return RpcInterface;
}


RPC_STATUS
RPC_SERVER::InterfaceExported (
    IN RPC_SERVER_INTERFACE PAPI * RpcInterfaceInformation,
    IN UUID_VECTOR *MyObjectUuidVector,
    IN unsigned char *MyAnnotation,
    IN BOOL MyfReplace
    )
/*++
Function Name:InterfaceExported

Parameters:

Description:
    RpcEpRegister was called on this interface. We need to keep track
    of the parameters, so that if we get a PNP notification, we can update
    the bindings using there params

Returns:

--*/
{
    RPC_INTERFACE * RpcInterface;
    RPC_STATUS Status;

    RpcInterface = FindOrCreateInterface (RpcInterfaceInformation, &Status);
    if (RpcInterface == NULL)
        {
        return Status;
        }

    return RpcInterface->InterfaceExported(
                                           MyObjectUuidVector,
                                           MyAnnotation,
                                           MyfReplace);
}

#if !defined(NO_LOCATOR_CODE)

RPC_STATUS
RPC_SERVER::NsInterfaceExported (
    IN unsigned long EntryNameSyntax,
    IN RPC_CHAR *EntryName,
    IN RPC_SERVER_INTERFACE PAPI * RpcInterfaceInformation,
    IN BOOL fUnexport
    )
{
    RPC_INTERFACE * RpcInterface;
    RPC_STATUS Status;
    HMODULE hLocator;

    if (pNsBindingExport == 0)
        {
        hLocator = LoadLibrary ((const RPC_SCHAR *)RPC_CONST_STRING("rpcns4.dll"));
        if (hLocator == 0)
            {
            return RPC_S_OUT_OF_MEMORY;
            }

        pNsBindingExport = (NS_EXPORT_FUNC) GetProcAddress(hLocator,
                                          "RpcNsBindingExportW");
        if (pNsBindingExport == 0)
            {
            return RPC_S_OUT_OF_MEMORY;
            }

        pNsBindingUnexport = (NS_UNEXPORT_FUNC) GetProcAddress(hLocator,
                                            "RpcNsBindingUnexportW");
        if (pNsBindingUnexport == 0)
            {
            pNsBindingExport = 0;
            return RPC_S_OUT_OF_MEMORY;
            }
        }

    RpcInterface = FindOrCreateInterface (RpcInterfaceInformation, &Status);
    if (RpcInterface == NULL)
        {
        return Status;
        }

    if (fUnexport == 0)
        {
        return RpcInterface->NsInterfaceExported(
                                                 EntryNameSyntax,
                                                 EntryName);
        }
    else
        {
        return RpcInterface->NsInterfaceUnexported(
                                                 EntryNameSyntax,
                                                 EntryName);
        }
}
#endif

RPC_STATUS
RPC_SERVER::EnumerateAndCallEachAddress (
    IN AddressCallbackType actType,
    IN OUT void *Context OPTIONAL
    )
/*++
Function Name:  DestroyContextHandlesForInterface

Parameters:
    actType - the type of callback.
    Context - opaque memory block to be passed to the callback.

Description:
    This function is called when we want to invoke a specific method
    on each address.

Returns:
    RPC_S_OK for success or RPC_S_* for error

--*/
{
    RPC_ADDRESS_DICT AddressDict;
    RPC_ADDRESS_DICT *AddressDictToUse;
    RPC_ADDRESS *CurrentAddress;
    BOOL UsingAddressDictionaryCopy;
    int Result;
    DictionaryCursor cursor;
    DestroyContextHandleCallbackContext *ContextHandleContext;

    // try to copy all entries in the address dictionary to the local
    // dictionary. We will walk the address list from there to avoid
    // holding the server mutex while walking potentially large tree.
    // If we do that, only the page faults will be enough to kill the
    // server. On the other hand, we can't rely that the memory will be
    // there. Therefore, we attempt to copy the dictionary under the
    // mutex, but if this fails, we will retain the mutex and go ahead
    // with the cleanup. The logic behind this is that if we don't have
    // the few bytes to copy the dictionary, probably the server isn't
    // doing anything, and holding the mutex won't hurt it anymore

    ServerMutex.Request();

#if DBG
    if (actType == actDestroyContextHandle)
        {
        RPC_INTERFACE *Interface;

        ContextHandleContext = (DestroyContextHandleCallbackContext *)Context;
        Interface = FindInterface(ContextHandleContext->RpcInterfaceInformation);
        ASSERT(Interface);
        // the interface must use strict context handles
        ASSERT(Interface->DoesInterfaceUseNonStrict() == FALSE);
        }
#endif

    UsingAddressDictionaryCopy = AddressDict.ExpandToSize(RpcAddressDictionary.Size());

    if (UsingAddressDictionaryCopy)
        {
        AddressDictToUse = &AddressDict;

        RpcAddressDictionary.Reset(cursor);
        while ( (CurrentAddress = RpcAddressDictionary.Next(cursor)) != 0 )
            {
            // we never destroy addresses. Therefore, we don't need to mark
            // those addresses as used in any way
            Result = AddressDict.Insert(CurrentAddress);
            // this must succeed as we have reserved enough size
            ASSERT(Result != -1);
            }

        ServerMutex.Clear();
        }
    else
        {
        AddressDictToUse = &RpcAddressDictionary;
        }

    // N.B. We may, or may not have the ServerMutex here - depending on how
    // we were doing with memory
    AddressDictToUse->Reset(cursor);
    while ( (CurrentAddress = AddressDictToUse->Next(cursor)) != 0 )
        {
        switch (actType)
            {
            case actDestroyContextHandle:
                ContextHandleContext = (DestroyContextHandleCallbackContext *)Context;
                CurrentAddress->DestroyContextHandlesForInterface(
                    ContextHandleContext->RpcInterfaceInformation,
                    ContextHandleContext->RundownContextHandles
                    );
                break;

            case actCleanupIdleSContext:
                CurrentAddress->CleanupIdleSContexts();
                break;

            default:
                ASSERT(0);
            }
        }

    if (!UsingAddressDictionaryCopy)
        {
        ServerMutex.Clear();
        }

    return RPC_S_OK;
}


RPC_STATUS
RPC_ENTRY
I_RpcNsInterfaceExported (
    IN unsigned long EntryNameSyntax,
    IN unsigned short *EntryName,
    IN RPC_SERVER_INTERFACE PAPI * RpcInterfaceInformation
    )
{
#if !defined(NO_LOCATOR_CODE)
    InitializeIfNecessary();

    return (GlobalRpcServer->NsInterfaceExported(
                                                 EntryNameSyntax,
                                                 EntryName,
                                                 RpcInterfaceInformation, 0));
#else
    return RPC_S_CANNOT_SUPPORT;
#endif
}


RPC_STATUS
RPC_ENTRY
I_RpcNsInterfaceUnexported (
    IN unsigned long EntryNameSyntax,
    IN unsigned short *EntryName,
    IN RPC_SERVER_INTERFACE PAPI * RpcInterfaceInformation
    )
{
#if !defined(NO_LOCATOR_CODE)
   InitializeIfNecessary();

   return (GlobalRpcServer->NsInterfaceExported(
                                                 EntryNameSyntax,
                                                 EntryName,
                                                 RpcInterfaceInformation, 1));
#else
    return RPC_S_CANNOT_SUPPORT;
#endif
}


#define MAXIMUM_CACHED_THREAD_TIMEOUT (1000L * 60L * 60L)


void
BaseCachedThreadRoutine (
    IN CACHED_THREAD * CachedThread
    )
/*++

Routine Description:

    Each thread will execute this routine.  When it first gets called, it
    will immediately call the procedure and parameter specified in the
    cached thread object.  After that it will wait on its event and then
    execute the specified routine everytime it gets woken up.  If the wait
    on the event times out, the thread will exit unless it has been protected.

Arguments:

    CachedThread - Supplies the cached thread object to be used by this
        thread.

--*/
{
    RPC_SERVER * RpcServer = CachedThread->OwningRpcServer;
    THREAD *pThread = RpcpGetThreadPointer();
    long WaitTimeout;

    ASSERT(pThread);

    while (pThread->ThreadHandle() == (void *) -1)
        {
        Sleep(1);
        }

    ASSERT(pThread->ThreadHandle());

    CachedThread->SetThread(pThread);

    if (pThread->DebugCell)
        {
        pThread->DebugCell->TID = (unsigned short)GetCurrentThreadId();
        pThread->DebugCell->LastUpdateTime = NtGetTickCount();
        }

    for(;;)
        {
        if (CachedThread->CallProcedure())
            {
#ifdef RPC_OLD_IO_PROTECTION
            // This thread has already timed-out waiting on
            // a transport level cache.  Let it go now...
            ASSERT(pThread->InqProtectCount() == 1);
#endif

            if (pThread->IsIOPending() == FALSE)
                {
                delete CachedThread;
                return;
                }

            // we're a cached IOCP thread - we need to unjoin the IOCP
            UnjoinCompletionPort();
            }

        WaitTimeout = gThreadTimeout;

        // Now we cache this thread.  This consists of clearing the
        // work available flag and inserting the thread cache object into
        // the list thread cache objects.

        CachedThread->WorkAvailableFlag = WorkIsNotAvailable;

        RpcServer->ThreadCacheMutex.Request();
        RpcServer->InsertIntoFreeList(CachedThread);
        RpcServer->ThreadCacheMutex.Clear();

        // Now we loop waiting for work.  We get out of the loop in three
        // ways: (1) a timeout occurs and there is work to do, (2) the
        // event gets kicked because there is work to do, (3) a timeout
        // occurs, there is no work to do, and the thread is not protected.

        for (;;)
            {

            // Ignore spurious signals.
            while(      (CachedThread->WaitForWorkEvent.Wait(WaitTimeout) == 0)
                    &&  (CachedThread->WorkAvailableFlag == WorkIsNotAvailable) )
                ;


            if (CachedThread->WorkAvailableFlag == WorkIsAvailable)
                {
                break;
                }

            // We must take the lock to avoid a race condition where another
            // thread is trying to signal us right now.

            RpcServer->ThreadCacheMutex.Request();

            if (CachedThread->WorkAvailableFlag)
                {
                RpcServer->ThreadCacheMutex.Clear();
                break;
                }

            if (pThread->IsIOPending())
                {
                // If we reach here, there is no work available, and the thread
                // is protected.  We just need to wait again. There is no need to
                // busy wait if the thread is protected and it keeps timing out.

                if (WaitTimeout < MAXIMUM_CACHED_THREAD_TIMEOUT/2)
                    {
                    WaitTimeout = WaitTimeout * 2;
                    }

                // Since this thread can't exit anyway, move it to the front of the
                // free list so it will be reused first.

                RpcServer->RemoveFromFreeList(CachedThread);
                RpcServer->InsertIntoFreeList(CachedThread);

                RpcServer->ThreadCacheMutex.Clear();
                continue;
                }

            // No work available.

#ifdef RPC_OLD_IO_PROTECTION
            ASSERT(pThread->InqProtectCount() == 1);
#endif

            // There is no work available, and this thread is not
            // protected, so we can safely let it commit suicide.

            RpcServer->RemoveFromFreeList(CachedThread);
            RpcServer->ThreadCacheMutex.Clear();

            delete CachedThread;
            return;
            }

        ASSERT(CachedThread->WorkAvailableFlag == WorkIsAvailable);

        }

    NO_RETURN;
}


RPC_STATUS
RPC_SERVER::CreateThread (
    IN THREAD_PROC Procedure,
    IN void * Parameter
    )
/*++

Routine Description:

    This routine is used to create a new thread which will begin
    executing the specified procedure.  The procedure will be passed
    parameter as the argument.

Arguments:

    Procedure - Supplies the procedure which the new thread should
        begin executing.

    Parameter - Supplies the argument to be passed to the procedure.

Return Value:

    RPC_S_OK - We successfully created a new thread and started it
        executing the supplied procedure.

    RPC_S_OUT_OF_THREADS - We could not create another thread.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allocate
        the data structures we need to complete this operation.

--*/
{
    THREAD * Thread;
    CACHED_THREAD * CachedThread;
    RPC_STATUS RpcStatus = RPC_S_OK;

    ThreadCacheMutex.Request();

    CachedThread = RemoveHeadFromFreeList();
    if (CachedThread)
        {
        // set all parameters within the mutex to avoid races
        CachedThread->SetWakeUpThreadParams(Procedure, Parameter);

        ThreadCacheMutex.Clear();

        CachedThread->WakeUpThread();
        return(RPC_S_OK);
        }

    ThreadCacheMutex.Clear();

    if (IsServerSideDebugInfoEnabled())
        {
        RpcStatus = InitializeServerSideCellHeapIfNecessary();
        if (RpcStatus != RPC_S_OK)
            return RpcStatus;
        }

    CachedThread = new CACHED_THREAD(Procedure, Parameter, this, &RpcStatus);
    if ( CachedThread == 0 )
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    if ( RpcStatus != RPC_S_OK )
        {
        delete CachedThread;
        return(RpcStatus);
        }

    ASSERT( RpcStatus == RPC_S_OK );

    Thread = new THREAD((THREAD_PROC) BaseCachedThreadRoutine, CachedThread,
            &RpcStatus);

    if (Thread == 0)
        {
        delete CachedThread;
        return(RPC_S_OUT_OF_THREADS);
        }

    if (RpcStatus != RPC_S_OK)
        {
        delete CachedThread;
        delete Thread;
        if (RpcStatus == ERROR_MAX_THRDS_REACHED)
            RpcStatus = RPC_S_OUT_OF_THREADS;
        }

    return(RpcStatus);
}



RPC_STATUS
RPC_SERVER::InquireInterfaceIds (
    OUT RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * InterfaceIdVector
    )
/*++

Routine Description:

    This routine is used to obtain a vector of the interface identifiers of
    the interfaces supported by this server.

Arguments:

    IfIdVector - Returns a vector of the interfaces supported by this server.

Return Value:

    RPC_S_OK - Everything worked out just great.

    RPC_S_NO_INTERFACES - No interfaces have been registered with the runtime.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allocate
        the interface id vector.

--*/
{
    DictionaryCursor cursor;

    ServerMutex.Request();
    if (RpcInterfaceDictionary.Size() == 0)
        {
        ServerMutex.Clear();
        *InterfaceIdVector = 0;
        return RPC_S_NO_INTERFACES;
        }

    *InterfaceIdVector = (RPC_IF_ID_VECTOR __RPC_FAR *) RpcpFarAllocate(
            sizeof(RPC_IF_ID_VECTOR) + (RpcInterfaceDictionary.Size() - 1)
            * sizeof(RPC_IF_ID __RPC_FAR *));
    if ( *InterfaceIdVector == 0 )
        {
        ServerMutex.Clear();
        return(RPC_S_OUT_OF_MEMORY);
        }

    (*InterfaceIdVector)->Count = 0;
    (*InterfaceIdVector)->IfId[0] = (RPC_IF_ID __RPC_FAR *) RpcpFarAllocate(
            sizeof(RPC_IF_ID));
    RpcInterfaceDictionary.Reset(cursor);

    RPC_INTERFACE * RpcInterface;
    while ((RpcInterface = RpcInterfaceDictionary.Next(cursor)) != 0)
        {
        (*InterfaceIdVector)->IfId[(*InterfaceIdVector)->Count] =
                RpcInterface->InquireInterfaceId();
        if ( (*InterfaceIdVector)->IfId[(*InterfaceIdVector)->Count] != 0 )
            {
            RPC_IF_ID * Interface = (*InterfaceIdVector)->IfId[(*InterfaceIdVector)->Count];
            (*InterfaceIdVector)->Count += 1;
            }
        }
    ServerMutex.Clear();

    if (0 == (*InterfaceIdVector)->Count)
        {
        RpcpFarFree(*InterfaceIdVector);
        *InterfaceIdVector = 0;
        return RPC_S_NO_INTERFACES;
        }

    return(RPC_S_OK);
}


RPC_STATUS
RPC_SERVER::InquirePrincipalName (
    IN unsigned long AuthenticationService,
    OUT RPC_CHAR __RPC_FAR * __RPC_FAR * ServerPrincipalName
    )
/*++

Routine Description:

Arguments:

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete the
        operation.

    RPC_S_UNKNOWN_AUTHN_SERVICE - The specified authentication service is
        not supported.

--*/
{
    RPC_AUTHENTICATION * Service;
    DictionaryCursor cursor;

    ServerMutex.Request();
    AuthenticationDictionary.Reset(cursor);
    while ( (Service = AuthenticationDictionary.Next(cursor)) != 0 )
        {
        if ( Service->AuthenticationService == AuthenticationService )
            {
            ServerMutex.Clear();
            *ServerPrincipalName = DuplicateString(
                    Service->ServerPrincipalName);
            if ( *ServerPrincipalName == 0 )
                {
                return(RPC_S_OUT_OF_MEMORY);
                }
            return(RPC_S_OK);
            }
        }

    ServerMutex.Clear();
    return(RPC_S_UNKNOWN_AUTHN_SERVICE);
}



void
RPC_SERVER::RegisterRpcForwardFunction (
       RPC_FORWARD_FUNCTION * pForwardFunction
       )
/*++

Routine Description:
   Sets the RPC_SERVER pEpmapperForwardFunction. (The pEpmapperForwardFunction
   is the function the runtime can call when it receives a pkt for a
   dynamic endpoint. pEpmapperForwardFunction will return endpoint of
   the server to forward the pkt to).

Arguments:
   pForwardFunction - pointer to the epmapper forward function.

Return Value:
   none

--*/
{

   pRpcForwardFunction = pForwardFunction;

}


RPC_STATUS
RPC_SERVER::UnregisterEndpoint (
    IN RPC_CHAR __RPC_FAR * Protseq,
    IN RPC_CHAR __RPC_FAR * Endpoint
    )
{
    return (RPC_S_CANNOT_SUPPORT);
}


RPC_ADDRESS::RPC_ADDRESS (
    IN OUT RPC_STATUS PAPI * RpcStatus
    ) : AddressMutex(RpcStatus,
                     TRUE  // pre-allocate semaphore
                     )
/*++

Routine Description:

    We just need to initialization some stuff to zero.  That way if we
    later have to delete this address because of an error in initialization
    we can tell what instance variables need to be freed.

--*/
{
    NetworkAddress = 0;
    Endpoint = 0;
    RpcProtocolSequence = 0;
}


RPC_ADDRESS::~RPC_ADDRESS (
    )
/*++

Routine Description:

    This routine will only get called if part way through initialization
    an error occurs.  We just need to free up any memory used by instance
    variables.  Once FireUpManager has been called and succeeds, the
    address will never be destroyed.

--*/
{
    if (Endpoint != 0)
        delete Endpoint;
    if (RpcProtocolSequence != 0)
        delete RpcProtocolSequence;
}



RPC_CHAR *
RPC_ADDRESS::GetListNetworkAddress (
    IN unsigned int Index
    )
/*++

Routine Description:

    A pointer to the network address for this address is returned.

--*/
{
    if (Index >= pNetworkAddressVector->Count)
        {
        return (NULL);
        }

    return(pNetworkAddressVector->NetworkAddresses[Index]);
}


RPC_STATUS
RPC_ADDRESS::CopyDescriptor (
    IN void *SecurityDescriptor,
    OUT void **OutDescriptor
    )
{
   BOOL b;
   SECURITY_DESCRIPTOR_CONTROL    Control;
   DWORD Revision;
   DWORD BufferLength;

   if ( IsValidSecurityDescriptor(SecurityDescriptor) == FALSE )
       {
       return(RPC_S_INVALID_SECURITY_DESC);
       }

   if (FALSE == GetSecurityDescriptorControl(SecurityDescriptor, &Control, &Revision))
       {
       return(RPC_S_INVALID_SECURITY_DESC);
       }

   if (Control & SE_SELF_RELATIVE)
       {
       //
       // Already self-relative, just copy it.
       //

       BufferLength = GetSecurityDescriptorLength(SecurityDescriptor);

       ASSERT(BufferLength >= sizeof(SECURITY_DESCRIPTOR));

       *OutDescriptor = RpcpFarAllocate(BufferLength);
       if (*OutDescriptor == 0)
           {
           return(RPC_S_OUT_OF_MEMORY);
           }

       memcpy(*OutDescriptor, SecurityDescriptor, BufferLength);

       return(RPC_S_OK);
       }

   //
   // Make self-relative and copy it.
   //
   BufferLength = 0;
   b = MakeSelfRelativeSD(SecurityDescriptor, 0, &BufferLength);
   ASSERT(b == FALSE);
   if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
       {
       return(RPC_S_INVALID_SECURITY_DESC);
       }

   ASSERT(BufferLength >= sizeof(SECURITY_DESCRIPTOR_RELATIVE));

   *OutDescriptor = RpcpFarAllocate(BufferLength);

   if (*OutDescriptor == 0)
       {
       return(RPC_S_OUT_OF_MEMORY);
       }

   b = MakeSelfRelativeSD(SecurityDescriptor,
                          *OutDescriptor,
                          &BufferLength);

   if (b == FALSE)
       {
       ASSERT(GetLastError() != ERROR_INSUFFICIENT_BUFFER);
       delete *OutDescriptor;

       return(RPC_S_OUT_OF_MEMORY);
       }

   return(RPC_S_OK);
}


RPC_STATUS
RPC_ADDRESS::SetEndpointAndStuff (
    IN RPC_CHAR PAPI * NetworkAddress,
    IN RPC_CHAR PAPI * Endpoint,
    IN RPC_CHAR PAPI * RpcProtocolSequence,
    IN RPC_SERVER * Server,
    IN unsigned int StaticEndpointFlag,
    IN unsigned int PendingQueueSize,
    IN void PAPI *SecurityDescriptor,
    IN unsigned long EndpointFlags,
    IN unsigned long NICFlags,
    IN NETWORK_ADDRESS_VECTOR *pNetworkAddressVector
    )
/*++

Routine Description:

    We just need to set some instance variables of this rpc address.

Arguments:

    Endpoint - Supplies the endpoint for this rpc address.

    RpcProtocolSequence - Supplies the rpc protocol sequence for this
        rpc address.

    Server - Supplies the rpc server which owns this rpc address.

    StaticEndpointFlag - Supplies a flag which specifies whether this
        address has a static endpoint or a dynamic endpoint.

--*/
{
    RPC_STATUS Status;

    this->NetworkAddress = NetworkAddress;
    this->Endpoint = Endpoint;
    this->RpcProtocolSequence = RpcProtocolSequence;
    this->pNetworkAddressVector = pNetworkAddressVector;
    this->Server = Server;
    this->StaticEndpointFlag = StaticEndpointFlag;
    this->PendingQueueSize = PendingQueueSize;
    this->EndpointFlags = EndpointFlags;
    this->NICFlags = NICFlags;

    if (SecurityDescriptor)
        {
        Status = CopyDescriptor(SecurityDescriptor,
                                &this->SecurityDescriptor);
        if (Status != RPC_S_OK)
            {
            return Status;
            }
        }

    return RPC_S_OK;
}


RPC_STATUS
RPC_ADDRESS::FindInterfaceTransfer (
    IN PRPC_SYNTAX_IDENTIFIER InterfaceIdentifier,
    IN PRPC_SYNTAX_IDENTIFIER ProposedTransferSyntaxes,
    IN unsigned int NumberOfTransferSyntaxes,
    OUT PRPC_SYNTAX_IDENTIFIER AcceptedTransferSyntax,
    OUT RPC_INTERFACE ** RpcInterface,
    OUT BOOL *fIsInterfaceTransferPreferred,
    OUT int *ProposedTransferSyntaxIndex,
    OUT int *AvailableTransferSyntaxIndex
    )
/*++

Routine Description:

    This method is used to determine if a client bind request can be
    accepted or not.  All we have got to do here is hand off to the
    server which owns this address.

Arguments:

    InterfaceIdentifier - Supplies the syntax identifier for the
        interface; this is the interface uuid and version.

    ProposedTransferSyntaxes - Supplies a list of one or more transfer
        syntaxes which the client initiating the binding supports.  The
        server should pick one of these which is supported by the
        interface.

    NumberOfTransferSyntaxes - Supplies the number of transfer syntaxes
        specified in the proposed transfer syntaxes argument.

    AcceptedTransferSyntax - Returns the transfer syntax which the
        server accepted.

    RpcInterface - Returns a pointer to the rpc interface found which
        supports the requested interface and one of the requested transfer
        syntaxes.

Return Value:

    RPC_S_OK - The requested interface exists and it supports at least
        one of the proposed transfer syntaxes.  We are all set, now we
        can make remote procedure calls.

    RPC_P_UNSUPPORTED_TRANSFER_SYNTAX - The requested interface exists,
        but it does not support any of the proposed transfer syntaxes.

    RPC_P_UNSUPPORTED_INTERFACE - The requested interface is not supported
        by this rpc server.

--*/
{
    return Server->FindInterfaceTransfer(
                                         InterfaceIdentifier,
                                         ProposedTransferSyntaxes,
                                         NumberOfTransferSyntaxes,
                                         AcceptedTransferSyntax,
                                         RpcInterface,
                                         fIsInterfaceTransferPreferred,
                                         ProposedTransferSyntaxIndex,
                                         AvailableTransferSyntaxIndex);
}


BINDING_HANDLE *
RPC_ADDRESS::InquireBinding (
    RPC_CHAR * LocalNetworkAddress
    )
/*++

Routine Description:

    We need to return create and return a binding handle which can
    be used by a client to make remote procedure calls to this rpc
    address.

Return Value:

    A newly created binding handle will be returned, inless an out
    of memory error occurs, in which case zero will be returned.

--*/
{
    RPC_STATUS Status;
    DCE_BINDING * DceBinding;
    BINDING_HANDLE * BindingHandle;
    RPC_CHAR * DynamicEndpoint = 0;
    RPC_CHAR * PAPI * tmpPtr;

    if(LocalNetworkAddress == 0)
        {
        LocalNetworkAddress = pNetworkAddressVector->NetworkAddresses[0];
        }

    DceBinding = new DCE_BINDING(
                                 0,
                                 RpcProtocolSequence,
                                 LocalNetworkAddress,
                                 (StaticEndpointFlag != 0 ? Endpoint : 0),
                                 0,
                                 &Status);
    if ((DceBinding == 0)
        || (Status != RPC_S_OK))
        {
        delete DceBinding;
        return(0);
        }

    if (StaticEndpointFlag == 0)
        {
        DynamicEndpoint = DuplicateString(Endpoint);
        if (DynamicEndpoint == 0)
            {
            delete DceBinding;
            return(0);
            }
        }

    BindingHandle = new SVR_BINDING_HANDLE(DceBinding, DynamicEndpoint, &Status);
    if (BindingHandle == 0)
        {
        delete DceBinding;
        }

    return(BindingHandle);
}


RPC_STATUS
RPC_ADDRESS::ServerStartingToListen (
    IN unsigned int MinimumCallThreads,
    IN unsigned int MaximumConcurrentCalls
    )
/*++

Routine Description:

    This method will be called for each address when the server starts
    listening.  In addition, if an address is added while the server is
    listening, then this method will be called.  The purpose of the method
    is to notify the address about the minimum number of call threads
    required; the maximum concurrent calls can safely be ignored, but it
    can be used to set an upper bound on the number of call threads.

Arguments:

    MinimumCallThreads - Supplies a number indicating the minimum number
        of call threads which should be created for this address.

    MaximumConcurrentCalls - Supplies the maximum number of concurrent
        calls which this server will support.

Return Value:

    RPC_S_OK - This routine will always return this value.  Protocol
        support modules may return other values.

--*/
{
    UNUSED(MinimumCallThreads);
    UNUSED(MaximumConcurrentCalls);

    return(RPC_S_OK);
}


void
RPC_ADDRESS::ServerStoppedListening (
    )
/*++

Routine Description:

    This routine will be called to notify an address that the server has
    stopped listening for remote procedure calls.  Each protocol module
    may override this routine; it is safe not too, but not as efficient.
    Note that this routine will be called before all calls using the
    server have been allowed to complete.

--*/
{
}


long
RPC_ADDRESS::InqNumberOfActiveCalls (
    )
/*++

Return Value:

    Each protocol module will define this routine.  We will use this
    functionality when the server has stopped listening and is waiting
    for all remote procedure calls to complete.  The number of active calls
    for the address will be returned.

--*/
{
    return(ActiveCallCount);
}


RPC_STATUS
RPC_ADDRESS::RestartAddress (
    IN unsigned int MinThreads,
    IN unsigned int MaxCalls
    )
{
    RPC_STATUS Status;
    int Key;

    Status = ServerSetupAddress(
                                NetworkAddress,
                                &Endpoint,
                                PendingQueueSize,
                                SecurityDescriptor,
                                EndpointFlags,
                                NICFlags,
                                &pNetworkAddressVector);
    if (Status != RPC_S_OK)
        {
        pNetworkAddressVector = NULL;

        return Status;
        }


    Key = Server->AddAddress(this);
    if (Key == -1)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    Server->ServerMutex.Request();
    Status = ServerStartingToListen(MinThreads, MaxCalls);
    Server->ServerMutex.Clear();


    if (Status != RPC_S_OK)
        {
        return Status;
        }

    CompleteListen();

    return RPC_S_OK;
}

void
RPC_ADDRESS::DestroyContextHandlesForInterface (
    IN RPC_SERVER_INTERFACE PAPI * ,
    IN BOOL
    )
/*++
Function Name:  DestroyContextHandlesForInterface

Parameters:
    RpcInterfaceInformation - the interface for which context handles
        are to be unregistered
    RundownContextHandles - if non-zero, rundown the context handles. If
        FALSE, destroy the runtime portion of the context handle resource,
        but don't call the user rundown routine.

Description:
    Each protocol engine will implement its own version of this routine,
    if it supports the feature. For those who don't, this routine provides
    default no-op behaviour

Returns:

--*/
{
}

void
RPC_ADDRESS::CleanupIdleSContexts (
    void
    )
/*++
Function Name:  CleanupIdleSContexts

Parameters:

Description:
    Each protocol engine will implement its own version of this routine,
    if it supports the feature. For those who don't, this routine provides
    default no-op behaviour

Returns:

--*/
{
}


/*====================================================================

SCONNECTION

==================================================================== */

RPC_STATUS
SetThreadSecurityContext(
    SECURITY_CONTEXT * Context
    )
/*++

Routine Description:

    RpcImpersonateClient() takes a handle_t, so many threads can impersonate
    the client of a single SCONNECTION.  RPC needs to record which context
    each thread is using.  It is logical to place this in the TLS, but threads
    not created by RPC lack the THREAD structure in their TLS.  This wrapper
    function will store the security context in the TLS if available, or
    place the context in a dictionary if not.

Arguments:

    Context - the security context to associate with this thread

Return Value:

    RPC_S_OK if successful
    RPC_S_OUT_OF_MEMORY if the dictionary insertion failed

--*/

{
    THREAD * ThreadInfo = ThreadSelf();

    if (ThreadInfo)
        {
        ThreadInfo->SecurityContext = Context;
        return RPC_S_OK;
        }

    return RPC_S_OUT_OF_MEMORY;
}

SECURITY_CONTEXT *
QueryThreadSecurityContext(
    )
/*++

Routine Description:

    Fetches the security context associated with this thread for this
    connection.  We check the TLS if available; if nothing is there
    then we scan the connection's dictionary.

Arguments:

    none

Return Value:

    the associated security context, or zero if none is found

--*/
{
    THREAD * ThreadInfo = ThreadSelf();

    if (ThreadInfo)
        {
        if (ThreadInfo->SecurityContext)
            {
            return (SECURITY_CONTEXT *) ThreadInfo->SecurityContext;
            }
        }

    return 0;
}

SECURITY_CONTEXT *
ClearThreadSecurityContext(
    )
/*++

Routine Description:

    Clears the association between this thread and its security context
    for this connection.

Arguments:

    none

Return Value:

    the formerly associated security context, or zero if none was found

--*/
{
    THREAD * ThreadInfo = ThreadSelf();

    if (ThreadInfo)
        {
        SECURITY_CONTEXT * Context =
            (SECURITY_CONTEXT *) ThreadInfo->SecurityContext;

        if (Context)
            {
            ThreadInfo->SecurityContext = 0;
            return Context;
            }
        }

    return 0;
}

RPC_STATUS
SCALL::ImpersonateClient (
    )
// This routine just returns RPC_CANNOT_SUPPORT indicating that this
// particular connection does not support impersonation.
{

    ASSERT(0 && "improper SCALL member called\n");
    return(RPC_S_CANNOT_SUPPORT);
}

RPC_STATUS
SCALL::RevertToSelf (
    )
// We always return RPC_CANNOT_SUPPORT indicating that the particular
// connection does not support impersonation.
{

    ASSERT(0 && "improper SCALL member called\n");
    return(RPC_S_CANNOT_SUPPORT);
}

void
NDRSContextHandlePostDispatchProcessing (
    IN SCALL *SCall,
    ServerContextHandle *CtxHandle
    );

void
SCALL::DoPostDispatchProcessing (
    void
    )
{
    DictionaryCursor cursor;
    ServerContextHandle *CtxHandle;
    ServerContextHandle *RetrievedCtxHandle;
    int Key;

    // the list will contain all in-only context
    // handles, as they don't get marshalled. It will also
    // contain the marshalling buffers for the newly
    // created context handles
    if (ActiveContextHandles.Size() > 0)
        {
        // no need to synchronize access to the
        // dictionary - only this call will be
        // touching it
        ActiveContextHandles.Reset(cursor);
        while ((CtxHandle = ActiveContextHandles.NextWithKey(cursor, &Key)) != 0)
            {
            // ignore buffers
            if ((ULONG_PTR)CtxHandle & SCALL::DictionaryEntryIsBuffer)
                {
                RetrievedCtxHandle = ActiveContextHandles.Delete(Key);
                ASSERT(RetrievedCtxHandle == CtxHandle);
                continue;
                }

            // NDRSContextHandlePostDispatchProcessing will remove the context handle
            // from the dictionary - this doesn't interfere with our
            // enumeration
            NDRSContextHandlePostDispatchProcessing(this,
                CtxHandle
                );
            }

        }
}


RPC_STATUS
SCONNECTION::IsClientLocal (
    OUT unsigned int PAPI * ClientLocalFlag
    )
/*++

Routine Description:

    The connection oriented protocol module will override this method;
    all other protocol modules should just use this routine.  We need this
    support so that the security system can tell if a client is local or
    remote.

Arguments:

    ClientLocalFlag - Returns an indication of whether or not the client is
        local (ie. on the same machine as the server).  This field will be
        set to a non-zero value to indicate that the client is local;
        otherwise, the client is remote.

Return Value:

    RPC_S_CANNOT_SUPPORT - This will always be used.

--*/
{
    UNUSED(ClientLocalFlag);

    ASSERT(0 && "improper SCALL member called\n");
    return(RPC_S_CANNOT_SUPPORT);
}

RPC_STATUS
SCALL::CreateAndSaveAuthzContextFromToken (
    IN OUT PAUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContextPlaceholder OPTIONAL,
    IN HANDLE ImpersonationToken,
    IN AUTHZ_RESOURCE_MANAGER_HANDLE AuthzResourceManager,
    IN PLARGE_INTEGER pExpirationTime OPTIONAL,
    IN LUID Identifier,
    IN DWORD Flags,
    IN PVOID DynamicGroupArgs OPTIONAL,
    OUT PAUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext
    )
/*++

Routine Description:

    Creates an Authz context from token. If saving is requested, it
    tries to save it in a thread-safe manner and duplicates it before
    returning. If saving is not requested, the resulting authz context
    is simply returned. In both cases caller owns the returned auth
    context.

Arguments:

    pAuthzClientContextPlaceholder - contains a pointer to an authz placeholder.
        If NULL, out of the ImpersonationToken an authz context will
        be made and will be returned. If non-NULL, it must contain
        NULL. In this case an authz context will be created from the token,
        and it will be stored in the placeholder in a thread safe manner and a
        duplicate will be made and returned in pAuthzClientContext.
    ImpersonationToken - the impersonation token to use.
    AuthzResourceManager - authz parameters (not interpreted)
    pExpirationTime - authz parameters (not interpreted)
    Identifier - authz parameters (not interpreted)
    Flags - authz parameters (not interpreted)
    DynamicGroupArgs - authz parameters (not interpreted)
    pAuthzClientContext - contains the output authz context on success

Return Value:

    Win32 error code. EEInfo has been added.

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    BOOL Result;
    AUTHZ_CLIENT_CONTEXT_HANDLE AuthzClientContext;

    Result = AuthzInitializeContextFromTokenFn(
        Flags,
        ImpersonationToken,
        AuthzResourceManager,
        pExpirationTime,
        Identifier,
        DynamicGroupArgs,
        &AuthzClientContext);

    if (!Result)
        {
        Status = GetLastError();

        RpcpErrorAddRecord(EEInfoGCAuthz,
            Status,
            EEInfoDLSCALL__CreateAndSaveAuthzContextFromToken10,
            GetCurrentThreadId(),
            (ULONGLONG)AuthzResourceManager);

        return Status;
        }

    if (pAuthzClientContextPlaceholder)
        {
        if (InterlockedCompareExchangePointer((PVOID *)pAuthzClientContextPlaceholder,
            AuthzClientContext,
            NULL) != NULL)
            {
            // somebody beat us to the punch - free the context we obtained
            AuthzFreeContextFn(AuthzClientContext);
            // use the context that has been provided
            AuthzClientContext = *pAuthzClientContextPlaceholder;
            }

        Status = DuplicateAuthzContext(AuthzClientContext,
            pExpirationTime,
            Identifier,
            Flags,
            DynamicGroupArgs,
            pAuthzClientContext);

        if (Status)
            {
            // EEInfo has already been added
            return Status;
            }
        }
    else
        {
        *pAuthzClientContext = AuthzClientContext;
        }

    return Status;
}

RPC_STATUS
SCALL::DuplicateAuthzContext (
    IN AUTHZ_CLIENT_CONTEXT_HANDLE AuthzClientContext,
    IN PLARGE_INTEGER pExpirationTime OPTIONAL,
    IN LUID Identifier,
    IN DWORD Flags,
    IN PVOID DynamicGroupArgs OPTIONAL,
    OUT PAUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext
    )
/*++

Routine Description:

    Take an Authz context, and make a duplicate of it, using the
    specified parameters. This method is a wrapper for
    AuthzInitializeContextFromContext, mainly adding error handling.

Arguments:

    AuthzClientContext - source authz context
    pExpirationTime - authz parameters (not interpreted)
    Identifier - authz parameters (not interpreted)
    Flags - authz parameters (not interpreted)
    DynamicGroupArgs - authz parameters (not interpreted)
    pAuthzClientContext - target authz context pointer

Return Value:

    Win32 error code.

--*/
{
    RPC_STATUS Status;
    BOOL Result;

    // Copy the authz context. We must do a copy,
    // to avoid lifetime issues b/n our copy
    // and the client copy
    Result = AuthzInitializeContextFromAuthzContextFn(
        Flags,
        AuthzClientContext,
        pExpirationTime,
        Identifier,
        DynamicGroupArgs,
        pAuthzClientContext);

    if (!Result)
        {
        Status = GetLastError();

        RpcpErrorAddRecord(EEInfoGCAuthz,
            Status,
            EEInfoDLSCALL__DuplicateAuthzContext10,
            GetCurrentThreadId(),
            (ULONGLONG)AuthzClientContext);
        }
    else
        Status = RPC_S_OK;

    return Status;
}


/* ====================================================================

ASSOCIATION_HANDLE :

==================================================================== */

static long AssociationIdCount = 0L;

void
DestroyContextCollection (
    IN ContextCollection *CtxCollection
    );

ASSOCIATION_HANDLE::ASSOCIATION_HANDLE (
    void
    )
{
    CtxCollection = NULL;
    AssociationID = InterlockedIncrement(&AssociationIdCount);
}

ASSOCIATION_HANDLE::~ASSOCIATION_HANDLE (
    )
// We finally get to use the rundown routines for somethings.  The association
// is being deleted which is the event that the rundown routines were waiting
// for.
{
    FireRundown();
}

// Returns the context handle collection for this association.
RPC_STATUS
ASSOCIATION_HANDLE::GetAssociationContextCollection (
    ContextCollection **CtxCollectionPlaceholder
    )
/*++
Function Name:  GetAssociationContextCollection

Parameters:
    CtxCollectionPlaceholder - a placeholder where to put the pointer to
        the context collection.

Description:
    The context handle code will call the SCALL to get the collection
    of context handles for this association. The SCALL method will
    simply delegate to this.
    This routine will check if the context handle collection was created
    and if so, it will just return it. If it wasn't created, it will try
    to create it.

Returns:
    RPC_S_OK for success or RPC_S_* for error.

--*/
{
    RPC_STATUS RpcStatus;

    if (CtxCollection)
        {
        *CtxCollectionPlaceholder = CtxCollection;
        return RPC_S_OK;
        }

    RpcStatus = NDRSContextInitializeCollection(&CtxCollection);
    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    *CtxCollectionPlaceholder = CtxCollection;
    return RpcStatus;
}

void
ASSOCIATION_HANDLE::FireRundown (
    void
    )
{
    int nRetries = 20;
    RPC_STATUS status;

    if (CtxCollection)
        {
        // make a best effort to make sure there is another listening thread
        // besides this one. If we repeatedly fail, we fire the rundown
        // anyway - currently few servers use outgoing RPC callbacks into the
        // same process, so we'd rather risk an unlikely deadlock than cause
        // a sure leak
        while (nRetries > 0)
            {
            status = CreateThread();
            if (status == RPC_S_OK)
                break;
            Sleep(10);
            nRetries --;
            }
        DestroyContextCollection(CtxCollection);
        if (status == RPC_S_OK)
            RundownNotificationCompleted();
        }
}

// do nothing in the base case
RPC_STATUS ASSOCIATION_HANDLE::CreateThread(void)
{
    return RPC_S_OK;
}

void ASSOCIATION_HANDLE::RundownNotificationCompleted(void)
{
}

void
ASSOCIATION_HANDLE::DestroyContextHandlesForInterface (
    IN RPC_SERVER_INTERFACE PAPI * RpcInterfaceInformation,
    IN BOOL RundownContextHandles
    )
/*++
Function Name:  DestroyContextHandlesForInterface

Parameters:
    RpcInterfaceInformation - the interface for which context handles
        are to be unregistered
    RundownContextHandles - if non-zero, rundown the context handles. If
        FALSE, destroy the runtime portion of the context handle resource,
        but don't call the user rundown routine.

Description:
    The association will call into NDR to destroy the specified context
    handles. It will either have a reference on the association, or the
    association mutex. Both ways, we're safe from destruction, and NDR
    will synchronize access to the list internally. The address has made
    a best effort not to hold the association mutex. If memory is low,
    it may end up doing so, however.

Returns:

--*/
{
    ContextCollection *LocalCtxCollection;
    void *pGuard;

    // N.B. An association mutex may be held on entry for this
    // function. The server mutex may be held as well

    LocalCtxCollection = CtxCollection;

    // shortcut the common path
    if (!LocalCtxCollection)
        return;

    pGuard = &RpcInterfaceInformation->InterfaceId;

    // call into NDR to destroy the context handles
    DestroyContextHandlesForGuard(LocalCtxCollection,
        RundownContextHandles,
        pGuard);
}

/* ====================================================================

Routine to initialize the server DLL.

==================================================================== */

int
InitializeServerDLL (
    )
{
    GetMaxRpcSizeAndThreadPoolParameters();

    if (InitializeClientDLL() != 0)
        return(1);

#if 0
    if (InitializeSTransports() != 0)
        return(1);
#endif

    if (InitializeObjectDictionary() != 0)
        return(1);

    if (InitializeRpcServer() != 0)
        return(1);

    if (InitializeRpcProtocolLrpc() != 0)
        return(1);

    return(0);
}

#if DBG
void
RpcpInterfaceForCallDoesNotUseStrict (
    IN RPC_BINDING_HANDLE BindingHandle
    )
{
    SCALL *SCall;

    if (((MESSAGE_OBJECT *)BindingHandle)->Type(SCALL_TYPE))
        {
        SCall = (SCALL *)BindingHandle;
        SCall->InterfaceForCallDoesNotUseStrict();
        }
}
#endif

RPC_STATUS
InqLocalConnAddress (
    IN SCALL *SCall,
    IN OUT void *Buffer,
    IN OUT unsigned long *BufferSize,
    OUT unsigned long *AddressFormat
    )
/*++

Routine Description:

    This routine is used by a server application to inquire about the local
    address on which a call is made.

Arguments:

    Binding - Supplies a valid server binding. The binding must have been
        verified to be an SCALL by the caller.

    Buffer - The buffer that will receive the output address

    BufferSize - the size of the supplied Buffer on input. On output the
        number of bytes written to the buffer. If the buffer is too small
        to receive all the output data, ERROR_MORE_DATA is returned,
        nothing is written to the buffer, and BufferSize is set to
        the size of the buffer needed to return all the data.

    AddressFormat - a constant indicating the format of the returned address.
        Currently supported are RPC_P_ADDR_FORMAT_TCP_IPV4 and
        RPC_P_ADDR_FORMAT_TCP_IPV6.

Return Values:

    RPC_S_OK - success.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete this
        operation.

    RPC_S_INVALID_BINDING - The supplied client binding is invalid.

    RPC_S_CANNOT_SUPPORT - The local address was inquired for a protocol
        sequence that doesn't support this type of functionality. Currently
        only ncacn_ip_tcp supports it.

    RPC_S_* or Win32 error for other errors
--*/
{
    // is this an osf scall?
    if (!SCall->InvalidHandle(OSF_SCALL_TYPE))
        {
        OSF_SCALL *OsfSCall;

        OsfSCall = (OSF_SCALL *)SCall;

        return OsfSCall->InqLocalConnAddress(
            Buffer,
            BufferSize,
            AddressFormat);
        }
    else if (!SCall->InvalidHandle(DG_SCALL_TYPE))
        {
        // this is a dg call
        DG_SCALL *DgSCall;

        DgSCall = (DG_SCALL *)SCall;

        return DgSCall->InqLocalConnAddress(
            Buffer,
            BufferSize,
            AddressFormat);
        }
    else
        {
        // the others don't support it
        return RPC_S_CANNOT_SUPPORT;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\init.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    initnt.cxx

Abstract:

    This module contains the code used to initialize the RPC runtime.  One
    routine gets called when a process attaches to the dll.  Another routine
    gets called the first time an RPC API is called.

Author:

    Michael Montague (mikemon) 03-May-1991

Revision History:
    Kamen Moutafov (KamenM) Dec 99 - Feb 2000 - Support for cell debugging stuff

--*/

#include <precomp.hxx>
#include <hndlsvr.hxx>
#include <thrdctx.hxx>
#include <rpccfg.h>
#include <rc4.h>
#include <randlib.h>
#include <epmap.h>
#include <CellHeap.hxx>

#include <lpcpack.hxx>

int RpcHasBeenInitialized = 0;
RTL_CRITICAL_SECTION GlobalMutex;

RPC_SERVER * GlobalRpcServer;
BOOL g_fClientSideDebugInfoEnabled = FALSE;
BOOL g_fServerSideDebugInfoEnabled = FALSE;
BOOL g_fSendEEInfo = FALSE;
LRPC_SERVER *GlobalLrpcServer = NULL;
HINSTANCE hInstanceDLL ;

EXTERN_C HINSTANCE g_hRpcrt4;

DWORD gPageSize;
DWORD gThreadTimeout;
UINT  gNumberOfProcessors;
DWORD gAllocationGranularity;
BOOL gfServerPlatform;
ULONGLONG gPhysicalMemorySize;  // in megabytes

//
// By default the non pipe arguments cannot be more than 4 Megs
//
DWORD gMaxRpcSize = 0x400000;
DWORD gProrateStart = 0;
DWORD gProrateMax = 0;
DWORD gProrateFactor = 0;
void *g_rc4SafeCtx = 0;

extern "C" {

BOOLEAN
InitializeDLL (
    IN HINSTANCE DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )
/*++

Routine Description:

    This routine will get called: when a process attaches to this dll, and
    when a process detaches from this dll.

Return Value:

    TRUE - Initialization successfully occurred.

    FALSE - Insufficient memory is available for the process to attach to
        this dll.

--*/
{
    NTSTATUS NtStatus;

    UNUSED(Context);

    switch (Reason)
        {
        case DLL_PROCESS_ATTACH:
            hInstanceDLL = DllHandle ;
            g_hRpcrt4 = DllHandle;

            GlobalMutex.DebugInfo = NULL;
            NtStatus = RtlInitializeCriticalSectionAndSpinCount(&GlobalMutex, PREALLOCATE_EVENT_MASK);
            if (NT_SUCCESS(NtStatus) == 0)
                {
                return(FALSE);
                }

            // initialize safe rc4 operations.
            if(!rc4_safe_startup( &g_rc4SafeCtx ))
                {
                (void) RtlDeleteCriticalSection(&GlobalMutex);
                return FALSE;
                }
            break;

        case DLL_PROCESS_DETACH:
            //
            // If shutting down because of a FreeLibrary call, cleanup
            //

            if (Context == NULL) 
                {
                ShutdownLrpcClient();
                }

            if (GlobalMutex.DebugInfo != NULL)
                {
                NtStatus = RtlDeleteCriticalSection(&GlobalMutex);
                ASSERT(NT_SUCCESS(NtStatus));
                }

            if (g_rc4SafeCtx)
                rc4_safe_shutdown( g_rc4SafeCtx ); // free safe rc4 resources.

            break;

        case DLL_THREAD_DETACH:
            THREAD * Thread = RpcpGetThreadPointer();

#ifdef RPC_OLD_IO_PROTECTION
            if (Thread)
                {
                Thread->UnprotectThread();
                }
#else
            delete Thread;
#endif

            break;
        }

    return(TRUE);
}

}    //extern "C" end

#ifdef NO_RECURSIVE_MUTEXES
unsigned int RecursionCount = 0;
#endif // NO_RECURSIVE_MUTEXES

extern int InitializeRpcAllocator(void);
extern RPC_STATUS ReadPolicySettings(void);

const ULONG MEGABYTE = 0x100000;

typedef struct tagBasicSystemInfo
{
    DWORD m_dwPageSize;
    ULONGLONG m_dwPhysicalMemorySize;
    DWORD m_dwNumberOfProcessors;
    ULONG AllocationGranularity;
    BOOL m_fServerPlatform;
} BasicSystemInfo;

BOOL 
GetBasicSystemInfo (
    IN OUT BasicSystemInfo *basicSystemInfo
    )
/*++

Routine Description:

    Gets basic system information. We don't use the Win32 GetSystemInfo, because
    under NT it accesses the image header, which may not be available if the image
    was loaded from the network, and the network failed. Therefore, we need a function
    that accesses just what we need, and nothing else.

Arguments:

    The basic system info structure.

Return Value:

    0 - failure

    non-0 - success.

--*/
{
    //
    // Query system info (for # of processors) and product type
    //

    SYSTEM_BASIC_INFORMATION BasicInfo;
    NTSTATUS Status;
    BOOL b;

    Status = NtQuerySystemInformation(
                            SystemBasicInformation,
                            &BasicInfo,
                            sizeof(BasicInfo),
                            NULL
                            );
    if ( !NT_SUCCESS(Status) )
        {
        DbgPrintEx(DPFLTR_RPCPROXY_ID,
                       DPFLTR_ERROR_LEVEL,
                       "RPCTRANS: NtQuerySystemInformation failed: %x\n",
                       Status);

        return 0;
        }

    basicSystemInfo->m_dwPageSize = BasicInfo.PageSize;
    basicSystemInfo->m_dwNumberOfProcessors = BasicInfo.NumberOfProcessors;
    basicSystemInfo->m_dwPhysicalMemorySize = ((BasicInfo.NumberOfPhysicalPages * (ULONGLONG) basicSystemInfo->m_dwPageSize) / MEGABYTE);
    basicSystemInfo->AllocationGranularity = BasicInfo.AllocationGranularity;

    NT_PRODUCT_TYPE type;
    b = RtlGetNtProductType(&type);
    if (b)
        {
        basicSystemInfo->m_fServerPlatform = (type != NtProductWinNt);
        return 1;
        }
    else
        {
        DbgPrintEx(DPFLTR_RPCPROXY_ID,
                       DPFLTR_ERROR_LEVEL,
                       "RpcGetNtProductType failed, usign default\n");
        return 0;
        }
}


RPC_STATUS
PerformRpcInitialization (
    void
    )
/*++

Routine Description:

    This routine will get called the first time that an RPC runtime API is
    called.  There is actually a race condition, which we prevent by grabbing
    a mutex and then performing the initialization.  We only want to
    initialize once.

Return Value:

    RPC_S_OK - This status code indicates that the runtime has been correctly
        initialized and is ready to go.

    RPC_S_OUT_OF_MEMORY - If initialization failed, it is most likely due to
        insufficient memory being available.

--*/
{
    if ( RpcHasBeenInitialized == 0 ) 
        {
        RequestGlobalMutex();
        if ( RpcHasBeenInitialized == 0 )
            {
            RPC_STATUS Status;
            BasicSystemInfo SystemInfo;
            BOOL b;

            b = GetBasicSystemInfo(&SystemInfo);    
            if (!b)
                {
                ClearGlobalMutex();
                return RPC_S_OUT_OF_MEMORY;
                }

            gNumberOfProcessors = SystemInfo.m_dwNumberOfProcessors;
            gPageSize = SystemInfo.m_dwPageSize;
            gAllocationGranularity = SystemInfo.AllocationGranularity;
            gfServerPlatform = SystemInfo.m_fServerPlatform;
            gPhysicalMemorySize = SystemInfo.m_dwPhysicalMemorySize;

            // Should be something like 64kb / 4kb.
            ASSERT(gAllocationGranularity % gPageSize == 0);

            if (( InitializeRpcAllocator() != 0)
                || ( InitializeServerDLL() != 0 ))
                {
                ClearGlobalMutex();
                return(RPC_S_OUT_OF_MEMORY);
                }

            Status = InitializeEPMapperClient();
            if (Status != RPC_S_OK)
                {
                ClearGlobalMutex();
                return Status;
                }

            Status = ReadPolicySettings();
            if (Status != RPC_S_OK)
                {
                ClearGlobalMutex();
                return Status;
                }

            if (gfServerPlatform)
                {
                gThreadTimeout = 90*1000;
                }
            else
                {
                gThreadTimeout = 30*1000;
                }

            Status = InitializeCellHeap();
            if (Status != RPC_S_OK)
                {
                ClearGlobalMutex();
                return Status;
                }

            RpcHasBeenInitialized = 1;
            ClearGlobalMutex();

            if (LoadLibrary(RPC_CONST_SSTRING("rpcrt4.dll")) == 0)
                {
                return RPC_S_OUT_OF_MEMORY;
                }
            }
        else
            {
            ClearGlobalMutex();
            }
        }
    return(RPC_S_OK);
}

#ifdef DBG
long lGlobalMutexCount = 0;
#endif


void
GlobalMutexRequestExternal (
    void
    )
/*++

Routine Description:

    Request the global mutex.

--*/
{
    GlobalMutexRequest();
}


void
GlobalMutexClearExternal (
    void
    )
/*++

Routine Description:

    Clear the global mutex.

--*/
{
    GlobalMutexClear();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\linklist.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       LinkList.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

File: Linkist.cxx

Description:

    The implementation of the functions that support link list operations. 
    All of these simply relegate to the macro versions


History :

kamenm     Aug 2000    Created

-------------------------------------------------------------------- */
#include <precomp.hxx>


PLIST_ENTRY
RpcpfRemoveHeadList(
    PLIST_ENTRY ListHead
    )
/*++

Routine Description:

    Removes the head of the list.

Arguments:
    ListHead - the head of the list

Return Value:
    The removed entry. If the list is empty,
    ListHead will be returned.

--*/
{
    return RpcpRemoveHeadList(ListHead);
}


PLIST_ENTRY
RpcpfRemoveTailList(
    PLIST_ENTRY ListHead
    )
/*++

Routine Description:

    Removes the tail of the list

Arguments:
    ListHead - the head of the list

Return Value:
    The removed entry. If the list is empty,
    ListHead will be returned.

--*/
{
    return RpcpRemoveTailList(ListHead);
}


VOID
RpcpfRemoveEntryList(
    PLIST_ENTRY Entry
    )
/*++

Routine Description:

    Removes an entry from the list

Arguments:
    Entry - the entry to remove

Return Value:

--*/
{
    RpcpRemoveEntryList(Entry);
}


VOID
RpcpfInsertTailList(
    PLIST_ENTRY ListHead,
    PLIST_ENTRY Entry
    )
/*++

Routine Description:

    Adds an entry to the tail of the list

Arguments:
    ListHead - the head of the list
    Entry - the entry to add

Return Value:

--*/
{
    RpcpInsertTailList(ListHead,Entry);
}


VOID
RpcpfInsertHeadList(
    PLIST_ENTRY ListHead,
    PLIST_ENTRY Entry
    )
/*++

Routine Description:

    Adds an entry to the head of the list

Arguments:
    ListHead - the head of the list
    Entry - the entry to add

Return Value:

--*/
{
    RpcpInsertHeadList(ListHead,Entry);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\locks.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    Locks.cxx

Abstract:

    Out of line methods for some of the syncronization classes
    defined in locks.hxx.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     03-14-95    Moved from misc.cxx.
    MarioGo     01-27-96    Changed from busy (Sleep(0)) wait to event

--*/

#include <precomp.hxx>
#include <locks.hxx>

//
// CShareLock methods
//


#if defined(NTENV) && !defined(_WIN64)
// extern DWORD GetCurrentThreadId(void);
#define GetCurrentThreadId() ((DWORD)NtCurrentTeb()->ClientId.UniqueThread)
#endif

CSharedLock::CSharedLock(RPC_STATUS &status)
{
    exclusive_owner = 0;
    writers = 0;
    hevent = INVALID_HANDLE_VALUE;  // Flag in the d'tor
    
    if (status == RPC_S_OK)
        {
        __try {
            InitializeCriticalSection(&lock);
            }
        __except( GetExceptionCode() == ERROR_OUTOFMEMORY )
            {
            status = RPC_S_OUT_OF_MEMORY;
        }
    
        if (status == RPC_S_OK)
            {
            hevent = CreateEvent(0, FALSE, FALSE, 0);
            if (0 == hevent)
                {
                status = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
        }
}

CSharedLock::~CSharedLock()
{
    if (hevent != INVALID_HANDLE_VALUE)
        {
        DeleteCriticalSection(&lock);

        if (hevent) CloseHandle(hevent);
        }
}

void
CSharedLock::LockShared()
{
    readers++;

    LogEvent(SU_MUTEX, EV_INC, this, 0, readers);

    if (writers)
        {
        if ((readers--) == 0)
            {
            SetEvent(hevent);
            }

        EnterCriticalSection(&lock);
        readers++;
        LeaveCriticalSection(&lock);
        }

    exclusive_owner = 0;
}

void
CSharedLock::UnlockShared(void)
{
    ASSERT((LONG)readers > 0);
    ASSERT(exclusive_owner == 0);

    if ( (readers--) == 0 && writers)
        {
        SetEvent(hevent);
        }

    LogEvent(SU_MUTEX, EV_DEC, this, 0, readers);
}

void
CSharedLock::LockExclusive(void)
{
    EnterCriticalSection(&lock);

    LogEvent(SU_MUTEX, EV_INC, this, ULongToPtr(0x99999999), writers+1);

    writers++;
    while(readers)
        {
        WaitForSingleObject(hevent, INFINITE);
        }
    ASSERT(writers);
    exclusive_owner = GetCurrentThreadId();
}

void
CSharedLock::UnlockExclusive(void)
{
    LogEvent(SU_MUTEX, EV_DEC, this, ULongToPtr(0x99999999), writers-1);

    ASSERT(HeldExclusive());
    ASSERT(writers);
    writers--;
    exclusive_owner = 0;
    LeaveCriticalSection(&lock);
}

void
CSharedLock::Unlock()
{
    // Either the lock is held exclusively by this thread or the thread
    // has a shared lock. (or the caller has a bug).

    if (HeldExclusive())
        {
        UnlockExclusive();
        }
    else
        {
        UnlockShared();
        }
}

void
CSharedLock::ConvertToExclusive(void)
{
    ASSERT((LONG)readers > 0);
    ASSERT(exclusive_owner == 0);

    if ( (readers--) == 0 && writers )
        SetEvent(hevent);

    EnterCriticalSection(&lock);
    writers++;
    while(readers)
        {
        WaitForSingleObject(hevent, INFINITE);
        }
    ASSERT(writers);
    exclusive_owner = GetCurrentThreadId();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\lpcsvr.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    lpcsvr.cxx

Abstract:

    Implementation of the RPC on LPC protocol engine for the server.

Revision History:
    Mazhar Mohammed: Code fork from spcsvr.cxx, 08/02/95
    05-06-96: Merged WMSG and LRPC into a single protocol
    Mazhar Mohammed  Added Pipes Support
    Mazhar Mohammed  Added support for Async RPC 08-14-96
    Mazhar Mohammed  No more WMSG 9/22/97
    Kamen Moutafov      (kamenm)    Jan-2000    Support for multiple transfer syntaxes
    Kamen Moutafov (KamenM) Dec 99 - Feb 2000 - Support for cell debugging stuff
    Kamen Moutafov      (KamenM)    Mar-2000    Support for extended error info
--*/

#include <precomp.hxx>
#include <queue.hxx>
#include <hndlsvr.hxx>
#include <lpcpack.hxx>
#include <lpcsvr.hxx>
#include <ProtBind.hxx>
#include <lpcclnt.hxx>
#include <CharConv.hxx>


inline BOOL
RecvLotsaCallsWrapper(
      LRPC_ADDRESS  * Address
      )
{
  Address->ReceiveLotsaCalls();
  return(FALSE);
}

inline RPC_STATUS
InitializeLrpcIfNecessary(
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

--*/

{
    int nIndex ;
    RPC_STATUS Status ;

    if (GlobalLrpcServer == 0)
        {
        if ((Status = InitializeLrpcServer()) != RPC_S_OK)
            {
            return Status ;
            }
        }

    return (RPC_S_OK) ;
}


LRPC_SERVER::LRPC_SERVER(
    IN OUT RPC_STATUS  *Status
    ) : ServerMutex(Status,
                    TRUE    // pre-allocate semaphore
                    )
{
    Address = NULL ;
    EndpointInitialized = 0 ;
}


RPC_STATUS
LRPC_SERVER::InitializeAsync (
    )
{
    RPC_CHAR Endpoint[20];
    RPC_STATUS Status = RPC_S_OK ;

    if (EndpointInitialized == 0)
        {
        swprintf(Endpoint, RPC_CONST_STRING("MSAsyncRPC_%d"),
                        GetCurrentProcessId()) ;

        Status = RpcServerUseProtseqEpW (
            RPC_STRING_LITERAL("ncalrpc"), 100, Endpoint, NULL) ;
        if (Status != RPC_S_OK)
            {
            return Status ;
            }

        Status = GlobalRpcServer->ServerListen(1, 100, 1) ;

        if (Status == RPC_S_OK)
            {
            Status = SetEndpoint(Endpoint) ;
            }
        }

    return Status ;
}


RPC_STATUS
InitializeLrpcServer (
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/

{
    RPC_STATUS Status = RPC_S_OK ;

    GlobalMutexRequest() ;

    if (GlobalLrpcServer == 0)
        {
        GlobalLrpcServer = new LRPC_SERVER(&Status) ;

        if (GlobalLrpcServer == 0)
            {
#if DBG
            PrintToDebugger("LRPC: LRPC_SERVER initialization failed\n") ;
#endif

            GlobalMutexClear() ;

            return (RPC_S_OUT_OF_MEMORY) ;
            }

        if (Status != RPC_S_OK)
            {
            GlobalMutexClear() ;

            delete GlobalLrpcServer ;
            GlobalLrpcServer = 0 ;

            return Status ;
            }
        }

    GlobalMutexClear() ;

    return (RPC_S_OK) ;
}

void
SetCommonFaultFields (
    IN LRPC_MESSAGE *LrpcMessage,
    IN RPC_STATUS Status,
    IN int Flags,
    IN int AdditionalLength
    )
{
    LrpcMessage->Fault.RpcHeader.MessageType = LRPC_MSG_FAULT;
    LrpcMessage->Fault.RpcStatus = Status;
    LrpcMessage->LpcHeader.u1.s1.DataLength =
        sizeof(LRPC_FAULT_MESSAGE) - sizeof(PORT_MESSAGE) 
        - sizeof(LrpcMessage->Fault.Buffer) + (CSHORT)AdditionalLength;
    LrpcMessage->LpcHeader.u1.s1.TotalLength =
        sizeof(LRPC_FAULT_MESSAGE) - sizeof(LrpcMessage->Fault.Buffer) 
        + (CSHORT)AdditionalLength;

    if ((Flags & LRPC_SYNC_CLIENT) == 0)
        {
        LrpcMessage->LpcHeader.u2.ZeroInit = 0;
        LrpcMessage->LpcHeader.CallbackId = 0 ;
        LrpcMessage->LpcHeader.MessageId = 0 ;
        LrpcMessage->LpcHeader.u2.s2.DataInfoOffset = 0;
        }
}

void
SetCommonFault2Fields (
    IN LRPC_MESSAGE *LrpcMessage,
    IN RPC_STATUS Status,
    IN unsigned int Length,
    IN void *Buffer
    )
{
    LrpcMessage->Fault2.RpcHeader.MessageType = LRPC_MSG_FAULT2;
    LrpcMessage->Fault2.RpcStatus = Status;
    LrpcMessage->LpcHeader.u1.s1.DataLength =
        sizeof(LRPC_FAULT2_MESSAGE) - sizeof(PORT_MESSAGE);
    LrpcMessage->LpcHeader.u1.s1.TotalLength =
        sizeof(LRPC_FAULT2_MESSAGE);
    // the Server/DataEntries must have been set in GetBuffer - no
    // need to reset them here
    LrpcMessage->Fault2.RpcHeader.Flags |= LRPC_EEINFO_PRESENT;
}

void
TrimIfNecessaryAndSetImmediateBuffer (
    IN LRPC_MESSAGE *LrpcMessage,
    IN RPC_STATUS Status,
    IN int Flags,
    IN size_t EstimatedEEInfoSize,
    IN BOOL fTrimEEInfo,
    IN ExtendedErrorInfo *CurrentEEInfo
    )
{
    size_t NeededLength;
    RPC_STATUS RpcStatus;

    if (fTrimEEInfo)
        {
        ASSERT(MAXIMUM_FAULT_MESSAGE >= MinimumTransportEEInfoLength);
        TrimEEInfoToLength (MAXIMUM_FAULT_MESSAGE, &NeededLength);

        if (NeededLength == 0)
            {
            SetCommonFaultFields(LrpcMessage, Status, Flags, 0);
            return;
            }

        ASSERT(NeededLength <= MAXIMUM_FAULT_MESSAGE);
        EstimatedEEInfoSize = NeededLength;
        // fall through to the next if - it will succeed
        // as we know the length is trimmed.
        }
    else
        {
        ASSERT(EstimatedEEInfoSize <= MAXIMUM_FAULT_MESSAGE);
        }

    RpcStatus = PickleEEInfo(CurrentEEInfo, 
        LrpcMessage->Fault.Buffer, 
        MAXIMUM_FAULT_MESSAGE);
    if (RpcStatus != RPC_S_OK)
        {
        SetCommonFaultFields(LrpcMessage, Status, Flags, 0);
        return;
        }

    SetCommonFaultFields(LrpcMessage, Status, Flags, EstimatedEEInfoSize);
    LrpcMessage->Fault.RpcHeader.Flags |= LRPC_EEINFO_PRESENT;
}


void
SetFaultPacket (
    IN LRPC_MESSAGE *LrpcMessage,
    IN RPC_STATUS Status,
    IN int Flags,
    IN LRPC_SCALL *CurrentCall OPTIONAL
    )
/*++

Routine Description:

    Initialize a fault packet

Arguments:

    LrpcMessage - Fault message
    Status - Fault status
    Flags - Flags from the request message

--*/

{
    THREAD *Thread;
    ExtendedErrorInfo *CurrentEEInfo;
    size_t EstimatedEEInfoSize;
    RPC_STATUS RpcStatus;
    RPC_MESSAGE RpcMessage;

    // we will see whether there is extended error information here
    // and try to send it. If we run in out-of-memory, or there is
    // no EEInfo, send plain old fault.
    Thread = ThreadSelf();
    if (Thread && g_fSendEEInfo)
        {
        CurrentEEInfo = Thread->GetEEInfo();
        if (CurrentEEInfo)
            {
            // if this function runs in out-of-memory, it will
            // return 0.
            EstimatedEEInfoSize = EstimateSizeOfEEInfo();
            if (EstimatedEEInfoSize == 0)
                {
                SetCommonFaultFields(LrpcMessage, Status, Flags, 0);
                return;
                }

            // if there is no current call, we cannot send arbitrary length
            // data, so we must trim the EEInfo
            if (CurrentCall == NULL)
                {
                TrimIfNecessaryAndSetImmediateBuffer(LrpcMessage,
                    Status,
                    Flags,
                    EstimatedEEInfoSize,
                    TRUE,
                    CurrentEEInfo);
                return;
                }

            if (EstimatedEEInfoSize <= MAXIMUM_FAULT_MESSAGE)
                {
                TrimIfNecessaryAndSetImmediateBuffer(LrpcMessage,
                    Status,
                    Flags,
                    EstimatedEEInfoSize,
                    FALSE,
                    CurrentEEInfo);
                return;
                }

            ASSERT(CurrentCall != NULL);

            // here, the estimated EEInfo size is larger that the available
            // space in the fault packet. We have a call, so we must try
            // sending a fault2 packet.
            RpcMessage.Handle = CurrentCall;
            RpcMessage.RpcFlags = CurrentCall->RpcMessage.RpcFlags;
            // increase the buffer lenght in case we fall in the window
            // b/n MAXIMUM_MESSAGE_BUFFER and the EstimatedEEInfoSize. If we
            // do, GetBuffer will return us an immediate buffer, and this is
            // not something we want
            RpcMessage.BufferLength = max(EstimatedEEInfoSize, MAXIMUM_MESSAGE_BUFFER + 4);
            RpcStatus = CurrentCall->LRPC_SCALL::GetBuffer(&RpcMessage, NULL);
            if (RpcStatus != RPC_S_OK)
                {
                // can't send the full data - trim and send
                TrimIfNecessaryAndSetImmediateBuffer(LrpcMessage,
                    Status,
                    Flags,
                    EstimatedEEInfoSize,
                    TRUE,
                    CurrentEEInfo);
                return;
                }

            ASSERT(CurrentCall->LrpcReplyMessage->Rpc.RpcHeader.Flags != LRPC_BUFFER_IMMEDIATE);
            // on success, GetBuffer has allocated a buffer in RpcMessage.Buffer
            // and has setup CurrentCall->LrpcReplyMessage for sending to
            // the client.
            // Fill in the EEInfo
            RpcStatus = PickleEEInfo(CurrentEEInfo, 
                (unsigned char *)RpcMessage.Buffer, 
                EstimatedEEInfoSize);
            if (RpcStatus != RPC_S_OK)
                {
                if (!CurrentCall->IsClientAsync())
                    CurrentCall->Association->Buffers.DeleteItemByBruteForce(RpcMessage.Buffer);
                RpcpFarFree(RpcMessage.Buffer);

                // can't send the full data - trim and send
                TrimIfNecessaryAndSetImmediateBuffer(LrpcMessage,
                    Status,
                    Flags,
                    EstimatedEEInfoSize,
                    TRUE,
                    CurrentEEInfo);
                return;
                }

            // Send to the client
            if (CurrentCall->IsClientAsync())
                {
                if (!CurrentCall->IsSyncCall())
                    {
                    ASSERT(CurrentCall->LrpcAsyncReplyMessage == CurrentCall->LrpcReplyMessage);
                    }
                SetCommonFault2Fields(CurrentCall->LrpcReplyMessage,
                    Status,
                    RpcMessage.BufferLength,
                    RpcMessage.Buffer);
                }
            else
                {
                // send the data for sync client
                // set fault2 fields

                SetCommonFault2Fields(CurrentCall->LrpcReplyMessage,
                    Status,
                    RpcMessage.BufferLength,
                    RpcMessage.Buffer);

                // our caller will do the sending
                }
            return;
            }
        }

    SetCommonFaultFields(LrpcMessage, Status, Flags, 0);
}

void
SetBindAckFault (
    IN LRPC_MESSAGE *LrpcMessage,
    IN RPC_STATUS Status
    )
/*++

Routine Description:

    Initialize a fault bind ack packet (bind_nak). It will add extended
    error info if there is some, and sending of eeinfo is enabled.

Arguments:

    LrpcMessage - Bind message
    Status - Fault status

--*/
{
    size_t NeededLength;
    ExtendedErrorInfo *EEInfo;

    ASSERT(IsBufferAligned(LrpcMessage->Bind.BindExchange.Buffer));

    ASSERT(MAX_BIND_NAK >= MinimumTransportEEInfoLength);

    LrpcMessage->Bind.BindExchange.RpcStatus = Status;

    if (g_fSendEEInfo)
        {
        EEInfo = RpcpGetEEInfo();
        if (EEInfo)
            {
            TrimEEInfoToLength (MAX_BIND_NAK, &NeededLength);

            if (NeededLength != 0)
                {
                Status = PickleEEInfo(EEInfo, 
                    LrpcMessage->Bind.BindExchange.Buffer, 
                    MAX_BIND_NAK);
                if (Status == RPC_S_OK)
                    {
                    LrpcMessage->Bind.BindExchange.Flags |= EXTENDED_ERROR_INFO_PRESENT;
                    LrpcMessage->LpcHeader.u1.s1.DataLength = (CSHORT)NeededLength + 
                        BIND_NAK_PICKLE_BUFFER_OFFSET
                        - sizeof(PORT_MESSAGE);
                    }
                }
            }
        }

    if (!(LrpcMessage->Bind.BindExchange.Flags & EXTENDED_ERROR_INFO_PRESENT))
        {
        LrpcMessage->LpcHeader.u1.s1.DataLength = sizeof(LRPC_BIND_MESSAGE)
                - sizeof(PORT_MESSAGE);
        }
}


LRPC_ADDRESS::LRPC_ADDRESS (
    OUT RPC_STATUS * Status
    ) : RPC_ADDRESS(Status),
    ThreadsDoingLongWait(0)
/*++

--*/
{
    ObjectType = LRPC_ADDRESS_TYPE;
    LpcAddressPort = 0;
    CallThreadCount = 0;
    ActiveCallCount = 0;
    ServerListeningFlag = 0;
    AssociationCount = 0;
    fServerThreadsStarted = 0;
    SequenceNumber = 1;
    fTickleMessageAvailable = FALSE;
    TickleMessage = NULL;

    if (IsServerSideDebugInfoEnabled())
        {
        DebugCell = (DebugEndpointInfo *)AllocateCell(&DebugCellTag);
        if (DebugCell == NULL)
            {
            *Status = RPC_S_OUT_OF_MEMORY;
            }
        else
            {
            DebugCell->TypeHeader = 0;
            DebugCell->Type = dctEndpointInfo;
            DebugCell->ProtseqType = (UCHAR)LRPC_TOWER_ID;
            DebugCell->Status = desAllocated;
            memset(DebugCell->EndpointName, 0, sizeof(DebugCell->EndpointName));
            }
        }
    else
        DebugCell = NULL;

}


RPC_STATUS
LRPC_ADDRESS::ServerStartingToListen (
    IN unsigned int MinimumCallThreads,
    IN unsigned int MaximumConcurrentCalls
    )
/*++

Routine Description:

    This routine gets called when RpcServerListen is called by the application.
    We need to create the threads we need to receive remote procedure calls.

Arguments:

    MinimumCallThreads - Supplies the minimum number of threads which we
        must create.

    MaximumConcurrentCalls - Unused.

Return Value:

    RPC_S_OK - Ok, this address is all ready to start listening for remote
        procedure calls.

    RPC_S_OUT_OF_THREADS - We could not create enough threads so that we
        have at least the minimum number of call threads required (as
        specified by the MinimumCallThreads argument).

--*/
{
    RPC_STATUS Status;

    UNUSED(MaximumConcurrentCalls);

    if (fServerThreadsStarted == 0)
        {
        Status = InitializeServerSideCellHeapIfNecessary();
        if (Status != RPC_S_OK)
            return Status;

        this->MinimumCallThreads = MinimumCallThreads;
        AddressMutex.Request();
        if (CallThreadCount < this->MinimumCallThreads)
            {
            Status = Server->CreateThread((THREAD_PROC)&RecvLotsaCallsWrapper,
                                          this);

            if (Status != RPC_S_OK)
                {
                AddressMutex.Clear();
                VALIDATE(Status)
                    {
                    RPC_S_OUT_OF_THREADS,
                    RPC_S_OUT_OF_MEMORY
                    } END_VALIDATE;
                
                return(Status);
                }
            CallThreadCount += 1;
            }
        AddressMutex.Clear();
        fServerThreadsStarted = 1;
        }

    ServerListeningFlag = 1;
    return(RPC_S_OK);
}


void
LRPC_ADDRESS::ServerStoppedListening (
    )
/*++

Routine Description:

    We just need to indicate that the server is no longer listening, and
    set the minimum call thread count to one.

--*/
{
    ServerListeningFlag = 0;
    MinimumCallThreads = 1;
}

#ifdef DEBUGRPC

// Hard coded world (aka EveryOne) SID
const SID World = { 1, 1, { 0, 0, 0, 0, 0, 1}, 0};

// Hard coded anonymous SID
const SID AnonymousLogonSid = { 1, 1, SECURITY_NT_AUTHORITY, SECURITY_ANONYMOUS_LOGON_RID};

SECURITY_DESCRIPTOR *DefaultPortSD = NULL;

RPC_STATUS
CreateAndGetDefaultPortSDIfNecessary (
    OUT SECURITY_DESCRIPTOR **PortSD
    )
/*++
Function Name: CreateAndGetDefaultPortSDIfNecessary

Parameters:
    PortSD - receives the default port SD on success.
        Undefined on failure

Description:
    If the default port SD is not created, creates it,
    and returns it. If it is already created, it simply
    returns it. The function is thread-safe.

Returns:
    RPC_S_OK or other codes for error.

--*/
{
    DWORD DaclSize;
    PACL Dacl;
    ULONG LengthOfDacl;
    SECURITY_DESCRIPTOR *LocalDefaultSD;    // we work on a local copy to make 
                                            // this thread safe

    if (DefaultPortSD)
        {
        *PortSD = DefaultPortSD;
        return RPC_S_OK;
        }

    LocalDefaultSD = new SECURITY_DESCRIPTOR;

    if (   LocalDefaultSD == 0
        || !InitializeSecurityDescriptor(LocalDefaultSD,
                                       SECURITY_DESCRIPTOR_REVISION) )
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    ASSERT(GetSidLengthRequired(SID_MAX_SUB_AUTHORITIES) <= 0x44);

    DaclSize = 2 * sizeof(ACCESS_ALLOWED_ACE) + sizeof(World) + sizeof(AnonymousLogonSid) + 0x44;
    LengthOfDacl = DaclSize + sizeof(ACL);
    Dacl = (ACL *) new char[LengthOfDacl];

    if (NULL == Dacl)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    ASSERT(IsValidSid((PVOID)&World));
    ASSERT(IsValidSid((PVOID)&AnonymousLogonSid));

    InitializeAcl(Dacl, LengthOfDacl, ACL_REVISION);

    if (!AddAccessAllowedAce(Dacl, ACL_REVISION,
                             PORT_ALL_ACCESS,
                             (PVOID)&World))
        {
        // this should never fail unless we messed up the
        // parameters or there is a version mismatch
        ASSERT(0);
        delete Dacl;
        delete LocalDefaultSD;
        return(RPC_S_OUT_OF_RESOURCES);
        }
    if (!AddAccessAllowedAce(Dacl, ACL_REVISION,
                             PORT_ALL_ACCESS,
                             (PVOID)&AnonymousLogonSid ))
        {
        // this should never fail unless we messed up the
        // parameters or there is a version mismatch
        ASSERT(0);
        delete Dacl;
        delete LocalDefaultSD;
        return(RPC_S_OUT_OF_RESOURCES);
        }

    if (!SetSecurityDescriptorDacl(LocalDefaultSD, TRUE, Dacl, FALSE))
        {
        delete Dacl;
        delete LocalDefaultSD;
        return(RPC_S_OUT_OF_RESOURCES);
        }

    if (InterlockedCompareExchangePointer((PVOID *)&DefaultPortSD,
        LocalDefaultSD,
        NULL) != NULL)
        {
        // somebody beat us to the punch - free our local copy
        delete Dacl;
        delete LocalDefaultSD;
        }

    *PortSD = DefaultPortSD;

    return RPC_S_OK;
}
#endif


RPC_STATUS
LRPC_ADDRESS::ActuallySetupAddress (
    IN RPC_CHAR  * Endpoint,
    IN void  * SecurityDescriptor OPTIONAL
    )
/*++
Function Name:ActuallySetupAddress

Parameters:

Description:

Returns:

--*/
{
    NTSTATUS NtStatus;
    RPC_CHAR * LpcPortName;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    RPC_STATUS Status;
#ifdef DEBUGRPC
    BOOL Result;
    BOOL DaclPresent;
    PACL Dacl;
    BOOL Ignored;
#endif

    // Allocate and initialize the port name.  We need to stick the
    // LRPC_DIRECTORY_NAME on the front of the endpoint.  This is for
    // security reasons (so that anyone can create LRPC endpoints).

    LpcPortName = new RPC_CHAR[RpcpStringLength(Endpoint)
            + RpcpStringLength(LRPC_DIRECTORY_NAME) + 1];
    if (LpcPortName == 0)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    RpcpMemoryCopy(
                   LpcPortName,
                   LRPC_DIRECTORY_NAME,
                   RpcpStringLength(LRPC_DIRECTORY_NAME) *sizeof(RPC_CHAR));

    RpcpMemoryCopy(
                   LpcPortName + RpcpStringLength(LRPC_DIRECTORY_NAME),
                   Endpoint,
                   (RpcpStringLength(Endpoint) + 1) *sizeof(RPC_CHAR));

    RtlInitUnicodeString(&UnicodeString, LpcPortName);

#ifdef DEBUGRPC
    // in checked builds we check the security descriptor for NULL Dacl,
    // and if present, we replace it with a default "allow everyone"
    // Dacl. This was requested by ChrisW (12/14/2000) from the Security 
    // Team so that they can get LPC ports out of the picture, and then 
    // ASSERT on NULL Dacls for other objects
    if (SecurityDescriptor)
        {
        Result = GetSecurityDescriptorDacl(SecurityDescriptor,
            &DaclPresent,
            &Dacl,
            &Ignored  // lpbDaclDefaulted
            );

        if (!Result)
            {
            // invalid security descriptor is the only reason this could fail
            delete LpcPortName;
            return RPC_S_INVALID_ENDPOINT_FORMAT;
            }

        if (DaclPresent && (Dacl == NULL))
            {
            Status = CreateAndGetDefaultPortSDIfNecessary((SECURITY_DESCRIPTOR **)&SecurityDescriptor);
            if (Status != RPC_S_OK)
                {
                delete LpcPortName;
                return Status;
                }

            // We were able to grab a default port SD - just let it through
            }
        // else 
        //    {
        //    the security descriptor supplied by caller has non NULL Dacl - let
        //    it through
        //    }
        }
#endif

    InitializeObjectAttributes(
                            &ObjectAttributes,
                            &UnicodeString,
                            OBJ_CASE_INSENSITIVE,
                            0,
                            SecurityDescriptor);

    NtStatus = NtCreatePort(
                            &LpcAddressPort,
                            &ObjectAttributes,
                            sizeof(LRPC_BIND_EXCHANGE),
                            PORT_MAXIMUM_MESSAGE_LENGTH,
                            0);

    delete LpcPortName;
    if (NT_SUCCESS(NtStatus))
        {
        Status = LrpcSetEndpoint(Endpoint);
        return(Status);
        }

    if (NtStatus == STATUS_NO_MEMORY)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }
    if ((NtStatus == STATUS_INSUFFICIENT_RESOURCES)
        || (NtStatus == STATUS_QUOTA_EXCEEDED))
        {
        return(RPC_S_OUT_OF_RESOURCES);
        }
    if ((NtStatus == STATUS_OBJECT_PATH_INVALID)
        || (NtStatus == STATUS_OBJECT_PATH_NOT_FOUND)
        || (NtStatus == STATUS_OBJECT_NAME_INVALID)
        || (NtStatus == STATUS_OBJECT_TYPE_MISMATCH)
        || (NtStatus == STATUS_INVALID_OWNER))
        {
        return(RPC_S_INVALID_ENDPOINT_FORMAT);
        }

#if DBG
        if (NtStatus != STATUS_OBJECT_NAME_COLLISION)
        {
        PrintToDebugger("RPC : NtCreatePort : %lx\n", NtStatus);
        }
#endif // DBG

    ASSERT(NtStatus == STATUS_OBJECT_NAME_COLLISION);
    return(RPC_S_DUPLICATE_ENDPOINT);
}


extern RPC_CHAR  *
ULongToHexString (
    IN RPC_CHAR  * String,
    IN unsigned long Number
    );


RPC_STATUS
LRPC_ADDRESS::ServerSetupAddress (
    IN RPC_CHAR * NetworkAddress,
    IN RPC_CHAR  *  *Endpoint,
    IN unsigned int PendingQueueSize,
    IN void  * SecurityDescriptor, OPTIONAL
    IN unsigned long EndpointFlags,
    IN unsigned long NICFlags,
    OUT NETWORK_ADDRESS_VECTOR **ppNetworkAddressVector
    )
/*++

Routine Description:

    We need to setup the connection port and get ready to receive remote
    procedure calls.  We will use the name of this machine as the network
    address.

Arguments:

    Endpoint - Supplies the endpoint to be used will this address.

    NetworkAddress - Returns the network address for this server.  The
        ownership of the buffer allocated to contain the network address
        passes to the caller.

    SecurityDescriptor - Optionally supplies a security descriptor to
        be placed on this address.

    PendingQueueSize - Unused.

    RpcProtocolSequence - Unused.

Return Value:

    RPC_S_OK - We successfully setup this address.

    RPC_S_INVALID_SECURITY_DESC - The supplied security descriptor is
        invalid.

    RPC_S_CANT_CREATE_ENDPOINT - The endpoint format is correct, but
        the endpoint can not be created.

    RPC_S_INVALID_ENDPOINT_FORMAT - The endpoint is not a valid
        endpoint for this particular transport interface.

    RPC_S_OUT_OF_RESOURCES - Insufficient resources are available to
        setup the address.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to setup
        the address.

--*/
{
    BOOL Boolean;
    RPC_CHAR * String;
    RPC_STATUS Status ;
    RPC_CHAR DynamicEndpoint[64];
    static unsigned int DynamicEndpointCount = 0;
    DWORD NetworkAddressLength = MAX_COMPUTERNAME_LENGTH + 1;
    ULONG EndpointLength;

    UNUSED(PendingQueueSize);

    if (*Endpoint)
        {
        // the maximum allowed length in bytes is the
        // string length in bytes (string length * 2) + the NULL 
        // terminator
        EndpointLength = RpcpStringLength(*Endpoint) * 2 + 2;
        if (EndpointLength > BIND_BACK_PORT_NAME_LEN)
            {
            RpcpErrorAddRecord(EEInfoGCRuntime, 
                RPC_S_INVALID_ENDPOINT_FORMAT,
                EEInfoDLLRPC_ADDRESS__ServerSetupAddress10,
                *Endpoint,
                EndpointLength,
                BIND_BACK_PORT_NAME_LEN);
            return RPC_S_INVALID_ENDPOINT_FORMAT;
            }
        }

    Status = InitializeLrpcIfNecessary() ;

    if (Status != RPC_S_OK)
        {
        return Status ;
        }

    ASSERT(GlobalLrpcServer != 0) ;

    *ppNetworkAddressVector = (NETWORK_ADDRESS_VECTOR *)
        new char[ sizeof(NETWORK_ADDRESS_VECTOR) + sizeof(RPC_CHAR *) + sizeof(RPC_CHAR) * (MAX_COMPUTERNAME_LENGTH + 1)];

    if (*ppNetworkAddressVector == NULL)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    (*ppNetworkAddressVector)->Count = 1;
    (*ppNetworkAddressVector)->NetworkAddresses[0] = (RPC_CHAR *)
        (((char *) *ppNetworkAddressVector) + sizeof(NETWORK_ADDRESS_VECTOR) + sizeof(RPC_CHAR *));

    Boolean = GetComputerNameW(
                      (*ppNetworkAddressVector)->NetworkAddresses[0],
                      &NetworkAddressLength);

    if (Boolean != TRUE)
        {
        Status = GetLastError();
#if DBG
        PrintToDebugger("RPC : GetComputerNameW : %d\n", Status);
#endif // DBG

        if (Status == ERROR_NOT_ENOUGH_MEMORY)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            }
        else if ((Status == ERROR_NOT_ENOUGH_QUOTA)
                 || (Status == ERROR_NO_SYSTEM_RESOURCES))
            {
            Status = RPC_S_OUT_OF_RESOURCES;
            }
        else
            {
            ASSERT(0);
            Status = RPC_S_OUT_OF_MEMORY;
	    }

        goto Cleanup;
        }

    if (*Endpoint)
        {
        Status = ActuallySetupAddress(*Endpoint, SecurityDescriptor);
        }
    else
        {
        for (;;)
            {
            String = DynamicEndpoint;

            *String++ = RPC_CONST_CHAR('L');
            *String++ = RPC_CONST_CHAR('R');
            *String++ = RPC_CONST_CHAR('P');
            *String++ = RPC_CONST_CHAR('C');

            String = ULongToHexString(String,
                       PtrToUlong(NtCurrentTeb()->ClientId.UniqueProcess));
            DynamicEndpointCount += 1;
            *String++ = RPC_CONST_CHAR('.');
            String = ULongToHexString(String, DynamicEndpointCount);
            *String = 0;

            Status = ActuallySetupAddress(DynamicEndpoint, SecurityDescriptor);

            if (Status != RPC_S_DUPLICATE_ENDPOINT)
                {
                break;
                }
            }

        if (Status == RPC_S_OK)
            {
            *Endpoint = DuplicateString(DynamicEndpoint);
            if (*Endpoint == 0)
                {
                Status = RPC_S_OUT_OF_MEMORY;
                }
            else
                {
                return(RPC_S_OK);
                }
            }
        }

Cleanup:
    if (Status != RPC_S_OK)
        {
        delete *ppNetworkAddressVector;
        *ppNetworkAddressVector = 0;
        }

    return Status;
}

RPC_STATUS
LRPC_ADDRESS::CompleteListen (
    )
/*++
Function Name:CompleteListen

Parameters:

Description:

Returns:

--*/
{
    LRPC_ADDRESS *LocalAddress;

    if (DebugCell)
        {
        CStackAnsi AnsiEndpoint;
        int i;
        RPC_STATUS RpcStatus;

        i = RpcpStringLength(InqEndpoint()) + 1;
        *(AnsiEndpoint.GetPAnsiString()) = (char *)_alloca(i);

        RpcStatus = AnsiEndpoint.Attach(InqEndpoint(), i, i * 2);

        // note that effectively we ignore the result. That's ok - we don't
        // want servers to be unable to start because of code page issues
        // in the debug path. If this fails and we ignore it, the worse
        // that can happen is to have empty endpoint in the debug cell 
        // - not a big deal.
        if (RpcStatus == RPC_S_OK)
            {
            strncpy(DebugCell->EndpointName, AnsiEndpoint, sizeof(DebugCell->EndpointName));
            }
        
        DebugCell->Status = desActive;
        }

    do
        {
        AddressChain = LrpcAddressList;
        }
    while (InterlockedCompareExchangePointer((PVOID *)&LrpcAddressList, this, LrpcAddressList) != AddressChain);

    return(RPC_S_OK);
}



inline LRPC_SASSOCIATION *
LRPC_ADDRESS::ReferenceAssociation (
    IN unsigned long AssociationKey
    )
/*++

Routine Description:

    Given an assocation key, we need to map it into an association.  The
    association may already have been deleted, in which case, we need to
    return zero.

Arguments:

    AssociationKey - Supplies the key to be used to map into an association.

Return Value:

    If the association still exists, it will be returned; otherwise, zero
    will be returned.

--*/
{
    LRPC_SASSOCIATION * Association;
    LPC_KEY *LpcKey = (LPC_KEY *) &AssociationKey;
    USHORT MySequenceNumber;

    ASSERT(SERVERKEY(AssociationKey));

    MySequenceNumber = LpcKey->SeqNumber & ~SERVER_KEY_MASK;

    AddressMutex.Request();
    Association = AssociationDictionary.Find(LpcKey->AssocKey);
    if (Association == 0
        || Association->SequenceNumber != MySequenceNumber)
        {
        AddressMutex.Clear();
        return(0);
        }
    Association->AssociationReferenceCount++;

    LogEvent(SU_SASSOC, EV_INC, Association, 0,
             Association->AssociationReferenceCount, 1, 1);
    AddressMutex.Clear();

    return(Association);
}


inline LRPC_CASSOCIATION *
LRPC_ADDRESS::ReferenceClientAssoc (
    IN unsigned long AssociationKey
    )
/*++

Routine Description:

    Given an assocation key, we need to map it into an association.  The
    association may already have been deleted, in which case, we need to
    return zero.

Arguments:

    AssociationKey - Supplies the key to be used to map into an association.

Return Value:

    If the association still exists, it will be returned; otherwise, zero
    will be returned.

--*/
{
    LRPC_CASSOCIATION * Association;
    LPC_KEY *LpcKey = (LPC_KEY *) &AssociationKey;

    LrpcMutexRequest();
    Association = LrpcAssociationDict->Find(LpcKey->AssocKey);
    if (Association == 0
        || Association->SequenceNumber != LpcKey->SeqNumber)
        {
        LrpcMutexClear();
        return(0);
        }

    Association->AddReference();
    LrpcMutexClear();

    return(Association);
}

#if defined(_WIN64)
#define BAD_HANDLE_CONST  ((HANDLE)0xbaaaaaadbaaaaaad)
#else
#define BAD_HANDLE_CONST  (ULongToHandle(0xbaaaaaad))
#endif


inline void
LRPC_ADDRESS::DereferenceAssociation (
    IN LRPC_SASSOCIATION * Association
    )
/*++

Routine Description:

    We are done using this address, so the reference count can be decremented.
    If no one is referencing this association, then we can go ahead and
    delete it.

Arguments:

    Association - Supplies the association whose reference count should be
        decremented.

--*/
{
    NTSTATUS NtStatus;

    AddressMutex.Request();

    Association->AssociationReferenceCount -= 1;

    ASSERT(Association->AssociationReferenceCount >= 0);

    LogEvent(SU_SASSOC, EV_DEC, Association, 0,
             Association->AssociationReferenceCount, 1, 1);

    if (Association->AssociationReferenceCount <= 0)
        {
        AssociationDictionary.Delete(Association->DictionaryKey);
        AssociationCount--;
        AddressMutex.Clear();

        if (Association->LpcServerPort)
            {
            NtStatus = NtClose(Association->LpcServerPort);
            Association->LpcServerPort = BAD_HANDLE_CONST;
            LogEvent(SU_SASSOC, EV_STOP, Association, Association->LpcServerPort,
                     Association->AssociationReferenceCount, 1, 1);

#if DBG
            if (!NT_SUCCESS(NtStatus))
                {
                PrintToDebugger("RPC : NtClose : %lx\n", NtStatus);
                                ASSERT(0) ;
                }
#endif // DBG
            }

        if (Association->LpcReplyPort)
            {
            NtStatus = NtClose(Association->LpcReplyPort);

#if DBG
            if (!NT_SUCCESS(NtStatus))
                {
                PrintToDebugger("RPC : NtClose : %lx\n", NtStatus);
                                ASSERT(0) ;
                }
#endif // DBG

            }

        delete Association;
        }
    else
        {
        AddressMutex.Clear();
        }
}

BOOL
LRPC_ADDRESS::DealWithLRPCRequest (
    IN LRPC_MESSAGE * LrpcMessage,
    IN LRPC_MESSAGE * LrpcReply,
    IN LRPC_SASSOCIATION *Association,
    OUT LRPC_MESSAGE **LrpcResponse
    )
/*++

Routine Description:

    Deal with a new LRPC request.

Arguments:

 LrpcMessage - request message
 LrpcReply - the reply is placed here
 Association - the association on which the request arrived

Return Value:

  FALSE if the thread should stay, or !FALSE if the thread should go
--*/

{
    int retval ;
    LRPC_SCALL *SCall;
    NTSTATUS NtStatus ;
    RPC_STATUS Status;
    LRPC_SCALL *NewSCall ;
    int Flags = LrpcMessage->Rpc.RpcHeader.Flags ;

    if (ServerListeningFlag == 0
        && GlobalRpcServer->InqNumAutoListenInterfaces() == 0)
        {
        *LrpcResponse = LrpcMessage ;
        RpcpErrorAddRecord(EEInfoGCRuntime, 
            RPC_S_SERVER_TOO_BUSY, 
            EEInfoDLDealWithLRPCRequest10,
            (ULONG)ServerListeningFlag, 
            (ULONG)GlobalRpcServer->InqNumAutoListenInterfaces());
        SetFaultPacket(*LrpcResponse,
                              RPC_S_SERVER_TOO_BUSY, Flags, NULL);
        return 0;
        }

    Status = Association->AllocateSCall(LrpcMessage,
                                       LrpcReply,
                                       Flags, 
                                       &SCall) ;
    if (Status != RPC_S_OK)
        {
        *LrpcResponse = LrpcMessage ;
        RpcpErrorAddRecord(EEInfoGCRuntime, 
            Status, 
            EEInfoDLDealWithLRPCRequest20);
        SetFaultPacket(*LrpcResponse, Status, Flags, NULL);
        return 0 ;
        }

    ASSERT(SCall);

    Status = SCall->LrpcMessageToRpcMessage(LrpcMessage,
                                            &(SCall->RpcMessage));

    if (Status != RPC_S_OK)
        {
#if DBG
        PrintToDebugger("LRPC: LrpcMessageToRpcMessage failed: %d\n",
                                                       Status) ;
#endif

        *LrpcResponse = LrpcMessage ;
        SetFaultPacket(*LrpcResponse, Status, Flags, NULL);

        Association->FreeSCall (SCall) ;
        return 0;
        }

    AddressMutex.Request();

    if (SCall->Flags & LRPC_CAUSAL)
        {
        retval = Association->MaybeQueueSCall(SCall) ;
        switch (retval)
            {
            case 0:
                break;

            case 1:
                AddressMutex.Clear();
                *LrpcResponse = NULL ;
                return 0;

            case -1:
                AddressMutex.Clear();
                *LrpcResponse = LrpcMessage ;

                RpcpErrorAddRecord(EEInfoGCRuntime, 
                    RPC_S_OUT_OF_MEMORY, 
                    EEInfoDLDealWithLRPCRequest30);
                SetFaultPacket(*LrpcResponse, LRPC_MSG_FAULT, Flags, NULL);

                Association->FreeSCall (SCall) ;
                return 0;
            }
        }

    ActiveCallCount += 1;

    if (ActiveCallCount >= CallThreadCount)
        {
        Status = Server->CreateThread(
                         (THREAD_PROC)&RecvLotsaCallsWrapper,
                         this);

        if (Status == RPC_S_OK)
            {
            CallThreadCount += 1;
            }
        else
            {
            // If the above SCall is causal and creating the thread has failed
            // then the call has been put into the dictionary and needs
            // to be removed.  It will be the only scall for the key.
            if (SCall->Flags & LRPC_CAUSAL)
                Association->ClientThreadDict.Delete(MsgClientIdToClientId(SCall->LrpcRequestMessage->Rpc.LpcHeader.ClientId).UniqueThread) ;

            ActiveCallCount -= 1;
            ASSERT((int)ActiveCallCount >= 0);
            AddressMutex.Clear();
            *LrpcResponse = LrpcMessage ;
            RpcpErrorAddRecord(EEInfoGCRuntime, 
                Status, 
                EEInfoDLDealWithLRPCRequest40);
            SetFaultPacket(*LrpcResponse,
                          RPC_S_SERVER_TOO_BUSY, Flags, NULL);

            Association->FreeSCall(SCall) ;
            return 0;
            }
        }
    AddressMutex.Clear();

    while (1)
        {
        LrpcReply->Rpc.RpcHeader.Flags = 0;

        SCall->DealWithRequestMessage();

        if ((SCall->Flags & LRPC_CAUSAL) == 0)
            {
            break;
            }

        NewSCall = Association->GetNextSCall(SCall) ;
        if (NewSCall)
            {
            SCall->SendReply();

            SCall = NewSCall ;
            while (SCall->Deleted)
                {
                FreeMessage(SCall->LrpcRequestMessage) ;

                NewSCall = Association->GetNextSCall(SCall) ;

                AddressMutex.Request();

                //
                // N.B. If a causally ordered call fails
                // in DealWithRequestMessage, this is fine, because
                // in SendReply, if we send back a fault,
                // we will mark all calls in the SCallDict with Deleted,
                // and in this loop, we will skip them.
                //
                if (NewSCall == 0)
                    {
                    if (fKeepThread())
                        {
                        retval = 0;
                        }
                    else
                        {
                        CallThreadCount -= 1;
                        retval = 1;
                        }
                    ActiveCallCount -= 1;
                    ASSERT((int)ActiveCallCount >= 0);
                    AddressMutex.Clear();

                    Association->FreeSCall(SCall) ;
                    DereferenceAssociation(Association) ;

                    *LrpcResponse = NULL ;

                    return retval;
                    }

                AddressMutex.Clear();

                Association->FreeSCall(SCall) ;
                DereferenceAssociation(Association) ;

                SCall = NewSCall ;
                }

            RpcpPurgeEEInfo();
            }
        else
            {
            break;
            }

        // Make sure that the LrpcReplyMessage is always pointing to the
        // one located on this thread's stack.  It is possible that we
        // will pick up a queued scall that was put into the queue on
        // another thread.  In this case, the LrpcReplyMessage may point to
        // that thread's stack - a recepie for disaster.
        // Note that LrpcReply is located on the stack for the current thread.
        LrpcReply->Rpc.RpcHeader.CallId = SCall->CallId ;
        SCall->LrpcReplyMessage = LrpcReply;

        }

    AddressMutex.Request();
    if (fKeepThread())
        {
        if (SCall->IsSyncCall() && SCall->IsClientAsync() == 0)
            {
            ActiveCallCount -= 1;
            ASSERT((int)ActiveCallCount >= 0);
            AddressMutex.Clear();

            *LrpcResponse = SCall->InitMsg();

            Association->FreeSCall(SCall) ;
            }
        else
            {
            AddressMutex.Clear();

            *LrpcResponse = NULL;
            SCall->SendReply();

            AddressMutex.Request();
            ActiveCallCount -= 1;
            ASSERT((int)ActiveCallCount >= 0);
            AddressMutex.Clear();
            }

        return 0 ;
        }

    //
    // This thread is extraneous, reply and return this
    // thread to the system.
    //
    ActiveCallCount -= 1;
    ASSERT((int)ActiveCallCount >= 0);
    CallThreadCount -= 1;
    AddressMutex.Clear();

    SCall->SendReply();

    return 1 ;
}

#define LRPC_LISTEN_TIMEOUT  5*60*1000

inline void
FormatTimeOut(
    OUT PLARGE_INTEGER TimeOut,
    IN DWORD Milliseconds
    )
{
    ASSERT(Milliseconds != -1);

    TimeOut->QuadPart = UInt32x32To64( Milliseconds, 10000 );
    TimeOut->QuadPart *= -1;
}

RPC_STATUS
LRPC_ADDRESS::BeginLongCall(
    void
    )
{
    RPC_STATUS Status = RPC_S_OK;

    AddressMutex.Request();

    if (ActiveCallCount + 1 >= CallThreadCount)
        {
        AddressMutex.Clear();

        Status = Server->CreateThread(
                         (THREAD_PROC)&RecvLotsaCallsWrapper,
                         this);

        AddressMutex.Request();

        // N.B. We increase the active call count
        // regrdless of Status. This is OK, because
        // if we return failure, the caller of this function
        // is responsible to decrease it
        ActiveCallCount ++;

        if (Status == RPC_S_OK)
            {
            CallThreadCount += 1;
            }
        }
    else
        {
        ActiveCallCount ++;
        }
    AddressMutex.Clear();
    return Status;
}

void LRPC_ADDRESS::HandleInvalidAssociationReference (
    IN LRPC_MESSAGE *RequestMessage,
    IN OUT LRPC_MESSAGE **ReplyMessage,
    IN ULONG AssociationKey
    )
{
    ASSERT(RequestMessage != NULL);
    ASSERT(ReplyMessage != NULL);

    // we handle only binds, requests and copies
    if ((RequestMessage->Bind.MessageType != LRPC_MSG_REQUEST)
        && (RequestMessage->Bind.MessageType != LRPC_MSG_BIND)
        && (RequestMessage->Bind.MessageType != LRPC_MSG_COPY))
        {
        *ReplyMessage = NULL;
        return;
        }

    RpcpErrorAddRecord(EEInfoGCRuntime, 
        RPC_S_CALL_FAILED_DNE,
        EEInfoDLLRPC_ADDRESS__HandleInvalidAssociationReference10,
        AssociationKey);

    if (RequestMessage->Bind.MessageType == LRPC_MSG_BIND)
        {
        SetBindAckFault(RequestMessage, RPC_S_CALL_FAILED_DNE);

        // if this is bind, patch up the fields a bit, as SetFaultPacket
        // does not set everything right for the bind case
        RequestMessage->Bind.MessageType = LRPC_BIND_ACK;
        }
    else
        {
        SetFaultPacket(RequestMessage, 
            RPC_S_CALL_FAILED_DNE, 
            RequestMessage->Rpc.RpcHeader.Flags, 
            NULL);
        }

    *ReplyMessage = RequestMessage;
}

BOOL
LRPC_ADDRESS::EndLongCall(
    void
    )
{
    AddressMutex.Request();
    ActiveCallCount -= 1;

    int SpareThreads = CallThreadCount -
        (ActiveCallCount + MinimumCallThreads);

    if (SpareThreads > 0)
        {
        ASSERT(CallThreadCount > ActiveCallCount);

        AddressMutex.Clear();

        return TRUE;
        }

    AddressMutex.Clear();

    return FALSE;
}


void
LRPC_ADDRESS::ReceiveLotsaCalls (
    )
/*++

Routine Description:

    Here is where we receive remote procedure calls to this address.  One
    more threads will be executing this routine at once.

--*/
{
    NTSTATUS NtStatus;
    LRPC_SASSOCIATION * Association;
    LRPC_CASSOCIATION *CAssociation;
    unsigned long AssociationKey;
    char *PaddedMessage;
    LRPC_MESSAGE * Reply  ;
    LRPC_MESSAGE * LrpcMessage = 0;
    LRPC_MESSAGE * LrpcReplyMessage = 0;
    int AssociationType = 0;
    int Flags = 0;
    BOOL PartialFlag  ;
    BOOL fStatus ;
    RPC_STATUS Status;
    unsigned long ReplyKey = -1;
    LARGE_INTEGER LongTimeout;
    LARGE_INTEGER ShortTimeout;
    PLARGE_INTEGER pliTimeout = &ShortTimeout;
    ULONG_PTR Key;
    THREAD *ThisThread;
    DebugThreadInfo *DebugCell;

    FormatTimeOut(&ShortTimeout, gThreadTimeout);
    FormatTimeOut(&LongTimeout, LRPC_LISTEN_TIMEOUT);
    pliTimeout = &ShortTimeout;

    PaddedMessage = (char *) _alloca(PadToNaturalBoundary(sizeof(LRPC_MESSAGE) + 1) + sizeof(LRPC_MESSAGE));
    Reply = (LRPC_MESSAGE *) AlignOnNaturalBoundary(PaddedMessage) ;

    ThisThread = RpcpGetThreadPointer();
    ASSERT(ThisThread);

    DebugCell = ThisThread->DebugCell;

    if (DebugCell)
        {
        if (this->DebugCell)
            {
            GetDebugCellIDFromDebugCell(
                (DebugCellUnion *)this->DebugCell, 
                &this->DebugCellTag, 
                &ThisThread->DebugCell->Endpoint);
            }
        }

    for (;;)
        {
        if (LrpcMessage == 0)
            {
            while ((LrpcMessage = AllocateMessage()) == 0)
                {
                Sleep(100) ;
                }
            }

        ASSERT(LrpcReplyMessage == 0
            || LrpcReplyMessage->Rpc.RpcHeader.MessageType <= MAX_LRPC_MSG);

        if (DebugCell)
            {
            DebugCell->Status = dtsIdle;
            DebugCell->LastUpdateTime = NtGetTickCount();
            }

        RpcpPurgeEEInfoFromThreadIfNecessary(ThisThread);

        NtStatus = NtReplyWaitReceivePortEx(LpcAddressPort,
                                         (PVOID *) &Key,
                                         (PORT_MESSAGE *) LrpcReplyMessage,
                                         (PORT_MESSAGE *) LrpcMessage,
                                         pliTimeout);
        AssociationKey = (ULONG) Key; // need this for 64bit

        if (NtStatus != STATUS_TIMEOUT
            && NT_SUCCESS(NtStatus))
            {
            if (pliTimeout != &ShortTimeout)
                {
#if defined (RPC_GC_AUDIT)
                DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) LPC Thread %X: coming back from long wait\n",
                    GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId());
#endif
                ASSERT((pliTimeout == NULL) || (pliTimeout == &LongTimeout));
                ThreadsDoingLongWait.Decrement();
                pliTimeout = &ShortTimeout;
                }

            if (DebugCell)
                {
                DebugCell->Status = dtsProcessing;
                DebugCell->LastUpdateTime = NtGetTickCount();
                }

#if 0
            if (LrpcMessage->LpcHeader.u2.s2.Type == LPC_CONNECTION_REQUEST)
                LogEvent(SU_PACKET, EV_PKT_IN, (void *) LrpcMessage->LpcHeader.u2.ZeroInit, 
                    (void *)LrpcMessage->Connect.BindExchange.ConnectType, AssociationKey);
            else
                LogEvent(SU_PACKET, EV_PKT_IN, (void *) LrpcMessage->LpcHeader.u2.ZeroInit, 
                    0, AssociationKey);
#endif

            if (LrpcMessage->LpcHeader.u2.s2.Type == LPC_DATAGRAM
                || LrpcMessage->LpcHeader.u2.s2.Type == LPC_REQUEST)
                {
                if (!SERVERKEY(AssociationKey))
                    {
                    VALIDATE(LrpcMessage->Bind.MessageType)
                        {
                        LRPC_MSG_FAULT,
                        LRPC_MSG_FAULT2,
                        LRPC_MSG_RESPONSE,
                        LRPC_CLIENT_SEND_MORE
                        } END_VALIDATE;

                    //
                    // response or fault on the back connection.
                    // we are using async rpc or pipes
                    //
                    CAssociation = ReferenceClientAssoc(AssociationKey);
                    if (CAssociation)
                        {
                        BeginLongCall();

                        LrpcReplyMessage = 0;

                        CAssociation->ProcessResponse(LrpcMessage, &LrpcReplyMessage);

                        //
                        // the receive thread needs to allocate a new message
                        //
                        LrpcMessage = 0 ;

                        CAssociation->RemoveReference() ;

                        EndLongCall();
                        }
                    else
                        {
                        HandleInvalidAssociationReference(LrpcMessage,
                            &LrpcReplyMessage,
                            AssociationKey);
                        }

                    continue;
                    }

                Association = ReferenceAssociation(AssociationKey);
                if (Association == 0)
                    {
                    HandleInvalidAssociationReference(LrpcMessage,
                        &LrpcReplyMessage,
                        AssociationKey);
                    continue;
                    }

                ReplyKey = AssociationKey;
                Flags = LrpcMessage->Rpc.RpcHeader.Flags ;
                PartialFlag = FALSE ;

                if (LrpcMessage->Bind.MessageType == LRPC_MSG_REQUEST)
                    {
                    //
                    // Optimize the common case
                    //
                    fStatus = DealWithLRPCRequest (
                                        LrpcMessage,
                                        Reply,
                                        Association,
                                        &LrpcReplyMessage) ;

                    if (fStatus)
                        {
                        // this is the first of two exits from the loop
                        // (the second is below)
                        if (DebugCell)
                            {
                            DebugCell->Status = dtsAllocated;
                            DebugCell->LastUpdateTime = NtGetTickCount();
                            }

                        return;
                        }

                    if (LrpcReplyMessage == 0)
                        {
                        LrpcMessage = 0;
                        }
                    else
                        {
                        DereferenceAssociation(Association);
                        }
                    }
                else
                    {
                    switch (LrpcMessage->Bind.MessageType)
                        {
                        case LRPC_PARTIAL_REQUEST:
                        case LRPC_SERVER_SEND_MORE:
                        case LRPC_MSG_CANCEL:
                            LrpcReplyMessage = Association->
                                DealWithPartialRequest(&LrpcMessage) ;
                            break;

                        case LRPC_MSG_COPY:
                            LrpcReplyMessage = Association->DealWithCopyMessage(
                                (LRPC_COPY_MESSAGE *)LrpcMessage);
                            break;

                        case LRPC_MSG_BIND :
                            Association->DealWithBindMessage(LrpcMessage);

                            LrpcReplyMessage = 0 ;
                            break;


                        case LRPC_MSG_BIND_BACK:
                            BeginLongCall();

                            LrpcReplyMessage = Association->
                                DealWithBindBackMessage(LrpcMessage);

                            EndLongCall();
                            break;

                        default:
#if DBG
                            PrintToDebugger("RPC : Bad Message Type (%d) - %d\n",
                                        LrpcMessage->Bind.MessageType,
                                        LrpcMessage->LpcHeader.u2.s2.Type);
#endif // DBG

                            ASSERT(0) ;
                            LrpcReplyMessage = 0 ;
                            Association->Delete();
                            break;
                        }
                    DereferenceAssociation(Association);
                    }
                }
            else
                {
                switch (LrpcMessage->LpcHeader.u2.s2.Type)
                    {
                    case LPC_CONNECTION_REQUEST:
                        if (LrpcMessage->Connect.BindExchange.ConnectType
                            == LRPC_CONNECT_REQUEST)
                            {
                            BeginLongCall();

                            DealWithNewClient(LrpcMessage) ;

                            EndLongCall();
                            }
                        else if (LrpcMessage->Connect.BindExchange.ConnectType
                                 == LRPC_CONNECT_RESPONSE)
                            {
                            DealWithConnectResponse(LrpcMessage) ;
                            }
                        else if (LrpcMessage->Connect.BindExchange.ConnectType
                                 == LRPC_CONNECT_TICKLE)
                            {
                            HANDLE Ignore;

                            // always reject - this just has the purpose of tickling
                            // a thread on a long wait
                            NtStatus = NtAcceptConnectPort(&Ignore,
                                                           NULL,
                                                           (PORT_MESSAGE *) LrpcMessage,
                                                           FALSE,
                                                           NULL,
                                                           NULL);
#if defined (RPC_GC_AUDIT)
                            DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) LPC Thread %X: tickled\n",
                                GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId());
#endif
                            }
                        else
                            {
                            ASSERT(0) ;
                            }
                        LrpcReplyMessage = 0;
                        break;

                    case LPC_CLIENT_DIED:
                        LrpcReplyMessage = 0;
                        break;

                    case LPC_PORT_CLOSED:
                        if (SERVERKEY(AssociationKey))
                            {
                            Association = ReferenceAssociation(AssociationKey);
                            if (Association == 0)
                                {
                                LrpcReplyMessage = 0;
                                continue;
                                }
                            
                            BeginLongCall();

                            Association->Delete();
                            DereferenceAssociation(Association);

                            LrpcReplyMessage = 0;

                            EndLongCall();
                            }
                        else
                            {
                            CAssociation = ReferenceClientAssoc(AssociationKey);
                            if (CAssociation)
                                {
                                BeginLongCall();
                                CAssociation->AbortAssociation(1) ;
                                CAssociation->RemoveReference() ;
                                EndLongCall();
                                }

                            LrpcReplyMessage = 0;
                            }
                        continue;

                    default:
                        LrpcReplyMessage = 0 ;
                        ASSERT(0);
                    } // switch
                } // else
            } // if
        else
            {
            switch (NtStatus)
                {
                case STATUS_NO_MEMORY:
                case STATUS_INSUFFICIENT_RESOURCES:
                case STATUS_UNSUCCESSFUL:
                    PauseExecution(500L);
                    break;

                case STATUS_TIMEOUT:
#if defined (RPC_GC_AUDIT)
                    DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) LPC Thread %X: timed out - gc\n",
                        GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId());
#endif

                    PerformGarbageCollection();

                    if (pliTimeout == &ShortTimeout)
                        {
                        // be conservative and presume we will
                        // be doing long wait. If later we find out
                        // we won't, we'll reverse that. Also, this must
                        // be done nefore we check for 
                        // GarbageCollectedRequested - this allows other
                        // threads to safely count the number of threads
                        // on short wait without taking a mutex
                        ThreadsDoingLongWait.Increment();

                        LrpcReplyMessage = 0;
                        // if there is garbage collection
                        // requested, don't switch to long
                        // wait
                        if (GarbageCollectionRequested)
                            {
#if defined (RPC_GC_AUDIT)
                            DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) LPC Thread %X: gc requested - can't do long wait\n",
                                GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId());
#endif
                            ThreadsDoingLongWait.Decrement();
                            }
                        else
                            {
#if defined (RPC_GC_AUDIT)
                            DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) LPC Thread %X: going to long wait\n",
                                GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId());
#endif
                            // there is no garbage collection requested
                            // switch to longer wait (but not infinite yet)
                            pliTimeout = &LongTimeout;
                            }
                        }
                    else if (pliTimeout == &LongTimeout)
                        {
                        // if this is a long wait, and we're a spare
                        // thread, we can go
                        AddressMutex.Request();
                        if (CallThreadCount - ActiveCallCount > 1)
                            {
                            CallThreadCount -= 1;
                            ASSERT(CallThreadCount > ActiveCallCount);
                            AddressMutex.Clear();

                            // decrease the counter of threads doing long
                            // listen after we decrease the CallThreadCount
                            // This allows other threads to use the number
                            // of threads doing short wait without taking
                            // a mutex
                            ThreadsDoingLongWait.Decrement();

                            FreeMessage(LrpcMessage);

                            // N.B. This is the second exit from the loop (see above)
                            if (DebugCell)
                                {
                                DebugCell->Status = dtsAllocated;
                                DebugCell->LastUpdateTime = NtGetTickCount();
                                }

                            return ;
                            }
                         else
                            {
                            //
                            // We are assuming that if the call has timed out, the reply has
                            // been sent
                            //
                            LrpcReplyMessage = 0;
                            pliTimeout = NULL;
#if defined (RPC_GC_AUDIT)
                            DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) LPC Thread %X: going to infinite wait\n",
                                GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId());
#endif
                            }
                        AddressMutex.Clear();
                        }
                    else
                        {
                        ASSERT(!"We cannot get a timeout on wait with infinite timeout");
                        }

                    if (DebugCell)
                        {
                        RelocateCellIfPossible((void **) &DebugCell, &ThisThread->DebugCellTag);
                        ThisThread->DebugCell = DebugCell;
                        }
                    break;

                default:
                    if (LrpcReplyMessage)
                        {
                        LrpcReplyMessage = 0;
                        if (ReplyKey != -1)
                            {
                            Association = ReferenceAssociation(ReplyKey);
                            if (Association == 0)
                                {
                                continue;
                                }
                            }
                        else
                            continue;

                        BeginLongCall();

                        Association->Delete();
                        DereferenceAssociation(Association);
                        
                        EndLongCall();
                        }
                    break;
                } // switch
            } // else
        } // for
}

#define DEFAULT_PORT_DIR      "\\RPC Control\\"
#define DEFAULT_PORT_NAME   "ARPC Port1"
#define DEFAULT_REPLY_NAME  "ARPC Reply Port"


void
LRPC_ADDRESS::DealWithNewClient (
    IN LRPC_MESSAGE * ConnectionRequest
    )
/*++

Routine Description:

    A new client has connected with our address port.  We need to take
    care of the new client and send a response.

Arguments:

    ConnectionRequest - Supplies information need by LPC to abort the
        connect request.  Includes the bind request from the client.
        This contains the information about which interface the client
        wants to bind with.  and which we use to send the status code
        back in.


--*/
{
    LRPC_SASSOCIATION * Association;
    NTSTATUS NtStatus;
    RPC_STATUS Status = RPC_S_OK;
    DWORD Key;
    LPC_KEY *LpcKey = (LPC_KEY *) &Key;

    Association = new LRPC_SASSOCIATION(this,
                                 &Status);
    if (Association == 0)
        {
        RejectNewClient(ConnectionRequest, RPC_S_OUT_OF_MEMORY);
        return;
        }

    if (Status != RPC_S_OK)
        {
        delete Association ;
        RejectNewClient(ConnectionRequest, RPC_S_OUT_OF_MEMORY);
        return ;
        }

    AddressMutex.Request();
    Association->DictionaryKey = (unsigned short)
            AssociationDictionary.Insert(Association);
    AssociationCount++;
    SequenceNumber = (SequenceNumber+1) % (0x7FFF);
    Association->SequenceNumber = SequenceNumber;
    AddressMutex.Clear();

    if (Association->DictionaryKey == -1)
        {
        AddressMutex.Request();
        AssociationCount-- ;
        AddressMutex.Clear();

        delete Association ;
        RejectNewClient(ConnectionRequest, RPC_S_OUT_OF_MEMORY);
        return;
        }

    if (ConnectionRequest->Connect.BindExchange.Flags & BIND_BACK_FLAG)
        {
        ConnectionRequest->Connect.BindExchange.szPortName[PORT_NAME_LEN-1] = NULL;

        Status = Association->BindBack(
            (RPC_CHAR *)ConnectionRequest->Connect.BindExchange.szPortName,
            ConnectionRequest->Connect.BindExchange.AssocKey) ;
        if (Status != RPC_S_OK)
            {
            RejectNewClient(ConnectionRequest, RPC_S_OUT_OF_MEMORY);
            Association->Delete() ;
            return;
            }
        }

    ConnectionRequest->Connect.BindExchange.RpcStatus = RPC_S_OK;

    ASSERT(sizeof(unsigned long) <= sizeof(PVOID));

    ASSERT((Association->SequenceNumber & SERVER_KEY_MASK) == 0);

    LpcKey->SeqNumber = Association->SequenceNumber | SERVER_KEY_MASK;
    LpcKey->AssocKey = Association->DictionaryKey;

    // After the call to NtAcceptConnectPort, the client will become unblocked
    // the association will be in the dictionary and will have refcount 1.  If the client quits
    // or closes port the association will be deleted.  Then NtCompleteConnectPort
    // may touch invalid memory or operate on a bad handle.  To prevent that we
    // need to hold an extra count between the two calls.
    //
    // Since this thread is the only one playing with the association up to now,
    // there is no need for a lock.
    Association->AssociationReferenceCount++;

    NtStatus = NtAcceptConnectPort(&(Association->LpcServerPort),
                                   ULongToPtr(Key),
                                   (PORT_MESSAGE *) ConnectionRequest,
                                   TRUE,
                                   NULL,
                                   NULL);

    if (NT_ERROR(NtStatus))
        {
        Association->Delete();

        // We just have to dereference the association to remove the extra
        // count added above.  This should cause its deletion.
        DereferenceAssociation(Association);

#if DBG
        PrintToDebugger("RPC : NtAcceptConnectPort : %lx\n", NtStatus);
#endif // DBG

        return;
        }

    NtStatus = NtCompleteConnectPort(Association->LpcServerPort);
	 
    if (NT_ERROR(NtStatus))
        {
#if DBG
        PrintToDebugger("RPC : NtCompleteConnectPort : %lx\n", NtStatus);
#endif // DBG

        // If Association->Delete() has already been called on a different
        // theread due to a closed client port, this call will be ignored...
        Association->Delete();

        // and the final reference will be removed here causing a deletion.
        DereferenceAssociation(Association);

        return;
        }

        // Remove the extra-reference.
        DereferenceAssociation(Association);
}


void
LRPC_ADDRESS::DealWithConnectResponse (
    IN LRPC_MESSAGE * ConnectResponse
    )
/*++

Routine Description:

   Just received a connect response from the remove server,
   need to handle that.

Arguments:

    ConnectionRequest -
      Needed to get the pAssoc
--*/
{
   NTSTATUS NtStatus;
   HANDLE temp ;
   LRPC_CASSOCIATION * Association ;
   DWORD Key;

   Key = ConnectResponse->Connect.BindExchange.AssocKey;

   Association = ReferenceClientAssoc(Key);
   if (Association == 0)
       {
       RejectNewClient(ConnectResponse, RPC_S_PROTOCOL_ERROR);
       return;
       }

   NtStatus = NtAcceptConnectPort(&temp,
                                 ULongToPtr(Key),
                                 (PPORT_MESSAGE) ConnectResponse,
                                 TRUE,
                                 NULL,
                                 NULL);

   if (NT_SUCCESS(NtStatus))
       {
       Association->SetReceivePort(temp) ;

       NtStatus = NtCompleteConnectPort(temp);

       if (!NT_SUCCESS(NtStatus))
          {
    #if DBG
          PrintToDebugger("LRPC: NtCompleteConnectPort(1) failed: %lx\n",
                          NtStatus) ;
    #endif

          Association->Delete();
          }
       }
   else
      {
#if DBG
      PrintToDebugger("LRPC: NtAcceptConnectionPort(1) failed: %lx\n",
                      NtStatus) ;
#endif

      Association->Delete();
      }

    //
    // Remove the reference we added above
    //
    Association->RemoveReference() ;
}


void
LRPC_ADDRESS::RejectNewClient (
    IN LRPC_MESSAGE * ConnectionRequest,
    IN RPC_STATUS Status
    )
/*++

Routine Description:

    A new client has connected with our address port.  We need to reject
    the client.

Arguments:

    ConnectionRequest - Supplies information need by LPC to abort the
        connect request.  Includes the bind request from the client,
        which we use to send the status code back in.


    Status - Supplies the reason the client is being rejected.

--*/
{
    NTSTATUS NtStatus;
    HANDLE Ignore;

    ASSERT(Status != RPC_S_OK);

    ConnectionRequest->Connect.BindExchange.RpcStatus = Status;
    ConnectionRequest->Connect.BindExchange.Flags |= SERVER_BIND_EXCH_RESP;
    NtStatus = NtAcceptConnectPort(&Ignore,
                                   NULL,
                                   (PORT_MESSAGE *) ConnectionRequest,
                                   FALSE,
                                   NULL,
                                   NULL);
#if DBG
    if (!NT_SUCCESS(NtStatus))
        {
        PrintToDebugger("RPC : NtAcceptConnectPort : %lx\n", NtStatus);

        // if the client thread dies for whatever reason, NtAcceptConnectPort
        // can return STATUS_REPLY_MESSAGE_MISMATCH
        VALIDATE(NtStatus)
            {
            STATUS_INVALID_CID,
            STATUS_REPLY_MESSAGE_MISMATCH
            } END_VALIDATE;
        }
#endif // DBG
}

void
LRPC_ADDRESS::EnumerateAndCallEachAssociation (
    IN AssociationCallbackType asctType,
    IN OUT void *Context OPTIONAL
    )
/*++
Function Name:  EnumerateAndCallEachAssociation

Parameters:
    asctType - type of callback to make
    Context - opaque memory block specific for the callback
        type.

Description:
    Common infrastructure for calling into each association

Returns:

--*/
{
    LRPC_SASSOCIATION *CurrentAssociation;
    BOOL CopyOfDictionaryUsed;
    LRPC_SASSOCIATION_DICT AssocDictCopy;
    LRPC_SASSOCIATION_DICT *AssocDictToUse;
    BOOL Res;
    DictionaryCursor cursor;
    DestroyContextHandleCallbackContext *CallbackContext;

    AddressMutex.Request();

    CopyOfDictionaryUsed = AssocDictCopy.ExpandToSize(AssociationDictionary.Size());
    if (CopyOfDictionaryUsed)
        {
        AssociationDictionary.Reset(cursor);
        while ( (CurrentAssociation = AssociationDictionary.Next(cursor)) != 0 )
            {
            Res = AssocDictCopy.Insert(CurrentAssociation);
            ASSERT(Res != -1);
            // artifically add a count to keep it alive
            // while we destroy the contexts
            CurrentAssociation->AssociationReferenceCount++;
            }

        AddressMutex.Clear();

        AssocDictToUse = &AssocDictCopy;
        }
    else
        {
        AssocDictToUse = &AssociationDictionary;
        }

    AssocDictToUse->Reset(cursor);
    while ( (CurrentAssociation = AssocDictToUse->Next(cursor)) != 0 )
        {
        switch (asctType)
            {
            case asctDestroyContextHandle:
                CallbackContext = (DestroyContextHandleCallbackContext *)Context;

                // call into the association to destroy the context handles
                CurrentAssociation->DestroyContextHandlesForInterface(
                    CallbackContext->RpcInterfaceInformation,
                    CallbackContext->RundownContextHandles);
                break;

            case asctCleanupIdleSContext:
                CurrentAssociation->CleanupIdleSContexts();
                break;

            default:
                ASSERT(0);
            }
        }

    if (CopyOfDictionaryUsed)
        {
        while ( (CurrentAssociation = AssocDictCopy.Next(cursor)) != 0 )
            {
            // remove the extra refcounts
            DereferenceAssociation(CurrentAssociation);
            }
        }
    else
        {
        AddressMutex.Clear();
        }    
}

void
LRPC_ADDRESS::DestroyContextHandlesForInterface (
    IN RPC_SERVER_INTERFACE PAPI * RpcInterfaceInformation,
    IN BOOL RundownContextHandles
    )
/*++
Function Name:  DestroyContextHandlesForInterface

Parameters:
    RpcInterfaceInformation - the interface for which context handles
        are to be unregistered
    RundownContextHandles - if non-zero, rundown the context handles. If
        FALSE, destroy the runtime portion of the context handle resource,
        but don't call the user rundown routine.

Description:
    The implementation for context handle destruction for the local RPC 
    (LRPC). Using the callback infrastructure it will walk the list of 
    associations, and for each one it will ask the association to 
    destroy the context handles for that interface.

Returns:

--*/
{
    DestroyContextHandleCallbackContext CallbackContext;

    CallbackContext.RpcInterfaceInformation = RpcInterfaceInformation;
    CallbackContext.RundownContextHandles = RundownContextHandles;

    EnumerateAndCallEachAssociation(asctDestroyContextHandle,
        &CallbackContext);
}

void
LRPC_ADDRESS::CleanupIdleSContexts (
    void
    )
/*++
Function Name:  CleanupIdleSContexts

Parameters:

Description:
    The implementation for idle SContext cleanup for the local RPC 
    (LRPC). Using the callback infrastructure it will walk the list of 
    associations, and for each one it will ask the association to 
    destroy the idle scontexts


Returns:

--*/
{
    LogEvent(SU_GC, EV_PRUNE, this, 0, 0, 0, 0);

    EnumerateAndCallEachAssociation(asctCleanupIdleSContext,
        NULL);
}

BOOL 
LRPC_ADDRESS::PrepareForLoopbackTickling (
    void
    )
{
    RPC_CHAR * LpcPortName;
    int DirectoryNameLength;
    int EndpointLength;

    LrpcMutexVerifyOwned();

    DirectoryNameLength = RpcpStringLength(LRPC_DIRECTORY_NAME);
    EndpointLength = RpcpStringLength(InqEndpoint());

    LpcPortName = new RPC_CHAR[
                    EndpointLength
                    + DirectoryNameLength + 1];
    if (LpcPortName == 0)
        {
        return FALSE;
        }

    TickleMessage = new LRPC_BIND_EXCHANGE;
    if (TickleMessage == NULL)
        {
        delete LpcPortName;
        return FALSE;
        }

    RpcpMemoryCopy(LpcPortName, LRPC_DIRECTORY_NAME,
            DirectoryNameLength * sizeof(RPC_CHAR));

    RpcpMemoryCopy(LpcPortName + DirectoryNameLength,
            InqEndpoint(), 
            (EndpointLength + 1) * sizeof(RPC_CHAR));

    RtlInitUnicodeString(&ThisAddressLoopbackString, LpcPortName);

    return TRUE;
}

BOOL
LRPC_ADDRESS::LoopbackTickle (
    void
    )
{
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    HANDLE LoopbackPort;
    ULONG TickleMessageLength = sizeof(LRPC_BIND_EXCHANGE);
    NTSTATUS NtStatus;

    ASSERT (IsPreparedForLoopbackTickling());

    SecurityQualityOfService.EffectiveOnly = FALSE;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.ImpersonationLevel = SecurityAnonymous;
    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);

    TickleMessage->ConnectType = LRPC_CONNECT_TICKLE ;
//    TickleMessage->AssocKey = Key;
    TickleMessage->Flags = 0;

    NtStatus = NtConnectPort(
                             &LoopbackPort,
                             &ThisAddressLoopbackString,
                             &SecurityQualityOfService,
                             NULL,
                             NULL,
                             NULL,
                             TickleMessage,
                             &TickleMessageLength);

    if (NtStatus == STATUS_PORT_CONNECTION_REFUSED)
        return TRUE;
    else
        {
        ASSERT(NtStatus != RPC_S_OK);
        return FALSE;
        }
}


LRPC_SASSOCIATION::LRPC_SASSOCIATION (
    IN LRPC_ADDRESS * Address,
    IN RPC_STATUS *Status
    ) : AssociationMutex(Status)
/*++

--*/
{
    ObjectType = LRPC_SASSOCIATION_TYPE;
    LpcServerPort = 0;
    LpcReplyPort = 0 ;
    this->Address = Address;
    AssociationReferenceCount = 1;
    Aborted = 0 ;
    Deleted = -1 ;

    if (*Status == RPC_S_OK)
        {
        CachedSCall = new LRPC_SCALL(Status);
        if (CachedSCall == 0)
            {
            *Status = RPC_S_OUT_OF_MEMORY;
            }
        }
    else
        {
        CachedSCall = NULL;
        }

    CachedSCallAvailable = 0;
    fFirstCall = 0;
}


LRPC_SASSOCIATION::~LRPC_SASSOCIATION (
    )
/*++

Routine Description:

    We will call this routine when the client has notified us that this port
    has closed, and there are no calls outstanding on it.

--*/
{
    PVOID Buffer;
    LRPC_SBINDING * Binding;
    LRPC_SCALL *SCall ;
    unsigned int Length ;
    LRPC_SCONTEXT *SContext;
    DictionaryCursor cursor;

    while (SCall = (LRPC_SCALL *) FreeSCallQueue.TakeOffQueue(&Length))
        {
        delete SCall;
        }


    Bindings.Reset(cursor);
    while ((Binding = Bindings.Next(cursor)) != 0)
        {
        delete Binding;
        }

    if (CachedSCall)
        {
        delete CachedSCall;
        }

    SContextDict.Reset(cursor);
    while ((SContext = SContextDict.Next(cursor)) != 0)
        {
        delete SContext;
        }
}

RPC_STATUS
LRPC_SASSOCIATION::AllocateSCall (
    IN LRPC_MESSAGE * LrpcMessage,
    IN LRPC_MESSAGE * LrpcReplyMessage,
    IN unsigned int Flags,
    IN LRPC_SCALL **SCall
    )
/*++

Routine Description:

    Allocate an SCall

Arguments:

    LrpcMessage - Request message
    LrpcReplyMessage - Reply message
    Flags - Request flags

Return Value:
    Pointer to the SCall

--*/

{
    unsigned int Length ;
    RPC_STATUS Status ;
    LRPC_SCALL *NewSCall;

    *SCall = NULL;

    if (InterlockedIncrement(&CachedSCallAvailable) == 1)
        {
        NewSCall = CachedSCall;
        }
    else
        {
        AssociationMutex.Request() ;
        NewSCall = (LRPC_SCALL *) FreeSCallQueue.TakeOffQueue(&Length) ;
        AssociationMutex.Clear() ;

        if (NewSCall == 0)
            {
            NewSCall = new LRPC_SCALL(&Status) ;
            if (NewSCall == 0)
                {
                return RPC_S_OUT_OF_MEMORY;
                }
            if (Status != RPC_S_OK)
                {
                delete NewSCall;
                return Status;
                }
            }
        }

    Status = NewSCall->ActivateCall(this,
                           LrpcMessage,
                           LrpcReplyMessage,
                           Flags) ;
    

    if ((Flags & LRPC_BUFFER_PARTIAL)
        || NewSCall->IsClientAsync())
        {
        Status = NewSCall->SetupCall() ;
        if (Status != RPC_S_OK)
            {
            if (NewSCall != CachedSCall)
                {
                delete NewSCall ;
                }

            return RPC_S_OUT_OF_MEMORY ;
            }
        }

    LogEvent(SU_SCALL, EV_CREATE, NewSCall, 0, Flags, 1);
    
    *SCall = NewSCall;
    
    return RPC_S_OK;
}

void
LRPC_SASSOCIATION::FreeSCall (
    IN LRPC_SCALL *SCall
    )
/*++

Routine Description:

 Free the SCall

Arguments:

 SCall - Pointer to the SCall object

--*/

{
    ASSERT(SCall->pAsync != (PRPC_ASYNC_STATE) -1);

    if (SCall->pAsync)
        {
        SCall->DoPostDispatchProcessing();
        }

    if (SCall->SBinding
        && SCall->SBinding->RpcInterface->IsAutoListenInterface())
        {
        SCall->SBinding->RpcInterface->EndAutoListenCall() ;
        }

    if (SCall->ReceiveEvent)
        {
        AssociationMutex.Request() ;
        SCallDict.Delete(ULongToPtr(SCall->CallId));
        AssociationMutex.Clear() ;
        }

    LogEvent(SU_SCALL, EV_DELETE, SCall, SCall->pAsync, SCall->Flags, 1);

    SCall->pAsync = (PRPC_ASYNC_STATE) -1;
    if (SCall->SContext)
        {
        SCall->SContext->RemoveReference();
        }

    if (SCall->ClientPrincipalName != NULL)
        {
        delete SCall->ClientPrincipalName;
        SCall->ClientPrincipalName = NULL;
        }

    SCall->DeactivateCall();
    if (SCall == CachedSCall)
        {
        CachedSCallAvailable = 0;
        }
    else
        {
        AssociationMutex.Request() ;
        SCall->pAsync = (PRPC_ASYNC_STATE) -1;
        if (FreeSCallQueue.PutOnQueue(SCall, 0))
            delete SCall ;
        AssociationMutex.Clear() ;
        }

}

int
LRPC_SASSOCIATION::MaybeQueueSCall (
    IN LRPC_SCALL *SCall
    )
/*++

Routine Description:

 if the thread is currently executing a call, the call
 is queued up, otherwise it is signalled to be dispatched.

Arguments:

  SCall - the SCall to be dispatched.

Return Value:

 0: dispatch the call
 1: don't dispatch the call
-1: error
--*/

{
    LRPC_SCALL *FirstSCall ;
    int Status ;

    AssociationMutex.Request() ;

    FirstSCall = ClientThreadDict.Find(
        MsgClientIdToClientId(SCall->LrpcRequestMessage->Rpc.LpcHeader.ClientId).UniqueThread) ;

    if (FirstSCall == 0)
        {
        Status = ClientThreadDict.Insert(
            MsgClientIdToClientId(SCall->LrpcRequestMessage->Rpc.LpcHeader.ClientId).UniqueThread,
            SCall) ;

        SCall->LastSCall = SCall ;

        AssociationMutex.Clear() ;

        VALIDATE(Status)
            {
            0,
            -1
            } END_VALIDATE;

        return Status ;
        }


    ASSERT(FirstSCall->LastSCall);

    FirstSCall->LastSCall->NextSCall = SCall ;
    FirstSCall->LastSCall = SCall ;

    AssociationMutex.Clear() ;

    return 1 ;
}

LRPC_SCALL *
LRPC_SASSOCIATION::GetNextSCall (
    IN LRPC_SCALL *SCall
    )
/*++

Routine Description:

 description

Arguments:

 SCall - description

Return Value:
--*/

{
    LRPC_SCALL *NextSCall ;

    ASSERT(SCall) ;

    AssociationMutex.Request() ;
    NextSCall = SCall->NextSCall ;
    if (NextSCall != 0)
        {
        ASSERT(SCall->LastSCall);

        NextSCall->LastSCall = SCall->LastSCall ;
        ClientThreadDict.Update (
            MsgClientIdToClientId(SCall->LrpcRequestMessage->Rpc.LpcHeader.ClientId).UniqueThread,
            NextSCall) ;
        }
    else
        {
        ClientThreadDict.Delete (
            MsgClientIdToClientId(SCall->LrpcRequestMessage->Rpc.LpcHeader.ClientId).UniqueThread) ;
        }
    AssociationMutex.Clear() ;

    return NextSCall ;
}

void
LRPC_SASSOCIATION::Delete(
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/

{
    LRPC_SCALL *SCall ;
    DictionaryCursor cursor;

    if (InterlockedIncrement(&Deleted) == 0)
        {
        AssociationMutex.Request() ;
        SCallDict.Reset(cursor) ;
        while ((SCall = SCallDict.Next(cursor)) != 0)
            {
            SCall->Deleted = 1;
            if (SCall->ReceiveEvent)
                {
                SCall->ReceiveEvent->Raise();
                }
            }
        AssociationMutex.Clear() ;

        LogEvent(SU_SASSOC, EV_DELETE,
                 this, 0, AssociationReferenceCount, 1, 1);

        Address->DereferenceAssociation(this);
        }
}


RPC_STATUS
LRPC_SASSOCIATION::BindBack (
    IN RPC_CHAR *Endpoint,
    IN DWORD AssocKey
    )
/*++

Routine Description:

    Create a back connection to the client.

Arguments:

 LrpcThread - LrpcThread to connect to.
 pAssoc - Pointer to client association.

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/

{
    NTSTATUS NtStatus;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    RPC_CHAR * LpcPortName ;
    UNICODE_STRING unicodePortName;
    LRPC_BIND_EXCHANGE BindExchange;
    unsigned long BindExchangeLength = sizeof(LRPC_BIND_EXCHANGE);

    LpcPortName = new RPC_CHAR[RpcpStringLength(Endpoint)
                            + RpcpStringLength(LRPC_DIRECTORY_NAME) + 1];

    if (LpcPortName == 0)
        {
#if DBG
        PrintToDebugger("LRPC: Out of memory in DealWithNewClient\n") ;
#endif
        return RPC_S_OUT_OF_MEMORY ;
        }

    RpcpMemoryCopy(LpcPortName,
            LRPC_DIRECTORY_NAME,
            RpcpStringLength(LRPC_DIRECTORY_NAME) * sizeof(RPC_CHAR));

    RpcpMemoryCopy(LpcPortName + RpcpStringLength(LRPC_DIRECTORY_NAME),
            Endpoint,
            (RpcpStringLength(Endpoint) + 1) * sizeof(RPC_CHAR));

    RtlInitUnicodeString(&unicodePortName, LpcPortName);

    // Hack Hack, where do I get the real QOS values from ??
    SecurityQualityOfService.EffectiveOnly = TRUE;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_STATIC_TRACKING;
    SecurityQualityOfService.ImpersonationLevel = SecurityAnonymous;

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);


    BindExchange.ConnectType = LRPC_CONNECT_RESPONSE ;
    BindExchange.AssocKey = AssocKey ;

    NtStatus = NtConnectPort(&LpcReplyPort,
                             &unicodePortName,
                             &SecurityQualityOfService,
                             0,
                             0,
                             0,
                             &BindExchange,
                             &BindExchangeLength);

    delete LpcPortName ;

    if (!NT_SUCCESS(NtStatus))
        {
#if DBG
        PrintToDebugger("LRPC: NtConnectPort : %lx\n", NtStatus);
#endif // DBG

        return RPC_S_OUT_OF_MEMORY ;
        }

    return RPC_S_OK ;
}


LRPC_MESSAGE *
LRPC_SASSOCIATION::DealWithBindBackMessage (
    IN LRPC_MESSAGE *BindBackMessage
    )
/*++

Routine Description:

 Used in conjuction with  Async RPC. This function
 creates a back connection to the client so that two asynchronous
 flow of data can occur.

Arguments:

 BindBackMessage - The message receive from the client

Return Value:
    reply message.

--*/

{
    RPC_STATUS Status ;

    BindBackMessage->BindBack.szPortName[PORT_NAME_LEN-1] = NULL;

    Status = BindBack((RPC_CHAR *) BindBackMessage->BindBack.szPortName,
                      BindBackMessage->BindBack.AssocKey) ;

    BindBackMessage->Ack.MessageType = LRPC_MSG_ACK ;
    BindBackMessage->Ack.RpcStatus = Status ;
    BindBackMessage->LpcHeader.u1.s1.DataLength =
        sizeof(LRPC_BIND_MESSAGE) - sizeof(PORT_MESSAGE);
    BindBackMessage->LpcHeader.u1.s1.TotalLength =
        sizeof(LRPC_BIND_MESSAGE);

    if (Status != RPC_S_OK)
        {
        Delete() ;
        }

    return BindBackMessage ;
}


RPC_STATUS
LRPC_SASSOCIATION::AddBinding (
    IN OUT LRPC_BIND_EXCHANGE * BindExchange
    )
/*++

Routine Description:

    We will attempt to add a new binding to this association.

Arguments:

    BindExchange - Supplies a description of the interface to which the
        client wish to bind.

Return Value:

--*/
{
    RPC_STATUS Status;
    RPC_SYNTAX_IDENTIFIER TransferSyntax;
    RPC_INTERFACE * RpcInterface;
    LRPC_SBINDING * Binding;
    BOOL fIgnored;
    int DictKey;
    RPC_SYNTAX_IDENTIFIER ProposedSyntaxes[MaximumNumberOfTransferSyntaxes];
    int PresentationContexts[MaximumNumberOfTransferSyntaxes];
    int TransferSyntaxFlagSettings[MaximumNumberOfTransferSyntaxes];
    int NextProposedSyntax;
    int ChosenProposedTransferSyntax;
    int ChosenAvailableTransferSyntax;

    NextProposedSyntax = 0;
    if (BindExchange->TransferSyntaxSet & TS_NDR20_FLAG)
        {
        RpcpMemoryCopy(&ProposedSyntaxes[NextProposedSyntax],
            NDR20TransferSyntax, sizeof(RPC_SYNTAX_IDENTIFIER));
        PresentationContexts[NextProposedSyntax] = (int)BindExchange->PresentationContext[0];
        TransferSyntaxFlagSettings[NextProposedSyntax] = TS_NDR20_FLAG;
        NextProposedSyntax ++;
        }

    if (BindExchange->TransferSyntaxSet & TS_NDR64_FLAG)
        {
        RpcpMemoryCopy(&ProposedSyntaxes[NextProposedSyntax],
            NDR64TransferSyntax, sizeof(RPC_SYNTAX_IDENTIFIER));
        PresentationContexts[NextProposedSyntax] = (int)BindExchange->PresentationContext[1];
        TransferSyntaxFlagSettings[NextProposedSyntax] = TS_NDR64_FLAG;
        NextProposedSyntax ++;
        }

    if (BindExchange->TransferSyntaxSet & TS_NDRTEST_FLAG)
        {
        RpcpMemoryCopy(&ProposedSyntaxes[NextProposedSyntax],
            NDRTestTransferSyntax, sizeof(RPC_SYNTAX_IDENTIFIER));
        PresentationContexts[NextProposedSyntax] = (int)BindExchange->PresentationContext[2];
        TransferSyntaxFlagSettings[NextProposedSyntax] = TS_NDRTEST_FLAG;
        NextProposedSyntax ++;
        }

    if (NextProposedSyntax == 0)
        {
        // no syntaxes proposed - protocol error
        ASSERT(0);
        return RPC_S_PROTOCOL_ERROR;
        }

    ASSERT(NextProposedSyntax <= MaximumNumberOfTransferSyntaxes);

    Status = Address->FindInterfaceTransfer(&(BindExchange->InterfaceId),
                                            ProposedSyntaxes,
                                            NextProposedSyntax,
                                            &TransferSyntax,
                                            &RpcInterface,
                                            &fIgnored,
                                            &ChosenProposedTransferSyntax,
                                            &ChosenAvailableTransferSyntax);
    if (Status != RPC_S_OK)
        {
        return(Status);
        }

    ASSERT (ChosenProposedTransferSyntax < NextProposedSyntax);

    Binding = new LRPC_SBINDING(RpcInterface,
                                ChosenAvailableTransferSyntax);
    if (Binding == 0)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }
    Binding->SetPresentationContext(PresentationContexts[ChosenProposedTransferSyntax]);
    DictKey = (unsigned char) Bindings.Insert(Binding);
    if (DictKey == -1)
        {
        delete Binding;
        return(RPC_S_OUT_OF_MEMORY);
        }

    BindExchange->TransferSyntaxSet = TransferSyntaxFlagSettings[ChosenProposedTransferSyntax];
    return(RPC_S_OK);
}


RPC_STATUS
LRPC_SASSOCIATION::SaveToken (
    IN LRPC_MESSAGE *LrpcMessage,
    OUT HANDLE *pTokenHandle,
    IN BOOL fRestoreToken
    )
/*++

Routine Description:

    Impersonate the client and save away the token.

Arguments:

 LrpcMessage - request message

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/

{
    NTSTATUS NtStatus ;
    HANDLE ImpersonationToken = 0;
    RPC_STATUS Status;

    if (fRestoreToken)
        {
        //
        // Save away the old token
        //
        if (OpenThreadToken (GetCurrentThread(),
                         TOKEN_IMPERSONATE | TOKEN_QUERY,
                         TRUE,
                         &ImpersonationToken) == FALSE)
            {
            ImpersonationToken = 0;
#if DBG
            if (GetLastError() != ERROR_NO_TOKEN)
                {
                PrintToDebugger("LRPC: OpenThreadToken failed %d\n", GetLastError());
                }
#endif
            }
        }

    NtStatus = NtImpersonateClientOfPort(LpcServerPort,
                                        (PORT_MESSAGE *) LrpcMessage);

    if (NT_ERROR(NtStatus))
        {
#if DBG
        PrintToDebugger("LRPC: NtImpersonateClientOfPort failed: 0x%lX\n",
                        NtStatus) ;
#endif

        return RPC_S_INVALID_AUTH_IDENTITY ;
        }

    Status = RPC_S_OK;

    if (OpenThreadToken (GetCurrentThread(),
                         TOKEN_IMPERSONATE | TOKEN_QUERY,
                         TRUE,
                         pTokenHandle) == FALSE)
        {
        *pTokenHandle = 0;

        if (GetLastError() == ERROR_CANT_OPEN_ANONYMOUS)
            {
            Status = ERROR_CANT_OPEN_ANONYMOUS;
            }
        else
            {
#if DBG
            PrintToDebugger("LRPC: OpenThreadToken failed\n") ;
#endif
            }
        }

    if (fRestoreToken)
        {
        //
        // Restore the token
        //
        NtStatus = NtSetInformationThread(NtCurrentThread(),
                                          ThreadImpersonationToken,
                                          &ImpersonationToken,
                                          sizeof(HANDLE));

#if DBG
        if (!NT_SUCCESS(NtStatus))
            {
            PrintToDebugger("RPC : NtSetInformationThread : %lx\n", NtStatus);
            }
#endif // DBG

        if (ImpersonationToken)
            {
            CloseHandle(ImpersonationToken);
            }

        }

    return Status;
}


RPC_STATUS
LRPC_SASSOCIATION::GetClientName (
    IN LRPC_SCALL *SCall,
    IN OUT ULONG *ClientPrincipalNameBufferLength OPTIONAL,   // in bytes
    OUT RPC_CHAR **ClientPrincipalName
    )
/*++

Routine Description:

    Gets the client name for the given scall

Arguments:

    SCall - the SCall for which to get the client name
    ClientPrincipalNameBufferLength - if present, *ClientPrincipalName must
        point to a caller supplied buffer, which if big enough,
        will be filled with the client principal name. If not present,
        *ClientPrincipalName must be NULL.
    ClientPrincipalName - see ClientPrincipalNameBufferLength

Return Value:

    RPC_S_OK for success, or RPC_S_* / Win32 error code for error.

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    BOOL Result;
    unsigned long Size;
    HANDLE TokenHandle = 0;
    LRPC_SCONTEXT *SContext = 0;
    TOKEN_STATISTICS TokenStatisticsInformation;
    DictionaryCursor cursor;
    BOOL fAnonymous;
    BOOL fMutexHeld = FALSE;
    BOOL fAssociationSContextUsed = FALSE;
    RPC_CHAR *CurrentUserName;
    ULONG CurrentUserNameLength;

    if (SCall->SContext == NULL)
        {
        // take the lock opportunistically
        AssociationMutex.Request();

        fMutexHeld = TRUE;

        if (SCall->SContext == NULL)
            {
            Status = SaveToken(
                               SCall->LrpcRequestMessage,
                               &TokenHandle, 1);
            if ((Status != RPC_S_OK) && (Status != ERROR_CANT_OPEN_ANONYMOUS))
                {
                goto Cleanup;
                }

            if (Status == RPC_S_OK)
                {
                Result = GetTokenInformation(
                                             TokenHandle,
                                             TokenStatistics,
                                             &TokenStatisticsInformation,
                                             sizeof(TokenStatisticsInformation),
                                             &Size
                                             );
                if (Result != TRUE)
                    {
                    Status = RPC_S_INVALID_AUTH_IDENTITY;
                    goto Cleanup;
                    }

                fAnonymous = FALSE;
                }
            else
                {
                ASSERT(Status == ERROR_CANT_OPEN_ANONYMOUS);
                fAnonymous = TRUE;
                TokenHandle = 0;
                }

            SContextDict.Reset(cursor);
            while ((SContext = SContextDict.Next(cursor)) != 0)
                {
                // if either input and found are anonymous, or the modified
                // ids match, we have found it
                if ((fAnonymous && SContext->GetAnonymousFlag())
                    ||
                    FastCompareLUIDAligned(&SContext->ClientLuid,
                        &TokenStatisticsInformation.ModifiedId))
                    {
                    break;
                    }
                }

            if (SContext == 0)
                {
                SContext = new LRPC_SCONTEXT(NULL,
                            fAnonymous ? NULL : ((LUID *) &TokenStatisticsInformation.ModifiedId),
                            this,
                            FALSE,   // fDefaultLogonId
                            fAnonymous
                            );
                if (SContext == 0)
                    {
                    Status = RPC_S_OUT_OF_MEMORY;
                    goto Cleanup;
                    }

                if (SContextDict.Insert(SContext) == -1)
                    {
                    delete SContext;
                    Status = RPC_S_OUT_OF_MEMORY;
                    goto Cleanup;
                    }

                // mark the context as server side only
                SContext->SetServerSideOnlyFlag();

                // record that we have used this recently to prevent it from being
                // garbage collected
                SContext->UpdateLastAccessTime();

                EnableIdleLrpcSContextsCleanup();

                // tell the garbage collector that we have something to be
                // collected
                GarbageCollectionNeeded(FALSE,  // fOneTimeCleanup
                    LRPC_SCONTEXT::CONTEXT_IDLE_TIMEOUT);
                }
            else
                {
                // record that we have used this recently to prevent it from being
                // garbage collected
                SContext->UpdateLastAccessTime();
                }

            // we have taken or created the current SContext in the association
            // we need to prevent the garbage collection thread from destroying
            // it underneath us. We add one refcount for the purpose and record
            // this
            SContext->AddReference();

            fAssociationSContextUsed = TRUE;
            }
        else
            {
            SContext = SCall->SContext;

            // record that we have used this recently to prevent it from being
            // garbage collected
            SContext->UpdateLastAccessTime();
            }
        AssociationMutex.Clear() ;
        fMutexHeld = FALSE;
        }
    else
        {
        SContext = SCall->SContext;

        // record that we have used this recently to prevent it from being
        // garbage collected
        SContext->UpdateLastAccessTime();
        }

    ASSERT(SContext);

    // if we go through the path where the token is retrieved from
    // the SContext, passing NULL TokenHandle to get user name is Ok
    // as it will retrieve the token from the SContext
    Status = SContext->GetUserName(ClientPrincipalNameBufferLength, ClientPrincipalName, TokenHandle);

    // If ARGUMENT_PRESENT(ClientPrincipalNameBufferLength), Status may be
    // ERROR_MORE_DATA, which is a success error code.

    if (fAssociationSContextUsed)
        {
        if ((Status == RPC_S_OK) 
            && (!ARGUMENT_PRESENT(ClientPrincipalNameBufferLength)))
            {
            // we weren't supplied a user buffer. Copy the principal
            // name to a call variable to avoid the garbage collector
            // collecting this under the feet of our caller. Then
            // we can release the refcount
            if (SCall->ClientPrincipalName == NULL)
                {
                CurrentUserNameLength = (RpcpStringLength(*ClientPrincipalName) + 1) * sizeof(RPC_CHAR);
                // CurrentUserNameLength is in bytes. Allocate chars for it and cast it back
                CurrentUserName = (RPC_CHAR *) new char [CurrentUserNameLength];
                if (CurrentUserName != NULL)
                    {
                    RpcpMemoryCopy(CurrentUserName,
                        *ClientPrincipalName,
                        CurrentUserNameLength);
                    SCall->ClientPrincipalName = CurrentUserName;
                    *ClientPrincipalName = CurrentUserName;
                    }
                else
                    {
                    Status = RPC_S_OUT_OF_MEMORY;
                    // fall through in cleanup path
                    }
                }
            else
                {
                *ClientPrincipalName = SCall->ClientPrincipalName;
                }
            }

        // succeeded or not, drop the refcount
        SContext->RemoveReference();
        }

    if (Status != RPC_S_OK)
        {
        // N.B. failure of this function doesn't mean we have
        // to delete a newly created scontext. scontexts without
        // names are perfectly valid, and since we know the only
        // missing part from this scontext is the name, we can
        // leave it alone, return failure, and attempt to get the 
        // name next time
        goto Cleanup;
        }

Cleanup:

    if (fMutexHeld)
        {
        AssociationMutex.Clear() ;
        }

    if (TokenHandle)
        {
        CloseHandle(TokenHandle);
        }

    return Status;
}

#if defined(_WIN64)
C_ASSERT((FIELD_OFFSET(TOKEN_STATISTICS, ModifiedId) % 8) == 0);
C_ASSERT((FIELD_OFFSET(LRPC_SCONTEXT, ClientLuid) % 8) == 0);
#endif


void
LRPC_SASSOCIATION::DealWithBindMessage (
    IN LRPC_MESSAGE * LrpcMessage
    )
/*++

Routine Description:

    LRPC_ADDRESS::ReceiveLotsaCalls will call this routine when the client
    sends a bind message.  We need to process the bind message, and send
    a response to the client.

Arguments:

    LrpcMessage - Supplies the bind message.  We will also use this to send
        the response.

Return Value:

    The reply message to be sent to the client will be returned.

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    NTSTATUS NtStatus ;
    HANDLE ImpersonationToken = 0;
    HANDLE TokenHandle;
    unsigned long Size;
    BOOL Result;
    LRPC_SCONTEXT *SContext;
    ULONG SecurityContextId = -1;
    DictionaryCursor cursor;
    BOOL fBindDefaultLogonId;
    BOOL fAnonymous;

    if (LrpcMessage->Bind.BindExchange.Flags & NEW_SECURITY_CONTEXT_FLAG)
        {
        TOKEN_STATISTICS TokenStatisticsInformation;

        //
        // If SaveToken succeeds, as a side-effect, it will
        // fill in the SecurityContextId field of the BindExchange
        //
        Status = SaveToken(
                           LrpcMessage,
                           &TokenHandle) ;

        if ((Status != RPC_S_OK) && (Status != ERROR_CANT_OPEN_ANONYMOUS))
            {
            RpcpErrorAddRecord(EEInfoGCRuntime, 
                Status, 
                EEInfoDLDealWithBindMessage10);
            goto Cleanup;
            }

        if (TokenHandle || (Status == ERROR_CANT_OPEN_ANONYMOUS))
            {
            if (TokenHandle)
                {
                Result = GetTokenInformation(
                                         TokenHandle,
                                         TokenStatistics,
                                         &TokenStatisticsInformation,
                                         sizeof(TokenStatisticsInformation),
                                         &Size
                                         );
                if (Result != TRUE)
                    {
                    RpcpErrorAddRecord(EEInfoGCRuntime,
                        RPC_S_INVALID_AUTH_IDENTITY, 
                        EEInfoDLDealWithBindMessage20,
                        GetLastError());
                    CloseHandle(TokenHandle);
                    Status = RPC_S_INVALID_AUTH_IDENTITY;
                    goto Cleanup;
                    }

                fAnonymous = FALSE;
                }
            else
                {
                fAnonymous = TRUE;
                Status = RPC_S_OK;
                }

            AssociationMutex.Request();

            int Key = 0;
            fBindDefaultLogonId = 
                (LrpcMessage->Bind.BindExchange.Flags & DEFAULT_LOGONID_FLAG) 
                ? TRUE : FALSE;
            SContextDict.Reset(cursor);
            while ((SContext = SContextDict.NextWithKey(cursor, &Key)) != 0)
                {
                if ((fAnonymous && SContext->GetAnonymousFlag())
                    ||
                    (FastCompareLUIDAligned(&SContext->ClientLuid,
                      &TokenStatisticsInformation.ModifiedId)
                        &&
                    (SContext->GetDefaultLogonIdFlag() == fBindDefaultLogonId)))
                    {
                    SecurityContextId = Key;
                    SContext->ClearServerSideOnlyFlag();
                    break;
                    }
                }

            if (SContext == 0)
                {
                if (fAnonymous)
                    {
                    SContext = new LRPC_SCONTEXT(TokenHandle,
                             (LUID *) NULL,
                             this,
                             0,
                             fAnonymous);
                    }
                else
                    {
                    SContext = new LRPC_SCONTEXT(TokenHandle,
                             (LUID *) &TokenStatisticsInformation.ModifiedId,
                             this,
                             fBindDefaultLogonId,
                             0      // fAnonymousToken
                             );
                    }

                if (SContext == 0)
                    {
                    RpcpErrorAddRecord(EEInfoGCRuntime,
                        RPC_S_OUT_OF_MEMORY, 
                        EEInfoDLDealWithBindMessage30,
                        sizeof(LRPC_SCONTEXT));
                    CloseHandle(TokenHandle);
                    Status = RPC_S_OUT_OF_MEMORY;
                    AssociationMutex.Clear();

                    goto Cleanup;
                    }

                if ((SecurityContextId = SContextDict.Insert(SContext)) == -1)
                    {
                    RpcpErrorAddRecord(EEInfoGCRuntime,
                        RPC_S_OUT_OF_MEMORY, 
                        EEInfoDLDealWithBindMessage40);
                    delete SContext;
                    Status = RPC_S_OUT_OF_MEMORY;
                    AssociationMutex.Clear();

                    goto Cleanup;
                    }

                }
            else if (SContext->hToken == NULL)
                {
                // if the context had no token, add one. This can happen
                // if previous callers for this modified id just queried
                // the user name. In this case, we won't cache the token
                SContext->hToken = TokenHandle;
                }
            else
                {
                CloseHandle(TokenHandle);
                }

            AssociationMutex.Clear();
            }

Cleanup:
        //
        // Revert
        //
        NtStatus = NtSetInformationThread(NtCurrentThread(),
                                          ThreadImpersonationToken,
                                          &ImpersonationToken,
                                          sizeof(HANDLE));

    #if DBG
        if (!NT_SUCCESS(NtStatus))
            {
            PrintToDebugger("RPC : NtSetInformationThread : %lx\n", NtStatus);
            }
    #endif // DBG
        }

    if (Status == RPC_S_OK
        && LrpcMessage->Bind.BindExchange.Flags & NEW_PRESENTATION_CONTEXT_FLAG)
        {
        Status = AddBinding(&(LrpcMessage->Bind.BindExchange));
        if (Status != RPC_S_OK)
            {
            RpcpErrorAddRecord(EEInfoGCRuntime,
                Status, 
                EEInfoDLDealWithBindMessage50);
            }
        }

    LrpcMessage->Bind.BindExchange.RpcStatus = Status ;

    if (LrpcMessage->Bind.OldSecurityContexts.NumContexts > 0)
        {
        DWORD i;
        LRPC_SCONTEXT *SContext;
        DWORD NumContexts = LrpcMessage->Bind.OldSecurityContexts.NumContexts;
        DWORD CalculatedSize = ((NumContexts-1) * sizeof(DWORD))+sizeof(LRPC_BIND_MESSAGE);

        if (NumContexts > MAX_LRPC_CONTEXTS
            || CalculatedSize > (DWORD) LrpcMessage->LpcHeader.u1.s1.TotalLength)
            {
            //
            // Bogus request
            //
            LrpcMessage->Bind.BindExchange.RpcStatus = RPC_S_PROTOCOL_ERROR;
            RpcpErrorAddRecord(EEInfoGCRuntime,
                RPC_S_PROTOCOL_ERROR, 
                EEInfoDLDealWithBindMessage60,
                NumContexts,
                CalculatedSize,
                (DWORD) LrpcMessage->LpcHeader.u1.s1.TotalLength);
            goto Reply;
            }
        
        AssociationMutex.Request();
        for (i = 0; i < NumContexts; i++)
            {
            SContext = SContextDict.Delete(
                LrpcMessage->Bind.OldSecurityContexts.SecurityContextId[i]);
            if (SContext)
                {
                SContext->Destroy();
                }
            else
                {
                ASSERT(0);
                }
            }
        AssociationMutex.Clear();
        }

Reply:
    // if failure, check out of EEInfo
    if ((LrpcMessage->Bind.BindExchange.RpcStatus != RPC_S_OK) && (g_fSendEEInfo))
        {
        SetBindAckFault(LrpcMessage, 
            LrpcMessage->Bind.BindExchange.RpcStatus);
        }

    LrpcMessage->Bind.MessageType = LRPC_BIND_ACK ;
    LrpcMessage->Bind.BindExchange.SecurityContextId = SecurityContextId;
    if (!(LrpcMessage->Bind.BindExchange.Flags & EXTENDED_ERROR_INFO_PRESENT))
        {
        LrpcMessage->LpcHeader.u1.s1.DataLength = sizeof(LRPC_BIND_MESSAGE)
                - sizeof(PORT_MESSAGE);
        }

    ReplyMessage(LrpcMessage);
}

RPC_STATUS LRPC_SASSOCIATION::CreateThread(void)
{
    RPC_STATUS status;
    status = Address->BeginLongCall();
    if (status != RPC_S_OK)
        {
        Address->EndLongCall();
        }
    return status;
}

void LRPC_SASSOCIATION::RundownNotificationCompleted(void)
{
    Address->EndLongCall();
}

RPC_STATUS
LRPC_SBINDING::CheckSecurity (
    SCALL * Context
    )
{
    if ( (RpcInterface->SequenceNumber == SequenceNumber)
         || (RpcInterface->IsSecurityCallbackReqd() == 0))
        {
        return (RPC_S_OK);
        }

    RPC_STATUS Status = RpcInterface->CheckSecurityIfNecessary(Context);

    NukeStaleEEInfoIfNecessary(Status);

    Context->RevertToSelf();

    if (Status == RPC_S_OK)
        {
        SequenceNumber = RpcInterface->SequenceNumber ;
        return (RPC_S_OK);
        }
    else
        {
        SequenceNumber = 0;
        RpcpErrorAddRecord(EEInfoGCApplication, 
            RPC_S_ACCESS_DENIED, 
            EEInfoDLCheckSecurity10,
            Status);
        return (RPC_S_ACCESS_DENIED);
        }
}


void
LRPC_SCALL::DealWithRequestMessage (
    )
/*++

Routine Description:

    We will process the original request message in this routine, dispatch
    the remote procedure call to the stub, and then send the response
    message.

Arguments:

    RpcMessage - Contains the request buffer

Return Value:

    none

--*/
{
    RPC_STATUS Status, ExceptionCode;
    int Flags = LrpcRequestMessage->Rpc.RpcHeader.Flags ;
    LRPC_SBINDING *LrpcBinding ;
    THREAD *ThisThread;
    DebugThreadInfo *ThreadDebugCell;
    DebugCallInfo *CallDebugCell;
    ULONG TickCount;
    PRPC_DISPATCH_TABLE DispatchTableToUse;

    RuntimeInfo.Length = sizeof(RPC_RUNTIME_INFO) ;

    ClientId = MsgClientIdToClientId(LrpcRequestMessage->LpcHeader.ClientId);
    MessageId = LrpcRequestMessage->LpcHeader.MessageId;
    CallbackId = LrpcRequestMessage->LpcHeader.CallbackId;

    LrpcBinding = LookupBinding(
        LrpcRequestMessage->Rpc.RpcHeader.PresentContext);
    if (LrpcBinding == 0)
        {
        COPYMSG(LrpcReplyMessage, LrpcRequestMessage) ;
        FreeBuffer(&RpcMessage);
        RpcpErrorAddRecord(EEInfoGCRuntime, 
            RPC_S_UNKNOWN_IF, 
            EEInfoDLDealWithRequestMessage10,
            LrpcRequestMessage->Rpc.RpcHeader.PresentContext);
        SetFaultPacket(LrpcReplyMessage, RPC_S_UNKNOWN_IF, Flags, NULL);
        return;
        }

    SBinding = LrpcBinding;

    if (SBinding->RpcInterface->IsAutoListenInterface())
        {
        LrpcBinding->RpcInterface->BeginAutoListenCall() ;
        }

    LrpcBinding->GetSelectedTransferSyntaxAndDispatchTable(&RpcMessage.TransferSyntax,
        &DispatchTableToUse);
    RpcMessage.ProcNum = LrpcRequestMessage->Rpc.RpcHeader.ProcedureNumber;
    RpcMessage.Handle = this;
    RpcMessage.ReservedForRuntime = &RuntimeInfo ;

    // NDR_DREP_ASCII | NDR_DREP_LITTLE_ENDIAN | NDR_DREP_IEEE

    RpcMessage.DataRepresentation = 0x00 | 0x10 | 0x0000;

    if ((LrpcRequestMessage->Rpc.RpcHeader.Flags & LRPC_OBJECT_UUID))
        {
        ObjectUuidFlag = 1;
        RpcpMemoryCopy(&ObjectUuid,
            &(LrpcRequestMessage->Rpc.RpcHeader.ObjectUuid), sizeof(UUID));
        }

    ThisThread = RpcpGetThreadPointer();

    ASSERT(ThisThread);

    RpcpSetThreadContextWithThread(ThisThread, this);

    ThreadDebugCell = ThisThread->DebugCell;

    //
    // Check IF Level Security
    //
    if (LrpcBinding->RpcInterface->IsSecurityCallbackReqd() != 0)
        {
        Status = LrpcBinding->CheckSecurity(this);
        if (Status != RPC_S_OK)
            {
            COPYMSG(LrpcReplyMessage, LrpcRequestMessage) ;

            FreeBuffer(&RpcMessage);

            // the error record (if any) was already added
            // by CheckSecurity
            SetFaultPacket(LrpcReplyMessage,
                           RPC_S_ACCESS_DENIED,
                           Flags,
                           NULL) ;

            RpcpSetThreadContextWithThread(ThisThread, 0) ;
            return;
            }
        }

    if (ThreadDebugCell)
        {
        TickCount = NtGetTickCount();

        ThreadDebugCell->Status = dtsDispatched;
        ThreadDebugCell->LastUpdateTime = TickCount;

        CallDebugCell = DebugCell;
        CallDebugCell->InterfaceUUIDStart = LrpcBinding->RpcInterface->GetInterfaceFirstDWORD();
        CallDebugCell->CallID = CallId;
        CallDebugCell->LastUpdateTime = TickCount;
        // shoehorn the PID and TID into shorts - most of the time
        // it doesn't actually truncate important information
        CallDebugCell->PID = (USHORT)ClientId.UniqueProcess;
        CallDebugCell->TID = (USHORT)ClientId.UniqueThread;
        CallDebugCell->ProcNum = (unsigned short)RpcMessage.ProcNum;
        CallDebugCell->Status = csDispatched;
        GetDebugCellIDFromDebugCell((DebugCellUnion *)ThreadDebugCell, 
            &ThisThread->DebugCellTag, &CallDebugCell->ServicingTID);
        if (LrpcBinding->RpcInterface->IsPipeInterface())
            CallDebugCell->CallFlags |= DBGCELL_PIPE_CALL;
        }

    if (ObjectUuidFlag != 0)
        {
        Status = LrpcBinding->RpcInterface->DispatchToStubWithObject(
                                        &RpcMessage,
                                        &ObjectUuid,
                                        0,
                                        DispatchTableToUse,
                                        &ExceptionCode);
        }
    else
        {
        Status = LrpcBinding->RpcInterface->DispatchToStub(
                                        &RpcMessage,
                                        0,
                                        DispatchTableToUse,
                                        &ExceptionCode);
        }

    RpcpSetThreadContextWithThread(ThisThread, 0);

    LRPC_SCALL::RevertToSelf();

    if (ThreadDebugCell)
        {
        ThreadDebugCell->Status = dtsProcessing;
        ThreadDebugCell->LastUpdateTime = NtGetTickCount();
        }

    if (Status != RPC_S_OK)
        {
        if (Status == RPC_P_EXCEPTION_OCCURED)
            {
            SetFaultPacket(LrpcReplyMessage,
                           LrpcMapRpcStatus(ExceptionCode),
                           Flags,
                           this) ;
            }
        else
            {
            VALIDATE(Status)
                {
                RPC_S_PROCNUM_OUT_OF_RANGE,
                RPC_S_UNKNOWN_IF,
                RPC_S_NOT_LISTENING,
                RPC_S_SERVER_TOO_BUSY,
                RPC_S_UNSUPPORTED_TYPE
                } END_VALIDATE;

            if (Status == RPC_S_NOT_LISTENING)
                {
                RpcpErrorAddRecord(EEInfoGCRuntime, 
                    Status, 
                    EEInfoDLDealWithRequestMessage20);
                Status = RPC_S_SERVER_TOO_BUSY;
                }

            RpcpErrorAddRecord(EEInfoGCRuntime, 
                Status, 
                EEInfoDLDealWithRequestMessage30);
            SetFaultPacket(LrpcReplyMessage,
                           LrpcMapRpcStatus(Status),
                           Flags,
                           this);
            }

        if (IsSyncCall())
            {
            INITMSG(LrpcReplyMessage,
                    ClientId,
                    CallbackId,
                    MessageId) ;
            }
        else
            {
            if (Flags & LRPC_NON_PIPE)
                {
                INITMSG(LrpcReplyMessage,
                    ClientId,
                    CallbackId,
                    MessageId) ;

                Association->ReplyMessage(LrpcReplyMessage);
                }
            else
                {
                if ((LrpcReplyMessage->Rpc.RpcHeader.MessageType != LRPC_MSG_FAULT2)
                    || (!IsClientAsync()))
                    {
                    SendDGReply(LrpcReplyMessage);
                    }
                }
            RemoveReference();
            }
        }
    else
        {
        //
        // The rest of the response headers are set in ::GetBuffer.
        //
        LrpcReplyMessage->Rpc.RpcHeader.MessageType = LRPC_MSG_RESPONSE;
        }
}


void
LRPC_SCALL::SendReply (
    )
{
    RPC_STATUS Status;
    BOOL Shutup ;
    LRPC_SASSOCIATION *LocalAssociation;

    if (IsSyncCall())
        {
        if (IsClientAsync())
            {
            if (LrpcReplyMessage->Fault.RpcHeader.MessageType == LRPC_MSG_FAULT)
                {
                SendDGReply(LrpcReplyMessage);
                }
            else
                {
                RpcMessage.RpcFlags = 0;
                Status = SendRequest(&RpcMessage, &Shutup) ;
                if (Status != RPC_S_OK)
                    {
#if DBG
                    PrintToDebugger("RPC: SendRequest failed: %d\n", Status);
#endif
                    Association->Delete();
                    }
                }

            }
        else
            {
            INITMSG(LrpcReplyMessage,
                ClientId,
                CallbackId,
                MessageId) ;

            Association->ReplyMessage(LrpcReplyMessage);
            }

        FreeMessage(LrpcRequestMessage) ;

        LocalAssociation = Association;
        Association->FreeSCall(this) ;

        // don't touch the this pointer after FreeSCall - it may be freed
        LocalAssociation->Address->DereferenceAssociation(LocalAssociation);
        }
    else
        {
        if ((LrpcReplyMessage->Rpc.RpcHeader.MessageType != LRPC_MSG_FAULT2)
            || (!IsClientAsync()))
            {
            RemoveReference();
            }
        else
            {
            BOOL Shutup;
            RpcMessage.RpcFlags = 0;
            Status = SendRequest(&RpcMessage, &Shutup) ;
            if (Status != RPC_S_OK)
                {
#if DBG
                PrintToDebugger("RPC: SendRequest failed: %d\n", Status);
#endif
                Association->Delete();
                }
            }
        }
}


LRPC_MESSAGE *
LRPC_SASSOCIATION::DealWithCopyMessage (
    IN LRPC_COPY_MESSAGE * LrpcMessage
    )
/*++

Routine Description:

    We will process a copy message in this routine; this means that we need
    to copy a buffer of data from the server into the client's address
    space.

Arguments:

    LrpcMessage - Supplies the copy message which was received from
        the client.

Return Value:

    The reply message to be sent to the client will be returned.

--*/
{
    NTSTATUS NtStatus;
    SIZE_T NumberOfBytesWritten;
    PVOID Buffer;

    ASSERT(LrpcMessage->IsPartial == 0);

    AssociationMutex.Request() ;

    // We need this only to prevent an attack
    // Also, the pointer is to a server address.  It is ok to just cast it
    // to the server's pointer type and it won't hurt anything in the case
    // of 32/64 bit LRPC.
    Buffer = Buffers.DeleteItemByBruteForce(MsgPtrToPtr(LrpcMessage->Server.Buffer));
    AssociationMutex.Clear() ;

   if (LrpcMessage->RpcStatus == RPC_S_OK)
       {
       if (Buffer == 0)
           {
           LrpcMessage->RpcStatus = RPC_S_PROTOCOL_ERROR;
           }
       else
           {
           NtStatus = NtWriteRequestData(LpcServerPort,
                                         (PORT_MESSAGE *) LrpcMessage,
                                         0,
                                         (PVOID) Buffer,
                                         LrpcMessage->Server.Length,
                                         &NumberOfBytesWritten);

           if (NT_ERROR(NtStatus))
               {
               LrpcMessage->RpcStatus = RPC_S_OUT_OF_MEMORY;
               }
           else
               {
               ASSERT(LrpcMessage->Server.Length == NumberOfBytesWritten);
               LrpcMessage->RpcStatus = RPC_S_OK;
               }
           }
       }

    LrpcMessage->LpcHeader.u1.s1.DataLength = sizeof(LRPC_COPY_MESSAGE)
                                            - sizeof(PORT_MESSAGE);
    LrpcMessage->LpcHeader.u1.s1.TotalLength = sizeof(LRPC_COPY_MESSAGE);

    if (Buffer != 0)
        {
        RpcpFarFree(Buffer);
        }

    return((LRPC_MESSAGE *) LrpcMessage);
}


LRPC_MESSAGE *
LRPC_SASSOCIATION::DealWithPartialRequest (
    IN LRPC_MESSAGE **LrpcMessage
    )
/*++

Routine Description:

    Deal with more data on  a dispatched call. This
    only happens when you have pipes. Pipe data on
    async calls is handled differently from sync calls.

Arguments:

 LrpcMessage - the LRPC message. For pipe data, we always
    take the slow path (ie: NtReadRequestData).

Return Value:

  NULL: if the request was processed.
  not NULL: if there was a problem. the return value contains the
  reply message.
--*/

{
    LRPC_SCALL *SCall ;
    RPC_STATUS Status ;

    AssociationMutex.Request() ;
    SCall = SCallDict.Find(ULongToPtr((*LrpcMessage)->Rpc.RpcHeader.CallId));
    AssociationMutex.Clear() ;

    // we have to wait until the server either calls
    // Receive or calls Register. If it Calls Receive,
    // we know that it is synchronous. If it calls
    // Register, we know that it is async.

    if (SCall)
        {
        Status = SCall->ProcessResponse(LrpcMessage) ;
        }
    else
        {
#if DBG
        PrintToDebugger("LRPC: No call corresponding the the pipe request\n");
#endif
        Status = RPC_S_OUT_OF_MEMORY ;
        }

    if (Status != RPC_S_OK)
        {
        SetFaultPacket(*LrpcMessage,
                       Status,
                       LRPC_SYNC_CLIENT,
                       NULL) ;
        return *LrpcMessage ;
        }

    return NULL ;
}

void
LRPC_SASSOCIATION::CleanupIdleSContexts (
    void
    )
/*++

Routine Description:

    Walks the list of SContexts, finds the ones
    that are idle and server side only, and cleans
    them up.

Arguments:

Return Value:

--*/
{
    LRPC_SCONTEXT *SContext;
    DictionaryCursor cursor;

    SContextDict.Reset(cursor);

    AssociationMutex.Request();
    while ((SContext = SContextDict.Next(cursor)) != 0)
        {
        if (SContext->GetServerSideOnlyFlag())
            {
            if (SContext->IsIdle())
                {
                SContext = (LRPC_SCONTEXT *)SContextDict.DeleteItemByBruteForce(SContext);
                ASSERT(SContext);

                SContext->Destroy();
                }
            }
        }

    AssociationMutex.Clear();
}


RPC_STATUS
LRPC_SCALL::SetupCall(
    )
/*++

Routine Description:

    Helper function that does the setup needed to use the
    call in conjuction with Pipes or Async RPC.

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/

{
    RPC_STATUS Status = RPC_S_OK ;

    //
    // Stuff from ActivateCall
    //
    RcvBufferLength = 0;
    CallId = LrpcRequestMessage->Rpc.RpcHeader.CallId ;
    ReceiveComplete = 0;
    AsyncReply = 0;
    CachedAPCInfoAvailable = 1;
    Choked = 0;
    AsyncStatus = RPC_S_OK ;
    NeededLength = 0;
    NotificationIssued = -1;

    if (ReceiveEvent == 0)
        {
        ReceiveEvent = new EVENT(&Status, 0);
        if (ReceiveEvent == 0 || Status)
            {
            delete ReceiveEvent;
            ReceiveEvent = 0;
            return RPC_S_OUT_OF_MEMORY ;
            }

        CallMutex = new MUTEX(&Status) ;
        if (CallMutex == 0 || Status)
            {
            Association->SCallDict.Delete(ULongToPtr(CallId));
            goto Cleanup;
            }
        }
    else
        {
        ReceiveEvent->Lower();
        }

    Association->AssociationMutex.Request() ;
    if (Association->SCallDict.Insert(ULongToPtr(CallId), this) == -1)
        {
        Association->AssociationMutex.Clear() ;
        goto Cleanup;
        }
    Association->AssociationMutex.Clear() ;

    LrpcReplyMessage->Rpc.RpcHeader.CallId = CallId ;

    return (RPC_S_OK) ;

Cleanup:
    delete CallMutex ;
    delete ReceiveEvent;

    CallMutex = 0;
    ReceiveEvent = 0;

    return RPC_S_OUT_OF_MEMORY ;
}

RPC_STATUS
LRPC_SCALL::NegotiateTransferSyntax (
    IN OUT PRPC_MESSAGE Message
    )
{
    // this can happen in the callback case only.
    // Just return the already negotiated transfer syntax
    PRPC_DISPATCH_TABLE Ignored;

    SBinding->GetSelectedTransferSyntaxAndDispatchTable(&Message->TransferSyntax,
        &Ignored);

    return RPC_S_OK;
}


RPC_STATUS
LRPC_SCALL::GetBuffer (
    IN OUT PRPC_MESSAGE Message,
    IN UUID *
    )
/*++

Routine Description:

    We will allocate a buffer which will be used to either send a request
    or receive a response.

Arguments:

    Message - Supplies the length of the buffer that is needed.  The buffer
        will be returned.

Return Value:

    RPC_S_OK - A buffer has been successfully allocated.  It will be of at
        least the required length.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allocate that
        large a buffer.

--*/
{
    int BufferKey ;

    ASSERT(LrpcReplyMessage != 0) ;

    if (PARTIAL(Message))
        {
        CurrentBufferLength =
            (Message->BufferLength < MINIMUM_PARTIAL_BUFFLEN)
            ? MINIMUM_PARTIAL_BUFFLEN:Message->BufferLength ;

        Message->Buffer = RpcpFarAllocate(CurrentBufferLength) ;
        if (Message->Buffer == 0)
            {
            CurrentBufferLength = 0;
            return (RPC_S_OUT_OF_MEMORY) ;
            }
        }
    else if (Message->BufferLength <= MAXIMUM_MESSAGE_BUFFER)
        {
        ASSERT(((ULONG_PTR) LrpcReplyMessage->Rpc.Buffer) % 8 == 0);
        // uncomment this to check for 16 byte alignment on 64 bits
        // ASSERT(IsBufferAligned(LrpcReplyMessage->Rpc.Buffer));
        Message->Buffer = LrpcReplyMessage->Rpc.Buffer;
        LrpcReplyMessage->LpcHeader.u2.ZeroInit = 0;
        LrpcReplyMessage->Rpc.RpcHeader.Flags = LRPC_BUFFER_IMMEDIATE;
        LrpcReplyMessage->LpcHeader.u1.s1.DataLength = (USHORT)
                (Align4(Message->BufferLength) + sizeof(LRPC_RPC_HEADER));

        return (RPC_S_OK) ;
        }
    else
        {
        Message->Buffer = RpcpFarAllocate(Message->BufferLength);
        if (Message->Buffer == 0)
            {
            return(RPC_S_OUT_OF_MEMORY);
            }
        }

    LrpcReplyMessage->Rpc.RpcHeader.Flags = LRPC_BUFFER_SERVER;
    LrpcReplyMessage->LpcHeader.u2.ZeroInit = 0;

    if (PARTIAL(Message) || IsClientAsync())
        {
        LrpcReplyMessage->Rpc.Request.CountDataEntries = 1;
        LrpcReplyMessage->LpcHeader.MessageId =  0;
        LrpcReplyMessage->LpcHeader.CallbackId = 0;
        LrpcReplyMessage->LpcHeader.u2.s2.DataInfoOffset =
            sizeof(PORT_MESSAGE) + sizeof(LRPC_RPC_HEADER);
        LrpcReplyMessage->LpcHeader.u1.s1.DataLength =
            sizeof(LRPC_RPC_HEADER) + sizeof(PORT_DATA_INFORMATION);
        LrpcReplyMessage->Rpc.Request.DataEntries[0].Base = PtrToMsgPtr(Message->Buffer);
        LrpcReplyMessage->Rpc.Request.DataEntries[0].Size = Message->BufferLength;
        }
    else
        {
        Association->AssociationMutex.Request() ;
        BufferKey = Association->Buffers.Insert((LRPC_CLIENT_BUFFER *) Message->Buffer) ;
        Association->AssociationMutex.Clear() ;

        if (BufferKey == -1)
            {
            RpcpFarFree(Message->Buffer) ;
            return RPC_S_OUT_OF_MEMORY ;
            }

        LrpcReplyMessage->LpcHeader.u1.s1.DataLength =
            sizeof(LRPC_RPC_HEADER) + sizeof(LRPC_SERVER_BUFFER) ;

        ASSERT(Message->BufferLength < 0x80000000);

        LrpcReplyMessage->Rpc.Server.Length = Message->BufferLength ;
        LrpcReplyMessage->Rpc.Server.Buffer = PtrToMsgPtr(Message->Buffer) ;
        }

    return(RPC_S_OK);
}



void
LRPC_SCALL::FreeBuffer (
    IN PRPC_MESSAGE Message
    )
/*++

Routine Description:

    We will free the supplied buffer.

Arguments:

    Message - Supplies the buffer to be freed.

--*/
{
    ASSERT(LrpcReplyMessage != NULL) ;

    if (!(Message->Buffer == LrpcRequestMessage->Rpc.Buffer
        || Message->Buffer == LrpcReplyMessage->Rpc.Buffer))
        {
        if (!PARTIAL(Message) && !IsClientAsync())
            {
            Association->AssociationMutex.Request() ;
            Association->Buffers.DeleteItemByBruteForce((LRPC_CLIENT_BUFFER *) Message->Buffer);
            Association->AssociationMutex.Clear() ;
            }

        RpcpFarFree(Message->Buffer);
        }
}

void
LRPC_SCALL::FreePipeBuffer (
    IN PRPC_MESSAGE Message
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/

{
    RpcpFarFree(Message->Buffer) ;
}

RPC_STATUS
LRPC_SCALL::ReallocPipeBuffer (
    IN PRPC_MESSAGE Message,
    IN unsigned int NewSize
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/

{
    int BufferKey;
    PVOID Buffer ;
    void *NewBuffer ;
    BOOL BufferChanged = FALSE ;

    if (NewSize > CurrentBufferLength)
        {
        NewBuffer = RpcpFarAllocate(NewSize) ;
        if (NewBuffer == 0)
            {
            RpcpFarFree(Message->Buffer) ;

            return (RPC_S_OUT_OF_MEMORY) ;
            }

        if (CurrentBufferLength > 0)
            {
            RpcpMemoryCopy(NewBuffer, Message->Buffer, Message->BufferLength) ;
            FreePipeBuffer(Message) ;
            }
        Message->Buffer = NewBuffer ;
        CurrentBufferLength = NewSize ;
        BufferChanged = TRUE ;
        }

    Message->BufferLength = NewSize ;

    LrpcReplyMessage->Rpc.RpcHeader.Flags = LRPC_BUFFER_SERVER;

    ASSERT(Message->BufferLength < 0x80000000);

    LrpcReplyMessage->Rpc.Request.DataEntries[0].Base = PtrToMsgPtr(Message->Buffer);
    LrpcReplyMessage->Rpc.Request.DataEntries[0].Size = Message->BufferLength;


    return (RPC_S_OK) ;
}


RPC_STATUS
LRPC_SCALL::AbortAsyncCall (
    IN PRPC_ASYNC_STATE pAsync,
    IN unsigned long ExceptionCode
    )
{
    NTSTATUS NtStatus;
    RPC_STATUS Status = RPC_S_OK;

    NukeStaleEEInfoIfNecessary(ExceptionCode);

    RpcpErrorAddRecord(EEInfoGCApplication, 
        ExceptionCode, 
        EEInfoDLAbortCall, 
        SBinding->GetInterfaceFirstDWORD(),
        (short)RpcMessage.ProcNum,
        RpcMessage.RpcFlags);

    SetFaultPacket(LrpcReplyMessage, ExceptionCode, Flags, this);

    if (IsClientAsync())
        {
        if (LrpcReplyMessage->Rpc.RpcHeader.MessageType != LRPC_MSG_FAULT2)
            {
            NtStatus = SendDGReply(LrpcReplyMessage) ;
            }
        else
            {
            BOOL Ignored;
            RpcMessage.RpcFlags = 0;
            RpcMessage.Buffer = NULL;
            Status = SendRequest(&RpcMessage, 
                &Ignored        // shutup parameter - it is not relevant for us
                );
            if (Status != RPC_S_OK)
                {
#if DBG
                PrintToDebugger("RPC: SendRequest failed: %d\n", Status);
#endif
                Association->Delete();
                }
            }
        }
    else
        {
        INITMSG(LrpcReplyMessage,
                ClientId,
                CallbackId,
                MessageId);

        NtStatus = Association->ReplyMessage(LrpcReplyMessage);
        }

    if (NT_ERROR(NtStatus))
        {
        Status = RPC_S_CALL_FAILED ;
        }

    RemoveReference();

    return Status ;
}


RPC_STATUS
LRPC_SCALL::Receive (
    IN PRPC_MESSAGE Message,
    IN unsigned int Size
    )
/*++

Routine Description:
    Receive routine used by pipes

Arguments:

   Message - contains to buffer to receive in
   pSize - pointer to a size value that contains the minimum amount of
              data that needs to be received.


Return Value:

    RPC_S_OK - We have successfully converted the message.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to do the
        conversion.

--*/
{
    int RequestedSize;
    unsigned long Extra = IsExtraMessage(Message) ;

    ASSERT(ReceiveEvent) ;

    Message->DataRepresentation = 0x00 | 0x10 | 0x0000;

    if (!Extra && Message->Buffer)
        {
        ASSERT(LrpcRequestMessage->Rpc.RpcHeader.Flags & LRPC_BUFFER_REQUEST);

        RpcpFarFree(Message->Buffer);
        Message->Buffer = 0;
        Message->BufferLength = 0;
        }

    //
    // It is ok for us to find out that the buffer is complete
    // before SavedBuffer is set,
    // we need to take the CallMutex in GetCoalescedBuffer
    //
    while (!BufferComplete && (!PARTIAL(Message) || RcvBufferLength < Size))
        {
        if (ReceiveEvent->Wait() == WAIT_FAILED)
            {
            return RPC_S_CALL_FAILED;
            }

        if (AsyncStatus != RPC_S_OK)
            {
            return AsyncStatus;
            }
        }

   return GetCoalescedBuffer(Message, Extra) ;
}


RPC_STATUS
LRPC_SCALL::Send (
    IN OUT PRPC_MESSAGE Message
    )
{
    BOOL Shutup ;

    Message->RpcFlags |= RPC_BUFFER_PARTIAL;

    return SendRequest(Message, &Shutup) ;
}


RPC_STATUS
LRPC_SCALL::SendRequest (
    IN OUT PRPC_MESSAGE Message,
    OUT BOOL *Shutup
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/

{
    RPC_STATUS Status;
    NTSTATUS NtStatus ;
    int RemainingLength = 0;
    LRPC_MESSAGE ReplyMessage ;

    *Shutup = 0;

    if (PARTIAL(Message))
        {
        if (Message->BufferLength < MINIMUM_PARTIAL_BUFFLEN)
            {
            return (RPC_S_SEND_INCOMPLETE) ;
            }

        if (NOT_MULTIPLE_OF_EIGHT(Message->BufferLength))
            {
            RemainingLength = Message->BufferLength & LOW_BITS ;
            Message->BufferLength &= ~LOW_BITS ;
            }

        LrpcReplyMessage->Rpc.RpcHeader.Flags |= LRPC_BUFFER_PARTIAL ;
        }

    if (FirstSend)
        {
        // this code will get executed only in
        // the non async case
        FirstSend = 0;

        if (ReceiveEvent == 0)
            {
            Status = SetupCall() ;
            if (Status != RPC_S_OK)
                {
                if (PARTIAL(Message)
                    && LrpcReplyMessage->Rpc.RpcHeader.Flags & LRPC_BUFFER_SERVER)
                    {
                    RpcpFarFree(Message->Buffer);
                    }
                return Status ;
                }
            }
        }

    if (LrpcReplyMessage->Rpc.RpcHeader.Flags & LRPC_BUFFER_SERVER)
        {
        ASSERT((Message->Buffer == NULL)
            || (PtrToMsgPtr(Message->Buffer) == LrpcReplyMessage->Rpc.Request.DataEntries[0].Base));

        LrpcReplyMessage->LpcHeader.u1.s1.TotalLength =
            LrpcReplyMessage->LpcHeader.u1.s1.DataLength
            + sizeof(PORT_MESSAGE);
        if (LrpcReplyMessage->Rpc.RpcHeader.Flags & LRPC_EEINFO_PRESENT)
            {
            LrpcReplyMessage->Rpc.RpcHeader.MessageType = LRPC_MSG_FAULT2;
            // for FAULT2, the length has already been set
            }
        else
            {
            LrpcReplyMessage->Rpc.RpcHeader.MessageType = LRPC_MSG_RESPONSE;
            LrpcReplyMessage->Rpc.Request.DataEntries[0].Size =
                Message->BufferLength ;
            }
        LrpcReplyMessage->Rpc.RpcHeader.CallId = CallId;

        NtStatus = NtRequestWaitReplyPort(Association->LpcReplyPort,
                                     (PORT_MESSAGE *) LrpcReplyMessage,
                                     (PORT_MESSAGE *) &ReplyMessage) ;

        if (NT_ERROR(NtStatus))
            {
            if (Message->Buffer)
                {
                RpcpFarFree(Message->Buffer);
                }
            return RPC_S_CALL_FAILED ;
            }
        else
            {
            ASSERT((ReplyMessage.Rpc.RpcHeader.MessageType == LRPC_MSG_ACK)
                   ||
                   (ReplyMessage.Rpc.RpcHeader.MessageType == LRPC_MSG_FAULT));

            if (!PARTIAL(Message) && 
                (LrpcReplyMessage->Rpc.RpcHeader.MessageType != LRPC_MSG_FAULT2) && 
                (LrpcReplyMessage->Rpc.RpcHeader.MessageType != LRPC_MSG_FAULT))
                {
                if (Message->Buffer)
                    {
                    RpcpFarFree(Message->Buffer);
                    }
                }

            if (ReplyMessage.Rpc.RpcHeader.MessageType == LRPC_MSG_ACK)
                {
                *Shutup = ReplyMessage.Ack.Shutup;
                }
            else
                {
                Status = ReplyMessage.Fault.RpcStatus;
                return Status;
                }
            }
        }
    else
        {
        ASSERT(!PARTIAL(Message)) ;

        LrpcReplyMessage->Rpc.RpcHeader.MessageType = LRPC_MSG_RESPONSE;
        NtStatus = SendDGReply(LrpcReplyMessage) ;

        if (NT_ERROR(NtStatus))
            {
            return RPC_S_CALL_FAILED ;
            }
        }

    if (RemainingLength)
        {
        ASSERT(PARTIAL(Message)) ;
        RpcpMemoryMove(Message->Buffer,
                      (char  *) Message->Buffer + Message->BufferLength,
                      RemainingLength) ;

        Message->BufferLength = RemainingLength ;
        return (RPC_S_SEND_INCOMPLETE) ;
        }

    return RPC_S_OK ;
}

inline RPC_STATUS
LRPC_SCALL::GetBufferDo(
    IN OUT PRPC_MESSAGE Message,
    IN unsigned long NewSize,
    IN BOOL fDataValid
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/

{
    void *NewBuffer ;

    if (NewSize < CurrentBufferLength)
        {
        Message->BufferLength = NewSize ;
        }
    else
        {
        NewBuffer = RpcpFarAllocate(NewSize) ;
        if (NewBuffer == 0)
            {
            RpcpFarFree(Message->Buffer) ;

            Message->BufferLength = 0;
            return RPC_S_OUT_OF_MEMORY ;
            }

        if (fDataValid && Message->BufferLength > 0)
            {
            RpcpMemoryCopy(NewBuffer,
                           Message->Buffer,
                           Message->BufferLength) ;
            }

        if (EXTRA(Message))
            {
            ASSERT(Message->ReservedForRuntime) ;
            ((PRPC_RUNTIME_INFO)Message->ReservedForRuntime)->OldBuffer =
                    NewBuffer;
            }

        RpcpFarFree(Message->Buffer) ;
        Message->Buffer = NewBuffer ;
        Message->BufferLength = NewSize ;
        }

    return RPC_S_OK ;
}


RPC_STATUS
LRPC_SCALL::SendReceive (
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:


Arguments:

    Message - Supplies the request and returns the response of a remote
        procedure call.

Return Value:

    RPC_S_OK - The remote procedure call completed successful.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to perform the
        remote procedure call.

    RPC_S_OUT_OF_RESOURCES - Insufficient resources are available to complete
        the remote procedure call.

--*/
{
    NTSTATUS NtStatus;
    RPC_STATUS ExceptionCode, Status;
    LRPC_MESSAGE *LrpcSavedMessage;
    SIZE_T NumberOfBytesRead;
    RPC_MESSAGE RpcMessage ;
    RPC_RUNTIME_INFO RuntimeInfo ;
    PRPC_DISPATCH_TABLE DispatchTableToUse;


    // The LrpcMessage must be saved, it is in use by the stub.  The current
    // LrpcReplyMessage can be used for the callback request message and reply.
    //
    // We must:
    // Save the current LrpcRequestMessage
    // Make the current LrpcReplyMessage the LrpcRequestMessage
    // Allocate a new LrpcReplyMessage.

    LrpcSavedMessage = LrpcRequestMessage;
    LrpcRequestMessage = LrpcReplyMessage;
    LrpcReplyMessage = 0;  // Only needed if we receive a recursive request.

    Association->Address->Server->OutgoingCallback();

    // NDR_DREP_ASCII | NDR_DREP_LITTLE_ENDIAN | NDR_DREP_IEEE
    Message->DataRepresentation = 0x00 | 0x10 | 0x0000;

    LrpcRequestMessage->LpcHeader.u1.s1.TotalLength = sizeof(PORT_MESSAGE)
            + LrpcRequestMessage->LpcHeader.u1.s1.DataLength;
    LrpcRequestMessage->LpcHeader.u2.s2.Type = LPC_REQUEST;
    INITMSG(LrpcRequestMessage, ClientId, CallbackId, MessageId);
    LrpcRequestMessage->Rpc.RpcHeader.MessageType = LRPC_MSG_CALLBACK;
    LrpcRequestMessage->Rpc.RpcHeader.ProcedureNumber = (unsigned short) Message->ProcNum;
    LrpcRequestMessage->Rpc.RpcHeader.PresentContext =
            SBinding->GetOnTheWirePresentationContext();

    NtStatus = NtRequestWaitReplyPort(Association->LpcServerPort,
                                      (PORT_MESSAGE *) LrpcRequestMessage,
                                      (PORT_MESSAGE *) LrpcRequestMessage);

    if (NT_ERROR(NtStatus))
        {
        LrpcReplyMessage = LrpcRequestMessage;
        LrpcRequestMessage = LrpcSavedMessage;

        if (NtStatus == STATUS_NO_MEMORY)
            {
            return(RPC_S_OUT_OF_MEMORY);
            }
        if (NtStatus == STATUS_INSUFFICIENT_RESOURCES)
            {
            return(RPC_S_OUT_OF_RESOURCES);
            }
#if DBG
        if ((NtStatus != STATUS_INVALID_PORT_HANDLE)
            && (NtStatus != STATUS_INVALID_HANDLE)
            && (NtStatus != STATUS_INVALID_CID)
            && (NtStatus != STATUS_PORT_DISCONNECTED)
            && (NtStatus != STATUS_LPC_REPLY_LOST))
            {
            PrintToDebugger("RPC : NtRequestWaitReplyPort : %lx\n",
                           NtStatus);

            ASSERT(0) ;
            }
#endif // DBG

        return(RPC_S_CALL_FAILED);
        }

    for (;;)
        {
        if (LrpcRequestMessage->Rpc.RpcHeader.MessageType
            == LRPC_MSG_FAULT)
            {
            Status = LrpcRequestMessage->Fault.RpcStatus;
            break;
            }

        if (LrpcRequestMessage->Rpc.RpcHeader.MessageType
            == LRPC_MSG_RESPONSE)
            {
            if (LrpcRequestMessage->Rpc.RpcHeader.Flags & LRPC_BUFFER_REQUEST)
                {
                LrpcRequestMessage->LpcHeader.ClientId = LrpcSavedMessage->Rpc.LpcHeader.ClientId;
                LrpcRequestMessage->LpcHeader.CallbackId = LrpcRequestMessage->Rpc.LpcHeader.CallbackId + 1;
                LrpcSavedMessage->LpcHeader.MessageId = LrpcSavedMessage->Rpc.LpcHeader.MessageId;
                }
            Status = LrpcMessageToRpcMessage(LrpcRequestMessage, Message);
            break;
            }

        if (LrpcRequestMessage->Rpc.RpcHeader.MessageType
            == LRPC_MSG_PUSH)
            {
            ASSERT(PushedResponse == 0);
            PushedResponse = RpcpFarAllocate(
                    (unsigned int)
                    LrpcRequestMessage->Push.Response.DataEntries[0].Size);
            if (PushedResponse == 0)
                {
                LrpcRequestMessage->Push.RpcStatus = RPC_S_OUT_OF_MEMORY;
                }
            else
                {
                NtStatus = NtReadRequestData(
                    Association->LpcServerPort,
                    (PORT_MESSAGE *) LrpcRequestMessage,
                    0,
                    PushedResponse,
                    LrpcRequestMessage->Push.Response.DataEntries[0].Size,
                    &NumberOfBytesRead);

                if (NT_ERROR(NtStatus))
                    {
                    RpcpFarFree(PushedResponse);
                    PushedResponse = 0;
                    LrpcRequestMessage->Push.RpcStatus = RPC_S_OUT_OF_MEMORY;
                    }
                else
                    {
                    ASSERT(LrpcRequestMessage->Push.Response.DataEntries[0].Size
                                == NumberOfBytesRead);
                    LrpcRequestMessage->Push.RpcStatus = RPC_S_OK;
                    }
                }


            INITMSG(LrpcRequestMessage,
                    ClientId,
                    CallbackId,
                    MessageId) ;

            NtStatus = NtReplyWaitReplyPort(Association->LpcServerPort,
                                          (PORT_MESSAGE *) LrpcRequestMessage);

            if (PushedResponse)
                {
                RpcpFarFree(PushedResponse);
                PushedResponse = 0;
                }
            }
        else
            {
            VALIDATE(LrpcRequestMessage->Rpc.RpcHeader.MessageType)
                {
                LRPC_MSG_REQUEST
                } END_VALIDATE;

            Status = LrpcMessageToRpcMessage(LrpcRequestMessage,
                                                                  Message);
            if (Status != RPC_S_OK)
                {
                LrpcRequestMessage->Fault.RpcHeader.MessageType =
                        LRPC_MSG_FAULT;
                LrpcRequestMessage->Fault.RpcStatus = LrpcMapRpcStatus(Status);
                LrpcRequestMessage->LpcHeader.u1.s1.DataLength =
                        sizeof(LRPC_FAULT_MESSAGE) - sizeof(PORT_MESSAGE);
                LrpcRequestMessage->LpcHeader.u1.s1.TotalLength =
                        sizeof(LRPC_FAULT_MESSAGE);

                INITMSG(LrpcRequestMessage,
                        ClientId,
                        CallbackId,
                        MessageId) ;

                NtStatus = NtReplyWaitReplyPort(Association->LpcServerPort,
                                        (PORT_MESSAGE *) LrpcRequestMessage);
                }
            else
                {

                LrpcReplyMessage = new LRPC_MESSAGE;

                if (LrpcReplyMessage != 0)
                    {
                    SBinding->GetSelectedTransferSyntaxAndDispatchTable(&Message->TransferSyntax,
                        &DispatchTableToUse);
                    Message->ProcNum =
                        LrpcRequestMessage->Rpc.RpcHeader.ProcedureNumber;

                    RuntimeInfo.Length = sizeof(RPC_RUNTIME_INFO) ;
                    RpcMessage = *Message ;
                    RpcMessage.ReservedForRuntime = &RuntimeInfo ;

                    if (ObjectUuidFlag != 0)
                        {
                        Status = SBinding->RpcInterface->
                                   DispatchToStubWithObject(
                                        &RpcMessage,
                                        &ObjectUuid,
                                        1,
                                        DispatchTableToUse,
                                        &ExceptionCode);
                        }
                    else
                        {
                        Status = SBinding->RpcInterface->
                                    DispatchToStub(
                                        &RpcMessage,
                                        1,
                                        DispatchTableToUse,
                                        &ExceptionCode);
                        }

                     *Message = RpcMessage ;

                    // Because we must send the reply and recieve the
                    // reply into the same message, we just copy the
                    // response into the LrpcRequestMessage

                    RpcpMemoryCopy(LrpcRequestMessage,
                                   LrpcReplyMessage,
                                   sizeof(LRPC_MESSAGE));
                    delete LrpcReplyMessage;
                    LrpcReplyMessage = 0;

                    }
                else
                    Status = RPC_S_OUT_OF_MEMORY;

                if (Status != RPC_S_OK)
                    {
                    VALIDATE(Status)
                        {
                        RPC_S_OUT_OF_MEMORY,
                        RPC_P_EXCEPTION_OCCURED,
                        RPC_S_PROCNUM_OUT_OF_RANGE
                        } END_VALIDATE;

                    if (Status == RPC_P_EXCEPTION_OCCURED)
                        {
                        Status = LrpcMapRpcStatus(ExceptionCode);
                        }

                    LrpcRequestMessage->Fault.RpcStatus = Status;
                    LrpcRequestMessage->LpcHeader.u1.s1.DataLength =
                            sizeof(LRPC_FAULT_MESSAGE) - sizeof(PORT_MESSAGE);
                    LrpcRequestMessage->LpcHeader.u1.s1.TotalLength =
                            sizeof(LRPC_FAULT_MESSAGE);
                    LrpcRequestMessage->Fault.RpcHeader.MessageType =
                            LRPC_MSG_FAULT;
                    }
                else
                    {
                    LrpcRequestMessage->LpcHeader.u1.s1.TotalLength =
                        sizeof(PORT_MESSAGE)
                        + LrpcRequestMessage->LpcHeader.u1.s1.DataLength;
                    LrpcRequestMessage->Rpc.RpcHeader.MessageType =
                        LRPC_MSG_RESPONSE;
                    }

                INITMSG(LrpcRequestMessage,
                        ClientId,
                        CallbackId,
                        MessageId) ;

                NtStatus = NtReplyWaitReplyPort(Association->LpcServerPort,
                                          (PORT_MESSAGE *) LrpcRequestMessage);
                }
            }

        if (NT_ERROR(NtStatus))
            {
            if (NtStatus == STATUS_NO_MEMORY)
                {
                Status = RPC_S_OUT_OF_MEMORY;
                }
            else if (NtStatus == STATUS_INSUFFICIENT_RESOURCES)
                {
                Status = RPC_S_OUT_OF_RESOURCES;
                }
            else
                {
                VALIDATE(NtStatus)
                    {
                    STATUS_INVALID_PORT_HANDLE,
                    STATUS_INVALID_HANDLE,
                    STATUS_INVALID_CID,
                    STATUS_PORT_DISCONNECTED,
                    STATUS_LPC_REPLY_LOST
                    } END_VALIDATE;

                Status = RPC_S_CALL_FAILED;
                }
            break;
            }
        }


    if (Status == RPC_S_OK)
        {
        Message->Handle = (RPC_BINDING_HANDLE) this;
        }

    ASSERT(LrpcReplyMessage == 0);
    LrpcReplyMessage = LrpcRequestMessage;
    LrpcRequestMessage = LrpcSavedMessage;

    return(Status);
}


void
LRPC_SCALL::FreeObject (
    )
{
    LRPC_SASSOCIATION *MyAssociation;

    ASSERT(pAsync) ;
    ASSERT(DispatchBuffer) ;

    if (DispatchBuffer != LrpcRequestMessage->Rpc.Buffer)
        {
        RpcpFarFree(DispatchBuffer);
        }

    FreeMessage(LrpcRequestMessage) ;

    SBinding->RpcInterface->EndCall(0, 1) ;

    MyAssociation = Association;

    MyAssociation->FreeSCall(this) ;
    MyAssociation->Address->DereferenceAssociation(MyAssociation);

    // Warning: The SCALL could have been nuked at this point.
    // DO NOT touch the SCALL after this
}


RPC_STATUS
LRPC_SCALL::AsyncSend (
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:

    Send an async reply. This request can either be partial or complete.
    If it is a complete request, we cleanup the SCall.

Arguments:

 Message - contains the request

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_SEND_INCOMPLETE - some data still needs to be sent.
                    Message->Buffer pointes to the remaining data, and
                    Message->BufferLength is the length of the remaining data.
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    NTSTATUS NtStatus ;
    BOOL fRetVal ;
    BOOL Shutup ;

    ASSERT(ReceiveEvent) ;

    if (AsyncStatus != RPC_S_OK)
        {
        if (PARTIAL(Message))
            {
            Status = AsyncStatus;
            }

        goto Cleanup;
        }

    FirstSend = 0;

    if (Flags & LRPC_NON_PIPE)
        {
        LrpcReplyMessage->Rpc.RpcHeader.MessageType = LRPC_MSG_RESPONSE;

        ASSERT(!IsClientAsync()) ;
        NtStatus = Association->ReplyMessage(LrpcReplyMessage);

        if (!NT_SUCCESS(NtStatus))
            {
            Status = RPC_S_OUT_OF_MEMORY ;
            }
        }
    else
        {
        Status = SendRequest(Message, &Shutup) ;
        }

    if (PARTIAL(Message))
        {
        if (Status == RPC_S_OK
            || Status == RPC_S_SEND_INCOMPLETE)
            {
            if ((pAsync->Flags & RPC_C_NOTIFY_ON_SEND_COMPLETE) && !Shutup)
                {
                CallMutex->Request() ;
                if (!IssueNotification(RpcSendComplete))
                    {
                    Status = RPC_S_OUT_OF_MEMORY ;
                    }
                CallMutex->Clear() ;
                }

            return Status;
            }
        }
    else
        {
        //
        // Non partial async sends will always succeed
        // if they fail, we will hide the error
        //
        Status = RPC_S_OK;
        }

Cleanup:
    //
    // on the server, the stub never calls FreeBuffer
    //
    RemoveReference();

    return Status;
}


RPC_STATUS
LRPC_SCALL::AsyncReceive (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned int Size
    )
/*++

Routine Description:

    On the server, this routine is only called when the stub needs
    more data to unmarshall the non pipe parameters, or when it needs
    pipe data.

Arguments:

 Message - contains information about the request
 Size - needed size

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/
{
    RPC_STATUS Status ;
    int Extra = IsExtraMessage(Message);

    ASSERT(ReceiveEvent) ;

    if (PARTIAL(Message) == 0)
        {
        return Receive(Message, Size);
        }

    if (Extra)
        {
        Status = Receive(Message, Size);
        //
        // don't need to check the status. If Receive failed, we are
        //  never going to access dispatch buffer anyway
        //
        DispatchBuffer = Message->Buffer ;

        return Status;
        }

    CallMutex->Request();

    Message->DataRepresentation = 0x00 | 0x10 | 0x0000;

    if (BufferComplete == 0
        && RcvBufferLength < Size)
        {
        if (NOTIFY(Message))
            {
            NeededLength = Size ;
            }
        CallMutex->Clear() ;

        return RPC_S_ASYNC_CALL_PENDING;
        }
    else
        {
        Status = GetCoalescedBuffer(Message, 0);
        }
    CallMutex->Clear();

    return Status ;
}


RPC_STATUS
LRPC_SCALL::SetAsyncHandle (
    IN PRPC_ASYNC_STATE pAsync
    )
/*++

Routine Description:

    Set the async handle corresponding this SCALL. This call is made
    by the stubs.

Arguments:

 pAsync - The async handle to association with this SCall

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/
{
    RPC_STATUS Status ;
    THREAD *Thread = RpcpGetThreadPointer();

    ASSERT(Thread);
    ASSERT(pAsync);

    Thread->fAsync = TRUE;

    if (DebugCell)
        {
        ASSERT(IsServerSideDebugInfoEnabled());
        DebugCell->CallFlags |= DBGCELL_ASYNC_CALL;
        }

    if (ReceiveEvent == 0)
        {
        Status = SetupCall();
        if (Status != RPC_S_OK)
            {
            return Status;
            }
        }

    if (LrpcAsyncReplyMessage == 0)
        {
        LrpcAsyncReplyMessage = AllocateMessage() ;
        if (LrpcAsyncReplyMessage == 0)
            {
            return RPC_S_OUT_OF_MEMORY ;
            }
        }

    LrpcReplyMessage = LrpcAsyncReplyMessage;
    LrpcReplyMessage->Rpc.RpcHeader.CallId = CallId ;

    INITMSG(LrpcReplyMessage,
        ClientId,
        CallbackId,
        MessageId) ;

    this->pAsync = pAsync ;
    return RPC_S_OK ;
}


RPC_STATUS
LRPC_SCALL::ProcessResponse (
    IN LRPC_MESSAGE **LrpcMessage
    )
/*++

Routine Description:

    A buffer has just arrived, process it. If some other buffer is already
    processing buffers, simply queue it and go away. Otherwise, does
    the processing ourselves.

Arguments:

 Message - Details on the arrived message
--*/
{
    RPC_MESSAGE Message ;
    RPC_STATUS Status ;

    switch ((*LrpcMessage)->Rpc.RpcHeader.MessageType)
        {
        case LRPC_SERVER_SEND_MORE:
            if (pAsync && (pAsync->Flags & RPC_C_NOTIFY_ON_SEND_COMPLETE))
                {
                if (!IssueNotification(RpcSendComplete))
                    {
                    AsyncStatus = RPC_S_OUT_OF_MEMORY ;

#if DBG
                    PrintToDebugger("RPC: IssueNotification failed\n") ;
#endif
                    //
                    // We are pretty much hosed here, but we'll try to
                    // queue notification anyway.
                    //
                    IssueNotification() ;
                    return RPC_S_OUT_OF_MEMORY ;
                    }
                }
            return RPC_S_OK ;

        case LRPC_MSG_CANCEL:
            InterlockedExchange(&CancelPending, 1);
            return RPC_S_OK;

        default:
            break;
        }

    CallMutex->Request() ;
    ASSERT(BufferComplete == 0);

    Message.RpcFlags = 0;
    Status = LrpcMessageToRpcMessage(
                                     *LrpcMessage,
                                     &Message) ;
    if (Status != RPC_S_OK)
        {
#if DBG
        PrintToDebugger("RPC: LrpcMessageToRpcMessage failed: %x\n", Status) ;
#endif

        AsyncStatus = Status ;
        IssueNotification() ;
        return Status ;
        }


    if (COMPLETE(&Message))
        {
        ASSERT(BufferComplete == 0);
        BufferComplete = 1;
        }

    if (Message.BufferLength)
        {
        RcvBufferLength += Message.BufferLength ;
        if (BufferQueue.PutOnQueue(Message.Buffer,
                                   Message.BufferLength))
          {
          AsyncStatus = Status = RPC_S_OUT_OF_MEMORY ;

#if DBG
          PrintToDebugger("RPC: PutOnQueue failed\n") ;
#endif
          }
        }

    if (IsSyncCall())
        {
        CallMutex->Clear() ;

        ReceiveEvent->Raise();
        }
    else
        {
        if (Status == RPC_S_OK
            && NeededLength > 0
            && RcvBufferLength >= NeededLength)
          {
          IssueNotification(RpcReceiveComplete);
          }
        CallMutex->Clear() ;
        }

    return Status ;
}


RPC_STATUS
LRPC_SCALL::GetCoalescedBuffer (
    IN PRPC_MESSAGE Message,
    IN BOOL BufferValid
    )
/*++

Routine Description:

    Remove buffers from the queue and coalesce them into a single buffer.

Arguments:

    Message - on return this will contain the coalesced buffer, Message->BufferLength
        gives us the length of the coalesced buffer.
    BufferValid - Tells us if Message->Buffer is valid on entry.

Return Value:

    RPC_S_OK - Function succeeded
    RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/
{
    void *NewBuffer, *Buffer ;
    char *Current ;
    unsigned int bufferlength ;
    unsigned int TotalLength ;
    LRPC_MESSAGE SendMore ;
    NTSTATUS NtStatus ;

    CallMutex->Request() ;

    ASSERT(RcvBufferLength);

    if (BufferValid)
        {
        TotalLength = RcvBufferLength + Message->BufferLength ;
        }
    else
        {
        TotalLength = RcvBufferLength ;
        }

    NewBuffer = RpcpFarAllocate(TotalLength) ;
    if (NewBuffer == 0)
        {
        CallMutex->Clear() ;
        return RPC_S_OUT_OF_MEMORY;
        }

    if (BufferValid)
        {
        RpcpMemoryCopy(NewBuffer, Message->Buffer, Message->BufferLength) ;
        Current = (char *) NewBuffer + Message->BufferLength ;
        }
    else
        {
        Current = (char *) NewBuffer;
        }

    while ((Buffer = BufferQueue.TakeOffQueue(&bufferlength)) != 0)
        {
        RpcpMemoryCopy(Current, Buffer, bufferlength) ;
        Current += bufferlength ;
        RpcpFarFree(Buffer);
        }

    if (BufferValid && Message->Buffer)
        {
        RpcpFarFree(Message->Buffer);

        //
        // Update the dispatch buffer
        //
        ASSERT(Message->ReservedForRuntime) ;
        ((PRPC_RUNTIME_INFO)Message->ReservedForRuntime)->OldBuffer = NewBuffer;

        if (Message->Buffer == DispatchBuffer)
            DispatchBuffer = NewBuffer;
        }

    Message->Buffer = NewBuffer ;
    Message->BufferLength = TotalLength ;

    RcvBufferLength = 0;

    if (BufferComplete)
        {
        Message->RpcFlags |= RPC_BUFFER_COMPLETE ;
        }
    else
        {
        if (Choked)
            {
            CallMutex->Clear() ;

            //
            // send a message to the client
            // to start sending data again
            //
            SendMore.Rpc.RpcHeader.MessageType = LRPC_CLIENT_SEND_MORE;
            SendMore.LpcHeader.u1.s1.DataLength =
                sizeof(LRPC_MESSAGE) - sizeof(PORT_MESSAGE);
            SendMore.LpcHeader.u2.ZeroInit = 0;
            SendMore.Rpc.RpcHeader.CallId = CallId ;

            NtStatus = SendDGReply(&SendMore) ;

            if (!NT_SUCCESS(NtStatus))
                {
                return RPC_S_CALL_FAILED ;
                }

            return RPC_S_OK;
            }
        }

    CallMutex->Clear() ;

    return RPC_S_OK ;
}


RPC_STATUS
LRPC_SCALL::ImpersonateClient (
    )
/*++

Routine Description:

    We will impersonate the client which made the remote procedure call.

--*/
{
    NTSTATUS NtStatus;
    RPC_STATUS Status;
    HANDLE hToken;
    DWORD LastError;

    Status = SetThreadSecurityContext((SECURITY_CONTEXT *) MAXUINT_PTR);
    if (RPC_S_OK != Status)
        {
        return Status;
        }

    if (SContext)
        {
        if (SContext->GetAnonymousFlag())
            {
            NtStatus = NtImpersonateAnonymousToken(NtCurrentThread());
            if (!NT_SUCCESS(NtStatus))
                {
                RpcpErrorAddRecord(EEInfoGCRuntime, 
                    RPC_S_ACCESS_DENIED,
                    EEInfoDLLRPC_SCALL__ImpersonateClient10,
                    (ULONG)NtStatus,
                    (ULONG)GetCurrentThreadId());

                ClearThreadSecurityContext();

                return RPC_S_ACCESS_DENIED;
                }
            }
        else if (SetThreadToken(NULL, SContext->hToken) == FALSE)
            {
            LastError = GetLastError();

            ClearThreadSecurityContext();
            
            if (LastError == ERROR_OUTOFMEMORY)
                {
                return (RPC_S_OUT_OF_MEMORY) ;
                }

            return RPC_S_ACCESS_DENIED;
            }
        }
    else
        {
        NtStatus = NtImpersonateClientOfPort(Association->LpcServerPort,
                                      (PORT_MESSAGE *) LrpcRequestMessage);

        if ((NtStatus == STATUS_INVALID_CID)
            || (NtStatus == STATUS_PORT_DISCONNECTED)
            || (NtStatus == STATUS_REPLY_MESSAGE_MISMATCH))
            {
            ClearThreadSecurityContext();
            return RPC_S_NO_CONTEXT_AVAILABLE;
            }

        if (!NT_SUCCESS(NtStatus))
            {
#if DBG
            PrintToDebugger("RPC : NtImpersonateClientOfPort : %lx\n",NtStatus);
#endif // DBG
            return RPC_S_ACCESS_DENIED;
            }
        }

    return(RPC_S_OK);
}


RPC_STATUS
LRPC_SCALL::RevertToSelf (
    )
/*++

Routine Description:

    This reverts a server thread back to itself after impersonating a client.
    We just check to see if the server thread is impersonating; this optimizes
    the common case.

--*/
{
    HANDLE ImpersonationToken = 0;
    NTSTATUS NtStatus;

    if (ClearThreadSecurityContext())
        {
        NtStatus = NtSetInformationThread(
                                          NtCurrentThread(),
                                          ThreadImpersonationToken,
                                          &ImpersonationToken,
                                          sizeof(HANDLE));
#if DBG
        if (!NT_SUCCESS(NtStatus))
            {
            PrintToDebugger("RPC : NtSetInformationThread : %lx\n", NtStatus);
            }
#endif // DBG

        if (!NT_SUCCESS(NtStatus))
            {
            if (NtStatus == STATUS_NO_MEMORY)
                {
                return RPC_S_OUT_OF_MEMORY;
                }
            return RPC_S_ACCESS_DENIED;
            }
        }

    return(RPC_S_OK);
}

RPC_STATUS
LRPC_SCALL::GetAuthorizationContext (
    IN BOOL ImpersonateOnReturn,
    IN AUTHZ_RESOURCE_MANAGER_HANDLE AuthzResourceManager,
    IN PLARGE_INTEGER pExpirationTime OPTIONAL,
    IN LUID Identifier,
    IN DWORD Flags,
    IN PVOID DynamicGroupArgs OPTIONAL,
    OUT PAUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext
    )
/*++

Routine Description:

    Gets an authorization context for the client that can be used
    with Authz functions. The resulting context is owned by the caller
    and must be freed by it.

Arguments:

    ImpersonateOnReturn - if TRUE, when we return, we should be impersonating.
    AuthzResourceManager - the resource manager to use (passed to Authz)
    pExpirationTime - the expiration time to use (passed to Authz)
    Identifier - the LUID (passed to Authz)
    Flags - Flags (passed to Authz)
    DynamicGroupArgs - parameter required by Authz (passed to Authz)
    pAuthzClientContext - the authorization context, returned on success. 
    Undefined on failure.

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    RPC_STATUS RevertStatus;
    BOOL fNeedToRevert = FALSE;
    HANDLE ImpersonationToken;
    BOOL Result;
    BOOL fImpersonating = FALSE;
    PAUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContextPlaceholder;

    ASSERT (AuthzResourceManager != NULL);

    if (ImpersonateOnReturn 
        || (SContext == NULL) 
        || (SContext->AuthzClientContext == NULL))
        {
        Status = LRPC_SCALL::ImpersonateClient();
        if (Status != RPC_S_OK)
            {
            RpcpErrorAddRecord(EEInfoGCRuntime, 
                Status, 
                EEInfoDLLRPC_SCALL__GetAuthorizationContext10,
                (ULONG)ImpersonateOnReturn,
                (ULONGLONG)SContext);

            return Status;
            }

        fImpersonating = TRUE;
        if (!ImpersonateOnReturn)
            {
            fNeedToRevert = TRUE;
            }
        }

    if (SContext && SContext->AuthzClientContext)
        {
        Status = DuplicateAuthzContext(SContext->AuthzClientContext,
            pExpirationTime, 
            Identifier,
            Flags,
            DynamicGroupArgs,
            pAuthzClientContext);
        }
    else
        {
        // either we don't have an scontext, or its 
        // AuthzClientContext is not set yet.
        // Get the token from the thread
        Result = OpenThreadToken(GetCurrentThread(),
            TOKEN_QUERY,
            TRUE,
            &ImpersonationToken);

        if (Result)
            {
            if (SContext)
                pAuthzClientContextPlaceholder = &SContext->AuthzClientContext;
            else
                pAuthzClientContextPlaceholder = NULL;

            Status = CreateAndSaveAuthzContextFromToken(pAuthzClientContextPlaceholder,
                ImpersonationToken,
                AuthzResourceManager,
                pExpirationTime,
                Identifier,
                Flags,
                DynamicGroupArgs,
                pAuthzClientContext);

            CloseHandle(ImpersonationToken);
            }
        else
            {
            Status = GetLastError();
            if (Status == ERROR_CANT_OPEN_ANONYMOUS)
                {
                Result = AuthzInitializeContextFromSidFn(
                    AUTHZ_SKIP_TOKEN_GROUPS,
                    (PSID)&AnonymousSid,
                    AuthzResourceManager,
                    pExpirationTime,
                    Identifier,
                    DynamicGroupArgs,
                    pAuthzClientContext);

                if (Result)
                    {
                    if (SContext)
                        {
                        if (InterlockedCompareExchangePointer((PVOID *)&SContext->AuthzClientContext,
                                pAuthzClientContext,
                                NULL) != NULL)
                            {
                            // somebody beat us to the punch - free the context we obtained
                            AuthzFreeContextFn(*pAuthzClientContext);
                            *pAuthzClientContext = SContext->AuthzClientContext;
                            }
                        }
                    // else
                    // the authz context is already loaded in pAuthzClientContext
                    Status = RPC_S_OK;
                    }
                else
                    {
                    Status = GetLastError();

                    RpcpErrorAddRecord(EEInfoGCAuthz, 
                        Status, 
                        EEInfoDLLRPC_SCALL__GetAuthorizationContext30,
                        GetCurrentThreadId(),
                        (ULONGLONG)AuthzResourceManager);
                    }

                }
            else
                {
                RpcpErrorAddRecord(EEInfoGCRuntime,
                    Status, 
                    EEInfoDLLRPC_SCALL__GetAuthorizationContext20,
                    GetCurrentThreadId());
                }
            }

        }

    // if caller didn't ask us to impersonate and we are,
    // or we if he did ask us, but we failed somewhere,
    // revert to self
    if (fNeedToRevert || (Status && fImpersonating))
        {
        RevertStatus = LRPC_SCALL::RevertToSelf();
        ASSERT(RevertStatus == RPC_S_OK);
        }

    return Status;
}


RPC_STATUS
LRPC_SCALL::IsClientLocal (
    OUT unsigned int * ClientLocalFlag
    )
/*++

Routine Description:

    A client using LRPC will always be local.

Arguments:

    ClientLocalFlag - Returns a flag which will always be set to a non-zero
        value indicating that the client is local.

--*/
{
    UNUSED(this);

    *ClientLocalFlag = 1;
    return(RPC_S_OK);
}


RPC_STATUS
LRPC_SCALL::ConvertToServerBinding (
    OUT RPC_BINDING_HANDLE __RPC_FAR * ServerBinding
    )
/*++

Routine Description:

    If possible, convert this call into a server binding, meaning a
    binding handle pointing back to the client.

Arguments:

    ServerBinding - Returns the server binding.

Return Value:

    RPC_S_OK - The server binding has successfully been created.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allocate
        a new binding handle.

--*/
{
    BOOL Boolean;
    RPC_STATUS Status;
    RPC_CHAR UuidString[37];
    RPC_CHAR * StringBinding;
    RPC_CHAR * NetworkAddress;
    DWORD NetworkAddressLength = MAX_COMPUTERNAME_LENGTH + 1;

    if (ObjectUuidFlag != 0)
        {
        ObjectUuid.ConvertToString(UuidString);
        UuidString[36] = '\0';
        }

    NetworkAddress = new RPC_CHAR[NetworkAddressLength];
    if (NetworkAddress == 0)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    Boolean = GetComputerNameW(
                               NetworkAddress,
                               &NetworkAddressLength);

    if (Boolean != TRUE)
        {
        Status =  GetLastError();

#if DBG
        PrintToDebugger("RPC : GetComputerNameW : %d\n", Status);
#endif // DBG

        if (Status == ERROR_NOT_ENOUGH_MEMORY)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            }
        else if ((Status == ERROR_NOT_ENOUGH_QUOTA)
                 || (Status == ERROR_NO_SYSTEM_RESOURCES))
            {
            Status = RPC_S_OUT_OF_RESOURCES;
            }
        else
            {
            ASSERT(0);
            Status = RPC_S_OUT_OF_MEMORY;
	    }

        delete NetworkAddress;

        return Status;
        }

    Status = RpcStringBindingComposeW(
                                      (ObjectUuidFlag != 0 ? UuidString : 0),
                                      RPC_STRING_LITERAL("ncalrpc"),
                                      NetworkAddress,
                                      0,
                                      0,
                                      &StringBinding);
    delete NetworkAddress;

    if (Status != RPC_S_OK)
        {
        return(Status);
        }

    Status = RpcBindingFromStringBindingW(
                                          StringBinding,
                                          ServerBinding);

    RpcStringFreeW(&StringBinding);
    return(Status);
}


void
LRPC_SCALL::InquireObjectUuid (
    OUT RPC_UUID * ObjectUuid
    )
/*++

Routine Description:

    This routine copies the object uuid from the call into the supplied
    ObjectUuid argument.

Arguments:

    ObjectUuid - Returns a copy of the object uuid passed by the client
        in the remote procedure call.

--*/
{
    if (ObjectUuidFlag == 0)
        {
        ObjectUuid->SetToNullUuid();
        }
    else
        {
        ObjectUuid->CopyUuid(&(this->ObjectUuid));
        }
}


RPC_STATUS
LRPC_SCALL::ToStringBinding (
    OUT RPC_CHAR ** StringBinding
    )
/*++

Routine Description:

    We need to convert this call into a string binding.  We will ask the
    address for a binding handle which we can then convert into a string
    binding.

Arguments:

    StringBinding - Returns the string binding for this call.

Return Value:


--*/
{
    RPC_STATUS Status;
    BINDING_HANDLE * BindingHandle
            = Association->Address->InquireBinding();

    if (BindingHandle == 0)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    Status = BindingHandle->ToStringBinding(StringBinding);
    BindingHandle->BindingFree();
    return(Status);
}


RPC_STATUS
LRPC_SCALL::GetAssociationContextCollection (
    OUT ContextCollection **CtxCollection
    )
{
    return Association->GetAssociationContextCollection(CtxCollection);
}


inline RPC_STATUS
LRPC_SCALL::LrpcMessageToRpcMessage (
    IN LRPC_MESSAGE  *  LrpcMessage,
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:

    We will convert from an LRPC_MESSAGE representation of a buffer (and
    its length) to an RPC_MESSAGE representation.

Arguments:

    RpcMessage - Returns the RPC_MESSAGE representation.

Return Value:

    RPC_S_OK - We have successfully converted the message.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to do the
        conversion.

--*/
{
    NTSTATUS NtStatus;
    SIZE_T NumberOfBytesRead;
    unsigned char MessageType = LrpcMessage->Rpc.RpcHeader.MessageType;
    RPC_STATUS Status = RPC_S_OK ;
    LRPC_MESSAGE ReplyMessage ;

    if(LrpcMessage->Rpc.RpcHeader.Flags & LRPC_BUFFER_IMMEDIATE)
        {
        Message->Buffer = LrpcMessage->Rpc.Buffer;
        ASSERT(LrpcMessage->LpcHeader.u1.s1.DataLength
                     >= sizeof(LRPC_RPC_HEADER));
        Message->BufferLength =
                (unsigned int) LrpcMessage->LpcHeader.u1.s1.DataLength
                                            - sizeof(LRPC_RPC_HEADER);
        Message->RpcFlags |= RPC_BUFFER_COMPLETE ;
        }
    else if (LrpcMessage->Rpc.RpcHeader.Flags & LRPC_BUFFER_REQUEST)
        {
        Message->BufferLength = LrpcMessage->Rpc.Request.DataEntries[0].Size;

        if (LrpcMessage->Rpc.RpcHeader.Flags & LRPC_BUFFER_PARTIAL)
            {
            CallMutex->Request() ;

            //
            // If the user ever specifies a Size > LRPC_THRESHOLD_SIZE
            // our performance will be bad.
            //
            if (RcvBufferLength >= LRPC_THRESHOLD_SIZE)
                {
                Choked = 1;
                }
            CallMutex->Clear() ;
            }
        else
            {
            Message->RpcFlags |= RPC_BUFFER_COMPLETE ;
            }

        Message->Buffer = RpcpFarAllocate(Message->BufferLength) ;
        if (Message->Buffer == 0)
            {
            Status = RPC_S_OUT_OF_MEMORY ;
            RpcpErrorAddRecord(EEInfoGCRuntime, 
                Status, 
                EEInfoDLLrpcMessageToRpcMessage10, 
                Message->BufferLength);
            }
        else
            {
            NtStatus = NtReadRequestData(Association->LpcServerPort,
                                         (PORT_MESSAGE *) LrpcMessage,
                                         0,
                                         Message->Buffer,
                                         Message->BufferLength,
                                         &NumberOfBytesRead) ;

            if (NT_ERROR(NtStatus))
                {
                RpcpFarFree(Message->Buffer) ;
                Message->Buffer = 0;

                Status = RPC_S_OUT_OF_MEMORY ;
                RpcpErrorAddRecord(EEInfoGCRuntime, 
                    Status, 
                    EEInfoDLLrpcMessageToRpcMessage20, 
                    NtStatus);
                }
            else
                {
                ASSERT(Message->BufferLength == NumberOfBytesRead) ;
                }
            }

        if (IsClientAsync())
            {
            COPYMSG((&ReplyMessage), LrpcMessage) ;
            ReplyMessage.Ack.MessageType = LRPC_MSG_ACK ;
            ReplyMessage.Ack.RpcStatus = Status;
            ReplyMessage.Ack.Shutup = (short) Choked ;
            ReplyMessage.LpcHeader.u1.s1.DataLength =
                    sizeof(LRPC_ACK_MESSAGE) - sizeof(PORT_MESSAGE) ;

           NtStatus = Association->ReplyMessage(&ReplyMessage);

           if (NT_ERROR(NtStatus))
                {
                RpcpFarFree(Message->Buffer);
                RpcpErrorAddRecord(EEInfoGCRuntime, 
                    RPC_S_OUT_OF_MEMORY, 
                    EEInfoDLLrpcMessageToRpcMessage30, 
                    NtStatus);
                return(RPC_S_OUT_OF_MEMORY);
                }
            }
      }
  else
      {
      ASSERT((LrpcMessage->Rpc.RpcHeader.Flags & LRPC_BUFFER_IMMEDIATE)
             || (LrpcMessage->Rpc.RpcHeader.Flags & LRPC_BUFFER_REQUEST));
      }

    return(Status);
}


RPC_STATUS
LRPC_SCALL::InquireAuthClient (
    OUT RPC_AUTHZ_HANDLE  * Privileges,
    OUT RPC_CHAR  *  * ServerPrincipalName, OPTIONAL
    OUT unsigned long  * AuthenticationLevel,
    OUT unsigned long  * AuthenticationService,
    OUT unsigned long  * AuthorizationService,
    IN  unsigned long    Flags
    )
/*++

Routine Description:

    Each protocol module must define this routine: it is used to obtain
    the authentication and authorization information about a client making
    the remote procedure call represented by this.

Arguments:

    Privileges - Returns a the privileges of the client.

    ServerPrincipalName - Returns the server principal name which the client
        specified.

    AuthenticationLevel - Returns the authentication level requested by
        the client.

    AuthenticationService - Returns the authentication service requested by
        the client.

    AuthorizationService - Returns the authorization service requested by
        the client.

Return Value:

    RPC_S_OK or RPC_S_* / Win32 error

--*/
{
    RPC_STATUS Status;

    if(ARGUMENT_PRESENT(Privileges))
        {
        *(RPC_CHAR **)Privileges = NULL;
        Status = Association->GetClientName(this, 
            NULL,       // ClientPrincipalNameBufferLength
            (RPC_CHAR **) Privileges);
        if (Status != RPC_S_OK)
            {
            return Status;
            }
        }

    if (ARGUMENT_PRESENT(ServerPrincipalName))
       {
       *ServerPrincipalName = NULL;
       }

    if(ARGUMENT_PRESENT(AuthenticationLevel))
       {
       *AuthenticationLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY ;
       }

    if(ARGUMENT_PRESENT(AuthenticationService))
        {
        *AuthenticationService = RPC_C_AUTHN_WINNT ;
        }

    if(ARGUMENT_PRESENT(AuthorizationService))
        {
        *AuthorizationService =   RPC_C_AUTHZ_NONE  ;
        }

    return(RPC_S_OK);
}

RPC_STATUS
LRPC_SCALL::InquireCallAttributes (
    IN OUT void *RpcCallAttributes
    )
/*++

Routine Description:

    Inquire the security context attributes for the LRPC client

Arguments:
    RpcCallAttributes - a pointer to 
        RPC_CALL_ATTRIBUTES_V1_W structure. The Version
        member must be initialized.

Return Value:

    RPC_S_OK or RPC_S_* / Win32 error. EEInfo will be returned.

--*/
{
    RPC_CALL_ATTRIBUTES_V1 *CallAttributes;
    RPC_STATUS Status = RPC_S_OK;

    CallAttributes = 
        (RPC_CALL_ATTRIBUTES_V1 *)RpcCallAttributes;

    CallAttributes->AuthenticationLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
    CallAttributes->AuthenticationService = RPC_C_AUTHN_WINNT;
    CallAttributes->NullSession = FALSE;

    if (CallAttributes->Flags & RPC_QUERY_CLIENT_PRINCIPAL_NAME)
        {
        Status = Association->GetClientName(this, 
            &CallAttributes->ClientPrincipalNameBufferLength,
            &CallAttributes->ClientPrincipalName);

        if ((Status != RPC_S_OK) && (Status != ERROR_MORE_DATA))
            {
            return Status;
            }
        }

    if (CallAttributes->Flags & RPC_QUERY_SERVER_PRINCIPAL_NAME)
        {
        CallAttributes->ServerPrincipalNameBufferLength = 0;
        }

    return Status;
}

LRPC_SBINDING *
LRPC_SCALL::LookupBinding (
   IN unsigned short PresentContextId
   )
/*++
Function Name:LookupBinding

Parameters:

Description:

Returns:

--*/
{
    LRPC_SBINDING *CurBinding;
    DictionaryCursor cursor;

    Association->Bindings.Reset(cursor);
    while ((CurBinding = Association->Bindings.Next(cursor)))
        {
        if (CurBinding->GetPresentationContext() == PresentContextId)
            {
            return CurBinding;
            }
        }

    return NULL;
}

LRPC_SCONTEXT::LRPC_SCONTEXT (
    IN HANDLE MyToken,
    IN LUID *UserLuid,
    IN LRPC_SASSOCIATION *MyAssociation,
    IN BOOL fDefaultLogonId,
    IN BOOL fAnonymousToken
    )
{
    hToken = MyToken;
    ClientName = NULL;
    RefCount = 1;
    ClearDeletedFlag();
    Association = MyAssociation;
    AuthzClientContext = NULL;
    if (fAnonymousToken)
        SetAnonymousFlag();
    else
        ClearAnonymousFlag();
    if (fAnonymousToken)
        {
        ASSERT(fDefaultLogonId == FALSE);
        ASSERT(UserLuid == NULL);
        }
    else
        {
        ASSERT(fAnonymousToken == FALSE);
        if (fDefaultLogonId)
            SetDefaultLogonIdFlag();
        else
            ClearDefaultLogonIdFlag();
        FastCopyLUID(&ClientLuid, UserLuid);
        }
}

LRPC_SCONTEXT::~LRPC_SCONTEXT (
    void
    )
{
    if (hToken)
        {
        CloseHandle(hToken);
        }
    RpcpFarFree(ClientName);

    if (AuthzClientContext)
        {
        AuthzFreeContextFn(AuthzClientContext);
        AuthzClientContext = NULL;
        }

    if (GetServerSideOnlyFlag())
        {
        // if this is server side only context, remove us
        // from the garbage collection count
        InterlockedDecrement(&PeriodicGarbageCollectItems);
        }
}

RPC_STATUS
LRPC_SCONTEXT::GetUserName (
    IN OUT ULONG *ClientPrincipalNameBufferLength OPTIONAL,
    OUT RPC_CHAR **UserName,
    IN HANDLE hUserToken OPTIONAL
    )
/*++

Routine Description:

    Gets the user name for the given context.

Arguments:

    ClientPrincipalNameBufferLength - if present, *UserName must
        point to a caller supplied buffer, which if big enough,
        will be filled with the client principal name. If not present,
        *UserName must be NULL.
    UserName - see ClientPrincipalNameBufferLength
    hUserToken - if present, the user name for the given token will
        be retrieved instead of the user name for the token inside
        the LRPC_SCONTEXT

Return Value:

    RPC_S_OK for success, or RPC_S_* / Win32 error code for error.

--*/
{
    TOKEN_USER *pUser;
    RPC_STATUS Status;
    RPC_CHAR *ClientPrincipalName;
    ULONG ClientPrincipalNameLength;    // in bytes, including NULL terminator

    if (ClientName == 0)
        {
        if (GetAnonymousFlag() == 0)
            {
            if (hUserToken == NULL)
                {
                ASSERT(hToken != NULL);
                hUserToken = hToken;
                }

            pUser = GetSID(hUserToken);
            if (pUser == 0)
                {
                return RPC_S_OUT_OF_MEMORY;
                }

            Status = LookupUser((SID *)pUser->User.Sid, &ClientPrincipalName);
            delete pUser;
            }
        else
            {
            Status = LookupUser((SID *)&AnonymousSid, &ClientPrincipalName);
            }

        if (Status != RPC_S_OK)
            {
            return Status;
            }

        if (InterlockedCompareExchangePointer((PVOID *)&ClientName, ClientPrincipalName, NULL) != NULL)
            {
            // somebody beat us to the punch. Free the allocated string
            delete ClientPrincipalName;
            }
        }

    // at this stage, ClientName must contain the client principal name
    ASSERT(ClientName);

    // See where our caller wants us to put it
    if (ARGUMENT_PRESENT(ClientPrincipalNameBufferLength))
        {
        // in the future, we may think of caching the length to avoid
        // computing it every time
        ClientPrincipalNameLength = (RpcpStringLength(ClientName) + 1) * sizeof(RPC_CHAR);

        // if there is enough space in the data, copy it to user buffer
        if (ClientPrincipalNameLength <= *ClientPrincipalNameBufferLength)
            {
            RpcpMemoryCopy(*UserName,
                ClientName,
                ClientPrincipalNameLength);
            Status = RPC_S_OK;
            }
        else
            {
            Status = ERROR_MORE_DATA;
            }

        *ClientPrincipalNameBufferLength = ClientPrincipalNameLength;

        return Status;
        }
    else
        {
        ASSERT(*UserName == NULL);
        *UserName = ClientName;
        }

    return RPC_S_OK;
}

TOKEN_USER *
LRPC_SCONTEXT::GetSID (
    IN HANDLE hToken
    )
{
    char *Buf = NULL;
    ULONG Bufflen = 64 ;
    ULONG Length;

    Buf = new char[Bufflen];
    if (Buf == 0)
        {
        return NULL;
        }

    while (1)
        {
        if (GetTokenInformation(hToken,
                            TokenUser, Buf, Bufflen,
                            &Length) == FALSE)
            {
            if (Length > Bufflen)
                {
                Bufflen = Length ;
                delete Buf;

                Buf = new char[Bufflen];
                if (Buf == 0)
                    {
                    return NULL;
                    }
                continue;
                }
            else
                {
#if DBG
                PrintToDebugger("LRPC: GetTokenInformation failed\n") ;
#endif
                return NULL;
                }
            }
        break;
        }

    return (TOKEN_USER *) Buf;
}

RPC_STATUS
LRPC_SCONTEXT::LookupUser (
    IN SID *pSid,
    OUT RPC_CHAR **UserName
    )
{
    unsigned long UserLength = USER_NAME_LEN  ;
    unsigned long OldDomainLen, OldUserLen;
    unsigned long DomainLen = DOMAIN_NAME_LEN ;
    RPC_CHAR *DomainName = NULL, *MyUserName = NULL;
    SID_NAME_USE Name ;
    RPC_STATUS Status = RPC_S_OK ;

    MyUserName = new RPC_CHAR[UserLength];
    if (MyUserName == 0)
        {
        Status = RPC_S_OUT_OF_MEMORY ;
        goto Cleanup ;
        }

    DomainLen += UserLength ;
    DomainName = new RPC_CHAR [DomainLen];
    if (DomainName == 0)
        {
        Status = RPC_S_OUT_OF_MEMORY ;
        goto Cleanup ;
        }

    OldDomainLen = DomainLen ;
    OldUserLen = UserLength ;

    while (1)
        {
        if (LookupAccountSidW(NULL, pSid,
                          MyUserName, &UserLength,
                          DomainName, &DomainLen, &Name) == FALSE)
            {
            if ((UserLength > OldUserLen) || (DomainLen > OldDomainLen))
                {
                if (UserLength > OldUserLen)
                    {
                    OldUserLen = UserLength ;
                    delete MyUserName;

                    MyUserName = new RPC_CHAR[UserLength];
                    if (MyUserName == 0)
                        {
                        Status = RPC_S_OUT_OF_MEMORY ;
                        goto Cleanup ;
                        }
                    }

                if (DomainLen > OldDomainLen)
                    {
                    DomainLen += UserLength;
                    OldDomainLen = DomainLen;

                    delete DomainName;

                    DomainName = new RPC_CHAR[DomainLen];
                    if (DomainName == 0)
                        {
                        Status = RPC_S_OUT_OF_MEMORY ;
                        goto Cleanup ;
                        }
                    }
                continue;
                }
            else
                {
#if DBG
                PrintToDebugger("LRPC: LookupAccountSid failed\n");
#endif
                Status = RPC_S_UNKNOWN_PRINCIPAL;
                goto Cleanup ;
                }
            }
        break;
        }

    RpcpStringConcatenate(DomainName, RPC_CONST_STRING("\\")) ;
    RpcpStringConcatenate(DomainName, MyUserName) ;

    delete MyUserName;
    *UserName = DomainName ;
    ASSERT(Status == RPC_S_OK);

Cleanup:
    if (Status)
        {
        if (MyUserName) 
            delete MyUserName;
        if (DomainName) 
            delete DomainName;

        return Status ;
        }

    return RPC_S_OK;
}

LRPC_ADDRESS *LrpcAddressList = NULL;


RPC_ADDRESS *
LrpcCreateRpcAddress (
    )
/*++

Routine Description:

    We just to create a new LRPC_ADDRESS.  This routine is a proxy for the
    new constructor to isolate the other modules.

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    RPC_ADDRESS * RpcAddress;

    RpcAddress = new LRPC_ADDRESS(&Status);
    if (Status != RPC_S_OK)
        {
        return(0);
        }
    return(RpcAddress);
}

/*
 This private API was requested by KumarP from the LSA group on 04/05/2000.
 Here's his justification:

 I am adding a new auditing feature to LSA that will allow any local process 
 to make an rpc call to LSA and generate an arbitrary audit. To be able to 
 make this call, the clients will first issue one call to get an audit-context 
 handle from LSA. LSA will maintain a list of handles till the client 
 explicitly closes the audit-context. 

 The reason I would like to have this API is to track which processes have 
 opened audit-contexts. This will help in situations where there is a 
 rogue/mal-functioning process that opens up a large number of audit-contexts. 
 In this case, I should be able to break LSA into debugger and dump the context 
 list and know which process has opened which handles. This may optionally 
 allow me to prevent certain processes from calling this API (though currently 
 there is no such requirement).

 */
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqLocalClientPID (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned long *Pid
    )
{
    LRPC_SCALL * Call;
    HANDLE LocalPid;

    InitializeIfNecessary();

    if (Binding == NULL)
        {
        Call = (LRPC_SCALL *) RpcpGetThreadContext();
        if (Call == NULL)
            return RPC_S_NO_CALL_ACTIVE;
        }
    else
        {
        Call = (LRPC_SCALL *) Binding;
        }

    if (Call->InvalidHandle(LRPC_SCALL_TYPE))
        return(RPC_S_INVALID_BINDING);

    LocalPid = Call->InqLocalClientPID();

    *Pid = HandleToUlong(LocalPid);

    return RPC_S_OK;
}

const SID AnonymousSid = { 1, 1, SECURITY_NT_AUTHORITY, SECURITY_ANONYMOUS_LOGON_RID};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\lpcclnt.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    lpcclnt.cxx

Abstract:

    Implementation of the RPC on LPC protocol engine for the client.

Revision History:
    Mazhar Mohammed: Code fork from spcclnt.cxx, 08/02/95

    Tony Chan: Added Singled Security Model, 12/15/95

    Mazhar Mohammed  Merged WMSG and LRPC into a single protocol 05-06-96
    Mazhar Mohammed  Added Pipes Support
    Mazhar Mohammed  Added support for Async RPC 08-14-96
    Kamen Moutafov      (KamenM)    Jan-2000            Support for multiple transfer syntaxes
    Kamen Moutafov      (KamenM) Dec 99 - Feb 2000      Support for cell debugging stuff
    Kamen Moutafov      (KamenM)    Mar-2000            Support for extended error info
--*/

#include <precomp.hxx>
#include <rpcqos.h>
#include <queue.hxx>
#include <lpcpack.hxx>
#include <hndlsvr.hxx>
#include <lpcsvr.hxx>
#include <ProtBind.hxx>
#include <lpcclnt.hxx>
#include <epmap.h>
#include <CharConv.hxx>

const SECURITY_IMPERSONATION_LEVEL RpcToNtImp[] =
{
    // RPC_C_IMP_LEVEL_DEFAULT
    SecurityImpersonation,

    // RPC_C_IMP_LEVEL_ANONYMOUS
    SecurityAnonymous,

    // RPC_C_IMP_LEVEL_IDENTIFY
    SecurityIdentification,

    //RPC_C_IMP_LEVEL_IMPERSONATE
    SecurityImpersonation,

    //RPC_C_IMP_LEVEL_DELEGATE
    SecurityDelegation
};

const unsigned long NtToRpcImp[] =
{
    //SecurityAnonymous,
    RPC_C_IMP_LEVEL_ANONYMOUS,

    //SecurityIdentification,
    RPC_C_IMP_LEVEL_IDENTIFY,

    // SecurityImpersonation,
    RPC_C_IMP_LEVEL_IMPERSONATE,

    //SecurityDelegation
    RPC_C_IMP_LEVEL_DELEGATE
};

SECURITY_IMPERSONATION_LEVEL
MapRpcToNtImp (
    IN unsigned long ImpersonationType
   )
{
    if (ImpersonationType <= RPC_C_IMP_LEVEL_DELEGATE)
        {
        return RpcToNtImp[ImpersonationType];
        }

    ASSERT(0) ;
    return SecurityImpersonation ;
}

unsigned long
MapNtToRpcImp (
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    )
{
    if (ImpersonationLevel <= SecurityDelegation)
        {
        return NtToRpcImp[ImpersonationLevel];
        }

    ASSERT(0);
    return RPC_C_IMP_LEVEL_IMPERSONATE;
}

RPC_STATUS
InitializeLrpcIfNecessary(
   ) ;

RPC_STATUS
InitializeAsyncLrpcIfNecessary (
    )
/*++

Routine Description:

    We need to perform the required initialization for Async RPC to
    work. If we currently don't have a listening thread. We need to
    add a note in the docs that if the app ever plans to start a
    listening thread on the client (ie: become a server),
    it should do it before it makes the first Async RPC call. This is
    not a requirement, it is just an effeciency consideration.

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/
{
    RPC_STATUS Status;

    Status = InitializeLrpcIfNecessary();
    if (Status != RPC_S_OK)
        {
#if DBG
        PrintToDebugger("LRPC: InitializeLrpcIfNecessary failed: %x\n", Status) ;
#endif
        return RPC_S_OUT_OF_MEMORY ;
        }

    return GlobalLrpcServer->InitializeAsync();
}


LRPC_BINDING_HANDLE::LRPC_BINDING_HANDLE (
    OUT RPC_STATUS * Status
    ) : BINDING_HANDLE (Status),
    BindingReferenceCount(1)
/*++

Routine Description:

    We just allocate an LRPC_BINDING_HANDLE and initialize things so that
    we can use it later.

Arguments:

    Status - Returns the result of initializing the binding mutex.

--*/
{
    BindingMutex.SetSpinCount(4000);
    ObjectType = LRPC_BINDING_HANDLE_TYPE;
    CurrentAssociation = 0;
    DceBinding = 0;
    AuthInfoInitialized = 0;
    StaticTokenHandle = 0;
    EffectiveOnly = TRUE;
}


LRPC_BINDING_HANDLE::~LRPC_BINDING_HANDLE (
    )
/*++

--*/
{
    LRPC_CASSOCIATION *Association;
    DictionaryCursor cursor;

    if (SecAssociation.Size() != 0)
        {
        SecAssociation.Reset(cursor);
        while ((Association  = SecAssociation.Next(cursor)) != 0)
            {
            if (Association != 0)
                {
                // take away from the bindinghandle dictionary
                RemoveAssociation(Association);
                // take away from the global dict
                Association->RemoveBindingHandleReference();
                }
            }
        }

    delete DceBinding;

    if (StaticTokenHandle)
        {
        CloseHandle(StaticTokenHandle);
        }
}

RPC_STATUS
LRPC_BINDING_HANDLE::NegotiateTransferSyntax (
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:

Arguments:

    Message - Supplies the length of the buffer required, and returns the
        new buffer.

Return Value:


--*/
{
    LRPC_CCALL * CCall;
    RPC_STATUS Status;
    int  RetryCount = 0;
    static long  nInitialized = -1 ;
    LRPC_CASSOCIATION *Association ;
    DictionaryCursor cursor;

    for (;;)
        {
        for (;;)
            {
            Status = AllocateCCall(&CCall, (RPC_CLIENT_INTERFACE  *)
                                Message->RpcInterfaceInformation,
                                Message);
            if (Status != RPC_S_SERVER_UNAVAILABLE)
                {
                break;
                }
            if (!fDynamicEndpoint)
                {
                break;
                }

            // If we reach here, it means that we are iterating through the
            // list of endpoints obtained from the endpoint mapper.

            BindingMutex.Request() ;
            if (BindingReferenceCount.GetInteger() == 1)
                {
                if (SecAssociation.Size() != 0)
                    {
                    DceBinding = CurrentAssociation->DuplicateDceBinding();
                    if(DceBinding == 0)
                        {
                        BindingMutex.Clear() ;

                        return(RPC_S_OUT_OF_MEMORY);
                        }
                    CurrentAssociation = 0;
                    DceBinding->MaybeMakePartiallyBound(
                        (PRPC_CLIENT_INTERFACE)Message->RpcInterfaceInformation,
                        InqPointerAtObjectUuid());

                    if ( *InquireEpLookupHandle() != 0 )
                        {
                        EpFreeLookupHandle(*InquireEpLookupHandle());
                        *InquireEpLookupHandle() = 0;
                        }

                    // remove references
                    SecAssociation.Reset(cursor);
                    while((Association  = SecAssociation.Next(cursor)) != 0)
                        {
                        if (Association != 0)
                            {
                            // in the AssociationDict all DceBinding should be the same
                            // may be we can take out this line. or remove ref
                            // on the first Association
                            RemoveAssociation(Association);
                            Association->RemoveReference();
                            }
                        }
                    }
                }

            BindingMutex.Clear() ;

            RetryCount ++;
            if (RetryCount > 2)
                {
                break;
                }

            RpcpPurgeEEInfo();
            }

        if (Status == RPC_S_OK)
            {
            break;
            }

        if (InqComTimeout() != RPC_C_BINDING_INFINITE_TIMEOUT)
            {
            return(Status);
            }

        if ((Status != RPC_S_SERVER_UNAVAILABLE)
            && (Status != RPC_S_SERVER_TOO_BUSY))
            {
            return(Status);
            }
        }

    Message->TransferSyntax = CCall->Binding->GetTransferSyntaxId();
    Message->Handle = CCall;
    return RPC_S_OK;
}


RPC_STATUS
LRPC_BINDING_HANDLE::GetBuffer (
    IN OUT PRPC_MESSAGE Message,
    IN UUID *ObjectUuid
    )
/*++

Routine Description:

Arguments:

    Message - Supplies the length of the buffer required, and returns the
        new buffer.

Return Value:


--*/
{
    ASSERT(!"We should never be here - the binding handle cannot allocate a buffer");
    return RPC_S_INTERNAL_ERROR;
}


RPC_STATUS
LRPC_BINDING_HANDLE::BindingCopy (
    OUT BINDING_HANDLE *  * DestinationBinding,
    IN unsigned int MaintainContext
    )
/*++

Routine Description:

    We will make a copy of this binding handle in one of two ways, depending
    on whether on not this binding handle has an association.

Arguments:

    DestinationBinding - Returns a copy of this binding handle.

    MaintainContext - Supplies a flag that indicates whether or not context
        is being maintained over this binding handle.  A non-zero value
        indicates that context is being maintained.

Return Value:

    RPC_S_OK - This binding handle has been successfully copied.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to make a copy
        of this binding handle.

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    LRPC_BINDING_HANDLE * NewBindingHandle;
    CLIENT_AUTH_INFO * AuthInfo;
    LRPC_CASSOCIATION *SecAssoc;
    DictionaryCursor cursor;
    int Key;

    UNUSED(MaintainContext);

    NewBindingHandle = new LRPC_BINDING_HANDLE(&Status);
    if (NewBindingHandle == 0)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    if (Status != RPC_S_OK)
        {
        delete NewBindingHandle;
        return(Status);
        }

    NewBindingHandle->fDynamicEndpoint = fDynamicEndpoint;

    if ((AuthInfo = InquireAuthInformation()) != 0)
        {
        Status = NewBindingHandle->SetAuthInformation(
                                AuthInfo->ServerPrincipalName,
                                AuthInfo->AuthenticationLevel,
                                AuthInfo->AuthenticationService,
                                NULL,
                                AuthInfo->AuthorizationService,
                                0,
                                AuthInfo->ImpersonationType,
                                AuthInfo->IdentityTracking,
                                AuthInfo->Capabilities
                                );

        if (Status != RPC_S_OK)
            {
            ASSERT (Status == RPC_S_OUT_OF_MEMORY);
            delete NewBindingHandle;
            return(RPC_S_OUT_OF_MEMORY);
            }
        }


    BindingMutex.Request() ;
    if (SecAssociation.Size() == 0)
        {
        NewBindingHandle->DceBinding = DceBinding->DuplicateDceBinding();
        if (NewBindingHandle->DceBinding == 0)
            {
            BindingMutex.Clear() ;
            delete NewBindingHandle;
            return(RPC_S_OUT_OF_MEMORY);
            }
        }
    else
        {
        // copy all sec associations
        SecAssociation.Reset(cursor);
        while((SecAssoc = SecAssociation.Next(cursor)) != 0)
            {
            Key = NewBindingHandle->AddAssociation(SecAssoc);
            if (Key == -1)
                {
                BindingMutex.Clear() ;
                delete NewBindingHandle;
                return (RPC_S_OUT_OF_MEMORY);
                }
            SecAssoc->DuplicateAssociation();
            }

        // since the CurrentAssociation is in the SecAssociation dictionary,
        // it should have already been copied. Just assign it
        NewBindingHandle->CurrentAssociation = CurrentAssociation;
        }
    BindingMutex.Clear() ;

    *DestinationBinding = (BINDING_HANDLE *) NewBindingHandle;
    return(RPC_S_OK);
}


RPC_STATUS
LRPC_BINDING_HANDLE::BindingFree (
    )
/*++

Routine Description:

    When the application is done with a binding handle, this routine will
    get called.

Return Value:

    RPC_S_OK - This operation always succeeds.

--*/
{
    int LocalRefCount;

    LocalRefCount = BindingReferenceCount.Decrement();

    if (LocalRefCount == 0)
        {
        delete this;
        }

    return(RPC_S_OK);
}


RPC_STATUS
LRPC_BINDING_HANDLE::PrepareBindingHandle (
    IN TRANS_INFO  * TransportInformation,
    IN DCE_BINDING * DceBinding
    )
/*++

Routine Description:

    This method will be called just before a new binding handle is returned
    to the user.  We just stack the binding information so that we can use
    it later when the first remote procedure call is made.  At that time,
    we will actually bind to the interface.

Arguments:

    TransportInformation - Unused.

    DceBinding - Supplies the binding information for this binding handle.

--*/
{
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    RPC_STATUS Status;

    UNUSED(TransportInformation);

    if (DceBinding->InqNetworkOptions() != 0 &&
        DceBinding->InqNetworkOptions()[0] != 0)
        {
        Status = I_RpcParseSecurity(DceBinding->InqNetworkOptions(),
                           &SecurityQualityOfService);
        if (Status != RPC_S_OK)
            {
            ASSERT(Status == RPC_S_INVALID_NETWORK_OPTIONS);
            return(Status);
            }

        Status = SetAuthInformation(NULL,
                                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                    RPC_C_AUTHN_WINNT,
                                    NULL,
                                    NULL,
                                    0,
                                    MapNtToRpcImp(SecurityQualityOfService.ImpersonationLevel),
                                    SecurityQualityOfService.ContextTrackingMode,
                                    RPC_C_QOS_CAPABILITIES_DEFAULT,
                                    TRUE);
        if (Status != RPC_S_OK)
            {
            return Status;
            }
        EffectiveOnly = SecurityQualityOfService.EffectiveOnly;
        }

    this->DceBinding = DceBinding;
    fDynamicEndpoint = DceBinding->IsNullEndpoint();

    return RPC_S_OK;
}


RPC_STATUS
LRPC_BINDING_HANDLE::ToStringBinding (
    OUT RPC_CHAR  *  * StringBinding
    )
/*++

Routine Description:

    We need to convert the binding handle into a string binding.  If the
    handle is unbound, use the DceBinding directly, otherwise, get it from
    the association.

Arguments:

    StringBinding - Returns the string representation of the binding
        handle.

Return Value:

    RPC_S_OK - The binding handle has successfully been converted into a
        string binding.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allocate the
        string.

--*/
{
    if (CurrentAssociation == 0)
        {
        *StringBinding = DceBinding->StringBindingCompose(
                InqPointerAtObjectUuid());
        }
    else
        {
        *StringBinding = CurrentAssociation->StringBindingCompose(
                InqPointerAtObjectUuid());
        }

    if (*StringBinding == 0)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    return(RPC_S_OK);
}


RPC_STATUS
LRPC_BINDING_HANDLE::ResolveBinding (
    IN RPC_CLIENT_INTERFACE  * RpcClientInterface
    )
/*++

Routine Description:

    We need to try and resolve the endpoint for this binding handle
    if necessary (the binding handle is partially-bound).  If there is
    isn't a association allocated, call the binding management routines
    to do it.

Arguments:

    RpcClientInterface - Supplies interface information to be used
        in resolving the endpoint.

Return Value:

    RPC_S_OK - This binding handle is a full resolved binding handle.

    RPC_S_NO_ENDPOINT_FOUND - The endpoint can not be resolved.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to resolve
        the endpoint.

    EPT_S_NOT_REGISTERED  - There are no more endpoints to be found
        for the specified combination of interface, network address,
        and lookup handle.

    EPT_S_CANT_PERFORM_OP - The operation failed due to misc. error e.g.
        unable to bind to the EpMapper.

--*/
{
    RPC_STATUS Status;

    if (CurrentAssociation == 0)
        {
        BindingMutex.Request();
        Status = DceBinding->ResolveEndpointIfNecessary(
                RpcClientInterface, 
                InqPointerAtObjectUuid(),
                InquireEpLookupHandle(), 
                FALSE, 
                InqComTimeout(), 
                INFINITE,    // CallTimeout
                NULL        // AuthInfo
                );
        BindingMutex.Clear();
        return(Status);
        }

    return(RPC_S_OK);
}


RPC_STATUS
LRPC_BINDING_HANDLE::BindingReset (
    )
/*++

Routine Description:

    This routine will set the endpoint of this binding handle to zero,
    if possible.  The binding handle will become partially bound as a
    result.  If a remote procedure call has been made on this binding
    handle, it will fail as well.

Return Value:

    RPC_S_OK - The binding handle has successfully been made partially
        bound.

    RPC_S_WRONG_KIND_OF_BINDING - The binding handle currently has remote
        procedure calls active.

--*/
{
    LRPC_CASSOCIATION *Association ;
    DictionaryCursor cursor;

    BindingMutex.Request() ;
    if (CurrentAssociation != 0)
        {
        if (BindingReferenceCount.GetInteger() != 1)
            {
            BindingMutex.Clear() ;
            return(RPC_S_WRONG_KIND_OF_BINDING);
            }

        DceBinding = CurrentAssociation->DuplicateDceBinding();
        if(DceBinding == 0)
            {
            BindingMutex.Clear() ;
            return(RPC_S_OUT_OF_MEMORY);
            }
        CurrentAssociation = 0;
        SecAssociation.Reset(cursor);
        while((Association  = SecAssociation.Next(cursor)) != 0)
            {
            RemoveAssociation(Association);
            Association->RemoveBindingHandleReference();
            }
        }

    fDynamicEndpoint = TRUE;
    DceBinding->MakePartiallyBound();

    if (*InquireEpLookupHandle() != 0)
        {
        EpFreeLookupHandle(*InquireEpLookupHandle());
        *InquireEpLookupHandle() = 0;
        }

    BindingMutex.Clear() ;
    return(RPC_S_OK);
}


void
LRPC_BINDING_HANDLE::FreeCCall (
    IN LRPC_CCALL * CCall
    )
/*++

Routine Description:

    This routine will get called to notify this binding handle that a remote
    procedure call on this binding handle has completed.

Arguments:

    CCall - Supplies the remote procedure call which has completed.

--*/
{
    int LocalRefCount;

    CCall->InqAssociation()->FreeCCall(CCall);

    // do not touch the association beyond this. It could be freed.

    LocalRefCount = BindingReferenceCount.Decrement();

    if (LocalRefCount == 0)
        {
        delete this;
        }
}


RPC_STATUS
LRPC_BINDING_HANDLE::AllocateCCall (
    OUT LRPC_CCALL ** CCall,
    IN PRPC_CLIENT_INTERFACE RpcInterfaceInformation,
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:

    This method will allocate an LRPC_CCALL which has been bound to the
    interface specified by the interface information.  First, we have got
    to see if we have an association for this binding.  If not, we need
    to find or create one.  Before we can find or create an association,
    we need to resolve the endpoint if necessary.  Next we need to see
    if there is already an LRPC_CCALL allocated for this interface and
    thread.  Otherwise, we need to ask the association to allocate a
    LRPC_CCALL for us.

Arguments:

    CCall - Returns the allocated LRPC_CCALL which has been bound to
        the interface specified by the rpc interface information.

    RpcInterfaceInformation - Supplies information describing the
        interface to which we wish to bind.

Return Value:


--*/
{
    RPC_STATUS Status;
    RPC_CHAR ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD ComputerNameLength = MAX_COMPUTERNAME_LENGTH + 1;
    BOOL Boolean;
    BOOL FoundSameAuthInfo = FALSE;
    LRPC_CASSOCIATION * Association;
    LRPC_CASSOCIATION *MyAssociation = NULL;
    DictionaryCursor cursor;
    int LocalRefCount;

    BindingMutex.Request();

    if (AuthInfoInitialized == 0)
        {
        Status = SetAuthInformation(NULL,
                                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                    RPC_C_AUTHN_WINNT,
                                    NULL,
                                    NULL,
                                    0,
                                    RPC_C_IMP_LEVEL_IMPERSONATE,
                                    RPC_C_QOS_IDENTITY_DYNAMIC,
                                    RPC_C_QOS_CAPABILITIES_DEFAULT,
                                    TRUE);
        if (Status != RPC_S_OK)
            {
            BindingMutex.Clear();
            return Status;
            }
        }

    // First we need to check if there is already a call active for this
    // thread and interface.  To make the common case quicker, we will check
    // to see if there are any calls in the dictionary first.

    if (RecursiveCalls.Size() != 0)
        {
        RecursiveCalls.Reset(cursor);
        while ((*CCall = RecursiveCalls.Next(cursor)) != 0)
            {
            if ((*CCall)->IsThisMyActiveCall(
                                             GetThreadIdentifier(),
                                             RpcInterfaceInformation) != 0)
                {
                BindingMutex.Clear();
                return(RPC_S_OK);
                }
            }
        }

    // To start off, see if the binding handle points to an association
    // yet.  If not, we have got to get one.

    if (CurrentAssociation == 0)
        {
        // Before we even bother to find or create an association, lets
        // check to make sure that we are on the same machine as the server.

        ASSERT(DceBinding->InqNetworkAddress() != 0);

        if (DceBinding->InqNetworkAddress()[0] != 0)
            {
            Boolean = GetComputerName(ComputerName, &ComputerNameLength);

#if DBG

            if (Boolean != TRUE)
                {
                PrintToDebugger("RPC : GetComputerName : %d\n",
                                GetLastError());
                }

#endif // DBG

            ASSERT(Boolean == TRUE);

            if (RpcpStringCompareInt(DceBinding->InqNetworkAddress(),
                        ComputerName) != 0)
                {
                BindingMutex.Clear();
                RpcpErrorAddRecord(EEInfoGCRuntime, 
                    RPC_S_SERVER_UNAVAILABLE,
                    EEInfoDLLRPC_BINDING_HANDLE__AllocateCCall10,
                    DceBinding->InqNetworkAddress(),
                    ComputerName);
                return(RPC_S_SERVER_UNAVAILABLE);
                }
            }

        if (DceBinding->IsNullEndpoint())
            {
            LrpcMutexRequest();
            MyAssociation = FindOrCreateLrpcAssociation(
                                           DceBinding,
                                           InquireAuthInformation(),
                                           RpcInterfaceInformation);
            LrpcMutexClear();

            // don't do anything in the both success and failure
            // case. In failure case we'll try full endpoint resolution
            // In success case, we leave FoundSameAuthInfo to be FALSE,
            // and the code below will figure out we have something
            // in MyAssociation and will do the housekeeping tasks
            // associated with finding an association
            ASSERT(DceBinding);
            }

        if (!MyAssociation)
            {
            Status = DceBinding->ResolveEndpointIfNecessary(
                    RpcInterfaceInformation, 
                    InqPointerAtObjectUuid(),
                    InquireEpLookupHandle(), 
                    FALSE, 
                    InqComTimeout(), 
                    INFINITE,    // CallTimeout
                    NULL        // AuthInfo
                    );
            if (Status != RPC_S_OK)
                {
                BindingMutex.Clear();

                RpcpErrorAddRecord(EEInfoGCRuntime, 
                    Status,
                    EEInfoDLLRPC_BINDING_HANDLE__AllocateCCall20,
                    RpcInterfaceInformation->InterfaceId.SyntaxGUID.Data1);
                return(Status);
                }
            }
        }
    else
        {
        if (CurrentAssociation->IsSupportedAuthInfo(
            InquireAuthInformation()) == TRUE)
            {
            MyAssociation = CurrentAssociation ;
            FoundSameAuthInfo = TRUE;
            }
        else
            {
            SecAssociation.Reset(cursor);
            while ((Association = SecAssociation.Next(cursor)) != 0)
                {
                if(Association->IsSupportedAuthInfo(
                                 InquireAuthInformation()) == TRUE)
                    {
                    MyAssociation = Association ;
                    FoundSameAuthInfo = TRUE;
                    break;
                    }
                }
            }
        }

    if (FoundSameAuthInfo == FALSE)
        {
        // we have some association in the dictionary, check for security level
        if (DceBinding == 0)
            {
            SecAssociation.Reset(cursor);
            Association  = SecAssociation.Next(cursor);
            // it will get deleted when Assoc goes
            DceBinding = Association->DuplicateDceBinding();
            if(DceBinding == 0)
                {
                BindingMutex.Clear() ;

                return(RPC_S_OUT_OF_MEMORY);
                }
            }

        // if we still haven't found the association
        // (may do so during the interface based search for
        // an endpoint).
        if (!MyAssociation)
            {
            LrpcMutexRequest();
            MyAssociation = FindOrCreateLrpcAssociation(
                                           DceBinding,
                                           InquireAuthInformation(),
                                           NULL);
            LrpcMutexClear();
            }

        if (CurrentAssociation == 0)
            {
            CurrentAssociation = MyAssociation ;
            }

        if (MyAssociation == 0)
            {
            BindingMutex.Clear();
            return(RPC_S_OUT_OF_MEMORY);
            }

        // The association now owns the DceBinding.
        DceBinding = 0;

        if((AddAssociation(MyAssociation)) == -1)
            {
            delete MyAssociation;
            if (CurrentAssociation == MyAssociation)
                {
                CurrentAssociation = 0;
                }

            BindingMutex.Clear();
            return (RPC_S_OUT_OF_MEMORY);
            }
        }

    BindingReferenceCount.Increment();

    BindingMutex.Clear();

    ASSERT(MyAssociation) ;

    Status = MyAssociation->AllocateCCall(
                                          this,
                                          CCall,
                                          Message,
                                          RpcInterfaceInformation);

    if (Status != RPC_S_OK)
        {
        LocalRefCount = BindingReferenceCount.Decrement();
        ASSERT(LocalRefCount != 0);
        }

    return(Status);
}

RPC_STATUS
LRPC_BINDING_HANDLE::SetAuthInformation (
    IN RPC_CHAR  * ServerPrincipalName, OPTIONAL
    IN unsigned long AuthenticationLevel,
    IN unsigned long AuthenticationService,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthorizationService,
    IN SECURITY_CREDENTIALS * Credentials,
    IN unsigned long ImpersonationType,
    IN unsigned long IdentityTracking,
    IN unsigned long Capabilities,
    IN BOOL bAcquireNewCredentials,
    IN ULONG AdditionalTransportCredentialsType, OPTIONAL
    IN void *AdditionalCredentials OPTIONAL
    )
/*++

Routine Description:

    We set the authentication and authorization information in this binding
    handle.

Arguments:

    ServerPrincipalName - Optionally supplies the server principal name.

    AuthenticationLevel - Supplies the authentication level to use.

    AuthenticationService - Supplies the authentication service to use.

    AuthIdentity - Optionally supplies the security context to use.

    AuthorizationService - Supplies the authorization service to use.

    AdditionalTransportCredentialsType  - the type of additional credentials
        supplied in AdditionalCredentials. Not supported for LRPC.

    AdditionalCredentials - pointer to additional credentials if any. Not supported
        for LRPC.

Return Value:

    RPC_S_OK - The supplied authentication and authorization information has
    been set in the binding handle.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete the
    operation.

    RPC_S_UNKNOWN_AUTHN_SERVICE - The specified authentication service is
    not supported.

    RPC_S_UNKNOWN_AUTHN_LEVEL - The specified authentication level is
    not supported.

    RPC_S_INVALID_AUTH_IDENTITY - The specified security context (supplied
    by the auth identity argument) is invalid.

    RPC_S_UNKNOWN_AUTHZ_SERVICE - The specified authorization service is
    not supported.

--*/
{

    RPC_CHAR * NewString ;
    RPC_STATUS Status;
    SEC_WINNT_AUTH_IDENTITY *ntssp;
    HANDLE hToken;
    unsigned long MappedAuthenticationLevel;


    if ((AdditionalTransportCredentialsType != 0) || (AdditionalCredentials != NULL))
        return RPC_S_CANNOT_SUPPORT;

    if (AuthenticationLevel == RPC_C_AUTHN_LEVEL_DEFAULT)
        {
        AuthenticationLevel = RPC_C_AUTHN_LEVEL_CONNECT;
        }

    MappedAuthenticationLevel = MapAuthenticationLevel(AuthenticationLevel);

    if (AuthenticationLevel > RPC_C_AUTHN_LEVEL_PKT_PRIVACY)
        {
        return(RPC_S_UNKNOWN_AUTHN_LEVEL);
        }

    ClientAuthInfo.AuthenticationLevel = MappedAuthenticationLevel;
    ClientAuthInfo.AuthenticationService = AuthenticationService;
    ClientAuthInfo.AuthIdentity = AuthIdentity;
    ClientAuthInfo.AuthorizationService = AuthorizationService;
    ClientAuthInfo.IdentityTracking = IdentityTracking;
    ClientAuthInfo.Capabilities = Capabilities;

    if (MappedAuthenticationLevel == RPC_C_AUTHN_LEVEL_NONE)
        {
        ClientAuthInfo.ImpersonationType = RPC_C_IMP_LEVEL_ANONYMOUS;
        }
    else
        {
        ClientAuthInfo.ImpersonationType = ImpersonationType;
        }

    if (AuthenticationService == RPC_C_AUTHN_NONE)
        {
        AuthInfoInitialized = 0;

        return (RPC_S_OK);
        }

    if(AuthenticationService != RPC_C_AUTHN_WINNT)
        {
        return(RPC_S_UNKNOWN_AUTHN_SERVICE) ;
        }

    if (ARGUMENT_PRESENT(ServerPrincipalName) && *ServerPrincipalName)
        {
        NewString = DuplicateString(ServerPrincipalName);
        if ( NewString == 0 )
            {
            return(RPC_S_OUT_OF_MEMORY);
            }

        BindingMutex.Request();
        if ( ClientAuthInfo.ServerPrincipalName != 0 )
            {
            delete ClientAuthInfo.ServerPrincipalName;
            }
        ClientAuthInfo.ServerPrincipalName = NewString;
        BindingMutex.Clear();
        }

    if (IdentityTracking == RPC_C_QOS_IDENTITY_STATIC)
        {
        if (StaticTokenHandle)
            {
            CloseHandle(StaticTokenHandle);
            }

        if (OpenThreadToken (GetCurrentThread(),
                         TOKEN_IMPERSONATE | TOKEN_QUERY,
                         TRUE,
                         &StaticTokenHandle) == FALSE)
            {
            StaticTokenHandle = 0;
            }

        Status = ReAcquireCredentialsIfNecessary();
        if (Status != RPC_S_OK)
            {
            return Status;
            }
        }

    AuthInfoInitialized = 1;

    return(RPC_S_OK);
}


unsigned long
LRPC_BINDING_HANDLE::MapAuthenticationLevel (
    IN unsigned long AuthenticationLevel
    )
/*++

Routine Description:

    The connection oriented protocol module supports all authentication
    levels except for RPC_C_AUTHN_LEVEL_CALL.  We just need to map it
    to RPC_C_AUTHN_LEVEL_PKT.

--*/
{
    UNUSED(this);

    if (AuthenticationLevel >= RPC_C_AUTHN_LEVEL_CONNECT)
        {
        return(RPC_C_AUTHN_LEVEL_PKT_PRIVACY);
        }

    return(AuthenticationLevel);
}


inline int
LRPC_BINDING_HANDLE::AddAssociation (
    IN LRPC_CASSOCIATION * Association
    )
/*++

Routine Description:

    This supplied remote procedure call needs to be put into the dictionary
    of association

--*/
{
    int err;
    BindingMutex.Request() ;
    err = SecAssociation.Insert(Association) ;
    BindingMutex.Clear() ;

    return(err);

}


inline void
LRPC_BINDING_HANDLE::RemoveAssociation (
    IN LRPC_CASSOCIATION * Association
    )
/*++

Routine Description:

    Remove Association from BindingHandle, can keep a Key for Association because
    1 association may be added to many BINDINGHANDLE::SecAssociationDict, 1 key per
    Association won't do the job. Therefore, we delete Association this way.
    Remember, there will be 5 Association in the SecAssoc the most, 1 per SecurityLevel

--*/
{
    BindingMutex.Request() ;
    SecAssociation.DeleteItemByBruteForce(Association);
    BindingMutex.Clear() ;
}

RPC_STATUS
LRPC_BINDING_HANDLE::SetTransportOption( IN unsigned long option,
                                    IN ULONG_PTR     optionValue )
{
    if (option == RPC_C_OPT_DONT_LINGER)
        {
        if (CurrentAssociation == NULL)
            return RPC_S_WRONG_KIND_OF_BINDING;

        if (CurrentAssociation->GetDontLingerState())
            return RPC_S_WRONG_KIND_OF_BINDING;

        CurrentAssociation->SetDontLingerState((BOOL)optionValue);

        return RPC_S_OK;
        }
    else
        {
        return BINDING_HANDLE::SetTransportOption(option, optionValue);
        }
}

RPC_STATUS
LRPC_BINDING_HANDLE::InqTransportOption( IN  unsigned long option,
                                    OUT ULONG_PTR   * pOptionValue )
{
    if (option == RPC_C_OPT_DONT_LINGER)
        {
        if (CurrentAssociation == NULL)
            return RPC_S_WRONG_KIND_OF_BINDING;

        *pOptionValue = CurrentAssociation->GetDontLingerState();

        return RPC_S_OK;
        }
    else
        {
        return BINDING_HANDLE::InqTransportOption(option, pOptionValue);
        }
}


MTSyntaxBinding *CreateLrpcBinding(
        IN RPC_SYNTAX_IDENTIFIER *InterfaceId,
        IN TRANSFER_SYNTAX_STUB_INFO *TransferSyntaxInfo,
        IN int CapabilitiesBitmap
        )
{
    return new LRPC_BINDING(InterfaceId, 
        TransferSyntaxInfo,
        CapabilitiesBitmap);
}



// protected by the LrpcMutex
LRPC_CASSOCIATION_DICT * LrpcAssociationDict = 0;
long LrpcLingeredAssociations = 0;
unsigned long LrpcDestroyedAssociations = 0;
ULARGE_INTEGER LastDestroyedAssociationsBatchTimestamp;


LRPC_CASSOCIATION::LRPC_CASSOCIATION (
    IN DCE_BINDING * DceBinding,
    IN CLIENT_AUTH_INFO *pClientAuthInfo,
    USHORT MySequenceNumber,
    OUT RPC_STATUS * Status
    ) : AssociationMutex(Status, 4000),
        AssocAuthInfo(pClientAuthInfo, Status)
/*++

Routine Description:

    This association will be initialized, so that it is ready to be
    placed into the dictionary of associations.

Arguments:

    DceBinding - Supplies the DCE_BINDING which will name this association.

    Status - Returns the result of creating the association mutex.

--*/
{
    ObjectType = LRPC_CASSOCIATION_TYPE;
    this->DceBinding = DceBinding;
    LpcClientPort = 0;
    LpcReceivePort = 0;
    BackConnectionCreated = 0;
    CallIdCounter = 1;
    SequenceNumber = MySequenceNumber;
    Linger.fAssociationLingered = FALSE;
    DeletedContextCount = 0;
    BindingHandleReferenceCount = 1;
    RefCount.SetInteger(2);
    CachedCCall = NULL;
    DontLinger = FALSE;
    LastSecContextTrimmingTimestamp = 0;

    if (*Status == RPC_S_OK)
        {
        CachedCCall = new LRPC_CCALL(Status);
        if (*Status == RPC_S_OK)
            {
            if (CachedCCall == 0)
                {
                *Status = RPC_S_OUT_OF_MEMORY ;
                return;
                }

            CachedCCall->SetAssociation(this);
            CachedCCallFlag = 1;
            }
        }
}


LRPC_CASSOCIATION::~LRPC_CASSOCIATION (
   )
{
    LRPC_BINDING * Binding;
    LRPC_CCALL * CCall ;
    LRPC_CCONTEXT *SecurityContext;
    DictionaryCursor cursor;

    if (DceBinding != 0)
        {
        delete DceBinding;
        }

    Bindings.Reset(cursor);
    while ((Binding = Bindings.RemoveNext(cursor)) != 0)
        {
        Binding->RemoveReference();
        }

    SecurityContextDict.Reset(cursor);
    while (SecurityContext = SecurityContextDict.RemoveNext(cursor))
        {
        delete SecurityContext;
        }

    // delete all CCalls
    ActiveCCalls.Reset(cursor) ;
    while ((CCall = ActiveCCalls.Next(cursor, TRUE)) != 0)
        {
        delete CCall ;
        }

    if (CachedCCallFlag != 0)
        {
        delete CachedCCall;
        }

    FreeCCalls.Reset(cursor);
    while ((CCall = FreeCCalls.Next(cursor)) != 0)
        {
        delete CCall;
        }

    CloseLpcClientPort();
}



RPC_STATUS
LRPC_CASSOCIATION::CreateBackConnection (
    IN LRPC_BINDING_HANDLE *BindingHandle
    )
/*++

Routine Description:

 Ask the server to create a back connection to us. Used in
 conjuction with Async RPC.

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/

{
#if defined(BUILD_WOW6432)
    char LrpcMessageBuffer[sizeof(LRPC_BIND_BACK_MESSAGE) + 8];
    char LrpcReplyBuffer[sizeof(LRPC_MESSAGE) + 8];
    LRPC_BIND_BACK_MESSAGE *LrpcMessagePtr = (LRPC_BIND_BACK_MESSAGE *) AlignPtr8(LrpcMessageBuffer);
    LRPC_MESSAGE *LrpcReplyPtr = (LRPC_MESSAGE *)AlignPtr8(LrpcReplyBuffer);
#else
    LRPC_BIND_BACK_MESSAGE LrpcMessageBuffer;
    LRPC_MESSAGE LrpcReplyBuffer;
    LRPC_BIND_BACK_MESSAGE *LrpcMessagePtr = &LrpcMessageBuffer;
    LRPC_MESSAGE *LrpcReplyPtr = &LrpcReplyBuffer;
#endif
    NTSTATUS NtStatus ;
    RPC_STATUS Status = RPC_S_OK;

    if (BackConnectionCreated == 0)
        {
        Status = AssociationMutex.RequestSafe() ;
        if (Status)
            return Status;

        if (BackConnectionCreated)
            {
            AssociationMutex.Clear() ;
            return RPC_S_OK ;
            }

        if (LpcClientPort == 0)
            {
            Status = OpenLpcPort(BindingHandle, TRUE) ;
            if (Status != RPC_S_OK)
                {
                AssociationMutex.Clear() ;

                RpcpErrorAddRecord(EEInfoGCRuntime, 
                    Status,
                    EEInfoDLLRPC_CASSOCIATION__CreateBackConnection10,
                    InqEndpoint());

                return Status ;
                }
            }
        else
            {
            LrpcGetEndpoint((RPC_CHAR *) LrpcMessagePtr->szPortName) ;

            LrpcMessagePtr->LpcHeader.u1.s1.DataLength =
                    sizeof(LRPC_BIND_BACK_MESSAGE) - sizeof(PORT_MESSAGE);
            LrpcMessagePtr->LpcHeader.u1.s1.TotalLength =
                    sizeof(LRPC_BIND_BACK_MESSAGE);
            LrpcMessagePtr->LpcHeader.u2.ZeroInit = 0;
            LrpcMessagePtr->MessageType = LRPC_MSG_BIND_BACK;

            DWORD Key;
            LPC_KEY *LpcKey = (LPC_KEY *) &Key;

            LpcKey->SeqNumber = SequenceNumber;
            LpcKey->AssocKey = (unsigned short) AssociationDictKey;

            LrpcMessagePtr->AssocKey = Key;


            NtStatus = NtRequestWaitReplyPort(LpcClientPort,
                             (PORT_MESSAGE *) LrpcMessagePtr,
                             (PORT_MESSAGE *) LrpcReplyPtr) ;

            if (NT_ERROR(NtStatus))
                {
                AssociationMutex.Clear() ;

                if (NtStatus == STATUS_NO_MEMORY)
                    {
                    Status = RPC_S_OUT_OF_MEMORY;
                    }
                else if (NtStatus == STATUS_INSUFFICIENT_RESOURCES)
                    {
                    Status = RPC_S_OUT_OF_RESOURCES;
                    }
                else
                    {
                    VALIDATE(NtStatus)
                        {
                        STATUS_INVALID_PORT_HANDLE,
                        STATUS_INVALID_HANDLE,
                        STATUS_PORT_DISCONNECTED,
                        STATUS_LPC_REPLY_LOST
                        } END_VALIDATE;
                    Status = RPC_S_SERVER_UNAVAILABLE;
                    }

                RpcpErrorAddRecord(EEInfoGCLPC, 
                    Status,
                    EEInfoDLLRPC_CASSOCIATION__CreateBackConnection20,
                    NtStatus);

                return (Status);
                }

            ASSERT(LrpcReplyPtr->Ack.MessageType == LRPC_MSG_ACK) ;
            if (LrpcReplyPtr->Ack.RpcStatus != RPC_S_OK)
                {
                AssociationMutex.Clear() ;

                RpcpErrorAddRecord(EEInfoGCRuntime, 
                    LrpcReplyPtr->Ack.RpcStatus,
                    EEInfoDLLRPC_CASSOCIATION__CreateBackConnection30);

                return LrpcReplyPtr->Ack.RpcStatus;
                }
            }

        BackConnectionCreated = 1 ;
        AssociationMutex.Clear() ;
        }

    return Status ;
}

void 
LRPC_CASSOCIATION::RemoveBindingHandleReference (
    void
    )
{
    BOOL fWillLinger = FALSE;
    LRPC_CASSOCIATION *CurrentAssociation;
    LRPC_CASSOCIATION *OldestAssociation = NULL;
    DWORD OldestAssociationTimestamp;
    DictionaryCursor cursor;
    BOOL fEnableGarbageCollection = FALSE;

    LrpcMutexRequest();

    LogEvent(SU_CASSOC, EV_DEC, this, 0, BindingHandleReferenceCount, 1, 1);
    BindingHandleReferenceCount --;
    if (BindingHandleReferenceCount == 0)
        {
        if (LpcClientPort && IsGarbageCollectionAvailable() && (!DontLinger))
            {
            fWillLinger = PrepareForLoopbackTicklingIfNecessary();
            if (fWillLinger)
                {
                if (LrpcLingeredAssociations >= MaxLrpcLingeredAssociations)
                    {
                    OldestAssociationTimestamp = ~(DWORD)0;

                    // need to walk the dictionary and clean up the oldest item
                    LrpcAssociationDict->Reset(cursor);
                    while ((CurrentAssociation = LrpcAssociationDict->Next(cursor)) != 0)
                        {
                        if (CurrentAssociation->Linger.fAssociationLingered)
                            {
                            // yes, if the tick count wraps around, we may make a
                            // suboptimal decision and destroy a newer lingering
                            // association. That's ok - it will be a slight perf hit once
                            // every ~47 days - it won't be a bug
                            if (OldestAssociationTimestamp > CurrentAssociation->Linger.Timestamp)
                                {
                                OldestAssociation = CurrentAssociation;
                                }
                            }
                        }

                    // there must be an oldest association here
                    ASSERT(OldestAssociation);
                    LrpcAssociationDict->Delete(OldestAssociation->AssociationDictKey);
                    OldestAssociation->AssociationDictKey = -1;

                    // no need to update LrpcLingeredAssociations - we removed one,
                    // but we add one, so the balance is the same
                    }
                else
                    {
                    LrpcLingeredAssociations ++;
                    ASSERT(LrpcLingeredAssociations <= MaxLrpcLingeredAssociations);
                    }

                Linger.Timestamp = GetTickCount() + gThreadTimeout;
                Linger.fAssociationLingered = TRUE;
                }
            }

        if (!fWillLinger)
            {
            LrpcDestroyedAssociations ++;
            fEnableGarbageCollection = CheckIfGCShouldBeTurnedOn(
                LrpcDestroyedAssociations, 
                NumberOfLrpcDestroyedAssociationsToSample,
                DestroyedLrpcAssociationBatchThreshold,
                &LastDestroyedAssociationsBatchTimestamp
                );

            Delete();
            }
        }

    LrpcMutexClear();

    if (fEnableGarbageCollection)
        {
        // ignore the return value - we'll make a best effort to
        // create the thread, but if there's no memory, that's
        // still ok as the garbage collection thread only
        // provides better perf in this case
        (void) CreateGarbageCollectionThread();
        }

    if (OldestAssociation)
        {
#if defined (RPC_GC_AUDIT)
        int Diff;

        Diff = (int)(GetTickCount() - OldestAssociation->Linger.Timestamp);
        DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) LRPC association sync gc'ed %d ms after expire\n",
            GetCurrentProcessId(), GetCurrentProcessId(), Diff);
#endif
        OldestAssociation->Delete();
        }

    if (fWillLinger)
        {
        fWillLinger = GarbageCollectionNeeded(TRUE, gThreadTimeout);
        if (fWillLinger == FALSE)
            {
            // uh-oh - we couldn't register for garbage collection - probably
            // extremely low on memory. If nobody has picked us up in the meantime, 
            // delete this association. Otherwise, let it go - somebody is using
            // it and we don't need to worry about gc'ing it. We also need to guard
            // against the gc thread trying to do Delete on this also. If it does
            // so, it will set the AssociationDictKey to -1 before it releases 
            // the mutex - therefore we can check for this. A gc thread cannot
            // completely kill the object as we will hold one reference on it
            LrpcMutexRequest();
            if (AssociationDictKey != -1)
                {
                LrpcLingeredAssociations --;
                ASSERT(LrpcLingeredAssociations >= 0);
                if (Linger.fAssociationLingered)
                    Delete();
                }
            LrpcMutexClear();
            }
#if defined (RPC_GC_AUDIT)
        else
            {
            DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) LRPC association lingered %X\n",
                GetCurrentProcessId(), GetCurrentProcessId(), this);
            }
#endif
        }

    // removing the reference should be the last thing to do. Otherwise we're racing
    // with a gc thread which may kill the this pointer underneath us
    REFERENCED_OBJECT::RemoveReference();
}

void LRPC_CASSOCIATION::Delete(void)
{
    int MyCount;

    if (SetDeletedFlag())
        {
        if (AssociationDictKey != -1)
            {
            LrpcMutexRequest();

            LrpcAssociationDict->Delete(AssociationDictKey);

            LrpcMutexClear();
            }

        REFERENCED_OBJECT::RemoveReference();
        }

}

BOOL
LRPC_CASSOCIATION::DoesBindingForInterfaceExist (
    IN PRPC_CLIENT_INTERFACE RpcInterfaceInformation
    )
/*++

Routine Description:

    Checks if an association supports a binding for this interface.

Arguments:

    RpcInterfaceInformation - Supplies the interface information for
        which we are looking for an osf binding object.

Return Value:

    FALSE if it doesn't. Non-zero if it does.

--*/
{
    LRPC_BINDING *Binding;
    DictionaryCursor cursor;
    BOOL fRetVal = FALSE;
    BOOL fMutexTaken;

    fMutexTaken = AssociationMutex.TryRequest();
    if (!fMutexTaken)
        return FALSE;

    Bindings.Reset(cursor);
    while ((Binding = Bindings.Next(cursor)) != 0)
        {
        // if we have a binding on the same interface,
        // return TRUE
        if (RpcpMemoryCompare(Binding->GetInterfaceId(), 
            &RpcInterfaceInformation->InterfaceId,
            sizeof(RPC_SYNTAX_IDENTIFIER)) == 0)
            {
            fRetVal = TRUE;
            break;
            }
        }
    AssociationMutex.Clear();

    return fRetVal;
}


RPC_STATUS
LRPC_CASSOCIATION::AllocateCCall (
    IN LRPC_BINDING_HANDLE *BindingHandle,
    OUT LRPC_CCALL ** CCall,
    IN OUT PRPC_MESSAGE Message,
    IN PRPC_CLIENT_INTERFACE RpcInterfaceInformation
    )
/*++

Routine Description:

    This method will allocate an LRPC_CCALL which has been bound to the
    interface specified by the interface information.  This means that
    first we need to find the presentation context corresponding to the
    requested interface.

Arguments:

    CCall - Returns the allocated LRPC_CCALL which has been bound to
        the interface specified by the rpc interface information.

    RpcInterfaceInformation - Supplies information describing the
        interface to which we wish to bind.

Return Value:


--*/
{
    LRPC_BINDING *SelectedBinding;
    int RetryCount;
    RPC_STATUS Status;
    LRPC_CCONTEXT *SecurityContext;
    BOOL fAlterSecurityContextNeeded = FALSE;
    BOOL fAlterContextNeeded = FALSE;
    LRPC_CCONTEXT *CurrentSecurityContext = NULL;
    BOOL fUpdateCredentials = FALSE;
    LUID CurrentModifiedId;
    DictionaryCursor cursor;
    LRPC_BINDING *BindingsForThisInterface[MaximumNumberOfTransferSyntaxes];
    int NumberOfBindingsAvailable;
    BOOL BindingCreated[MaximumNumberOfTransferSyntaxes];
    int i;
    int PreferredTransferSyntax;
    int MatchingTransferSyntax;
    BOOL IsBackConnectionNeeded = IsNonsyncMessage(Message);
    RPC_STATUS CaptureStatus;
    LRPC_BINDING *CurrentBinding;
    BOOL fAssociationAborted = FALSE;
    ULONG EffectiveIdentityTracking;

    if (IsBackConnectionNeeded)
        {
        CLIENT_AUTH_INFO * AuthInfo;

        AuthInfo = BindingHandle->InquireAuthInformation();

        ASSERT(AuthInfo);

        if (AuthInfo->IdentityTracking == RPC_C_QOS_IDENTITY_DYNAMIC)
            {
            CaptureStatus = CaptureModifiedId(&CurrentModifiedId);
            fUpdateCredentials = TRUE;
            }
        }

    Status = AssociationMutex.RequestSafe();
    if (Status)
        return Status;

    if (fUpdateCredentials)
        {
        BindingHandle->UpdateCredentials((CaptureStatus != RPC_S_OK), &CurrentModifiedId);
        }

    RetryCount = 0;

    EffectiveIdentityTracking = BindingHandle->GetIdentityTracking();

    do
        {
        //
        // We need to look at two things here. Presentation context
        // and security context (in the async dynamic case only). If both match
        // then we can allocate the call. Otherwise, we need to first bind
        // in order to negotiate the interface/presentation context.
        //
        if (IsBackConnectionNeeded
            || EffectiveIdentityTracking == RPC_C_QOS_IDENTITY_STATIC)
            {
            SecurityContextDict.Reset(cursor);

            while (SecurityContext = SecurityContextDict.Next(cursor))
                {
                if (BindingHandle->CompareCredentials(SecurityContext))
                    {
                    CurrentSecurityContext = SecurityContext;
                    CurrentSecurityContext->AddReference();
                    CurrentSecurityContext->UpdateTimestamp();
                    break;
                    }
                }

            if (SecurityContext == 0)
                {
                fAlterSecurityContextNeeded = TRUE;
                }
            }

        Status = MTSyntaxBinding::FindOrCreateBinding(RpcInterfaceInformation,
            Message, &Bindings, CreateLrpcBinding, &NumberOfBindingsAvailable,
            (MTSyntaxBinding **)BindingsForThisInterface, BindingCreated);

        if (Status != RPC_S_OK)
            {
            goto Cleanup;
            }

        PreferredTransferSyntax = -1;
        MatchingTransferSyntax = -1;
        for (i = 0; i < NumberOfBindingsAvailable; i ++)
            {
            // do we support the preferred server
            if (BindingsForThisInterface[i]->IsTransferSyntaxServerPreferred())
                {
                PreferredTransferSyntax = i;
                break;
                }
            else if ((BindingCreated[i] == FALSE) && (MatchingTransferSyntax < 0))
                {
                MatchingTransferSyntax = i;
                }
            }

        // is there a syntax preferred by the server
        if (PreferredTransferSyntax >= 0)
            {
            // do we already support it (i.e. the binding was not created)
            if (BindingCreated[PreferredTransferSyntax] == FALSE)
                {
                // then we're all set - just use it
                fAlterContextNeeded = FALSE;
                SelectedBinding = BindingsForThisInterface[PreferredTransferSyntax];
                }
            else
                {
                // we don't support it - negotiate it. We know this
                // will succeed, because the server preferences
                // are set. This should be hit in the auto-retry case only
                fAlterContextNeeded = TRUE;
                ASSERT(_NOT_COVERED_);
                }
            }
        else
            {
            // no preferred syntax - any will do. Check if we found anything supported
            if (MatchingTransferSyntax >= 0)
                {
                SelectedBinding = BindingsForThisInterface[MatchingTransferSyntax];
                fAlterContextNeeded = FALSE;
                }
            else
                {
                fAlterContextNeeded = TRUE;
                }
            }

        if (fAlterContextNeeded == FALSE)
            {
            if (IsBackConnectionNeeded)
                {
                Status = InitializeAsyncLrpcIfNecessary() ;
                if (Status == RPC_S_OK)
                    {
                    Status = CreateBackConnection(BindingHandle);
                    }

                if (Status != RPC_S_OK)
                    {
                    goto Cleanup;
                    }
                }
            }

        if (fAlterContextNeeded || fAlterSecurityContextNeeded)
            {
            Status = ActuallyDoBinding(
                                   BindingHandle,
                                   IsBackConnectionNeeded,
                                   fAlterContextNeeded,
                                   fAlterSecurityContextNeeded,
                                   BindingHandle->ClientAuthInfo.DefaultLogonId,
                                   NumberOfBindingsAvailable,
                                   BindingsForThisInterface,
                                   &SelectedBinding,
                                   &CurrentSecurityContext);
            if (Status != RPC_S_SERVER_UNAVAILABLE) 
                {
                fAssociationAborted = FALSE;
                break;
                }

            // The server appears to have gone away, close the port and retry.

            RetryCount++;

            SelectedBinding = 0;

            // both the creation in ActuallyDoBinding and the
            // retrieval from the cache will add a refcount -
            // remove it
            if (CurrentSecurityContext)
                {
                CurrentSecurityContext->RemoveReference();
                CurrentSecurityContext = NULL; 
                }
            fAlterContextNeeded = TRUE;

            if (IsBackConnectionNeeded
                || EffectiveIdentityTracking == RPC_C_QOS_IDENTITY_STATIC)
                {
                fAlterSecurityContextNeeded = TRUE;
                }

            AbortAssociation();

            if (RetryCount < 3)
                {
                RpcpPurgeEEInfo();
                }

            fAssociationAborted = TRUE;
            }
        else
            {
            Status = RPC_S_OK;
            break;
            }

    } while(RetryCount < 3);

    if (Status == RPC_S_OK)
        {
        ASSERT(SelectedBinding != 0);

        Status = ActuallyAllocateCCall(
                                       CCall,
                                       SelectedBinding,
                                       IsBackConnectionNeeded,
                                       BindingHandle,
                                       CurrentSecurityContext);
        }
    else
        {
        // if the association was aborted, the bindings were already removed from the
        // dictionary - don't do it again
        if (fAssociationAborted == FALSE)
            {
            // the binding failed - remove the created bindings from the dictionary
            for (i = 0; i < NumberOfBindingsAvailable; i ++)
                {
                if (BindingCreated[i])
                    {
                    CurrentBinding = Bindings.Delete(BindingsForThisInterface[i]->GetPresentationContext());
                    ASSERT(CurrentBinding == BindingsForThisInterface[i]);
                    delete CurrentBinding;
                    }
                }
            }
        }

Cleanup:
    if (CurrentSecurityContext)
        {
        if (Status == RPC_S_OK)
            {
            (*CCall)->SetCurrentSecurityContext(CurrentSecurityContext);
            }
        else
            {
            // remove the added reference
            CurrentSecurityContext->RemoveReference();
            }
        }
    AssociationMutex.Clear();

    return(Status);
}


RPC_STATUS
LRPC_CASSOCIATION::ActuallyAllocateCCall (
    OUT LRPC_CCALL ** CCall,
    IN LRPC_BINDING * Binding,
    IN BOOL IsBackConnectionNeeded,
    IN LRPC_BINDING_HANDLE * BindingHandle,
    IN LRPC_CCONTEXT *SecurityContext
    )
/*++

Routine Description:

    We need to allocate a LRPC_CCALL object for the call.  We also need
    to initialize it so that it specified the correct bound interface.

Arguments:

    CCall - Returns the allocated LRPC_CCALL which has been bound to
        the interface specified by the rpc interface information.

    Binding - Supplies a representation of the interface to which the
        remote procedure call is supposed to be directed.

Return Value:

    RPC_S_OK - An LRPC_CCALL has been allocated and is ready to be used
        to make a remote procedure call.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allocate
        the LRPC_CALL object.

Notes:

    The global mutex will be held when this routine is called.

--*/
{
    RPC_STATUS Status = RPC_S_OK ;
    DictionaryCursor cursor;
    LRPC_CCALL *LocalCall;
    THREAD *ThisThread;

    if (CachedCCallFlag != 0)
        {
        LocalCall = CachedCCall ;
        CachedCCallFlag = 0;
        }
    else
        {
        ThisThread = RpcpGetThreadPointer();

        ASSERT(ThisThread);

        if (ThisThread->GetCachedLrpcCall())
            {
            LocalCall = ThisThread->GetCachedLrpcCall();
            ThisThread->SetCachedLrpcCall(NULL);

            LocalCall->SetAssociation(this);
            }
        else
            {
            FreeCCalls.Reset(cursor) ;

            while ((LocalCall = FreeCCalls.Next(cursor)) != 0)
                {
                FreeCCalls.Delete(LocalCall->FreeCallKey) ;
                break;
                }
            }

        if (LocalCall == 0)
            {
            LocalCall = new LRPC_CCALL(&Status);
            if (LocalCall == 0)
                {
                return(RPC_S_OUT_OF_MEMORY);
                }

            if (Status != RPC_S_OK)
                {
                delete LocalCall ;
                return Status ;
                }
            LocalCall->SetAssociation(this);
            }
        }

    Status = LocalCall->ActivateCall(BindingHandle,
                                Binding,
                                IsBackConnectionNeeded,
                                SecurityContext);
    if (Status != RPC_S_OK)
        {
        goto Cleanup;
        }

    if (IsBackConnectionNeeded)
        {
        if (ActiveCCalls.Insert(ULongToPtr(CallIdCounter), LocalCall) == -1)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            // remove the reference we added to this
            // binding
            Binding->RemoveReference();
            goto Cleanup;
            }

        LocalCall->CallId = CallIdCounter++;

        LogEvent(SU_CCALL, EV_START, LocalCall, this, LocalCall->CallId, 1, 0);
        }

    AddReference();

    *CCall = LocalCall;
    return(RPC_S_OK);

Cleanup:
    if (LocalCall == CachedCCall)
        {
        CachedCCallFlag = 1;
        }
    else
        {
        delete LocalCall ;
        }

    return (Status) ;
}

void
LRPC_CASSOCIATION::PrepareBindPacket(LRPC_MESSAGE *LrpcMessage)
{
    int MessageSize;
    int NumContexts = 0;
    LRPC_CCONTEXT *CContext;
    LRPC_CCONTEXT *DeletedContext;
    DictionaryCursor cursor;

    SecurityContextDict.Reset(cursor);
    while (NumContexts < MAX_LRPC_CONTEXTS)
        {
        CContext = SecurityContextDict.Next(cursor);
        if (CContext)
            {
            if (CContext->IsUnused()
                && CContext->IsSecurityContextOld())
                {
                LrpcMessage->Bind.OldSecurityContexts.SecurityContextId[NumContexts]
                    = CContext->SecurityContextId;
                DeletedContext = SecurityContextDict.Delete(CContext->ContextKey);
                ASSERT(DeletedContext == CContext);

                NumContexts++;

                delete CContext;
                }
            }
        else
            {
            break;
            }
        }

    UpdateLastSecContextTrimmingTimestamp();

    MessageSize = sizeof(LRPC_BIND_MESSAGE)+NumContexts*sizeof(DWORD);

    LrpcMessage->Bind.OldSecurityContexts.NumContexts = NumContexts;

    LrpcMessage->LpcHeader.u1.s1.DataLength = (CSHORT) (MessageSize - sizeof(PORT_MESSAGE));
    LrpcMessage->LpcHeader.u1.s1.TotalLength = (CSHORT) MessageSize;
}



RPC_STATUS
LRPC_CASSOCIATION::ActuallyDoBinding (
    IN LRPC_BINDING_HANDLE *BindingHandle,
    IN BOOL IsBackConnectionNeeded,
    IN BOOL fAlterContextNeeded,
    IN BOOL fAlterSecurityContextNeeded,
    IN BOOL fDefaultLogonId,
    IN int NumberOfBindings,
    LRPC_BINDING *BindingsForThisInterface[],
    OUT LRPC_BINDING ** Binding,
    OUT LRPC_CCONTEXT **pSecurityContext
    )
/*++

Routine Description:

Arguments:

    RpcInterfaceInformation - Supplies information describing the interface
        to which we wish to bind.

    Binding - Returns an object representing the binding to the interface
        described by the first argument.

Return Value:

--*/
{
    NTSTATUS NtStatus;
    NTSTATUS MyNtStatus;
    RPC_STATUS Status = RPC_S_OK;
    int DictKey ;
    HANDLE ImpersonationToken = 0;
    BOOL fTokenAltered = 0;
    int i;
    LRPC_BIND_EXCHANGE *BindExchange;
    int BindingForNDR20PresentationContext;
    int BindingForNDR64PresentationContext;
    int BindingForNDRTestPresentationContext;
    int ChosenBindingIndex;
    LRPC_BINDING *SelectedBinding;

    LRPC_MESSAGE *LrpcMessage;
    ULONG EffectiveIdentityTracking;

    //
    // To start with, see if we have an LPC port; if we dont, open one
    // up.
    //

    //
    // The AssociationMutex is held when this function is called
    //

    AssociationMutex.VerifyOwned();

    if (IsBackConnectionNeeded)
        {
        Status = InitializeAsyncLrpcIfNecessary() ;
        if (Status == RPC_S_OK)
            {
            Status = CreateBackConnection(BindingHandle) ;
            }

        if (Status != RPC_S_OK)
            {
            RpcpErrorAddRecord(EEInfoGCRuntime, 
                Status,
                EEInfoDLLRPC_CASSOCIATION__ActuallyDoBinding10,
                InqEndpoint());
            return Status ;
            }
        }
    else
        {
        if (LpcClientPort == 0)
            {
            //
            // we now need to bind explicitly
            //
            Status = OpenLpcPort(BindingHandle, FALSE);
            ASSERT(fAlterContextNeeded == TRUE);

            if (Status != RPC_S_OK)
                {
                RpcpErrorAddRecord(EEInfoGCRuntime, 
                    Status,
                    EEInfoDLLRPC_CASSOCIATION__ActuallyDoBinding20,
                    InqEndpoint());
                return Status ;
                }
            }
        }


    LrpcMessage = (LRPC_MESSAGE *)AlignOnNaturalBoundary(
        _alloca(PadToNaturalBoundary(sizeof(LRPC_MESSAGE) + 1) + sizeof(LRPC_MESSAGE)));
    if (CacheNeedsTrimming())
        {
        PrepareBindPacket(LrpcMessage);
        }
    else
        {
        LrpcMessage->LpcHeader.u1.s1.DataLength = sizeof(LRPC_BIND_MESSAGE)
            - sizeof(PORT_MESSAGE);
        LrpcMessage->LpcHeader.u1.s1.TotalLength = sizeof(LRPC_BIND_MESSAGE);
        LrpcMessage->Bind.OldSecurityContexts.NumContexts = 0;
        }
    BindExchange = &LrpcMessage->Bind.BindExchange;

    // Otherwise, just go ahead and send the bind request message to the
    // server, and then wait for the bind response.

    LrpcMessage->LpcHeader.u2.ZeroInit = 0;
    LrpcMessage->Bind.MessageType = LRPC_MSG_BIND;

    if (fAlterContextNeeded)
        {
        SelectedBinding = *Binding = NULL;
        ASSERT(NumberOfBindings > 0);
        // all bindings have the same interface ID. Therefore, it is
        // safe to use the first
        RpcpMemoryCopy(&BindExchange->InterfaceId, 
            BindingsForThisInterface[0]->GetInterfaceId(),
            sizeof(RPC_SYNTAX_IDENTIFIER));

        BindExchange->Flags = NEW_PRESENTATION_CONTEXT_FLAG;
        BindExchange->TransferSyntaxSet = 0;
        BindingForNDR20PresentationContext = BindingForNDR64PresentationContext = -1;

        ASSERT (NumberOfBindings <= MaximumNumberOfTransferSyntaxes);
        for (i = 0; i < NumberOfBindings; i ++)
            {
            if (RpcpMemoryCompare(BindingsForThisInterface[i]->GetTransferSyntaxId(), 
                NDR20TransferSyntax, sizeof(RPC_SYNTAX_IDENTIFIER)) == 0)
                {
                BindExchange->TransferSyntaxSet |= TS_NDR20_FLAG;
                BindExchange->PresentationContext[0]
                    = BindingsForThisInterface[i]->GetOnTheWirePresentationContext();
                BindingForNDR20PresentationContext = i;
                }
            else if (RpcpMemoryCompare(BindingsForThisInterface[i]->GetTransferSyntaxId(), 
                NDR64TransferSyntax, sizeof(RPC_SYNTAX_IDENTIFIER)) == 0)
                {
                BindExchange->TransferSyntaxSet |= TS_NDR64_FLAG;
                BindExchange->PresentationContext[1]
                    = BindingsForThisInterface[i]->GetOnTheWirePresentationContext();
                BindingForNDR64PresentationContext = i;
                }
            else if (RpcpMemoryCompare(BindingsForThisInterface[i]->GetTransferSyntaxId(), 
                NDRTestTransferSyntax, sizeof(RPC_SYNTAX_IDENTIFIER)) == 0)
                {
                BindExchange->TransferSyntaxSet |= TS_NDRTEST_FLAG;
                BindExchange->PresentationContext[2]
                    = BindingsForThisInterface[i]->GetOnTheWirePresentationContext();
                BindingForNDRTestPresentationContext = i;
                }
            else
                {
                ASSERT(!"Unknown transfer syntax\n");
                Status = RPC_S_UNSUPPORTED_TRANS_SYN;
                goto Cleanup;
                }
            }

        }
    else
        {
        BindExchange->Flags = 0;
        ASSERT(*Binding != NULL);
        SelectedBinding = *Binding;
        }

    if (fAlterSecurityContextNeeded)
        {
        BindExchange->Flags |= NEW_SECURITY_CONTEXT_FLAG;

        if (fDefaultLogonId)
            BindExchange->Flags |= DEFAULT_LOGONID_FLAG;

        EffectiveIdentityTracking = BindingHandle->GetIdentityTracking();

        if (EffectiveIdentityTracking == RPC_C_QOS_IDENTITY_STATIC)
            {
            if (OpenThreadToken (GetCurrentThread(),
                             TOKEN_IMPERSONATE | TOKEN_QUERY,
                             TRUE,
                             &ImpersonationToken) == FALSE)
                {
                ImpersonationToken = 0;
                }

            MyNtStatus = NtSetInformationThread(NtCurrentThread(),
                                              ThreadImpersonationToken,
                                              &(BindingHandle->StaticTokenHandle),
                                              sizeof(HANDLE));
#if DBG
            if (!NT_SUCCESS(MyNtStatus))
                {
                PrintToDebugger("RPC : NtSetInformationThread : %lx\n", MyNtStatus);
                }
#endif // DBG
            fTokenAltered = 1;
            }
        }

    NtStatus = NtRequestWaitReplyPort(LpcClientPort,
                     (PORT_MESSAGE *) LrpcMessage,
                     (PORT_MESSAGE *) LrpcMessage) ;

    if (fTokenAltered)
        {
        MyNtStatus = NtSetInformationThread(NtCurrentThread(),
                                          ThreadImpersonationToken,
                                          &ImpersonationToken,
                                          sizeof(HANDLE));
#if DBG
        if (!NT_SUCCESS(MyNtStatus))
            {
            PrintToDebugger("RPC : NtSetInformationThread : %lx\n", MyNtStatus);
            }
#endif // DBG

        if (ImpersonationToken)
            {
            CloseHandle(ImpersonationToken);
            }
        }

    if (NT_SUCCESS(NtStatus))
        {
        ASSERT(LrpcMessage->Bind.MessageType == LRPC_BIND_ACK);
        if (BindExchange->RpcStatus == RPC_S_OK)
            {
            if (fAlterSecurityContextNeeded &&
                (IsBackConnectionNeeded
                 || EffectiveIdentityTracking == RPC_C_QOS_IDENTITY_STATIC))
                {
                //
                // It is possible for the security context ID to be -1
                // This will happen when the server is not able to open the token
                //
                *pSecurityContext = new LRPC_CCONTEXT(
                                    BindingHandle->InquireAuthInformation(),
                                    BindExchange->SecurityContextId,
                                    this);
                if (*pSecurityContext == 0)
                    {
                    Status = RPC_S_OUT_OF_MEMORY;
                    goto Cleanup;
                    }

                if ((DictKey = SecurityContextDict.Insert(*pSecurityContext)) == -1)
                    {
                    delete *pSecurityContext;
                    *pSecurityContext = NULL;
                    Status = RPC_S_OUT_OF_MEMORY;
                    goto Cleanup;
                    }

                (*pSecurityContext)->AddReference();
                (*pSecurityContext)->ContextKey = DictKey;
                }

            if (fAlterContextNeeded)
                {
                ChosenBindingIndex = -1;

                // which presentation context did the server pick?
                if (BindExchange->TransferSyntaxSet & TS_NDR20_FLAG)
                    {
                    ASSERT(BindingForNDR20PresentationContext != -1);
                    // the server should choose only one transfer syntax
                    ASSERT((BindExchange->TransferSyntaxSet & ~TS_NDR20_FLAG) == 0);
                    ChosenBindingIndex = BindingForNDR20PresentationContext;
                    }
                else if (BindExchange->TransferSyntaxSet & TS_NDR64_FLAG)
                    {
                    ASSERT(BindingForNDR64PresentationContext != -1);
                    // the server should choose only one transfer syntax
                    ASSERT((BindExchange->TransferSyntaxSet & ~TS_NDR64_FLAG) == 0);
                    ChosenBindingIndex = BindingForNDR64PresentationContext;
                    }
                else if (BindExchange->TransferSyntaxSet & TS_NDRTEST_FLAG)
                    {
                    ASSERT(BindingForNDRTestPresentationContext != -1);
                    // the server should choose only one transfer syntax
                    ASSERT((BindExchange->TransferSyntaxSet & ~TS_NDRTEST_FLAG) == 0);
                    ChosenBindingIndex = BindingForNDRTestPresentationContext;
                    }
                else
                    {
                    ASSERT(!"Server supplied invalid response");
                    }

                if (ChosenBindingIndex < 0)
                    {
                    ASSERT(_NOT_COVERED_);
                    BindExchange->RpcStatus = RPC_S_UNSUPPORTED_TRANS_SYN;
                    }
                else
                    {
                    // if we offered the server a choice of bindings and it
                    // exercised this choice, record its preferences
                    if (NumberOfBindings > 1)
                        {
                        BindingsForThisInterface[ChosenBindingIndex]->
                            TransferSyntaxIsServerPreferred();
                        for (i = 0; i < NumberOfBindings; i ++)
                            {
                            if (ChosenBindingIndex != i)
                                {
                                BindingsForThisInterface[i]->TransferSyntaxIsNotServerPreferred();
                                }
                            }
                        }

                    SelectedBinding = BindingsForThisInterface[ChosenBindingIndex];
                    }
                }

            }
        else
            {
            if (BindExchange->Flags & EXTENDED_ERROR_INFO_PRESENT)
                {
                ExtendedErrorInfo *EEInfo;

                ASSERT(IsBufferAligned(LrpcMessage->Bind.BindExchange.Buffer));
                Status = UnpickleEEInfo(LrpcMessage->Bind.BindExchange.Buffer,
                    LrpcMessage->LpcHeader.u1.s1.DataLength
                        - BIND_NAK_PICKLE_BUFFER_OFFSET
                        + sizeof(PORT_MESSAGE),
                    &EEInfo);
                if (Status == RPC_S_OK)
                    {
                    RpcpSetEEInfo(EEInfo);
                    }

                RpcpErrorAddRecord(EEInfoGCRuntime, 
                    BindExchange->RpcStatus,
                    EEInfoDLLRPC_CASSOCIATION__ActuallyDoBinding30);
                }
            }

        Status = BindExchange->RpcStatus;

        ASSERT (Status != RPC_S_SERVER_UNAVAILABLE
            && Status != RPC_S_ACCESS_DENIED) ;
        }
    else
        {
        Status = RPC_S_SERVER_UNAVAILABLE;

        RpcpErrorAddRecord(EEInfoGCLPC, 
            Status,
            EEInfoDLLRPC_CASSOCIATION__ActuallyDoBinding40,
            NtStatus);
        }

Cleanup:
    *Binding = SelectedBinding;
    return (Status);
}


void
LRPC_CASSOCIATION::ProcessResponse (
   IN LRPC_MESSAGE *LrpcResponse,
   IN OUT LRPC_MESSAGE **LrpcReplyMessage
   )
/*++

Routine Description:
    Process a response on the back connection.
    Two types of responses can show up on the back connection:
    1. Responses from async calls.

Arguments:

 LrpcResponse - Reply message.

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/

{
    LRPC_CCALL *CCall ;
    RPC_MESSAGE RpcMessage ;
    THREAD *ThisThread;
    LRPC_CCALL *ExistingCCall;
    ULONG OriginalCallId;

    ThisThread = RpcpGetThreadPointer();
    ASSERT(ThisThread);
    ASSERT(ThisThread->GetDestroyedWithOutstandingLocksFlag() == 0);

    OriginalCallId = LrpcResponse->Rpc.RpcHeader.CallId;
    AssociationMutex.Request() ;
    CCall = ActiveCCalls.Find(ULongToPtr(OriginalCallId)) ;
    if (CCall == 0)
        {
        AssociationMutex.Clear() ;

        if (LrpcResponse->Rpc.RpcHeader.Flags & LRPC_BUFFER_SERVER)
            {
            // There may be a server thread stuck waiting for the reply
            // in which case we should treat this as a synchronous call
            // and make sure the message is not dropped.
            // We do this only if the buffer is server. If it is not,
            // we don't do that, because the LPC response we received
            // was datagram, and we can't send a response to a datagram.
            // Note that this is not necessary either, since the response
            // is from a server, and we don't have any use on the server
            // for a fault to a response (it just gets dropped). If the
            // buffer is server, we still need to do it to free
            // the thread, because it is doing NtRequestWaitReplyPort,
            // and this is blocking.
            SetFaultPacket(LrpcResponse,
                RPC_S_CALL_FAILED_DNE,
                LrpcResponse->Rpc.RpcHeader.Flags | LRPC_SYNC_CLIENT,
                NULL);

            *LrpcReplyMessage = LrpcResponse;
            }

        return ;
        }
    CCall->LockCallFromResponse();
    AssociationMutex.Clear() ;

    CCall->ProcessResponse(LrpcResponse);

    // if this call was destroyed with outstanding locks, don't
    // touch it - just clear the flag
    if (ThisThread->GetDestroyedWithOutstandingLocksFlag())
        {
        ThisThread->ClearDestroyedWithOutstandingLocksFlag();
        }
    else
        {
        AssociationMutex.Request() ;
        // check if somebody has freed the call. If yes, don't do anything - the counter
        // would have been reset
        ExistingCCall = ActiveCCalls.Find(ULongToPtr(OriginalCallId));
        if (ExistingCCall 
            && (ExistingCCall == CCall))
            {
            CCall->UnlockCallFromResponse();
            }
        AssociationMutex.Clear() ;
        }
}


RPC_STATUS
LRPC_CASSOCIATION::OpenLpcPort (
    IN LRPC_BINDING_HANDLE *BindingHandle,
    IN BOOL fBindBack
    )
/*++

Routine Description:

Arguments:

    RpcInterfaceInformation - Supplies information describing the interface
        to which we wish to bind.

    Binding - Returns an object representing the binding to the interface
        described by the first argument.

Return Value:

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete the
        operation.

Notes:

    The global mutex will be held when this routine is called.

--*/
{
    NTSTATUS NtStatus;
    UNICODE_STRING UnicodeString;
    RPC_CHAR * LpcPortName;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    RPC_STATUS Status;
    LRPC_BIND_EXCHANGE BindExchange;
    unsigned long BindExchangeLength = sizeof(LRPC_BIND_EXCHANGE);
    DWORD LastError;

    //
    // Look at the network options and initialize the security quality
    // of service appropriately.
    //

    SecurityQualityOfService.EffectiveOnly = (unsigned char) BindingHandle->EffectiveOnly;
    SecurityQualityOfService.ContextTrackingMode =
                        SECURITY_DYNAMIC_TRACKING;

    SecurityQualityOfService.ImpersonationLevel =
            MapRpcToNtImp(AssocAuthInfo.ImpersonationType) ;

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);

    //
    // Allocate and initialize the port name.  We need to stick the
    // LRPC_DIRECTORY_NAME on the front of the endpoint.  This is for
    // security reasons (so that anyone can create LRPC endpoints).
    //

    LpcPortName = new RPC_CHAR[
                    RpcpStringLength(DceBinding->InqEndpoint())
                    + RpcpStringLength(LRPC_DIRECTORY_NAME) + 1];
    if (LpcPortName == 0)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    RpcpMemoryCopy(LpcPortName, LRPC_DIRECTORY_NAME,
            RpcpStringLength(LRPC_DIRECTORY_NAME) * sizeof(RPC_CHAR));

    RpcpMemoryCopy(LpcPortName + RpcpStringLength(LRPC_DIRECTORY_NAME),
            DceBinding->InqEndpoint(),
            (RpcpStringLength(DceBinding->InqEndpoint()) + 1)
                * sizeof(RPC_CHAR));

    RtlInitUnicodeString(&UnicodeString, LpcPortName);

    DWORD Key;
    LPC_KEY *LpcKey = (LPC_KEY *) &Key;

    LpcKey->SeqNumber = SequenceNumber;
    LpcKey->AssocKey = (unsigned short) AssociationDictKey;

    BindExchange.ConnectType = LRPC_CONNECT_REQUEST ;
    BindExchange.AssocKey = Key;

    if (fBindBack)
        {
        BindExchange.Flags = BIND_BACK_FLAG;
        LrpcGetEndpoint((RPC_CHAR *) BindExchange.szPortName) ;
        }
    else
        {
        BindExchange.Flags = 0;
        }

    if (AssocAuthInfo.Capabilities == RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH
        && AssocAuthInfo.ServerPrincipalName)
        {
        int i;
        DWORD SizeofSID, DomainNameLen;
        SID_NAME_USE eUse;
        PSID pSID;
        RPC_CHAR *pDomainName;

        SizeofSID = sizeof(SID)+10*sizeof(ULONG);
        DomainNameLen = 256 * sizeof(RPC_CHAR);

        for (i = 0; i < 2; i++)
            {
            pSID = (PSID) new char[SizeofSID];
            pDomainName = (RPC_CHAR *) new char[DomainNameLen];

            if (pSID == 0 || pDomainName == 0)
                {
                delete pSID;
                delete pDomainName;
                delete LpcPortName;

                return RPC_S_OUT_OF_MEMORY;
                }

            if (LookupAccountNameW (
                                    NULL,
                                    AssocAuthInfo.ServerPrincipalName,
                                    pSID,
                                    &SizeofSID,
                                    pDomainName,
                                    &DomainNameLen,
                                    &eUse)) 
                {
                break;
                }

            delete pSID;
            delete pDomainName;

            LastError = GetLastError();
            if (LastError != ERROR_INSUFFICIENT_BUFFER)
                {
                delete LpcPortName;

                switch (LastError)
                    {
                    case ERROR_NONE_MAPPED:
                        Status = RPC_S_UNKNOWN_PRINCIPAL;
                        break;

                    case ERROR_ACCESS_DENIED:
                    case ERROR_TRUSTED_RELATIONSHIP_FAILURE:
                        Status = RPC_S_ACCESS_DENIED;
                        break;

                    default:
                        Status = RPC_S_OUT_OF_MEMORY;
                    }

                RpcpErrorAddRecord(EEInfoGCRuntime, 
                    Status,
                    EEInfoDLLRPC_CASSOCIATION__OpenLpcPort10,
                    LastError);

                return Status;
                }
            }
        delete pDomainName;

        ASSERT(i < 2);

        NtStatus = NtSecureConnectPort (
                                        &LpcClientPort,
                                        &UnicodeString,
                                        &SecurityQualityOfService,
                                        NULL,
                                        pSID,
                                        NULL,
                                        NULL,
                                        &BindExchange,
                                        &BindExchangeLength);
        delete pSID;
        }
    else
        {
        NtStatus = NtConnectPort(
                                 &LpcClientPort,
                                 &UnicodeString,
                                 &SecurityQualityOfService,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &BindExchange,
                                 &BindExchangeLength);
        }

    delete LpcPortName;
    if (NT_SUCCESS(NtStatus))
        {
        ASSERT(BindExchangeLength == sizeof(LRPC_BIND_EXCHANGE));

        return(BindExchange.RpcStatus);
        }

    if (NtStatus == STATUS_PORT_CONNECTION_REFUSED)
        {
        if (BindExchange.Flags & SERVER_BIND_EXCH_RESP)
            {
            RpcpErrorAddRecord(EEInfoGCRuntime, 
                BindExchange.RpcStatus,
                EEInfoDLLRPC_CASSOCIATION__OpenLpcPort20,
                NtStatus);
            return(BindExchange.RpcStatus);
            }

        // if the SERVER_BIND_EXCH_RESP flag is not set, the rejection
        // comes from LPC. The only case where this can happen is if
        // the server is not available.
        RpcpErrorAddRecord(EEInfoGCRuntime, 
            RPC_S_SERVER_UNAVAILABLE,
            EEInfoDLLRPC_CASSOCIATION__OpenLpcPort30,
            NtStatus);

        return(RPC_S_SERVER_UNAVAILABLE);
        }

    if (NtStatus == STATUS_NO_MEMORY)
        {
        Status = RPC_S_OUT_OF_MEMORY;
        }
    else if ((NtStatus == STATUS_INSUFFICIENT_RESOURCES)
        || (NtStatus == STATUS_QUOTA_EXCEEDED))
        {
        Status = RPC_S_OUT_OF_RESOURCES;
        }
    else if (NtStatus == STATUS_OBJECT_PATH_INVALID)
        {
        Status = RPC_S_INVALID_ENDPOINT_FORMAT;
        }

    else if (NtStatus == STATUS_ACCESS_DENIED
        || NtStatus == STATUS_SERVER_SID_MISMATCH
        || NtStatus == STATUS_BAD_IMPERSONATION_LEVEL)
        {
        Status = RPC_S_ACCESS_DENIED;
        }
    else
        {
#if DBG
        if (NtStatus != STATUS_OBJECT_NAME_NOT_FOUND)
            {
            PrintToDebugger("LRPC: NtConnectPort : %lx\n", NtStatus);
            }
#endif // DBG

        ASSERT(NtStatus == STATUS_OBJECT_NAME_NOT_FOUND);

        Status = RPC_S_SERVER_UNAVAILABLE;
        }

    RpcpErrorAddRecord(EEInfoGCRuntime, 
        Status,
        EEInfoDLLRPC_CASSOCIATION__OpenLpcPort40,
        NtStatus);

    return Status;
}


void
LRPC_CASSOCIATION::FreeCCall (
    IN LRPC_CCALL * CCall
    )
/*++

Routine Description:

    This routine will get called to notify this association that a remote
    procedure call on this association has completed.

Arguments:

    CCall - Supplies the remote procedure call which has completed.

--*/
{
    LRPC_CCALL *DeletedCall;
    BOOL fMutexTaken = FALSE;
    ExtendedErrorInfo *LocalEEInfo;
    LRPC_MESSAGE *LocalLrpcMessage;
    THREAD *ThisThread;
    BOOL fCacheToThread;
    BOOL fOutstandingLocks = FALSE;
    BOOL fUnlocked;
    void *Buffer;
    unsigned int BufferLength ;

    if (CCall->CallId != (ULONG) -1)
        {

        // Try to take both resources, but if fail on the second, release
        // the first and retry.  There is a potential deadlock here, since
        // another thread may have the call locked while holding the AssociationMutex,
        // release the mutex, and try to take it again.  This may happen in
        // ProcessResponse()
        while (TRUE)
            {
            AssociationMutex.Request();
            fMutexTaken = TRUE;

            LogEvent(SU_CCALL, EV_STOP, CCall, this, CCall->CallId, 1, 0);

            if (CCall->AsyncStatus == RPC_S_CALL_CANCELLED)
                {
                // if the call was cancelled, there is a race condition
                // where the server may still be sending us a response
                // make sure we wait for any response already in the pipeline
                // to go through
                fOutstandingLocks = CCall->TryWaitForCallToBecomeUnlocked(&fUnlocked);

                if (fUnlocked)
                    break;
                else
                    {
                    AssociationMutex.Clear();
                    fMutexTaken = FALSE;
                    Sleep(10);
                    }
                }
            else
                {
                // this is not a cancel. It is possible that a response
                // is still being processed. We zero out the counter now,
                // and we will remove the element from the dictionary and
                // reset its CallId (we're still inside the mutex). When
                // the thread that processes the response is about to
                // decrease the refcount, it will check whether the call is
                // in the dictionary and whether it has the same call id.
                // If yes, it won't touch the call.
                CCall->ResponseLockCount.SetInteger(0);
                break;
                }
            }

        DeletedCall = ActiveCCalls.Delete(ULongToPtr(CCall->CallId));
        ASSERT((DeletedCall == 0) || (CCall == DeletedCall));

        CCall->CallId = (ULONG) -1;
        }

    LogEvent(SU_CCALL, EV_REMOVED, CCall, this, 0, 1, 2);
    LogEvent(SU_CCALL, EV_REMOVED, CCall, this, 0, 1, 6);

    if (CCall->BufferQueue.Size() != 0)
        {
        if (!fMutexTaken)
            {
            AssociationMutex.Request();
            fMutexTaken = TRUE;
            }

        while ((Buffer = CCall->BufferQueue.TakeOffQueue(&BufferLength)) != 0)
            {
            CCall->ActuallyFreeBuffer(Buffer);
            }
        }


    if (fMutexTaken)
        {
        LocalEEInfo = CCall->EEInfo;
        CCall->EEInfo = NULL;
        }
    else
        {
        LocalEEInfo = 
            (ExtendedErrorInfo *)InterlockedExchangePointer((PVOID *)(&CCall->EEInfo), NULL);
        }

    if (LocalEEInfo != NULL)
        {
        FreeEEInfoChain(LocalEEInfo);
        }

    CCall->Binding->RemoveReference();
    CCall->Binding = NULL;

    if (CCall == CachedCCall)
        {
        CachedCCallFlag = 1 ;
        }
    else
        {
        if (fMutexTaken)
            {
            LocalLrpcMessage = CCall->LrpcMessage;
            CCall->LrpcMessage = 0;
            }
        else
            {
            LocalLrpcMessage = 
                (LRPC_MESSAGE *)InterlockedExchangePointer((PVOID *)(&CCall->LrpcMessage), 0);
            }
        FreeMessage(LocalLrpcMessage);

        ThisThread = RpcpGetThreadPointer();

        ASSERT(ThisThread);

        if (gfServerPlatform && (ThisThread->GetCachedLrpcCall() == NULL))
            {
            CCall->FreeCallKey = -1;
            // set the association to NULL to toast anybody who tries to touch it
            CCall->Association = NULL;
            ThisThread->SetCachedLrpcCall(CCall);
            }
        else if (FreeCCalls.Size() < 64)
            {
            if (!fMutexTaken)
                {
                AssociationMutex.Request();
                fMutexTaken = TRUE;
                }

            if ((CCall->FreeCallKey = FreeCCalls.Insert(CCall)) == -1)
                {
                delete CCall;
                }
            }
        else
            {
            CCall->FreeCallKey = -1;
            delete CCall;
            }
        }

    if (fMutexTaken)
        {
        AssociationMutex.Clear();
        }

    if (fOutstandingLocks)
        {
        ThisThread = RpcpGetThreadPointer();

        ASSERT(ThisThread);

        ThisThread->SetDestroyedWithOutstandingLocksFlag();
        }

    RemoveReference();
}


LRPC_CASSOCIATION *
FindOrCreateLrpcAssociation (
    IN DCE_BINDING * DceBinding,
    IN CLIENT_AUTH_INFO *pClientAuthInfo,
    IN RPC_CLIENT_INTERFACE *InterfaceInfo
    )
/*++

Routine Description:

    This routine finds an existing association supporting the requested
    DCE binding, or creates a new association which supports the
    requested DCE binding.  Ownership of the passed DceBinding passes
    to this routine.

Arguments:

    DceBinding - Supplies binding information; if an association is
                 returned the ownership of the DceBinding is passed
                 to the association.

Return Value:

    An association which supports the requested binding will be returned.
    Otherwise, zero will be returned, indicating insufficient memory.

--*/
{
    LRPC_CASSOCIATION * Association;
    RPC_STATUS Status = RPC_S_OK;
    static USHORT SequenceNumber = 1;
    DictionaryCursor cursor;
    BOOL fOnlyEndpointDiffers;
    int Result;

    // First, we check for an existing association.

    LrpcAssociationDict->Reset(cursor);
    while ((Association = LrpcAssociationDict->Next(cursor)) != 0)
        {
#if defined (RPC_GC_AUDIT)
        DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Comparing association to: %S, %S, %S\n",
            GetCurrentProcessId(), GetCurrentProcessId(), Association->DceBinding->InqRpcProtocolSequence(),
            Association->DceBinding->InqNetworkAddress(), Association->DceBinding->InqEndpoint());
#endif
        Result = Association->CompareWithDceBinding(DceBinding, &fOnlyEndpointDiffers);
        if ((Association->IsSupportedAuthInfo(pClientAuthInfo) == TRUE)
            &&
            (!Result
                ||
             (
                fOnlyEndpointDiffers
                && InterfaceInfo
                && DceBinding->IsNullEndpoint()
                && Association->DoesBindingForInterfaceExist(InterfaceInfo)
             )
            )
           )
            {
            Association->AddBindingHandleReference();
            if (Association->Linger.fAssociationLingered == TRUE)
                {
#if defined (RPC_GC_AUDIT)
                DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) LRPC lingering association resurrected %X %S %S %S\n",
                    GetCurrentProcessId(), GetCurrentProcessId(), Association,
                    Association->DceBinding->InqRpcProtocolSequence(),
                    Association->DceBinding->InqNetworkAddress(), 
                    Association->DceBinding->InqEndpoint());
#endif
                LrpcLingeredAssociations --;
                ASSERT(LrpcLingeredAssociations >= 0);
                Association->Linger.fAssociationLingered = FALSE;
                }

            delete DceBinding;
            return(Association);
            }
        }

    // if asked to do short endpoint resolution, don't create new association
    if (InterfaceInfo)
        return NULL;

#if defined (RPC_GC_AUDIT)
    DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Creating association to: %S, %S, %S\n",
        GetCurrentProcessId(), GetCurrentProcessId(), DceBinding->InqRpcProtocolSequence(),
        DceBinding->InqNetworkAddress(), DceBinding->InqEndpoint());
#endif

    SequenceNumber = (SequenceNumber+1) % (0x7FFF);
    Association = new LRPC_CASSOCIATION(DceBinding,
                                        pClientAuthInfo,
                                        SequenceNumber,
                                        &Status);

    if ((Association != 0) && (Status == RPC_S_OK))
        {
        Association->AssociationDictKey = LrpcAssociationDict->Insert(Association);
        if (Association->AssociationDictKey == -1)
            {
            Association->DceBinding = 0;
            delete Association;
            return(0);
            }

        return(Association);
        }
    else
        {
        if (Association != 0)
            {
            Association->DceBinding = 0;
            delete Association;
            }
        return(0);
        }

    ASSERT(0);
    return(0);
}


void
ShutdownLrpcClient (
    )
/*++

Routine Description:

    This routine will get called when the process which is using this dll
    exits.  We will go through and notify any servers that we are going
    away.

--*/
{
    LRPC_CASSOCIATION * Association;
    DictionaryCursor cursor;

    if (LrpcAssociationDict != 0)
        {
        LrpcAssociationDict->Reset(cursor);
        while ((Association = LrpcAssociationDict->Next(cursor)) != 0)
            {
            Association->RemoveReference() ;
            }
        }
}


void
LRPC_CASSOCIATION::AbortAssociation (
    IN BOOL ServerAborted
    )
/*++

Routine Description:

    This association needs to be aborted because a the server side of the
    lpc port has been closed.

--*/
{
    LRPC_BINDING * Binding;
    LRPC_CCALL *CCall ;
    LRPC_CCONTEXT *SecurityContext;
    DictionaryCursor cursor;

    AssociationMutex.Request();

    LogEvent(SU_CASSOC, EV_ABORT, this, 0, ServerAborted, 1, 0);

    CloseLpcClientPort();

    Bindings.Reset(cursor);
    while ((Binding = Bindings.RemoveNext(cursor)) != 0)
        {
        // RemoveReference will destroy the binding if its 
        // ref count reaches 0
        Binding->RemoveReference();
        }

    SecurityContextDict.Reset(cursor);
    while (SecurityContext = SecurityContextDict.RemoveNext(cursor))
        {
        SecurityContext->Destroy();
        }

    int waitIterations = 8;
    if (ServerAborted)
        {
        ActiveCCalls.Reset(cursor);
        while ((CCall = ActiveCCalls.Next(cursor, TRUE)) != 0)
            {
            CCall->ServerAborted(&waitIterations);
            }
        }

    // nuke the free calls as well, because when we abort the association
    // some information in them will be stale
    FreeCCalls.Reset(cursor);
    while ((CCall = FreeCCalls.Next(cursor)) != 0)
        {
        delete CCall;
        }

    AssociationMutex.Clear();
}

void
LRPC_CASSOCIATION::CloseLpcClientPort (
    )
/*++

Routine Description:

    The LpcClientPort will be closed (and a close message sent to the server).

--*/
{
    NTSTATUS NtStatus;

    if (LpcClientPort != 0)
        {
        NtStatus = NtClose(LpcClientPort);

#if DBG

        if (!NT_SUCCESS(NtStatus))
            {
            PrintToDebugger("RPC : NtClose : %lx\n", NtStatus);
            }

#endif // DBG

        if (LpcReceivePort)
            {
            NtStatus = NtClose(LpcReceivePort) ;

#if DBG
            if (!NT_SUCCESS(NtStatus))
                {
                PrintToDebugger("RPC : NtClose : %lx\n", NtStatus);
                }

#endif

            ASSERT(NT_SUCCESS(NtStatus));
            }
        LpcClientPort = 0;
        LpcReceivePort = 0;
        BackConnectionCreated = 0;
        }
}


BOOL
LRPC_CASSOCIATION::IsSupportedAuthInfo(
    IN CLIENT_AUTH_INFO * ClientAuthInfo
    )
/*++

Routine Description:

    Check if this association supports the needed auth info.

Arguments:

    ClientAuthInfo - description

Return Value:
    TRUE: it does
    FALSE: it doesn't
--*/

{
    if (!ClientAuthInfo)
        {
        if (AssocAuthInfo.ImpersonationType == RPC_C_IMP_LEVEL_IMPERSONATE)
            {
            return TRUE ;
            }
        return FALSE;
        }

    if ((ClientAuthInfo->AuthenticationLevel == RPC_C_AUTHN_LEVEL_NONE
        && AssocAuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE)
        || (AssocAuthInfo.AuthenticationLevel == RPC_C_AUTHN_LEVEL_NONE
        && ClientAuthInfo->AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE))
        {
        return(FALSE);
        }

    ASSERT(ClientAuthInfo->AuthenticationService == RPC_C_AUTHN_WINNT);

    if (ClientAuthInfo->AuthorizationService
                != AssocAuthInfo.AuthorizationService)
        {
        return(FALSE);
        }

#if 0
    if (ClientAuthInfo->IdentityTracking != AssocAuthInfo.IdentityTracking)
        {
        return(FALSE);
        }
#endif

    if (ClientAuthInfo->ImpersonationType != AssocAuthInfo.ImpersonationType)
        {
        return (FALSE) ;
        }

    if (ClientAuthInfo->ServerPrincipalName)
        {
        if (AssocAuthInfo.ServerPrincipalName == 0
            || RpcpStringCompare(ClientAuthInfo->ServerPrincipalName,
                                 AssocAuthInfo.ServerPrincipalName) != 0)
            {
            return FALSE;
            }
        }

    return(TRUE);
}


LRPC_CCALL::LRPC_CCALL (
    IN OUT RPC_STATUS  *Status
    ) : CallMutex(Status), 
        SyncEvent(Status, 0),
        ResponseLockCount(0)
/*++

--*/
{
    ObjectType = LRPC_CCALL_TYPE;
    CurrentBindingHandle = 0;
    Association = 0;
    CallAbortedFlag = 0;
    LrpcMessage = 0;
    CachedLrpcMessage = 0;
    FreeCallKey = -1;
    CallId = (ULONG) -1;
    EEInfo = NULL;
}



LRPC_CCALL::~LRPC_CCALL (
    )
/*++

--*/
{
    if (LrpcMessage)
        {
        FreeMessage(LrpcMessage) ;
        }

    if (CachedLrpcMessage)
        {
        FreeMessage(CachedLrpcMessage) ;
        }

    if (CallId != (ULONG) -1)
        {
        // the association mutex is currently held
        Association->ActiveCCalls.Delete(ULongToPtr(CallId));
        }

    if (FreeCallKey != -1)
        {
        Association->FreeCCalls.Delete(FreeCallKey) ;
        }
}


RPC_STATUS
LRPC_CCALL::NegotiateTransferSyntax (
    IN OUT PRPC_MESSAGE Message
    )
{
    // just return the transfer syntax already negotiated in the binding
    Message->TransferSyntax = Binding->GetTransferSyntaxId();

    return RPC_S_OK;
}


RPC_STATUS
LRPC_CCALL::GetBuffer (
    IN OUT PRPC_MESSAGE Message,
    IN UUID *ObjectUuid
    )
/*++

Routine Description:

    We will allocate a buffer which will be used to either send a request
    or receive a response.

    ObjectUuid - Ignored

Arguments:

    Message - Supplies the length of the buffer that is needed.  The buffer
        will be returned.

Return Value:

    RPC_S_OK - A buffer has been successfully allocated.  It will be of at
        least the required length.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allocate that
        large a buffer.

--*/
{
    RPC_STATUS Status;

    SetObjectUuid(ObjectUuid);

    if (LrpcMessage == 0)
        {
        LrpcMessage = AllocateMessage();

        if (LrpcMessage == 0)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            goto Cleanup;
            }
        }

    if (PARTIAL(Message))
        {
        CurrentBufferLength = (Message->BufferLength < MINIMUM_PARTIAL_BUFFLEN)
            ?   MINIMUM_PARTIAL_BUFFLEN:Message->BufferLength ;

        Message->Buffer = RpcpFarAllocate(CurrentBufferLength);
        if (Message->Buffer == 0)
            {
            CurrentBufferLength = 0 ;
            Status = RPC_S_OUT_OF_MEMORY;
            goto Cleanup;
            }
        }
    else if (Message->BufferLength <= MAXIMUM_MESSAGE_BUFFER)
        {
        CurrentBufferLength = MAXIMUM_MESSAGE_BUFFER ;

        // Uncomment to check for 16 byte alignment on 64 bit
        // ASSERT(IsBufferAligned(LrpcMessage->Rpc.Buffer));

        Message->Buffer = LrpcMessage->Rpc.Buffer;
        LrpcMessage->Rpc.RpcHeader.Flags = LRPC_BUFFER_IMMEDIATE;
        LrpcMessage->LpcHeader.u2.ZeroInit = 0;
        LrpcMessage->LpcHeader.u1.s1.DataLength = (USHORT)
                (Align4(Message->BufferLength) + sizeof(LRPC_RPC_HEADER));

        return(RPC_S_OK);
        }
    else
        {
        CurrentBufferLength = Message->BufferLength ;
        Message->Buffer = RpcpFarAllocate(Message->BufferLength);
        if (Message->Buffer == 0)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            goto Cleanup;
            }
        }

    LrpcMessage->Rpc.RpcHeader.Flags = LRPC_BUFFER_REQUEST;
    LrpcMessage->Rpc.Request.CountDataEntries = 1;
    LrpcMessage->Rpc.Request.DataEntries[0].Base = PtrToMsgPtr(Message->Buffer);
    LrpcMessage->Rpc.Request.DataEntries[0].Size = Message->BufferLength;
    LrpcMessage->LpcHeader.CallbackId = 0;
    LrpcMessage->LpcHeader.u2.ZeroInit = 0;
    LrpcMessage->LpcHeader.u2.s2.DataInfoOffset = sizeof(PORT_MESSAGE)
                 + sizeof(LRPC_RPC_HEADER);
    LrpcMessage->LpcHeader.u1.s1.DataLength = sizeof(LRPC_RPC_HEADER)
                 + sizeof(PORT_DATA_INFORMATION);

    Status = RPC_S_OK;
Cleanup:
    if (Status != RPC_S_OK)
        {
        AbortCCall();
        ASSERT(Status == RPC_S_OUT_OF_MEMORY);
        }
    return(Status);
}


RPC_STATUS
LpcError (
    IN NTSTATUS NtStatus,
    IN BOOL fDNE
    )
{
    if (NtStatus == STATUS_NO_MEMORY)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }
    if (NtStatus == STATUS_INSUFFICIENT_RESOURCES)
        {
        return(RPC_S_OUT_OF_RESOURCES);
        }

    VALIDATE(NtStatus)
        {
        STATUS_INVALID_PORT_HANDLE,
        STATUS_INVALID_HANDLE,
        STATUS_PORT_DISCONNECTED,
        STATUS_LPC_REPLY_LOST
        } END_VALIDATE;

    if ((NtStatus != STATUS_LPC_REPLY_LOST) && fDNE)
        {
        return (RPC_S_CALL_FAILED_DNE) ;
        }

    return (RPC_S_CALL_FAILED);
}


RPC_STATUS
LRPC_CCALL::AsyncSend (
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:

    Send an async request. This request can be either partial or complete.

Arguments:

 Message - contains the request.

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/
{
    RPC_STATUS Status ;
    NTSTATUS NtStatus ;
    BOOL fRetVal ;
    BOOL Shutup ;
    ULONG_PTR fNonCausal;
    ULONG AsyncStateFlags;

    // If it is a small request, we send it here, otherwise, we
    // use the helper function.

    ASSERT(pAsync) ;
    Status = CurrentBindingHandle->InqTransportOption(
                                               RPC_C_OPT_BINDING_NONCAUSAL,
                                               &fNonCausal);
    ASSERT(Status == RPC_S_OK);

    if (fNonCausal == 0)
        {
        LrpcMessage->Rpc.RpcHeader.Flags  |= LRPC_CAUSAL;
        }

    if (LrpcMessage->Rpc.RpcHeader.Flags & LRPC_BUFFER_IMMEDIATE)
        {
        LrpcMessage->LpcHeader.u1.s1.TotalLength = sizeof(PORT_MESSAGE)
                    + LrpcMessage->LpcHeader.u1.s1.DataLength;
        LrpcMessage->Rpc.RpcHeader.MessageType = LRPC_MSG_REQUEST;
        LrpcMessage->Rpc.RpcHeader.ProcedureNumber = (unsigned short) Message->ProcNum;
        LrpcMessage->Rpc.RpcHeader.PresentContext = GetOnTheWirePresentationContext();
        if (CurrentSecurityContext)
            {
            LrpcMessage->Rpc.RpcHeader.SecurityContextId = CurrentSecurityContext->SecurityContextId;
            }
        else
            {
            LrpcMessage->Rpc.RpcHeader.SecurityContextId = -1;
            }

        ASSERT(CallId != (ULONG) -1);
        LrpcMessage->Rpc.RpcHeader.CallId = CallId ;

        if (UuidSpecified)
            {
            RpcpMemoryCopy(&(LrpcMessage->Rpc.RpcHeader.ObjectUuid),
                       &ObjectUuid, sizeof(UUID));
            LrpcMessage->Rpc.RpcHeader.Flags  |= LRPC_OBJECT_UUID;
            }

        NtStatus = NtRequestPort(Association->LpcClientPort,
                                 (PORT_MESSAGE *) LrpcMessage) ;

        if (NT_ERROR(NtStatus))
            {
            FreeCCall() ;
            return LpcError(NtStatus, TRUE) ;
            }

        Status = RPC_S_OK;
       }
    else
        {
        AsyncStateFlags = pAsync->Flags;
        Status = SendRequest(Message, &Shutup) ;

        if ((AsyncStateFlags & RPC_C_NOTIFY_ON_SEND_COMPLETE) && !Shutup
            && (Status == RPC_S_OK || Status == RPC_S_SEND_INCOMPLETE))
            {
            if (!IssueNotification(RpcSendComplete))
                {
                Status = RPC_S_OUT_OF_MEMORY ;
                }
            }
        }

    if (Status == RPC_S_OK)
        {
        CallMutex.Request();
        if (AsyncStatus == RPC_S_CALL_FAILED)
            {
            LogEvent(SU_CCALL, EV_ABORT, this, (PVOID) 44, 44, 1, 0);
            Status = RPC_S_CALL_FAILED;
            CallMutex.Clear();

            FreeCCall();
            }
        else
            {
            fSendComplete = 1;
            CallMutex.Clear();
            }
        }

    return(Status);
}


RPC_STATUS
LRPC_CCALL::AsyncReceive (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned int Size
    )
/*++

Routine Description:

Arguments:

 Message - Contains the request. On return, it will contain the received buffer
  and its length.
 Size - Requested size.

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/
{
    RPC_STATUS Status;
    int Extra = IsExtraMessage(Message);

    Message->DataRepresentation = 0x00 | 0x10 | 0x0000;

    CallMutex.Request();

    if (BufferComplete)
        {
        Status = GetCoalescedBuffer(Message, Extra);
        }
    else
        {
        if (PARTIAL(Message))
            {
            if (RcvBufferLength < Size)
                {
                if (NOTIFY(Message))
                    {
                    NeededLength = Size ;
                    }
                Status = RPC_S_ASYNC_CALL_PENDING;
                }
            else
                {
                Status = GetCoalescedBuffer(Message, Extra);
                }
            }
        else
            {
            Status = AsyncStatus;
            ASSERT(Status != RPC_S_OK);
            }
        }

    CallMutex.Clear();

    if (Status == RPC_S_OK
        || Status == RPC_S_ASYNC_CALL_PENDING)
        {
        return Status;
        }

    FreeCCall();

    return Status;
}


RPC_STATUS
LRPC_CCALL::CancelAsyncCall (
    IN BOOL fAbort
    )
/*++
Function Name:CancelAsyncCall

Parameters:
    fAbort - TRUE: the cancel is abortive, ie, the call completes immediately
                FALSE: a cancel PDU is sent to the server, the call doesn't complete
                until the server returns

Description:

Returns:
    RPC_S_OK: The call was successfully cancelled
    others - an error occured during the cancellation process
--*/
{
#if defined(BUILD_WOW6432)
    char LrpcCancelMessageBuffer[sizeof(LRPC_MESSAGE) + 8];
    LRPC_MESSAGE *LrpcCancelMessagePtr = (LRPC_MESSAGE *)AlignPtr8(LrpcCancelMessageBuffer);
#else
    LRPC_MESSAGE LrpcCancelMessageBuffer;
    LRPC_MESSAGE *LrpcCancelMessagePtr = &LrpcCancelMessageBuffer;
#endif
    NTSTATUS NtStatus;

    LogEvent(SU_CCALL, EV_ABORT, this, 0, fAbort, 1, 1);

    //
    // Notify the server that the call has been cancelled
    //
    LrpcCancelMessagePtr->LpcHeader.u1.s1.DataLength = sizeof(LRPC_RPC_MESSAGE)
            - sizeof(PORT_MESSAGE);
    LrpcCancelMessagePtr->LpcHeader.u1.s1.TotalLength = sizeof(LRPC_RPC_MESSAGE);
    LrpcCancelMessagePtr->LpcHeader.u2.ZeroInit = 0;

    ASSERT(CallId != (ULONG) -1);
    LrpcCancelMessagePtr->Rpc.RpcHeader.CallId = CallId;
    LrpcCancelMessagePtr->Rpc.RpcHeader.MessageType = LRPC_MSG_CANCEL;

    NtStatus = NtRequestPort(Association->LpcClientPort,
                                      (PORT_MESSAGE *) LrpcCancelMessagePtr) ;

    // sending the notification to the server is a best effort. We ignore the
    // result

    if (fAbort)
        {
        //
        // If the cancel was abortive, complete the call right away.
        //

        //
        // We indicate completion. When the app calls RpcAsyncCompleteCall
        // we will destroy the call. That is fine, even if the server
        // hasn't replied yet, because if the server sends a reply to
        // a call or an association that is not there, the client code
        // is protected, and will simply free the packet.
        //
        CallFailed(RPC_S_CALL_CANCELLED);
        }

    return RPC_S_OK;
}


void
LRPC_CCALL::ProcessResponse(
    IN LRPC_MESSAGE *LrpcResponse
    )
/*++

Routine Description:

    A buffer has just arrived, process it. If some other buffer is already
    processing buffers, simply queue it and go away. Otherwise, does
    the processing ourselves.

Arguments:

 Message - Details on the arrived message
--*/
{
    RPC_MESSAGE Message ;
    RPC_STATUS Status ;
    BOOL fRetVal = 0;
    BOOL fFault2;
    RPC_STATUS FaultStatus;
    THREAD *ThisThread;
    ExtendedErrorInfo *EEInfo;
    DelayedPipeAckData AckData;

    //
    // So that abort will not issue a notification
    //
    fSendComplete = 0;

    switch (LrpcResponse->Rpc.RpcHeader.MessageType)
        {
        case LRPC_MSG_FAULT:
            if (LrpcResponse->Fault.RpcHeader.Flags & LRPC_EEINFO_PRESENT)
                {
                ThisThread = RpcpGetThreadPointer();
                ASSERT(ThisThread);

                ASSERT(ThisThread->GetEEInfo() == NULL);
                Status = UnpickleEEInfo(LrpcResponse->Fault.Buffer,
                    LrpcResponse->Fault.LpcHeader.u1.s1.TotalLength 
                        - sizeof(LRPC_FAULT_MESSAGE) 
                        + sizeof(LrpcResponse->Fault.Buffer),
                    &EEInfo);
                if (Status == RPC_S_OK)
                    {
                    this->EEInfo = EEInfo;
                    }
                }

            if (pAsync == 0)
                {
                AsyncStatus = LrpcResponse->Fault.RpcStatus ;
                SyncEvent.Raise();
                }
            else
                {
                CallFailed(LrpcResponse->Fault.RpcStatus);
                }

            FreeMessage(LrpcResponse);
            return ;

        case LRPC_CLIENT_SEND_MORE:
            if (pAsync
                && (pAsync->Flags & RPC_C_NOTIFY_ON_SEND_COMPLETE))
                {
                if (!IssueNotification(RpcSendComplete))
                    {
                    CallFailed(RPC_S_OUT_OF_MEMORY);
                    }
                }
            FreeMessage(LrpcResponse);
            return;
        }

    ASSERT((LrpcResponse->Rpc.RpcHeader.MessageType == LRPC_MSG_FAULT2)
        || (LrpcResponse->Rpc.RpcHeader.MessageType == LRPC_MSG_RESPONSE));

    if (LrpcResponse->Rpc.RpcHeader.MessageType == LRPC_MSG_FAULT2)
        {
        fFault2 = TRUE;
        FaultStatus = LrpcResponse->Fault2.RpcStatus;
        }
    else
        fFault2 = FALSE;

    Message.RpcFlags = 0;
    AckData.DelayedAckPipeNeeded = FALSE;

    Status = LrpcMessageToRpcMessage(LrpcResponse,
                        &Message,
                        Association->LpcReceivePort,
                        TRUE,   // IsReplyFromBackConnection
                        &AckData
                        ) ;

    if (fFault2 && (Status == RPC_S_OK))
        {
        ThisThread = RpcpGetThreadPointer();
        ASSERT(ThisThread);

        ASSERT(ThisThread->GetEEInfo() == NULL);
        Status = UnpickleEEInfo((unsigned char *)Message.Buffer,
            Message.BufferLength,
            &EEInfo);
        if (Status == RPC_S_OK)
            {
            this->EEInfo = EEInfo;
            }
        // else
        // fall through the error case below, which will
        // handle the failure properly
        }

    if ((Status != RPC_S_OK) || fFault2)
        {
        // remember to send delayed ack if any
        if (AckData.DelayedAckPipeNeeded)
            {
            (void) SendPipeAck(Association->LpcReceivePort,
                LrpcResponse,
                AckData.CurrentStatus);

            if ((Status != RPC_S_OK) && (Message.Buffer))
                {
                RpcpFarFree(Message.Buffer);
                }

            FreeMessage(LrpcResponse) ;
            }

        if (fFault2)
            {
            AsyncStatus = FaultStatus;
            Status = FaultStatus;
            }
        else
            AsyncStatus = Status ;

        if (pAsync == 0)
            {
            SyncEvent.Raise();
            }
        else
            {
            CallFailed(Status);
            }

        return;
        }

    CallMutex.Request() ;

    // we have taken the mutex - now we can send the ack
    // The reason we need to wait for the mutex to be
    // taken before we send the delayed ack for pipes is
    // that once we send an ack, the server will send more
    // data and these can race with this thread. To be
    // safe, we need to take the mutex.
    if (AckData.DelayedAckPipeNeeded)
        {
        Status = SendPipeAck(Association->LpcReceivePort,
            LrpcResponse,
            AckData.CurrentStatus);

        FreeMessage(LrpcResponse) ;

        if (Status != RPC_S_OK)
            {
            CallMutex.Clear();

            if (Message.Buffer)
                {
                RpcpFarFree(Message.Buffer);
                }

            AsyncStatus = Status ;

            if (pAsync == 0)
                {
                SyncEvent.Raise();
                }
            else
                {
                CallFailed(Status);
                }

            return;
            }
        }

    if (COMPLETE(&Message))
        {
        BufferComplete = 1;
        }

    RcvBufferLength += Message.BufferLength ;
    if (Message.BufferLength)
        {
        if (BufferQueue.PutOnQueue(Message.Buffer,
                                   Message.BufferLength))
            {
            Status = RPC_S_OUT_OF_MEMORY ;
#if DBG
            PrintToDebugger("RPC: PutOnQueue failed\n") ;
#endif
            if (pAsync)
                {
                CallMutex.Clear();
                CallFailed(Status);
                return;
                }
            else
                {
                AsyncStatus = Status;
                }
            }
        }

    if (pAsync == 0)
        {
        CallMutex.Clear() ;

        SyncEvent.Raise();
        return;
        }

    if (BufferComplete)
        {
        AsyncStatus = RPC_S_OK;
        CallMutex.Clear() ;
        IssueNotification();
        }
    else
        {
        if (NeededLength > 0 && RcvBufferLength >= NeededLength)
            {
            CallMutex.Clear() ;
            IssueNotification(RpcReceiveComplete);
            }
        else
            {
            CallMutex.Clear() ;
            }
        }

}


RPC_STATUS
LRPC_CCALL::GetCoalescedBuffer (
    IN PRPC_MESSAGE Message,
    IN BOOL BufferValid
    )
/*++

Routine Description:

    Remove buffers from the queue and coalesce them into a single buffer.

Arguments:

 Message - on return this will contain the coalesced buffer, Message->BufferLength
  gives us the length of the coalesced buffer.
 BufferValid - Tells us if Message->Buffer is valid on entry.

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/
{
    void *NewBuffer, *Buffer ;
    char *Current ;
    unsigned int bufferlength ;
    unsigned int TotalLength ;
    LRPC_MESSAGE SendMore ;
    NTSTATUS NtStatus ;

    CallMutex.Request() ;

    if (RcvBufferLength == 0)
        {
        if (BufferComplete)
            {
            Message->RpcFlags |= RPC_BUFFER_COMPLETE ;
            }

        if (BufferValid == 0)
            {
            Message->Buffer = 0;
            Message->BufferLength = 0;
            }

        CallMutex.Clear();

        return RPC_S_OK;
        }

    BOOL fFillNewBuffer;

    if (BufferValid)
        {
        TotalLength = RcvBufferLength + Message->BufferLength ;

        NewBuffer = RpcpFarAllocate(TotalLength) ;
        if (NewBuffer == 0)
            {
            CallMutex.Clear() ;
            return RPC_S_OUT_OF_MEMORY;
            }

        RpcpMemoryCopy(NewBuffer, Message->Buffer, Message->BufferLength) ;
        Current = (char *) NewBuffer + Message->BufferLength ;
        fFillNewBuffer = 1;
        }
    else
        {
        TotalLength = RcvBufferLength ;

        if (BufferQueue.Size() == 1)
            {
            Buffer = BufferQueue.TakeOffQueue(&bufferlength);
            ASSERT(Buffer);

            NewBuffer = Buffer;
            ASSERT(TotalLength == bufferlength);

            fFillNewBuffer = 0;
            }
        else
            {
            NewBuffer = RpcpFarAllocate(TotalLength) ;
            if (NewBuffer == 0)
                {
                CallMutex.Clear() ;
                return RPC_S_OUT_OF_MEMORY;
                }
            Current = (char *) NewBuffer;

            fFillNewBuffer = 1;
            }
        }

    if (fFillNewBuffer)
        {
        while ((Buffer = BufferQueue.TakeOffQueue(&bufferlength)) != 0)
            {
            RpcpMemoryCopy(Current, Buffer, bufferlength) ;
            Current += bufferlength ;
            ActuallyFreeBuffer(Buffer);
            }
        }

    if (Message->Buffer)
        {
        ActuallyFreeBuffer(Message->Buffer);
        }

    Message->Buffer = NewBuffer ;
    Message->BufferLength = TotalLength ;

    RcvBufferLength = 0;

    if (BufferComplete)
        {
        Message->RpcFlags |= RPC_BUFFER_COMPLETE ;
        }
    else
        {
        if (Choked)
            {
            CallMutex.Clear() ;

            //
            // send a message to the server
            // to start sending data again
            //
            SendMore.Rpc.RpcHeader.MessageType = LRPC_SERVER_SEND_MORE;
            SendMore.LpcHeader.CallbackId = 0;
            SendMore.LpcHeader.MessageId =  0;
            SendMore.LpcHeader.u1.s1.DataLength =
                sizeof(LRPC_MESSAGE) - sizeof(PORT_MESSAGE);
            SendMore.LpcHeader.u1.s1.TotalLength = sizeof(LRPC_MESSAGE);
            SendMore.LpcHeader.u2.ZeroInit = 0;

            ASSERT(CallId != (ULONG) -1);
            SendMore.Rpc.RpcHeader.CallId = CallId ;

            NtStatus = NtRequestPort(Association->LpcClientPort,
                                     (PORT_MESSAGE *) &SendMore) ;

            if (!NT_SUCCESS(NtStatus))
                {
                return RPC_S_CALL_FAILED ;
                }

            return RPC_S_OK;
            }
        }

    CallMutex.Clear() ;

    return RPC_S_OK ;
}


void
LRPC_CCALL::ServerAborted (
    IN OUT int *waitIterations
    )
/*++

Routine Description:

    The server has died, we need the call needs to reflect that, and
    cleanup if possible.

--*/

{
    if (pAsync)
        {
        int i;

        for (;*waitIterations && AsyncStatus == RPC_S_ASYNC_CALL_PENDING; (*waitIterations)--)
            {
            Sleep(500);
            }

        LogEvent(SU_CCALL, EV_ABORT, this, (PVOID) 22, 22, 1, 0);
        CallMutex.Request();
        if (AsyncStatus == RPC_S_ASYNC_CALL_PENDING)
            {
            if (fSendComplete == 0)
                {
                AsyncStatus = RPC_S_CALL_FAILED;
                CallMutex.Clear();
                }
            else
                {
                CallMutex.Clear();
                CallFailed(RPC_S_CALL_FAILED);
                }
            }
        else 
            {
            CallMutex.Clear();
            }
        }
}


RPC_STATUS
LRPC_CCALL::SendReceive (
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:


Arguments:

    Message - Supplies the request and returns the response of a remote
        procedure call.

Return Value:

    RPC_S_OK - The remote procedure call completed successful.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to perform the
        remote procedure call.

    RPC_S_OUT_OF_RESOURCES - Insufficient resources are available to complete
        the remote procedure call.

--*/
{
    NTSTATUS NtStatus;
    RPC_STATUS ExceptionCode, Status;
    void * OriginalMessageBuffer;
    LRPC_MESSAGE *SavedLrpcMessage = 0;
    LRPC_MESSAGE *TmpLrpcMessage = 0;
    int ActiveCallSetupFlag = 0;
    void * TempBuffer;
    ExtendedErrorInfo *EEInfo;

    DebugClientCallInfo *ClientCallInfo;
    DebugCallTargetInfo *CallTargetInfo;
    CellTag ClientCallInfoCellTag;
    CellTag CallTargetInfoCellTag;
    THREAD *ThisThread = RpcpGetThreadPointer();
    BOOL fDebugInfoSet = FALSE;

    if (CallAbortedFlag != 0)
        {
        //
        // Don't know if it is safe to free the buffer here
        //
        return(RPC_S_CALL_FAILED_DNE);
        }

    ASSERT(ThisThread);

    // if either client side debugging is enabled or we are
    // calling on a thread that has a scall dispatched
    if ((IsClientSideDebugInfoEnabled() || ((ThisThread->Context) && IsServerSideDebugInfoEnabled())) && (RecursionCount == 0))
        {
        CStackAnsi AnsiString;
        RPC_CHAR *Endpoint;
        int EndpointLength;

        if (!IsClientSideDebugInfoEnabled())
            {
            Status = SetDebugClientCallInformation(&ClientCallInfo, &ClientCallInfoCellTag,
                &CallTargetInfo, &CallTargetInfoCellTag, Message, ThisThread->DebugCell,
                ThisThread->DebugCellTag);
            }
        else
            {
            Status = SetDebugClientCallInformation(&ClientCallInfo, &ClientCallInfoCellTag,
                &CallTargetInfo, &CallTargetInfoCellTag, Message, NULL, NULL);
            }

        if (Status != RPC_S_OK)
            goto Cleanup;

        ClientCallInfo->CallID = CallId;

        Endpoint = Association->InqEndpoint();
        EndpointLength = RpcpStringLength(Endpoint) + 1;
        *(AnsiString.GetPAnsiString()) = (char *)_alloca(EndpointLength);

        Status = AnsiString.Attach(Endpoint, EndpointLength, EndpointLength * 2);

        // effectively ignore failure in the conversion
        if (Status == RPC_S_OK)
            {
            strncpy(ClientCallInfo->Endpoint, AnsiString, sizeof(ClientCallInfo->Endpoint));
            }

        CallTargetInfo->ProtocolSequence = LRPC_TOWER_ID;
        CallTargetInfo->TargetServer[0] = 0;

        fDebugInfoSet = TRUE;
        }

    // NDR_DREP_ASCII | NDR_DREP_LITTLE_ENDIAN | NDR_DREP_IEEE

    Message->DataRepresentation = 0x00 | 0x10 | 0x0000;

    if (CallStack == 0)
        {
        if (UuidSpecified)
            {
            RpcpMemoryCopy(&(LrpcMessage->Rpc.RpcHeader.ObjectUuid),
                            &ObjectUuid, sizeof(UUID));
            LrpcMessage->Rpc.RpcHeader.Flags  |= LRPC_OBJECT_UUID;
            }

        }
    else
        {
        LrpcMessage->LpcHeader.u2.s2.Type = LPC_REQUEST;
        LrpcMessage->LpcHeader.ClientId = ClientIdToMsgClientId(ClientId);
        LrpcMessage->LpcHeader.MessageId = MessageId;
        LrpcMessage->LpcHeader.CallbackId = CallbackId;
        }

    LrpcMessage->LpcHeader.u1.s1.TotalLength = sizeof(PORT_MESSAGE)
                + LrpcMessage->LpcHeader.u1.s1.DataLength;

    LrpcMessage->Rpc.RpcHeader.MessageType = LRPC_MSG_REQUEST;

    LrpcMessage->Rpc.RpcHeader.ProcedureNumber = (unsigned short) Message->ProcNum;
    LrpcMessage->Rpc.RpcHeader.PresentContext = GetOnTheWirePresentationContext();
    if (CurrentSecurityContext)
        {
        LrpcMessage->Rpc.RpcHeader.SecurityContextId = CurrentSecurityContext->SecurityContextId;
        }
    else
        {
        LrpcMessage->Rpc.RpcHeader.SecurityContextId = -1;
        }

    TempBuffer = Message->Buffer;
    LrpcMessage->Rpc.RpcHeader.Flags |= LRPC_SYNC_CLIENT | LRPC_NON_PIPE;

    NtStatus = NtRequestWaitReplyPort(Association->LpcClientPort,
                                      (PORT_MESSAGE *) LrpcMessage,
                                      (PORT_MESSAGE *) LrpcMessage);

    if (NT_ERROR(NtStatus))
        {
        if (NtStatus == STATUS_NO_MEMORY)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            goto Cleanup;
            }
        if (NtStatus == STATUS_INSUFFICIENT_RESOURCES)
            {
            Status = RPC_S_OUT_OF_RESOURCES;
            goto Cleanup;
            }

        VALIDATE(NtStatus)
            {
            STATUS_INVALID_PORT_HANDLE,
            STATUS_INVALID_HANDLE,
            STATUS_PORT_DISCONNECTED,
            STATUS_LPC_REPLY_LOST
            } END_VALIDATE;

        Association->AbortAssociation();

        if ((CallStack == 0)
               && (NtStatus != STATUS_LPC_REPLY_LOST))
            {
            //
            // It's possible that the server stopped and has now restarted.
            // We'll try re-binding and only fail if the new call fails.
            //
            // We can only retry if we are SURE that the server did not
            // execute the request.

            if (RecursionCount > 3)
                {
                // Prevent an infinite loop when GetBuffer returns ok but
                // the SendReceive always fails.
                Status = RPC_S_CALL_FAILED_DNE;
                }
            else
                {
                Status = AutoRetryCall(Message, 
                                       TRUE     // fFromSendReceive
                                       );
                }
            }
        else
            {
            // In a callback and/or couldn't retry.
            Status = RPC_S_CALL_FAILED;
            }

Cleanup:
        if (fDebugInfoSet)
            {
            FreeCell(CallTargetInfo, &CallTargetInfoCellTag);
            FreeCell(ClientCallInfo, &ClientCallInfoCellTag);
            }
        ActuallyFreeBuffer(TempBuffer);
        AbortCCall();
        return Status;
        }

    // The message was sent and we got a reply okay.

    ActuallyFreeBuffer(Message->Buffer);

    for (;;)
        {
        if (LrpcMessage->Rpc.RpcHeader.MessageType == LRPC_MSG_FAULT)
            {
            if (LrpcMessage->Fault.RpcHeader.Flags & LRPC_EEINFO_PRESENT)
                {
                Status = UnpickleEEInfo(LrpcMessage->Fault.Buffer,
                    LrpcMessage->Fault.LpcHeader.u1.s1.TotalLength 
                        - sizeof(LRPC_FAULT_MESSAGE) 
                        + sizeof(LrpcMessage->Fault.Buffer),
                    &EEInfo);
                if (Status == RPC_S_OK)
                    {
                    RpcpSetEEInfoForThread(ThisThread, EEInfo);
                    }
                // else we just fall through and return an error code - 
                // this is best effort, so it's Ok
                }
            Status = LrpcMessage->Fault.RpcStatus;
            break;
            }

        if ((LrpcMessage->Rpc.RpcHeader.MessageType == LRPC_MSG_RESPONSE)
            || (LrpcMessage->Rpc.RpcHeader.MessageType == LRPC_MSG_FAULT2))
            {
            BOOL fFault2;
            RPC_STATUS FaultStatus;

            // remember if the message was fault2
            if (LrpcMessage->Rpc.RpcHeader.MessageType == LRPC_MSG_FAULT2)
                {
                fFault2 = TRUE;
                FaultStatus = LrpcMessage->Fault2.RpcStatus;
                }
            else
                fFault2 = FALSE;

            Status = LrpcMessageToRpcMessage(LrpcMessage,
                                             Message,
                                             Association->LpcClientPort,
                                             FALSE, // IsReplyFromBackConnection
                                             NULL   // StatusIfDelayedAck
                                             );

            if (fFault2)
                {
                if (Status == RPC_S_OK)
                    {
                    Status = UnpickleEEInfo((unsigned char *)Message->Buffer,
                        Message->BufferLength,
                        &EEInfo);
                    if (Status == RPC_S_OK)
                        {
                        RpcpSetEEInfoForThread(ThisThread, EEInfo);
                        }
                    // else
                    // fall through to restoring the original status
                    }

                // the status of the retrieval of
                // the extended error info is irrelevant - we
                // need to restore the original fault code
                Status = FaultStatus;
                }
            break;
            }

        ASSERT(LrpcMessage->Rpc.RpcHeader.MessageType
                        == LRPC_MSG_CALLBACK);

        CallStack += 1;

        Status = RPC_S_OK;
        if ((CallStack == 1)
            && (ActiveCallSetupFlag == 0))
            {
            ClientId = MsgClientIdToClientId(LrpcMessage->LpcHeader.ClientId);
            MessageId = LrpcMessage->LpcHeader.MessageId;
            CallbackId = LrpcMessage->LpcHeader.CallbackId;

            RecursiveCallsKey = CurrentBindingHandle->AddRecursiveCall(this);
            if (RecursiveCallsKey == -1)
                {
                Status = RPC_S_OUT_OF_MEMORY;
                }
            else
                {
                ActiveCallSetupFlag = 1;
                }
            }

        if (SavedLrpcMessage == 0)
            {
            // First callback, we may need to allocated a new LRPC_MESSAGE.
            if (CachedLrpcMessage == 0)
                {
                CachedLrpcMessage = AllocateMessage() ;
                }
            if (CachedLrpcMessage == 0)
                Status = RPC_S_OUT_OF_MEMORY;
            }

        if (Status == RPC_S_OK)
            {
            Status = LrpcMessageToRpcMessage(LrpcMessage,
                                             Message,
                                             Association->LpcClientPort,
                                             FALSE,     // IsReplyFromBackConnection
                                             NULL       // StatusIfDelayedAck
                                             );

            }

        if (Status != RPC_S_OK)
            {
            ActuallyFreeBuffer(Message->Buffer);

            LrpcMessage->Fault.RpcHeader.MessageType = LRPC_MSG_FAULT;
            LrpcMessage->Fault.RpcStatus = LrpcMapRpcStatus(Status);
            LrpcMessage->LpcHeader.u1.s1.DataLength =
                    sizeof(LRPC_FAULT_MESSAGE) - sizeof(PORT_MESSAGE);
            LrpcMessage->LpcHeader.u1.s1.TotalLength =
                    sizeof(LRPC_FAULT_MESSAGE);
            LrpcMessage->LpcHeader.ClientId = ClientIdToMsgClientId(ClientId);
            LrpcMessage->LpcHeader.MessageId = MessageId;
            LrpcMessage->LpcHeader.CallbackId = CallbackId;

            NtStatus = NtReplyWaitReplyPort(Association->LpcClientPort,
                                           (PORT_MESSAGE *) LrpcMessage);
            }
        else
            {
            PRPC_DISPATCH_TABLE DispatchTableToUse;

            OriginalMessageBuffer = Message->Buffer;
            Message->TransferSyntax = Binding->GetTransferSyntaxId();
            Message->ProcNum = LrpcMessage->Rpc.RpcHeader.ProcedureNumber;

            if (SavedLrpcMessage == 0)
                {
                // First callback
                ASSERT(CachedLrpcMessage != 0);
                SavedLrpcMessage = LrpcMessage;
                LrpcMessage = CachedLrpcMessage;
                CachedLrpcMessage = 0;
                }
            else
                {
                // >First callback, LrpcMessage and SavedLrpcMessages swap roles
                TmpLrpcMessage = SavedLrpcMessage;
                SavedLrpcMessage = LrpcMessage;
                LrpcMessage = TmpLrpcMessage;
                }

            Status = DispatchCallback((PRPC_DISPATCH_TABLE)
                        Binding->GetDispatchTable(),
                        Message,
                        &ExceptionCode);

            if (OriginalMessageBuffer != SavedLrpcMessage->Rpc.Buffer)
                {
                ActuallyFreeBuffer(OriginalMessageBuffer);
                }

            if (Status != RPC_S_OK)
                {
                VALIDATE(Status)
                    {
                    RPC_P_EXCEPTION_OCCURED,
                    RPC_S_PROCNUM_OUT_OF_RANGE
                    } END_VALIDATE;

                if (Status == RPC_P_EXCEPTION_OCCURED)
                    {
                    Status = LrpcMapRpcStatus(ExceptionCode);
                    }

                LrpcMessage->Fault.RpcStatus = Status;
                LrpcMessage->LpcHeader.u1.s1.DataLength =
                        sizeof(LRPC_FAULT_MESSAGE) - sizeof(PORT_MESSAGE);
                LrpcMessage->LpcHeader.u1.s1.TotalLength =
                        sizeof(LRPC_FAULT_MESSAGE);
                LrpcMessage->Fault.RpcHeader.MessageType = LRPC_MSG_FAULT;
                }
            else
                {
                LrpcMessage->Rpc.RpcHeader.MessageType =
                        LRPC_MSG_RESPONSE;

                if (LrpcMessage->Rpc.RpcHeader.Flags & LRPC_BUFFER_REQUEST)
                    {
                    Status = MakeServerCopyResponse();

                    if (Status != RPC_S_OK)
                        {
                        break;
                        }
                    }
                }

            LrpcMessage->LpcHeader.ClientId = ClientIdToMsgClientId(ClientId);
            LrpcMessage->LpcHeader.MessageId = MessageId;
            LrpcMessage->LpcHeader.CallbackId = CallbackId;
            LrpcMessage->LpcHeader.u1.s1.TotalLength =
                LrpcMessage->LpcHeader.u1.s1.DataLength + sizeof(PORT_MESSAGE);

            NtStatus = NtReplyWaitReplyPort(Association->LpcClientPort,
                                           (PORT_MESSAGE *) LrpcMessage);

            RpcpPurgeEEInfo();

            }
        CallStack -= 1;

        if (NT_ERROR(NtStatus))
            {
            if (NtStatus == STATUS_NO_MEMORY)
                {
                Status = RPC_S_OUT_OF_MEMORY;
                }
            else if (NtStatus == STATUS_INSUFFICIENT_RESOURCES)
                {
                Status = RPC_S_OUT_OF_RESOURCES;
                }
            else
                {
                Association->AbortAssociation();
                VALIDATE(NtStatus)
                    {
                    STATUS_INVALID_PORT_HANDLE,
                    STATUS_INVALID_HANDLE,
                    STATUS_PORT_DISCONNECTED,
                    STATUS_LPC_REPLY_LOST
                    } END_VALIDATE;
                Status = RPC_S_CALL_FAILED;
                }
            break;
            }
        }

    if (SavedLrpcMessage != 0)
        {
        if (CachedLrpcMessage != 0)
            {
            FreeMessage(CachedLrpcMessage) ;
            }

        CachedLrpcMessage = SavedLrpcMessage;
        }

    if (ActiveCallSetupFlag != 0)
        {
        CurrentBindingHandle->RemoveRecursiveCall(RecursiveCallsKey);
        }

    if (Status != RPC_S_OK)
        {
        if (CallStack == 0)
            {
            FreeCCall();
            }
        }

    if (fDebugInfoSet)
        {
        FreeCell(CallTargetInfo, &CallTargetInfoCellTag);
        FreeCell(ClientCallInfo, &ClientCallInfoCellTag);
        }

    return(Status);
}


RPC_STATUS
LRPC_CCALL::SendRequest (
    IN OUT PRPC_MESSAGE Message,
    OUT BOOL *Shutup
   )
/*++

Routine Description:

    Helper function used for sending async requests or pipe requests

Arguments:

    Message - request message

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory
 RPC_S_SEND_INCOMPLETE - we were unable to send the complete request.

--*/

{
    NTSTATUS NtStatus;
    RPC_STATUS ExceptionCode, Status;
    void * OriginalMessageBuffer;
    LRPC_MESSAGE *TmpLrpcMessage = 0;
    void * TempBuffer;
    LRPC_MESSAGE *LrpcReplyMessage ;
    int RemainingLength = 0;

    ASSERT((LrpcMessage->Rpc.RpcHeader.Flags
                & LRPC_BUFFER_IMMEDIATE)  == 0) ;
    *Shutup = 0;

    if (CallAbortedFlag != 0)
        {
        return(RPC_S_CALL_FAILED_DNE);
        }

    if (CallStack > 0)
        {
        return (RPC_S_CALL_FAILED);
        }

    if (PARTIAL(Message))
        {
        if (Message->BufferLength < MINIMUM_PARTIAL_BUFFLEN)
            {
            return (RPC_S_SEND_INCOMPLETE);
            }

        LrpcMessage->Rpc.RpcHeader.Flags |= LRPC_BUFFER_PARTIAL ;
        if (NOT_MULTIPLE_OF_EIGHT(Message->BufferLength))
            {
            RemainingLength = Message->BufferLength & LOW_BITS ;
            Message->BufferLength &= ~LOW_BITS ;
            }
        }

    // NDR_DREP_ASCII | NDR_DREP_LITTLE_ENDIAN | NDR_DREP_IEEE
    Message->DataRepresentation = 0x00 | 0x10 | 0x0000;

    ASSERT(CallId != (ULONG) -1);
    LrpcMessage->Rpc.RpcHeader.CallId = CallId ;

    if (FirstFrag)
        {
        LrpcMessage->Rpc.RpcHeader.MessageType = LRPC_MSG_REQUEST;
        }
    else
        {
        LrpcMessage->Rpc.RpcHeader.MessageType = LRPC_PARTIAL_REQUEST;
        }

    LrpcMessage->LpcHeader.u1.s1.TotalLength =
        sizeof(PORT_MESSAGE) + LrpcMessage->LpcHeader.u1.s1.DataLength;

    LrpcMessage->Rpc.Request.DataEntries[0].Size = Message->BufferLength;
    LrpcMessage->Rpc.RpcHeader.ProcedureNumber = (unsigned short) Message->ProcNum;
    LrpcMessage->Rpc.RpcHeader.PresentContext = GetOnTheWirePresentationContext();
    if (CurrentSecurityContext)
        {
        LrpcMessage->Rpc.RpcHeader.SecurityContextId = CurrentSecurityContext->SecurityContextId;
        }
    else
        {
        LrpcMessage->Rpc.RpcHeader.SecurityContextId = -1;
        }

    if (UuidSpecified)
        {
        ASSERT(CallStack == 0) ;
        RpcpMemoryCopy(&(LrpcMessage->Rpc.RpcHeader.ObjectUuid),
               &ObjectUuid, sizeof(UUID));
        LrpcMessage->Rpc.RpcHeader.Flags  |= LRPC_OBJECT_UUID;
        }

    NtStatus = NtRequestWaitReplyPort(Association->LpcClientPort,
                                     (PORT_MESSAGE *) LrpcMessage,
                                     (PORT_MESSAGE *) LrpcMessage);

    if (NT_ERROR(NtStatus))
        {
        TempBuffer = Message->Buffer;

        if (NtStatus == STATUS_NO_MEMORY)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            goto Cleanup;
            }
        if (NtStatus == STATUS_INSUFFICIENT_RESOURCES)
            {
            Status = RPC_S_OUT_OF_RESOURCES;
            goto Cleanup;
            }

        VALIDATE(NtStatus)
            {
            STATUS_INVALID_PORT_HANDLE,
            STATUS_INVALID_HANDLE,
            STATUS_PORT_DISCONNECTED,
            STATUS_LPC_REPLY_LOST
            } END_VALIDATE;

        if (pAsync)
            {
            ASSERT(RecursionCount == 0);

            if (NtStatus != STATUS_LPC_REPLY_LOST)
                {
                Status = RPC_S_CALL_FAILED_DNE;
                }
            else
                {
                Status = RPC_S_CALL_FAILED;
                }

            goto Cleanup;
            }

        Association->AbortAssociation();

        if ((NtStatus != STATUS_LPC_REPLY_LOST) && FirstFrag)
            {
            ASSERT(CallStack == 0) ;

            //
            // It's possible that the server stopped and has now restarted.
            // We'll try re-binding and only fail if the new call fails.
            //
            // We can only retry if we are SURE that the server did not
            // execute the request.

            if (RecursionCount > 3)
                {
                // Prevent an infinite loop when GetBuffer returns ok but
                // the SendReceive always fails.
                Status = RPC_S_CALL_FAILED_DNE;
                }
            else
                {
                Status = AutoRetryCall(Message, 
                                       FALSE     // fFromSendReceive
                                       );
                }
            }
        else
            {
            // In a callback and/or couldn't retry.
            Status = RPC_S_CALL_FAILED;
            }

Cleanup:
        ActuallyFreeBuffer(TempBuffer);
        AbortCCall();
        return Status;
        }
    else
        {
        FirstFrag = 0;
        }

    if (LrpcMessage->Rpc.RpcHeader.MessageType == LRPC_MSG_ACK)
        {
        *Shutup  = LrpcMessage->Ack.Shutup ;

        if (PARTIAL(Message))
            {
            if (LrpcMessage->Ack.RpcStatus == RPC_S_OK)
                {
                if (RemainingLength)
                    {
                    RpcpMemoryMove(Message->Buffer,
                                   (char  *) Message->Buffer + Message->BufferLength,
                                    RemainingLength) ;

                    Message->BufferLength = RemainingLength ;
                    return (RPC_S_SEND_INCOMPLETE) ;
                    }

                return RPC_S_OK;
                }
            }

        ActuallyFreeBuffer(Message->Buffer);
        Message->Buffer = 0;

        return LrpcMessage->Ack.RpcStatus ;
        }

    ActuallyFreeBuffer(Message->Buffer);
    Message->Buffer = 0;

    if (LrpcMessage->Rpc.RpcHeader.MessageType == LRPC_MSG_RESPONSE)
        {
        ASSERT(!PARTIAL(Message)) ;

        CurrentBufferLength = 0;

        Status = LrpcMessageToRpcMessage(LrpcMessage,
                                         Message,
                                         Association->LpcClientPort,
                                         FALSE,     // IsReplyFromBackConnection
                                         NULL       // StatusIfDelayedAck
                                         );

        if (Status == RPC_S_OK
            && COMPLETE(Message))
            {
            BufferComplete = 1;
            }

        Message->RpcFlags = 0;
        // we have no out pipes
        ASSERT(Status != RPC_S_OK || BufferComplete) ;
        }
    else  if (LrpcMessage->Rpc.RpcHeader.MessageType == LRPC_MSG_FAULT)
        {
        CurrentBufferLength = 0;
        Status = LrpcMessage->Fault.RpcStatus;
        }

    if (Status != RPC_S_OK)
        {
        ASSERT(CallStack == 0) ;
        FreeCCall();
        }

    return Status ;
}


RPC_STATUS 
LRPC_CCALL::AutoRetryCall (
    IN OUT PRPC_MESSAGE Message, 
    BOOL fFromSendReceive
    )
{
    RPC_STATUS Status;
    void *OldBuffer;
    UUID *UuidToUse;
    LRPC_CCALL *NewCall;

    // any failure after this is unrelated
    RpcpPurgeEEInfo();

    OldBuffer = Message->Buffer;
    Message->Handle = (RPC_BINDING_HANDLE) CurrentBindingHandle;

    if (UuidSpecified)
        {
        UuidToUse = &ObjectUuid;
        }
    else
        {
        UuidToUse = 0;
        }

    Status = CurrentBindingHandle->NegotiateTransferSyntax(Message);
    if (Status != RPC_S_OK)
        goto CleanupAndReturn;

    NewCall = ((LRPC_CCALL *)(Message->Handle));
    Status = NewCall->GetBuffer(Message, UuidToUse);
    if (Status != RPC_S_OK)
        goto CleanupAndReturn;

    ASSERT(Message->Buffer != OldBuffer);

    RpcpMemoryCopy(Message->Buffer, OldBuffer,
                   Message->BufferLength);

    // This CCALL should be freed,
    // a new one was allocated in NegotiateTransferSyntax and is now being used.

    ASSERT(NewCall != this);

    NewCall->SetRecursionCount(RecursionCount + 1);

    if (fFromSendReceive)
        Status = NewCall->SendReceive(Message);
    else
        Status = NewCall->Send(Message);

    // the caller has remembered the old buffer and call object,
    // and will clean them up regardless of what we return - our
    // job is simply to allocate a new call and buffer, and stick
    // them in the Message

CleanupAndReturn:
    if (Status == RPC_S_SERVER_UNAVAILABLE)
        {
        // Since we're retrying, if the server has gone missing,
        // it just means that the call failed.

        Status = RPC_S_CALL_FAILED_DNE;
        }

    return(Status);
}

RPC_STATUS
LRPC_CCALL::Send (
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:
    This rountine is used by pipes to send partila data...

Arguments:

    Message - Supplies the request and returns the response of a remote
        procedure call.

Return Value:

    RPC_S_OK - The remote procedure call completed successful.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to perform the
        remote procedure call.

    RPC_S_OUT_OF_RESOURCES - Insufficient resources are available to complete
        the remote procedure call.
--*/
{
    RPC_STATUS Status ;
    BOOL Shutup ;

    Status = SendRequest(Message, &Shutup) ;

    return(Status);
}



RPC_STATUS
LRPC_CCALL::Receive (
    IN PRPC_MESSAGE Message,
    IN unsigned int Size
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/

{
    int size = 0 ;
    int BufferLength ;
    int RequestedLength ;
    RPC_STATUS Status ;
    int ActualBufferLength = 0;
    int Extra = IsExtraMessage(Message) ;

    if (BufferComplete
        && RcvBufferLength == 0)
        {
        Message->RpcFlags |= RPC_BUFFER_COMPLETE ;
        return (RPC_S_OK) ;
        }

    // If you get here, it means that you have out pipe data.

    //
    // allocate a buffer big enough to hold the out data:
    // if you have a partial receive, you can allocate the buffer up
    // front and start receive data.
    //
    if (PARTIAL(Message))
        {
        if (Extra)
            {
            ActualBufferLength = Message->BufferLength ;
            BufferLength = Message->BufferLength+Size ;
            }
        else
            {
            BufferLength = Size ;
            }
        }
    else
        {
        if (Extra)
            {
            ActualBufferLength = Message->BufferLength ;
            BufferLength = Message->BufferLength + MINIMUM_PARTIAL_BUFFLEN ;
            }
        else
            {
            BufferLength = MINIMUM_PARTIAL_BUFFLEN ;
            }
        }

    Status = GetBufferDo(Message, BufferLength, Extra) ;
    if (Status != RPC_S_OK)
        {
        FreeCCall();
        return Status ;
        }
    RequestedLength = Message->BufferLength - ActualBufferLength;

    while (!BufferComplete
           && (!PARTIAL(Message) || (RcvBufferLength < Size)))
        {
        if (SyncEvent.Wait() == WAIT_FAILED)
            {
            return RPC_S_CALL_FAILED;
            }
        }

    return GetCoalescedBuffer(Message, Extra);
}


void
LRPC_CCALL::FreeBuffer (
    IN PRPC_MESSAGE Message
    )
/*++

Routine Description:

    We will free the supplied buffer.

Arguments:

    Message - Supplies the buffer to be freed.

--*/
{
    ActuallyFreeBuffer(Message->Buffer);

    if (CallStack == 0)
        {
        FreeCCall();
        }
}

void
LRPC_CCALL::FreePipeBuffer (
    IN PRPC_MESSAGE Message
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/

{
    RpcpFarFree(Message->Buffer) ;
}

RPC_STATUS
LRPC_CCALL::GetBufferDo (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned long NewSize,
    IN int fDataValid
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/

{
    void *NewBuffer ;
    int SizeToAlloc ;

    if (NewSize < CurrentBufferLength)
        {
        Message->BufferLength = NewSize ;
        }
    else
        {
        SizeToAlloc = (NewSize < MINIMUM_PARTIAL_BUFFLEN) ?
                        MINIMUM_PARTIAL_BUFFLEN:NewSize ;

        NewBuffer = RpcpFarAllocate(SizeToAlloc) ;
        if (NewBuffer == 0)
            {
            RpcpFarFree(Message->Buffer) ;
            CurrentBufferLength = 0;
            Message->BufferLength = 0;
            return RPC_S_OUT_OF_MEMORY ;
            }

        if (fDataValid && Message->BufferLength > 0)
            {
            RpcpMemoryCopy(NewBuffer,
                           Message->Buffer,
                           Message->BufferLength) ;
            }

        RpcpFarFree(Message->Buffer) ;
        Message->Buffer = NewBuffer ;
        Message->BufferLength = NewSize ;
        CurrentBufferLength = SizeToAlloc ;
        }

    return RPC_S_OK ;
}

RPC_STATUS
LRPC_CCALL::ReallocPipeBuffer (
    IN PRPC_MESSAGE Message,
    IN unsigned int NewSize
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/

{
    unsigned int SizeToAlloc ;
    void *TempBuffer ;

    if (LrpcMessage == 0)
        {
        LrpcMessage = AllocateMessage();
        if (LrpcMessage == 0)
            {
            return(RPC_S_OUT_OF_MEMORY);
            }
        }

    if (GetBufferDo(Message, NewSize, 1) != RPC_S_OK)
        return RPC_S_OUT_OF_MEMORY ;

    Message->BufferLength = NewSize ;

    LrpcMessage->Rpc.RpcHeader.Flags = LRPC_BUFFER_REQUEST;
    LrpcMessage->Rpc.Request.CountDataEntries = 1;
    LrpcMessage->Rpc.Request.DataEntries[0].Base = PtrToMsgPtr(Message->Buffer);
    LrpcMessage->Rpc.Request.DataEntries[0].Size = Message->BufferLength;
    LrpcMessage->LpcHeader.CallbackId = 0;
    LrpcMessage->LpcHeader.u2.ZeroInit = 0;
    LrpcMessage->LpcHeader.u2.s2.DataInfoOffset = sizeof(PORT_MESSAGE)
                 + sizeof(LRPC_RPC_HEADER);
    LrpcMessage->LpcHeader.u1.s1.DataLength = sizeof(LRPC_RPC_HEADER)
                 + sizeof(PORT_DATA_INFORMATION);

    return (RPC_S_OK) ;
}


void
LRPC_CCALL::AbortCCall (
    )
/*++

Routine Description:

    This client call has failed, so we need to abort it.  We may called
    while nested in one or more callbacks.

--*/
{
    LRPC_BINDING_HANDLE * BindingHandle;

    CallAbortedFlag = 1;

    if (CallStack == 0)
        {
        ASSERT(CurrentBindingHandle != 0);

        BindingHandle = CurrentBindingHandle;
        CurrentBindingHandle = 0;
        BindingHandle->FreeCCall(this);
        }
}


inline RPC_STATUS
LRPC_CCALL::LrpcMessageToRpcMessage (
    IN LRPC_MESSAGE *LrpcResponse,
    OUT RPC_MESSAGE * Message,
    IN HANDLE              LpcPort,
    IN BOOL IsReplyFromBackConnection OPTIONAL,
    OUT DelayedPipeAckData *AckData OPTIONAL
    )
/*++

Routine Description:

    We will convert from an LRPC_MESSAGE representation of a buffer (and
    its length) to an RPC_MESSAGE representation.

Arguments:

    LrpcResponse - the response we received from the server

    RpcMessage - Returns the RPC_MESSAGE representation.

    LpcPort - the association port on which we send data to the server

    IsReplyFromBackConnection - non-zero if the reply is from back connection

    AckData - if non-NULL, and the received data are pipe data, an 
        acknowledgement to a pipe response will be delayed, the current 
        status will be placed here, and it will be indicated the ack was
        delayed. Also, if non-NULL, the caller must set 
        AckData->DelayedAckPipeNeeded to FALSE.
        If NULL, any acknowledgement will be sent immediately.

--*/
{
    NTSTATUS NtStatus;
    SIZE_T NumberOfBytesRead;
#if defined(BUILD_WOW6432)
    char CopyMessageBuffer[sizeof(LRPC_COPY_MESSAGE) + 8];
    LRPC_COPY_MESSAGE *CopyMessagePtr = (LRPC_COPY_MESSAGE *) AlignPtr8(CopyMessageBuffer);
#else
    LRPC_COPY_MESSAGE CopyMessageBuffer;
    LRPC_COPY_MESSAGE *CopyMessagePtr = &CopyMessageBuffer;
#endif
    RPC_STATUS Status = RPC_S_OK;
    RPC_STATUS Status2;
    BOOL fPartialResponse;

    if (ARGUMENT_PRESENT(AckData))
        {
        ASSERT(AckData->DelayedAckPipeNeeded == FALSE);
        }

   if(LrpcResponse->Rpc.RpcHeader.Flags & LRPC_BUFFER_IMMEDIATE)
        {
        Message->Buffer = LrpcResponse->Rpc.Buffer;

        ASSERT(LrpcResponse->LpcHeader.u1.s1.DataLength
                      >= sizeof(LRPC_RPC_HEADER));

        Message->BufferLength =
                      (unsigned int) LrpcResponse->LpcHeader.u1.s1.DataLength
                      - sizeof(LRPC_RPC_HEADER);

        if ((LrpcResponse->Rpc.RpcHeader.Flags & LRPC_BUFFER_PARTIAL) == 0)
            {
            Message->RpcFlags |= RPC_BUFFER_COMPLETE ;
            }

        if (IsReplyFromBackConnection)
            {
            LpcReplyMessage = LrpcResponse ;
            }
        }
    else if (LrpcResponse->Rpc.RpcHeader.Flags & LRPC_BUFFER_SERVER)
        {
        if (IsReplyFromBackConnection == 0)
            {
            UINT BufferLength;
            LPC_PVOID ServerBuffer;

            ASSERT(LrpcMessage == LrpcResponse);
            BufferLength = LrpcResponse->Rpc.Server.Length;
            ServerBuffer = LrpcResponse->Rpc.Server.Buffer;
            ASSERT(BufferLength < 0x80000000);
            Message->BufferLength = BufferLength;

            Message->RpcFlags |= RPC_BUFFER_COMPLETE ;
            Message->Buffer = RpcpFarAllocate(BufferLength) ;

            CopyMessagePtr->LpcHeader.u2.ZeroInit = 0;
            CopyMessagePtr->Server.Buffer = ServerBuffer;
            CopyMessagePtr->Server.Length = BufferLength;

            if (Message->Buffer == 0)
                {
                CopyMessagePtr->RpcStatus = RPC_S_OUT_OF_MEMORY;
                }
            else
                {
                CopyMessagePtr->RpcStatus = RPC_S_OK;
                CopyMessagePtr->Request.CountDataEntries = 1;
                CopyMessagePtr->Request.DataEntries[0].Base = PtrToMsgPtr(Message->Buffer);
                CopyMessagePtr->Request.DataEntries[0].Size = Message->BufferLength ;
                CopyMessagePtr->LpcHeader.u2.s2.DataInfoOffset =
                        sizeof(PORT_MESSAGE) + sizeof(LRPC_RPC_HEADER);
                }
            CopyMessagePtr->LpcHeader.CallbackId = 0;
            CopyMessagePtr->RpcHeader.Flags = LRPC_SYNC_CLIENT ;
            CopyMessagePtr->LpcHeader.u1.s1.DataLength =
                        sizeof(LRPC_COPY_MESSAGE) - sizeof(PORT_MESSAGE);
            CopyMessagePtr->LpcHeader.u1.s1.TotalLength =
                        sizeof(LRPC_COPY_MESSAGE);
            CopyMessagePtr->RpcHeader.MessageType = LRPC_MSG_COPY;
            CopyMessagePtr->IsPartial = 0 ;

            NtStatus = NtRequestWaitReplyPort(Association->LpcClientPort,
                                             (PORT_MESSAGE *) CopyMessagePtr,
                                             (PORT_MESSAGE *) CopyMessagePtr);
            if ((NT_ERROR(NtStatus))
                || (CopyMessagePtr->RpcStatus != RPC_S_OK))
                {
                RpcpFarFree(Message->Buffer);
                return(RPC_S_OUT_OF_MEMORY);
                }
            }
        else
            {
            fPartialResponse = FALSE;

            if (LrpcResponse->Rpc.RpcHeader.Flags & LRPC_BUFFER_PARTIAL)
                {
                fPartialResponse = TRUE;

                CallMutex.Request() ;
                if ((RcvBufferLength >= LRPC_THRESHOLD_SIZE))
                    {
                    Choked = 1;
                    }
                CallMutex.Clear() ;
                }
            else
                {
                Message->RpcFlags |= RPC_BUFFER_COMPLETE ;
                }

            Message->BufferLength = (unsigned int)
                                LrpcResponse->Rpc.Request.DataEntries[0].Size ;

            Message->Buffer = RpcpFarAllocate(
                    Message->BufferLength);

            if (Message->Buffer != NULL)
                {
                NtStatus = NtReadRequestData(LpcPort,
                                            (PORT_MESSAGE*) LrpcResponse,
                                            0,
                                            Message->Buffer,
                                            Message->BufferLength,
                                            &NumberOfBytesRead) ;

                if (NT_ERROR(NtStatus))
                    {
#if DBG
                    PrintToDebugger("LRPC:  NtReadRequestData failed: %x\n", NtStatus) ;
#endif
                    Status = RPC_S_OUT_OF_MEMORY;
                    }
                else
                    {
                    ASSERT(Message->BufferLength == NumberOfBytesRead);
                    }
                }
            else
                {
                Status = RPC_S_OUT_OF_MEMORY;
                }

            if (ARGUMENT_PRESENT(AckData) && fPartialResponse && (Status == RPC_S_OK))
                {
                // if pipe and delayed ack was asked for, and
                // moreover the operation didn't fail
                // just store the relevant data in the caller
                // supplied data structure
                AckData->DelayedAckPipeNeeded = TRUE;
                AckData->CurrentStatus = Status;
                }
            else
                {
                Status2 = SendPipeAck(LpcPort, 
                    LrpcResponse,
                    Status);

                FreeMessage(LrpcResponse) ;

                // if either operation failed, fail the whole function
                // if both operations failed, the first one is considered
                // the original failure and the error code from it is
                // preserved
                if ((Status == RPC_S_OK) && (Status2 != RPC_S_OK))
                    Status = Status2;
                }

            if ((Status != RPC_S_OK) && (Message->Buffer))
                {
                RpcpFarFree(Message->Buffer);
                }
            }
        }
    else
        {
        ASSERT((LrpcResponse->Rpc.RpcHeader.Flags & LRPC_BUFFER_IMMEDIATE)
               || (LrpcResponse->Rpc.RpcHeader.Flags & LRPC_BUFFER_SERVER));
        }

    return(Status);
}

RPC_STATUS
LRPC_CCALL::SendPipeAck (
    IN HANDLE LpcPort,
    IN LRPC_MESSAGE *LrpcResponse,
    IN RPC_STATUS CurrentStatus
    )
/*++

Routine Description:

    Sends an acknowledgement to the server.

Arguments:

    LpcPort - the port to send the ack to.

    LrpcResponse - the response that we received from the server

    CurrentStatus - the status up to the moment. It will
        be sent to the server.

Return Value:

    The result of the operation. RPC_S_OK for success
        or RPC_S_* for error.

--*/
{
    unsigned char MessageType;
    RPC_STATUS RpcStatus = RPC_S_OK;
    NTSTATUS NtStatus;

    MessageType = LrpcResponse->Rpc.RpcHeader.MessageType ;

    LrpcResponse->Ack.MessageType = LRPC_MSG_ACK ;
    LrpcResponse->Ack.Shutup = (short) Choked ;
    LrpcResponse->Ack.RpcStatus = CurrentStatus;
    LrpcResponse->LpcHeader.u1.s1.DataLength = sizeof(LRPC_ACK_MESSAGE)
               - sizeof(PORT_MESSAGE) ;
    LrpcResponse->LpcHeader.u1.s1.TotalLength =
               sizeof(LRPC_ACK_MESSAGE) ;

    // setup the reply message
    NtStatus = NtReplyPort(LpcPort,
                          (PORT_MESSAGE *) LrpcResponse) ;

    LrpcResponse->Rpc.RpcHeader.MessageType = MessageType ;

    if (NT_ERROR(NtStatus))
        {
#if DBG
        PrintToDebugger("LRPC:  NtReplyPort failed: %x\n", NtStatus) ;
#endif
        RpcStatus = RPC_S_OUT_OF_MEMORY;
        }

    return RpcStatus;
}

BOOL
LRPC_CCALL::TryWaitForCallToBecomeUnlocked (
    BOOL *fUnlocked    
    )
/*++

Routine Description:

    Checks if a call is unlocked. If the lock count
    becomes 0, or if the lock count becomes 1 and this thread
    is the last one with a lock, the call is considered unlocked.
    In this case *fUnlocked is set to TRUE.  Otherwise it is set to FALSE.

Return Value:

    If fUnlocked == TRUE:

        TRUE - the call has 1 outstanding lock count and the 
            LastProcessResponseTID is our TID. This means that we're
            called from ProcessResponse (indirectly - through COM as
            they complete the call on the thread that issues the
            notification). If we return TRUE, we have already taken
            the lock down and the caller should not remove any locks
        FALSE - the call has no outstanding locks

    If fUnlocked == FALSE

        Undefined

--*/
{
    ULONG CurrentThreadId = GetCurrentThreadId();

    if (ResponseLockCount.GetInteger() == 0)
        {
        *fUnlocked = TRUE;
        return FALSE;
        }
    else if ((ResponseLockCount.GetInteger() == 1)
        && (LastProcessResponseTID == CurrentThreadId))
        {
        // If our caller has an outstanding lock and we free the call
        // with the lock held, zero out the count on their behalf. 
        // In our caller we will notify the ultimate caller so that it 
        // doesn't double take away the lock. 
        ResponseLockCount.SetInteger(0);

        // the only outstanding lock is by us in our caller - process
        // response. Indicate to the caller that only our lock is
        // active and it has been taken down.
        *fUnlocked = TRUE;
        return TRUE;
        }

    *fUnlocked = FALSE;
    // The return value is meaningless.  Arbitrarily, return FALSE.
    return FALSE;
}


void
LRPC_CCALL::FreeCCall (
    )
/*++

Routine Description:

    We are done with this client call.  We need to notify the binding
    handle we are done.

--*/
{
    LRPC_BINDING_HANDLE * BindingHandle;
    THREAD *Thread;

    ASSERT(CurrentBindingHandle != 0);

    BindingHandle = CurrentBindingHandle;
    CurrentBindingHandle = 0;
    if (CurrentSecurityContext)
        {
        CurrentSecurityContext->RemoveReference();
        CurrentSecurityContext = 0;
        }

    // if async, and there is EEInfo,
    // transfer the EEInfo from the call to
    // the thread
    if (EEInfo)
        {
        Thread = RpcpGetThreadPointer();
        RpcpPurgeEEInfoFromThreadIfNecessary(Thread);
        Thread->SetEEInfo(EEInfo);
        EEInfo = NULL;
        }
    BindingHandle->FreeCCall(this);
}


void
LRPC_CCALL::ActuallyFreeBuffer (
    IN void * Buffer
    )
/*++

Routine Description:

    Actually free a message buffer.

Arguments:

    Buffer - Supplies the message buffer to be freed.

--*/
{
    if (LpcReplyMessage && (Buffer == LpcReplyMessage->Rpc.Buffer))
        {
        FreeMessage(LpcReplyMessage) ;
        LpcReplyMessage = 0;
        }
    else
        {
        if ((Buffer !=  LrpcMessage->Rpc.Buffer)
            && ((CachedLrpcMessage == 0)
                || (Buffer != CachedLrpcMessage->Rpc.Buffer)))
            {
            RpcpFarFree(Buffer);
            }
        }
}


RPC_STATUS
LRPC_CCALL::MakeServerCopyResponse (
    )
/*++

Routine Description:

    NtReadRequestData only works if the client has made a request.  The client
    wants to send a large buffer back as a response.  We need to make a request
    to the server so that it will copy the data.

Return Value:

    RPC_S_OK - The server successfully copied the data.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete the
        operation.

--*/
{
    LRPC_PUSH_MESSAGE LrpcPushMessage;
    NTSTATUS NtStatus;

    LrpcPushMessage.LpcHeader.u1.s1.TotalLength =
             sizeof(LRPC_PUSH_MESSAGE);
    LrpcPushMessage.LpcHeader.u1.s1.DataLength =
             sizeof(LRPC_PUSH_MESSAGE) - sizeof(PORT_MESSAGE);
    LrpcPushMessage.LpcHeader.ClientId = ClientIdToMsgClientId(ClientId);
    LrpcPushMessage.LpcHeader.MessageId = MessageId;
    LrpcPushMessage.LpcHeader.CallbackId = CallbackId ;
    LrpcPushMessage.LpcHeader.u2.s2.Type = LPC_REQUEST;
    LrpcPushMessage.RpcHeader.MessageType = LRPC_MSG_PUSH;

    LrpcPushMessage.Response.CountDataEntries = 1;
    LrpcPushMessage.Response.DataEntries[0] =
            LrpcMessage->Rpc.Request.DataEntries[0];

    LrpcPushMessage.LpcHeader.u2.s2.DataInfoOffset = sizeof(PORT_MESSAGE)
            + sizeof(LRPC_RPC_HEADER);

    NtStatus = NtRequestWaitReplyPort(Association->LpcClientPort,
                                      (PORT_MESSAGE *) &LrpcPushMessage,
                                      (PORT_MESSAGE *) &LrpcPushMessage);
    if (NT_ERROR(NtStatus))
        {
        // Assume that when the client tries to send the response it will
        // fail as well, so just claim that everything worked.

#if DBG
        if ((NtStatus != STATUS_NO_MEMORY)
            && (NtStatus != STATUS_INSUFFICIENT_RESOURCES))
            {
            PrintToDebugger("RPC : NtRequestWaitReplyPort : %lx\n", NtStatus);
            ASSERT(0);
            }
#endif // DBG

        return(RPC_S_OK);
        }

    VALIDATE(LrpcPushMessage.RpcStatus)
        {
        RPC_S_OK,
        RPC_S_OUT_OF_MEMORY
        } END_VALIDATE;

    return(LrpcPushMessage.RpcStatus);
}


BINDING_HANDLE *
LrpcCreateBindingHandle (
    )
/*++

Routine Description:

    We just need to create a new LRPC_BINDING_HANDLE.  This routine is a
    proxy for the new constructor to isolate the other modules.

--*/
{
    LRPC_BINDING_HANDLE * BindingHandle;
    RPC_STATUS Status = RPC_S_OK;

    Status = InitializeLrpcIfNecessary() ;
    if (Status != RPC_S_OK)
        {
        return 0 ;
        }

    BindingHandle = new LRPC_BINDING_HANDLE(&Status);
    if (Status != RPC_S_OK)
        {
        delete BindingHandle;
        return(0);
        }

    return(BindingHandle);
}

void
LRPC_CASSOCIATION::LrpcDeleteLingeringAssociations (
    void
    )
/*++

Routine Description:

    Will attempt to clean up lingering LRPC associations.

Return Value:

--*/
{
    BOOL fMutexTaken;
    LRPC_CASSOCIATION *CurrentAssociation;
    LRPC_CASSOCIATION *NextAssociation;
    LRPC_CASSOCIATION *FirstAssociation;
    DictionaryCursor cursor;
    DWORD CurrentTickCount;
    int Diff;

    // if there are no lrpc associations, return
    if (!GlobalLrpcServer)
        return;

    fMutexTaken = LrpcMutexTryRequest();
    if (!fMutexTaken)
        {
        // we couldn't cleanup anything - restore the flag
        if (!GarbageCollectionRequested)
            GarbageCollectionRequested = TRUE;
        return;
        }

    FirstAssociation = NULL;
    CurrentTickCount = GetTickCount();

    // need to walk the dictionary and clean up all associations with
    // expired timeouts
    LrpcAssociationDict->Reset(cursor);
    while ((CurrentAssociation = LrpcAssociationDict->Next(cursor)) != 0)
        {
        if (CurrentAssociation->Linger.fAssociationLingered)
            {
            // this will work even for wrapped tick count
            Diff = (int)(CurrentTickCount - CurrentAssociation->Linger.Timestamp);
            if (Diff > 0)
                {
#if defined (RPC_GC_AUDIT)
                DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) LRPC association gc'ed %d ms after expire\n",
                    GetCurrentProcessId(), GetCurrentProcessId(), Diff);
#endif
                // enlink the expired associations to a list - we'll clean it up
                // later
                CurrentAssociation->NextAssociation = FirstAssociation;
                FirstAssociation = CurrentAssociation;
                LrpcAssociationDict->Delete(CurrentAssociation->AssociationDictKey);
                // indicate to the other threads (needed once we release the mutex)
                // that this association is being cleaned up and they cannot call
                // Delete on it
                CurrentAssociation->AssociationDictKey = -1;
                LrpcLingeredAssociations --;
                }
            else
                {
                // this item hasn't expired yet - update the first gc time, and
                // raise the GarbageCollectionRequested flag if necessary
                if ((int)(CurrentAssociation->Linger.Timestamp - NextOneTimeCleanup) < 0)
                    {
                    // there is a race between this thread and threads calling
                    // GarbageCollectionNeeded. Those threads may overwrite the
                    // value we're about to write, which can result in delayed
                    // garbage collection for this value - that's ok.
                    NextOneTimeCleanup = CurrentAssociation->Linger.Timestamp;
                    }

                if (!GarbageCollectionRequested)
                    GarbageCollectionRequested = TRUE;
                }
            }
        }

    LrpcMutexClear();

    // destroy the associations at our leasure
    CurrentAssociation = FirstAssociation;
    while (CurrentAssociation != NULL)
        {
        NextAssociation = CurrentAssociation->NextAssociation;
        CurrentAssociation->Delete();
        CurrentAssociation = NextAssociation;
        }
}


int
InitializeRpcProtocolLrpc (
    )
/*++

Routine Description:

    For each process, this routine will be called once.  All initialization
    will be done here.

Return Value:

    Zero will be returned if initialization completes successfully,
    otherwise, non-zero will be returned.

--*/
{
    LrpcAssociationDict = new LRPC_CASSOCIATION_DICT;
    if (LrpcAssociationDict == 0)
        {
        return(1);
        }
    return(0);
}


RPC_STATUS
LrpcMapRpcStatus (
    IN RPC_STATUS Status
    )
/*++

Routine Description:

    Some NTSTATUS codes need to be mapped into RPC_STATUS codes before being
    returned as a fault code.  We take care of doing that mapping in this
    routine.

--*/
{
    switch (Status)
        {
        case STATUS_INTEGER_DIVIDE_BY_ZERO :
            return(RPC_S_ZERO_DIVIDE);

        case STATUS_ACCESS_VIOLATION :
        case STATUS_ILLEGAL_INSTRUCTION :
            return(RPC_S_ADDRESS_ERROR);

        case STATUS_FLOAT_DIVIDE_BY_ZERO :
            return(RPC_S_FP_DIV_ZERO);

        case STATUS_FLOAT_UNDERFLOW :
            return(RPC_S_FP_UNDERFLOW);

        case STATUS_FLOAT_OVERFLOW :
            return(RPC_S_FP_OVERFLOW);
        }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\msgapi.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    msgapi.cxx

Abstract:

    The I_RpcSendReceive API used to send and receive messages as part of
    a remote procedure call lives here.  This API is used by both clients
    (to make calls) and by servers (to make callbacks).

Author:

    Michael Montague (mikemon) 07-Nov-1991

Revision History:
    Mazhar Mohammed (mazharm) 09-11-95 added I_RpcReceive, I_RpcSend
    Mazhar Mohammed (mazharm) 03-31-96 added support for async RPC
                                               I_RpcAsyncSend and I_RpcAsyncReceive

Revision History:

--*/

#include <precomp.hxx>

#define    _SND_RECV_CALLED               0x100


RPC_STATUS RPC_ENTRY
I_RpcSendReceive (
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:

    We do all of the protocol module independent work of making a remote
    procedure call; at least the part concerned with sending the request
    and receiving the response.  The majority of the work is done by
    each rpc protocol module.

Arguments:

    Message - Supplies and returns the information required to make
        the remote procedure call.

Return Values:

    RPC_S_OK - The operation completed successfully.

--*/
{
    RPC_STATUS retval;
    THREAD *Thread;

    AssertRpcInitialized();

    ASSERT(!RpcpCheckHeap());

    Thread = ThreadSelf();
    if (!Thread)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    RpcpPurgeEEInfoFromThreadIfNecessary(Thread);

    MESSAGE_OBJECT *MObject = (MESSAGE_OBJECT *) Message->Handle;

    ASSERT( MObject->InvalidHandle(CALL_TYPE) == 0 );

    ASSERT( Message->Buffer != 0 );
    ASSERT( !COMPLETE(Message) );

    retval = MObject->SendReceive(Message);

    ASSERT(!RpcpCheckHeap());

    // Insure that the buffer is aligned on an eight byte boundary.

#ifdef DEBUGRPC

    if ( retval == RPC_S_OK )
        {
        ASSERT( (((ULONG_PTR) Message->Buffer) % 8) == 0);
        // uncomment this to check for 16 byte alignment on 64 bits
        // ASSERT( IsBufferAligned(Message->Buffer) );
        }

#endif // DEBUGRPC

    return(retval);
}


RPC_STATUS RPC_ENTRY
I_RpcSend (
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:
    This API is used in conjunction with pipes. This is used to send the marshalled
    parameters and the marshalled pipe data.

    Client: If the RPC_BUFFER_PARTIAL bit is set in Message->RpcFlags,
    this routine returns as soon as the buffer is sent. If the
    bit is not set, this routine blocks until the first reply fragment arrives.

    Server: The send always treated as a partial send.

Arguments:

    Message - Supplies  the information required to send the request


Return Values:

    RPC_S_OK - The operation completed successfully.
    RPC_S_SEND_INCOMPLETE - The complete data wasn't sent, Message->Buffer
    points to the remaining data and Message->BufferLength indicates the length of the
    remaining data. Any additional data needs to be appended to the
    end of the buffer.

--*/
{
    RPC_STATUS retval;
    THREAD *Thread;
    PVOID MessageBuffer;

    AssertRpcInitialized();

    ASSERT(!RpcpCheckHeap());

    Thread = ThreadSelf();
    if (!Thread)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    RpcpPurgeEEInfoFromThreadIfNecessary(Thread);

    MESSAGE_OBJECT *MObject = (MESSAGE_OBJECT *) Message->Handle;

    ASSERT( MObject->InvalidHandle(CALL_TYPE) == 0 );

    MessageBuffer = Message->Buffer;
    ASSERT( MessageBuffer != 0 );

    if (ASYNC(Message))
        {
        retval = MObject->AsyncSend(Message);
        }
    else
        {
        retval = MObject->Send(Message);
        }

    ASSERT(!RpcpCheckHeap());

    // Insure that the buffer is aligned on an eight byte boundary.

#ifdef DEBUGRPC

    if ( retval == RPC_S_OK )
        {
        ASSERT( (((ULONG_PTR) MessageBuffer) % 8) == 0);
        // uncomment this to check for 16 byte alignment on 64 bits
        //ASSERT( IsBufferAligned(MessageBuffer) );
        }

#endif // DEBUGRPC

    return(retval);
}


RPC_STATUS RPC_ENTRY
I_RpcReceive (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned int Size
    )
/*++

Routine Description:
    This routine is used in conjunction with pipes. If the RPC_BUFFER_PARTIAL bit
    is set in Message->RpcFlags, this call blocks until some data is received. Size is
    used as a hint of how much data the caller is requesting. If the partial bit is not set,
    this call blocks until the complete buffer is received.

Arguments:

    Message - Supplies  the information required to make the receive
    Size - used as a hint to indicate the amount of data needed by the caller

Return Values:

    RPC_S_OK - The operation completed successfully.
--*/
{

    RPC_STATUS retval;
    THREAD *Thread;

    AssertRpcInitialized();

    ASSERT(!RpcpCheckHeap());

    Thread = ThreadSelf();
    if (!Thread)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    RpcpPurgeEEInfoFromThreadIfNecessary(Thread);

    MESSAGE_OBJECT *MObject = (MESSAGE_OBJECT *) Message->Handle;

    ASSERT( MObject->InvalidHandle(CALL_TYPE) == 0 );

    //
    // Temp hack
    // Need to get Ryszard to fix
    // the NDR engine to never ask for 0 bytes
    // We can then change this to an ASSERT
    // ASSERT(Size)
    //
    if (Size == 0)
        Size = 1;

    if (ASYNC(Message))
        {
        retval = MObject->AsyncReceive(Message, Size);
        }
    else
        {
        retval = MObject->Receive(Message, Size);
        }

    ASSERT(!RpcpCheckHeap());

    // Insure that the buffer is aligned on an eight byte boundary.

#ifdef DEBUGRPC

    if ( retval == RPC_S_OK )
        {
        ASSERT( (((ULONG_PTR) Message->Buffer) % 8) == 0);
        // uncomment this to check for 16 byte alignment on 64 bits
        // ASSERT( IsBufferAligned(Message->Buffer) );
        }

#endif // DEBUGRPC

    return(retval);
}



RPC_STATUS RPC_ENTRY
I_RpcAsyncSetHandle (
    IN  PRPC_MESSAGE Message,
    IN  PRPC_ASYNC_STATE pAsync
    )
/*++
    This API is called on the client and server side. If this API is called on the
    server, runtime assumes that the call is async
    we will add more params later.
--*/
{
    RPC_STATUS retval;

    AssertRpcInitialized();

    ASSERT(!RpcpCheckHeap());

    MESSAGE_OBJECT *MObject = (MESSAGE_OBJECT *) Message->Handle;

    if (MObject->InvalidHandle(CALL_TYPE))
        {
        ASSERT(0);
        return (RPC_S_INVALID_BINDING);
        }

#if DBG
    if (!MObject->InvalidHandle(CCALL_TYPE))
        {
        // if we end up with invalid pAsync here, this means we were either
        // called by a private test, or COM. Both should know better. The
        // public APIs should pass through NDR and NDR already should have
        // validated the parameters.
        ASSERT((pAsync->Lock == 0) || (pAsync->Lock == 1));
        }
#endif

    retval = MObject->SetAsyncHandle(pAsync);

    if (retval == RPC_S_OK)
         {
         pAsync->RuntimeInfo = (void *) MObject;
         }

    ASSERT(!RpcpCheckHeap());

    return(retval);
}



RPC_STATUS RPC_ENTRY
I_RpcAsyncAbortCall (
    IN PRPC_ASYNC_STATE pAsync,
    IN unsigned long ExceptionCode
    )
/*++

Routine Description:


Arguments:
 pAsync - the async handle being registered

Return Value:
    RPC_S_OK - the call succeeded.
    RPC_S_INVALID_HANDLE - the handle was bad.

--*/

{
    MESSAGE_OBJECT *MObject = (MESSAGE_OBJECT *) pAsync->RuntimeInfo;

    if (!ThreadSelf())
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    if (MObject)
        {
        if (MObject->InvalidHandle(CALL_TYPE))
            {
            ASSERT(0);
            return (RPC_S_INVALID_BINDING);
            }

        return ((CALL *) MObject)->AbortAsyncCall(pAsync, ExceptionCode);
        }

    return RPC_S_INVALID_ASYNC_HANDLE;
}



#ifdef __cplusplus
extern "C" {
#endif


RPC_STATUS
I_RpcParseSecurity (
    IN RPC_CHAR * NetworkOptions,
    OUT SECURITY_QUALITY_OF_SERVICE * SecurityQualityOfService
    )
/*++

Routine Description:

    Parse a string of security options and build into the binary format
    required by the operating system.  The network options must follow
    the following syntax.  Case is not sensitive.

        security=
            [anonymous|identification|impersonation|delegation]
            [dynamic|static]
            [true|false]

        All three fields must be present.  To specify impersonation
        with dynamic tracking and effective only, use the following
        string for the network options.

        "security=impersonation dynamic true"

Arguments:

    NetworkOptions - Supplies the string containing the network options
        to be parsed.

    SecurityQualityOfService - Returns the binary format of the network
        options.

Return Value:

    RPC_S_OK - The network options have been correctly parsed into binary
        format.

    RPC_S_INVALID_NETWORK_OPTIONS - The network options are invalid and
        cannot be parsed.

--*/
{

    ASSERT(NetworkOptions[0] != 0);

    // We need to parse the security information from the network
    // options, and then stuff it into the object attributes.  To
    // begin with, we check for "security=" at the beginning of
    // the network options.

    if (RpcpStringNCompare(NetworkOptions, RPC_CONST_STRING("security="),
                sizeof("security=") - 1) != 0)
        {
        return(RPC_S_INVALID_NETWORK_OPTIONS);
        }

    NetworkOptions += sizeof("security=") - 1;

    // Ok, now we need to determine if the next field is one of
    // Anonymous, Identification, Impersonation, or Delegation.

    if (RpcpStringNCompare(NetworkOptions, RPC_CONST_STRING("anonymous"),
                sizeof("anonymous") - 1) == 0)
        {
        SecurityQualityOfService->ImpersonationLevel = SecurityAnonymous;
        NetworkOptions += sizeof("anonymous") - 1;
        }
    else if (RpcpStringNCompare(NetworkOptions, RPC_CONST_STRING("identification"),
                sizeof("identification") - 1) == 0)
        {
        SecurityQualityOfService->ImpersonationLevel = SecurityIdentification;
        NetworkOptions += sizeof("identification") - 1;
        }
    else if (RpcpStringNCompare(NetworkOptions, RPC_CONST_STRING("impersonation"),
                sizeof("impersonation") - 1) == 0)
        {
        SecurityQualityOfService->ImpersonationLevel = SecurityImpersonation;
        NetworkOptions += sizeof("impersonation") - 1;
        }
    else if (RpcpStringNCompare(NetworkOptions, RPC_CONST_STRING("delegation"),
                sizeof("delegation") - 1) == 0)
        {
        SecurityQualityOfService->ImpersonationLevel = SecurityDelegation;
        NetworkOptions += sizeof("delegation") - 1;
        }
    else
        {
        return(RPC_S_INVALID_NETWORK_OPTIONS);
        }

    if (*NetworkOptions != RPC_CONST_CHAR(' '))
        {
        return(RPC_S_INVALID_NETWORK_OPTIONS);
        }

    NetworkOptions++;

    // Next comes the context tracking field; it must be one of
    // dynamic or static.

    if (RpcpStringNCompare(NetworkOptions, RPC_CONST_STRING("dynamic"),
                sizeof("dynamic") - 1) == 0)
        {
        SecurityQualityOfService->ContextTrackingMode =
                SECURITY_DYNAMIC_TRACKING;
        NetworkOptions += sizeof("dynamic") - 1;
        }
    else if (RpcpStringNCompare(NetworkOptions, RPC_CONST_STRING("static"),
                sizeof("static") - 1) == 0)
        {
        SecurityQualityOfService->ContextTrackingMode =
                SECURITY_STATIC_TRACKING;
        NetworkOptions += sizeof("static") - 1;
        }
    else
        {
        return(RPC_S_INVALID_NETWORK_OPTIONS);
        }

    if (*NetworkOptions != RPC_CONST_CHAR(' '))
        {
        return(RPC_S_INVALID_NETWORK_OPTIONS);
        }

    NetworkOptions++;

    // Finally, comes the effective only flag.  This must be one of
    // true or false.

    if (RpcpStringNCompare(NetworkOptions, RPC_CONST_STRING("true"),
                sizeof("true") - 1) == 0)
        {
        SecurityQualityOfService->EffectiveOnly = TRUE;
        NetworkOptions += sizeof("true") - 1;
        }
    else if (RpcpStringNCompare(NetworkOptions, RPC_CONST_STRING("false"),
                sizeof("false") - 1) == 0)
        {
        SecurityQualityOfService->EffectiveOnly = FALSE;
        NetworkOptions += sizeof("false") - 1;
        }
    else
        {
        return(RPC_S_INVALID_NETWORK_OPTIONS);
        }

    if (*NetworkOptions != 0)
        {
        return(RPC_S_INVALID_NETWORK_OPTIONS);
        }

    SecurityQualityOfService->Length = sizeof(SECURITY_QUALITY_OF_SERVICE);

    return(RPC_S_OK);
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\mutex.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1990 - 1999
//
//  File:       mutex.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

                      Microsoft OS/2 LAN Manager
                   Copyright(c) Microsoft Corp., 1990

-------------------------------------------------------------------- */
/* --------------------------------------------------------------------

File: mutex.cxx

Description:

This file contains the system independent mutex class for NT.

History:

mikemon    ??-??-??    The beginning.
mikemon    12-31-90    Upgraded the comments.

-------------------------------------------------------------------- */

#include <precomp.hxx>


void
MUTEX::CommonConstructor (
    OUT RPC_STATUS PAPI * RpcStatus,
    IN DWORD dwSpinCount
    )
/*++

Routine Description:

    We construct a mutex in this routine; the only interesting part is that
    we need to be able to return a success or failure status.

Arguments:

    RpcStatus - Returns either RPC_S_OK or RPC_S_OUT_OF_MEMORY.

--*/
{
    CriticalSection.DebugInfo = 0;

    if ( *RpcStatus == RPC_S_OK )
        {
        if ( NT_SUCCESS(RtlInitializeCriticalSectionAndSpinCount(&CriticalSection, dwSpinCount)) )
            {
            *RpcStatus = RPC_S_OK;
            }
        else
            {
            *RpcStatus = RPC_S_OUT_OF_MEMORY;
            }
        }

#ifdef NO_RECURSIVE_MUTEXES
    RecursionCount = 0;
#endif // NO_RECURSIVE_MUTEXES
}


void MUTEX::Free(void)
{
    NTSTATUS NtStatus;

    if ( IsSuccessfullyInitialized() )
        {
        NtStatus = RtlDeleteCriticalSection(&CriticalSection);
        ASSERT(NT_SUCCESS(NtStatus));
        }
}

#ifdef DEBUGRPC

void
MUTEX::EnumOwnedCriticalSections()
{
    CRITICAL_SECTION_DEBUG * DebugInfo;

    return;

    HANDLE MyThreadId = ULongToPtr(GetCurrentThreadId());
    DWORD  Count      = NtCurrentTeb()->CountOfOwnedCriticalSections;

//    if (!Count)
//        {
//        DbgPrint("thread %x: taking %x\n", &CriticalSection);
//        return;
//        }

    DbgPrint("thread %x owns the following %d critical section(s):\n",
             MyThreadId, Count
             );

    DebugInfo = CriticalSection.DebugInfo;

    BOOL Found = FALSE;

    for (;;)
        {
        DebugInfo = CONTAINING_RECORD( DebugInfo->ProcessLocksList.Flink,
                                       RTL_CRITICAL_SECTION_DEBUG,
                                       ProcessLocksList
                                       );

        if (!DebugInfo->ProcessLocksList.Flink)
            {
//            DbgPrint("null forward link\n");
            break;
            }

        if (DebugInfo->ProcessLocksList.Flink == &CriticalSection.DebugInfo->ProcessLocksList)
            {
//            DbgPrint("circular list complete\n");
            break;
            }

//        DbgPrint("mutex %x owner %x\n",
//                 DebugInfo->CriticalSection,
//                 DebugInfo->CriticalSection
//                 ? DebugInfo->CriticalSection->OwningThread
//                 : 0
//                 );

        if (DebugInfo->CriticalSection &&
            DebugInfo->CriticalSection->OwningThread == MyThreadId)
            {
            DbgPrint("    %x\n", DebugInfo->CriticalSection);
            Found = TRUE;
            }
        }

    if (Found)
        {
        DbgPrint("and is taking %x\n", &CriticalSection);
        DbgBreakPoint();
        }
}

#endif  // DEBUG


void
MUTEX3::Request()
{
    if (guard.Increment() > 0)
        {
        if (owner == GetCurrentThreadId())
            {
            guard.Decrement();

            ASSERT(guard.GetInteger() >= 0);

            recursion++;
            return;
            }

        event.Wait();

        ASSERT(guard.GetInteger() >= 0);
        }

    ASSERT(owner == 0);
    ASSERT(recursion == 0);

    owner = GetCurrentThreadId();
    recursion = 1;
    return;
}


void 
MUTEX3::Clear()
{
    ASSERT(owner == GetCurrentThreadId());
    ASSERT(recursion > 0);

    if ( --recursion > 0)
        {
        return;
        }

    owner = 0;

    if (guard.Decrement() >= 0)
        {
        event.Raise();
        }
}

BOOL
MUTEX3::TryRequest()
{
    if (guard.CompareExchange(0, -1) == -1)
        {
        // Lock wasn't owned, now we own it.
        owner = GetCurrentThreadId();
        recursion = 1;
        return TRUE;
        }

    if (owner == GetCurrentThreadId())
        {
        // We can aquire it recursivly, just increment the count
        recursion++;
        return TRUE;
        }

    // Owned by another thread

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\memory.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1999

Module Name:

    memory.cxx

Abstract:

    This file contains the new and delete routines for memory management in
    the RPC runtime.  Rather than using the memory management provided by the
    C++ system we'll use the system allocator.

Revision History:

    mikemon    ??-??-??    Beginning of time (at least for this file).
    mikemon    12-31-90    Upgraded the comments.
    mariogo    04-24-96    Rewrite to unify platforms, behavior and performance.

--*/

#include <precomp.hxx>

#include <ntlsa.h>      // definitions for LSA allocation routines

HANDLE hRpcHeap = 0;
unsigned int DebugFlags = 0;
#define RPC_FAIL_ALLOCATIONS 0x00000001
#define  NO_HEAP_SLOWDOWN


PLSA_ALLOCATE_PRIVATE_HEAP LsaAlloc = NULL;
PLSA_FREE_PRIVATE_HEAP LsaFree = NULL;

inline void *AllocWrapper(size_t size)
{
    void *pobj;

    if( !LsaAlloc )
        {
        pobj = HeapAlloc(hRpcHeap, 0, size);
        }
    else 
        {
        pobj = LsaAlloc( size );
        }
    LogEvent(SU_HEAP, EV_CREATE, pobj, hRpcHeap, size, TRUE, 3);

    return pobj;
}

inline void FreeWrapper(void *pobj)
{
    LogEvent(SU_HEAP, EV_DELETE, pobj, hRpcHeap, 0, TRUE, 3);

    if( !LsaFree )
        {
        HeapFree(hRpcHeap, 0, pobj);
        } 
    else 
        {
        LsaFree( pobj );
        }
}

int fHeapInitialized = 0;
int fBufferCacheInitialized = 0;

BOOL fMaybeLsa = FALSE;

#ifndef DEBUGRPC

void *
__cdecl
operator new (
    IN size_t size
    )
{
    return(AllocWrapper(size));
}

void
__cdecl
operator delete (
    IN void * obj
    )
{
    FreeWrapper(obj);
}

int InitializeRpcAllocator(void)
{
    HMODULE hLsa;

    if (0 == fHeapInitialized)
        {
        if (RpcpStringCompare(FastGetImageBaseName(), L"lsass.exe") == 0)
            {
            fMaybeLsa = TRUE;
            if (gfServerPlatform)
                {
                // if this looks like lsa on a server box
                hLsa = GetModuleHandle(L"lsasrv.dll");
                if (hLsa)
                    {

                    //
                    // use LSA for FRE build (per KamenM request).
                    //
                    LsaAlloc = (PLSA_ALLOCATE_PRIVATE_HEAP)GetProcAddress(hLsa, "LsaIAllocateHeap");
                    LsaFree = (PLSA_FREE_PRIVATE_HEAP)GetProcAddress(hLsa, "LsaIFreeHeap");

                    if( LsaAlloc == NULL || LsaFree == NULL )
                        {
                        LsaAlloc = NULL;
                        LsaFree = NULL;
                        }
                    }
                }
            }

        if (hRpcHeap == 0)
            hRpcHeap = RtlProcessHeap();

        fHeapInitialized = 1;
        }

    if (0 == fBufferCacheInitialized)
        {
        RPC_STATUS status = RPC_S_OK;
        gBufferCache = new BCACHE(status);

        if (   0 == gBufferCache
            || status != RPC_S_OK )
            {
            return(RPC_S_OUT_OF_MEMORY);
            }
        fBufferCacheInitialized = TRUE;
        }

    return(RPC_S_OK);
}

int
RpcpCheckHeap (
    void
    )
// Allow some checked compenents to be linked into a free memory.cxx.
{
    return 0;
}


#else // ******************** DEBUG ********************

#ifdef NO_HEAP_SLOWDOWN
int fMemoryCheck = 0;
#else
int fMemoryCheck = 1;
#endif

CRITICAL_SECTION RpcHeapLock;

int InitializeRpcAllocator(void)
/*++

Routine Description:

    Called during RPC initialization. This function must can by one
    thread at a time.  Sets the heap handle for debugging.

    Maybe called more then once if this (or a later step) of RPC
    initialization fails.

--*/
{
    if (0 == fHeapInitialized)
        {
        if (RpcpStringCompare(FastGetImageBaseName(), L"lsass.exe") == 0)
            {
            fMaybeLsa = TRUE;
            }

        if (0 == hRpcHeap)
            {
            hRpcHeap = RtlCreateHeap(  HEAP_GROWABLE
                                     | HEAP_TAIL_CHECKING_ENABLED
                                     | HEAP_FREE_CHECKING_ENABLED
                                     | HEAP_CLASS_1,
                                     0,
                                     16 * 1024 - 512,
                                     0,
                                     0,
                                     0
                                     );
            }

        if (hRpcHeap)
            {
            if (0 == RtlInitializeCriticalSectionAndSpinCount(&RpcHeapLock, PREALLOCATE_EVENT_MASK))
                {
                fHeapInitialized = 1;
                }
            }

        if (0 == fHeapInitialized )
            {
            return(RPC_S_OUT_OF_MEMORY);
            }
        }

    if (0 == fBufferCacheInitialized)
        {
        RPC_STATUS status = RPC_S_OK;
        gBufferCache = new BCACHE(status);

        if (   0 == gBufferCache
            || status != RPC_S_OK )
            {
            return(RPC_S_OUT_OF_MEMORY);
            }
        fBufferCacheInitialized = TRUE;
        }


    return(RPC_S_OK);
}

#define RPC_GUARD 0xA1

typedef struct _RPC_MEMORY_BLOCK
{
    // First,forward and backward links to other RPC heap allocations.
    // These are first allow easy debugging with the dl command
    struct _RPC_MEMORY_BLOCK *next;
    struct _RPC_MEMORY_BLOCK *previous;

    // Specifies the size of the block of memory in bytes.
    unsigned long size;

    // Thread id of allocator
    unsigned long tid;

    void *          AllocStackTrace[4];

    // (Pad to make header 0 mod 8) 0 when allocated, 0xF0F0F0F0 when freed.
    unsigned long free;

    // Reserve an extra 4 bytes as the front guard of each block.
    unsigned char frontguard[4];

    // Data will appear here.  Note that the header must be 0 mod 8.

    // Reserve an extra 4 bytes as the rear guard of each block.
    unsigned char rearguard[4];

} RPC_MEMORY_BLOCK;

//
// Compile-time test to ensure that RPC_MEMORY_BLOCK.rearguard is aligned on
// natural boundary.
//

#if defined(_WIN64)
C_ASSERT( (FIELD_OFFSET( RPC_MEMORY_BLOCK, rearguard ) % 16) == 0 );
#else
C_ASSERT( (FIELD_OFFSET( RPC_MEMORY_BLOCK, rearguard ) % 8) == 0 );
#endif

RPC_MEMORY_BLOCK * AllocatedBlocks = 0;
unsigned long BlockCount = 0;

int
CheckMemoryBlock (
    RPC_MEMORY_BLOCK * block
    )
{
    if (   block->frontguard[0] != RPC_GUARD
        || block->frontguard[1] != RPC_GUARD
        || block->frontguard[2] != RPC_GUARD
        || block->frontguard[3] != RPC_GUARD )
        {
        PrintToDebugger("RPC : BAD BLOCK (front) @ %p\n", block);
        ASSERT(0);
        return(1);
        }

    if (   block->rearguard[block->size]   != RPC_GUARD
        || block->rearguard[block->size+1] != RPC_GUARD
        || block->rearguard[block->size+2] != RPC_GUARD
        || block->rearguard[block->size+3] != RPC_GUARD )
        {
        PrintToDebugger("RPC : BAD BLOCK (rear) @ %p (%p)\n",block, &block->rearguard[block->size]);
        ASSERT(0);
        return(1);
        }

    ASSERT(block->free == 0);

    if ( block->next != 0)
       {
       ASSERT(block->next->previous == block);
       }

    if ( block->previous != 0)
       {
       ASSERT(block->previous->next == block);
       }

    return(0);
}

int
RpcValidateHeapList(
    void
    )
// Called with RpcHeapLock held.
{
    RPC_MEMORY_BLOCK * block;
    unsigned Blocks = 0;

    // Under stress this check causes performance to drop too much.
    // Compile with -DNO_HEAP_SLOWDOWN or ed the flag in memory
    // to speed things up.

    if (fMemoryCheck == 0)
        {
        return(0);
        }

    block = AllocatedBlocks;

    while (block != 0)
        {
        if (CheckMemoryBlock(block))
            {
            return(1);
            }
        block = block->next;
        Blocks++;
        }

    ASSERT(Blocks == BlockCount);

    return(0);
}

int
RpcpCheckHeap (
    void
    )
// Returns 0 if the heap appears to be okay.
{
    if (fMemoryCheck == 0)
        {
        return(0);
        }

    EnterCriticalSection(&RpcHeapLock);

    int ret = RpcValidateHeapList();

    LeaveCriticalSection(&RpcHeapLock);

    return(ret);
}

void * __cdecl
operator new(
    size_t size
    )
{
    RPC_MEMORY_BLOCK * block;

    EnterCriticalSection(&RpcHeapLock);

    ASSERT( ("You allocated a negative amount",
            size < (size + sizeof(RPC_MEMORY_BLOCK))) );

    RpcValidateHeapList();
    if (DebugFlags & RPC_FAIL_ALLOCATIONS)
        {
        if ((GetTickCount() % 13) == 0)
            {
            LeaveCriticalSection(&RpcHeapLock);

            PrintToDebugger("RPC: Purposely failed an allocation\n") ;
            return 0;
            }
        }

    block = (RPC_MEMORY_BLOCK *)AllocWrapper(size + sizeof(RPC_MEMORY_BLOCK));

    if ( block == 0 )
        {
        LeaveCriticalSection(&RpcHeapLock);
        return(0);
        }

    block->size = size;
    block->tid = GetCurrentThreadId();
    block->free = 0;

    if (AllocatedBlocks != 0)
        AllocatedBlocks->previous = block;

    block->next = AllocatedBlocks;
    block->previous = 0;
    AllocatedBlocks = block;
    BlockCount++;

    block->frontguard[0] = RPC_GUARD;
    block->frontguard[1] = RPC_GUARD;
    block->frontguard[2] = RPC_GUARD;
    block->frontguard[3] = RPC_GUARD;

    #if i386
    ULONG ignore;

    RtlCaptureStackBackTrace(
                             2,
                             4,
                             (void **) &block->AllocStackTrace,
                             &ignore);
    #endif


    block->rearguard[size]   = RPC_GUARD;
    block->rearguard[size+1] = RPC_GUARD;
    block->rearguard[size+2] = RPC_GUARD;
    block->rearguard[size+3] = RPC_GUARD;

    LeaveCriticalSection(&RpcHeapLock);

    return(&(block->rearguard[0]));
}

void __cdecl
operator delete (
    IN void * obj
    )
{
    RPC_MEMORY_BLOCK * block;

    if (obj == 0)
        return;

    EnterCriticalSection(&RpcHeapLock);

    block = (RPC_MEMORY_BLOCK *) (((unsigned char *) obj)
                    - FIELD_OFFSET(RPC_MEMORY_BLOCK, rearguard));

    // Validate block being freed.

    CheckMemoryBlock(block);

    if (block->next != 0)
        {
        CheckMemoryBlock(block->next);
        }

    if (block->previous != 0)
        {
        CheckMemoryBlock(block->previous);
        }

    // Remove the block from the list

    if (block == AllocatedBlocks)
        AllocatedBlocks = block->next;

    if (block->next != 0)
        block->next->previous = block->previous;

    if (block->previous != 0)
        block->previous->next = block->next;

    // Mark this block as free
    block->free = 0xF0F0F0F0;

    // Validate other RPC allocations.
    BlockCount-- ;
    RpcValidateHeapList();

    LeaveCriticalSection(&RpcHeapLock);

    FreeWrapper(block);
}

#endif // DEBUGRPC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\pipe.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pipe.cxx
//
//--------------------------------------------------------------------------

#include <precomp.hxx>
#include "pipe.h"

void I_RpcReadPipeElementsFromBuffer (
    PIPE_STATE PAPI *state,
    char PAPI *TargetBuffer,
    int TargetBufferSize, 
    int PAPI *NumCopied
    )
{
    char PAPI *temp, PAPI *temp1 ;
    int size ;
    int totalsize ;

    ASSERT(state->CurrentState == start ||
                 (state->PartialCountSize < sizeof(DWORD) &&
                 state->PartialPipeElementSize < state->PipeElementSize)) ;

    if (TargetBufferSize < state->PipeElementSize)
        {
        return ;
        }

    while (1)
        {
        switch(state->CurrentState)
            {
            case     start:
                // read in an element count
                if (state->BytesRemaining == 0)
                    {
                    return ;
                    }

                // transition: end of src
                if (state->BytesRemaining <sizeof(DWORD))
                    {
                    state->CurrentState = return_partial_count ;
                    break;
                    }

                // transition: scan chunk count
                state->PartialCount = 0 ;
                state->PartialCountSize = 0 ;
                state->PartialPipeElementSize = 0 ;

                state->ElementsRemaining = *((DWORD *) state->CurPointer) ;
#if DBG
                PrintToDebugger("PIPES: <start> ElementsRemainaing: %d\n",
                                        state->ElementsRemaining) ;
#endif

                state->CurPointer +=  sizeof(DWORD) ;
                state->BytesRemaining -= sizeof(DWORD) ;
                if (state->ElementsRemaining == 0)
                    {
                    state->EndOfPipe = 1 ;
                    return ;
                    }
                else
                    {
                    state->CurrentState = copy_pipe_elem ;
                    }
                break;

            case     read_partial_count: // also a start state & final state
                size = sizeof(DWORD) ;
                totalsize = 0 ;
                ASSERT(state->PartialCountSize > 0 && state->PartialCountSize < 4) ;
                ASSERT(state->ElementsRemaining == 0) ;

                temp = (char *) &(state->PartialCount) ;
                temp1 = (char *) &(state->ElementsRemaining) ;

                for (;state->PartialCountSize;
                    state->PartialCountSize--, size--, totalsize++)
                    {
                     *temp1++ = *temp++ ;
                    }

                for (;size && state->BytesRemaining;
                        size--,state->BytesRemaining--, totalsize++)
                    {
                    *temp1++ = *state->CurPointer++ ;
                    }

#if DBG
                PrintToDebugger("PIPES: <read_partial_count>ElementsRemainaing: %d\n",
                                        state->ElementsRemaining) ;
#endif

                if (size == 0)
                    {
                    state->CurrentState = copy_pipe_elem ;
                    }
                else
                    {
                    // copy the stuff back into Partial count
                    // and keep it around for the next call
                    // the next time around, we'll end up in the same
                    // state
                    temp = (char *) &(state->PartialCount) ;
                    temp1 = (char *) &(state->ElementsRemaining) ;

                    ASSERT(totalsize < sizeof(DWORD)) ;

                    for (;totalsize; totalsize--, state->PartialCountSize++)
                        {
                        *temp++ = *temp1++ ;
                        }

                    return ;
                    }
                break;

            case     read_partial_pipe_elem: //also a start state
                ASSERT(state->PartialPipeElementSize > 0 &&
                             state->PartialPipeElementSize < state->PipeElementSize) ;

                if (TargetBufferSize < state->PipeElementSize)
                    {
                    // this is not an error
                    return ;
                    }

                size = state->PipeElementSize ;

                if (state->BytesRemaining >= size-state->PartialPipeElementSize)
                    {
                    temp = (char *) state->PartialPipeElement ;
    
                    for (;state->PartialPipeElementSize;
                        state->PartialPipeElementSize--, size--,
                        TargetBufferSize--)
                        {
                         *TargetBuffer++ = *temp++ ;
                        }
    
                    for (;size && state->BytesRemaining;
                            size--, state->BytesRemaining--, 
                            TargetBufferSize--)
                        {
                        *TargetBuffer++ = *state->CurPointer++ ;
                        }

                    state->CurrentState = copy_pipe_elem ;
                    *NumCopied += 1 ;
                    }
                else
                    {
                    // copy the stuff back into partial pipe buffer
                    // and keep it around for the next call
                    // the next time around, we'll end up in the same
                    // state
                    temp = (char *) state->PartialPipeElement+
                               state->PartialPipeElementSize ;
                    
                    for (;state->BytesRemaining; state->BytesRemaining--,
                         state->PartialPipeElementSize++)
                        {
                        *temp++ = *state->CurPointer++ ;
                        }

                    return ;
                    }
                break;

            case     copy_pipe_elem: // also a start state
                if (state->BytesRemaining >= state->PipeElementSize)
                    {
                    if (TargetBufferSize >= state->PipeElementSize)
                        {
                        for (size = state->PipeElementSize; size;
                                size--, TargetBufferSize--, state->BytesRemaining--)
                            {
                            *TargetBuffer++ = *state->CurPointer++ ;
                            }

                        state->ElementsRemaining-- ;
                        *NumCopied += 1 ;

                        if (state->ElementsRemaining == 0)
                            {
                            state->CurrentState = start ;
                            if (TargetBufferSize < state->PipeElementSize)
                                {
                                return ;
                                }
                            }
                        }
                    else
                        {
                        // end of target buffer
                        // return the appropriate count
                        return ;
                        }
                    }
                else
                    {
                    if (state->BytesRemaining)
                        {
                        state->CurrentState = return_partial_pipe_elem ;
                        }
                    else
                        {
                        return ;
                        }
                    }
                break;

            case     return_partial_pipe_elem: // also save pipe elem
                ASSERT(state->BytesRemaining < state->PipeElementSize) ;

                state->PartialPipeElementSize = 0;

                for (temp = (char *) state->PartialPipeElement; state->BytesRemaining;
                    state->BytesRemaining--, state->PartialPipeElementSize++)
                    {
                    *temp++ = *state->CurPointer++ ;
                    }
                state->CurrentState = read_partial_pipe_elem ;
                return;

            case     return_partial_count: // also save count
                state->PartialCountSize = 0 ;
                ASSERT(state->BytesRemaining < sizeof(DWORD)) ;

                for (temp = (char *) &(state->PartialCount); state->BytesRemaining;
                    state->BytesRemaining--, state->PartialCountSize++)
                    {
                    *temp++ = *state->CurPointer++ ;
                    }
                state->CurrentState = read_partial_count ;
                return;

            default:
                ASSERT(0) ;
                break;
            }
        }
}

RPC_STATUS RPC_ENTRY
MyRpcCompleteAsyncCall (
    IN PRPC_ASYNC_STATE pAsync,
    IN void *Reply
    )
/*++
Function Name:MyRpcCompleteAsyncCall
    This is function is used by the bvts, the real stuff will call
    RpcCompleteAsyncCall. 
    
Parameters:

Description:

Returns:

--*/
{
    return STUB(pAsync)->CompletionRoutine (pAsync, Reply) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\miscnt.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    miscnt.cxx

Abstract:

    This file contains NT specific implementations of miscellaneous
    routines.

Author:

    Michael Montague (mikemon) 25-Nov-1991

Revision History:

    Kamen Moutafov (KamenM) Dec 99 - Feb 2000 - Support for cell debugging stuff
    Kamen Moutafov      (KamenM)    Mar-2000    Support for extended error info
--*/

#include <precomp.hxx>
#include <rpccfg.h>
#include <CharConv.hxx>

static const char *RPC_REGISTRY_PROTOCOLS =
    "Software\\Microsoft\\Rpc\\ClientProtocols";

static const char *RPC_REGISTRY_PROTOCOL_IDS =
    "Software\\Microsoft\\Rpc\\AdditionalProtocols";

static const RPC_CHAR *RPC_REGISTRY_DEFAULT_SECURITY_DLL =
    L"System\\CurrentControlSet\\Control\\SecurityProviders";

// N.B. This value must agree with the key specified in the system.adm file
static const RPC_CHAR *RPC_POLICY_SETTINGS = 
    L"Software\\Policies\\Microsoft\\Windows NT\\Rpc";

static const RPC_CHAR *RPC_REGISTRY_IMAGE_FILE_EXEC =
    L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\";

static const RPC_CHAR *RPC_REGISTRY_THREAD_THROTTLE =
    L"\\RpcThreadPoolThrottle";

const int IMAGE_FILE_EXEC_LENGTH = 75;
const int THREAD_THROTTLE_LENGTH = 24;

#define MAX_ENDPOINT_LENGTH 128
#define MAX_ID_LENGTH 6
#define MAX_DLL_NAME 128

typedef struct
{
    const RPC_CHAR * RpcProtocolSequence;
    const RPC_CHAR * TransportInterfaceDll;
    unsigned long TransportId;
} RPC_PROTOCOL_SEQUENCE_MAP;

static const RPC_PROTOCOL_SEQUENCE_MAP RpcProtocolSequenceMap[] =
{
    {
    RPC_CONST_STRING("ncacn_np"),
    RPC_CONST_STRING("rpcrt4.dll"),
    NMP_TOWER_ID
    },

    {
    RPC_CONST_STRING("ncacn_ip_tcp"),
    RPC_CONST_STRING("rpcrt4.dll"),
    TCP_TOWER_ID
    },

#ifdef SPX_ON
    {
    RPC_CONST_STRING("ncacn_spx"),
    RPC_CONST_STRING("rpcrt4.dll"),
    SPX_TOWER_ID
    },
#endif

    {
    RPC_CONST_STRING("ncadg_ip_udp"),
    RPC_CONST_STRING("rpcrt4.dll"),
    UDP_TOWER_ID
    },

#ifdef IPX_ON
    {
    RPC_CONST_STRING("ncadg_ipx"),
    RPC_CONST_STRING("rpcrt4.dll"),
    IPX_TOWER_ID
    },
#endif

#ifdef NETBIOS_ON
    {
    RPC_CONST_STRING("ncacn_nb_tcp"),
    RPC_CONST_STRING("rpcrt4.dll"),
    NB_TOWER_ID
    },

    {
    RPC_CONST_STRING("ncacn_nb_ipx"),
    RPC_CONST_STRING("rpcrt4.dll"),
    NB_TOWER_ID
    },

    {
    RPC_CONST_STRING("ncacn_nb_nb"),
    RPC_CONST_STRING("rpcrt4.dll"),
    NB_TOWER_ID
    },
#endif

#ifdef APPLETALK_ON
    {
    RPC_CONST_STRING("ncacn_at_dsp"),
    RPC_CONST_STRING("rpcrt4.dll"),
    DSP_TOWER_ID
    },
#endif

    {
    RPC_CONST_STRING("ncacn_http"),
    RPC_CONST_STRING("rpcrt4.dll"),
    HTTP_TOWER_ID
    },

    {
    RPC_CONST_STRING("ncadg_cluster"),
    RPC_CONST_STRING("rpcrt4.dll"),
    CDP_TOWER_ID
    },

#ifdef NCADG_MQ_ON
    {
    RPC_CONST_STRING("ncadg_mq"),
    RPC_CONST_STRING("rpcrt4.dll"),
    MQ_TOWER_ID
    },
#endif

#ifdef BANYAN_ON
    {
    RPC_CONST_STRING("ncacn_vns_spp"),
    RPC_CONST_STRING("rpcrt4.dll"),
    SPP_TOWER_ID
    },
#endif

    {
    RPC_CONST_STRING("ncalrpc"),
    0,
    0
    },
};

const int RpcProtseqMapLength = (sizeof(RpcProtocolSequenceMap)
                                / sizeof(RPC_PROTOCOL_SEQUENCE_MAP));

static const RPC_PROTOCOL_SEQUENCE_MAP RpcUseAllProtseqMap[] =
{
    {
    RPC_CONST_STRING("ncacn_np"),
    RPC_CONST_STRING("rpcrt4.dll"),
    NMP_TOWER_ID
    },

    {
    RPC_CONST_STRING("ncalrpc"),
    0,
    0
    },
};

const int RpcUseAllProtseqMapLength = (sizeof(RpcUseAllProtseqMap)
                                / sizeof(RPC_PROTOCOL_SEQUENCE_MAP));


typedef struct
{
    unsigned char * RpcProtocolSequence;
    unsigned char * RpcSsEndpoint;
    unsigned long    TransportId;
} RPC_PROTOCOL_INFO;


static const RPC_PROTOCOL_INFO StaticProtocolMapping[] =
{
    {
    (unsigned char *)"ncacn_np",
    (unsigned char *)"\\pipe\\epmapper",
    0x0F
    }
};

RPC_PROTOCOL_INFO * AdditionalProtocols = 0;
unsigned long TotalAdditionalProtocols = 0;

static const char *RPC_REGISTRY_SECURITY_PROVIDERS =
                "Software\\Microsoft\\Rpc\\SecurityService";
static const char *RPC_MISC_SETTINGS =
                "Software\\Microsoft\\Rpc";

BOOL  DefaultProviderRead = FALSE;
DWORD DefaultAuthLevel  = RPC_C_AUTHN_LEVEL_CONNECT;
DWORD DefaultProviderId = RPC_C_AUTHN_WINNT;

RPC_CHAR *DefaultSecurityDLL = L"secur32.dll";
BOOL DefaultSecurityDLLRead = FALSE;

void
GetMaxRpcSizeAndThreadPoolParameters (
    void
    )
{
    HKEY RegistryKey;

    DWORD Result;
    DWORD RegStatus;
    DWORD Type;
    DWORD DwordSize = sizeof(DWORD);
    RPC_CHAR KeyName[MAX_PATH + IMAGE_FILE_EXEC_LENGTH + THREAD_THROTTLE_LENGTH];
    const RPC_CHAR * ModuleName;
    int ModuleLength;
    RPC_CHAR *CurrentPos;

    //
    // Get the default Rpc size.
    //
    RegStatus = RegOpenKeyExA(
                    HKEY_LOCAL_MACHINE,
                    (LPSTR) RPC_MISC_SETTINGS,
                    0L, KEY_READ,                      //Reserved
                    &RegistryKey
                    );

    if ( RegStatus != ERROR_SUCCESS )
        {
        return;
        }

    RegStatus = RegQueryValueExA(
                    RegistryKey,
                    "MaxRpcSize",
                    0,
                    &Type,
                    (LPBYTE) &Result,
                    &DwordSize
                    );

    if (RegStatus == ERROR_SUCCESS
        && Type == REG_DWORD)
        {
        gMaxRpcSize = Result;
        }

    RegCloseKey(RegistryKey);
    
    //
    // Find out the .EXE name.
    //
    ModuleName = FastGetImageBaseName();
    ModuleLength = RpcpStringLength(ModuleName);

    CurrentPos = KeyName;
    RpcpMemoryCopy(CurrentPos, 
        RPC_REGISTRY_IMAGE_FILE_EXEC, 
        IMAGE_FILE_EXEC_LENGTH * 2);

    CurrentPos += IMAGE_FILE_EXEC_LENGTH - 1;
    RpcpMemoryCopy(CurrentPos, 
        ModuleName, 
        ModuleLength * 2);

    CurrentPos += ModuleLength;
    RpcpMemoryCopy(CurrentPos, 
        RPC_REGISTRY_THREAD_THROTTLE, 
        THREAD_THROTTLE_LENGTH * 2);

    RegStatus = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    KeyName,
                    0L, KEY_READ,                      //Reserved
                    &RegistryKey
                    );

    if ( RegStatus != ERROR_SUCCESS )
        {
        return;
        }

    DwordSize = sizeof(DWORD);

    RegStatus = RegQueryValueExA(
                    RegistryKey,
                    "ProrateMax",
                    0,
                    &Type,
                    (LPBYTE) &Result,
                    &DwordSize
                    );

    if (RegStatus == ERROR_SUCCESS
        && Type == REG_DWORD)
        {
        gProrateMax = Result;
        }

    DwordSize = sizeof(DWORD);

    RegStatus = RegQueryValueExA(
                    RegistryKey,
                    "ProrateFactor",
                    0,
                    &Type,
                    (LPBYTE) &Result,
                    &DwordSize
                    );

    if (RegStatus == ERROR_SUCCESS
        && Type == REG_DWORD)
        {
        gProrateFactor = Result;
        }

    DwordSize = sizeof(DWORD);

    RegStatus = RegQueryValueExA(
                    RegistryKey,
                    "ProrateStart",
                    0,
                    &Type,
                    (LPBYTE) &Result,
                    &DwordSize
                    );

    if (RegStatus == ERROR_SUCCESS
        && Type == REG_DWORD)
        {
        gProrateStart = Result;
        }

    RegCloseKey(RegistryKey);

    // if any of these values are invalid, turn it off
    if ((gProrateFactor == 0) || (gProrateMax == 0))
        gProrateStart = 0;
}


BOOL
GetDefaultLevel()
{
    HKEY RegistryKey;

    DWORD Result;
    DWORD RegStatus;
    DWORD Type;
    DWORD DwordSize = sizeof(DWORD);

    //
    // Get the default provider level.
    //
    RegStatus = RegOpenKeyExA(
                    HKEY_LOCAL_MACHINE,
                    (LPSTR) RPC_REGISTRY_SECURITY_PROVIDERS,
                    0L, KEY_READ,                      //Reserved
                    &RegistryKey
                    );

    if ( RegStatus != ERROR_SUCCESS )
        {
        return FALSE;
        }

    RegStatus = RegQueryValueExA(
                    RegistryKey,
                    "DefaultAuthLevel",
                    0,
                    &Type,
                    (LPBYTE) &Result,
                    &DwordSize
                    );

    if (RegStatus == ERROR_CANTOPEN ||
        RegStatus == ERROR_CANTREAD )
        {
        RegCloseKey(RegistryKey);
        return TRUE;
        }

    if ( RegStatus != ERROR_SUCCESS )
        {
        RegCloseKey(RegistryKey);
        return FALSE;
        }

    if ( Type != REG_DWORD )
        {
        RegCloseKey(RegistryKey);
        return TRUE;
        }

    if (Result >= RPC_C_AUTHN_LEVEL_CONNECT     &&
        Result <= RPC_C_AUTHN_LEVEL_PKT_PRIVACY )
        {
        DefaultAuthLevel = Result;
        }

    RegCloseKey(RegistryKey);
    return TRUE;
}


void
RpcpGetDefaultSecurityProviderInfo()
{
    if (DefaultProviderRead)
        {
        return;
        }

    if (GetDefaultLevel())
        {
        DefaultProviderRead = TRUE;
        }
}

RPC_STATUS
GetDefaultSecurityDll (
    IN RPC_CHAR *DllName,
    IN ULONG DllNameLength
    )
{
    HKEY RegistryKey;
    DWORD RegStatus;
    RPC_CHAR *DuplicateDllName;
    DWORD Type;

    if (DefaultSecurityDLLRead == FALSE)
        {
        RegStatus = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    RPC_REGISTRY_DEFAULT_SECURITY_DLL,
                    0L, KEY_READ,                      //Reserved
                    &RegistryKey
                    );

        if ( RegStatus != ERROR_SUCCESS )
            {
            if (RegStatus == ERROR_FILE_NOT_FOUND)
                {
                DefaultSecurityDLLRead = TRUE;
                return RPC_S_OK;
                }

            return(RPC_S_UNKNOWN_AUTHN_SERVICE);
            }


        RegStatus = RegQueryValueEx(
                    RegistryKey,
                    L"ClientDll",
                    0,
                    &Type,
                    (unsigned char *)DllName,
                    &DllNameLength
                    );

        if ( RegStatus != ERROR_SUCCESS )
            {
            RegCloseKey(RegistryKey);
            if (RegStatus == ERROR_FILE_NOT_FOUND)
                {
                DefaultSecurityDLLRead = TRUE;
                return RPC_S_OK;
                }

            return(RPC_S_UNKNOWN_AUTHN_SERVICE);
            }

        if (Type != REG_SZ)
            {
            RegCloseKey(RegistryKey);
            return(RPC_S_UNKNOWN_AUTHN_SERVICE);
            }

        DuplicateDllName = DuplicateString(DllName);

        RegCloseKey(RegistryKey);

        if (DuplicateDllName)
            {
            DefaultSecurityDLL = DuplicateDllName;
            DefaultSecurityDLLRead = TRUE;
            }
        else
            {
            return RPC_S_OUT_OF_MEMORY;
            }

        }

    return RPC_S_OK;
}

RPC_STATUS
RpcGetSecurityProviderInfo(
    IN unsigned long AuthnId,
    OUT RPC_CHAR **Dll,
    OUT unsigned long PAPI * Count
    )
{

    DWORD RegStatus, Ignore, NumberOfValues, MaximumValueLength;
    unsigned long DllNameLength = MAX_DLL_NAME+1;
    DWORD ClassLength = 64, Type;
    RPC_CHAR DllName[MAX_DLL_NAME+1];
    FILETIME LastWriteTime;
    HKEY RegistryKey;
    unsigned char ClassName[64];
    RPC_STATUS Status = RPC_S_OK;
    char AuthnIdZ[8];
    RPC_CHAR unicodeAuthnIdZ[8];
    RPC_CHAR *pAuthnIdZ;
    RPC_CHAR *ActualDllName;

    RpcItoa(AuthnId, AuthnIdZ, 10);

    RegStatus = RegOpenKeyExA(
                    HKEY_LOCAL_MACHINE,
                    (LPSTR) RPC_REGISTRY_SECURITY_PROVIDERS,
                    0L, KEY_READ,                      //Reserved
                    &RegistryKey
                    );

    if ( RegStatus != ERROR_SUCCESS )
        {
        return(RPC_S_UNKNOWN_AUTHN_SERVICE);
        }

    RegStatus = RegQueryInfoKeyA(
                    RegistryKey,
                    (LPSTR) ClassName,
                    &ClassLength,
                    0,                                //Reserved
                    &Ignore,
                    &Ignore,
                    &Ignore,
                    &NumberOfValues,
                    &Ignore,
                    &MaximumValueLength,
                    &Ignore,
                    &LastWriteTime
                    );

    if ( (RegStatus != ERROR_SUCCESS) || (NumberOfValues < 2) )
        {
        RegStatus = RegCloseKey(RegistryKey);
        ASSERT( RegStatus == ERROR_SUCCESS );
        return(RPC_S_UNKNOWN_AUTHN_SERVICE);
        }

    *Count = NumberOfValues - 2;    //Gross

    SimpleAnsiToUnicode(AuthnIdZ, unicodeAuthnIdZ);
    pAuthnIdZ = unicodeAuthnIdZ;

    RegStatus = RegQueryValueEx(
                    RegistryKey,
                    (const RPC_SCHAR *)pAuthnIdZ,
                    0,
                    &Type,
                    (unsigned char *)DllName,
                    &DllNameLength
                    );

    RegCloseKey(RegistryKey);

    if (RegStatus != ERROR_SUCCESS)
        {
        RegStatus = GetDefaultSecurityDll(
            DllName, 
            DllNameLength);

        if (RegStatus == RPC_S_OK)
            ActualDllName = DefaultSecurityDLL;
        }
    else
        {
        ActualDllName = DllName;
        }

    if (RegStatus == ERROR_SUCCESS)
        {
        *Dll = DuplicateString(ActualDllName);
        if (*Dll == 0)
            {
            RegStatus = RPC_S_OUT_OF_MEMORY;
            }
        }
    else
        {
        RegStatus = RPC_S_UNKNOWN_AUTHN_SERVICE;
        }

    return(RegStatus);
}

DWORD * FourLeggedPackages = 0;
DWORD NullPackageList[] = { 0 };



BOOL
ReadPackageLegInfo()
/*++

Routine Description:

    NT 4.0 and previous versions allowed only two or three legs to set up the
    security context.  Two were represented on the wire as BIND then BIND_ACK;
    three added an AUTH3 packet.  When Jeff added 4- and 6-leg support, he
    made the sequence BIND, BIND-ACK, ALTER-CXT, ALTER-CXT-RESPONSE.  Sadly,
    it turns out to be impossible for RPC to tell whether a given package wants
    three or four legs, so the client would have to guess whether to send
    an AUTH3 or an ALTER-CXT to an NT 4 server. To solve this we are adding a
    registry value that lists all the providers that need more than three legs.

    The format, in regdmp.exe form, is

        \Registry\Machine\Software\Microsoft\Rpc
            Four-legged packages = REG_MULTI_SZ "16" "18" ""

    This function opens the registry and converts this data into an in-memory
    array of DWORD package IDs.

    Not all packages are in this list; see GetPackageLegCount() for details.

Return Values:

    TRUE = the registry data was read, or the value does not exist.
           Calling this function again will have no effect.

    FALSE = there was a problem reading the data in the registry.
            You can call the fn later and it will try again.

--*/
{
    DWORD Size = 0;
    DWORD RegStatus;
    DWORD Type;
    HKEY RegistryKey;
    wchar_t * Strings;

    if (FourLeggedPackages)
        {
        return TRUE;
        }

    SecurityCritSect->VerifyOwned();

    // open key;
    RegStatus = RegOpenKeyExA(
                    HKEY_LOCAL_MACHINE,
                    (LPSTR) RPC_REGISTRY_SECURITY_PROVIDERS,
                    0L, KEY_READ,                      //Reserved
                    &RegistryKey
                    );

    if ( RegStatus != ERROR_SUCCESS )
        {
        return FALSE;
        }

    // get size of strings

    RegStatus = RegQueryValueExW(
                    RegistryKey,
                    L"Four-legged packages",
                    0,
                    &Type,
                    0,
                    &Size
                    );

    if (RegStatus == ERROR_FILE_NOT_FOUND )
        {
        RegCloseKey(RegistryKey);

        FourLeggedPackages = NullPackageList;
        return TRUE;
        }

    if ( RegStatus != ERROR_SUCCESS )
        {
        RegCloseKey(RegistryKey);
        return FALSE;
        }

    //
    // Place an upper bound on the size to avoid hacker attacks.
    //
    if ( Type != REG_MULTI_SZ || Size > 4000)
        {
        RegCloseKey(RegistryKey);
        FourLeggedPackages = NullPackageList;
        return TRUE;
        }

    // get string data.

    Strings = (wchar_t *) _alloca( Size );

    RegStatus = RegQueryValueExW(
                    RegistryKey,
                    L"Four-legged packages",
                    0,
                    &Type,
                    (unsigned char *) Strings,
                    &Size
                    );

    RegCloseKey(RegistryKey);

    if (RegStatus == ERROR_CANTOPEN ||
        RegStatus == ERROR_CANTREAD )
        {
        FourLeggedPackages = NullPackageList;
        return TRUE;
        }

    if ( RegStatus != ERROR_SUCCESS )
        {
        return FALSE;
        }

    if ( Type != REG_MULTI_SZ )
        {
        FourLeggedPackages = NullPackageList;
        return TRUE;
        }

    // count strings; the buffer is terminated by an empty string that will be counted.

    int Count = 0;
    wchar_t * p;
    for (p=Strings; p < Strings + Size; ++p)
        {
        if (*p == '\0')
            {
            ++Count;
            }
        }

    // allocate memory.

    DWORD * LegData = new DWORD[Count];
    if (!LegData)
        {
        return FALSE;
        }

    // transfer data
    int i;
    wchar_t * new_p;
    for (i=0, p=Strings; p < Strings + Size; ++i, p = new_p+1)
        {
        LegData[i] = wcstoul(p, &new_p, 10);
        if (*new_p != '\0')
            {
            // The string is badly formatted. Eliminate it.
            --i;
            new_p += wcslen(new_p);
            }
        }

    if (FourLeggedPackages && FourLeggedPackages != NullPackageList)
        {
        delete FourLeggedPackages;
        }

    FourLeggedPackages = LegData;

    return TRUE;
}


RPC_STATUS
LoadAdditionalTransportInfo(
    )
{

    DWORD RegStatus, Index, Ignore, NumberOfValues, MaximumValueLength;
    DWORD ClassLength = 64, ProtseqLength, IgnoreLength;
    BYTE Protseq[MAX_PROTSEQ_LENGTH+1];
    BYTE MaxValueData[MAX_ENDPOINT_LENGTH+MAX_ID_LENGTH+2+8];
    FILETIME LastWriteTime;
    HKEY RegistryKey;
    unsigned char ClassName[64];
    char * Value;
    RPC_PROTOCOL_INFO * AdditionalProtocolsInfo;
    RPC_STATUS Status = RPC_S_OK;
    unsigned long Length, TransportId;

    RegStatus = RegOpenKeyExA(
                    HKEY_LOCAL_MACHINE,
                    (LPSTR) RPC_REGISTRY_PROTOCOL_IDS,
                    0L, KEY_READ,                      //Reserved
                    &RegistryKey
                    );

    if ( RegStatus != ERROR_SUCCESS )
        {
        return(RPC_S_INVALID_RPC_PROTSEQ);
        }

    RegStatus = RegQueryInfoKeyA(
                    RegistryKey,
                    (LPSTR) ClassName,
                    &ClassLength,
                    0,                                //Reserved
                    &Ignore,
                    &Ignore,
                    &Ignore,
                    &NumberOfValues,
                    &Ignore,
                    &MaximumValueLength,
                    &Ignore,
                    &LastWriteTime
                    );

    if ( (RegStatus != ERROR_SUCCESS) || (NumberOfValues == 0) )
        {
        RegStatus = RegCloseKey(RegistryKey);
        ASSERT( RegStatus == ERROR_SUCCESS );
        return(RPC_S_INVALID_RPC_PROTSEQ);
        }

    //Allocate a table for additional transports mapping

    AdditionalProtocolsInfo = (RPC_PROTOCOL_INFO *) new unsigned char [
                                  sizeof(RPC_PROTOCOL_INFO) *  NumberOfValues];
    if (AdditionalProtocolsInfo == 0)
       {
       Status = RPC_S_OUT_OF_MEMORY;
       goto Cleanup;
       }

    AdditionalProtocols = AdditionalProtocolsInfo;
    TotalAdditionalProtocols = NumberOfValues;

    for (Index = 0; Index < NumberOfValues; Index++)
        {

        ProtseqLength = MAX_PROTSEQ_LENGTH;
        IgnoreLength = MAX_ENDPOINT_LENGTH + MAX_ID_LENGTH;
        RegStatus = RegEnumValueA(
                         RegistryKey,
                         Index,
                         (LPSTR) &Protseq,
                         &ProtseqLength,
                         0,
                         &Ignore,
                         (LPBYTE) MaxValueData,
                         &IgnoreLength
                         );

        if (RegStatus == ERROR_SUCCESS)
           {
           //Add this to our table..
           AdditionalProtocolsInfo->RpcProtocolSequence =
                               new unsigned char[ProtseqLength+1];
           Value = (char  * )&MaxValueData;
           AdditionalProtocolsInfo->RpcSsEndpoint =
                      new unsigned char[Length = (strlen(Value) + 1)];


           if (AdditionalProtocolsInfo->RpcProtocolSequence == 0
               || AdditionalProtocolsInfo->RpcSsEndpoint == 0)
              {
              Status = RPC_S_OUT_OF_MEMORY;
              goto Cleanup;
              }

           RpcpMemoryCopy(
                  AdditionalProtocolsInfo->RpcProtocolSequence,
                  Protseq,
                  ProtseqLength+1
                  );

           RpcpMemoryCopy(
                  AdditionalProtocolsInfo->RpcSsEndpoint,
                  Value,
                  Length
                  );
           Value = Value + Length;

           for (TransportId = 0;
                (*Value > '0') && (*Value <= '9') && (TransportId <= 255);
                Value++)
               {
               TransportId = TransportId * 10 + (*Value - '0');
               }
           AdditionalProtocolsInfo->TransportId = TransportId;

           AdditionalProtocolsInfo++;
           }

        }

Cleanup:
    RegStatus = RegCloseKey(RegistryKey);

    if (Status != RPC_S_OK)
       {
       if (AdditionalProtocols != 0)
          {
          AdditionalProtocolsInfo = AdditionalProtocols;
          for (Index = 0; Index < NumberOfValues; Index++)
              {
              if (AdditionalProtocolsInfo->RpcProtocolSequence != 0)
                  delete AdditionalProtocolsInfo->RpcProtocolSequence;
              if (AdditionalProtocolsInfo->RpcSsEndpoint != 0)
                  delete AdditionalProtocolsInfo->RpcSsEndpoint;
              AdditionalProtocolsInfo++;
              }

          delete AdditionalProtocols;
          AdditionalProtocols = 0;
          TotalAdditionalProtocols = 0;
          }
       }

    return(Status);
}


RPC_STATUS
RpcGetAdditionalTransportInfo(
    IN unsigned long TransportId,
    OUT unsigned char PAPI * PAPI * ProtocolSequence
    )
{
   unsigned long i;
   RPC_PROTOCOL_INFO * ProtocolInfo;

   RequestGlobalMutex();

   if (AdditionalProtocols == 0)
      {
      LoadAdditionalTransportInfo();
      }

   ClearGlobalMutex();

   for (i = 0, ProtocolInfo = AdditionalProtocols ;
        i < TotalAdditionalProtocols;
        i++)
       {
       if (ProtocolInfo->TransportId == TransportId)
          {
          *ProtocolSequence = ProtocolInfo->RpcProtocolSequence;
          return (RPC_S_OK);
          }
       ProtocolInfo ++;
       }

   return(RPC_S_INVALID_RPC_PROTSEQ);

}



RPC_CHAR *
LocalMapRpcProtocolSequence (
    IN RPC_CHAR PAPI * RpcProtocolSequence
    )
/*++

Routine Description:

    We need to check the supplied protocol sequence (and module) to see
    if we can map them into a transport interface dll without having to
    use the registry.

Arguments:

    ServerSideFlag - Supplies a flag indicating whether this protocol
        sequence is to be mapped for a client or a server; a non-zero
        value indicates that it is being mapped for a server.

    RpcProtocolSequence - Supplies the protocol sequence which we need to
        map into a transport interface dll.

Return Value:

    If we successfully map the protocol sequence, then a pointer to a static
    string containing the transport interface dll (name) will be returned;
    the caller must duplicate the string.  Otherwise, zero will be returned.

--*/
{
    unsigned int Index;

    for (Index = 0; Index < RpcProtseqMapLength; Index++)
        {
        if ( RpcpStringCompare(RpcProtocolSequence,
                    RpcProtocolSequenceMap[Index].RpcProtocolSequence) == 0 )
            {
            return((RPC_CHAR *)(RpcProtocolSequenceMap[Index].TransportInterfaceDll));
            }
        }

    return(0);
}

RPC_STATUS
RpcGetWellKnownTransportInfo(
    IN unsigned long TransportId,
    OUT RPC_CHAR **PSeq
    )
{
    unsigned int Index;

    for (Index = 0; Index < RpcProtseqMapLength; Index++)
        {
        if (TransportId == RpcProtocolSequenceMap[Index].TransportId)
            {
            *PSeq = (RPC_CHAR *)RpcProtocolSequenceMap[Index].RpcProtocolSequence;
            return RPC_S_OK;
            }
        }

    return(RPC_S_PROTSEQ_NOT_SUPPORTED);
}


RPC_STATUS
RpcConfigMapRpcProtocolSequence (
    IN unsigned int ServerSideFlag,
    IN RPC_CHAR PAPI * RpcProtocolSequence,
    OUT RPC_CHAR * PAPI * TransportInterfaceDll
    )
/*++

Routine Description:

    This routine is used by the rpc protocol modules to map from an
    rpc protocol sequence to the name of a transport interface dll.

Arguments:

    ServerSideFlag - Supplies a flag indicating whether this protocol
        sequence is to be mapped for a client or a server; a non-zero
        value indicates that it is being mapped for a server.

    RpcProtocolSequence - Supplies the rpc protocol sequence to map.

    TransportInterfaceDll - Returns the transport support dll which
        supports the requested rpc protocol sequence.  This will be a
        newly allocated string which the caller must free.

Return Value:

    RPC_S_OK - Everything worked out fine.

    RPC_S_PROTSEQ_NOT_SUPPORTED - The requested rpc protocol sequence
        does not have a mapping to a transport interface dll for this
        rpc protocol module.

    RPC_S_OUT_OF_MEMORY - We ran out of memory trying to map the rpc
        protocol sequence.

--*/
{
    RPC_CHAR * TempString;
    HKEY RegistryKey;
    DWORD Type;
    long RegStatus;
    unsigned char * KeyString;
    unsigned long Length;

    TempString = LocalMapRpcProtocolSequence(RpcProtocolSequence);
    if ( TempString != 0 )
        {
        *TransportInterfaceDll = new RPC_CHAR[RpcpStringLength(TempString) + 1];
        if ( *TransportInterfaceDll == 0 )
            {
            return(RPC_S_OUT_OF_MEMORY);
            }
        memcpy(*TransportInterfaceDll, TempString,
                (RpcpStringLength(TempString) + 1) * sizeof(RPC_CHAR));
        return(RPC_S_OK);
        }

    KeyString = (unsigned char *) RPC_REGISTRY_PROTOCOLS;

    RegStatus = RegOpenKeyExA(HKEY_LOCAL_MACHINE, (LPSTR) KeyString, 0L,
            KEY_READ, &RegistryKey);
    if ( RegStatus != ERROR_SUCCESS )
        {
        return(RPC_S_PROTSEQ_NOT_SUPPORTED);
        }

    *TransportInterfaceDll = new RPC_CHAR[MAX_DLLNAME_LENGTH + 1];
    if ( *TransportInterfaceDll == 0 )
        {
        RegStatus = RegCloseKey(RegistryKey);
        ASSERT( RegStatus == ERROR_SUCCESS );

        return(RPC_S_OUT_OF_MEMORY);
        }

    Length = (MAX_DLLNAME_LENGTH + 1) * sizeof(RPC_CHAR);
    RegStatus = RegQueryValueEx(RegistryKey, (const RPC_SCHAR *)RpcProtocolSequence,
            0, &Type, (LPBYTE) *TransportInterfaceDll, &Length);

    if ( RegStatus == ERROR_SUCCESS )
        {
        RegStatus = RegCloseKey(RegistryKey);
        ASSERT( RegStatus == ERROR_SUCCESS );

        return(RPC_S_OK);
        }

    RegStatus = RegCloseKey(RegistryKey);
    ASSERT( RegStatus == ERROR_SUCCESS );

    delete *TransportInterfaceDll;

    return(RPC_S_PROTSEQ_NOT_SUPPORTED);
}


RPC_STATUS
RpcConfigInquireProtocolSequencesFromKey (
    OUT RPC_PROTSEQ_VECTOR PAPI * PAPI * ProtseqVector,
    unsigned char *RegistryKeyName
    )
/*++

Routine Description:

    This routine is used to obtain a list of the rpc protocol sequences
    supported by the system using a given registry key as a reference
    point.

Arguments:

    ProtseqVector - Returns a vector of supported rpc protocol sequences
        for this rpc protocol module.
    RegistryKeyName - the path of the registry key, starting from
        HKLM (the HKLM itself should not be supplied)

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_NO_PROTSEQS - The current system configuration does not
        support any rpc protocol sequences.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to inquire
        the rpc protocol sequences supported by the specified rpc
        protocol sequence.

--*/
{
    DWORD RegStatus, Index, Ignore, MaximumValueLength;
    DWORD ClassLength = 64, ProtseqLength, IgnoreLength;
    BYTE IgnoreData[MAX_DLLNAME_LENGTH];
    FILETIME LastWriteTime;
    HKEY RegistryKey = 0;
    unsigned char ClassName[64];
    DWORD NumberOfValues = 0;

    RegStatus = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
            (LPSTR) RegistryKeyName, 0L, KEY_READ, &RegistryKey);

    if ( RegStatus != ERROR_SUCCESS )
        {
        return(RPC_S_NO_PROTSEQS);
        }

    RegStatus = RegQueryInfoKeyA(RegistryKey, (LPSTR) ClassName, &ClassLength,
            0, &Ignore, &Ignore, &Ignore, &NumberOfValues,
            &Ignore, &MaximumValueLength, &Ignore, &LastWriteTime);

    ASSERT( RegStatus == ERROR_SUCCESS );

    if ( RegStatus != ERROR_SUCCESS )
        {
        RegStatus = RegCloseKey(RegistryKey);
        ASSERT( RegStatus == ERROR_SUCCESS );
        return(RPC_S_NO_PROTSEQS);
        }

    NumberOfValues += RpcUseAllProtseqMapLength;

    *ProtseqVector = (RPC_PROTSEQ_VECTOR *) new unsigned char[
            sizeof(RPC_PROTSEQ_VECTOR) + (NumberOfValues - 1)
                    * sizeof(RPC_CHAR *)];

    if ( *ProtseqVector == 0 )
        {
        RegStatus = RegCloseKey(RegistryKey);
        ASSERT( RegStatus == ERROR_SUCCESS );
        return(RPC_S_OUT_OF_MEMORY);
        }

    (*ProtseqVector)->Count = (unsigned int) NumberOfValues;

    for (Index = 0; Index < NumberOfValues; Index++)
        {
        (*ProtseqVector)->Protseq[Index] = 0;
        }

    for (Index = 0; Index < RpcUseAllProtseqMapLength; Index++)
        {
        (*ProtseqVector)->Protseq[Index] = new RPC_CHAR[MAX_PROTSEQ_LENGTH];
        if ( (*ProtseqVector)->Protseq[Index] == 0 )
            {
            RegStatus = RegCloseKey(RegistryKey);
            ASSERT( RegStatus == ERROR_SUCCESS );

            RpcProtseqVectorFree(ProtseqVector);

            return(RPC_S_OUT_OF_MEMORY);
            }

        RpcpStringCopy((*ProtseqVector)->Protseq[Index],
                       RpcUseAllProtseqMap[Index].RpcProtocolSequence);

        }

    unsigned VectorIndex = Index;

    for (Index = 0; VectorIndex < NumberOfValues; Index++, VectorIndex++)
        {
        (*ProtseqVector)->Protseq[VectorIndex] = new RPC_CHAR[MAX_PROTSEQ_LENGTH];
        if ( (*ProtseqVector)->Protseq[VectorIndex] == 0 )
            {
            RegStatus = RegCloseKey(RegistryKey);
            ASSERT( RegStatus == ERROR_SUCCESS );

            RpcProtseqVectorFree(ProtseqVector);

            return(RPC_S_OUT_OF_MEMORY);
            }

        ProtseqLength = MAX_PROTSEQ_LENGTH;
        IgnoreLength = MAX_DLLNAME_LENGTH;
        RegStatus = RegEnumValue(RegistryKey, Index,
                (RPC_SCHAR *)(*ProtseqVector)->Protseq[VectorIndex], &ProtseqLength,
                0, &Ignore, (LPBYTE) IgnoreData, &IgnoreLength);

        ASSERT( RegStatus == ERROR_SUCCESS );

        if (RpcpStringCompare((RPC_SCHAR *)(*ProtseqVector)->Protseq[VectorIndex], RPC_T("ncacn_np")) == 0)
            {
            // ignore this named pipe value - we have to have it in the registry for
            // compatibility purposes with VB, but we don't really use it
            NumberOfValues --;
            (*ProtseqVector)->Count --;
            delete (*ProtseqVector)->Protseq[VectorIndex];
            VectorIndex --;
            }
        }

    RegStatus = RegCloseKey(RegistryKey);
    ASSERT( RegStatus == ERROR_SUCCESS );

    return(RPC_S_OK);
}

RPC_STATUS RpcConfigInquireStaticProtocolSequences(RPC_PROTSEQ_VECTOR **ProtseqVector)
/*++

Routine Description:

    Returns a protseq vector that contains all the protseqs in the static RpcProtocolSequenceMap
        map.

Arguments:

    ProtseqVector - Returns a vector of supported rpc protocol sequences.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to construct the vector.

--*/
{
    int nNumberOfValues = sizeof(RpcProtocolSequenceMap) / sizeof(RpcProtocolSequenceMap[0]);
    int i;

    *ProtseqVector = (RPC_PROTSEQ_VECTOR *) new unsigned char[
            sizeof(RPC_PROTSEQ_VECTOR) + (nNumberOfValues - 1)
                    * sizeof(RPC_CHAR *)];

    if ( *ProtseqVector == 0 )
        return(RPC_S_OUT_OF_MEMORY);

    (*ProtseqVector)->Count = (unsigned int) nNumberOfValues;

    for (i = 0; i < nNumberOfValues; i ++)
        {
        (*ProtseqVector)->Protseq[i] = NULL;
        }

    for (i = 0; i < nNumberOfValues; i ++)
        {
        (*ProtseqVector)->Protseq[i] = new RPC_CHAR[MAX_PROTSEQ_LENGTH];
        if ( (*ProtseqVector)->Protseq[i] == 0 )
            {

            RpcProtseqVectorFree(ProtseqVector);

            return(RPC_S_OUT_OF_MEMORY);
            }

        RpcpStringCopy((*ProtseqVector)->Protseq[i],
                       RpcProtocolSequenceMap[i].RpcProtocolSequence);

        }

    return RPC_S_OK;
}

int MarkDuplicateEntries(IN RPC_PROTSEQ_VECTOR *ProtseqVector1,
                         IN int nVector1CurrentPos,
                         IN RPC_PROTSEQ_VECTOR *ProtseqVector2 OPTIONAL,
                         IN OUT UCHAR *pfDuplicates1,
                         IN OUT UCHAR *pfDuplicates2)

/*++

Routine Description:

    This routine is tightly coupled with RpcConfigInquireProtocolSequences.
    If the current element is already marked as duplicate by previous
    run of this function, we directly return 1. If not,
    it checks whether the current element is duplicate of any element
    starting with the nVetcor1StartingPos from the first vector, and
    going through the whole second vector if it is there, and marking
    all duplicates of the current element as such. Then 0 is returned.
    If the second vector is NULL, the pfDuplicates2 must be NULL also. This
    means that there is one vector only, and its data are passed in
    in RpcProtseqVector1 and in pfDuplicates1.

Arguments:

    RpcProtseqVector1 - the first vector
    nVector1CurrentPos - the current position from the first vector
    RpcProtseqVector2 - the second vector. This argument may be null
    pfDuplicates1 - the array of duplicate flags for the first vector
    pfDuplicates2 - the array of duplicate flags for the second vector. If
        second vector is NULL, must be NULL also.

Return Value:

    1 - the current element is a duplicate of an element that we
        encountered in a previous run of this function.
    0 - the current element is unique in both vectors

--*/
{
    int i;
    RPC_CHAR *pszCurrentElement;

    ASSERT(nVector1CurrentPos < (int)ProtseqVector1->Count);

    if (pfDuplicates1[nVector1CurrentPos])
        return 1;

    pszCurrentElement = ProtseqVector1->Protseq[nVector1CurrentPos];

    for (i = nVector1CurrentPos + 1; i < (int)ProtseqVector1->Count; i ++)
        {
        if (RpcpStringCompare(pszCurrentElement,
            ProtseqVector1->Protseq[i]) == 0)
            {
            pfDuplicates1[i] = TRUE;
            }
        }

    if (ProtseqVector2)
        {
        ASSERT(pfDuplicates2 != NULL);

        for (i = 0; i < (int)ProtseqVector2->Count; i ++)
            {
            if (RpcpStringCompare(pszCurrentElement,
                ProtseqVector2->Protseq[i]) == 0)
                {
                pfDuplicates2[i] = TRUE;
                }
            }
        }
    else
        {
        ASSERT(pfDuplicates2 == NULL);
        }

    return 0;
}

RPC_STATUS
MergeProtseqVectors (IN OUT RPC_PROTSEQ_VECTOR *ProtseqVector1,
                     IN OUT RPC_PROTSEQ_VECTOR *ProtseqVector2 OPTIONAL,
                     OUT RPC_PROTSEQ_VECTOR **ProtseqVector
                     )

/*++

Routine Description:

    This routine takes two protseq vectors, and in the OUT argument ProtseqVector
        returns the resulting vector, which is a union of the two IN
        vectors. Successful or not, the input vectors will be freed on exit.

Arguments:

    ProtseqVector1 - the first vector
    ProtseqVector2 - the second vector. This argument may be null in which case the
        output vector is simply the first vector.
    ProtseqVector - the resulting union vector. If the return value from the function
        is not RPC_S_OK, the out parameter is undefined and should not be used by caller.

Return Value:

    RPC_S_OK - success. The ProtseqVector argument contains the resulting vector.
    error code - the cause of the error.

--*/
{
    unsigned char *pfDuplicate1;
    unsigned char *pfDuplicate2;
    int i, j;
    int nDuplicateElements;
    int nCurrentElement;
    int nUniqueElements;

    // compare basically each with each
    // construct arrays in which we will mark each duplicate element
    // if it is such
    pfDuplicate1 = (unsigned char *)alloca(ProtseqVector1->Count);
    if (ProtseqVector2)
        pfDuplicate2 = (unsigned char *)alloca(ProtseqVector2->Count);
    else
        pfDuplicate2 = NULL;

    // all elements are presumed to be unique unless proven otherwise
    memset(pfDuplicate1, 0, ProtseqVector1->Count);
    if (ProtseqVector2)
        memset(pfDuplicate2, 0, ProtseqVector2->Count);

    nDuplicateElements = 0;

    // do compare each with each
    // test the first vector for uniqueness
    for (i = 0; i < (int)ProtseqVector1->Count; i ++)
        {
        nDuplicateElements += MarkDuplicateEntries(ProtseqVector1, i,
            ProtseqVector2, pfDuplicate1, pfDuplicate2);
        }

    if (ProtseqVector2)
        {
        // test the second vector for uniqueness
        for (i = 0; i < (int)ProtseqVector2->Count; i ++)
            {
            nDuplicateElements += MarkDuplicateEntries(ProtseqVector2, i,
                NULL, pfDuplicate2, NULL);
            }
        }

    // here we must move the unique elements to a new vector
    // first, calculate the length of the new vector
    nUniqueElements = ProtseqVector1->Count - nDuplicateElements;
    if (ProtseqVector2)
        nUniqueElements += ProtseqVector2->Count;

    // second, alloc the new vector
    *ProtseqVector = (RPC_PROTSEQ_VECTOR *) new unsigned char[
            sizeof(RPC_PROTSEQ_VECTOR) +
            (nUniqueElements - 1) * sizeof(RPC_CHAR *)];
    if (*ProtseqVector == NULL)
        {
        RpcProtseqVectorFree(&ProtseqVector1);
        if (ProtseqVector2)
            RpcProtseqVectorFree(&ProtseqVector2);
        return RPC_S_OUT_OF_MEMORY;
        }

    // set the count of the union vector
    (*ProtseqVector)->Count = nUniqueElements;

    nCurrentElement = 0;    // counts the current element in the union
                            // vector
    for (i = 0; i < (int)ProtseqVector1->Count; i ++)
        {
        if (!pfDuplicate1[i])
            {
            (*ProtseqVector)->Protseq[nCurrentElement] =
                ProtseqVector1->Protseq[i];
            nCurrentElement ++;
            // save the string from deletion
            ProtseqVector1->Protseq[i] = NULL;
            }
        }

    if (ProtseqVector2)
        {
        for (i = 0; i < (int)ProtseqVector2->Count; i ++)
            {
            if (!pfDuplicate2[i])
                {
                (*ProtseqVector)->Protseq[nCurrentElement] =
                    ProtseqVector2->Protseq[i];
                nCurrentElement ++;
                // save the string from deletion
                ProtseqVector2->Protseq[i] = NULL;
                }
            }
        }

    // we don't need the original vectors anymore - delete them
    RpcProtseqVectorFree(&ProtseqVector1);
    if (ProtseqVector2)
        RpcProtseqVectorFree(&ProtseqVector2);

    return RPC_S_OK;
}


RPC_STATUS
RpcConfigInquireProtocolSequences (
    IN BOOL fGetAllProtseqs,
    OUT RPC_PROTSEQ_VECTOR PAPI * PAPI * ProtseqVector1
    )
/*++

Routine Description:

    This routine is used to obtain a list of the rpc protocol sequences
    supported by the system.

Arguments:

    fGetAllProtseqs - if TRUE, all protseqs known will be returned. If FALSE,
        only the protseqs currently installed will be returned.
    ProtseqVector - Returns a vector of supported rpc protocol sequences
        for this rpc protocol module.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_NO_PROTSEQS - The current system configuration does not
        support any rpc protocol sequences.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to inquire
        the rpc protocol sequences supported by rpc.

--*/
{
    RPC_STATUS RpcStatus1;
    RPC_STATUS RpcStatus2;
    RPC_PROTSEQ_VECTOR *ProtseqVector2 = NULL;
    RPC_PROTSEQ_VECTOR *ProtseqVector;

    if (fGetAllProtseqs)
        {
        RpcStatus2 = RpcConfigInquireStaticProtocolSequences(&ProtseqVector2);
        if (RpcStatus2 != RPC_S_OK)
            return RpcStatus2;
        }

    // under NT, failure to query the registry vector is fatal. Under Win98, querying
    // this registry vector is optional, and if we fail, we have to continue gathering the
    // vector from other sources.
    RpcStatus1 = RpcConfigInquireProtocolSequencesFromKey(
        ProtseqVector1, (unsigned char *)RPC_REGISTRY_PROTOCOLS);

    if (RpcStatus1 != RPC_S_OK)
        {
        RpcProtseqVectorFree(&ProtseqVector2);
        return RpcStatus1;
        }

    if (fGetAllProtseqs)
        {
        // Merge the static vector and the one from the registry
        RpcStatus1 = MergeProtseqVectors(*ProtseqVector1, ProtseqVector2, &ProtseqVector);
        if (RpcStatus1 != RPC_S_OK)
            {
            return RpcStatus1;
            }

        *ProtseqVector1 = ProtseqVector;
        }

    return RpcStatus1;
}

// N.B. This enumration must agree with the values
// in system.adm
typedef enum tagStateInformationPolicyValues
{
    sipvNone,
    sipvAuto1,
    sipvAuto2,
    sipvServer,
    sipvFull
} StateInformationPolicyValues;

// N.B. This enumration must agree with the values
// in system.adm
typedef enum tagEEInfoPolicyValues
{
    eeipvOff,
    eeipvOnWithExceptions,
    eeipvOffWithExceptions,
    eeipvOn
} EEInfoPolicyValues;

void 
SetAutoPolicySettings(
    StateInformationPolicyValues PolicyValue
    )
/*++

Routine Description:

    This routine sets the state information maintenance to the appropriate
    level of Auto, depending on machine capacity.

Arguments:

    PolicyValue - sipvAuto1 or sipvAuto2

Return Value:

    RPC_S_OK - The operation completed successfully.

    other RPC_S_* - error

--*/
{
    NT_PRODUCT_TYPE ProductType;
    BOOL fNeedServer;
    ULONG_PTR MinMemoryNeeded;
    MEMORYSTATUSEX MemoryStatus;
    BOOL fResult;

    ASSERT((PolicyValue == sipvAuto1) || (PolicyValue == sipvAuto2));

    // client side debug info is FALSE by default - no need to
    // set it explicitly

    // see what we have
    // RtlGetNtProductType always returns valid ProductType
    // It may be incorrect during GUI mode setup, but it will
    // be valid
    (VOID) RtlGetNtProductType(&ProductType);

    MemoryStatus.dwLength = sizeof(MemoryStatus);
    fResult = GlobalMemoryStatusEx(&MemoryStatus);
    ASSERT(fResult);

    // see what we have been asked for
    if (PolicyValue == sipvAuto1)
        {
        fNeedServer = FALSE;
        MinMemoryNeeded = 64 * 1024 * 1024;     // 64MB of RAM
        }
    else 
        {
        ASSERT (PolicyValue == sipvAuto2);
        fNeedServer = TRUE;
        MinMemoryNeeded = 127 * 1024 * 1024;    // 127MB of RAM
        }

    // if we need server, but this is workstation, no state info
    if (fNeedServer && (ProductType == NtProductWinNt))
        {
        g_fServerSideDebugInfoEnabled = FALSE;
        return;
        }

    // if we have less physical memory than the one we need,
    // no state info
    if (MemoryStatus.ullTotalPhys < (ULONGLONG) MinMemoryNeeded)
        {
        g_fServerSideDebugInfoEnabled = FALSE;
        return;
        }

    g_fServerSideDebugInfoEnabled = TRUE;
}

typedef enum tagExceptionListParserState
{
    elpsOutsideOfQuotes,
    elpsInsideQuotes,
    elpsReadingWhitespace,
    elpsReadingCharacter
} ExceptionListParserState;

BOOL
DoesThisProcessCmdLineStartWithThisString (
    IN LPWSTR CmdLine,
    IN LPWSTR CmdLineStart
    )
/*++

Routine Description:

    Checks if the process name starts with the string given
    in CmdLineStart

Arguments:

    CmdLine - the process command line with path name stripped
    CmdLineStart - the patter to match against

Return Value:

    non-zero - there is a match
    FALSE - there is no match

--*/
{
    int CmdLineLength = RpcpStringLength(CmdLine);
    int CmdLineStartLength = RpcpStringLength(CmdLineStart);

    if (CmdLineLength >= CmdLineStartLength)
        {
        if (RpcpStringNCompare(CmdLine, CmdLineStart, CmdLineStartLength) == 0)
            return TRUE;
        }
    return FALSE;    
}

typedef enum tagExceptionListCharacterTypes
{
    elctQuotes,
    elctCharacter,
    elctWhitespace
} ExceptionListCharacterTypes;

inline ExceptionListCharacterTypes
GetCharacterType (
    RPC_CHAR Character
    )
{
    if (Character == '"')
        return elctQuotes;
    if (Character == ' ')
        return elctWhitespace;
    return elctCharacter;
}

RPC_STATUS
IsThisProcessAnException (
    IN HKEY RegistryKey,
    BOOL *fThisProcessIsException
    )
/*++

Routine Description:

    Checks whether the current process is in the exceptions list as
    specified in the ExtErrorInfoExceptions registry key

Arguments:

    RegistryKey - an open key to RPC_POLICY_SETTINGS
    fThisProcessIsException - on output non-zero if this process is
        an exception and FALSE otherwise

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    DWORD RegStatus;
    RPC_CHAR *Buffer = NULL;
    DWORD Type;
    DWORD Size = 0;
    int Retries = 5;
    int State;
    RPC_CHAR *CurrentPos;
    RPC_CHAR *CurrentString;
    RPC_CHAR *CommandLine;
    RPC_CHAR *LastBackslash;
    BOOL fIsSubstring;

    *fThisProcessIsException = FALSE;

    while (Retries > 0)
        {
        RegStatus = RegQueryValueExW(
                        RegistryKey,
                        L"ExtErrorInfoExceptions",
                        0,
                        &Type,
                        (LPBYTE) Buffer,
                        &Size
                        );

        if ( (RegStatus != ERROR_SUCCESS) && (RegStatus != ERROR_MORE_DATA) )
            {
            if (RegStatus == ERROR_FILE_NOT_FOUND)
                RegStatus = RPC_S_OK;
            else
                RegStatus = RPC_S_OUT_OF_MEMORY;

            goto CleanupAndReturn;
            }
        else
            {
            if ((Buffer == NULL) || (RegStatus == ERROR_MORE_DATA))
                {
                if (Buffer)
                    delete Buffer;

                Buffer = new RPC_CHAR[Size];
                if (Buffer == NULL)
                    {
                    RegStatus = RPC_S_OUT_OF_MEMORY;
                    goto CleanupAndReturn;
                    }

                continue;
                }

            if (Type != REG_SZ)
                {
                RegStatus = RPC_S_INTERNAL_ERROR;
                goto CleanupAndReturn;
                }

            ASSERT(RegStatus == RPC_S_OK);

            CommandLine = GetCommandLine();
            LastBackslash = wcsrchr(CommandLine, '\\');
            if (LastBackslash != NULL)
                CommandLine = LastBackslash + 1;

            // here, Buffer contains the exception string
            // The format of the exception string is:
            // "cmd_line_start" "cmd_line_start" ...
            // If there is only one cmd_line_start, it doesn't have to be in double quotes
            State = elpsOutsideOfQuotes;
            CurrentPos = Buffer;
            CurrentString = NULL;
            while (*CurrentPos != 0)
                {
                switch (State)
                    {
                    case elpsOutsideOfQuotes:
                        switch (GetCharacterType(*CurrentPos))
                            {
                            case elctQuotes:
                                CurrentString = CurrentPos;
                                State = elpsInsideQuotes;
                                break;

                            case elctCharacter:
                                CurrentString = CurrentPos;
                                State = elpsReadingCharacter;
                                break;

                            case elctWhitespace:
                                State = elpsReadingWhitespace;
                                break;

                            default:
                                ASSERT(0);
                            }
                        break;

                    case elpsReadingCharacter:
                        switch (GetCharacterType(*CurrentPos))
                            {
                            case elctQuotes:
                                *CurrentPos = 0;
                                fIsSubstring = DoesThisProcessCmdLineStartWithThisString(
                                    CommandLine, CurrentString);
                                if (fIsSubstring)
                                    {
                                    *fThisProcessIsException = TRUE;
                                    goto CleanupAndReturn;
                                    }
                                CurrentString = CurrentPos + 1;
                                State = elpsReadingCharacter;
                                break;

                            case elctWhitespace:
                                *CurrentPos = 0;
                                fIsSubstring = DoesThisProcessCmdLineStartWithThisString(
                                    CommandLine, CurrentString);
                                if (fIsSubstring)
                                    {
                                    *fThisProcessIsException = TRUE;
                                    goto CleanupAndReturn;
                                    }
                                State = elpsReadingCharacter;
                                break;

                            // default:
                                // can be elpsReadingCharacter
                            }
                        break;

                    case elpsReadingWhitespace:
                        switch (GetCharacterType(*CurrentPos))
                            {
                            case elctQuotes:
                                CurrentString = CurrentPos + 1;
                                State = elpsInsideQuotes;
                                break;

                            case elctCharacter:
                                CurrentString = CurrentPos;
                                State = elpsReadingCharacter;
                                break;

                            // default:
                                // can be elctWhitespace
                            }
                        break;

                    case elpsInsideQuotes:
                        switch (GetCharacterType(*CurrentPos))
                            {
                            case elctQuotes:
                                *CurrentPos = 0;
                                fIsSubstring = DoesThisProcessCmdLineStartWithThisString(
                                    CommandLine, CurrentString);
                                if (fIsSubstring)
                                    {
                                    *fThisProcessIsException = TRUE;
                                    goto CleanupAndReturn;
                                    }
                                State = elpsOutsideOfQuotes;
                                break;

                            //default:
                                // can be elctCharacter or elctWhitespace
                            }
                        break;

                    default:
                        ASSERT(0);
                    }
                CurrentPos ++;
                }

                if (CurrentString)
                    {
                    fIsSubstring = DoesThisProcessCmdLineStartWithThisString(
                        CommandLine, CurrentString);
                    if (fIsSubstring)
                        {
                        *fThisProcessIsException = TRUE;
                        goto CleanupAndReturn;
                        }
                    }
                break;
            }

            Retries --;
        }

CleanupAndReturn:
    if (Buffer)
        delete Buffer;
    if (Retries == 0)
        RegStatus = RPC_S_INTERNAL_ERROR;
    return RegStatus;
}

RPC_STATUS ReadPolicySettings(void)
/*++

Routine Description:

    Reads the policy settings for RPC and sets the appropriate global
    variables.

Arguments:

    void

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    HKEY RegistryKey;
    DWORD RegStatus;
    DWORD Result;
    DWORD Type;
    DWORD DwordSize = sizeof(DWORD);
    BOOL ThisProcessIsException;

    RegStatus = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    (LPWSTR) RPC_POLICY_SETTINGS,
                    0L,                       //Reserved
                    KEY_READ,
                    &RegistryKey
                    );

    if ( RegStatus != ERROR_SUCCESS )
        {
        if (RegStatus == ERROR_FILE_NOT_FOUND)
            {
            SetAutoPolicySettings(sipvAuto2);
            return RPC_S_OK;
            }
        return RPC_S_OUT_OF_MEMORY;
        }

    RegStatus = RegQueryValueExW(
                    RegistryKey,
                    L"StateInformation",
                    0,
                    &Type,
                    (LPBYTE) &Result,
                    &DwordSize
                    );

    if ( RegStatus != ERROR_SUCCESS )
        {
        if (RegStatus == ERROR_FILE_NOT_FOUND)
            {
            SetAutoPolicySettings(sipvAuto2);
            RegStatus = RPC_S_OK;
            }
        else
            {
            RegStatus = RPC_S_OUT_OF_MEMORY;
            goto CleanupAndReturn;
            }
        }
    else
        {

        if (Type != REG_DWORD)
            {
            RegStatus = RPC_S_INTERNAL_ERROR;
            goto CleanupAndReturn;
            }

        ASSERT(RegStatus == RPC_S_OK);

        switch (Result)
            {
            case sipvNone:
                // nothing to do - the client/server DebugInfoEnabled values
                // are off by default
                break;

            case sipvAuto1:
            case sipvAuto2:
                SetAutoPolicySettings((StateInformationPolicyValues)Result);
                break;

            case sipvServer:
                g_fServerSideDebugInfoEnabled = TRUE;
                break;

            case sipvFull:
                g_fServerSideDebugInfoEnabled = TRUE;
                g_fClientSideDebugInfoEnabled = TRUE;
                break;

            default:
                RegStatus = RPC_S_INTERNAL_ERROR;
                goto CleanupAndReturn;
            }

        }

    RegStatus = RegQueryValueExW(
                    RegistryKey,
                    L"ExtErrorInformation",
                    0,
                    &Type,
                    (LPBYTE) &Result,
                    &DwordSize
                    );

    if ( RegStatus != ERROR_SUCCESS )
        {
        if (RegStatus == ERROR_FILE_NOT_FOUND)
            {
            RegStatus = RPC_S_OK;
            }
        else
            {
            RegStatus = RPC_S_OUT_OF_MEMORY;
            goto CleanupAndReturn;
            }
        }
    else
        {

        if (Type != REG_DWORD)
            {
            RegStatus = RPC_S_INTERNAL_ERROR;
            goto CleanupAndReturn;
            }

        ASSERT(RegStatus == RPC_S_OK);

        switch (Result)
            {
            case eeipvOff:
                // nothing to do - the g_fSendEEInfo is already false
                break;

            case eeipvOnWithExceptions:
                RegStatus = IsThisProcessAnException(RegistryKey,
                    &ThisProcessIsException);
                if ((RegStatus != RPC_S_OK) || (ThisProcessIsException == FALSE))
                    g_fSendEEInfo = TRUE;
                break;

            case eeipvOffWithExceptions:
                RegStatus = IsThisProcessAnException(RegistryKey,
                    &ThisProcessIsException);
                if ((RegStatus == RPC_S_OK) && (ThisProcessIsException == TRUE))
                    g_fSendEEInfo = TRUE;
                break;

            case eeipvOn:
                g_fSendEEInfo = TRUE;
                break;

            default:
                RegStatus = RPC_S_INTERNAL_ERROR;
                goto CleanupAndReturn;
            }
        }

CleanupAndReturn:
    RegCloseKey(RegistryKey);
    return RegStatus;
}

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcSystemFunction001 (
    IN SystemFunction001Commands FunctionCode,
    IN void *InData,
    OUT void *OutData
    )
/*++

Routine Description:

    Test hook.

Arguments:

    FunctionCode - which test function to perform

    InData - input data from the test function

    OutData - output data from the test function

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    THREAD *Thread;

    InitializeIfNecessary();

    Thread = ThreadSelf();
    if (!Thread)
        return RPC_S_OUT_OF_MEMORY;

    RpcpPurgeEEInfoFromThreadIfNecessary(Thread);

    switch (FunctionCode)
        {
        case sf001cHttpSetInChannelTarget:
        case sf001cHttpSetOutChannelTarget:
            return HTTP2TestHook (FunctionCode,
                InData,
                OutData
                );
            break;

        default:
            return RPC_S_CANNOT_SUPPORT;
        }

    return RPC_S_OK;
}

#ifdef WINNT35_UUIDS

unsigned long
SomeLongValue (
    )
/*++

Routine Description:

    This routine, SomeShortValue, AnotherShortValue, and SomeCharacterValue
    are used to generate the fields of a GUID if we can not determine
    the network address from the network card (so we can generate a
    UUID).  These routines must generate some pseudo random values
    based on the current time and/or the time since boot as well as the
    current process and thread.

    For the long value, we will use the current thread identifier and
    current process identifier bitwise exclusive ored together.

    For the two short values, we use the low part of the time field
    (which is long, which we split into two values).

    Finally, for the character value, we use a constant.

Return Value:

    An unsigned long value will be returned.

--*/
{
    TEB * CurrentTeb;

    CurrentTeb = NtCurrentTeb();
    return(((unsigned long) CurrentTeb->ClientId.UniqueThread)
            ^ ((unsigned long) CurrentTeb->ClientId.UniqueProcess));
}


unsigned short
SomeShortValue (
    )
/*++

See SomeLongValue.

--*/
{
    LARGE_INTEGER SystemTime;

    for (;;)
        {
        NtQuerySystemTime(&SystemTime);
        if (ThreadSelf()->TimeLow != SystemTime.LowPart)
            break;
        PauseExecution(1L);
        }
    ThreadSelf()->TimeLow = SystemTime.LowPart;
    return((unsigned short) SystemTime.LowPart);
}


unsigned short
AnotherShortValue (
    )
/*++

See SomeLongValue.

--*/
{
    return((unsigned short) (ThreadSelf()->TimeLow >> 16));
}


unsigned char
SomeCharacterValue (
    )
/*++

See SomeLongValue.

--*/
{
    return(0x69);
}

#endif WINNT35_UUIDS



typedef struct {
    RPC_STATUS RpcStatus;
    long NtStatus;
    } STATUS_MAPPING;

static const STATUS_MAPPING StatusMap[] =
    {
    { RPC_S_OK, STATUS_SUCCESS },
    { RPC_S_INVALID_STRING_BINDING, RPC_NT_INVALID_STRING_BINDING },
    { RPC_S_WRONG_KIND_OF_BINDING, RPC_NT_WRONG_KIND_OF_BINDING },
    { RPC_S_INVALID_BINDING, RPC_NT_INVALID_BINDING },
    { RPC_S_PROTSEQ_NOT_SUPPORTED, RPC_NT_PROTSEQ_NOT_SUPPORTED },
    { RPC_S_INVALID_RPC_PROTSEQ, RPC_NT_INVALID_RPC_PROTSEQ },
    { RPC_S_INVALID_STRING_UUID, RPC_NT_INVALID_STRING_UUID },
    { RPC_S_INVALID_ENDPOINT_FORMAT, RPC_NT_INVALID_ENDPOINT_FORMAT },
    { RPC_S_INVALID_NET_ADDR, RPC_NT_INVALID_NET_ADDR },
    { RPC_S_NO_ENDPOINT_FOUND, RPC_NT_NO_ENDPOINT_FOUND },
    { RPC_S_INVALID_TIMEOUT, RPC_NT_INVALID_TIMEOUT },
    { RPC_S_OBJECT_NOT_FOUND, RPC_NT_OBJECT_NOT_FOUND },
    { RPC_S_ALREADY_REGISTERED, RPC_NT_ALREADY_REGISTERED },
    { RPC_S_TYPE_ALREADY_REGISTERED, RPC_NT_TYPE_ALREADY_REGISTERED },
    { RPC_S_ALREADY_LISTENING, RPC_NT_ALREADY_LISTENING },
    { RPC_S_NO_PROTSEQS_REGISTERED, RPC_NT_NO_PROTSEQS_REGISTERED },
    { RPC_S_NOT_LISTENING, RPC_NT_NOT_LISTENING },
    { RPC_S_UNKNOWN_MGR_TYPE, RPC_NT_UNKNOWN_MGR_TYPE },
    { RPC_S_UNKNOWN_IF, RPC_NT_UNKNOWN_IF },
    { RPC_S_NO_BINDINGS, RPC_NT_NO_BINDINGS },
    { RPC_S_NO_MORE_BINDINGS, RPC_NT_NO_MORE_BINDINGS },
    { RPC_S_NO_PROTSEQS, RPC_NT_NO_PROTSEQS },
    { RPC_S_CANT_CREATE_ENDPOINT, RPC_NT_CANT_CREATE_ENDPOINT },
    { RPC_S_OUT_OF_RESOURCES, RPC_NT_OUT_OF_RESOURCES },
    { RPC_S_SERVER_UNAVAILABLE, RPC_NT_SERVER_UNAVAILABLE },
    { RPC_S_SERVER_TOO_BUSY, RPC_NT_SERVER_TOO_BUSY },
    { RPC_S_INVALID_NETWORK_OPTIONS, RPC_NT_INVALID_NETWORK_OPTIONS },
    { RPC_S_NO_CALL_ACTIVE, RPC_NT_NO_CALL_ACTIVE },
    { RPC_S_CALL_FAILED, RPC_NT_CALL_FAILED },
    { RPC_S_CALL_CANCELLED, RPC_NT_CALL_CANCELLED },
    { RPC_S_CALL_FAILED_DNE, RPC_NT_CALL_FAILED_DNE },
    { RPC_S_PROTOCOL_ERROR, RPC_NT_PROTOCOL_ERROR },
    { RPC_S_UNSUPPORTED_TRANS_SYN, RPC_NT_UNSUPPORTED_TRANS_SYN },
    { RPC_S_SERVER_OUT_OF_MEMORY, STATUS_INSUFF_SERVER_RESOURCES },
    { RPC_S_UNSUPPORTED_TYPE, RPC_NT_UNSUPPORTED_TYPE },
    { RPC_S_INVALID_TAG, RPC_NT_INVALID_TAG },
    { RPC_S_INVALID_BOUND, RPC_NT_INVALID_BOUND },
    { RPC_S_NO_ENTRY_NAME, RPC_NT_NO_ENTRY_NAME },
    { RPC_S_INVALID_NAME_SYNTAX, RPC_NT_INVALID_NAME_SYNTAX },
    { RPC_S_UNSUPPORTED_NAME_SYNTAX, RPC_NT_UNSUPPORTED_NAME_SYNTAX },
    { RPC_S_UUID_NO_ADDRESS, RPC_NT_UUID_NO_ADDRESS },
    { RPC_S_DUPLICATE_ENDPOINT, RPC_NT_DUPLICATE_ENDPOINT },
    { RPC_S_UNKNOWN_AUTHN_TYPE, RPC_NT_UNKNOWN_AUTHN_TYPE },
    { RPC_S_MAX_CALLS_TOO_SMALL, RPC_NT_MAX_CALLS_TOO_SMALL },
    { RPC_S_STRING_TOO_LONG, RPC_NT_STRING_TOO_LONG },
    { RPC_S_PROTSEQ_NOT_FOUND, RPC_NT_PROTSEQ_NOT_FOUND },
    { RPC_S_PROCNUM_OUT_OF_RANGE, RPC_NT_PROCNUM_OUT_OF_RANGE },
    { RPC_S_BINDING_HAS_NO_AUTH, RPC_NT_BINDING_HAS_NO_AUTH },
    { RPC_S_UNKNOWN_AUTHN_SERVICE, RPC_NT_UNKNOWN_AUTHN_SERVICE },
    { RPC_S_UNKNOWN_AUTHN_LEVEL, RPC_NT_UNKNOWN_AUTHN_LEVEL },
    { RPC_S_INVALID_AUTH_IDENTITY, RPC_NT_INVALID_AUTH_IDENTITY },
    { RPC_S_UNKNOWN_AUTHZ_SERVICE, RPC_NT_UNKNOWN_AUTHZ_SERVICE },
    { EPT_S_INVALID_ENTRY, EPT_NT_INVALID_ENTRY },
    { EPT_S_CANT_PERFORM_OP, EPT_NT_CANT_PERFORM_OP },
    { EPT_S_NOT_REGISTERED, EPT_NT_NOT_REGISTERED },
    { RPC_S_NOTHING_TO_EXPORT, RPC_NT_NOTHING_TO_EXPORT },
    { RPC_S_INCOMPLETE_NAME, RPC_NT_INCOMPLETE_NAME },
    { RPC_S_INVALID_VERS_OPTION, RPC_NT_INVALID_VERS_OPTION },
    { RPC_S_NO_MORE_MEMBERS, RPC_NT_NO_MORE_MEMBERS },
    { RPC_S_NOT_ALL_OBJS_UNEXPORTED, RPC_NT_NOT_ALL_OBJS_UNEXPORTED },
    { RPC_S_INTERFACE_NOT_FOUND, RPC_NT_INTERFACE_NOT_FOUND },
    { RPC_S_ENTRY_ALREADY_EXISTS, RPC_NT_ENTRY_ALREADY_EXISTS },
    { RPC_S_ENTRY_NOT_FOUND, RPC_NT_ENTRY_NOT_FOUND },
    { RPC_S_NAME_SERVICE_UNAVAILABLE, RPC_NT_NAME_SERVICE_UNAVAILABLE },
    { RPC_S_INVALID_NAF_ID, RPC_NT_INVALID_NAF_ID },
    { RPC_S_CANNOT_SUPPORT, RPC_NT_CANNOT_SUPPORT },
    { RPC_S_NO_CONTEXT_AVAILABLE, RPC_NT_NO_CONTEXT_AVAILABLE },
    { RPC_S_INTERNAL_ERROR, RPC_NT_INTERNAL_ERROR },
    { RPC_S_ZERO_DIVIDE, RPC_NT_ZERO_DIVIDE },
    { RPC_S_ADDRESS_ERROR, RPC_NT_ADDRESS_ERROR },
    { RPC_S_FP_DIV_ZERO, RPC_NT_FP_DIV_ZERO },
    { RPC_S_FP_UNDERFLOW, RPC_NT_FP_UNDERFLOW },
    { RPC_S_FP_OVERFLOW, RPC_NT_FP_OVERFLOW },
    { RPC_X_NO_MORE_ENTRIES, RPC_NT_NO_MORE_ENTRIES },
    { RPC_X_SS_CHAR_TRANS_OPEN_FAIL, RPC_NT_SS_CHAR_TRANS_OPEN_FAIL },
    { RPC_X_SS_CHAR_TRANS_SHORT_FILE, RPC_NT_SS_CHAR_TRANS_SHORT_FILE },
    { RPC_X_SS_IN_NULL_CONTEXT, RPC_NT_SS_IN_NULL_CONTEXT },
    { RPC_X_SS_CONTEXT_MISMATCH, RPC_NT_SS_CONTEXT_MISMATCH },
    { RPC_X_SS_CONTEXT_DAMAGED, RPC_NT_SS_CONTEXT_DAMAGED },
    { RPC_X_SS_HANDLES_MISMATCH, RPC_NT_SS_HANDLES_MISMATCH },
    { RPC_X_SS_CANNOT_GET_CALL_HANDLE, RPC_NT_SS_CANNOT_GET_CALL_HANDLE },
    { RPC_X_NULL_REF_POINTER, RPC_NT_NULL_REF_POINTER },
    { RPC_X_ENUM_VALUE_OUT_OF_RANGE, RPC_NT_ENUM_VALUE_OUT_OF_RANGE },
    { RPC_X_BYTE_COUNT_TOO_SMALL, RPC_NT_BYTE_COUNT_TOO_SMALL },
    { RPC_X_BAD_STUB_DATA, RPC_NT_BAD_STUB_DATA },
    { ERROR_INVALID_PARAMETER, STATUS_INVALID_PARAMETER },
    { ERROR_OUTOFMEMORY, STATUS_NO_MEMORY },
    { ERROR_MAX_THRDS_REACHED, STATUS_NO_MEMORY },
    { ERROR_INSUFFICIENT_BUFFER, STATUS_BUFFER_TOO_SMALL },
    { ERROR_INVALID_SECURITY_DESCR, STATUS_INVALID_SECURITY_DESCR },
    { ERROR_ACCESS_DENIED, STATUS_ACCESS_DENIED },
    { ERROR_NOACCESS, STATUS_ACCESS_VIOLATION },
    { RPC_S_CALL_IN_PROGRESS, RPC_NT_CALL_IN_PROGRESS },
    { RPC_S_GROUP_MEMBER_NOT_FOUND, RPC_NT_GROUP_MEMBER_NOT_FOUND },
    { EPT_S_CANT_CREATE, EPT_NT_CANT_CREATE },
    { RPC_S_INVALID_OBJECT, RPC_NT_INVALID_OBJECT },
    { RPC_S_INVALID_ASYNC_HANDLE, RPC_NT_INVALID_ASYNC_HANDLE },
    { RPC_S_INVALID_ASYNC_CALL, RPC_NT_INVALID_ASYNC_CALL },
    { RPC_X_PIPE_CLOSED, RPC_NT_PIPE_CLOSED },
    { RPC_X_PIPE_EMPTY, RPC_NT_PIPE_EMPTY },
    { RPC_X_PIPE_DISCIPLINE_ERROR, RPC_NT_PIPE_DISCIPLINE_ERROR }
    };

long RPC_ENTRY
I_RpcMapWin32Status (
    IN RPC_STATUS Status
    )
/*++

Routine Description:

    This routine maps a WIN32 RPC status code into an NT RPC status code.

Arguments:

    Status - Supplies the WIN32 RPC status code to be mapped.

Return Value:

    The NT RPC status code corresponding to the WIN32 RPC status code
    will be returned.

--*/
{
    register int i;
    for(i = 0; i < sizeof(StatusMap)/sizeof(STATUS_MAPPING); i++)
        {
        if (StatusMap[i].RpcStatus == Status)
            {
            return(StatusMap[i].NtStatus);
            }
        }
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\osfpcket.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    osfpcket.cxx

Abstract:

    This file provides helper routines for dealing with packets for the
    OSF Connection Oriented RPC protocol.

Author:

    Michael Montague (mikemon) 23-Jul-1990

Revision History:

    30-Apr-1991    o-decjt

        Initialized the drep[4] fields to reflect integer, character,
        and floating point format.

--*/

#include <precomp.hxx>
#include <osfpcket.hxx>


void
ConstructPacket (
    IN OUT rpcconn_common PAPI * Packet,
    IN unsigned char PacketType,
    IN unsigned int PacketLength
    )
/*++

Routine Description:

    This routine fills in the common fields of a packet, except for the
    call_id.

Arguments:

    Packet - Supplies the packet for which we want to fill in the common
        fields; returns the filled in packet.

    PacketType - Supplies the type of the packet; this is one of the values
        in the rpc_ptype_t enumeration.

    PacketLength - Supplies the total length of the packet in bytes.

--*/
{
    Packet->rpc_vers = OSF_RPC_V20_VERS;
    Packet->rpc_vers_minor = OSF_RPC_V20_VERS_MINOR;
    Packet->PTYPE = PacketType;
    Packet->pfc_flags = 0;
    Packet->drep[0] = NDR_LOCAL_CHAR_DREP | NDR_LOCAL_INT_DREP;
    Packet->drep[1] = NDR_LOCAL_FP_DREP;
    Packet->drep[2] = 0;
    Packet->drep[3] = 0;
    Packet->frag_length = (unsigned short) PacketLength;
    Packet->auth_length = 0;
}

unsigned int PacketSizes[] =
{
    sizeof(rpc_request), // = 0
    0, // = 1
    sizeof(rpc_response),// = 2
    sizeof(rpc_fault),// = 3
    0,// = 4
    0,// = 5
    0,// = 6
    0,// = 7
    0,// = 8
    0,// = 9
    0,// = 10
    sizeof(rpc_bind),// = 11,
    sizeof(rpc_bind_ack),// = 12,
    sizeof(rpc_bind_nak),// = 13,
    sizeof(rpc_alter_context),// = 14,
    sizeof(rpc_alter_context_resp),// = 15,
    sizeof(rpc_auth_3),// = 16,
    sizeof(rpc_shutdown),// = 17,
    sizeof(rpc_cancel),// = 18,
    sizeof(rpc_orphaned) // = 19
};


unsigned int
MinPacketLength (
    IN rpcconn_common PAPI *Packet
    )
{
    unsigned int Size;

    if (Packet->PTYPE > rpc_orphaned)
        {
        return 0;
        }

    Size = PacketSizes[Packet->PTYPE];
    if (Size == 0)
        {
        return 0;
        }

    if (Packet->pfc_flags & PFC_OBJECT_UUID)
        {
        Size += sizeof(UUID);
        }

    if (Packet->auth_length)
        {
        Size += Packet->auth_length+sizeof(sec_trailer);

        if (Size > Packet->frag_length)
            {
            return 0;
            }

        sec_trailer  * SecurityTrailer = (sec_trailer  *) (((unsigned char  *) Packet) 
                + Packet->frag_length - Packet->auth_length - sizeof(sec_trailer));
        
        Size += SecurityTrailer->auth_pad_length;
        }

    return Size;
}


RPC_STATUS
ValidatePacket (
    IN rpcconn_common PAPI * Packet,
    IN unsigned int PacketLength
    )
/*++

Routine Description:

    This is the routine used to validate a packet and perform data
    conversion, if necessary of the common part of a packet.  In addition,
    to data converting the common part of a packet, we data convert the
    rest of the headers of rpc_request, rpc_response, and rpc_fault packets.

Arguments:

    Packet - Supplies the packet to validate and data convert (if
        necessary).

    PacketLength - Supplies the length of the packet as reported by the
        transport.

Return Value:

    RPC_S_OK - The packet has been successfully validated and the data
        converted (if necessary).

    RPC_S_PROTOCOL_ERROR - The supplied packet does not contain an rpc
        protocol version which we recognize.

--*/
{

    if ( DataConvertEndian(Packet->drep) != 0 )
        {
        // We need to data convert the packet.

        Packet->frag_length = RpcpByteSwapShort(Packet->frag_length);
        Packet->auth_length = RpcpByteSwapShort(Packet->auth_length);
        Packet->call_id = RpcpByteSwapLong(Packet->call_id);

        if (   (Packet->PTYPE == rpc_request)
            || (Packet->PTYPE == rpc_response)
            || (Packet->PTYPE == rpc_fault))
            {
            ((rpcconn_request PAPI *) Packet)->alloc_hint = 
                RpcpByteSwapLong(((rpcconn_request PAPI *) Packet)->alloc_hint);
            ((rpcconn_request PAPI *) Packet)->p_cont_id 
                = RpcpByteSwapShort(((rpcconn_request PAPI *) Packet)->p_cont_id);
            if ( Packet->PTYPE == rpc_request )
                {
                ((rpcconn_request PAPI *) Packet)->opnum = 
                    RpcpByteSwapShort(((rpcconn_request PAPI *) Packet)->opnum);
                }
            }
        }
    else if ( (Packet->drep[0] & NDR_DREP_ENDIAN_MASK) != NDR_LOCAL_INT_DREP )
        {
        return(RPC_S_PROTOCOL_ERROR);
        }

    if (Packet->frag_length != (unsigned short) PacketLength)
        {
        ASSERT(0);
        return (RPC_S_PROTOCOL_ERROR);
        }

    unsigned int MinLength = MinPacketLength(Packet);

    if (MinLength == 0 || MinLength > PacketLength)
        {
        return (RPC_S_PROTOCOL_ERROR);
        }

    if (   (Packet->rpc_vers != OSF_RPC_V20_VERS)
        || (Packet->rpc_vers_minor > OSF_RPC_V20_VERS_MINOR))
        {
        return(RPC_S_PROTOCOL_ERROR);
        }

    return(RPC_S_OK);
}


void
ByteSwapSyntaxId (
    IN p_syntax_id_t PAPI * SyntaxId
    )
/*++

Routine Description:

    This routine is used to perform data conversion in a syntax identifier
    if necessary.

Arguments:

    SyntaxId - Supplies the syntax identifier to be byte swapped.

--*/
{
    ByteSwapUuid((RPC_UUID *)&SyntaxId->if_uuid);
    SyntaxId->if_version = RpcpByteSwapLong(SyntaxId->if_version);
}

#if 0

void
ConvertStringEbcdicToAscii (
    IN unsigned char * String
    )
/*++

Routine Description:

    We will convert a zero terminated character string from EBCDIC to
    ASCII.  The conversion will be done in place.

Arguments:

    String - Supplies the string to be converted.

--*/
{
    UNUSED(String);
    ASSERT(!RPC_S_CANNOT_SUPPORT);
}
#endif

void
UnpickleEEInfoFromBuffer (
    IN PVOID Buffer,
    IN size_t SizeOfPickledData
    )
{
    RPC_STATUS RpcStatus;
    ExtendedErrorInfo *EEInfo;

    ASSERT(IsBufferAligned(Buffer));
    ASSERT(RpcpGetEEInfo() == NULL);

    RpcStatus = UnpickleEEInfo((unsigned char *)Buffer,
        SizeOfPickledData,
        &EEInfo);

    if (RpcStatus == RPC_S_OK)
        {
        StripComputerNameIfRedundant(EEInfo);
        RpcpSetEEInfo(EEInfo);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\osfclnt.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    osfclnt.cxx

Abstract:

    This file contains the client side implementation of the OSF connection
    oriented RPC protocol engine.

Author:

    Michael Montague (mikemon) 17-Jul-1990

Revision History:
    Mazhar Mohammed (mazharm) 11-08-1996 - Major re-haul to support async:
      - Added support for Async RPC, Pipes
      - Changed it to operate as a state machine
      - Changed class structure
      - Got rid of the TRANS classes.

    Kamen Moutafov      (kamenm)    Jan-2000    Support for multiple transfer syntaxes
    Kamen Moutafov (KamenM) Dec 99 - Feb 2000 - Support for cell debugging stuff
    Kamen Moutafov      (KamenM)    Mar-2000    Support for extended error info
--*/

#include <precomp.hxx>
#include <osfpcket.hxx>
#include <bitset.hxx>
#include <queue.hxx>
#include <ProtBind.hxx>
#include <osfclnt.hxx>
#include <rpccfg.h>
#include <epmap.h>
#include <twrtypes.h>
#include <hndlsvr.hxx>
#include <schnlsp.h>
#include <charconv.hxx>

//
// Maximum retries in light of getting a shutdown
// or closed in doing a bind or shutdown
//
#define MAX_RETRIES  3
// #define RPC_IDLE_CLEANUP_AUDIT
NEW_SDICT(OSF_CASSOCIATION);

MUTEX *AssocDictMutex = NULL;
OSF_CASSOCIATION_DICT * AssociationDict;
long OsfLingeredAssociations = 0;
const long MaxOsfLingeredAssociations = 8;
ULONG OsfDestroyedAssociations = 0;
const ULONG NumberOfOsfDestroyedAssociationsToSample = 128;

// in 100 nano-second intervals, this constant is 2 seconds
const DWORD DestroyedOsfAssociationBatchThreshold = 1000 * 10 * 1000 * 2;

ULARGE_INTEGER OsfLastDestroyedAssociationsBatchTimestamp;


OSF_BINDING_HANDLE::OSF_BINDING_HANDLE (
    IN OUT RPC_STATUS  * Status
    ) : BINDING_HANDLE(Status)
{
    ALLOCATE_THIS(OSF_BINDING_HANDLE);

    ObjectType = OSF_BINDING_HANDLE_TYPE;
    Association = 0;
    ReferenceCount = 1;
    DceBinding = 0;
    TransInfo = 0;
    TransAuthInitialized = 0;
    pToken = 0;
}



OSF_BINDING_HANDLE::~OSF_BINDING_HANDLE (
    )
{
    OSF_RECURSIVE_ENTRY *RecursiveEntry;
    DictionaryCursor cursor;

    if (Association != 0)
        {
        Unbind();
        }
    else
        {
        delete DceBinding;
        }

    RecursiveCalls.Reset(cursor);

    while ((RecursiveEntry = RecursiveCalls.Next(cursor)))
       {
       delete RecursiveEntry->CCall;
       }
}


RPC_STATUS
OSF_BINDING_HANDLE::AcquireCredentialsForTransport(
    )
/*++
Function Name:AcquireCredentialsForTransport

Parameters:

Description:

Returns:

--*/
{
    BOOL Result, fTokenFound;
    unsigned long Size;
    RPC_STATUS Status;
    HANDLE ImpersonationToken = 0;
    TOKEN_STATISTICS TokenStatisticsInformation;

    //
    // This function is called only when RPC security is not being used
    //
    ASSERT(fNamedPipe == 1);
    ASSERT(ClientAuthInfo.AuthenticationService == RPC_C_AUTHN_NONE);
    ASSERT(Association);

    if (OpenThreadToken (GetCurrentThread(),
                        TOKEN_IMPERSONATE | TOKEN_QUERY,
                        TRUE,
                        &ImpersonationToken) == FALSE)
        {
        ClientAuthInfo.DefaultLogonId = TRUE;
        pToken = NULL;

        if (GetLastError() != ERROR_NO_TOKEN)
            {
            return RPC_S_ACCESS_DENIED;
            }

        return RPC_S_OK;
        }



    Result = GetTokenInformation(
                 ImpersonationToken,
                 TokenStatistics,
                 &TokenStatisticsInformation,
                 sizeof(TOKEN_STATISTICS),
                 &Size
                 );
   if (Result != TRUE)
       {
       ClientAuthInfo.DefaultLogonId = TRUE;
       CloseHandle(ImpersonationToken);

       return RPC_S_ACCESS_DENIED;
       }


    ClientAuthInfo.DefaultLogonId = FALSE;

    Status = Association->FindOrCreateToken(
                            ImpersonationToken,
                            &TokenStatisticsInformation.AuthenticationId,
                            &pToken,
                            &fTokenFound);
    if (Status != RPC_S_OK)
        {
        //
        // If there is a failure, the callee will free the token
        //
        return Status;
        }

    if (fTokenFound)
        {
        CloseHandle(ImpersonationToken);
        }

    ASSERT(pToken);
    FastCopyLUIDAligned(&ClientAuthInfo.ModifiedId, &pToken->ModifiedId);

    return RPC_S_OK;
}


BOOL
ReplaceToken(
    HANDLE NewToken
    )
/*++
Function Name:ReplaceToken

Parameters:

Description:

Returns:

--*/
{
    NTSTATUS NtStatus;
    HANDLE hTokenToReplace = NewToken;

    //
    // This thread should either have a null token or
    // the token we captured in Initialize. It cannot have
    // any other token.
    //
    NtStatus = NtSetInformationThread(NtCurrentThread(),
                                      ThreadImpersonationToken,
                                      &hTokenToReplace,
                                      sizeof(HANDLE));


    if (!NT_SUCCESS(NtStatus))
        {
        return FALSE;
        }

    return TRUE;
}


BOOL
OSF_BINDING_HANDLE::SwapToken (
    HANDLE *OldToken
    )
/*++
Function Name:SwapToken

Parameters:

Description:

Returns:

--*/
{

    HANDLE ImpersonationToken = 0;
    HANDLE NewToken ;

    *OldToken = 0;

    if (!(ClientAuthInfo.AuthenticationService == RPC_C_AUTHN_NONE && fNamedPipe))
        {
        return FALSE;
        }

    if (pToken == 0)
        {
        NewToken = 0;
        }
    else
        {
        NewToken = pToken->hToken;
        }

    ImpersonationToken = 0;

    if (OpenThreadToken (GetCurrentThread(),
        TOKEN_IMPERSONATE | TOKEN_QUERY,
        TRUE,
        &ImpersonationToken) == FALSE)
        {
        ImpersonationToken = 0;
        }

    if (ReplaceToken(NewToken) == FALSE)
        {
        if (ImpersonationToken)
            {
            CloseHandle(ImpersonationToken);
            }

        return FALSE;
        }

    *OldToken = ImpersonationToken;

    return TRUE;
}


RPC_STATUS 
OSF_BINDING_HANDLE::NegotiateTransferSyntax (
    IN OUT PRPC_MESSAGE Message
    )
/*++
Function Name:NegotiateTransferSyntax

Parameters:

Description:
    Negotiate a transfer syntax, if necessary. A bind/alter context may be done
    in the process.

Returns:
    Status of the operation

--*/
{
    OSF_CCALL *CCall;
    RPC_STATUS Status;
    unsigned int NotChangedRetry = 0;
    unsigned int Retry;
    RPC_CLIENT_INTERFACE *ClientInterface;
    BOOL fResult;
    BOOL fRetry;

    AssocDictMutex->VerifyNotOwned();

    for (;;)
        {
        Retry = 0;
        for (;;)
            {
            //
            // Allocate a call object.
            //
            Status = AllocateCCall(&CCall, Message, &fRetry);
            Message->Handle = (RPC_BINDING_HANDLE) CCall;
            if (Status == RPC_S_OK)
                {
                // by now the Binding in the CCall should have
                // been fixed or in the async case, NDR20 should have been
                // used
                ClientInterface = (RPC_CLIENT_INTERFACE *)Message->RpcInterfaceInformation;
                if (DoesInterfaceSupportMultipleTransferSyntaxes(ClientInterface))
                    Message->TransferSyntax = CCall->GetSelectedBinding()->GetTransferSyntaxId();
                return Status;
                }

            if ((Status != RPC_P_CONNECTION_SHUTDOWN)
                && (Status != RPC_P_CONNECTION_CLOSED)
                && (fRetry == FALSE))
                {
                break;
                }

            if (this->Association != 0)
               {
               Association->ShutdownRequested(Status, NULL);
               }

            Retry++;
            if (Retry == MAX_RETRIES)
               break;
            }

        if (Status == EPT_S_NOT_REGISTERED)
            {

            BindingMutex.Request();

            if (DceBinding == NULL)
                {
                // in a scenario where multiple threads make an RPC
                // call on the same binding handle, it is possible that
                // even though this thread failed with EPT_S_NOT_REGISTERED
                // another thread succeeded and transferred the ownership of
                // the DceBinding to the association. In such case we're
                // already bound to an association, and all we need is to
                // loop around and try the call again
                BindingMutex.Clear();
                continue;
                }

            // we ran out of endpoints - drop the endpoint set for the next
            // iteration
            fResult = DceBinding->MaybeMakePartiallyBound(
                   (PRPC_CLIENT_INTERFACE)Message->RpcInterfaceInformation,
                   InqPointerAtObjectUuid());
            if (fResult)
                {
                if ( *InquireEpLookupHandle() != 0 )
                    {
                    EpFreeLookupHandle(*InquireEpLookupHandle());
                    *InquireEpLookupHandle() = 0;
                    }
                }

            BindingMutex.Clear();

            break;
            }

        if (Status != RPC_S_SERVER_UNAVAILABLE)
            {
            break;
            }

        // if this is either a static endpoint, or an endpoint resolved through
        // the interface information, there is no need to iterate
        if (!fDynamicEndpoint 
            || 
            ((RPC_CLIENT_INTERFACE *)Message->RpcInterfaceInformation)->RpcProtseqEndpointCount)
            {
            break;
            }

        //
        // If we reach here, it means that we are iterating through the list
        // of endpoints obtained from the endpoint mapper.
        //
        BindingMutex.Request();

        if (ReferenceCount == 1
            && Association != 0)
            {

            // there is an association (which means the server's endpoint
            // mapper was contacted), and the refcount is 1 (we're the
            // only user). We know this is a dynamic endpoint. We have
            // the following cases to take care of:
            // - the list of endpoints is exhausted. If this is the case,
            //   we wouldn't have gotten here, as we will get 
            //   EPT_S_NOT_REGISTERED from AllocateCCall and we would
            //   have bailed out earlier on the first iteration. Since
            //   the code above would have dropped the endpoints list for
            //   the next iteration, we will be fine
            // - we're iterating over the list of endpoints in the same
            //   call. In this case, we will be getting server unavailable
            //   from each endpoint for which the server is not there,
            //   and we will move on to the next endpoint, until we exhaust
            //   them and get EPT_S_NOT_REGISTERED

            DceBinding = Association->DuplicateDceBinding();
            Unbind();

            if (DceBinding == NULL)
                {
                BindingMutex.Clear();
                return RPC_S_OUT_OF_MEMORY;
                }

            RpcpErrorAddRecord(EEInfoGCRuntime,
                Status,
                EEInfoDLOSF_BINDING_HANDLE__NegotiateTransferSyntax10,
                DceBinding->InqEndpoint()
                );

            // whack the endpoint and move on to the next (if any)
            fResult = DceBinding->MaybeMakePartiallyBound(
                   (PRPC_CLIENT_INTERFACE)Message->RpcInterfaceInformation,
                   InqPointerAtObjectUuid());
            if (fResult == FALSE)
                {
                NotChangedRetry += 1;
                RpcpPurgeEEInfo();
                }
            else
                {
                // we don't purge here because we want next iterations
                // to add to the record
                NotChangedRetry = 0;
                }
            }
        else
            {
            // either there is more then one reference to the binding handle,
            // or the endpoint mapper could not be contacted (i.e. no
            // association)
            NotChangedRetry += 1;
            RpcpPurgeEEInfo();
            }
        BindingMutex.Clear();

        if (NotChangedRetry > 4)
            {
            return(RPC_S_SERVER_UNAVAILABLE);
            }
        }

    ASSERT(Status != RPC_S_OK);

    if (Status == RPC_P_CONNECTION_CLOSED
        || Status == RPC_P_CONNECTION_SHUTDOWN)
        {
        return(RPC_S_CALL_FAILED_DNE);
        }
    return(Status);
}


RPC_STATUS
OSF_BINDING_HANDLE::GetBuffer (
    IN PRPC_MESSAGE Message,
    IN UUID *ObjectUuid
    )
/*++
Function Name:GetBuffer

Parameters:

Description:
    Ask the call object for a buffer

Returns:

--*/
{
    ASSERT(!"We should never be here - the binding handle cannot allocate a buffer");
    return RPC_S_INTERNAL_ERROR;
}


RPC_STATUS
OSF_BINDING_HANDLE::AllocateCCall (
    OUT OSF_CCALL *  *CCall,
    IN PRPC_MESSAGE Message,
    OUT BOOL *Retry
    )
/*++
Function Name:AllocateCCall

Parameters:
    CCall - Returns the allocated Call object

    Message - The RPC_MESSAGE for this call.

    Retry - if set on output, the caller should retry the allocation.

Description:
    Finds an existing association or creates a new one. Asks the association
    to allocate the call object for us.

Returns:
    RPC_S_OK or an error code.

--*/
{
    OSF_RECURSIVE_ENTRY *RecursiveEntry;
    CLIENT_AUTH_INFO * AuthInfo;
    RPC_STATUS Status;
    BOOL fDynamic = FALSE;
    CLIENT_AUTH_INFO AuthInfo2;
    DictionaryCursor cursor;
    BOOL fBindingHandleReferenceRemoved;
    ULONG_PTR CallTimeout;

    *Retry = FALSE;

    BindingMutex.Request();

    //
    // First we need to check if there is already a recursive Call
    // for this thread and interface.  To make the common case quicker,
    // we will check to see if there are any Calls in the dictionary
    // first. ** We will find a recursive call only in the case of callbacks **
    //
    if ( RecursiveCalls.Size() != 0 )
        {
        RecursiveCalls.Reset(cursor);
        while ( (RecursiveEntry = RecursiveCalls.Next(cursor)) != 0 )
            {
            *CCall = RecursiveEntry->IsThisMyRecursiveCall(
                               GetThreadIdentifier(),
                               (RPC_CLIENT_INTERFACE  *)
                               Message->RpcInterfaceInformation);
            if ( *CCall != 0 )
                {
                BindingMutex.Clear();

                if ((*CCall)->CurrentState == Aborted)
                    {
                    return (*CCall)->AsyncStatus;
                    }

                //
                // This reference will be removed when the send
                // for this call is complete
                //
                (*CCall)->CurrentState = SendingFirstBuffer;
                return(RPC_S_OK);
                }
            }
        }

    if (Association == 0)
        {
        // if we don't have an object UUID, and we have a dynamic endpoint, 
        // attempt quick resolution
        if (InqIfNullObjectUuid() && DceBinding->IsNullEndpoint())
            {
            Association = FindOrCreateAssociation(
                                                  DceBinding,
                                                  TransInfo,
                                                  (RPC_CLIENT_INTERFACE *)Message->RpcInterfaceInformation
                                                  );
            AssocDictMutex->VerifyNotOwned();


            // do nothing in both cases. In failure case, we will do full
            // resolution. In success case, ownership of the dce binding
            // has passed to the association, and we don't need to copy
            // the resolved endpoint back
            }

        // if we are still NULL, attempt full resolution
        if (Association == NULL)
            {
            Status = OSF_BINDING_HANDLE::InqTransportOption(
                RPC_C_OPT_CALL_TIMEOUT,
                &CallTimeout);

            // this function cannot fail unless it is given invalid
            // parameters
            ASSERT(Status == RPC_S_OK);

            Status = DceBinding->ResolveEndpointIfNecessary(
                                   (RPC_CLIENT_INTERFACE  *)
                                   Message->RpcInterfaceInformation,
                                   InqPointerAtObjectUuid(),
                                   InquireEpLookupHandle(),
                                   FALSE,
                                   InqComTimeout(),
                                   (ULONG)CallTimeout,
                                   &ClientAuthInfo
                                   );

            if ( Status != RPC_S_OK )
                {
                BindingMutex.Clear();
                return(Status);
                }

            Association = FindOrCreateAssociation(
                                                  DceBinding,
                                                  TransInfo,
                                                  NULL
                                                  );

            AssocDictMutex->VerifyNotOwned();

            if (Association == 0)
                {
                BindingMutex.Clear();

                return RPC_S_OUT_OF_MEMORY;
                }
            }

        //
        // Ownership of the DCE binding passes to the association.  We are
        // going to set the field to zero so that no one screws with them.
        //
        DceBinding = 0;

        if (ClientAuthInfo.AuthenticationService == RPC_C_AUTHN_NONE && fNamedPipe)
            {
            if (TransAuthInitialized == 0)
                {
                Status = AcquireCredentialsForTransport();
                if (Status != RPC_S_OK)
                    {
                    BindingMutex.Clear();
                    return Status;
                    }
                TransAuthInitialized = 1;
                }
            }
        }
    else
        {
        if (Association->IsValid() == 0)
            {
            if (ReferenceCount == 1)
                {
                DceBinding = Association->DuplicateDceBinding();
                if (DceBinding == 0)
                    {
                    Status = RPC_S_OUT_OF_MEMORY;
                    }
                else
                    {
                    Status = Association->AssociationShutdownError;
                    Unbind();
                    *Retry = TRUE;
                    }
                }
            else
                {
                Status = Association->AssociationShutdownError;
                }

            BindingMutex.Clear();
            return Status;
            }
        }

    //
    // We will assume that we are successfully able to allocate a Call,
    // so we bump the reference count now.
    //
    ReferenceCount++;

    AuthInfo  = InquireAuthInformation();

    //
    // If this is a secure BH and it requires DYNAMIC TRACKING, check if
    // LogonID has changed. If it has changed, get new Credential Handle
    //
    if ((AuthInfo != 0)
        && (AuthInfo->AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE)
        && (AuthInfo->IdentityTracking == RPC_C_QOS_IDENTITY_DYNAMIC))
        {
        Status = ReAcquireCredentialsIfNecessary();
        if (Status != RPC_S_OK)
            {
            ReferenceCount -=1;
            BindingMutex.Clear();

            return (Status);
            }

        fDynamic = TRUE;
        AuthInfo = AuthInfo->ShallowCopyTo(&AuthInfo2);
        AuthInfo->ReferenceCredentials();
        }

    BindingMutex.Clear();

    Status = Association->AllocateCCall(
                                        this,
                                        Message,
                                        AuthInfo,
                                        CCall,
                                        &fBindingHandleReferenceRemoved);

    if (fDynamic)
        AuthInfo->PrepareForDestructionAfterShallowCopy();

    if ( Status == RPC_S_OK )
        {
        if ((*CCall)->CurrentState != SendingFirstBuffer
            && (*CCall)->Connection->fExclusive)
            {
            OSF_CCALL_STATE myState = (*CCall)->CurrentState;

            Status = (*CCall)->BindToServer(
                FALSE   // sync bind
                );
            if (Status != RPC_S_OK)
                {
                //
                // Call has not yet started, ok to directly
                // free the call.
                //
                if (myState == NeedOpenAndBind)
                    {
                    (*CCall)->FreeCCall(RPC_S_CALL_FAILED_DNE);
                    }
                else
                    {
                    (*CCall)->FreeCCall(Status);
                    }
                }
            }
        }
    else
        {
        if (fBindingHandleReferenceRemoved == 0)
            {
            BindingMutex.Request();
            ReferenceCount -= 1;
            ASSERT( ReferenceCount != 0 );
            BindingMutex.Clear();
            }
        }

    return Status;
}


RPC_STATUS
OSF_BINDING_HANDLE::BindingCopy (
    OUT BINDING_HANDLE *  * DestinationBinding,
    IN UINT MaintainContext
    )
/*++

Routine Description:

    We need to copy this binding handle.  This is relatively easy to
    do: we just need to point the copied binding handle to the same
    association as this binding handle.  We also need to tell the
    association about the new binding handle.

Arguments:

    DestinationBinding - Returns a copy of this binding handle.

    MaintainContext - Supplies a flag that indicates whether or not context
        is being maintained over this binding handle.  A non-zero value
        indicates that context is being maintained.

Return Value:

    RPC_S_OUT_OF_MEMORY - This indicates that there is not enough memory
        to allocate a new binding handle.

    RPC_S_OK - We successfully copied this binding handle.

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    OSF_BINDING_HANDLE * Binding;
    RPC_UUID Uuid;
    CLIENT_AUTH_INFO * AuthInfo;

    Binding = new OSF_BINDING_HANDLE(&Status);
    if ( Status != RPC_S_OK )
        {
        delete Binding;
        Binding = 0;
        }
    if ( Binding == 0 )
        {
        *DestinationBinding = 0;
        return(RPC_S_OUT_OF_MEMORY);
        }

    BindingMutex.Request();

    Status = Binding->BINDING_HANDLE::Clone( this );
    if (Status != RPC_S_OK)
        {
        delete Binding;
        Binding = 0;
        *DestinationBinding = 0;

        BindingMutex.Clear();

        return Status;
        }

    Binding->ClientAuthInfo.DefaultLogonId = ClientAuthInfo.DefaultLogonId;
    Binding->fNamedPipe = fNamedPipe;
    Binding->fDynamicEndpoint = fDynamicEndpoint;

    if (pToken)
        {
        ASSERT(Association);
        ASSERT(fNamedPipe);
        Association->ReferenceToken(pToken);
        Binding->pToken = pToken;
        FastCopyLUIDAligned(&(Binding->ClientAuthInfo.ModifiedId),
            &(pToken->ModifiedId));
        }

    Binding->Association = Association;
    if ( DceBinding != 0 )
        {
        ASSERT( MaintainContext == 0 );

        Binding->DceBinding = DceBinding->DuplicateDceBinding();
        }
    else
        {
        Binding->DceBinding = 0;
        }

    Binding->TransInfo = TransInfo;

    if ( Association != 0 )
        {
        Association->IncrementCount();
        if ( MaintainContext != 0 )
            {
            Association->MaintainingContext();
            }
        }

    BindingMutex.Clear();

    *DestinationBinding = (BINDING_HANDLE *) Binding;
    return(RPC_S_OK);
}


RPC_STATUS
OSF_BINDING_HANDLE::BindingFree (
    )
/*++

Routine Description:

    This method gets called when the application calls RpcBindingFree.
    All we have got to do is to decrement the reference count, and if
    it has reached zero, delete the binding handle.

Return Value:

    RPC_S_OK - This operation always succeeds.

--*/
{
    BindingMutex.Request();
    ReferenceCount -= 1;

    if ( ReferenceCount == 0 )
        {
        BindingMutex.Clear();
        delete this;
        }
    else
        {
        BindingMutex.Clear();
        }

    return(RPC_S_OK);
}


RPC_STATUS
OSF_BINDING_HANDLE::PrepareBindingHandle (
    IN TRANS_INFO  * TransInfo,
    IN DCE_BINDING * DceBinding
    )
/*++

Routine Description:

    This method will be called just before a new binding handle is returned
    to the user.  We just stash the transport interface and binding
    information so we can use it later when the first remote procedure
    call is made.  At that time, we will actually bind to the interface.

Arguments:

    TransportInterface - Supplies a pointer to a data structure describing
        a loadable transport.

    DceBinding - Supplies the binding information for this binding handle.

--*/
{
    this->TransInfo = (TRANS_INFO *) TransInfo;
    this->DceBinding = DceBinding;
    fDynamicEndpoint = DceBinding->IsNullEndpoint();
    // we count it as named pipes only in the remote case
    fNamedPipe = DceBinding->IsNamedPipeTransport() && DceBinding->InqNetworkAddress();
    Association = 0;

    return RPC_S_OK;
}


RPC_STATUS
OSF_BINDING_HANDLE::ToStringBinding (
    OUT RPC_CHAR  *  * StringBinding
    )
/*++

Routine Description:

    We need to convert the binding handle into a string binding.  If the
    binding handle has not yet been used to make a remote procedure
    call, then we can just use the information in the binding handle to
    create the string binding.  Otherwise, we need to ask the association
    to do it for us.

Arguments:

    StringBinding - Returns the string representation of the binding
        handle.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_OUT_OF_MEMORY - We do not have enough memory available to
        allocate space for the string binding.

--*/
{
    if ( Association == 0 )
        {
        *StringBinding = DceBinding->StringBindingCompose(
                                                          InqPointerAtObjectUuid());
        if (*StringBinding == 0)
            return(RPC_S_OUT_OF_MEMORY);
        return(RPC_S_OK);
        }
    return(Association->ToStringBinding(StringBinding,
                                    InqPointerAtObjectUuid()));
}


RPC_STATUS
OSF_BINDING_HANDLE::BindingReset (
    )
/*++

Routine Description:

    This routine will set the endpoint of this binding handle to zero,
    if possible.  The binding handle will become partially bound as a
    result.  If a remote procedure call has been made on this binding
    handle, it will fail as well.

Return Value:

    RPC_S_OK - The binding handle has successfully been made partially
        bound.

    RPC_S_WRONG_KIND_OF_BINDING - The binding handle currently has remote
        procedure calls active.

--*/
{
    BindingMutex.Request();

    if ( Association != 0 )
        {
        if ( ReferenceCount != 1 )
            {
            BindingMutex.Clear();
            return(RPC_S_WRONG_KIND_OF_BINDING);
            }

        DceBinding = Association->DuplicateDceBinding();
        if (DceBinding == NULL)
            {
            BindingMutex.Clear();
            return RPC_S_OUT_OF_MEMORY;
            }
        Unbind();
        }

    DceBinding->MakePartiallyBound();
    fDynamicEndpoint = TRUE;

    if ( *InquireEpLookupHandle() != 0 )
        {
        EpFreeLookupHandle(*InquireEpLookupHandle());
        *InquireEpLookupHandle() = 0;
        }

    BindingMutex.Clear();
    return(RPC_S_OK);
}


ULONG
OSF_BINDING_HANDLE::MapAuthenticationLevel (
    IN ULONG AuthenticationLevel
    )
/*++

Routine Description:

    The connection oriented protocol module supports all authentication
    levels except for RPC_C_AUTHN_LEVEL_CALL.  We just need to map it
    to RPC_C_AUTHN_LEVEL_PKT.

--*/
{
    UNUSED(this);

    if ( AuthenticationLevel == RPC_C_AUTHN_LEVEL_CALL )
        {
        return(RPC_C_AUTHN_LEVEL_PKT);
        }

    return(AuthenticationLevel);
}



RPC_STATUS
OSF_BINDING_HANDLE::ResolveBinding (
    IN PRPC_CLIENT_INTERFACE RpcClientInterface
    )
/*++

Routine Description:

    We need to try and resolve the endpoint for this binding handle
    if necessary (the binding handle is partially-bound).  We check
    to see if an association has been obtained for this binding
    handle; if so, we need to do nothing since the binding handle is
    fully-bound, otherwise, we try and resolve an endpoint for it.

Arguments:

    RpcClientInterface - Supplies interface information to be used
        in resolving the endpoint.

Return Value:

    RPC_S_OK - The binding handle is now fully-bound.

    RPC_S_NO_ENDPOINT_FOUND - We were unable to resolve the endpoint
        for this particular combination of binding handle (network address)
        and interface.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to resolve
        the endpoint.

--*/
{
    RPC_STATUS Status;

    BindingMutex.Request();
    if ( Association == 0 )
        {
        Status = DceBinding->ResolveEndpointIfNecessary(
                                                      RpcClientInterface,
                                                      InqPointerAtObjectUuid(),
                                                      InquireEpLookupHandle(),
                                                      FALSE,
                                                      InqComTimeout(),
                                                      INFINITE,      // CallTimeout
                                                      &ClientAuthInfo
                                                      );
        }
    else
        {
        Status = RPC_S_OK;
        }
    BindingMutex.Clear();

    return(Status);
}


RPC_STATUS
OSF_BINDING_HANDLE::AddRecursiveEntry (
    IN OSF_CCALL * CCall,
    IN PRPC_CLIENT_INTERFACE RpcInterfaceInformation
    )
/*++

Routine Description:

    When a callback occurs, we need to add an entry for the thread and
    interface being using for the callback to the binding handle.  This
    is so that we can later turn original calls into callbacks if they
    are from the same thread (as the original call) and to the same
    interface (as the original call).

Arguments:

    CCall - Supplies the Call on which the original call was
        sent.

    RpcInterfaceInformation - Supplies the interface used by the original
        call.

Return Value:

    RPC_S_OK - An recursive entry has been added to the binding handle for
        the supplied Call and interface.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to perform the
        operation.

--*/
{
    OSF_RECURSIVE_ENTRY * RecursiveEntry;

    BindingMutex.Request();
    RecursiveEntry = new OSF_RECURSIVE_ENTRY(GetThreadIdentifier(),
            RpcInterfaceInformation, CCall);
    if ( RecursiveEntry == 0 )
        {
        BindingMutex.Clear();
        return(RPC_S_OUT_OF_MEMORY);
        }

    CCall->RecursiveCallsKey = RecursiveCalls.Insert(
            RecursiveEntry);
    if ( CCall->RecursiveCallsKey == -1 )
        {
        BindingMutex.Clear();
        delete RecursiveEntry;
        return(RPC_S_OUT_OF_MEMORY);
        }

    ReferenceCount += 1;
    BindingMutex.Clear();

    return(RPC_S_OK);
}


void
OSF_BINDING_HANDLE::RemoveRecursiveCall (
    IN OSF_CCALL * CCall
    )
/*++

Routine Description:

    The specified Call is removed from the dictionary of active
    Calls for this binding handle.

Arguments:

    CCall - Supplies the Call to be removed from the
        dictionary of active Calls.

--*/
{
    OSF_RECURSIVE_ENTRY * RecursiveEntry;

    BindingMutex.Request();
    RecursiveEntry = RecursiveCalls.Delete(CCall->RecursiveCallsKey);
    if ( RecursiveEntry != 0 )
        {
        delete RecursiveEntry;
        }
    CCall->RecursiveCallsKey = -1;
    ReferenceCount -= 1;
    BindingMutex.Clear();
}


OSF_CASSOCIATION *
OSF_BINDING_HANDLE::FindOrCreateAssociation (
    IN DCE_BINDING * DceBinding,
    IN TRANS_INFO *TransInfo,
    IN RPC_CLIENT_INTERFACE *InterfaceInfo
    )
/*++
Function Name:FindOrCreateAssociation

Parameters:
    DceBinding - Supplies binding information; ownership of this object
        passes to this routine.

    TransportInterface - Supplies a pointer to the data structure which
        describes a loadable transport.

    InterfaceInfo - Supplied the interface information for this call. Used
        to make quick resolution on new binding handles if existing bindings
        for this interface exist. If supplied, it takes precedence over
        endpoint matching for selecting an association, and no new association
        will be created - only existing ones will be found!


Description:
    This routine finds an existing association supporting the requested
    DCE binding, or create a new association which supports the
    requested DCE binding.  Ownership of the passed DceBinding pass
    to this routine.

Returns:

    An association which supports the requested binding will be returned;
    Otherwise, zero will be returned, indicating insufficient memory.
--*/
{
    OSF_CASSOCIATION * CAssociation;
    RPC_STATUS Status = RPC_S_OK;
    DictionaryCursor cursor;
    ULONG_PTR fUnique;
    BOOL fOnlyEndpointDifferent;
    int Result;

    Status = OSF_BINDING_HANDLE::InqTransportOption(RPC_C_OPT_UNIQUE_BINDING, &fUnique);
    ASSERT(Status == RPC_S_OK);

    //
    // We start be looking in the dictionary of existing associations
    // to see if there is one supporting the binding information specified.
    //

    AssocDictMutex->Request();

    if (fUnique == 0)
        {
        AssociationDict->Reset(cursor);
        while ( (CAssociation = AssociationDict->Next(cursor)) != 0 )
            {
            if (CAssociation->IsValid())
                {
                Result = CAssociation->CompareWithDceBinding(DceBinding, 
                    &fOnlyEndpointDifferent);
                // if the DceBindings are the same, or they differ only
                // by the endpoint, and it is a NULL endpoint, and there
                // is InterfaceInfo specified, and this association 
                // supports at least one binding for this interface,
                // choose the association
                if (!Result 
                    ||
                    (
                        fOnlyEndpointDifferent 
                        && DceBinding->IsNullEndpoint()
                        && InterfaceInfo
                        && CAssociation->DoesBindingForInterfaceExist(InterfaceInfo)
                    )
                   )
                    {
                    if (CAssociation->Linger.fAssociationLingered == TRUE)
                        {
#if defined (RPC_GC_AUDIT)
                        DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) OSF lingering association resurrected %X %S %S %S\n",
                            GetCurrentProcessId(), GetCurrentProcessId(), CAssociation,
                        CAssociation->DceBinding->InqRpcProtocolSequence(),
                        CAssociation->DceBinding->InqNetworkAddress(), 
                        CAssociation->DceBinding->InqEndpoint());
#endif
                        OsfLingeredAssociations --;
                        ASSERT(OsfLingeredAssociations >= 0);
                        CAssociation->Linger.fAssociationLingered = FALSE;
                        }

                    CAssociation->IncrementCount();
                    AssocDictMutex->Clear();

                    delete DceBinding;

                    return(CAssociation);
                    }
                }
            }
        }


    // if asked to do short endpoint resolution, don't create new association
    if (InterfaceInfo)
        {
        AssocDictMutex->Clear();
        return NULL;
        }

#if defined (RPC_GC_AUDIT)
    DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Creating association to: %S, %S, %S\n",
        GetCurrentProcessId(), GetCurrentProcessId(), DceBinding->InqRpcProtocolSequence(),
        DceBinding->InqNetworkAddress(), DceBinding->InqEndpoint());
#endif

    RPC_CONNECTION_TRANSPORT *ClientInfo =
            (RPC_CONNECTION_TRANSPORT *) TransInfo->InqTransInfo();

    CAssociation = new (ClientInfo->ResolverHintSize)
                          OSF_CASSOCIATION(DceBinding,
                                        TransInfo,
                                        &Status);

    if ( (Status != RPC_S_OK) && (CAssociation != NULL) )
        {
        CAssociation->DceBinding = 0;
        delete CAssociation;
        CAssociation = 0;
        }

    if (CAssociation != 0)
        {
        CAssociation->Key = AssociationDict->Insert(CAssociation);
        if (CAssociation->Key == -1)
            {
            CAssociation->DceBinding = 0;
            delete CAssociation;
            CAssociation = 0;
            }
        }

    AssocDictMutex->Clear();

    return(CAssociation);
}

RPC_STATUS
OSF_BINDING_HANDLE::SetTransportOption( IN unsigned long option,
                                    IN ULONG_PTR     optionValue )
{
    if (option == RPC_C_OPT_DONT_LINGER)
        {
        if (Association == NULL)
            return RPC_S_WRONG_KIND_OF_BINDING;

        if (Association->GetDontLingerState())
            return RPC_S_WRONG_KIND_OF_BINDING;

        Association->SetDontLingerState((BOOL)optionValue);

        return RPC_S_OK;
        }
    else
        {
        return BINDING_HANDLE::SetTransportOption(option, optionValue);
        }
}

RPC_STATUS
OSF_BINDING_HANDLE::InqTransportOption( IN  unsigned long option,
                                    OUT ULONG_PTR   * pOptionValue )
{
    if (option == RPC_C_OPT_DONT_LINGER)
        {
        if (Association == NULL)
            return RPC_S_WRONG_KIND_OF_BINDING;

        *pOptionValue = Association->GetDontLingerState();

        return RPC_S_OK;
        }
    else
        {
        return BINDING_HANDLE::InqTransportOption(option, pOptionValue);
        }
}

#pragma optimize ("t", on)

OSF_CCONNECTION *
OSF_CASSOCIATION::LookForExistingConnection(
    IN OSF_BINDING_HANDLE *BindingHandle,
    IN BOOL fExclusive,
    IN CLIENT_AUTH_INFO *ClientAuthInfo,
    IN int *PresentationContexts,
    IN int NumberOfPresentationContexts,
    OUT int *PresentationContextSupported,
    OUT OSF_CCALL_STATE *InitialCallState,
    IN BOOL fUseSeparateConnection
    )
/*++
Function Name:LookForExistingConnection

Parameters:
    BindingHandle - the binding handle through which the call is made
    fExclusive - non-zero if we are looking for an exclusive connection
        zero otherwise
    ClientAuthInfo - a connection must support this specified auth info
    PresentationContexts - array of presentation contexts, any of which
        is acceptable to our callers
    NumberOfPresentationContexts - the size of the PresentationContexts
        array
    PreferredPresentationContext - the preferred presentation context for
        this connection. -1 if no preferences. Note that this is taken
        from a previous binding to the server - this is not the client
        preference.
    PresentationContextSupported - the presentation context that the
        chosen connection supports. This is useful only if multiple
        presentation contexts were given. Also, if the connection
        supports multiple pcontexts and multiple pcontexts were given
        this would be any of the pcontexts. This is an index into the
        NumberOfPresentationContexts array. If the connection supports
        none of the suggested presentation contexts, this is set to -1.
        In this case, alter context is required
    InitialCallState - the initial state that the call should have is
        returned in this parameter
    fUseSeparateconnection - if non-zero, a separate connection is requested

Description:

Returns:

--*/
{
    OSF_CCONNECTION *CConnection, *FirstMatch = 0;
    DictionaryCursor cursor;
    RPC_STATUS Status;

    ASSERT(ClientAuthInfo);

    AssociationMutex.VerifyOwned();

    *PresentationContextSupported = -1;

    ActiveConnections.Reset(cursor);

    if (fExclusive || fUseSeparateConnection)
        {
        INT cConnectionFree, cConnectionBusy;

        if (fExclusive)
            {
            cConnectionFree = SYNC_CONN_FREE;
            cConnectionBusy = SYNC_CONN_BUSY;
            }
        else
            {
            cConnectionFree = ASYNC_CONN_FREE;
            cConnectionBusy = ASYNC_CONN_BUSY;
            }

        while ((CConnection = ActiveConnections.Next(cursor)) != 0)
            {
            if (cConnectionFree == (INT) CConnection->ThreadId
                && CConnection->SupportedAuthInfo(ClientAuthInfo,
                                                BindingHandle->fNamedPipe) != 0)
                {
                if (CConnection->SupportedPContext(PresentationContexts,
                    NumberOfPresentationContexts, PresentationContextSupported) !=0)
                    {
                    CConnection->ThreadId = cConnectionBusy;
                    *InitialCallState = SendingFirstBuffer;
                    break;
                    }
                else
                    {
                    //
                    // We found a connection that will require an alt-context
                    // before we can use it.
                    //
                    FirstMatch = CConnection;
                    } // if-else
                } // if
            } // while

            if (0 == CConnection && FirstMatch)
                {
                CConnection = FirstMatch ;
                CConnection->ThreadId = cConnectionBusy;
                *InitialCallState = NeedAlterContext;
                }
        }
    else
        {
        DWORD ThreadId = GetCurrentThreadId();

        while ((CConnection = ActiveConnections.Next(cursor)) != 0)
            {
            if (CConnection->SupportedAuthInfo(ClientAuthInfo,
                                               BindingHandle->fNamedPipe) != 0)
                {
                if (CConnection->SupportedPContext(PresentationContexts,
                    NumberOfPresentationContexts, PresentationContextSupported) !=0)
                    {
                    if (ThreadId == CConnection->ThreadId)
                        {
                        //
                        // We found a connection where everything matches,
                        // including the thread id. Go ahead and use it.
                        //
                        *InitialCallState = SendingFirstBuffer;
                        break;
                        }
                    }
                else
                    {
                    if (ThreadId == CConnection->ThreadId)
                        {
                        //
                        // We found a connection where the thread id matches, but
                        // it will need an alt-context, before it can be used. Mark it as
                        // our first choice.
                        //
                        FirstMatch = CConnection;
                        }
                    } // if-else
                } // if
            } // while

        if (0 == CConnection && FirstMatch)
            {
            //
            // Matching thread-id, but will need an alt-context, before
            // it can be used. The alt-context will be sent when the call
            // actually gets scheduled.
            //
            CConnection = FirstMatch;
            *InitialCallState = NeedAlterContext;
            }
        } // if-else

    if (CConnection)
        {
        if (fExclusive)
            {
            CConnection->fExclusive = 1;
            }
        else
            {
            CConnection->fExclusive = 0;
            }

        // CCONN++
        CConnection->AddReference();
        // mark this connection as just retrieved from the cache
        // see the comments to the FreshFromCache flag
        CConnection->SetFreshFromCacheFlag();
        }

    return CConnection;
}
#pragma optimize("", on)

/*
    Mechanism: Multiple transfer syntax negotiation

    Purpose: Negotiate a transfer syntax supported by both the client and
    the server and optimal for the server (if there is a choice). It should
    allow for fail-over of the server to a downlevel node in the case
    of mixed clusters, but it is allowed to fail the first one or more calls 
    after the failover while it adjusts (this restricted implementation was
    approved by MarioGo on RPC team meeting on Apr 10th, 2000).

    Implementation: Here's the matrix for the scenarios. The only current
    difference b/n sync and async is the initial conn establishment. The
    matrix describes only the case where we support both (the others are
    trivial)

    Sync Calls:
    Conn Av.        Preference      Action
    -------------   ------------    -------------
    No conn.        Doesn't matter  Offer both. Don't fix choice for call
    Conn NDR20      Not set         Alter context to both. This cannot 
                                    fail with invalid xfer syntax.
    Conn NDR20      NDR20           Use the conn.
    Conn NDR20      NDR64           The connection is stale. Use the
                                    connection anyway. We know it will
                                    blow and we'll open a new one.
    Conn NDR64      Not set         Alter context to both. This cannot
                                    fail with invalid xfer syntax.
    Conn NDR64      NDR20           The connection is stale. Use the
                                    connection anyway. We know it will
                                    blow and we'll open a new one.
    Conn NDR64      NDR64           Use the conn

    Conn both       Any             Use preference.

    Non-sync Calls:
    Conn Av.        Preference      Action
    -------------   ------------    -------------
    No conn.        Not set         Offer both. If NDR64 is negotiated,
                                    negotiate once more (alter context)
                                    for NDR20, so that we can send the first
                                    call, which was marshalled NDR20.
    Conn NDR20      Not set         Alter context to both. Choose NDR20.
    Conn NDR20      NDR20           Use the conn.
    Conn NDR20      NDR64           The connection is stale. Use the
                                    connection anyway. We know it will
                                    blow and we'll open a new one.
    Conn NDR64      Not set         Alter context to both. Choose NDR20.
                                    If NDR64 is chosen, alter context
                                    to NDR20. If NDR20 is chosen, use it.
    Conn NDR64      NDR20           The connection is stale. Use the
                                    connection anyway. We know it will
                                    blow and we'll open a new one.
    Conn NDR64      NDR64           Use the conn

    Conn both       All             Use preference.

 */

const int AUTO_ENABLE_IDLE_CLEANUP = 70;


RPC_STATUS
OSF_CASSOCIATION::AllocateCCall (
    IN OSF_BINDING_HANDLE *BindingHandle,
    IN PRPC_MESSAGE Message,
    IN CLIENT_AUTH_INFO * ClientAuthInfo,
    OUT OSF_CCALL ** pCCall,
    OUT BOOL *fBindingHandleReferenceRemoved
    )
/*++
Function Name:AllocateCCall

Parameters:
    CCall - Returns the allocated call.

    ClientAuthInfo - Supplies the authentication and authorization
        information required for the connection.

Description:

    In this method, we allocate a connection supporting the requested
    interface information.  This means that first we need to find the
    presentation context corresponding to the requested interface
    interface.  Then we search for an existing connection supporting
    the presentation context, and then we try and create a new
    connection. We then ask the Connection object to create a Call
    for us.

Returns:
    RPC_S_OK - The operation completed successfully.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to create
        objects necessary to allocate a connection.

--*/
{
    ULONG CallIdToUse;
    RPC_STATUS Status;
    OSF_BINDING *BindingsForThisInterface[MaximumNumberOfTransferSyntaxes];
    int NumberOfBindingsAvailable;
    int NumberOfBindingsToUse;
    int PresentationContextsAvailable[MaximumNumberOfTransferSyntaxes];
    int *PresentationContextsToUse;
    int PresentationContextSupported;
    int NDR20PresentationContext;
    int i;
    OSF_CCALL_STATE InitialCallState;
    OSF_CCONNECTION *CConnection = 0;
    BOOL fExclusive = !NONSYNC(Message);
    ULONG_PTR fUseSeparateConnection = PARTIAL(Message);
    RPC_CLIENT_INTERFACE  *RpcInterfaceInformation =
        (RPC_CLIENT_INTERFACE  *) Message->RpcInterfaceInformation;
    OSF_BINDING *BindingsList;
    OSF_BINDING *BindingToUse;
    RPC_DISPATCH_TABLE *DispatchTableToUse;

    *fBindingHandleReferenceRemoved = FALSE;

    //
    // To begin with, we need to obtain the presentation context
    // corresponding to the specified interface information.
    //
    Status = AssociationMutex.RequestSafe();
    if (Status)
        return Status;

    Status = FindOrCreateOsfBinding(RpcInterfaceInformation, Message, &NumberOfBindingsAvailable,
        BindingsForThisInterface);
    if ( Status != RPC_S_OK )
        {
        AssociationMutex.Clear();
        return(Status);
        }

    CallIdToUse = CallIdCounter++;

    if (fExclusive == 0 && fUseSeparateConnection == 0)
        {
        Status = BindingHandle->InqTransportOption(
                                               RPC_C_OPT_BINDING_NONCAUSAL,
                                               &fUseSeparateConnection);
        ASSERT(Status == RPC_S_OK);
        }

    //
    // Ok, now we search for an available connection supporting the
    // requested presentation context.
    //

    // construct the array of presentation contexts any of which will
    // do the job
#ifdef DEBUGRPC
    BindingsList = 0;
    NDR20PresentationContext = -1;
#endif

    NumberOfBindingsToUse = NumberOfBindingsAvailable;
    PresentationContextsToUse = PresentationContextsAvailable;
    for (i = 0; i < NumberOfBindingsAvailable; i ++)
        {
        PresentationContextsAvailable[i] = BindingsForThisInterface[i]->GetPresentationContext();
        if (BindingsForThisInterface[i]->IsTransferSyntaxListStart())
            {
            // make sure only one binding is the list start
            ASSERT(BindingsList == 0);
            BindingsList = BindingsForThisInterface[i];
            }

        if (BindingsForThisInterface[i]->IsTransferSyntaxServerPreferred())
            {
            // one of the transfer syntaxes is marked as preferred -
            // try to use it.
            // Note that this doesn't break the mixed cluster scenario,
            // because when binding on new connection, we always offer both, regardless of
            // preferences. We hit this path only when we choose from
            // existing. If we moved the association to a different node
            // of the cluster, all the old connections will be blown
            // away, and it doesn't matter what presentation context we
            // choose for them. A successful bind to the new node will
            // reset the preferences, so we're fine
            NumberOfBindingsToUse = 1;
            PresentationContextsToUse = &PresentationContextsAvailable[i];
            }

        if (IsNonsyncMessage(Message))
            {
            // the call is non sync and there may be no preference. For non sync, 
            // we start with NDR20, because the client may be downlevel. When
            // the first bind completes, it will set the preference
            if (BindingsForThisInterface[i]->CompareWithTransferSyntax(NDR20TransferSyntax) == 0)
                {
                NDR20PresentationContext = i;
                }
            }
        }

    // at least one binding must be the start of the list
    ASSERT(BindingsList != 0);

    CConnection = LookForExistingConnection (
                                            BindingHandle,
                                            fExclusive,
                                            ClientAuthInfo,
                                            PresentationContextsToUse,
                                            NumberOfBindingsToUse,
                                            &PresentationContextSupported,
                                            &InitialCallState,
                                            BOOL(fUseSeparateConnection)) ;


    AssociationMutex.Clear();

    if (CConnection == 0)
        {
        //
        // Allocate a new connection
        //
        RPC_CONNECTION_TRANSPORT *ClientInfo
            = (RPC_CONNECTION_TRANSPORT *) TransInfo->InqTransInfo();

        Status = RPC_S_OK;

        CConnection = new(ClientInfo->ClientConnectionSize
                          + ClientInfo->SendContextSize
                          + sizeof(PVOID))
                          OSF_CCONNECTION(
                              this,
                              ClientInfo,
                              BindingHandle->InqComTimeout(),
                              ClientAuthInfo,
                              fExclusive,
                              BOOL(fUseSeparateConnection),
                              &Status);

        if (CConnection == 0)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            }

        if (Status != RPC_S_OK)
            {
            delete CConnection;
            return Status;
            }

        Status = AssociationMutex.RequestSafe();
        if (Status)
            {
            delete CConnection;
            return Status;
            }

        if (!fExclusive)
            {
            Status = TransInfo->StartServerIfNecessary();
            if (Status != RPC_S_OK)
                {
                AssociationMutex.Clear();

                delete CConnection;
                return Status;
                }
            }

        CConnection->ConnectionKey = ActiveConnections.Insert(CConnection);
        if (CConnection->ConnectionKey == -1)
            {
            AssociationMutex.Clear();

            delete CConnection;
            return RPC_S_OUT_OF_MEMORY;
            }

        if (IsValid() == FALSE)
            {
            ActiveConnections.Delete(CConnection->ConnectionKey);
            CConnection->ConnectionKey = -1;
            AssociationMutex.Clear();

            delete CConnection;

            return AssociationShutdownError;
            }

        if (ActiveConnections.Size() > AUTO_ENABLE_IDLE_CLEANUP)
            {
            // EnableIdleConnectionCleanup doesn't fail
            (void) EnableIdleConnectionCleanup();
            }

        InitialCallState = NeedOpenAndBind;

        //
        // Since this is the first call on the connection
        // we might as well use the cached CCall
        // we are deliberately not taking the connection mutex
        // The cached call is already marked as not available in
        // the constructor of the connection
        //
        *pCCall = CConnection->CachedCCall;

        if (fEnableIdleConnectionCleanup && (fIdleConnectionCleanupNeeded == FALSE))
            {
            fIdleConnectionCleanupNeeded = TRUE;

            //
            // Finally, we need to notify the protocol independent layer that
            // the code to delete idle connections should be executed periodically.
            // We divide by two to reduce the amount of extra time an idle
            // connection lives beyond the minimum.
            //

            GarbageCollectionNeeded(FALSE, CLIENT_DISCONNECT_TIME1 / 2);
            }

        AssociationMutex.Clear();

        if (NumberOfBindingsAvailable == 1)
            {
            // we support only one binding - just use it
            BindingToUse = BindingsForThisInterface[0];
            DispatchTableToUse = BindingToUse->GetDispatchTable();
            BindingsList = 0;
            }
        else if (IsNonsyncMessage(Message))
            {
            // if there is still more than one available binding left
            // and the call is non-sync (this can happen while the server
            // preferences are not yet recorded), artifically limit the connection
            // lookup to NDR20 to avoid downward level server compatibility problems

            ASSERT (NDR20PresentationContext != -1);

            // we may overwrite the choices made up when we iterated over the
            // available bindings. That's ok - we always want to advertise both
            // for new connections
            NumberOfBindingsToUse = 1;
            PresentationContextsToUse = &PresentationContextsAvailable[NDR20PresentationContext];

            i = (int)(PresentationContextsToUse - PresentationContextsAvailable);
            BindingToUse = BindingsForThisInterface[i];
            DispatchTableToUse = BindingToUse->GetDispatchTable();
            }
        else
            {
            // even if server preference is set, we should still suggest both
            // to support the mixed cluster scenario
            BindingToUse = 0;
            DispatchTableToUse = 0;
            }

        Status = (*pCCall)->ActivateCall(
                                        BindingHandle,
                                        BindingToUse,
                                        BindingsList,
                                        CallIdToUse,
                                        InitialCallState,
                                        DispatchTableToUse,
                                        CConnection);
        if (Status != RPC_S_OK)
            {
            ConnectionAborted(CConnection);

            delete CConnection;
            return Status ;
            }

        if (!fExclusive)
            {
            BindingHandle->OSF_BINDING_HANDLE::AddReference();
            // add one more reference to the connection in case the sync
            // path fails with out of memory and starts cleaning up
            // This extra reference will make sure that the connection
            // and cached call do not go away underneath the async path
            CConnection->OSF_CCONNECTION::AddReference();
            (*pCCall)->OSF_CCALL::AddReference();
            Status = CConnection->TransPostEvent(*pCCall);

            if (Status != RPC_S_OK)
                {
                BindingHandle->OSF_BINDING_HANDLE::BindingFree();
                ConnectionAborted(CConnection);
                (*pCCall)->OSF_CCALL::RemoveReference();

                delete CConnection;
                return Status;
                }
            }
        }
    else
        {
        // there is a connection found. If the connection supports both
        // transfer syntaxes, then a server preferred syntax must have
        // been established. If there is no server preferred syntax,
        // the chosen connection supports at most one syntax currently

        // If there is only one binding to use (either because we support
        // only one, or because there is server preference set), we use it
        // if the connection supports it. Otherwise, we need to alter
        // context the connection.
        // If there are more bindings, this means there are no server
        // preferences, and it gets more complicated. First, we need to
        // alter context both to find out the server preference. The server
        // may choose the same syntax that we already support, or it may 
        // choose a different syntax. In the async case, we choose whatever
        // is currently supported, but we try to alter context both to give
        // the server a chance to indicate its preferences.

        if (NumberOfBindingsToUse == 1)
            {
            // only one binding. Do we support it?
            if (PresentationContextSupported >= 0)  // faster version of != -1
                {
                // yes - easy choice. Just use it.

                // calculate the offset of the chosen presentation context in the original
                // presentation contexts array (PresentationContextsAvailable).
                i = (int)((PresentationContextsToUse - PresentationContextsAvailable) + PresentationContextSupported);

                }
            else
                {
                // if we are here, the connection does not support the transfer
                // syntax we need. We have only one that we support, so we
                // stick with it and fail the call if we cannot
                // negotiate to it (just a shortcut version of the first case).
                // Note that the LookForExistingConnection has set the state of
                // the call to NeedAlterContext if this is the case, so the
                // bind function will do the right thing - we don't need to worry
                // about it.
                i = (int)(PresentationContextsToUse - PresentationContextsAvailable);
                }

            // this is the same offset as the offset in the BindingsForThisInterface array, since the
            // two arrays are parallel
            BindingToUse = BindingsForThisInterface[i];
            DispatchTableToUse = BindingToUse->GetDispatchTable();
            BindingsList = 0;
            }
        else
            {
            // here NumberOfBindingsToUse is more than one. This means we support
            // more than one xfer syntax, and the server preferences are not
            // set.

            InitialCallState = NeedAlterContext;

            // We offered both. At least one must be supported - otherwise
            // the connection should have been gone.
            if (PresentationContextSupported >= 0)
                {
                // this should never happen yet. It can only happen
                // in the multiple client stubs with differen xfer syntax
                // support scenario, but we don't support it yet.
                ASSERT(0);
                if (IsNonsyncMessage(Message))
                    {
                    i = (int)((PresentationContextsToUse - PresentationContextsAvailable) + PresentationContextSupported);
                    BindingToUse = BindingsForThisInterface[i];
                    DispatchTableToUse = BindingToUse->GetDispatchTable();
                    // Don't whack out the list - this allows the client to offer both
                    // BindingsList = 0;
                    }
                else
                    {
                    BindingToUse = 0;
                    DispatchTableToUse = 0;
                    }
                }
            else
                {
                if (IsNonsyncMessage(Message))
                    {
                    // if there is still more than one available binding left
                    // and the call is non-sync (this can happen while the server
                    // preferences are not yet recorded), artifically limit the connection
                    // lookup to NDR20 to avoid downward level server compatibility problems

                    ASSERT (NDR20PresentationContext != -1);

                    // we may overwrite the choices made up when we iterated over the
                    // available bindings. That's ok - we always want to advertise both
                    // in this case
                    NumberOfBindingsToUse = 1;
                    PresentationContextsToUse = &PresentationContextsAvailable[NDR20PresentationContext];

                    i = (int)(PresentationContextsToUse - PresentationContextsAvailable);
                    BindingToUse = BindingsForThisInterface[i];
                    DispatchTableToUse = BindingToUse->GetDispatchTable();
                    // Don't whack out the list - this allows the client to offer both
                    // BindingsList = 0;
                    }
                else
                    {
                    // even if server preference is set, we should still suggest both
                    // to support the mixed cluster scenario
                    BindingToUse = 0;
                    DispatchTableToUse = 0;
                    }

                }
            }

        //
        // This is not the first call on the connection. We will ask it to allocate
        // a call for us
        //
        Status = CConnection->AllocateCCall(pCCall);
        if (Status == RPC_S_OK)
            {
            Status = (*pCCall)->ActivateCall(
                                             BindingHandle,
                                             BindingToUse,
                                             BindingsList,
                                             CallIdToUse,
                                             InitialCallState,
                                             DispatchTableToUse,
                                             CConnection);
            if (Status != RPC_S_OK)
                {
                //
                // Call has not yet started, ok to directly
                // free the call.
                //
                (*pCCall)->FreeCCall(RPC_S_CALL_FAILED_DNE);
                *fBindingHandleReferenceRemoved = TRUE;
                return Status;
                }

            Status = (*pCCall)->ReserveSpaceForSecurityIfNecessary();
            if (Status != RPC_S_OK)
                {
                //
                // Call has not yet started, ok to directly
                // free the call.
                //
                (*pCCall)->FreeCCall(RPC_S_CALL_FAILED_DNE);
                *fBindingHandleReferenceRemoved = TRUE;
                return Status;
                }
            }
        }


    return Status;
}

BOOL
OSF_CASSOCIATION::ConnectionAborted (
    IN OSF_CCONNECTION *Connection
    )
/*++
Function Name:ConnectionAborted

Parameters:

Description:

Returns:

--*/
{
    BOOL fDontKill = FALSE;

    AssociationMutex.Request();
    if (Connection->ConnectionKey != -1)
        {
        LogEvent(SU_CCONN, EV_STOP, Connection, this, Connection->ConnectionKey, 1, 0);
        ActiveConnections.Delete(Connection->ConnectionKey);
        Connection->ConnectionKey = -1;
        }

    if (Connection->fConnectionAborted == 0)
        {
        NotifyConnectionClosed();
        Connection->fConnectionAborted = 1;
        }
    else
        {
        fDontKill = TRUE;
        }
    AssociationMutex.Clear();

    return fDontKill;
}

RPC_STATUS
OSF_CASSOCIATION::FindOrCreateToken (
    IN HANDLE hToken,
    IN LUID *pModifiedId,
    OUT RPC_TOKEN **ppToken,
    OUT BOOL *pfTokenFound
    )
/*++
Function Name:FindOrCreateToken

Parameters:

Description:

Returns:

--*/
{
    DictionaryCursor cursor;
    RPC_TOKEN *Token;
    RPC_STATUS Status;

    Status = AssociationMutex.RequestSafe();
    if (Status)
        return Status;
    TokenDict.Reset(cursor);
    while ((Token = TokenDict.Next(cursor)) != 0)
        {
        if (FastCompareLUIDAligned(&Token->ModifiedId, pModifiedId))
            {
            *pfTokenFound = TRUE;
            Token->RefCount++; // Token++;
            LogEvent(SU_REFOBJ, EV_INC, Token, 0, Token->RefCount, 1, 1);

            *ppToken = Token;
            Status = RPC_S_OK;
            goto Cleanup;
            }
        }

    *pfTokenFound = FALSE;

    *ppToken = new RPC_TOKEN(hToken, pModifiedId); // constructor cannot fail
    if (*ppToken == 0)
        {
        CloseHandle(hToken);
        Status = RPC_S_OUT_OF_MEMORY;
        goto Cleanup;
        }

    if (((*ppToken)->Key = TokenDict.Insert(*ppToken)) == -1)
        {
        Status = RPC_S_OUT_OF_MEMORY;
        delete *ppToken;
        goto Cleanup;
        }

    Status = RPC_S_OK;

Cleanup:
    AssociationMutex.Clear();
    return Status;
}

void
OSF_CASSOCIATION::ReferenceToken(
    IN RPC_TOKEN *pToken
    )
/*++
Function Name:ReferenceToken

Parameters:

Description:

Returns:

--*/
{
    AssociationMutex.Request();

    ASSERT(pToken->RefCount);

    pToken->RefCount++; // Token++
    LogEvent(SU_REFOBJ, EV_INC, pToken, 0, pToken->RefCount, 1, 1);

    AssociationMutex.Clear();
}

void
OSF_CASSOCIATION::DereferenceToken(
    IN RPC_TOKEN *pToken
    )
/*++
Function Name:DereferenceToken

Parameters:

Description:

Returns:

--*/
{
    AssociationMutex.Request();
    LogEvent(SU_REFOBJ, EV_DEC, pToken, 0, pToken->RefCount, 1, 1);

    pToken->RefCount--; // Token--
    if (pToken->RefCount == 0)
        {
        TokenDict.Delete(pToken->Key);
        CleanupConnectionList(pToken);
        delete pToken;
        }

    AssociationMutex.Clear();
}

void
OSF_CASSOCIATION::CleanupConnectionList(
    IN RPC_TOKEN *pToken
    )
/*++
Function Name:CleanupConnectionList

Parameters:

Description:

Returns:

--*/
{
    DictionaryCursor cursor;
    OSF_CCONNECTION *CConnection;

    AssociationMutex.VerifyOwned();

    if ( MaintainContext != 0 && ActiveConnections.Size() <= 1) return;

    ActiveConnections.Reset(cursor);
    while ( (CConnection = ActiveConnections.Next(cursor)) != 0 )
        {
        if (CConnection->ThreadId == SYNC_CONN_FREE
            || CConnection->ThreadId == ASYNC_CONN_FREE)
            {
            if (CConnection->MatchModifiedId(&(pToken->ModifiedId)) == TRUE)
                {
                CConnection->AddReference(); //CCONN++

                ConnectionAborted(CConnection);
                CConnection->DeleteConnection();

                //
                // I don't if the add/remove reference is really needed
                // I am only doing it to preserve existing semantics
                //
                CConnection->RemoveReference(); // CCONN--
                }
            }
        }

}


void
ConstructPContextList (
    OUT p_cont_list_t *pCon, // Place the list here.
    IN OSF_BINDING *AvailableBindings,
    IN int NumberOfBindings
    )
/*++
Function Name:ConstructPContextList

Parameters:

Description:
    Construct the presentation context list in the
    rpc_bind packet (and implicitly rpc_alter_context)
    packet.

Returns:

--*/
{
    int i;
    OSF_BINDING *CurrentBinding;

    pCon->n_context_elem = (unsigned char)NumberOfBindings;
    pCon->reserved = 0;
    pCon->reserved2 = 0;

    CurrentBinding = AvailableBindings;
    for (i = 0; i < NumberOfBindings; i ++, CurrentBinding = CurrentBinding->GetNextBinding())
        {
        pCon->p_cont_elem[i].p_cont_id = CurrentBinding->GetOnTheWirePresentationContext();
        pCon->p_cont_elem[i].n_transfer_syn = (unsigned char) 1;
        pCon->p_cont_elem[i].reserved = 0;

        RpcpMemoryCopy(&pCon->p_cont_elem[i].abstract_syntax,
                       CurrentBinding->GetInterfaceId(),
                       sizeof(RPC_SYNTAX_IDENTIFIER));

        RpcpMemoryCopy(pCon->p_cont_elem[i].transfer_syntaxes,
                       CurrentBinding->GetTransferSyntaxId(),
                       sizeof(RPC_SYNTAX_IDENTIFIER));
        }
}



OSF_CCONNECTION::OSF_CCONNECTION (
    IN OSF_CASSOCIATION *MyAssociation,
    IN RPC_CONNECTION_TRANSPORT * RpcClientInfo,
    IN UINT Timeout,
    IN CLIENT_AUTH_INFO * ClientAuthInfo,
    IN BOOL fExclusive,
    IN BOOL fSeparateConnection,
    OUT RPC_STATUS  * pStatus
    ) : ConnMutex(pStatus),
    ClientSecurityContext(ClientAuthInfo, 0, FALSE, pStatus)
/*++
Function Name:OSF_CCONNECTION

Parameters:

Description:
    Constructor for the connection object

Returns:

--*/
{
    LogEvent(SU_CCONN, EV_CREATE, this);

    Association = MyAssociation;
    // CASSOC++
    Association->AddReference();

    ObjectType = OSF_CCONNECTION_TYPE;
    ClientInfo = RpcClientInfo;
    State = ConnUninitialized;
    ComTimeout = Timeout ;
    u.ConnSendContext = (char *) TransConnection()
                      + ClientInfo->ClientConnectionSize
                      + sizeof(PVOID);
    *((PVOID *) ((char *) u.ConnSendContext - sizeof(PVOID))) = (PVOID) this;

    MaxFrag = 512;
    ConnectionKey = -1;
    AdditionalLegNeeded = 0;
    LastTimeUsed = 0;
    SavedHeader = 0;
    SavedHeaderSize = 0;
    MaxSavedHeaderSize = 0;
    BufferToFree = 0;

    fIdle = 0;
    this->fExclusive = fExclusive;
    this->fSeparateConnection = fSeparateConnection;
    InitializeWireAuthId(ClientAuthInfo);

    if (fExclusive)
        {
        AdditionalSpaceForSecurity = 0;
        ThreadId = SYNC_CONN_BUSY;
        }
    else
        {
        //
        // If it turns out that needed size is actually bigger
        // we will really the buffers
        //
        AdditionalSpaceForSecurity = 0x140;

        if (fSeparateConnection)
            {
            ThreadId = ASYNC_CONN_BUSY;
            }
        else
            {
            ThreadId = GetCurrentThreadId();
            }
        }

    fConnectionAborted = 1;


    //
    // We need two references on the connection. One for itself, and
    // one for the cached ccall, which is implicitly getting allocated.
    //
    SetReferenceCount(2);

    DceSecurityInfo.SendSequenceNumber = 0;
    DceSecurityInfo.ReceiveSequenceNumber = 0;

    *pStatus = TransInitialize(
                    Association->DceBinding->InqNetworkAddress(),
                    Association->DceBinding->InqNetworkOptions());
    if (*pStatus == RPC_S_OK)
        {
        CachedCCall = new (ClientInfo->SendContextSize+sizeof(PVOID))
                                    OSF_CCALL(pStatus);
        if (CachedCCall == 0)
            {
            *pStatus = RPC_S_OUT_OF_MEMORY;
            }
        }
    else
        {
        CachedCCall = NULL;
        }

    CachedCCallAvailable = 0;
    CurrentCall = CachedCCall;
    ConnectionReady = 0;

}


OSF_CCONNECTION::~OSF_CCONNECTION (
    )
{
    LogEvent(SU_CCONN, EV_DELETE, this);

    RPC_STATUS Status;

    if (CachedCCall)
        {
        delete CachedCCall;
        }

    TransInitComplete();
    TransClose();

    Association->ConnectionAborted(this);

    if (SavedHeader != 0)
       {
       ASSERT(SavedHeaderSize != 0);
       RpcpFarFree(SavedHeader);
       }

   // CASSOC--
   Association->RemoveReference();
}


RPC_STATUS
OSF_CCONNECTION::ValidateHeader(
     rpcconn_common * Buffer,
     unsigned long BufferLength
     )
{
    if (ClientSecurityContext.AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE)
        {
        unsigned CopyLength;

        if (Buffer->PTYPE == rpc_bind_ack ||
            Buffer->PTYPE == rpc_alter_context_resp)
            {
            CopyLength = BufferLength;
            }
        else
            {
            CopyLength = sizeof(rpcconn_response);
            }

        if (MaxSavedHeaderSize < CopyLength)
            {
            if (SavedHeader != 0)
                {
                ASSERT(MaxSavedHeaderSize != 0);
                RpcpFarFree(SavedHeader);
                }

            SavedHeader = RpcpFarAllocate(CopyLength);
            if (SavedHeader == 0)
                {
                MaxSavedHeaderSize = 0;
                return(RPC_S_OUT_OF_MEMORY);
                }
            MaxSavedHeaderSize = CopyLength;
            RpcpMemoryCopy(SavedHeader, Buffer, CopyLength);
            }
        else
            {
            RpcpMemoryCopy(SavedHeader, Buffer, CopyLength);
            }

        SavedHeaderSize = CopyLength;
        }

    RPC_STATUS Status = ValidatePacket(Buffer, BufferLength);
    if ( Status != RPC_S_OK )
        {
        ASSERT( Status == RPC_S_PROTOCOL_ERROR );
        return Status;
        }

    return RPC_S_OK;
}


RPC_STATUS
OSF_CCONNECTION::TransReceive (
    OUT PVOID  * Buffer,
    OUT UINT  * BufferLength,
    IN ULONG Timeout
    )
/*++

Routine Description:

Arguments:

    Buffer - Returns a packet received from the transport.

    BufferLength - Returns the length of the buffer.

Return Value:

    RPC_S_OK - We successfully received a packet from the server.
    RPC_S_* - an error has occurred. See the validate clause at the
        end

--*/
{
    RPC_STATUS Status;

    if ( State != ConnOpen )
        {
        return(RPC_P_CONNECTION_CLOSED);
        }

    ASSERT(CurrentCall);

    Status = ClientInfo->SyncRecv(
                                 TransConnection(),
                                 (BUFFER *) Buffer,
                                 BufferLength, 
                                 INFINITE);

    if ( (Status == RPC_P_RECEIVE_FAILED)
        || (Status == RPC_P_CONNECTION_SHUTDOWN)
        || (Status == RPC_P_TIMEOUT))
        {
        State = ConnAborted;
        }

    VALIDATE(Status)
        {
        RPC_S_OK,
        RPC_S_OUT_OF_MEMORY,
        RPC_S_OUT_OF_RESOURCES,
        RPC_S_CALL_CANCELLED,
        RPC_P_RECEIVE_ALERTED,
        RPC_P_TIMEOUT,
        RPC_P_RECEIVE_FAILED,
        RPC_P_CONNECTION_SHUTDOWN
        } END_VALIDATE;

    return(Status);
}


RPC_STATUS
OSF_CCONNECTION::TransOpen (
    IN OSF_BINDING_HANDLE *BindingHandle,
    IN RPC_CHAR *RpcProtocolSequence,
    IN RPC_CHAR *NetworkAddress,
    IN RPC_CHAR *Endpoint,
    IN RPC_CHAR *NetworkOptions,
    IN void *ResolverHint,
    IN BOOL fHintInitialized,
    IN ULONG CallTimeout
    )
/*++
Function Name:TransOpen

Parameters:
    CallTimeout - call timeout in milliseconds

Description:

Returns:

--*/
{
    RPC_STATUS Status ;
    BOOL fTokenSwapped ;
    HANDLE OldToken = 0;
    CLIENT_AUTH_INFO *ClientAuthInfo;

    fTokenSwapped = BindingHandle->SwapToken(&OldToken);
    ClientAuthInfo = BindingHandle->InquireAuthInformation();

    Status = ClientInfo->Open(TransConnection(),
                              RpcProtocolSequence,
                              NetworkAddress,
                              Endpoint,
                              NetworkOptions,
                              ComTimeout,
                              0,
                              0,
                              ResolverHint,
                              fHintInitialized,
                              CallTimeout,
                              ClientAuthInfo->AdditionalTransportCredentialsType,
                              ClientAuthInfo->AdditionalCredentials
                              );

    if (fTokenSwapped)
        {
        ReplaceToken(OldToken);
        if (OldToken)
            {
            CloseHandle(OldToken);
            }
        }

    //
    // If an error occurs in opening the connection, we go ahead and
    // delete the memory for the connection, and return zero (setting
    // this to zero does that).
    //
    VALIDATE (Status)
        {
        RPC_S_OK,
        RPC_S_PROTSEQ_NOT_SUPPORTED,
        RPC_S_SERVER_UNAVAILABLE,
        RPC_S_OUT_OF_MEMORY,
        RPC_S_OUT_OF_RESOURCES,
        RPC_S_SERVER_TOO_BUSY,
        RPC_S_INVALID_NETWORK_OPTIONS,
        RPC_S_INVALID_ENDPOINT_FORMAT,
        RPC_S_INVALID_NET_ADDR,
        RPC_S_ACCESS_DENIED,
        RPC_S_INTERNAL_ERROR,
        RPC_S_SERVER_OUT_OF_MEMORY,
        RPC_S_CALL_CANCELLED
        } END_VALIDATE;

    if ( Status == RPC_S_OK )
        {
        State = ConnOpen;
        }

    return Status ;
}


void
OSF_CCONNECTION::TransClose (
    )
{
    RPC_STATUS Status;

    if (State != ConnUninitialized)
        {
        __try
            {
            Status = ClientInfo->Close(TransConnection(), 0);

            ASSERT( Status == RPC_S_OK );
            }
        __except( EXCEPTION_EXECUTE_HANDLER )
            {
#if DBG
            PrintToDebugger("RPC: exception in Close\n") ;
#endif
            Status = RPC_S_OUT_OF_MEMORY ;
            }

        State = ConnUninitialized;
        }
}


RPC_STATUS
OSF_CCONNECTION::TransAsyncSend (
    IN void  * Buffer,
    IN UINT BufferLength,
    IN void  *SendContext
    )
/*++
Function Name:TransAsyncSend

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;

    {
    rpcconn_common * pkt = (rpcconn_common *) Buffer;
    LogEvent(SU_CCONN, EV_PKT_OUT, this, pkt, (pkt->PTYPE << 16) | pkt->frag_length);
    }

    //
    // When this function is called, there is should be not outstanding send
    //
    if ( State != ConnOpen )
        {
        return(RPC_P_CONNECTION_CLOSED);
        }

    DceSecurityInfo.SendSequenceNumber += 1;

    Status = ClientInfo->Send(TransConnection(),
                              BufferLength,
                              (BUFFER) Buffer,
                              SendContext);

    if ( Status != RPC_S_OK )
        {
        State = ConnAborted;
        }

    VALIDATE(Status)
        {
        RPC_S_OK,
        RPC_S_OUT_OF_MEMORY,
        RPC_S_OUT_OF_RESOURCES,
        RPC_P_SEND_FAILED
        } END_VALIDATE;


    return(Status);
}


RPC_STATUS
OSF_CCONNECTION::TransAsyncReceive (
    )
/*++
Function Name:TransAsyncReceive

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;

    if (State != ConnOpen || fConnectionAborted)
        {
        return(RPC_P_CONNECTION_CLOSED);
        }

    //
    // If the call to Recv succeeds, this reference is removed
    // in ProcessIOEvents after the call to ProcessReceiveComplete
    //
    // CCONN++
    AddReference();

    Status = ClientInfo->Recv(TransConnection());

    if ((Status == RPC_P_RECEIVE_FAILED)
        || (Status == RPC_P_CONNECTION_SHUTDOWN)
        || (Status == RPC_P_TIMEOUT))
        {
        State = ConnAborted;
        }

    VALIDATE(Status)
        {
        RPC_S_OK,
        RPC_S_OUT_OF_MEMORY,
        RPC_S_OUT_OF_RESOURCES,
        RPC_P_RECEIVE_ALERTED,
        RPC_P_RECEIVE_FAILED,
        RPC_P_CONNECTION_SHUTDOWN
        } END_VALIDATE;

    if (Status != RPC_S_OK)
        {
        ConnectionAborted(Status);

        // CCONN--
        RemoveReference();
        }

    return(Status);
}

void
OsfBindToServer(
    PVOID Context
    )
{
    ((OSF_CCALL *) Context)->BindToServer(
        TRUE        // this is an async bind - slightly different
                    // refcounting is used
        );
}


RPC_STATUS
OSF_CCONNECTION::TransPostEvent (
    IN PVOID Context
    )
/*++
Function Name:TransPostEvent

Parameters:

Description:

Returns:

--*/
{
    LogEvent(SU_CCONN, EV_NOTIFY, this, Context, 0, 1);
    return ClientInfo->PostEvent( CO_EVENT_BIND_TO_SERVER, Context) ;
}


RPC_STATUS
OSF_CCONNECTION::TransSend (
    IN void  * Buffer,
    IN UINT BufferLength,
    IN BOOL fDisableShutdownCheck,
    IN BOOL fDisableCancelCheck,
    IN ULONG Timeout
    )
/*++

Routine Description:

Arguments:

    Buffer - Supplies a packet to be sent to the server.

    BufferLength - Supplies the length of the buffer in bytes.

Return Value:

    RPC_S_OK - The packet was successfully sent to the server.
    RPC_S_* - an error occurred - see the validate clause at the
        end

--*/
{
    RPC_STATUS Status;

    {
        rpcconn_common * pkt = (rpcconn_common *) Buffer;
        LogEvent(SU_CCONN, EV_PKT_OUT, this, 0, (pkt->PTYPE << 16) | pkt->frag_length);
    }

    if ( State != ConnOpen )
        {
        return(RPC_P_CONNECTION_CLOSED);
        }

    if (fDisableCancelCheck == 0
        && CurrentCall->fCallCancelled)
        {
        return(RPC_S_CALL_CANCELLED);
        }

    DceSecurityInfo.SendSequenceNumber += 1;

    Status = ClientInfo->SyncSend(TransConnection(),
                                  BufferLength,
                                  (BUFFER) Buffer,
                                  fDisableShutdownCheck,
                                  fDisableCancelCheck,
                                  INFINITE);  // Timeout

    if ( Status == RPC_P_SEND_FAILED )
        {
        State = ConnAborted;
        }

    VALIDATE(Status)
        {
        RPC_S_OK,
        RPC_S_OUT_OF_MEMORY,
        RPC_S_OUT_OF_RESOURCES,
        RPC_P_SEND_FAILED,
        RPC_S_CALL_CANCELLED,
        RPC_P_RECEIVE_COMPLETE,
        RPC_P_TIMEOUT
        } END_VALIDATE;

    return(Status);
}

void
OSF_CCONNECTION::TransAbortConnection (
    )
{
    ClientInfo->Abort(TransConnection());
}

RPC_STATUS
OSF_CCONNECTION::TransSendReceive (
    IN void  * SendBuffer,
    IN UINT SendBufferLength,
    OUT void  *  * ReceiveBuffer,
    OUT UINT  * ReceiveBufferLength,
    IN ULONG Timeout
    )
/*++

Routine Description:

Arguments:

    SendBuffer - Supplies a packet to be sent to the server.

    SendBufferLength - Supplies the length of the send buffer in bytes.

    ReceiveBuffer - Returns a packet received from the transport.

    ReceiveBufferLength - Returns the length of the receive buffer in bytes.

    dwTimeout - the timeout to wait for the receive. -1 if infinite.

Return Value:

    RPC_S_OK - The packet was successfully sent to the server, and we
        successfully received one from the server.
    RPC_S_* - an error occurred - see the validate clause at the end

--*/
{
    RPC_STATUS Status;

    {
        rpcconn_common * pkt = (rpcconn_common *) SendBuffer;
        if (pkt->PTYPE != rpc_request)
            {
            LogEvent(SU_CCONN, EV_PKT_OUT, this, ULongToPtr(pkt->call_id), (pkt->PTYPE << 16) | pkt->frag_length);
            }
        else
            {
            LogEvent(SU_CCONN, EV_PKT_OUT, this, ULongToPtr(pkt->call_id),
                (((rpcconn_request *)pkt)->opnum << 24) | (pkt->PTYPE << 16) | pkt->frag_length);
            }
    }

    if ( State != ConnOpen )
        {
        return(RPC_P_CONNECTION_CLOSED);
        }

    if (CurrentCall->fCallCancelled)
        {
        return(RPC_S_CALL_CANCELLED);
        }

    DceSecurityInfo.SendSequenceNumber += 1;

    if ( ClientInfo->SyncSendRecv != 0
         && (CurrentCall->CancelState != CANCEL_NOTINFINITE)
         && (Timeout == INFINITE))
        {
        Status = ClientInfo->SyncSendRecv(TransConnection(),
                                         SendBufferLength,
                                         (BUFFER) SendBuffer,
                                         ReceiveBufferLength,
                                         (BUFFER *) ReceiveBuffer);
        if (!Status)
            {
            rpcconn_common * pkt = (rpcconn_common *) *ReceiveBuffer;
            LogEvent(SU_CCONN, EV_PKT_IN, this, 0, (pkt->PTYPE << 16) | pkt->frag_length);
            }
        }
    else
        {
        Status = ClientInfo->SyncSend (TransConnection(),
                                       SendBufferLength,
                                       (BUFFER) SendBuffer,
                                       FALSE, 
                                       FALSE,
                                       Timeout);     // Timeout
        if ( Status == RPC_S_OK
            || Status == RPC_P_RECEIVE_COMPLETE )
            {
            Status = ClientInfo->SyncRecv(TransConnection(),
                                          (BUFFER *) ReceiveBuffer,
                                          ReceiveBufferLength,
                                          Timeout);
            if (!Status)
                {
                rpcconn_common * pkt = (rpcconn_common *) *ReceiveBuffer;
                LogEvent(SU_CCONN, EV_PKT_IN, this, 0, (pkt->PTYPE << 16) | pkt->frag_length);
                }
            }
        }

    if ((Status == RPC_P_SEND_FAILED)
        || (Status == RPC_P_RECEIVE_FAILED)
        || (Status == RPC_P_CONNECTION_SHUTDOWN)
        || (Status == RPC_P_TIMEOUT))
        {
        State = ConnAborted;
        }

    VALIDATE(Status)
        {
         RPC_S_OK,
         RPC_S_OUT_OF_MEMORY,
         RPC_S_OUT_OF_RESOURCES,
         RPC_P_RECEIVE_FAILED,
         RPC_S_CALL_CANCELLED,
         RPC_P_SEND_FAILED,
         RPC_P_CONNECTION_SHUTDOWN,
         RPC_P_TIMEOUT
         } END_VALIDATE;

    return(Status);
}


UINT
OSF_CCONNECTION::TransMaximumSend (
    )
/*++

Return Value:

    The maximum packet size which can be sent on this transport is returned.

--*/
{
    return(ClientInfo->MaximumFragmentSize);
}


void
OSF_CCONNECTION::ConnectionAborted (
    IN RPC_STATUS Status,
    IN BOOL fShutdownAssoc
    )
/*++
Function Name:AbortConnection

Parameters:

Description:

Returns:

--*/
{
    OSF_CCALL *CCall;
    unsigned int Size;
    DictionaryCursor cursor;
    BOOL fFreeLastBuffer;

    // the failing of the call may take a reference from underneath us
    // bump up the reference count while we have a reference on the
    // object. We'll remove it by the end of the function
    // CCONN++
    ASSERT(fExclusive == 0);

    AddReference();

    // make sure the connection gets removed from the dictionary
    Association->ConnectionAborted(this);

    if (fShutdownAssoc)
        {
        Association->ShutdownRequested(Status, NULL);
        }

    ConnMutex.Request();

    ActiveCalls.Reset(cursor);
    while (CCall = ActiveCalls.Next(cursor))
        {
        if (CCall->CALL::GetCallStatus() == RPC_S_CALL_CANCELLED)
            {
            CCall->CallFailed(RPC_S_CALL_CANCELLED);
            }
        else
            {
            fFreeLastBuffer = FALSE;
            if (CCall->fLastSendComplete)
                {
                if (CurrentCall != CCall)
                    {
                    if ((CCall->CurrentState == NeedOpenAndBind)
                        ||
                        (CCall->CurrentState == NeedAlterContext))
                        {
                        fFreeLastBuffer = TRUE;
                        }
                    }
                else if ((CCall->CurrentState == NeedOpenAndBind)
                        ||
                        (CCall->CurrentState == NeedAlterContext)
                        ||
                        (CCall->CurrentState == WaitingForAlterContext)
                        ||
                        (CCall->CurrentState == SendingFirstBuffer)
                       )
                    {
                    fFreeLastBuffer = TRUE;
                    }
                }

            if (fFreeLastBuffer)
                {
                TransFreeBuffer(CCall->ActualBuffer(CCall->LastBuffer));
                CCall->LastBuffer = NULL;
                }

            CCall->CallFailed(Status);
            }
        }

    //
    // Remove the send references on all the calls currently in the queue
    //
    while (CCall = (OSF_CCALL *) CallQueue.TakeOffQueue(&Size))
        {
        //
        // Remove the send reference, CCALL--
        //
        CCall->RemoveReference();
        }
    ConnMutex.Clear();

    //
    // Make sure we remove this connection from the dictionary
    // before deleting it. We don't want another thread to pick it up
    //
    TransAbortConnection();

    Delete();

    //
    // This routine will always be called with a reference held
    //
    ASSERT(RefCount.GetInteger());

    State = ConnAborted;

    // CCONN--
    RemoveReference();
}


void
OSF_CCONNECTION::AdvanceToNextCall(
    )
/*++
Function Name:AdvanceToNextCall

Parameters:

Description:

Returns:

--*/
{
    UINT Size;
    RPC_STATUS Status;


    ConnMutex.Request();
    CurrentCall = (OSF_CCALL *) CallQueue.TakeOffQueue(&Size);

    if (CurrentCall == 0)
        {
        MakeConnectionIdle();
        ConnMutex.Clear();
        }
    else
        {
        ConnMutex.Clear();
        Status = CurrentCall->SendData(0);
        if (Status != RPC_S_OK)
            {
            ConnectionAborted(Status);

            //
            // The connection cannot die.
            //

            //
            // Remove the send reference for this call. CCALL--
            //
            CurrentCall->RemoveReference();
            }
        }
}


inline RPC_STATUS
OSF_CCONNECTION::TransGetBuffer (
    OUT void  *  * Buffer,
    IN UINT BufferLength
    )
/*++

Routine Description:

    We need a buffer to receive data into or to put data into to be sent.
    This should be really simple, but we need to make sure that buffer we
    return is aligned on an 8 byte boundary.  The stubs make this requirement.

Arguments:

    Buffer - Returns a pointer to the buffer.

    BufferLength - Supplies the required length of the buffer in bytes.

Return Value:

    RPC_S_OK - We successfully allocated a buffer of at least the required
        size.

    RPC_S_OUT_OF_MEMORY - There is insufficient memory available to allocate
        the required buffer.

--*/
{
    int  * Memory;

    //
    // Our memory allocator returns memory which is aligned by at least
    // 8, so we dont need to worry about aligning it.
    //

    Memory = (int  *) CoAllocateBuffer(BufferLength);
    if ( Memory == 0 )
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    ASSERT(IsBufferAligned(Memory));

    *Buffer = Memory;

    ASSERT(PadPtr8(*Buffer) == 0);

    return(RPC_S_OK);
}


inline void
OSF_CCONNECTION::TransFreeBuffer (
    IN void  * Buffer
    )
/*++

Routine Description:

    We need to free a buffer which was allocated via TransGetBuffer.  The
    only tricky part is remembering to remove the padding before actually
    freeing the memory.

--*/
{
    CoFreeBuffer(Buffer);
}


RPC_STATUS
OSF_CCONNECTION::TransReallocBuffer (
    IN OUT void  *  * Buffer,
    IN UINT OldSize,
    IN UINT NewSize
    )
/*++
Function Name:TransReallocBuffer

Parameters:

Description:
    Reallocates a give buffer to the new size.

Returns:
    RPC_S_OK: the buffer is successfully reallocated
    RPC_S_OUT_OF_MEMORY: the realloc failed, the old buffer
     is still valid.

--*/
{
    BUFFER NewBuffer;
    RPC_STATUS Status;

    Status = TransGetBuffer(
                            (PVOID *) &NewBuffer,
                            NewSize);
    if (Status != RPC_S_OK)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    if (OldSize)
        {
        RpcpMemoryCopy(NewBuffer, *Buffer, OldSize);
        TransFreeBuffer(*Buffer);
        }

    *Buffer = NewBuffer;

    return RPC_S_OK;
}


inline RPC_STATUS
OSF_CCONNECTION::AllocateCCall (
    OUT OSF_CCALL **CCall
    )
/*++
Function Name:AllocateCCall

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;

    if (fExclusive)
        {
        ASSERT(CachedCCallAvailable == 1);
        CachedCCallAvailable = 0;
        *CCall = CachedCCall;
        }
    else
        {
        if (InterlockedCompareExchange( (PLONG)&CachedCCallAvailable, 0, 1))
            {
            *CCall = CachedCCall;
            }
        else
            {
            Status = RPC_S_OK;

            *CCall = new (ClientInfo->SendContextSize+sizeof(PVOID))
                               OSF_CCALL(&Status);

            if (*CCall == 0)
                {
                Status =  RPC_S_OUT_OF_MEMORY;
                }

            if (Status != RPC_S_OK)
                {
                delete *CCall;
                return Status;
                }
            }

        }

    LogEvent(SU_CCALL, EV_START, *CCall);

    return RPC_S_OK;
}


RPC_STATUS
OSF_CCONNECTION::AddCall (
    IN OSF_CCALL *CCall
    )
/*++
Function Name:AddCall

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;

    //
    // Think of a better way of doing this. This condition is true the first
    // time a connection is created, and when we are talking to legacy
    // servers over non-exclusive connections
    //
    if (CurrentCall == CCall)
        {
        return RPC_S_OK;
        }

    ConnMutex.Request();
    if (CurrentCall == 0)
        {
        CurrentCall = CCall;
        }
    else
        {
        if ((State == ConnAborted) 
            || ((Association->IsAssociationReset())
                &&
                (State != ConnUninitialized)
               )
           )
            {
            ConnMutex.Clear();
            return RPC_S_CALL_FAILED;
            }

        Status = CallQueue.PutOnQueue(CCall, 0);
        if (Status != 0)
            {
            ConnMutex.Clear();
            return RPC_S_OUT_OF_MEMORY;
            }
        }
    ConnMutex.Clear();

    return RPC_S_OK;
}


void
OSF_CCONNECTION::FreeCCall (
    IN OSF_CCALL *CCall,
    IN RPC_STATUS Status,
    IN ULONG ComTimeout
    )
/*++
Function Name:FreeCCall

Parameters:
    CCall - the call that is being freed
    Status - the status with which the call completed
    ComTimeout - the communication timeout for this call

Description:
    Free the call, remove reference on the connection. If the free
    is abortive, we need to cleanup the connection and inform the
    association about it.

Returns:

--*/
{
    LogEvent(SU_CCALL, EV_STOP, CCall);

    ConnMutex.Request();

    if (CCall->EEInfo)
        {
        FreeEEInfoChain(CCall->EEInfo);
        CCall->EEInfo = NULL;
        }

    if (fExclusive == 0)
        {
        ActiveCalls.Delete(IntToPtr(CCall->CallId));
        }

    if (CCall == CachedCCall)
        {
        CachedCCallAvailable = 1;
        }
    else
        {
        delete CCall;
        }

    switch (Status)
        {
        case RPC_S_OUT_OF_MEMORY:
        case RPC_S_ACCESS_DENIED:
        case RPC_S_PROTOCOL_ERROR:
        case RPC_S_CALL_FAILED:
        case RPC_S_CALL_FAILED_DNE:
        case RPC_S_CALL_CANCELLED:
        case RPC_S_SEC_PKG_ERROR:
        case RPC_S_INVALID_ARG:
        case RPC_S_SERVER_UNAVAILABLE:
        case RPC_P_CONNECTION_SHUTDOWN:
        case RPC_P_CONNECTION_CLOSED:
            //
            // Need to release the connection mutex, so we won't deadlock
            //
            ConnMutex.Clear();
            Association->ConnectionAborted(this);

            ConnMutex.Request();

            if (fExclusive)
                {
                Delete();
                }
            else
                {
                TransAbortConnection();
                }
            break;

        default:
            // RPC_S_UNKNOWN_IF & others
            // Put error codes here only if you are absolutely
            // sure you can recover. If in doubt, put them
            // above

            if (ThreadId == SYNC_CONN_BUSY)
                {
                ThreadId = SYNC_CONN_FREE;
                }
            else if (ThreadId == ASYNC_CONN_BUSY)
                {
                ThreadId = ASYNC_CONN_FREE;
                ASSERT(fExclusive == FALSE);
                if (ComTimeout != RPC_C_BINDING_INFINITE_TIMEOUT)
                    {
                    TurnOnOffKeepAlives (FALSE, 0);
                    }
                }

            SetLastTimeUsedToNow();
            break;
        }
    ConnMutex.Clear();

    //
    // Remove the reference held by the call, CCONN--
    //
    RemoveReference();
}


void
OSF_CCONNECTION::ProcessSendComplete (
   IN RPC_STATUS EventStatus,
   IN BUFFER Buffer
   )
/*++
Function Name:ProcessSendComplete

Parameters:

Description:

Returns:

--*/
{
    rpcconn_common *Packet = (rpcconn_common *) Buffer;
    OSF_CCALL *OldCall = CurrentCall;

    switch (Packet->PTYPE)
        {
        case rpc_request:
        case rpc_response:
            TransFreeBuffer(BufferToFree);

            if (EventStatus == RPC_S_OK)
                {
                if (Association->fMultiplex == mpx_yes)
                    {
                    //
                    // We are have no more data to send on this
                    // call. Remove ourselves from the call queue
                    //
                    AdvanceToNextCall();
                    }
                else
                    {
                    if (OldCall->fOkToAdvanceCall())
                        {
                        AdvanceToNextCall();
                        }
                    }

                //
                // Remove the send reference on the call, CCALL--
                //
                OldCall->RemoveReference();
                return;
                }

            break;

        default:
            ASSERT(ConnectionReady == 0);
            TransFreeBuffer(Buffer);
            ConnectionReady = 1;
            break;
        }

    if (EventStatus != RPC_S_OK)
        {
        VALIDATE(EventStatus)
            {
            RPC_P_SEND_FAILED,
            RPC_P_CONNECTION_CLOSED,
            RPC_P_CONNECTION_SHUTDOWN
            } END_VALIDATE;


        ConnectionAborted(RPC_S_CALL_FAILED_DNE);

        if (OldCall)
            {
            //
            // The current I/O failed.
            // Remove the send reference on the call, CCALL--
            //
            OldCall->RemoveReference();
            }
       }
}


void
OSF_CCONNECTION::ProcessReceiveComplete (
    IN RPC_STATUS EventStatus,
    IN BUFFER Buffer,
    IN UINT BufferLength
    )
/*++
Function Name:ProcessReceiveComplete

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;
    OSF_CCALL *CCall;
    BOOL fSubmitReceive;

    if (EventStatus)
        {
        LogEvent(SU_CCONN, EV_PKT_IN, this, LongToPtr(EventStatus));
        }
    else
        {
        rpcconn_common * pkt = (rpcconn_common *) Buffer;
        LogEvent(SU_CCONN, EV_PKT_IN, this, 0, (pkt->PTYPE << 16) | pkt->frag_length);
        }

    if (EventStatus != RPC_S_OK)
        {
        VALIDATE(EventStatus)
            {
            RPC_P_CONNECTION_CLOSED,
            RPC_P_RECEIVE_FAILED,
            RPC_P_CONNECTION_SHUTDOWN
            } END_VALIDATE;

        ASSERT(Buffer == 0);
        ConnectionAborted(RPC_S_CALL_FAILED);
        return;
        }

    ASSERT(Buffer);

    unsigned long CallId = ((rpcconn_common *) Buffer)->call_id;

    if (DataConvertEndian(((rpcconn_common *) Buffer)->drep) != 0)
        {
        CallId = RpcpByteSwapLong(CallId);
        }

    ConnMutex.Request();
    CCall = ActiveCalls.Find(IntToPtr(CallId));
    if (CCall)
        {
        if (CCall->CurrentState == Aborted)
            {
            ConnMutex.Clear();
            TransAbortConnection();
            return;
            }

        // CCALL++
        CCall->AddReference();
        ConnMutex.Clear();

        //
        // We try to create a thread. If it doesn't work,
        // well too bad !, we'll go ahead and process this
        // PDU any way
        //
        Status = Association->TransInfo->CreateThread();

        VALIDATE(Status)
            {
            RPC_S_OK,
            RPC_S_OUT_OF_MEMORY,
            RPC_S_OUT_OF_THREADS
            } END_VALIDATE;

        //
        // if fSubmitReceive is 1, we need to post a receive,
        // otherwise, the receive will be posted by someone else
        //
        fSubmitReceive = CCall->ProcessReceivedPDU(
                                                   (rpcconn_common *) Buffer,
                                                   BufferLength);

        ConnMutex.Request();
        CCall->RemoveReference(); // CCALL--
        ConnMutex.Clear();
        }
    else
        {
        ConnMutex.Clear();

        fSubmitReceive = 0;
        TransAbortConnection();
        }

    if (fSubmitReceive)
        {
        //
        // TransAsyncReceive will retry several times
        // before giving up
        //
        TransAsyncReceive ();
        }
}


RPC_STATUS
OSF_CCONNECTION::OpenConnectionAndBind (
    IN OSF_BINDING_HANDLE *BindingHandle,
    IN ULONG Timeout,
    IN BOOL fAlwaysNegotiateNDR20,
    OUT FAILURE_COUNT_STATE *fFailureCountExceeded OPTIONAL
    )
/*++
Function Name: OpenConnectionAndBind

Parameters:
    BindingHandle - the binding handle on which we are doing the call
    Timeout - the timeout for the bind (if any)
    fAlwaysNegotiateNDR20 - TRUE if NDR20 should always be negotiated.
        If the server chooses NDR64, we will explicitly alter-context
        to NDR20 if this flag is set.
    fFailureCountExceeded - if supplied, must be FailureCountUnknown. If
        supplied, and we got bind failure with reason not specified, and 
        we haven't exceeded the failure count, this function will keep
        retrying. If supplied, and we received bind failure with reason
        not specified and the failure count is exceeded, it will be set
        to FailureCountExceeded.

Description:

Returns:

--*/
{
    RPC_STATUS Status;
    BOOL fMutexHeld;
    ULONG MyAssocGroupId;
    MPX_TYPES myfMpx = Association->fMultiplex;
    ULONG MyfInitialized;
    void *MyHint = NULL;
    OSF_BINDING *BindingNegotiated;
    OSF_BINDING *IgnoredBinding;
    BOOL fPossibleAssociationReset;

    if (ARGUMENT_PRESENT(fFailureCountExceeded))
        {
        ASSERT(*fFailureCountExceeded == FailureCountUnknown);
        }

    if (!fExclusive)
        {
        //
        // First thing we do is kick off a thread to go and listen
        // this stuff is going to take very long
        //
        Status = Association->TransInfo->CreateThread();
        if (Status != RPC_S_OK)
            {
            //
            // Can't do anything right now, lets just go back and listen
            //
            return Status;
            }
        }

    while (1)
        {
        if (Association->IsResolverHintSynchronizationNeeded())
            {
            Association->AssociationMutex.Request();
            fMutexHeld = TRUE;
            }
        else
            fMutexHeld = FALSE;

        MyfInitialized = Association->AssocGroupId;

        if (MyfInitialized == 0)
            {
            // make sure the hint is allocated only once on the stack
            // otherwise, some of the retry paths will loop through here
            // and may contribute to a stack overflow
            if (MyHint == NULL)
                {
                MyHint = alloca(ClientInfo->ResolverHintSize);
                ASSERT((ClientInfo->ResolverHintSize == 0) || MyHint);
                }
            }
        else
            {
            MyHint = Association->InqResolverHint();
            }

        while (TRUE)
            {
            RpcpPurgeEEInfo();
            Status = TransOpen (
                        BindingHandle,
                        Association->DceBinding->InqRpcProtocolSequence(),
                        Association->DceBinding->InqNetworkAddress(),
                        Association->DceBinding->InqEndpoint(),
                        Association->DceBinding->InqNetworkOptions(),
                        MyHint,
                        MyfInitialized,
                        Timeout);
            if (Status != RPC_S_OK)
                {
                if (ComTimeout == RPC_C_BINDING_INFINITE_TIMEOUT
                    && (Status == RPC_S_SERVER_UNAVAILABLE
                        || Status == RPC_S_SERVER_TOO_BUSY))
                    {
                    continue;
                    }

                if (fMutexHeld)
                    {
                    Association->AssociationMutex.Clear();
                    fMutexHeld = FALSE;
                    }

                if (Status == RPC_S_SERVER_UNAVAILABLE)
                    {
                    Association->ShutdownRequested(Status, NULL);
                    }

                return Status;
                }

            if (fMutexHeld == FALSE)
                {
                Association->AssociationMutex.Request();
                fMutexHeld = TRUE;
                }

            MyAssocGroupId = Association->AssocGroupId;

            if (MyAssocGroupId != 0)
                {
                if (MyfInitialized == 0 && ClientInfo->ResolverHintSize)
                    {
                    //
                    // We lost the race, we need to check if the address
                    // we picked up is the same as the one the winner picked up
                    // if it is not, we need to loop back
                    //
                    if (Association->CompareResolverHint(MyHint))
                        {
                        if (Association->IsResolverHintSynchronizationNeeded() == FALSE)
                            {
                            // if the resolver does not require synchronization, loop
                            // around without the mutex
                            Association->AssociationMutex.Clear();
                            fMutexHeld = FALSE;
                            }

                        if (MyHint != Association->InqResolverHint())
                            Association->FreeResolverHint(MyHint);
                        MyfInitialized = 1;
                        MyHint = Association->InqResolverHint();
                        TransClose();
                        continue;
                        }
                    }

                Association->AssociationMutex.Clear();
                fMutexHeld = FALSE;

                if (MyHint != Association->InqResolverHint())
                    Association->FreeResolverHint(MyHint);
                }
            else
                {
                //
                // We won the race, we need to store the resolved address in
                // the association
                //
                if (ClientInfo->ResolverHintSize)
                    {
                    Association->SetResolverHint(MyHint);
                    Association->ResolverHintInitialized = TRUE;
                    }
                }
            break;
            } // while (1)


        TransInitComplete();

        //
        // Send a bind packet and wait for response
        //
        Status = ActuallyDoBinding (
                                CurrentCall,
                                MyAssocGroupId,
                                TRUE,       // fNewConnection
                                Timeout,
                                &BindingNegotiated,
                                &fPossibleAssociationReset,
                                fFailureCountExceeded);

        if (Status != RPC_S_OK)
            {

            if (fMutexHeld)
                {
                Association->AssociationMutex.Clear();
                fMutexHeld = FALSE;
                }

            LogEvent(SU_CCONN, EV_STATE, ULongToPtr(MyAssocGroupId), ULongToPtr(Association->AssocGroupId), Status, 1, 0);
            if ((Status == RPC_P_CONNECTION_SHUTDOWN)
                && 
                (
                 fPossibleAssociationReset
                 ||
                 (
                  ARGUMENT_PRESENT(fFailureCountExceeded)
                  &&
                  (*fFailureCountExceeded == FailureCountNotExceeded)
                 )
		        )
                &&
                (Association->IsValid())
               )
                {
                //
                // Either:
                // 1. We have hit a race condition where the
                // AssocGroupId is renegotiated because the
                // close for the last connection came ahead
                // of the bind for the next connection. In this
                // case server returns BindNak with 
                // reason_not_specified, which gets translated
                // to RPC_P_CONNECTION_SHUTDOWN. Retry again.
                // or
                // 2. We got bind_nak with reason not specified
                // and the failure count was not exceeded
                //

                TransClose();

                ASSERT(fMutexHeld == FALSE);

                Association->AssociationMutex.Request();
                if (fConnectionAborted == 0)
                    {
                    ASSERT(Association);
                    Association->NotifyConnectionClosed();
                    fConnectionAborted = 1;
                    }

                if (fPossibleAssociationReset)
                    Association->FailureCount = 0;

                InitializeWireAuthId(&ClientSecurityContext);

                if (ClientSecurityContext.AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE)
                    {
                    // DeleteSecurityContext checks and deletes 
                    // the security context only if necessary
                    ClientSecurityContext.DeleteSecurityContext();
                    }

                Association->AssociationMutex.Clear();

                if (ARGUMENT_PRESENT(fFailureCountExceeded))
                    {
                    *fFailureCountExceeded = FailureCountUnknown;
                    }

                continue;
                }

            if (fExclusive == 0
                && Status == RPC_S_PROTOCOL_ERROR
                && myfMpx == mpx_unknown)
                {
                Association->fMultiplex = mpx_no;
                //Association->MinorVersion = 0;

                //
                // The server seems to be a legacy server,
                // close the connection and start over,
                // this time, don't set the PFC_CONC_MPX bit
                //
                TransClose();

                ASSERT(fMutexHeld == FALSE);

                Association->AssociationMutex.Request();
                if (fConnectionAborted == 0)
                    {
                    ASSERT(Association);
                    Association->NotifyConnectionClosed();
                    fConnectionAborted = 1;
                    }
                InitializeWireAuthId(&ClientSecurityContext);

                if (ClientSecurityContext.AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE)
                    {
                    // DeleteSecurityContext checks and deletes 
                    // the security context only if necessary
                    ClientSecurityContext.DeleteSecurityContext();
                    }

                Association->AssociationMutex.Clear();
                continue;
                }
            return Status;
            }

        break;
        }

    // if we negotiated NDR64, but we were asked to negotiate NDR20,
    // alter context to get the right context for this call
    if (fAlwaysNegotiateNDR20 
        && (BindingNegotiated->CompareWithTransferSyntax(NDR64TransferSyntax) == 0))
        {
        // limit the choice to NDR20 only
        // We do this by whacking the list of available bindings. Since the chosen binding
        // is NDR20, this will force the bind to negotiate NDR20. We also change the state
        // to WaitingForAlterContext
        ASSERT(CurrentCall->Bindings.SelectedBinding->CompareWithTransferSyntax(NDR20TransferSyntax) == 0);
        CurrentCall->Bindings.AvailableBindingsList = NULL;

        CurrentCall->CurrentState = NeedAlterContext;

        Status = ActuallyDoBinding (
                                CurrentCall,
                                MyAssocGroupId,
                                FALSE,       // fNewConnection
                                Timeout,
                                &IgnoredBinding,
                                &fPossibleAssociationReset,      // never actually used here
                                NULL        // fFailureCountExceeded
                                );

        if (Status)
            {
            if (fMutexHeld)
                {
                Association->AssociationMutex.Clear();
                }
            return Status;
            }
        }

    if (fMutexHeld)
        {
        Association->AssociationMutex.Clear();
        }

    ASSERT((CurrentCall->CurrentState == NeedOpenAndBind)
           || (CurrentCall->CurrentState == NeedAlterContext)
           || (CurrentCall->CurrentState == Aborted));

    if ((CurrentCall == NULL) || (CurrentCall->CurrentState == Aborted))
        {
        TransAbortConnection();
        if ((CurrentCall != NULL) && (CurrentCall->GetCallStatus() == RPC_S_CALL_CANCELLED))
            {
            return RPC_S_CALL_CANCELLED;
            }
        else
            {
            return RPC_S_CALL_FAILED_DNE;
            }
        }

    CurrentCall->CurrentState = SendingFirstBuffer;

    if (!fExclusive)
        {
        Status = TransAsyncReceive();
        if (Status != RPC_S_OK)
            {
            return Status;
            }

        CurrentCall->CallMutex.Request();
        if (CurrentCall->CurrentBuffer == 0)
            {
            MakeConnectionIdle();
            CurrentCall->CallMutex.Clear();
            }
        else
            {
            ASSERT(IsIdle() == 0);
            CurrentCall->CallMutex.Clear();

            Status = CurrentCall->SendNextFragment();
            }
        }

    return Status ;
}


RPC_STATUS
OSF_CCONNECTION::ActuallyDoBinding (
    IN OSF_CCALL *CCall,
    IN ULONG MyAssocGroupId,
    IN BOOL fNewConnection,
    IN ULONG Timeout,
    OUT OSF_BINDING **BindingNegotiated,
    OUT BOOL *fPossibleAssociationReset,
    OUT FAILURE_COUNT_STATE *fFailureCountExceeded
    )
/*++
Function Name:ActuallyDoBinding

Parameters:
    fFailureCountExceeded - if supplied, must be FailureCountUnknown. If
        we got bind failure with reason not specified, and we haven't
        exceeded the failure count, it will be set to 
        FailureCountNotExceeded. If we received bind failure with reason
        not specified and the failure count is exceeded, it will be set
        to FailureCountExceeded.

Description:

Returns:

--*/
{
    RPC_STATUS Status;
    rpcconn_common * Buffer = 0;
    UINT BufferLength = 0;
    OSF_BINDING *Binding;

    if (ARGUMENT_PRESENT(fFailureCountExceeded))
        {
        ASSERT(*fFailureCountExceeded == FailureCountUnknown);
        }

    *fPossibleAssociationReset = FALSE;

    if ( fNewConnection != 0)
        {
        ASSERT(fConnectionAborted == 1);

        Association->AssociationMutex.Request();

        if ((MyAssocGroupId != 0) && (Association->AssocGroupId != MyAssocGroupId))
            {
            // if we are already reset, then the server connection may
            // be killed also. Just back out and retry
            LogEvent(SU_CASSOC, EV_STATE, (PVOID)55, (PVOID)55, 66, 1, 0);
            *fPossibleAssociationReset = TRUE;

            Association->FailureCount = 0;

            Association->AssociationMutex.Clear();

            return (RPC_P_CONNECTION_SHUTDOWN);
            }

        Association->NotifyConnectionBindInProgress();

        Association->AssociationMutex.Clear();
        }

    Status = SendBindPacket( TRUE,
                             CCall,
                             MyAssocGroupId,
                             (fNewConnection ? rpc_bind : rpc_alter_context),
                             Timeout,
                             FALSE,             // synchronous
                             &Buffer,
                             &BufferLength,
                             0,                 // no input buffer
                             0                  // no input buffer
                             );
    //
    // Now mark this connection as a part of the pool
    //
    if ( fNewConnection != 0)
        {
        Association->AssociationMutex.Request();

        if (Association->fPossibleServerReset)
            {
            LogEvent(SU_CASSOC, EV_STATE, (PVOID)77, (PVOID)77, 88, 1, 0);
            *fPossibleAssociationReset = TRUE;
            }

        //
        // Did we get aborted while we were trying to bind ?
        //
        if (ConnectionKey == -1)
            {

            Association->NotifyConnectionBindCompleted();

            TransAbortConnection();

            if (Status == RPC_S_OK)
                {
                TransFreeBuffer(Buffer);
                }

            Status = RPC_P_CONNECTION_SHUTDOWN;
            }
        else
            {
            if ((Status != RPC_S_OK) || ( Buffer->PTYPE != rpc_bind_nak ))
                {
                Association->NotifyConnectionOpen();
                fConnectionAborted = 0;
                }
            
            Association->NotifyConnectionBindCompleted();
            }

        Association->AssociationMutex.Clear();
        }

    if ( Status != RPC_S_OK )
        {
        VALIDATE(Status)
            {
            RPC_S_OUT_OF_MEMORY,
            RPC_S_OUT_OF_RESOURCES,
            RPC_P_CONNECTION_SHUTDOWN,
            RPC_P_CONNECTION_CLOSED,
            RPC_S_UUID_NO_ADDRESS,
            RPC_S_ACCESS_DENIED,
            RPC_S_SEC_PKG_ERROR,
            RPC_S_CALL_CANCELLED,
            RPC_P_TIMEOUT,
            ERROR_SHUTDOWN_IN_PROGRESS
            } END_VALIDATE;

        //
        // We'll let the call decide whether to nuke the connection
        //
        return(Status);
        }

    // We loop around ignoring shutdown packets until we get a response.

    for (;;)
        {
        if ( Buffer->PTYPE == rpc_shutdown )
            {
            Association->ShutdownRequested(RPC_S_CALL_FAILED_DNE, NULL);

            TransFreeBuffer(Buffer);

            Status = TransReceive((void **) &Buffer,
                &BufferLength,
                Timeout);

            if ( Status != RPC_S_OK )
                {
                VALIDATE(Status)
                    {
                    RPC_S_OUT_OF_MEMORY,
                    RPC_S_OUT_OF_RESOURCES,
                    RPC_P_RECEIVE_FAILED,
                    RPC_P_CONNECTION_CLOSED,
                    RPC_S_CALL_CANCELLED,
                    RPC_P_TIMEOUT
                    } END_VALIDATE;

                if ( Status == RPC_P_RECEIVE_FAILED )
                    {
                    return RPC_P_CONNECTION_CLOSED;
                    }
                return Status;
                }

            // If there is security, we need to save the packet header;
            // byte-swapping the header will mess up decryption.

            Status = ValidateHeader(Buffer, BufferLength);
            if ( Status != RPC_S_OK )
                {
                TransFreeBuffer(Buffer);
                return Status;
                }

            continue;
            }
        else if ( fNewConnection )
            {
            // Since this is a new connection, the packet we receive
            // must be either a bind_ack or a bind_nak; anything else
            // is an error.

            if (Buffer->PTYPE == rpc_bind_ack || Buffer->PTYPE == rpc_bind_nak)
                {
                break;
                }
            else
                {
                TransFreeBuffer(Buffer);
                return RPC_S_PROTOCOL_ERROR;
                }
            }
        else
            {
            // This is a preexisting connection.
            // We allow only an alter_context_response.

            if ( Buffer->PTYPE == rpc_alter_context_resp )
                {
                break;
                }
            else
                {
                TransFreeBuffer(Buffer);
                return RPC_S_PROTOCOL_ERROR;
                }
            }
        }

    ULONG NewGroupId;

    //
    // We subtract from BufferLength the length of the authentication
    // information; that way ProcessBindAckOrNak can check the length
    // correctly, whether or not there is security information.
    //
    if (MyAssocGroupId == 0)
        {
        Association->AssociationMutex.VerifyOwned();

        Status = Association->ProcessBindAckOrNak(
                                         Buffer,
                                         BufferLength - Buffer->auth_length,
                                         this,
                                         CCall,
                                         &NewGroupId,
                                         BindingNegotiated,
                                         fFailureCountExceeded);
        }
    else
        {
        Status = Association->AssociationMutex.RequestSafe();

        if (Status == RPC_S_OK)
            {
            Status = Association->ProcessBindAckOrNak(
                                             Buffer,
                                             BufferLength - Buffer->auth_length,
                                             this,
                                             CCall,
                                             &NewGroupId,
                                             BindingNegotiated,
                                             fFailureCountExceeded);

            Association->AssociationMutex.Clear();
            }
        }

    LogEvent(SU_CCONN, EV_STATE, ULongToPtr(MyAssocGroupId), ULongToPtr(Association->AssocGroupId), Status, 1, 0);

    if (fExclusive == 0
        && Association->fMultiplex == mpx_unknown)
        {
        if (((rpcconn_common *) Buffer)->pfc_flags & PFC_CONC_MPX)
            {
            Association->fMultiplex = mpx_yes;
            }
        else
            {
            Association->fMultiplex = mpx_no;
            }
        }

    if ( Status == RPC_S_OK )
        {
        Status = FinishSecurityContextSetup(
                             CCall,
                             MyAssocGroupId,
                             &Buffer,
                             &BufferLength,
                             Timeout
                             );
        }
    else
        {
        TransFreeBuffer(Buffer);
        }

    if ( Status == RPC_S_OK )
        {
        Binding = CCall->GetSelectedBinding();
        if (MyAssocGroupId == 0)
            {
            Association->AssociationMutex.VerifyOwned();

            if (AddPContext(Binding->GetPresentationContext()) != 0)
                {
                Status = RPC_S_OUT_OF_RESOURCES;
                }
            else
                {
                //
                // Once we reach here, we know that the binding has been accepted,
                // so we can go ahead and set the association group id.
                // warning: as soon as the AssocGroupId is set, threads
                // will start sending the bind without acquiring the mutex
                //
                LogEvent(SU_CASSOC, EV_NOTIFY, Association, this, NewGroupId, 1, 0);
                Association->AssocGroupId = NewGroupId;
                }
            }
        else
            {
            Status = Association->AssociationMutex.RequestSafe();
            if (Status == RPC_S_OK)
                {
                if (AddPContext(Binding->GetPresentationContext()) != 0)
                    {
                    Status = RPC_S_OUT_OF_RESOURCES;
                    }
                Association->AssociationMutex.Clear();
                }
            }

        if (fNewConnection)
            {
            Status = CCall->ReserveSpaceForSecurityIfNecessary();
            }
        }
    else
        {
        if (fNewConnection != 0)
            {
            //
            // If Status == DNE, it means that we probably got a B-NAK
            // [Also note this is a new connection]
            // If we were using security, [Auth Level != NONE]
            // delete this connection, and return RPC_P_CONNECTION_SHUTDOWN
            // which will cause BH->GetBuffer code to retry 2 more times
            //

            if (Status == RPC_S_CALL_FAILED_DNE)
               {
               //
               // Retry failures over non-authenticated
               // binds also.. the ones we retry over are bind naks with
               // unspecifed reason .. one day we can get OSF to send
               // bind_nk with reason assoc_group_shutdown..
               // && (CConnection->AuthInfo.AuthenticationLevel
               // != RPC_C_AUTHN_LEVEL_NONE))
               //
               Status = RPC_P_CONNECTION_SHUTDOWN;
               }
            }
        }

    return(Status);
}


RPC_STATUS
OSF_CCONNECTION::FinishSecurityContextSetup (
    IN OSF_CCALL *Call,
    IN unsigned long AssocGroup,
    IN OUT rpcconn_common * * Buffer,
    IN OUT unsigned int * BufferLength,
    IN ULONG Timeout
    )
{
    RPC_STATUS Status = RPC_S_OK;

    if (ClientSecurityContext.AuthenticationService == RPC_C_AUTHN_NONE
        || ClientSecurityContext.AuthenticationLevel == RPC_C_AUTHN_LEVEL_NONE)
        {
        TransFreeBuffer(*Buffer);
        return RPC_S_OK;
        }

    if ( !ClientSecurityContext.FullyConstructed() )
        {
        //
        // Some packages need more than one round trip; we keep sending secure
        // alter-context packets until the security context is fully set up.
        //
        do
            {
            rpcconn_common * InputBuffer = *Buffer;

            *Buffer = 0;

            Status = SendBindPacket(
                         FALSE,
                         Call,
                         AssocGroup,
                         rpc_alter_context,
                         Timeout,
                         FALSE,      // synchronous
                         Buffer,
                         BufferLength,
                         InputBuffer,
                         *BufferLength
                         );

            TransFreeBuffer(InputBuffer);
            }
        while (Status == RPC_S_OK && !ClientSecurityContext.FullyConstructed() );

        if (Status == RPC_S_OK && *Buffer)
            {
            TransFreeBuffer(*Buffer);
            }
        }
    else
        {
        TransFreeBuffer(*Buffer);
        }

    if (RPC_S_OK == Status)
        {
        // We need to figure out how much space to reserve for security
        // information at the end of request and response packets.
        // In addition to saving space for the signature or header,
        // we need space to pad the packet to a multiple of the maximum
        // security block size as well as for the security trailer.

        switch ( ClientSecurityContext.AuthenticationLevel )
            {

            case RPC_C_AUTHN_LEVEL_CONNECT:
            case RPC_C_AUTHN_LEVEL_PKT:
            case RPC_C_AUTHN_LEVEL_PKT_INTEGRITY:
                 AdditionalSpaceForSecurity = MAXIMUM_SECURITY_BLOCK_SIZE +
                     ClientSecurityContext.MaximumSignatureLength()
                    + sizeof(sec_trailer);
                 break;

            case RPC_C_AUTHN_LEVEL_PKT_PRIVACY:
                 AdditionalSpaceForSecurity = MAXIMUM_SECURITY_BLOCK_SIZE +
                    ClientSecurityContext.MaximumHeaderLength()
                    + sizeof(sec_trailer);
                 break;

            default:
                 ASSERT(!"Unknown Security Level\n");

            }
        }

    return Status;
}


RPC_STATUS
OSF_CCONNECTION::DealWithAlterContextResp (
    IN OSF_CCALL *CCall,
    IN rpcconn_common *Packet,
    IN int PacketLength,
    IN OUT BOOL *AlterContextToNDR20IfNDR64Negotiated
    )
/*++
Function Name:DealWithAlterContextResp

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;
    ULONG NewGroupId;
    BOOL fContextAddingFailed;
    OSF_BINDING *Binding;
    OSF_BINDING *NegotiatedBinding;

    Status = Association->AssociationMutex.RequestSafe();
    if (Status)
        return Status;

    Status = Association->ProcessBindAckOrNak(
                         Packet,
                         PacketLength - Packet->auth_length,
                         this,
                         CCall,
                         &NewGroupId,
                         &NegotiatedBinding,
                         NULL           // fFailureCountExceeded
                         );

    if ( Status != RPC_S_OK )
        {
        Association->AssociationMutex.Clear();
        }
    else
        {
        // the binding must have been fixed on the call by now
        Binding = CCall->GetSelectedBinding();
        ASSERT(Binding);

        fContextAddingFailed = AddPContext(Binding->GetPresentationContext());
        Association->AssociationMutex.Clear();
        if (fContextAddingFailed)
            return RPC_S_OUT_OF_MEMORY;

        if (*AlterContextToNDR20IfNDR64Negotiated)
            {
            if (NegotiatedBinding->CompareWithTransferSyntax(NDR64TransferSyntax) == 0)
                {
                ConnectionReady = 0;
                CCall->SendAlterContextPDU();
                }
            else
                {
                *AlterContextToNDR20IfNDR64Negotiated = FALSE;
                }
            }
        }

    return Status;
}


RPC_STATUS
OSF_CCONNECTION::SendBindPacket (
    IN BOOL fInitialPass,
    IN OSF_CCALL *Call,
    IN ULONG AssocGroup,
    IN unsigned char PacketType,
    IN ULONG Timeout,
    IN BOOL fAsync,
    OUT rpcconn_common * * Buffer,
    OUT UINT  * BufferLength,
    IN rpcconn_common * InputPacket,
    IN unsigned int InputPacketLength
    )
/*++

Routine Description:

    This routine is used to send a bind or alter context packet.  It
    will allocate a buffer, fill in the packet, and then send it and
    receive a reply.  The reply buffer is just returned to the caller.

Arguments:

    fInitialPass - true if this is the first bind packet sent for this
        connection

    Call - the call whose binding information we need to use in order
        to bind.

    AssocGroup - Supplies the association group id for the association
        group of which this connection is a new member.

    PacketType - Supplies the packet type which must be one of rpc_bind
        or rpc_alter_context.

    fAsync - the binding is async

    Buffer - Returns the reply buffer.

    BufferLength - Returns the length of the reply buffer.

    InputPacket - the packet received from a peer, if this is not
        the first leg of a security negotiation

    InputPacketLength - the length of the input packet

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete
        the operation.

    RPC_S_OUT_OF_RESOURCES - Insufficient resources are available to
        complete the operation.

    RPC_S_ACCESS_DENIED - The security package won't allow this.

    RPC_P_CONNECTION_CLOSED - The connection has been closed and the
        receive operation failed.  The send operation may or may not
        have succeeded.

--*/
{
    rpcconn_bind * BindPacket = 0;
    UINT BindPacketLength, AuthPadLength, SecurityTokenLength;
    RPC_STATUS Status;
    sec_trailer * SecurityTrailer;
    SECURITY_BUFFER_DESCRIPTOR BufferDescriptor;
    SECURITY_BUFFER SecurityBuffers[4];
    DCE_INIT_SECURITY_INFO InitSecurityInfo;
    UINT CompleteNeeded = 0;
    OSF_CCALL *CallToBindFor = Call;
    OSF_BINDING *BindingsAvailable;
    OSF_BINDING *CurrentBinding;
    BOOL fMultipleBindingsAvailable;
    int AvailableBindingsCount;

    ASSERT(CallToBindFor != 0);

    BindingsAvailable = CallToBindFor->GetListOfAvaialbleBindings(&fMultipleBindingsAvailable);

    if (fMultipleBindingsAvailable)
        {
        AvailableBindingsCount = 0;
        CurrentBinding = BindingsAvailable;
        do
            {
            AvailableBindingsCount ++;
            CurrentBinding = CurrentBinding->GetNextBinding();
            }
        while (CurrentBinding != 0);
        }
    else
        {
        AvailableBindingsCount = 1;
        }

    BindPacketLength = sizeof(rpcconn_bind) + sizeof(p_cont_list_t) +
            (AvailableBindingsCount - 1) * sizeof(p_cont_elem_t);

    //
    // If we need to send authentication information in the packet, we
    // need to save space for it.  This method prepares and sends both
    // rpc_bind and rpc_alter_context packets; we will only send
    // authentication information in rpc_bind packets.  This is due to
    // a design decision that each connection supports only a single
    // security context, which is determined when the connection is
    // created.
    //

    if (ClientSecurityContext.AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE
        && !ClientSecurityContext.FullyConstructed())
        {
        VALIDATE(ClientSecurityContext.AuthenticationLevel)
            {
            RPC_C_AUTHN_LEVEL_CONNECT,
            RPC_C_AUTHN_LEVEL_PKT,
            RPC_C_AUTHN_LEVEL_PKT_INTEGRITY,
            RPC_C_AUTHN_LEVEL_PKT_PRIVACY
            } END_VALIDATE;

        if (fInitialPass)
            {
            Status = UuidCreateSequential(&(DceSecurityInfo.AssociationUuid));
            if ((Status != RPC_S_OK )
                && (Status != RPC_S_UUID_LOCAL_ONLY))
                {
                return(Status);
                }
            }

        //
        // We align the packet length to a four byte boundary, and then
        // save space for the token and the sec_trailer.  We also need
        // to save the length of the token because we will need it later
        // if we do third leg authentication.
        //

        AuthPadLength = Pad4(BindPacketLength);
        BindPacketLength += AuthPadLength;
        TokenLength = ClientSecurityContext.Credentials->MaximumTokenLength();
        BindPacketLength += TokenLength + sizeof(sec_trailer);
        }

    Status = TransGetBuffer((void * *) &BindPacket,
                            BindPacketLength);
    if ( Status != RPC_S_OK )
        {
        ASSERT( Status == RPC_S_OUT_OF_MEMORY );
        TransFreeBuffer(BindPacket);
        return(RPC_S_OUT_OF_MEMORY);
        }

    ConstructPacket((rpcconn_common *) BindPacket, PacketType, BindPacketLength);

    //
    // A three-leg protocol will be sending an RPC_AUTH_3 instead of a BIND or ALTER_CONTEXT.
    // DCE Kerberos is the only package that uses the read-only output buffers.
    //

    BindPacket->max_xmit_frag
            = BindPacket->max_recv_frag
            = (unsigned short) TransMaximumSend();
    BindPacket->assoc_group_id = AssocGroup;
    BindPacket->common.call_id = CallToBindFor->CallId;
    BindPacket->common.pfc_flags =
        PFC_FIRST_FRAG | PFC_LAST_FRAG;

    if (fSeparateConnection == 0
        && fExclusive == 0
        && Association->fMultiplex != mpx_no)
        {
        //
        // We don't want to set PFC_CONC_MPX for all the requests
        // because the legacy NT server will send a protocol error fault
        // and nuke the connection
        //
        BindPacket->common.pfc_flags |= PFC_CONC_MPX;
        }

    ConstructPContextList((p_cont_list_t *) (BindPacket + 1),
                          BindingsAvailable,
                          AvailableBindingsCount);

    //
    // If this connection is using security, we need to stick the
    // authentication information into the packet.
    //

    if ( ClientSecurityContext.AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE
         && !ClientSecurityContext.FullyConstructed() )
        {
        InitSecurityInfo.DceSecurityInfo      = DceSecurityInfo;
        InitSecurityInfo.AuthorizationService = ClientSecurityContext.AuthorizationService;
        InitSecurityInfo.PacketType           = PacketType;

        BufferDescriptor.ulVersion = 0;
        BufferDescriptor.cBuffers = 4;
        BufferDescriptor.pBuffers = SecurityBuffers;

        SecurityBuffers[3].BufferType = SECBUFFER_PKG_PARAMS | SECBUFFER_READONLY;
        SecurityBuffers[3].pvBuffer   = &InitSecurityInfo;
        SecurityBuffers[3].cbBuffer   = sizeof(DCE_INIT_SECURITY_INFO);

        if (fInitialPass)
            {
            AdditionalLegNeeded = 0;

            SecurityBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
            SecurityBuffers[0].pvBuffer   = BindPacket;
            SecurityBuffers[0].cbBuffer   = sizeof(rpcconn_bind);

            SecurityBuffers[1].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
            SecurityBuffers[1].pvBuffer   = ((unsigned char  *) BindPacket)
                                          + sizeof(rpcconn_bind);
            SecurityBuffers[1].cbBuffer   = BindPacketLength
                                          - sizeof(rpcconn_bind)
                                          - ClientSecurityContext.Credentials->MaximumTokenLength();

            SecurityBuffers[2].BufferType = SECBUFFER_TOKEN;
            SecurityBuffers[2].pvBuffer   = ((unsigned char  *) BindPacket)
                                          + BindPacketLength
                                          - ClientSecurityContext.Credentials->MaximumTokenLength();
            SecurityBuffers[2].cbBuffer   = ClientSecurityContext.Credentials->MaximumTokenLength();

            Status = ClientSecurityContext.InitializeFirstTime(
                                           ClientSecurityContext.Credentials,
                                           ClientSecurityContext.ServerPrincipalName,
                                           ClientSecurityContext.AuthenticationLevel,
                                           &BufferDescriptor,
                                           &WireAuthId);

            LogEvent(SU_CCONN, EV_SEC_INIT1, this, LongToPtr(Status), SecurityBuffers[2].cbBuffer);
            }
        else
            {
            if (ClientSecurityContext.Legs == ThreeLegs)
                {
                BindPacket->common.PTYPE = rpc_auth_3;

                SecurityBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
                SecurityBuffers[0].pvBuffer   = BindPacket;
                SecurityBuffers[0].cbBuffer   = sizeof(rpcconn_auth3);

                SecurityBuffers[1].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
                SecurityBuffers[1].pvBuffer   = ((unsigned char  *) BindPacket)
                                              + sizeof(rpcconn_auth3);
                SecurityBuffers[1].cbBuffer   = sizeof(sec_trailer);

                SecurityBuffers[2].BufferType = SECBUFFER_TOKEN;
                SecurityBuffers[2].pvBuffer   = ((unsigned char  *) BindPacket)
                                              + sizeof(rpcconn_auth3)
                                              + sizeof(sec_trailer);
                SecurityBuffers[2].cbBuffer   = TokenLength;

                //
                // These structures are already 4-aligned, so no padding is needed.
                //
                BindPacketLength = sizeof(rpcconn_auth3) + sizeof(sec_trailer) + TokenLength;
                }
            else
                {
                SecurityBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
                SecurityBuffers[0].pvBuffer   = BindPacket;
                SecurityBuffers[0].cbBuffer   = sizeof(rpcconn_bind);

                SecurityBuffers[1].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
                SecurityBuffers[1].pvBuffer   = ((unsigned char  *) BindPacket)
                                              + sizeof(rpcconn_bind);
                SecurityBuffers[1].cbBuffer   = BindPacketLength
                                              - sizeof(rpcconn_bind)
                                              - TokenLength;

                SecurityBuffers[2].BufferType = SECBUFFER_TOKEN;
                SecurityBuffers[2].pvBuffer   = ((unsigned char  *) BindPacket)
                                              + BindPacketLength
                                              - TokenLength;
                SecurityBuffers[2].cbBuffer   = TokenLength;
                }

           //
           // a third leg auth may not be needed with some packages
           // on an alter context [where only pcon is changed as opposed
           // to an alternative client principal]
           //
           AdditionalLegNeeded = 0;

           if (InputPacket)
               {
               SECURITY_BUFFER_DESCRIPTOR InputBufferDescriptor;
               SECURITY_BUFFER            InputBuffers[4];
               DCE_INIT_SECURITY_INFO     InputSecurityInfo;

               InputSecurityInfo.DceSecurityInfo      = DceSecurityInfo;
               InputSecurityInfo.AuthorizationService = ClientSecurityContext.AuthorizationService;
               InputSecurityInfo.PacketType           = InputPacket->PTYPE;

               InputBufferDescriptor.ulVersion = 0;
               InputBufferDescriptor.cBuffers = 4;
               InputBufferDescriptor.pBuffers = InputBuffers;

               ASSERT((SavedHeader != 0) && (SavedHeaderSize != 0));

               InputBuffers[0].cbBuffer   = sizeof(rpcconn_bind_ack) - sizeof(unsigned short);
               InputBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
               InputBuffers[0].pvBuffer   = SavedHeader;

               InputBuffers[1].cbBuffer   = InputPacketLength
                                          - (sizeof(rpcconn_bind_ack) - sizeof(unsigned short))
                                          - InputPacket->auth_length;
               InputBuffers[1].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
               InputBuffers[1].pvBuffer   = ((unsigned char *) SavedHeader)
                                          + sizeof(rpcconn_bind_ack) - sizeof(unsigned short);

               InputBuffers[2].cbBuffer   = InputPacket->auth_length;
               InputBuffers[2].BufferType = SECBUFFER_TOKEN;
               InputBuffers[2].pvBuffer   = ((unsigned char *) InputPacket) + InputPacketLength - InputPacket->auth_length;

               InputBuffers[3].cbBuffer   = sizeof(DCE_INIT_SECURITY_INFO);
               InputBuffers[3].BufferType = SECBUFFER_PKG_PARAMS | SECBUFFER_READONLY;
               InputBuffers[3].pvBuffer   = &InputSecurityInfo;

               Status = ClientSecurityContext.InitializeThirdLeg(
                          ClientSecurityContext.Credentials,
                          *((unsigned long *) &(BindPacket->common.drep[0])),
                          &InputBufferDescriptor,
                          &BufferDescriptor
                          );

               }
           else
               {
               Status = ClientSecurityContext.InitializeThirdLeg(
                          ClientSecurityContext.Credentials,
                          *((unsigned long *) &(BindPacket->common.drep[0])),
                          0,
                          &BufferDescriptor
                          );
               }

           LogEvent(SU_CCONN, EV_SEC_INIT3, this, LongToPtr(Status), SecurityBuffers[2].cbBuffer);
           }

        //
        // The security package has encrypted or signed the data.
        //

        if ( Status == RPC_P_CONTINUE_NEEDED )
            {
            //
            // Remember the fact that the security package requested that
            // it be called again.  This will be important later: see
            // OSF_CASSOCIATION::ActuallyDoBinding.
            //

            AdditionalLegNeeded = 1;
            }
        else if ( Status == RPC_P_COMPLETE_NEEDED )
            {
            CompleteNeeded = 1;
            }
        else if ( Status == RPC_P_COMPLETE_AND_CONTINUE )
            {
            AdditionalLegNeeded = 1;
            CompleteNeeded = 1;
            }
        else if ( Status != RPC_S_OK )
            {
            VALIDATE(Status)
                {
                RPC_S_OUT_OF_MEMORY,
                RPC_S_ACCESS_DENIED,
                RPC_S_SEC_PKG_ERROR,
                RPC_S_UNKNOWN_AUTHN_SERVICE,
                RPC_S_INVALID_ARG,
                ERROR_SHUTDOWN_IN_PROGRESS
                } END_VALIDATE;

            TransFreeBuffer(BindPacket);
            return(Status);
            }

        //
        // The Snego package can behave either as a 3- or 4-leg protocol depending
        // upon the server. It knows which way to go after the first call to
        // InitializeSecurityContext().
        //
        if (fInitialPass && AdditionalLegNeeded)
            {
            ClientSecurityContext.Legs = GetPackageLegCount( WireAuthId );
            if (ClientSecurityContext.Legs == LegsUnknown)
                {
                TransFreeBuffer(BindPacket);
                return RPC_S_OUT_OF_MEMORY;
                }
            }

        //
        // In NT 4.0 and before, the length was considered a read-only field.
        //
        SecurityTokenLength = (UINT) SecurityBuffers[2].cbBuffer;

        if (!AdditionalLegNeeded &&
            0 == SecurityTokenLength)
            {
            //
            // No more packets to send.
            //
            TransFreeBuffer(BindPacket);
            return RPC_S_OK;
            }

        //
        // We need to fill in the fields of the security trailer.
        //
        SecurityTrailer = (sec_trailer *)
                (((unsigned char  *) BindPacket)
                + BindPacketLength
                - ClientSecurityContext.Credentials->MaximumTokenLength()
                - sizeof(sec_trailer));

        SecurityTrailer->auth_type = WireAuthId;
        SecurityTrailer->auth_level = (unsigned char) ClientSecurityContext.AuthenticationLevel;
        SecurityTrailer->auth_pad_length = (unsigned char) AuthPadLength;
        SecurityTrailer->auth_reserved = 0;
        SecurityTrailer->auth_context_id = PtrToUlong(this);

        //
        // Ok, finally, we need to adjust the length of the packet,
        // and set the length of the authentication information.
        //

        BindPacket->common.auth_length = (unsigned short) SecurityTokenLength;
        BindPacketLength = BindPacketLength
                - ClientSecurityContext.Credentials->MaximumTokenLength()
                + SecurityTokenLength;
        BindPacket->common.frag_length = (unsigned short) BindPacketLength;

        if ( CompleteNeeded != 0 )
            {
            Status = ClientSecurityContext.CompleteSecurityToken(
                    &BufferDescriptor);
            if (Status != 0)
                {
                TransFreeBuffer(BindPacket);
                return(Status);
                }
            }
        }

    if (fAsync)
        {
        Status = TransAsyncSend(BindPacket,
                                BindPacketLength,
                                u.ConnSendContext);
        }
    else if (BindPacket->common.PTYPE == rpc_auth_3)
        {
        Status = TransSend(BindPacket,
                           BindPacketLength,
                           TRUE,    // fDisableShutdownCheck
                           FALSE,   // fDisableCancelCheck
                           Timeout
                           );
        //
        // Null out the reply buffer, because there is none !
        //
        *Buffer = NULL;
        }
    else
        {
        Status = TransSendReceive(BindPacket,
                                  BindPacketLength,
                                  (void * *) Buffer,
                                  BufferLength,
                                  Timeout);
        }

    if ( Status != RPC_S_OK )
        {
        VALIDATE(Status)
            {
            RPC_S_OUT_OF_MEMORY,
            RPC_S_ACCESS_DENIED,
            RPC_S_OUT_OF_RESOURCES,
            RPC_P_CONNECTION_CLOSED,
            RPC_P_RECEIVE_FAILED,
            RPC_P_SEND_FAILED,
            RPC_P_CONNECTION_SHUTDOWN,
            RPC_S_CALL_CANCELLED,
            RPC_P_TIMEOUT
            } END_VALIDATE;

        TransFreeBuffer(BindPacket);
        if ((Status == RPC_P_RECEIVE_FAILED)
            || (Status == RPC_P_SEND_FAILED))
            {
            return(RPC_P_CONNECTION_CLOSED);
            }

        return(Status);
        }
    else
        {
        ClearFreshFromCacheFlag();
        if (fAsync == 0)
            {
            switch (BindPacket->common.PTYPE)
                {
                case rpc_auth_3:
                    // don't have a new packet
                    break;

                case rpc_fault:
                    Status = ValidatePacket(*Buffer, *BufferLength);
                    if (Status == RPC_S_OK)
                        {
                        Status = ((rpcconn_fault *) *Buffer)->status;
                        }
                    break;

                default:
                    Status = ValidateHeader(*Buffer, *BufferLength);
                }

            TransFreeBuffer(BindPacket);
            }
        }

    return Status;
}


void
OSF_CCONNECTION::SetMaxFrag (
    IN unsigned short max_xmit_frag,
    IN unsigned short max_recv_frag
    )
{
    UNUSED(max_recv_frag);

    unsigned TranMax = TransMaximumSend();

    MaxFrag = max_xmit_frag;

    if (MaxFrag > TranMax || MaxFrag == 0)
        {
        MaxFrag = (unsigned short) TranMax;
        }

#ifndef WIN
    ASSERT( MaxFrag >= MUST_RECV_FRAG_SIZE );
#endif // WIN
}


RPC_STATUS
OSF_CCONNECTION::SendFragment(
    IN rpcconn_common  *pFragment,
    IN OSF_CCALL *CCall,
    IN UINT LastFragmentFlag,
    IN UINT HeaderSize,
    IN UINT MaxSecuritySize,
    IN UINT DataLength,
    IN UINT MaxFragmentLength,
    IN unsigned char  *ReservedForSecurity,
    IN BOOL fAsync,
    IN void *SendContext,
    IN ULONG Timeout,
    OUT void **ReceiveBuffer,
    OUT UINT *ReceiveBufferLength
    )
/*++
    Routine Description:

    Sends on fragment
--*/

{
    sec_trailer  * SecurityTrailer;
    UINT SecurityLength;
    UINT AuthPadLength;
    SECURITY_BUFFER_DESCRIPTOR BufferDescriptor;
    SECURITY_BUFFER SecurityBuffers[5];
    DCE_MSG_SECURITY_INFO MsgSecurityInfo;
    RPC_STATUS Status;

    if (ClientSecurityContext.AuthenticationLevel == RPC_C_AUTHN_LEVEL_NONE
        || (ClientSecurityContext.AuthenticationLevel == RPC_C_AUTHN_LEVEL_CONNECT
            && MaxSecuritySize == 0))
        {
        SecurityLength = 0;
        if (LastFragmentFlag != 0)
            {
            pFragment->pfc_flags |= PFC_LAST_FRAG;
            }
        }
    else
        {
        VALIDATE(ClientSecurityContext.AuthenticationLevel)
            {
            RPC_C_AUTHN_LEVEL_PKT_INTEGRITY,
            RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
            RPC_C_AUTHN_LEVEL_PKT,
            RPC_C_AUTHN_LEVEL_CONNECT
            } END_VALIDATE;

        if ( LastFragmentFlag == 0 )
            {
            SecurityTrailer = (sec_trailer  *)
                (((unsigned char  *) pFragment)
                + MaxFragmentLength - MaxSecuritySize);

            //
            // It is not the last fragment, so we need to save away the
            // part of the buffer which could get overwritten with
            // authentication information.  We can not use memcpy,
            // because the source and destination regions may overlap.
            //
            RpcpMemoryMove(ReservedForSecurity,
                       SecurityTrailer,
                       MaxSecuritySize);
            AuthPadLength = 0;
            }
        else
            {
            ASSERT( MAXIMUM_SECURITY_BLOCK_SIZE == 16 );
            AuthPadLength = Pad16(HeaderSize+DataLength+sizeof(sec_trailer));
            DataLength += AuthPadLength;
            ASSERT( ((HeaderSize+DataLength+sizeof(sec_trailer))
                        % MAXIMUM_SECURITY_BLOCK_SIZE) == 0 );
            SecurityTrailer = (sec_trailer  *)
                (((unsigned char  *) pFragment)
                + DataLength + HeaderSize);

            pFragment->pfc_flags |= PFC_LAST_FRAG;
            }

        SecurityTrailer->auth_type = (unsigned char) WireAuthId;
        SecurityTrailer->auth_level = (unsigned char) ClientSecurityContext.AuthenticationLevel;
        SecurityTrailer->auth_pad_length = (unsigned char) AuthPadLength;
        SecurityTrailer->auth_reserved = 0;
        SecurityTrailer->auth_context_id = PtrToUlong(this);

        BufferDescriptor.ulVersion = 0;
        BufferDescriptor.cBuffers = 5;
        BufferDescriptor.pBuffers = SecurityBuffers;

        SecurityBuffers[0].cbBuffer = HeaderSize;
        SecurityBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        SecurityBuffers[0].pvBuffer = ((unsigned char  *) pFragment);

        SecurityBuffers[1].cbBuffer = (LastFragmentFlag != 0 ?
             (DataLength)
            : (MaxFragmentLength - HeaderSize - MaxSecuritySize)
            );
        SecurityBuffers[1].BufferType = SECBUFFER_DATA;
        SecurityBuffers[1].pvBuffer = ((unsigned char  *) pFragment)
            + HeaderSize;

        SecurityBuffers[2].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        SecurityBuffers[2].cbBuffer = sizeof(sec_trailer);
        SecurityBuffers[2].pvBuffer = SecurityTrailer;

        SecurityBuffers[3].cbBuffer = MaxSecuritySize - sizeof(sec_trailer);
        SecurityBuffers[3].BufferType = SECBUFFER_TOKEN;
        SecurityBuffers[3].pvBuffer = SecurityTrailer + 1;

        SecurityBuffers[4].cbBuffer = sizeof(DCE_MSG_SECURITY_INFO);
        SecurityBuffers[4].BufferType = (SECBUFFER_PKG_PARAMS
            | SECBUFFER_READONLY);
        SecurityBuffers[4].pvBuffer = &MsgSecurityInfo;

        MsgSecurityInfo.SendSequenceNumber =
            DceSecurityInfo.SendSequenceNumber;
        MsgSecurityInfo.ReceiveSequenceNumber =
            InquireReceiveSequenceNumber();
        MsgSecurityInfo.PacketType = pFragment->PTYPE;

        //
        // DCE computes check sums for Header also
        // Make sure Header remains intact
        // Infact may need to extend security interface if
        // some packages return dynamic size seals/signatures
        //

        pFragment->auth_length = SecurityLength = (unsigned short)
                                         SecurityBuffers[3].cbBuffer;

        SecurityLength += sizeof(sec_trailer);
        if ( LastFragmentFlag != 0)
            {
            pFragment->pfc_flags |= PFC_LAST_FRAG;
            pFragment->frag_length = HeaderSize + DataLength
                + SecurityLength;
            }
        else
            {
            pFragment->frag_length += SecurityLength - MaxSecuritySize;
            }

        Status = ClientSecurityContext.SignOrSeal(
                                    MsgSecurityInfo.SendSequenceNumber,
                                    ClientSecurityContext.AuthenticationLevel
                                    != RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                    &BufferDescriptor);

        //
        // The fragment may have been checksumed. Do not touch the fragment
        // after this (including the header), if you do it will cause a checksum error
        //

        ASSERT(SecurityBuffers[3].cbBuffer <= pFragment->auth_length);

        if (Status != RPC_S_OK)
            {
            if ( LastFragmentFlag == 0 )
                {
                RpcpMemoryCopy(SecurityTrailer,
                             ReservedForSecurity,
                             MaxSecuritySize);
                }
            if (Status == ERROR_SHUTDOWN_IN_PROGRESS)
                {
                return Status;
                }

            if ((Status == SEC_E_CONTEXT_EXPIRED)
                || (Status == SEC_E_QOP_NOT_SUPPORTED))
                {
                return (RPC_S_SEC_PKG_ERROR);
                }
            return (RPC_S_ACCESS_DENIED);
            }
        }

    if (LastFragmentFlag != 0)
        {
        ASSERT(!RpcpCheckHeap());

        if (fAsync)
            {
            Status = TransAsyncSend(pFragment,
                                    pFragment->frag_length,
                                    SendContext);
            }
        else
            {
            if (ReceiveBuffer)
                {
                Status = TransSendReceive(pFragment,
                                          pFragment->frag_length,
                                          ReceiveBuffer,
                                          ReceiveBufferLength,
                                          Timeout);
                }
            else
                {
                Status = TransSend(pFragment,
                                   pFragment->frag_length,
                                   FALSE,   // fDisableShutdownCheck
                                   FALSE,   // fDisableCancelCheck
                                   Timeout);
                }
            }

        if (Status != RPC_S_OK)
            {
            if ((Status == RPC_P_CONNECTION_CLOSED)
                || (Status == RPC_P_SEND_FAILED))
                {
                return(RPC_S_CALL_FAILED_DNE);
                }
            if (Status == RPC_P_RECEIVE_FAILED)
                {
                return(RPC_S_CALL_FAILED);
                }
            if (Status == RPC_P_TIMEOUT)
                {
                RpcpErrorAddRecord(EEInfoGCRuntime,
                    RPC_S_CALL_CANCELLED,
                    EEInfoDLOSF_CCONNECTION__SendFragment10,
                    (ULONG)Status,
                    (ULONG)Timeout);

                return(RPC_S_CALL_CANCELLED);
                }

            VALIDATE(Status)
                {
                RPC_S_OUT_OF_MEMORY,
                RPC_S_OUT_OF_RESOURCES,
                RPC_P_CONNECTION_SHUTDOWN,
                RPC_S_CALL_CANCELLED
                } END_VALIDATE;

            return(Status);
            }

        ClearFreshFromCacheFlag();
        return(RPC_S_OK);
        }

    if (fAsync)
        {
        Status = TransAsyncSend(pFragment,
                                pFragment->frag_length,
                                CCall->CallSendContext);
        }
    else
        {
        Status = TransSend(pFragment,
                           pFragment->frag_length,
                           FALSE,   // fDisableShutdownCheck
                           FALSE,   // fDisableCancelCheck
                           Timeout);

        //
        // We need to restore the part of the buffer which we overwrote
        // with authentication information.
        //
        if ((ClientSecurityContext.AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE)
            && (ClientSecurityContext.AuthenticationLevel != RPC_C_AUTHN_LEVEL_CONNECT
                || (MaxSecuritySize != 0)))
            {
            //
            // if MaxSecuritySize == 0, there will be no copying,
            // so its OK to not check for it.
            //
            VALIDATE(ClientSecurityContext.AuthenticationLevel)
                {
                RPC_C_AUTHN_LEVEL_PKT_INTEGRITY,
                RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                RPC_C_AUTHN_LEVEL_PKT,
                RPC_C_AUTHN_LEVEL_CONNECT
                } END_VALIDATE;

            RpcpMemoryCopy(SecurityTrailer, ReservedForSecurity,
                           MaxSecuritySize);
            }

        if (ReceiveBuffer
            && Status == RPC_P_RECEIVE_COMPLETE)
            {
            // we're going to do a receive - whack any eeinfo
            // on the thread that the WS_CheckForShutdowns has
            // added
            RpcpPurgeEEInfo();

            Status = TransReceive(ReceiveBuffer, 
                ReceiveBufferLength,
                Timeout);
            }
        }

    if ( Status != RPC_S_OK )
        {
        if ((Status == RPC_P_CONNECTION_CLOSED)
            || (Status == RPC_P_SEND_FAILED))
            {
            return(RPC_S_CALL_FAILED_DNE);
            }

        if (Status == RPC_P_TIMEOUT)
            {
            RpcpErrorAddRecord(EEInfoGCRuntime,
                RPC_S_CALL_CANCELLED,
                EEInfoDLOSF_CCONNECTION__SendFragment20,
                (ULONG)Status,
                (ULONG)Timeout);
            return RPC_S_CALL_CANCELLED;
            }

        VALIDATE(Status)
            {
            RPC_S_OUT_OF_MEMORY,
            RPC_S_OUT_OF_RESOURCES,
            RPC_P_CONNECTION_SHUTDOWN,
            RPC_S_CALL_CANCELLED,
            RPC_P_RECEIVE_FAILED  
            } END_VALIDATE;

        return(Status);
        }

    ClearFreshFromCacheFlag();
    return Status;
}



inline int
OSF_CCONNECTION::SupportedAuthInfo (
    IN CLIENT_AUTH_INFO * ClientAuthInfo,
    IN BOOL fNamedPipe
    )
/*++

Arguments:

    ClientAuthInfo - Supplies the authentication and authorization information
        required of this connection.  A value of zero (the pointer is
        zero) indicates that we want an unauthenticated connection.

Return Value:

    Non-zero indicates that the connection has the requested authentication
    and authorization information; otherwise, zero will be returned.

--*/
{
    return (ClientSecurityContext.IsSupportedAuthInfo(ClientAuthInfo, fNamedPipe));
}


RPC_STATUS
OSF_CCONNECTION::AddActiveCall (
    IN ULONG CallId,
    IN OSF_CCALL *CCall
    )
/*++
Function Name:AddActiveCall

Parameters:

Description:

Returns:

--*/
{
    int retval;

    ConnMutex.Request();
    if (State == ConnAborted)
        {
        ConnMutex.Clear();
        return RPC_S_CALL_FAILED;
        }

    retval = ActiveCalls.Insert(IntToPtr(CallId), CCall);
    ConnMutex.Clear();

    if (retval == -1)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    return RPC_S_OK;
}


RPC_STATUS
OSF_CCONNECTION::CallCancelled (
    OUT PDWORD Timeout
    )
/*++
Function Name:CallCancelled

Parameters:

Description:
    This function is called by the transport interface when it notices that it has
    received an altert. This routine is called via I_RpcIOAlerted

Returns:

--*/
{
    if (fExclusive == 0 || CurrentCall == 0)
        {
        return RPC_S_NO_CALL_ACTIVE;
        }
    ASSERT(fExclusive && CurrentCall);

    //
    // Even if we get alerted in the bind path, we already have a call object.
    // That makes it easy for us to track cancels
    //

    return CurrentCall->CallCancelled(Timeout);
}

MTSyntaxBinding *CreateOsfBinding(
        IN RPC_SYNTAX_IDENTIFIER *InterfaceId,
        IN TRANSFER_SYNTAX_STUB_INFO *TransferSyntaxInfo,
        IN int CapabilitiesBitmap
        )
{
    return new OSF_BINDING(InterfaceId, 
        TransferSyntaxInfo, 
        CapabilitiesBitmap);
}

extern "C" RPC_IF_HANDLE _mgmt_ClientIfHandle;


OSF_CCALL::OSF_CCALL (
    RPC_STATUS __RPC_FAR * pStatus
    ) : CallMutex(pStatus),
      SyncEvent(pStatus, 0),
      fAdvanceCallCount(0)
{
    LogEvent(SU_CCALL, EV_CREATE, this);

    ObjectType = OSF_CCALL_TYPE;
    ReservedForSecurity = 0;
    SecBufferLength = 0;
    SavedHeaderSize = 0;
    SavedHeader = 0;
    InReply = 0;
    EEInfo = NULL;
    CachedAPCInfoAvailable = 1;
#ifdef DEBUGRPC
    CallbackLevel = 0;
#endif

    CallSendContext = (char *) this+sizeof(OSF_CCALL)+sizeof(PVOID);
    *((PVOID *) ((char *) CallSendContext - sizeof(PVOID))) = (PVOID) this;
}


OSF_CCALL::~OSF_CCALL (
    )
{
    LogEvent(SU_CCALL, EV_DELETE, this);

    if (CachedAPCInfoAvailable == 0)
        {
        ASSERT(!"Can't destroy call with queued APCs on it");
        }

    if (ReservedForSecurity)
        {
        RpcpFarFree(ReservedForSecurity);
        }

    if (SavedHeader)
        {
        RpcpFarFree(SavedHeader);
        }

    Connection->NotifyCallDeleted();
}

RPC_STATUS OSF_CCALL::ReserveSpaceForSecurityIfNecessary (void)
{
    SECURITY_CONTEXT *ClientSecurityContext ;

    ClientSecurityContext = &(Connection->ClientSecurityContext);
    //
    // We need to figure out about security: do we need to put authentication
    // information into each packet, and if so, how much space should we
    // reserve. So that we have space to save the contents of the buffer
    // which will be overwritten with authentication information (for all but
    // the last fragment).
    //
    if (ClientSecurityContext->AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE)
        {
        VALIDATE(ClientSecurityContext->AuthenticationLevel)
            {
            RPC_C_AUTHN_LEVEL_PKT_INTEGRITY,
            RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
            RPC_C_AUTHN_LEVEL_CONNECT,
            RPC_C_AUTHN_LEVEL_PKT
            } END_VALIDATE;

        MaxSecuritySize = Connection->AdditionalSpaceForSecurity
                - MAXIMUM_SECURITY_BLOCK_SIZE;

        if (MaxSecuritySize < sizeof(sec_trailer))
            {
            ASSERT(MaxSecuritySize >= sizeof(sec_trailer));
            return(RPC_S_INTERNAL_ERROR);
            }

        if (MaxSecuritySize == sizeof(sec_trailer))
            {
            if (ClientSecurityContext->AuthenticationLevel
                != RPC_C_AUTHN_LEVEL_CONNECT)
                {
                ASSERT(0);
                return(RPC_S_INTERNAL_ERROR);
                }

            MaxSecuritySize = 0;
            }
        else
            {
            if (SecBufferLength < Connection->AdditionalSpaceForSecurity)
                {
                if (ReservedForSecurity)
                    {
                    RpcpFarFree(ReservedForSecurity);
                    }

                ReservedForSecurity = (unsigned char *)
                    RpcpFarAllocate(Connection->AdditionalSpaceForSecurity);
                if (ReservedForSecurity == 0)
                    {
                    SecBufferLength = 0;
                    return RPC_S_OUT_OF_MEMORY;
                    }
                SecBufferLength = Connection->AdditionalSpaceForSecurity;
                }

            }
        }

    // if the header size has already been determined, update the frag length
    // if not, we'll let the GetBuffer thread do it. Also, there is a small
    // race condition where we may update it twice, but since this is perf
    // only, we don't care - in the common case the gains are huge when we
    // don't have to update
    if (HeaderSize != 0)
        UpdateMaxFragLength(ClientSecurityContext->AuthenticationLevel);
    fDataLengthNegotiated = TRUE;

    return RPC_S_OK;
}


void OSF_CCALL::UpdateObjectUUIDInfo (IN UUID *ObjectUuid)
{
    UUID *ObjectUuidToUse;
    ULONG AuthnLevel;

    //
    // Do the initial setup
    //
    if (ObjectUuid)
        {
        ObjectUuidToUse = ObjectUuid;
        }
    else if (BindingHandle->InqIfNullObjectUuid() == 0)
        {
        ObjectUuidToUse = BindingHandle->InqPointerAtObjectUuid();
        }
    else
        {
        ObjectUuidToUse = 0;
        UuidSpecified = 0;
        HeaderSize = sizeof(rpcconn_request);
        }

    if (ObjectUuidToUse)
        {
        UuidSpecified = 1;
        HeaderSize = sizeof(rpcconn_request) + sizeof(UUID);
        RpcpMemoryCopy(&this->ObjectUuid, ObjectUuidToUse, sizeof(UUID));
        }

    AuthnLevel = Connection->ClientSecurityContext.AuthenticationLevel;
    // recalc if either there is no security size or if it is ready
    if ((MaxSecuritySize != 0) || (AuthnLevel == RPC_C_AUTHN_LEVEL_NONE))
        {
        UpdateMaxFragLength(AuthnLevel);
        }
}

void OSF_CCALL::UpdateMaxFragLength (ULONG AuthnLevel)
{
    BOOL fExclusive = Connection->fExclusive;

    // if the connection is exclusive, this all happens on the same thread -
    // no need for a mutex
    if (!fExclusive)
        CallMutex.Request();

    MaximumFragmentLength = Connection->MaxFrag;

    if (AuthnLevel != RPC_C_AUTHN_LEVEL_NONE)
        {
        MaximumFragmentLength -= ((MaximumFragmentLength
                                  - HeaderSize - MaxSecuritySize)
                                  % MAXIMUM_SECURITY_BLOCK_SIZE);
        }

    MaxDataLength = MaximumFragmentLength
        - HeaderSize - MaxSecuritySize;

    if (!fExclusive)
        CallMutex.Clear();
}


BOOL
OSF_CCALL::IssueNotification (
    IN RPC_ASYNC_EVENT Event
    )
{
    BOOL fRes;
    RPC_STATUS Status;

    if (pAsync == 0)
        {
        if (Connection->fExclusive == 0)
            {
            SyncEvent.Raise();
            }

        return 0;
        }

    // we must have bailed out by now if this is sync
    ASSERT (pAsync);

    fRes = CCALL::IssueNotificationEntry(Event);

    if (!fRes)
        return 0;

    if (AsyncStatus == RPC_S_OK)
        {
        RPC_SECURITY_CALLBACK_FN *SecurityCallback = NULL;

        Status = BindingHandle->InqTransportOption(
                                                   RPC_C_OPT_SECURITY_CALLBACK,
                                                   (ULONG_PTR *) &SecurityCallback);
        ASSERT(Status == RPC_S_OK);

        if (SecurityCallback)
            {
            (*SecurityCallback) (this);
            }
        }

    return CCALL::IssueNotificationMain(Event);
}

const int MAX_ASYNC_RETRIES = 3;


RPC_STATUS
OSF_CCALL::BindToServer (
    BOOL fAsyncBind
    )
/*++
Function Name:BindToServer

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;
    OSF_BINDING_HANDLE *pLocalBindingHandle = BindingHandle;
    OSF_CCONNECTION *pLocalConnection;
    ULONG Timeout;
    BOOL fBindingHandleTimeoutUsed = TRUE;
    BOOL fAlwaysNegotiateNDR20 = FALSE;
    OSF_BINDING *IgnoredBinding;
    ULONG LocalAssociationGroupId;
    BOOL Ignored;
    FAILURE_COUNT_STATE fFailureCountExceeded = FailureCountUnknown;
    int AsyncRetries = 0;

    if (EEInfo)
        {
        FreeEEInfoChain(EEInfo);
        EEInfo = NULL;
        }

    if (fAsyncBind == FALSE)
        {
        //
        // We party on the call even after the connection is aborted.
        // We need to keep a reference on the call
        // CCALL++
        // We do this only in the sync case, as in the async,
        // the reference has already been added for us by the caller
        //
        AddReference();
        }
    else
        {
        ASSERT(Connection->fExclusive == FALSE);

        // if this is a new, non-exclusive conn
        if (pLocalBindingHandle && (CurrentState == NeedOpenAndBind))
            {

            // if we have had no preferences at the time of
            // establishment (which is signified by the fact that both
            // SelectedBinding and AvalableBindingsList is set)
            if (Bindings.SelectedBinding && Bindings.AvailableBindingsList)
                {
                fAlwaysNegotiateNDR20 = TRUE;
                }
            }
        }

    Connection->CurrentCall = this;

    if (pLocalBindingHandle)
        {

        Timeout = GetEffectiveTimeoutForBind(pLocalBindingHandle, &fBindingHandleTimeoutUsed);

        do
            {
            switch (CurrentState)
                {
                case NeedOpenAndBind:
                    Status = Connection->OpenConnectionAndBind(
                        pLocalBindingHandle,
                        Timeout,
                        fAlwaysNegotiateNDR20,
                        &fFailureCountExceeded);
                    break;

                case NeedAlterContext:
                    if (Connection->fExclusive)
                        {
                        LocalAssociationGroupId = Connection->Association->AssocGroupId;
                        if (LocalAssociationGroupId)
                            {
                            Status = Connection->ActuallyDoBinding(
                                       this,
                                       Connection->Association->AssocGroupId,
                                       0,
                                       Timeout,
                                       &IgnoredBinding,
                                       &Ignored,     // fPossibleAssociationReset
                                       NULL          // fFailureCountExceeded
                                       );
                            if (Status == RPC_S_OK)
                                {
                                CurrentState = SendingFirstBuffer;
                                }
                            }
                        else
                            Status = RPC_S_CALL_FAILED_DNE;
                        }
                    else
                        {
                        Status = SendAlterContextPDU();
                        }
                    break;

                default:
#if DBG
                    PrintToDebugger("RPC: BindToServer was a nop, CurrentState: %d\n",
                                    CurrentState);
#endif
                    Status = RPC_S_OK;
                    break;
                }

            if (fAsyncBind)
                {
                ASSERT(fFailureCountExceeded != FailureCountNotExceeded);

                // if this is a bind_nak with reason not specified, and retry
                // attempts exhausted, shutdown the association, but without this
                // connection, and then retry the OpenConnectionAndBind
                if (
                    (fFailureCountExceeded == FailureCountExceeded)
                    &&
                    (CurrentState == NeedOpenAndBind)
                   )
                    {
                    Connection->Association->ShutdownRequested(RPC_S_OK, Connection);

                    // do some cleanup work on the current connection to avoid
                    // leaks.
                    Connection->TransClose();

                    Connection->InitializeWireAuthId(&Connection->ClientSecurityContext);

                    if (Connection->ClientSecurityContext.AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE)
                        {
                        // DeleteSecurityContext checks and deletes 
                        // the security context only if necessary
                        Connection->ClientSecurityContext.DeleteSecurityContext();
                        }

                    fFailureCountExceeded = FailureCountUnknown;
                    AsyncRetries ++;

                    // retry the bind
                    continue;
                    }

                pLocalBindingHandle->BindingFree();
                }

            // all paths except those with explicit continue exit the loop
            break;
            }
        while (AsyncRetries <= MAX_ASYNC_RETRIES);

        }
    else
        Status = RPC_S_CALL_FAILED_DNE;

    // save the data member in a local variable
    pLocalConnection = Connection;
    if (Status != RPC_S_OK)
        {
        if (pLocalBindingHandle)
            {
            Status = GetStatusForTimeout(
                pLocalBindingHandle,
                Status,
                fBindingHandleTimeoutUsed);
            }

        if (Connection->fExclusive == 0)
            {
            if (Status == RPC_P_CONNECTION_CLOSED
                || Status == RPC_P_CONNECTION_SHUTDOWN
                || Status == RPC_P_SEND_FAILED)
                {
                Status = RPC_S_CALL_FAILED_DNE;
                }

            Connection->ConnectionAborted(Status, 0);

            //
            // Remove the send reference for this call, CCALL--
            //
            RemoveReference();
            }
        }

    //
    // Remove the reference we added above
    // CCALL--
    //
    RemoveReference();

    if (fAsyncBind)
        pLocalConnection->RemoveReference();

    return Status;
}



RPC_STATUS
OSF_CCALL::ActuallyAllocateBuffer (
    OUT void  *  * Buffer,
    IN UINT BufferLength
    )
/*++

Routine Description:

    We need a buffer to receive data into or to put data into to be sent.
    This should be really simple, but we need to make sure that buffer we
    return is aligned on an 8 byte boundary.  The stubs make this requirement.

Arguments:

    Buffer - Returns a pointer to the buffer.

    BufferLength - Supplies the required length of the buffer in bytes.

Return Value:

    RPC_S_OK - We successfully allocated a buffer of at least the required
        size.

    RPC_S_OUT_OF_MEMORY - There is insufficient memory available to allocate
        the required buffer.

--*/
{
    return Connection->TransGetBuffer(Buffer, BufferLength);
}


void
OSF_CCALL::ActuallyFreeBuffer (
    IN void  * Buffer
    )
/*++

Routine Description:

    We need to free a buffer which was allocated via TransGetBuffer.  The
    only tricky part is remembering to remove the padding before actually
    freeing the memory.

--*/
{
    Connection->TransFreeBuffer(Buffer);
}


RPC_STATUS
OSF_CCALL::ActivateCall (
    IN OSF_BINDING_HANDLE *BindingHandle,
    IN OSF_BINDING *Binding,
    IN OSF_BINDING *AvailableBindingsList,
    IN ULONG CallIdToUse,
    IN OSF_CCALL_STATE InitialCallState,
    IN PRPC_DISPATCH_TABLE DispatchTable,
    IN OSF_CCONNECTION *CConnection
    )
/*++
Function Name:ActivateCall

Parameters:

Description:
    Only Binding or AvailableBindingsList can be used, but not both

Returns:

--*/
{
    RPC_STATUS Status = RPC_S_OK;

    ASSERT(BufferQueue.IsQueueEmpty());
    MaxSecuritySize = 0;
    MaxDataLength = 0;
    Connection = CConnection;
    this->BindingHandle = BindingHandle;
    CurrentBuffer = 0;
    CurrentOffset = 0;
    CurrentState = InitialCallState;
    CallStack = 0;
    RcvBufferLength = 0;
    pAsync = 0;
    NeededLength = 0;
    MaximumFragmentLength = 0;
    LastBuffer = NULL;
    RecursiveCallsKey = -1;
    fDataLengthNegotiated = FALSE;

    if (Binding)
        {
        // we can have both binding and binding list only for non-sync
        // calls
        ASSERT((AvailableBindingsList == NULL) || (Connection->fExclusive == FALSE));
        }
    else
        {
        // if we don't have a binding, this must be a sync call.
        // Async calls must have their bindings fixed by now
        ASSERT(Connection->fExclusive);
        }

    Bindings.SelectedBinding = Binding;
    Bindings.AvailableBindingsList = AvailableBindingsList;

    this->DispatchTableCallback = DispatchTable;
    CallId = CallIdToUse;
    fCallCancelled = FALSE;
    CancelState = CANCEL_NOTREGISTERED;
    AdditionalSpaceForSecurity = Connection->AdditionalSpaceForSecurity;
    fPeerChoked = 0;
    fDoFlowControl = 0;

    HeaderSize = 0;

    if (Connection->fExclusive == 0)
        {
        //
        // 1. The first reference is removed when
        //    all the sends are complete. This is called the send reference
        //    CCALL++
        // 2. The second one is removed when the client is done with the call,
        //     ie: when freebuffer is called or when an operation fails. This is called
        //     the call reference. CCALL++
        //
        SetReferenceCount(2);

        fAdvanceCallCount.SetInteger(0);
        AsyncStatus = RPC_S_ASYNC_CALL_PENDING ;
        FirstSend = 1;
        NotificationIssued = -1;
        fChoked = 0;
        fLastSendComplete = 0;

        CallingThread = ThreadSelf();
        if (CallingThread == 0)
            {
            //
            // If the thread pointer should have been initialized in
            // GetBuffer.
            return RPC_S_INTERNAL_ERROR;
            }

        Status = Connection->AddActiveCall(
                                       CallIdToUse,
                                       this);
        }
    else
        {
        CallingThread = 0;
        }

    return Status;
}


RPC_STATUS
OSF_CCALL::SendHelper (
    IN PRPC_MESSAGE Message,
    OUT BOOL *fFirstSend
    )
/*++
Function Name:Send

Parameters:
    Message - Contains information about the request

Description:

Returns:

--*/
{
    void  *NewBuffer;
    int RemainingLength = 0;
    RPC_STATUS Status = RPC_S_OK;
    BOOL fRegisterFailed = 0;

    ASSERT(HeaderSize != 0);

    *fFirstSend = 0;

    if (PARTIAL(Message))
        {
        if (fDataLengthNegotiated == 0
            || Message->BufferLength < MaxDataLength)
            {
            if (pAsync && (pAsync->Flags & RPC_C_NOTIFY_ON_SEND_COMPLETE))
                {
                if (!IssueNotification(RpcSendComplete))
                    {
                    CallFailed(Status);

                    // this is async only. We don't need to unregister for cancels
                    return Status;
                    }
                }

            return (RPC_S_SEND_INCOMPLETE);
            }

        ASSERT(MaxDataLength);

        RemainingLength = Message->BufferLength % MaxDataLength;

        if (RemainingLength)
            {
            Status = GetBufferDo(RemainingLength, &NewBuffer);

            if (Status != RPC_S_OK)
                {
                CallFailed(Status);

                UnregisterCallForCancels();

                return Status;
                }

            Message->BufferLength -= RemainingLength;
            RpcpMemoryCopy(NewBuffer,
                           (char *) Message->Buffer + Message->BufferLength,
                           RemainingLength);
            }
        }
    else
        {
        ASSERT(LastBuffer == NULL);
        LastBuffer = Message->Buffer;
        }

    //
    // Add a reference for this send, CCALL++
    //
    AddReference();

    //
    // You get to actually send only if you are the CurrentCall
    // and the connection is idle.
    //
Retry:
    if (AsyncStatus != RPC_S_ASYNC_CALL_PENDING)
        {
        Status = AsyncStatus;

        ASSERT(Status != RPC_S_OK);
        if (Status == RPC_S_CALL_FAILED_DNE)
            {
            Status = RPC_S_CALL_FAILED;
            }

        // N.B. The connection that does the bind will have
        // its send reference removed in case of failure, and
        // will be the current call. Therefore, we remove
        // the reference only if we aren't the current call
        if (Connection->CurrentCall != this)
            {
            //
            // We didn't get a chance to submit a new send
            // Remove the send reference CCALL--
            //
            OSF_CCALL::RemoveReference();
            }

        goto Cleanup;
        }

    CallMutex.Request();
    if (CurrentBuffer)
        {
        //
        // If the call had failed, we will find out after the we return
        // from this routine
        //
        if (pAsync == 0 && BufferQueue.Size() >= 4)
            {
            fChoked = 1;
            CallMutex.Clear();

            SyncEvent.Wait();
            goto Retry;
            }

        //
        // Since CurrentBuffer != 0, the connection could not have been
        // in a quiscent state. Therefore, we don't need to tickle it. This
        // also means that the call is currently in the call queue of the connection.
        // So, we don't need to add ourselves to the call queue.
        //
        if (BufferQueue.PutOnQueue(Message->Buffer, Message->BufferLength))
            {
            Status = RPC_S_OUT_OF_MEMORY;
            if (Connection->CurrentCall != this)
                {
                //
                // We didn't get a chance to submit a new send
                // Remove the send reference CCALL--
                //
                OSF_CCALL::RemoveReference();
                }
            }
        CallMutex.Clear();
        }
    else
        {
        CurrentOffset = 0;
        CurrentBuffer = Message->Buffer;
        CurrentBufferLength = Message->BufferLength;

        if (FirstSend)
            {
            FirstSend = 0;
            CallStack++;
            CallMutex.Clear();

            Status = RegisterCallForCancels();
            if (Status != RPC_S_OK)
                {
                fRegisterFailed = 1;

                if (Connection->CurrentCall != this)
                    {
                    //
                    // We didn't get a chance to submit a new send
                    // Remove the send reference CCALL--
                    //
                    OSF_CCALL::RemoveReference();
                    }

                goto Cleanup;
                }

            Status = Connection->AddCall(this);

            *fFirstSend = 1;

            if (Status != RPC_S_OK)
                {

                if (Connection->CurrentCall != this)
                    {
                    //
                    // We didn't get a chance to submit a new send
                    // Remove the send reference CCALL--
                    //
                    OSF_CCALL::RemoveReference();
                    }

                goto Cleanup;
                }
            }
        else
            {
            CallMutex.Clear();
            }

        //
        // The connection could be in a quiescent state
        // we need to tickle it
        //
        Connection->ConnMutex.Request();
        if (CurrentState == Complete)
            {
            Connection->ConnMutex.Clear();
            // Status should already be RPC_S_OK
            ASSERT(Status == RPC_S_OK);
            goto Cleanup;
            }
        if (Connection->CurrentCall == this
            && Connection->IsIdle())
            {
            Connection->MakeConnectionActive();
            if ((Connection->fExclusive == FALSE)
                && (BindingHandle->InqComTimeout() != RPC_C_BINDING_INFINITE_TIMEOUT))
                {
                // this is a best effort - ignore failure
                (void)Connection->TurnOnOffKeepAlives(TRUE,   // turn on
                    BindingHandle->InqComTimeout()
                    );
                }
            Connection->ConnMutex.Clear();

            Status = SendData(0);
            if (Status != RPC_S_OK)
                {
                //
                // We didn't get a chance to submit a new send
                // Remove the send reference CCALL--
                //
                OSF_CCALL::RemoveReference();
                }
            }
        else
            {
            Connection->ConnMutex.Clear();
            }
        }

Cleanup:

    if (Status)
        {
        ASSERT(Status != RPC_S_SEND_INCOMPLETE);

        if (RemainingLength)
            {
            //
            // NewBuffer should be initialized
            //
            FreeBufferDo(NewBuffer);
            }

        AsyncStatus = Status;
        if (!fRegisterFailed)
            {
            UnregisterCallForCancels();
            }
        }
    else
        {
        if (RemainingLength)
            {
            Message->Buffer = NewBuffer;
            Message->BufferLength = RemainingLength;
            ActualBufferLength = RemainingLength;

            Status = RPC_S_SEND_INCOMPLETE;
            }
        else
            {
            ActualBufferLength = 0;
            Message->Buffer = 0;
            Message->BufferLength = 0;
            }

        //
        // Call reference is removed in FreeBuffer
        //
        }

    //
    // Remove the reference for this send we added above, CCALL--
    //
    OSF_CCALL::RemoveReference();

    return Status;
}


RPC_STATUS
OSF_CCALL::Send (
    IN PRPC_MESSAGE Message
    )
{
    int i;
    BOOL fFirstSend;
    void *TempBuffer;
    RPC_STATUS Status;
    PRPC_ASYNC_STATE MypAsync = this->pAsync;
    OSF_BINDING_HANDLE *MyBindingHandle = this->BindingHandle;

    //
    // WARNING: Do not use any members of OSF_CCALL beyond this point.
    // the object could have been deleted.
    //
    for (i = 0;;i++)
        {
        Status = ((OSF_CCALL *) Message->Handle)->SendHelper(Message, &fFirstSend);

        if (Status == RPC_S_OK)
            {
            if (!PARTIAL(Message) && MypAsync)
                {
                //
                // Last send
                //
                ((OSF_CCALL *) Message->Handle)->CallMutex.Request();
                ASSERT(((OSF_CCALL *) Message->Handle)->fLastSendComplete == 0);

                if (((OSF_CCALL *) Message->Handle)->CurrentState == Aborted)
                    {
                    Status = ((OSF_CCALL *) Message->Handle)->GetCallStatus();

                    ((OSF_CCALL *) Message->Handle)->CallMutex.Clear();

                    //
                    // Remove the call reference, CCALL--
                    //
                    ((OSF_CCALL *) Message->Handle)->RemoveReference();

                    //
                    // No need to free the send buffer, it will be freed when the
                    // send is complete
                    //
                    }
                else
                    {
                    //
                    // For any future failures, a notification is issued
                    //
                    ((OSF_CCALL *) Message->Handle)->fLastSendComplete = 1;
                    ((OSF_CCALL *) Message->Handle)->CallMutex.Clear();
                    }
                }

            return Status;
            }

        if (Status != RPC_S_CALL_FAILED_DNE || i > 0 || fFirstSend == 0)
            {
            if (Status != RPC_S_SEND_INCOMPLETE)
                {
                ((OSF_CCALL *) Message->Handle)->FreeBufferDo(Message->Buffer);

                //
                // Remove the call reference, CCALL--
                //
                ((OSF_CCALL *) Message->Handle)->RemoveReference();
                }

            return Status;
            }


        Status = AutoRetryCall(Message,
                                FALSE, // not in SendReceive path
                                MyBindingHandle,
                                Status,
                                MypAsync);
        if (Status != RPC_S_OK)
            break;
        }

    return Status;
}

RPC_STATUS 
OSF_CCALL::AutoRetryCall (
    IN OUT RPC_MESSAGE *Message, 
    IN BOOL fSendReceivePath,
    IN OSF_BINDING_HANDLE *LocalBindingHandle, 
    IN RPC_STATUS CurrentStatus,
    IN RPC_ASYNC_STATE *AsyncState OPTIONAL
    )
/*++
Function Name:AutoRetryCall

Parameters:
    Message - Contains information about the request
    fSendReceivePath - TRUE if this is the send receive path, FALSE if it is the
        Send path. We need to differentiate, because we do the cleanup of the old
        call in slightly different ways
    LocalBindingHandle - a local copy of the binding handle that was used to
        make the original call
    AsyncState - a pointer to the async state of the original call (if any)

Description:
    Retries the current call. If the buffer is large, we allocate the new
    call first, and copy the contents of the buffers directly. Otherwise,
    we allocate the new call first, and then we copy directly from the old
    call buffer to the new call buffer. This saves on double copying in the
    large buffer case.

Returns:

--*/
{
    void *TempBuffer;
    RPC_STATUS Status;
    UUID MyUuid;
    UUID *UuidToUse;
    BOOL fUuidSpecified;
    OSF_CCALL *OldCall;
    BOOL fLargeBuffer;

    // any failure after this is unrelated
    RpcpPurgeEEInfo();

    OldCall = (OSF_CCALL *) Message->Handle;
    // if the buffer is larger than 128K (absolutely arbitrary value),
    // we'd rather open a new connection, than copy the buffer twice
    fLargeBuffer = Message->BufferLength > (1 << 17);

    ASSERT(OldCall->HeaderSize != 0);
    fUuidSpecified = OldCall->UuidSpecified;

    if (fUuidSpecified)
        {
        RpcpMemoryCopy(&MyUuid,
                       &(OldCall->ObjectUuid), sizeof(UUID));
        }

    if (fLargeBuffer)
        {
        TempBuffer = Message->Buffer;
        }
    else
        {
        TempBuffer = RpcpFarAllocate(Message->BufferLength);
        if (TempBuffer != 0)
            RpcpMemoryCopy(TempBuffer, Message->Buffer, Message->BufferLength);

        OldCall->CleanupOldCallOnAutoRetry(Message->Buffer, fSendReceivePath, CurrentStatus);

        if (TempBuffer == 0)
            {
            return RPC_S_OUT_OF_MEMORY;
            }
        }

    Message->Handle = LocalBindingHandle;

    UuidToUse = fUuidSpecified ? &MyUuid : 0;

    Status = NegotiateTransferSyntaxAndGetBuffer(Message, UuidToUse);

    if (Status != RPC_S_OK)
        {
        // the transfer syntax should not change in the async path for now - this
        // indicates application error, and it's better to ASSERT here in checked
        // builds, than leave the app writer bewildered on what has gone wrong if
        // we just spew the error code back
        if (!fSendReceivePath)
            {
            ASSERT(Status != RPC_P_TRANSFER_SYNTAX_CHANGED);
            }

        if (fLargeBuffer)
            OldCall->CleanupOldCallOnAutoRetry(TempBuffer, fSendReceivePath, CurrentStatus);
        else
            RpcpFarFree(TempBuffer);
        return Status;
        }

    if (AsyncState)
        {
        Status = I_RpcAsyncSetHandle(Message, AsyncState);
        if (Status != RPC_S_OK)
            {
            if (fLargeBuffer)
                OldCall->CleanupOldCallOnAutoRetry(TempBuffer, fSendReceivePath, CurrentStatus);
            else
                RpcpFarFree(TempBuffer);
            return Status;
            }
        }

    RpcpMemoryCopy(Message->Buffer, TempBuffer, Message->BufferLength);
    if (fLargeBuffer)
        OldCall->CleanupOldCallOnAutoRetry(TempBuffer, fSendReceivePath, CurrentStatus);
    else
        RpcpFarFree(TempBuffer);

    return RPC_S_OK;
}


RPC_STATUS
OSF_CCALL::AsyncSend (
    IN PRPC_MESSAGE Message
    )
/*++
Function Name:AsyncSend

Parameters:
    Message - Contains information about the request.

Description:
    This function is used in conjunction with Async RPC. This function may
    be used to send regular requests as well as pipe requests.

Returns:

--*/
{
    return Send(Message);
}


RPC_STATUS
OSF_CCALL::Receive (
    IN OUT PRPC_MESSAGE Message,
    IN UINT Size
    )
/*++
Function Name:Receive

Parameters:

Description:
    This function is used in conjunction with synchronous pipes. It is used to receive
    partial pipe data. If the RPC_BUFFER_EXTRA flag is set, the pipe data is
    appended to the end of the current buffer. If it is not set, the pipe data is copied
    from starting from the beginning of the buffer.

Returns:

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    unsigned long OldFlags = IsExtraMessage(Message);

    ASSERT(pAsync == 0);

    if (!EXTRA(Message) && Message->Buffer)
        {
        ActuallyFreeBuffer((char  *)Message->Buffer-sizeof(rpcconn_request));
        Message->Buffer = 0;
        }


    while (TRUE)
        {
        switch (CurrentState)
            {
            case Complete:
                Status = GetCoalescedBuffer(Message);
                break;

            case Aborted:
                ASSERT(AsyncStatus != RPC_S_OK);
                Status = AsyncStatus;
                break;

            default:
                if (RcvBufferLength >= Connection->MaxFrag)
                    {
                    Status = GetCoalescedBuffer(Message);
                    if (Status != RPC_S_OK)
                        {
                        break;
                        }

                    if (PARTIAL(Message) && Message->BufferLength >= Size)
                        {
                        break;
                        }

                    Message->RpcFlags |= RPC_BUFFER_EXTRA;
                    }
                else
                    {
                    //
                    // the call is not yet complete, wait for it.
                    //
                    SyncEvent.Wait();
                    }
                continue;
            }
        break;
        }

    Message->DataRepresentation = Connection->Association->SavedDrep;
    Message->RpcFlags &= ~(RPC_BUFFER_EXTRA);
    Message->RpcFlags |= OldFlags;

    if (Status != RPC_S_OK)
        {
        UnregisterCallForCancels();
        AsyncStatus = Status;

        // Remove the call reference, CCALL--
        OSF_CCALL::RemoveReference();
        }

    return Status;
}


RPC_STATUS
OSF_CCALL::GetCoalescedBuffer (
    IN PRPC_MESSAGE Message
    )
/*++
Function Name:GetCoalescedBuffer

Parameters:
    Message - the message structure that will receive the params

Description:
    This routine will coalesce the buffers in the buffer queue into a single
    buffer and return it in the Message structure. If the RPC_BUFFER_EXTRA
    flag is set, the data is appended to the existing buffer in Message->Buffer.

Returns:
    RPC_S_OK - the function was successful in doing its job
    RPC_S_OUT_OF_MEMORY - ran out of memory.
--*/
{
    char *Current;
    PVOID NewBuffer, Buffer;
    UINT bufferlength;
    UINT TotalLength;
    int Extra = IsExtraMessage(Message);
    RPC_STATUS Status;
    BOOL fSubmitReceive = 0;

    CallMutex.Request();
    if (RcvBufferLength == 0)
        {
        CallMutex.Clear();
        if (!Extra)
            {
            ASSERT(CurrentState == Complete);
            Message->Buffer = BufferQueue.TakeOffQueue(&bufferlength);

            ASSERT(Message->Buffer);
            ASSERT(bufferlength == 0);

            Message->BufferLength = 0;
            Message->RpcFlags |= RPC_BUFFER_COMPLETE;
            CallStack--;
            }
        return RPC_S_OK;
        }

    if (Extra)
        {
        TotalLength = RcvBufferLength + Message->BufferLength;
        }
    else
        {
        TotalLength = RcvBufferLength;
        }

    Status = Connection->TransGetBuffer (
                                         &NewBuffer,
                                         TotalLength+sizeof(rpcconn_request));
    if (Status != RPC_S_OK)
        {
        CallMutex.Clear();
        return RPC_S_OUT_OF_MEMORY;
        }

    NewBuffer = (char *) NewBuffer+sizeof(rpcconn_request);

    if (Extra && Message->Buffer)
        {
        RpcpMemoryCopy(NewBuffer, Message->Buffer, Message->BufferLength);
        Current = (char *) NewBuffer + Message->BufferLength;

        Connection->TransFreeBuffer(
                                    (char *) Message->Buffer
                                    -sizeof(rpcconn_request));
        }
    else
        {
        Current = (char *) NewBuffer;
        }

    while ((Buffer = BufferQueue.TakeOffQueue(&bufferlength)) != 0)
        {
        RpcpMemoryCopy(Current, Buffer, bufferlength);
        Current += bufferlength;

        Connection->TransFreeBuffer(
                                    (char *) Buffer
                                    -sizeof(rpcconn_request));
        }

    if (fPeerChoked)
        {
        fSubmitReceive = 1;
        fPeerChoked = 0;
        }

    Message->Buffer = NewBuffer;
    Message->BufferLength = TotalLength;

    if (CurrentState == Complete)
        {
        Message->RpcFlags |= RPC_BUFFER_COMPLETE;
        CallStack--;
        }

    RcvBufferLength = 0;
    CallMutex.Clear();

    if (fSubmitReceive)
        {
        Connection->TransAsyncReceive();
        }

    return RPC_S_OK;
}


RPC_STATUS
OSF_CCALL::AsyncReceive (
    IN OUT PRPC_MESSAGE Message,
    IN UINT Size
    )
/*++
Function Name:AsyncReceive

Parameters:
    Message - Contains information about the call
    Size - This field is ignored on the client.

Description:
    This is API is used to receive the non-pipe data in an async call. It this
    function is called before the call is actually complete, an
    RPC_S_ASYNC_CALL_PENDING is returned.

Returns:

--*/
{
    RPC_STATUS Status;

    if (!EXTRA(Message) && Message->Buffer)
        {
        ActuallyFreeBuffer((char  *)Message->Buffer-sizeof(rpcconn_request));
        Message->Buffer = 0;
        Message->BufferLength = 0;
        }

    while (TRUE)
        {
        switch (CurrentState)
            {
            case Complete:
                Status = GetCoalescedBuffer(Message);
                break;

            case Aborted:
                Status = AsyncStatus;
                break;

            default:
                if (PARTIAL(Message))
                    {
                    fDoFlowControl = 1;

                    CallMutex.Request();
                    if (RcvBufferLength < Size)
                        {
                        if (NOTIFY(Message))
                            {
                            NeededLength = Size;
                            }
                        CallMutex.Clear();

                        return RPC_S_ASYNC_CALL_PENDING;
                        }
                    else
                        {
                        Status = GetCoalescedBuffer(Message);
                        }
                    CallMutex.Clear();
                    }
                else
                    {
                    return RPC_S_ASYNC_CALL_PENDING;
                    }
                break;
            }
        break;
        }

    Message->DataRepresentation = Connection->Association->SavedDrep;

    if (Status != RPC_S_OK)
        {
        //
        // FreeBuffer is not going to be called. Cleanup now..
        //
        AsyncStatus = Status;

        // remove the call reference, CCALL--
        OSF_CCALL::RemoveReference();
        }

    return Status;
}


RPC_STATUS
OSF_CCALL::ReceiveReply (
    IN rpcconn_request *Request,
    IN PRPC_MESSAGE Message
    )
/*++
Function Name:ReceiveReply

Parameters:

Description:
    Helper function to receive the complete reply. The reply may either be a
    callback, or a response.

Returns:

--*/
{
    int BytesRead;
    PVOID NewBuffer;
    RPC_STATUS Status;
    UINT BytesRemaining;
    RPC_MESSAGE NewMessage;
    UINT NewBufferLength;
    int AllocHint = Request->alloc_hint;
    ULONG Timeout;


    //
    // Allocate a buffer, big enough to hold the non pipe data.
    // All the non pipe data will go into the first buffer, all other fragments
    // will go as separate buffers in the received buffer queue
    //
    if (AllocHint)
        {
        Status = Connection->TransGetBuffer(
                                         &NewBuffer,
                                         AllocHint+sizeof(rpcconn_request));

        if (Status != RPC_S_OK)
            {
            Connection->TransFreeBuffer(Request);
            return Status;
            }

        NewBuffer = (char *) NewBuffer+sizeof(rpcconn_request);
        RpcpMemoryCopy(NewBuffer, Message->Buffer, Message->BufferLength);

        Connection->TransFreeBuffer(Request);

        Message->Buffer = NewBuffer;

        BytesRemaining = AllocHint - Message->BufferLength;
        }
    else
        {
        BytesRemaining = 0;
        }

    BytesRead = Message->BufferLength;
    NewMessage.RpcFlags = Message->RpcFlags;

    Timeout = GetBindingHandleTimeout(BindingHandle);

    //
    // Receive the complete data
    //
    while (!COMPLETE(&NewMessage))
        {
        Status = Connection->TransReceive(
                                          &NewBuffer,
                                          &NewBufferLength,
                                          Timeout);
        if (Status != RPC_S_OK)
            {
            Connection->TransFreeBuffer((char *) Message->Buffer-sizeof(rpcconn_request));

            if ((Status == RPC_P_RECEIVE_FAILED)
                || (Status == RPC_P_CONNECTION_CLOSED)
                || (Status == RPC_P_CONNECTION_SHUTDOWN))
                {
                RpcpErrorAddRecord(EEInfoGCRuntime,
                    RPC_S_CALL_FAILED,
                    EEInfoDLOSF_CCALL__ReceiveReply10,
                    Status);
                return(RPC_S_CALL_FAILED);
                }

            if (Status == RPC_P_TIMEOUT)
                {
                RpcpErrorAddRecord(EEInfoGCRuntime,
                    RPC_S_CALL_CANCELLED,
                    EEInfoDLOSF_CCALL__ReceiveReply20,
                    (ULONG)Status,
                    (ULONG)Timeout);

                return RPC_S_CALL_CANCELLED;
                }

            return Status;
            }

        Status = ActuallyProcessPDU(
                                    (rpcconn_common *) NewBuffer,
                                    NewBufferLength,
                                    &NewMessage);

        if (Status != RPC_S_OK)
            {
            Connection->TransFreeBuffer((char *) Message->Buffer-sizeof(rpcconn_request));
            return Status;
            }

        if (BytesRemaining < NewMessage.BufferLength)
            {
            //
            // This code path is taken only in the OSF interop case
            //
            Message->Buffer = (char *) Message->Buffer - sizeof(rpcconn_request);
            Status = Connection->TransReallocBuffer(
                                 &Message->Buffer,
                                 BytesRead+sizeof(rpcconn_request),
                                 BytesRead
                                 +NewMessage.BufferLength
                                 +sizeof(rpcconn_request));

            if (Status != RPC_S_OK)
                {
                Connection->TransFreeBuffer((char *) Message->Buffer-sizeof(rpcconn_request));
                return Status;
                }
            Message->Buffer = (char *) Message->Buffer + sizeof(rpcconn_request);
            BytesRemaining = NewMessage.BufferLength;
            }

        RpcpMemoryCopy((char *) Message->Buffer+BytesRead,
                       NewMessage.Buffer,
                       NewMessage.BufferLength);

        Connection->TransFreeBuffer(NewBuffer);

        BytesRead += NewMessage.BufferLength;
        BytesRemaining -= NewMessage.BufferLength;
        }

    ASSERT(BytesRemaining == 0);

    Message->BufferLength = BytesRead;
    Message->RpcFlags = RPC_BUFFER_COMPLETE;

    return RPC_S_OK;
}


RPC_STATUS
OSF_CCALL::DealWithCallback (
    IN rpcconn_request *Request,
    IN PRPC_MESSAGE Message
    )
/*++
Function Name:DealWithCallback

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status, ExceptionCode;
    void *OriginalBuffer ;

    ASSERT(CurrentState == InCallbackRequest);

    if (CallStack == 1)
        {
        BindingHandle->AddRecursiveEntry(this,
                                     (RPC_CLIENT_INTERFACE  *)
                                     Message->RpcInterfaceInformation);

        }

#ifdef DEBUGRPC
    EnterCallback();
#endif

    if (!COMPLETE(Message))
        {
        ASSERT(Request);
        ASSERT(Request->common.PTYPE == rpc_request);
        //
        // Receive the complete reply
        //

        Status = ReceiveReply(Request, Message);
        if (Status != RPC_S_OK)
            {
            return Status;
            }
        }

    ASSERT(COMPLETE(Message));

    CurrentState = SendingFirstBuffer;
    OriginalBuffer = Message->Buffer;

    //
    // Dispatch the callback
    //
    Status = DispatchCallback(
                              DispatchTableCallback,
                              Message,
                              &ExceptionCode);


#ifdef DEBUGRPC
    ExitCallback();
#endif

    ActuallyFreeBuffer((char *) OriginalBuffer-sizeof(rpcconn_request));

    if ( Status != RPC_S_OK )
        {
        VALIDATE(Status)
            {
            RPC_P_EXCEPTION_OCCURED,
            RPC_S_PROCNUM_OUT_OF_RANGE
            } END_VALIDATE;

        if (Status == RPC_S_PROCNUM_OUT_OF_RANGE)
            {
            SendFault(RPC_S_PROCNUM_OUT_OF_RANGE, 0);
            }
        else
            {
            SendFault(ExceptionCode, 0);
            Status = ExceptionCode;
            }

        RpcpPurgeEEInfo();

        return Status;
        }

    CurrentState = InCallbackReply;

    CurrentOffset = 0;
    CurrentBuffer = Message->Buffer;
    CurrentBufferLength = Message->BufferLength;
    LastBuffer = Message->Buffer;

    Status = SendNextFragment(rpc_response);

    ASSERT(Connection->fExclusive);

    if (Connection->fExclusive)
        {
        if (Status != RPC_S_OK || (CurrentBufferLength == 0))
            {
            goto Cleanup;
            }

        while (CurrentBufferLength)
            {
            Status = SendNextFragment(rpc_response, FALSE);
            if (Status != RPC_S_OK)
                {
                break;
                }
            }

Cleanup:
            if (CallStack == 1)
                {
                BindingHandle->RemoveRecursiveCall(this);
                }

            FreeBufferDo(Message->Buffer);
        }
    else
        {
        //
        // Callbacks not allowed in the async or in pipes
        //
        Status = RPC_S_CALL_FAILED;
        }

    return Status;
}


RPC_STATUS
OSF_CCALL::FastSendReceive (
    IN OUT PRPC_MESSAGE Message,
    OUT BOOL *fRetry
    )
/*++
Function Name:FastSendReceive

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;
    UINT BufferLength;
    rpcconn_common *Request;
    DebugClientCallInfo *ClientCallInfo;
    DebugCallTargetInfo *CallTargetInfo;
    CellTag ClientCallInfoCellTag;
    CellTag CallTargetInfoCellTag;
    THREAD *ThisThread = RpcpGetThreadPointer();
    BOOL fDebugInfoSet = FALSE;
    ULONG Timeout;

    CurrentOffset = 0;
    CurrentBuffer = Message->Buffer;
    CurrentBufferLength = Message->BufferLength;
    Message->RpcFlags = 0;

    ASSERT(ThisThread);

    // if either client side debugging is enabled or we are
    // calling on a thread that has a scall dispatched
    if (IsClientSideDebugInfoEnabled() || ((ThisThread->Context) && IsServerSideDebugInfoEnabled()))
        {
        CStackAnsi AnsiString;
        RPC_CHAR *Endpoint;
        RPC_CHAR *NetworkAddress;
        int EndpointLength;
        int NetworkAddressLength;

        if (!IsClientSideDebugInfoEnabled())
            {
            Status = SetDebugClientCallInformation(&ClientCallInfo, &ClientCallInfoCellTag,
                &CallTargetInfo, &CallTargetInfoCellTag, Message, ThisThread->DebugCell,
                ThisThread->DebugCellTag);
            }
        else
            {
            Status = SetDebugClientCallInformation(&ClientCallInfo, &ClientCallInfoCellTag,
                &CallTargetInfo, &CallTargetInfoCellTag, Message, NULL, NULL);
            }

        if (Status != RPC_S_OK)
            return Status;

        ClientCallInfo->CallID = CallId;

        Endpoint = Connection->InqEndpoint();
        NetworkAddress = Connection->InqNetworkAddress();
        EndpointLength = RpcpStringLength(Endpoint) + 1;
        NetworkAddressLength = RpcpStringLength(NetworkAddress) + 1;
        *(AnsiString.GetPAnsiString()) = (char *)_alloca(max(EndpointLength, NetworkAddressLength));

        Status = AnsiString.Attach(Endpoint, EndpointLength, EndpointLength * 2);

        // effectively ignore failure in the conversion
        if (Status == RPC_S_OK)
            {
            strncpy(ClientCallInfo->Endpoint, AnsiString, sizeof(ClientCallInfo->Endpoint));
            }

        CallTargetInfo->ProtocolSequence = Connection->ClientInfo->TransId;
        Status = AnsiString.Attach(NetworkAddress, NetworkAddressLength, NetworkAddressLength * 2);
        if (Status == RPC_S_OK)
            {
            strncpy(CallTargetInfo->TargetServer, AnsiString, sizeof(CallTargetInfo->TargetServer));
            }

        fDebugInfoSet = TRUE;
        }

    Status = SendNextFragment(rpc_request, TRUE, (void **) &Request, &BufferLength) ;
    if (Status != RPC_S_OK)
        {
        goto Cleanup;
        }

    *fRetry = FALSE;

    while (CurrentBufferLength)
        {
        Status = SendNextFragment(rpc_request, FALSE, (void **) &Request, &BufferLength);
        if (Status != RPC_S_OK)
            {
            goto Cleanup;
            }
        }

    //
    // We have sent the complete request. It is time to start
    // receiving the reply. The reply could either be a response
    // or a callback
    //
    CurrentState = WaitingForReply;

    while (1)
        {
        //
        // This is the only place where we can receive a callback PDU
        //
        Status = ActuallyProcessPDU(
                                    Request,
                                    BufferLength,
                                    Message);

        if (Status != RPC_S_OK)
            {
            goto Cleanup;
            }

        VALIDATE(Request->PTYPE)
            {
            rpc_request,
            rpc_response,
            rpc_shutdown
            } END_VALIDATE;

        switch (Request->PTYPE)
            {
            case rpc_request:
                Status = DealWithCallback(
                                          (rpcconn_request *) Request,
                                          Message);
                Message->RpcFlags = 0;
                break;

            case rpc_response:
                if (!COMPLETE(Message))
                    {
                    Status = ReceiveReply(
                                          (rpcconn_request *) Request,
                                          Message);
                    }
                goto Cleanup;

            default:
                // ignore the pdu
                break;
            }

        Timeout = GetBindingHandleTimeout(BindingHandle);
        Status = Connection->TransReceive(
                                    (PVOID *) &Request,
                                    &BufferLength,
                                    Timeout);
        if (Status != RPC_S_OK)
            {
            if ((Status == RPC_P_RECEIVE_FAILED )
                || ( Status == RPC_P_CONNECTION_CLOSED ) )
                {
                RpcpErrorAddRecord(EEInfoGCRuntime,
                    RPC_S_CALL_FAILED_DNE,
                    EEInfoDLOSF_CCALL__FastSendReceive10,
                    Status);
                Status = RPC_S_CALL_FAILED;
                }
            else if (Status == RPC_P_CONNECTION_SHUTDOWN)
                {
                RpcpErrorAddRecord(EEInfoGCRuntime,
                    RPC_S_CALL_FAILED_DNE,
                    EEInfoDLOSF_CCALL__FastSendReceive20,
                    Status);
                Status = RPC_S_CALL_FAILED_DNE;
                }
            else if (Status == RPC_P_TIMEOUT)
                {
                Status = RPC_S_CALL_CANCELLED;
                RpcpErrorAddRecord(EEInfoGCRuntime,
                    Status,
                    EEInfoDLOSF_CCALL__FastSendReceive30,
                    RPC_P_TIMEOUT,
                    Timeout);
                }

            goto Cleanup;
            }
        }

Cleanup:
    if (fDebugInfoSet)
        {
        FreeCell(CallTargetInfo, &CallTargetInfoCellTag);
        FreeCell(ClientCallInfo, &ClientCallInfoCellTag);
        }
    return Status;
}


void
OSF_CCALL::CallFailed (
    IN RPC_STATUS Status
    )
/*++
Function Name:

Parameters:

Description:

Returns:

--*/
{
    ExtendedErrorInfo * pThreadEEInfo;

    CallMutex.Request();
    //
    // Should not transition from Complete -> Aborted
    //
    if (CurrentState != Complete
        && CurrentState != Aborted)
        {
        //
        // Notify the client that the call is complete. When the stub calls
        // I_RpcReceive, we can cleanup the call and return a failure
        // status.
        //
        AsyncStatus = Status;
        CurrentState = Aborted;

        //
        // If the last send is complete, then we need to issue the notification so
        // that I_RpcReceive is called. If the last send is not complete, we don't need
        // to issue the notification because
        if (pAsync)
            {
            if (EEInfo)
                {
                FreeEEInfoChain(EEInfo);
                EEInfo = NULL;
                }
            pThreadEEInfo = RpcpGetEEInfo();
            if (pThreadEEInfo)
                {
                EEInfo = pThreadEEInfo;
                RpcpClearEEInfo();
                }

            if (fLastSendComplete)
                {
                IssueNotification();
                }
            }
        else
            {
            SyncEvent.Raise();
            }
        }
    CallMutex.Clear();
}


RPC_STATUS
OSF_CCALL::CallCancelled (
    OUT PDWORD Timeout
    )
/*++
Function Name:CallCancelled

Parameters:

Description:
    This function is called via the connection whenever the transport interface
    notices that it has received an alert. This function should only be used in conjuction
    with sync non pipe calls.

Returns:
    RPC_S_OK: The call was cancelled
    others - if a failure occured.

--*/
{
    RPC_STATUS Status;

    if (CurrentState == NeedOpenAndBind)
        {
        *Timeout = 0;
        return RPC_S_OK;
        }

    if (fCallCancelled == 0)
        {
        return RPC_S_NO_CALL_ACTIVE;
        }

    Status = SendCancelPDU();
    //
    // Ignore the return status
    //

    *Timeout = (DWORD) ThreadGetRpcCancelTimeout();

    return Status;
}


inline RPC_STATUS
OSF_CCALL::SendReceiveHelper (
    IN OUT PRPC_MESSAGE Message,
    OUT BOOL *fRetry
    )
/*++
Function Name:SendReceive

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;
    THREAD *ThreadInfo;

    CallStack++;

    ASSERT(!PARTIAL(Message) && !ASYNC(Message));

    ThreadInfo = RpcpGetThreadPointer();
    ASSERT(ThreadInfo);

    if (CallStack == 1)
        {
        Status = ThreadInfo->RegisterForCancels(this);
        if (Status != RPC_S_OK)
            {
            return Status;
            }
        }

    if (ThreadInfo->CancelTimeout == RPC_C_CANCEL_INFINITE_TIMEOUT)
        {
        CancelState = CANCEL_INFINITE;
        }
    else
        {
        CancelState = CANCEL_NOTINFINITE;
        }

    LastBuffer = Message->Buffer;

    ASSERT (Connection->fExclusive);
    ASSERT(CurrentState == SendingFirstBuffer);
    Status = FastSendReceive(Message, fRetry);

    if (CallStack == 1)
        {
        ThreadInfo->UnregisterForCancels();
        }

    CallStack--;

    if (Status == RPC_S_OK
        && CallStack == 0)
        {
        RPC_SECURITY_CALLBACK_FN *SecurityCallback = NULL;

        CurrentState = Complete;
        Status = BindingHandle->InqTransportOption(
                                                   RPC_C_OPT_SECURITY_CALLBACK,
                                                   (ULONG_PTR *) &SecurityCallback);
        ASSERT(Status == RPC_S_OK);

        if (SecurityCallback)
            {
            (*SecurityCallback) (this);
            }
        }

    return Status;
}


RPC_STATUS
OSF_CCALL::SendReceive (
    IN OUT PRPC_MESSAGE Message
    )
/*++
Function Name:SendReceive

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;
    void *TempBuffer ;
    OSF_BINDING_HANDLE *MyBindingHandle;
    void *OriginalBuffer;
    BOOL fRetry = TRUE;
    int RetryAttempts = 0;
    OSF_CCONNECTION *LocalConnection;

    AssocDictMutex->VerifyNotOwned();

    MyBindingHandle = BindingHandle;

    //
    // WARNING: Do not use any members of OSF_CCALL beyond this point.
    // the object could have been deleted.
    //
    while (RetryAttempts <= 5)
        {
        OriginalBuffer = Message->Buffer;
        Status = ((OSF_CCALL *) Message->Handle)->SendReceiveHelper(Message, &fRetry);

        if (Status == RPC_S_OK || ((OSF_CCALL *) Message->Handle)->CallStack > 0)
            {
            ((OSF_CCALL *) Message->Handle)->FreeBufferDo(OriginalBuffer);
            break;
            }
        else
            {
            ASSERT(Status != RPC_S_SEND_INCOMPLETE);
            ASSERT(((OSF_CCALL *) Message->Handle)->CallStack == 0);

            if (Status == RPC_P_CONNECTION_SHUTDOWN)
                {
                Status = RPC_S_CALL_FAILED_DNE;
                }

            LocalConnection = ((OSF_CCALL *) Message->Handle)->Connection;

            if (fRetry == FALSE
                || (Status != RPC_S_CALL_FAILED_DNE)
                || (LocalConnection->ClientSecurityContext.AuthenticationLevel
                == RPC_C_AUTHN_LEVEL_PKT_PRIVACY))
                {
                ((OSF_CCALL *) Message->Handle)->FreeBufferDo(OriginalBuffer);
                ((OSF_CCALL *) Message->Handle)->FreeCCall(Status);
                LogEvent(SU_CCALL, EV_DELETE, Message->Handle, 0, Status, 1, 1);
                break;
                }
            }

        if (!LocalConnection->GetFreshFromCacheFlag())
            {
            // count this as a retry attempt only if the
            // connection was not from the cache
            RetryAttempts ++;
            }

        Status = AutoRetryCall(Message,
                                TRUE, // this is the SendReceive path
                                MyBindingHandle,
                                Status,
                                0);
        if (Status != RPC_S_OK)
            break;

        if (RetryAttempts > 5)
            Status = RPC_S_CALL_FAILED_DNE;
        }


    return Status;
}


RPC_STATUS
OSF_CCALL::ProcessRequestOrResponse (
    IN rpcconn_request *Request,
    IN UINT PacketLength,
    IN BOOL fRequest,
    IN OUT PRPC_MESSAGE Message
    )
/*++
Function Name:ProcessRequestOrResponse

Parameters:
    fRequest - If true, this is a request. Otherwise, it is a response

Description:
    This function is called by ActuallyProcessPDU

Returns:

--*/
{
    RPC_STATUS Status;

    if ((Request->common.pfc_flags & PFC_OBJECT_UUID) != 0)
        {
        ASSERT(0);
        return RPC_S_PROTOCOL_ERROR;
        }

    if ((Request->common.pfc_flags & PFC_FIRST_FRAG))
        {
        InReply = 1;
        ASSERT(BufferQueue.IsQueueEmpty());

        Message->DataRepresentation = Connection->Association->SavedDrep;

        //
        // Transition to the next state
        //
        if (fRequest)
            {
            CurrentState = InCallbackRequest;
            }
        else
            {
            CurrentState = Receiving;
            }
        }
    else
        {
        if (CurrentState == WaitingForReply)
            {
            ASSERT(0);
            return RPC_S_PROTOCOL_ERROR;
            }
        }

    if ((Request->common.pfc_flags & PFC_LAST_FRAG) != 0)
        {
        Message->RpcFlags |= RPC_BUFFER_COMPLETE;
        }

    Status = EatAuthInfoFromPacket(
                                   Request,
                                   &PacketLength);

    if (Status != RPC_S_OK)
        {
        return Status;
        }

    Message->BufferLength = PacketLength - sizeof(rpcconn_request);
    Message->Buffer =  (void *) (Request + 1);

    return RPC_S_OK;
}


RPC_STATUS
OSF_CCALL::ActuallyProcessPDU (
    IN rpcconn_common *Packet,
    IN UINT PacketLength,
    IN OUT PRPC_MESSAGE Message,
    IN BOOL fAsync,
    OUT BOOL *pfSubmitReceive
    )
/*++
Function Name:ActuallyProcessPDU

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    ULONG FaultStatus;
    BOOL AlterContextToNDR20IfNDR64Negotiated;

    //
    // If there is security save the rpc header
    //
    if (Connection->ClientSecurityContext.AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE )
        {
        CallMutex.Request();
        if (SavedHeader == 0)
            {
            SavedHeader = RpcpFarAllocate(sizeof(rpcconn_response));
            if (SavedHeader == 0)
               {
               CallMutex.Clear();
               Status = RPC_S_OUT_OF_MEMORY;
               goto Cleanup;
               }
            SavedHeaderSize = sizeof(rpcconn_response);
            }
        CallMutex.Clear();

        RpcpMemoryCopy(
                       SavedHeader,
                       Packet,
                       sizeof(rpcconn_response));
        }

    Status = ValidatePacket(Packet, PacketLength);
    if (Status != RPC_S_OK)
        {
        goto Cleanup;
        }

    switch (Packet->PTYPE)
        {
        case rpc_response:
            Status =  ProcessRequestOrResponse(
                                            (rpcconn_request *) Packet,
                                            PacketLength,
                                            0,
                                            Message);
            if (Status != RPC_S_OK)
                {
                goto Cleanup;
                }

            if (fAsync)
                {
                Status = ProcessResponse((rpcconn_response *) Packet,
                                         Message, pfSubmitReceive);
                }

            break;

        case rpc_alter_context_resp:
            if (CurrentState != WaitingForAlterContext)
                {
                ASSERT(0);
                Status = RPC_S_PROTOCOL_ERROR;
                goto Cleanup;
                }

            // if we have chosen NDR20 in the call, we must warn the DealWithAlterContextResp
            // to alter context once more to NDR20 if NDR64 was chosen by the server
            if (Bindings.AvailableBindingsList 
                && Bindings.SelectedBinding
                && (Bindings.SelectedBinding->CompareWithTransferSyntax(NDR20TransferSyntax) == 0))
                {
                AlterContextToNDR20IfNDR64Negotiated = TRUE;
                }
            else
                {
                AlterContextToNDR20IfNDR64Negotiated = FALSE;
                }

            Status = Connection->DealWithAlterContextResp(
                                                          this,
                                                          Packet,
                                                          PacketLength,
                                                          &AlterContextToNDR20IfNDR64Negotiated);

            ActuallyFreeBuffer(Packet);

            if (Status != RPC_S_OK)
                {
                return Status;
                }

            // if we sent another alter context, return and wait for the response
            if (AlterContextToNDR20IfNDR64Negotiated)
                return RPC_S_OK;

            //
            // Wait for the send to complete
            //
            Connection->WaitForSend();

            //
            // We sent the alter-context PDU when it was our turn,
            // now that we have received a response, we need to get
            // the ball rolling.
            //
            CurrentState = SendingFirstBuffer;

            ASSERT(Connection->IsIdle() == 0);

            CallMutex.Request();
            if (CurrentBuffer)
                {
                CallMutex.Clear();

                Status = SendNextFragment();
                }
            else
                {
                //
                // We don't have a buffer to send from this call, we will force
                // the connection to idle and wait for the this call to give us
                // its buffer. The send function will notice that the connection is
                // idle, and send its first data buffer.
                //
                Connection->MakeConnectionIdle();
                CallMutex.Clear();

                ASSERT(Status == RPC_S_OK);
                }

            return Status;

        case rpc_request:
            //
            // if we are going to reuse this function to handle
            // sync SendReceive, we need to keep track of this
            // and puke on the other cases (ie: when using Async
            // and when using pipes).
            //
            if (fAsync)
                {
                SendFault(RPC_S_CALL_FAILED, 0);
                Status = RPC_S_CALL_FAILED;
                goto Cleanup;
                }

            if ( Packet->call_id != CallId )
                {
                ASSERT(0);
                Status = RPC_S_PROTOCOL_ERROR;
                goto Cleanup;
                }

            if (((rpcconn_request  *) Packet)->p_cont_id
                        != GetSelectedBinding()->GetOnTheWirePresentationContext() )
                {
                SendFault(RPC_S_UNKNOWN_IF, 0);
                Status = RPC_S_UNKNOWN_IF;
                goto Cleanup;
                }

            Status =  ProcessRequestOrResponse(
                                            (rpcconn_request *) Packet,
                                            PacketLength,
                                            1,
                                            Message);
            if (Status != RPC_S_OK)
                {
                goto Cleanup;
                }

            Message->ProcNum = ((rpcconn_request *) Packet)->opnum;
            break;

        case rpc_fault:
            FaultStatus = ((rpcconn_fault  *) Packet)->status;

            if ((FaultStatus == 0)
                && (Packet->frag_length >= FaultSizeWithoutEEInfo + 4))
                {
                //
                // DCE 1.0.x style fault status:
                // Zero status and stub data contains the fault.
                //
                FaultStatus = *(ULONG  *) ((unsigned char *)Packet + FaultSizeWithoutEEInfo);
                }

            if (DataConvertEndian(Packet->drep) != 0)
                {
                FaultStatus = RpcpByteSwapLong(FaultStatus);
                }

            ASSERT(FaultStatus != 0);

            Status = MapFromNcaStatusCode(FaultStatus);

            ASSERT(Status != RPC_S_OK);

            if (((rpcconn_fault  *) Packet)->reserved & FaultEEInfoPresent)
                {
                ExtendedErrorInfo *EEInfo;

                UnpickleEEInfoFromBuffer(((rpcconn_fault  *) Packet)->buffer,
                    GetEEInfoSizeFromFaultPacket((rpcconn_fault  *) Packet));

                EEInfo = RpcpGetEEInfo();
                if (EEInfo && pAsync)
                    {
                    ASSERT(this->EEInfo == NULL);

                    // move the eeinfo to the call. Even though it is possible
                    // that the call will be completed on this thread, it is
                    // still ok, as we will move it back during completion
                    this->EEInfo = EEInfo;
                    RpcpClearEEInfo();
                    }
                }

            //
            // In 3.5 we didnt Sign/Seal Faults. So .. Unsign/UnSeal doesnt
            // get called and hence Client side and Server side Seq# are
            // out of Sync..  So cheat ..
            //

            Connection->IncReceiveSequenceNumber();

            if (fAsync)
                {
                if (Connection->Association->fMultiplex == mpx_no
                    && fOkToAdvanceCall())
                    {
                    //
                    // In the multiplexed case, the call is advanced
                    // when the send completes
                    //
                    Connection->AdvanceToNextCall();
                    }
                }
            break;

        case rpc_orphaned :
        case rpc_cancel :
        case rpc_shutdown :
            //
            // For the first release, we will just ignore these messages.
            //
            ASSERT(Status == RPC_S_OK);
            ActuallyFreeBuffer(Packet);
            break;
        }

Cleanup:
    if (Status != RPC_S_OK)
        {
        ActuallyFreeBuffer(Packet);
        }

    return Status;
}


BOOL
OSF_CCALL::ProcessReceivedPDU (
    IN void  *Buffer,
    IN int BufferLength
    )
/*++
Function Name:ProcessReceivedPDU

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;
    RPC_MESSAGE Message;
    rpcconn_common * Packet = (rpcconn_common *) Buffer;
    BOOL fSubmitReceive = 1;

    Message.RpcFlags = 0;

    Status = ActuallyProcessPDU(
                                Packet,
                                BufferLength,
                                &Message,
                                1,
                                &fSubmitReceive);

    if (Status != RPC_S_OK)
        {
        CallFailed(Status);
        }

    return fSubmitReceive;
}


RPC_STATUS
OSF_CCALL::UpdateBufferSize (
    IN OUT void **Buffer,
    IN int CurrentBufferLength
    )
{
    RPC_MESSAGE Message;
    RPC_STATUS Status;

    Message.RpcFlags = 0;
    Message.Handle = this;
    Message.ProcNum = ProcNum;
    Message.BufferLength = CurrentBufferLength;

    Status = GetBufferWithoutCleanup(&Message, 0);
    if (Status != RPC_S_OK)
        {
        CallFailed(Status);
        return Status;
        }

    RpcpMemoryCopy(Message.Buffer, *Buffer, CurrentBufferLength);

    ActuallyFreeBuffer((char  *) (*Buffer) - sizeof(rpcconn_request));

    return RPC_S_OK;
}

RPC_STATUS
OSF_CCALL::NegotiateTransferSyntaxAndGetBuffer (
    IN OUT PRPC_MESSAGE Message,
    IN UUID *ObjectUuid
    )
{
    OSF_BINDING_HANDLE *BindingHandle;
    OSF_CCALL *CCall;
    RPC_STATUS Status;
    RPC_SYNTAX_IDENTIFIER TransferSyntax;
    BOOL fInterfaceSupportsMultipleTransferSyntaxes;

    BindingHandle = (OSF_BINDING_HANDLE *)Message->Handle;

    ASSERT(BindingHandle->Type(OSF_BINDING_HANDLE_TYPE));

    fInterfaceSupportsMultipleTransferSyntaxes =
        DoesInterfaceSupportMultipleTransferSyntaxes(Message->RpcInterfaceInformation);

    if (fInterfaceSupportsMultipleTransferSyntaxes)
        RpcpMemoryCopy(&TransferSyntax, Message->TransferSyntax, sizeof(RPC_SYNTAX_IDENTIFIER));

    Status = BindingHandle->OSF_BINDING_HANDLE::NegotiateTransferSyntax(Message);

    if (Status != RPC_S_OK)
        return Status;

    CCall = (OSF_CCALL *)Message->Handle;

    if (fInterfaceSupportsMultipleTransferSyntaxes)
        {
        if (RpcpMemoryCompare(&TransferSyntax, Message->TransferSyntax, sizeof(RPC_SYNTAX_IDENTIFIER)) != 0)
            {
            // the transfer syntax has changed - possible during auto-reconnect, especially in a
            // mixed cluster environment

            //
            // We cannot free the call, because an async bind may be
            // in progress. All we should do is remove our ref counts
            // The async bind path holds its own ref count, so
            // we don't need to worry about it
            //
            CCall->AsyncStatus = RPC_S_CALL_FAILED_DNE;
            // we need to remove only one reference - the second reference
            // is removed during a successful bind, and another reference
            // will be added when a successful send is made - we're not
            // there yet, so we have only one reference.
            CCall->OSF_CCALL::RemoveReference();
            // When NDR starts supporting remarshalling, we should
            // return RPC_P_TRANSFER_SYNTAX_CHANGED
            return RPC_S_CALL_FAILED_DNE;
            }
        }

    Status = CCall->GetBuffer(Message, ObjectUuid);

    return Status;
}


RPC_STATUS
OSF_CCALL::SendMoreData (
    IN BUFFER Buffer
    )
/*++
Function Name:SendMoreData

Parameters:

Description:
    This function can only be called on a send completion

Returns:

--*/
{
    RPC_STATUS Status;
    void  * SecurityTrailer;

    CallMutex.Request();
    if (Buffer)
        {
        //
        // If we reach here, it means that this routine was called
        // as a result of a send complete
        //
        ASSERT(HeaderSize != 0);
        ASSERT(CurrentBuffer);
        ASSERT(CurrentBuffer != LastBuffer
               || CurrentBufferLength > MaxDataLength);


        CurrentOffset += MaxDataLength;
        CurrentBufferLength -= MaxDataLength;

        if (CurrentBufferLength == 0)
            {
            FreeBufferDo(CurrentBuffer);

            if (pAsync && (pAsync->Flags & RPC_C_NOTIFY_ON_SEND_COMPLETE))
                {
                if (!IssueNotification(RpcSendComplete))
                    {
                    CallMutex.Clear();
#if DBG
                    PrintToDebugger("RPC: SendMoreData failed: %d\n", AsyncStatus);
#endif
                    return RPC_S_OUT_OF_MEMORY;
                    }
                }

            //
            // We can be in SendingFirstBuffer, if the we had a very small pipe
            //

            VALIDATE(CurrentState)
                {
                SendingMoreData,
                SendingFirstBuffer
                } END_VALIDATE;

            CurrentOffset = 0;
            CurrentBuffer = BufferQueue.TakeOffQueue(
                                                     (unsigned int *) &CurrentBufferLength);

            if (fChoked == 1 && pAsync == 0 && BufferQueue.Size() <=1)
                {
                fChoked = 0;
                SyncEvent.Raise();
                }

            if (CurrentBuffer)
                {
                if ((AdditionalSpaceForSecurity < Connection->AdditionalSpaceForSecurity)
                   && UpdateBufferSize(&CurrentBuffer, CurrentBufferLength) != RPC_S_OK)
                   {
                   CallMutex.Clear();

                   return RPC_S_OUT_OF_MEMORY;
                   }
                }
            else
                {
                Connection->MakeConnectionIdle();
                ASSERT(CurrentBufferLength == 0);
                CallMutex.Clear();

                return RPC_S_OK;
                }
            }
        else
            {
            //
            // We need to restore the part of the buffer which we overwrote
            // with authentication information.
            //
            if (Connection->ClientSecurityContext.AuthenticationLevel
                != RPC_C_AUTHN_LEVEL_NONE)
                {
                VALIDATE(Connection->ClientSecurityContext.AuthenticationLevel)
                    {
                    RPC_C_AUTHN_LEVEL_PKT_INTEGRITY,
                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                    RPC_C_AUTHN_LEVEL_PKT,
                    RPC_C_AUTHN_LEVEL_CONNECT
                    } END_VALIDATE;

                ASSERT(HeaderSize != 0);

                SecurityTrailer = (char  *) Buffer
                     + MaximumFragmentLength - MaxSecuritySize;

                RpcpMemoryCopy(SecurityTrailer, ReservedForSecurity,
                                   MaxSecuritySize);
                }
            }
        }
    else
        {
        if (AdditionalSpaceForSecurity <
            Connection->AdditionalSpaceForSecurity)
            {
            if (UpdateBufferSize(&CurrentBuffer, CurrentBufferLength) != RPC_S_OK)
                {
                CallMutex.Clear();

                return RPC_S_OUT_OF_MEMORY;
                }
            }
        }
    CallMutex.Clear();

    BOOL fFirstSend = (CurrentState == SendingFirstBuffer)
                      && (CurrentOffset == 0);
    //
    // When the last fragment is sent
    // the state changes to WaitingForReply
    //
    Status = SendNextFragment(rpc_request, fFirstSend);

    if (Status != RPC_S_OK)
        {
        VALIDATE(CurrentState)
            {
            InCallbackReply,
            SendingMoreData,
            SendingFirstBuffer,
            WaitingForReply,
            Aborted
            } END_VALIDATE;


         if (CurrentState == InCallbackReply)
             {
             AsyncStatus = Status;
             SendFault(Status, 0);
             Status = RPC_S_OK;
             }
        }

    return Status;
}


RPC_STATUS
OSF_CCALL::SendData (
    IN BUFFER Buffer
    )
{
    RPC_STATUS Status = RPC_S_OK;

    switch (CurrentState)
        {
        case NeedAlterContext:
            //
            // need to send an alter context on the call
            //
            Status = SendAlterContextPDU();
            break;

        case WaitingForAlterContext:
            //
            // We are still waiting for alter-context to complete,
            // we don't have anything to do at this very point.
            // We will start sending data once we receive the
            // response to the alter-context.
            //
            break;

        case SendingMoreData:
        case InCallbackReply:
        case SendingFirstBuffer:
            //
            // the call is still sending the non pipe data
            // we need to finish sending this before
            // we can move on the the next call.
            //
            Status = SendMoreData(Buffer);
            break;

        case Aborted:
            //
            // some failure occured. the call is now in an
            // aborted state
            //
            Status = AsyncStatus;
#if DBG
            PrintToDebugger("RPC: Call in aborted state\n");
#endif
            ASSERT(Status != RPC_S_OK);
            break;

        case Complete:
            //
            // the call is complete, the receive complete before the send could
            // complete, but we should have advanced to the next call when
            // sending the last fragment. We should never get into this state,
            // unless we are talking to a legacy server
            //
            ASSERT(Status == RPC_S_OK);
            ASSERT(Connection->Association->fMultiplex == mpx_no);
            break;

        case Receiving:
            //
            // We should never be in this state unless we are talking to a legacy
            // server
            //
            ASSERT(Connection->Association->fMultiplex == mpx_no);
            // intentional fall through
        case WaitingForReply:
            ASSERT(Status == RPC_S_OK);
            break;

        case InCallbackRequest:
        default:
            //
            // we should never be in these states.
#if DBG
            PrintToDebugger("RPC: Bad call state: %d\n", CurrentState);
#endif
            ASSERT(0);
            Status = RPC_S_INTERNAL_ERROR;
            break;
        }

    return Status;
}


void
OSF_CCALL::ProcessSendComplete (
    IN RPC_STATUS EventStatus,
    IN BUFFER Buffer
    )
/*++
Function Name:ProcessSendComplete

Parameters:

Description:

Returns:

--*/
{
    if (EventStatus == RPC_S_OK)
        {
        EventStatus = SendData(Buffer);
        }

    if (EventStatus != RPC_S_OK)
        {
        Connection->ConnectionAborted(EventStatus);

        //
        // Remove the send reference on the call, CCALL--
        //
        RemoveReference();
        }
}


RPC_STATUS
OSF_CCALL::SendNextFragment (
    IN unsigned char PacketType,
    IN BOOL fFirstSend,
    OUT void **ReceiveBuffer,
    OUT UINT *ReceivedLength
    )
/*++
Function Name:SendNextFragment

Parameters:

Description:

Returns:

--*/
{
    int PacketLength;
    RPC_STATUS Status;
    BOOL LastFragmentFlag;
    rpcconn_common  *pFragment;
    void *SendContext = CallSendContext;
    int MyBufferLength;
    int MyHeaderSize = HeaderSize;
    ULONG Timeout;

    ASSERT(HeaderSize != 0);
    ASSERT(MaxDataLength);
    ASSERT(CurrentBuffer);

    if (UuidSpecified && (CallStack > 1 || PacketType != rpc_request))
        {
        MyHeaderSize -= sizeof(UUID);
        }

    //
    // Prepare the fragment
    //
    if (CurrentBuffer == LastBuffer
        && CurrentBufferLength <= MaxDataLength)
        {
        PacketLength = CurrentBufferLength + MyHeaderSize + MaxSecuritySize;
        LastFragmentFlag = 1;

        if (CurrentState != InCallbackReply)
            {
            ASSERT((CurrentState == SendingFirstBuffer)
                   || (CurrentState == SendingMoreData)
                   || (CurrentState == Aborted));

            CurrentState = WaitingForReply;

            if (Connection->fExclusive == 0)
                {
                //
                // This async send will complete on the connection
                // and the connection will free the buffer
                //
                SendContext = Connection->u.ConnSendContext;
                Connection->BufferToFree = ActualBuffer(CurrentBuffer);
                }
            }
        }
    else
        {
        PacketLength =  MaximumFragmentLength;
        LastFragmentFlag = 0;

        if (CurrentBufferLength == MaxDataLength
            && CurrentState == SendingFirstBuffer)
            {
            CurrentState = SendingMoreData;
            }
        }

    pFragment = (rpcconn_common  *)
            ((char  *) CurrentBuffer + CurrentOffset - MyHeaderSize);

    ConstructPacket(pFragment,
                    PacketType,
                    PacketLength);

    if (fFirstSend)
        {
        pFragment->pfc_flags |= PFC_FIRST_FRAG;
        }

    if ( PacketType == rpc_request )
        {
        if (UuidSpecified && (pAsync || CallStack == 1))
            {
            pFragment->pfc_flags |= PFC_OBJECT_UUID;
            RpcpMemoryCopy(((unsigned char  *) pFragment)
                    + sizeof(rpcconn_request),
                    &ObjectUuid,
                    sizeof(UUID));
            }

        ((rpcconn_request  *) pFragment)->alloc_hint = CurrentBufferLength;
        ((rpcconn_request  *) pFragment)->p_cont_id
            = GetSelectedBinding()->GetOnTheWirePresentationContext();
        ((rpcconn_request  *) pFragment)->opnum = (unsigned short) ProcNum;
        }
    else
        {
        ((rpcconn_response  *) pFragment)->alloc_hint = CurrentBufferLength;
        ((rpcconn_response  *) pFragment)->p_cont_id
            = GetSelectedBinding()->GetOnTheWirePresentationContext();
        ((rpcconn_response  *) pFragment)->alert_count = 0;
        ((rpcconn_response  *) pFragment)->reserved = 0;
        }

    pFragment->call_id = CallId;

    MyBufferLength = CurrentBufferLength;

    if (Connection->fExclusive)
        {
        Timeout = GetBindingHandleTimeout(BindingHandle);

        if (LastFragmentFlag == 0)
            {
            CurrentOffset += MaxDataLength;
            CurrentBufferLength -= MaxDataLength;
            if (UuidSpecified && (CallStack > 1 || PacketType != rpc_request))
                {
                CurrentOffset += sizeof(UUID);
                CurrentBufferLength -= sizeof(UUID);
                }
            ASSERT(((long)CurrentBufferLength) >= 0);
            }
        else
            {
            CurrentBufferLength = 0;
            }
        }
    else
        Timeout = INFINITE;

    if (ReceiveBuffer)
        {
        *ReceiveBuffer = NULL;
        }

    Status = Connection->SendFragment (
                           pFragment,
                           this,
                           LastFragmentFlag,
                           MyHeaderSize,
                           MaxSecuritySize,
                           MyBufferLength,
                           MaximumFragmentLength,
                           ReservedForSecurity,
                           !(Connection->fExclusive),
                           SendContext,
                           Timeout,
                           ReceiveBuffer,
                           ReceivedLength);

    if (ReceiveBuffer && *ReceiveBuffer)
        {
        CurrentBufferLength = 0;
        }


    return Status;
}


RPC_STATUS
OSF_CCALL::ProcessResponse (
    IN rpcconn_response *Packet,
    IN PRPC_MESSAGE Message,
    OUT BOOL *pfSubmitReceive
    )
/*++
Function Name:ProcessResponse

Parameters:

Description:
    Process the response data. The first buffer is placed on the buffer queue
    only after alloc_hint bytes have been received.

Returns:

--*/
{
    RPC_STATUS Status;

    //
    // We don't need to look at alloc_hint for the response PDUs
    // we can simply queue up the buffers. When we get the last one,
    // we'll coalesce them for for the non pipe case. For the pipe case,
    // we will progressively give the buffers to the stub.
    //

    CallMutex.Request();

    if (QueueBuffer(Message->Buffer,
                    Message->BufferLength))
        {
        CallFailed(RPC_S_OUT_OF_MEMORY);
        CallMutex.Clear();

        return RPC_S_OUT_OF_MEMORY;
        }

    if (COMPLETE(Message))
        {
        AsyncStatus = RPC_S_OK;
        CurrentState = Complete;
        CallMutex.Clear();

        if (Connection->Association->fMultiplex == mpx_no
            && fOkToAdvanceCall())
            {
            //
            // In the multiplexed case, the call is advanced
            // when the send completes
            //
            Connection->AdvanceToNextCall();
            }

        IssueNotification();
        }
    else
        {
        if (pAsync == 0)
            {
            if (BufferQueue.Size() >= 4
                && pfSubmitReceive)
                {
                fPeerChoked = 1;
                *pfSubmitReceive = 0;
                }

            CallMutex.Clear();

            SyncEvent.Raise();
            }
        else
            {
            if (NeededLength > 0
                && RcvBufferLength > NeededLength)
                {
                IssueNotification(RpcReceiveComplete);
                }
            else
                {
                if (fDoFlowControl
                    && BufferQueue.Size() >= 4
                    && pfSubmitReceive)
                    {
                    fPeerChoked = 1;
                    *pfSubmitReceive = 0;
                    }
                }
            CallMutex.Clear();
            }
        }

    return RPC_S_OK;
}


RPC_STATUS
OSF_CCALL::SendAlterContextPDU (
    )
/*++
Function Name:SendAlterContextPDU

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;
    ULONG Timeout;
    BOOL fBindingHandleTimeoutUsed;

    //
    // We try to create a thread to go down and listen
    //
    Status = BindingHandle->TransInfo->CreateThread();

    VALIDATE(Status)
        {
        RPC_S_OK,
        RPC_S_OUT_OF_MEMORY,
        RPC_S_OUT_OF_THREADS
        } END_VALIDATE;

    CurrentState = WaitingForAlterContext;

    ASSERT(Connection->Association->AssocGroupId);

    Timeout = GetEffectiveTimeoutForBind(
        BindingHandle,
        &fBindingHandleTimeoutUsed);

    //
    // Send the alter-context PDU
    //
    Status = Connection->SendBindPacket(
                            FALSE,
                            this,
                            Connection->Association->AssocGroupId,
                            rpc_alter_context,
                            Timeout
                            );


    if (Status != RPC_S_OK)
        {
        Status = GetStatusForTimeout(BindingHandle, Status, fBindingHandleTimeoutUsed);

        CallFailed(Status);
#if DBG
        PrintToDebugger("RPC: SendAlterContextPDU failed: %d\n", Status);
#endif
        }

    return Status;
}


RPC_STATUS
OSF_CCALL::EatAuthInfoFromPacket (
    IN rpcconn_request  * Request,
    IN OUT UINT  * RequestLength
    )
/*++

Routine Description:

    If there is authentication information in the packet, this routine
    will check it, and perform security as necessary.  This may include
    calls to the security support package.

Arguments:

    Request - Supplies the packet which may contain authentication
        information.

    RequestLength - Supplies the length of the packet in bytes, and
        returns the length of the packet without authentication
        information.

Return Value:

    RPC_S_OK - Everything went just fine.

    RPC_S_ACCESS_DENIED - A security failure of some sort occured.

    RPC_S_PROTOCOL_ERROR - This will occur if no authentication information
        is in the packet, and some was expected, or visa versa.

--*/
{
    RPC_STATUS Status;
    sec_trailer  * SecurityTrailer;
    SECURITY_BUFFER SecurityBuffers[5];
    DCE_MSG_SECURITY_INFO MsgSecurityInfo;
    SECURITY_BUFFER_DESCRIPTOR BufferDescriptor;

    if ( Request->common.auth_length != 0 )
        {
        SecurityTrailer = (sec_trailer  *)
                (((unsigned char  *) Request)
                + Request->common.frag_length
                - Request->common.auth_length
                - sizeof(sec_trailer));

        ASSERT(SecurityTrailer->auth_context_id == PtrToUlong(Connection));

        if ((Connection->ClientSecurityContext.AuthenticationLevel
            == RPC_C_AUTHN_LEVEL_NONE))
            {
            return(RPC_S_PROTOCOL_ERROR);
            }

        *RequestLength -= Request->common.auth_length;

        MsgSecurityInfo.SendSequenceNumber =
                Connection->InquireSendSequenceNumber();
        MsgSecurityInfo.ReceiveSequenceNumber =
                Connection->InquireReceiveSequenceNumber();
        MsgSecurityInfo.PacketType = Request->common.PTYPE;

        BufferDescriptor.ulVersion = 0;
        BufferDescriptor.cBuffers = 5;
        BufferDescriptor.pBuffers = SecurityBuffers;

        SecurityBuffers[0].cbBuffer = sizeof(rpcconn_request);
        SecurityBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        SecurityBuffers[0].pvBuffer = ((unsigned char  *) SavedHeader);

        SecurityBuffers[1].cbBuffer = *RequestLength
                                      - sizeof(rpcconn_request)
                                      - sizeof (sec_trailer);
        SecurityBuffers[1].BufferType = SECBUFFER_DATA;
        SecurityBuffers[1].pvBuffer = ((unsigned char  *) Request)
                                      + sizeof(rpcconn_request);

        SecurityBuffers[2].cbBuffer = sizeof(sec_trailer);
        SecurityBuffers[2].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        SecurityBuffers[2].pvBuffer = SecurityTrailer;

        SecurityBuffers[3].cbBuffer = Request->common.auth_length;
        SecurityBuffers[3].BufferType = SECBUFFER_TOKEN;
        SecurityBuffers[3].pvBuffer = SecurityTrailer + 1;

        SecurityBuffers[4].cbBuffer = sizeof(DCE_MSG_SECURITY_INFO);
        SecurityBuffers[4].BufferType = (SECBUFFER_PKG_PARAMS
                                         | SECBUFFER_READONLY);
        SecurityBuffers[4].pvBuffer = &MsgSecurityInfo;

        Status = Connection->ClientSecurityContext.VerifyOrUnseal(
                            MsgSecurityInfo.ReceiveSequenceNumber,
                            Connection->ClientSecurityContext.AuthenticationLevel
                            != RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                            &BufferDescriptor);

        if ( Status != RPC_S_OK )
            {
            ASSERT( (Status == RPC_S_ACCESS_DENIED) ||
                    (Status == ERROR_SHUTDOWN_IN_PROGRESS) ||
                    (Status == ERROR_PASSWORD_MUST_CHANGE) ||
                    (Status == ERROR_PASSWORD_EXPIRED) ||
                    (Status == ERROR_ACCOUNT_DISABLED) ||
                    (Status == ERROR_INVALID_LOGON_HOURS));

            return(Status);
            }
        *RequestLength -= (sizeof(sec_trailer)
                           + SecurityTrailer->auth_pad_length);
        }
    else
        {
        if ((Connection->ClientSecurityContext.AuthenticationLevel
                        == RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
            || (Connection->ClientSecurityContext.AuthenticationLevel
                        == RPC_C_AUTHN_LEVEL_PKT_PRIVACY))
            {
            return(RPC_S_PROTOCOL_ERROR);
            }
        }

    Connection->IncReceiveSequenceNumber();

    return(RPC_S_OK);
}


void
OSF_CCALL::SendFault (
    IN RPC_STATUS Status,
    IN int DidNotExecute
    )
{
    rpcconn_fault Fault;

    memset(&Fault, 0, sizeof(Fault));

    ConstructPacket((rpcconn_common  *) &Fault,rpc_fault,
                    sizeof(rpcconn_fault));

    if (DidNotExecute)
        Fault.common.pfc_flags |= PFC_DID_NOT_EXECUTE;

    Fault.common.pfc_flags |= PFC_FIRST_FRAG | PFC_LAST_FRAG;
    Fault.p_cont_id = GetSelectedBinding()->GetOnTheWirePresentationContext();
    Fault.status = MapToNcaStatusCode(Status);
    Fault.common.call_id = CallId;

    Connection->TransSend(&Fault,
        sizeof(rpcconn_fault), 
        TRUE,   // fDisableShutdownCheck
        TRUE,   // fDisableCancelCheck
        INFINITE
        );
}

RPC_STATUS
OSF_CCALL::SendCancelPDU(
    )
{
    rpcconn_common CancelPDU;
    RPC_STATUS Status;
    ULONG Timeout;

    ConstructPacket(
                    (rpcconn_common  *) &CancelPDU,
                    rpc_cancel,
                    sizeof(rpcconn_common));

    CancelPDU.call_id = CallId;
    CancelPDU.pfc_flags = PFC_LAST_FRAG | PFC_PENDING_CANCEL;

    Timeout = GetBindingHandleTimeout(BindingHandle);

    Status = Connection->TransSend(&CancelPDU, 
        sizeof(rpcconn_common), 
        TRUE,    // fDisableShutdownCheck
        TRUE,    // fDisableCancelCheck
        Timeout
        );

    if (Status == RPC_P_TIMEOUT)
        {
        Status = RPC_S_CALL_CANCELLED;
        }
    else
        {
        ASSERT(Status != RPC_S_CALL_CANCELLED);
        }

    return Status;
}


RPC_STATUS
OSF_CCALL::SendOrphanPDU (
    )
{
    rpcconn_common Orphan;
    RPC_STATUS Status;
    ULONG Timeout;

    ConstructPacket(
                    (rpcconn_common  *) &Orphan,
                    rpc_orphaned,
                    sizeof(rpcconn_common));

    Orphan.call_id = CallId;
    Orphan.pfc_flags = PFC_FIRST_FRAG | PFC_LAST_FRAG;

    Timeout = GetBindingHandleTimeout(BindingHandle);

    Status = Connection->TransSend(&Orphan, 
        sizeof(rpcconn_common),
        TRUE,    // fDisableShutdownCheck
        TRUE,    // fDisableCancelCheck
        Timeout
        );

    return Status;
}

RPC_STATUS
OSF_CCALL::NegotiateTransferSyntax (
    IN OUT PRPC_MESSAGE Message
    )
{
    // this can only happen for callbacks
    ASSERT(IsCallInCallback());

    // just return the transfer syntax already negotiated in the binding
    Message->TransferSyntax = GetSelectedBinding()->GetTransferSyntaxId();
    return RPC_S_OK;
}

RPC_STATUS
OSF_CCALL::GetBuffer (
    IN OUT PRPC_MESSAGE Message,
    IN UUID *ObjectUuid
    )
/*++

Routine Description:

Arguments:

    Message - Supplies a description containing the length of buffer to be
        allocated, and returns the allocated buffer.

    ObjectUuid - this parameter is ignored

Return Value:

    RPC_S_OK - A buffer of the requested size has successfully been allocated.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available.

--*/
{
    RPC_STATUS Status;

    AssocDictMutex->VerifyNotOwned();

    UpdateObjectUUIDInfo(ObjectUuid);
    Status = GetBufferWithoutCleanup(Message, ObjectUuid);

    // do the cleanup to get regular GetBuffer semantics
    if (Status != RPC_S_OK)
        {
        //
        // We cannot free the call, because an async bind may be
        // in progress. All we should do is remove our ref counts
        // The async bind path holds its own ref count, so
        // we don't need to worry about it
        //
        AsyncStatus = RPC_S_CALL_FAILED_DNE;
        if (Connection->fExclusive == 0)
            {
            // async calls have one more reference
            OSF_CCALL::RemoveReference();
            }
        OSF_CCALL::RemoveReference();
        }

    return(Status);
}

RPC_STATUS
OSF_CCALL::GetBufferWithoutCleanup (
    IN OUT PRPC_MESSAGE Message,
    IN UUID *ObjectUuid
    )
{
    RPC_STATUS Status;
    ULONG MaxFrag;
    ULONG NewLength;

    MaxFrag = Connection->MaxFrag;
    ProcNum = Message->ProcNum;

    //
    // In addition to saving space for the request (or response) header
    // and an object UUID, we want to save space for security information
    // if necessary.
    //

    if ((Message->RpcFlags & RPC_BUFFER_PARTIAL)
        && (Message->BufferLength < MaxFrag))
        {
        ActualBufferLength = MaxFrag;
        }
    else
        {
        ActualBufferLength = Message->BufferLength;
        }

    NewLength = ActualBufferLength
                    + sizeof(rpcconn_request)
                    + sizeof(UUID)
                    + (2 * Connection->AdditionalSpaceForSecurity);

    Status = ActuallyAllocateBuffer(&Message->Buffer,
                                           NewLength);
    if ( Status != RPC_S_OK )
        {
        ASSERT( Status == RPC_S_OUT_OF_MEMORY );
        return Status;
        }

    ASSERT(HeaderSize != 0);
    if (UuidSpecified)
        {
        Message->Buffer = (char  *) Message->Buffer
                                    + sizeof(rpcconn_request)
                                    + sizeof(UUID);
        }
    else
        {
        Message->Buffer = (char  *) Message->Buffer
                                    + sizeof(rpcconn_request);
        }

    return RPC_S_OK;
}

RPC_STATUS
OSF_CCALL::GetBufferDo (
    IN UINT culRequiredLength,
    OUT void  * * ppBuffer,
    IN int fDataValid,
    IN int DataLength
    )
/*++
Function Name:GetBufferDo

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;
    void  *NewBuffer;

    Status = ActuallyAllocateBuffer(&NewBuffer,
                                        culRequiredLength
                                        + sizeof(rpcconn_request)
                                        + sizeof(UUID));
    if (Status)
        return(RPC_S_OUT_OF_MEMORY);

    ASSERT(HeaderSize != 0);
    if (UuidSpecified)
        {
        NewBuffer = (((unsigned char  *) NewBuffer)
                        + sizeof(rpcconn_request))
                        + sizeof(UUID);
        }
    else
        {
        NewBuffer = (((unsigned char  *) NewBuffer)
                        + sizeof(rpcconn_request));
        }

    if (fDataValid)
        {
        RpcpMemoryCopy(NewBuffer, *ppBuffer, DataLength);
        ActuallyFreeBuffer(*ppBuffer);
        }

    *ppBuffer = NewBuffer;

    return(RPC_S_OK);
}

void
OSF_CCALL::FreeBufferDo (
    IN void  *Buffer
    )
/*++
Function Name:FreeBufferDo

Parameters:

Description:

Returns:

--*/
{
    ASSERT(HeaderSize != 0);
    if (UuidSpecified)
        {
        Buffer = (char  *) Buffer  - sizeof(rpcconn_request) - sizeof(UUID);
        }
    else
        {
        Buffer = (char  *) Buffer  - sizeof(rpcconn_request);
        }
    ActuallyFreeBuffer((char  *)Buffer);
}

void
OSF_CCALL::FreeBuffer (
    IN PRPC_MESSAGE Message
    )
/*++
Function Name:FreeBuffer

Parameters:

Description:

Returns:

--*/
{
    if (CallStack == 0)
        {
        if (Message->Buffer != NULL)
            {
            if (CurrentState == Complete)
                {
                ActuallyFreeBuffer((char  *)Message->Buffer-sizeof(rpcconn_response));
                }
            else
                {
                FreeBufferDo(Message->Buffer);
                }
            }

        if (Connection->fExclusive)
            {
            FreeCCall(RPC_S_OK);
            }
        else
            {
            UnregisterCallForCancels();

            // Remove the call reference CCALL--
            RemoveReference();
            }
        }
    else
        {
        if (Message->Buffer != NULL)
            {
            ActuallyFreeBuffer((char  *)Message->Buffer-sizeof(rpcconn_response));
            CurrentBufferLength = 0;
            }
        else
            {
            FreeCCall(RPC_S_OK);
            }
        }
}

void
OSF_CCALL::FreePipeBuffer (
    IN PRPC_MESSAGE Message
    )
/*++
Function Name:FreePipeBuffer

Parameters:

Description:

Returns:

--*/
{
    ASSERT(HeaderSize != 0);
    if (UuidSpecified)
        {
        Message->Buffer = (char  *) Message->Buffer
                                    - sizeof(rpcconn_request) - sizeof(UUID);
        }
    else
        {
        Message->Buffer = (char  *) Message->Buffer
                                    - sizeof(rpcconn_request);
        }

    ActuallyFreeBuffer((char  *)Message->Buffer);
}


RPC_STATUS
OSF_CCALL::ReallocPipeBuffer (
    IN PRPC_MESSAGE Message,
    IN UINT NewSize
    )
/*++
Function Name:ReallocPipeBuffer

Parameters:

Description:

Returns:

--*/
{
    void  *TempBuffer;
    RPC_STATUS Status;
    ULONG SizeToAlloc;
    ULONG MaxFrag = Connection->MaxFrag;

    if (NewSize > ActualBufferLength)
        {
        SizeToAlloc = (NewSize > MaxFrag) ? NewSize:MaxFrag;

        Status = ActuallyAllocateBuffer(&TempBuffer,
                              SizeToAlloc
                              + sizeof(rpcconn_request) + sizeof(UUID)
                              + (2 * Connection->AdditionalSpaceForSecurity));

        if ( Status != RPC_S_OK )
            {
            ASSERT( Status == RPC_S_OUT_OF_MEMORY );
            return(RPC_S_OUT_OF_MEMORY);
            }

        ASSERT(HeaderSize != 0);
        //
        // N.B. Potentially, if we could return ActualBufferLength
        // in NewSize, the stubs can take advantage of that and gain
        // perf.
        //
        if (UuidSpecified)
            {
            TempBuffer = (char  *) TempBuffer
                                        + sizeof(rpcconn_request)
                                        + sizeof(UUID);
            }
        else
            {
            TempBuffer = (char  *) TempBuffer
                                        + sizeof(rpcconn_request);
            }

        if (Message->BufferLength > 0)
            {
            RpcpMemoryCopy(TempBuffer, Message->Buffer,
                                      Message->BufferLength);
            FreePipeBuffer(Message);
            }

        Message->Buffer = TempBuffer;
        ActualBufferLength = SizeToAlloc;
        }

    Message->BufferLength = NewSize;

    return (RPC_S_OK);
}


void
OSF_CCALL::FreeCCall (
    IN RPC_STATUS Status
    )
/*++

Routine Description:

    This routine is used to free a connection when the original remote
    procedure call using it completes.

--*/
{
    void  *Buffer;
    UINT BufferLength;
    OSF_BINDING_HANDLE *MyBindingHandle;
    ULONG Timeout;

    ASSERT(BindingHandle != 0);

    LogEvent(SU_CCALL, EV_DELETE, this, NULL, Status, 1, 1);

    if (EEInfo)
        {
        ASSERT(pAsync);
        ASSERT(RpcpGetEEInfo() == NULL);

        // move the eeinfo to the thread
        RpcpSetEEInfo(EEInfo);
        EEInfo = NULL;
        }

    //
    // Empty the buffer queue and nuke the buffers
    //
    while (Buffer = BufferQueue.TakeOffQueue(&BufferLength))
        {
        if (InReply)
            {
            ActuallyFreeBuffer((char *) Buffer-sizeof(rpcconn_request));
            }
        else
            {
            FreeBufferDo(Buffer);
            }
        }

    if (RecursiveCallsKey != -1)
        {
        BindingHandle->RemoveRecursiveCall(this);
        }

    //
    // We will not send an Orphan PDU if the call was cancelled
    // This is because, we are going to close the connection anyway
    // When a connection close is received while a call is in progress,
    // it is treated as an orphan
    //
    MyBindingHandle = BindingHandle;
    BindingHandle = 0;


    //
    // N.B. If this call failed with a fatal error, we will nuke the connection
    // and all calls after it.
    //

    //
    // If its been this long and we are still the current call,
    // we need to advance the call
    //
    Connection->MaybeAdvanceToNextCall(this);

    //
    // release this CCall to the connection
    //
    if (MyBindingHandle)
        Timeout = MyBindingHandle->InqComTimeout();
    else
        Timeout = 0;

    Connection->FreeCCall(this, 
        Status,
        Timeout) ;

    //
    // The ref count on the binding handle
    // needs to be decremented if the binding handle is still there
    //
    if (MyBindingHandle)
        MyBindingHandle->BindingFree();

}

#if 1

RPC_STATUS
OSF_CCALL::Cancel(
    void * ThreadHandle
    )
{
    fCallCancelled = TRUE;
    return RPC_S_OK;
}
#else

RPC_STATUS
OSF_CCALL::Cancel(
    void * Tid
    )
{
    RPC_STATUS Status;
    Cancelled = TRUE;
    Status = I_RpcIOAlerted((OSF_CCONNECTION *)this,(DWORD)Tid);
    return RPC_S_OK;
}
#endif


RPC_STATUS
OSF_CCALL::CancelAsyncCall (
    IN BOOL fAbort
    )
/*++
Function Name:CancelAsyncCall

Parameters:
    fAbort - TRUE: the cancel is abortive, ie, the call completes immediately
                FALSE: a cancel PDU is sent to the server, the call doesn't complete
                until the server returns

Description:

Returns:
    RPC_S_OK: The call was successfully cancelled
    others - an error occured during the cancellation process
--*/
{
    RPC_STATUS Status;

    // The EEInfo that may be sitting on this thread could have
    // nothing to do with the the async call that we are about to cancel.
    RpcpPurgeEEInfo();

    switch (CurrentState)
        {
        case NeedOpenAndBind:
        case NeedAlterContext:
        case WaitingForAlterContext:
            //
            // The call has not yet started
            // fail the call right now
            //

            CallFailed(RPC_S_CALL_CANCELLED);
            break;

        case Aborted:
        case Complete:
            //
            // The call has either failed or has completed
            // we don't need to do anything
            //
            break;

        default:
            //
            // The call is in progress, we need to cancel it.
            //
            if (fAbort)
                {
                SendOrphanPDU();
                CallFailed(RPC_S_CALL_CANCELLED);
                }
            else
                {
                return SendCancelPDU();
                }
        }

    return RPC_S_OK;
}

RPC_STATUS 
OSF_CCALL::BindCompleteNotify (
    IN p_result_t *OsfResult, 
    IN int IndexOfPresentationContextAccepted,
    OUT OSF_BINDING **BindingNegotiated
    )
/*++
Function Name:BindCompleteNotify

Parameters:
    OsfResult - The one and only result element that contained acceptance
    IndexOfPresentationContextAccepted - the index of the accepted
        presentation context. Recall that the server indicates acceptance
        by position.
    BindingNegotiated - on success for multiple bindings proposed, the 
        pointer to the OSF binding that the server chose. On failure, or if 
        only one binding is proposed, it is undefined.

Description:
    Examines the accepted context, does a bunch of validity checks, and
    if necessary, fixes the binding which the call will use. If the binding
    is already fixed, it won't touch it.

Returns:
    RPC_S_OK: The acceptance is valid, and the call binding was fixed
    others: error code
--*/
{
    int CurrentBindingIndex;

    if (Bindings.AvailableBindingsList == FALSE)
        {
        // only one binding was proposed - it better be accepted
        if (GetSelectedBinding()->CompareWithTransferSyntax(&OsfResult->transfer_syntax) != 0)
            {
            return RPC_S_PROTOCOL_ERROR;
            }

        if (IndexOfPresentationContextAccepted > 0)
            return RPC_S_PROTOCOL_ERROR;
        }
    else
        {
        OSF_BINDING *CurrentBinding = GetBindingList();
        OSF_BINDING *BindingToUse;

        // multiple bindings were proposed - lookup the binding that
        // the server chose, fix our binding and record the server
        // preferences
        BindingToUse = 0;
        CurrentBindingIndex = 0;
        do
            {
            if (CurrentBinding->CompareWithTransferSyntax(&OsfResult->transfer_syntax) == 0)
                {
                BindingToUse = CurrentBinding;
                break;
                }
            CurrentBinding = CurrentBinding->GetNextBinding();
            CurrentBindingIndex ++;
            }
        while (CurrentBinding != 0);

        if (BindingToUse == 0)
            {
            ASSERT(0);
            // if the transfer syntax approved is none of the transfer syntaxes we suggested
            // this is a protocol error
            return RPC_S_PROTOCOL_ERROR;
            }

        if (CurrentBindingIndex != IndexOfPresentationContextAccepted)
            {
            ASSERT(0);
            // if server did choose a transfer syntax from a different p_cont_elem_t,
            // this is a protocol error
            return RPC_S_PROTOCOL_ERROR;
            }

        // we have suggested multiple syntaxes, and the server picked one of them - record
        // the server preferences. Instead of just setting the preference on the binding
        // the server chose, we need to walk the list, and reset the preferences on the
        // other bindings, to handle mixed cluster scenario case, where the server
        // preferences actually change
        BindingToUse->TransferSyntaxIsServerPreferred();
        CurrentBinding = GetBindingList();
        do
            {
            if (CurrentBinding != BindingToUse)
                CurrentBinding->TransferSyntaxIsNotServerPreferred();

            CurrentBinding = CurrentBinding->GetNextBinding();
            }
        while (CurrentBinding != 0);

        Bindings.AvailableBindingsList = 0;
        if (Bindings.SelectedBinding == NULL)
            {
            Bindings.SelectedBinding = BindingToUse;
            }

        *BindingNegotiated = BindingToUse;

        DispatchTableCallback = BindingToUse->GetDispatchTable();
        }
    return RPC_S_OK;
}


OSF_CASSOCIATION::OSF_CASSOCIATION (
    IN DCE_BINDING * DceBinding,
    IN TRANS_INFO *TransInfo,
    IN OUT RPC_STATUS  * Status
    ) : AssociationMutex(Status), 
        CallIdCounter(1),
        BindHandleCount(1)
/*++

Routine Description:

    We construct a OSF_CASSOCIATION object in this routine.  This consists
    of initializing some instance variables, and saving the parameters
    away.

Arguments:

    DceBinding - Supplies the binding information for this association.
        Ownership of this data passes to this object.

    RpcClientInfo - Supplies the information necessary to use the loadable
        transport corresponding to the network interface type used by
        this association.

--*/
{
    ALLOCATE_THIS(OSF_CASSOCIATION);

    LogEvent(SU_CASSOC, EV_START, this, 0, 0, 1, 0);

    ObjectType = OSF_CASSOCIATION_TYPE;
    AssocGroupId = 0;

    this->DceBinding = DceBinding;
    this->TransInfo = TransInfo;

    SecondaryEndpoint = 0;
    OpenConnectionCount = 0;
    ConnectionsDoingBindCount = 0;
    fPossibleServerReset = 0;

    ResolverHintInitialized = FALSE;
    DontLinger = FALSE;

    MaintainContext = 0;

    AssociationValid = TRUE;
    FailureCount = 0;
    fMultiplex = mpx_unknown;
    SetReferenceCount(1);
    SavedDrep = 0;

    fIdleConnectionCleanupNeeded = FALSE;

    Linger.fAssociationLingered = FALSE;
}

OSF_CASSOCIATION::~OSF_CASSOCIATION (
    )
{
    OSF_BINDING * Binding;
    DictionaryCursor cursor;

    if (ResolverHintInitialized)
        {
        FreeResolverHint(InqResolverHint());
        }

    if (DceBinding != 0)
       {
       delete DceBinding;
       }

    Bindings.Reset(cursor);
    while ((Binding = Bindings.Next(cursor)))
        delete Binding;

    if ( SecondaryEndpoint != 0 )
        {
        delete SecondaryEndpoint;
        }

    if (fIdleConnectionCleanupNeeded)
        {
        if (InterlockedDecrement(&PeriodicGarbageCollectItems) == 0)
            {
#if defined (RPC_GC_AUDIT)
            DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) PeriodicGarbageCollectItems dropped to 0\n",
                GetCurrentProcessId(), GetCurrentProcessId());
#endif
            }
        }
}


void
OSF_CASSOCIATION::NotifyConnectionOpen (
    )
/*++
Function Name:NotifyConnectionOpen

Parameters:

Description:

Returns:

--*/
{
    AssociationMutex.VerifyOwned();

    OpenConnectionCount++;
    LogEvent(SU_CASSOC, EV_INC, this, 0, OpenConnectionCount, 1, 1);
}


void
OSF_CASSOCIATION::NotifyConnectionClosed (
    )
/*++

Routine Description:

    This routine is necessary so that we can know when to set the association
    group id back to zero.  We do this when no more connections owned by
    this association can possibly be connected with the server.

--*/
{
    AssociationMutex.Request();

    ASSERT( OpenConnectionCount > 0 );
    OpenConnectionCount -= 1;

    LogEvent(SU_CASSOC, EV_DEC, this, 0, OpenConnectionCount, 1, 1);
    if ( OpenConnectionCount == 0 )
        {
        if (ConnectionsDoingBindCount == 0)
            {
            LogEvent(SU_CASSOC, EV_NOTIFY, this, ULongToPtr(OpenConnectionCount), 0, 1, 0);
            if (IsValid())
                {
                // don't reset invalid associations
                ResetAssociation();
                }
            }
        else
            {
            if (IsValid())
                {
                // don't signal possible reset on invalid associations - this will
                // cause more retries
                fPossibleServerReset = TRUE;
                }
            }
        }
    AssociationMutex.Clear();
}

void 
OSF_CASSOCIATION::NotifyConnectionBindInProgress (
    void
    )
{
    AssociationMutex.VerifyOwned();

    ConnectionsDoingBindCount ++;

    LogEvent(SU_CASSOC, EV_INC, this, (PVOID)1, ConnectionsDoingBindCount, 1, 1);
}

void 
OSF_CASSOCIATION::NotifyConnectionBindCompleted (
    void
    )
{
    AssociationMutex.VerifyOwned();

    ConnectionsDoingBindCount --;

    LogEvent(SU_CASSOC, EV_DEC, this, (PVOID)1, ConnectionsDoingBindCount, 1, 1);
    if (ConnectionsDoingBindCount == 0)
        {
        if (OpenConnectionCount == 0)
            {
            LogEvent(SU_CASSOC, EV_NOTIFY, this, ULongToPtr(OpenConnectionCount), ConnectionsDoingBindCount, 1, 0);
            if (IsValid())
                {
                // don't reset invalid associations
                ResetAssociation();
                }
            }
        else
            {
            if (IsValid())
                {
                // don't signal possible reset on invalid associations - this will
                // cause more retries
                fPossibleServerReset = FALSE;
                }
            }
        }
}

RPC_STATUS
OSF_CASSOCIATION::ProcessBindAckOrNak (
    IN rpcconn_common  * Buffer,
    IN UINT BufferLength,
    IN OSF_CCONNECTION * CConnection,
    IN OSF_CCALL *CCall,
    OUT ULONG *NewGroupId,
    OUT OSF_BINDING **BindingNegotiated,
    OUT FAILURE_COUNT_STATE *fFailureCountExceeded
    )
/*++

Routine Description:

Arguments:

    Buffer - Supplies the buffer containing either the bind_ack, bind_nak,
        or alter_context_resp packet.

    BufferLength - Supplies the length of the buffer, less the length of
        the authorization information.

    CConnection - Supplies the connection from which we received the packet.

    CCall - the call for which the bind is done.

    NewGroupId - if the bind was successful the new association group id
        will be returned.

    BindingNegotiated - The binding that was negotiated in the case of 
        success and multiple proposed bindings. Undefined if there is
        failure, or if only one binding was proposed.

    fFailureCountExceeded - if supplied, must be FailureCountUnknown. If
        we got bind failure with reason not specified, and we haven't
        exceeded the failure count, it will be set to 
        FailureCountNotExceeded. If we received bind failure with reason
        not specified and the failure count is exceeded, it will be set
        to FailureCountExceeded.

Return Value:

    RPC_S_OK - The client has successfully bound with the server.

    RPC_S_PROTOCOL_ERROR - The packet received from the server does not
        follow the protocol.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to make a
        copy of the secondary endpoint.

    RPC_S_UNSUPPORTED_TRANS_SYN - The transfer syntax supplied by the client
        is not supported by the server.

    RPC_S_UNKNOWN_IF - The interface to which the client wished to bind is not
        supported by the server.

    RPC_S_SERVER_TOO_BUSY - The server is too busy to accept the clients
        bind request.

    RPC_S_UNKNOWN_AUTHN_TYPE - The server does not support the authentication
        type specified by the client.

--*/
{
    rpcconn_bind_ack  *pBindAck;
    rpcconn_bind_nak  *pBindNak;
    p_result_list_t  *pResults;
    int port_spec_plus_pad;
    UINT SecondaryEndpointLength;
    unsigned char  * Pointer;
    RPC_STATUS Status;
    int NumberOfResultElements;
    int i;
    BOOL fConvertEndian;
    int PresentationContextAccepted;

    if (ARGUMENT_PRESENT(fFailureCountExceeded))
        {
        ASSERT(*fFailureCountExceeded == FailureCountUnknown);
        }

    AssociationMutex.VerifyOwned();

    SavedDrep = (Buffer->drep[0]| (Buffer->drep[1] << 8));

    //
    // The common header of the packet has already been validated and data
    // converted, if necessary, by whoever called this method.
    //

    if (   (Buffer->PTYPE == rpc_bind_ack)
        || (Buffer->PTYPE == rpc_alter_context_resp))
        {
        FailureCount = 0;

        //
        // The bind_ack and alter_context_resp packets are the same.
        //

        pBindAck = (rpcconn_bind_ack  *) Buffer;

        //
        // We need to convert the max_xmit_frag, max_recv_frag, and
        // assoc_group_id fields of the packet.
        //

        if ( DataConvertEndian(Buffer->drep) != 0 )
            {
            pBindAck->max_xmit_frag = RpcpByteSwapShort(pBindAck->max_xmit_frag);
            pBindAck->max_recv_frag = RpcpByteSwapShort(pBindAck->max_recv_frag);
            pBindAck->assoc_group_id = RpcpByteSwapLong(pBindAck->assoc_group_id);
            pBindAck->sec_addr_length = RpcpByteSwapShort(pBindAck->sec_addr_length);
            }

        if ( Buffer->PTYPE == rpc_bind_ack )
            {
            if (Buffer->pfc_flags & PFC_CONC_MPX)
                {
                fMultiplex = mpx_yes;
                }

            CConnection->SetMaxFrag(pBindAck->max_xmit_frag,
                                           pBindAck->max_recv_frag);
            }

        BufferLength -= sizeof(rpcconn_bind_ack);
        Pointer = (unsigned char  *) (pBindAck + 1);

        if ( pBindAck->sec_addr_length )
            {
            SecondaryEndpointLength = pBindAck->sec_addr_length;

            //
            // The secondary address length is two bytes long.  We want
            // to align the total of the secondary address length itself,
            // the the secondary address.  Hence, the length of the secondary
            // address and the necessary pad is calculated below.  Think
            // very carefully before changing this piece of code.
            //

            port_spec_plus_pad = SecondaryEndpointLength +
                                 Pad4(SecondaryEndpointLength + 2);

            if ( BufferLength < (UINT) port_spec_plus_pad )
                {
                return(RPC_S_PROTOCOL_ERROR);
                }

            #if 0

            if ( SecondaryEndpoint != 0 )
                {
                delete SecondaryEndpoint;
                }

            SecondaryEndpoint = new unsigned char[SecondaryEndpointLength];

            if ( SecondaryEndpoint == 0 )
                return(RPC_S_OUT_OF_MEMORY);

            RpcpMemoryCopy(SecondaryEndpoint, Pointer, SecondaryEndpointLength);
            if ( DataConvertCharacter(Buffer->drep) != 0 )
                {
                ConvertStringEbcdicToAscii(SecondaryEndpoint);
                }

            #endif

            BufferLength -= port_spec_plus_pad;
            Pointer = Pointer + port_spec_plus_pad;
            }
        else
            {
            Pointer = Pointer + 2;
            BufferLength -= 2;
            }

        pResults = (p_result_list_t *) Pointer;

        // the buffer must have at least as much results as it claims to have
        NumberOfResultElements = pResults->n_results;
        if (BufferLength < sizeof(p_result_list_t) + sizeof(p_result_t) * (NumberOfResultElements - 1))
            {
            return(RPC_S_PROTOCOL_ERROR);
            }

        PresentationContextAccepted = -1;
        fConvertEndian = DataConvertEndian(Buffer->drep);

        // we walk through the list of elements, and see which ones are accepted, and which
        // ones are rejected. If we have at least one accepted, the bind succeeds. If all are
        // rejected, we arbitrarily pick the first error code and declare it the cause of
        // the failure. Note that according to DCE spec, it is not a protocol error to
        // have a bind ack and no presentation contexts accepted
        for (i = 0; i < NumberOfResultElements; i ++)
            {
            if (fConvertEndian)
                {
                pResults->p_results[i].result = RpcpByteSwapShort(pResults->p_results[i].result);
                pResults->p_results[i].reason = RpcpByteSwapShort(pResults->p_results[i].reason);
                ByteSwapSyntaxId(&(pResults->p_results[i].transfer_syntax));
                }

            if ( pResults->p_results[i].result == acceptance )
                {
                // currently we can handle at most one acceptance. Everything else
                // is a protocol error. This is fine since we know only we will
                // propose NDR64, and any third party should accept at most NDR20
                // Our servers will always choose exactly one
                if (PresentationContextAccepted >= 0)
                    return RPC_S_PROTOCOL_ERROR;
                PresentationContextAccepted = i;
                }
            }

        if (PresentationContextAccepted < 0)    // faster version of == -1
            {
            if ( pResults->p_results[0].result != provider_rejection )
                {
                return(RPC_S_CALL_FAILED_DNE);
                }

            switch (pResults->p_results[0].reason)
                {
                case abstract_syntax_not_supported:
                    return(RPC_S_UNKNOWN_IF);

                case proposed_transfer_syntaxes_not_supported:
                    return(RPC_S_UNSUPPORTED_TRANS_SYN);

                case local_limit_exceeded:
                    return(RPC_S_SERVER_TOO_BUSY);

                default:
                    return(RPC_S_CALL_FAILED_DNE);
                }
            }

        // we have bound successfully. Notify the call so that
        // it can fix what binding it will use
        Status = CCall->BindCompleteNotify(
            &pResults->p_results[PresentationContextAccepted],
            PresentationContextAccepted,
            BindingNegotiated);
        if (Status != RPC_S_OK)
            return Status;

        *NewGroupId = pBindAck->assoc_group_id;

        return RPC_S_OK;
        }

    if (Buffer->PTYPE == rpc_bind_nak)
        {
        if (BufferLength < MinimumBindNakLength)
            {
            RpcpErrorAddRecord (EEInfoGCRuntime,
                RPC_S_PROTOCOL_ERROR,
                EEInfoDLOSF_CASSOCIATION__ProcessBindAckOrNak10,
                (ULONG)BufferLength,
                (ULONG)MinimumBindNakLength);

            return(RPC_S_PROTOCOL_ERROR);
            }

        pBindNak = (rpcconn_bind_nak  *) Buffer;

        if ( DataConvertEndian(Buffer->drep) != 0 )
            {
            pBindNak->provider_reject_reason = RpcpByteSwapShort(pBindNak->provider_reject_reason);
            }

        if (pBindNak->common.frag_length > BindNakSizeWithoutEEInfo)
            {
            if (RpcpMemoryCompare(&pBindNak->Signature, BindNakEEInfoSignature, sizeof(UUID)) == 0)
                {
                UnpickleEEInfoFromBuffer(pBindNak->buffer,
                    GetEEInfoSizeFromBindNakPacket(pBindNak));
                }
            }

        if (   (pBindNak->provider_reject_reason == temporary_congestion)
            || (pBindNak->provider_reject_reason
                    == local_limit_exceeded_reject))
            {
            Status = RPC_S_SERVER_TOO_BUSY;
            }
        else if ( pBindNak->provider_reject_reason
                    == protocol_version_not_supported )
            {
            Status = RPC_S_PROTOCOL_ERROR;
            }
        else if ( pBindNak->provider_reject_reason
                    == authentication_type_not_recognized )
            {
            Status = RPC_S_UNKNOWN_AUTHN_SERVICE;
            }

        else if ( pBindNak->provider_reject_reason
                    == invalid_checksum )
            {
            Status = RPC_S_ACCESS_DENIED;
            }
        else
            {
            FailureCount++;
            if (FailureCount >= 40)
                {
                LogEvent(SU_CASSOC, EV_ABORT, this, 0, FailureCount, 1, 0);
                AssociationValid = FALSE;
                AssociationShutdownError = RPC_S_CALL_FAILED_DNE;
                if (ARGUMENT_PRESENT(fFailureCountExceeded))
                    *fFailureCountExceeded = FailureCountExceeded;
                }
            else if (ARGUMENT_PRESENT(fFailureCountExceeded))
                {
                *fFailureCountExceeded = FailureCountNotExceeded;
                }

            Status = RPC_S_CALL_FAILED_DNE;
            }

        RpcpErrorAddRecord(EEInfoGCRuntime,
            Status,
            EEInfoDLOSF_CASSOCIATION__ProcessBindAckOrNak20,
            (ULONG)pBindNak->provider_reject_reason,
            (ULONG)FailureCount);

        return (Status);
        }

    return(RPC_S_PROTOCOL_ERROR);
}

void
OSF_CASSOCIATION::UnBind (
    )
{
    OSF_CCONNECTION * CConnection;
    BOOL fWillLinger = FALSE;
    DWORD OldestAssociationTimestamp;
    OSF_CASSOCIATION *CurrentAssociation;
    OSF_CASSOCIATION *OldestAssociation = NULL;
    BOOL fEnableGarbageCollection = FALSE;
    DictionaryCursor cursor;
    RPC_CHAR *NetworkAddress;
    long LocalBindHandleCount;

    LogEvent(SU_CASSOC, EV_DEC, this, (PVOID)2, BindHandleCount.GetInteger(), 1, 0);
    LocalBindHandleCount = BindHandleCount.Decrement();

    if (LocalBindHandleCount == 0)
        {
        // we don't linger remote named pipes, as sometimes this results in
        // credentials conflict
        NetworkAddress = DceBinding->InqNetworkAddress();
        if ((OpenConnectionCount > 0) 
             && 
             AssocGroupId 
             && 
             AssociationValid 
             &&
             (!DontLinger)
             &&
             ( 
                (NetworkAddress == NULL)
                ||
                (NetworkAddress[0] == 0)
                ||
                (!DceBinding->IsNamedPipeTransport())
             )
           )
            {
            if (IsGarbageCollectionAvailable())
                {
                if (OsfLingeredAssociations >= MaxOsfLingeredAssociations)
                    {
                    OldestAssociationTimestamp = ~(DWORD)0;

                    // need to walk the dictionary and clean up the oldest item
                    AssociationDict->Reset(cursor);
                    while ((CurrentAssociation = AssociationDict->Next(cursor)) != 0)
                        {
                        if (CurrentAssociation->Linger.fAssociationLingered)
                            {
                            // yes, if the tick count wraps around, we may make a
                            // suboptimal decision and destroy a newer lingering
                            // association. That's ok - it will be a slight perf hit once
                            // every ~47 days - it won't be a bug
                            if (OldestAssociationTimestamp > CurrentAssociation->Linger.Timestamp)
                                {
                                OldestAssociation = CurrentAssociation;
                                }
                            }
                        }

                    // there must be an oldest association here
                    ASSERT(OldestAssociation);
                    AssociationDict->Delete(OldestAssociation->Key);
                    OldestAssociation->Key = -1;

                    // no need to update OsfLingeredAssociations - we removed one,
                    // but we add one, so the balance is the same

                    }
                else
                    {
                    OsfLingeredAssociations ++;
                    ASSERT(OsfLingeredAssociations <= MaxOsfLingeredAssociations);
                    }

                Linger.Timestamp = GetTickCount() + gThreadTimeout;
                Linger.fAssociationLingered = TRUE;

                fWillLinger = TRUE;

                // Add one artifical reference. Once we release the AssocDictMutex,
                // a gc thread can come in and nuke the association, and if we
                // decide that we cannot do garbage collecting below and decide
                // to shutdown the association we may land on a freed object
                // CASSOC++
                OSF_CASSOCIATION::AddReference();
                }
            else
                {
                // good association, but can't linger it, because gc is not available
                // let's see if we can turn it on
                OsfDestroyedAssociations ++;
                fEnableGarbageCollection = CheckIfGCShouldBeTurnedOn(
                    OsfDestroyedAssociations, 
                    NumberOfOsfDestroyedAssociationsToSample,
                    DestroyedOsfAssociationBatchThreshold,
                    &OsfLastDestroyedAssociationsBatchTimestamp
                    );

                }
            }

        if (!fWillLinger)
            {
            AssociationDict->Delete(Key);
            }

        AssocDictMutex->Clear();

        if (!fWillLinger)
            {
            AssociationValid = FALSE;

            LogEvent(SU_CASSOC, EV_STOP, this, 0, 0, 1, 0);
            ShutdownRequested(RPC_S_CALL_FAILED_DNE, NULL);
            }

        AssociationMutex.Clear();

        if (OldestAssociation)
            {
#if defined (RPC_GC_AUDIT)
            int Diff;

            Diff = (int)(GetTickCount() - OldestAssociation->Linger.Timestamp);
            DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) OSF association sync gc'ed %d ms after expire\n",
                GetCurrentProcessId(), GetCurrentProcessId(), Diff);
#endif
            OldestAssociation->AssociationMutex.Request();
            OldestAssociation->AssociationValid = FALSE;

            OldestAssociation->ShutdownRequested(RPC_S_CALL_FAILED_DNE, NULL);

            OldestAssociation->AssociationMutex.Clear();

            OldestAssociation->OSF_CASSOCIATION::RemoveReference();
            }

        if (!fWillLinger)
            {
            // CASSOC--
            OSF_CASSOCIATION::RemoveReference();
            // N.B. If fWillLinger is FALSE, don't touch the this pointer
            // after here
            }

        if (fEnableGarbageCollection)
            {
            // ignore the return value - we'll make a best effort to
            // create the thread, but if there's no memory, that's
            // still ok as the garbage collection thread only
            // provides better perf in this case
            (void) CreateGarbageCollectionThread();
            }

        if (fWillLinger)
            {
            fWillLinger = GarbageCollectionNeeded(TRUE, gThreadTimeout);
            if (fWillLinger == FALSE)
                {
                // uh-oh - we couldn't register for garbage collection - probably
                // extremely low on memory. If nobody has picked us up in the meantime, 
                // delete this association. Otherwise, let it go - somebody is using
                // it and we don't need to worry about gc'ing it. We also need to guard
                // against the gc thread trying to do Delete on this also. If it does
                // so, it will set the Key to -1 before it releases 
                // the mutex - therefore we can check for this. A gc thread cannot
                // completely kill the object as we will hold one reference on it
                AssocDictMutex->Request();
                if ((Linger.fAssociationLingered) && (Key != -1))
                    {
                    OsfLingeredAssociations --;
                    ASSERT(OsfLingeredAssociations >= 0);
                    AssociationDict->Delete(Key);
                    Key = -1;

                    AssociationShutdownError = RPC_S_CALL_FAILED_DNE;
                    AssociationValid = FALSE;

                    AssocDictMutex->Clear();

                    LogEvent(SU_CASSOC, EV_STOP, this, 0, 0, 1, 0);
                    ShutdownRequested(RPC_S_CALL_FAILED_DNE, NULL);

                    // CASSOC--
                    OSF_CASSOCIATION::RemoveReference();

                    }
                else
                    {
                    AssocDictMutex->Clear();
                    }
                }
#if defined (RPC_GC_AUDIT)
            else
                {
                DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) OSF association lingered %X\n",
                    GetCurrentProcessId(), GetCurrentProcessId(), this);
                }
#endif

            // Remove the artifical reference we added above
            // CASSOC--
            OSF_CASSOCIATION::RemoveReference();
            // N.B. don't touch the this pointer after here
            }
        }
    else
        {
        AssocDictMutex->Clear();
        AssociationMutex.Clear();
        }
}


RPC_STATUS
OSF_CASSOCIATION::FindOrCreateOsfBinding (
    IN PRPC_CLIENT_INTERFACE RpcInterfaceInformation,
    IN RPC_MESSAGE *Message,
    OUT int *NumberOfBindings,
    IN OUT OSF_BINDING *BindingsForThisInterface[]
    )
/*++

Routine Description:

    This method gets called to find the osf bindings (a dictionary
    entry) corresponding to the specified rpc interface information.
    The caller of this routine must be holding (ie. requested) the
    association mutex.

Arguments:

    RpcInterfaceInformation - Supplies the interface information for
        which we are looking for an osf binding object.
    Message - supplies the RPC_MESSAGE for this call
    NumberOfBindings - an out parameter that will return the number
        of retrieved bindings
    BindingsForThisInterface - a caller supplied array where the
        found bindings will be placed.

Return Value:

    RPC_S_OK for success, other for failure

--*/
{
    BOOL Ignored[MaximumNumberOfTransferSyntaxes];
    AssociationMutex.VerifyOwned();

    return MTSyntaxBinding::FindOrCreateBinding(RpcInterfaceInformation,
        Message, &Bindings, CreateOsfBinding, NumberOfBindings,
        (MTSyntaxBinding **)BindingsForThisInterface, Ignored);
}

BOOL
OSF_CASSOCIATION::DoesBindingForInterfaceExist (
    IN PRPC_CLIENT_INTERFACE RpcInterfaceInformation
    )
/*++

Routine Description:

    Checks if an association supports a binding for this interface.

Arguments:

    RpcInterfaceInformation - Supplies the interface information for
        which we are looking for an osf binding object.

Return Value:

    FALSE if it doesn't. Non-zero if it does.

--*/
{
    OSF_BINDING *Binding;
    DictionaryCursor cursor;
    BOOL fRetVal = FALSE;
    BOOL Result;

    // if we are not in lsa, just ask for the mutex. If we are (or may be)
    // we have some more work to do. We can't directly ask for the mutex
    // since we may deadlock. In lsa the security providers can make RPC
    // calls from within the security context establishment routine. If
    // they do, they will hold an association mutex, and ask for the
    // association dict mutex within the inner RPC call. This thread
    // already holds the assoc dict mutex and will ask for the assoc
    // mutex (reverse order) causing a deadlock. Since this routine
    // is used only to shortcut remote endpoint resolution, and as
    // optimization, in lsa, if we can't get the mutex, we forego the
    // optimization and return not found. This will cause caller to
    // do remote endpoint resolution
    if (!fMaybeLsa)
        {
        AssociationMutex.Request();
        }
    else
        {
        Result = AssociationMutex.TryRequest();
        if (!Result)
            return FALSE;
        }

    Bindings.Reset(cursor);
    while ((Binding = Bindings.Next(cursor)) != 0)
        {
        // if we have a binding on the same interface,
        // return TRUE
        if (RpcpMemoryCompare(Binding->GetInterfaceId(), 
            &RpcInterfaceInformation->InterfaceId,
            sizeof(RPC_SYNTAX_IDENTIFIER)) == 0)
            {
            fRetVal = TRUE;
            break;
            }
        }

    AssociationMutex.Clear();

    return fRetVal;
}

void
OSF_CASSOCIATION::ShutdownRequested (
    IN RPC_STATUS AssociationShutdownError OPTIONAL,
    IN OSF_CCONNECTION *ExemptConnection OPTIONAL
    )
/*++

Routine Description:

    Aborts all connections in the association, except the Exempt
    connection, and marks the association as invalid.

Arguments:

    AssociationShutdownError - the error with which the association
        is to be shutdown

    ExemptConnection - an optional pointer to a connection which
        is not to be aborted.

--*/
{
    OSF_CCONNECTION * CConnection;
    DictionaryCursor cursor;
    BOOL fDontKill;
    BOOL fExemptConnectionSkipped = FALSE;

    AssociationMutex.Request();

    if (!ExemptConnection)
        {
        ASSERT(AssociationShutdownError != RPC_S_OK);
        LogEvent(SU_CASSOC, EV_STOP, this, 0, 0, 1, 0);
        // we will abort all connections - the association is invalid
        // mark it as such
        AssociationValid = FALSE;
        this->AssociationShutdownError = AssociationShutdownError;
        }

    ActiveConnections.Reset(cursor);
    while ((CConnection = ActiveConnections.Next(cursor)) != NULL)
        {
        if (CConnection == ExemptConnection)
            {
            fExemptConnectionSkipped = TRUE;
            continue;
            }

        fDontKill = ConnectionAborted(CConnection);

        if (fDontKill == FALSE)
            {
            // CCONN++
            CConnection->AddReference();

            CConnection->DeleteConnection();

            // CCONN--
            CConnection->RemoveReference();
            }
        }

    if (ExemptConnection)
        {
        ASSERT(fExemptConnectionSkipped);
        }

    // if at least one connection wasn't aborted, the association
    // is still valid - it just needs resetting
    if (ExemptConnection)
        ResetAssociation();

    AssociationMutex.Clear();
}


RPC_STATUS
OSF_CASSOCIATION::ToStringBinding (
    OUT RPC_CHAR  *  * StringBinding,
    IN RPC_UUID * ObjectUuid
    )
/*++

Routine Description:

    We need to convert the binding handle into a string binding.  If the
    binding handle has not yet been used to make a remote procedure
    call, then we can just use the information in the binding handle to
    create the string binding.  Otherwise, we need to ask the association
    to do it for us.

Arguments:

    StringBinding - Returns the string representation of the binding
        handle.

    ObjectUuid - Supplies the object uuid of the binding handle which
        is requesting that we create a string binding.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_OUT_OF_MEMORY - We do not have enough memory available to
        allocate space for the string binding.

--*/
{
    *StringBinding = DceBinding->StringBindingCompose(ObjectUuid);
    if (*StringBinding == 0)
        return(RPC_S_OUT_OF_MEMORY);
    return(RPC_S_OK);
}


int
OSF_CASSOCIATION::CompareWithDceBinding (
    IN DCE_BINDING * DceBinding,
    OUT BOOL *fOnlyEndpointDifferent
    )
/*++

Routine Description:

    This routine compares the specified binding information with the
    binding information in the object, this.

Arguments:

    DceBinding - Supplies the binding information to compare against
        the binding information in this.

    fOnlyEndpointDiffers - this output variable will be set to TRUE
        if the result is non-zero and only the endpoint is different.
        It will be set to FALSE if the result is non-zero, and there
        is more than the endpoint different. If this function returns
        0, the fOnlyEndpointDiffers argument is undefined.

Return Value:

    Zero will be returned if the specified binding information,
    DceBinding, is the same as in this.  Otherwise, non-zero will be
    returned.

--*/
{
    int Result;

    if ((Result = this->DceBinding->Compare(DceBinding, fOnlyEndpointDifferent)) != 0)
        return(Result);


    return(0);
}


OSF_CCONNECTION *
OSF_CASSOCIATION::FindIdleConnection (
    void
    )
/*++

Routine Description:

    This routine is used to find a connection which has been idle more
    than the minimum number of seconds specified.  If one is found, it
    is removed from the set of free connections and returned.  The
    association dict mutex will be held when this routine is called.

Arguments:

Return Value:

    If one or more idle connections are found, the first will be returned. Next
    connections can be retrieved by following the u.NextConnection link until
    NULL is reached; if no connections are idle, NULL will be returned.

--*/
{
    OSF_CCONNECTION *CConnection;
    OSF_CCONNECTION *FirstConnection;
    BOOL fMutexTaken;
    BOOL fThreadCreated = 0;
    DictionaryCursor cursor;
    ULONG TickCount;
    ULONG ClientDisconnectTime;
#if defined (RPC_IDLE_CLEANUP_AUDIT)
    ULONG ConnectionsPickedForCleanup = 0;
#endif

    //
    // If we need to maintain context with server, we do not want to close
    // the last open connection.  To be on the safe side, we will make
    // sure that there is at least one free connection.
    //

    fMutexTaken = AssociationMutex.TryRequest();
    if (!fMutexTaken)
        {
#if defined (RPC_IDLE_CLEANUP_AUDIT)
        DbgPrintEx(77, DPFLTR_ERROR_LEVEL, "%d (0x%X) Association mutex busy - aborting\n",
            GetCurrentProcessId(), GetCurrentProcessId());
#endif
        return NULL;
        }

    if ( ActiveConnections.Size() <= 1 )
        {
        if ( (MaintainContext != 0) || (ActiveConnections.Size() == 0))
            {
            ClearIdleConnectionCleanupFlag();
            AssociationMutex.Clear();
            return(0);
            }
        }

    FirstConnection = NULL;

    if (ActiveConnections.Size() > AGGRESSIVE_TIMEOUT_THRESHOLD)
        {
        ClientDisconnectTime = CLIENT_DISCONNECT_TIME2;
        }
    else
        {
        ClientDisconnectTime = CLIENT_DISCONNECT_TIME1;
        }

#if defined (RPC_IDLE_CLEANUP_AUDIT)
    DbgPrintEx(77, DPFLTR_ERROR_LEVEL, "%d (0x%X) Dictionary size for assoc %p is %d. Using timeout %d\n",
        GetCurrentProcessId(), GetCurrentProcessId(), this, ActiveConnections.Size(), ClientDisconnectTime);
#endif

    ActiveConnections.Reset(cursor);
    while ( (CConnection = ActiveConnections.Next(cursor)) != 0 )
        {
        if (CConnection->ThreadId == SYNC_CONN_FREE
            || CConnection->ThreadId == ASYNC_CONN_FREE)
            {
            TickCount = NtGetTickCount();
            if ( CConnection->InquireLastTimeUsed() == 0 )
                {
                CConnection->SetLastTimeUsedToNow();
                }
            // TickCount is ULONG and InquireLastTimeUsed is ULONG
            // If the tick count has wrapped, the result will still
            // be valid. Note that even though it is not technically 
            // impossible that the cleanup is not called for ~47 
            // days, and the next time we're called the connection 
            // looks like just used, a call after that will still
            // timeout and destroy the connection. If the caller has
            // waited for 47 days, it will wait for 30 more seconds.
            else if ( TickCount - CConnection->InquireLastTimeUsed()
                    > ClientDisconnectTime )
                {
                if (!fThreadCreated)
                    {
                    RPC_STATUS Status;

                    Status = TransInfo->CreateThread();
                    if (Status != RPC_S_OK)
                        {
                        AssociationMutex.Clear();
                        return (0);
                        }
                    fThreadCreated = 1;
                    }

                // link all obtained connections on a list
                CConnection->u.NextConnection = FirstConnection;
                FirstConnection = CConnection;

                //
                // This reference will be removed by OsfDeleteIdleConnections, CCONN++
                //
                CConnection->AddReference();

                // remove the connection from the association dictionary so that nobody
                // picks it up
                ConnectionAborted(CConnection);

#if defined (RPC_IDLE_CLEANUP_AUDIT)
                ConnectionsPickedForCleanup ++;
#endif

                // are we up to the last connection?
                if ((ActiveConnections.Size() <= 1) && (MaintainContext != 0))
                    break;
                }
            }
        }

    AssociationMutex.Clear();

#if defined (RPC_IDLE_CLEANUP_AUDIT)
    DbgPrintEx(77, DPFLTR_ERROR_LEVEL, "%d (0x%X) Assoc %p - %d connections picked for cleanup\n",
        GetCurrentProcessId(), GetCurrentProcessId(), this, ConnectionsPickedForCleanup);
#endif

    return(FirstConnection);
}


void
OSF_CCONNECTION::OsfDeleteIdleConnections (
    void
    )
/*++

Routine Description:

    This routine will be called to delete connections which have been
    idle for a certain amount of time.  We need to be careful of a couple
    of things in writing this routine:

    (1) We dont want to grab the global mutex for too long, because this
        will prevent threads which are trying to do real work from doing
        it.

    (2) We dont want to be holding the global mutex when we delete the
        connection.

--*/
{
    OSF_CASSOCIATION *Association;
    OSF_CCONNECTION *FirstConnection;
    OSF_CCONNECTION *CurrentConnection;
    OSF_CCONNECTION *NextConnection;
    BOOL fMutexTaken;
    DictionaryCursor cursor;
    ULONG ClientDisconnectTime;

#if defined (RPC_IDLE_CLEANUP_AUDIT)
    DbgPrintEx(77, DPFLTR_ERROR_LEVEL, "%d (0x%X) Attempting OSF garbage collection\n",
        GetCurrentProcessId(), GetCurrentProcessId());
#endif

    fMutexTaken = AssocDictMutex->TryRequest();
    if (!fMutexTaken)
        {
#if defined (RPC_IDLE_CLEANUP_AUDIT)
        DbgPrintEx(77, DPFLTR_ERROR_LEVEL, "%d (0x%X) Association dict mutex busy - aborting\n",
            GetCurrentProcessId(), GetCurrentProcessId());
#endif
        return;
        }

    AssociationDict->Reset(cursor);
    while ( (Association = AssociationDict->Next(cursor)) != 0 )
        {
        //
        // The architecture says that the client should disconnect
        // connections which have been idle too long.
        //
        FirstConnection = Association->FindIdleConnection();

        if (FirstConnection != 0)
            {
            AssocDictMutex->Clear();

            CurrentConnection = FirstConnection;

            while (CurrentConnection != NULL)
                {
                NextConnection = CurrentConnection->u.NextConnection;

                Association->ConnectionAborted(CurrentConnection);

                CurrentConnection->DeleteConnection();

                // CCONN--
                CurrentConnection->RemoveReference();

                CurrentConnection = NextConnection;
                }

            fMutexTaken = AssocDictMutex->TryRequest();
            if (!fMutexTaken)
                return;
            }
        }
    AssocDictMutex->Clear();
}

RPC_STATUS
OSF_CCONNECTION::TurnOnOffKeepAlives (
    IN BOOL TurnOn,
    IN ULONG Time
    )
/*++

Routine Description:

    Turns on or off keepalives for the given connection

Arguments:

    TurnOn - if non-zero, keep alives will be turned on with
        a value appropriate for this transport. If zero, keep
        alives will be turned off

    Timeout - if TurnOn is not zero, the time scale after which
        to turn on keep alives. If TurnOn is zero this parameter
        is ignored. The time scale is in runtime unitsd - 
        RPC_C_BINDING_MIN_TIMEOUT to RPC_C_BINDING_MAX_TIMEOUT

Return Value:

    RPC_S_OK if the transport supports keep alives
    RPC_S_CANNOT_SUPPORT otherwise

--*/
{
    KEEPALIVE_TIMEOUT uTime;
    uTime.RuntimeUnits = Time;

    if (ClientInfo->TurnOnOffKeepAlives)
        {
        // While turning on the keepalive we need to protect the IO
        // against connection closure.
        return ClientInfo->TurnOnOffKeepAlives(TransConnection(),
            TurnOn,
            TRUE,
            tuRuntime,
            uTime);
        }
    else
        {
        return RPC_S_CANNOT_SUPPORT;
        }
}

void
OSF_CASSOCIATION::OsfDeleteLingeringAssociations (
    void
    )
/*++

Routine Description:

    Will attempt to clean up lingering conn associations.

Return Value:

--*/
{
    BOOL fMutexTaken;
    OSF_CASSOCIATION *CurrentAssociation;
    OSF_CASSOCIATION *NextAssociation;
    OSF_CASSOCIATION *FirstAssociation;
    DictionaryCursor cursor;
    DWORD CurrentTickCount;
    int Diff;

    // if there are no osf associations, return
    if (!AssociationDict)
        return;

    fMutexTaken = AssocDictMutex->TryRequest();
    if (!fMutexTaken)
        {
        // we couldn't cleanup anything - restore the flag
        if (!GarbageCollectionRequested)
            GarbageCollectionRequested = TRUE;
        return;
        }

    FirstAssociation = NULL;
    CurrentTickCount = GetTickCount();

    // need to walk the dictionary and clean up all associations with
    // expired timeouts
    AssociationDict->Reset(cursor);

    while ((CurrentAssociation = AssociationDict->Next(cursor)) != 0)
        {
        if (CurrentAssociation->Linger.fAssociationLingered)
            {
            // this will work even for wrapped tick count
            Diff = (int)(CurrentTickCount - CurrentAssociation->Linger.Timestamp);
            if (Diff > 0)
                {
#if defined (RPC_GC_AUDIT)
                DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) OSF association gc'ed %d ms after expire\n",
                    GetCurrentProcessId(), GetCurrentProcessId(), Diff);
#endif
                // enlink the expired associations to a list - we'll clean it up
                // later
                CurrentAssociation->NextAssociation = FirstAssociation;
                FirstAssociation = CurrentAssociation;
                AssociationDict->Delete(CurrentAssociation->Key);
                // indicate to the other threads (needed once we release the mutex)
                // that this association is being cleaned up and they cannot clean it up
                CurrentAssociation->Key = -1;
                OsfLingeredAssociations --;

                // Add one artificial reference to the association. This will
                // prevent a thread that is doing unbind and lingered the
                // association, but later found out it couldn't destroy it
                // (see OSF_CASSOCIATION::UnBind) from deleteing the object
                // from underneath us
                // CASSOC++
                CurrentAssociation->OSF_CASSOCIATION::AddReference();
                }
            else
                {
                // this item hasn't expired yet - update the first gc time, and
                // raise the GarbageCollectionRequested flag if necessary
                if ((int)(CurrentAssociation->Linger.Timestamp - NextOneTimeCleanup) < 0)
                    {
                    // there is a race between this thread and threads calling
                    // GarbageCollectionNeeded. Those threads may overwrite the
                    // value we're about to write, which can result in delayed
                    // garbage collection for this value - that's ok.
                    NextOneTimeCleanup = CurrentAssociation->Linger.Timestamp;
                    }

                if (!GarbageCollectionRequested)
                    GarbageCollectionRequested = TRUE;
                }
            }
        }

    AssocDictMutex->Clear();

    // destroy the associations at our leasure
    CurrentAssociation = FirstAssociation;
    while (CurrentAssociation != NULL)
        {
        CurrentAssociation->AssociationMutex.Request();
        NextAssociation = CurrentAssociation->NextAssociation;
        CurrentAssociation->AssociationValid = FALSE;

        CurrentAssociation->ShutdownRequested(RPC_S_CALL_FAILED_DNE, NULL);

        CurrentAssociation->AssociationMutex.Clear();

        // Remove the artificial reference we added above
        // CASSOC--
        CurrentAssociation->OSF_CASSOCIATION::RemoveReference();

        CurrentAssociation->OSF_CASSOCIATION::RemoveReference();
        CurrentAssociation = NextAssociation;
        }
}


int
InitializeRpcProtocolOfsClient (
    )
/*++

Routine Description:

    We perform loadtime initialization necessary for the code in this
    file.  In particular, it means we allocate the association dictionary
    and the association dictionary mutex.

Return Value:

    Zero will be returned if initialization completes successfully;
    otherwise, non-zero will be returned.

--*/
{
    RPC_STATUS Status = RPC_S_OK;

    AssocDictMutex = new MUTEX(&Status,
                               TRUE    // pre-allocate semaphore
                               );
    if (AssocDictMutex == 0
        || Status != RPC_S_OK)
        {
        delete AssocDictMutex;
        return 1;
        }

    AssociationDict = new OSF_CASSOCIATION_DICT;
    if (AssociationDict == 0)
        {
        delete AssocDictMutex;
        return(1);
        }

    return(0);
}


RPC_STATUS
OsfMapRpcProtocolSequence (
    IN BOOL ServerSideFlag,
    IN RPC_CHAR  * RpcProtocolSequence,
    OUT TRANS_INFO *  *ClientTransInfo
    )
/*++
Routine Description:

    This routine is used to determine whether a given rpc protocol sequence
    is supported, and to get a pointer to the transport interface, so we
    do not have to keep looking it up.

Arguments:

    RpcProtocolSequence - Supplies the rpc protocol sequence.

    A pointer to the transport interface is returned.  This pointer
    must not be dereferenced by the caller.

Return Value:
    RPC_S_OK - The rpc protocol sequence is supported.

    RPC_S_PROTSEQ_NOT_SUPPORTED - The rpc protocol sequence is
    not supported.

    RPC_S_OUT_OF_MEMORY - There is insufficient memory to perform
    the operation.
--*/
{
    RPC_CHAR * DllName;
    RPC_STATUS Status;

    Status= RpcConfigMapRpcProtocolSequence(ServerSideFlag,
                                            RpcProtocolSequence,
                                            &DllName);
    if (Status != RPC_S_OK)
        {
        return Status;
        }

    Status = LoadableTransportInfo(DllName,
                                   RpcProtocolSequence,
                                   ClientTransInfo);
    delete DllName;

    return(Status);
}


BINDING_HANDLE *
OsfCreateBindingHandle (
    )
/*++

Routine Description:

    This routine does exactly one thing: it creates a binding handle of
    the appropriate type for the osf connection protocol module.

Return Value:

    A new binding handle will be returned.  Zero will be returned if
    insufficient memory is available to create the binding handle.

--*/
{
   BINDING_HANDLE * BindingHandle;
   RPC_STATUS Status = RPC_S_OK;

   BindingHandle = new OSF_BINDING_HANDLE(&Status);
   if ( Status != RPC_S_OK )
       {
       delete BindingHandle;
       return(0);
       }
   return(BindingHandle);
}


extern "C" {


RPC_STATUS RPC_ENTRY
OsfTowerConstruct(
    IN char  * ProtocolSeq,
    IN char  * Endpoint,
    IN char  * NetworkAddress,
    OUT unsigned short  * Floors,
    OUT ULONG  * ByteCount,
    OUT unsigned char  *  * Tower
    )
/*++

Routine Description:

    This routine constructs and returns the upper floors of a tower.
    It invokes the appropriate loadable transport and has them construct
    it.

Return Value:


--*/
{
    TRANS_INFO *ClientTransInfo;
    RPC_STATUS Status = RPC_S_OK;

#ifdef UNICODE
    CStackUnicode Pseq;
    USES_CONVERSION;
#else
    RPC_CHAR * Pseq;
#endif

#ifdef UNICODE
    ATTEMPT_STACK_A2W(Pseq, ProtocolSeq);
#else
    Pseq = (RPC_CHAR  * )ProtocolSeq;
#endif

    if (Status == RPC_S_OK)
        {
        Status = OsfMapRpcProtocolSequence( 0,
                                            Pseq,
                                            &ClientTransInfo);
        }

    if (Status == RPC_S_OK)
        {
        Status = ClientTransInfo->InqTransInfo()->TowerConstruct( ProtocolSeq,
                                                                  NetworkAddress,
                                                                  Endpoint,
                                                                  Floors,
                                                                  ByteCount,
                                                                  Tower);
        }

    return(Status);
}



RPC_STATUS RPC_ENTRY
OsfTowerExplode(
    IN unsigned char  * Tower,
    OUT char  *  * Protseq,
    OUT char  *  * Endpoint,
    OUT char  *  * NWAddress
    )
/*++

Routine Description:

    This routine accepts upper floors of a tower [Floor 3 onwards]
    It invokes the appropriate loadable transport based on the opcode
    it finds in level 3 to return protocol sequence, endpoint and nwaddress.

Return Value:


--*/
{
    RPC_STATUS Status;
    unsigned short TransportId;
    unsigned char  * Id;
    unsigned char  * ProtocolSequence;
    TRANS_INFO *ClientTransInfo;
#ifdef UNICODE
    CStackUnicode Pseq;
    USES_CONVERSION;
#else
    RPC_CHAR * Pseq;
#endif

    Id = (Tower + sizeof(unsigned short));

    TransportId = (0x00FF & *Id);

    ClientTransInfo = GetLoadedClientTransportInfoFromId(TransportId);
    if (ClientTransInfo != 0)
        {
        Status = ClientTransInfo->InqTransInfo()->TowerExplode(
                                    Tower,
                                    Protseq,
                                    NWAddress,
                                    Endpoint);
        return(Status);
        }

#ifndef UNICODE
    Status = RpcGetWellKnownTransportInfo(TransportId, &Pseq);
#else
    Status = RpcGetWellKnownTransportInfo(TransportId, Pseq.GetPUnicodeString());
#endif

    if (Status != RPC_S_OK)
        {
        Status = RpcGetAdditionalTransportInfo(TransportId, &ProtocolSequence);

        if (Status == RPC_S_OK)
            {
#ifdef UNICODE
            ATTEMPT_STACK_A2W(Pseq, ProtocolSequence);
#else
            Pseq = (RPC_CHAR *) ProtocolSequence;
#endif
            }
        else
            {
            return (Status);
            }
        }

    Status = OsfMapRpcProtocolSequence(0,
                                        Pseq,
                                        &ClientTransInfo);

    if (Status == RPC_S_OK)
        {
        ASSERT(ClientTransInfo != 0);

        Status = ClientTransInfo->InqTransInfo()->TowerExplode(
                                        Tower,
                                        Protseq,
                                        NWAddress,
                                        Endpoint);
        }

    return(Status);
}

} // extern "C"

RPC_STATUS SetAuthInformation (
    IN RPC_BINDING_HANDLE BindingHandle,
    IN CLIENT_AUTH_INFO *AuthInfo
    )
/*++

Routine Description:

    Sets the auth info for a binding handle. Caller must take
    care to pass only OSF binding handles. Transport credentials
    are set, but normal are not (on purpose).

Arguments:

    BindingHandle - the binding handle on which to set auth info.

    AuthInfo - the auth info to set.

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    OSF_BINDING_HANDLE *OsfBindingHandle;
    SEC_WINNT_AUTH_IDENTITY_W *NewAuthIdentity;
    RPC_HTTP_TRANSPORT_CREDENTIALS_W *HttpCredentials;
    RPC_STATUS Status;

    OsfBindingHandle = (OSF_BINDING_HANDLE *)BindingHandle;
    // the only non-trivial piece to copy is the transport credentials
    // since they are encrypted in memory
    if (AuthInfo->AdditionalTransportCredentialsType == RPC_C_AUTHN_INFO_TYPE_HTTP)
        {
        ASSERT(AuthInfo->AdditionalCredentials);
        HttpCredentials = (RPC_HTTP_TRANSPORT_CREDENTIALS_W *)AuthInfo->AdditionalCredentials;
        HttpCredentials = DuplicateHttpTransportCredentials(HttpCredentials);
        if (HttpCredentials == NULL)
            return RPC_S_OUT_OF_MEMORY;

        if (HttpCredentials->TransportCredentials)
            {
            Status = DecryptAuthIdentity(HttpCredentials->TransportCredentials);
            if (Status != RPC_S_OK)
                {
                // on failure the credentials will be wiped out already by
                // DecryptAuthIdentity. Just free the credentials
                FreeHttpTransportCredentials (HttpCredentials);
                return Status;
                }
            }
        }
    else
        {
        HttpCredentials = NULL;
        }

    Status = OsfBindingHandle->SetAuthInformation(
                                      NULL,
                                      AuthInfo->AuthenticationLevel,
                                      RPC_C_AUTHN_NONE,
                                      AuthInfo->AuthIdentity,
                                      AuthInfo->AuthorizationService,
                                      NULL,     // SecurityCredentials
                                      AuthInfo->ImpersonationType,
                                      AuthInfo->IdentityTracking,
                                      AuthInfo->Capabilities,
                                      TRUE,  // Acquire new credentials
                                      AuthInfo->AdditionalTransportCredentialsType,
                                      HttpCredentials
                                      );

    // success or not, we need to wipe out and free the transport credentials (if any)
    if (HttpCredentials)
        {
        WipeOutAuthIdentity (HttpCredentials->TransportCredentials);
        FreeHttpTransportCredentials (HttpCredentials);
        }

    return Status;    
}

RPC_STATUS RPC_ENTRY
I_RpcTransIoCancelled (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    OUT PDWORD Timeout
    )
/*++
Function Name:I_RpcTransIOCancelled

Parameters:
    TransConnection: The connection on which the thread was partying on, when the
    alert was received.
    Timeout - If the call was cancelled, on return, this param will contain
     the cancel timeout.

Description:
    This function is called by the transport interface, when it notices that an alert has
    been received. This function should only be called when the transport is dealing with
    a sync call.

Returns:
    RPC_S_OK: The call was cancelled
    RPC_S_NO_CALL_ACTIVE: no call was cancelled
    others - If a failure occured.
--*/
{
    THREAD *ThreadInfo = RpcpGetThreadPointer();

    ASSERT(ThreadInfo != 0);
    if (ThreadInfo->GetCallCancelledFlag() == 0)
        {
        return RPC_S_NO_CALL_ACTIVE;
        }

    return InqTransCConnection(ThisConnection)->CallCancelled(Timeout);
}


unsigned short RPC_ENTRY
I_RpcTransClientMaxFrag (
    IN RPC_TRANSPORT_CONNECTION ThisConnection
    )
/*++

Routine Description:

    The client side transport interface modules will use this routine to
    determine the negotiated maximum fragment size.

Arguments:

    ThisConnection - Supplies the connection for which we are returning
    the maximum fragment size.

--*/
{
   return (unsigned short) InqTransCConnection(ThisConnection)->InqMaximumFragmentLength();
}


BUFFER RPC_ENTRY
I_RpcTransConnectionAllocatePacket(
    RPC_TRANSPORT_CONNECTION ThisConnection,
    UINT Size
    )
/*++
Function Name:I_RpcTransConnectionAllocatePacket

Parameters:

Description:

Returns:

--*/
{
    return(RpcAllocateBuffer(Size));
}

void RPC_ENTRY
I_RpcTransConnectionFreePacket(
    RPC_TRANSPORT_CONNECTION ThisConnection,
    BUFFER Ptr
    )
/*++
Function Name:I_RpcTransConnectionFreePacket

Parameters:

Description:

Returns:

--*/
{
    RpcFreeBuffer(Ptr);
}

RPC_STATUS RPC_ENTRY
I_RpcTransConnectionReallocPacket(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN BUFFER *ppBuffer,
    IN UINT OldSize,
    IN UINT NewSize
    )
/*++
Function Name:I_RpcTransConnectionReallocPacket

Parameters:

Description:

Returns:

--*/
{
    ASSERT(NewSize > OldSize);

    PVOID Buffer = RpcAllocateBuffer(NewSize);

    if (Buffer)
        {

        if (OldSize)
            {
            RpcpMemoryCopy(Buffer, *ppBuffer, OldSize);
            RpcFreeBuffer(*ppBuffer);
            }

        *ppBuffer = Buffer;

        return(RPC_S_OK);
        }

    return(RPC_S_OUT_OF_MEMORY);
}

BOOL RPC_ENTRY
I_RpcTransPingServer (
    IN RPC_TRANSPORT_CONNECTION ThisConnection
    )
{
    #if 0
    RPC_STATUS Status = RPC_S_OK;
    THREAD *ThisThread = ThreadSelf();
    BOOL fRetVal;

    if (ThisThread->fPinging)
        {
        //
        // We are already pinging, it is best to give up
        // on the server
        //
        return FALSE;
        }

    ThisThread->fPinging = 1;
    EVENT ThreadEvent(&Status);
    EVENT WriteEvent(&Status);
    HANDLE hOldThreadEvent, hOldWriteEvent;

    ASSERT(ThisThread);

    if (Status != RPC_S_OK)
        {
        return TRUE;
        }


    hOldWriteEvent = ThisThread->hWriteEvent;
    hOldThreadEvent = ThisThread->hThreadEvent;

    ThisThread->hWriteEvent = WriteEvent.EventHandle;
    ThisThread->hThreadEvent = ThreadEvent.EventHandle;

    fRetVal =  InqTransCConnection(ThisConnection)->PingServer();

    ThisThread->hWriteEvent = hOldWriteEvent;
    ThisThread->hThreadEvent = hOldThreadEvent;
    ThisThread->fPinging = 0;

    return fRetVal;
    #else
    return(FALSE);
    #endif
}

void
I_RpcTransVerifyClientRuntimeCallFromContext(
    void *SendContext
    )
/*++

Routine Description:

    Verifies that the supplied context follows a valid
    runtime client call object.

Arguments:

    SendContext - the context as seen by the transport

Return Value:

--*/
{
    REFERENCED_OBJECT *pObj;

    pObj = (REFERENCED_OBJECT *) *((PVOID *)
                     ((char *) SendContext - sizeof(void *)));
    ASSERT(pObj->InvalidHandle(OSF_CCALL_TYPE | OSF_CCONNECTION_TYPE) == 0);
}

BOOL
I_RpcTransIsClientConnectionExclusive(
    void *RuntimeConnection
    )
/*++

Routine Description:

    Checks whether the supplied runtime connection
    is exclusive.

Arguments:

    RuntimeConnection - the connection to check.

Return Value:

    non-zero if the connection is exclusive. 0 otherwise.

--*/
{
    OSF_CCONNECTION *Connection = (OSF_CCONNECTION *)RuntimeConnection;
    ASSERT(Connection->InvalidHandle(OSF_CCONNECTION_TYPE) == 0);

    return Connection->IsExclusive();
}


RPC_STATUS RPC_ENTRY
I_RpcBindingInqWireIdForSnego (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char *WireId
    )
/*++

Routine Description:

Arguments:

Return Value:

    The status for the operation is returned.

--*/
{
    OSF_CCALL * Call;

    InitializeIfNecessary();

    Call = (OSF_CCALL *) Binding;

    if (Call->InvalidHandle(OSF_CCALL_TYPE))
        return(RPC_S_INVALID_BINDING);

    return(Call->InqWireIdForSnego(WireId));
}

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingHandleToAsyncHandle (
    IN RPC_BINDING_HANDLE Binding,
    OUT void **AsyncHandle
    )
{
    OSF_CCALL * Call;

    InitializeIfNecessary();

    Call = (OSF_CCALL *) Binding;

    if (Call->InvalidHandle(OSF_CCALL_TYPE))
        return(RPC_S_INVALID_BINDING);

    return Call->BindingHandleToAsyncHandle(AsyncHandle);
}

extern "C"
{

void
I_Trace (
    int IgnoreFirst,
    const char  * IgnoreSecond,
    ...
    )
/*++

Routine Description:

    This is an old routine which is no longer used.  Because it is exported
    by the dll, we need to leave an entry point.

--*/
{
    UNUSED(IgnoreFirst);
    UNUSED(IgnoreSecond);
}

}; // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\osfsvr.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    osfsvr.cxx

Abstract:

    This file contains the server side implementation of the OSF connection
    oriented RPC protocol engine.

Author:

    Michael Montague (mikemon) 17-Jul-1990

Revision History:
    Mazhar Mohammed (mazharm) 2/1/97 major rehaul to support async
    - Added support for Async RPC, Pipes
    - Changed it to operate as a state machine
    - Changed class structure
    - Got rid of the TRANS classes

    Kamen Moutafov      (kamenm)    Jan-2000    Support for multiple transfer syntaxes
    Kamen Moutafov (KamenM) Dec 99 - Feb 2000 - Support for cell debugging stuff
    Kamen Moutafov      (KamenM)    Mar-2000    Support for extended error info
--*/

#include <precomp.hxx>
#include <wincrypt.h>
#include <rpcssl.h>
#include <thrdctx.hxx>
#include <hndlsvr.hxx>
#include <osfpcket.hxx>
#include <secsvr.hxx>
#include <osfsvr.hxx>
#include <sdict2.hxx>
#include <rpccfg.h>
#include <schnlsp.h>     // for UNISP_RPC_ID
#include <charconv.hxx>

extern long GroupIdCounter;

// explicit placement new operator
inline
PVOID __cdecl
operator new(
        size_t size,
        PVOID pPlacement
        )
{
        return pPlacement;
}


OSF_ADDRESS::OSF_ADDRESS (
    IN TRANS_INFO  * RpcTransInfo,
    IN OUT RPC_STATUS  * Status
    ) : RPC_ADDRESS(Status)
/*++

Routine Description:

--*/
{
    RPC_CONNECTION_TRANSPORT *RpcServerInfo =
        (RPC_CONNECTION_TRANSPORT *) RpcTransInfo->InqTransInfo();
    int i;
    RPC_STATUS OriginalFailureStatus;

    ObjectType = OSF_ADDRESS_TYPE;
    ActiveCallCount = 0;
    ServerListeningFlag = 0;
    ServerInfo = RpcServerInfo;
    TransInfo = RpcTransInfo;
    SetupAddressOccurred = 0;
    if (IsServerSideDebugInfoEnabled())
        {
        DebugCell = (DebugEndpointInfo *)AllocateCell(&DebugCellTag);
        if (DebugCell == NULL)
            {
            *Status = RPC_S_OUT_OF_MEMORY;
            }
        else
            {
            DebugCell->TypeHeader = 0;
            DebugCell->Type = dctEndpointInfo;
            DebugCell->ProtseqType = (UCHAR)RpcServerInfo->TransId;
            DebugCell->Status = desAllocated;
            memset(DebugCell->EndpointName, 0, sizeof(DebugCell->EndpointName));
            }
        }
    else
        DebugCell = NULL;

#if defined(_WIN64)
    ASSERT((MutexAllocationSize % 8) == 0);
#else
    ASSERT((MutexAllocationSize % 4) == 0);
#endif

    OriginalFailureStatus = RPC_S_OK;
    for (i = 0; i < NumberOfAssociationsDictionaries; i ++)
        {
        // explicit placement
        new (GetAssociationBucketMutex(i)) MUTEX (Status,
                                                  TRUE      // pre-allocate semaphores
                                                  );

        // if there is a failure, remember it, so that subsequent successes
        // don't overwrite the failure
        if ((*Status != RPC_S_OK) && (OriginalFailureStatus == RPC_S_OK))
            {
            OriginalFailureStatus = *Status;
            }

        // don't check the status - the constructors will
        // check it. Also, we need to invoke all constructors
        // to give them a chance to initialize enough of the
        // object so that it can be destroyed properly
        }

    if (OriginalFailureStatus != RPC_S_OK)
        *Status = OriginalFailureStatus;
}


RPC_STATUS
OSF_ADDRESS::ServerSetupAddress (
    IN RPC_CHAR * NetworkAddress,
    IN RPC_CHAR  *  *Endpoint,
    IN unsigned int PendingQueueSize,
    IN void  * SecurityDescriptor, OPTIONAL
    IN unsigned long EndpointFlags,
    IN unsigned long NICFlags,
    OUT NETWORK_ADDRESS_VECTOR **ppNetworkAddressVector
    )
/*++

Routine Description:

    At this point, we need to setup the loadable transport interface.
    We also need to obtain the network address for this server.  After
    allocating a buffer to hold the network address, we will call
    the loadable transport interface to let it do its thing.

Arguments:

    Endpoint - Supplies the endpoint to be used will this address.

    NetworkAddress - Returns the network address for this server.  The
        ownership of the buffer allocated to contain the network address
        passes to the caller.

    SecurityDescriptor - Optionally supplies a security descriptor to
        be placed on this address.  Whether or not this is suppored depends
        on the particular combination of transport interface and operating
        system.

    PendingQueueSize - Supplies the size of the queue of pending
        requests which should be created by the transport.  Some transports
        will not be able to make use of this value, while others will.

    RpcProtocolSequence - Supplies the protocol sequence for which we
        are trying to setup an address.  This argument is necessary so
        that a single transport interface dll can support more than one
        protocol sequence.

Return Value:

    RPC_S_OK - We successfully setup this address.

    RPC_S_INVALID_SECURITY_DESC - The supplied security descriptor is
        invalid.

    RPC_S_CANT_CREATE_ENDPOINT - The endpoint format is correct, but
        the endpoint can not be created.

    RPC_S_INVALID_ENDPOINT_FORMAT - The endpoint is not a valid
        endpoint for this particular transport interface.

    RPC_S_OUT_OF_RESOURCES - Insufficient resources are available to
        setup the address.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to setup
        the address.

--*/
{

    RPC_STATUS Status;

    Status = ServerInfo->Listen(InqRpcTransportAddress(),
                                            NetworkAddress,
                                            Endpoint,
                                            PendingQueueSize,
                                            SecurityDescriptor,
                                            EndpointFlags,
                                            NICFlags,
                                            ppNetworkAddressVector);

    if ( Status == RPC_S_OK )
        {
        SetupAddressOccurred = 1;
        }

    VALIDATE(Status)
        {
        RPC_S_OK,
        RPC_S_INVALID_SECURITY_DESC,
        RPC_S_INVALID_ARG,
        RPC_S_CANT_CREATE_ENDPOINT,
        RPC_S_INVALID_ENDPOINT_FORMAT,
        RPC_S_OUT_OF_RESOURCES,
        RPC_S_PROTSEQ_NOT_SUPPORTED,
        RPC_S_DUPLICATE_ENDPOINT,
        RPC_S_OUT_OF_MEMORY,
        RPC_S_SERVER_UNAVAILABLE
        } END_VALIDATE;

    return(Status);
}

#ifndef NO_PLUG_AND_PLAY

void
OSF_ADDRESS::PnpNotify (
    )
{
    ServerInfo->PnpNotify();
}
#endif


RPC_STATUS
OSF_ADDRESS::CompleteListen (
    )
/*++
Function Name:CompleteListen

Parameters:

Description:

Returns:

--*/
{
    if (ServerInfo->CompleteListen != 0)
        {
        ServerInfo->CompleteListen(InqRpcTransportAddress());
        }

    if (DebugCell)
        {
        CStackAnsi AnsiEndpoint;
        int i;
        RPC_STATUS RpcStatus;

        i = RpcpStringLength(InqEndpoint()) + 1;
        *(AnsiEndpoint.GetPAnsiString()) = (char *)_alloca(i);

        RpcStatus = AnsiEndpoint.Attach(InqEndpoint(), i, i * 2);

        // note that effectively ignore the result. That's ok - we don't
        // want servers to be unable to start because of code page issues
        // in the debug path. If this fails and we ignore it, the worse
        // that can happen is to have empty endpoint in the debug cell
        // - not a big deal.
        if (RpcStatus == RPC_S_OK)
            {
            strncpy(DebugCell->EndpointName, AnsiEndpoint, sizeof(DebugCell->EndpointName));
            }

        DebugCell->Status = desActive;
        }
    return(RPC_S_OK);
}


RPC_STATUS
OSF_ADDRESS::ServerStartingToListen (
    IN unsigned int MinimumCallThreads,
    IN unsigned int MaximumConcurrentCalls
    )
/*++

Routine Description:


Arguments:

    MinimumCallThreads - Supplies the minimum number of threads to have
        available to receive remote procedure calls.

    MaximumConcurrentCalls - Unused.

Return Value:

    RPC_S_OK - Ok, this address is all ready to start listening for
        remote procedure calls.

    RPC_S_OUT_OF_THREADS - We could not create enough threads so that we
        have least the minimum number of call threads required (as
        specified by the MinimumCallThreads argument).

--*/
{
    RPC_STATUS Status;

    UNUSED(MaximumConcurrentCalls);
    UNUSED(MinimumCallThreads);

    Status = TransInfo->StartServerIfNecessary();
    if (Status == RPC_S_OK)
        {
        ServerListeningFlag = 1;
        }

    return Status;
}



OSF_ADDRESS::~OSF_ADDRESS (
    )
/*++

Routine Description:

    We need to clean up the address after it has been partially
    initialized.  This routine will only be called before FireUpManager
    is called, but it may have been called before or after one of
    SetupAddressWithEndpoint or SetupAddressUnknownEndpoint is called.
    We will keep track of whether or not SetupAddress* occurred
    successfully; if so, we need to call AbortSetupAddress to give the
    loadable transport module a chance to clean things up.

--*/
{
    int i;
    if (SetupAddressOccurred != 0)
        ServerInfo->AbortListen(InqRpcTransportAddress());

    for (i = 0; i < NumberOfAssociationsDictionaries; i ++)
        {
        GetAssociationBucketMutex(i)->Free();
        }

    if (DebugCell != NULL)
        {
        FreeCell(DebugCell, &DebugCellTag);
        }
}


OSF_SCONNECTION *
OSF_ADDRESS::NewConnection (
   )
/*++

Routine Description:

    We will create a new connection which belongs to this address.

Arguments:

    ConnectionKey - Supplies the connection key specified for this
        connection by the loadable transport.

Return Value:

    The new connection will be returned unless insufficient memory
    is available, in which case, zero will be returned.

--*/
{
    OSF_SCONNECTION * SConnection;
    RPC_STATUS Status = RPC_S_OK;

    SConnection = new (ServerInfo->ServerConnectionSize)
                                    OSF_SCONNECTION (
                                           this,
                                           ServerInfo,
                                           &Status);

    if ( Status != RPC_S_OK )
        {
        //
        // Server serverinfo to 0, so it doesn't call close
        //
        SConnection->ServerInfo = 0;

        delete SConnection;
        SConnection = 0;
        }

    if ( SConnection == 0 )
        {
        return(0);
        }

    //
    // Add a reference for the receive that is going to be posted by the
    // transport
    //
    SConnection->AddReference(); // CONN++

    return(SConnection);
}

unsigned int
OSF_ADDRESS::TransSecondarySize (
    )
{
    unsigned int Length = RpcpStringLength(InqEndpoint()) + 1;

    // Will be converted to ANSI in the wire, no need to multiply by
    // sizeof(RPC_CHAR).

    return(Length);
}

RPC_STATUS
OSF_ADDRESS::TransSecondary (
    IN unsigned char * Address,
    IN unsigned int AddressLength
    )
{
    RPC_STATUS Status;
    unsigned char *AnsiAddress;

    AnsiAddress = UnicodeToAnsiString(InqEndpoint(),&Status);

    if (Status != RPC_S_OK)
        {
        ASSERT(Status == RPC_S_OUT_OF_MEMORY);
        ASSERT(AnsiAddress == 0);
        return Status;
        }

    RpcpMemoryCopy(Address,AnsiAddress,AddressLength);

    delete AnsiAddress;

    return (RPC_S_OK);
}


void
OSF_ADDRESS::ServerStoppedListening (
    )
/*++

Routine Description:

    We just need to indicate that the server is no longer listening, and
    set the minimum call threads to one.

--*/
{
    ServerListeningFlag = 0;
}

OSF_ASSOCIATION *
OSF_ADDRESS::RemoveAssociation (
    IN int Key,
    IN OSF_ASSOCIATION *pAssociation
    )
{
    int HashBucketNumber;
    OSF_ASSOCIATION *pAssociationRemoved;

    AddressMutex.VerifyNotOwned();

    HashBucketNumber = GetHashBucketForAssociation(pAssociation->AssocGroupId());
    // verify the the bucket is locked
    GetAssociationBucketMutex(HashBucketNumber)->VerifyOwned();

    pAssociationRemoved = Associations[HashBucketNumber].Delete(Key);

    return pAssociationRemoved;
}

int
OSF_ADDRESS::AddAssociation (
    IN OSF_ASSOCIATION * TheAssociation
    )
{
    int HashBucketNumber;
    int Key;

    HashBucketNumber = GetHashBucketForAssociation(TheAssociation->AssocGroupId());

    AddressMutex.VerifyNotOwned();

    // lock the bucket
    GetAssociationBucketMutex(HashBucketNumber)->Request();
    Key = Associations[HashBucketNumber].Insert(TheAssociation);
    // unlock the bucket
    GetAssociationBucketMutex(HashBucketNumber)->Clear();
    return Key;
}

OSF_ASSOCIATION *
OSF_ADDRESS::FindAssociation (
    IN unsigned long AssociationGroupId,
    IN RPC_CLIENT_PROCESS_IDENTIFIER * ClientProcess
    )
    // The AddressMutex has already been requested.
{
    DictionaryCursor cursor;
    OSF_ASSOCIATION * Association;
    OSF_ASSOCIATION_DICT *pAssocDict;
    int HashBucketNumber;

    // get the hashed bucket
    HashBucketNumber = GetHashBucketForAssociation(AssociationGroupId);
    pAssocDict = &Associations[HashBucketNumber];

    AddressMutex.VerifyNotOwned();

    // lock the bucket
    GetAssociationBucketMutex(HashBucketNumber)->Request();
    // lookup the association in the bucket
    pAssocDict->Reset(cursor);
    while ( (Association = pAssocDict->Next(cursor)) != 0 )
        {
        if ( Association->IsMyAssocGroupId(AssociationGroupId,
                    ClientProcess) != 0 )
            {
            Association->AddConnection();
            GetAssociationBucketMutex(HashBucketNumber)->Clear();
            return(Association);
            }
        }

    // unlock the bucket
    GetAssociationBucketMutex(HashBucketNumber)->Clear();
    return(0);
}

void
OSF_ADDRESS::DestroyContextHandlesForInterface (
    IN RPC_SERVER_INTERFACE PAPI * RpcInterfaceInformation,
    IN BOOL RundownContextHandles
    )
/*++
Function Name:  DestroyContextHandlesForInterface

Parameters:
    RpcInterfaceInformation - the interface for which context handles
        are to be unregistered
    RundownContextHandles - if non-zero, rundown the context handles. If
        FALSE, destroy the runtime portion of the context handle resource,
        but don't call the user rundown routine.

Description:
    The implementation fo context handle destruction for the connection 
    oriented protocols. It will walk the list of associations, and for
    each one it will ask the association to destroy the context handles
    for that interface

Returns:

--*/
{
    int i;
    MUTEX *CurrentBucketMutex;
    DictionaryCursor cursor;
    OSF_ASSOCIATION_DICT *CurrentAssocDict;
    OSF_ASSOCIATION *CurrentAssociation;
    BOOL CopyOfDictionaryUsed;
    OSF_ASSOCIATION_DICT AssocDictCopy;
    OSF_ASSOCIATION_DICT *AssocDictToUse;
    BOOL Res;

    // N.B. We may or we may not own the ServerMutex here - be prepared
    // for both occasions. The first implication is not to call functions
    // that take the server mutex.

    for (i = 0; i < NumberOfAssociationsDictionaries; i ++)
        {
        CurrentBucketMutex = GetAssociationBucketMutex(i);

        CurrentBucketMutex->Request();

        CurrentAssocDict = &Associations[i];
        CopyOfDictionaryUsed = AssocDictCopy.ExpandToSize(CurrentAssocDict->Size());
        if (CopyOfDictionaryUsed)
            {
            CurrentAssocDict->Reset(cursor);
            while ( (CurrentAssociation = CurrentAssocDict->Next(cursor)) != 0 )
                {
                Res = AssocDictCopy.Insert(CurrentAssociation);
                ASSERT(Res != -1);
                // artifically add a connection count to keep it alive
                // while we destroy the contexts
                CurrentAssociation->AddConnection();
                }
            CurrentBucketMutex->Clear();
            AssocDictToUse = &AssocDictCopy;
            }
        else
            {
            AssocDictToUse = CurrentAssocDict;
            }

        AssocDictToUse->Reset(cursor);
        while ( (CurrentAssociation = AssocDictToUse->Next(cursor)) != 0 )
            {
            // call into the association to destroy the context handles
            CurrentAssociation->DestroyContextHandlesForInterface(
                RpcInterfaceInformation,
                RundownContextHandles);
            }

        if (CopyOfDictionaryUsed)
            {
            while ( (CurrentAssociation = AssocDictCopy.Next(cursor)) != 0 )
                {
                // remove the extra refcounts
                CurrentAssociation->RemoveConnection();
                }
            AssocDictCopy.DeleteAll();
            }
        else
            {
            CurrentBucketMutex->Clear();
            }
        }
}

OSF_SBINDING::OSF_SBINDING ( // Constructor.
    IN RPC_INTERFACE * TheInterface,
    IN int PContext,
    IN int SelectedTransferSyntaxIndex
    )
{
    PresentContext = PContext;
    Interface = TheInterface;
    SequenceNumber = 0;
    CurrentSecId = -1;
    this->SelectedTransferSyntaxIndex = SelectedTransferSyntaxIndex;
}


OSF_SCALL::OSF_SCALL (
    IN OSF_SCONNECTION *Connection,
    IN OUT RPC_STATUS *Status
    ) : CallMutex(Status), SyncEvent(Status, 0)
{
    ObjectType = OSF_SCALL_TYPE;
    Thread = 0;
    CallOrphaned = 0;
    CancelPending = 0;
    SavedHeader = 0;
    SavedHeaderSize = 0;

    this->Connection = Connection;
    SendContext = (char *) this+sizeof(OSF_SCALL);
    SetReferenceCount(0);

    if (IsServerSideDebugInfoEnabled())
        {
        if (*Status != RPC_S_OK)
            {
            DebugCell = NULL;
            return;
            }

        DebugCell = (DebugCallInfo *)AllocateCell(&CellTag);
        if (DebugCell == NULL)
            *Status = RPC_S_OUT_OF_MEMORY;
        else
            {
            memset(DebugCell, 0, sizeof(DebugCallInfo));
            DebugCell->Type = dctCallInfo;
            DebugCell->Status = (BYTE)csAllocated;
            GetDebugCellIDFromDebugCell((DebugCellUnion *)Connection->DebugCell,
                &Connection->DebugCellTag, &DebugCell->Connection);
            DebugCell->LastUpdateTime = NtGetTickCount();
            // if this is the call for the connection,
            // it will be NULL. If this is a subsequent
            // call on the connection, the CachedSCall would
            // have been set already.
            if (Connection->CachedSCall == NULL)
                DebugCell->CallFlags = DBGCELL_CACHED_CALL;
            }
        }
    else
        DebugCell = NULL;

    //
    // we don't need to initialize ObjectUuidSpecified, ActualBufferLength,
    // FirstFrag and Alertcount
    //
}


OSF_SCALL::~OSF_SCALL (
    )
{
    if (SavedHeader != 0)
       {
       ASSERT(SavedHeaderSize != 0) ;
       RpcpFarFree(SavedHeader);
       }

    if (DebugCell != NULL)
        {
        FreeCell(DebugCell, &CellTag);
        }
}


void
OSF_SCALL::InquireObjectUuid (
    OUT RPC_UUID  * ObjectUuid
    )
/*++

Routine Description:

    This routine copies the object uuid from the server connection into
    the supplied ObjectUuid argument.

Arguments:

    ObjectUuid - Returns a copy of the object uuid in the server connection.

--*/
{
    if (ObjectUuidSpecified == 0)
        ObjectUuid->SetToNullUuid();
    else
        ObjectUuid->CopyUuid(&(this->ObjectUuid));
}


void
OSF_SCALL::SendFault (
    IN RPC_STATUS Status,
    IN int DidNotExecute
    )
{
    p_context_id_t p_cont = 0;

    if (CurrentBinding)
        p_cont = (p_context_id_t)CurrentBinding->GetPresentationContext();

    Connection->SendFault(Status, DidNotExecute, CallId, p_cont);
}



RPC_STATUS
OSF_SCALL::SendReceive (
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:

Arguments:

    Message - Supplies the request to send to the server and returns the
        response received from the server.

Return Value:

    RPC_S_OK - We successfully sent a remote procedure call request to the
        server and received back a response.

--*/
{
    RPC_STATUS Status, ExceptionCode;
    unsigned int RemoteFaultOccured = 0;
    RPC_MESSAGE RpcMessage ;
    RPC_RUNTIME_INFO RuntimeInfo ;
    PRPC_DISPATCH_TABLE DispatchTableToUse;

    if (CurrentState == CallAborted)
        {
        return RPC_S_CALL_FAILED;
        }

    CallStack += 1;
    Address->Server->OutgoingCallback();
    FirstFrag = 1;

    SyncEvent.Lower();

    Status = SendRequestOrResponse(Message, rpc_request);
    if (Status != RPC_S_OK)
        {
        CallStack -= 1;
        return Status;
        }

    for (;TRUE;)
        {
        if (CurrentState == CallAborted)
            {
            Status = RPC_S_CALL_FAILED;
            break;
            }
        //
        // In the callback case, when the receive event is kicked,
        // we have either received a fault or we have received a complete
        // response/request
        //
        SyncEvent.Wait();

        switch (CurrentState)
            {
            case ReceivedCallback:
                //
                // Just received a new callback,
                // need to dispatch it
                //

                RuntimeInfo.Length = sizeof(RPC_RUNTIME_INFO) ;

                RpcMessage.Handle = (RPC_BINDING_HANDLE) this;
                RpcMessage.Buffer = DispatchBuffer ;
                RpcMessage.BufferLength = DispatchBufferOffset;
                RpcMessage.RpcFlags = RPC_BUFFER_COMPLETE;
                RpcMessage.DataRepresentation = Connection->DataRep;
                RpcMessage.ReservedForRuntime = &RuntimeInfo ;
                CurrentBinding->GetSelectedTransferSyntaxAndDispatchTable(
                    &RpcMessage.TransferSyntax, &DispatchTableToUse);
                RpcMessage.ProcNum = ProcNum;


                //
                // Dispatch the callback
                //
                if ( ObjectUuidSpecified != 0 )
                    {
                    Status = CurrentBinding->GetInterface()
                                  ->DispatchToStubWithObject(
                                           &RpcMessage,
                                           &ObjectUuid,
                                           1,
                                           DispatchTableToUse,
                                           &ExceptionCode);
                    }
                else
                    {
                    Status = CurrentBinding->GetInterface()
                                ->DispatchToStub(
                                           &RpcMessage,
                                           1,
                                           DispatchTableToUse,
                                           &ExceptionCode);
                    }

                //
                // Send the reponse
                //
                if ( Status != RPC_S_OK )
                    {

                    VALIDATE(Status)
                        {
                        RPC_P_EXCEPTION_OCCURED,
                        RPC_S_PROCNUM_OUT_OF_RANGE
                        } END_VALIDATE;

                    if ( Status == RPC_S_PROCNUM_OUT_OF_RANGE )
                        {
                        SendFault(RPC_S_PROCNUM_OUT_OF_RANGE, 1);
                        }
                    else
                        {
                        SendFault(ExceptionCode, 0);
                        Status = ExceptionCode;
                        }

                    continue;
                    }

                FirstFrag = 1;
                Status = SendRequestOrResponse(&RpcMessage, rpc_response);
                if ( Status == RPC_S_CALL_FAILED_DNE )
                    {
                    Status = RPC_S_CALL_FAILED;
                    }

                //
                // if the client went away, it is wise to simple go away
                //
                if (Status != RPC_S_OK)
                    {
                    break;
                    }

                //
                // Go back to waiting for our original reply
                //
                continue;

            case ReceivedCallbackReply:
                //
                // Received a reply to our callback
                // need to return to the caller with the reply
                //
                Message->Buffer = DispatchBuffer;
                Message->BufferLength = DispatchBufferOffset;
                Message->DataRepresentation = Connection->DataRep;
                Status = RPC_S_OK;
                break;

            case ReceivedFault:
                //
                // Received a fault, fail the call / propagate status
                // code
                //
                Status = AsyncStatus;
                break;

            case CallAborted:
                //
                // Call aborted, possibly because
                //
                Status = RPC_S_CALL_FAILED;
                break;

            default:
                //
                // Something bad happened, go back to looking
                ASSERT(0);
            }
        break;
        }

    //
    // We need this so the response to the original call can be sent
    // correctly.
    //
    FirstFrag = 1;

    CallStack -= 1;

    if ( Status == RPC_S_OK )
        {
        Message->Handle = (RPC_BINDING_HANDLE) this;
        }

    return(Status);
}

RPC_STATUS
OSF_SCALL::NegotiateTransferSyntax (
    IN OUT PRPC_MESSAGE Message
    )
{
    // this can happen in the callback case only.
    // Just return the already negotiated transfer syntax
    PRPC_DISPATCH_TABLE Ignored;

    CurrentBinding->GetSelectedTransferSyntaxAndDispatchTable(&Message->TransferSyntax,
        &Ignored);

    return RPC_S_OK;
}


RPC_STATUS
OSF_SCALL::GetBuffer (
    IN OUT PRPC_MESSAGE Message,
    IN UUID *ObjectUuid
    )
{
    ULONG BufferLengthToAllocate;

    Message->Handle = (RPC_BINDING_HANDLE) this;

    if (Message->RpcFlags & RPC_BUFFER_PARTIAL &&
        Message->BufferLength < Connection->MaxFrag)
        {
        ActualBufferLength = Connection->MaxFrag ;
        }
    else
        {
        ActualBufferLength = Message->BufferLength ;
        }

    // In addition to saving space for the request (or response) header,
    // we want to save space for security information if necessary.
    BufferLengthToAllocate = ActualBufferLength
                + sizeof(rpcconn_request)
                + (2* Connection->AdditionalSpaceForSecurity);

    if (TransGetBuffer(&Message->Buffer, BufferLengthToAllocate))
        {
        ActualBufferLength = 0 ;
        RpcpErrorAddRecord(EEInfoGCRuntime, 
            RPC_S_OUT_OF_MEMORY, 
            EEInfoDLOSF_SCALL__GetBuffer10,
            BufferLengthToAllocate);
        return(RPC_S_OUT_OF_MEMORY);
        }

    Message->Buffer = (unsigned char *) Message->Buffer
            + sizeof(rpcconn_request);

    return(RPC_S_OK);
}


RPC_STATUS
OSF_SCALL::GetBufferDo (
    OUT void ** ppBuffer,
    IN unsigned int culRequiredLength,
    IN BOOL fDataValid,
    IN unsigned int DataLength,
    IN unsigned long Extra
    )
{
    void *NewBuffer;

    if (TransGetBuffer(&NewBuffer,
                       culRequiredLength + sizeof(rpcconn_request)))
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    if (fDataValid)
        {
        ASSERT(DataLength < culRequiredLength);

        NewBuffer = (unsigned char *) NewBuffer + sizeof(rpcconn_request);

        RpcpMemoryCopy(NewBuffer, *ppBuffer, DataLength);

        TransFreeBuffer((unsigned char *) *ppBuffer-sizeof(rpcconn_request));
        *ppBuffer = NewBuffer;
        }
    else
        {
        *ppBuffer = (unsigned char *) NewBuffer + sizeof(rpcconn_request);
        }

    return(RPC_S_OK);
}


void
OSF_SCALL::FreeBufferDo (
    IN void *pBuffer
    )
{
#if DBG
    if (pBuffer == DispatchBuffer)
        {
        LogEvent(SU_SCALL, EV_DELETE, this, pBuffer, 1, 1);
        }
#endif
    TransFreeBuffer((unsigned char *) pBuffer - sizeof(rpcconn_request));
}


void
OSF_SCALL::FreeBuffer (
    IN PRPC_MESSAGE Message
    )
{
    TransFreeBuffer((unsigned char *) Message->Buffer
            - sizeof(rpcconn_request));
    ActualBufferLength = 0;
}


void
OSF_SCALL::FreePipeBuffer (
    IN PRPC_MESSAGE Message
    )
{
    TransFreeBuffer((unsigned char *) Message->Buffer
            - sizeof(rpcconn_request));
}


RPC_STATUS
OSF_SCALL::ReallocPipeBuffer (
    IN PRPC_MESSAGE Message,
    IN unsigned int NewSize
    )
{
    void *TempBuffer ;
    RPC_STATUS Status ;
    unsigned int SizeToAlloc ;

    if (NewSize > ActualBufferLength)
        {
        SizeToAlloc = (NewSize > Connection->MaxFrag) ?
                        NewSize:Connection->MaxFrag ;

        Status = TransGetBuffer(&TempBuffer,
                SizeToAlloc + sizeof(rpcconn_request) + sizeof(UUID)
                + (2* Connection->AdditionalSpaceForSecurity) );
        if ( Status != RPC_S_OK )
            {
            ASSERT( Status == RPC_S_OUT_OF_MEMORY );
            return(RPC_S_OUT_OF_MEMORY);
            }

        if (ActualBufferLength > 0)
            {
            RpcpMemoryCopy((char  *) TempBuffer+sizeof(rpcconn_request),
                                        Message->Buffer, Message->BufferLength) ;
            OSF_SCALL::FreePipeBuffer(Message) ;
            }

        Message->Buffer = (char  *) TempBuffer + sizeof(rpcconn_request);
        ActualBufferLength = SizeToAlloc ;
        }

    Message->BufferLength = NewSize ;

    return (RPC_S_OK) ;
}


RPC_STATUS
OSF_SCALL::TransGetBuffer (
    OUT void  *  * Buffer,
    IN unsigned int BufferLength
    )
/*++

Routine Description:

    We need a buffer to receive data into or to put data into to be sent.
    This should be really simple, but we need to make sure that buffer we
    return is aligned on an 8 byte boundary.  The stubs make this requirement.

Arguments:

    Buffer - Returns a pointer to the buffer.

    BufferLength - Supplies the required length of the buffer in bytes.

Return Value:

    RPC_S_OK - We successfully allocated a buffer of at least the required
        size.

    RPC_S_OUT_OF_MEMORY - There is insufficient memory available to allocate
        the required buffer.

--*/
{
    void *Memory;

    //
    // The NT memory allocator returns memory which is aligned by at least
    // 8, so we dont need to worry about aligning it.
    //
    Memory = CoAllocateBuffer(BufferLength);
    if ( Memory == 0 )
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    ASSERT( IsBufferAligned(Memory) );

    *Buffer = Memory;

    return(RPC_S_OK);
}


void
OSF_SCALL::TransFreeBuffer (
    IN void  * Buffer
    )
/*++

Routine Description:

    We need to free a buffer which was allocated via TransGetBuffer.  The
    only tricky part is remembering to remove the padding before actually
    freeing the memory.

--*/
{
    CoFreeBuffer(Buffer);
}


BOOL
OSF_SCALL::BeginRpcCall (
    IN rpcconn_common * Packet,
    IN unsigned int PacketLength
    )
/*++

Routine Description:

Arguments:

    Packet - Supplies the packet we received from the connection.  Ownership
        of this buffer passes to this routine.

    PacketLength - Supplies the length of the packet in bytes.

Return Value:

    A non-zero return value indicates that the connection should not
    be placed in the receive any state; instead, the thread should just
    forget about the connection and go back to waiting for more new
    procedure calls.

--*/
{
    RPC_STATUS Status;
    unsigned long SizeofHeaderToSave = 0;
    int retval ;
    BOOL fReceivePosted;
    unsigned int HeaderSize = sizeof(rpcconn_request);
    THREAD *ThisThread;

    ActivateCall();

    //
    // Save the unbyteswapped header for the security related stuff
    // Especially if SECURITY is on. For Request/Resonse we save just
    // the greater of rpc_req or rpc_resp. We havent byteswapped anything..
    // but if auth_length is 0, byteswapping is irrelevant..
    //
    if (Packet->auth_length != 0)
       {
       if ((Packet->PTYPE == rpc_request) || (Packet->PTYPE == rpc_response))
            {
            SizeofHeaderToSave = sizeof(rpcconn_request);
            if ( (Packet->pfc_flags & PFC_OBJECT_UUID) != 0 )
               {
               SizeofHeaderToSave += sizeof(UUID);
               }
            }

       if (SavedHeaderSize < SizeofHeaderToSave)
          {
          if (SavedHeader != 0)
             {
             ASSERT(SavedHeaderSize != 0);
             RpcpFarFree(SavedHeader);
             }

          SavedHeader = RpcpFarAllocate(SizeofHeaderToSave);
          if (SavedHeader == 0)
             {
             Status = RPC_S_PROTOCOL_ERROR;
             goto Cleanup;
             }

          SavedHeaderSize = SizeofHeaderToSave;
          RpcpMemoryCopy(SavedHeader, Packet, SizeofHeaderToSave);
          }
        else if (SizeofHeaderToSave != 0)
          {
          RpcpMemoryCopy(SavedHeader, Packet, SizeofHeaderToSave);
          }
       }

    if (Packet->pfc_flags & PFC_PENDING_CANCEL)
        {
        RpcCancelThread(GetCurrentThread());
        }

    Status = ValidatePacket(Packet, PacketLength);

    CallId = Packet->call_id;

    if (Status != RPC_S_OK)
        {
        ASSERT(Status == RPC_S_PROTOCOL_ERROR);

        //
        // It is not the first packet, so we need to send a fault instead,
        // and then we will blow the connection away.
        //
        goto Cleanup;
        }



    //
    // We need to figure out about security: do we need to put authentication
    // information into each packet, and if so, how much space should we
    // reserve.  When we allocated the buffer (see OSF_SCALL::GetBuffer)
    // we saved space for security information.  We did so we could just
    // stick the authentication information into there without having to
    // copy anything
    //

    if (Connection->AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE)
        {
        ASSERT(Connection->AdditionalSpaceForSecurity >=
               MAXIMUM_SECURITY_BLOCK_SIZE);

        MaxSecuritySize = Connection->AdditionalSpaceForSecurity
                                    - MAXIMUM_SECURITY_BLOCK_SIZE;

        if (MaxSecuritySize == sizeof(sec_trailer))
           {
            MaxSecuritySize = 0;
           }
        else
           {
           //
           // We need to arrange things so that the length of the stub data
           // is a multiple of MAXIMUM_SECURITY_BLOCK_SIZE:
           // this is a requirement of the security package.
           //
           MaximumFragmentLength -= ((MaximumFragmentLength - HeaderSize
                - MaxSecuritySize) % MAXIMUM_SECURITY_BLOCK_SIZE);
           }
        }


    ASSERT(Packet->PTYPE == rpc_request);

    CurrentBinding = Connection->LookupBinding(
                                         ((rpcconn_request *) Packet)->p_cont_id);
    if (CurrentBinding)
        {
        RPC_INTERFACE *CurrentInterface = CurrentBinding->GetInterface();

        ASSERT(CurrentState == NewRequest);

        //
        // Check the security callback on this connection
        // - If IF does not require a security callback, just dispatch
        // - If IF requires a callback and current call is insecure - send a fault
        //         and fail the call
        // - If IF requires a callback, have the binding confirm that for this id
        //         we did callback once before
        // - If we never did callback.. ever, SBinding->CheckSecurity will force
        //         a security callback
        if (CurrentInterface->IsSecurityCallbackReqd() != 0)
            {
            if (Connection->CurrentSecurityContext == 0)
                {
                Status = RPC_S_ACCESS_DENIED;
                goto Cleanup;
                }

            Status = Connection->CurrentSecurityContext->CheckForFailedThirdLeg();
            if (Status != RPC_S_OK)
                {
                goto Cleanup;
                }

            ASSERT(Connection->CurrentSecurityContext->FullyConstructed() );

            ThisThread = RpcpGetThreadPointer();

            // set the current context for this thread so that the app
            // can use the security callback. We'll whack it afterwards
            // as the actual call may not get dispatched on this thread
            RpcpSetThreadContextWithThread(ThisThread, this);

            Status = CurrentBinding->CheckSecurity(this,
                            Connection->CurrentSecurityContext->AuthContextId);

            RpcpSetThreadContextWithThread(ThisThread, 0);

            if (Status != RPC_S_OK)
                {
                fSecurityFailure = 1;

                if (Packet->pfc_flags & PFC_LAST_FRAG)
                    {
                    Status = RPC_S_ACCESS_DENIED;
                    Connection->CleanupPac();
                    goto Cleanup;
                    }

                SendFault(RPC_S_ACCESS_DENIED, 1);

                Connection->TransFreeBuffer(Packet);
                return 0;
                }
            }

        if (CurrentInterface->IsPipeInterface())
            {
            fPipeCall = 1;
            if (DebugCell)
                {
                DebugCell->CallFlags |= DBGCELL_PIPE_CALL;
                }
            }

        if (CurrentInterface->IsAutoListenInterface())
            {
            CurrentInterface->BeginAutoListenCall();
            }

        fReceivePosted = ProcessReceivedPDU(Packet, PacketLength, 1);

        return fReceivePosted;
        }
    else
        {
        //
        // We did not find a binding, which indicates the client tried
        // to make a remote procedure call on an unknown interface.
        //
        Status = RPC_S_UNKNOWN_IF;
        }

Cleanup:
    Connection->TransFreeBuffer(Packet);

    //
    // No one else can come in until we post the next receive,
    // so it is ok to send the fault before making the call
    // available
    //
    SendFault(Status,1);

    if (Status != RPC_S_UNKNOWN_IF)
        {
        Connection->fDontFlush = (CurrentState == NewRequest);

        //
        // We are going to kill the connection, do't post another receive
        //
        fReceivePosted = 1;

        Connection->OSF_SCONNECTION::Delete();
        }
    else
        {
        fReceivePosted = 0;
        }

    //
    // If the call has not been dispatched yet, DispatchBuffer needs to be freed
    //
    ASSERT(fCallDispatched == 0);
    ASSERT(DispatchBuffer == 0);

    if (Connection->fExclusive)
        {
        DeactivateCall();
        Connection->CachedSCallAvailable = 1;
        }

    //
    // Remove the reply reference for this call
    //
    OSF_SCALL::RemoveReference();  // CALL--

    //
    // Remove the dispatch reference for this call
    //
    OSF_SCALL::RemoveReference();  // CALL--

    return fReceivePosted;
}

#define SC_CLEANUP(_status, _dne)  {Status = _status; fDNE = _dne; goto Cleanup;}


BOOL
OSF_SCALL::ProcessReceivedPDU (
    IN rpcconn_common * Packet,
    IN unsigned int PacketLength,
    IN BOOL fDispatch
    )
/*++
Function Name:ProcessReceivedPDU

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    rpcconn_request *Request = (rpcconn_request *) Packet;
    int FragmentLength = (int) PacketLength;
    unsigned char PTYPE, Flags;
    unsigned short OpNum;
    unsigned long Drep;
    int MyCallStack = CallStack;
    BOOL fDNE = 0;
    BOOL fReceivePosted = 0;
    BOOL fCallCleanedUp = FALSE;

    if (fSecurityFailure)
        {

        if (Packet->pfc_flags & PFC_LAST_FRAG)
            {
            Connection->TransFreeBuffer(Packet);
            goto Cleanup2;
            }

        Connection->TransFreeBuffer(Packet);

        return 0;
        }

    switch (Packet->PTYPE)
        {
        case rpc_request :
        case rpc_response:
            if (!fDispatch)
                {
                //
                // This must be a request or response
                // save the maximum of req/resonse size [i.e. sizeof request]
                // also, we are not saving the first frag. here .. hence
                // the approp. memory is already set aside
                //
                ASSERT((Connection->AuthInfo.AuthenticationLevel
                        == RPC_C_AUTHN_LEVEL_NONE)
                       || (SavedHeaderSize >= sizeof(rpcconn_request)));

                if (Connection->AuthInfo.AuthenticationLevel
                    != RPC_C_AUTHN_LEVEL_NONE)
                    {
                    if (SavedHeader == NULL)
                        {
                        SC_CLEANUP(RPC_S_PROTOCOL_ERROR, 1);
                        }

                    RpcpMemoryCopy(SavedHeader, Packet, sizeof(rpcconn_request));
                    }

                Status = ValidatePacket(Packet, PacketLength);

                if (Status != RPC_S_OK )
                    {
                    ASSERT(Status == RPC_S_PROTOCOL_ERROR );
                    SC_CLEANUP(Status, 1);
                    }
                }

            if (Packet->call_id != CallId)
                {
                SC_CLEANUP(RPC_S_PROTOCOL_ERROR, 0);
                }

            Flags = Request->common.pfc_flags;
            Drep = *((unsigned long  *) Request->common.drep);
            OpNum = Request->opnum;
            PTYPE=Request->common.PTYPE;

            Status = Connection->EatAuthInfoFromPacket(
                                Request,
                                &FragmentLength,
                                &SavedHeader,
                                &SavedHeaderSize);
            if (Status != RPC_S_OK )
                {
                VALIDATE(Status)
                    {
                    RPC_S_PROTOCOL_ERROR,
                    ERROR_SHUTDOWN_IN_PROGRESS,
                    RPC_S_ACCESS_DENIED,
                    ERROR_PASSWORD_MUST_CHANGE,
                    ERROR_PASSWORD_EXPIRED,
                    ERROR_ACCOUNT_DISABLED,
                    ERROR_INVALID_LOGON_HOURS
                    } END_VALIDATE;

                 fSecurityFailure = 1;

                 if (Packet->pfc_flags & PFC_LAST_FRAG
                     || (Status == RPC_S_PROTOCOL_ERROR))
                     {
                     SC_CLEANUP(Status, 0);
                     }

                 SendFault(RPC_S_ACCESS_DENIED, 1);

                 Connection->TransFreeBuffer(Packet);
                 return 0;
                }

            //
            // Ok, if the packet contains an object uuid, we need to shift
            // the stub data so that the packet does not contain an object
            // uuid.
            //
            if ((Flags & PFC_OBJECT_UUID) != 0)
                {
                if (CallStack != 0 )
                    {
                    //
                    // There can not be an object uuid in the message.
                    // This is an error.
                    //
                    SC_CLEANUP(RPC_S_PROTOCOL_ERROR, 0);
                    }

                //
                // First save away the object UUID so that we can get it later.
                //
                ObjectUuidSpecified = 1;
                RpcpMemoryCopy(&ObjectUuid, Request + 1, sizeof(UUID));
                if (DataConvertEndian(((unsigned char *) &Drep)) != 0 )
                    {
                    ByteSwapUuid(&ObjectUuid);
                    }


                //
                // Now shift the stub data so that the packet is as if there is
                // no object UUID in the packet.
                //
                RpcpMemoryCopy(Request + 1,
                               ((unsigned char  *) (Request + 1))
                               + sizeof(UUID), FragmentLength);
                }


            //
            // we need to keep this peice of code here, because
            // we need to allocate stuff in the callback case.
            //
            if (Flags & PFC_FIRST_FRAG)
                {
                //
                // Optimize for the single PDU RPC case
                //
                if ((Flags & PFC_LAST_FRAG) != 0)
                    {
                    CurrentState = CallCompleted;
                    DispatchBuffer = (void  *) (Request+1);
                    DispatchBufferOffset = FragmentLength;

                    //
                    // Buffers will be freed by callee
                    //
                    ASSERT(Status == RPC_S_OK);
                    return DispatchRPCCall (PTYPE, OpNum);
                    }

                if (Request->alloc_hint)
                    {
                    AllocHint = Request->alloc_hint;
                    }
                else
                    {
                    AllocHint = FragmentLength;
                    }

                // check the packet size. Note that we check it on first frag
                // only. If they decrease it, we don't care. We will recheck
                // it in all paths below if caller icnreases it.
                if (CurrentBinding->GetInterface()->CallSizeLimitReached(AllocHint))
                    {
                    fSecurityFailure = 1;

                    SendFault(RPC_S_ACCESS_DENIED, 1);

                    Connection->TransFreeBuffer(Packet);
                    return 0;
                    }

                DispatchBufferOffset = 0;

                Status = GetBufferDo(&DispatchBuffer, AllocHint);
                if (Status != RPC_S_OK)
                    {
                    SC_CLEANUP(RPC_S_OUT_OF_MEMORY, 0);
                    }
                }
            else
                {
                if (DispatchBuffer == 0)
                    {
                    //
                    // Looks like it is the first fragment on the call, and it doesn't have
                    // the first-frag bit set
                    //
                    SC_CLEANUP(RPC_S_PROTOCOL_ERROR, 0);
                    }
                }

            if (fPipeCall == 0 || CallStack)
                {
                //
                // Non-pipe case
                //
                if (DispatchBufferOffset+FragmentLength > AllocHint)
                    {
                    Status = GetBufferDo(
                                         &DispatchBuffer,
                                         DispatchBufferOffset+FragmentLength,
                                         1,
                                         DispatchBufferOffset);
                    if (Status != RPC_S_OK)
                        {
                        SC_CLEANUP(RPC_S_OUT_OF_MEMORY, 0);
                        }

                    AllocHint = DispatchBufferOffset + FragmentLength;

                    if (CurrentBinding->GetInterface()->
                        CallSizeLimitReached(AllocHint))
                        {
                        fSecurityFailure = 1;

                        if (Packet->pfc_flags & PFC_LAST_FRAG)
                            {
                            SC_CLEANUP(RPC_S_ACCESS_DENIED, 0);
                            }

                        SendFault(RPC_S_ACCESS_DENIED, 1);

                        Connection->TransFreeBuffer(Packet);
                        return 0;
                        }

                    }

                //
                // Copy current buffer into the dispatch buffer
                //
                RpcpMemoryCopy(
                               (char *) DispatchBuffer+DispatchBufferOffset,
                               Request+1,
                               FragmentLength);
                DispatchBufferOffset += FragmentLength;

                Connection->TransFreeBuffer(Packet);

                if (Flags & PFC_LAST_FRAG)
                    {
                    CurrentState = CallCompleted;

                    //
                    // Buffers will be freed by callee
                    //
                    ASSERT(Status == RPC_S_OK);

                    return DispatchRPCCall (PTYPE, OpNum);
                    }
                }
            else
                {
                //
                // Pipe call
                //
                ASSERT(PTYPE == rpc_request);

                //
                // If it is a pipe call, we need to dispatch as soon as we get
                // at least alloc hint bytes. If it is not a pipe call, we wait until
                // we get the last fragment.
                //
                if (!fCallDispatched)
                    {
                    if (DispatchBufferOffset+FragmentLength > AllocHint)
                        {
                        Status = GetBufferDo(
                                         &DispatchBuffer,
                                         DispatchBufferOffset+FragmentLength,
                                         1,
                                         DispatchBufferOffset);
                        if (Status != RPC_S_OK)
                            {
                            SC_CLEANUP(Status, 0);
                            }

                        AllocHint = DispatchBufferOffset + FragmentLength;

                        if (CurrentBinding->GetInterface()->
                            CallSizeLimitReached(AllocHint))
                            {
                            fSecurityFailure = 1;

                            if (Packet->pfc_flags & PFC_LAST_FRAG)
                                {
                                SC_CLEANUP(RPC_S_ACCESS_DENIED, 0);
                                }

                            SendFault(RPC_S_ACCESS_DENIED, 1);

                            Connection->TransFreeBuffer(Packet);
                            return 0;
                            }

                        }
                    //
                    // Copy the buffer in
                    //
                    RpcpMemoryCopy(
                               (char *) DispatchBuffer+DispatchBufferOffset,
                               Request+1,
                               FragmentLength);

                    DispatchBufferOffset += FragmentLength;

                    Connection->TransFreeBuffer(Packet);

                    ASSERT(Status == RPC_S_OK);

                    if (DispatchBufferOffset == AllocHint)
                        {
                        ASSERT(fSecurityFailure == 0);

                        if (Flags & PFC_LAST_FRAG)
                            {
                            CurrentState = CallCompleted;
                            }
                        else
                            {
                            //
                            // Buffers will be freed by callee
                            //
                            DispatchFlags = 0;
                            }

                        return DispatchRPCCall (PTYPE, OpNum);
                        }
                    }
                else
                    {
                    //
                    // Once a pipe call is dispatched, we don't care about how
                    // big it gets. The manager routine has the option to abandon
                    // the call whenever it wants.
                    //
                    CallMutex.Request();

                    if ((Connection->fExclusive)
                        && (Connection->CachedSCallAvailable))
                        {
                        CallMutex.Clear();
                        ASSERT (Connection->CachedSCall == this);
                        Connection->TransFreeBuffer(Packet);
                        return 0;
                        }
                    //
                    // A pipe call is already in progress. We simply need to queue
                    // the buffer into the buffer queue. It get picked up later.
                    //
                    LogEvent(SU_SCALL, EV_BUFFER_IN, Request, this, 0, 1, 0);
                    if (BufferQueue.PutOnQueue(Request+1, FragmentLength))
                        {
                        CallMutex.Clear();
                        SC_CLEANUP(RPC_S_OUT_OF_MEMORY, 0);
                        }
                    RcvBufferLength += FragmentLength;

                    if ((Flags & PFC_LAST_FRAG) != 0)
                        {
                        CurrentState = CallCompleted;
                        }

                    if (pAsync == 0)
                        {
                        if (BufferQueue.Size() >= 4
                            && Connection->fExclusive
                            && CurrentState != CallCompleted)
                            {
                            fPeerChoked = 1;
                            fReceivePosted = 1;
                            }

                        CallMutex.Clear();
                        SyncEvent.Raise();
                        }
                    else
                        {
                        if (NeededLength > 0 && ((CurrentState == CallCompleted)
                           || (RcvBufferLength >= NeededLength)))
                            {
                            IssueNotification(RpcReceiveComplete);
                            }
                        else
                            {
                            //
                            // Cannot do this for non-exclusive connections because
                            // other calls will get blocked
                            //
                            if (BufferQueue.Size() >= 4
                                && Connection->fExclusive
                                && CurrentState != CallCompleted)
                                {
                                fPeerChoked = 1;
                                fReceivePosted = 1;
                                }
                            }
                        CallMutex.Clear();
                        }

                    //
                    // We received pipe data
                    // there's nothing to cleanup
                    //
                    return fReceivePosted;
                    }
                }

            return 0;

        case rpc_fault:
            Status = ((rpcconn_fault  *)Packet)->status;

            if ((Status == 0) &&
                (Packet->frag_length >= FaultSizeWithoutEEInfo + 4))
                {
                //
                // DCE 1.0.x style fault status:
                // Zero status and stub data contains the fault.
                //
                Status = *(unsigned long  *) ((unsigned char *)Packet + FaultSizeWithoutEEInfo);
                }

            if (DataConvertEndian(Packet->drep) != 0)
                {
                Status = RpcpByteSwapLong(Status);
                }

            if (Status == 0)
                {
                Status = RPC_S_CALL_FAILED;
                }

            AsyncStatus = MapFromNcaStatusCode(Status);
            CurrentState = ReceivedFault;

            SyncEvent.Raise();

            Connection->TransFreeBuffer(Packet);
            return 0;

        case rpc_cancel:
        case rpc_orphaned:
            CancelPending = 1;

            Connection->TransFreeBuffer(Packet);
            return 0;

        default :
            //
            // We should never reach here
            //
            ASSERT(0);
            SC_CLEANUP(RPC_S_PROTOCOL_ERROR, 0);
            break;
        }


Cleanup:
    //
    // If we reach here it means that the call failed
    // Every call to ProcessReceivedPDU has a reference on the call,
    // the call is alive here
    //
    ASSERT(Status != RPC_S_OK);

    Connection->TransFreeBuffer(Packet);
    if ((MyCallStack == 0) && (fCallDispatched == 0))
        {
        CleanupCallAndSendFault(Status, 0);
        fCallCleanedUp = TRUE;
        }
    else
        {
        SendFault(Status, 0);
        }

Cleanup2:

    //
    // There is a chance that this error happened due to a bogus packet
    // We need to make sure that we don't something bad in that case
    //
    if (MyCallStack == 0)
        {
        if (fCallDispatched == 0)
            {
            if (fCallCleanedUp == FALSE)
                CleanupCall();

            //
            // We cannot continue to use this connection
            //
            Connection->fDontFlush = (CurrentState == NewRequest);
            Connection->OSF_SCONNECTION::Delete();

            //
            // Remove the reference held by the dispatch
            // thread
            //
            OSF_SCALL::RemoveReference(); // CALL--

            //
            // We just finished sending the reply (the fault)
            // remove the reply reference
            //
            OSF_SCALL::RemoveReference(); // CALL--
            }
        else
            {
            //
            // The call will go away when the dispatch completes
            //
            Connection->OSF_SCONNECTION::Delete();
            }

        return 1;
        }

    return 0;
}



RPC_STATUS
OSF_SCALL::Receive (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned int Size
    )
/*++
Function Name:Receive

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    BOOL fForceExtra = FALSE;

    if (!EXTRA(Message) && Message->Buffer)
        {
        ASSERT(Message->Buffer != DispatchBuffer);

        FreeBufferDo((char  *)Message->Buffer);
        Message->Buffer = 0;
        Message->BufferLength = 0;
        }

    if (fSecurityFailure)
        {
        return RPC_S_ACCESS_DENIED;
        }

    Message->DataRepresentation = Connection->DataRep;

    while (TRUE)
        {
        switch (CurrentState)
            {
            case CallCompleted:
                //
                // When the last frag is received on this call, the call state
                // transitions to the Complete state. The call states are valid
                // only when using Async and Pipes
                //
                Status = GetCoalescedBuffer(Message, fForceExtra);
                break;

            case CallCancelled:
                Status = RPC_S_CALL_CANCELLED;
                break;

            case CallAborted:
                ASSERT(AsyncStatus != RPC_S_OK);
                Status = AsyncStatus;
                break;

            default:
                if (RcvBufferLength > Connection->MaxFrag)
                    {
                    Status = GetCoalescedBuffer(Message, fForceExtra);

                    if (Status != RPC_S_OK)
                        {
                        break;
                        }

                    if (PARTIAL(Message) && Message->BufferLength >= Size)
                        {
                        break;
                        }

                    fForceExtra = TRUE;
                    }
                else
                    {
                    //
                    // the call is not yet complete, wait for it.
                    //
                    SyncEvent.Wait();
                    }
                continue;
            }
        break;
        }

    return Status;
}



RPC_STATUS
OSF_SCALL::AsyncReceive (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned int Size
    )
/*++
Function Name:AsyncReceive

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status ;
    int Extra = IsExtraMessage(Message);

    ASSERT(EXTRA(Message) == 0 && PARTIAL(Message));

    if (Message->Buffer)
        {
        ASSERT(Message->Buffer != DispatchBuffer);

        FreeBufferDo((char  *)Message->Buffer);
        Message->Buffer = 0;
        }

    if (fSecurityFailure)
        {
        return RPC_S_ACCESS_DENIED;
        }

    switch (CurrentState)
        {
        case CallCompleted:
            Status = GetCoalescedBuffer(Message, FALSE);
            Message->DataRepresentation = Connection->DataRep;
            break;

        case CallCancelled:
            Status = RPC_S_CALL_CANCELLED;
            break;

        case CallAborted:
            Status = AsyncStatus;
            break;

        default:
            CallMutex.Request();
            if (RcvBufferLength < Size)
                {
                if (NOTIFY(Message))
                    {
                    NeededLength = Size ;
                    }
                CallMutex.Clear() ;

                return RPC_S_ASYNC_CALL_PENDING;
                }
            else
                {
                Status = GetCoalescedBuffer(Message, FALSE);
                Message->DataRepresentation = Connection->DataRep;
                }
            CallMutex.Clear();
            break;
        }

    return Status ;
}

RPC_STATUS
OSF_SCALL::SetAsyncHandle (
    IN PRPC_ASYNC_STATE pAsync
    )
/*++
Function Name:SetAsyncHandle

Parameters:

Description:

Returns:

--*/
{
    this->pAsync = pAsync;
    Thread->fAsync = TRUE;

    if (DebugCell)
        {
        DebugCell->CallFlags |= DBGCELL_ASYNC_CALL;
        }

    return RPC_S_OK;
}

RPC_STATUS
OSF_SCALL::AbortAsyncCall (
    IN PRPC_ASYNC_STATE pAsync,
    IN unsigned long ExceptionCode
    )
/*++
Function Name:AbortAsyncCall

Parameters:

Description:

Returns:

--*/
{
    ASSERT(CurrentBinding);

    CleanupCallAndSendFault(ExceptionCode, 0);

    //
    // The call was aborted asynchronously
    // Remove the reference held for the reply.
    //
    RemoveReference(); // CALL--

    return RPC_S_OK;
}


RPC_STATUS
OSF_SCALL::GetCoalescedBuffer (
    IN PRPC_MESSAGE Message,
    BOOL fForceExtra
    )
/*++
Function Name:GetCoalescedBuffer

Parameters:
    Message - the message structure that will receive the params

Description:
    This routine will coalesce the buffers in the buffer queue into a single
    buffer and return it in the Message structure. If the RPC_BUFFER_EXTRA
    flag is set, the data is appended to the existing buffer in Message->Buffer.

Returns:
    RPC_S_OK - the function was successful in doing its job
    RPC_S_OUT_OF_MEMORY - ran out of memory.
--*/
{
    char *Current;
    UINT bufferlength;
    UINT TotalLength;
    RPC_STATUS Status;
    void *NewBuffer, *Buffer;
    int Extra = IsExtraMessage(Message);
    BOOL fExtendedExtra = Extra | fForceExtra;
    BOOL fSubmitReceive = 0;

    CallMutex.Request();
    if (RcvBufferLength == 0)
        {
        CallMutex.Clear();
        return RPC_S_OK;
        }

    if (fExtendedExtra)
        {
        TotalLength = RcvBufferLength + Message->BufferLength;
        }
    else
        {
        TotalLength = RcvBufferLength;
        }

    Status = TransGetBuffer (&NewBuffer,
                             TotalLength+sizeof(rpcconn_request));
    if (Status != RPC_S_OK)
        {
        CallMutex.Clear();
        return RPC_S_OUT_OF_MEMORY;
        }

    NewBuffer = (char *) NewBuffer+sizeof(rpcconn_request);

    if (fExtendedExtra && Message->Buffer)
        {

        RpcpMemoryCopy(NewBuffer, Message->Buffer, Message->BufferLength);
        Current = (char *) NewBuffer + Message->BufferLength;

        Connection->TransFreeBuffer((char *) Message->Buffer-sizeof(rpcconn_request));

        if (Extra)
            {
            //
            // Update the dispatch buffer, but only for the true EXTRA flag, not
            // for the forced extra
            //
            ASSERT(Message->ReservedForRuntime) ;
            ((PRPC_RUNTIME_INFO)Message->ReservedForRuntime)->OldBuffer = NewBuffer;

            if ((CallStack == 0) && (Message->Buffer == DispatchBuffer))
                DispatchBuffer = NewBuffer;
            }
        }
    else
        {
        Current = (char *) NewBuffer;
        }

    while ((Buffer = BufferQueue.TakeOffQueue(&bufferlength)) != 0)
        {
        RpcpMemoryCopy(Current, Buffer, bufferlength);
        Current += bufferlength;

        Connection->TransFreeBuffer((char *) Buffer-sizeof(rpcconn_request));
        }

    Message->Buffer = NewBuffer;
    Message->BufferLength = TotalLength;

    RcvBufferLength = 0;

    if (CurrentState == CallCompleted)
        {
        Message->RpcFlags = RPC_BUFFER_COMPLETE;
        }

    if (fPeerChoked)
        {
        fSubmitReceive = 1;
        fPeerChoked = 0;
        }
    CallMutex.Clear();

    if (fSubmitReceive)
        {
        Connection->TransAsyncReceive();
        }

    return RPC_S_OK;
}


void
OSF_SCALL::DispatchHelper ()
{
    THREAD *MyThread;
    RPC_STATUS Status, ExceptionCode;
    DebugCallInfo *Cell;
    DebugThreadInfo *ThreadCell;
    ULONG TickCount;
    PRPC_DISPATCH_TABLE DispatchTableToUse;

    //
    // We have a new RPC call. We need to dispatch it.
    //
    FirstCallRuntimeInfo.Length = sizeof(RPC_RUNTIME_INFO) ;

    FirstCallRpcMessage.Handle = (RPC_BINDING_HANDLE) this;
    FirstCallRpcMessage.Buffer = DispatchBuffer;
    FirstCallRpcMessage.BufferLength = DispatchBufferOffset;
    FirstCallRpcMessage.RpcFlags = DispatchFlags ;
    FirstCallRpcMessage.DataRepresentation = Connection->DataRep;
    FirstCallRpcMessage.ReservedForRuntime = &FirstCallRuntimeInfo ;
    CurrentBinding->GetSelectedTransferSyntaxAndDispatchTable(&FirstCallRpcMessage.TransferSyntax,
        &DispatchTableToUse);
    FirstCallRpcMessage.ProcNum = ProcNum;

    MyThread = (THREAD *) RpcpGetThreadPointer();
    ASSERT(MyThread);

    RpcpSetThreadContextWithThread(MyThread, this);

    Thread = MyThread;

    ThreadCell = Thread->DebugCell;

    if (ThreadCell)
        {
        TickCount = NtGetTickCount();
        Cell = DebugCell;
        Cell->CallID = CallId;
        Cell->ProcNum = (unsigned short)ProcNum;
        Cell->Status = csDispatched;
        Cell->LastUpdateTime = TickCount;
        Cell->InterfaceUUIDStart 
            = CurrentBinding->GetInterface()->GetInterfaceFirstDWORD();
        ThreadCell->Status = dtsDispatched;
        ThreadCell->LastUpdateTime = TickCount;
        GetDebugCellIDFromDebugCell((DebugCellUnion *)ThreadCell, &MyThread->DebugCellTag, &Cell->ServicingTID);
        }

    //
    // Actually dispatch the RPC call
    //
    if ( ObjectUuidSpecified != 0 )
        {
        Status = CurrentBinding->GetInterface()->DispatchToStubWithObject(
                                    &FirstCallRpcMessage,
                                    &ObjectUuid,
                                    0,
                                    DispatchTableToUse,
                                    &ExceptionCode);
        }
    else
        {
        Status = CurrentBinding->GetInterface()->DispatchToStub(
                                    &FirstCallRpcMessage,
                                    0,
                                    DispatchTableToUse,
                                    &ExceptionCode);
        }

    //
    // We need to insure that the server thread stops impersonating
    // the client at the end of the call, so we go ahead and call
    // RevertToSelf, and dont worry about the return value.
    //

    OSF_SCALL::RevertToSelf();

    if (ThreadCell)
        {
        ThreadCell->Status = dtsProcessing;
        ThreadCell->LastUpdateTime = NtGetTickCount();
        }

   if(Status != RPC_S_OK)
       {
       //Thread = 0;

       VALIDATE(Status)
           {
           RPC_S_PROCNUM_OUT_OF_RANGE,
           RPC_S_UNKNOWN_IF,
           RPC_S_NOT_LISTENING,
           RPC_S_SERVER_TOO_BUSY,
           RPC_S_UNSUPPORTED_TYPE,
           RPC_P_EXCEPTION_OCCURED
           } END_VALIDATE;

       BOOL fDNE = 1;

       if( Status == RPC_P_EXCEPTION_OCCURED )
           {
           fDNE=0;
           Status = ExceptionCode;
           }
       else if ( Status == RPC_S_NOT_LISTENING )
           {
           Status = RPC_S_SERVER_TOO_BUSY;
           }

       while (CurrentBufferLength)
           {
           #if DBG
           PrintToDebugger("RPC: Waiting for the async send....\n");
           #endif
           Sleep(200);
           }

       //
       // There may be another thread still sending data on this call
       // This will be taken care of in CleanupCall
       //
       CleanupCallAndSendFault(Status, fDNE);

       // It is tempting to think that since an exception was 
       // raised, there will be no reply. However, in the pipe
       // case we may make a bunch of sends, and still get
       // an exception in the end. If there were no sends,
       // remove the reply reference for the call
       if (FirstSend)
           {
           OSF_SCALL::RemoveReference(); // CALL--
           }

       goto Cleanup;
       }

    if (MyThread->IsSyncCall())
        {
        ASSERT( FirstCallRpcMessage.Buffer != 0 );

        if ( CallOrphaned )
            {
            CallOrphaned = 0;
            Thread = 0;

            //
            // clear cancel if thread didn\'t notice it.
            //
            TestCancel();
            goto Cleanup;
            }

        FirstCallRpcMessage.RpcFlags = 0;
        OSF_SCALL::Send(&FirstCallRpcMessage);
        }

Cleanup:
    RpcpSetThreadContextWithThread(MyThread, 0);
}


BOOL
OSF_SCALL::DispatchRPCCall (
    IN unsigned char PTYPE,
    IN unsigned short OpNum
    )
/*++

Routine Description:
    Dispatch an new RPC call, or wake up thread that will dispatch a callback.

Arguments:

    Packet - Supplies the packet we received from the connection.  Ownership
        of this buffer passes to this routine.

    PacketLength - Supplies the length of the packet in bytes.

Return Value:

    A non-zero return value indicates that the connection should not
    be placed in the receive any state; instead, the thread should just
    forget about the connection and go back to waiting for more new
    procedure calls.

--*/
{
    RPC_STATUS Status;
    BOOL fNeedToSendFault;
    OSF_SCONNECTION *LocalConnection;

    if (CallStack > 0)
        {
        //
        // This is a callback request/response. We just need to signal the Event
        // and have it pick up the call
        //
        if (PTYPE == rpc_request)
            {
            CurrentState = ReceivedCallback;
            ProcNum = OpNum;
            }
        else
            {
            CurrentState = ReceivedCallbackReply;
            }

        SyncEvent.Raise();
        return 0;
        }

    ProcNum = OpNum;
    fCallDispatched = 1;

    if (Connection->fExclusive == 0 && Connection->MaybeQueueThisCall(this))
        {
        //
        // We don't get to dispatch right now, looks like another call is
        // currently dispatched. When the current call is done, it will do the
        // right thing
        //

        return 0;
        }

    fNeedToSendFault = FALSE;

    //
    // Looks like we are really going to dispatch a call
    // kick off another thread to go and pick up more requests
    //
    Status = Address->CreateThread();
    if (Status == RPC_S_OK)
        {
        //
        // Post another receive
        //
        Status = Connection->TransAsyncReceive();
        }
    else
        {
        Status = RPC_S_OUT_OF_MEMORY;
        fNeedToSendFault = TRUE;
        }

    if (Status != RPC_S_OK)
        {
        FreeBufferDo(DispatchBuffer);

        if (fNeedToSendFault)
            CleanupCallAndSendFault(Status, 0);
        else
            CleanupCall();

        if (Connection->fExclusive == 0)
            {
            //
            // By the time we get here, calls may have piled up
            //
            Connection->AbortQueuedCalls();
            }

        //
        // We cannot continue to use this connection
        //
        Connection->fDontFlush = (CurrentState == NewRequest);
        Connection->Delete();

        //
        // Remove the reply reference
        //
        RemoveReference(); // CALL--

        //
        // Remove the dispatch reference
        //
        RemoveReference(); // CALL--

        return 1;
        }

    // the call may have been cleaned up after this (though not
    // destroyed) - save the connection in a local variable
    LocalConnection = Connection;

    //
    // Dispatch the current call
    //
    DispatchHelper();

    if (LocalConnection->fExclusive == 0)
        {
        LocalConnection->DispatchQueuedCalls();
        }

    //
    // Remove the dispatch reference
    //
    RemoveReference();  // CALL--

    return 1;
}


RPC_STATUS
OSF_SCALL::SendNextFragment (
    void
    )
/*++
Function Name:SendNextFragment

Description:
    Send the next response fragment

Returns:

--*/
{
    RPC_STATUS Status;
    RPC_STATUS RpcStatus2;
    rpcconn_common  * pFragment;
    BOOL LastFragmentFlag;
    ULONG PacketLength;
    ULONG MaxDataLength = MaximumFragmentLength
        - sizeof(rpcconn_response) - MaxSecuritySize;
    unsigned char *ReservedForSecurity = (unsigned char *) CurrentBuffer
        + CurrentOffset + CurrentBufferLength
        + Connection->AdditionalSpaceForSecurity;

    pFragment = (rpcconn_common *)
                ((char *) CurrentBuffer+CurrentOffset-sizeof(rpcconn_response));

    if (CurrentBuffer == LastBuffer
        && CurrentBufferLength <= MaxDataLength)
        {
        LastFragmentFlag = 1;
        PacketLength = CurrentBufferLength;
        }
    else
        {
        //
        // Each outstanding send needs to hold a reference
        // on the call. Since the call holds a reference
        // on the connection. The connection will also be alive
        //
        AddReference(); // CALL++

        LastFragmentFlag = 0;
        PacketLength = MaxDataLength;
        }

    ConstructPacket(pFragment, rpc_response,
                    PacketLength+sizeof(rpcconn_response)+MaxSecuritySize);

    if (FirstSend)
        {
        FirstSend = 0;
        pFragment->pfc_flags |= PFC_FIRST_FRAG;
        }

    ((rpcconn_response  *) pFragment)->alloc_hint = CurrentBufferLength;
    ((rpcconn_response  *) pFragment)->p_cont_id = (unsigned char) CurrentBinding->GetPresentationContext();
    ((rpcconn_response  *) pFragment)->alert_count = (unsigned char) 0;
    ((rpcconn_response  *) pFragment)->reserved = 0;
    pFragment->call_id = CallId;

    LogEvent(SU_SCALL, EV_BUFFER_OUT, this, pFragment, LastFragmentFlag, 1);

    if (LastFragmentFlag)
        {
        char *BufferToFree = (char *) CurrentBuffer-sizeof(rpcconn_response);
        int MyMaxFrag = MaximumFragmentLength;
        int MyMaxSec = MaxSecuritySize;

        CurrentBufferLength = 0;

        CleanupCall();

        if (Connection->IsHttpTransport())
            {
            RpcStatus2 = Connection->SetLastBufferToFree (BufferToFree);
            VALIDATE(RpcStatus2)
                {
                RPC_S_OK,
                RPC_S_CANNOT_SUPPORT
                } END_VALIDATE;

            // if the transport does not support SetLastBufferToFree, it will
            // return RPC_S_CANNOT_SUPPORT. In this case we retain ownership of
            // the buffer.
            }

        //
        // The call should still be alive at this point because the caller
        // of this function has not release the send reference
        //
        Status = Connection->SendFragment(
                         pFragment,
                         LastFragmentFlag,
                         sizeof(rpcconn_response),
                         MyMaxSec,
                         PacketLength,
                         MyMaxFrag,
                         ReservedForSecurity);

        //
        // Last send always succeeds
        //
        Status = RPC_S_OK;

        if ((Connection->IsHttpTransport() == FALSE) || (RpcStatus2 != RPC_S_OK))
            Connection->TransFreeBuffer(BufferToFree);
        }
    else
        {
        Status = Connection->SendFragment(
                         pFragment,
                         LastFragmentFlag,
                         sizeof(rpcconn_response),
                         MaxSecuritySize,
                         PacketLength,
                         MaximumFragmentLength,
                         ReservedForSecurity,
                         TRUE,
                         SendContext) ;

        if (Status != RPC_S_OK)
            {
            CurrentBufferLength = 0;

            //
            // Remove the reference for the outstanding send
            //
            OSF_SCALL::RemoveReference(); // CALL--
            }
        }


    return Status;
}



RPC_STATUS
OSF_SCALL::Send (
    IN OUT PRPC_MESSAGE Message
    )
/*++
Routine Description:
    

Arguments:
    Message - Supplies the buffer containing the response to be sent
--*/
{
    void *NewBuffer;
    int RemainingLength = 0;
    RPC_STATUS Status = RPC_S_OK;
    RPC_STATUS StatusToReturn = RPC_S_OK;
    ULONG MaxDataLength = MaximumFragmentLength
                            - sizeof(rpcconn_response) - MaxSecuritySize;
    BOOL fOutstandingSend = 0;
    BOOL fBufferSent = 0;


    ASSERT(LastBuffer == 0);

    if (PARTIAL(Message))
        {
        if (Message->BufferLength < MaxDataLength)
            {
            return RPC_S_SEND_INCOMPLETE;
            }

        RemainingLength = Message->BufferLength % MaxDataLength;

        if (RemainingLength)
            {
            Status = GetBufferDo(&NewBuffer, RemainingLength);
            if (Status != RPC_S_OK)
                {
                ASSERT(Status == RPC_S_OUT_OF_MEMORY);
                FreeBufferDo(Message->Buffer);

                return Status;
                }

            Message->BufferLength -= RemainingLength;
            RpcpMemoryCopy(NewBuffer,
                           (char *) Message->Buffer+Message->BufferLength,
                           RemainingLength);
            }
        }
    else
        {
        LastBuffer = Message->Buffer;
        }


    while (1)
        {
        CallMutex.Request();
        if (CurrentBuffer == 0)
            {
            //
            // If CurrentBuffer == 0, it means that the call is idle
            //
            CurrentOffset = 0;
            CurrentBuffer = Message->Buffer;
            CurrentBufferLength = Message->BufferLength;
            fBufferSent = TRUE;

            if ((CurrentBuffer != LastBuffer)
                || (CurrentBufferLength > MaxDataLength))
                {
                UpdateBuffersAfterNonLastSend(
                    NewBuffer,
                    RemainingLength,
                    Message);
                fOutstandingSend = TRUE;
                }

            CallMutex.Clear();

            Status = SendNextFragment();

            if (Status && fOutstandingSend)
                {
                // if we failed on a non last send, there will be 
                // nobody else to drive the call - we need to 
                // return the unsent buffer to Message->Buffer,
                // so that it can be freed below.
                Message->Buffer = CurrentBuffer;
                CleanupCall();
                }

            // N.B. Do not touch any call members after
            // this point if the call succeeded - you may affect 
            // the next call.
            // This is because once we send, we may get swapped out
            // and other threads could drive the call to
            // completion (i.e. send all fragments and cleanup
            // the call on the last fragment). From then on,
            // it may be another call we're writing on.

            if (fOutstandingSend && RemainingLength && (Status == RPC_S_OK))
                StatusToReturn = RPC_S_SEND_INCOMPLETE;
            }
        else
            {
            if ((AsyncStatus == RPC_S_OK) && (pAsync == 0) && (BufferQueue.Size() >= 4))
                {
                fChoked = 1;
                CallMutex.Clear();

                SyncEvent.Wait();
                // if the call already failed, bail out
                if (AsyncStatus != RPC_S_OK)
                    {
                    Status = AsyncStatus;
                    fOutstandingSend = TRUE;
                    break;
                    }
                continue;
                }
            else if (AsyncStatus != RPC_S_OK)
                {
                CallMutex.Clear();
                Status = AsyncStatus;
                fOutstandingSend = TRUE;
                break;
                }

            //
            // Since CurrentBuffer != 0, the call is busy sending the reply
            //
            if (BufferQueue.PutOnQueue(Message->Buffer, Message->BufferLength))
                {
                Status = RPC_S_OUT_OF_MEMORY;
                }
            else
                {
                UpdateBuffersAfterNonLastSend(
                    NewBuffer,
                    RemainingLength,
                    Message);

                if (RemainingLength)
                    StatusToReturn = RPC_S_SEND_INCOMPLETE;
                }
            CallMutex.Clear();
            }
        break;
        }

    if (Status)
        {
        if (RemainingLength)
            {
            FreeBufferDo(NewBuffer);
            }

        if (fOutstandingSend)
            {
            FreeBufferDo(Message->Buffer);
            }
        }
    else
        {
        if (StatusToReturn != RPC_S_OK)
            Status = StatusToReturn;
        }

    if (fBufferSent)
        {
        //
        // Remove the reference for the call (if failure)
        // or for the outstanding send (if success)
        //
        RemoveReference(); // CALL--
        }

    return Status;
}



RPC_STATUS
OSF_SCALL::AsyncSend (
    IN OUT PRPC_MESSAGE Message
    )
/*++
Function Name:AsyncSend
Parameters:
    Message - Supplies the buffer containing the response to be sent

Description:
    It isn't neccassary for us to send the reply using async IO. For the first
    cut, we will send the request synchronously. This will save us a whole lot
    of headache.

Returns:

--*/
{
    RPC_STATUS Status;
    ULONG OldBufferLength = Message->BufferLength;

    ASSERT(FirstSend == 0 || BufferQueue.IsQueueEmpty());

    if (AsyncStatus != RPC_S_OK)
        {
        Status = AsyncStatus;

        CleanupCall();

        //
        // Remove the reply reference
        //
        RemoveReference(); // CALL--

        return Status;
        }

    Status = Send(Message);

    if (Status == RPC_S_SEND_INCOMPLETE)
        {
        if (Message->BufferLength == OldBufferLength
            && (pAsync->Flags & RPC_C_NOTIFY_ON_SEND_COMPLETE))
            {
            CallMutex.Request() ;
            if (!IssueNotification(RpcSendComplete))
                {
                Status = RPC_S_OUT_OF_MEMORY ;
                }
            CallMutex.Clear() ;
            }
        }

    //
    // In the failure case, the reference has already been removed
    // by the server
    //

    return Status;
}


RPC_STATUS
OSF_SCALL::SendRequestOrResponse (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned char PacketType
    )
/*++

Routine Description:

    This routine is used to send to synchoronous sends, as in callbacks
    and callback response.

Arguments:

    Message - Supplies the buffer containing the request or response to be
        sent, and returns the first fragment received from the server.

    PacketType - Supplies the packet type; this must be rpc_request or
        rpc_response.

Return Value:

    RPC_S_OK - We successfully sent the request and received a fragment from
        the server.

    RPC_S_CALL_FAILED_DNE - The connection failed part way through sending
        the request or response.

    RPC_S_CALL_FAILED - The connection failed after sending the request or
        response, and the receive failed.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to perform the
        operation.

    RPC_S_OUT_OF_RESOURCES - Insufficient resources are available to perform
        the operation.

--*/
{
    RPC_STATUS Status;
    RPC_MESSAGE SendBuffer;
    rpcconn_common  * pFragment;
    ULONG LastFragmentFlag = 0;
    ULONG LengthLeft = Message->BufferLength;
    ULONG HeaderSize = sizeof(rpcconn_request);
    ULONG MaxDataLength = MaximumFragmentLength - HeaderSize - MaxSecuritySize;
    unsigned char *ReservedForSecurity = (unsigned char *) Message->Buffer
        + Message->BufferLength + Connection->AdditionalSpaceForSecurity;

    ASSERT(!PARTIAL(Message));
    ASSERT( sizeof(rpcconn_response) == sizeof(rpcconn_request));

    VALIDATE(PacketType)
        {
        rpc_request,
        rpc_response
        } END_VALIDATE;

    SendBuffer.Buffer = Message->Buffer;
    pFragment = (rpcconn_common  *) ((char  *) Message->Buffer - HeaderSize);

    for (;;)
        {
        //
        // Check to see if the remaining data will fit into a single
        // fragment; if so, set the last fragment flag.
        //
        if ( LengthLeft <= MaxDataLength )
            {
            LastFragmentFlag = 1;
            }

        ConstructPacket(pFragment, PacketType, (LastFragmentFlag != 0 ?
               LengthLeft+HeaderSize+MaxSecuritySize : MaximumFragmentLength));

        if ((LengthLeft == Message->BufferLength))
            {
            if (FirstFrag)
                {
                FirstFrag = 0;
                pFragment->pfc_flags |= PFC_FIRST_FRAG;

                if (TestCancel())
                    {
                    pFragment->pfc_flags |= PFC_PENDING_CANCEL;
                    }
                }
            }

        if (PacketType == rpc_request)
            {
            ((rpcconn_request  *) pFragment)->alloc_hint = LengthLeft;
            ((rpcconn_request  *) pFragment)->p_cont_id = (unsigned short) CurrentBinding->GetPresentationContext();
            ((rpcconn_request  *) pFragment)->opnum = (unsigned short) Message->ProcNum;
            }
        else
            {
            ((rpcconn_response  *) pFragment)->alloc_hint = LengthLeft;
            ((rpcconn_response  *) pFragment)->p_cont_id = (unsigned short) CurrentBinding->GetPresentationContext();
            ((rpcconn_response  *) pFragment)->alert_count = (unsigned char) 0;
            ((rpcconn_response  *) pFragment)->reserved = 0;
            }

        pFragment->call_id = CallId;

        Status = Connection->SendFragment(
                                 pFragment,
                                 LastFragmentFlag,
                                 HeaderSize,
                                 MaxSecuritySize,
                                 LengthLeft,
                                 MaximumFragmentLength,
                                 ReservedForSecurity) ;

        if (Status != RPC_S_OK || LastFragmentFlag)
            {
            FreeBuffer(&SendBuffer);
            return (Status) ;
            }

        pFragment = (rpcconn_common  *)
            (((unsigned char  *) pFragment) + MaxDataLength);

        LengthLeft -= MaxDataLength;
        }

    ASSERT(0);
}


void
OSF_SCALL::ProcessSendComplete (
    IN RPC_STATUS EventStatus,
    IN BUFFER Buffer
    )
/*++
Function Name:ProcessSendComplete

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;
    int MaxDataLength = MaximumFragmentLength
        - sizeof(rpcconn_response) - MaxSecuritySize;
    unsigned int MyCurrentBufferLength;

    LogEvent(SU_SCALL, EV_NOTIFY, this, Buffer, EventStatus, 1);

    ASSERT(Buffer);
    ASSERT((char *) Buffer-CurrentOffset
           +sizeof(rpcconn_request) == CurrentBuffer);
    ASSERT((((rpcconn_common *) Buffer)->pfc_flags & PFC_LAST_FRAG) == 0);

    if (EventStatus != RPC_S_OK)
        {
        Status = RPC_S_CALL_FAILED;
        goto Abort;
        }

    MyCurrentBufferLength = CurrentBufferLength - MaxDataLength;
    CurrentOffset += MaxDataLength;

    CallMutex.Request();
    if (MyCurrentBufferLength == 0)
        {
        Connection->TransFreeBuffer(
                                    (char *) CurrentBuffer-sizeof(rpcconn_response));

        CurrentBuffer = BufferQueue.TakeOffQueue(&MyCurrentBufferLength);
        if (CurrentBuffer == 0)
            {
            if (pAsync && (pAsync->Flags & RPC_C_NOTIFY_ON_SEND_COMPLETE))
                {
                if (!IssueNotification(RpcSendComplete))
                    {
                    AsyncStatus = RPC_S_OUT_OF_MEMORY;
                    }
                }
            CurrentBufferLength = 0;
            CallMutex.Clear();
            return;
            }

        CurrentOffset = 0;

        if (fChoked == 1 && pAsync == 0 && BufferQueue.Size() <=1)
            {
            fChoked = 0;
            SyncEvent.Raise();
            }
        }
    else
        {
        //
        // We know that there is more to send in the current buffer
        // We need to restore the part of the buffer which we overwrote
        // with authentication information.
        //
        ASSERT(CurrentBuffer);
        unsigned char *ReservedForSecurity = (unsigned char *) CurrentBuffer
                + CurrentOffset + MyCurrentBufferLength
                + Connection->AdditionalSpaceForSecurity;

        if  ((Connection->AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE)
             && (MaxSecuritySize != 0))
            {
            RpcpMemoryCopy((char *) Buffer+MaximumFragmentLength-MaxSecuritySize,
                       ReservedForSecurity, MaxSecuritySize);
            }
        }

    ASSERT(MyCurrentBufferLength);

    CurrentBufferLength = MyCurrentBufferLength;
    CallMutex.Clear();

    ASSERT(CurrentBuffer);

    Status = SendNextFragment();

    if (Status != RPC_S_OK)
        {
        goto Abort;
        }

    //
    // Remove reference held by the outstanding send
    // or the call reference in the case of the last call
    //
    RemoveReference(); // CALL--

    return;

Abort:
    ASSERT(CurrentBuffer);
    ASSERT(Status != RPC_S_OK);


    Connection->TransFreeBuffer(
                (char *) CurrentBuffer-sizeof(rpcconn_response));

    //
    // We cannot remove the reference here, if we do
    // we'll cause the other thread to puke
    //
    AsyncStatus = Status;

    BUFFER MyBuffer;
    unsigned int ignore;

    CallMutex.Request();
    while (MyBuffer = BufferQueue.TakeOffQueue(&ignore))
       {
       Connection->TransFreeBuffer((char *) MyBuffer-sizeof(rpcconn_response));
       }
    // wake up the thread that was flow controlled, if any
    if (fChoked == 1 && pAsync == 0)
        {
        fChoked = 0;
        SyncEvent.Raise();
        }
    CallMutex.Clear();

    CurrentBufferLength = 0;

    //
    // Remove the reply reference
    //
    RemoveReference(); // CALL--
}


RPC_STATUS
OSF_SCALL::ImpersonateClient (
    )
/*++
Function Name:ImpersonateClient

Parameters:

Description:

 This is relatively easy: we check to see if there is RPC protocol level
 security, if there is not, we let the transport try and impersonate
 the client, and if there is, we let the GSSAPI deal with it.

Returns:

--*/
{
    return Connection->ImpersonateClient();
}


RPC_STATUS
OSF_SCALL::RevertToSelf (
    )
/*++
Function Name:RevertToSelf

Parameters:

Description:

  As with ImpersonateClient, this is relatively easy.  We just check
  to see if we should let the RPC protocol level security deal with
  it or the transport.

Returns:

--*/
{
    return Connection->RevertToSelf();
}

RPC_STATUS
OSF_SCALL::GetAuthorizationContext (
    IN BOOL ImpersonateOnReturn,
    IN AUTHZ_RESOURCE_MANAGER_HANDLE AuthzResourceManager,
    IN PLARGE_INTEGER pExpirationTime OPTIONAL,
    IN LUID Identifier,
    IN DWORD Flags,
    IN PVOID DynamicGroupArgs OPTIONAL,
    OUT PAUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext
    )
/*++

Routine Description:

    Gets an authorization context for the client that can be used
    with Authz functions. The resulting context is owned by the caller
    and must be freed by it.

Arguments:

    ImpersonateOnReturn - if TRUE, when we return, we should be impersonating.
    AuthzResourceManager - the resource manager to use (passed to Authz)
    pExpirationTime - the expiration time to use (passed to Authz)
    Identifier - the LUID (passed to Authz)
    Flags - Flags (passed to Authz)
    DynamicGroupArgs - parameter required by Authz (passed to Authz)
    pAuthzClientContext - the authorization context, returned on success. 
    Undefined on failure.

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    RPC_STATUS RevertStatus;
    HANDLE ImpersonationToken;
    BOOL Result;
    PAUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContextPlaceholder;
    SECURITY_CONTEXT *SecurityContext = Connection->CurrentSecurityContext;
    SECURITY_STATUS SecurityStatus;
    BOOL fNeedToCloseToken;
    AUTHZ_CLIENT_CONTEXT_HANDLE AuthzContext;

    ASSERT (AuthzResourceManager != NULL);

    if (!SecurityContext)
        {
        return RPC_S_NO_CONTEXT_AVAILABLE;
        }

    AuthzContext = SecurityContext->GetAuthzContext();

    if (ImpersonateOnReturn)
        {
        Status = OSF_SCALL::ImpersonateClient();

        if (Status != RPC_S_OK)
            {
            RpcpErrorAddRecord(EEInfoGCRuntime, 
                Status, 
                EEInfoDLOSF_SCALL__GetAuthorizationContext10,
                (ULONGLONG)this,
                (ULONGLONG)0);

            return Status;
            }
        }

    if (AuthzContext)
        {
        Status = DuplicateAuthzContext(AuthzContext,
            pExpirationTime, 
            Identifier,
            Flags,
            DynamicGroupArgs,
            pAuthzClientContext);

        if ((Status != RPC_S_OK) && ImpersonateOnReturn)
            {
            RevertStatus = OSF_SCALL::RevertToSelf();
            ASSERT(RevertStatus == RPC_S_OK);
            }

        // EEInfo, if any, has already been added
        return Status;
        }

    // if there was Authz context created, we would have
    // returned by now. If we are here, this means there
    // is none. Create it.
    Status = SecurityContext->GetAccessToken(&ImpersonationToken, 
        &fNeedToCloseToken);

    if (Status)
        {
        if (ImpersonateOnReturn)
            {
            RevertStatus = OSF_SCALL::RevertToSelf();
            ASSERT(RevertStatus == RPC_S_OK);
            }
        return Status;
        }

    Status = CreateAndSaveAuthzContextFromToken(SecurityContext->GetAuthzContextAddress(),
        ImpersonationToken,
        AuthzResourceManager,
        pExpirationTime,
        Identifier,
        Flags,
        DynamicGroupArgs,
        pAuthzClientContext);

    if (fNeedToCloseToken)
        {
        CloseHandle(ImpersonationToken);
        }

    if (Status)
        {
        if (ImpersonateOnReturn)
            {
            RevertStatus = OSF_SCALL::RevertToSelf();
            ASSERT(RevertStatus == RPC_S_OK);
            }

        return Status;
        }

    return RPC_S_OK;
}

RPC_STATUS
OSF_SCALL::GetAssociationContextCollection (
    OUT ContextCollection **CtxCollection
    )
/*++
Function Name:  GetAssociationContextCollection

Parameters:
    CtxCollection - a placeholder where to put the pointer to 
        the context collection.

Description:
    The context handle code will call the SCALL to get the collection
    of context handles for this association. The SCALL method will
    simply delegate to the association.

Returns:
    RPC_S_OK for success or RPC_S_* for error.

--*/
{
    return Connection->GetAssociationContextCollection(CtxCollection);
}

void 
OSF_SCALL::CleanupCallAndSendFault (
    IN RPC_STATUS Status,
    IN int DidNotExecute
    )
/*++
Function Name:CleanupCallAndSendFault

Parameters: Status - the error code for the fault

Description:

  A syntactic sugar function that saves all relevant call members in a local
  variable, cleans up the call, and then sends the fault directly on the
  connection. Designed to prevent the case where we send the fault to the client
  and the next request comes in before we have made this call available - this
  confuses the server.

Returns:

--*/
{
    p_context_id_t p_cont = 0;
    OSF_SCONNECTION *pLocalConnection;
    unsigned long LocalCallId = CallId;

    if (CurrentBinding)
        p_cont = (p_context_id_t)CurrentBinding->GetPresentationContext();

    pLocalConnection = Connection;

    // make the call available before we send the fault
    CleanupCall();
    pLocalConnection->SendFault(Status, DidNotExecute, LocalCallId, p_cont);
}


RPC_STATUS
OSF_SCALL::ConvertToServerBinding (
    OUT RPC_BINDING_HANDLE __RPC_FAR * ServerBinding
    )
/*++

Routine Description:

    If possible, convert this connection into a server binding, meaning a
    binding handle pointing back to the client.

Arguments:

    ServerBinding - Returns the server binding.

Return Value:

    RPC_S_OK - The server binding has successfully been created.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allocate
        a new binding handle.

    RPC_S_CANNOT_SUPPORT - This will be returned if the transport does
        not support query the network address of the client.

--*/
{
    RPC_CHAR * NetworkAddress;
    RPC_STATUS Status;
    RPC_CHAR * StringBinding;

    Status = Connection->TransQueryClientNetworkAddress(
                                                                &NetworkAddress);
    if ( Status != RPC_S_OK )
        {
        return(Status);
        }

    Status = RpcStringBindingCompose(0,
                        Address->InqRpcProtocolSequence(),
                        NetworkAddress,
                        0,
                        0,
                        &StringBinding);
    delete NetworkAddress;
    if ( Status != RPC_S_OK )
        {
        return(Status);
        }

    Status = RpcBindingFromStringBinding(StringBinding, ServerBinding);

    if ( ObjectUuidSpecified != 0 && RPC_S_OK == Status)
        {
        Status = RpcBindingSetObject(*ServerBinding, (UUID *) &ObjectUuid);
        }
    RpcStringFree(&StringBinding);

    return(Status);
}



OSF_SCONNECTION::OSF_SCONNECTION (
    IN OSF_ADDRESS * TheAddress,
    IN RPC_CONNECTION_TRANSPORT * ServerInfo,
    IN OUT RPC_STATUS  * Status
    ) : ConnMutex(Status)
{
    ObjectType = OSF_SCONNECTION_TYPE;
    MaxFrag = 512;
    Association = 0;
    AuthContextId = 0;
    SavedHeader = 0;
    SavedHeaderSize = 0;
    CurrentSecurityContext = 0;
    RpcSecurityBeingUsed = 0;
    SecurityContextAltered = 0;
    AdditionalSpaceForSecurity = 0;

    DceSecurityInfo.SendSequenceNumber = 0;
    DceSecurityInfo.ReceiveSequenceNumber = 0;
    AuthContinueNeeded = 0;
    CurrentCallId=-1;
    CachedSCallAvailable = 1;
    this->ServerInfo = ServerInfo;
    ConnectionClosedFlag = 0;
    Address = TheAddress;
    TransConnection = (char *) this+sizeof(OSF_SCONNECTION);

    if (IsServerSideDebugInfoEnabled())
        {
        // zero out the CachedSCall - this is a signal that
        // the OSF_SCALL constructor will use to tell
        // it is the cached call
        CachedSCall = NULL;
        DebugCell = (DebugConnectionInfo *) AllocateCell(&DebugCellTag);
        if (DebugCell != 0)
            {
            memset(DebugCell, 0, sizeof(*DebugCell));
            DebugCell->Type = dctConnectionInfo;
            TheAddress->GetDebugCellIDForThisObject(&DebugCell->Endpoint);
            }
        else
            *Status = RPC_S_OUT_OF_MEMORY;
        }
    else
        DebugCell = NULL;

    CachedSCall = new (ServerInfo->SendContextSize)
                            OSF_SCALL(this, Status);
    if (CachedSCall == 0)
        {
        *Status = RPC_S_OUT_OF_MEMORY;
        }
    fExclusive = 0;
    fDontFlush = 0;
    fFirstCall = 0;
    fCurrentlyDispatched = 0;
}

OSF_SCONNECTION::~OSF_SCONNECTION (
    )
{
    OSF_SBINDING * SBinding;
    SECURITY_CONTEXT * SecurityContext;
    DictionaryCursor cursor;

    if (CachedSCall)
        {
        delete CachedSCall;
        }

    ASSERT( AuthInfo.PacHandle == 0 );
    if ( CurrentSecurityContext && AuthInfo.PacHandle )
       {
       CurrentSecurityContext->DeletePac( AuthInfo.PacHandle );
       }

    SecurityContextDict.Reset(cursor);
    while ( (SecurityContext = SecurityContextDict.Next(cursor)) != 0 )
        delete SecurityContext;

    Bindings.Reset(cursor);
    while (SBinding = Bindings.Next(cursor))
        delete SBinding;

    if (Association)
        Association->RemoveConnection();

    if (SavedHeader)
        {
        RpcpFarFree(SavedHeader);
        }

    if (ServerInfo)
        {
        //
        // ServerInfo will be set to 0 when create on the SCONNECTION fails
        // look at NewConnection
        //
        ServerInfo->Close(TransConnection, fDontFlush);
        }

    if (DebugCell)
        {
        FreeCell(DebugCell, &DebugCellTag);
        }
}


RPC_STATUS
OSF_SCONNECTION::TransSend (
    IN void * Buffer,
    IN unsigned int BufferLength
    )
/*++

--*/
{
    RPC_STATUS Status;

    {
    rpcconn_common * pkt = (rpcconn_common *) Buffer;
    LogEvent(SU_SCONN, EV_PKT_OUT, this, 0, (pkt->PTYPE << 16) | pkt->frag_length);
    }

    if (ConnectionClosedFlag != 0)
        return(RPC_P_CONNECTION_CLOSED);

    if (DebugCell)
        {
        DebugCell->LastSendTime = NtGetTickCount();
        DebugCell->LastTransmitFragmentSize = (USHORT) BufferLength;
        }

    DceSecurityInfo.SendSequenceNumber += 1;

    Status = ServerInfo->SyncSend(
                                 TransConnection,
                                 BufferLength,
                                 Buffer,
                                 TRUE, 
                                 TRUE,
                                 INFINITE);   // Timeout


    VALIDATE(Status)
        {
        RPC_S_OK,
        RPC_S_OUT_OF_MEMORY,
        RPC_S_OUT_OF_RESOURCES,
        RPC_P_SEND_FAILED
        } END_VALIDATE;

    if ( Status == RPC_S_OK )
        {
        GlobalRpcServer->PacketSent();
        }

    if ( Status == RPC_P_SEND_FAILED )
        {
        ConnectionClosedFlag = 1;
        }

    return(Status);
}


RPC_STATUS
OSF_SCONNECTION::TransAsyncSend (
    IN void * Buffer,
    IN unsigned int BufferLength,
    IN void *SendContext
    )
/*++
Function Name:TransAsyncSend

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;

    {
    rpcconn_common * pkt = (rpcconn_common *) Buffer;
    LogEvent(SU_SCONN, EV_PKT_OUT, this, 0, (pkt->PTYPE << 16) | pkt->frag_length);
    }

    if ( ConnectionClosedFlag != 0 )
        {
        return(RPC_P_CONNECTION_CLOSED);
        }

    if (DebugCell)
        {
        DebugCell->LastSendTime = NtGetTickCount();
        DebugCell->LastTransmitFragmentSize = (USHORT) BufferLength;
        }

    DceSecurityInfo.SendSequenceNumber += 1;

    Status = ServerInfo->Send(TransConnection,
                              BufferLength,
                              (BUFFER) Buffer,
                              SendContext);

    if (Status == RPC_S_OK)
        {
        GlobalRpcServer->PacketSent();
        }

    if ( Status == RPC_P_SEND_FAILED )
        {
        ConnectionClosedFlag = 1;
        }


    VALIDATE(Status)
        {
        RPC_S_OK,
        RPC_S_OUT_OF_MEMORY,
        RPC_S_OUT_OF_RESOURCES,
        RPC_P_SEND_FAILED
        } END_VALIDATE;

    return(Status);
}


RPC_STATUS
OSF_SCONNECTION::TransAsyncReceive (
    )
/*++
Function Name:TransAsyncReceive

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;

    //
    // Each outstanding receive will hold a reference
    // on the connection
    //
    AddReference(); // CONN++

    if (ConnectionClosedFlag != 0)
        {
        AbortConnection();
        return(RPC_P_CONNECTION_CLOSED);
        }

    Status = ServerInfo->Recv(TransConnection);

    if (Status != RPC_S_OK)
        {
        VALIDATE(Status)
            {
            RPC_P_RECEIVE_FAILED,
            RPC_P_CONNECTION_SHUTDOWN,
            RPC_P_CONNECTION_CLOSED
            } END_VALIDATE;

        if (fExclusive && !CachedSCallAvailable)
            CachedSCall->WakeUpPipeThreadIfNecessary(RPC_S_CALL_FAILED);

        ConnectionClosedFlag = 1;
        AbortConnection();
        }

    return Status;
 }


unsigned int
OSF_SCONNECTION::TransMaximumSend (
    )
/*++

--*/
{
    return(ServerInfo->MaximumFragmentSize);
}


RPC_STATUS
OSF_SCONNECTION::TransImpersonateClient (
    )
/*++
Function Name:TransImpersonateClient

Parameters:

Description:

   If the transport module supports impersonation it will provide the
   sImpersonateClient entry point, in which case we call it.  If an
   error occurs (indicated by sImpersonateClient returning non-zero),
   then no context is available.  NOTE: this is the correct error code
   for NT; it may not be the right one (or only one) for other transports
   which support impersonation.

Returns:

--*/
{
    RPC_STATUS Status;

    if ( ServerInfo->ImpersonateClient == 0 )
        {
        return(RPC_S_CANNOT_SUPPORT);
        }

    Status = ServerInfo->ImpersonateClient(TransConnection);

    VALIDATE(Status)
        {
        RPC_S_OK,
        RPC_S_NO_CONTEXT_AVAILABLE
        } END_VALIDATE;

    return(Status);
}


void
OSF_SCONNECTION::TransRevertToSelf (
    )
/*++

--*/
// As with TransImpersonateClient, if the transport module supports
// impersonation, then sRevertToSelf will be non-zero.  We do not have
// to worry about errors.
//
// For revert to self to work in NT, the transport module needs to know
// the handle of the calling thread when it was originally created.  None
// of the other operating systems we support at this point have
// impersonation built into the transports.
{
    RPC_STATUS Status;

    if ( ServerInfo->RevertToSelf != 0 )
        {
        Status = ServerInfo->RevertToSelf(TransConnection);
        ASSERT( Status == RPC_S_OK );
        }
}


void
OSF_SCONNECTION::TransQueryClientProcess (
    OUT RPC_CLIENT_PROCESS_IDENTIFIER * ClientProcess
    )
/*++

Routine Description:

    We need to obtain the client process identifier for the client process
    at the other end of this connection.  This is necessary so that we can
    determine whether or not a connection should belong to a given
    association.  We need to do this so that context handles (which hang off
    of associations) are secure.

Arguments:

    ClientProcess - Returns the client process identifier for the client
        process at the other end of this connection.

--*/
{
    RPC_STATUS Status;

    if ( ServerInfo->QueryClientId == 0 )
        {
        ClientProcess->ZeroOut();
        }
    else
        {
        Status = ServerInfo->QueryClientId(TransConnection,
                                                   ClientProcess);
        ASSERT( Status == RPC_S_OK );
        }
}


RPC_STATUS
OSF_SCONNECTION::TransQueryClientNetworkAddress (
    OUT RPC_CHAR ** NetworkAddress
    )
/*++

Routine Description:

    This routine is used to query the network address of the client at the
    other end of this connection.

Arguments:

    NetworkAddress - Returns the client's network address.

Return Value:

    RPC_S_OK - The client's network address has successfully been obtained.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete the
        operation.

    RPC_S_CANNOT_SUPPORT - This particular transport implementation does
        not support this operation.

--*/
{
    RPC_STATUS Status;

    if (   ( ServerInfo->TransInterfaceVersion < 2 )
        || ( ServerInfo->QueryClientAddress == 0 ) )
        {
        return(RPC_S_CANNOT_SUPPORT);
        }

    Status = ServerInfo->QueryClientAddress(TransConnection,
                                               NetworkAddress);

    return(Status);
}


void
OSF_SCONNECTION::AbortConnection (
    )
/*++

Routine Description:
--*/
{
    DictionaryCursor cursor;

    //
    // When AbortConnection is called,
    // there should be no pending IO
    //

    //
    // Delete the object, ie: remove the object reference
    //
    Delete();

    //
    // If there are calls stuck in callbacks, wake them up
    //
    if (fExclusive)
        {
        ConnMutex.Request();
        if (CachedSCallAvailable == 0)
            {
            CachedSCall->DeactivateCall();
            CachedSCallAvailable = 1;
            ConnMutex.Clear();

            CachedSCall->AbortCall();
            }
        else
            {
            ConnMutex.Clear();
            }
        }
    else
        {
        ConnMutex.Request();
        OSF_SCALL *NextCall;

        CallDict.Reset(cursor);
        while ((NextCall = CallDict.Next(cursor)) != 0)
            {
            NextCall->AbortCall();
            }
        ConnMutex.Clear();
        }

    //
    // Remove the reference held by the pending receive
    //
    RemoveReference(); // CONN--
}


void
OSF_SCONNECTION::FreeObject (
    )
{
    RemoveFromAssociation();

    delete this;
}


void
OSF_SCONNECTION::FreeSCall (
    IN OSF_SCALL *SCall,
    IN BOOL fRemove
    )
/*++
Function Name:FreeSCall

Parameters:

Description:

Returns:

--*/
{
    ASSERT(SCall->BufferQueue.IsQueueEmpty());

    if (fExclusive == 0)
        {
        if (fRemove)
            {
            OSF_SCALL *Call;

            ConnMutex.Request();
            Call = CallDict.Delete(ULongToPtr(SCall->CallId));
            ConnMutex.Clear();

            ASSERT(Call == 0 || Call == SCall);
            }

        // CurrentBinding is initialized in OSF_SCALL::BeginRpcCall
        // by a call to OSF_CCONNECTION::LookupBinding.  That call may
        // not succeed if we do not find the binding in the dictionary,
        // or we may fail before initialization.
        if (SCall->CurrentBinding != NULL)
            {
            RPC_INTERFACE *CallInterface;

            CallInterface = SCall->CurrentBinding->GetInterface();

            if (SCall->pAsync)
                {
                CallInterface->EndCall(0, 1);
                }

            if (CallInterface->IsAutoListenInterface())
                {
                CallInterface->EndAutoListenCall();
                }
            }

        SCall->DeactivateCall();
        if (SCall == CachedSCall)
            {
            CachedSCallAvailable = 1;
            }
        else
            {
            delete SCall;
            }

        }

    //
    // Remove the reference held by the call
    //
    RemoveReference(); // CONN--
}


RPC_STATUS
OSF_SCONNECTION::TransGetBuffer (
    OUT void * * Buffer,
    IN unsigned int BufferLength
    )
{
    int  * Memory;

    //
    // Our memory allocator returns memory which is aligned by at least
    // 8, so we dont need to worry about aligning it.
    //
    Memory = (int  *) CoAllocateBuffer(BufferLength);
    if ( Memory == 0 )
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    ASSERT( IsBufferAligned(Memory) );

    *Buffer = Memory;

    return(RPC_S_OK);
}

void
OSF_SCONNECTION::TransFreeBuffer ( // Free a buffer.
    IN void  * Buffer
    )
{
    CoFreeBuffer(Buffer);
}


void
OSF_SCONNECTION::ProcessReceiveComplete (
    IN RPC_STATUS EventStatus,
    IN BUFFER Buffer,
    IN UINT BufferLength
    )
/*++
Function Name:ProcessReceiveComplete

Parameters:

Description:

Returns:

--*/
{
    rpcconn_common *Packet = (rpcconn_common *) Buffer;
    rpcconn_auth3  * AuthThirdLegPacket;
    sec_trailer  * NewSecurityTrailer;
    OSF_SCALL *SCall = 0;
    RPC_STATUS Status;
    SECURITY_BUFFER_DESCRIPTOR InputBufferDescriptor;
    SECURITY_BUFFER InputBuffers[4];
    BOOL fReceivePosted = 0;
    BOOL fDNE = 0;

    if (EventStatus)
        {
        LogEvent(SU_SCONN, EV_PKT_IN, this, LongToPtr(EventStatus));
        }
    else
        {
        if (Packet->PTYPE == rpc_request)
            {
            LogEvent(SU_SCONN, EV_PKT_IN, this, 0,
                (((rpcconn_request *)Packet)->opnum << 24) | (Packet->PTYPE << 16) | Packet->frag_length);
            }
        else
            {
            LogEvent(SU_SCONN, EV_PKT_IN, this, 0, (Packet->PTYPE << 16) | Packet->frag_length);
            }
        }

    if (DebugCell)
        {
        DebugCell->LastReceiveTime = NtGetTickCount();
        DebugCell->LastTransmitFragmentSize = (USHORT)BufferLength;
        }

    if (EventStatus != RPC_S_OK)
        {
        VALIDATE(EventStatus)
            {
            RPC_P_CONNECTION_CLOSED,
            RPC_P_RECEIVE_FAILED,
            RPC_P_CONNECTION_SHUTDOWN
            } END_VALIDATE;
        ConnectionClosedFlag = 1;

        if (fExclusive && !CachedSCallAvailable)
            CachedSCall->WakeUpPipeThreadIfNecessary(RPC_S_CALL_FAILED);

        TransFreeBuffer(Buffer);

        AbortConnection();
        return;
        }

    ASSERT(EventStatus == 0);
    ASSERT(Buffer);

    GlobalRpcServer->PacketReceived();

    //
    // Check and make sure that if this is the first packet on this
    // connection that it is a bind packet.
    //
    if ((Association == 0) && (Packet->PTYPE != rpc_bind))
        {
        SendBindNak(protocol_version_not_supported, Packet->call_id);
        TransFreeBuffer(Packet);
        AbortConnection();
        return;
        }

    switch (Packet->PTYPE)
        {
        case rpc_request:
            if (fExclusive)
                {
                if (Packet->pfc_flags & PFC_FIRST_FRAG
                    && CachedSCallAvailable)
                    {
                    //
                    // New call is about to be started
                    // Add a reference on the connection
                    //
                    AddReference(); // CONN++

                    CachedSCallAvailable = 0;
                    fReceivePosted = CachedSCall->BeginRpcCall(Packet, BufferLength);
                    }
                else
                    {
                    fReceivePosted = CachedSCall->ProcessReceivedPDU(Packet, BufferLength);
                    }
                }
            else
                {
                if ((long) Packet->call_id <= (long) CurrentCallId)
                    {
                    //
                    // If it is a non-first fragment, or if it is a callback
                    //
                    SCall = FindCall(Packet->call_id);
                    if (SCall == 0)
                        {
                        if ((long) Packet->call_id < (long) CurrentCallId
                            || (Packet->pfc_flags & PFC_FIRST_FRAG) == 0)
                            {
                            //
                            // Can't find the call. This could be because the pipe call
                            // raised an exception and the call is now complete.
                            //
                            TransFreeBuffer(Packet);
                            fReceivePosted = 0;
                            goto End;
                            }
                        //
                        // If the client is Win95, it will use the same call_id
                        // for subsequent calls on the same connection
                        //
                        }
                    }

                if (SCall == 0)
                    {
                    CurrentCallId = Packet->call_id;

                    //
                    // A new call is about to be started, create one
                    //
                    if (InterlockedCompareExchange(
                        (LPLONG) &CachedSCallAvailable, 0, 1))
                        {
                        SCall = CachedSCall;
                        }
                    else
                        {
                        Status = RPC_S_OK;
                        SCall = new (ServerInfo->SendContextSize)
                                            OSF_SCALL(this, &Status);
                        if (SCall == 0 || Status != RPC_S_OK)
                            {
                            SendFault(RPC_S_OUT_OF_MEMORY, 1, Packet->call_id);

                            if (SCall != 0)
                                {
                                delete SCall;
                                }

                            TransFreeBuffer(Packet);
                            break;
                            }
                        }

                    //
                    // New call is about to be started
                    // Add a reference on the connection
                    //
                    AddReference(); // CONN++

                    int DictKey;

                    ASSERT(SCall);
                    ConnMutex.Request();
                    DictKey = CallDict.Insert(ULongToPtr(Packet->call_id), SCall);
                    ConnMutex.Clear();

                    if (DictKey == -1)
                        {
                        SendFault(RPC_S_OUT_OF_MEMORY, 1, Packet->call_id);
                        FreeSCall(SCall);
                        TransFreeBuffer(Packet);
                        break;
                        }

                    ASSERT(SCall);
                    //
                    // We need this reference to prevent the call from going
                    // away from under us when the client goes away
                    //
                    SCall->AddReference();  // CALL++
                    fReceivePosted = SCall->BeginRpcCall(Packet, BufferLength);
                    SCall->OSF_SCALL::RemoveReference();  // CALL--
                    }
                else
                    {
                    ASSERT(SCall);

                    //
                    // The packet will be freed by the callee
                    //
                    fReceivePosted = SCall->ProcessReceivedPDU(Packet, BufferLength);

                    //
                    // Remove the reference added by the lookup
                    //
                    SCall->OSF_SCALL::RemoveReference(); // CALL--
                    }
                }

            break;

        case rpc_bind:
        case rpc_alter_context:
            //
            // Save the unbyteswapped header for the security related stuff
            // Especially if SECURITY is on.
            // For Bind and AlterContext we save entire packet [we can do better though]
            //
            if (Packet->auth_length != 0)
                {
                if (SavedHeaderSize < BufferLength)
                    {
                    if (SavedHeader != 0)
                        {
                        ASSERT(SavedHeaderSize != 0);
                        RpcpFarFree(SavedHeader);
                        }

                    SavedHeader = RpcpFarAllocate(BufferLength);
                    if (SavedHeader == 0)
                        {
                        if ( Association == 0 )
                            {
                            SendBindNak(
                                        protocol_version_not_supported,
                                        Packet->call_id);
                            TransFreeBuffer(Packet);
                            AbortConnection();
                            return;
                            }

                        SC_CLEANUP(RPC_S_OUT_OF_MEMORY, 1);
                        }
                    SavedHeaderSize = BufferLength;
                    RpcpMemoryCopy(SavedHeader, Packet, BufferLength);
                    }
                else
                    {
                    RpcpMemoryCopy(SavedHeader, Packet, BufferLength);
                    }
                }

            //
            // These things can take quite a while and could cause deadlocks
            // if we dont have any listening threads
            //
            Address->CreateThread();

            Status = ValidatePacket(Packet, BufferLength);
            if (Status != RPC_S_OK)
                {
                ASSERT( Status == RPC_S_PROTOCOL_ERROR );

                //
                // If this the first packet on the connection, it should be an
                // rpc_bind packet, and we want to send a rpc_bind_nak packet
                // rather than a fault.  We can tell that this is the first packet
                // because the association is zero.
                //

                if ( Association == 0 )
                    {
                    SendBindNak(protocol_version_not_supported,
                                Packet->call_id);
                    TransFreeBuffer(Packet);

                    AbortConnection();
                    return;
                    }

                //
                // It is not the first packet, so we need to send a fault instead,
                // and then we will blow the connection away.
                //

                SC_CLEANUP(RPC_S_PROTOCOL_ERROR, 1);
                }

            if (Packet->PTYPE == rpc_bind)
                {
                if (Association != 0)
                    {
                    SendBindNak(reason_not_specified_reject,
                                Packet->call_id);
                    AbortConnection();
                    return;
                    }

                //
                // The packet will be freed by the callee
                //
                if (AssociationRequested(
                  (rpcconn_bind *) Packet, BufferLength) != 0)
                  {
                  AbortConnection();
                  return;
                  }
                }
            else
                {
                if (Association == 0)
                    {
                    SendFault(RPC_S_PROTOCOL_ERROR, 1, Packet->call_id);
                    }

                //
                // The packet will be freed by the callee
                //
                if (AlterContextRequested(
                   (rpcconn_alter_context *) Packet,
                   BufferLength) != 0 )
                   {
                   AbortConnection();
                   return;
                   }
                }
            break;

        case rpc_auth_3:
            //
            // This means that the client sent us back a third leg
            // AuthInfo.Authentication packet.
            //
            ASSERT(AuthContinueNeeded != 0);

            // Save the unbyteswapped header
            ASSERT(AuthInfo.AuthenticationLevel
                   != RPC_C_AUTHN_LEVEL_NONE);

            AuthThirdLegPacket = (rpcconn_auth3  *) Buffer;

            if (AuthContinueNeeded == 0)
                {
                SC_CLEANUP(RPC_S_PROTOCOL_ERROR, 1);
                }

            if (SavedHeaderSize < BufferLength)
              {
              if (SavedHeader != 0)
                 {
                 ASSERT(SavedHeaderSize != 0);
                 RpcpFarFree(SavedHeader);
                 }

              SavedHeader = RpcpFarAllocate(BufferLength);
              if (SavedHeader == 0)
                 {
                 SC_CLEANUP(RPC_S_OUT_OF_MEMORY, 1);
                 }
              SavedHeaderSize = BufferLength;
              RpcpMemoryCopy(SavedHeader, AuthThirdLegPacket,
                                          BufferLength);
              }
            else
              {
              RpcpMemoryCopy(SavedHeader, AuthThirdLegPacket,
                                          BufferLength);
              }

            //
            // These things can take quite a while and could cause deadlocks
            // if we dont have any listening threads
            //
            Address->CreateThread();

            Status = ValidatePacket(
                                    (rpcconn_common  *) AuthThirdLegPacket,
                                    BufferLength);
            if ( Status != RPC_S_OK )
                {
                SC_CLEANUP(RPC_S_OUT_OF_MEMORY, 1);
                }

            if ( AuthThirdLegPacket->common.PTYPE != rpc_auth_3 )
                {
                SC_CLEANUP(RPC_S_OUT_OF_MEMORY, 1);
                }

            NewSecurityTrailer = (sec_trailer  *)
                    (((unsigned char  *) AuthThirdLegPacket)
                    + AuthThirdLegPacket->common.frag_length - sizeof(sec_trailer)
                    - AuthThirdLegPacket->common.auth_length);

            if (   (NewSecurityTrailer->auth_type != AuthInfo.AuthenticationService)
                || (NewSecurityTrailer->auth_level != AuthInfo.AuthenticationLevel) )
                {
                SC_CLEANUP(RPC_S_OUT_OF_MEMORY, 1);
                }

            InputBufferDescriptor.ulVersion = 0;
            InputBufferDescriptor.cBuffers = 4;
            InputBufferDescriptor.pBuffers = InputBuffers;

            InputBuffers[0].cbBuffer = sizeof(rpcconn_auth3);
            InputBuffers[0].BufferType =
                SECBUFFER_DATA | SECBUFFER_READONLY;
            InputBuffers[0].pvBuffer = SavedHeader;

            InputBuffers[1].cbBuffer =
                AuthThirdLegPacket->common.frag_length
                - sizeof(rpcconn_auth3)
                - AuthThirdLegPacket->common.auth_length;
            InputBuffers[1].BufferType =
                SECBUFFER_DATA | SECBUFFER_READONLY;
            InputBuffers[1].pvBuffer =
                (char  *) SavedHeader + sizeof(rpcconn_auth3);

            InputBuffers[2].cbBuffer = AuthThirdLegPacket->common.auth_length;
            InputBuffers[2].BufferType = SECBUFFER_TOKEN;
            InputBuffers[2].pvBuffer = NewSecurityTrailer + 1;

            InputBuffers[3].cbBuffer = sizeof(DCE_INIT_SECURITY_INFO);
            InputBuffers[3].BufferType =
                SECBUFFER_PKG_PARAMS | SECBUFFER_READONLY;
            InputBuffers[3].pvBuffer = &InitSecurityInfo;

            Status = CurrentSecurityContext->AcceptThirdLeg(
                                *((unsigned long  *)
                                  AuthThirdLegPacket->common.drep),
                                &InputBufferDescriptor, 0);

           LogEvent(SU_SCONN, EV_SEC_ACCEPT3, this, LongToPtr(Status), 0);

            if ( Status != RPC_S_OK )
                {
                SC_CLEANUP(RPC_S_OUT_OF_MEMORY, 1);
                }
            TransFreeBuffer(AuthThirdLegPacket);

            DceSecurityInfo.ReceiveSequenceNumber += 1;

            //
            // We need to figure out how much space to reserve for security
            // information at the end of request and response packets.
            // In addition to saving space for the signature or header,
            // we need space to pad the packet to a multiple of the maximum
            // security block size as well as for the security trailer.
            //
            if ((AuthInfo.AuthenticationLevel
                 == RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
               || (AuthInfo.AuthenticationLevel
                 == RPC_C_AUTHN_LEVEL_PKT)
               || (AuthInfo.AuthenticationLevel
                 == RPC_C_AUTHN_LEVEL_CONNECT) )
                {
                AdditionalSpaceForSecurity = MAXIMUM_SECURITY_BLOCK_SIZE
                        + CurrentSecurityContext->MaximumSignatureLength()
                        + sizeof(sec_trailer);
                }
            else if ( AuthInfo.AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT_PRIVACY )
                {
                AdditionalSpaceForSecurity = MAXIMUM_SECURITY_BLOCK_SIZE
                        + CurrentSecurityContext->MaximumHeaderLength()
                        + sizeof(sec_trailer);
                }

            break;

        case rpc_cancel :
        case rpc_orphaned :
        case rpc_fault :
        case rpc_response:
            if (fExclusive)
                {
                if (!CachedSCallAvailable)
                    {
                    //
                    // The packet will be freed by the callee
                    //
                    fReceivePosted = CachedSCall->ProcessReceivedPDU(
                                                                     Packet, BufferLength);
                    }
                else
                    {
                    TransFreeBuffer(Packet);
                    fReceivePosted = 0;
                    goto End;
                    }
                }
            else
                {
                SCall = FindCall(Packet->call_id);
                if (SCall == 0)
                    {
                    if (Packet->PTYPE == rpc_cancel
                        || Packet->PTYPE == rpc_orphaned)
                        {
                        //
                        // Too late, looks like the call is complete
                        //
                        TransFreeBuffer(Packet);
                        }
                    else
                        {
#if DBG
                        PrintToDebugger(
                                        "RPC: Conn: 0x%lXNo SCall corresponding to the CallId: %d\n",
                                        this, Packet->call_id);
                        ASSERT(0);
#endif
                        SC_CLEANUP(RPC_S_PROTOCOL_ERROR, 0);
                        }
                    break;
                    }
                //
                // The packet will be freed by the callee
                //
                fReceivePosted = SCall->ProcessReceivedPDU(Packet, BufferLength);

                //
                // Remove the reference added by the lookup
                //
                SCall->OSF_SCALL::RemoveReference(); // CALL--
                }


            break;

        default:
            SC_CLEANUP(RPC_S_PROTOCOL_ERROR, 0);
        }

End:
    //
    // Submit the receive for the next packet
    //
    if (!fReceivePosted)
        {
        TransAsyncReceive();
        }

    //
    // Remove the reference held by the pending receive
    //
    OSF_SCONNECTION::RemoveReference(); // CONN--
    return;

Cleanup:
    SendFault(Status, fDNE, Packet->call_id);
    TransFreeBuffer(Packet);

    AbortConnection();
}


RPC_STATUS
OSF_SCONNECTION::ImpersonateClient (
    )
/*++
Function Name:ImpersonateClient

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;

    if ( !RpcSecurityBeingUsed )
        {
        Status = SetThreadSecurityContext(
                              (SECURITY_CONTEXT *) MAXUINT_PTR);
        if (RPC_S_OK != Status)
            {
            return Status;
            }

        return TransImpersonateClient();
        }

    SECURITY_CONTEXT * SecurityContext = CurrentSecurityContext;

    if (!SecurityContext)
        {
        ASSERT(SecurityContextAltered);
        return RPC_S_NO_CONTEXT_AVAILABLE;
        }

    Status = SetThreadSecurityContext(
                             SecurityContext);
    if (RPC_S_OK != Status)
        {
        return Status;
        }

    Status = SecurityContext->ImpersonateClient();
    if (RPC_S_OK != Status)
        {
        ClearThreadSecurityContext();
        }

    return Status;
}



RPC_STATUS
OSF_SCONNECTION::RevertToSelf (
    )
/*++
Function Name:RevertToSelf

Parameters:

Description:

Returns:

--*/
{
    SECURITY_CONTEXT * SecurityContext =
        ClearThreadSecurityContext();

    if (!RpcSecurityBeingUsed)
        {
        if (SecurityContext)
            {
            ASSERT(SecurityContext == (SECURITY_CONTEXT *) MAXUINT_PTR);
            TransRevertToSelf();
            }
        return RPC_S_OK;
        }

    if (SecurityContext)
        {
        SecurityContext->RevertToSelf();
        }

    return(RPC_S_OK);
}


void
OSF_SCONNECTION::SendFault (
    IN RPC_STATUS Status,
    IN int DidNotExecute,
    IN unsigned long CallId,
    IN p_context_id_t p_cont_id
    )
/*++
Function Name:SendFault

Parameters:

Description:

Returns:

--*/
{
    rpcconn_fault *Fault;
    size_t FaultSize;
    BOOL fEEInfoPresent = FALSE;

    if (g_fSendEEInfo)
        {
        fEEInfoPresent = PickleEEInfoIntoPacket(FaultSizeWithoutEEInfo,
            (PVOID *)&Fault,
            &FaultSize);
        }

    if (fEEInfoPresent)
        {
        Fault->reserved = FaultEEInfoPresent;
        Fault->alloc_hint = FaultSize;
        }
    else
        {
        FaultSize = FaultSizeWithoutEEInfo;
        Fault = (rpcconn_fault *)_alloca(FaultSize);
        RpcpMemorySet(Fault, 0, FaultSize);
        }

    ConstructPacket((rpcconn_common *)Fault, rpc_fault, FaultSize);

    if (DidNotExecute != 0)
        {
        DidNotExecute = PFC_DID_NOT_EXECUTE;
        }

    if (Status == ERROR_SHUTDOWN_IN_PROGRESS)
        {
        if (DidNotExecute)
            {
            Status = RPC_S_SERVER_UNAVAILABLE;
            }
        else
            {
            Status = ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
        }
        }

    Fault->common.pfc_flags |= PFC_FIRST_FRAG | PFC_LAST_FRAG | DidNotExecute;
    Fault->status = MapToNcaStatusCode(Status);
    Fault->common.call_id = CallId;
    Fault->p_cont_id = p_cont_id;

    TransSend(Fault, FaultSize);

    if (fEEInfoPresent)
        delete Fault;
}

BOOL
OSF_SCONNECTION::PickleEEInfoIntoPacket (
    IN size_t PickleStartOffset,
    OUT PVOID *Packet,
    OUT size_t *PacketSize)
/*++
Function Name: PickeEEInfoIntoPacket

Parameters:
    PickleStartOffset - the offset in bytes where the pickling starts
    Packet - the allocated packet will be placed here on success.
    PacketSize - the size of the packet if success is returned. If
        failure is returned, this parameter is undefined

Description:
    Checks for EEInfo on the thread, trims the EEInfo to MaxFrag,
        allocates the packet, zeroes it out, and pickles the EEInfo
        starting from PickleStartOffset.

Returns:
    TRUE if EEInfo was pickled. FALSE if not.

--*/
{
    unsigned char *CurrentPacket;
    BOOL fEEInfoPresent = FALSE;
    ExtendedErrorInfo *EEInfo;
    RPC_STATUS RpcStatus;
    size_t CurrentPacketSize;

    EEInfo = RpcpGetEEInfo();
    if (EEInfo)
        {
        ASSERT(MaxFrag > 0);
        AddComputerNameToChain(EEInfo);
        TrimEEInfoToLength (MaxFrag, &CurrentPacketSize);
        if (CurrentPacketSize != 0)
            {
            CurrentPacketSize += PickleStartOffset;
            CurrentPacket = new unsigned char[CurrentPacketSize];

            if (CurrentPacket)
                {
                ASSERT(IsBufferAligned(CurrentPacket + PickleStartOffset));

                RpcpMemorySet(CurrentPacket, 0, CurrentPacketSize);

                RpcStatus = PickleEEInfo(EEInfo, 
                    CurrentPacket + PickleStartOffset, 
                    CurrentPacketSize - PickleStartOffset);

                if (RpcStatus == RPC_S_OK)
                    {
                    fEEInfoPresent = TRUE;
                    *Packet = CurrentPacket;
                    *PacketSize = CurrentPacketSize;
                    }
                else
                    {
                    delete CurrentPacket;
                    }
                }
            }
        }

    return fEEInfoPresent;
}


RPC_STATUS
OSF_SCONNECTION::SendFragment(
    IN OUT rpcconn_common  *pFragment,
    IN unsigned int LastFragmentFlag,
    IN unsigned int HeaderSize,
    IN unsigned int MaxSecuritySize,
    IN unsigned int DataLength,
    IN unsigned int MaximumFragmentLength,
    IN unsigned char  *MyReservedForSec,
    IN BOOL fAsync,
    IN void *SendContext
    )
/*++
Function Name:SendFragment

Parameters:

Description:

Returns:

--*/
{
    sec_trailer  * SecurityTrailer;
    unsigned int SecurityLength;
    unsigned int AuthPadLength;
    SECURITY_BUFFER_DESCRIPTOR BufferDescriptor;
    SECURITY_BUFFER SecurityBuffers[5];
    DCE_MSG_SECURITY_INFO MsgSecurityInfo;
    RPC_STATUS Status;
    unsigned long AuthLevel;

    AuthLevel = AuthInfo.AuthenticationLevel;
    if (   ((AuthLevel != RPC_C_AUTHN_LEVEL_NONE)
           && (AuthLevel != RPC_C_AUTHN_LEVEL_CONNECT))
        || ((AuthLevel == RPC_C_AUTHN_LEVEL_CONNECT)
           &&(MaxSecuritySize != 0))  )
        {
        if ( LastFragmentFlag == 0 )
            {
            SecurityTrailer = (sec_trailer  *)
                    (((unsigned char  *) pFragment)
                    + MaximumFragmentLength - MaxSecuritySize);

            // It is not the last fragment, so we need to save away the
            // part of the buffer which could get overwritten with
            // authentication information.  We can not use memcpy,
            // because the source and destination regions may overlap.

            RpcpMemoryMove(MyReservedForSec, SecurityTrailer,
                    MaxSecuritySize);
            AuthPadLength = 0;
            }
        else
            {
            ASSERT( MAXIMUM_SECURITY_BLOCK_SIZE == 16 );
            AuthPadLength = Pad16(HeaderSize+DataLength+sizeof(sec_trailer));
            DataLength += AuthPadLength;
            ASSERT( ((DataLength + HeaderSize+sizeof(sec_trailer))
                       % MAXIMUM_SECURITY_BLOCK_SIZE) == 0 );
            SecurityTrailer = (sec_trailer  *)
                    (((unsigned char  *) pFragment) + DataLength
                    + HeaderSize);
            pFragment->pfc_flags |= PFC_LAST_FRAG;
            }

        SecurityTrailer->auth_type = (unsigned char) AuthInfo.AuthenticationService;
        SecurityTrailer->auth_level = (unsigned char) AuthLevel;
        SecurityTrailer->auth_pad_length = (unsigned char) AuthPadLength;
        SecurityTrailer->auth_reserved = 0;
        SecurityTrailer->auth_context_id = AuthContextId;

        BufferDescriptor.ulVersion = 0;
        BufferDescriptor.cBuffers = 5;
        BufferDescriptor.pBuffers = SecurityBuffers;

        SecurityBuffers[0].cbBuffer = HeaderSize;
        SecurityBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        SecurityBuffers[0].pvBuffer = ((unsigned char  *) pFragment);

        SecurityBuffers[1].cbBuffer = (LastFragmentFlag != 0 ?
                DataLength
                : (MaximumFragmentLength - HeaderSize
                  - MaxSecuritySize ));
        SecurityBuffers[1].BufferType = SECBUFFER_DATA;
        SecurityBuffers[1].pvBuffer = ((unsigned char  *) pFragment)
                + HeaderSize;

        SecurityBuffers[2].cbBuffer = sizeof(sec_trailer);
        SecurityBuffers[2].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        SecurityBuffers[2].pvBuffer = SecurityTrailer;

        SecurityBuffers[3].cbBuffer = MaxSecuritySize - sizeof(sec_trailer);
        SecurityBuffers[3].BufferType = SECBUFFER_TOKEN;
        SecurityBuffers[3].pvBuffer = SecurityTrailer + 1;

        SecurityBuffers[4].cbBuffer = sizeof(DCE_MSG_SECURITY_INFO);
        SecurityBuffers[4].BufferType = SECBUFFER_PKG_PARAMS
                | SECBUFFER_READONLY;

        SecurityBuffers[4].pvBuffer = &MsgSecurityInfo;

        MsgSecurityInfo.SendSequenceNumber =
                DceSecurityInfo.SendSequenceNumber;
        MsgSecurityInfo.ReceiveSequenceNumber =
                DceSecurityInfo.ReceiveSequenceNumber;
        MsgSecurityInfo.PacketType = pFragment->PTYPE;

        pFragment->auth_length =  (unsigned short) SecurityBuffers[3].cbBuffer;
        SecurityLength = MaxSecuritySize;

        if ( LastFragmentFlag != 0 )
            {
            pFragment->frag_length = HeaderSize + DataLength + SecurityLength;
            }
        else
            {
            pFragment->frag_length += SecurityLength - MaxSecuritySize;
            }

        Status = CurrentSecurityContext->SignOrSeal(
                MsgSecurityInfo.SendSequenceNumber,
                AuthLevel != RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                &BufferDescriptor);

        //
        // If the package computes a checksum of the read-only buffers,
        // then it should not change SecurityBuffers[3].cbBuffer.
        //

        // removed ASSERT( pFragment->auth_length == SecurityBuffers[3].cbBuffer);

        {
        //
        // The package might have updated SecurityBuffers[3].cbBuffer.
        // update the header appropriately
        //
        unsigned short AuthLengthChange = pFragment->auth_length - (unsigned short) SecurityBuffers[3].cbBuffer;

        SecurityLength         -= AuthLengthChange;
        pFragment->auth_length -= AuthLengthChange;
        pFragment->frag_length -= AuthLengthChange;
        }

        if (Status != RPC_S_OK)
            {
            if ( LastFragmentFlag == 0 )
                {
                RpcpMemoryCopy(SecurityTrailer, MyReservedForSec,
                                      MaxSecuritySize);
                }

            if (Status == ERROR_SHUTDOWN_IN_PROGRESS)
                {
                return Status;
                }

            if ( (Status == SEC_E_CONTEXT_EXPIRED)
               || (Status == SEC_E_QOP_NOT_SUPPORTED) )
                  {
                  return (RPC_S_SEC_PKG_ERROR);
                  }
            return (RPC_S_ACCESS_DENIED);
            }
        }
    else
        {
        SecurityLength = 0;
        }

    if ( LastFragmentFlag != 0 )
        {
        pFragment->pfc_flags |= PFC_LAST_FRAG;

        ASSERT(pFragment->frag_length == DataLength+HeaderSize+SecurityLength);

        if (fAsync)
            {
            Status = TransAsyncSend(
                                    pFragment,
                                    pFragment->frag_length,
                                    SendContext);

            }
        else
            {
            Status = TransSend(
                           pFragment,
                           pFragment->frag_length);
            }

        if (Status != RPC_S_OK)
            {
            if ((Status == RPC_P_CONNECTION_CLOSED)
                || (Status == RPC_P_SEND_FAILED))
                {
                return(RPC_S_CALL_FAILED_DNE);
                }
            if ( Status == RPC_P_RECEIVE_FAILED)
                {
                return(RPC_S_CALL_FAILED);
                }

            VALIDATE(Status)
                {
                RPC_S_OUT_OF_MEMORY,
                RPC_S_OUT_OF_RESOURCES
                } END_VALIDATE;
            return(Status);
            }

        return(RPC_S_OK);
        }


    ASSERT(pFragment->frag_length == MaximumFragmentLength
           - MaxSecuritySize + SecurityLength);


    if (fAsync)
        {
        Status = TransAsyncSend (
                                 pFragment,
                                 pFragment->frag_length,
                                 SendContext);

        }
    else
        {
        Status = TransSend(
                             pFragment,
                             pFragment->frag_length);

        //
        // We need to restore the part of the buffer which we overwrote
        // with authentication information.
        //
        if ((AuthLevel != RPC_C_AUTHN_LEVEL_NONE)
             &&(MaxSecuritySize != 0))
             {
             RpcpMemoryCopy(SecurityTrailer,
                            MyReservedForSec, MaxSecuritySize);
             }
        }

    if ( Status != RPC_S_OK )
        {
        if (   (Status == RPC_P_CONNECTION_CLOSED)
            || (Status == RPC_P_SEND_FAILED))
            {
            return(RPC_S_CALL_FAILED_DNE);
            }

        VALIDATE(Status)
            {
            RPC_S_OUT_OF_MEMORY,
            RPC_S_OUT_OF_RESOURCES
            } END_VALIDATE;

        return(Status);
        }

    return Status ;
}

RPC_STATUS
OSF_SCONNECTION::GetServerPrincipalName (
    IN unsigned long Flags,
    OUT RPC_CHAR **ServerPrincipalName OPTIONAL
    )
/*++

Routine Description:

    Obtains the server principal name.

Arguments:

    ServerPrincipalName - Returns the server principal name which the client
        specified.

Return Value:

    RPC_S_OK or RPC_S_* / Win32 error

--*/
{
    RPC_STATUS Status;
    SECURITY_CONTEXT * SecurityContext;

    SecurityContext = CurrentSecurityContext;

    if ( ARGUMENT_PRESENT(ServerPrincipalName) )
        {
        if (AuthInfo.AuthenticationService == RPC_C_AUTHN_GSS_SCHANNEL)
            {
            if (AuthInfo.PacHandle == 0)
                {
                Status = SecurityContext->GetDceInfo(
                                                     &AuthInfo.PacHandle,
                                                     &AuthInfo.AuthorizationService
                                                     );
                if (Status)
                    {
                    return Status;
                    }

                }

            Status = RpcCertGeneratePrincipalName( (PCCERT_CONTEXT) AuthInfo.PacHandle,
                                                    Flags,
                                                    ServerPrincipalName
                                                    );
            return Status;

            }
        else
            {
            Status = Address->Server->InquirePrincipalName(
                    SecurityContext->AuthenticationService, ServerPrincipalName);

            VALIDATE(Status)
                {
                RPC_S_OK,
                RPC_S_OUT_OF_MEMORY
                } END_VALIDATE;
            return(Status);
            }
        }

    return RPC_S_OK;
}


RPC_STATUS
OSF_SCONNECTION::InquireAuthClient (
    OUT RPC_AUTHZ_HANDLE  * Privileges,
    OUT RPC_CHAR  *  * ServerPrincipalName, OPTIONAL
    OUT unsigned long  * AuthenticationLevel,
    OUT unsigned long  * AuthenticationService,
    OUT unsigned long  * AuthorizationService,
    IN  unsigned long Flags
    )
/*++

Routine Description:

    Each protocol module must define this routine: it is used to obtain
    the authentication and authorization information about a client making
    the remote procedure call represented by this.

Arguments:

    Privileges - Returns a the privileges of the client.

    ServerPrincipalName - Returns the server principal name which the client
        specified.

    AuthenticationLevel - Returns the authentication level requested by
        the client.

    AuthenticationService - Returns the authentication service requested by
        the client.

    AuthorizationService - Returns the authorization service requested by
        the client.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_BINDING_HAS_NO_AUTH - The remote procedure call represented by
        this binding is not authenticated.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to inquire the
        server principal name.

--*/
{
    RPC_STATUS Status;
    SECURITY_CONTEXT * SecurityContext;

    SecurityContext = CurrentSecurityContext;
    if ( !SecurityContext )
        {
        return(RPC_S_BINDING_HAS_NO_AUTH);
        }

    if (AuthenticationLevel)
        {
        *AuthenticationLevel = SecurityContext->AuthenticationLevel;
        }

    if (AuthenticationService)
        {
        *AuthenticationService = SecurityContext->AuthenticationService;
        }

    if (Privileges || AuthorizationService)
        {
        if (AuthInfo.PacHandle == 0)
            {
            SecurityContext->GetDceInfo(
                     &AuthInfo.PacHandle,
                     &AuthInfo.AuthorizationService
                     );
            }

        if ( Privileges )
            {
            *Privileges = AuthInfo.PacHandle;
            }
        if ( AuthorizationService )
            {
            *AuthorizationService = AuthInfo.AuthorizationService;
            }
        }

    Status = GetServerPrincipalName(Flags, ServerPrincipalName);

    return(Status);
}

RPC_STATUS
OSF_SCONNECTION::InquireCallAttributes (
    IN OUT void *RpcCallAttributes
    )
/*++

Routine Description:

    Inquire the security context attributes for the OSF client

Arguments:

    RpcCallAttributes - a pointer to 
        RPC_CALL_ATTRIBUTES_V1_W structure. The Version
        member must be initialized.

Return Value:

    RPC_S_OK or RPC_S_* / Win32 error. EEInfo will be returned.

--*/
{
    RPC_CALL_ATTRIBUTES_V1 *CallAttributes;
    RPC_STATUS Status;
    SECURITY_CONTEXT * SecurityContext;
    RPC_CHAR *ServerPrincipalName = NULL;
    ULONG ServerPrincipalNameLength;    // in bytes, including terminating NULL

    SecurityContext = CurrentSecurityContext;
    if ( !SecurityContext )
        {
        return(RPC_S_BINDING_HAS_NO_AUTH);
        }

    CallAttributes = 
        (RPC_CALL_ATTRIBUTES_V1 *)RpcCallAttributes;

    CallAttributes->AuthenticationLevel = SecurityContext->AuthenticationLevel;
    CallAttributes->AuthenticationService = SecurityContext->AuthenticationService;
    CallAttributes->NullSession = SecurityContext->ContextAttributes & ASC_RET_NULL_SESSION;

    if (CallAttributes->Flags & RPC_QUERY_CLIENT_PRINCIPAL_NAME)
        {
        CallAttributes->ClientPrincipalNameBufferLength = 0;
        }

    if (CallAttributes->Flags & RPC_QUERY_SERVER_PRINCIPAL_NAME)
        {
        Status = GetServerPrincipalName(CallAttributes->Flags,
            &ServerPrincipalName);

        if (Status != RPC_S_OK)
            return Status;

        if (ServerPrincipalName)
            {
            ServerPrincipalNameLength = (RpcpStringLength(ServerPrincipalName) + 1) * sizeof(RPC_CHAR);
            // now, see whether the user supplied memory is big enough
            if (CallAttributes->ServerPrincipalNameBufferLength < ServerPrincipalNameLength)
                {
                Status = ERROR_MORE_DATA;
                }
            else
                {
                // a buffer is specified, and it is large enough
                RpcpMemoryCopy(CallAttributes->ServerPrincipalName,
                    ServerPrincipalName,
                    ServerPrincipalNameLength);
                Status = RPC_S_OK;
                }

            // in both cases store the resulting length
            CallAttributes->ServerPrincipalNameBufferLength = ServerPrincipalNameLength;

            RpcStringFree(&ServerPrincipalName);
            }
        else
            {
            CallAttributes->ServerPrincipalNameBufferLength = 0;
            }
        return Status;
        }
    else
        {
        return RPC_S_OK;
        }
}

OSF_SBINDING *
OSF_SCONNECTION::LookupBinding (
   IN p_context_id_t PresentContextId
   )
/*++
Function Name:LookupBinding

Parameters:

Description:

Returns:

--*/
{
    OSF_SBINDING *CurBinding;
    DictionaryCursor cursor;

    Bindings.Reset(cursor);
    while ((CurBinding = Bindings.Next(cursor)))
        {
        if (CurBinding->GetPresentationContext() == PresentContextId)
            {
            return CurBinding;
            }
        }

    return NULL;
}

RPC_STATUS
OSF_SCONNECTION::GetAssociationContextCollection (
    OUT ContextCollection **CtxCollection
    )
{
    return Association->GetAssociationContextCollection(CtxCollection);
}


RPC_STATUS
OSF_SCONNECTION::IsClientLocal (
    OUT unsigned int  * ClientLocalFlag
    )
/*++

Routine Description:

    We just need to inquire the client process identifier for this
    connection; if the first part is zero, then the client is local.

Arguments:

    ClientLocalFlag - Returns an indication of whether or not the client is
        local (ie. on the same machine as the server).  This field will be
        set to a non-zero value to indicate that the client is local;
        otherwise, the client is remote.

Return Value:

    RPC_S_OK - This will always be used.

--*/
{
    RPC_CLIENT_PROCESS_IDENTIFIER ClientProcess;
    int i;

    TransQueryClientProcess(&ClientProcess);

    if ( ClientProcess.IsLocal() == FALSE )
        {
        if (ClientProcess.IsNull())
            return RPC_S_CANNOT_SUPPORT;

        *ClientLocalFlag = 0;
        }
    else
        {
        *ClientLocalFlag = 1;
        }

    return(RPC_S_OK);
}

int
OSF_SCONNECTION::SendBindNak (
    IN p_reject_reason_t reject_reason,
    IN unsigned long CallId
    )
{
    rpcconn_bind_nak *BindNak;
    size_t BindNakSize;
    BOOL fEEInfoPresent = FALSE;
    int RetVal;

    if (g_fSendEEInfo)
        {
        fEEInfoPresent = PickleEEInfoIntoPacket(BindNakSizeWithoutEEInfo,
            (PVOID *) &BindNak,
            &BindNakSize);
        }

    if (fEEInfoPresent == FALSE)
        {
        BindNakSize = BindNakSizeWithoutEEInfoAndSignature;
        BindNak = (rpcconn_bind_nak *)_alloca(BindNakSize);
        RpcpMemorySet(BindNak, 0, BindNakSize);
        }
    else
        {
        RpcpMemoryCopy (&BindNak->Signature, 
            BindNakEEInfoSignature,
            sizeof (UUID));
        }

    ConstructPacket((rpcconn_common *) BindNak, rpc_bind_nak, BindNakSize);
    BindNak->provider_reject_reason = reject_reason;
    BindNak->versions.n_protocols = 1;
    BindNak->versions.p_protocols[0].major = OSF_RPC_V20_VERS;
    BindNak->versions.p_protocols[0].minor = 0;
    BindNak->common.call_id = CallId;
    BindNak->common.pfc_flags = PFC_FIRST_FRAG | PFC_LAST_FRAG ;

    if (TransSend(BindNak,BindNakSize))
        {
        RetVal = -1;
        }
    else
        {
        RetVal = 0;
        }

    if (fEEInfoPresent)
        {
        delete BindNak;
        }

    return RetVal;
}

typedef struct tagSelectedInterfaceAndTransferSyntaxInfo
{
    RPC_INTERFACE *Interface;
    int SelectedAvailableTransferSyntaxIndex;
} SelectedInterfaceAndTransferSyntaxInfo;

int
OSF_SCONNECTION::ProcessPContextList (
    IN OSF_ADDRESS * Address,
    IN p_cont_list_t *PContextList,
    IN OUT unsigned int * PContextListLength,
    OUT p_result_list_t *ResultList
    )
/*++

Routine Description:

Arguments:

    Address - Supplies the address which owns this connection.  We need
        this information so that we can try to find the interface (and
        transfer syntax) the client requested.

    PContextList - Supplies a pointer to the presentation context list
        which the client passed in the rpc_bind packet.  It has not yet
        had data conversion performed on it.

    PContextListLength - Supplies the maximum possible length of the
        presentation context list, and returns its actual length.  The
        lengths are in bytes as usual.

    ResultList - Returns the result list corresponding to the presentation
        context list.

Return Value:

    A non-zero value will be returned if we are unable to process the
    presentation context list.  The caller should send an rpc_bind_nak
    packet to the client, and then close the connection.

--*/
{
    p_cont_elem_t *PContextElem;
    unsigned int PContextListIndex;
    unsigned int TransferSyntaxIndex;
    SelectedInterfaceAndTransferSyntaxInfo *SelectionInfo;
    OSF_SBINDING * SBinding;
    RPC_STATUS Status;
    BOOL fInterfaceTransferIsPreferred;
    p_result_t *PResultElem;
    int PreferredPContextIndex;
    BOOL fRejectCurrentContext;
    BOOL fPContextAlreadyAccepted;
    unsigned int NumberOfPContextElements;
    int fIgnored;

    if (*PContextListLength < sizeof(p_cont_list_t))
        {
        return(1);
        }

    NumberOfPContextElements = (unsigned int) PContextList->n_context_elem;

    // make sure the client doesn't offer a gaziliion pcontexts
    if (NumberOfPContextElements > 20)
        {
        return 1;
        }

    SelectionInfo = (SelectedInterfaceAndTransferSyntaxInfo *)
        _alloca(sizeof(SelectedInterfaceAndTransferSyntaxInfo) * NumberOfPContextElements);

    *PContextListLength -= (sizeof(p_cont_list_t) - sizeof(p_cont_elem_t));
    ResultList->n_results = PContextList->n_context_elem;
    ResultList->reserved = 0;
    ResultList->reserved2 = 0;

    PreferredPContextIndex = -1;

    for (PContextListIndex = 0, PContextElem = PContextList->p_cont_elem;
         PContextListIndex < NumberOfPContextElements;
         PContextListIndex ++)
        {
        if (*PContextListLength < sizeof(p_cont_elem_t))
            {
            return(1);
            }

        if (*PContextListLength < (sizeof(p_cont_elem_t) + sizeof(p_syntax_id_t)
                * (PContextElem->n_transfer_syn - 1)))
            {
            return(1);
            }

        *PContextListLength -= (sizeof(p_cont_elem_t) + sizeof(p_syntax_id_t)
                * (PContextElem->n_transfer_syn - 1));

        if ( DataConvertEndian(((unsigned char *) &DataRep)) != 0 )
            {
            PContextElem->p_cont_id = RpcpByteSwapShort(PContextElem->p_cont_id);
            ByteSwapSyntaxId(&PContextElem->abstract_syntax);
            for ( TransferSyntaxIndex = 0;
                    TransferSyntaxIndex < PContextElem->n_transfer_syn;
                    TransferSyntaxIndex++ )
                {
                ByteSwapSyntaxId(&(PContextElem->transfer_syntaxes[
                        TransferSyntaxIndex]));
                }
            }

        Status = Address->FindInterfaceTransfer(
                (PRPC_SYNTAX_IDENTIFIER)
                &PContextElem->abstract_syntax.if_uuid,
                (PRPC_SYNTAX_IDENTIFIER) PContextElem->transfer_syntaxes,
                PContextElem->n_transfer_syn,
                (PRPC_SYNTAX_IDENTIFIER)
                &(ResultList->p_results[PContextListIndex].transfer_syntax),
                &SelectionInfo[PContextListIndex].Interface,
                &fInterfaceTransferIsPreferred,
                &fIgnored,
                &SelectionInfo[PContextListIndex].SelectedAvailableTransferSyntaxIndex);

        if (Status == RPC_S_OK)
            {
            ResultList->p_results[PContextListIndex].result = acceptance;
            ResultList->p_results[PContextListIndex].reason = 0;

            if (fInterfaceTransferIsPreferred)
                {
                // only one pcontext can be preferred. If not, there is
                // error in the stubs
                ASSERT(PreferredPContextIndex == -1);
                PreferredPContextIndex = PContextListIndex;
                }

            // for all accepted we will make a second pass once we know
            // which transfer syntax will be selected
            }
        else
            {
            ResultList->p_results[PContextListIndex].result =
                            provider_rejection;
            if (Status == RPC_S_UNSUPPORTED_TRANS_SYN)
                {
                ResultList->p_results[PContextListIndex].reason =
                                proposed_transfer_syntaxes_not_supported;
                }
            else
                {
                ASSERT(Status == RPC_S_UNKNOWN_IF);
                ResultList->p_results[PContextListIndex].reason =
                                abstract_syntax_not_supported;
                }

            memset(&(ResultList->p_results[PContextListIndex].
                    transfer_syntax.if_uuid.Data1),0,sizeof(GUID));
            ResultList->p_results[PContextListIndex].
                            transfer_syntax.if_version = 0;
            }

        PContextElem = (p_cont_elem_t *) ((unsigned char *)PContextElem + sizeof(p_cont_elem_t)
            + sizeof(p_syntax_id_t) * (PContextElem->n_transfer_syn - 1));
        }

    fPContextAlreadyAccepted = FALSE;
    for (PContextListIndex = 0, PResultElem = ResultList->p_results,
        PContextElem = PContextList->p_cont_elem;
        PContextListIndex < NumberOfPContextElements;
        PContextListIndex ++, PResultElem = &(ResultList->p_results[PContextListIndex]))
        {
        fRejectCurrentContext = TRUE;

        // if there is a preferred context ...
        if (PreferredPContextIndex >= 0)
            {
            // ... and this is the one, don't reject it
            if ((unsigned int)PreferredPContextIndex == PContextListIndex)
                {
                ASSERT(PResultElem->result == acceptance);
                fRejectCurrentContext = FALSE;
                }
            else
                {
                // else nothing - this is not the preferred one, and the
                // default action is reject it
                }
            }
        else if (PResultElem->result == acceptance)
            {
            // if we haven't already accepted one, accept the current
            if (!fPContextAlreadyAccepted)
                {
                fRejectCurrentContext = FALSE;
                fPContextAlreadyAccepted = TRUE;
                }
            else
                {
                // else nothing - we have already accepted one and
                // we will reject this one
                }
            }

        if (!fRejectCurrentContext)
            {
            SBinding = new OSF_SBINDING(SelectionInfo[PContextListIndex].Interface,
                    PContextElem->p_cont_id,
                    SelectionInfo[PContextListIndex].SelectedAvailableTransferSyntaxIndex);

            if (   (SBinding == 0)
                || (Bindings.Insert(SBinding) == -1))
                {
                PResultElem->result = provider_rejection;
                PResultElem->reason = local_limit_exceeded;
                memset(&(PResultElem->transfer_syntax.if_uuid.Data1), 0, sizeof(p_syntax_id_t));
                }
            }
        else if (PResultElem->result == acceptance)
            {
            // apparently we have already accepted somebody, and this is not the
            // lucky one
            PResultElem->result = provider_rejection;
            PResultElem->reason = proposed_transfer_syntaxes_not_supported;
            memset(&(PResultElem->transfer_syntax.if_uuid.Data1), 0, sizeof(p_syntax_id_t));
            }
        else
            {
            // nothing - we have to reject the current one, and it has already
            // been rejected
            }

        PContextElem = (p_cont_elem_t *) ((unsigned char *)PContextElem + sizeof(p_cont_elem_t)
            + sizeof(p_syntax_id_t) * (PContextElem->n_transfer_syn - 1));
        }

    return(0);
}

unsigned short // Return the minimum of the three arguments.
MinOf (
    IN unsigned short Arg1,
    IN unsigned short Arg2,
    IN unsigned short Arg3
    )
{
    unsigned short Min = 0xFFFF;

    if (Arg1 < Min)
        Min = Arg1;
    if (Arg2 < Min)
        Min = Arg2;
    if (Arg3 < Min)
        Min = Arg3;
    return(Min);
}

int
OSF_SCONNECTION::AssociationRequested (
    IN rpcconn_bind * BindPacket,
    IN unsigned int BindPacketLength
    )
/*++

Routine Description:

Arguments:

    Address - Supplies the address which owns this connection.

    BindPacket - Supplies the buffer containing the rpc_bind packet
        received from the client.

    BindPacketLength - Supplies the length of the buffer in bytes.

Return Value:

    A non-zero return value indicates that the connection needs to
    be deleted by the caller.

--*/
{
    p_cont_list_t * PContextList;
    unsigned int SecondaryAddressLength;
    unsigned int BindAckLength, TokenLength = 0, AuthPadLength;
    rpcconn_bind_ack * BindAck;
    RPC_STATUS Status;
    sec_trailer  * SecurityTrailer,  * NewSecurityTrailer;
    SECURITY_CREDENTIALS * SecurityCredentials = 0;
    RPC_CLIENT_PROCESS_IDENTIFIER ClientProcess;
    unsigned int CompleteNeeded = 0;
    SECURITY_BUFFER_DESCRIPTOR InputBufferDescriptor;
    SECURITY_BUFFER_DESCRIPTOR OutputBufferDescriptor;
    SECURITY_BUFFER InputBuffers[4];
    SECURITY_BUFFER OutputBuffers[4];
    unsigned long CallId = BindPacket->common.call_id;
    ULONG CalculatedSize;

    PContextList = (p_cont_list_t *) (BindPacket + 1);

    CalculatedSize = sizeof(rpcconn_bind)+sizeof(p_cont_list_t)
                        + (PContextList->n_context_elem-1)*sizeof(p_cont_elem_t);

    DataRep = * (unsigned long  *) BindPacket->common.drep;

    if ( BindPacketLength < CalculatedSize )
        {
        TransFreeBuffer(BindPacket);
        SendBindNak(reason_not_specified_reject, CallId);
        return(1);
        }

    if ( DataConvertEndian(BindPacket->common.drep) != 0 )
        {
        BindPacket->max_xmit_frag = RpcpByteSwapShort(BindPacket->max_xmit_frag);
        BindPacket->max_recv_frag = RpcpByteSwapShort(BindPacket->max_recv_frag);
        BindPacket->assoc_group_id = RpcpByteSwapLong(BindPacket->assoc_group_id);
        }

    ASSERT(TransMaximumSend() % 8 == 0);

    MaxFrag = MinOf(BindPacket->max_xmit_frag,
                    BindPacket->max_recv_frag,
                    (unsigned short) TransMaximumSend()) & 0xFFFFFFF8;

    if ( MaxFrag < MUST_RECV_FRAG_SIZE )
        MaxFrag = MUST_RECV_FRAG_SIZE;

    ASSERT(MaxFrag % 8 == 0);

    // Now we need to check to see if we should be performing authentication
    // at the rpc protocol level.  This will be the case if there is
    // authentication information in the packet.

    if ( BindPacket->common.auth_length != 0 )
        {
        // Ok, we have got authentication information in the packet.  We
        // will save away the information, and then check it.

        SecurityTrailer = (sec_trailer  *)
                (((unsigned char  *) BindPacket) + BindPacketLength
                - BindPacket->common.auth_length - sizeof(sec_trailer));


        AuthInfo.AuthenticationLevel = SecurityTrailer->auth_level;

        //Hack for OSF Clients
        //If Level is CALL .. bump it ip to CONNECT
        if (AuthInfo.AuthenticationLevel == RPC_C_AUTHN_LEVEL_CALL)
           {
           AuthInfo.AuthenticationLevel = RPC_C_AUTHN_LEVEL_PKT;
           }
        if (   (AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_CONNECT)
            && (AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_PKT)
            && (AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
            && (AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_PKT_PRIVACY) )
            {
            TransFreeBuffer(BindPacket);
            SendBindNak(reason_not_specified_reject, CallId);
            return(1);
            }
        AuthInfo.AuthenticationService = SecurityTrailer->auth_type;
        AuthContextId = SecurityTrailer->auth_context_id;

        if ( DataConvertEndian(BindPacket->common.drep) != 0 )
            {
            AuthContextId = RpcpByteSwapLong(AuthContextId);
            }

        RPC_STATUS Status = RPC_S_OK;
        CurrentSecurityContext = new SECURITY_CONTEXT(
                                             &AuthInfo,
                                             AuthContextId,
                                             FALSE,
                                             &Status
                                             );

        if ( (CurrentSecurityContext == 0)
           || RPC_S_OK != Status
           ||(SecurityContextDict.Insert(CurrentSecurityContext) == -1) )
            {
            TransFreeBuffer(BindPacket);
            SendBindNak(local_limit_exceeded_reject, CallId);
            return(1);
            }

        CallTestHook( TH_RPC_SECURITY_SERVER_CONTEXT_CREATED, CurrentSecurityContext, this );

        RpcSecurityBeingUsed = 1;
        Status = Address->Server->AcquireCredentials(
                AuthInfo.AuthenticationService, AuthInfo.AuthenticationLevel,
                &SecurityCredentials);
        if ( Status == RPC_S_OUT_OF_MEMORY )
            {
            TransFreeBuffer(BindPacket);
            SendBindNak(local_limit_exceeded_reject, CallId);
            return(1);
            }
        if ( Status != RPC_S_OK )
            {
            TransFreeBuffer(BindPacket);
            RpcpErrorAddRecord(EEInfoGCRuntime,
                Status,
                EEInfoDLAssociationRequested30,
                AuthInfo.AuthenticationService,
                AuthInfo.AuthenticationLevel);
            SendBindNak(authentication_type_not_recognized, CallId);
            return(1);
            }
        ASSERT( SecurityCredentials != 0 );
        }

    // Calculate the size of the rpc_bind_ack packet.

    SecondaryAddressLength = Address->TransSecondarySize();
    BindAckLength = sizeof(rpcconn_bind_ack) + SecondaryAddressLength
                    + Pad4(SecondaryAddressLength + 2) + sizeof(p_result_list_t)
                    + sizeof(p_result_t) * (PContextList->n_context_elem - 1);

    // Ok, we need to save some space for authentication information if
    // necessary.  This includes space for the token, the security trailer,
    // and alignment if necessary.

    if ( SecurityCredentials != 0 )
        {
        AuthPadLength = Pad4(BindAckLength);
        BindAckLength += SecurityCredentials->MaximumTokenLength()
                + sizeof(sec_trailer) + AuthPadLength;
        }

    // Allocate the rpc_bind_ack packet.  If that fails, send a rpc_bind_nak
    // to the client indicating that the server is out of resources;
    // whoever called AssociationRequested will take care of cleaning up
    // the connection.

    Status = TransGetBuffer((void **) &BindAck, BindAckLength);
    if ( Status != RPC_S_OK )
        {
        ASSERT( Status == RPC_S_OUT_OF_MEMORY );

        if ( SecurityCredentials != 0 )
            {
            SecurityCredentials->DereferenceCredentials();
            }
        TransFreeBuffer(BindPacket);
        SendBindNak(local_limit_exceeded_reject, CallId);
        return(1);
        }

    // Finally we get to do something about that authentication that the
    // client sent us.

    if ( SecurityCredentials != 0 )
        {
        NewSecurityTrailer = (sec_trailer  *)
                (((unsigned char  *) BindAck) + BindAckLength
                - SecurityCredentials->MaximumTokenLength()
                - sizeof(sec_trailer));

        InitSecurityInfo.DceSecurityInfo = DceSecurityInfo;
        InitSecurityInfo.PacketType = BindPacket->common.PTYPE;
        InputBufferDescriptor.ulVersion = 0;
        InputBufferDescriptor.cBuffers = 4;
        InputBufferDescriptor.pBuffers = InputBuffers;

        InputBuffers[0].cbBuffer = sizeof(rpcconn_bind);
        InputBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        InputBuffers[0].pvBuffer = SavedHeader;

        InputBuffers[1].cbBuffer = BindPacket->common.frag_length
                - sizeof(rpcconn_bind) - BindPacket->common.auth_length;
        InputBuffers[1].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        InputBuffers[1].pvBuffer = (char *) SavedHeader +
                                            sizeof(rpcconn_bind);

        InputBuffers[2].cbBuffer = BindPacket->common.auth_length;
        InputBuffers[2].BufferType = SECBUFFER_TOKEN;
        InputBuffers[2].pvBuffer = SecurityTrailer + 1;
        InputBuffers[3].cbBuffer = sizeof(DCE_INIT_SECURITY_INFO);
        InputBuffers[3].BufferType = SECBUFFER_PKG_PARAMS | SECBUFFER_READONLY;
        InputBuffers[3].pvBuffer = &InitSecurityInfo;

        OutputBufferDescriptor.ulVersion = 0;
        OutputBufferDescriptor.cBuffers = 4;
        OutputBufferDescriptor.pBuffers = OutputBuffers;

        OutputBuffers[0].cbBuffer = sizeof(rpcconn_bind_ack)
                - sizeof(unsigned short);
        OutputBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        OutputBuffers[0].pvBuffer = BindAck;
        OutputBuffers[1].cbBuffer = BindAckLength
                - SecurityCredentials->MaximumTokenLength()
                - (sizeof(rpcconn_bind_ack) - sizeof(unsigned short));
        OutputBuffers[1].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        OutputBuffers[1].pvBuffer = ((unsigned char *) BindAck)
            + sizeof(rpcconn_bind_ack) - sizeof(unsigned short);
        OutputBuffers[2].cbBuffer = SecurityCredentials->MaximumTokenLength();
        OutputBuffers[2].BufferType = SECBUFFER_TOKEN;
        OutputBuffers[2].pvBuffer = NewSecurityTrailer + 1;
        OutputBuffers[3].cbBuffer = sizeof(DCE_INIT_SECURITY_INFO);
        OutputBuffers[3].BufferType = SECBUFFER_PKG_PARAMS | SECBUFFER_READONLY;
        OutputBuffers[3].pvBuffer = &InitSecurityInfo;

        Status = CurrentSecurityContext->AcceptFirstTime(
                               SecurityCredentials,
                               &InputBufferDescriptor,
                               &OutputBufferDescriptor,
                               SecurityTrailer->auth_level,
                               *((unsigned long  *) BindPacket->common.drep),
                               0);

        LogEvent(SU_SCONN, EV_SEC_ACCEPT1, this, LongToPtr(Status), OutputBuffers[2].cbBuffer);

#if 0
        if (Status == SEC_E_BUFFER_TOO_SMALL)
            {
            unsigned long NewTokenLength = OutputBuffers[2].cbBuffer;

            TransFreeBuffer( BindAck );

            BindAckLength = sizeof(rpcconn_bind_ack) + SecondaryAddressLength
                            + Pad4(SecondaryAddressLength + 2) + sizeof(p_result_list_t)
                            + sizeof(p_result_t) * (PContextList->n_context_elem - 1);

            AuthPadLength = Pad4(BindAckLength);
            BindAckLength += NewTokenLength
                          + sizeof(sec_trailer) + AuthPadLength;

            Status = TransGetBuffer((void **) &BindAck, BindAckLength);
            if ( Status != RPC_S_OK )
                {
                ASSERT( Status == RPC_S_OUT_OF_MEMORY );

                SecurityCredentials->DereferenceCredentials();

                TransFreeBuffer(BindPacket);
                SendBindNak(local_limit_exceeded_reject, CallId);
                return(1);
                }

            NewSecurityTrailer = (sec_trailer  *)
                    (((unsigned char  *) BindAck) + BindAckLength
                    - NewTokenLength
                    - sizeof(sec_trailer));

            OutputBufferDescriptor.ulVersion = 0;
            OutputBufferDescriptor.cBuffers = 4;
            OutputBufferDescriptor.pBuffers = OutputBuffers;

            OutputBuffers[0].cbBuffer = sizeof(rpcconn_bind_ack)
                    - sizeof(unsigned short);
            OutputBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
            OutputBuffers[0].pvBuffer = BindAck;
            OutputBuffers[1].cbBuffer = BindAckLength
                    - NewTokenLength
                    - (sizeof(rpcconn_bind_ack) - sizeof(unsigned short));
            OutputBuffers[1].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
            OutputBuffers[1].pvBuffer = ((unsigned char *) BindAck)
                + sizeof(rpcconn_bind_ack) - sizeof(unsigned short);
            OutputBuffers[2].cbBuffer = NewTokenLength;
            OutputBuffers[2].BufferType = SECBUFFER_TOKEN;
            OutputBuffers[2].pvBuffer = NewSecurityTrailer + 1;
            OutputBuffers[3].cbBuffer = sizeof(DCE_INIT_SECURITY_INFO);
            OutputBuffers[3].BufferType = SECBUFFER_PKG_PARAMS | SECBUFFER_READONLY;
            OutputBuffers[3].pvBuffer = &InitSecurityInfo;

            Status = CurrentSecurityContext->AcceptFirstTime(
                                   SecurityCredentials,
                                   &InputBufferDescriptor,
                                   &OutputBufferDescriptor,
                                   SecurityTrailer->auth_level,
                                   *((unsigned long  *) BindPacket->common.drep),
                                   0);

            LogEvent(SU_SCONN, EV_SEC_ACCEPT1, this, (void *) Status, OutputBuffers[2].cbBuffer);

            }
#endif

        TokenLength = (unsigned int) OutputBuffers[2].cbBuffer;

        if (   ( Status == RPC_P_CONTINUE_NEEDED )
            || ( Status == RPC_S_OK )
            || ( Status == RPC_P_COMPLETE_NEEDED )
            || ( Status == RPC_P_COMPLETE_AND_CONTINUE ) )
            {
            if ( Status == RPC_P_CONTINUE_NEEDED )
                {
                AuthContinueNeeded = 1;
                }
            else if ( Status == RPC_P_COMPLETE_AND_CONTINUE )
                {
                AuthContinueNeeded = 1;
                CompleteNeeded = 1;
                }
            else if ( Status == RPC_P_COMPLETE_NEEDED )
                {
                CompleteNeeded = 1;
                }

            BindAckLength = BindAckLength + TokenLength
                    - SecurityCredentials->MaximumTokenLength();

            NewSecurityTrailer->auth_type = SecurityTrailer->auth_type;
            NewSecurityTrailer->auth_level = SecurityTrailer->auth_level;
            NewSecurityTrailer->auth_pad_length = (unsigned char) AuthPadLength;
            NewSecurityTrailer->auth_reserved = 0;
            NewSecurityTrailer->auth_context_id = AuthContextId;

            SecurityCredentials->DereferenceCredentials();
            }
        else
            {
            VALIDATE(Status)
                {
                RPC_S_OUT_OF_MEMORY,
                RPC_S_ACCESS_DENIED,
                ERROR_SHUTDOWN_IN_PROGRESS,
                RPC_S_UNKNOWN_AUTHN_SERVICE
                } END_VALIDATE;

            TransFreeBuffer(BindPacket);
            TransFreeBuffer(BindAck);
            SecurityCredentials->DereferenceCredentials();

            if (Status == RPC_S_OUT_OF_MEMORY)
                {
                SendBindNak(local_limit_exceeded_reject, CallId);
                }
            else
            if (Status == RPC_S_UNKNOWN_AUTHN_SERVICE ||
                Status == ERROR_SHUTDOWN_IN_PROGRESS )
                {
                SendBindNak(authentication_type_not_recognized, CallId);
                }
            else
                {
                SendBindNak(invalid_checksum, CallId);
                }
            return(1);
            }
        }


    TransQueryClientProcess(&ClientProcess);

    if ( BindPacket->assoc_group_id != 0 )
        {
        // This means this is a connection on an existing association.

        Association = Address->FindAssociation(
                (int) BindPacket->assoc_group_id, &ClientProcess);

        if ( Association == 0 )
            {
            RpcpErrorAddRecord (EEInfoGCRuntime,
                RPC_S_ENTRY_NOT_FOUND,
                EEInfoDLAssociationRequested10,
                BindPacket->assoc_group_id,
                ClientProcess.GetDebugULongLong1(),
                ClientProcess.GetDebugULongLong2());

            TransFreeBuffer(BindPacket);
            TransFreeBuffer(BindAck);
            SendBindNak(reason_not_specified_reject, CallId);
            return(1);
            }
        }
    if ( Association == 0 )
        {
        Association = new OSF_ASSOCIATION(Address, &ClientProcess, &Status);
        if ( (Association == 0) || (Status != RPC_S_OK) )
            {
            if (Association != 0)
                {
                delete Association;
                Association = NULL;
                }
            TransFreeBuffer(BindPacket);
            TransFreeBuffer(BindAck);
            RpcpErrorAddRecord (EEInfoGCRuntime,
                Status,
                EEInfoDLAssociationRequested20,
                sizeof(OSF_ASSOCIATION));
            SendBindNak(local_limit_exceeded_reject, CallId);
            return(1);
            }
        }

    BindPacketLength -= sizeof(rpcconn_bind);
    if ( ProcessPContextList(Address, PContextList, &BindPacketLength,
            (p_result_list_t *) (((unsigned char *) BindAck) + sizeof(rpcconn_bind_ack)
            + SecondaryAddressLength + Pad4(SecondaryAddressLength + 2))) != 0 )
        {
        TransFreeBuffer(BindPacket);
        TransFreeBuffer(BindAck);
        SendBindNak(reason_not_specified_reject, CallId);
        return(1);
        }

    // Fill in the header of the rpc_bind_ack packet.

    ConstructPacket((rpcconn_common *) BindAck, rpc_bind_ack, BindAckLength);

    BindAck->max_xmit_frag = BindAck->max_recv_frag = MaxFrag;
    BindAck->assoc_group_id = Association->AssocGroupId();
    BindAck->sec_addr_length = (unsigned short) SecondaryAddressLength;
    BindAck->common.call_id = CallId;

    if (PFC_CONC_MPX & BindPacket->common.pfc_flags)
        {
        ((rpcconn_common  *) BindAck)->pfc_flags |=
            (PFC_FIRST_FRAG | PFC_LAST_FRAG | PFC_CONC_MPX) ;
        }
    else
        {
        fExclusive = 1;
        ((rpcconn_common  *) BindAck)->pfc_flags |=
            (PFC_FIRST_FRAG | PFC_LAST_FRAG) ;
        }

    DceSecurityInfo.ReceiveSequenceNumber += 1;

    if ( SecondaryAddressLength != 0 )
        {
        Status = Address->TransSecondary((unsigned char *) (BindAck + 1),
                                 SecondaryAddressLength);
        if (Status != RPC_S_OK)
            {
            ASSERT(Status == RPC_S_OUT_OF_MEMORY);
            TransFreeBuffer(BindPacket);
            TransFreeBuffer(BindAck);
            SendBindNak(reason_not_specified_reject, CallId);
            return(1);
            }
        }

    // The result list has already been filled in by ProcessPContextList.
    // All that is left to do, is fill in the authentication information.

    BindAck->common.auth_length = (unsigned short) TokenLength;

    // Send the rpc_bind_ack packet back to the client.

    TransFreeBuffer(BindPacket);

    if ( CompleteNeeded != 0 )
        {
        Status = CurrentSecurityContext->CompleteSecurityToken(
                                              &OutputBufferDescriptor);
        if (Status != RPC_S_OK)
            {
            TransFreeBuffer(BindAck);
            SendBindNak(invalid_checksum, CallId);
            return(1);
            }
        }

    //
    // We may need to do third leg AuthInfo.Authentication.
    // we will do that when we receive the third leg packet
    //
    if ( AuthContinueNeeded == 0 )
        {
        //
        // We need to figure out how much space to reserve for security
        // information at the end of request and response packets.
        // In addition to saving space for the signature or header,
        // we need space to pad the packet to a multiple of the maximum
        // security block size as well as for the security trailer.
        //

        //
        // In the case where we need a third leg, this information will be obtained
        // after we process the third leg packet.
        //
        if ((AuthInfo.AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
            ||(AuthInfo.AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT)
            ||(AuthInfo.AuthenticationLevel == RPC_C_AUTHN_LEVEL_CONNECT) )
            {
            AdditionalSpaceForSecurity = MAXIMUM_SECURITY_BLOCK_SIZE
                + CurrentSecurityContext->MaximumSignatureLength()
                + sizeof(sec_trailer);
            }
        else if (AuthInfo.AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT_PRIVACY)
            {
            AdditionalSpaceForSecurity = MAXIMUM_SECURITY_BLOCK_SIZE
                + CurrentSecurityContext->MaximumHeaderLength()
                + sizeof(sec_trailer);
            }
        }

    //
    // Sending the bind ack should be the last thing we do
    // in this function. The action will continue in the processing
    // of the third leg.
    //
    Status = TransSend(BindAck, BindAckLength);
    TransFreeBuffer(BindAck);
    if ( Status != RPC_S_OK )
        {
        return(1);
        }

    if (DebugCell)
        {
        DWORD LocalFlags = 0;

        if (AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE)
            {
            LocalFlags = AuthInfo.AuthenticationLevel << 1;
            switch (AuthInfo.AuthenticationService)
                {
                case RPC_C_AUTHN_WINNT:
                    LocalFlags |= DBGCELL_AUTH_SVC_NTLM;
                    break;

                case RPC_C_AUTHN_GSS_KERBEROS:
                case RPC_C_AUTHN_GSS_NEGOTIATE:
                    LocalFlags |= DBGCELL_AUTH_SVC_KERB;
                    break;

                default:
                    ASSERT(AuthInfo.AuthenticationService);
                    LocalFlags |= DBGCELL_AUTH_SVC_OTHER;
                }
            }

        if (fExclusive)
            LocalFlags |= 1;

        DebugCell->ConnectionID[0] = ULongToPtr(ClientProcess.GetDebugULong1());
        DebugCell->ConnectionID[1] = ULongToPtr(ClientProcess.GetDebugULong2());

        DebugCell->Flags = (unsigned char)LocalFlags;
        }

    return(0);
}


int
OSF_SCONNECTION::AlterContextRequested (
    IN rpcconn_alter_context * AlterContext,
    IN unsigned int AlterContextLength
    )
/*++

Routine Description:

Arguments:

    AlterContext - Supplies the buffer containing the rpc_alter_context
        packet received from the client.

    AlterContextLength - Supplies the length of the buffer in bytes.

    Address - Supplies the address which owns this connection.

Return Value:

    A non-zero return value indicates that the connection needs to
    be deleted by the caller.

--*/
{
    p_cont_list_t *PContextList;
    rpcconn_alter_context_resp * AlterContextResp = 0;
    unsigned int AlterContextRespLength = 0;
    unsigned int TokenLength = 0;
    unsigned int CompleteNeeded = 0;
    RPC_STATUS Status;
    sec_trailer  * SecurityTrailer,  * NewSecurityTrailer;
    SECURITY_BUFFER_DESCRIPTOR InputBufferDescriptor;
    SECURITY_BUFFER_DESCRIPTOR OutputBufferDescriptor;
    SECURITY_BUFFER InputBuffers[4];
    SECURITY_BUFFER OutputBuffers[4];
    DCE_INIT_SECURITY_INFO InitSecurityInfo;
    SECURITY_CREDENTIALS * SecurityCredentials = 0;
    unsigned long SecureAlterContext = 0;
    unsigned int AuthPadLength;
    unsigned long NewContextRequired = 0;
    CLIENT_AUTH_INFO NewClientInfo;
    unsigned NewId;
    SECURITY_CONTEXT * SecId;
    unsigned long CallId = AlterContext->common.call_id;
    ULONG CalculatedSize;

    //
    // The packet has already been validate by whoever called this method.
    // Data conversion of the common part of the header was performed at
    // that time as well.  We do not use the max_xmit_frag, max_recv_frag,
    // or assoc_group_id fields of the packet, so we will not bother to
    // data convert them.
    //

    // make sure PContextList is there
    if ( AlterContextLength <
        sizeof(rpcconn_alter_context) + sizeof(p_cont_list_t))
        {
        SendFault(RPC_S_ACCESS_DENIED, 1, CallId);
        TransFreeBuffer(AlterContext);
        return(1);
        }

    PContextList = (p_cont_list_t *) (AlterContext + 1);

    CalculatedSize = sizeof(rpcconn_alter_context)+sizeof(p_cont_list_t)
                        + (PContextList->n_context_elem-1)*sizeof(p_cont_elem_t);

    DataRep = * (unsigned long  *) AlterContext->common.drep;

    if ( AlterContextLength <  CalculatedSize)
        {
        SendFault(RPC_S_ACCESS_DENIED, 1, CallId);
        TransFreeBuffer(AlterContext);
        return(1);
        }

    if ( AlterContext->common.auth_length != 0 )
        {
        //
        // We are dealing with a secure alter context
        // it may be adding a presentation context
        // or a new security context
        //
        SecureAlterContext = 1;
        SecurityTrailer = (sec_trailer  *)
                (((unsigned char  *) AlterContext) + AlterContextLength -
                AlterContext->common.auth_length - sizeof(sec_trailer));

        NewId = SecurityTrailer->auth_context_id;
        NewClientInfo.AuthenticationLevel = SecurityTrailer->auth_level;
        NewClientInfo.AuthenticationService = SecurityTrailer->auth_type;
        if (DataConvertEndian(((unsigned char *)&DataRep)) != 0)
            {
            NewId = RpcpByteSwapLong(NewId);
            }

        if (NewClientInfo.AuthenticationLevel ==  RPC_C_AUTHN_LEVEL_CALL)
           {
           NewClientInfo.AuthenticationLevel = RPC_C_AUTHN_LEVEL_PKT;
           }
        //
        //Check to see if a new context is being added..
        //
        SecId = FindSecurityContext(NewId,
                                    NewClientInfo.AuthenticationLevel,
                                    NewClientInfo.AuthenticationService
                                    );

        if (SecId == 0)
           {
           RPC_STATUS Status = RPC_S_OK;

           SecId = new SECURITY_CONTEXT(&NewClientInfo, NewId, FALSE, &Status);
           if ( (SecId == 0)
              || RPC_S_OK != Status
              ||(SecurityContextDict.Insert(SecId) == -1) )
              {
              SendFault(RPC_S_OUT_OF_MEMORY, 1, CallId);
              TransFreeBuffer(AlterContext);
              return (1);
              }
           NewContextRequired = 1;

           //
           // If previously no secure rpc had taken place
           // set original sec. context
           // else, mark this connection to indicate
           // security context is altered ..
           //
           if (RpcSecurityBeingUsed)
              {
              SecurityContextAltered = 1;
              }
           }

        AuthInfo = NewClientInfo;
        AuthInfo.ReferenceCredentials();

        AuthContextId = NewId;
        CurrentSecurityContext = SecId;
        RpcSecurityBeingUsed = 1;

        if (   (AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_CONNECT)
            && (AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_PKT)
            && (AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
            && (AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_PKT_PRIVACY) )
            {
            SendFault(RPC_S_ACCESS_DENIED, 1, CallId);
            TransFreeBuffer(AlterContext);
            return(1);
            }

        Status = Address->Server->AcquireCredentials(
                AuthInfo.AuthenticationService,
                AuthInfo.AuthenticationLevel,
                &SecurityCredentials
                );

        if ( Status == RPC_S_OUT_OF_MEMORY ||
             Status == ERROR_SHUTDOWN_IN_PROGRESS)
            {
            SendFault(Status, 1, CallId);
            TransFreeBuffer(AlterContext);
            return(1);
            }
        if ( Status != RPC_S_OK )
            {
            if (SecurityCredentials != 0)
                {
                SecurityCredentials->DereferenceCredentials();
                }
            SendFault(RPC_S_ACCESS_DENIED, 1, CallId);
            TransFreeBuffer(AlterContext);

            return(1);
            }
        ASSERT( SecurityCredentials != 0 );

        } //if secure alter context


    AlterContextRespLength =
        sizeof(rpcconn_alter_context_resp) + sizeof(p_result_list_t)
        + sizeof(p_result_t) * (PContextList->n_context_elem - 1);

    if (SecureAlterContext != 0)
       {
       ASSERT(SecurityCredentials != 0);
       AuthPadLength = Pad4(AlterContextRespLength);
       AlterContextRespLength += AuthPadLength +
                        SecurityCredentials->MaximumTokenLength() +
                        sizeof(sec_trailer);
       }

    Status = TransGetBuffer((void **) &AlterContextResp,
            AlterContextRespLength);
    if ( Status != RPC_S_OK )
        {
        ASSERT( Status == RPC_S_OUT_OF_MEMORY );
        if (SecurityCredentials != 0)
            {
            SecurityCredentials->DereferenceCredentials();
            }
        SendFault(RPC_S_OUT_OF_MEMORY, 1, CallId);
        TransFreeBuffer(AlterContext);
        return(1);
        }

    AlterContextLength -= sizeof(rpcconn_alter_context);
    if ( ProcessPContextList(Address, PContextList, &AlterContextLength,
            (p_result_list_t *) (AlterContextResp + 1)) != 0 )
        {
        TransFreeBuffer(AlterContext);
        TransFreeBuffer(AlterContextResp);
        if (SecurityCredentials != 0)
           {
           SecurityCredentials->DereferenceCredentials();
           }
        SendFault(RPC_S_PROTOCOL_ERROR, 1, CallId);
        return(1);
        }

    if ( SecureAlterContext != 0 )
        {
        ASSERT(SecurityCredentials != 0);
        NewSecurityTrailer = (sec_trailer  *)
                (((unsigned char  *) AlterContextResp) +
                              AlterContextRespLength -
                              SecurityCredentials->MaximumTokenLength() -
                              sizeof(sec_trailer));

        InitSecurityInfo.DceSecurityInfo = DceSecurityInfo;
        InitSecurityInfo.PacketType = AlterContext->common.PTYPE;
        InputBufferDescriptor.ulVersion = 0;
        InputBufferDescriptor.cBuffers = 4;
        InputBufferDescriptor.pBuffers = InputBuffers;

        InputBuffers[0].cbBuffer = sizeof(rpcconn_alter_context);
        InputBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        InputBuffers[0].pvBuffer = SavedHeader;

        InputBuffers[1].cbBuffer = AlterContext->common.frag_length -
                                   sizeof(rpcconn_alter_context) -
                                   AlterContext->common.auth_length;
        InputBuffers[1].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        InputBuffers[1].pvBuffer = (char  *) SavedHeader +
                                          sizeof(rpcconn_alter_context);

        InputBuffers[2].cbBuffer = AlterContext->common.auth_length;
        InputBuffers[2].BufferType = SECBUFFER_TOKEN;
        InputBuffers[2].pvBuffer = SecurityTrailer + 1;
        InputBuffers[3].cbBuffer = sizeof(DCE_INIT_SECURITY_INFO);
        InputBuffers[3].BufferType = SECBUFFER_PKG_PARAMS | SECBUFFER_READONLY;
        InputBuffers[3].pvBuffer = &InitSecurityInfo;

        OutputBufferDescriptor.ulVersion = 0;
        OutputBufferDescriptor.cBuffers = 4;
        OutputBufferDescriptor.pBuffers = OutputBuffers;
        OutputBuffers[0].cbBuffer = sizeof(rpcconn_alter_context_resp);
        OutputBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        OutputBuffers[0].pvBuffer = AlterContextResp;
        OutputBuffers[1].cbBuffer = AlterContextRespLength
                - SecurityCredentials->MaximumTokenLength()
                - sizeof(rpcconn_alter_context_resp);
        OutputBuffers[1].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        OutputBuffers[1].pvBuffer = ((unsigned char *) AlterContextResp)
            + sizeof(rpcconn_alter_context_resp);
        OutputBuffers[2].cbBuffer = SecurityCredentials->MaximumTokenLength();
        OutputBuffers[2].BufferType = SECBUFFER_TOKEN;
        OutputBuffers[2].pvBuffer = NewSecurityTrailer + 1;
        OutputBuffers[3].cbBuffer = sizeof(DCE_INIT_SECURITY_INFO);
        OutputBuffers[3].BufferType = SECBUFFER_PKG_PARAMS | SECBUFFER_READONLY;
        OutputBuffers[3].pvBuffer = &InitSecurityInfo;

        if ( NewContextRequired != 0 )
            {
            Status = CurrentSecurityContext->AcceptFirstTime(
                               SecurityCredentials,
                               &InputBufferDescriptor,
                               &OutputBufferDescriptor,
                               SecurityTrailer->auth_level,
                               *((unsigned long *) AlterContext->common.drep),
                               NewContextRequired
                               );

           LogEvent(SU_SCONN, EV_SEC_ACCEPT1, this, LongToPtr(Status), OutputBuffers[2].cbBuffer);
            //
            // Since we have (potentially) a new security context we
            // need to figure out
            // additional security related information at this stage..
            //

            switch (SecurityTrailer->auth_level)

                {

                case RPC_C_AUTHN_LEVEL_CONNECT:
                case RPC_C_AUTHN_LEVEL_CALL:     //OSF Hack..
                case RPC_C_AUTHN_LEVEL_PKT:
                case RPC_C_AUTHN_LEVEL_PKT_INTEGRITY:

                     AdditionalSpaceForSecurity = MAXIMUM_SECURITY_BLOCK_SIZE +
                            CurrentSecurityContext->MaximumSignatureLength() +
                            sizeof (sec_trailer);
                     break;
                case RPC_C_AUTHN_LEVEL_PKT_PRIVACY:
                     AdditionalSpaceForSecurity = MAXIMUM_SECURITY_BLOCK_SIZE +
                               CurrentSecurityContext->MaximumHeaderLength() +
                               sizeof (sec_trailer);
                     break;

                default:
                     ASSERT(!"Unknown Security Level\n");
                }
            }
        else
            {
            Status = CurrentSecurityContext->AcceptThirdLeg(
                         *((unsigned long  *) AlterContext->common.drep),
                         &InputBufferDescriptor,
                         &OutputBufferDescriptor
                         );

           LogEvent(SU_SCONN, EV_SEC_ACCEPT3, this, LongToPtr(Status), OutputBuffers[2].cbBuffer);
            }
        TokenLength = (unsigned int) OutputBuffers[2].cbBuffer;

        if ( Status == RPC_S_OK                    ||
             Status == RPC_P_COMPLETE_NEEDED       ||
             Status == RPC_P_CONTINUE_NEEDED       ||
             Status == RPC_P_COMPLETE_AND_CONTINUE )
            {
            if ( Status == RPC_P_COMPLETE_NEEDED       ||
                 Status == RPC_P_COMPLETE_AND_CONTINUE )
                {
                CompleteNeeded = 1;
                }

            if ( Status == RPC_S_OK              ||
                 Status == RPC_P_COMPLETE_NEEDED )
                {
                switch (SecurityTrailer->auth_level)
                    {
                    case RPC_C_AUTHN_LEVEL_CONNECT:
                    case RPC_C_AUTHN_LEVEL_CALL:     //OSF Hack..
                    case RPC_C_AUTHN_LEVEL_PKT:
                    case RPC_C_AUTHN_LEVEL_PKT_INTEGRITY:

                         AdditionalSpaceForSecurity = MAXIMUM_SECURITY_BLOCK_SIZE +
                                CurrentSecurityContext->MaximumSignatureLength() +
                                sizeof (sec_trailer);
                         break;
                    case RPC_C_AUTHN_LEVEL_PKT_PRIVACY:
                         AdditionalSpaceForSecurity = MAXIMUM_SECURITY_BLOCK_SIZE +
                                   CurrentSecurityContext->MaximumHeaderLength() +
                                   sizeof (sec_trailer);
                         break;

                    default:
                         ASSERT(!"Unknown Security Level\n");
                    }
                }

            AlterContextRespLength = AlterContextRespLength +
                                    TokenLength -
                                    SecurityCredentials->MaximumTokenLength();

            NewSecurityTrailer->auth_type = SecurityTrailer->auth_type;
            NewSecurityTrailer->auth_level = SecurityTrailer->auth_level;
            NewSecurityTrailer->auth_pad_length = (unsigned char) AuthPadLength;
            NewSecurityTrailer->auth_reserved = 0;
            NewSecurityTrailer->auth_context_id = AuthContextId;

            SecurityCredentials->DereferenceCredentials();
            SecurityCredentials = 0;

            Status = RPC_S_OK;
            }

        if (Status)
            {
            TransFreeBuffer(AlterContext);
            TransFreeBuffer(AlterContextResp);

            SecurityCredentials->DereferenceCredentials();

            SendFault(RPC_S_ACCESS_DENIED, 1, CallId);
            return(1);
            }
        }

    DceSecurityInfo.ReceiveSequenceNumber++;
    ConstructPacket((rpcconn_common *) AlterContextResp,
                    rpc_alter_context_resp, AlterContextRespLength);

    TransFreeBuffer(AlterContext);
    if ( Association == 0 )
        {
        TransFreeBuffer(AlterContextResp);
        SendFault(RPC_S_PROTOCOL_ERROR, 1, CallId);
        return(1);
        }

    AlterContextResp->assoc_group_id = Association->AssocGroupId();
    AlterContextResp->sec_addr_length = 0;
    AlterContextResp->max_xmit_frag = AlterContextResp->max_recv_frag = MaxFrag;
    AlterContextResp->common.call_id = CallId;
    AlterContextResp->common.pfc_flags = PFC_FIRST_FRAG | PFC_LAST_FRAG;

    AlterContextResp->common.auth_length = (unsigned short) TokenLength;
    if (CompleteNeeded != 0)
       {
       CurrentSecurityContext->CompleteSecurityToken(&OutputBufferDescriptor);
       }
    Status= TransSend(AlterContextResp, AlterContextRespLength);
    TransFreeBuffer(AlterContextResp);
    if ( Status != RPC_S_OK )
        {
        return(1);
        }

    return(0);
}


RPC_STATUS
OSF_SCONNECTION::EatAuthInfoFromPacket (
    IN rpcconn_request  * Request,
    IN OUT int  * RequestLength,
    IN OUT void  *  *SavedHeader,
    IN OUT unsigned long *SavedHeaderSize
    )
/*++

Routine Description:

    If there is authentication information in the packet, this routine
    will check it, and perform security as necessary.  This may include
    calls to the security support package.

Arguments:

    Request - Supplies the packet which may contain authentication
        information.

    RequestLength - Supplies the length of the packet in bytes, and
        returns the length of the packet without authentication
        information.

Return Value:

    RPC_S_OK - Everything went just fine.

    RPC_S_ACCESS_DENIED - A security failure of some sort occured.

    RPC_S_PROTOCOL_ERROR - This will occur if no authentication information
        is in the packet, and some was expected, or visa versa.

--*/
{
    sec_trailer  * SecurityTrailer;
    RPC_STATUS Status;
    SECURITY_BUFFER_DESCRIPTOR BufferDescriptor;
    SECURITY_BUFFER SecurityBuffers[5];
    DCE_MSG_SECURITY_INFO MsgSecurityInfo;
    unsigned long Id, Level, Service;
    SECURITY_CONTEXT * SecId;
    unsigned int HeaderSize = sizeof(rpcconn_request);
    unsigned long DataRep = * (unsigned long  *) Request->common.drep;

#if DBG
    // Check to make sure SavedHeader is OSF_SCALL->SavedHeader.
    // We may need to get to the call object below.
    OSF_SCALL *pSCall = (OSF_SCALL *) ((char *)SavedHeader - FIELD_OFFSET(OSF_SCALL, SavedHeader));
    ASSERT(pSCall->InvalidHandle(OSF_SCALL_TYPE) == 0); 
#endif

    if ( (Request->common.pfc_flags & PFC_OBJECT_UUID) != 0 )
        {
        HeaderSize += sizeof(UUID);
        }

    if ( Request->common.auth_length != 0 )
        {
        SecurityTrailer = (sec_trailer  *) (((unsigned char  *)
                Request) + Request->common.frag_length
                - Request->common.auth_length - sizeof(sec_trailer));

        if (RpcSecurityBeingUsed == 0)
            {
            return(RPC_S_PROTOCOL_ERROR);
            }


        //
        // Find the appropriate security context..
        //

        Id = SecurityTrailer->auth_context_id;
        Level = SecurityTrailer->auth_level;
        Service = SecurityTrailer->auth_type;
        if (DataConvertEndian(((unsigned char *)&DataRep)) != 0)
            {
            Id = RpcpByteSwapLong(Id);
            }

        //
        // Osf Hack
        //
        if (Level ==  RPC_C_AUTHN_LEVEL_CALL)
           {
           Level = RPC_C_AUTHN_LEVEL_PKT;
           }

        if ( (CurrentSecurityContext == 0)
           ||(CurrentSecurityContext->AuthContextId != Id)
           ||(CurrentSecurityContext->AuthenticationLevel != Level)
           ||(CurrentSecurityContext->AuthenticationService != Service) )
           {
           SecId = FindSecurityContext(Id, Level, Service);
           if (SecId == 0)
              {
              return (RPC_S_PROTOCOL_ERROR);
              }
           CurrentSecurityContext = SecId;
           AuthInfo.AuthenticationLevel =  Level;
           AuthInfo.AuthenticationService = Service;
           AuthContextId = Id;

           switch (Level)
               {
               case RPC_C_AUTHN_LEVEL_CONNECT:
               case RPC_C_AUTHN_LEVEL_CALL:     //OSF Hack..
               case RPC_C_AUTHN_LEVEL_PKT:
               case RPC_C_AUTHN_LEVEL_PKT_INTEGRITY:

                    AdditionalSpaceForSecurity = MAXIMUM_SECURITY_BLOCK_SIZE +
                           CurrentSecurityContext->MaximumSignatureLength() +
                           sizeof (sec_trailer);
                    break;
               case RPC_C_AUTHN_LEVEL_PKT_PRIVACY:
                    AdditionalSpaceForSecurity = MAXIMUM_SECURITY_BLOCK_SIZE +
                              CurrentSecurityContext->MaximumHeaderLength() +
                              sizeof (sec_trailer);
                    break;

               default:
                    ASSERT(!"Unknown Security Level\n");
               }
           }


       *RequestLength -=  (Request->common.auth_length
                            +HeaderSize + sizeof(sec_trailer) +
                            SecurityTrailer->auth_pad_length);

        MsgSecurityInfo.SendSequenceNumber =
               DceSecurityInfo.SendSequenceNumber;
        MsgSecurityInfo.ReceiveSequenceNumber =
               DceSecurityInfo.ReceiveSequenceNumber;
        MsgSecurityInfo.PacketType = Request->common.PTYPE;

        BufferDescriptor.ulVersion = 0;
        BufferDescriptor.cBuffers = 5;
        BufferDescriptor.pBuffers = SecurityBuffers;


        SecurityBuffers[0].cbBuffer = HeaderSize;
        SecurityBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        SecurityBuffers[0].pvBuffer = (unsigned char  *) *SavedHeader;

        SecurityBuffers[1].cbBuffer = *RequestLength + SecurityTrailer->auth_pad_length;
        SecurityBuffers[1].BufferType = SECBUFFER_DATA;
        SecurityBuffers[1].pvBuffer = ((unsigned char  *) Request)
                + HeaderSize;

        SecurityBuffers[2].cbBuffer = sizeof(sec_trailer);
        SecurityBuffers[2].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        SecurityBuffers[2].pvBuffer = SecurityTrailer;

        SecurityBuffers[3].cbBuffer = Request->common.auth_length;
        SecurityBuffers[3].BufferType = SECBUFFER_TOKEN;
        SecurityBuffers[3].pvBuffer = SecurityTrailer + 1;

        SecurityBuffers[4].cbBuffer = sizeof(DCE_MSG_SECURITY_INFO);
        SecurityBuffers[4].BufferType = SECBUFFER_PKG_PARAMS
                | SECBUFFER_READONLY;
        SecurityBuffers[4].pvBuffer = &MsgSecurityInfo;

        Status = CurrentSecurityContext->VerifyOrUnseal(
                MsgSecurityInfo.ReceiveSequenceNumber,
                AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                &BufferDescriptor);

        if ( Status != RPC_S_OK )
            {
            ASSERT( Status == RPC_S_ACCESS_DENIED ||
                    Status == ERROR_SHUTDOWN_IN_PROGRESS ||
                    Status == ERROR_PASSWORD_MUST_CHANGE ||
                    Status == ERROR_PASSWORD_EXPIRED ||
                    Status == ERROR_ACCOUNT_DISABLED ||
                    Status == ERROR_INVALID_LOGON_HOURS);
            return(Status);
            }
        }
    else if (CurrentSecurityContext == 0)
        {
        // This is a non-secure connection.  There is nothing to be done.
        ASSERT(AuthInfo.AuthenticationLevel == RPC_C_AUTHN_LEVEL_NONE);
        ASSERT(*SavedHeader == 0);

        *RequestLength -= HeaderSize;
        }
    else
        {
        //
        // We are doing a nonsecure rpc and previously we did a secure rpc.
        //
        // This switch from a secure to a non-secure connection is only
        // allowed to take place in between calls.  A given call has to
        // be either entirely secure or entirely non-secure.
        //
        // If this is the first buffer, then we are allowed to switch.
        // We determine whether this is the first buffer by the flag and the
        // current state of the call object. We can get to the call object because
        // this funciton is called with SavedHeader from OSF_SCALL::SavedHeader.
        // We do not explicitly pass in a call address for perf reasons.
        //
        OSF_SCALL *pSCall = (OSF_SCALL *) ((char *)SavedHeader - FIELD_OFFSET(OSF_SCALL, SavedHeader));

        if (Request->common.pfc_flags & PFC_FIRST_FRAG &&
            pSCall->RcvBufferLength == 0)
            {
            ASSERT(pSCall->CurrentState == NewRequest);

            // After we reset the auth level and zero-out the security
            // context the call will not be able to get past security callbacks.
            AuthInfo.AuthenticationLevel = RPC_C_AUTHN_LEVEL_NONE;
            CurrentSecurityContext = 0;
            if (*SavedHeader != 0)
               {
               ASSERT(*SavedHeaderSize != 0);
               RpcpFarFree(*SavedHeader);
               *SavedHeader = 0;
               *SavedHeaderSize = 0;
               }

           *RequestLength -= HeaderSize;
            }
        // Attempt to switch from a secure to a non-secure RPC within a call - fail.
        else
            {
            ASSERT(0 && "Switch from secure to non-secure RPC in the middle of a call.");
            return RPC_S_ACCESS_DENIED;
            }
        }
    DceSecurityInfo.ReceiveSequenceNumber += 1;

    if (*RequestLength < 0)
        {
        return RPC_S_ACCESS_DENIED;
        }

    return(RPC_S_OK);
}


BOOL
OSF_SCONNECTION::MaybeQueueThisCall (
    IN OSF_SCALL *ThisCall
    )
{
    BOOL fCallQueued = 0;

    ConnMutex.Request();
    if (fCurrentlyDispatched)
        {
        if (CallQueue.PutOnQueue(ThisCall, 0))
            {
            ThisCall->SendFault(RPC_S_OUT_OF_MEMORY, 1);

            //
            // Remove the reply reference
            //
            ThisCall->RemoveReference();  // CALL--

            //
            // Remove the dispatch reference();
            //
            ThisCall->RemoveReference();  // CALL--
            }
        fCallQueued = 1;
        }
    else
        {
        fCurrentlyDispatched = 1;
        }
    ConnMutex.Clear();

    return fCallQueued;
}


void
OSF_SCONNECTION::AbortQueuedCalls (
    )
{
    OSF_SCALL *NextCall;
    unsigned int ignore;

    while (1)
        {
        ConnMutex.Request();
        NextCall = (OSF_SCALL *) CallQueue.TakeOffQueue(&ignore);
        if (NextCall == 0)
            {
            fCurrentlyDispatched = 0;
            ConnMutex.Clear();

            break;
            }
        ConnMutex.Clear();

        //
        // Remove the reply reference
        //
        NextCall->RemoveReference();  // CALL--

        //
        // Remove the dispatch reference on the call
        //
        NextCall->RemoveReference();  // CALL--
        }
}


void
OSF_SCONNECTION::DispatchQueuedCalls (
    )
{
    OSF_SCALL *NextCall;
    unsigned int ignore;

    while (1)
        {
        ConnMutex.Request();
        NextCall = (OSF_SCALL *) CallQueue.TakeOffQueue(&ignore);
        if (NextCall == 0)
            {
            fCurrentlyDispatched = 0;
            ConnMutex.Clear();

            break;
            }
        ConnMutex.Clear();

        NextCall->DispatchHelper();

        //
        // Remove the dispatch reference on the call
        //
        NextCall->RemoveReference();  // CALL--
        }
}


OSF_ASSOCIATION::OSF_ASSOCIATION (
    IN OSF_ADDRESS *TheAddress,
    IN RPC_CLIENT_PROCESS_IDENTIFIER * ClientProcess,
    OUT RPC_STATUS * Status
    )
{
    ObjectType = OSF_ASSOCIATION_TYPE;
    *Status = RPC_S_OK;
    ConnectionCount = 1;
    Address = TheAddress;

    this->ClientProcess.Set(ClientProcess);

    AssociationGroupId = InterlockedExchangeAdd(&GroupIdCounter, 1);

    AssociationDictKey = Address->AddAssociation(this);

    if (AssociationDictKey == -1)
        {
        *Status = RPC_S_OUT_OF_MEMORY;
        }
}

OSF_ASSOCIATION::~OSF_ASSOCIATION (
    )
{
    if (AssociationDictKey != -1)
        {
        int HashBucketNumber;

        HashBucketNumber = Address->GetHashBucketForAssociation(AssocGroupId());
        // lock the bucket
        Address->GetAssociationBucketMutex(HashBucketNumber)->Request();

        Address->RemoveAssociation(AssociationDictKey, this);

        // unlock the bucket
        Address->GetAssociationBucketMutex(HashBucketNumber)->Clear();
        }
}

BOOL
OSF_ASSOCIATION::RemoveConnectionUnsafe (
    void
    )
{
    int HashBucketNumber;

    // get the hashed bucket
    HashBucketNumber = Address->GetHashBucketForAssociation(AssociationGroupId);
    // verify the bucket is locked
    Address->GetAssociationBucketMutex(HashBucketNumber)->VerifyOwned();

    ConnectionCount --;

    if (ConnectionCount == 0)
        {
        Address->RemoveAssociation(AssociationDictKey, this);
        AssociationDictKey = -1;
        return AssociationDictKey;  // AssociationDictKey is a quick non-zero value
        }
    else
        return FALSE;
}

void
OSF_ASSOCIATION::RemoveConnection (
    )
{
    int HashBucketNumber;
    BOOL Res;

    // get the hashed bucket
    HashBucketNumber = Address->GetHashBucketForAssociation(AssociationGroupId);
    // lock the bucket
    Address->GetAssociationBucketMutex(HashBucketNumber)->Request();
    Res = RemoveConnectionUnsafe();
    // unlock the bucket
    Address->GetAssociationBucketMutex(HashBucketNumber)->Clear();

    if (Res)
        delete this;
}

RPC_STATUS OSF_ASSOCIATION::CreateThread(void)
{
    return Address->CreateThread();
}


RPC_ADDRESS *
OsfCreateRpcAddress (
    IN TRANS_INFO  *TransportInfo
    )
/*++

Routine Description:

    This routine will be called to create an object representing an
    rpc address.  That is all it has got to do.

Arguments:

    A new rpc address will be returned, unless insufficient memory is
    available to create the new rpc address, in which case zero will
    be returned.

--*/
{
    RPC_ADDRESS * RpcAddress;
    RPC_STATUS Status = RPC_S_OK;
    RPC_CONNECTION_TRANSPORT *ServerInfo =
        (RPC_CONNECTION_TRANSPORT *) TransportInfo->InqTransInfo();

    RpcAddress = new (ServerInfo->AddressSize)
                               OSF_ADDRESS(TransportInfo, &Status);

    if ( Status != RPC_S_OK )
        {
        return(0);
        }
    return(RpcAddress);
}


RPC_STATUS
OSF_SCALL::Cancel(
    void * ThreadHandle
    )
{
    InterlockedIncrement(&CancelPending);

    return RPC_S_OK;
}

unsigned
OSF_SCALL::TestCancel(
    )
{
    return InterlockedExchange(&CancelPending, 0);
}


RPC_STATUS
OSF_SCALL::ToStringBinding (
    OUT RPC_CHAR  *  * StringBinding
    )
/*++

Routine Description:

    We need to convert this connection into a string binding.  We
    will ask the address for a binding handle which we can then
    convert into a string binding.

Arguments:

    StringBinding - Returns the string representation of the binding
        handle.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_OUT_OF_MEMORY - We do not have enough memory available to
        allocate space for the string binding.

--*/
{
    BINDING_HANDLE * BindingHandle;
    RPC_STATUS Status = RPC_S_OK;

    BindingHandle = Address->InquireBinding();
    if (BindingHandle == 0)
        return(RPC_S_OUT_OF_MEMORY);
    if ( ObjectUuidSpecified != 0)
        {
        Status = RpcBindingSetObject(BindingHandle, (UUID *) &ObjectUuid);
        }
    if (Status == RPC_S_OK)
        {
        Status = BindingHandle->ToStringBinding(StringBinding);
        }
    BindingHandle->BindingFree();
    return(Status);
}

#if DBG
void
OSF_SCALL::InterfaceForCallDoesNotUseStrict (
    void
    )
{
    CurrentBinding->InterfaceForCallDoesNotUseStrict();
}
#endif

RPC_STATUS
OSF_SCALL::InqLocalConnAddress (
    IN OUT void *Buffer,
    IN OUT unsigned long *BufferSize,
    OUT unsigned long *AddressFormat
    )
/*++

Routine Description:

    This routine is used by a server application to inquire about the local
    address on which a call is made.

Arguments:

    Buffer - The buffer that will receive the output address

    BufferSize - the size of the supplied Buffer on input. On output the
        number of bytes written to the buffer. If the buffer is too small
        to receive all the output data, ERROR_MORE_DATA is returned,
        nothing is written to the buffer, and BufferSize is set to
        the size of the buffer needed to return all the data.

    AddressFormat - a constant indicating the format of the returned address.
        Currently supported are RPC_P_ADDR_FORMAT_TCP_IPV4 and
        RPC_P_ADDR_FORMAT_TCP_IPV6.

Return Values:

    RPC_S_OK - success.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete this
        operation.

    RPC_S_INVALID_BINDING - The supplied client binding is invalid.

    RPC_S_CANNOT_SUPPORT - The local address was inquired for a protocol 
        sequence that doesn't support this type of functionality. Currently
        only ncacn_ip_tcp supports it.

    RPC_S_* or Win32 error for other errors
--*/
{
    return Connection->InqLocalConnAddress(
        Buffer,
        BufferSize,
        AddressFormat);
}

void
OSF_SCALL::WakeUpPipeThreadIfNecessary (
    IN RPC_STATUS Status
    )
/*++

Routine Description:

    If a pipe thread is being stuck on wait, it fires the event to wake
    it up.

Arguments:
    Status - the status with which the call failed.

Return Values:

--*/
{
    if (pAsync == 0)
        {
        if (fPipeCall)
            {
            CallMutex.Request();

            CurrentState = CallAborted;
            AsyncStatus = Status;

            // wake up the thread that was flow controlled, if any
            fChoked = 0;

            CallMutex.Clear();

            LogEvent(SU_SCALL, EV_STATUS, this, SyncEvent.EventHandle, 0, 1, 0);
            SyncEvent.Raise();
            }
        }
}


RPC_STATUS RPC_ENTRY
I_RpcTransServerReallocPacket (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN OUT void  *  * Buffer,
    IN unsigned int OldBufferLength,
    IN unsigned int NewBufferLength
    )
/*++

Routine Description:

    The server side transport interface modules will use this routine to
    increase the size of a buffer so that the entire packet to be
    received will fit into it, or to allocate a new buffer.  If the buffer
    is to be reallocated, the data from the old buffer is copied
    into the beginning of the new buffer.  The old buffer will be freed.

Arguments:

    ThisConnection - Supplies the connection for which we are reallocating
        a transport buffer.

    Buffer - Supplies the buffer which we want to reallocate to
        be larger.  If no buffer is supplied, then a new one is allocated
        anyway.  The new buffer is returned via this argument.

    OldBufferLength - Supplies the current length of the buffer in bytes.
        This information is necessary so we know how much of the buffer
        needs to be copied into the new buffer.

    NewBufferLength - Supplies the required length of the buffer in bytes.

Return Value:

    RPC_S_OK - The requested larger buffer has successfully been allocated.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allocate
        the buffer.

--*/
{
    ASSERT(0);
    return(RPC_S_INTERNAL_ERROR);
}


BUFFER RPC_ENTRY
I_RpcTransServerAllocatePacket (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN UINT Size
    )
/*++

Routine Description:

    The server side transport interface modules will use this routine to
    increase the size of a buffer so that the entire packet to be
    received will fit into it, or to allocate a new buffer.  If the buffer
    is to be reallocated, the data from the old buffer is copied
    into the beginning of the new buffer.  The old buffer will be freed.

Arguments:

    ThisConnection - Supplies the connection for which we are reallocating
        a transport buffer.

    Buffer - Supplies the buffer which we want to reallocate to
        be larger.  If no buffer is supplied, then a new one is allocated
        anyway.  The new buffer is returned via this argument.

    OldBufferLength - Supplies the current length of the buffer in bytes.
        This information is necessary so we know how much of the buffer
        needs to be copied into the new buffer.

    NewBufferLength - Supplies the required length of the buffer in bytes.

Return Value:

    RPC_S_OK - The requested larger buffer has successfully been allocated.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allocate
        the buffer.

--*/
{
    ASSERT(0);
    return(0);
}


unsigned short RPC_ENTRY
I_RpcTransServerMaxFrag (
    IN RPC_TRANSPORT_CONNECTION ThisConnection
    )
/*++

Routine Description:

    The server side transport interface modules will use this routine to
    determine the negotiated maximum fragment size.

Arguments:

    ThisConnection - Supplies the connection for which we are returning
    the maximum fragment size.

--*/
{
    ASSERT(0);
    return(0);
}

RPC_TRANSPORT_CONNECTION RPC_ENTRY
I_RpcTransServerNewConnection (
    IN RPC_TRANSPORT_ADDRESS ThisAddress
    )
{
    OSF_SCONNECTION * SConnection;
    OSF_ADDRESS *Address ;

    Address = InqTransAddress(ThisAddress) ;

    SConnection = Address->NewConnection();
    if ( SConnection == 0 )
        {
        return(0);
        }

    return(SConnection->TransConnection);
}



void RPC_ENTRY
I_RpcTransServerFreePacket (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN void  * Buffer
    )
/*++

Routine Description:

    We need to free a transport buffer for a transport connection; this
    will typically occur when the connection is being closed.

Arguments:

    ThisConnection - Supplies the transport connection which owns the
        buffer.

    Buffer - Supplies the buffer to be freed.

--*/
{
    ASSERT(0);
}


void  * RPC_ENTRY
I_RpcTransProtectThread (
    void
    )
/*++

Routine Description:

    In some cases, if an asyncronous io operation has been started by a
    thread, the thread can not be deleted because the io operation will
    be cancelled.  This routine will be called by a transport to indicate
    that the current thread can not be deleted.

Return Value:

    A pointer to the thread will be returned.  This is necessary, so that
    later the thread can be unprotected.

--*/
{
#ifdef RPC_OLD_IO_PROTECTION
    THREAD  * Thread = RpcpGetThreadPointer();

    Thread->ProtectThread();
    return((void  *) Thread);
#endif
    return 0;
}


void RPC_ENTRY
I_RpcTransUnprotectThread (
    IN void  * Thread
    )
/*++

Routine Description:

    When a thread no longer needs to be protected from deletion, this
    routine must be called.

Arguments:

    Thread - Supplies the thread which no longer needs to be protected
        from deletion.

--*/
{
#ifdef RPC_OLD_IO_PROTECTION
    ((THREAD  *) Thread)->UnprotectThread();
#endif
}

void
I_RpcTransVerifyServerRuntimeCallFromContext(
    void *SendContext
    )
/*++

Routine Description:

    Verifies that the supplied context follows a valid
    runtime server call object.

Arguments:

    SendContext - the context as seen by the transport

Return Value:

--*/
{
    ASSERT(InqTransSCall(SendContext)->InvalidHandle(OSF_SCALL_TYPE) == 0);    
}

const UUID BindNakEEInfoSignatureData = { /* 90740320-fad0-11d3-82d7-009027b130ab */
        0x90740320,
        0xfad0,
        0x11d3,
        {0x82, 0xd7, 0x00, 0x90, 0x27, 0xb1, 0x30, 0xab}
    };

const UUID *BindNakEEInfoSignature = &BindNakEEInfoSignatureData;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\pipe.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pipe.h
//
//--------------------------------------------------------------------------

#ifndef __PIPE_HXX
#define __PIPE_HXX

enum receive_states {
        start,
        copy_pipe_elem,
        return_partial_pipe_elem, // also save pipe elem
        return_partial_count, // also save count
        read_partial_count, // also a start state
        read_partial_pipe_elem //also a start state
        } ;

typedef struct {
    void *Buffer ;
    int BufferLength ;
    receive_states CurrentState ;
    char PAPI *CurPointer ;          // current pointer in the buffer
    int BytesRemaining ;      // bytes remaining in current buffer
    int ElementsRemaining ; // elements remaining in current pipe chunk
    DWORD PartialCount ;
    int PartialCountSize ;
    int PartialPipeElementSize ;
    int EndOfPipe ;
    int PipeElementSize ;
    void PAPI *PartialPipeElement ;
    void PAPI *AllocatedBuffer ;
    int BufferSize ;
    int SendBufferOffset ;
    void PAPI *PreviousBuffer ;
    int PreviousBufferSize ;
    HANDLE BindingHandle;
    } PIPE_STATE ;

//
// N.B. this structure is the same as MIDL_ASYNC_STUB_STATE
//
typedef struct async_stub_state {
    void *CallHandle ;
    RPC_STATUS (*CompletionRoutine) (
        PRPC_ASYNC_STATE pAsync,
        void *Reply) ;
    int Length ;
    void *UserData ;
    int State ;
    void *Buffer ;
    int BufferLength ;
    unsigned long Flags ;
    PIPE_STATE PipeState ;
    BOOL (*ReceiveFunction) (
        PRPC_ASYNC_STATE pAsync,
        PRPC_MESSAGE Message) ;
    } RPC_ASYNC_STUB_STATE ;

void I_RpcReadPipeElementsFromBuffer (
    PIPE_STATE PAPI *state,
    char PAPI *TargetBuffer,
    int TargetBufferSize, 
    int PAPI *NumCopied
    ) ;

//states
enum
{
 SEND_COMPLETE,
 SEND_INCOMPLETE
} ;

RPC_STATUS RPC_ENTRY
MyRpcCompleteAsyncCall (
    IN PRPC_ASYNC_STATE pAsync,
    IN void *Reply
    );
    
#define STUB(_x_) ((RPC_ASYNC_STUB_STATE *) (_x_->StubInfo))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\rpccfg.h ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    rpccfg.h


Abstract:

    The entry points for configuration of the rpc runtime are prototyped
    in this file.  Each operating environment must defined these routines.

Author:

    Michael Montague (mikemon) 25-Nov-1991

Revision History:

--*/

#ifndef __RPCCFG_H__
#define __RPCCFG_H__

RPC_STATUS
RpcConfigMapRpcProtocolSequence (
    IN unsigned int ServerSideFlag,
    IN RPC_CHAR PAPI * RpcProtocolSequence,
    OUT RPC_CHAR * PAPI * TransportInterfaceDll
    );

RPC_STATUS
RpcConfigInquireProtocolSequences (
    IN BOOL fGetAllProtseqs,
    OUT RPC_PROTSEQ_VECTOR PAPI * PAPI * ProtseqVector
    );

RPC_STATUS
RpcGetAdditionalTransportInfo(
    IN  unsigned long TransportId,
    OUT unsigned char PAPI * PAPI * ProtocolSequence
    );

RPC_STATUS
RpcGetWellKnownTransportInfo(
    IN unsigned long TransportId,
    OUT RPC_CHAR **PSeq
    );

RPC_STATUS
RpcGetSecurityProviderInfo(
    unsigned long AuthnId,
    RPC_CHAR * PAPI * Dll,
    unsigned long PAPI * Count
    );

extern DWORD DefaultAuthLevel;
extern DWORD DefaultProviderId;

void
RpcpGetDefaultSecurityProviderInfo();


extern RPC_STATUS
ValidateSchannelPrincipalName(
    IN RPC_CHAR * EncodedName
    );

#endif // __RPCCFG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\principal.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:



Abstract:

    Functions to manipulate SSL-tyle principal names and certificates

Author:

    Jeff Roberts

Revisions:

    Jeff Roberts  (jroberts)  1-20-1998

        created the file

--*/

#include <precomp.hxx>

#include <rpcssl.h>
#include <cryptimp.hxx>
#include <CharConv.hxx>

#define INITIAL_NAME_LENGTH 100

// The prefix lengths do not include the NULL char.  Actual strings are one
// character longer.  This is generally OK, since these strings are prefixes and
// the NULL char gets overwritten.

#define     MSSTD_PREFIX_LENGTH 6
const RPC_CHAR MSSTD_PREFIX[]    = RPC_T("msstd:");

#define     FULLPATH_PREFIX_LENGTH 8
const RPC_CHAR FULLPATH_PREFIX[] = RPC_T("fullsic:");

//------------------------------------------------------------------------

DWORD
AddComponentName( RPC_CHAR *     *  pBuffer,
                  unsigned long  *  pBufferLength,
                  unsigned long  *  pCursor,
                  CERT_NAME_BLOB *  Name
                  );

DWORD
RpcCertMatchPrincipalName(
                   PCCERT_CONTEXT Context,
                   RPC_CHAR PrincipalName[]
                   );

DWORD
MatchFullPathPrincipalName(
                   PCCERT_CONTEXT Context,
                   RPC_CHAR EncodedPrincipalName[]
                   );

DWORD
CompareRdnElement(
               PCCERT_CONTEXT Context,
               DWORD dwGetNameStringType,
               void *pvGetNameStringTypePara,
               RPC_CHAR PrincipalName[],
               BOOL CaseSensitive
               );

DWORD
MarkPrincipalNameComponents(
                            RPC_CHAR * PrincipalName,
                            unsigned *   pCount
                            );

PCCERT_CONTEXT
FindMatchingCertificate( HCERTSTORE Store,
                         RPC_CHAR * SubjectName,
                         RPC_CHAR * IssuerName
                         );

DWORD
MatchMsPrincipalName(
                   PCCERT_CONTEXT Context,
                   RPC_CHAR EncodedPrincipalName[]
                   );

DWORD
DecodeEscapedString(
                    RPC_CHAR * Source,
                    RPC_CHAR * Destination
                    );

DWORD
FindIssuerContext( PCCERT_CONTEXT * pContext,
                   HCERTSTORE     * pStore,
                   BOOL           * pfFreeStore
                   );

RPC_CHAR *
EndOfRfc1779Name(
                 RPC_CHAR * Name
                 );

unsigned
Int4StrLen(
            unsigned long * String
            );

//------------------------------------------------------------------------

RPC_CHAR * __cdecl RpcpStringReverse (
        RPC_CHAR * string
        )
{
        RPC_CHAR *start = string;
        RPC_CHAR *left = string;
        RPC_CHAR ch;

        while (*string++)                 /* find end of string */
                ;
        string -= sizeof(RPC_CHAR);

        while (left < string)
        {
                ch = *left;
                *left++ = *string;
                *string-- = ch;
        }

        return(start);
}


DWORD
RpcCertMatchPrincipalName(
                   PCCERT_CONTEXT Context,
                   RPC_CHAR PrincipalName[]
                   )
/*++

Routine Description:

    This routine

Arguments:

    <Context>  is a CryptoAPI 2.0 context

    <PrincipalName> is a principal name prefixed with either "msstd:" or "fullsic:"

Return Value:

    0 if successful, otherwise an error

--*/
{
    DWORD Status = 0;

    InitializeIfNecessary();

    if (!LoadCrypt32Imports())
        {
        return GetLastError();
        }

    if (0 == RpcpStringNCompare(PrincipalName, MSSTD_PREFIX, MSSTD_PREFIX_LENGTH))
        {
        Status = MatchMsPrincipalName(Context, PrincipalName + MSSTD_PREFIX_LENGTH);
        }
    else if (0 == RpcpStringNCompare(PrincipalName, FULLPATH_PREFIX, FULLPATH_PREFIX_LENGTH))
        {
        Status = MatchFullPathPrincipalName(Context, PrincipalName + FULLPATH_PREFIX_LENGTH);
        }
    else
        {
        ASSERT( 0 && "RPC: principal name is in incorrect format" );
        Status = ERROR_INVALID_PARAMETER;
        }

    return Status;
}


DWORD
MatchMsPrincipalName(
                   PCCERT_CONTEXT Context,
                   RPC_CHAR EncodedPrincipalName[]
                   )
{
    PCERT_NAME_INFO Subject = 0;
    DWORD Status = 0;
    RPC_CHAR * PrincipalName = 0;

    //
    // It's time to decode the principal name.
    // The encoding is just a matter of extra backslashes when the
    // principal name contains our metacharacters.  Decoding will
    // always make the string smaller.
    //
    PrincipalName = (RPC_CHAR *) _alloca(sizeof(RPC_CHAR) * RpcpStringLength(EncodedPrincipalName));

    Status = DecodeEscapedString(EncodedPrincipalName, PrincipalName);
    if (Status)
        {
        RpcpErrorAddRecord(EEInfoGCSecurityProvider,
                           Status,
                           EEInfoDLMatchMsPrincipalName10);

        return Status;
        }


    if (RpcpCharacter((const RPC_SCHAR *) PrincipalName, '@'))
        {
        // Compare the principal name to the certificate subject's
        // email-address RDN attribute.
        return CompareRdnElement(Context, CERT_NAME_EMAIL_TYPE, NULL, PrincipalName, TRUE); 
        }
    else
        {
        // Compare the principal name to the certificate subject's
        // common-name RDN attribute.
        return CompareRdnElement(Context, CERT_NAME_ATTR_TYPE, szOID_COMMON_NAME, PrincipalName, FALSE);
        }

    ASSERT( 0 );
}


DWORD
CompareRdnElement(
               PCCERT_CONTEXT Context,
               DWORD dwGetNameStringType,
               void *pvGetNameStringTypePara,
               RPC_CHAR PrincipalName[],
               BOOL CaseSensitive
               )
{
    //
    // Decode the certificate's Subject field so we can see its attributes.
    //
    DWORD Status = 0;

    RPC_CHAR * pPrincipalName;

    DWORD NameSize = CertGetNameStringW(Context,
                                        dwGetNameStringType,
                                        0, // dwFlags
                                        pvGetNameStringTypePara, // pvTypePara
                                        NULL,
                                        0);
        
    if (NameSize > 1)
        {
        pPrincipalName = (RPC_CHAR *) _alloca( sizeof(wchar_t) * NameSize );

        NameSize = CertGetNameStringW(Context,
                                      dwGetNameStringType,
                                      0,
                                      pvGetNameStringTypePara,
                                      pPrincipalName,
                                      NameSize);
        
        ASSERT(NameSize > 1);
        }
    else
        {
        RpcpErrorAddRecord(EEInfoGCSecurityProvider,
                           ERROR_ACCESS_DENIED,
                           EEInfoDLCompareRdnElement10,
                           GetLastError());

        return ERROR_ACCESS_DENIED;
        }

    //
    // Now compare the cetificate info to the principal name.
    //
    if (CaseSensitive)
        {
        if (0 != RpcpStringSCompare(PrincipalName, pPrincipalName))
            {
            return ERROR_ACCESS_DENIED;
            }
        }
    else
        {
        if (0 != RpcpStringCompareInt(PrincipalName, pPrincipalName))
            {
            return ERROR_ACCESS_DENIED;
            }
        }

    return 0;
}


DWORD
DecodeEscapedString(
                    RPC_CHAR * Source,
                    RPC_CHAR * Destination
                    )
{
    for (;;)
        {
        if (*Source == '\\')
            {
            if(Source[1] != '<' && Source[1] != '*')
                {
                    Source++;
                }
            if (!*Source)
                {
                return ERROR_INVALID_PARAMETER;
                }
            *Destination = *Source;
            }
        else
            {
            *Destination = *Source;
            if (!*Source)
                {
                return 0;
                }
            }

        ++Source;
        ++Destination;
        }
}


DWORD
MatchFullPathPrincipalName(
                   PCCERT_CONTEXT Context,
                   RPC_CHAR EncodedPrincipalName[]
                   )
/*++

Routine Description:


Arguments:

    <Context>  is a CryptoAPI 2.0 context

    <PrincipalName> is a principal name with no prefix

        It can be in several forms:

            - complete and explicit, e.g.

                "\<CA>\<Name>"
                "\<CA>\<SA1>\<SA2>\<Name>"

            - wildcard in the subject-name position:

                "\<CA>\*"

            - no CA specified

                "name"          - This is equivalent to "\*\<CA>"

Return Value:

    0 if all components were successfully validated
    ERROR_NO_TOP_LEVEL_AUTHORITY if the top cert isn't in the CA store

    Some other error if something failed.

--*/
{
    DWORD       Status = 0;
    DWORD       ReturnedStatus = 0;
    HCERTSTORE  Store = Context->hCertStore;
    unsigned    PrincipalNameLength;
    RPC_CHAR *  CopyOfPrincipalName = 0;

    if (!*EncodedPrincipalName)
        {
        return ERROR_INVALID_PARAMETER;
        }

    PrincipalNameLength = RpcpStringLength(EncodedPrincipalName);

    //
    // If the name doesn't begin with a backslash, then treat it as "\*\subjectname".
    //
    if (EncodedPrincipalName[0] != '\\')
        {
        CopyOfPrincipalName = (RPC_CHAR *) _alloca( (5 + PrincipalNameLength + 2) *
                                                    sizeof(RPC_CHAR));

        RpcpStringCopy(CopyOfPrincipalName, RPC_CONST_STRING("\\*\\<"));
        RpcpStringCat(CopyOfPrincipalName, EncodedPrincipalName);
        RpcpStringCat(CopyOfPrincipalName, RPC_CONST_STRING(">"));

        return MatchFullPathPrincipalName( Context, CopyOfPrincipalName );
        }

    //
    // Form is "\<CA>\<Name>".  More precisely, the name looks like a
    // file system path, where each element of the path
    // is either
    //      "*"
    // or
    //      '<' plus an RFC1779 name plus '>'
    //
    unsigned    idx;
    unsigned    ComponentCount;
    RPC_CHAR **    Components = 0;
    RPC_CHAR *     Cursor;

    CopyOfPrincipalName = (RPC_CHAR *) _alloca( (PrincipalNameLength + 2) * sizeof(RPC_CHAR));

    RpcpStringCopy(CopyOfPrincipalName, EncodedPrincipalName);

    //
    // Sizing pass.  Count the number of path elements and separate them by '\0'.
    //
    Status = MarkPrincipalNameComponents( CopyOfPrincipalName, &ComponentCount );
    if (Status)
        {
        RpcpErrorAddRecord(EEInfoGCSecurityProvider,
                           Status,
                           EEInfoDLMatchFullPathPrincipalName10);

        return Status;
        }

    //
    // Init the component array.  The 0'th element of the array points to
    // the last component of the principal name (i.e., the client's subject name).
    //
    Components = (RPC_CHAR **) _alloca( sizeof(RPC_CHAR *) * ComponentCount );

    Cursor = CopyOfPrincipalName;
    idx    = ComponentCount-1;
    do
        {
        while (!*Cursor)
            {
            ++Cursor;
            }

        ASSERT( Cursor < CopyOfPrincipalName+PrincipalNameLength );

        Components[idx] = Cursor;

        Cursor += RpcpStringLength( Cursor );
        }
    while ( idx-- > 0 );

    //
    // Verify the principal name of all certs except the top authority one.
    //
    PCCERT_CONTEXT NewContext = 0;
    for (idx=0; idx < ComponentCount-1; ++idx)
        {
        if (NewContext)
            {
            CertFreeCertificateContext( NewContext );
            }

        NewContext = FindMatchingCertificate( Store,
                                              Components[idx],
                                              Components[idx+1]
                                              );
        if (!NewContext)
            {
            Status = GetLastError();

            if (Status == ERROR_NOT_ENOUGH_MEMORY)
                {
                ReturnedStatus = ERROR_NOT_ENOUGH_MEMORY;
                }
            else
                {
                ReturnedStatus = ERROR_ACCESS_DENIED;
                }

            RpcpErrorAddRecord(EEInfoGCSecurityProvider,
                               ReturnedStatus,
                               EEInfoDLMatchFullPathPrincipalName20,
                               Status);

            return ReturnedStatus;
            }
        }

    //
    // Look for the top-level authority certificate in the CA and ROOT stores,
    // matching the last remaining principal name component.
    //
    HCERTSTORE CaStore;
    HCERTSTORE RootStore;

    CaStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_W,
                             0,
                             0,
                             CERT_SYSTEM_STORE_CURRENT_USER,
                             RPC_CONST_STRING("CA")
                             );
    if (!CaStore)
        {
        Status = GetLastError();
        RpcpErrorAddRecord(EEInfoGCSecurityProvider,
                           Status,
                           EEInfoDLMatchFullPathPrincipalName30);

        CertFreeCertificateContext( NewContext );
        return Status;
        }


    RootStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_W,
                               0,
                               0,
                               CERT_SYSTEM_STORE_CURRENT_USER,
                               RPC_CONST_STRING("ROOT")
                               );
    if (!RootStore)
        {
        Status = GetLastError();
        RpcpErrorAddRecord(EEInfoGCSecurityProvider,
                           Status,
                           EEInfoDLMatchFullPathPrincipalName40);

        CertCloseStore( CaStore, 0 );
        CertFreeCertificateContext( NewContext );
        return Status;
        }

    //
    // Use Context instead of Components[] for the issuer name
    // so that the self-signed cert that we look for
    // is always the one that matches the Context we have.
    // Otherwise we'd be wrong about strings with a wildcard as top-level authority.
    //
    PCCERT_CONTEXT Parent = 0;
    while (1)
        {
        Parent = CertFindCertificateInStore(
                                            RootStore,
                                            X509_ASN_ENCODING,
                                            0,                             // no flags
                                            CERT_FIND_SUBJECT_NAME,        // exact match
                                            &NewContext->pCertInfo->Issuer,
                                            Parent
                                            );
        if (!Parent)
            {
            Parent = CertFindCertificateInStore(
                                                CaStore,
                                                X509_ASN_ENCODING,
                                                0,                             // no flags
                                                CERT_FIND_SUBJECT_NAME,        // exact match
                                                &NewContext->pCertInfo->Issuer,
                                                Parent
                                                );
            }

        if (!Parent)
            {
            goto finish;
            }

        if (CertCompareCertificateName( X509_ASN_ENCODING,
                                        & Parent->pCertInfo->Issuer,
                                        &Context->pCertInfo->Issuer
                                        ))
            {
            goto finish;
            }
        }

finish:

    CertCloseStore( CaStore, 0 );
    CertCloseStore( RootStore, 0 );
    CertFreeCertificateContext( NewContext );

    if (!Parent)
        {
        Status = GetLastError();
        if (Status == ERROR_NOT_ENOUGH_MEMORY)
            {
            ReturnedStatus = ERROR_NOT_ENOUGH_MEMORY;
            }
        else
            {
            ReturnedStatus = SEC_E_NO_AUTHENTICATING_AUTHORITY;
            }

        RpcpErrorAddRecord(EEInfoGCSecurityProvider,
                           ReturnedStatus,
                           EEInfoDLMatchFullPathPrincipalName50,
                           Status);

        return ReturnedStatus;
        }

    CertFreeCertificateContext( Parent );

    return 0;
}


PCCERT_CONTEXT
FindMatchingCertificate( HCERTSTORE Store,
                         RPC_CHAR * SubjectName,
                         RPC_CHAR * IssuerName
                         )
{
    PCCERT_CONTEXT   Context = 0;
    CERT_NAME_BLOB * IssuerBlob = 0;
    CERT_NAME_BLOB * SubjectBlob = 0;

    ASSERT( IssuerName[0] != '*' || SubjectName[0] != '*' );

    //
    // Make an issuer blob, if necessary.
    //
    if (IssuerName[0] != '*')
        {
        unsigned long BlobSize = INITIAL_NAME_LENGTH;

        IssuerBlob = (CERT_NAME_BLOB *) _alloca( sizeof(CERT_NAME_BLOB)+INITIAL_NAME_LENGTH );

        IssuerBlob->cbData = INITIAL_NAME_LENGTH;
        IssuerBlob->pbData = (unsigned char *) (IssuerBlob+1);

        if (! CertStrToNameT( X509_ASN_ENCODING,
                              IssuerName,
                              0,                  // no format restrictions
                              NULL,               // reserved, MBZ
                              IssuerBlob->pbData,
                              &IssuerBlob->cbData,
                              NULL                // would point to first invalid character
                              ))
            {
            BlobSize = IssuerBlob->cbData;

            IssuerBlob = (CERT_NAME_BLOB *) _alloca( sizeof(CERT_NAME_BLOB)+BlobSize );

            IssuerBlob->cbData = BlobSize;
            IssuerBlob->pbData = (unsigned char *) (IssuerBlob+1);

            if (! CertStrToNameT( X509_ASN_ENCODING,
                                     IssuerName,
                                     0,                  // no format restrictions
                                     NULL,               // reserved, MBZ
                                     IssuerBlob->pbData,
                                     &IssuerBlob->cbData,
                                     NULL                // would point to first invalid character
                                     ))
                {
                return 0;
                }
            }
        }

    //
    // Make a subject blob, if necessary.
    //
    if (SubjectName[0] != '*')
        {
        unsigned long BlobSize = INITIAL_NAME_LENGTH;

        SubjectBlob = (CERT_NAME_BLOB *) _alloca( sizeof(CERT_NAME_BLOB)+INITIAL_NAME_LENGTH );

        SubjectBlob->cbData = INITIAL_NAME_LENGTH;
        SubjectBlob->pbData = (unsigned char *) (SubjectBlob+1);

        if (! CertStrToNameT( X509_ASN_ENCODING,
                              SubjectName,
                              0,                  // no format restrictions
                              NULL,               // reserved, MBZ
                              SubjectBlob->pbData,
                              &SubjectBlob->cbData,
                              NULL                // would point to first invalid character
                              ))
            {
            BlobSize = SubjectBlob->cbData;

            SubjectBlob = (CERT_NAME_BLOB *) _alloca( sizeof(CERT_NAME_BLOB)+BlobSize );

            SubjectBlob->cbData = BlobSize;
            SubjectBlob->pbData = (unsigned char *) (SubjectBlob+1);

            if (! CertStrToNameT( X509_ASN_ENCODING,
                                     SubjectName,
                                     0,                  // no format restrictions
                                     NULL,               // reserved, MBZ
                                     SubjectBlob->pbData,
                                     &SubjectBlob->cbData,
                                     NULL                // would point to first invalid character
                                     ))
                {
                return 0;
                }
            }
        }

    //
    // Search for a certificate.
    //
    if (SubjectName[0] == '*')
        {
        //
        // Search by issuer only.
        //
        Context = CertFindCertificateInStore(
                                            Store,
                                            X509_ASN_ENCODING,
                                            0,                             // no flags
                                            CERT_FIND_ISSUER_NAME,         // exact match
                                            IssuerBlob,
                                            NULL                           // previous context in search
                                            );
        return Context;
        }
    else if (IssuerName[0] == '*')
        {
        //
        // Search by subject only.
        //
        Context = CertFindCertificateInStore(
                                            Store,
                                            X509_ASN_ENCODING,
                                            0,                             // no flags
                                            CERT_FIND_SUBJECT_NAME,        // exact match
                                            SubjectBlob,
                                            NULL                           // previous context in search
                                            );
        return Context;
        }
    else
        {
        //
        // Search by both.  The primary search is by subject,
        // on the theory that most subject names are distinct and
        // most issuer names are not.
        //
        while (1)
            {
            Context = CertFindCertificateInStore(
                                                Store,
                                                X509_ASN_ENCODING,
                                                0,                             // no flags
                                                CERT_FIND_SUBJECT_NAME,        // exact match
                                                SubjectBlob,
                                                NULL                           // previous context in search
                                                );
            if (!Context)
                {
                return Context;
                }

            if (CertCompareCertificateName( X509_ASN_ENCODING,
                                            &Context->pCertInfo->Issuer,
                                            IssuerBlob
                                            ))
                {
                return Context;
                }
            }
        }

    ASSERT( 0 && "should never get here" );
}


DWORD
MarkPrincipalNameComponents(
                            RPC_CHAR * PrincipalName,
                            unsigned *   pCount
                            )
{
    RPC_CHAR * Cursor;
    unsigned     ComponentCount;

    ComponentCount = 0;
    Cursor = PrincipalName;
    do
        {
        ++ComponentCount;

        if ( *Cursor != '\\' )
            {
            return ERROR_INVALID_PARAMETER;
            }

        *Cursor = '\0';
        ++Cursor;

        if (*Cursor == '*')
            {
            ++Cursor;
            }
        else if (*Cursor == '<')
            {
            *Cursor = '\0';
            ++Cursor;

            Cursor = EndOfRfc1779Name( Cursor );
            if (*Cursor != '>')
                {
                return ERROR_INVALID_PARAMETER;
                }

            *Cursor = '\0';
            ++Cursor;
            }
        else
            {
            return ERROR_INVALID_PARAMETER;
            }
        }
    while ( *Cursor );

    *pCount = ComponentCount;

    return 0;
}

RPC_CHAR *
EndOfRfc1779Name(
                 RPC_CHAR * Name
                 )
{
    unsigned Quotes = 0;

    for ( ; *Name; ++Name)
        {
        if (*Name == '>')
            {
            if (0 == (Quotes % 2))
                {
                return Name;
                }
            }
        else if (*Name == '\\')
            {
            ++Name;
            }
        else if (*Name == '"')
            {
            ++Quotes;
            }
        }

    return Name;
}


RPC_STATUS
RpcCertGeneratePrincipalName(
                      PCCERT_CONTEXT Context,
                      DWORD          Flags,
                      RPC_CHAR **       pBuffer
                      )
{
    THREAD *Thread;
    DWORD   Status = 0;

    InitializeIfNecessary();

    Thread = ThreadSelf();
    if (Thread)
        {
        RpcpPurgeEEInfoFromThreadIfNecessary(Thread);
        }

    if (!LoadCrypt32Imports())
        {
        return GetLastError();
        }

    if (Flags & RPC_C_FULL_CERT_CHAIN)
        {
        RPC_CHAR * Buffer;
        unsigned long Cursor = 0;
        unsigned long BufferLength = INITIAL_NAME_LENGTH;
        HCERTSTORE Store = Context->hCertStore;
        BOOL    fFreeStore = FALSE;

        Buffer = new RPC_CHAR[BufferLength];
        if (!Buffer)
            {
            return ERROR_NOT_ENOUGH_MEMORY;
            }

        PCCERT_CONTEXT Node = Context;
        do
            {
            Status = AddComponentName( &Buffer,
                                       &BufferLength,
                                       &Cursor,
                                       &Node->pCertInfo->Subject
                                       );
            if (Status)
                {
                RpcpErrorAddRecord(EEInfoGCSecurityProvider,
                                   Status,
                                   EEInfoDLRpcCertGeneratePrincipalName10);

                return Status;
                }

            //
            // Load the next certificate.
            //
            PCCERT_CONTEXT OldNode = Node;

            if (CertCompareCertificateName( X509_ASN_ENCODING,
                                            &Node->pCertInfo->Subject,
                                            &Node->pCertInfo->Issuer
                                            ))
                {
                break;
                }

            Node = CertFindCertificateInStore( Store,
                                               X509_ASN_ENCODING,
                                               0,                             // no flags
                                               CERT_FIND_SUBJECT_NAME,        // exact match
                                               &OldNode->pCertInfo->Issuer,
                                               NULL                           // previous context in search
                                               );
            if (!Node)
                {
                //
                // Take the top-level CA name from the current node's issuer field.
                //
                Status = AddComponentName( &Buffer,
                                           &BufferLength,
                                           &Cursor,
                                           &OldNode->pCertInfo->Issuer
                                           );
                if (Status)
                    {
                    RpcpErrorAddRecord(EEInfoGCSecurityProvider,
                                       Status,
                                       EEInfoDLRpcCertGeneratePrincipalName20);

                    CertFreeCertificateContext( OldNode );
                    return Status;
                    }
                }

            if (OldNode != Context)
                {
                CertFreeCertificateContext( OldNode );
                }
            }
        while ( Node );

        if (Cursor+FULLPATH_PREFIX_LENGTH+1 > BufferLength)
            {
            DWORD LongerBufferLength = BufferLength+FULLPATH_PREFIX_LENGTH+1;
            RPC_CHAR * LongerBuffer = new RPC_CHAR[LongerBufferLength];
            if (!LongerBuffer)
                {
                delete Buffer;
                return ERROR_NOT_ENOUGH_MEMORY;
                }

            RpcpStringNCopy( LongerBuffer, Buffer, BufferLength );

            delete Buffer;

            Buffer       = LongerBuffer;
            BufferLength = LongerBufferLength;
            }

        RpcpStringCopy( Buffer+Cursor,FULLPATH_PREFIX );
        RpcpStringReverse( Buffer+Cursor );
        RpcpStringReverse( Buffer );

        *pBuffer = Buffer;
        return 0;
        }
    else
        {

        RPC_CHAR * outputName;

        DWORD NameSize = CertGetNameStringW(Context,
                                            CERT_NAME_EMAIL_TYPE,
                                            0, // dwFlags
                                            NULL, // pvTypePara
                                            NULL,
                                            0);

        if (NameSize > 1)
            {
            outputName = new RPC_CHAR[ NameSize + MSSTD_PREFIX_LENGTH ];
            
            if (!outputName)
                {
                return ERROR_NOT_ENOUGH_MEMORY;
                }

            RpcpStringCopy(outputName, MSSTD_PREFIX);
        
            NameSize = CertGetNameStringW(Context,
                                          CERT_NAME_EMAIL_TYPE,
                                          0,
                                          NULL,
                                          outputName + MSSTD_PREFIX_LENGTH,
                                          NameSize);

            ASSERT(NameSize > 1);
            }
        else
            {
            NameSize = CertGetNameStringW(Context,
                                          CERT_NAME_ATTR_TYPE,
                                          0,
                                          szOID_COMMON_NAME,
                                          NULL,
                                          0);
            
            if (NameSize > 1)
                {
                outputName = new RPC_CHAR[ NameSize + MSSTD_PREFIX_LENGTH ];

                if (!outputName)
                    {
                    return ERROR_NOT_ENOUGH_MEMORY;
                    }
                
                RpcpStringCopy(outputName, MSSTD_PREFIX);
        
                NameSize = CertGetNameString(Context,
                                             CERT_NAME_ATTR_TYPE,
                                             0,
                                             szOID_COMMON_NAME,
                                             outputName + MSSTD_PREFIX_LENGTH,
                                             NameSize);
                
                ASSERT(NameSize > 1);
                }
            else
                {
                RpcpErrorAddRecord(EEInfoGCSecurityProvider,
                                   ERROR_INVALID_PARAMETER,
                                   EEInfoDLRpcCertGeneratePrincipalName30,
                                   GetLastError());

                return ERROR_INVALID_PARAMETER;
                } 
            }
        
        *pBuffer = outputName;

        return 0;
        }

    ASSERT( 0 && "never reach here" );
    return ERROR_INVALID_PARAMETER;
}


DWORD
AddComponentName( RPC_CHAR *     *  pBuffer,
                  unsigned long  *  pBufferLength,
                  unsigned long  *  pCursor,
                  CERT_NAME_BLOB *  Name
                  )
{
    (*pBuffer)[(*pCursor)++] = '>';

    DWORD Length = *pBufferLength - *pCursor;

    Length = CertNameToStrT( X509_ASN_ENCODING,
                             Name,
                             CERT_X500_NAME_STR,
                             *pBuffer + *pCursor,
                             Length
                             );

    if (Length >= *pBufferLength - *pCursor)
        {
        DWORD LongerBufferLength = 2 * *pBufferLength + Length;
        RPC_CHAR * LongerBuffer = new RPC_CHAR[LongerBufferLength];
        if (!LongerBuffer)
            {
            delete *pBuffer;
            return ERROR_NOT_ENOUGH_MEMORY;
            }

        RpcpStringNCopy( LongerBuffer, *pBuffer, *pBufferLength );

        delete *pBuffer;

        *pBuffer       = LongerBuffer;
        *pBufferLength = LongerBufferLength;

        Length = *pBufferLength - *pCursor;

        Length = CertNameToStrT( X509_ASN_ENCODING,
                                 Name,
                                 CERT_X500_NAME_STR,
                                 *pBuffer + *pCursor,
                                 Length
                                 );
        }

    RpcpStringReverse(*pBuffer + *pCursor);
    *pCursor += Length-1; // write over the '\0'

    (*pBuffer)[(*pCursor)++] = '<';
    (*pBuffer)[(*pCursor)++] = '\\';

    return 0;
}


unsigned
Int4StrLen(
           unsigned long * String
           )
{
    unsigned long * Cursor = String;

    while (*Cursor)
        {
        ++Cursor;
        }

    return (unsigned) (Cursor - String);
}

HMODULE Crypt32Handle = 0;
struct CRYPT32_FUNCTION_TABLE CFT;


BOOL
LoadCrypt32Imports()
{
    if (0 == Crypt32Handle)
        {
        RequestGlobalMutex();

        if (Crypt32Handle)
            {
            goto Cleanup;
            }

        Crypt32Handle = LoadLibrary(RPC_CONST_SSTRING("crypt32.dll"));
        if (!Crypt32Handle)
            {
            goto Cleanup;
            }

        FARPROC * ppProc = (FARPROC *) &CFT;

        *ppProc++ = GetProcAddress(Crypt32Handle, "CertOpenStore");
        *ppProc++ = GetProcAddress(Crypt32Handle, "CertCloseStore");
        *ppProc++ = GetProcAddress(Crypt32Handle, "CertFindCertificateInStore");
        *ppProc++ = GetProcAddress(Crypt32Handle, "CertFreeCertificateContext");
        *ppProc++ = GetProcAddress(Crypt32Handle, "CertCompareCertificateName");
#ifdef UNICODE
        *ppProc++ = GetProcAddress(Crypt32Handle, "CertStrToNameW");
        *ppProc++ = GetProcAddress(Crypt32Handle, "CertNameToStrW");
#else
        *ppProc++ = GetProcAddress(Crypt32Handle, "CertStrToNameA");
        *ppProc++ = GetProcAddress(Crypt32Handle, "CertNameToStrA");
#endif
        *ppProc++ = GetProcAddress(Crypt32Handle, "CertFindRDNAttr");
        *ppProc++ = GetProcAddress(Crypt32Handle, "CryptDecodeObject");

#if MANUAL_CERT_CHECK
        *ppProc++ = GetProcAddress(Crypt32Handle, "CertVerifyCertificateChainPolicy");
        *ppProc++ = GetProcAddress(Crypt32Handle, "CertGetCertificateChain");
        *ppProc++ = GetProcAddress(Crypt32Handle, "CertFreeCertificateChain");
#endif

        *ppProc++ = GetProcAddress(Crypt32Handle, "CertGetNameStringW");

        ppProc = (FARPROC *) &CFT;

        for (int i = 0; i < sizeof(CRYPT32_FUNCTION_TABLE)/sizeof(FARPROC); i++)
            {
            if (*ppProc++ == 0)
                {
                FreeLibrary(Crypt32Handle);
                Crypt32Handle = 0;
                goto Cleanup;
                }
            }
        ClearGlobalMutex();
        }

    return TRUE;

Cleanup:
    ClearGlobalMutex();
    return FALSE;
}

#if MANUAL_CERT_CHECK

DWORD
RpcCertVerifyContext(
    IN PCERT_CONTEXT Context,
    IN DWORD CapabilityFlags
    )
{
    DWORD s = 0;
    HCERTSTORE CaStore = 0;
    PCCERT_CHAIN_CONTEXT Chain = 0;

    //
    // Windows 2000 checked only the CA store, so we should check it also.
    //
    CaStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_W,
                             0,
                             0,
                             CERT_SYSTEM_STORE_CURRENT_USER,
                             RPC_CONST_STRING("CA")
                             );
    if (!CaStore)
        {
        s = GetLastError();
        RpcpErrorAddRecord(EEInfoGCSecurityProvider,
                           s,
                           EEInfoDLRpcCertVerifyContext10);

        goto Cleanup;
        }

    //
    // Build a certificate chain from the single certificate we have.
    //
    CERT_CHAIN_PARA ChainParameters;

    ChainParameters.cbSize = sizeof(CERT_CHAIN_PARA);
    ChainParameters.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
    ChainParameters.RequestedUsage.Usage.cUsageIdentifier = 0;

    if (!CertGetCertificateChain( NULL,     // use default chain engine
                                  Context,
                                  NULL,     // match against current time
                                  CaStore,  // aditional store to search
                                  &ChainParameters,
                                  0,        // no special flags
                                  0,        // reserved, MBZ
                                  &Chain
                                  ))
        {
        s = GetLastError();
        RpcpErrorAddRecord(EEInfoGCSecurityProvider,
                           s,
                           EEInfoDLRpcCertVerifyContext20);

        goto Cleanup;
        }

    //
    // Verify the chain.
    //
    CERT_CHAIN_POLICY_PARA   PolicyParameters;
    CERT_CHAIN_POLICY_STATUS PolicyStatus;

    PolicyParameters.cbSize = sizeof(CERT_CHAIN_POLICY_PARA);
    PolicyParameters.dwFlags = 0;
    PolicyParameters.pvExtraPolicyPara = 0;

    if (CapabilityFlags & RPC_C_QOS_CAPABILITIES_ANY_AUTHORITY)
        {
        PolicyParameters.dwFlags |= CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG;
        }

    PolicyStatus.cbSize = sizeof(CERT_CHAIN_POLICY_STATUS);

    if (!CertVerifyCertificateChainPolicy( CERT_CHAIN_POLICY_BASE,
                                           Chain,
                                           &PolicyParameters,
                                           &PolicyStatus))
        {
        s = GetLastError();
        RpcpErrorAddRecord(EEInfoGCSecurityProvider,
                           s,
                           EEInfoDLRpcCertVerifyContext30);

        goto Cleanup;
        }

    if (PolicyStatus.dwError)
        {
        s = ERROR_ACCESS_DENIED;
        RpcpErrorAddRecord(EEInfoGCSecurityProvider,
                           s,
                           EEInfoDLRpcCertVerifyContext40,
                           GetLastError());

        goto Cleanup;
        }

    //
    // Certificate verification succeeded.
    //
    s = 0;

Cleanup:

    if (Chain)
        {
        CertFreeCertificateChain( Chain );
        }

    if (CaStore)
        {
        CertCloseStore( CaStore, 0 );
        }

    return s;
}

#endif

RPC_STATUS
ValidateSchannelPrincipalName(
    IN RPC_CHAR * EncodedName
    )
//
// Does a quick syntactic check of an SSL principal name.
// The name should not be modified in any way.
//
// It should begin either with "msstd:" or "fullsic:".
// If msstd, then any non-enpty name will do.
// If fullsic, it should be a series of RFC1179 names, each surrounded
// by angle brackets, and separated by backslashes.  We check this by cloning
// the string and marking the components.
//
{
#define MAX_SSL_SPN_LENGTH  8000

    if (0 == RpcpStringNCompare(EncodedName, MSSTD_PREFIX, MSSTD_PREFIX_LENGTH))
        {
        if (EncodedName[MSSTD_PREFIX_LENGTH] == 0)
            {
            return ERROR_INVALID_PARAMETER;
            }
        }
    else if (0 == RpcpStringNCompare(EncodedName, FULLPATH_PREFIX, FULLPATH_PREFIX_LENGTH))
        {
        RPC_STATUS Status;
        size_t Length;
        unsigned ComponentCount;
        RPC_CHAR * PrincipalName;
        RPC_CHAR * EncodedPrincipalName;

        Length = RpcpStringLength( EncodedName );
        if (Length > MAX_SSL_SPN_LENGTH)
            {
            return ERROR_INVALID_PARAMETER;
            }

        PrincipalName = (RPC_CHAR *) _alloca(sizeof(RPC_CHAR) * Length);

        Status = DecodeEscapedString(EncodedName, PrincipalName);
        if (Status)
            {
            return Status;
            }

        Status = MarkPrincipalNameComponents( PrincipalName + FULLPATH_PREFIX_LENGTH, &ComponentCount );
        if (Status)
            {
            return Status;
            }

        if (ComponentCount < 1)
            {
            return ERROR_INVALID_PARAMETER;
            }
        }
    else
        {
        return ERROR_INVALID_PARAMETER;
        }

    return RPC_S_OK;
}

RPC_STATUS
I_RpcTransCertMatchPrincipalName(
                   PCCERT_CONTEXT Context,
                   RPC_CHAR PrincipalName[]
                   )
/*++

Routine Description:

    Verifies that the passed in context match the passed in 
        principal name and frees the certificate.

Arguments:

    Context - certificate context.

    PrincipalName - a principal name prefixed with either "msstd:" or "fullsic:"
    
Return Value:

    RPC_S_OK or RPC_S_ACCESS_DENIED

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = RpcCertMatchPrincipalName(Context, PrincipalName);

    if (RpcStatus == ERROR_OUTOFMEMORY)
        RpcStatus = RPC_S_OUT_OF_MEMORY;
    else if (RpcStatus != RPC_S_OK)
        RpcStatus = RPC_S_ACCESS_DENIED;

    CertFreeCertificateContext(Context);

    return RpcStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\protbind.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1990 - 1999
//
//  File:       ProtBind.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

File: ProtBind.cxx

Description:

    The implementation of the classes that support the binding process for 
    connection oriented and local.

History :

kamenm     10-01-00    Cloned from other files with a face lift and few stitches added

-------------------------------------------------------------------- */

#include <precomp.hxx>
#include <ProtBind.hxx>

// the following lookup table uses the least significant byte of
// SyntaxGUID.Data4[0]. It is 0xF for NDR20, 0x3 for NDR64, and
// 0x5 for NDRTest
const int SyntaxBindingCapabilitiesLookup[0x10] = {
    MTSyntaxBinding::SyntaxBindingCapabilityInvalid,     // 0
    MTSyntaxBinding::SyntaxBindingCapabilityInvalid,     // 1
    MTSyntaxBinding::SyntaxBindingCapabilityInvalid,     // 2
    MTSyntaxBinding::SyntaxBindingCapabilityNDR64,       // 3 - NDR64
    MTSyntaxBinding::SyntaxBindingCapabilityInvalid,     // 4
    MTSyntaxBinding::SyntaxBindingCapabilityNDRTest,     // 5 - NDRTest
    MTSyntaxBinding::SyntaxBindingCapabilityInvalid,     // 6
    MTSyntaxBinding::SyntaxBindingCapabilityInvalid,     // 7
    MTSyntaxBinding::SyntaxBindingCapabilityInvalid,     // 8
    MTSyntaxBinding::SyntaxBindingCapabilityInvalid,     // 9
    MTSyntaxBinding::SyntaxBindingCapabilityInvalid,     // 0xA
    MTSyntaxBinding::SyntaxBindingCapabilityInvalid,     // 0xB
    MTSyntaxBinding::SyntaxBindingCapabilityInvalid,     // 0xC
    MTSyntaxBinding::SyntaxBindingCapabilityInvalid,     // 0xD
    MTSyntaxBinding::SyntaxBindingCapabilityInvalid,     // 0xE
    MTSyntaxBinding::SyntaxBindingCapabilityNDR20        // 0xF - NDR20
    };


RPC_STATUS 
MTSyntaxBinding::FindOrCreateBinding (
    IN PRPC_CLIENT_INTERFACE RpcInterfaceInformation,
    IN RPC_MESSAGE *Message,
    IN SIMPLE_DICT *BindingsDict,
    IN CreateBindingFn CreateBinding,
    OUT int *NumberOfBindings,
    IN OUT MTSyntaxBinding *BindingsForThisInterface[],
    IN OUT BOOL BindingCreated[]
    )
/*++

Routine Description:

    This method gets called to find the bindings (a dictionary
    entry) corresponding to the specified rpc interface information.
    The caller of this routine is responsible for synchronization

Arguments:

    RpcInterfaceInformation - Supplies the interface information for
        which we are looking for an osf binding object.
    Message - supplies the RPC_MESSAGE for this call
    NumberOfBindings - an out parameter that will return the number
        of retrieved bindings
    BindingsForThisInterface - a caller supplied array where the
        found bindings will be placed.

Return Value:

    RPC_S_OK for success, other for failure

--*/
{
    MTSyntaxBinding *Binding;
    DictionaryCursor cursor;
    unsigned int i;
    ULONG NumberOfTransferSyntaxes;
    MIDL_SYNTAX_INFO *SyntaxInfoArray;
    int NextBindingToBeReturned;
    RPC_STATUS Status;
    BOOL fHasMultiSyntaxes;
    TRANSFER_SYNTAX_STUB_INFO *CurrentTransferInfo;
    int ClientPreferredTransferSyntax;
    MTSyntaxBinding *CurrentBinding;
    int CapabilitiesBitmap;
    unsigned char CurrentTransferInfoLookupValue;
    int CurrentCapability;

    if ((RpcInterfaceInformation->Length != sizeof(RPC_CLIENT_INTERFACE)) &&
        (RpcInterfaceInformation->Length != NT351_INTERFACE_SIZE))
        {
        return RPC_S_UNKNOWN_IF;
        }

    if (DoesInterfaceSupportMultipleTransferSyntaxes(RpcInterfaceInformation))
        {
        Status = NdrClientGetSupportedSyntaxes (RpcInterfaceInformation,
            &NumberOfTransferSyntaxes, &SyntaxInfoArray);
        if (Status != RPC_S_OK)
            return Status;

        ASSERT(NumberOfTransferSyntaxes > 0);
        ASSERT(SyntaxInfoArray != NULL);

        fHasMultiSyntaxes = TRUE;
        }
    else
        {
        fHasMultiSyntaxes = FALSE;
        NumberOfTransferSyntaxes = 1;
        }

    // build the capabilities bitmap
    CapabilitiesBitmap = 0;
    for (i = 0; i < NumberOfTransferSyntaxes; i ++)
        {
        if (fHasMultiSyntaxes)
            {
            CurrentTransferInfo 
                = (TRANSFER_SYNTAX_STUB_INFO *)&SyntaxInfoArray[i].TransferSyntax;
            }
        else
            {
            CurrentTransferInfo 
                = (TRANSFER_SYNTAX_STUB_INFO *)&RpcInterfaceInformation->TransferSyntax;
            }

        CurrentTransferInfoLookupValue = CurrentTransferInfo->TransferSyntax.SyntaxGUID.Data4[0] & 0xF;
        CurrentCapability = SyntaxBindingCapabilitiesLookup[CurrentTransferInfoLookupValue];

        ASSERT(CurrentCapability != MTSyntaxBinding::SyntaxBindingCapabilityInvalid);

        if (CurrentCapability == MTSyntaxBinding::SyntaxBindingCapabilityInvalid)
            return RPC_S_UNSUPPORTED_TRANS_SYN;

        CapabilitiesBitmap |= CurrentCapability;
        }

    // if we create a binding here, we must also properly link it to the
    // other bindings that differ only by transfer syntax. We rely on the fact
    // that the stubs will always return multiple transfer syntaxes in the same
    // order. Therefore, we add them one by one, and if we fail towards the end
    // we leave the already added entries there. The next time we come, we
    // will try to continue off where we left
    NextBindingToBeReturned = 0;
    CurrentBinding = 0;
    for (i = 0; i < NumberOfTransferSyntaxes; i ++)
        {
        //
        // First we search for an existing presentation context
        // corresponding to the specified interface information.  Otherwise,
        // we create a new presentation context.
        //
        if (fHasMultiSyntaxes)
            {
            CurrentTransferInfo 
                = (TRANSFER_SYNTAX_STUB_INFO *)&SyntaxInfoArray[i].TransferSyntax;
            }
        else
            {
            CurrentTransferInfo 
                = (TRANSFER_SYNTAX_STUB_INFO *)&RpcInterfaceInformation->TransferSyntax;
            }

        BindingsDict->Reset(cursor);
        while ((Binding = (MTSyntaxBinding *)BindingsDict->Next(cursor)) != 0)
            {
            if (Binding->CompareWithRpcInterfaceInformation(&RpcInterfaceInformation->InterfaceId,
                    CurrentTransferInfo, CapabilitiesBitmap) == 0)
                {
                BindingCreated[NextBindingToBeReturned] = FALSE;

                CurrentBinding = Binding;
                goto StoreResultAndLookForNextTransferSyntax;
                }
            }

        // if we are here, we haven't found any bindings for this transfer syntax -
        // create some
        Binding = CreateBinding(&RpcInterfaceInformation->InterfaceId, 
            CurrentTransferInfo, CapabilitiesBitmap);

        if (Binding == 0)
            {
            *NumberOfBindings = i;
            return(RPC_S_OUT_OF_MEMORY);
            }

        Binding->SetPresentationContext(BindingsDict->Insert(Binding));
        if (Binding->GetPresentationContext() == -1)
            {
            delete Binding;
            *NumberOfBindings = i;
            return RPC_S_OUT_OF_MEMORY;
            }

        if (CurrentBinding != 0)
            CurrentBinding->SetNextBinding(Binding);

        CurrentBinding = Binding;

        // the first transfer syntax info is marked as the list start
        // this helps us figure out where the list starts later on
        if (i == 0)
            Binding->TransferSyntaxIsListStart();

        BindingCreated[NextBindingToBeReturned] = TRUE;

StoreResultAndLookForNextTransferSyntax:
        // return the newly created binding to our caller
        BindingsForThisInterface[NextBindingToBeReturned] = Binding;
        NextBindingToBeReturned ++;
        }

    *NumberOfBindings = NumberOfTransferSyntaxes;
    return RPC_S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\queue.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       queue.cxx
//
//--------------------------------------------------------------------------

/*++

--*/

#include <precomp.hxx>
#include <queue.hxx>


QUEUE::QUEUE (
    )
/*++

Routine Description:

    We will construct an empty queue.

--*/
{
    ALLOCATE_THIS(QUEUE);

    QueueSlots = InitialQueueSlots;
    NumberOfQueueSlots = INITIALQUEUESLOTS;
    EndOfQueue = 0;
}


QUEUE::~QUEUE (
    )
/*++

Routine Desciption:

    We need to free up the queue slots if they have expanded beyond
    the initial ones.

--*/
{
    if (QueueSlots != InitialQueueSlots)
        delete QueueSlots;
}


int
QUEUE::PutOnQueue (
    IN void * Item,
    IN unsigned int Length
    )
/*++

Routine Description:

    The item will be placed on the tail of the queue.

Arguments:

    Item - Supplies the item to be placed on the queue.

    Length - Supplies the length of the item.

Return Value:

    Zero will be returned if everything completes successfully; otherwise,
    non-zero will be returned indicating an out of memory error.

--*/
{
    QUEUE_ITEM * NewQueueSlots;
    int Count;

    if (EndOfQueue == NumberOfQueueSlots)
        {
        NewQueueSlots = (QUEUE_ITEM *) new char[
                sizeof(QUEUE_ITEM) * NumberOfQueueSlots * 2];
        if (NewQueueSlots == 0)
            return(1);
        memcpy(NewQueueSlots, QueueSlots,
                sizeof(QUEUE_ITEM) * NumberOfQueueSlots);
        if (QueueSlots != InitialQueueSlots)
            delete QueueSlots;
        QueueSlots = NewQueueSlots;
        NumberOfQueueSlots *= 2;
        }

    for (Count = EndOfQueue; Count > 0; Count--)
        {
        ASSERT(QueueSlots[Count-1].Buffer != Item);
        QueueSlots[Count] = QueueSlots[Count - 1];
        }

    EndOfQueue += 1;
    QueueSlots[0].Buffer = Item;
    QueueSlots[0].BufferLength = Length;

    return(0);
}

int
QUEUE::PutOnFrontOfQueue (
    IN void * Item,
    IN unsigned int Length
    )
/*++

Routine Description:

    The item will be placed on the front of the queue.

Arguments:

    Item - Supplies the item to be placed on the queue.

    Length - Supplies the length of the item.

Return Value:

    Zero will be returned if everything completes successfully; otherwise,
    non-zero will be returned indicating an out of memory error.

--*/
{
    QUEUE_ITEM * NewQueueSlots;
    int Count;

    if (EndOfQueue == NumberOfQueueSlots)
        {
        NewQueueSlots = (QUEUE_ITEM *) new char[
                sizeof(QUEUE_ITEM) * NumberOfQueueSlots * 2];
        if (NewQueueSlots == 0)
            return(1);
        memcpy(NewQueueSlots, QueueSlots,
                sizeof(QUEUE_ITEM) * NumberOfQueueSlots);
        if (QueueSlots != InitialQueueSlots)
            delete QueueSlots;
        QueueSlots = NewQueueSlots;
        NumberOfQueueSlots *= 2;
        }

    QueueSlots[EndOfQueue].Buffer = Item;
    QueueSlots[EndOfQueue].BufferLength = Length;
    EndOfQueue += 1;

    return(0);
}
    

void *
QUEUE::TakeOffQueue (
    OUT unsigned int * Length
    )
/*++

Routine Description:

    This routine will remove an item from the front of the queue and
    return it.

Arguments:

    Length - Returns the length of the item in the queue.

Return Value:

    If the queue is not empty, the last item in the queue will be
    returned; otherwise, zero will be returned.

--*/
{
    if (EndOfQueue == 0)
        return(0);
    EndOfQueue -= 1;
    *Length = QueueSlots[EndOfQueue].BufferLength;
    return(QueueSlots[EndOfQueue].Buffer);
}


void *
QUEUE::TakeOffEndOfQueue (
    OUT unsigned int * Length
    )
/*++

Routine Description:

    This routine will remove an item from the tail of the queue and
    return it.

Arguments:

    Length - Returns the length of the item in the queue.

Return Value:

    If the queue is not empty, the last item in the queue will be
    returned; otherwise, zero will be returned.

--*/
{
    void *Buffer;
    int Count;

    if (EndOfQueue == 0)
        return(0);

    *Length = QueueSlots[0].BufferLength;
    Buffer = QueueSlots[0].Buffer;
    
    EndOfQueue -= 1;

    for (Count = 0; Count < EndOfQueue; Count++)
        {
        QueueSlots[Count] = QueueSlots[Count + 1];
        }

    return(Buffer);
}

int 
QUEUE::MergeWithQueue (
    IN QUEUE *pQueue
    )
/*++

Routine Description:

    Takes the contents of the second queue and merges it into the first queue. Does not check for
    duplicates. Does not implement transactional semantics - i.e. if merging fails halfway due to lack
    of memory, the operation is aborted, and the amount of elements that were transferred remain in
    the this queue. Appropriate synchronization must be taken care for by the caller.

Arguments:

    pQueue - the queue that we want to merge from.

Return Value:

    0 - success
    !0 - failure - out of memory

--*/
{
    unsigned int nLength;
    void *pQueueElement;

    while (1)
        {
        pQueueElement = pQueue->TakeOffQueue(&nLength);
        if (pQueueElement == 0)
            break;

        if (PutOnQueue(pQueueElement, nLength) != 0)
            {
            // guaranteed to succeed since we never decrease buffers
            pQueue->PutOnFrontOfQueue(pQueueElement, nLength);
            return 1;
            }
        }
    return 0;
}

int 
QUEUE::MergeWithQueueInFront (
    IN QUEUE *SourceQueue
    )
/*++

Routine Description:

    Takes the contents of the second queue and merges it into the front of first queue. Does not check for
    duplicates. Does not implement transactional semantics - i.e. if merging fails halfway due to lack
    of memory, the operation is aborted, and the amount of elements that were transferred remain in
    the this queue. Appropriate synchronization must be taken care for by the caller.

Arguments:

    SourceQueue - the queue that we want to merge from.

Return Value:

    0 - success
    !0 - failure - out of memory

--*/
{
    unsigned int nLength;
    void *pQueueElement;

    while (1)
        {
        pQueueElement = SourceQueue->TakeOffEndOfQueue(&nLength);
        if (pQueueElement == 0)
            break;

        if (PutOnFrontOfQueue(pQueueElement, nLength) != 0)
            {
            // guaranteed to succeed since we never decrease buffers
            SourceQueue->PutOnFrontOfQueue(pQueueElement, nLength);
            return 1;
            }
        }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\rpcerr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1991 - 1999
//
//  File:       rpcerr.h
//
//--------------------------------------------------------------------------

/*********************************************************/
/**               Microsoft LAN Manager                 **/
/**       Copyright(c) Microsoft Corp., 1987-1990       **/
/**                                                     **/
/**     Rpc Error Codes from the compiler and runtime   **/
/**                                                     **/
/*********************************************************/

/*
If you change this file, you must also change ntstatus.mc and winerror.mc
*/

#ifndef __RPCERR_H__
#define __RPCERR_H__

#define RPC_S_OK                          0
#define RPC_S_INVALID_ARG                 1
#define RPC_S_INVALID_STRING_BINDING      2
#define RPC_S_OUT_OF_MEMORY               3
#define RPC_S_WRONG_KIND_OF_BINDING       4
#define RPC_S_INVALID_BINDING             5
#define RPC_S_PROTSEQ_NOT_SUPPORTED       6
#define RPC_S_INVALID_RPC_PROTSEQ         7
#define RPC_S_INVALID_STRING_UUID         8
#define RPC_S_INVALID_ENDPOINT_FORMAT     9

#define RPC_S_INVALID_NET_ADDR            10
#define RPC_S_INVALID_NAF_ID              11
#define RPC_S_NO_ENDPOINT_FOUND           12
#define RPC_S_INVALID_TIMEOUT             13
#define RPC_S_OBJECT_NOT_FOUND            14
#define RPC_S_ALREADY_REGISTERED          15
#define RPC_S_TYPE_ALREADY_REGISTERED     16
#define RPC_S_ALREADY_LISTENING           17
#define RPC_S_NO_PROTSEQS_REGISTERED      18
#define RPC_S_NOT_LISTENING               19

#define RPC_S_OUT_OF_THREADS              20
#define RPC_S_UNKNOWN_MGR_TYPE            21
#define RPC_S_UNKNOWN_IF                  22
#define RPC_S_NO_BINDINGS                 23
#define RPC_S_NO_PROTSEQS                 24
#define RPC_S_CANT_CREATE_ENDPOINT        25
#define RPC_S_OUT_OF_RESOURCES            26
#define RPC_S_SERVER_UNAVAILABLE          27
#define RPC_S_SERVER_TOO_BUSY             28
#define RPC_S_INVALID_NETWORK_OPTIONS     29

#define RPC_S_NO_CALL_ACTIVE              30
#define RPC_S_INVALID_LEVEL               31
#define RPC_S_CANNOT_SUPPORT              32
#define RPC_S_CALL_FAILED                 33
#define RPC_S_CALL_FAILED_DNE             34
#define RPC_S_PROTOCOL_ERROR              35

// Unused.

// Unused.

#define RPC_S_UNSUPPORTED_TRANS_SYN       38
#define RPC_S_BUFFER_TOO_SMALL            39

#define RPC_S_NO_CONTEXT_AVAILABLE        40
#define RPC_S_SERVER_OUT_OF_MEMORY        41
#define RPC_S_UNSUPPORTED_TYPE            42
#define RPC_S_ZERO_DIVIDE                 43
#define RPC_S_ADDRESS_ERROR               44
#define RPC_S_FP_DIV_ZERO                 45
#define RPC_S_FP_UNDERFLOW                46
#define RPC_S_FP_OVERFLOW                 47
#define RPC_S_INVALID_TAG                 48
#define RPC_S_INVALID_BOUND               49

#define RPC_S_NO_ENTRY_NAME               50
#define RPC_S_INVALID_NAME_SYNTAX         51
#define RPC_S_UNSUPPORTED_NAME_SYNTAX     52
#define RPC_S_UUID_LOCAL_ONLY             53
#define RPC_S_UUID_NO_ADDRESS             54
#define RPC_S_DUPLICATE_ENDPOINT          55
#define RPC_S_INVALID_SECURITY_DESC       56
#define RPC_S_ACCESS_DENIED               57
#define RPC_S_UNKNOWN_AUTHN_TYPE          58
#define RPC_S_MAX_CALLS_TOO_SMALL         59

#define RPC_S_STRING_TOO_LONG             60
#define RPC_S_PROTSEQ_NOT_FOUND           61
#define RPC_S_PROCNUM_OUT_OF_RANGE        62
#define RPC_S_BINDING_HAS_NO_AUTH         63
#define RPC_S_UNKNOWN_AUTHN_SERVICE       64
#define RPC_S_UNKNOWN_AUTHN_LEVEL         65
#define RPC_S_INVALID_AUTH_IDENTITY       66
#define RPC_S_UNKNOWN_AUTHZ_SERVICE       67
#define EPT_S_INVALID_ENTRY               68
#define EPT_S_CANT_PERFORM_OP             69

#define EPT_S_NOT_REGISTERED              70
#define RPC_S_NOTHING_TO_EXPORT           71
#define RPC_S_INCOMPLETE_NAME             72
#define RPC_S_UNIMPLEMENTED_API           73
#define RPC_S_INVALID_VERS_OPTION         74
#define RPC_S_NO_MORE_MEMBERS             75
#define RPC_S_NOT_ALL_OBJS_UNEXPORTED     76
#define RPC_S_INTERFACE_NOT_FOUND         77
#define RPC_S_ENTRY_ALREADY_EXISTS        78
#define RPC_S_ENTRY_NOT_FOUND             79

#define RPC_S_NAME_SERVICE_UNAVAILABLE    80
#define RPC_S_CALL_IN_PROGRESS            81
#define RPC_S_NO_MORE_BINDINGS            82
#define RPC_S_GROUP_MEMBER_NOT_FOUND      83
#define EPT_S_CANT_CREATE                 84
#define RPC_S_INVALID_OBJECT              85
#define RPC_S_CALL_CANCELLED              86
#define RPC_S_BINDING_INCOMPLETE          87
#define RPC_S_COMM_FAILURE                88
#define RPC_S_UNSUPPORTED_AUTHN_LEVEL     89

#define RPC_S_NO_PRINC_NAME               90
#define RPC_S_NOT_RPC_ERROR               91
#define RPC_S_SEC_PKG_ERROR               92
#define RPC_S_NOT_CANCELLED               93
#define RPC_S_SEND_INCOMPLETE             94
#define RPC_S_NO_INTERFACES               95
#define RPC_S_ASYNC_CALL_PENDING          96
#define RPC_S_INVALID_ASYNC_HANDLE        97
#define RPC_S_INVALID_ASYNC_CALL          98

#define RPC_S_INTERNAL_ERROR              100

/* The list of servers available for auto_handle binding has been exhausted. */

#define RPC_X_NO_MORE_ENTRIES		256

/* Insufficient memory available to set up necessary data structures. */

#define RPC_X_NO_MEMORY			257

/* The specified bounds of an array are inconsistent. */

#define RPC_X_INVALID_BOUND		258

/* The discriminant value does not match any of the case values. */
/* There is no default case. */

#define RPC_X_INVALID_TAG		259

/* The file designated by DCERPCCHARTRANS cannot be opened. */

#define RPC_X_SS_CHAR_TRANS_OPEN_FAIL	260

/* The file containing char translation table has fewer than 512 bytes. */

#define RPC_X_SS_CHAR_TRANS_SHORT_FILE	261

/* A null context handle is passed in an [in] parameter position. */

#define RPC_X_SS_IN_NULL_CONTEXT	262

/* Only raised on the callee side. */
/* A uuid in an [in] handle does not correspond to any known context. */

#define RPC_X_SS_CONTEXT_MISMATCH	263

/* Only raised on the caller side. */
/* A uuid in an [in, out] context handle changed during a call. */

#define RPC_X_SS_CONTEXT_DAMAGED	264

#define RPC_X_SS_HANDLES_MISMATCH	265

#define RPC_X_SS_CANNOT_GET_CALL_HANDLE	266

#define RPC_X_NULL_REF_POINTER		267

#define RPC_X_ENUM_VALUE_OUT_OF_RANGE	268

#define RPC_X_BYTE_COUNT_TOO_SMALL	269

#define RPC_X_BAD_STUB_DATA			270

#define RPC_X_INVALID_ES_ACTION			271
#define RPC_X_WRONG_ES_VERSION			272
#define RPC_X_WRONG_STUB_VERSION		273
#define RPC_X_INVALID_BUFFER			274
#define RPC_X_INVALID_PIPE_OBJECT    275
#define RPC_X_INVALID_PIPE_OPERATION 276
#define RPC_X_WRONG_PIPE_VERSION     277
#define RPC_X_PIPE_CLOSED            278
#define RPC_X_PIPE_EMPTY             279
#define RPC_X_WRONG_PIPE_ORDER       280
#define RPC_X_PIPE_DISCIPLINE_ERROR  281

#define RPC_X_PIPE_APP_MEMORY        RPC_S_OUT_OF_MEMORY
#define RPC_X_INVALID_PIPE_OPERATION RPC_X_WRONG_PIPE_ORDER

#endif /* __RPCERR_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\rpcerrp.h ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    rpcerrp.h


Abstract:

    This file contains internal error codes used by the rpc runtime.
    Each error code has a define which begins with RPC_P_.

Author:

    Michael Montague (mikemon) 19-Nov-1991

Revision History:

--*/

#ifndef __RPCERRP_H__
#define __RPCERRP_H__

#ifdef WIN32RPC
#define RPC_P_NETWORK_ADDRESS_TOO_SMALL   0xC0021000L
#define RPC_P_ENDPOINT_TOO_SMALL          0xC0021001L
#define RPC_P_UNSUPPORTED_TRANSFER_SYNTAX 0xC0021005L
#define RPC_P_UNSUPPORTED_INTERFACE       0xC0021006L
#define RPC_P_RECEIVE_ALERTED             0xC0021007L
#define RPC_P_CONNECTION_CLOSED           0xC0021008L
#define RPC_P_RECEIVE_FAILED              0xC0021009L
#define RPC_P_SEND_FAILED                 0xC002100AL
#define RPC_P_TIMEOUT                     0xC002100BL
#define RPC_P_SERVER_TRANSPORT_ERROR      0xC002100CL
#define RPC_P_OK_REQUEST                  0xC002100DL
#define RPC_P_EXCEPTION_OCCURED           0xC002100EL
#define RPC_P_CONTINUE_NEEDED             0xC002100FL
#define RPC_P_COMPLETE_NEEDED             0xC0021010L
#define RPC_P_COMPLETE_AND_CONTINUE       0xC0021011L
#define RPC_P_CONNECTION_SHUTDOWN         0xC0021012L
#define RPC_P_EPMAPPER_EP                 0xC0021013L
#define RPC_P_OVERSIZE_PACKET             0xC0021014L
#define RPC_P_RECEIVE_COMPLETE            0xC0021015L
#define RPC_P_CONTEXT_EXPIRED             0xC0021016L
//#define RPC_P_ABORT_CALL                  0xC0020017L
#define RPC_P_IO_PENDING                  0xC0020018L
#define RPC_P_NO_BUFFERS                  0xC0020019L
#define RPC_P_FOUND_IN_CACHE              0xC0021020L
#define RPC_P_MATCHED_CACHE               0xC0021021L
#define RPC_P_PARTIAL_RECEIVE             0xC0021022L
#define RPC_P_HOST_DOWN                   0XC0021023L
#define RPC_P_PORT_DOWN                   0xC0021024L
#define RPC_P_CLIENT_SHUTDOWN_IN_PROGRESS 0xC0021025L
#define RPC_P_TRANSFER_SYNTAX_CHANGED     0xC0021026L
#define RPC_P_ADDRESS_FAMILY_INVALID      0xC0021028L
#define RPC_P_PACKET_CONSUMED             0xC0021029L
#define RPC_P_CHANNEL_NEEDS_RECYCLING     0xC002102AL
#define RPC_P_PACKET_NEEDS_FORWARDING     0xC002102BL
#define RPC_P_AUTH_NEEDED                 0xC002102CL
#define RPC_P_ABORT_NEEDED                0xC002102DL
#else // WIN32RPC

#define RPC_P_NETWORK_ADDRESS_TOO_SMALL   1000
#define RPC_P_ENDPOINT_TOO_SMALL          1001
#define RPC_P_UNSUPPORTED_TRANSFER_SYNTAX 1005
#define RPC_P_UNSUPPORTED_INTERFACE       1006
#define RPC_P_RECEIVE_ALERTED             1007
#define RPC_P_CONNECTION_CLOSED           1008
#define RPC_P_RECEIVE_FAILED              1009
#define RPC_P_SEND_FAILED                 1010
#define RPC_P_TIMEOUT                     1011
#define RPC_P_SERVER_TRANSPORT_ERROR      1012
#define RPC_P_OK_REQUEST                  1013
#define RPC_P_EXCEPTION_OCCURED           1014
#define RPC_P_CONTINUE_NEEDED             1015
#define RPC_P_COMPLETE_NEEDED             1016
#define RPC_P_COMPLETE_AND_CONTINUE       1017
#define RPC_P_CONNECTION_SHUTDOWN         1018
#define RPC_P_EPMAPPER_EP                 1019
#define RPC_P_OVERSIZE_PACKET             1020
#define RPC_P_THREAD_LISTENING            1021
#define RPC_P_CONTEXT_EXPIRED             1022
#define RPC_P_ABORT_CALL                  1023
#define RPC_P_IO_PENDING                  1024
#define RPC_P_NO_BUFFERS                  1025
#define RPC_P_FOUND_IN_CACHE              1026
#define RPC_P_MATCHED_CACHE               1027
#define RPC_P_PARTIAL_RECEIVE             1028
#endif // WIN32RPC

//
// DCE on-the-wire error codes
//
#define NCA_STATUS_COMM_FAILURE             0x1C010001
#define NCA_STATUS_OP_RNG_ERROR             0x1C010002
#define NCA_STATUS_UNK_IF                   0x1C010003
#define NCA_STATUS_WRONG_BOOT_TIME          0x1C010006
#define NCA_STATUS_YOU_CRASHED              0x1C010009
#define NCA_STATUS_PROTO_ERROR              0x1C01000B
#define NCA_STATUS_OUT_ARGS_TOO_BIG         0x1C010013
#define NCA_STATUS_SERVER_TOO_BUSY          0x1C010014
#define NCA_STATUS_UNSUPPORTED_TYPE         0x1C010017
#define NCA_STATUS_INVALID_PRES_CXT_ID      0x1C01001c
#define NCA_STATUS_UNSUPPORTED_AUTHN_LEVEL  0x1C01001d
#define NCA_STATUS_INVALID_CHECKSUM         0x1C01001f
#define NCA_STATUS_INVALID_CRC              0x1C010020

#define NCA_STATUS_ZERO_DIVIDE              0x1C000001
#define NCA_STATUS_ADDRESS_ERROR            0x1C000002
#define NCA_STATUS_FP_DIV_ZERO              0x1C000003
#define NCA_STATUS_FP_UNDERFLOW             0x1C000004
#define NCA_STATUS_FP_OVERFLOW              0x1C000005
#define NCA_STATUS_INVALID_TAG              0x1C000006
#define NCA_STATUS_INVALID_BOUND            0x1C000007
#define NCA_STATUS_VERSION_MISMATCH         0x1C000008
#define NCA_STATUS_UNSPEC_REJECT            0x1C000009
#define NCA_STATUS_BAD_ACTID                0x1C00000A
#define NCA_STATUS_WHO_ARE_YOU_FAILED       0x1C00000B
#define NCA_STATUS_CALL_DNE                 0x1C00000C
#define NCA_STATUS_FAULT_CANCEL             0x1C00000D
#define NCA_STATUS_ILLEGAL_INSTRUCTION      0x1C00000E
#define NCA_STATUS_FP_ERROR                 0x1C00000F
#define NCA_STATUS_OVERFLOW                 0x1C000010
#define NCA_STATUS_FAULT_UNSPEC             0x1C000012
#define NCA_STATUS_FAULT_PIPE_EMPTY         0x1C000014
#define NCA_STATUS_FAULT_PIPE_CLOSED        0x1C000015
#define NCA_STATUS_FAULT_PIPE_ORDER         0x1C000016
#define NCA_STATUS_FAULT_PIPE_DISCIPLINE    0x1C000017
#define NCA_STATUS_FAULT_PIPE_COMM_ERROR    0x1C000018
#define NCA_STATUS_FAULT_PIPE_MEMORY        0x1C000019
#define NCA_STATUS_CONTEXT_MISMATCH         0x1C00001A
#define NCA_STATUS_REMOTE_OUT_OF_MEMORY     0x1C00001B

#define NCA_STATUS_PARTIAL_CREDENTIALS      0x16C9A117

#endif // __RPCERRP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\rpcqos.h ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    rpcqos.h

Abstract:

    This header file serves one purpose only: it allows the named pipe client
    side loadable transport for NT and the local RPC over LPC to use a common
    routine for parsing the security information from the network options.

Author:

    Michael Montague (mikemon) 10-Apr-1992

Revision History:

--*/

#ifndef __RPCQOS_H__
#define __RPCQOS_H__

#ifdef __cplusplus
extern "C" {
#endif

RPCRTAPI
RPC_STATUS
I_RpcParseSecurity (
    IN RPC_CHAR * NetworkOptions,
    OUT SECURITY_QUALITY_OF_SERVICE * SecurityQos
    );

#ifdef __cplusplus
}
#endif

#endif /* __RPCQOS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\rpcobj.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    rpcobj.cxx

Abstract:

    The implementation of the object dictionary lives in this file;
    it is used to map from an object uuid to a type uuid.  From there
    we need to map to a manager entry point vector.

Author:

    Michael Montague (mikemon) 14-Nov-1991

Revision History:

--*/

#include <precomp.hxx>
#include <rpcobj.hxx>

static RPC_OBJECT_INQ_FN PAPI * ObjectTypeInquiryFn = 0;


class OBJECT_ENTRY
/*++

Class Description:

    Each of the entries in the object dictionary consist of one of these
    objects.

Fields:

    ObjectUuid - Contains the object uuid of this entry.

    TypeUuid - Contains the type uuid of the object uuid in this entry.

    DictionaryKey - Contains the key in the dictionary for this object
        entry.  I made this a public instance variable for two reasons:
            (1) I was just going to defined a writer and a reader for
                it (routines to set and get the value).
            (2) This class is private to a source file, so it is very
                obvious the scope of usage.

--*/
{
private:

    RPC_UUID ObjectUuid;
    RPC_UUID TypeUuid;

public:

    unsigned int DictionaryKey;

    OBJECT_ENTRY (
        IN RPC_UUID PAPI * ObjectUuid,
        IN RPC_UUID PAPI * TypeUuid
        );

    int
    MatchObjectUuid (
        IN RPC_UUID PAPI * ObjectUuid
        );

    void
    CopyToTypeUuid (
        OUT RPC_UUID PAPI * TypeUuid
        );
};


OBJECT_ENTRY::OBJECT_ENTRY (
    IN RPC_UUID PAPI * ObjectUuid,
    IN RPC_UUID PAPI * TypeUuid
    )
/*++

Routine Description:

    This routine is used to construct an entry in the object dictionary.

Arguments:

    ObjectUuid - Supplies the uuid to use to initialize the object uuid
        in this entry.

    TypeUuid - Supplies the uuid to use to initialize the type uuid in
        this entry.

--*/
{
    ALLOCATE_THIS(OBJECT_ENTRY);

    this->ObjectUuid.CopyUuid(ObjectUuid);
    this->TypeUuid.CopyUuid(TypeUuid);
}


inline int
OBJECT_ENTRY::MatchObjectUuid (
    IN RPC_UUID PAPI * ObjectUuid
    )
/*++

Routine Description:

    This method compares the supplied object uuid against the object
    uuid contained in this object entry.

Arguments:

    ObjectUuid - Supplies the object uuid.

Return Value:

    Zero will be returned if the supplied object uuid is the same as the
    object uuid contained in this.

--*/
{
    return(this->ObjectUuid.MatchUuid(ObjectUuid));
}


inline void
OBJECT_ENTRY::CopyToTypeUuid (
    OUT RPC_UUID PAPI * TypeUuid
    )
/*++

Routine Description:

    We copy the type uuid for this object entry into the supplied type
    uuid.

Arguments:

    TypeUuid - Returns a copy of the type uuid in this object entry.

--*/
{
    TypeUuid->CopyUuid(&(this->TypeUuid));
}

NEW_SDICT(OBJECT_ENTRY);

OBJECT_ENTRY_DICT * ObjectDictionary;


OBJECT_ENTRY *
FindObject (
    IN RPC_UUID PAPI * ObjectUuid
    )
/*++

Routine Description:

    This routine is used to find the object entry in the object dictionary
    having the specified object uuid.

Arguments:

    ObjectUuid - Supplies the object uuid which we wish to find.

Return Value:

    The object entry having the supplied object uuid will be returned if
    it can be found, otherwise, zero will be returned.

--*/
{
    OBJECT_ENTRY * ObjectEntry;
    DictionaryCursor cursor;

    ObjectDictionary->Reset(cursor);
    while ((ObjectEntry = ObjectDictionary->Next(cursor)) != 0)
        {
        if (ObjectEntry->MatchObjectUuid(ObjectUuid) == 0)
            return(ObjectEntry);
        }

    return(0);
}


RPC_STATUS
ObjectInqType (
    IN RPC_UUID PAPI * ObjUuid,
    OUT RPC_UUID PAPI * TypeUuid
    )
/*++

Routine Description:

    We search in the dictionary for the specified object UUID; if it
    is found, we return its type UUID.

Parameters:

    ObjUuid - Supplies the object UUID for which we are trying to
        find the type UUID.

    TypeUuid - Returns the type UUID of the object UUID, presuming
        that the object UUID is found.

Return Value:

    RPC_S_OK - The operation completed successfully; the object uuid
        is registered with the runtime or the object inquiry function
        knows the object uuid.

    RPC_S_OBJECT_NOT_FOUND - The specified object uuid has not been
        registered with the runtime and the object inquiry function
        does not know about the object uuid.

--*/
{
    RPC_STATUS Status;
    OBJECT_ENTRY * ObjectEntry;

    if (   ObjUuid == NULL
        || ObjUuid->IsNullUuid())
        {
        TypeUuid->SetToNullUuid();
        return(RPC_S_OK);
        }

    RequestGlobalMutex();
    ObjectEntry = FindObject(ObjUuid);
    if (ObjectEntry == 0)
        {
        if (ObjectTypeInquiryFn == 0)
            {
            ClearGlobalMutex();
            TypeUuid->SetToNullUuid();
            return(RPC_S_OBJECT_NOT_FOUND);
            }
        ClearGlobalMutex();
        (*ObjectTypeInquiryFn)((UUID PAPI *) ObjUuid, (UUID PAPI *) TypeUuid,
                &Status);
        return(Status);
        }

    ObjectEntry->CopyToTypeUuid(TypeUuid);
    ClearGlobalMutex();
    return(RPC_S_OK);
}


RPC_STATUS
ObjectSetInqFn (
    IN RPC_OBJECT_INQ_FN PAPI * InquiryFn
    )
/*++

Routine Description:

    With just two lines of code, the comment for this routine is
    already longer than the routine.

Arguments:

    InquiryFn - Supplies a function to be used when the type of an
        unknown object is inquired.

Return Value:

    RPC_S_OK - This is always returned by the second line of code.

--*/
{
    ObjectTypeInquiryFn = InquiryFn;

    return(RPC_S_OK);
}


RPC_STATUS
ObjectSetType (
    IN RPC_UUID PAPI * ObjUuid,
    IN RPC_UUID PAPI * TypeUuid OPTIONAL
    )
/*++

Routine Description:

    This routine is used to associate a type UUID with an object UUID.

Arguments:

    ObjUuid - Supplies the object UUID.

    TypeUuid - Supplies the type UUID to associate with the object
        UUID.

Return Value:

    RPC_S_OK - The type UUID was successfully associated with the
        object UUID.

    RPC_S_ALREADY_REGISTERED - The object uuid specified has already
        been registered with the runtime.

    RPC_S_OUT_OF_MEMORY - There is insufficient memory available to
        associate the object UUID with the type UUID.

    RPC_S_INVALID_OBJECT - The object uuid specified is the nil uuid.

--*/
{
    OBJECT_ENTRY * ObjectEntry;

    if ( ObjUuid->IsNullUuid() != 0 )
        {
        return(RPC_S_INVALID_OBJECT);
        }

    RequestGlobalMutex();
    ObjectEntry = FindObject(ObjUuid);
    if (   (ARGUMENT_PRESENT(TypeUuid) == 0)
        || (TypeUuid->IsNullUuid() != 0))
        {
        if (ObjectEntry != 0)
            {
            ObjectDictionary->Delete(ObjectEntry->DictionaryKey);
            ClearGlobalMutex();
            return(RPC_S_OK);
            }
        ClearGlobalMutex();
        return(RPC_S_OK);
        }

    if (ObjectEntry != 0)
        {
        ClearGlobalMutex();
        return(RPC_S_ALREADY_REGISTERED);
        }

    ObjectEntry = new OBJECT_ENTRY(ObjUuid,TypeUuid);
    if (ObjectEntry == 0)
        {
        ClearGlobalMutex();
        return(RPC_S_OUT_OF_MEMORY);
        }

    ObjectEntry->DictionaryKey = ObjectDictionary->Insert(ObjectEntry);
    if (ObjectEntry->DictionaryKey == -1)
        {
        ClearGlobalMutex();
        delete ObjectEntry;
        return(RPC_S_OUT_OF_MEMORY);
        }

    ClearGlobalMutex();
    return(RPC_S_OK);
}


int
InitializeObjectDictionary (
    )
/*++

Routine Description:

    At DLL initialization time, this routine will get called.

Return Value:

    Zero will be returned if initialization completes successfully;
    otherwise, non-zero will be returned.

--*/
{
    ObjectDictionary = new OBJECT_ENTRY_DICT;
    if (ObjectDictionary == 0)
        return(1);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\rpcssp.h ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    rpcssp.h

Abstract:

    This file contains the interface use by the RPC runtime to access
    a security support package.

Author:

    Michael Montague (mikemon) 15-Apr-1992

Revision History:

--*/

#ifndef __RPCSSP_H__
#define __RPCSSP_H__

#ifdef WIN32RPC
#define SECURITY_WIN32
#endif // WIN32RPC

#ifdef MAC
#define SECURITY_MAC
#endif

#ifdef DOS
#ifdef WIN
#define SECURITY_WIN16
#else // WIN
#define SECURITY_DOS
#endif // WIN
#endif // DOS

#include <security.h>

typedef struct _DCE_SECURITY_INFO
{
    unsigned long SendSequenceNumber;
    unsigned long ReceiveSequenceNumber;
    UUID AssociationUuid;
} DCE_SECURITY_INFO;

typedef struct _DCE_INIT_SECURITY_INFO
{
    DCE_SECURITY_INFO DceSecurityInfo;
    unsigned long AuthorizationService;
    unsigned char PacketType;
} DCE_INIT_SECURITY_INFO;

typedef struct _DCE_MSG_SECURITY_INFO
{
    unsigned long SendSequenceNumber;
    unsigned long ReceiveSequenceNumber;
    unsigned char PacketType;
} DCE_MSG_SECURITY_INFO;

#endif /* __RPCSSP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\rpcx86.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1991 - 1999
//
//  File:       rpcx86.h
//
//--------------------------------------------------------------------------

/*********************************************************/
/**               Microsoft LAN Manager                 **/
/**       Copyright(c) Microsoft Corp., 1991            **/
/**                                                     **/
/**     Exceptions package for C for DOS/WIN/OS2        **/
/**                                                     **/
/*********************************************************/

#ifndef __RPCx86_H__
#define __RPCx86_H__

typedef struct _ExceptionBuff {
        int registers[RPCXCWORD];
        struct _ExceptionBuff __RPC_FAR *pExceptNext;

} ExceptionBuff, __RPC_FAR *pExceptionBuff;

int  RPC_ENTRY RpcSetException(pExceptionBuff);
void RPC_ENTRY RpcLeaveException(void);

#define RpcTryExcept \
    {                           \
    int _exception_code;        \
    ExceptionBuff exception;    \
                                \
    _exception_code = RpcSetException(&exception); \
                                \
    if (!_exception_code)       \
        {

// trystmts

#define RpcExcept(expr) \
        RpcLeaveException();    \
        }                       \
    else                        \
        {                       \
        if (!(expr))            \
            RpcRaiseException(_exception_code);

// exceptstmts

#define RpcEndExcept \
        }                       \
    }

#define RpcTryFinally \
    {                           \
    int _abnormal_termination;  \
    ExceptionBuff exception;    \
                                \
    _abnormal_termination = RpcSetException(&exception); \
                                \
    if (!_abnormal_termination) \
        {

// trystmts

#define RpcFinally \
        RpcLeaveException();    \
        }

// finallystmts

#define RpcEndFinally \
    if (_abnormal_termination)  \
        RpcRaiseException(_abnormal_termination); \
    }

#define RpcExceptionCode() _exception_code
#define RpcAbnormalTermination() _abnormal_termination

#endif // __RPCx86_H__

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\sdict.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1990 - 1999
//
//  File:       sdict.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

File : sdict.cxx

Title : A simple dictionary.

Description :

History :

mikemon    ??-??-??    Beginning of time.
mikemon    10-30-90    Fixed the dictionary size.

-------------------------------------------------------------------- */

#include <precomp.hxx>

SIMPLE_DICT::SIMPLE_DICT()
{
    ALLOCATE_THIS(SIMPLE_DICT);

    cDictSize = 0;
    cDictSlots = INITIALDICTSLOTS;

    DictSlots = InitialDictSlots;
    memset(DictSlots, 0, sizeof(void *) * cDictSlots);
}

SIMPLE_DICT::~SIMPLE_DICT()
{
    if (DictSlots != InitialDictSlots)
        delete DictSlots;
}

int
SIMPLE_DICT::Insert (
    void *Item
    )
{
    int iDictSlots;
    BOOL Res;

    for (iDictSlots = 0; iDictSlots < cDictSlots; iDictSlots++)

        if (DictSlots[iDictSlots] == Nil)
            {
            DictSlots[iDictSlots] = Item;
            cDictSize += 1;
            return(iDictSlots);
            }

    // If we fell through to here, it must mean that the dictionary is
    // full; hence we need to allocate more space and copy the old
    // dictionary into it.

    Res = ExpandToSize(cDictSlots * 2);
    if (!Res)
        return (-1);

    DictSlots[iDictSlots] = Item;
    cDictSize += 1;
    return(iDictSlots);
}

void * 
SIMPLE_DICT::DeleteItemByBruteForce(
    void * Item
    )
{
   
    if (Item == 0)
       {
       return (0);
       }

    for (int i = 0; i < cDictSlots; i++)
        {
        if (DictSlots[i] == Item)
           {
           DictSlots[i] = Nil; 
           cDictSize -= 1;
           return (Item);
           }
        }

    return (0);
}

void *
SIMPLE_DICT::Delete (
    int Key
    )
{
    void *Item;

    if (Key >= cDictSlots)
        {
        return(Nil);
        }

    Item = DictSlots[Key];
    ASSERT((DictSlots[Key]));

    cDictSize -= 1;
    DictSlots[Key] = Nil;

    return(Item);
}

int
SIMPLE_DICT::ExpandToSize (
    int Size
    )
{
    void * * NewDictSlots;

    if (Size <= cDictSlots)
        return cDictSlots;  // cDictSlots is simply a quick non-zero value

    NewDictSlots = (void * *) new char[sizeof(void *) * Size];
    if (!NewDictSlots)
        return(0);

    RpcpMemoryCopy(NewDictSlots, DictSlots, sizeof(void *) * cDictSlots);
    RpcpMemorySet(NewDictSlots + cDictSlots, 0,  sizeof(void *) * (Size - cDictSlots));

    if (DictSlots != InitialDictSlots)
        delete DictSlots;
    DictSlots = NewDictSlots;

    cDictSlots = Size;

    return cDictSlots; // cDictSlots is simply a quick non-zero value
}

void
SIMPLE_DICT::DeleteAll (
    void
    )
{
    RpcpMemorySet(DictSlots, 0, cDictSlots * sizeof(void *));
}

void *
SIMPLE_DICT::Next (DictionaryCursor &cursor
    )
{
    for ( ; cursor < cDictSlots; cursor++)
        {
        if (DictSlots[cursor])
            return(DictSlots[cursor++]);
        }

    cursor = Nil;
    return(Nil);
}

void *SIMPLE_DICT::RemoveNext(DictionaryCursor &cursor)
{
    for ( ; cursor < cDictSlots; cursor++)
        {
        if (DictSlots[cursor])
            {
            void *Item = DictSlots[cursor];
            
            cDictSize -= 1;
            DictSlots[cursor] = Nil;
            cursor++;
            
            return(Item);
            }
        }

    cursor = Nil;
    return(Nil);
}

void *SIMPLE_DICT::NextWithKey (DictionaryCursor &cursor, int *Key)
{
    for ( ; cursor < cDictSlots; cursor++)
        {
        if (DictSlots[cursor])
            {
            *Key = cursor;
            return(DictSlots[cursor++]);
            }
        }

    cursor = Nil;
    return(Nil);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Revision History:

!ENDIF

TARGETNAME=rpcmtrt
TARGETTYPE=LIBRARY
TARGETPATH=obj

INCLUDES=..\;..\..\inc;$(NET_INC_PATH);$(DS_INC_PATH);$(DS_INC_PATH)\crypto;..\..\rtifs\$(O);..\..\trans;..\..\CharConv;$(INCLUDES)

#
# Setup for application developer to set breakpoints with windbg
#

MSC_WARNING_LEVEL=/W3 /WX

#NTDEBUG=ntsd
#NTDEBUGTYPE=windbg
#MSC_OPTIMIZATION=/Od

PRECOMPILED_INCLUDE=..\precomp.hxx
PRECOMPILED_CXX=1

SOURCES=$(SOURCES)      \
        ..\async.cxx    \
        ..\bcache.cxx   \
        ..\binding.cxx  \
        ..\bitset.cxx   \
        ..\bufapi.cxx   \
        ..\CellHeap.cxx \
        ..\clntapip.cxx \
        ..\dcebind.cxx  \
        ..\dcecmisc.cxx \
        ..\dcecmmn.cxx  \
        ..\dcestrng.cxx \
        ..\dcesvr.cxx   \
        ..\dcethunk.cxx \
        ..\dceuuid.cxx  \
        ..\delaytab.cxx \
        ..\dgclnt.cxx   \
        ..\dgpkt.cxx    \
        ..\dgsvr.cxx    \
        ..\dispatch.c   \
        ..\dispatch.c   \
        ..\eeinfo.cxx   \
        ..\epclnt.cxx   \
        ..\epmapper.cxx \
        ..\epmgmt.cxx   \
        ..\eventwrp.cxx \
        ..\gc.cxx       \
        ..\handle.cxx   \
        ..\hashtabl.cxx \
        ..\hndlsvr.cxx  \
        ..\init.cxx     \
        ..\LinkList.cxx \
        ..\locks.cxx    \
        ..\memory.cxx   \
        ..\miscnt.cxx   \
        ..\msgapi.cxx   \
        ..\mutex.cxx    \
        ..\osfclnt.cxx  \
        ..\osfpcket.cxx \
        ..\osfsvr.cxx   \
        ..\principal.cxx\
        ..\ProtBind.cxx \
        ..\queue.cxx    \
        ..\rpcobj.cxx   \
        ..\rpcuuid.cxx  \
        ..\sdict.cxx    \
        ..\sdict2.cxx   \
        ..\secclnt.cxx  \
        ..\sinfoapi.cxx \
        ..\sset.cxx     \
        ..\svrapip.cxx  \
        ..\svrbind.cxx  \
        ..\svrmgmt.c    \
        ..\swmr.cxx     \
        ..\threads.cxx  \
        ..\tower.cxx    \
        ..\uuidsup.cxx  \
        ..\util.cxx


RPCENV= $(RPCENV) -DWIN32RPC -DNTWIN32RPC -D_RPCRT4_

C_DEFINES=$(RPCENV) $(RPCTARGETENV) /DMSWMSG -D_RPCRT4_

# Used only for unit tests
# USE_MSVCRT=1
#        ..\linklist.cxx

UMTYPE=console
UMTEST=usvr*uclnt*dumpcert
UMLIBS=$(UMLIBS) \
    ..\..\dll\$(ALT_PROJECT_TARGET)\$(O)\rpcrt4.lib\
    $(O)\pipe.obj \
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\user32.lib   \
    $(SDK_LIB_PATH)\advapi32.lib \
    $(SDK_LIB_PATH)\ws2_32.lib \
    $(SDK_LIB_PATH)\iphlpapi.lib \
    $(SDK_LIB_PATH)\crypt32.lib \
    ..\..\CharConv\$(ALT_PROJECT_TARGET)\$(O)\CharConv.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\sdict2.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1990 - 1999
//
//  File:       sdict2.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

File : sdict2.cxx

Title : Simple dictionary.

Description :

History :

-------------------------------------------------------------------- */

#include <precomp.hxx>
#include <sdict2.hxx>

SIMPLE_DICT2::SIMPLE_DICT2 (
    )
{
    int iDictSlots;

    ALLOCATE_THIS(SIMPLE_DICT2);

    cDictSlots = INITIALDICT2SLOTS;
    DictKeys = InitialDictKeys;
    DictItems = InitialDictItems;
    for (iDictSlots = 0; iDictSlots < cDictSlots; iDictSlots++)
        {
        DictKeys [iDictSlots] = (void *) 0;
        DictItems[iDictSlots] = (void *) 0;
        }
}

SIMPLE_DICT2::~SIMPLE_DICT2 (
    )
{
    if (DictKeys != InitialDictKeys)
        {
        ASSERT(DictItems != InitialDictItems);

        delete DictKeys;
        delete DictItems;
        }
}

int
SIMPLE_DICT2::Insert (
    void * Key,
    void * Item
    )
{
    int iDictSlots;
    void * * NewDictKeys;
    void * * NewDictItems;

    for (iDictSlots = 0; iDictSlots < cDictSlots; iDictSlots++)
        {
        if (DictKeys[iDictSlots] == (void *) 0)
            {
            DictKeys[iDictSlots] = Key;
            DictItems[iDictSlots] = Item;
            return(0);
            }
        }
    // Otherwise, we need to expand the size of the dictionary.
    NewDictKeys = (void * *)
                    new unsigned char [sizeof(void *) * cDictSlots * 2];
    NewDictItems = (void * *)
                    new unsigned char [sizeof(void *) * cDictSlots * 2];
    if (NewDictKeys == (void *) 0)
        {
        if (NewDictItems)
            delete NewDictItems;
        return(-1);
        }
    if (NewDictItems == (void *) 0)
        {
        delete NewDictKeys;
        return(-1);
        }

    for (iDictSlots = 0; iDictSlots < cDictSlots; iDictSlots++)
        {
        NewDictKeys[iDictSlots] = DictKeys[iDictSlots];
        NewDictItems[iDictSlots] = DictItems[iDictSlots];
        }
    cDictSlots *= 2;
    NewDictKeys[iDictSlots] = Key;
    NewDictItems[iDictSlots] = Item;
    for (iDictSlots++; iDictSlots < cDictSlots; iDictSlots++)
        {
        NewDictKeys[iDictSlots] = (void *) 0;
        NewDictItems[iDictSlots] = (void *) 0;
        }
    if (DictKeys != InitialDictKeys)
        {
        ASSERT(DictItems != InitialDictItems);

        delete DictKeys;
        delete DictItems;
        }

    DictKeys = NewDictKeys;
    DictItems = NewDictItems;

    return(0);
}

void *
SIMPLE_DICT2::Delete (
    void * Key
    )
{
    int iDictSlots;

    for (iDictSlots = 0; iDictSlots < cDictSlots; iDictSlots++)
        {
        if (DictKeys[iDictSlots] == Key)
            {
            void * Item = DictItems[iDictSlots];

            DictKeys [iDictSlots] = (void *) 0;
            DictItems[iDictSlots] = (void *) 0;

            return Item;
            }
        }
    return((void *) 0);
}

void *
SIMPLE_DICT2::Find (
    void * Key
    )
{
    int iDictSlots;

    for (iDictSlots = 0; iDictSlots < cDictSlots; iDictSlots++)
        {
        if (DictKeys[iDictSlots] == Key)
            {
            return(DictItems[iDictSlots]);
            }
        }
    return((void *) 0);
}

void
SIMPLE_DICT2::Update (
    void * Key,
    void *Item
    )
{
    int iDictSlots;

    for (iDictSlots = 0; iDictSlots < cDictSlots; iDictSlots++)
        {
        if (DictKeys[iDictSlots] == Key)
            {
            DictItems[iDictSlots] = Item ;
            return;
            }
        }

    ASSERT(0) ;
}

void *SIMPLE_DICT2::Next (DictionaryCursor &cursor, BOOL fRemove)
{
    for ( ; cursor < cDictSlots; cursor++)
        {
        if (DictKeys[cursor])
            {
            if (fRemove)
                {
                DictKeys[cursor] = 0;
                }

            return(DictItems[cursor++]);
            }
        }

    cursor = Nil;
    return(Nil);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\rpcuuid.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    rpcuuid.cxx

Abstract:

    The implementations of the methods used to manipulate RPC_UUID
    instances (which contain UUIDs) live in this file.

Author:

    Michael Montague (mikemon) 15-Nov-1991

Revision History:

    Danny Glasser (dannygl) 03-Mar-1992
        Created worker functions for IsNullUuid, CopyUuid, and
        ConvertToString.  This is necessary for medium-model
        (i.e. Win16) support, because the Glock C++ translator
        doesn't support far "this" pointers.

    Danny Glasser (dannygl) 07-Mar-1992
        Same as above for ConvertFromString.

    Michael Montague (mikemon) 30-Nov-1992
        Removed the I_ routines.

--*/

#include <precomp.hxx>
#include <osfpcket.hxx>


static RPC_CHAR PAPI *
HexStringToULong (
    IN RPC_CHAR PAPI * String,
    OUT unsigned long PAPI * Number
    )
/*++

Routine Description:

    This routine converts the hex representation of a number into an
    unsigned long.  The hex representation is assumed to be a full
    eight characters long.

Arguments:

    String - Supplies the hex representation of the number.

    Number - Returns the number converted from hex representation.

Return Value:

    A pointer to the end of the hex representation is returned if the
    hex representation was successfully converted to an unsigned long.
    Otherwise, zero is returned, indicating that an error occured.

--*/
{
    unsigned long Result;
    int Count;

    Result = 0;
    for (Count = 0; Count < 8; Count++, String++)
        {
        if (   (*String >= RPC_CONST_CHAR('0'))
            && (*String <= RPC_CONST_CHAR('9')))
            Result = (Result << 4) + *String - RPC_CONST_CHAR('0');
        else if (   (*String >= RPC_CONST_CHAR('A'))
                 && (*String <= RPC_CONST_CHAR('F')))
            Result = (Result << 4) + *String - RPC_CONST_CHAR('A') + 10;
        else if (   (*String >= RPC_CONST_CHAR('a'))
                 && (*String <= RPC_CONST_CHAR('f')))
            Result = (Result << 4) + *String - RPC_CONST_CHAR('a') + 10;
        else
            return(0);
        }
    *Number = Result;
    return(String);
}


static RPC_CHAR PAPI *
HexStringToUShort (
    IN RPC_CHAR PAPI * String,
    OUT unsigned short PAPI * Number
    )
/*++

Routine Description:

    This routine converts the hex representation of a number into an
    unsigned short.  The hex representation is assumed to be a full
    four characters long.

Arguments:

    String - Supplies the hex representation of the number.

    Number - Returns the number converted from hex representation.

Return Value:

    A pointer to the end of the hex representation is returned if the
    hex representation was successfully converted to an unsigned short.
    Otherwise, zero is returned, indicating that an error occured.

--*/
{
    unsigned short Result;
    int Count;

    Result = 0;
    for (Count = 0; Count < 4; Count++, String++)
        {
        if (   (*String >= RPC_CONST_CHAR('0'))
            && (*String <= RPC_CONST_CHAR('9')))
            Result = (Result << 4) + *String - RPC_CONST_CHAR('0');
        else if (   (*String >= RPC_CONST_CHAR('A'))
                 && (*String <= RPC_CONST_CHAR('F')))
            Result = (Result << 4) + *String - RPC_CONST_CHAR('A') + 10;
        else if (   (*String >= RPC_CONST_CHAR('a'))
                 && (*String <= RPC_CONST_CHAR('f')))
            Result = (Result << 4) + *String - RPC_CONST_CHAR('a') + 10;
        else
            return(0);
        }
    *Number = Result;
    return(String);
}


static RPC_CHAR PAPI *
HexStringToUChar (
    IN RPC_CHAR PAPI * String,
    OUT unsigned char PAPI * Number
    )
/*++

Routine Description:

    This routine converts the hex representation of a number into an
    unsigned char.  The hex representation is assumed to be a full
    two characters long.

Arguments:

    String - Supplies the hex representation of the number.

    Number - Returns the number converted from hex representation.

Return Value:

    A pointer to the end of the hex representation is returned if the
    hex representation was successfully converted to an unsigned char.
    Otherwise, zero is returned, indicating that an error occured.

--*/
{
    RPC_CHAR Result;
    int Count;

    Result = 0;
    for (Count = 0; Count < 2; Count++, String++)
        {
        if (   (*String >= RPC_CONST_CHAR('0'))
            && (*String <= RPC_CONST_CHAR('9')))
            Result = (Result << 4) + *String - RPC_CONST_CHAR('0');
        else if (   (*String >= RPC_CONST_CHAR('A'))
                 && (*String <= RPC_CONST_CHAR('F')))
            Result = (Result << 4) + *String - RPC_CONST_CHAR('A') + 10;
        else if (   (*String >= RPC_CONST_CHAR('a'))
                 && (*String <= RPC_CONST_CHAR('f')))
            Result = (Result << 4) + *String - RPC_CONST_CHAR('a') + 10;
        else
            return(0);
        }
    *Number = (unsigned char)Result;
    return(String);
}


int
RPC_UUID::ConvertFromString (
    IN RPC_CHAR PAPI * String
    )
/*++

Routine Description:

    We convert the string representation of uuid into an actual uuid
    in this method.  The convert uuid is placed into this.

Arguments:

    String - Supplies the string representation of the uuid.

Return Value:

    0 - The operation completed successfully.

    1 - String does not supply a valid uuid.

--*/
{
    String = HexStringToULong(String,&Data1);
    if (String == 0)
        return(1);
    if (*String++ != RPC_CONST_CHAR('-'))
        return(1);
    String = HexStringToUShort(String,&Data2);
    if (String == 0)
        return(1);
    if (*String++ != RPC_CONST_CHAR('-'))
        return(1);
    String = HexStringToUShort(String,&Data3);
    if (String == 0)
        return(1);
    if (*String++ != RPC_CONST_CHAR('-'))
        return(1);
    String = HexStringToUChar(String,&Data4[0]);
    if (String == 0)
        return(1);
    String = HexStringToUChar(String,&Data4[1]);
    if (String == 0)
        return(1);
    if (*String++ != RPC_CONST_CHAR('-'))
        return(1);
    String = HexStringToUChar(String,&Data4[2]);
    if (String == 0)
        return(1);
    String = HexStringToUChar(String,&Data4[3]);
    if (String == 0)
        return(1);
    String = HexStringToUChar(String,&Data4[4]);
    if (String == 0)
        return(1);
    String = HexStringToUChar(String,&Data4[5]);
    if (String == 0)
        return(1);
    String = HexStringToUChar(String,&Data4[6]);
    if (String == 0)
        return(1);
    String = HexStringToUChar(String,&Data4[7]);
    if (String == 0)
        return(1);

    if ( *String != 0 )
        {
        return(1);
        }

    return(0);
}


void
RPC_UUID::SetToNullUuid (
    )
/*++

Routine Description:

    This is set to the null UUID value.

--*/
{
    RpcpMemorySet( (UUID __RPC_FAR *) this, 0, sizeof(UUID));
}


static RPC_CHAR HexDigits[] =
{
    RPC_CONST_CHAR('0'),
    RPC_CONST_CHAR('1'),
    RPC_CONST_CHAR('2'),
    RPC_CONST_CHAR('3'),
    RPC_CONST_CHAR('4'),
    RPC_CONST_CHAR('5'),
    RPC_CONST_CHAR('6'),
    RPC_CONST_CHAR('7'),
    RPC_CONST_CHAR('8'),
    RPC_CONST_CHAR('9'),
    RPC_CONST_CHAR('a'),
    RPC_CONST_CHAR('b'),
    RPC_CONST_CHAR('c'),
    RPC_CONST_CHAR('d'),
    RPC_CONST_CHAR('e'),
    RPC_CONST_CHAR('f')
};


RPC_CHAR PAPI *
ULongToHexString (
    IN RPC_CHAR PAPI * String,
    IN unsigned long Number
    )
/*++

Routine Description:

    We convert an unsigned long into hex representation in the specified
    string.  The result is always eight characters long; zero padding is
    done if necessary.

Arguments:

    String - Supplies a buffer to put the hex representation into.

    Number - Supplies the unsigned long to convert to hex.

Return Value:

    A pointer to the end of the hex string is returned.

--*/
{
    *String++ = HexDigits[(Number >> 28) & 0x0F];
    *String++ = HexDigits[(Number >> 24) & 0x0F];
    *String++ = HexDigits[(Number >> 20) & 0x0F];
    *String++ = HexDigits[(Number >> 16) & 0x0F];
    *String++ = HexDigits[(Number >> 12) & 0x0F];
    *String++ = HexDigits[(Number >> 8) & 0x0F];
    *String++ = HexDigits[(Number >> 4) & 0x0F];
    *String++ = HexDigits[Number & 0x0F];
    return(String);
}


static RPC_CHAR PAPI *
UShortToHexString (
    IN RPC_CHAR PAPI * String,
    IN unsigned short Number
    )
/*++

Routine Description:

    We convert an unsigned short into hex representation in the specified
    string.  The result is always four characters long; zero padding is
    done if necessary.

Arguments:

    String - Supplies a buffer to put the hex representation into.

    Number - Supplies the unsigned short to convert to hex.

Return Value:

    A pointer to the end of the hex string is returned.

--*/
{
    *String++ = HexDigits[(Number >> 12) & 0x0F];
    *String++ = HexDigits[(Number >> 8) & 0x0F];
    *String++ = HexDigits[(Number >> 4) & 0x0F];
    *String++ = HexDigits[Number & 0x0F];
    return(String);
}


static RPC_CHAR PAPI *
UCharToHexString (
    IN RPC_CHAR PAPI * String,
    IN RPC_CHAR Number
    )
/*++

Routine Description:

    We convert an unsigned char into hex representation in the specified
    string.  The result is always two characters long; zero padding is
    done if necessary.

Arguments:

    String - Supplies a buffer to put the hex representation into.

    Number - Supplies the unsigned char to convert to hex.

Return Value:

    A pointer to the end of the hex string is returned.

--*/
{
    *String++ = HexDigits[(Number >> 4) & 0x0F];
    *String++ = HexDigits[Number & 0x0F];
    return(String);
}


RPC_CHAR PAPI *
RPC_UUID::ConvertToString (
    OUT RPC_CHAR PAPI * String
    )
/*++

Routine Description:

    The string representation of this uuid is written into the string
    argument.  The printf statement used to print a uuid follows.

    printf("%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X",
            Uuid.Data1, Uuid.Data2, Uuid.Data3, Uuid.Data4[0],
            Uuid.Data4[1], Uuid.Data4[2], Uuid.Data4[3], Uuid.Data4[4],
            Uuid.Data4[5], Uuid.Data4[6], Uuid.Data4[7]);

Arguments:

    String - Returns the string representation of the uuid.

Return Value:

    A pointer to the end of the string representation of the uuid is
    returned.

--*/
{
    String = ULongToHexString(String, Data1);
    *String++ = RPC_CONST_CHAR('-');
    String = UShortToHexString(String,Data2);
    *String++ = RPC_CONST_CHAR('-');
    String = UShortToHexString(String,Data3);
    *String++ = RPC_CONST_CHAR('-');
    String = UCharToHexString(String, Data4[0]);
    String = UCharToHexString(String, Data4[1]);
    *String++ = RPC_CONST_CHAR('-');
    String = UCharToHexString(String, Data4[2]);
    String = UCharToHexString(String, Data4[3]);
    String = UCharToHexString(String, Data4[4]);
    String = UCharToHexString(String, Data4[5]);
    String = UCharToHexString(String, Data4[6]);
    String = UCharToHexString(String, Data4[7]);
    return(String);
}


int
RPC_UUID::IsNullUuid (
    )
/*++

Routine Description:

    This predicate tests whether this is the null uuid or not.

Return Value:

    FALSE - This is not the null uuid.

    TRUE - This is the null uuid.

--*/
{
    unsigned long PAPI * Vector;

    Vector = (unsigned long PAPI *) (UUID PAPI *) this;
    if (   (Vector[0] == 0)
        && (Vector[1] == 0)
        && (Vector[2] == 0)
        && (Vector[3] == 0))
        return(TRUE);
    return(FALSE);
}


unsigned short
RPC_UUID::HashUuid (
    )
/*++

Routine Description:

    This routine computes a unsigned short hash value for the Uuid.

Return Value:

    A hash value.

--*/
{
    unsigned short __RPC_FAR *Values;

    Values = (unsigned short __RPC_FAR *) (UUID *) this;

    return(  Values[0] ^ Values[1] ^ Values[2] ^ Values[3]
           ^ Values[4] ^ Values[5] ^ Values[6] ^ Values[7] );
}

void ByteSwapUuid(
    RPC_UUID PAPI *pUuid
    )
{
    pUuid->Data1 = RpcpByteSwapLong(pUuid->Data1);
    pUuid->Data2 = RpcpByteSwapShort(pUuid->Data2);
    pUuid->Data3 = RpcpByteSwapShort(pUuid->Data3);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\sinfoapi.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1990 - 1999
//
//  File:       sinfoapi.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

                      Microsoft OS/2 LAN Manager
                   Copyright(c) Microsoft Corp., 1990

-------------------------------------------------------------------- */
/* --------------------------------------------------------------------

File : sinfoapi.cxx

-------------------------------------------------------------------- */

#include <precomp.hxx>
#include <hndlsvr.hxx>
#include <thrdctx.hxx>

/* --------------------------------------------------------------------
A server thread calls this API to obtain the current call handle it should
be using.
-------------------------------------------------------------------- */
RPC_BINDING_HANDLE RPC_ENTRY
I_RpcGetCurrentCallHandle (
    )
{
#ifdef RPC_DELAYED_INITIALIZATION

    if ( RpcHasBeenInitialized == 0 )
        {
        RPC_STATUS RpcStatus;

        RpcStatus = PerformRpcInitialization();
        if ( RpcStatus != RPC_S_OK )
            return((RPC_BINDING_HANDLE) 0);
        }

#endif // RPC_DELAYED_INITIALIZATION

    return(RpcpGetThreadContext());
}

/* --------------------------------------------------------------------
-------------------------------------------------------------------- */

RPC_STATUS RPC_ENTRY
I_RpcServerInqTransportType(
    OUT unsigned int __RPC_FAR * Type
    )
/*++

Routine Description:

    Determines what kind of transport on the current thread

Arguments:

    Type - Points to the type of binding if the functions succeeds.
           One of:
           TRANSPORT_TYPE_CN
           TRANSPORT_TYPE_DG
           TRANSPORT_TYPE_LPC
           TRANSPORT_TYPE_WMSG

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_INVALID_BINDING - When the argument is not a binding handle.

--*/
{
    SCALL *SCall ;

    AssertRpcInitialized();

    ASSERT(!RpcpCheckHeap());

    SCall = (SCALL *) RpcpGetThreadContext() ;
    if (!SCall)
        {
        return (RPC_S_NO_CALL_ACTIVE) ;
        }

    return (SCall->InqTransportType(Type)) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\startsvc.h ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    startsvc.h

Abstract:

    This file contains the interface for insuring that the rpcss service
    has been started.

Author:

    Michael Montague (mikemon) (02-Oct-1992)

Revision History:

--*/

#ifndef __STARTSVC_H__
#define __STARTSVC_H__

#ifdef __cplusplus
extern "C" {
#endif
RPC_STATUS RPC_ENTRY
StartServiceIfNecessary (
    void
    );
#ifdef __cplusplus
}
#endif

#endif // __STARTSVC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\sset.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1990 - 1999
//
//  File:       sset.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

File : sset.cxx

Title : Simple set implementation.

Description :

History :

-------------------------------------------------------------------- */

#include <precomp.hxx>
#include <sset.hxx>

#include <memory.h>

SIMPLE_SET::SIMPLE_SET (
    )
{
    cSetSlots = INITIALSETSLOTS;
    iNextItem = 0;

    SetSlots = InitialSetSlots;
    memset(SetSlots, 0, sizeof(void *) * cSetSlots);
}

SIMPLE_SET::~SIMPLE_SET (
    )
{
    delete SetSlots;
}

int
SIMPLE_SET::Insert (
    void * Item
    )
{
    int iSetSlots;
    void * * NewSetSlots;

    for (iSetSlots = 0; iSetSlots < cSetSlots; iSetSlots++)
        {
	    if (SetSlots[iSetSlots] == 0)
                {
                SetSlots[iSetSlots] = Item;
                return(0);
                }
        }

    NewSetSlots = (void * *) new
            unsigned char[sizeof(void *) * cSetSlots * 2];
    if (NewSetSlots == 0)
        return(-1);

    memset(NewSetSlots, 0, sizeof(void *) * cSetSlots * 2);
    memcpy((void *)NewSetSlots, (void *)SetSlots, sizeof(void *) * cSetSlots);
    NewSetSlots[cSetSlots] = Item;

    if (SetSlots != InitialSetSlots)
        delete SetSlots;

    SetSlots = NewSetSlots;
    return(0);
}

int
SIMPLE_SET::Delete (
    void * Item
    )
{
    int iSetSlots;

    for (iSetSlots = 0; iSetSlots < cSetSlots; iSetSlots++)
        {
        if (SetSlots[iSetSlots] == Item)
            {
	    SetSlots[iSetSlots] = 0;
            return(0);
            }
        }
    return(-1);
}

int
SIMPLE_SET::MemberP (
    void * Item
    )
{
    int iSetSlots;

    for (iSetSlots = 0; iSetSlots < cSetSlots; iSetSlots++)
        {
        if (SetSlots[iSetSlots] == Item)
            {
            return(1);
            }
        }
    return(0);
}

void *
SIMPLE_SET::Next (
    )
{
    for ( ; iNextItem < cSetSlots; iNextItem++)
        {
	    if (SetSlots[iNextItem])
                {
	        iNextItem++;
                return(SetSlots[iNextItem-1]);
                }
        }
    iNextItem = 0;
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\secclnt.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    secclnt.cxx

Abstract:

    Implementation of security objects.

Author:

    Michael Montague (mikemon) 11-Apr-1992

Revision History:

    21-Feb-1997     jroberts    Added some SSL support.

--*/


#include <precomp.hxx>
#include <wincrypt.h>
#include <rpcssl.h>
#include <cryptimp.hxx>
#include <rpccfg.h>
#include <spseal.h>
#include <schnlsp.h>
#include <hndlsvr.hxx>

int SecuritySupportLoaded = 0;
int FailedToLoad = 0;

unsigned long NumberOfProviders = 0;
unsigned long LoadedProviders = 0;
unsigned long AvailableProviders = 0;
SECURITY_PROVIDER_INFO PAPI * ProviderList = 0;
MUTEX * SecurityCritSect;   // Mutex for the Server credentials cache.

// Incremented each time we leak SECURITY_CONTEXT::SecurityContext
// due to RpcSecurityInterface->DeleteSecurityContext
// returning SEC_E_INSUFFICIENT_MEMORY.
unsigned int nSecurityContextsLeaked = 0;

struct PACKAGE_LEG_INFO
{
    DWORD               Package;
    PACKAGE_LEG_COUNT   Legs;
};

const PACKAGE_LEG_INFO PredefinedPackageLegInfo[] =
{
    { RPC_C_AUTHN_WINNT,        ThreeLegs },
    { RPC_C_AUTHN_GSS_NEGOTIATE,EvenNumberOfLegs },
    { RPC_C_AUTHN_GSS_KERBEROS, EvenNumberOfLegs },
    { RPC_C_AUTHN_GSS_SCHANNEL, EvenNumberOfLegs },
    { RPC_C_AUTHN_DPA,          ThreeLegs },
    { RPC_C_AUTHN_DCE_PRIVATE,  ThreeLegs },
    { 0x44,                     ThreeLegs },        // RPC_C_AUTHN_NETLOGON from net\svcdlls\logonsrv\nlbind.h
    { 0,                        LegsUnknown }
};

// defined in principal.cxx
//
extern
DWORD
RpcCertMatchPrincipalName(
                   PCCERT_CONTEXT Context,
                   RPC_CHAR PrincipalName[]
                   );

#ifdef UNICODE
#define SEC_TCHAR   SEC_WCHAR
#else
#define SEC_TCHAR   SEC_CHAR
#endif


RPC_STATUS
FindSecurityPackage (
    IN unsigned long AuthenticationService,
    IN unsigned long AuthenticationLevel,
    OUT unsigned int __RPC_FAR * ProviderIndex,
    OUT unsigned int __RPC_FAR * PackageIndex
    );



RPC_STATUS
InsureSecuritySupportLoaded (
    )
/*++

Routine Description:

    This routine insures that the security support is loaded; if it is not
    loaded, then we go ahead and load it.

Return Value:

    A zero result indicates that security support has successfully been
    loaded, and is ready to go.

--*/
{
    RPC_STATUS Status = RPC_S_OK;

    if ( SecuritySupportLoaded != 0 )
        {
        return(0);
        }

    RequestGlobalMutex();
    if ( SecuritySupportLoaded != 0 )
        {
        ClearGlobalMutex();
        return(0);
        }

    SecurityCritSect = new MUTEX(&Status,
                                 TRUE  // pre-allocate semaphore
                                 );

    if (SecurityCritSect == 0)
        {
        Status = RPC_S_OUT_OF_MEMORY;
        }

    if (Status == RPC_S_OK)
        {
        SecuritySupportLoaded = 1;
        }

     ClearGlobalMutex();
     return (Status);
}



RPC_STATUS
IsAuthenticationServiceSupported (
    IN unsigned long AuthenticationService
    )
/*++

Routine Description:

    This routine is used to determine whether or not an authentication
    service is supported by the current configuration.

Arguments:

    AuthenticationService - Supplies a proposed authentication service.

Return Value:

    RPC_S_OK - The supplied authentication service is supported by the
        current configuration.

    RPC_S_UNKNOWN_AUTHN_SERVICE - The supplied authentication service
        is unknown, and not supported by the current configuration.

--*/
{
    unsigned int PackageIndex, ProviderIndex;

    // First make sure that the security support has been loaded.

    if ( InsureSecuritySupportLoaded() != RPC_S_OK )
        {
        return(RPC_S_OUT_OF_MEMORY);
        }


     return ( FindSecurityPackage(
                       AuthenticationService,
                       RPC_C_AUTHN_LEVEL_CONNECT,
                       &ProviderIndex,
                       &PackageIndex
                       ) );

}


RPC_STATUS
FindSecurityPackage (
    IN unsigned long AuthenticationService,
    IN unsigned long AuthenticationLevel,
    OUT unsigned int __RPC_FAR * ProviderIndex,
    OUT unsigned int __RPC_FAR * PackageIndex
    )
/*++

Routine Description:

    The methods used to acquire credentials for the client and the server use
    this routine to find a security package, given the an authentication
    service.

Arguments:

    AuthenticationService - Supplies the authentication service to be used
        (for the credentials and for the context).

    AuthenticationLevel - Supplies the authentication level to be used by
        these credentials.  It will already have been mapped by the protocol
        module into the final level.

    RpcStatus - Returns the status of the operation.  It will be one of the
        following values.

        RPC_S_OK - The return value from this routine is the index of
            the appropriate security package.

        RPC_S_UNKNOWN_AUTHN_SERVICE - The specified authentication service is
            not supported by the current configuration.

        RPC_S_UNKNOWN_AUTHN_LEVEL - The specified authentication level is not
            supported by the requested authentication service.

Return Value:

    If RpcStatus contains RPC_S_OK, then the index of the appropriate
    security package will be returned.

--*/
{
    unsigned int Index, i;
    INIT_SECURITY_INTERFACE InitSecurityInterface;
    PSecurityFunctionTable SecurityInterface = 0;
    SecPkgInfo PAPI * tmpPkgList;
    SECURITY_PACKAGE_INFO * SecurityPackages;
    SECURITY_PROVIDER_INFO PAPI * List;
    unsigned long NumberOfPackages, Total;
    RPC_CHAR * DllName = NULL;
    DLL * ProviderDll;
    RPC_STATUS Status = RPC_S_UNKNOWN_AUTHN_SERVICE;

    // First make sure that the security support has been loaded.

    if ( InsureSecuritySupportLoaded() != RPC_S_OK )
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    // 0xFFFF ia a "not-an-RPC-ID", indicating that the protocol
    // is not for use by RPC.
    if (AuthenticationService == 0xFFFF)
        {
        return(RPC_S_UNKNOWN_AUTHN_SERVICE);
        }

    SecurityCritSect->Request();

    List = ProviderList;
    for (i = 0; i < LoadedProviders; i ++)
        {

        SecurityPackages = List->SecurityPackages;
        NumberOfPackages = List->Count;

        for (Index = 0;Index < (unsigned int) NumberOfPackages;Index++)
            {
            if ( SecurityPackages[Index].PackageInfo.wRPCID == AuthenticationService )
               {
               if ( (AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
                   || ( AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT) )
                  {
                  if ( (SecurityPackages[Index].PackageInfo.fCapabilities
                            & SECPKG_FLAG_INTEGRITY) == 0 )
                     {
                     Status = RPC_S_UNKNOWN_AUTHN_LEVEL;
                     goto Cleanup;
                     }
                  }
               if ( AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT_PRIVACY )
                  {
                  if ( (SecurityPackages[Index].PackageInfo.fCapabilities
                            & SECPKG_FLAG_PRIVACY) == 0 )
                     {
                     Status =  RPC_S_UNKNOWN_AUTHN_LEVEL;
                     goto Cleanup;
                     }
                  }
              Status = RPC_S_OK;
              *ProviderIndex = i;
              *PackageIndex = Index;
              break;
              }
           } //For over all packages in one provider(dll)

        if (Status == RPC_S_OK)
           {
           SecurityCritSect->Clear();
           return(Status);
           }
        List++;
        } //For over all providers(dll)

    if ((LoadedProviders == AvailableProviders) && (LoadedProviders != 0))
       {
       goto Cleanup;
       }

    Status = RpcGetSecurityProviderInfo (
                  AuthenticationService, &DllName, &Total);

    ASSERT(!RpcpCheckHeap());

    if (Status != RPC_S_OK)
       {
       goto Cleanup;
       }

    if (ProviderList == 0)
        {
        ProviderList = (SECURITY_PROVIDER_INFO PAPI *)
                        new char [sizeof(SECURITY_PROVIDER_INFO) * Total];
        if (ProviderList == 0)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            goto Cleanup;
            }
        AvailableProviders = Total;
        }
    else
        {
        List = ProviderList;
        for (i = 0; i < LoadedProviders; i ++)
            {
            if (RpcpStringCompare(DllName, List->ProviderDllName) == 0)
                {
                delete DllName;
                Status = RPC_S_UNKNOWN_AUTHN_SERVICE;
                goto Cleanup;
                }
            List++;
            }
        }

    ProviderDll = new DLL(DllName, &Status);

    if ((ProviderDll == NULL) && (Status == RPC_S_INVALID_ARG))
        {
        Status = RPC_S_UNKNOWN_AUTHN_SERVICE;
        }

    if (Status != RPC_S_OK)
        {
        goto Cleanup;
        }

    ASSERT(!RpcpCheckHeap());

    InitSecurityInterface = (INIT_SECURITY_INTERFACE_W)
            ProviderDll->GetEntryPoint(SECURITY_ENTRYPOINT_ANSIW);

    if ( InitSecurityInterface == 0 )
        {
        delete ProviderDll;
        Status = RPC_S_UNKNOWN_AUTHN_SERVICE;
        goto Cleanup;
        }

    SecurityInterface = (*InitSecurityInterface)();
    if (   (SecurityInterface == 0)
        || (SecurityInterface->dwVersion
                    < SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION) )
        {
        delete ProviderDll;
        Status = RPC_S_UNKNOWN_AUTHN_SERVICE;
        goto Cleanup;
        }

    Status = (*SecurityInterface->EnumerateSecurityPackages)(
                          &NumberOfPackages, &tmpPkgList);

    if ( Status != SEC_E_OK)
        {
        delete ProviderDll;

        if (Status == SEC_E_INSUFFICIENT_MEMORY)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            }
        else
            {
            VALIDATE(Status) {
                SEC_E_SECPKG_NOT_FOUND
                } END_VALIDATE;
            Status = RPC_S_UNKNOWN_AUTHN_SERVICE;
            }

        goto Cleanup;
        }

   ProviderList[LoadedProviders].Count = NumberOfPackages;
   ProviderList[LoadedProviders].RpcSecurityInterface = SecurityInterface;
   ProviderList[LoadedProviders].ProviderDll = ProviderDll;
   ProviderList[LoadedProviders].ProviderDllName = DllName;
   *ProviderIndex = LoadedProviders;

   //
   // Fill in the SecurityPackages member for this Provider.
   //
   ProviderList[LoadedProviders].SecurityPackages =
        (SECURITY_PACKAGE_INFO *) new char
        [sizeof(SECURITY_PACKAGE_INFO) * NumberOfPackages];
   if (ProviderList[LoadedProviders].SecurityPackages == NULL)
       {
       Status = RPC_S_OUT_OF_MEMORY;
       goto Cleanup;
       }

   //
   // Save the SecPkgInfo array to the SecurityPackages structure.
   //
   for (i = 0; i < NumberOfPackages; i++)
       {
       ProviderList[LoadedProviders].
       SecurityPackages[i].
       PackageInfo = tmpPkgList[i];

       ProviderList[LoadedProviders].
       SecurityPackages[i].
       ServerSecurityCredentials = NULL;
       }


   SecurityPackages = ProviderList[LoadedProviders].SecurityPackages;
   Status = RPC_S_UNKNOWN_AUTHN_SERVICE;
   for (i = 0; i < NumberOfPackages; i++)
       {
       if ( SecurityPackages[i].PackageInfo.wRPCID == AuthenticationService )
          {
          if ( ( AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT_INTEGRITY )
             ||( AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT) )
              {
              if ( (SecurityPackages[i].PackageInfo.fCapabilities
                    & SECPKG_FLAG_INTEGRITY) == 0 )
                  {
                  Status = RPC_S_UNKNOWN_AUTHN_LEVEL;
                  continue;
                  }
              }
          if ( AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT_PRIVACY )
              {
              if ( (SecurityPackages[i].PackageInfo.fCapabilities
                            & SECPKG_FLAG_PRIVACY) == 0 )
                  {
                  Status = RPC_S_UNKNOWN_AUTHN_LEVEL;
                  continue;
                  }
              }
          *PackageIndex = i;
          Status = RPC_S_OK;
          break;
          }
       }
   LoadedProviders++;

Cleanup:
   SecurityCritSect->Clear();
   return(Status);
}




RPC_STATUS
FindServerCredentials (
    IN RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn,
    IN void __RPC_FAR * Arg,
    IN unsigned long AuthenticationService,
    IN unsigned long AuthenticationLevel,
    IN RPC_CHAR __RPC_FAR * Principal,
    IN OUT SECURITY_CREDENTIALS ** SecurityCredentials
    )
/*++

Routine Description:

    The method is used to find cached server credentials for use by the
    server.

Arguments:

    AuthenticationService - Supplies the authentication service to be used
        (for the credentials and for the context).

    AuthenticationLevel - Supplies the authentication level to be used by
        these credentials.  It will already have been mapped by the protocol
        module into the final level.

    SecurityCredentials - TBS

    RpcStatus - Returns the status of the operation.  It will be one of the
        following values.

        RPC_S_OK - The return value from this routine is the index of
            the appropriate security package.

        RPC_S_UNKNOWN_AUTHN_SERVICE - The specified authentication service is
            not supported by the current configuration.

        RPC_S_UNKNOWN_AUTHN_LEVEL - The specified authentication level is not
            supported by the requested authentication service.

Return Value:

    If RpcStatus contains RPC_S_OK, then valid credentials are passed
    back.

--*/
{

    SECURITY_STATUS SecurityStatus;
    TimeStamp TimeStamp;
    RPC_STATUS RpcStatus, CredStatus = RPC_S_OK;
    PSecurityFunctionTable RpcSecurityInterface;
    SECURITY_PACKAGE_INFO *pPackageInfo = 0;
    SECURITY_CREDENTIALS *pSecCredentials = 0;
    CredHandle tmpCredHandle;
    unsigned int ProviderIndex;
    unsigned int PackageIndex;

    //
    // NULL out the OUT parameters.
    //
    *SecurityCredentials = NULL;

    //
    // Find the right security package
    //
    RpcStatus = FindSecurityPackage(
                    AuthenticationService,
                    AuthenticationLevel,
                    &ProviderIndex,
                    &PackageIndex
                    );
    if (RpcStatus != RPC_S_OK)
        {
        RpcpErrorAddRecord (EEInfoGCRuntime,
            RpcStatus,
            EEInfoDLFindServerCredentials10,
            AuthenticationService,
            AuthenticationLevel);

        return (RpcStatus);
        }

    //
    // Now, get the server-credentials for this security package.
    //
    pPackageInfo = &(ProviderList[ProviderIndex].
                     SecurityPackages[PackageIndex]
                     );


    // Protect the access
    SecurityCritSect->Request();

    //
    // Check to see if credentials have already been acquired for this
    // package. If yes, return them.
    //
    if (pPackageInfo->ServerSecurityCredentials)
        {
        *SecurityCredentials = pPackageInfo->ServerSecurityCredentials;
        // Add a reference for the caller.
        pPackageInfo->ServerSecurityCredentials->ReferenceCredentials();
        SecurityCritSect->Clear();
        return (RPC_S_OK);
        }

    //
    // Allocate a new set of credentials. Ref count is 1, if successful.
    //
    pSecCredentials = new SECURITY_CREDENTIALS(&CredStatus);
    if (pSecCredentials == NULL)
        {
        SecurityCritSect->Clear();
        return (RPC_S_OUT_OF_MEMORY);
        }
    if (CredStatus != RPC_S_OK)
        {
        delete pSecCredentials;
        SecurityCritSect->Clear();
        return (CredStatus);
        }

    //
    // This is the first time Credentials are being acquired for this
    // package. Acquire them now.
    //
    RpcSecurityInterface = ProviderList[ProviderIndex].RpcSecurityInterface;

    SecurityStatus = (*RpcSecurityInterface->AcquireCredentialsHandle)(
            (SEC_TCHAR __SEC_FAR *) Principal,
            pPackageInfo->PackageInfo.Name,
            SECPKG_CRED_INBOUND,
            0,
            Arg,
            (SEC_GET_KEY_FN) GetKeyFn,
            Arg,
            &(pSecCredentials->CredentialsHandle),
            &TimeStamp
            );

    if (SecurityStatus != SEC_E_OK)
        {
        SetExtendedError(SecurityStatus);
        RpcpErrorAddRecord (EEInfoGCSecurityProvider,
            SecurityStatus,
            EEInfoDLFindServerCredentials20,
            Principal,
            pPackageInfo->PackageInfo.Name);

        SecurityCritSect->Clear();
        delete pSecCredentials;

        switch (SecurityStatus)
            {
            case SEC_E_INSUFFICIENT_MEMORY:
                RpcStatus = RPC_S_OUT_OF_MEMORY;
                break;

            case SEC_E_SHUTDOWN_IN_PROGRESS:
                RpcStatus = ERROR_SHUTDOWN_IN_PROGRESS;
                break;

            case SEC_E_SECPKG_NOT_FOUND:
                RpcStatus = RPC_S_UNKNOWN_AUTHN_SERVICE;
                break;

            case SEC_E_NO_SPM:
                RpcStatus = RPC_S_SEC_PKG_ERROR;
                break;

            default:
                {
#if DBG
                if ((SecurityStatus != SEC_E_NO_CREDENTIALS) &&
                    (SecurityStatus != SEC_E_UNKNOWN_CREDENTIALS))
                    {
                    PrintToDebugger("RPC SEC: AcquireCredentialsForServer "
                                    "Returned 0x%x\n", SecurityStatus);
                    }
#endif
                RpcStatus = RPC_S_INVALID_AUTH_IDENTITY;
                }
            } // end of switch


        RpcpErrorAddRecord (EEInfoGCRuntime,
            RpcStatus,
            EEInfoDLFindServerCredentials30,
            SecurityStatus);

        return RpcStatus;
        }

    //
    // Setup the new Credentials.
    //
    pSecCredentials->Valid = TRUE;
    pSecCredentials->bServerCredentials = TRUE;
    pSecCredentials->AuthenticationService = AuthenticationService;
    pSecCredentials->ProviderIndex = ProviderIndex;
    pSecCredentials->PackageIndex = PackageIndex;

    //
    // Cache the new credentials.
    //
    pPackageInfo->ServerSecurityCredentials = pSecCredentials;

    // Add a reference for the Cache.
    pPackageInfo->ServerSecurityCredentials->ReferenceCredentials();

    *SecurityCredentials = pSecCredentials;

    SecurityCritSect->Clear();

    return (RPC_S_OK);
}




RPC_STATUS
RemoveCredentialsFromCache (
    IN unsigned long AuthenticationService
    )
/*++

Routine Description:

    An RPC server can call RpcRegisterAuthInfo() a second time on the same
    Authentication Service to update the GetKeyFunction and Arg values.
    In this case, we need to flush our credentials cache so that when
    the server tries to acquires credentials again,  the credentials can
    be acquired using the new values.

Arguments:

    AuthenticationService - Supplies the authentication service to be used
        (for the credentials and for the context).

Return Value:

    RPC_S_OK, If Cache has been successfully flushed.
    Return Value from FindSecurityPackage(), if not

--*/
{
    unsigned int ProviderIndex;
    unsigned int PackageIndex;
    SECURITY_PACKAGE_INFO *pPackageInfo = 0;
    RPC_STATUS   RpcStatus;

    //
    // First, find the right security package
    //
    RpcStatus = FindSecurityPackage(
                    AuthenticationService,
                    RPC_C_AUTHN_LEVEL_DEFAULT,  // Doesn't matter
                    &ProviderIndex,
                    &PackageIndex
                    );

    ASSERT(RpcStatus == RPC_S_OK);

    if (RpcStatus != RPC_S_OK)
        {
        return (RpcStatus);
        }

    pPackageInfo = &(ProviderList[ProviderIndex].SecurityPackages[PackageIndex]);

    //
    // Flush the credentials.
    //
    SecurityCritSect->Request();

    if (pPackageInfo->ServerSecurityCredentials)
        {
        // Remove the reference maintained by the cache.
        pPackageInfo->ServerSecurityCredentials->DereferenceCredentials(TRUE);
        pPackageInfo->ServerSecurityCredentials = NULL;
        }

    SecurityCritSect->Clear();

    return (RPC_S_OK);
}


#define INVALID_INDEX   0xFFFF


SECURITY_CREDENTIALS::SECURITY_CREDENTIALS (
    IN OUT RPC_STATUS PAPI * Status
    ) : CredentialsMutex(Status)
/*++

Routine Description:

    We need this here to keep the compiler happy.

--*/
{
    DefaultPrincName = NULL;

    ReferenceCount = 1;
    Valid = FALSE;

    bServerCredentials = FALSE;
    fDeleted = FALSE;

    // Initialize to invalid values.
    ProviderIndex = INVALID_INDEX;
    PackageIndex  = INVALID_INDEX;
}

SECURITY_CREDENTIALS::~SECURITY_CREDENTIALS (
    )
{
    PSecurityFunctionTable RpcSecurityInterface;

    if (DefaultPrincName != NULL)
        {
        RpcSecurityInterface = InquireProviderFunctionTable();

        ASSERT(RpcSecurityInterface != NULL);

        (*RpcSecurityInterface->FreeContextBuffer)(DefaultPrincName);
        }
}



void
SECURITY_CREDENTIALS::ReferenceCredentials(
    )
{

 CredentialsMutex.Request();
 ReferenceCount++;
 CredentialsMutex.Clear();

}


void
SECURITY_CREDENTIALS::DereferenceCredentials(
    BOOL fRemoveIt  OPTIONAL
    )
{
    CredentialsMutex.Request();
    ReferenceCount--;

    ASSERT(((long)ReferenceCount) >= 0);

    if (fRemoveIt)
        {
        fDeleted = TRUE;
        }

    if (ReferenceCount == 0)
        {
        //
        // Server side SCENARIOS when (ReferenceCount == 0)
        //
        // a. RemoveCredentialsFromCache() removes the extra reference
        //    held by the cache. It does so holding the cache Mutex ie.,
        //    SecurityCritSect. So, no other thread can get a reference
        //    on the credentials in the cache.
        //
        // b. DereferenceCredentials() has been called by one of the
        //    threads possessing the cached credentials AND the cache
        //    has already removed it's reference. Cache will remove it's
        //    reference only when it removes this credential from the
        //    cache. This implies no other thread could have gotten a
        //    reference on the credentials in the cache, in the meantime.
        //
        // These two imply that ReferenceCount cannot change here. Also,
        // in case (a), credentials will soon be removed from the cache.
        // In case (b), credentials have already been removed.
        //

        if (bServerCredentials)
            {
            ASSERT(fDeleted);
            }

        CredentialsMutex.Clear();
        FreeCredentials();
        delete this;
        } // if (ReferenceCount == 0)
     else
        {
        CredentialsMutex.Clear();
        }
}



RPC_STATUS
SECURITY_CREDENTIALS::AcquireCredentialsForClient (
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    IN unsigned long AuthenticationService,
    IN unsigned long AuthenticationLevel
    )
/*++

Routine Description:

    We need to use this method in order to acquire security credentials.  We
    need the security credentials so that we (as a client) can initialize
    a security context with a server.  This method, with
    SECURITY_CREDENTIALS::FreeCredentials may cache security credentials,
    but that is transparent to clients of this class.

Arguments:

    AuthIdentity - Supplies the security identity for which we wish to obtain
        credentials.  If this argument is not supplied, then we use the
        security identity of this process.

    AuthenticationService - Supplies the authentication service to be used
        (for the credentials and for the context).

    AuthenticationLevel - Supplies the authentication level to be used by
        these credentials.  It will already have been mapped by the protocol
        module into the final level.

Return Value:

    RPC_S_OK - We now have security credentials for the requested
        authentication service.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to perform the
        operation.

    RPC_S_UNKNOWN_AUTHN_SERVICE - The specified authentication service is
        not supported by the current configuration.

    RPC_S_INVALID_AUTH_IDENTITY - The specified identity is not known to
        the requested authentication service.

    RPC_S_UNKNOWN_AUTHN_LEVEL - The specified authentication level is not
        supported by the requested authentication service.

--*/
{
    SECURITY_STATUS SecurityStatus;
    TimeStamp TimeStamp;
    RPC_STATUS RpcStatus;
    PSecurityFunctionTable RpcSecurityInterface;

    unsigned Flags = SCH_CRED_USE_DEFAULT_CREDS;

    RpcStatus    = FindSecurityPackage(
                          AuthenticationService,
                          AuthenticationLevel,
                          &ProviderIndex,
                          &PackageIndex
                          );

    if ( RpcStatus != RPC_S_OK )
        {
        RpcpErrorAddRecord(EEInfoGCRuntime,
            RpcStatus,
            EEInfoDLAcquireCredentialsForClient20,
            AuthenticationService,
            AuthenticationLevel);

        return(RpcStatus);
        }

    RpcSecurityInterface = ProviderList[ProviderIndex].RpcSecurityInterface;

    if (AuthIdentity == RPC_C_NO_CREDENTIALS)
        {
        Flags = 0;
        AuthIdentity = 0;
        }

    //
    // RPC does its own name checking using msstd or fullsic names.
    // This requires the ability to disable schannel's name checking,
    // a feature available only with credentials version-4 or better.
    //
#define MINIMUM_SCHANNEL_CRED_VERSION 4

    if (AuthenticationService == RPC_C_AUTHN_GSS_SCHANNEL && 
        AuthIdentity != NULL)
        {
        SCHANNEL_CRED * cred = (SCHANNEL_CRED *) AuthIdentity;

        Flags |= SCH_CRED_NO_SERVERNAME_CHECK;

        if (cred->dwVersion < MINIMUM_SCHANNEL_CRED_VERSION)
            {
            RpcpErrorAddRecord(EEInfoGCRuntime,
                ERROR_INVALID_PARAMETER,
                EEInfoDLAcquireCredentialsForClient30,
                AuthenticationService,
                AuthenticationLevel);

            return RPC_S_INVALID_AUTH_IDENTITY;
            }

        cred->dwFlags |= Flags;
        }

    SecurityStatus = (*RpcSecurityInterface->AcquireCredentialsHandle)(
            0,
            ProviderList[ProviderIndex].SecurityPackages[PackageIndex].PackageInfo.Name,
            SECPKG_CRED_OUTBOUND,
            0,
            AuthIdentity, 0, 0, &CredentialsHandle, &TimeStamp);

    if ( SecurityStatus != SEC_E_OK )
        {
        RpcpErrorAddRecord(EEInfoGCSecurityProvider,
            SecurityStatus,
            EEInfoDLAcquireCredentialsForClient10,
            AuthenticationService,
            AuthenticationLevel);
        }

    if (SecurityStatus != SEC_E_OK)
        {
        if ( SecurityStatus == SEC_E_INSUFFICIENT_MEMORY )
            {
            RpcStatus = RPC_S_OUT_OF_MEMORY;
            }
        else if ( SecurityStatus == SEC_E_SECPKG_NOT_FOUND )
            {
            RpcStatus = RPC_S_UNKNOWN_AUTHN_SERVICE;
            }
        else if ( SecurityStatus == SEC_E_SHUTDOWN_IN_PROGRESS )
            {
            RpcStatus = ERROR_SHUTDOWN_IN_PROGRESS;
            }
        else if ( SecurityStatus == SEC_E_NO_SPM)
            {
            RpcStatus = RPC_S_SEC_PKG_ERROR;
            }
        else
            {

            VALIDATE(SecurityStatus)
                     {
                     SEC_E_NO_CREDENTIALS,
                     SEC_E_UNKNOWN_CREDENTIALS,
                     SEC_E_NO_AUTHENTICATING_AUTHORITY,
                     SEC_E_INVALID_TOKEN
                     }
            END_VALIDATE;

            RpcStatus = RPC_S_INVALID_AUTH_IDENTITY;
            }

        RpcpErrorAddRecord(EEInfoGCRuntime,
            RpcStatus,
            EEInfoDLAcquireCredentialsForClient30,
            SecurityStatus);

        return RpcStatus;
        }

    this->AuthenticationService = AuthenticationService;
    Valid = TRUE;
    return(RPC_S_OK);
}


RPC_STATUS
SECURITY_CREDENTIALS::InquireDefaultPrincName(
    OUT SEC_CHAR __SEC_FAR **MyDefaultPrincName
    )
{
    SECURITY_STATUS SecurityStatus;
    SecPkgCredentials_NamesA CredentialsNames;
    PSecurityFunctionTable RpcSecurityInterface;
    RPC_STATUS Status;

    if (DefaultPrincName == NULL)
    {
        RpcSecurityInterface = InquireProviderFunctionTable();
        if (RpcSecurityInterface == NULL) {
            return (RPC_S_OUT_OF_MEMORY);
        }
        if (RpcSecurityInterface->QueryCredentialsAttributes == NULL) {
            return (RPC_S_CANNOT_SUPPORT);
        }
        SecurityStatus = (*RpcSecurityInterface->QueryCredentialsAttributes)(
            InquireCredHandle(), SECPKG_CRED_ATTR_NAMES, &CredentialsNames);

        if (SecurityStatus != SEC_E_OK)
            {
            SetExtendedError(SecurityStatus);

            RpcpErrorAddRecord (EEInfoGCSecurityProvider,
                SecurityStatus,
                EEInfoDLInquireDefaultPrincName10,
                AuthenticationService);

            if (SecurityStatus == SEC_E_INSUFFICIENT_MEMORY)
                {
                Status = RPC_S_OUT_OF_MEMORY;
                }
            else if ( SecurityStatus == SEC_E_SHUTDOWN_IN_PROGRESS )
                {
                Status = ERROR_SHUTDOWN_IN_PROGRESS;
                }
            else
                {
                Status = RPC_S_SEC_PKG_ERROR;
                }

            RpcpErrorAddRecord (EEInfoGCRuntime,
                Status,
                EEInfoDLInquireDefaultPrincName20,
                SecurityStatus);

            return Status;
            }

        if (CredentialsNames.sUserName == NULL)
            {
            return RPC_S_OUT_OF_MEMORY;
            }

        DefaultPrincName = CredentialsNames.sUserName;
    }

    *MyDefaultPrincName = DefaultPrincName;

    return (RPC_S_OK);
}



void
SECURITY_CREDENTIALS::FreeCredentials (
    )
/*++

Routine Description:

    When we are done using the credentials, we call this routine to free
    them.

--*/
{
    if (Valid)
        {
        SECURITY_STATUS SecurityStatus;

        PSecurityFunctionTable RpcSecurityInterface
            = ProviderList[ProviderIndex].RpcSecurityInterface;

        SecurityStatus = (*RpcSecurityInterface->FreeCredentialHandle)(
                &CredentialsHandle);
        ASSERT( SecurityStatus == SEC_E_OK ||
                SecurityStatus == SEC_E_SECPKG_NOT_FOUND ||
                SecurityStatus == SEC_E_SHUTDOWN_IN_PROGRESS );
        }
}


RPC_STATUS
SECURITY_CONTEXT::SetMaximumLengths (
    )
/*++

Routine Description:

    This routine initializes the maximum header length and maximum signature
    length fields of this object.

--*/
{
    SECURITY_STATUS SecurityStatus;
    SecPkgContext_Sizes ContextSizes;
    RPC_STATUS Status;

    if (FailedContext != 0)
        {
        // We cheat if 3rd Leg Failed as we dont really have a true Context
        // Provider is going to really complain if we call QueryContextAttr()
        // .. we get around that by picking large values.
        // The rest of the code prevents these values to be really used
        // We do this because we do not want to block 3rd Leg, rather fail the
        // first request!

        MaxSignatureLength = 256;
        MaxHeaderLength    = 256;
        cbBlockSize        = 64;
        return RPC_S_OK;
        }

    ASSERT( FullyConstructed() );

    SecurityStatus = (*RpcSecurityInterface->QueryContextAttributes)(
            &SecurityContext, SECPKG_ATTR_SIZES, &ContextSizes);

    if (SecurityStatus != SEC_E_OK)
        {
#ifdef DEBUGRPC
        PrintToDebugger("RPC: secclnt.cxx: QueryContextAttributes returned: %lx\n",
                        SecurityStatus);
#endif
        Status = GetLastError();

        RpcpErrorAddRecord (EEInfoGCSecurityProvider,
            RPC_S_OUT_OF_MEMORY,
            EEInfoDLSetMaximumLengths10,
            SecurityStatus,
            Status,
            AuthenticationService,
            (ULONGLONG)&SecurityContext
            );

        return RPC_S_OUT_OF_MEMORY;
        }

    MaxSignatureLength = (unsigned int) ContextSizes.cbMaxSignature;
    MaxHeaderLength    = (unsigned int) ContextSizes.cbSecurityTrailer;
    cbBlockSize        = (unsigned int) ContextSizes.cbBlockSize;

    ASSERT(ContextSizes.cbBlockSize <= MAXIMUM_SECURITY_BLOCK_SIZE );

    return RPC_S_OK;
}


SECURITY_CONTEXT::SECURITY_CONTEXT (
    CLIENT_AUTH_INFO *myAuthInfo,
    unsigned myAuthContextId,
    BOOL fUseDatagram,
    RPC_STATUS __RPC_FAR * pStatus
    )
    : CLIENT_AUTH_INFO  (myAuthInfo, pStatus),
      AuthContextId     (myAuthContextId),
      fDatagram         ((boolean) fUseDatagram),
      fFullyConstructed (FALSE),
      Legs              (LegsUnknown),
      ContextAttributes (0)
/*++

Routine Description:

    We need to set the flag indicating that there is no security context
    to be deleted.

--*/
{
    ASSERT( AuthenticationLevel != 0 );

    DontForgetToDelete = 0;
    FailedContext = 0;
    FailedContextEEInfo = NULL;
    AuthzClientContext = NULL;
}


RPC_STATUS
SECURITY_CONTEXT::CompleteSecurityToken (
    IN OUT SECURITY_BUFFER_DESCRIPTOR PAPI * BufferDescriptor
    )
/*++

--*/
{
    SECURITY_STATUS SecurityStatus;
    RPC_STATUS Status;

    ASSERT(   ( SecuritySupportLoaded != 0 )
           && ( FailedToLoad == 0 ) );

    SecurityStatus = (*RpcSecurityInterface->CompleteAuthToken)(
            &SecurityContext, BufferDescriptor);
    if (SecurityStatus == SEC_E_OK)
        {
        return (RPC_S_OK);
        }

    SetExtendedError(SecurityStatus);

    RpcpErrorAddRecord (EEInfoGCSecurityProvider,
        SecurityStatus,
        EEInfoDLCompleteSecurityToken10,
        AuthenticationService,
        AuthenticationLevel);

    if (  (SecurityStatus == SEC_E_NO_CREDENTIALS)
        || (SecurityStatus == SEC_E_LOGON_DENIED)
        || (SecurityStatus == SEC_E_INVALID_TOKEN)
        || (SecurityStatus == SEC_E_UNKNOWN_CREDENTIALS)
        || (SecurityStatus == SEC_E_WRONG_PRINCIPAL)
        || (SecurityStatus == SEC_E_TIME_SKEW))
        {
        Status = RPC_S_ACCESS_DENIED;
        }
    else if ( SecurityStatus ==  SEC_E_INSUFFICIENT_MEMORY )
        {
        Status = RPC_S_OUT_OF_MEMORY;
        }
    else if ( SecurityStatus == SEC_E_SHUTDOWN_IN_PROGRESS )
        {
        Status = ERROR_SHUTDOWN_IN_PROGRESS;
        }
    else
        {
#if DBG
        PrintToDebugger("RPC: CompleteSecurityContext Returned %lx\n",
                         SecurityStatus);
#endif
        Status = RPC_S_SEC_PKG_ERROR;
        }

    RpcpErrorAddRecord (EEInfoGCRuntime,
        Status,
        EEInfoDLCompleteSecurityToken20,
        SecurityStatus);
    return Status;
}


RPC_STATUS
SECURITY_CONTEXT::SignOrSeal (
    IN unsigned long Sequence,
    IN unsigned int SignNotSealFlag,
    IN OUT SECURITY_BUFFER_DESCRIPTOR PAPI * BufferDescriptor
    )
/*++

Routine Description:

    A protocol module will use this routine to prepare a message to be
    sent so that it can be verified that the message has not been tampered
    with, and that it has not been exchanged out of sequence.  The sender
    will use this routine to prepare the message; the receiver will use
    SECURITY_CONTEXT::VerifyOrUnseal to verify the message.  Typically,
    the security package will generate a cryptographic checksum of the
    message and include sequencing information.

Arguments:

    SignNotSealFlag - Supplies a flag indicating that MakeSignature should
        be called rather than SealMessage.

    BufferDescriptor - Supplies the message to to signed or sealed and returns
        the resulting message (after being signed or sealed).

Return Value:

    RPC_S_OK - This routine will always succeed.

--*/
{
    SECURITY_STATUS SecurityStatus;
    SEAL_MESSAGE_FN SealMessage;

    {
    DWORD Status = 0;

    CallTestHook( TH_SECURITY_FN_SIGN, this, &Status );

    if (Status)
        {
        return Status;
        }
    }

    if ( SignNotSealFlag == 0 )
        {
        SealMessage = (SEAL_MESSAGE_FN) RpcSecurityInterface->Reserved3;
        SecurityStatus = (*SealMessage)(&SecurityContext,
                0, BufferDescriptor, Sequence);
        }
    else
        {
        SecurityStatus = (*RpcSecurityInterface->MakeSignature)(
                &SecurityContext, 0, BufferDescriptor, Sequence);
        }

#if DBG
        if ( (SecurityStatus != SEC_E_OK)
           &&(SecurityStatus != SEC_E_CONTEXT_EXPIRED)
           &&(SecurityStatus != SEC_E_QOP_NOT_SUPPORTED) )
           {
           PrintToDebugger("Sign/Seal Returned [%lx]\n", SecurityStatus);
           }
#endif

    if ( SecurityStatus == SEC_E_SHUTDOWN_IN_PROGRESS )
        {
        SecurityStatus = ERROR_SHUTDOWN_IN_PROGRESS;
        }

    if (SecurityStatus != SEC_E_OK)
        {
        RpcpErrorAddRecord (EEInfoGCSecurityProvider,
            SecurityStatus,
            EEInfoDLSignOrSeal10,
            AuthenticationService,
            AuthenticationLevel);
        }

    return(SecurityStatus);
}


RPC_STATUS
SECURITY_CONTEXT::VerifyOrUnseal (
    IN unsigned long Sequence,
    IN unsigned int VerifyNotUnsealFlag,
    IN OUT  SECURITY_BUFFER_DESCRIPTOR PAPI * BufferDescriptor
    )
/*++

Routine Description:

    This routine works with SECURITY_CONTEXT::SignOrSeal.  A sender will
    prepare a message using SignOrSeal, and then the receiver will use
    this routine to verify that the message has not been tampered with, and
    that it has not been exchanged out of sequence.

Arguments:

    VerifyNotUnsealFlag - Supplies a flag indicating that VerifySignature
        should be called rather than UnsealMessage.

    BufferDescriptor - Supplies the message to be verified or unsealed.

Return Value:

    RPC_S_OK - The message has not been tampered with, and it is from the
        expected client.

    RPC_S_ACCESS_DENIED - A security violation occured.

--*/
{
    SECURITY_STATUS SecurityStatus;
    unsigned long QualityOfProtection;
    UNSEAL_MESSAGE_FN UnsealMessage;

    {
    DWORD Status = 0;

    CallTestHook( TH_SECURITY_FN_VERIFY, this, &Status );

    if (Status)
        {
        return Status;
        }
    }

    //
    // If the context had failed previously..
    // Just go ahead and return an error..
    // This is only for connetion-oriented RPC.
    //
    if (FailedContext != 0 || !FullyConstructed() )
       {
       RpcpSetEEInfo(FailedContextEEInfo);
       FailedContextEEInfo = NULL;
       SetLastError(FailedContext);

       if ((FailedContext == ERROR_PASSWORD_MUST_CHANGE)
           || (FailedContext == ERROR_PASSWORD_EXPIRED)
           || (FailedContext == ERROR_ACCOUNT_DISABLED)
           || (FailedContext == ERROR_INVALID_LOGON_HOURS))
           {
           return FailedContext;
           }

        RpcpErrorAddRecord (EEInfoGCRuntime,
            RPC_S_ACCESS_DENIED,
            EEInfoDLVerifyOrUnseal20,
            FailedContext);

       return (RPC_S_ACCESS_DENIED);
       }

    if ( VerifyNotUnsealFlag == 0 )
        {
        UnsealMessage = (UNSEAL_MESSAGE_FN) RpcSecurityInterface->Reserved4;
        SecurityStatus = (*UnsealMessage)(
                &SecurityContext, BufferDescriptor, Sequence,
                &QualityOfProtection);
        }
    else
        {
        SecurityStatus = (*RpcSecurityInterface->VerifySignature)(
                &SecurityContext, BufferDescriptor, Sequence,
                &QualityOfProtection);
        }

    if ( SecurityStatus != SEC_E_OK )
        {

#if DBG
        if ((SecurityStatus != SEC_E_MESSAGE_ALTERED)
           &&(SecurityStatus != SEC_E_OUT_OF_SEQUENCE)
           &&(SecurityStatus != SEC_E_SECPKG_NOT_FOUND))    // on system shutdown, if the security
           {                        // package is already uninitialized, we may get this error
           PrintToDebugger("Verify/UnSeal Returned Unexp. Code [%lx]\n",
                            SecurityStatus);
           }
#endif

        SetExtendedError(SecurityStatus);

        if ( SecurityStatus == SEC_E_SHUTDOWN_IN_PROGRESS )
            {
            SecurityStatus = ERROR_SHUTDOWN_IN_PROGRESS;
            }

        RpcpErrorAddRecord (EEInfoGCSecurityProvider,
            RPC_S_ACCESS_DENIED,
            EEInfoDLVerifyOrUnseal10,
            SecurityStatus,
            AuthenticationService,
            AuthenticationLevel);

        ASSERT( (SecurityStatus == SEC_E_MESSAGE_ALTERED) ||
                (SecurityStatus == SEC_E_OUT_OF_SEQUENCE) ||
                (SecurityStatus == SEC_E_SECPKG_NOT_FOUND) );
        SetLastError(RPC_S_ACCESS_DENIED);

        return(RPC_S_ACCESS_DENIED);
        }
    return(RPC_S_OK);
}


RPC_STATUS
SECURITY_CONTEXT::InitializeFirstTime (
    IN SECURITY_CREDENTIALS * Credentials,
    IN RPC_CHAR * ServerPrincipalName,
    IN unsigned long AuthenticationLevel,
    IN OUT SECURITY_BUFFER_DESCRIPTOR PAPI * BufferDescriptor,
    IN OUT unsigned char *NewAuthType
    )
/*++

Routine Description:

Arguments:

Return Value:

    RPC_S_OK - Send the token to the server; everything worked fine so
        far.

    RPC_P_CONTINUE_NEEDED - Indicates that that everything is ok, but that
        we need to call into the security package again when we have
        received a token back from the server.

    RPC_P_COMPLETE_NEEDED - Indicates that everyting is ok, but that we
        need to call CompleteAuthToken before sending the message.

    RPC_P_COMPLETE_AND_CONTINUE - Needs both a complete and a continue.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to perform the
        operation.

    RPC_S_ACCESS_DENIED - Access is denied.

--*/
{
    SECURITY_STATUS SecurityStatus;
    TimeStamp TimeStamp;
    unsigned long ContextRequirements;
    RPC_STATUS Status;
    RPC_STATUS Status2;
    unsigned char RetrievedAuthType;
    BOOL fDone;

    ASSERT(   ( SecuritySupportLoaded != 0 )
           && ( FailedToLoad == 0 ) );

    RpcSecurityInterface = Credentials->InquireProviderFunctionTable();

    switch ( AuthenticationLevel )
        {
        case RPC_C_AUTHN_LEVEL_CONNECT :
            ContextRequirements = 0;
            break;

        case RPC_C_AUTHN_LEVEL_PKT :
            ContextRequirements = ISC_REQ_REPLAY_DETECT;
            break;

        case RPC_C_AUTHN_LEVEL_PKT_INTEGRITY :
            ContextRequirements = ISC_REQ_REPLAY_DETECT
                                | ISC_REQ_SEQUENCE_DETECT
                                | ISC_REQ_INTEGRITY;
            break;

        case RPC_C_AUTHN_LEVEL_PKT_PRIVACY :
            ContextRequirements = ISC_REQ_REPLAY_DETECT
                                | ISC_REQ_SEQUENCE_DETECT
                                | ISC_REQ_CONFIDENTIALITY
                                | ISC_REQ_INTEGRITY;
            break;

        default :
            ASSERT(   ( AuthenticationLevel == RPC_C_AUTHN_LEVEL_CONNECT )
                   || ( AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT )
                   || ( AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT_INTEGRITY )
                   || ( AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT_PRIVACY ) );
            return RPC_S_INTERNAL_ERROR;
        }


    if (fDatagram)
        {
        ContextRequirements |= ISC_REQ_DATAGRAM;
        }
    else
        {
        ContextRequirements |= ISC_REQ_CONNECTION;
        }

    switch(ImpersonationType)
        {
        case RPC_C_IMP_LEVEL_IDENTIFY:
            ContextRequirements |= ISC_REQ_IDENTIFY;
            break;

        case RPC_C_IMP_LEVEL_IMPERSONATE:
            break;

        case RPC_C_IMP_LEVEL_DELEGATE:
            ContextRequirements |= ISC_REQ_DELEGATE;
            break;

        default:
            ASSERT(   ImpersonationType == RPC_C_IMP_LEVEL_ANONYMOUS
                   || ImpersonationType == RPC_C_IMP_LEVEL_IDENTIFY
                   || ImpersonationType == RPC_C_IMP_LEVEL_IMPERSONATE
                   || ImpersonationType == RPC_C_IMP_LEVEL_DELEGATE );
            ContextRequirements |= ISC_REQ_IDENTIFY;
            break;
        }

    if (Capabilities == RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH)
        {
        ContextRequirements |= ISC_REQ_MUTUAL_AUTH;
        }

    if (Credentials->AuthenticationService == RPC_C_AUTHN_GSS_SCHANNEL)
        {
#if MANUAL_CERT_CHECK
        ContextRequirements |= ISC_REQ_MANUAL_CRED_VALIDATION;
#endif
        }
    else
        {
        ContextRequirements |= ISC_REQ_USE_DCE_STYLE;
        }

    SecurityStatus = (*RpcSecurityInterface->InitializeSecurityContext)(
            Credentials->InquireCredHandle(),
            0,
            (SEC_TCHAR __SEC_FAR *) ServerPrincipalName,
            ContextRequirements,
            0,
            0,
            (fDatagram ? BufferDescriptor : 0),
            0,
            &SecurityContext,
            (fDatagram ? 0 : BufferDescriptor),
            &ContextAttributes,
            &TimeStamp
            );

    if (   ( SecurityStatus != SEC_E_OK )
        && ( SecurityStatus != SEC_I_CONTINUE_NEEDED )
        && ( SecurityStatus != SEC_I_COMPLETE_NEEDED )
        && ( SecurityStatus != SEC_I_COMPLETE_AND_CONTINUE ) )
        {
        SetExtendedError(SecurityStatus);

        RpcpErrorAddRecord (EEInfoGCSecurityProvider,
            SecurityStatus,
            EEInfoDLInitializeFirstTime10,
            AuthenticationService,
            AuthenticationLevel,
            ServerPrincipalName,
            ContextRequirements);

        if ((SecurityStatus == SEC_E_NO_CREDENTIALS)
           || (SecurityStatus == SEC_E_LOGON_DENIED)
           || (SecurityStatus == SEC_E_INVALID_TOKEN)
           || (SecurityStatus == SEC_E_UNKNOWN_CREDENTIALS)
           || (SecurityStatus == SEC_E_NO_KERB_KEY)
           || (SecurityStatus == SEC_E_TIME_SKEW) )
            {
            Status = RPC_S_ACCESS_DENIED;
            }
        else if ( SecurityStatus == SEC_E_SHUTDOWN_IN_PROGRESS )
            {
            Status = ERROR_SHUTDOWN_IN_PROGRESS;
            }
        else if (SecurityStatus == SEC_E_SECPKG_NOT_FOUND)
            {
            Status = RPC_S_UNKNOWN_AUTHN_SERVICE;
            }
        else if ( SecurityStatus ==  SEC_E_INSUFFICIENT_MEMORY )
            {
            Status = RPC_S_OUT_OF_MEMORY;
            }
        else
            {
#if DBG
            PrintToDebugger("RPC: InitializeFirstTime Returned %lx\n", SecurityStatus);
#endif
            //
            // Originally the default for all providers was SEC_PKG_ERROR.  This seems less
            // helpful than ACCESS_DENIED, but we can't change it for NTLM and Kerberos because
            // it might break old app code.
            //
            // SCHANNEL is new, so we can return ACCESS_DENIED.
            //
            if (AuthenticationService == RPC_C_AUTHN_GSS_SCHANNEL)
                {
                Status = RPC_S_ACCESS_DENIED;
                }
            else
                {
                Status = RPC_S_SEC_PKG_ERROR;
                }
            }

        RpcpErrorAddRecord (EEInfoGCRuntime,
            Status,
            EEInfoDLInitializeFirstTime20,
            SecurityStatus);

        return Status;
        }

    RetrievedAuthType = 0;

    DontForgetToDelete = 1;

    if (NewAuthType)
        {
        ASSERT(*NewAuthType == this->AuthenticationService);

        if (*NewAuthType == RPC_C_AUTHN_GSS_NEGOTIATE)
            {
            SecPkgContext_NegotiationInfo NegoInfo;
            SECURITY_STATUS Status;

            Status = (*RpcSecurityInterface->QueryContextAttributes)(
                         &SecurityContext,
                         SECPKG_ATTR_NEGOTIATION_INFO,
                         &NegoInfo);
            if (Status == SEC_E_OK)
                {
                if (NegoInfo.NegotiationState == SECPKG_NEGOTIATION_COMPLETE)
                    {
                    RetrievedAuthType = (unsigned char) NegoInfo.PackageInfo->wRPCID;
                    }
                (*RpcSecurityInterface->FreeContextBuffer)(NegoInfo.PackageInfo);
                }
            else
                {
                RpcpErrorAddRecord (EEInfoGCSecurityProvider,
                    RPC_S_OUT_OF_MEMORY,
                    EEInfoDLInitializeFirstTime30,
                    Status,
                    (ULONG)AuthenticationService,
                    AuthenticationLevel,
                    (ULONG)ContextRequirements);

                return RPC_S_OUT_OF_MEMORY;
                }
            }
        }

    Flags = ContextRequirements;

    fDone = TRUE;

    if ( SecurityStatus == SEC_I_CONTINUE_NEEDED )
        {
        if (!fDatagram)
            {
            fDone = FALSE;
            }
        Status = RPC_P_CONTINUE_NEEDED;
        }

    else if ( SecurityStatus == SEC_I_COMPLETE_NEEDED )
        {
        // Can't set the maximum lengths on a partly completed connection.

        Status = RPC_P_COMPLETE_NEEDED;
        }
    else if ( SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE )
        {
        if (!fDatagram)
            {
            fDone = FALSE;
            }
        Status = RPC_P_COMPLETE_AND_CONTINUE;
        }
    else
        {
        Status = RPC_S_OK;
        }

    if (fDone)
        {
        fFullyConstructed = TRUE;

        Status2 = SetMaximumLengths();
        if (Status2 != RPC_S_OK)
            {
            return Status2;
            }
        }

    if (RetrievedAuthType)
        *NewAuthType = RetrievedAuthType;

    return(Status);
}


RPC_STATUS
SECURITY_CONTEXT::InitializeThirdLeg (
    IN SECURITY_CREDENTIALS * Credentials,
    IN unsigned long DataRepresentation,
    IN SECURITY_BUFFER_DESCRIPTOR PAPI * InputBufferDescriptor,
    IN OUT SECURITY_BUFFER_DESCRIPTOR PAPI * OutputBufferDescriptor
    )
/*++

Routine Description:

Arguments:

Return Value:

    RPC_S_OK - Send the token to the server; everything worked fine so
        far.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to perform the
        operation.

    RPC_S_ACCESS_DENIED - Access is denied.

--*/
{
    SECURITY_STATUS SecurityStatus;
    TimeStamp TimeStamp;
    RPC_STATUS Status;

    ASSERT(   (SecuritySupportLoaded != 0)
           && (FailedToLoad == 0) );

    SecurityStatus = (*RpcSecurityInterface->InitializeSecurityContext)(
            Credentials->InquireCredHandle(),
            &SecurityContext,
            0,
            Flags,
            0,
            DataRepresentation,
            InputBufferDescriptor,
            0,
            &SecurityContext,
            OutputBufferDescriptor,
            &ContextAttributes,
            &TimeStamp
            );

    if (   ( SecurityStatus != SEC_E_OK )
        && ( SecurityStatus != SEC_I_CONTINUE_NEEDED )
        && ( SecurityStatus != SEC_I_COMPLETE_NEEDED )
        && ( SecurityStatus != SEC_I_COMPLETE_AND_CONTINUE ) )
        {
        SetExtendedError(SecurityStatus);

        RpcpErrorAddRecord (EEInfoGCSecurityProvider,
            SecurityStatus,
            EEInfoDLInitializeThirdLeg10,
            AuthenticationService,
            AuthenticationLevel,
            ContextAttributes);

        if (  (SecurityStatus == SEC_E_NO_CREDENTIALS)
           || (SecurityStatus == SEC_E_LOGON_DENIED)
           || (SecurityStatus == SEC_E_INVALID_TOKEN)
           || (SecurityStatus == SEC_E_UNKNOWN_CREDENTIALS)
           || (SecurityStatus == SEC_E_NO_KERB_KEY)
           || (SecurityStatus == SEC_E_TIME_SKEW) )
            {
            Status = RPC_S_ACCESS_DENIED;
            }
        else if ( SecurityStatus == SEC_E_SHUTDOWN_IN_PROGRESS )
            {
            Status = ERROR_SHUTDOWN_IN_PROGRESS;
            }
        else if (SecurityStatus == SEC_E_SECPKG_NOT_FOUND)
            {
            Status = RPC_S_UNKNOWN_AUTHN_SERVICE;
            }
        else if ( SecurityStatus ==  SEC_E_INSUFFICIENT_MEMORY )
            {
            Status = RPC_S_OUT_OF_MEMORY;
            }
        else
            {
#if DBG
            PrintToDebugger("RPC: InitializeThirdLeg Returned %lx\n",
                            SecurityStatus );
#endif
            //
            // Originally the default for all connection-oriented providers
            // was SEC_PKG_ERROR.  This seems less helpful than ACESS_DENIED,
            // but we can't change it for NTLM and Kerberos because it might
            // break old app code. SCHANNEL is new, so we can return ACCESS_DENIED.
            //
            // Datagram returns the bare error code.
            //
            if (AuthenticationService == RPC_C_AUTHN_GSS_SCHANNEL)
                {
                Status = RPC_S_ACCESS_DENIED;
                }
            else if (fDatagram)
                {
                // leave the error code alone
                }
            else
                {
                Status = RPC_S_SEC_PKG_ERROR;
                }
            }

        RpcpErrorAddRecord (EEInfoGCRuntime,
            Status,
            EEInfoDLInitializeThirdLeg20,
            SecurityStatus);

        return Status;
        }

    if ( SecurityStatus == SEC_I_CONTINUE_NEEDED )
        {
        return(RPC_P_CONTINUE_NEEDED);
        }

    if ( SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE )
        {
        return(RPC_P_COMPLETE_AND_CONTINUE);
        }

    ASSERT(SecurityStatus == SEC_E_OK
           || SecurityStatus == SEC_I_COMPLETE_NEEDED);

    if ( (ImpersonationType == RPC_C_IMP_LEVEL_IDENTIFY) &&
         (!(ContextAttributes & ISC_RET_IDENTIFY)) )
        {
        RpcpErrorAddRecord (EEInfoGCRuntime,
            RPC_S_SEC_PKG_ERROR,
            EEInfoDLInitializeThirdLeg30,
            SEC_E_SECURITY_QOS_FAILED,
            ImpersonationType,
            ContextAttributes);
        SetExtendedError(SEC_E_SECURITY_QOS_FAILED);
        return (RPC_S_SEC_PKG_ERROR);
        }

    if ( (ImpersonationType == RPC_C_IMP_LEVEL_DELEGATE) &&
         (!(ContextAttributes & ISC_RET_DELEGATE)) )
        {
        RpcpErrorAddRecord (EEInfoGCRuntime,
            RPC_S_SEC_PKG_ERROR,
            EEInfoDLInitializeThirdLeg40,
            SEC_E_SECURITY_QOS_FAILED,
            ImpersonationType,
            ContextAttributes);
        SetExtendedError(SEC_E_SECURITY_QOS_FAILED);
        return (RPC_S_SEC_PKG_ERROR);
        }

    if ( (!(ContextAttributes & ISC_RET_MUTUAL_AUTH) )&&
         (Capabilities  == RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH) )
        {
        RpcpErrorAddRecord (EEInfoGCRuntime,
            RPC_S_SEC_PKG_ERROR,
            EEInfoDLInitializeThirdLeg50,
            SEC_E_SECURITY_QOS_FAILED,
            ImpersonationType,
            ContextAttributes);
         SetExtendedError(SEC_E_SECURITY_QOS_FAILED);
         return (RPC_S_SEC_PKG_ERROR);
        }

    if ( SecurityStatus == SEC_I_COMPLETE_NEEDED )
        {
        fFullyConstructed = TRUE;

        Status = SetMaximumLengths();
        if (Status != RPC_S_OK)
            return Status;
        return(RPC_P_COMPLETE_NEEDED);
        }

    fFullyConstructed = TRUE;

    Status = SetMaximumLengths();
    if (Status != RPC_S_OK)
        return Status;

    if (AuthenticationService == RPC_C_AUTHN_GSS_SCHANNEL)
        {
        return VerifyCertificate();
        }

    return(RPC_S_OK);
}

RPC_STATUS
SECURITY_CONTEXT::GetWireIdForSnego(
    OUT unsigned char *WireId
    )
{
    SecPkgContext_NegotiationInfo NegoInfo;
    SECURITY_STATUS SecStatus;
    RPC_STATUS RpcStatus = RPC_S_OK;

    if (AuthenticationService != RPC_C_AUTHN_GSS_NEGOTIATE)
        return RPC_S_INVALID_BINDING;

    ASSERT(RpcSecurityInterface != NULL);

    SecStatus = (*RpcSecurityInterface->QueryContextAttributes)(
                 &SecurityContext,
                 SECPKG_ATTR_NEGOTIATION_INFO,
                 &NegoInfo);
    if (SecStatus == SEC_E_OK)
        {
        if (NegoInfo.NegotiationState == SECPKG_NEGOTIATION_COMPLETE)
            {
            *WireId = (unsigned char) NegoInfo.PackageInfo->wRPCID;
            }
        else
            RpcStatus = RPC_S_SEC_PKG_ERROR;

        (*RpcSecurityInterface->FreeContextBuffer)(NegoInfo.PackageInfo);
        }
    else
        {
        SetExtendedError(SecStatus);
        RpcStatus = RPC_S_OUT_OF_MEMORY;
        }

    return RpcStatus;
}


RPC_STATUS
SECURITY_CONTEXT::AcceptFirstTime (
    IN SECURITY_CREDENTIALS * NewCredentials,
    IN SECURITY_BUFFER_DESCRIPTOR PAPI * InputBufferDescriptor,
    IN OUT SECURITY_BUFFER_DESCRIPTOR PAPI * OutputBufferDescriptor,
    IN unsigned long AuthenticationLevel,
    IN unsigned long DataRepresentation,
    IN unsigned long NewContextNeededFlag
    )
/*++

Routine Description:

Arguments:

Return Value:

    RPC_S_OK - Everything worked just fine.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete the
        operation.

    RPC_P_CONTINUE_NEEDED - Indicates that everything is ok, but that we
        need to send the output token back to the client, and then wait
        for a token back from the client.

    RPC_P_COMPLETE_NEEDED - Indicates that everyting is ok, but that we
        need to call CompleteAuthToken before sending the message.

    RPC_P_COMPLETE_AND_CONTINUE - Needs both a complete and a continue.

    RPC_S_ACCESS_DENIED - Access is denied.

--*/
{
    SECURITY_STATUS SecurityStatus;
    TimeStamp TimeStamp;
    unsigned long ContextRequirements;
    RPC_STATUS RpcStatus;
    DWORD Status = 0;

    ASSERT(   (SecuritySupportLoaded != 0)
           && (FailedToLoad == 0) );

    if (Credentials)
        {
        Credentials->DereferenceCredentials();
        }
    Credentials = NewCredentials;
    Credentials->ReferenceCredentials();

    RpcSecurityInterface = Credentials->InquireProviderFunctionTable();

    if (NewContextNeededFlag == 1)
        {
        DeleteSecurityContext();
        }

    switch ( AuthenticationLevel )
        {
        case RPC_C_AUTHN_LEVEL_CONNECT :
            ContextRequirements = ASC_REQ_MUTUAL_AUTH;
            break;

        case RPC_C_AUTHN_LEVEL_PKT :
            ContextRequirements = ASC_REQ_MUTUAL_AUTH
                    | ASC_REQ_REPLAY_DETECT;
            break;

        case RPC_C_AUTHN_LEVEL_PKT_INTEGRITY :
            ContextRequirements = ASC_REQ_MUTUAL_AUTH
                    | ASC_REQ_REPLAY_DETECT | ASC_REQ_SEQUENCE_DETECT;
            break;

        case RPC_C_AUTHN_LEVEL_PKT_PRIVACY :
            ContextRequirements = ASC_REQ_MUTUAL_AUTH
                    | ASC_REQ_REPLAY_DETECT | ASC_REQ_SEQUENCE_DETECT
                    | ASC_REQ_CONFIDENTIALITY;
            break;

        default :
            ASSERT(AuthenticationLevel == RPC_C_AUTHN_LEVEL_CONNECT ||
                   AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT ||
                   AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT_INTEGRITY ||
                   AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT_PRIVACY );
            return RPC_S_INTERNAL_ERROR;
        }

    if (fDatagram)
        {
        ContextRequirements |= ASC_REQ_DATAGRAM;
        }
    else
        {
        ContextRequirements |= ASC_REQ_CONNECTION;
        }

    if (Credentials->AuthenticationService == RPC_C_AUTHN_WINNT ||
        Credentials->AuthenticationService == RPC_C_AUTHN_DCE_PRIVATE ||
        Credentials->AuthenticationService == RPC_C_AUTHN_GSS_KERBEROS ||
        Credentials->AuthenticationService == RPC_C_AUTHN_GSS_NEGOTIATE)
        {
        ContextRequirements |= ASC_REQ_USE_DCE_STYLE | ASC_REQ_DELEGATE;
        }

    if (AuthenticationService == RPC_C_AUTHN_WINNT
        || AuthenticationService == RPC_C_AUTHN_GSS_NEGOTIATE)
        {
        ContextRequirements |= ASC_REQ_ALLOW_NON_USER_LOGONS;
        }

    CallTestHook( TH_SECURITY_FN_ACCEPT1, this, &Status );

    if (Status)
        {
        SetExtendedError(Status);
        return Status;
        }

    SecurityStatus = (*RpcSecurityInterface->AcceptSecurityContext)(
            Credentials->InquireCredHandle(), 0, InputBufferDescriptor,
            ContextRequirements, DataRepresentation, &SecurityContext,
            OutputBufferDescriptor, &ContextAttributes, &TimeStamp);

    if (   ( SecurityStatus != SEC_E_OK )
        && ( SecurityStatus != SEC_I_CONTINUE_NEEDED )
        && ( SecurityStatus != SEC_I_COMPLETE_NEEDED )
        && ( SecurityStatus != SEC_I_COMPLETE_AND_CONTINUE ) )
        {
        RpcpErrorAddRecord (EEInfoGCSecurityProvider,
            SecurityStatus,
            EEInfoDLAcceptFirstTime10,
            AuthenticationService,
            AuthenticationLevel,
            ContextRequirements);

        SetExtendedError(SecurityStatus);

        if (  (SecurityStatus == SEC_E_NO_CREDENTIALS)
            || (SecurityStatus == SEC_E_LOGON_DENIED)
            || (SecurityStatus == SEC_E_INVALID_TOKEN)
            || (SecurityStatus == SEC_E_NO_AUTHENTICATING_AUTHORITY)
            || (SecurityStatus == SEC_E_UNKNOWN_CREDENTIALS) 
            || (SecurityStatus == SEC_E_CONTEXT_EXPIRED)
            || (SecurityStatus == SEC_E_TIME_SKEW))
            {
            RpcStatus = RPC_S_ACCESS_DENIED;
            }
        else if ( SecurityStatus == SEC_E_SHUTDOWN_IN_PROGRESS )
            {
            RpcStatus = ERROR_SHUTDOWN_IN_PROGRESS;
            }
        else if (SecurityStatus == SEC_E_SECPKG_NOT_FOUND)
            {
            RpcStatus = RPC_S_UNKNOWN_AUTHN_SERVICE;
            }
        else
            RpcStatus = RPC_S_OUT_OF_MEMORY;

        RpcpErrorAddRecord (EEInfoGCRuntime,
            RpcStatus,
            EEInfoDLAcceptFirstTime20,
            SecurityStatus);

        return RpcStatus;
        }

    DontForgetToDelete = 1;

    Flags = ContextRequirements;

    if ( SecurityStatus == SEC_I_CONTINUE_NEEDED )
        {
        return(RPC_P_CONTINUE_NEEDED);
        }
    if ( SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE )
        {
        return(RPC_P_COMPLETE_AND_CONTINUE);
        }

    ASSERT((SecurityStatus == SEC_I_COMPLETE_NEEDED)
        || (SecurityStatus == SEC_E_OK));


    fFullyConstructed = TRUE;

    RpcStatus = SetMaximumLengths();
    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    Credentials->DereferenceCredentials();
    Credentials = 0;
    if ( SecurityStatus == SEC_I_COMPLETE_NEEDED )
        return(RPC_P_COMPLETE_NEEDED);
    else
        return(RPC_S_OK);
}


RPC_STATUS
SECURITY_CONTEXT::AcceptThirdLeg (
    IN unsigned long DataRepresentation,
    IN SECURITY_BUFFER_DESCRIPTOR PAPI * BufferDescriptor,
    OUT SECURITY_BUFFER_DESCRIPTOR PAPI * OutBufferDescriptor
    )
/*++

Routine Description:

Arguments:

Return Value:

    RPC_S_OK - Everything worked just fine.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete the
        operation.

    RPC_S_ACCESS_DENIED - Access is denied.

    RPC_P_COMPLETE_NEEDED - Indicates that everyting is ok, but that we
        need to call CompleteAuthToken before sending the message.

--*/
{
    SECURITY_STATUS SecurityStatus;
    TimeStamp TimeStamp;
    RPC_STATUS RpcStatus;

    ASSERT(   (SecuritySupportLoaded != 0)
           && (FailedToLoad == 0) );

    SetLastError(0);


    {
    DWORD Status = 0;

    CallTestHook( TH_SECURITY_FN_ACCEPT3, this, &Status );

    if (Status)
        {
        FailedContext = Status;

        SetExtendedError(Status);

        return Status;
        }
    }

    SecurityStatus = (*RpcSecurityInterface->AcceptSecurityContext)(
            Credentials->InquireCredHandle(),
            &SecurityContext,
            BufferDescriptor,
            Flags,
            DataRepresentation,
            &SecurityContext,
            OutBufferDescriptor,
            &ContextAttributes,
            &TimeStamp
            );

    //
    // If 3rd Leg Failed Bit is set, map all errors other than out of memory
    // to SUCCESS
    //
    if ( 
        ( 
         ( SecurityStatus != SEC_E_OK )
         && ( SecurityStatus != SEC_I_COMPLETE_NEEDED)
         && ( SecurityStatus != SEC_I_CONTINUE_NEEDED)
         && ( SecurityStatus != SEC_I_COMPLETE_AND_CONTINUE)
         && ( SecurityStatus != SEC_E_INSUFFICIENT_MEMORY )
         && ( ContextAttributes & ASC_RET_THIRD_LEG_FAILED ) 
        )
        || 
        (  
         ( SecurityStatus == SEC_E_LOGON_DENIED )
         || ( SecurityStatus == SEC_E_NO_CREDENTIALS )
         || ( SecurityStatus == SEC_E_INVALID_TOKEN )
         || ( SecurityStatus == SEC_E_UNKNOWN_CREDENTIALS )
         || ( SecurityStatus == SEC_E_NO_AUTHENTICATING_AUTHORITY ) 
         || ( SecurityStatus == SEC_E_TIME_SKEW )
        ) 
       )
        {
        FailedContext = GetLastError();

        RpcpErrorAddRecord (EEInfoGCSecurityProvider,
            SecurityStatus,
            EEInfoDLAcceptThirdLeg10,
            AuthenticationService,
            AuthenticationLevel,
            FailedContext);

        if (!fDatagram)
            {
            SecurityStatus = SEC_E_OK;
            }

        SetExtendedError(SecurityStatus);

        if ( (FailedContext != ERROR_PASSWORD_MUST_CHANGE)
            && (FailedContext != ERROR_PASSWORD_EXPIRED)
            && (FailedContext != ERROR_ACCOUNT_DISABLED)
            && (FailedContext != ERROR_INVALID_LOGON_HOURS) )
            {
            FailedContext = RPC_S_ACCESS_DENIED;

            RpcpErrorAddRecord (EEInfoGCRuntime,
                FailedContext,
                EEInfoDLAcceptThirdLeg30);
            }

        ASSERT(FailedContextEEInfo == NULL);
        FailedContextEEInfo = RpcpGetEEInfo();
        RpcpClearEEInfo();
        }

    if (   ( SecurityStatus != SEC_E_OK )
        && ( SecurityStatus != SEC_I_COMPLETE_NEEDED )
        && ( SecurityStatus != SEC_I_CONTINUE_NEEDED )
        && ( SecurityStatus != SEC_I_COMPLETE_AND_CONTINUE ) )
        {
        SetExtendedError(SecurityStatus);

        RpcpErrorAddRecord (EEInfoGCSecurityProvider,
            SecurityStatus,
            EEInfoDLAcceptThirdLeg20,
            AuthenticationService,
            AuthenticationLevel);

        DontForgetToDelete = 0;

        if ( SecurityStatus == SEC_E_SHUTDOWN_IN_PROGRESS )
            {
            RpcStatus = ERROR_SHUTDOWN_IN_PROGRESS;
            }
        else if (   (SecurityStatus == SEC_E_SECPKG_NOT_FOUND)
            || (SecurityStatus == SEC_E_NO_CREDENTIALS)
            || (SecurityStatus == SEC_E_LOGON_DENIED)
            || (SecurityStatus == SEC_E_INVALID_TOKEN)
            || (SecurityStatus == SEC_E_UNKNOWN_CREDENTIALS)
            || (SecurityStatus == SEC_E_NO_AUTHENTICATING_AUTHORITY) 
            || (SecurityStatus == SEC_E_CONTEXT_EXPIRED)
            || (SecurityStatus == SEC_E_TIME_SKEW))
            {
            RpcStatus = RPC_S_ACCESS_DENIED;
            }
        else
            {
            ASSERT( SecurityStatus == SEC_E_INSUFFICIENT_MEMORY );
            RpcStatus = RPC_S_OUT_OF_MEMORY;
            }

        RpcpErrorAddRecord (EEInfoGCRuntime,
            RpcStatus,
            EEInfoDLAcceptThirdLeg40,
            SecurityStatus);

        return RpcStatus;
        }

    if ( SecurityStatus == SEC_I_CONTINUE_NEEDED )
        {
        return(RPC_P_CONTINUE_NEEDED);
        }
    if ( SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE )
        {
        return(RPC_P_COMPLETE_AND_CONTINUE);
        }


    ASSERT ( (SecurityStatus == SEC_I_COMPLETE_NEEDED)
        || (SecurityStatus == SEC_E_OK));

    fFullyConstructed = TRUE;

    RpcStatus = SetMaximumLengths();
    if (RpcStatus)
        {
        FailedContext = RpcStatus;

        ASSERT(FailedContextEEInfo == NULL);
        FailedContextEEInfo = RpcpGetEEInfo();
        RpcpClearEEInfo();

        //
        // We don't want to block third leg - mimic success
        // Failed context has already been set
        //
        MaxSignatureLength = 256;
        MaxHeaderLength    = 256;
        cbBlockSize        = 64;
        }

    if (SecurityStatus == SEC_I_COMPLETE_NEEDED)
        return(RPC_P_COMPLETE_NEEDED);
    else
        return RPC_S_OK;
}



unsigned long
SECURITY_CONTEXT::InquireAuthorizationService (
    )
/*++

Return Value:

    The authorization service for this security context will be returned.

--*/
{
    SecPkgContext_DceInfo DceInfo;
    SECURITY_STATUS SecurityStatus;
    SecurityStatus = (*RpcSecurityInterface->QueryContextAttributes)(
            &SecurityContext, SECPKG_ATTR_DCE_INFO, &DceInfo);
    ASSERT( SecurityStatus == SEC_E_OK );
    return(DceInfo.AuthzSvc);
}


RPC_AUTHZ_HANDLE
SECURITY_CONTEXT::InquirePrivileges (
    )
/*++

Return Value:

    The privileges of the client at the other end of this security context
    will be returned.

--*/
{
    SecPkgContext_DceInfo DceInfo;
    SECURITY_STATUS SecurityStatus;

    SecurityStatus = (*RpcSecurityInterface->QueryContextAttributes)(
            &SecurityContext, SECPKG_ATTR_DCE_INFO, &DceInfo);
    ASSERT( SecurityStatus == SEC_E_OK );
    return(DceInfo.pPac);
}


DWORD
SECURITY_CONTEXT::GetDceInfo (
        RPC_AUTHZ_HANDLE __RPC_FAR * PacHandle,
        unsigned long __RPC_FAR * AuthzSvc
        )

/*++

Return Value:

    The privileges of the client at the other end of this security context
    will be returned.

--*/
{
    SecPkgContext_DceInfo DceInfo;
    SECURITY_STATUS SecurityStatus;

    *PacHandle = 0;
    *AuthzSvc  = 0;

    SecurityStatus = (*RpcSecurityInterface->QueryContextAttributes)(
            &SecurityContext, SECPKG_ATTR_DCE_INFO, &DceInfo);

    ASSERT( (SecurityStatus == SEC_E_OK)
           ||  (SecurityStatus == SEC_E_UNSUPPORTED_FUNCTION)
           ||  (SecurityStatus == SEC_E_INVALID_HANDLE));

    if (SecurityStatus == SEC_E_OK)
        {
        *PacHandle = DceInfo.pPac;
        *AuthzSvc  = DceInfo.AuthzSvc;
        return 0;
        }

    if (AuthenticationService == RPC_C_AUTHN_GSS_SCHANNEL)
        {
        SecurityStatus = (*RpcSecurityInterface->QueryContextAttributes)(
            &SecurityContext, SECPKG_ATTR_REMOTE_CERT_CONTEXT, PacHandle);

        if (SecurityStatus != SEC_E_OK)
            {
            *PacHandle = 0;
            }
        }

    return SecurityStatus;
}


void
SECURITY_CONTEXT::DeleteSecurityContext (
    void
    )
/*++

Routine Description:

    If there is a valid security context, we need to delete it.

--*/
{
    SECURITY_STATUS SecurityStatus;
    unsigned int nRetries = 0;

    if ( DontForgetToDelete != 0 )
        {
        if (AuthzClientContext)
            {
            AuthzFreeContextFn(AuthzClientContext);
            AuthzClientContext = NULL;
            }

        // SEC_E_INSUFFICIENT_MEMORY may be returned under extremely low
        // memory conditions.  We will do the following:
        // - Retry 10 times to delete the security context.
        // - Raise a flag in the process that we have leaked one or more security contexts.
        do 
            {
            SecurityStatus = (*RpcSecurityInterface->DeleteSecurityContext)(
                    &SecurityContext );
            nRetries++;
            }
        while (SecurityStatus == SEC_E_INSUFFICIENT_MEMORY && nRetries < 10);

        if (SecurityStatus == SEC_E_INSUFFICIENT_MEMORY)
            {
            nSecurityContextsLeaked++;
            }

        // when the process shutdowns, the security system may return SEC_E_SECPKG_NOT_FOUND
        // since it is uninitialized. This is the only time when this error will be
        // returned, so it is safe to ignore.
        if (SecurityStatus == SEC_E_SECPKG_NOT_FOUND)
             SecurityStatus = SEC_E_OK;

#if DBG
        if ((SecurityStatus != SEC_E_OK) && (SecurityStatus != SEC_E_SHUTDOWN_IN_PROGRESS))
            {
            PrintToDebugger("DeleteSecurityContext(0x%x) Returned [%lx]\n",
                            &SecurityContext,
                            SecurityStatus);
            }
        if (SecurityStatus == SEC_E_INSUFFICIENT_MEMORY)
            {
            PrintToDebugger("SecurityContext(0x%x) leaked\n",
                            &SecurityContext);
            }
#endif

        ASSERT( SecurityStatus == SEC_E_OK ||
                SecurityStatus == SEC_E_SHUTDOWN_IN_PROGRESS ||
                SecurityStatus == SEC_E_INSUFFICIENT_MEMORY);

        DontForgetToDelete = 0;
        }

    if (FailedContextEEInfo)
        {
        FreeEEInfoChain(FailedContextEEInfo);
        FailedContextEEInfo = NULL;
        }
}

RPC_STATUS
SECURITY_CONTEXT::CheckForFailedThirdLeg (
    void
    )
/*++

Routine Description:

    If the third leg has failed, we will return the error code
    and restore the eeinfo.

--*/
{
    ASSERT(   ( SecuritySupportLoaded != 0 )
           && ( FailedToLoad == 0 ) );

    if (FailedContext != 0)
        {
        if (FailedContextEEInfo)
            {
            RpcpSetEEInfo(FailedContextEEInfo);
            FailedContextEEInfo = NULL;
            }
        return (RPC_S_ACCESS_DENIED);
        }

    return RPC_S_OK;
}


void
SECURITY_CONTEXT::DeletePac(
        void __RPC_FAR * PacHandle
        )

/*++

Return Value:


--*/
{
    if (AuthenticationService == RPC_C_AUTHN_GSS_SCHANNEL)
        {
        if (!LoadCrypt32Imports())
            {
            return;
            }

        CertFreeCertificateContext( (PCERT_CONTEXT) PacHandle );
        }
    else
        {
        (*RpcSecurityInterface->FreeContextBuffer)( PacHandle );
        }
}


RPC_STATUS
SECURITY_CONTEXT::ImpersonateClient (
    )
/*++

Routine Description:

    The server thread calling this routine will impersonate the client at the
    other end of this security context.

Return Value:

    RPC_S_OK - The impersonation successfully occured.

    RPC_S_NO_CONTEXT_AVAILABLE - There is no security context available to
        be impersonated.

--*/
{
    SECURITY_STATUS SecurityStatus;

    ASSERT(   ( SecuritySupportLoaded != 0 )
           && ( FailedToLoad == 0 ) );

    if (FailedContext != 0)
       {
       if (FailedContextEEInfo)
           {
           RpcpSetEEInfo(FailedContextEEInfo);
           FailedContextEEInfo = NULL;
           }
       return (RPC_S_ACCESS_DENIED);
       }

    ASSERT( FullyConstructed() );

    SecurityStatus = (*RpcSecurityInterface->ImpersonateSecurityContext)(
            &SecurityContext);

    if ( SecurityStatus != SEC_E_OK )
        {
        RpcpErrorAddRecord (EEInfoGCSecurityProvider,
            RPC_S_NO_CONTEXT_AVAILABLE,
            EEInfoDLImpersonateClient10,
            SecurityStatus,
            AuthenticationService,
            AuthenticationLevel);

        ASSERT( SecurityStatus == SEC_E_NO_IMPERSONATION );
        return(RPC_S_NO_CONTEXT_AVAILABLE);
        }

    return(RPC_S_OK);
}


void
SECURITY_CONTEXT::RevertToSelf (
    )
/*++

Routine Description:

    The server thread calling this routine will stop impersonating.  If the
    thread is not impersonating, then this is a noop.

--*/
{
    SECURITY_STATUS SecurityStatus;

    ASSERT(   ( SecuritySupportLoaded != 0 )
           && ( FailedToLoad == 0 ) );

    SecurityStatus = (*RpcSecurityInterface->RevertSecurityContext)(
            &SecurityContext);

    ASSERT( SecurityStatus == SEC_E_OK );
}

RPC_STATUS
SECURITY_CONTEXT::GetAccessToken (
    OUT HANDLE *ImpersonationToken,
    OUT BOOL *fNeedToCloseToken
    )
/*++

Routine Description:

    Gets the access token maintained by the security provider.

Arguments:

    ImpersonationToken - contains the impersonation token on success
    fNeedToCloseToken - true if the resulting token needs closing.
        False otherwise. Some security providers support handing off
        of the token itself (faster). Some don't. All support handing
        off a copy of the token. Depending on what security provider
        we have, we'll get the token, and set this variable. This
        parameter is undefined in case of failure.

Return Value:
    RPC_S_OK on success, or RPC_S_* on failure. Supports EEInfo.

--*/
{
    SECURITY_STATUS SecurityStatus;
    HANDLE Token;

    ASSERT(   ( SecuritySupportLoaded != 0 )
           && ( FailedToLoad == 0 ) );

    ASSERT( FullyConstructed() );

    SecurityStatus = (*RpcSecurityInterface->QueryContextAttributes)(
            &SecurityContext,
            SECPKG_ATTR_ACCESS_TOKEN,
            &Token);

    if ( (SecurityStatus != SEC_E_OK)
        && (SecurityStatus != SEC_E_UNSUPPORTED_FUNCTION) )
        {
        RpcpErrorAddRecord (EEInfoGCSecurityProvider,
            RPC_S_NO_CONTEXT_AVAILABLE,
            EEInfoDLSECURITY_CONTEXT__GetAccessToken10,
            SecurityStatus,
            AuthenticationService,
            AuthenticationLevel);

        ASSERT( 0 );
        return(RPC_S_NO_CONTEXT_AVAILABLE);
        }

    if (SecurityStatus != SEC_E_OK)
        {
        ASSERT(SecurityStatus == SEC_E_UNSUPPORTED_FUNCTION);

        // the security provider does not provide quick retrieval
        // of token - go the long way
        SecurityStatus = (*RpcSecurityInterface->QuerySecurityContextToken)(
            &SecurityContext, &Token);

        if (SecurityStatus != SEC_E_OK)
            {
            RpcpErrorAddRecord (EEInfoGCSecurityProvider,
                RPC_S_NO_CONTEXT_AVAILABLE,
                EEInfoDLSECURITY_CONTEXT__GetAccessToken20,
                SecurityStatus,
                AuthenticationService,
                AuthenticationLevel);

            ASSERT( SecurityStatus == SEC_E_NO_IMPERSONATION );
            return(RPC_S_NO_CONTEXT_AVAILABLE);
            }

        *fNeedToCloseToken = TRUE;
        }
    else
        {
        *fNeedToCloseToken = FALSE;
        }

    *ImpersonationToken = Token;
    return RPC_S_OK;
}


PACKAGE_LEG_COUNT
GetPackageLegCount(
    DWORD id
    )
/*++

Routine Description:

    This fn determines whether the given security package is a 3- or 4-leg
    protocol. The relevance of this information is described in
    ReadPackageLegInfo(). This fn. first searches the hardcoded entries in
    PredefinedPackageLegInfo[], and if the package is not found it turns to the
    registry information stored in FourLeggedPackages[].

Return Values:

    LegsUnknown = the fn cannot give a reliable answer

    ThreeLegs = this is a 3-leg protocol

    EvenNumberOfLegs = this is not a 3-leg protocol

--*/
{
    int i;

    if ( InsureSecuritySupportLoaded() != RPC_S_OK )
        {
        return LegsUnknown;
        }

    for (i=0; PredefinedPackageLegInfo[i].Package != 0; ++i)
        {
        if (PredefinedPackageLegInfo[i].Package == id)
            {
            return PredefinedPackageLegInfo[i].Legs;
            }
        }

    CLAIM_MUTEX Lock( *SecurityCritSect );

    if (!FourLeggedPackages)
        {
        if (!ReadPackageLegInfo())
            {
            return LegsUnknown;
            }
        }

    ASSERT(FourLeggedPackages);

    for (i=0; FourLeggedPackages[i] != 0; ++i)
        {
        if (FourLeggedPackages[i] == id)
            {
            return EvenNumberOfLegs;
            }
        }

    return ThreeLegs;
}

DWORD
SECURITY_CONTEXT::VerifyCertificate()
{
    DWORD SecurityStatus = 0;

    //
    // Compare the name on the certificate against the expected principal name.
    //
    if (ServerPrincipalName)
        {
        //
        // Get a copy of the raw certificate.
        //
        if (!LoadCrypt32Imports())
            {
            return GetLastError();
            }

        PCERT_CONTEXT ClientContext;

        SecurityStatus = (*RpcSecurityInterface->QueryContextAttributes)(
                                &SecurityContext,
                                SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                                &ClientContext
                                );
        if (SecurityStatus)
            {
            RpcpErrorAddRecord ( EEInfoGCSecurityProvider,
                                 RPC_S_OUT_OF_MEMORY,
                                 EEInfoDLInitializeThirdLeg60,
                                 SecurityStatus );

            ASSERT( SecurityStatus == SEC_E_INSUFFICIENT_MEMORY );
            return SecurityStatus;
            }

        SecurityStatus = RpcCertMatchPrincipalName( ClientContext, ServerPrincipalName );
        switch (SecurityStatus)
            {
            case 0:
            case ERROR_NOT_ENOUGH_MEMORY:
                break;

            default:

                //
                // we are supposed to have verified the princ name earlier.
                //
                ASSERT( SecurityStatus != ERROR_INVALID_PARAMETER );

                SetExtendedError(SecurityStatus);

                SecurityStatus = RPC_S_ACCESS_DENIED;
                break;
            }

        CertFreeCertificateContext( ClientContext );
        }

    return SecurityStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\startsvc.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    startsvc.c

Abstract:

    This routine implements on-demand starting of the RpcSs service.

Author:

    Bharat Shah (barats) 4-5-92

Revision History:

--*/

#include <sysinc.h>
#include <rpc.h>
#include <winsvc.h>
#include <startsvc.h>

#define SUCCESS         0
const RPC_CHAR *pRPCEPMPR = RPC_CONST_STRING("RPCSS");



RPC_STATUS RPC_ENTRY
StartServiceIfNecessary(
    void
    )
/*++

Routine Description:

    If the rpcss service has not yet been started, then we attempt to
    start it.

Returns:

    RPC_S_OK - The rpcss service is running.

    Service controller errors.


--*/
{

    SC_HANDLE           hServiceController = NULL;
    SC_HANDLE           hService = NULL;
    SERVICE_STATUS      ServiceStatus;
    DWORD               status;
    DWORD               Counter = 0L;
    BOOL                FirstTime = TRUE;
    unsigned long       ArgC = 0;
    RPC_CHAR     PAPI *     ArgV[1] = { NULL };

    //
    // Get a handle to the service controller.
    //
    hServiceController = OpenSCManager(
                            NULL,
                            NULL,
                            GENERIC_READ);

    if (hServiceController == NULL)
       {
        status = GetLastError();
        return(status);
       }

    //
    // Get a handle to the service
    //
    hService = OpenService(
                hServiceController,
                pRPCEPMPR,
                GENERIC_READ|SERVICE_START);

    if (hService == NULL)
       {
        status = GetLastError();
        goto CleanExit;
       }

    //
    // Call StartService
    //
    /*
    if (!StartService(hService,ArgC,ArgV))
       {
          status = GetLastError();
          if (status == ERROR_SERVICE_ALREADY_RUNNING)
             status = RPC_S_OK;
          goto CleanExit;
       }
    */

    do
      {

        if (!QueryServiceStatus(hService,&ServiceStatus))
            {
              status = GetLastError();
              goto CleanExit;
            }

        switch(ServiceStatus.dwCurrentState)
        {

          case SERVICE_RUNNING:
                status = SUCCESS;
                goto CleanExit;
                break;

          case SERVICE_STOP_PENDING:
          case SERVICE_START_PENDING:
                if (!FirstTime && (Counter == ServiceStatus.dwCheckPoint))
                   {
                    status = ERROR_SERVICE_REQUEST_TIMEOUT;
                    goto CleanExit;
                   }
                else
                   {
                    FirstTime = FALSE;
                    Counter = ServiceStatus.dwCheckPoint;
                    Sleep(ServiceStatus.dwWaitHint);
                   }
                 break;
 
          case SERVICE_STOPPED:
                if (!StartService(hService, ArgC, ArgV))
                   {
                   status = GetLastError();
                   if (status == ERROR_SERVICE_ALREADY_RUNNING)
                               status = RPC_S_OK;
                   goto CleanExit;
                   }
                 Sleep(500);
                 break;

          default:
                 status = GetLastError();
                 goto CleanExit;
                 break;
       }
    }
   while (TRUE);

CleanExit:

    if(hServiceController != NULL) {
        (VOID) CloseServiceHandle(hServiceController);
    }
    if(hService != NULL) {
        (VOID) CloseServiceHandle(hService);
    }
    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\svrapip.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1991 - 1999
//
//  File:       svrapip.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

                      Microsoft OS/2 LAN Manager
                   Copyright(c) Microsoft Corp., 1990

-------------------------------------------------------------------- */
/* --------------------------------------------------------------------

File : svrapip.cxx

Description :

This file contains the private entry points into the server runtime.

History :

mikemon    02-02-91    Created.

-------------------------------------------------------------------- */

#include <precomp.hxx>

void RPC_ENTRY
I_RpcRequestMutex (
    IN OUT I_RPC_MUTEX * Mutex
    )
{
    if (*Mutex == 0)
        {
        RPC_STATUS RpcStatus = RPC_S_OK;

        MUTEX *mutex = new MUTEX(&RpcStatus);

        if ( NULL == mutex )
            {
            RpcpRaiseException(RPC_S_OUT_OF_MEMORY);
            return;
            }

        if ( RpcStatus != RPC_S_OK )
            {
            delete mutex;
            RpcpRaiseException(RPC_S_OUT_OF_MEMORY);
            return;
            }

        if (InterlockedCompareExchangePointer(Mutex, mutex, NULL) != NULL)
            {
            delete mutex;
            }
        }

    ((MUTEX *) (*Mutex))->Request();
}

void RPC_ENTRY
I_RpcClearMutex (
    IN I_RPC_MUTEX Mutex
    )
{
    ((MUTEX *) Mutex)->Clear();
}

void RPC_ENTRY
I_RpcDeleteMutex (
    IN I_RPC_MUTEX Mutex
    )
{
    delete ((MUTEX *) Mutex);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\svrbind.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    svrbind.cxx

Abstract:

    This file contains the implementation of the server binding handle
    class, SVR_BINDING_HANDLE.

Author:

    Michael Montague (mikemon) 23-Nov-1991

Revision History:

--*/

#include <precomp.hxx>


RPC_STATUS
SVR_BINDING_HANDLE::InsureRealBindingHandle (
    )
/*++

Routine Description:

    This method is used to insure that we have transformed this binding
    handle into a real full fledged binding handle.  If we do not
    have a real binding handle, then we attempt to create one.

Return Value:

    RPC_S_OK will be returned if we successfully obtain a real binding
    handle.  Otherwise, the result of trying to create a binding handle
    will be returned; see DCE_BINDING::CreateBindingHandle for a list
    of error codes.

--*/
{
    RPC_STATUS Status;

    if (RealBindingHandle == 0)
        {

        RealBindingHandle = DceBinding->CreateBindingHandle(&Status);

        if (Status != RPC_S_OK)
            {
            RealBindingHandle = 0;
            return(Status);
            }

        // This binding needs to transfer its ObjectUuid, if any,
        // to the new binding.  It is not possible to efficiently add
        // the object uuid to the DceBinding first.

        if (InqIfNullObjectUuid() == 0)
            {
            RealBindingHandle->SetObjectUuid(InqPointerAtObjectUuid());
            }

        DceBinding = 0;
        }
    return(RPC_S_OK);
}


SVR_BINDING_HANDLE::SVR_BINDING_HANDLE (
    IN DCE_BINDING * DceBinding,
    IN RPC_CHAR * DynamicEndpoint, 
    IN OUT RPC_STATUS *Status
    ) : BINDING_HANDLE(Status)
/*++

Routine Description:

    This constructor is trivial.  We just stash the binding information
    and dynamic endpoint away for future use.

Arguments:

    DceBinding - Supplies the binding information.  Ownership of this
        object passes to this routine.

    DynamicEndpoint - Supplies the dynamic endpoint for the rpc address
        corresponding to this binding.  Ownership of this object passes
        to this routine.

--*/
{
    ObjectType = SVR_BINDING_HANDLE_TYPE;
    this->DceBinding = DceBinding;
    RealBindingHandle = 0;

    if( DynamicEndpoint )
        {
        EndpointIsDynamic = 1;
        DceBinding->AddEndpoint(DynamicEndpoint);
        }
    else
        {
        EndpointIsDynamic = 0;
        }
}


SVR_BINDING_HANDLE::~SVR_BINDING_HANDLE (
    )
/*++

Routine Description:

    Since ownership of the binding information passed to the constructor
    of this instance, we need to delete the binding information now.
    Actually, before we can delete the binding information we need to
    check to see if ownership has passed to the real binding handle.

--*/
{
    if (DceBinding != 0)
        delete DceBinding;
}


inline HANDLE_TYPE // Return SVR_BINDING_HANDLE_TYPE.
SVR_BINDING_HANDLE::Type (
    )
{
    UNUSED(this);

    return (SVR_BINDING_HANDLE_TYPE);
}


void
SVR_BINDING_HANDLE::MakePartiallyBound(
    )
/*++

Routine Description:

    This routine is called by RPC_SERVER::NsBindingsModify(). We just
    remove the endpoint information from DceBinding member variable.

--*/
{
    if (EndpointIsDynamic)
        {
        DceBinding->MakePartiallyBound();
        }
}




RPC_STATUS
SVR_BINDING_HANDLE::SendReceive (
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:

    We need to transport the server binding handle into a full fledged
    binding handle, and then let the full fledged binding handle take
    care of performing the requested operation.

Arguments:

    Message - Supplies and returns information describing the remote
        procedure call to be sent.

Return Value:

    For possible return codes, see DCE_BINDING::CreateBindingHandle and
    SendReceive.

--*/
{
    RPC_STATUS Status;

    Status = InsureRealBindingHandle();
    if (Status != RPC_S_OK)
        return(Status);
    return(RealBindingHandle->SendReceive(Message));
}


RPC_STATUS
SVR_BINDING_HANDLE::NegotiateTransferSyntax (
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:

    We need to transport the server binding handle into a full fledged
    binding handle, and then let the full fledged binding handle take
    care of performing the requested operation.

Arguments:

    Message - Supplies and returns information describing the buffer
        we need to allocate.

Return Value:

    For possible return codes, see DCE_BINDING::CreateBindingHandle and
    the different flavors of NegotiateTransferSyntax.

--*/
{
    RPC_STATUS Status;

    Status = InsureRealBindingHandle();
    if (Status != RPC_S_OK)
        return(Status);
    return(RealBindingHandle->NegotiateTransferSyntax(Message));
}


RPC_STATUS
SVR_BINDING_HANDLE::GetBuffer (
    IN OUT PRPC_MESSAGE Message,
    IN UUID *ObjectUuid
    )
/*++

Routine Description:

    We need to transport the server binding handle into a full fledged
    binding handle, and then let the full fledged binding handle take
    care of performing the requested operation.

Arguments:

    Message - Supplies and returns information describing the buffer
        we need to allocate.

Return Value:

    For possible return codes, see DCE_BINDING::CreateBindingHandle and
    the different flavors of GetBuffer.

--*/
{
    RPC_STATUS Status;

    Status = InsureRealBindingHandle();
    if (Status != RPC_S_OK)
        return(Status);
    return(RealBindingHandle->GetBuffer(Message, ObjectUuid));
}


void
SVR_BINDING_HANDLE::FreeBuffer (
    IN PRPC_MESSAGE Message
    )
/*++

Routine Description:

    We need to transport the server binding handle into a full fledged
    binding handle, and then let the full fledged binding handle take
    care of performing the requested operation.

Arguments:

    Message - Supplies the buffer to be freed.

--*/
{
    RPC_STATUS Status;

    Status = InsureRealBindingHandle();
    ASSERT(Status == RPC_S_OK);
    RealBindingHandle->FreeBuffer(Message);
}


RPC_STATUS
SVR_BINDING_HANDLE::BindingCopy (
    OUT BINDING_HANDLE * PAPI * DestinationBinding,
    IN unsigned int MaintainContext
    )
/*++

Routine Description:

    We need to copy this binding handle.  This is relatively easy to
    do: we just need to duplicate the binding information and construct
    another server binding handle.

Arguments:

    DestinationBinding - Returns a copy of this binding handle.

    MaintainContext - Supplies a flag that indicates whether or not context
        is being maintained over this binding handle.  A non-zero value
        indicates that context is being maintained.

Return Value:

    RPC_S_OUT_OF_MEMORY - This indicates that there is not enough memory
        to allocate a new binding handle.

    RPC_S_OK - We successfully copied this binding handle.

--*/
{
    SVR_BINDING_HANDLE * Binding;
    DCE_BINDING * DceBinding;
    RPC_STATUS Status;

    if (RealBindingHandle != 0)
        return(RealBindingHandle->BindingCopy(DestinationBinding,
                MaintainContext));

    // Even if the binding is really dynamic, the endpoint has
    // been added to the DceBinding in the constructor.

    DceBinding = this->DceBinding->DuplicateDceBinding();
    if (DceBinding == 0)
        {
        *DestinationBinding = 0;
        return(RPC_S_OUT_OF_MEMORY);
        }

    Binding = new SVR_BINDING_HANDLE(DceBinding,0, &Status);
    *DestinationBinding = Binding;
    if (Binding == 0)
        return(RPC_S_OUT_OF_MEMORY);
    return(RPC_S_OK);
}


RPC_STATUS
SVR_BINDING_HANDLE::BindingFree (
    )
/*++

Routine Description:

    The application wants to free this binding handle.  If there is a real
    binding handle, we need to invoke BindingFree on it as well; otherwise,
    all we have got to do is to delete it.

Return Value:

    RPC_S_OK - This value will be returned, unless an error occurs in the
        BindingFree operation invoked on the real binding handle.

--*/
{
    RPC_STATUS Status;

    if (RealBindingHandle != 0)
        {
        Status = RealBindingHandle->BindingFree();
        RealBindingHandle = 0;
        if (Status != RPC_S_OK)
            return(Status);
        }

    delete this;
    return(RPC_S_OK);
}


RPC_STATUS
SVR_BINDING_HANDLE::ToStringBinding (
    OUT RPC_CHAR PAPI * PAPI * StringBinding
    )
/*++

Routine Description:

    We need to convert the binding handle into a string binding.  We
    can just use the information in this server binding handle to
    create the string binding.

Arguments:

    StringBinding - Returns the string representation of the binding
        handle.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_OUT_OF_MEMORY - We do not have enough memory available to
        allocate space for the string binding.

--*/
{
    if (RealBindingHandle != 0)
        return(RealBindingHandle->ToStringBinding(StringBinding));

     *StringBinding = DceBinding->StringBindingCompose(
            InqPointerAtObjectUuid());
    if (*StringBinding == 0)
        return(RPC_S_OUT_OF_MEMORY);
    return(RPC_S_OK);
}


RPC_STATUS
SVR_BINDING_HANDLE::ToStaticStringBinding (
    OUT RPC_CHAR PAPI * PAPI * StringBinding
    )
/*++

Routine Description:

    We need to convert the binding handle into a string binding.  We
    can just use the information in this server binding handle to
    create the string binding.

Arguments:

    StringBinding - Returns the string representation of the binding
        handle.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_OUT_OF_MEMORY - We do not have enough memory available to
        allocate space for the string binding.

--*/
{
    RPC_STATUS Status;
    RPC_CHAR __RPC_FAR * CopiedStringBinding;
    RPC_UUID *MyUuid = 0;
    DCE_BINDING *MyDceBinding;

    if (RealBindingHandle != 0)
        {
        Status = RealBindingHandle->ToStringBinding(StringBinding);
        if (Status != RPC_S_OK)
            {
            return Status;
            }

        if (EndpointIsDynamic == 0)
            {
            return RPC_S_OK;
            }
    
        // 
        // The endpoint is dynamic, need to strip it out
        //
        CopiedStringBinding = (RPC_CHAR *)
              _alloca( (RpcpStringLength(StringBinding)+1)*(sizeof(RPC_CHAR)) );
        if (CopiedStringBinding == 0)
            {
            return (RPC_S_OUT_OF_MEMORY);
            }
        RpcpStringCopy(CopiedStringBinding, StringBinding);
        
        MyDceBinding = new DCE_BINDING(CopiedStringBinding,&Status);
    
        if ( MyDceBinding == 0 )
            {
            return(RPC_S_OUT_OF_MEMORY);
            }
        
        if ( Status != RPC_S_OK )
            {
            delete MyDceBinding;
            return(Status);
            }
        }
    else
        {
        MyUuid = InqPointerAtObjectUuid();
        MyDceBinding = DceBinding;
        }

    *StringBinding = MyDceBinding->StringBindingCompose(
                                                        MyUuid, 
                                                        EndpointIsDynamic);

    if (DceBinding != MyDceBinding)
        {
        delete MyDceBinding;
        }

    if (*StringBinding == 0)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    return(RPC_S_OK);
}


RPC_STATUS
SVR_BINDING_HANDLE::InquireDynamicEndpoint (
    OUT RPC_CHAR PAPI * PAPI * DynamicEndpoint
    )
/*++

Routine Description:

    This routine is used to obtain the dynamic endpoint from a binding
    handle which was created from an rpc address.  If there is a dynamic
    endpoint, we just need to duplicate it, and return a pointer to it.

Arguments:

    DynamicEndpoint - Returns a pointer to the dynamic endpoint, it is
        always set to zero.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_OUT_OF_MEMORY - Unable to allocate memory for the endpoint string.

--*/
{
    if (EndpointIsDynamic == 1 && DceBinding)
        {
        *DynamicEndpoint = DuplicateStringPAPI(DceBinding->InqEndpoint());
        if (*DynamicEndpoint == 0)
            return(RPC_S_OUT_OF_MEMORY);
        }
    else
        {
        *DynamicEndpoint = 0;
        }
    return(RPC_S_OK);
}


RPC_STATUS
SVR_BINDING_HANDLE::PrepareBindingHandle (
    IN TRANS_INFO *  TransportInterface,
    IN DCE_BINDING * DceBinding
    )
{
    UNUSED(this);
    UNUSED(TransportInterface);
    UNUSED(DceBinding);

    ASSERT( 0 );
    return RPC_S_OK;
}

RPC_STATUS
SVR_BINDING_HANDLE::ResolveBinding (
    IN PRPC_CLIENT_INTERFACE RpcClientInterface
    )
{
    RPC_STATUS Status;

    Status = InsureRealBindingHandle();
    if (Status != RPC_S_OK)
        return (Status);
    return(RealBindingHandle->ResolveBinding(RpcClientInterface));
}

RPC_STATUS
SVR_BINDING_HANDLE::BindingReset (
    )
{
    RPC_STATUS Status;

    Status = InsureRealBindingHandle();
    if (Status != RPC_S_OK)
        return(Status);
    Status = RealBindingHandle->BindingReset();
    if (Status == RPC_S_OK)
        {
        EndpointIsDynamic = 0;
        }
    return (Status);
}


RPC_STATUS
SVR_BINDING_HANDLE::InquireTransportType(
    OUT unsigned int PAPI *Type
    )
{
    RPC_STATUS Status;

    Status = InsureRealBindingHandle();
    if (Status != RPC_S_OK)
        return(Status);
    return(RealBindingHandle->InquireTransportType(Type));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\svrmgmt.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    svrmgmt.c

Abstract:

    We implement the server side of the remote management routines in this
    file.

Author:

    Michael Montague (mikemon) 14-Apr-1993

Revision History:

--*/

#include <sysinc.h>
#include <rpc.h>
#include <mgmt.h>


int
DefaultMgmtAuthorizationFn (
    IN RPC_BINDING_HANDLE ClientBinding,
    IN unsigned long RequestedMgmtOperation,
    OUT RPC_STATUS __RPC_FAR * Status
    )
/*++

Routine Description:

    This is the default authorization function used to control remote access
    to the server's management routines.

Arguments:

    ClientBinding - Supplies the client binding handle of the application
        which is calling this routine.

    RequestedMgmtOperation - Supplies which management routine is being called.

    Status - Returns RPC_S_OK.

Return Value:

    A value of non-zero will be returned if the client is authorized to
    call the management routine; otherwise, zero will be returned.

--*/
{
    ((void) ClientBinding);

    *Status = RPC_S_OK;

    if ( RequestedMgmtOperation != RPC_C_MGMT_STOP_SERVER_LISTEN )
        {
        return(1);
        }

    return(0);
}

RPC_MGMT_AUTHORIZATION_FN MgmtAuthorizationFn = DefaultMgmtAuthorizationFn;


RPC_STATUS RPC_ENTRY
RpcMgmtSetAuthorizationFn (
    IN RPC_MGMT_AUTHORIZATION_FN AuthorizationFn
    )
/*++

Routine Description:

    An application can use this routine to set the authorization function
    which will be called when a remote call arrives for one of the server's
    management routines, or to return to using the default (built-in)
    authorizatio function.

Arguments:

    AuthorizationFn - Supplies a new authorization function.
                      The fn may be nil, in which case the built-in auth fn
                      is used instead.

Return Value:

    RPC_S_OK - This will always be returned.

--*/
{
    if (AuthorizationFn)
        {
        MgmtAuthorizationFn = AuthorizationFn;
        }
    else
        {
        MgmtAuthorizationFn = DefaultMgmtAuthorizationFn;
        }

    return(RPC_S_OK);
}


void
rpc_mgmt_inq_if_ids (
    RPC_BINDING_HANDLE binding,
    rpc_if_id_vector_p_t __RPC_FAR * if_id_vector,
    unsigned long __RPC_FAR * status
    )
/*++

Routine Description:

    This is the management code corresponding to the rpc_mgmt_inq_if_ids
    remote operation.

--*/
{
    //
    // If the auth fn returns false, the op is denied.
    //
    if ( (*MgmtAuthorizationFn)(binding, RPC_C_MGMT_INQ_IF_IDS, status) == 0 )
        {
        if (0 == *status || RPC_S_OK == *status)
            {
            *status = RPC_S_ACCESS_DENIED;
            }

        return;
        }

    *status = RpcMgmtInqIfIds(0, (RPC_IF_ID_VECTOR **) if_id_vector);
}


void
rpc_mgmt_inq_princ_name (
    RPC_BINDING_HANDLE binding,
    unsigned32 authn_svc,
    unsigned32 princ_name_size,
    unsigned char server_princ_name[],
    error_status_t * status
    )
/*++

Routine Description:

    This is the management code corresponding to the
    rpc_mgmt_inq_server_princ_name remote operation.

--*/
{
    unsigned char * ServerPrincName;
    
    //
    // We have to call the function, even if princ_name_size == 0. 
    // The call may be using it just to see if it has access
    //
    
    //
    // If the auth fn returns false, the op is denied.
    //
    if ( (*MgmtAuthorizationFn)(binding, RPC_C_MGMT_INQ_PRINC_NAME, status)
         == 0 )
        {
        if (0 == *status || RPC_S_OK == *status)
            {
            *status = RPC_S_ACCESS_DENIED;
            }

        if (princ_name_size)
            {
            *server_princ_name = '\0';
            }   
        return;
        }

    *status = RpcMgmtInqServerPrincNameA(0, authn_svc, &ServerPrincName);
    if ( *status == 0 )
        {
        unsigned int count;
        if (princ_name_size)
            {
            count = strlen(ServerPrincName);
            if (count > princ_name_size - 1)
                {
                *status = RPC_S_BUFFER_TOO_SMALL;
                }
            else
                {
                RpcpMemoryCopy(server_princ_name, ServerPrincName, count + 1);
                }
            RpcStringFreeA(&ServerPrincName);
            }
        }
    else
        {
        if (princ_name_size)
            {
            *server_princ_name = '\0';
            }
        }
}


void
rpc_mgmt_inq_stats (
    RPC_BINDING_HANDLE binding,
    unsigned32 * count,
    unsigned32 statistics[],
    error_status_t * status
    )
/*++

Routine Description:

    This is the management code corresponding to the rpc_mgmt_inq_stats
    remote operation.

--*/
{
    RPC_STATS_VECTOR __RPC_FAR * StatsVector;
    unsigned long Index;

    //
    // If the auth fn returns false, the op is denied.
    //
    if ( (*MgmtAuthorizationFn)(binding, RPC_C_MGMT_INQ_STATS, status) == 0 )
        {
        if (0 == *status || RPC_S_OK == *status)
            {
            *status = RPC_S_ACCESS_DENIED;
            }

        return;
        }

    *status = RpcMgmtInqStats(0, &StatsVector);
    if ( *status == RPC_S_OK )
        {
        for (Index = 0; Index < StatsVector->Count && Index < *count; Index++)
            {
            statistics[Index] = StatsVector->Stats[Index];
            }
        *count = Index;
        RpcMgmtStatsVectorFree(&StatsVector);
        }
}


unsigned long
rpc_mgmt_is_server_listening (
    RPC_BINDING_HANDLE binding,
    unsigned long __RPC_FAR * status
    )
/*++

Routine Description:

    This is the management code corresponding to the
    rpc_mgmt_is_server_listening remote operation.

--*/
{
    //
    // If the auth fn returns false, the op is denied.
    //
    if ( (*MgmtAuthorizationFn)(binding, RPC_C_MGMT_IS_SERVER_LISTEN, status)
         == 0 )
        {
        if (0 == *status || RPC_S_OK == *status)
            {
            *status = RPC_S_ACCESS_DENIED;
            }

        return 1;
        }

    *status = RpcMgmtIsServerListening(0);
    if ( *status == RPC_S_OK )
        {
        return(1);
        }

    if ( *status == RPC_S_NOT_LISTENING )
        {
        *status = RPC_S_OK;
        }

    return(0);
}


void
rpc_mgmt_stop_server_listening (
    RPC_BINDING_HANDLE binding,
    unsigned long __RPC_FAR * status
    )
/*++

Routine Description:

    This is the management code corresponding to the
    rpc_mgmt_stop_server_listening remote operation.

--*/
{
    //
    // If the auth fn returns false, the op is denied.
    //
    if ( (*MgmtAuthorizationFn)(binding, RPC_C_MGMT_STOP_SERVER_LISTEN, status)
          == 0 )
        {
        if (0 == *status || RPC_S_OK == *status)
            {
            *status = RPC_S_ACCESS_DENIED;
            }

        return;
        }

    // N.B. RpcMgmtStopServerListening just flags the global
    // server as not listening. There is no danger of deadlock

    *status = RpcMgmtStopServerListening(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\testhlp.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1991 - 1999
//
//  File:       testhlp.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

                      Microsoft OS/2 LAN Manager
                   Copyright(c) Microsoft Corp., 1990

-------------------------------------------------------------------- */
/* --------------------------------------------------------------------

File : testhlp.cxx

Description :

These are the operating system specific helper routines for NT.  This 
isolates all of the operating system specific stuff from the testing
code.

History :

mikemon    01-14-91    Created this file.

-------------------------------------------------------------------- */

#include <ntos2.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <testhlp.hxx>

void
TestHlpResumeThread (
    int Thread
    )
{
    ULONG SuspendCount;
    
    NtResumeThread((HANDLE) Thread,&SuspendCount);
}

int
TestHlpCurrentThread (
    )
{
    TEB * pTeb;
    OBJECT_ATTRIBUTES ObjectAttributes;
    void * Thread;
    
    InitializeObjectAttributes(&ObjectAttributes,(PSTRING) 0,0,(HANDLE) 0,0);
    
    pTeb = NtCurrentTeb();
    NtOpenThread(&Thread,THREAD_ALL_ACCESS,&ObjectAttributes,
                    &(pTeb->ClientId));
    return((int) Thread);
}

void
TestHlpSuspendThread (
    int Thread
    )
{
    ULONG SuspendCount;
    
    NtSuspendThread((HANDLE) Thread,&SuspendCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\swmr.cxx ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    SWMR.cxx

Abstract:

    Implementation of Single Writer Multiple Readers lock.

Author:

    Kamen Moutafov    [KamenM]

Revision History:

    KamenM      Aug 2000    Created

Notes:
    Mechanism: Single Writer Multiple Reader Lock (SWMRLock)
    Design Goals: 
        1. Low resource usage for unused locks (i.e. one
        is embedded in each context handle) in the common case.
        2. Fairness in dispatching, including conversions from
        shared to exclusive and vice versa.
        3. Decent performance in the common case.
        4. Efficient handling of convoys
        5. Ability to claim the lock from one thread and release
        it from another.
    Design non-goals:
        1. Good throughput when multiple threads claim the lock.

    Description:
        The SWMRLock contains one mini spin lock, and a queue
        of waiters. The spin lock is used to synchronize few
        enqueue/dequeue operations. The queue is used to keep
        all claimants of the lock, and to wake up the next
        waiter when necessary.

    Scenarios:
        1. Multiple synchronized sync callers (writers). They will 
        borrow the thread event, and will make two interlocks to 
        get it.
        2. Multiple non-synchronized sync/async callers (readers). 
        They will use the cached waiter - 0 events, two interlocks 
        to get it.
        3. Multiple non-synchronized sync/async callers (readers) 
        followed by one synchronzied sync caller (writer). All readers
        will use the cached waiter, and the sync writer who destroys
        the context handle will borrow the thread event.

    Data Structures:
        Generic state:
                    *****************
                    *               *
                    *    SWMRLock   *
                    *               *
                    *****************
                       |        |
           FirstWaiter |        |   LastWaiter & ~StateMask
           +-----------+        +-------------------+
           |                                        |
           |                                        |
           V                                        V
    /////////////////                       /////////////////////
    /               /  Next          Next   /                   /
    /   SWMRWaiter  / -----> ...   -------->/    SWMRWaiter     /
    /               /                       /                   /
    /////////////////                       /////////////////////

        Scenario 1:
                    *****************
                    *               *
                    *    SWMRLock   *
                    *               *
                    *****************
                       |        |
           FirstWaiter |        |   LastWaiter & ~StateMask (LastWaiter = Pointer | LastWriter)
           +-----------+        +-------------------+
           |                                        |
           |                                        |
           V                                        V
    /////////////////                       /////////////////////
    /               /                       /                   /
    /     Writer    /                       /       Writer      /
    /               /                       /                   /
    / Flags:        /                       / Flags:            /
    /  swmrwtWriter /                       /  swmrwtWriter     /
    /  | OwnLock    /                       /                   /
    / RefCount: 1   /  Next          Next   / RefCount: 1       /
    / Next:         / -----> ...   -------->/ Next: NULL        /
    / hEvent: EVENT /                       / hEvent: EVENT     /
    /  or NULL      /                       /                   /
    /               /                       /                   /
    /////////////////                       /////////////////////

        Scenario 2:
                    *****************
                    *               *
                    *    SWMRLock   *
                    *               *
                    *****************
                       |
                       | FirstWaiter
                       | == LastWaiter (LastWaiter = Pointer | LastReader)
                       |
                       |
                       |
                       V
                /////////////////
                /               /
                /     Reader    /
                /               /
                / Flags:        /
                /  swmrwtReader /
                /  | OwnLock    /
                / RefCount: N   /
                / Next: NULL    /
                / hEvent: NULL  /
                /               /
                /////////////////

        Scenario 3:
                    *****************
                    *               *
                    *    SWMRLock   *
                    *               *
                    *****************
                       |        |
           FirstWaiter |        |   LastWaiter & ~StateMask (LastWaiter = Pointer | LastWriter)
           +-----------+        +-------------------+
           |                                        |
           |                                        |
           V                                        V
    /////////////////                       /////////////////////
    /               /                       /                   /
    /     Reader    /                       /       Writer      /
    /               /                       /                   /
    / Flags:        /                       / Flags:            /
    /  swmrwtReader /                       /  swmrwtWriter     /
    /  | OwnLock    /                       /                   /
    / RefCount: N   /         Next          / RefCount: 1       /
    / Next:         / --------------------->/ Next: NULL        /
    / hEvent: EVENT /                       / hEvent: EVENT     /
    /  or NULL      /                       /                   /
    /               /                       /                   /
    /////////////////                       /////////////////////

--*/

// undef this to get unit tests for SWMR
// #define _TEST_SWMR_

#include <precomp.hxx>

#if defined(_TEST_SWMR_)
extern "C" {
#include <rpcperf.h>
#include <rpcrt.h>

void Test (void);
extern long Clients;
}

HANDLE ProcessHeap;

void *
__cdecl
operator new (
    IN size_t size
    )
{
    return(RtlAllocateHeap(ProcessHeap, 0, size));
}

void
__cdecl
operator delete (
    IN void * obj
    )
{
    RtlFreeHeap(ProcessHeap, 0, obj);
}


#define _NOT_COVERED_ (0)
#endif

#include <swmr.hxx>

void
SpinOrYield (
    IN OUT BOOL *fNonFirstIteration,
    IN SWMRWaiterQueue *Queue
    )
{
    int i;

#if defined(_TEST_SWMR_)
    if ((2 > 1) && (*fNonFirstIteration == FALSE))
#else
    if ((gNumberOfProcessors > 1) && (*fNonFirstIteration == FALSE))
#endif
        {
        for (i = 0; i < 2000; i ++)
            {
            if (Queue->GetLastWaiterState() == SWMRWaiterQueue::Free)
                return;
            }
        }
    else
        {
        Sleep (10);
        }

    *fNonFirstIteration = TRUE;
}

#if defined(_TEST_SWMR_)
long TestCounter = 0;
#endif

SWMRWaiter *
SWMRLock::AllocateWaiter (
    IN SWMRWaiterType WaiterType,
    IN BOOL fEventRequired
    )
/*++

Routine Description:

    Allocates a waiter. First, it tries the cache. If this
    fails, it does the allocation.

Arguments:
    WaiterType - whether the needed waiter is a reader or writer
    fEventRequired - if non-FALSE, the event is required and must
    be allocated before return. Otherwise, the event may not be allocated

Return Value:
    The new waiter. If NULL, either a waiter could not be allocated or its
    event couldn't be initialized.

--*/
{
    SWMRWaiter *NewWaiter;
    RPC_STATUS RpcStatus;

    if (CachedWaiterAvailable)
        {
        if (InterlockedCompareExchange(&CachedWaiterAvailable, 0, 1) == 1)
            {
            RpcStatus = CachedWaiter.Initialize(WaiterType, fEventRequired);
            if (RpcStatus != RPC_S_OK)
                return NULL;
            return &CachedWaiter;
            }
        }

    NewWaiter = new SWMRWaiter;
    if (NewWaiter)
        {
        RpcStatus = NewWaiter->Initialize(WaiterType, fEventRequired);
        if (RpcStatus != RPC_S_OK)
            {
            delete NewWaiter;
            NewWaiter = NULL;
            }
        }
    return NewWaiter;
}

void
SWMRLock::FreeWaiter (
    IN SWMRWaiter *Waiter
    )
/*++

Routine Description:

    Frees a waiter.

Arguments:
    Waiter - the waiter to be freed. This cannot be the cached waiter.

Return Value:

--*/
{
    ASSERT(Waiter);

    Waiter->FreeWaiterData();

    delete Waiter;
}

void
SWMRLock::StoreOrFreeSpareWaiter (
    IN OUT SWMRWaiter **WaiterCache OPTIONAL,
    IN SWMRWaiter *Waiter OPTIONAL
    )
/*++

Routine Description:

    Given an optional waiter cache, this code decides what
    to do with a waiter that is no longer used. The policy is
    as follows:
    If the waiter is NULL, return.
    If the waiter is the cached waiter, mark the cached waiter
    as available.
    If it is not the cached waiter, and there is a waiter cache
    passed, store the waiter.
    Else, free the waiter.

Arguments:
    WaiterCache - The waiter cache.
    Waiter - waiter to be freed.

Return Value:

--*/
{
    if (Waiter)
        {
        if (Waiter != &CachedWaiter)
            {
            if (WaiterCache && (*WaiterCache == NULL))
                {
                *WaiterCache = Waiter;
                }
            else
                {
                FreeWaiter(Waiter);
                }
            }
        else
            {
            ASSERT(CachedWaiterAvailable == 0);
            InterlockedExchange(&CachedWaiterAvailable, 1);
            }
        }
}

void
SWMRLock::LockSharedOnLastReader (
    IN OUT SWMRWaiter **WaiterCache OPTIONAL,
    IN OUT SWMRWaiter *OldWaiter,
    IN OUT SWMRWaiter *AllocatedWaiter
    )
/*++

Routine Description:

    Does the locking for shared access if the last waiter is a reader

Arguments:
    WaiterCache - See WaiterCache in LockSharedOrExclusive
    OldWaiter - the OldWaiter obtained when the lock was taken
    AllocatedWaiter - new waiter available for use. In this case,
    we only free it.

Return Value:

Notes:
    The function is called with the lock held. It must release the lock
        as soon as it can.

--*/
{
    SWMRWaiter *LastWaiter;

    // here we know we're adding a reader to waiting readers
    LastWaiter = RemoveReaderStateFromWaiterPtr(OldWaiter);

    ASSERT((LastWaiter->Flags & SWMRWaiter::WaiterTypeMask) == swmrwtReader);
    ASSERT(LastWaiter->Next == NULL);
    ASSERT(LastWaiter->RefCount >= 1);

    LastWaiter->RefCount ++;
    if ((LastWaiter->Flags & SWMRWaiter::OwnLockMask) == 0)
        {
        UnlockAndCommit(OldWaiter);

        // if we have created a waiter, try to cache it or free it
        StoreOrFreeSpareWaiter(WaiterCache, AllocatedWaiter);

        // the last waiter on the queue doesn't own the lock -
        // wait on it. We know the block can't go away because
        // we have added our refcount. On return, we will
        // own the lock
        ASSERT(LastWaiter->hEvent);

        WaitForSingleObject(LastWaiter->hEvent, INFINITE);
        }
    else
        {
        UnlockAndCommit(OldWaiter);

        // if we have created a waiter, try to cache it or free it
        StoreOrFreeSpareWaiter(WaiterCache, AllocatedWaiter);
        }
}

void
SWMRLock::LockSharedOrExclusiveOnLastWriter (
    IN OUT SWMRWaiter **WaiterCache OPTIONAL,
    IN OUT SWMRWaiter *OldWaiter,
    IN OUT SWMRWaiter *AllocatedWaiter,
    IN ULONG_PTR DesiredState
    )
/*++

Routine Description:

    Does the locking for both shared and exclusive access if the last waiter 
    is a writer

Arguments:
    WaiterCache - See WaiterCache in LockSharedOrExclusive
    OldWaiter - the OldWaiter obtained when the lock was taken
    AllocatedWaiter - new waiter available for use. In this case,
    we only free it.
    DesiredState - the state of the new last waiter

Return Value:

Notes:
    The function is called with the lock held. It must release the lock
        as soon as it can.

--*/
{
    SWMRWaiter *LastWaiter;

    ASSERT(AllocatedWaiter != NULL);

    // here we know we're adding a reader to writer
    LastWaiter = RemoveWriterStateFromWaiterPtr(OldWaiter);

    ASSERT((LastWaiter->Flags & SWMRWaiter::WaiterTypeMask) == swmrwtWriter);
    ASSERT(LastWaiter->Next == NULL);
    ASSERT(LastWaiter->RefCount == 1);
    ASSERT(LastWaiter != AllocatedWaiter);

    LastWaiter->Next = AllocatedWaiter;

    LastWaiter = SetStateInWaiterPtr(AllocatedWaiter, DesiredState);
    UnlockAndCommit(LastWaiter);

    if (WaiterCache)
        *WaiterCache = NULL;

    // Wait for it. On return, we will own the lock
    ASSERT(AllocatedWaiter->hEvent);

    WaitForSingleObject(AllocatedWaiter->hEvent, INFINITE);
}

void
SWMRLock::LockExclusiveOnLastReader (
    IN OUT SWMRWaiter **WaiterCache OPTIONAL,
    IN OUT SWMRWaiter *OldWaiter,
    IN OUT SWMRWaiter *AllocatedWaiter
    )
/*++

Routine Description:

    Does the locking for exclusive access if the last waiter is a reader

Arguments:
    WaiterCache - See WaiterCache in LockSharedOrExclusive
    OldWaiter - the OldWaiter obtained when the lock was taken
    AllocatedWaiter - new waiter available for use. In this case,
    we only free it.

Return Value:

Notes:
    The function is called with the lock held. It must release the lock
        as soon as it can.

--*/
{
    SWMRWaiter *LastWaiter;

    ASSERT(AllocatedWaiter != NULL);

    // here we know we're adding a writer to a reader
    LastWaiter = RemoveReaderStateFromWaiterPtr(OldWaiter);

    ASSERT((LastWaiter->Flags & SWMRWaiter::WaiterTypeMask) == swmrwtReader);
    ASSERT(LastWaiter->Next == NULL);
    ASSERT(LastWaiter->RefCount >= 1);
    ASSERT(LastWaiter != AllocatedWaiter);

    LastWaiter->Next = AllocatedWaiter;

    LastWaiter = AddWriterStateInWaiterPtr(AllocatedWaiter);
    UnlockAndCommit(LastWaiter);

    if (WaiterCache)
        *WaiterCache = NULL;

    // Wait for it. On return, we will own the lock
    ASSERT(AllocatedWaiter->hEvent);
    WaitForSingleObject(AllocatedWaiter->hEvent, INFINITE);
}

RPC_STATUS 
SWMRLock::LockSharedOrExclusive (
    IN OUT SWMRWaiter **WaiterCache OPTIONAL,
    IN SWMRWaiterType WaiterType,
    IN ULONG_PTR DesiredState
    )
/*++

Routine Description:

    Worker function that does most of the work association
    with claiming a lock for shared or exclusive access. In fact,
    it does all the work apart from hanlding a reader after writer,
    reader after reader, writer after reader and writer after writer

Arguments:
    WaiterCache - An optional parameter allowing caching of waiter blocks.
        If WaiterCache == NULL, no caching will be done.
        If WaiterCache != NULL, but *WaiterCache == NULL, *WaiterCache
        may be set to the new Waiter block. If *WaiterCache != NULL,
        the cached value will be used. Its hEvent may or may not be set. If
        not set and needed, this routine may fill it in.
    WaiterType - the type of the caller. If this is swmrwtReader, DesiredState
        must be LastReader and vice versa. If this is swmrwtWriter, DesiredState
        must ve LastWriter and vice versa. We could have done with one argument
        only, except we want to save one if.
    DesiredState - LastReader or LastWriter

Return Value:
    RPC_S_OK or RPC_S_* for error

--*/
{
    ULONG_PTR LastWaiterState;
    SWMRWaiter *Waiter;
    SWMRWaiter *OldWaiter;
    SWMRWaiter *LastWaiter;
    BOOL fNonFirstIteration = FALSE;
    RPC_STATUS RpcStatus;

    ASSERT((DesiredState == LastReader) || (DesiredState == LastWriter));
    if (DesiredState == LastReader)
        {
        ASSERT(WaiterType == swmrwtReader);
        }
    else
        {
        ASSERT(WaiterType == swmrwtWriter);
        }

    if (WaiterCache)
        {
        Waiter = *WaiterCache;
        if (Waiter)
            {
            *WaiterCache = NULL;
            Waiter->Initialize(WaiterType, FALSE);
            }
        }
    else
        {
        Waiter = NULL;
        }

    while (TRUE)
        {
        // on entry to this loop:
        // Waiter may be NULL, or non-NULL. If non-NULL,
        // its RefCount, Next and WaiterType are
        // initialized. If hEvent is non-NULL, it must
        // be valid too. (Flags & OwnLockMask) is 0

        if (Waiter)
            {
            ASSERT((Waiter->Flags & SWMRWaiter::OwnLockMask) == 0);
            }

        LastWaiterState = GetLastWaiterState();

        switch (LastWaiterState)
            {
            case Free:
                if (!Waiter)
                    {
                    Waiter = AllocateWaiter(WaiterType, FALSE);
                    if (!Waiter)
                        {
                        return RPC_S_OUT_OF_MEMORY;
                        }
                    }

                // we know we have a waiter here
                OldWaiter = Lock();
                if (!VerifyState(OldWaiter, Free))
                    {
                    UnlockAndCommit(OldWaiter);
                    // the state has changed while we were switching - loop around
                    continue;
                    }      

                Waiter->Flags |= SWMRWaiter::OwnLock;

                SetFirstWaiter(Waiter);
                LastWaiter = SetStateInWaiterPtr(Waiter, DesiredState);
                UnlockAndCommit(LastWaiter);

                if (WaiterCache)
                    *WaiterCache = NULL;

                if (WaiterType == swmrwtWriter)
                    SetLastWriterThreadId();

                return RPC_S_OK;

                // no break necessary
                // break;

            case LastReader:
                if (WaiterType == swmrwtReader)
                    {
                    OldWaiter = Lock();
                    if (!VerifyState(OldWaiter, LastReader))
                        {
                        UnlockAndCommit(OldWaiter);
                        // the state has changed while we were switching - loop around
                        continue;
                        }

                    LockSharedOnLastReader(WaiterCache, OldWaiter, Waiter);

                    // cache is consumed or freed after LockSharedOnLastReader 

                    LastWaiter = RemoveReaderStateFromWaiterPtr(OldWaiter);
                    }
                else
                    {
                    if (!Waiter)
                        {
                        Waiter = AllocateWaiter(WaiterType, TRUE);
                        if (!Waiter)
                            {
                            return RPC_S_OUT_OF_MEMORY;
                            }
                        }
                    else
                        {
                        RpcStatus = Waiter->InitializeEventIfNecessary();
                        if (RpcStatus != RPC_S_OK)
                            {
                            StoreOrFreeSpareWaiter(WaiterCache, Waiter);
                            return RpcStatus;
                            }
                        }

                    OldWaiter = Lock();
                    if (!VerifyState(OldWaiter, LastReader))
                        {
                        UnlockAndCommit(OldWaiter);
                        // the state has changed while we were switching - loop around
                        continue;
                        }

                    LockExclusiveOnLastReader(WaiterCache,
                        OldWaiter,
                        Waiter);

                    // the cache has been consumed and indicated as such

                    LastWaiter = Waiter;
                    SetLastWriterThreadId();
                    }

                // on return, we must own the lock
                ASSERT((LastWaiter->Flags & SWMRWaiter::OwnLockMask) == SWMRWaiter::OwnLock);

                SetFirstWaiter(LastWaiter);

                return RPC_S_OK;

                // break is not needed
                // break;

            case LastWriter:
                // the lock is owned by a writer - we must queue ourselves.
                // For this, we need a waiter block
                if (!Waiter)
                    {
                    Waiter = AllocateWaiter(WaiterType,
                        TRUE);
                    if (!Waiter)
                        {
                        return RPC_S_OUT_OF_MEMORY;
                        }
                    }
                else
                    {
                    RpcStatus = Waiter->InitializeEventIfNecessary();
                    if (RpcStatus != RPC_S_OK)
                        {
                        StoreOrFreeSpareWaiter(WaiterCache, Waiter);
                        return RpcStatus;
                        }
                    }

                OldWaiter = Lock();
                if (!VerifyState(OldWaiter, LastWriter))
                    {
                    UnlockAndCommit(OldWaiter);
                    // the state has changed while we were switching - loop around
                    continue;
                    }

                LockSharedOrExclusiveOnLastWriter(WaiterCache,
                    OldWaiter,
                    Waiter,
                    DesiredState);

                // the cache has been consumed and indicated as such

                // on return, we must own the lock
                ASSERT((Waiter->Flags & SWMRWaiter::OwnLockMask) == SWMRWaiter::OwnLock);

                SetFirstWaiter(Waiter);

                if (WaiterType == swmrwtWriter)
                    SetLastWriterThreadId();

                return RPC_S_OK;

                // no need for break
                // break

            case Locked:
                SpinOrYield(&fNonFirstIteration, this);
                break;

            // no need for default
            // default:
            }
        }
}

void
SWMRLock::UnlockShared (
    IN OUT SWMRWaiter **WaiterCache OPTIONAL
    )
/*++

Routine Description:

    Releases a lock obtained for shared access.

Arguments:
    WaiterCache - An optional parameter allowing caching of waiter blocks.
        If WaiterCache == NULL, no caching will be done.
        If WaiterCache != NULL, but *WaiterCache == NULL, *WaiterCache
        may be set to the new Waiter block. If *WaiterCache != NULL,
        and a waiter block is produces as a result of the operation, it will
        be freed.

Return Value:

--*/
{
    SWMRWaiter *OldWaiter;
    SWMRWaiter *FirstWaiter;
    long NewRefCount;
    SWMRWaiter *Next;
    HANDLE hEvent;

    FirstWaiter = GetFirstWaiter();
    ASSERT(FirstWaiter != NULL);

    OldWaiter = Lock();

    NewRefCount = -- FirstWaiter->RefCount;

    if (NewRefCount == 0)
        {
        Next = FirstWaiter->Next;
        if (Next)
            {
            Next->Flags |= SWMRWaiter::OwnLock;
            hEvent = Next->hEvent;
            ASSERT(hEvent);

            ASSERT((Next->Flags & SWMRWaiter::WaiterTypeMask) == swmrwtWriter);

            SetFirstWaiter(Next);

            UnlockAndCommit(OldWaiter);
            StoreOrFreeSpareWaiter(WaiterCache, FirstWaiter);
            SetEvent(hEvent);
            }
        else
            {
            UnlockAndCommit(NULL);
            StoreOrFreeSpareWaiter(WaiterCache, FirstWaiter);
            }
        }
    else
        {
        UnlockAndCommit(OldWaiter);
        }
}

void
SWMRLock::UnlockExclusive (
    IN OUT SWMRWaiter **WaiterCache OPTIONAL
    )
/*++

Routine Description:

    Releases a lock obtained for exclusive access.

Arguments:
    WaiterCache - An optional parameter allowing caching of waiter blocks.
        If WaiterCache == NULL, no caching will be done.
        If WaiterCache != NULL, but *WaiterCache == NULL, *WaiterCache
        may be set to the new Waiter block. If *WaiterCache != NULL,
        and a waiter block is produces as a result of the operation, it will
        be freed.

Return Value:

--*/
{
    SWMRWaiter *OldWaiter;
    SWMRWaiter *FirstWaiter;
    SWMRWaiter *Next;

    FirstWaiter = GetFirstWaiter();
    ASSERT(FirstWaiter != NULL);

    OldWaiter = Lock();

    Next = FirstWaiter->Next;
    if (Next)
        {
        Next->Flags |= SWMRWaiter::OwnLock;

        SetFirstWaiter(Next);

        UnlockAndCommit(OldWaiter);
        StoreOrFreeSpareWaiter(WaiterCache, FirstWaiter);
        ASSERT(Next->hEvent);
        SetEvent(Next->hEvent);
        }
    else
        {
        UnlockAndCommit(NULL);
        StoreOrFreeSpareWaiter(WaiterCache, FirstWaiter);
        }
}

void
SWMRLock::Unlock (
    IN OUT SWMRWaiter **WaiterCache OPTIONAL
    )
/*++

Routine Description:

    Releases a lock obtained for any access.

Arguments:
    WaiterCache - An optional parameter allowing caching of waiter blocks.
        If WaiterCache == NULL, no caching will be done.
        If WaiterCache != NULL, but *WaiterCache == NULL, *WaiterCache
        may be set to the new Waiter block. If *WaiterCache != NULL,
        and a waiter block is produces as a result of the operation, it will
        be freed.

Return Value:

--*/
{
    SWMRWaiter *OldWaiter;
    SWMRWaiter *FirstWaiter;
    SWMRWaiter *Next;

    FirstWaiter = GetFirstWaiter();
    ASSERT(FirstWaiter != NULL);

    if ((FirstWaiter->Flags & SWMRWaiter::WaiterTypeMask) == swmrwtReader)
        {
        UnlockShared(WaiterCache);
        }
    else
        {
        ASSERT((FirstWaiter->Flags & SWMRWaiter::WaiterTypeMask) == swmrwtWriter);
        UnlockExclusive(WaiterCache);
        }
}

RPC_STATUS
SWMRLock::ConvertToExclusive (
    IN OUT SWMRWaiter **WaiterCache OPTIONAL
    )
/*++

Routine Description:

    Converts a shared lock to exclusive. In the process it *does not*
    release the shared lock (except for case described below in Return Value).
    This means that it is legal for the caller
    to walk a list in shared mode, then decide to delete an element
    and convert it to exclusive. If it gets ERROR_MORE_WRITES, it has the lock,
    but a writer may have intervened and any data structure protected by the lock
    may have been modified. In this case the thread must protect itself 
    appropriately. If it gets RPC_S_OK then there is no danger of other writers 
    coming in and changing the data structure in any way

Arguments:
    WaiterCache - An optional parameter allowing caching of waiter blocks.
        If WaiterCache == NULL, no caching will be done.
        If WaiterCache != NULL, but *WaiterCache == NULL, *WaiterCache
        may be set to the new Waiter block. If *WaiterCache != NULL,
        the cached value will be used. Its hEvent must be set

Return Value:
    RPC_S_OK or RPC_S_* for error. If RPC_S_CANNOT_SUPPORT is returned,
    this means the lock is already owned exclusively. It is safe
    for multiple threads to try to convert the same lock ownership to exclusive.
    The only peculiarity is that if two threads try to get convert the same reader
    lock to exclusive, one has to lose the reader lock, and it will get 
    ERROR_MORE_WRITES. The other will get RPC_S_OK, and it knows it hasn't lost
    the reader lock.

--*/
{
    SWMRWaiter *CurrentOwner = GetFirstWaiter();
    SWMRWaiter *OldWaiter;
    SWMRWaiter *LastWaiter;
    SWMRWaiter *AllocatedWaiter = NULL;
    RPC_STATUS RpcStatus;
    SWMRWaiter *NextOwner;

    // make sure the current lock is not already in exclusive mode
    if ((CurrentOwner->Flags & SWMRWaiter::WaiterTypeMask) == swmrwtWriter)
        {
        return RPC_S_CANNOT_SUPPORT;
        }

    while (TRUE)
        {

        ASSERT(CurrentOwner->RefCount > 0);

        if (CurrentOwner->RefCount == 1)
            {
            OldWaiter = Lock();

            if (CurrentOwner->RefCount == 1)
                {
                NextOwner = CurrentOwner->Next;
                // if there is next, it's flags are either swmrwtReader, swmrwtWriter,
                // or swmrwtWriter | WriterInsertedBefore
                if (NextOwner)
                    {
                    ASSERT(
                            (NextOwner->Flags == swmrwtReader)
                            || (NextOwner->Flags == swmrwtWriter)
                            || (NextOwner->Flags == (swmrwtWriter | SWMRWaiter::WriterInsertedBefore))
                          );

                    // we need to raise the flag only for next writers who don't have the flag raised
                    if (NextOwner->Flags == swmrwtWriter)
                        {
                        NextOwner->Flags = swmrwtWriter | SWMRWaiter::WriterInsertedBefore;
                        }
                    }
                CurrentOwner->Flags = swmrwtWriter | SWMRWaiter::OwnLock;
                LastWaiter = RemoveStateFromWaiterPtr(OldWaiter);
                if (LastWaiter == CurrentOwner)
                    {
                    LastWaiter = AddWriterStateInWaiterPtr(LastWaiter);
                    UnlockAndCommit(LastWaiter);
                    }
                else
                    {
                    UnlockAndCommit(OldWaiter);
                    }

                // if we have spun around, and a waiter has been allocated,
                // make sure it is freed
                StoreOrFreeSpareWaiter(WaiterCache, AllocatedWaiter);

                SetLastWriterThreadId();

                // get out of the loop
                break;
                }

            // somebody beat us to the punch. Just unlock and loop around
            UnlockAndCommit(OldWaiter);

            }
        else
            {
            // there are multiple readers on this waiter. We need to allocate
            // a new block to wait on.
            if (!AllocatedWaiter)
                {
                if (WaiterCache)
                    {
                    AllocatedWaiter = *WaiterCache;
                    if (AllocatedWaiter)
                        {
                        *WaiterCache = NULL;
                        RpcStatus = AllocatedWaiter->Initialize(swmrwtWriter, TRUE);
                        if (RpcStatus != RPC_S_OK)
                            {
                            *WaiterCache = AllocatedWaiter;
                            return RpcStatus;
                            }
                        }
                    }

                // if we there was no cache, or we found nothing in the cache
                // create a waiter
                if (!AllocatedWaiter)
                    {
                    AllocatedWaiter = AllocateWaiter(swmrwtWriter, TRUE);
                    if (!AllocatedWaiter)
                        {
                        return RPC_S_OUT_OF_MEMORY;
                        }
                    }
                }
            else
                {
                RpcStatus = AllocatedWaiter->InitializeEventIfNecessary();
                if (RpcStatus != RPC_S_OK)
                    {
                    StoreOrFreeSpareWaiter(WaiterCache, AllocatedWaiter);
                    return RpcStatus;
                    }
                }

            OldWaiter = Lock();
            if (CurrentOwner->RefCount > 1)
                {
                // form a separate waiter block and queue it after the current
                // reader block
                AllocatedWaiter->Next = CurrentOwner->Next;
                CurrentOwner->Next = AllocatedWaiter;
                CurrentOwner->RefCount --;
                ASSERT(CurrentOwner->RefCount >= 1);
                ASSERT(CurrentOwner->Flags == (swmrwtReader | SWMRWaiter::OwnLock));
                LastWaiter = RemoveStateFromWaiterPtr(OldWaiter);

                // if we were the last waiter ...
                if (LastWaiter == CurrentOwner)
                    {
                    // ... update the last to point to us
                    LastWaiter = AddWriterStateInWaiterPtr(AllocatedWaiter);
                    UnlockAndCommit(LastWaiter);
                    }
                else
                    {
                    ASSERT (AllocatedWaiter->Next != NULL);
                    // if the next waiter is a writer, indicate to it
                    // that we have moved in before it. This allows
                    // arbitraging b/n multiple converts from shared
                    // to exclusive. Pure writers will ignore this flag
                    if (AllocatedWaiter->Next->Flags == swmrwtWriter)
                        {
                        AllocatedWaiter->Next->Flags = swmrwtWriter | SWMRWaiter::WriterInsertedBefore;
                        }
                    else
                        {
                        ASSERT((AllocatedWaiter->Next->Flags & SWMRWaiter::WaiterTypeMask) != swmrwtWriter);
                        }
                    // just unlock
                    UnlockAndCommit(OldWaiter);
                    }

                ASSERT(AllocatedWaiter->hEvent);
                WaitForSingleObject(AllocatedWaiter->hEvent, INFINITE);

                // we must own the lock here
                ASSERT((AllocatedWaiter->Flags == (SWMRWaiter::OwnLock | swmrwtWriter))
                    || (AllocatedWaiter->Flags == (SWMRWaiter::OwnLock | swmrwtWriter | SWMRWaiter::WriterInsertedBefore)));

                // indicate the cache has been consumed
                if (WaiterCache)
                    {
                    *WaiterCache = NULL;
                    }

                SetLastWriterThreadId();

                if (AllocatedWaiter->Flags 
                    == (SWMRWaiter::OwnLock | swmrwtWriter | SWMRWaiter::WriterInsertedBefore))
                    {
                    return ERROR_MORE_WRITES;
                    }
                else
                    {
                    return RPC_S_OK;
                    }
                }
            else
                {
                // this has become a single reader entry (us).
                // just convert it to a writer - release
                // the lock and loop around
                UnlockAndCommit(OldWaiter);
                }
            }
        }

    return RPC_S_OK;
}

RPC_STATUS
SWMRLock::ConvertToShared (
    IN OUT SWMRWaiter **WaiterCache OPTIONAL,
    IN BOOL fSyncCacheUsed
    )
/*++

Routine Description:

    Converts an exclusive lock to shared. In the process it *does not*
    release the shared lock. This means that it is legal for the caller
    to walk a list in exclusive mode, then decide to move to shared mode
    so that new readers can come in, and it is safe to assume that no
    new writer has intervened in the meantime.

Arguments:
    WaiterCache - An optional parameter allowing caching of waiter blocks.
        If WaiterCache == NULL, no caching will be done.
        If WaiterCache != NULL, but *WaiterCache == NULL, *WaiterCache
        may be set to the new Waiter block. If *WaiterCache != NULL,
        the cached value will be used. Its hEvent must be set
    fSyncCacheUsed - if a caller was using sync cache (i.e. a thread tied
        or a call tied cache), it may specify non-FALSE to this parameter
        to cause this function to allocate a new waiter block if the waiter
        block may be needed by other waiters.
        Note that whether the cache is sync depends on previous calls to
        LockShared/LockExclusive/ConvertToExclusive. If you don't have
        enough information to determine what those calls were using,
        always specify TRUE. This will always work. FALSE can be used
        as an additional optimization if we know the history of our waiter
        block.

Return Value:
    RPC_S_OK or RPC_S_* for error. If RPC_S_CANNOT_SUPPORT is returned,
    this means the lock is already owned in shared mode. It is safe
    for multiple threads to try to convert the same lock ownership to shared.

--*/
{
    SWMRWaiter *CurrentOwner = GetFirstWaiter();
    SWMRWaiter *OldWaiter;
    SWMRWaiter *LastWaiter;
    SWMRWaiter *AllocatedWaiter = NULL;
    SWMRWaiter *NextWaiter;
    HANDLE hEvent;

    // make sure the current lock is not already in shared mode
    if ((CurrentOwner->Flags & SWMRWaiter::WaiterTypeMask) == swmrwtReader)
        return RPC_S_CANNOT_SUPPORT;

    if (fSyncCacheUsed)
        {
        // you cannot claim that you use a sync cache if you don't have
        // any cache at all
        ASSERT(WaiterCache != NULL);
        }

    ASSERT(CurrentOwner->RefCount == 1);

    while (TRUE)
        {
        NextWaiter = CurrentOwner->Next;

        // we have three cases - last owner, non-last owner with following
        // readers and non-last owner with following writers
        if (NextWaiter == NULL)
            {
            // if a sync cache was used, we must return whatever we took
            // out of the cache, and recreate a waiter for the cache,
            // because we're going to become last readers, and other
            // readers may join, causing lifetime issues with our cached
            // entry if it is sync
            if (fSyncCacheUsed && (*WaiterCache == NULL) && (CurrentOwner != &CachedWaiter))
                {
                if (!AllocatedWaiter)
                    {
                    AllocatedWaiter = AllocateWaiter(swmrwtReader, FALSE);
                    if (!AllocatedWaiter)
                        {
                        return RPC_S_OUT_OF_MEMORY;
                        }
                    AllocatedWaiter->Flags = swmrwtReader | SWMRWaiter::OwnLock;
                    }

                LastWaiter = AddReaderStateInWaiterPtr(AllocatedWaiter);
                }
            else
                {
                LastWaiter = AddReaderStateInWaiterPtr(CurrentOwner);
                }

            OldWaiter = Lock();
            NextWaiter = CurrentOwner->Next;
            if (NextWaiter)
                {
                // somebody managed to queue a waiter before we converted -
                // unlock and loop around
                UnlockAndCommit(OldWaiter);
                }
            else
                {
                if (AllocatedWaiter)
                    {
                    // the first waiter has changed - update it
                    SetFirstWaiter(AllocatedWaiter);
                    }
                else
                    {
                    // update the flags of the old waiter
                    CurrentOwner->Flags = swmrwtReader | SWMRWaiter::OwnLock;
                    }

                UnlockAndCommit(LastWaiter);

                if (AllocatedWaiter)
                    {
                    ASSERT(CurrentOwner != &CachedWaiter);
                    // we were asked to free up a previous cached item
                    *WaiterCache = CurrentOwner;
                    }

                // break out of the loop
                break;
                }
            }
        else if ((NextWaiter->Flags & SWMRWaiter::WaiterTypeMask) == swmrwtReader)
            {
            // we need to take the lock to avoid races with threads
            // trying to queue themselves after the next waiter
            OldWaiter = Lock();

            // here we effectively join the next waiter and discard the current
            // waiter block. This allows
            // us to free the current item to the cache, ensuring good
            // performance for sync caches
            NextWaiter->Flags |= SWMRWaiter::OwnLock;
            NextWaiter->RefCount ++;
            hEvent = NextWaiter->hEvent;
            ASSERT(hEvent);

            SetFirstWaiter(NextWaiter);

            UnlockAndCommit(OldWaiter);

            SetEvent(hEvent);

            StoreOrFreeSpareWaiter(WaiterCache, CurrentOwner);
            StoreOrFreeSpareWaiter(WaiterCache, AllocatedWaiter);

            break;
            }
        else
            {
            ASSERT((NextWaiter->Flags == swmrwtWriter)
                || (NextWaiter->Flags == (swmrwtWriter | SWMRWaiter::WriterInsertedBefore)));

            // We must reset the flags. This is because there may be pending
            // WriterInsertedBefore. We want to clear this so that we don't
            // return ERROR_MORE_WRITES if they convert back to exclusive and
            // find this stale flag
            CurrentOwner->Flags = SWMRWaiter::OwnLock | swmrwtReader;

            StoreOrFreeSpareWaiter(WaiterCache, AllocatedWaiter);

            break;
            }
        }

    return RPC_S_OK;
}

#if defined(_TEST_SWMR_)
SWMRLock TestLock;

long TestCheck = 0;

HANDLE HoldEvent = NULL;
BOOL fHoldFlag = FALSE;
long HoldingThreadCount = 0;

DWORD WINAPI TestThreadProc (LPVOID )
{
    RPC_STATUS RpcStatus;
    long OldTestCheck;
    SWMRWaiter **WaiterCache;
    SWMRWaiter *CachedWaiter = NULL;
    int i, j;
    int RndNum;
    BOOL fReader;
    BOOL fSyncCache;

    RndNum = rand();
    if (RndNum % 2)
        {
        WaiterCache = NULL;
        }
    else
        {
        WaiterCache = &CachedWaiter;
        }

    RndNum = rand();
    // one out of 3 is writer
    if ((RndNum % 3) == 2)
        {
        fReader = FALSE;
        Dump("%d is a writer\n", GetCurrentThreadId());
        }
    else
        {
        fReader = TRUE;
        Dump("%d is a reader\n", GetCurrentThreadId());
        }

    for (; TestCounter < (signed)Iterations; )
        {
        if (fHoldFlag)
            {
            InterlockedIncrement(&HoldingThreadCount);
            WaitForSingleObject(HoldEvent, INFINITE);
            }

        if (fReader)
            {
            RpcStatus = TestLock.LockShared(WaiterCache);
            }
        else
            {
            RpcStatus = TestLock.LockExclusive(WaiterCache);
            }

        if (RpcStatus != RPC_S_OK)
            continue;

        // once in a while we will swap the reader to writer and vice versa
        if ((rand() % 17) == 0)
            {
            if (fReader)
                {
                // current reader. ConvertToExclusive. This can fail due to the
                // fault injection. Retry
                do
                    {
                    RpcStatus = TestLock.ConvertToExclusive(WaiterCache);
                    }
                while ((RpcStatus != RPC_S_OK) && (RpcStatus != ERROR_MORE_WRITES));
                fReader = FALSE;
                }
            else
                {
                if (WaiterCache)
                    {
                    fSyncCache = (rand() % 3) == 0;
                    }
                else
                    {
                    fSyncCache = FALSE;
                    }

                // current writer. ConvertToShared
                do
                    {
                    RpcStatus = TestLock.ConvertToShared(WaiterCache, fSyncCache);
                    }
                while (RpcStatus != RPC_S_OK);
                fReader = TRUE;
                }
            }

        if (fReader)
            {
            OldTestCheck = InterlockedIncrement(&TestCheck);
            ASSERT(OldTestCheck >= 1);
            if (OldTestCheck < 1)
                DebugBreak();
            }
        else
            {
            OldTestCheck = InterlockedCompareExchange(&TestCheck, 1, 0);
            ASSERT(OldTestCheck == 0);
            if (OldTestCheck != 0)
                DebugBreak();
            }

        TestCounter ++;

        if ((TestCounter % 100000) == 0)
            {
            // print something to screen
            Dump("%d: Test %ld\n", GetCurrentThreadId(), TestCounter);
            }

        for (i = 0; i < 50; i ++)
            {
            // random function call to prevent the compiler from
            // optimizing the loop away
            RndNum = GetCurrentThreadId();
            }

        if (fReader)
            {
            OldTestCheck = InterlockedDecrement(&TestCheck);
            ASSERT(OldTestCheck >= 0);
            if (OldTestCheck < 0)
                DebugBreak();
            }
        else
            {
            OldTestCheck = InterlockedCompareExchange(&TestCheck, 0, 1);
            if (OldTestCheck != 1)
                DebugBreak();
            ASSERT(OldTestCheck == 1);
            }

        if (fReader)
            {
            TestLock.UnlockShared(WaiterCache);
            }
        else
            {
            TestLock.UnlockExclusive(WaiterCache);
            }

        RndNum = rand() % 100;
        if (RndNum == 11)
            {
            Sleep(10);
            }
        }

    if (CachedWaiter)
        {
        TestLock.FreeWaiterCache(&CachedWaiter);
        }

    return 0;
}

void Test (void)
{
    int i;
    HANDLE hThread;
    int Retries;

    srand( GetTickCount() );
    HoldEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    ProcessHeap = GetProcessHeap();

    for (i = 0; i < Clients; i ++)
        {
        hThread = CreateThread(NULL, 0, TestThreadProc, NULL, 0, NULL);
        CloseHandle(hThread);
        }

    while (TRUE)
        {
        Sleep(rand());
        if (TestCounter >= (signed)Iterations)
            continue;

        Retries = 0;
        fHoldFlag = TRUE;
        while (HoldingThreadCount < Clients)
            {
            if (Retries > 3)
                {
                Dump("Threads did not pick up the hold command! Breaking ...\n");
                DebugBreak();
                ASSERT(0);
                }
            Sleep(50);
            Dump("Holding threads ...\n");
            Retries ++;
            }

        Dump("All threads checked in. Releasing ...\n");
        HoldingThreadCount = 0;
        fHoldFlag = FALSE;
        PulseEvent(HoldEvent);
        }
    
    Sleep(INFINITE);
}

#endif // _TEST_SWMR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\threads.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1990 - 1999
//
//  File:       threads.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

                      Microsoft OS/2 LAN Manager
                   Copyright(c) Microsoft Corp., 1990

-------------------------------------------------------------------- */
/* --------------------------------------------------------------------

File: threads.cxx

Description:

This file provides a system independent threads package for use on the
NT operating system.

History:
  5/24/90 [mikemon] File created.
  Kamen Moutafov (KamenM) Dec 99 - Feb 2000 - Support for cell debugging stuff

-------------------------------------------------------------------- */

#include <precomp.hxx>

#include <rpcuuid.hxx>
#include <binding.hxx>
#include <handle.hxx>
#include <hndlsvr.hxx>
#include <lpcpack.hxx>
#include <lpcsvr.hxx>
#include <ProtBind.hxx>
#include <lpcclnt.hxx>

unsigned long DefaultThreadStackSize = 0;

void
PauseExecution (
    unsigned long milliseconds
    )
{

    Sleep(milliseconds);

}


DLL::DLL (
    IN RPC_CHAR * DllName,
    OUT RPC_STATUS * Status
    )
/*++

Routine Description:

    We will load a dll and create an object to represent it.

Arguments:

    DllName - Supplies the name of the dll to be loaded.

    Status - Returns the status of the operation.  This will only be set
        if an error occurs.  The possible error values are as follows.

        RPC_S_OUT_OF_MEMORY - Insufficient memory is available to load
            the dll.

        RPC_S_INVALID_ARG - The requested dll can not be found.

--*/
{
    DWORD dwLastError;

    if (RpcpStringCompare(DllName, RPC_T("rpcrt4.dll")) == 0)
        {
        DllHandle = 0;
        return;
        }

    DllHandle = (void *)LoadLibrary((const RPC_SCHAR *)DllName);
    if ( DllHandle == 0 )
        {
        dwLastError = GetLastError();
        if ( (dwLastError == ERROR_NOT_ENOUGH_MEMORY)
             || (dwLastError == ERROR_COMMITMENT_LIMIT) )
            {
            *Status = RPC_S_OUT_OF_MEMORY;
            }
        else
            {
            *Status = RPC_S_INVALID_ARG;
            }
        }
}


DLL::~DLL (
    )
/*++

Routine Description:

    We just need to free the library, but only if was actually loaded.

--*/
{
    if ( DllHandle != 0 )
        {
        BOOL Status = FreeLibrary((HMODULE)DllHandle);
        ASSERT( Status );
        }
}


extern HANDLE GetCompletionPortHandleForThread(void);
extern void ReleaseCompletionPortHandleForThread(HANDLE h);


void *
DLL::GetEntryPoint (
    IN char * Procedure
    )
/*++

Routine Description:

    We obtain the entry point for a specified procedure from this dll.

Arguments:

    Procedure - Supplies the name of the entry point.

Return Value:

    A pointer to the requested procedure will be returned if it can be
    found; otherwise, zero will be returned.

--*/
{
    FARPROC ProcedurePointer;

    if (DllHandle == 0)
        {
        if (strcmp(Procedure, "TransportLoad") == 0)
            return (PVOID)TransportLoad;
        else if (strcmp(Procedure, "GetCompletionPortHandleForThread") == 0)
            return (PVOID)GetCompletionPortHandleForThread;
        else if (strcmp(Procedure, "ReleaseCompletionPortHandleForThread") == 0)
            return (PVOID) ReleaseCompletionPortHandleForThread;

        ASSERT(0);
        return NULL;
        }

    ProcedurePointer = GetProcAddress((HINSTANCE)DllHandle, (LPSTR) Procedure);
    if ( ProcedurePointer == 0 )
        {
        ASSERT( GetLastError() == ERROR_PROC_NOT_FOUND );
        }

    return(ProcedurePointer);
}

unsigned long
CurrentTimeSeconds (
    void
    )
// Return the current time in seconds.  When this time is counted
// from is not particularly important since it is used as a delta.
{

    return(GetTickCount()*1000L);

}


RPC_STATUS
SetThreadStackSize (
    IN unsigned long ThreadStackSize
    )
/*++

Routine Description:

    We want to set the default thread stack size.

Arguments:

    ThreadStackSize - Supplies the required thread stack size in bytes.

Return Value:

    RPC_S_OK - We will always return this, because this routine always
        succeeds.

--*/
{
    if (DefaultThreadStackSize < ThreadStackSize)
        DefaultThreadStackSize = ThreadStackSize;

    return(RPC_S_OK);
}


long
ThreadGetRpcCancelTimeout (
    )
{

 THREAD * ThreadInfo = RpcpGetThreadPointer();

 ASSERT(ThreadInfo);
 return (ThreadInfo->CancelTimeout);
}


RPC_STATUS
ThreadStartRoutine (
    IN THREAD * Thread
    )
{
    RpcpSetThreadPointer(Thread);

    Thread->StartRoutine();

    return 0;
}

THREAD *
ThreadSelfHelper (
    )
{
    THREAD * Thread;
    RPC_STATUS Status = RPC_S_OK;

    Thread = new THREAD(&Status);
    if (Thread == 0)
        {
        return 0;
        }

    if (Status != RPC_S_OK)
        {
        delete Thread;
        return 0;
        }

    return Thread;
}


RPC_STATUS RPC_ENTRY
RpcMgmtSetCancelTimeout(
    long Timeout
    )
/*++

Routine Description:

    An application will use this routine to set the cancel
    timeout for a thread.

Arguments:

    Timeout - Supplies the cancel timeout value to set in the thread.
    0 = No cancel timeout
    n = seconds
    RPC_C_CANCEL_INFINITE_TIMEOUT = Infinite

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_INVALID_TIMEOUT - The specified timeout value is invalid.

--*/
{
    InitializeIfNecessary();

    THREAD *Thread = ThreadSelf() ;

    if (!Thread)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    return Thread->SetCancelTimeout(Timeout);
}

RPC_STATUS
RegisterForCancels(
    CALL * Call
    )
{
    THREAD * ThreadInfo = ThreadSelf();
    if (ThreadInfo == 0)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    return ThreadInfo->RegisterForCancels(Call);
}

RPC_STATUS
UnregisterForCancels(
    )
{
    THREAD *ThreadInfo = RpcpGetThreadPointer();

    ASSERT(ThreadInfo);

    ThreadInfo->UnregisterForCancels ();

    return RPC_S_OK;
}



RPC_STATUS RPC_ENTRY
RpcCancelThread(
    IN void * ThreadHandle
    )
{
    if (!QueueUserAPC(CancelAPCRoutine, ThreadHandle, 0))
        {
        return RPC_S_ACCESS_DENIED;
        }

    return RPC_S_OK;
}

RPC_STATUS RPC_ENTRY
RpcCancelThreadEx (
    IN void *ThreadHandle,
    IN long Timeout
    )
{
    if (!QueueUserAPC(CancelExAPCRoutine, ThreadHandle, (UINT_PTR) Timeout))
        {
        return RPC_S_ACCESS_DENIED;
        }

    return RPC_S_OK;
}


RPC_STATUS RPC_ENTRY
RpcServerTestCancel (
    IN RPC_BINDING_HANDLE BindingHandle OPTIONAL
    )
/*++
Function Name:RpcServerTestCancel

Parameters:
    BindingHandle - This is the SCALL on which the server is trying to test for cancels.

Description:
    New API used by a server to check if a call has been cancelled.
    If BindingHandle is NULL, the test is perfomed on the dispatched call
    on the thread on which it is called. Async servers need to call
    RpcServerTestCancel(RpcAsyncGetCallHandle(pAsync))

Returns:
    RPC_S_OK: The call was cancelled
    RPC_S_CALL_IN_PROGRESS: The call was not cancelled
    RPC_S_INVALID_BINDING: The handle is invalid
    RPC_S_NO_CALL_ACTIVE: No call is active on this thread
--*/
{
    CALL *Call;

    if (BindingHandle == 0)
        {
        Call = (CALL *) RpcpGetThreadContext();
        if (Call == 0)
            {
#if DBG
            PrintToDebugger("RPC: RpcServerTestCancel: no call active\n");
#endif
            return RPC_S_NO_CALL_ACTIVE;
            }
        }
    else
        {
        Call = (CALL *) BindingHandle;
        if (Call->InvalidHandle(SCALL_TYPE))
            {
#if DBG
            PrintToDebugger("RPC: RpcServerTestCancel: bad handle\n");
#endif
            return RPC_S_INVALID_BINDING;
            }
        }

    if (Call->TestCancel())
        {
        return RPC_S_OK;
        }

    return RPC_S_CALL_IN_PROGRESS;
}


RPC_STATUS RPC_ENTRY
RpcTestCancel(
    )
/*++
Function Name:RpcTestCancel

Parameters:

Description:
    This function is here only for backward compatibility. The new API to test
    for cancels is RpcServerTestCancel.

Returns:

--*/
{
    return RpcServerTestCancel(0);
}

void RPC_ENTRY
RpcServerYield ()
{
    THREAD * ThreadInfo = RpcpGetThreadPointer();
    ASSERT(ThreadInfo);

    if (ThreadInfo)
        {
        ThreadInfo->YieldThread();
        }
}


THREAD::THREAD (
    IN THREAD_PROC Procedure,
    IN void * Parameter,
    OUT RPC_STATUS * Status
#ifdef RPC_OLD_IO_PROTECTION
    ) : ProtectCount(1), ReleaseCount(0),
#else
    ) :
#endif
    ThreadEvent(Status)
/*++

Routine Description:

    We construct a thread in this method.  It is a little bit weird, because
    we need to be able to clean things up if we cant create the thread.

Arguments:

    Procedure - Supplies the procedure which the new thread should execute.

    Parameter - Supplies a parameter to be passed to the procedure.

    RpcStatus - Returns the status of the operation.  This will be set to
        RPC_S_OUT_OF_THREADS if we can not create a new thread.

--*/
{
    unsigned long ThreadIdentifier;
    HANDLE ImpersonationToken, NewToken = 0;
    NTSTATUS NtStatus;

    CommonConstructor();

    SavedProcedure = Procedure;
    SavedParameter = Parameter;
    HandleToThread = 0;

    if (*Status != RPC_S_OK)
        {
        return;
        }

    if (IsServerSideDebugInfoEnabled())
        {
        DebugCell = (DebugThreadInfo *) AllocateCell(&DebugCellTag);
        if (DebugCell == NULL)
            {
            *Status = RPC_S_OUT_OF_MEMORY;
            return;
            }
        else
            {
            DebugCell->TypeHeader = 0;
            DebugCell->Type = dctThreadInfo;
            DebugCell->Status = dtsAllocated;
            }
        }

    //
    // If there is a token on the calling thread, null it out
    //
    if (OpenThreadToken (GetCurrentThread(),
                     TOKEN_IMPERSONATE | TOKEN_QUERY,
                     TRUE,
                     &ImpersonationToken) == FALSE)
        {
        if ( GetLastError() == ERROR_NO_TOKEN )
            {
            ImpersonationToken = 0 ;
            }
        else
            {
            //
            // More interesting.  There may be a token, and
            // we can't open it.  Note that the anonymous token can't be opened
            // this way.  Complain:
            //
#if DBG
            PrintToDebugger( "RPC : OpenThreadToken returned %d\n", GetLastError() );
#endif
            ASSERT(0);
            *Status = RPC_S_ACCESS_DENIED;
            return;
            }
        }
    else
        {
        NtStatus = NtSetInformationThread(NtCurrentThread(),
                                          ThreadImpersonationToken,
                                          &NewToken,
                                          sizeof(HANDLE));

        if (!NT_SUCCESS(NtStatus))
            {
            *Status = RPC_S_ACCESS_DENIED;
#if DBG
            PrintToDebugger("RPC : NtSetInformationThread : %lx\n", NtStatus);
#endif
            ASSERT(0);
            CloseHandle(ImpersonationToken);
            return;
            }
        }

    HandleToThread = CreateThread(0, DefaultThreadStackSize,
                    (LPTHREAD_START_ROUTINE) ThreadStartRoutine,
                    this, 0, &ThreadIdentifier);
    if ( HandleToThread == 0 )
        {
        *Status = RPC_S_OUT_OF_THREADS;
        }

    if (ImpersonationToken)
        {
        //
        // If there was a token, restore it.
        //
        NtStatus = NtSetInformationThread(NtCurrentThread(),
                                      ThreadImpersonationToken,
                                      &ImpersonationToken,
                                      sizeof(HANDLE));

#if DBG
        if (!NT_SUCCESS(NtStatus))
            {
            PrintToDebugger("RPC : NtSetInformationThread : %lx\n", NtStatus);
            }
#endif // DBG

        CloseHandle(ImpersonationToken);
        }
}


THREAD::THREAD (
    OUT RPC_STATUS * Status
#ifdef RPC_OLD_IO_PROTECTION
    ) : ProtectCount(1), ReleaseCount(0),
#else
    ) :
#endif
    ThreadEvent(Status)
/*++
Routine Description:
    This overloaded constructor is called only by the main app thread.
    this is needed because in WMSG we will be dispatching in the
    context of main app thread.

Arguments:
    RpcStatus - Returns the status of the operation
--*/
{
    HANDLE hProcess ;

    CommonConstructor();

    SavedProcedure = 0;
    SavedParameter = 0;
    HandleToThread = 0;

    if (*Status != RPC_S_OK)
        {
        return;
        }

    hProcess = GetCurrentProcess() ;

    if (!DuplicateHandle(hProcess,
                         GetCurrentThread(),
                         hProcess,
                         &HandleToThread,
                         0,
                         FALSE,
                         DUPLICATE_SAME_ACCESS))
        {
        *Status = RPC_S_OUT_OF_MEMORY ;
        return;
        }

    RpcpSetThreadPointer(this);

    *Status = RPC_S_OK ;
}

void
THREAD::CommonConstructor (
    )
/*++
Function Name:CommonConstructor

Parameters:

Description:

Returns:

--*/
{
    CancelTimeout = RPC_C_CANCEL_INFINITE_TIMEOUT;
    Context = 0;
    SecurityContext = 0;
    ClearCallCancelledFlag();
    fAsync = FALSE;
    ExtendedStatus = RPC_S_OK;
    DebugCell = NULL;
    ThreadEEInfo = NULL;
    NDRSlot = NULL;
    CachedLrpcCall = NULL;
    LastSuccessfullyDestroyedContext = NULL;
    CachedWaiterPtr = NULL;
    CachedEEInfoBlock = NULL;
    ParametersOfCachedEEInfo = 0;

    ActiveCall = 0;

    for (int i = 0; i < 4; i++)
        {
        BufferCache[i].pList = 0;
        BufferCache[i].cBlocks = 0;
        }

    #ifdef CHECK_MUTEX_INVERSION
    ConnectionMutexHeld = 0;
    #endif
}

THREAD::~THREAD (
    )
{
    ASSERT (0 == SecurityContext);
#ifdef RPC_OLD_IO_PROTECTION
    ASSERT(ProtectCount == ReleaseCount.GetInteger());
#endif

    if (CachedWaiterPtr && (CachedWaiterPtr != &CachedWaiter))
        SWMRLock::FreeWaiterCache(&CachedWaiterPtr);

    if (DebugCell != NULL)
        {
        FreeCell(DebugCell, &DebugCellTag);
        }

    if ( HandleToThread != 0 )
        {
        CloseHandle(HandleToThread);
        }

    if (CachedLrpcCall)
        {
        delete CachedLrpcCall;
        }

    if (ThreadEEInfo)
        PurgeEEInfo();

    if (CachedEEInfoBlock)
        FreeEEInfoRecordShallow(CachedEEInfoBlock);

    gBufferCache->ThreadDetach(this);
}

void *
THREAD::ThreadHandle (
    )
/*++
Function Name:ThreadHandle

Parameters:

Description:

Returns:

--*/
{
    while ( HandleToThread == 0 )
        {
        PauseExecution(100L);
        }

    return(HandleToThread);
}

RPC_STATUS
THREAD::SetCancelTimeout (
    IN long Timeout
    )
/*++
Function Name:SetCancelTimeout

Parameters:

Description:

Returns:

--*/
{

    CancelTimeout = Timeout;

    return RPC_S_OK;
}


void
SetExtendedError (
    IN RPC_STATUS Status
    )
{
    THREAD *pThread = ThreadSelf();

    if (pThread == 0)
        {
        return;
        }

    pThread->SetExtendedError(Status);
}


RPC_STATUS
I_RpcGetExtendedError (
    )
{
    THREAD *pThread = ThreadSelf();

    if (pThread == 0)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    return pThread->GetExtendedError();
}


HANDLE RPC_ENTRY
I_RpcTransGetThreadEvent(
    )
/*++

Routine Description:

    Returns the receive event specific to this thread.

Arguments:

    None

Return Value:

    Returns the send event. This function will not fail
--*/
{
    THREAD *pThis = RpcpGetThreadPointer();

    ASSERT(pThis);
    ASSERT(pThis->ThreadEvent.EventHandle);

    return(pThis->ThreadEvent.EventHandle);
}


RPC_STATUS
THREAD::CancelCall (
    IN BOOL fTimeoutValid,
    IN long Timeout
    )
{
    RPC_STATUS Status;

    if (fTimeoutValid)
        {
        CancelTimeout = Timeout;
        }

    SetCallCancelledFlag();
    if (ActiveCall)
        {
        Status = ActiveCall->Cancel(HandleToThread);
        }
    else
        {
        Status =  RPC_S_NO_CALL_ACTIVE;
        }

    return Status;
}


RPC_STATUS
THREAD::RegisterForCancels (
    IN CALL *Call
    )
{
    Call->NestingCall = ActiveCall;
    ActiveCall = Call;

    return RPC_S_OK;
}


void
THREAD::UnregisterForCancels (
    )
{
    if (ActiveCall)
        {
        ActiveCall = ActiveCall->NestingCall;
        }

    //
    // Need to think about when we should cancel the next call if ActiveCall != 0
    //
}

void
THREAD::PurgeEEInfo (
    void
    )
{
    ASSERT(ThreadEEInfo != NULL);
    FreeEEInfoChain(ThreadEEInfo);
    ThreadEEInfo = NULL;
}

VOID RPC_ENTRY
CancelAPCRoutine (
    IN ULONG_PTR Timeout
    )
{
    RPC_STATUS Status;
    THREAD *Thread = ThreadSelf() ;

    if (Thread == 0)
        {
        return;
        }

    Status = Thread->CancelCall();
#if DBG
    if (Status != RPC_S_OK)
        {
        PrintToDebugger("RPC: CancelCall failed %d\n", Status);
        }
#endif
}

void
THREAD::GetWaiterCache (
    OUT SWMRWaiter **WaiterCache,
    IN SCALL *SCall,
    IN SWMRWaiterType WaiterType
    )
{
    ASSERT(WaiterCache != NULL);

    if (CachedWaiterPtr)
        {
        LogEvent(SU_THREAD, EV_POP, CachedWaiterPtr->hEvent, CachedWaiterPtr, 0, 1, 1);
        // if we have something in the cache, we may as well use it
        *WaiterCache = CachedWaiterPtr;
        CachedWaiterPtr = NULL;
        }
    else if ((WaiterType == swmrwtWriter) && SCall->IsSyncCall())
        {
        // the cache is empty, but this is exclusive, sync usage, so we can 
        // borrow the thread event and cook up a waiter
        SWMRWaiter::CookupWaiterFromEventAndBuffer(&CachedWaiter, WaiterType, ThreadEvent.EventHandle);
        *WaiterCache = &CachedWaiter;
        }
    else
        {
        // the cache is empty and this is either shared or async usage so we can't 
        // use the thread buffer/event.
        *WaiterCache = NULL;
        }
}

void
THREAD::FreeWaiterCache (
    IN OUT SWMRWaiter **WaiterCache
    )
{
    ASSERT(WaiterCache != NULL);

    // if we got something in the cache and this is not a cooked up item
    if (*WaiterCache && (*WaiterCache != &CachedWaiter))
        {
        if (CachedWaiterPtr)
            {
            // if our cache is already full, just free the new waiter
            SWMRLock::FreeWaiterCache(WaiterCache);
            }
        else
            {
            // store it
            CachedWaiterPtr = *WaiterCache;
            LogEvent(SU_THREAD, EV_PUSH, CachedWaiterPtr->hEvent, CachedWaiterPtr, 0, 1, 1);
            *WaiterCache = NULL;
            }
        }
}

VOID RPC_ENTRY
CancelExAPCRoutine (
    IN ULONG_PTR Timeout
    )
{
    RPC_STATUS Status;
    THREAD *Thread = ThreadSelf() ;

    if (Thread == 0)
        {
        return;
        }

    Status = Thread->CancelCall(TRUE, (long) Timeout);
#if DBG
    if (Status != RPC_S_OK)
        {
        PrintToDebugger("RPC: CancelCall failed %d\n", Status);
        }
#endif
}


void
RpcpRaiseException (
    IN RPC_STATUS exception
    )
{
    if ( exception == STATUS_ACCESS_VIOLATION )
        {
        exception = ERROR_NOACCESS;
        }

    RaiseException(exception,
                   EXCEPTION_NONCONTINUABLE,
                   0,
                   0);

    ASSERT(0);
}



void RPC_ENTRY
RpcRaiseException (
    IN RPC_STATUS exception
    )
{
    NukeStaleEEInfoIfNecessary(exception);
    RpcpRaiseException(exception);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\sysinc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1991 - 1999
//
//  File:       sysinc.h
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

File : sysinc.h

Description :

This file includes all of the system include files necessary for a
specific version of the runtime.  In addition, it defines some system
dependent debugging options.

***** If you are adding are changing something for a specific     *****
***** system you MUST 1) make the change for all the defined      *****
***** systems and 2) add a comment if needed in the template for  *****
***** future systems.                                             *****

History :

mikemon    08-01-91    Created.
mikemon    10-31-91    Moved system dependent stuff from util.hxx to
                       here.
mariogo    10-19-94    Order conquered chaos and the world rejoiced

-------------------------------------------------------------------- */

#ifndef __SYSINC_H__
#define __SYSINC_H__

// Some system indepentent macros

#ifndef DEBUGRPC
#define INTERNAL_FUNCTION   static
#define INTERNAL_VARIABLE   static
#else
#define INTERNAL_FUNCTION
#define INTERNAL_VARIABLE
#endif  // ! DEBUGRPC

// The following functions are can be implemented as macros
// or functions for system type.

// extern void  *
// RpcpFarAllocate (
//     IN unsigned int Length
//     );

// extern void
// RpcpFarFree (
//     IN void  * Object
//     );

// extern int
// RpcpStringCompare (
//     IN RPC_CHAR  * FirstString,
//     IN RPC_CHAR  * SecondString
//     );

// extern int
// RpcpStringNCompare (
//     IN RPC_CHAR * FirstString,
//     IN RPC_CHAR * SecondString,
//     IN unsigned int Length
//     );

// extern RPC_CHAR *
// RpcpStringCopy (
//    OUT RPC_CHAR * Destination,
//    IN  RPC_CHAR * Source
//    );

// extern RPC_CHAR *
// RpcpStringCat (
//    OUT RPC_CHAR * Destination,
//    IN  CONST RPC_CHAR * Source
//    );

// extern int
// RpcpStringLength (
//    IN RPC_CHAR * WideCharString
//    );

// extern void
// RpcpMemoryMove (
//    OUT void  * Destination,
//    IN  void  * Source,
//    IN  unsigned int Length
//    );

// extern void  *
// RpcpMemoryCopy (
//    OUT void  * Destination,
//    IN  void  * Source,
//    IN  unsigned int Length
//    );

// extern void *
// RpcpMemorySet (
//    OUT void  * Buffer,
//    IN  unsigned char  Value,
//    IN  unsigned int Length
//    );

// extern char *
// RpcpItoa(
//    IN  int Value,
//    OUT char *Buffer,
//    IN  int Radix);

// extern int
// RpcpStringPrintfA(
//    OUT char *Buffer,
//    IN  char *Format,
//    ...);

// extern void
// PrintToDebugger(
//    IN char *Format,
//    ...);

// extern void
// RpcpBreakPoint(
//    );

#ifdef __cplusplus
extern "C" {
#endif

extern void GlobalMutexRequestExternal(void);
extern void GlobalMutexClearExternal(void);

#ifdef __cplusplus
} // extern "C"
#endif


#include<nt.h>
#include<ntrtl.h>
#include<nturtl.h>
#include<stdio.h>
#include<string.h>
#include<memory.h>
#include<malloc.h>
#include<stdlib.h>
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include<windows.h>

#ifdef __cplusplus
extern "C" {
#endif

#if DBG
#define DEBUGRPC
#endif

#if DBG
#undef ASSERT
#define ASSERT( exp ) \
    if (!(exp)) { RtlAssert( #exp, __FILE__, __LINE__, NULL ); DebugBreak(); }
#endif

#define NO_RETURN { ASSERT(0); }

#define ASSUME(exp) ASSERT(exp)

#define FORCE_INLINE inline

#ifndef FORCE_VTABLES
#define NO_VTABLE __declspec(novtable)
#else
#define NO_VTABLE
#endif

#define RPC_DELAYED_INITIALIZATION 1

// flag to preallocate the events on some critical sections
#ifndef PREALLOCATE_EVENT_MASK

#define PREALLOCATE_EVENT_MASK  0x80000000  // Defined only in dll\resource.c

#endif // PREALLOCATE_EVENT_MASK

#define RPC_CHAR WCHAR
#define RPC_SCHAR RPC_CHAR
#define RPC_CONST_CHAR(character) ((RPC_CHAR) L##character)
#define RPC_CONST_STRING(string) ((const RPC_CHAR *) L##string)
#define RPC_CONST_SSTRING(string)	RPC_CONST_STRING(string)
#define RPC_STRING_LITERAL(string)	((RPC_CHAR *) L##string)
#define RPC_T(string)			(L##string)

#define UNUSED(_x_) ((void)(_x_))
#define MAX_DLLNAME_LENGTH 256

#if DBG
#define ASSERT_VALID(c)     ((c)->AssertValid())
#define ASSERT_VALID1(c, p1)     ((c)->AssertValid(p1))
#else
#define ASSERT_VALID
#define ASSERT_VALID1
#endif

#define LOCALE_US	(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT))

#define RpcpFarAllocate(Length) \
    ((void *) new char[Length])

#define RpcpFarFree(Object) \
    (delete Object)

#define RpcpStringSCompare(FirstString, SecondString) \
    lstrcmp((const wchar_t *) FirstString, (const wchar_t *) SecondString)

#define RpcpStringCompare(FirstString, SecondString) \
    _wcsicmp((const wchar_t *) FirstString, (const wchar_t *) SecondString)

#define RpcpStringNCompare(FirstString, SecondString, Length) \
    _wcsnicmp((const wchar_t*) FirstString, (const wchar_t *) SecondString, \
            (size_t) Length)

// always compares ASCII
#define RpcpStringCompareA(FirstString, SecondString) \
    _stricmp((const char *) FirstString, (const char *) SecondString)

#define RpcpStringNCompareA(FirstString, SecondString, Size) \
    _strnicmp((const char *) FirstString, (const char *) SecondString, Size)

#define RpcpStringCompareInt(FirstString, SecondString) \
    (CompareStringW(LOCALE_US, NORM_IGNORECASE, \
    (const wchar_t *) FirstString, -1, (const wchar_t *) SecondString, -1) != CSTR_EQUAL)

#define RpcpStringCompareIntA(FirstString, SecondString) \
    (CompareStringA(LOCALE_US, NORM_IGNORECASE, \
    FirstString, -1, SecondString, -1) != CSTR_EQUAL)

#define RpcpStringCopy(Destination, Source) \
    wcscpy((wchar_t *) Destination, (const wchar_t *) Source)

#define RpcpStringNCopy(DestinationString, SourceString, Length) \
    wcsncpy((wchar_t *) DestinationString, (wchar_t *) SourceString, Length)

#define RpcpStringCat(Destination, Source) \
    wcscat((wchar_t *) Destination, (const wchar_t *) Source)

#define RpcpStringLength(String) \
    wcslen((const wchar_t *) String)

#define RpcpStrStr(String1, String2) \
    wcsstr((const wchar_t *) String1, (const wchar_t *) String2)

#define RpcpStringLengthA(String) \
    strlen(String)

#define RpcpStringToLower(String) \
    _wcslwr(String)

#define RpcpMemoryCompare(FirstBuffer, SecondBuffer, Length) \
    memcmp(FirstBuffer, SecondBuffer, Length)

#define RpcpMemoryCopy(Destination, Source, Length) \
    RtlCopyMemory(Destination, Source, Length)

#define RpcpMemoryMove(Destination, Source, Length) \
    RtlMoveMemory(Destination, Source, Length)

#define RpcpMemorySet(Buffer, Value, Length) \
    RtlFillMemory(Buffer, Length, Value)

#if defined(TYPE_ALIGNMENT)
#undef TYPE_ALIGNMENT
#endif

#define TYPE_ALIGNMENT(x) __alignof(x)

void
RpcpRaiseException (
    IN long exception
    );

RPC_CHAR * __cdecl RpcpStringReverse (RPC_CHAR *string);
void * I_RpcBCacheAllocate (IN unsigned int size);
void I_RpcBCacheFree (IN void * obj);

void I_RpcDoCellUnitTest(IN OUT void *p);

// some test hook definitions
typedef enum tagSystemFunction001Commands
{
    sf001cHttpSetInChannelTarget,
    sf001cHttpSetOutChannelTarget
} SystemFunction001Commands;

#ifdef STATS
void I_RpcGetStats(DWORD *pdwStat1, DWORD *pdwStat2, DWORD *pdwStat3, DWORD *pdwStat4);
#endif

#define RpcpItoa(Value, Buffer, Radix) \
    _itoa(Value, Buffer, Radix)

#define RpcpItow(Value, Buffer, Radix) \
    _itow(Value, Buffer, Radix)

#define RpcpCharacter(Buffer, Character) \
	wcschr(Buffer, Character)

#define RpcpStringPrintfA sprintf
#define RpcpStringConcatenate(FirstString, SecondString) \
     wcscat(FirstString, (const wchar_t *) SecondString)

LONG
I_RpcSetNDRSlot(
    IN void *NewSlot
    );

void *
I_RpcGetNDRSlot(
    void
    );

long 
NDRCCopyContextHandle (
    IN void *SourceBinding,
    OUT void **DestinationBinding
    );

#if defined(_M_IA64) || defined(_M_AMD64)
#define CONTEXT_HANDLE_BEFORE_MARSHAL_MARKER ((PVOID)0xbaadbeefbaadbeef)
#define CONTEXT_HANDLE_AFTER_MARSHAL_MARKER ((PVOID)0xdeaddeaddeaddead)
#else
#define CONTEXT_HANDLE_BEFORE_MARSHAL_MARKER ((PVOID)0xbaadbeef)
#define CONTEXT_HANDLE_AFTER_MARSHAL_MARKER ((PVOID)0xdeaddead)
#endif


#define ANSI_strtol    strtol

#define PrintToConsole  printf  /* Use only in test applications */

#if defined(_M_IA64) || defined(_M_AMD64)
// uncomment this to disable locator support for IA64 or amd64
//#define NO_LOCATOR_CODE
//#define APPLETALK_ON
//#define NETBIOS_ON
//#define NCADG_MQ_ON
//#define SPX_ON
//#define IPX_ON
#else
#define APPLETALK_ON
//#define NETBIOS_ON
//#define NCADG_MQ_ON
#define SPX_ON
//#define IPX_ON
#endif

#if !defined(SPX_ON) && !defined(IPX_ON)
#define SPX_IPX_OFF
#endif

#ifdef DEBUGRPC

#define PrintToDebugger DbgPrint
#define RpcpBreakPoint() DebugBreak()

// ASSERT defined by system

extern BOOL ValidateError(
    IN unsigned int Status,
    IN unsigned int Count,
    IN const int ErrorList[]);

#define VALIDATE(_myValueToValidate) \
    { int _myTempValueToValidate = (_myValueToValidate); \
      static const int _myValidateArray[] =

#define END_VALIDATE ; \
    if (ValidateError(_myTempValueToValidate,\
                      sizeof(_myValidateArray)/sizeof(int), \
                      _myValidateArray) == 0) ASSERT(0);}

#else

    // PrintToDebugger defined only on debug builds...

    #define RpcpBreakPoint()

/* Does nothing on retail systems */
#define VALIDATE(_myValueToValidate) { int _bogusarray[] =
#define END_VALIDATE ; }

#endif

// List Operations
//

#define RpcpInitializeListHead(ListHead)    InitializeListHead(ListHead)


#define RpcpIsListEmpty(ListHead)           IsListEmpty(ListHead)


PLIST_ENTRY
RpcpfRemoveHeadList(
    PLIST_ENTRY ListHead
    );


#define RpcpRemoveHeadList(ListHead)        RemoveHeadList(ListHead)


PLIST_ENTRY
RpcpfRemoveTailList(
    PLIST_ENTRY ListHead
    );


#define RpcpRemoveTailList(ListHead)        RemoveTailList(ListHead)


VOID
RpcpfRemoveEntryList(
    PLIST_ENTRY Entry
    );


#define RpcpRemoveEntryList(Entry)          RemoveEntryList(Entry)


VOID
RpcpfInsertTailList(
    PLIST_ENTRY ListHead,
    PLIST_ENTRY Entry
    );


#define RpcpInsertTailList(ListHead,Entry)  InsertTailList(ListHead,Entry)


VOID
RpcpfInsertHeadList(
    PLIST_ENTRY ListHead,
    PLIST_ENTRY Entry
    );


#define RpcpInsertHeadList(ListHead,Entry)  InsertHeadList(ListHead,Entry)

#ifdef __cplusplus
}
#endif

//
// Don't read this part.  These are needed to support macros
// used in the past.  Please use the supported versions above.
//

#define PAPI __RPC_FAR

// Some old C++ compiler the runtime once used didn't allocate
// the this pointer before calling the constructor.  If you
// have such a compiler now, I'm very sorry for you.

#define ALLOCATE_THIS(class)
#define ALLOCATE_THIS_PLUS(class, amt, errptr, errcode)

#ifdef __cplusplus
#define START_C_EXTERN      extern "C" {
#define END_C_EXTERN        }
#else
#define START_C_EXTERN
#define END_C_EXTERN
#endif

// These must always evaluate "con" even on retail systems.

#ifdef DEBUGRPC
#define EVAL_AND_ASSERT(con) ASSERT(con)
#else
#define EVAL_AND_ASSERT(con) (con)
#endif

#define RequestGlobalMutex GlobalMutexRequest
#define ClearGlobalMutex GlobalMutexClear
#define RpcItoa RpcpItoa

// Double check basic stuff.
#if !defined(TRUE)              || \
    !defined(FALSE)             || \
    !defined(ASSERT)            || \
    !defined(VALIDATE)          || \
    !defined(IN)                || \
    !defined(OUT)               || \
    !defined(CONST)             || \
    !defined(UNALIGNED)         || \
    !defined(UNUSED)

    #error "Some basic macro is not defined"
#endif

#endif /* __SYSINC_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\tower.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    tower.c

Abstract:

    This file contains encoding/decoding for the tower representation
    of the binding information that DCE runtime uses.

    TowerConstruct/TowerExplode will be called by the Runtime EpResolveBinding
    on the client side, TowerExplode will be called by the Endpoint Mapper
    and in addition the name service may call TowerExplode, TowerConstruct.

Author:

    Bharat Shah  (barats) 3-23-92

Revision History:

--*/
#include <precomp.hxx>
#include <epmp.h>
#include <twrtypes.h>
#include <twrproto.h>


//
// TowerVerify() defines.
//
// Note: DECnet Protocol uses 6 Floors, all others 5.
//
#define MAX_FLOOR_COUNT             6

#ifndef UNALIGNED
#error UNALIGNED not defined by sysinc.h or its includes and is needed.
#endif

#pragma pack(1)


/*
   Some Lrpc specific stuff
*/

#define NP_TRANSPORTID_LRPC 0x10
#define NP_TOWERS_LRPC      0x04

// "ncalrpc" including the NULL terminator
const int LrpcProtocolSequenceLength = 8;


RPC_STATUS
Floor0or1ToId(
    IN PFLOOR_0OR1 Floor,
    OUT PGENERIC_ID Id
    )
/*++

Routine Description:

    This function extracts Xfer Syntax or If info from a
    a DCE tower Floor 0 or 1 encoding

Arguments:

    Floor - A pointer to Floor0 or Floor 1 encoding
    Id    -

Return Value:
    EP_S_CANT_PERFORM_OP - The Encoding for the floor [0 or 1] is incorrect.

--*/
{
    if (Floor->FloorId != UUID_ENCODING)
        {
        return (EP_S_CANT_PERFORM_OP);
        }

    RpcpMemoryCopy((char PAPI *)&Id->Uuid, (char PAPI *) &Floor->Uuid,
          sizeof(UUID));

    Id->MajorVersion = Floor->MajorVersion;
    Id->MinorVersion = Floor->MinorVersion;

    return(RPC_S_OK);
}


RPC_STATUS
CopyIdToFloor(
    OUT PFLOOR_0OR1 Floor,
    IN  PGENERIC_ID Id
    )
/*++

Routine Description:

    This function constructs FLOOR 0 or 1 from the given IF-id or Transfer
    Syntax Id.

Arguments:

   Floor - Pointer to Floor 0 or 1 structure that will be constructed

   Id    - Pointer to If-id or Xfer Syntax Id.

Return Value:

  RPC_S_OK

--*/
{

    Floor->FloorId = UUID_ENCODING;
    Floor->ProtocolIdByteCount = sizeof(Floor->Uuid) + sizeof(Floor->FloorId)
                               + sizeof(Floor->MajorVersion);
    Floor->AddressByteCount  = sizeof(Floor->MinorVersion);

    RpcpMemoryCopy((char PAPI *) &Floor->Uuid, (char PAPI *) &Id->Uuid,
          sizeof(UUID));

    Floor->MajorVersion = Id->MajorVersion;
    Floor->MinorVersion = Id->MinorVersion;

    return(RPC_S_OK);
}


RPC_STATUS
LrpcTowerConstruct(
    IN char PAPI * Endpoint,
    OUT unsigned short PAPI UNALIGNED * Floors,
    OUT unsigned long  PAPI UNALIGNED * ByteCount,
    OUT unsigned char PAPI * UNALIGNED PAPI * Tower
    )
{
    unsigned long TowerSize;
    FLOOR_234 UNALIGNED *Floor;

    int EndpointLength;

    *Floors = NP_TOWERS_LRPC;
    if ((Endpoint == NULL) || (*Endpoint == '\0'))
        {
        EndpointLength = 0;
        }
    else
        {
        EndpointLength = RpcpStringLengthA(Endpoint) + 1;
        }

    if (EndpointLength == 0)
        TowerSize = 2;
    else
        TowerSize = EndpointLength;

    TowerSize += sizeof(FLOOR_234) - 2;

    *ByteCount = TowerSize;
    if ((*Tower = (unsigned char *)I_RpcAllocate(TowerSize)) == NULL)
        {
        return (RPC_S_OUT_OF_MEMORY);
        }

    Floor = (PFLOOR_234) *Tower;

    Floor->ProtocolIdByteCount = 1;
    Floor->FloorId = (unsigned char)(NP_TRANSPORTID_LRPC & 0xFF);
    if (EndpointLength)
        {
        Floor->AddressByteCount = (unsigned short)EndpointLength;
        RpcpMemoryCopy((char PAPI *)&Floor->Data[0], Endpoint,
               EndpointLength);
        }
    else
        {
        Floor->AddressByteCount = 2;
        Floor->Data[0] = 0;
        }

    return(RPC_S_OK);
}


RPC_STATUS
LrpcTowerExplode(
    IN char PAPI * Tower,
    OUT char PAPI * UNALIGNED PAPI * Protseq,
    OUT char PAPI * UNALIGNED PAPI * Endpoint,
    OUT char PAPI * UNALIGNED PAPI * NetworkAddress
    )
{

    FLOOR_234 UNALIGNED *Floor = (PFLOOR_234) Tower;

    if (Protseq != NULL)
        {
        *Protseq = new char[LrpcProtocolSequenceLength];
        if (*Protseq == NULL)
            {
            return(RPC_S_OUT_OF_MEMORY);
            }
        RpcpMemoryCopy(*Protseq, "ncalrpc", LrpcProtocolSequenceLength);
        }

    if (Endpoint == NULL)
        {
        return (RPC_S_OK);
        }

    *Endpoint = new char[Floor->AddressByteCount];
    if (*Endpoint == NULL)
        {
        if (Protseq != NULL)
            {
            delete (*Protseq);
            }
        return(RPC_S_OUT_OF_MEMORY);
        }

    RpcpMemoryCopy(*Endpoint, (char PAPI *)&Floor->Data[0],
        Floor->AddressByteCount);

    return(RPC_S_OK);

}


RPC_STATUS
GetProtseqAndEndpointFromFloor3(
    IN PFLOOR_234 Floor,
    OUT char PAPI * PAPI * Protseq,
    OUT char PAPI * PAPI * Endpoint,
    OUT char PAPI * PAPI * NWAddress
    )
{
/*++

Routine Description:

    This function extracts the Protocol Sequence and Endpoint info
    from a "Lower Tower" representation

Arguments:

   Floor - Pointer to Floor2 structure.

   Protseq - A pointer that will contain Protocol seq on return
             The memory will be allocated by this routins and caller
             will have to free this memory.

   Endpoint- A pointer that will contain Endpoint on return
             The memory will be allocated by this routins and caller
             will have to free this memory.

Return Value:

  RPC_S_OK

  RPC_S_OUT_OF_MEMORY - There is no memory to return Protseq or Endpoint str.

  EP_S_CANT_PERFORM_OP - Lower Tower Encoding is incorrect.
--*/

    unsigned short Type = Floor->FloorId, ProtocolType;
    RPC_STATUS Status;

    ProtocolType = Floor->FloorId;
    Floor = NEXTFLOOR(PFLOOR_234, Floor);

    if (NWAddress != 0)
        {
        *NWAddress = 0;
        }

    switch(ProtocolType)
        {

        case LRPC:
            Status = LrpcTowerExplode((char *)Floor,
                                     Protseq, Endpoint, NWAddress);
            break;

        case CONNECTIONFUL:
        case CONNECTIONLESS:

            Status = OsfTowerExplode((char *) Floor,
                                       Protseq, Endpoint, NWAddress);
            break;

        default:
            Status = EP_S_CANT_PERFORM_OP;
    }

    return(Status);
}

#define BadMacByteCount 0x0100
#define TCP_TOWER_ID   0x07

const unsigned short MinFloor0Or1LHS = 0x13;
const unsigned short MinFloor0Or1RHS = 0x2;


RPC_STATUS
TowerVerify(
    IN twr_p_t Tower
)
/*++

Routine Description:

    This function verifies a DCE tower representation of various binding
    information. This is to make sure that we don't choke while trying
    to decode the embeded information.

Arguments:

    Tower - Tower encoding.

Notes:

    See Appendix L (Protocol Tower Encoding) of "X/Open DCE: Remote Procedure
    Call" specification for more information on the exact layout of the
    tower_octet_string and the tower floors.

Return Value:

    RPC_S_OK - Tower is valid.

    EP_S_CANT_PERFORM_OP - Error while parsing the Tower encoding

--*/
{
    RPC_STATUS  status;
    unsigned short i;
    unsigned short FloorCount   = 0;
    unsigned short cLHSBytes    = 0;
    unsigned short cRHSBytes    = 0;
    byte *UpperBound, *LowerBound, *pAddress, *pTemp;
    int fBadMacClient = 0;

    //
    // Check for NULL pointer
    //
    if (NULL == Tower)
        {
        return (EP_S_CANT_PERFORM_OP);
        }

    //
    // Do the verification within an Try-Except block. Just in case...
    //
    __try
    {

        //
        // We trust MIDL to give us a valid Tower structure.
        //

        //
        // LowerBound points to Floor1
        // UpperBound points to the byte after the last Floor
        //
        LowerBound = Tower->tower_octet_string + 2; // FloorCount is 2 bytes
        UpperBound = Tower->tower_octet_string + Tower->tower_length;

        //
        // Get the floor count.
        //
        FloorCount = *((unsigned short UNALIGNED *)&Tower->tower_octet_string);


        if (    FloorCount > MAX_FLOOR_COUNT
             || FloorCount == 0)
            {
            #ifdef DEBUGRPC
            PrintToDebugger("RPC: TowerVerify(): Too many/few floors - %d",
                            FloorCount);
            #endif // DEBUGRPC
            
            status = EP_S_CANT_PERFORM_OP;
            goto endtry;
            }

        //
        // Loop through each Floor verifying it's integrity.
        //
        pAddress = LowerBound;

        for (i = 0; i < FloorCount; i++)
            {
            //
            // Verify the LHS of the Tower floor.
            //
            cLHSBytes = *(unsigned short UNALIGNED *)pAddress;

            if (i == 3
                && cLHSBytes == BadMacByteCount
                && *(((char *) pAddress)+2) == TCP_TOWER_ID)
                {
                fBadMacClient = 1;
                }

            if (fBadMacClient)
                {
                cLHSBytes = RpcpByteSwapShort(cLHSBytes);
                }

            pAddress += (2 + cLHSBytes); // size of cLHSBytes is 2 bytes
            if (pAddress >= UpperBound)
                {
#ifdef DEBUGRPC
                PrintToDebugger("RPC: TowerVerify(): LHS of Tower floor %d "
                                "greater than equal to Upper bound", i);
#endif // DEBUGRPC
                status = EP_S_CANT_PERFORM_OP;
                goto endtry;
                }

            //
            // Verify the RHS of the Tower floor.
            //
            if (fBadMacClient)
                {
                cRHSBytes = RpcpByteSwapShort(*(unsigned short UNALIGNED *)pAddress);
                }
            else
                cRHSBytes = *(unsigned short UNALIGNED *)pAddress;

            pAddress += (2 + cRHSBytes); // size of cRHSBytes is 2 bytes
            //
            // Note, for the last Floor, here, pAddress == UpperBound. So,
            // we do a '>' instead of '>='.
            //
            if (pAddress > UpperBound)
                {
#ifdef DEBUGRPC
                PrintToDebugger("RPC: TowerVerify(): RHS of Tower floor %d "
                                "greater than Upper bound", i);
#endif // DEBUGRPC
                status = EP_S_CANT_PERFORM_OP;
                goto endtry;
                }

            // if this is floor 0 or 1, verify that we have at least
            // an interface/transfer syntax id in there.
            if ((i == 0) || (i == 1))
                {
                if ((cLHSBytes < MinFloor0Or1LHS)
                    || (cRHSBytes < MinFloor0Or1RHS))
                    {
#ifdef DEBUGRPC
                    PrintToDebugger("RPC: TowerVerify(): Floor 0or1 LHSBytes or RHSBytes less than minumum %d, %d "
                                "greater than Upper bound", cLHSBytes, cRHSBytes);
#endif // DEBUGRPC
                    status = EP_S_CANT_PERFORM_OP;
                    goto endtry;
                    }
                }

            } // for ()

        //
        // Tower looks good, as far as we can tell
        //
        status = RPC_S_OK;

        //
        // It's much better *not* to return from within the __try block.
        // (saves thousands of instructions)
        //
endtry:

#if 1
        //
        // The compiler needs at least one statement between the label and the end of the block, I guess.
        // Luckily a null statement is sufficient.
        //
        ;
#endif

    }
    __except(    ( GetExceptionCode() == STATUS_ACCESS_VIOLATION )
              || ( GetExceptionCode() == STATUS_DATATYPE_MISALIGNMENT ) )
    {

#ifdef DEBUGRPC
        PrintToDebugger("RPC: TowerVerify() generated an exception 0x%x",
                        RpcExceptionCode());
#endif // DEBUGRPC

        status = EP_S_CANT_PERFORM_OP;

    }

    return status;
}






RPC_STATUS RPC_ENTRY
TowerExplode(
    IN twr_p_t Tower,
    OUT  RPC_IF_ID PAPI * Ifid, OPTIONAL
    OUT  RPC_TRANSFER_SYNTAX PAPI * XferId, OPTIONAL
    OUT  char PAPI * PAPI * Protseq, OPTIONAL
    OUT  char PAPI * PAPI * Endpoint, OPTIONAL
    OUT  char PAPI * PAPI * NWAddress OPTIONAL
    )
/*++


Routine Description:

    This function converts a DCE tower representation of various binding
    information to binding info that is suitable to MS runtime.
    Specically it returns Ifid, Xferid, Protseq and Endpoint information
    encoded in the tower.

Arguments:

    Tower - Tower encoding.

    Ifid  - A pointer to Ifid

    Xferid - A pointer to Xferid

    Protseq - A pointer to pointer returning Protseq

    Endpoint- A pointer to pointer returning Endpoint

Return Value:

    RPC_S_OK

    EP_S_CANT_PERFORM_OP - Error while parsing the Tower encoding

    RPC_S_OUT_OF_MEMORY - There is no memory to return Protseq and Endpoint
                          strings.
--*/
{
    PFLOOR_0OR1 Floor;
    PFLOOR_234  Floor234;
    unsigned short FloorCount;
    RPC_STATUS err = RPC_S_OK;

    //
    // Validate the Tower before proceeding...
    //
    err = TowerVerify(Tower);
    if (err != RPC_S_OK)
        {
        return (err);
        }

    FloorCount = *((unsigned short PAPI *)&Tower->tower_octet_string);

    Floor = (PFLOOR_0OR1)
           ((unsigned short PAPI *)&Tower->tower_octet_string + 1);

    //Process Floor 0 Interface Spec.
    if (Ifid != NULL)
        {
        err = Floor0or1ToId(Floor, (PGENERIC_ID) Ifid);
        }

    Floor = NEXTFLOOR(PFLOOR_0OR1, Floor);


    //Now we point to and process Floor 1 Transfer Syntax Spec.
    if ((!err) && (XferId != NULL))
        {
        err = Floor0or1ToId(Floor, (PGENERIC_ID) XferId);
        }

    if (err)
        {
        return(err);
        }

    Floor234 = (PFLOOR_234)NEXTFLOOR(PFLOOR_0OR1, Floor);

    //Now Floor234 points to Floor 2. RpcProtocol [Connect-Datagram]

    err = GetProtseqAndEndpointFromFloor3(Floor234, Protseq,Endpoint,NWAddress);

    return(err);
}


RPC_STATUS RPC_ENTRY
TowerConstruct(
    IN RPC_IF_ID PAPI * Ifid,
    IN RPC_TRANSFER_SYNTAX PAPI * Xferid,
    IN char PAPI * RpcProtocolSequence,
    IN char PAPI * Endpoint, OPTIONAL
    IN char PAPI * NWAddress, OPTIONAL
    OUT twr_t PAPI * PAPI * Tower
    )
/*++


Routine Description:

    This function constructs a DCE tower representation from
    Protseq, Endpoint, XferId and IfId

Arguments:

    Ifid  - A pointer to Ifid

    Xferid - A pointer to Xferid

    Protseq - A pointer to Protseq

    Endpoint- A pointer to Endpoint

    Tower - The constructed tower returmed - The memory is allocated
            by  the routine and caller will have to free it.

Return Value:

    RPC_S_OK

    EP_S_CANT_PERFORM_OP - Error while parsing the Tower encoding

    RPC_S_OUT_OF_MEMORY - There is no memory to return the constructed
                          Tower.
--*/
{

    unsigned short Numfloors,  PAPI *FloorCnt;
    twr_t PAPI * Twr;
    PFLOOR_0OR1 Floor;
    PFLOOR_234  Floor234, Floor234_1;
    RPC_STATUS Status;
    unsigned long TowerLen, ByteCount;
    char PAPI * UpperTower;
    unsigned short ProtocolType;


    if ( RpcpStringCompareA(RpcProtocolSequence, "ncalrpc") == 0 )
        {
        ProtocolType = LRPC;
        Status = LrpcTowerConstruct(Endpoint, &Numfloors,
                                &ByteCount, (unsigned char **)&UpperTower);
        }
    else

        {

        if (   (RpcProtocolSequence[0] == 'n')
            && (RpcProtocolSequence[1] == 'c')
            && (RpcProtocolSequence[2] == 'a')
            && (RpcProtocolSequence[3] == 'c')
            && (RpcProtocolSequence[4] == 'n')
            && (RpcProtocolSequence[5] == '_'))
            {
            ProtocolType = CONNECTIONFUL;
            }
        else if (   (RpcProtocolSequence[0] == 'n')
            && (RpcProtocolSequence[1] == 'c')
            && (RpcProtocolSequence[2] == 'a')
            && (RpcProtocolSequence[3] == 'd')
            && (RpcProtocolSequence[4] == 'g')
            && (RpcProtocolSequence[5] == '_'))
            {
            ProtocolType = CONNECTIONLESS;
            }

        else
            {
            return(RPC_S_INVALID_RPC_PROTSEQ);
            }

        Status = OsfTowerConstruct(
                       RpcProtocolSequence,
                       Endpoint,
                       NWAddress,
                       &Numfloors,
                       &ByteCount,
                       (unsigned char **)&UpperTower
                       );
        }

    if (Status != RPC_S_OK)
        {
        return (Status);
        }

    TowerLen = 2 + ByteCount;
    TowerLen += 2 * sizeof(FLOOR_0OR1) + sizeof(FLOOR_2) ;

    if ( (*Tower = Twr = (twr_t *)I_RpcAllocate((unsigned int)TowerLen+4)) == NULL)
        {
        I_RpcFree(UpperTower);
        return(RPC_S_OUT_OF_MEMORY);
        }

    Twr->tower_length = TowerLen;

    FloorCnt = (unsigned short PAPI *)&Twr->tower_octet_string;
    *FloorCnt = Numfloors;

    Floor = (PFLOOR_0OR1)(FloorCnt+1);

    //Floor 0 - IfUuid and IfVersion
    CopyIdToFloor(Floor, (PGENERIC_ID)Ifid);
    Floor++;

    //Floor 1 - XferUuid and XferVersion
    CopyIdToFloor(Floor, (PGENERIC_ID)Xferid);

    //Floor 2
    //ProtocolId = CONNECTIONFUL/CONNECTIONLESS/LRPC and Address = 0(ushort)
    Floor234 = (PFLOOR_234) (Floor + 1);
    Floor234->ProtocolIdByteCount = 1;
    Floor234->FloorId = (byte) ProtocolType;
    Floor234->Data[0] = 0x0;
    Floor234->Data[1] = 0x0;
    Floor234->AddressByteCount = 2;

    //Floor 3,4,5.. use the tower encoded by the Transports
    Floor234_1 = NEXTFLOOR(PFLOOR_234, Floor234);

    RpcpMemoryCopy((char PAPI *)Floor234_1, (char PAPI *)UpperTower,
          (size_t)ByteCount);
    I_RpcFree(UpperTower);

    return(RPC_S_OK);
}

#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\twrtypes.h ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    tower.c

Abstract:

    This file accompanies tower.c

Author:

    Bharat Shah  (barats) 3-25-92

Revision History:

--*/

typedef int fpp;

//Towers are not DWORD or WORD aligned. Consequently we need to
//Pack these structures that are used to parse/construct towers
#pragma pack(1)

typedef struct _FLOOR_0OR1 {
   unsigned short ProtocolIdByteCount;
   byte FloorId;
   UUID Uuid;
   unsigned short MajorVersion;
   unsigned short AddressByteCount;
   unsigned short MinorVersion;
} FLOOR_0OR1;
typedef FLOOR_0OR1 PAPI UNALIGNED * PFLOOR_0OR1;

typedef struct _FLOOR_234 {
   unsigned short ProtocolIdByteCount;
   byte FloorId;
   unsigned short AddressByteCount;
   byte Data[2];
} FLOOR_234;
typedef FLOOR_234 PAPI UNALIGNED * PFLOOR_234;

typedef struct _FLOOR_2 {
   unsigned short ProtocolIdByteCount;
   byte RpcProtocol;
   unsigned short AddressByteCount;
   unsigned short RpcProtocolMinor;
} FLOOR_2;
typedef FLOOR_2 PAPI UNALIGNED * PFLOOR_2;

typedef struct _FLOOR_3 {
   unsigned short ProtocolIdByteCount;
   byte PortType;
   unsigned short AddressByteCount;
   char     EndPoint[2];
} FLOOR_3;
typedef FLOOR_3 PAPI UNALIGNED * PFLOOR_3;

typedef struct _FLOOR_4 {
   unsigned short ProtocolIdByteCount;
   byte HostType;
   unsigned short AddressByteCount;
   char Host[2];
} FLOOR_4;
typedef FLOOR_4 PAPI UNALIGNED * PFLOOR_4;


typedef struct _GENERIC_ID {
   UUID Uuid;
   unsigned short MajorVersion;
   unsigned short MinorVersion;
} GENERIC_ID;
typedef GENERIC_ID PAPI UNALIGNED * PGENERIC_ID;

//This comment to force some changes for C++
#pragma pack()

#define UUID_ENCODING     0x0D

#define TCP_IP            0x07
#define UDP_IP            0x08
#define DNA_PHASE_4       0x02
#define DNA_PHASE_5       0x03
#define MS_CN_NMP         0x0F
#define MS_LRPC           0x10

#define MS_CN_HOSTNAME    0x11
#define IP_HOSTNAME       0x09
#define AT_NBP_NAME       0x18

#define CONNECTIONLESS    0x0A
#define CONNECTIONFUL     0x0B
#define LRPC              0x0C

#define NEXTFLOOR(t,x) (t)((byte PAPI *)x + ((t)x)->ProtocolIdByteCount\
                                        + ((t)x)->AddressByteCount\
                                        + sizeof(((t)x)->ProtocolIdByteCount)\
                                        + sizeof(((t)x)->AddressByteCount))

#define NCACN_NP          0x0F   // N.B. Different on the OSF web site
#define NCACN_IP_TCP      0x07
#define NCADG_IP_UDP      0x08
#define NCACN_SPX         0x0C
#define NCADG_IPX         0x0E
#define NCACN_NB          0x12
#define NCACN_AT_DSP      0x16
#define NCADG_AT_DDP      0x17
#define NCACN_VNS_SPP     0x1A
#define NCADG_MQ          0x1D   // N.B. Not showing on the OSF web site
#define NCACN_HTTP        0x1F   // N.B. Not showing on the OSF web site


/*
  Some predefined Ids for NetBIOS
*/

#define NB_NBID        0x13
#define NB_XNSID       0x15
#define NB_IPID        0x09
#define NB_IPXID       0x0d
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\twrproto.h ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    tower.c 

Abstract:

    This file accompanies tower.c

Author:

    Bharat Shah  (barats) 3-25-92

Revision History:

--*/

//Function Prototypes


#ifdef __cplusplus
extern "C" {
#endif 

RPC_STATUS  RPC_ENTRY
  TowerExplode(
    twr_p_t Tower,
    RPC_IF_ID PAPI * Ifid,
    RPC_TRANSFER_SYNTAX PAPI * XferId,
    char PAPI * PAPI * Protseq,
    char PAPI * PAPI * Endpoint,
    char PAPI * PAPI * NWAddress
    );

RPC_STATUS RPC_ENTRY
OsfTowerConstruct(
    char PAPI * ProtocolSeq,
    char PAPI * Endpoint,
    char PAPI * NetworkAddress,
    unsigned short PAPI * Floors,
    unsigned long PAPI * ByteCount,
    unsigned char PAPI * PAPI * Tower
    );

RPC_STATUS RPC_ENTRY
OsfTowerExplode(
    char PAPI * Floor,
    OUT char PAPI * PAPI * Protseq,
    OUT char PAPI * PAPI * Endpoint,
    OUT char PAPI * PAPI * NWAddress
    );
RPC_STATUS  RPC_ENTRY
  TowerConstruct(
    RPC_IF_ID PAPI * Ifid,
    RPC_TRANSFER_SYNTAX PAPI * Xferid,
    char PAPI * Protseq,
    char PAPI * Endpoint,
    char PAPI * NWAddress,
    twr_p_t PAPI * Tower
    );

RPC_STATUS RPC_ENTRY
ExplodePredefinedTowers(
    IN  unsigned char PAPI * Tower,
    OUT char PAPI * UNALIGNED PAPI * Protseq,
    OUT char PAPI * UNALIGNED PAPI * Endpoint,
    OUT char PAPI * UNALIGNED PAPI * NWAddress
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\uuidsup.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1994 - 1999

Module Name:

    uuidsup.cxx

Abstract:

    Implements system dependent functions used in creating Uuids.

    This file is for Win32 (NT and Chicago) systems.

    External functions are:
        UuidGlobalMutexRequest
        UuidGlobalMutexClear
        GetNodeId
        UuidGetValues

Note:

    WARNING:

    Everything in this file is only called from within UuidCreate()
    which is already holding the global mutex.  Therefore none of
    this code is multithread safe.  For example, access to the global
    Uuid HKEY's is not protected.

Author:

   Mario Goertzel   (MarioGo)  May 23, 1994

Revision History:

--*/

#include <precomp.hxx>
#include <uuidsup.hxx>


RPC_STATUS __RPC_API
UuidGetValues(
    OUT UUID_CACHED_VALUES_STRUCT __RPC_FAR *Values
    )
/*++

Routine Description:

    This routine allocates a block of uuids for UuidCreate to handout.

Arguments:

    Values - Set to contain everything needed to allocate a block of uuids.
             The following fields will be updated here:

    NextTimeLow -   Together with LastTimeLow, this denotes the boundaries
                    of a block of Uuids. The values between NextTimeLow
                    and LastTimeLow are used in a sequence of Uuids returned
                    by UuidCreate().

    LastTimeLow -   See NextTimeLow.

    ClockSequence - Clock sequence field in the uuid.  This is changed
                    when the clock is set backward.

Return Value:

    RPC_S_OK - We successfully allocated a block of uuids.

    RPC_S_OUT_OF_MEMORY - As needed.
--*/
{
    NTSTATUS NtStatus;
    ULARGE_INTEGER Time;
    ULONG Range;
    ULONG Sequence;
    int Tries = 0;

    do {
        NtStatus = NtAllocateUuids(&Time, &Range, &Sequence, (char *) &Values->NodeId[0]);

        if (NtStatus == STATUS_RETRY)
            {
            Sleep(1);
            }

        Tries++;

        if (Tries == 20)
            {
#ifdef DEBUGRPC
            PrintToDebugger("Rpc: NtAllocateUuids retried 20 times!\n");
            ASSERT(Tries < 20);
#endif
            NtStatus = STATUS_UNSUCCESSFUL;
            }

        } while(NtStatus == STATUS_RETRY);

    if (!NT_SUCCESS(NtStatus))
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    // NtAllocateUuids keeps time in SYSTEM_TIME format which is 100ns ticks since
    // Jan 1, 1601.  UUIDs use time in 100ns ticks since Oct 15, 1582.

    // 17 Days in Oct + 30 (Nov) + 31 (Dec) + 18 years and 5 leap days.

    Time.QuadPart +=   (unsigned __int64) (1000*1000*10)       // seconds
                     * (unsigned __int64) (60 * 60 * 24)       // days
                     * (unsigned __int64) (17+30+31+365*18+5); // # of days

    ASSERT(Range);

    Values->ClockSeqHiAndReserved =
        RPC_UUID_RESERVED | (((unsigned char) (Sequence >> 8))
        & (unsigned char) RPC_UUID_CLOCK_SEQ_HI_MASK);

    Values->ClockSeqLow = (unsigned char) (Sequence & 0x00FF);

    // The order of these assignments is important

    Values->Time.QuadPart = Time.QuadPart + (Range - 1);
    Values->AllocatedCount = Range;

    if ((Values->NodeId[0] & 0x80) == 0)
        {
        return(RPC_S_OK);
        }

    return (RPC_S_UUID_LOCAL_ONLY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\rtifs\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt

NBASE_HDR =$(O)\nbase.h

MGMT_HDR  =$(O)\mgmt.h
MGMT_CSTUB=$(O)\mgmt_c.c
MGMT_SSTUB=$(O)\mgmt_s.c

CONV_HDR  =$(O)\conv.h
CONV_CSTUB=$(O)\conv_c.c
CONV_SSTUB=$(O)\conv_s.c

CONVC_HDR  =$(O)\convc.h
CONVC_CSTUB=$(O)\convc_c.c
CONVC_SSTUB=$(O)\convc_s.c

MQMGR_HDR  =$(O)\mqmgr.h
MQMGR_CSTUB=$(O)\mqmgr_c.c
MQMGR_SSTUB=..\epmap\$(O)\mqmgr_s.c

EPMP_HDR  =$(O)\epmp.h
EPMP_CSTUB=$(O)\epmp_c.c
EPMP_SSTUB=..\epmap\$(O)\epmp_s.c

DBGIDL_HDR  =$(O)\DbgIdl.h
DBGIDL_CSTUB=$(O)\DbgIdl_c.c
DBGIDL_SSTUB=..\epmap\$(O)\DbgIdl_s.c

EEINFO_HDR  =$(O)\EEInfo.h
EEINFO_CSTUB=$(O)\EEInfo_c.c

CPP_CMD = -cpp_cmd "$(MIDL_CPP)"
CPP_OPT = $(MIDL_FLAGS)

COMMON_FLAGS= $(MIDL_OPTIMIZATION_NT5) -c_ext -ms_ext -I..\mtrt -oldnames -DNTENV $(CPP_CMD) $(CPP_OPT)

EPMP_FLAGS= $(COMMON_FLAGS:-protocol all=) 

clean: delsrc allidl

delsrc:
    -del $(MGMT_HDR)  $(MGMT_CSTUB)  $(MGMT_SSTUB)  \
         $(CONV_HDR)  $(CONV_CSTUB)  $(CONV_SSTUB)  \
         $(EPMP_HDR)  $(EPMP_CSTUB)  $(EPMP_SSTUB)  \
         $(MQMGR_HDR) $(MQMGR_CSTUB) $(MQMGR_SSTUB) \
         $(EEINFO_HDR) $(EEINFO_CSTUB) \
         $(DBGIDL_HDR) $(DBGIDL_CSTUB) $(DBGIDL_SSTUB) >nul 2>&1

allidl: dirs nbase mgmt epmp conv mqmgr convc dbgidl eeinfo

dirs: ..\epmap\$(O) $(O)

$(O):
    md $@
    
..\epmap\$(O):
    md $@

#
# Common DCE types, imported into all the other .idls
#

nbase: $(NBASE_HDR)

$(NBASE_HDR): nbase.idl
        midl $(COMMON_FLAGS) -server none -client none -header $(NBASE_HDR)\
        nbase.idl

#
# Remote RPC Management APIs
#
mgmt: $(MGMT_HDR) $(MGMT_CSTUB) $(MGMT_SSTUB)

$(MGMT_HDR) $(MGMT_CSTUB) $(MGMT_SSTUB) : mgmt.idl mgmt.acf nbase.idl
        midl $(COMMON_FLAGS) -prefix client _ \
         -cstub $(MGMT_CSTUB) -sstub $(MGMT_SSTUB) -header $(MGMT_HDR) mgmt.idl

#
# Conversation interface - datagram callback to verify client id.
#
conv: $(CONV_HDR) $(CONV_CSTUB) $(CONV_SSTUB)

$(CONV_HDR) $(CONV_CSTUB) $(CONV_SSTUB) : conv.idl nbase.idl
        midl $(COMMON_FLAGS) -prefix client _ \
         -cstub $(CONV_CSTUB) -sstub $(CONV_SSTUB) -header $(CONV_HDR) conv.idl

#
# Client Conversation interface - datagram context handle keep-alives.
#
convc: $(CONVC_HDR) $(CONVC_CSTUB) $(CONVC_SSTUB)

$(CONVC_HDR) $(CONVC_CSTUB) $(CONVC_SSTUB) : convc.idl nbase.idl
        midl $(COMMON_FLAGS) -prefix client _ \
         -cstub $(CONVC_CSTUB) -sstub $(CONVC_SSTUB) -header $(CONVC_HDR) convc.idl

#
# Endpoint mapper interface
#
epmp: $(EPMP_HDR) $(EPMP_CSTUB) $(EPMP_SSTUB)

$(EPMP_HDR) $(EPMP_CSTUB) : epmp.idl epmp.acf nbase.idl
        midl $(EPMP_FLAGS) -header $(EPMP_HDR) -cstub $(EPMP_CSTUB) -server none -D_CLIENT_PASS_ epmp.idl

$(EPMP_SSTUB) : $(EPMP_HDR)
        midl $(EPMP_FLAGS) -header $(EPMP_HDR) -sstub $(EPMP_SSTUB) -client none -D_SERVER_PASS_ epmp.idl

#
# MQ Management Interface (for temporary queues):
#
mqmgr: $(MQMGR_HDR) $(MQMGR_CSTUB) $(MQMGR_SSTUB)

$(MQMGR_HDR) $(MQMGR_CSTUB) $(MQMGR_SSTUB) : mqmgr.idl mqmgr.acf nbase.idl
        midl $(COMMON_FLAGS) \
        -cstub $(MQMGR_CSTUB) -sstub $(MQMGR_SSTUB) -header $(MQMGR_HDR) mqmgr.idl

#
# DbgIdl interface (for enhanced debugging):
#
dbgidl: $(DBGIDL_HDR) $(DBGIDL_CSTUB) $(DBGIDL_SSTUB)

$(DBGIDL_HDR) $(DBGIDL_CSTUB) $(DBGIDL_SSTUB) : DbgIdl.idl nbase.idl
        midl $(COMMON_FLAGS) \
        -cstub $(DBGIDL_CSTUB) -sstub $(DBGIDL_SSTUB) -header $(DBGIDL_HDR) DbgIdl.idl

#
# EEInfo interface (for extended error information):
#
eeinfo: $(EEINFO_HDR) $(EEINFO_CSTUB)

$(EEINFO_HDR) $(EEINFO_CSTUB) : EEInfo.idl nbase.idl
        midl $(COMMON_FLAGS) \
        -cstub $(EEINFO_CSTUB) -server none -header $(EEINFO_HDR) EEInfo.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\usvr.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1990 - 1999
//
//  File:       usvr.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

                      Microsoft OS/2 LAN Manager
                   Copyright(c) Microsoft Corp., 1990

-------------------------------------------------------------------- */
/* --------------------------------------------------------------------

File : usvr.cxx

Description :

Server test program for the RPC runtime.  This program functions as half
of the build verification test for the RPC runtime.  The other half is
the client test program.

This particular program is independent of the particular operating
system other than requiring threads support of some sort (including
mutexes).

RPC server runtime APIs:

RpcCreateServer
RpcDeleteServer
RpcAddAddress
RpcRemoveAddress
RpcAddInterface
RpcRemoveInterface
RpcMonitorAssociation
RpcQueryConfig
RpcGetCurrentCallHandle
RpcGetAssociationContext
RpcQueryCall
RpcQueryBinding
RpcQueryProtocolStack
I_RpcGetBuffer
I_RpcFreeBuffer
I_RpcSendReceive


-------------------------------------------------------------------- */
#include <precomp.hxx>
#include "pipe.h"
#include "astub.h"
#define _PNP_POWER_
#include <winsock2.h>
#include <Charconv.hxx>
#include <direct.h>

extern "C"
{
#include <iphlpapi.h>
}

/*
Transports:

    Update this to add a new transport.
*/

#define RPC_TRANSPORT_NAMEPIPE 1
#define RPC_LRPC 2
#define RPC_TRANSPORT_TCP 3
#define RPC_TRANSPORT_DNET 4
#define RPC_TRANSPORT_NETBIOS 5
#define RPC_TRANSPORT_SPX 6
#define RPC_TRANSPORT_UDP 7
#define RPC_TRANSPORT_IPX 8
#define RPC_TRANSPORT_DSP 9
#define RPC_TRANSPORT_VNS 10
#define RPC_WMSG          11
#define RPC_TRANSPORT_MSMQ 12

#define MAXLISTENTHREADS 12345
#define MAX_CALL_REQUESTS 500

#define EXTENDED_ERROR_EXCEPTION 77777

#define SIZEOUT_ASYNC_EXCEPTION (0xfffffff)

typedef DWORD
(RPCRTAPI RPC_ENTRY *SET_TEST_HOOK_FN)(
                    RPC_TEST_HOOK_ID id,
                    RPC_TEST_HOOK_FN fn
                    );

//
// Global variables.
//
BOOL fExtendedError        = FALSE;

unsigned int MinimumListenThreads  = 1;
unsigned int UseEndpointMapperFlag = 0;
unsigned int NoSecurityTests       = 0;
unsigned int DatagramFlag          = 0;
unsigned int AutoListenFlag        = 0;
unsigned int IFSecurity        = 0;
int Verbose = 0;

unsigned int WarnFlag = 0; // Flag for warning messages;
unsigned int ErrorFlag = 0; // Flag for error messages;
unsigned int TransportType;
int MaxRpcSize = 1000000;
unsigned long ulSecurityPackage = 10 ;
int FireWallFlag = 0;

char NetBiosProtocol[20] = "ncacn_nb_nb";  // NetBios transport protocol
char *TransportOption = "-namepipe";

int ServerType ;
#define SYNC_WMSG 1
#define ASYNC_WMSG 2
HWND hWnd ;
char szAppName[] = "usvr";
THREAD_IDENTIFIER CurrentTid ;

extern RPC_SERVER_INTERFACE IsabelleInterfaceInformation;


RPC_STATUS Status; // Contains the status of the last RPC API call.
I_RPC_MUTEX PrintMutex = 0; // Mutex used to serialize print operations.

#define CHUNK_SIZE   50
#define NUM_CHUNKS 100
#define BUFF_SIZE 100

typedef int pipe_element_t ;

typedef struct {
    void (*Pull) (
            PIPE_STATE *state,
            pipe_element_t *buffer,
            int max_buf,
            int *actual_transfer_count
            ) ;

    void (*Push) (
        PIPE_STATE *state,
        pipe_element_t *buffer,
        int max_buf
        ) ;

    PIPE_STATE *state ;
    } pipe_t ;

int ShutdownCalled ;
unsigned int IsabelleErrors = 0;
unsigned int HelgaErrors = 0;
unsigned int SylviaErrors = 0;

SET_TEST_HOOK_FN SetTestHookFn;

//
// forward declarations
//


extern void
Async (
    ) ;


extern void
SendAck (
    ) ;


void
DgTransport (
    );

void
SecurityErrorWrapper(
    int subtest
    );

DWORD
GenericServerListen(
    char * name,
    int endpoint
    );

DWORD
GenericServerUnlisten(
    char * name
    );

//
// function definitions
//

void
ApiError ( // An API error occured; we just print a message.
    IN char * Routine, // The routine which called the API.
    IN char * API,
    IN RPC_STATUS status
    )
{
    if (ErrorFlag)
        {
        I_RpcRequestMutex(&PrintMutex);
        PrintToConsole("    ApiError in %s (%s = %u)\n",Routine,API,status);
        I_RpcClearMutex(PrintMutex);
        }
}

void
PauseExecution (
    unsigned long milliseconds
    )
{

    Sleep(milliseconds);

}

void
CompleteReceive(
    PRPC_MESSAGE Callee
    )
{
    DWORD size = 0;

    Callee->RpcFlags |=  RPC_BUFFER_EXTRA;
    Callee->RpcFlags &= ~RPC_BUFFER_PARTIAL;

    if ((Callee->RpcFlags & RPC_BUFFER_COMPLETE) == 0)
        {
        Status =  I_RpcReceive(Callee, size) ;
        if (Status)
            {
            ApiError("CompleteReceive", "I_RpcReceive", Status) ;
            }
        }

    ASSERT(Callee->RpcFlags & RPC_BUFFER_COMPLETE);
}

RPC_STATUS
RpcServerUseProtseqEpWrapper (
    IN unsigned char PAPI * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned char PAPI * Endpoint,
    IN void PAPI * SecurityDescriptor
    )
{
    RPC_POLICY Policy ;

    if (FireWallFlag)
        {
        Policy.Length = sizeof(RPC_POLICY) ;
        Policy.NICFlags = RPC_C_BIND_TO_ALL_NICS;
        Policy.EndpointFlags = RPC_C_DONT_FAIL;
        return RpcServerUseProtseqEpExA(Protseq, MaxCalls, Endpoint,
                        SecurityDescriptor,&Policy) ;
        }
    else
        {
        return RpcServerUseProtseqEpA(Protseq, MaxCalls, Endpoint, SecurityDescriptor) ;
        }
}

RPC_STATUS
RpcServerUseProtseqWrapper (
    IN unsigned char PAPI * Protseq,
    IN unsigned int MaxCalls,
    IN void PAPI * SecurityDescriptor OPTIONAL
    )
{
    RPC_POLICY Policy ;

    if (FireWallFlag)
        {
        Policy.Length = sizeof(RPC_POLICY) ;
        Policy.NICFlags = RPC_C_BIND_TO_ALL_NICS ;
        return RpcServerUseProtseqExA(Protseq, MaxCalls, SecurityDescriptor, &Policy) ;
        }
    else
        {
        return RpcServerUseProtseqA(Protseq, MaxCalls, SecurityDescriptor) ;
        }
}

RPC_STATUS
RpcServerUseAllProtseqsWrapper (
    IN unsigned int MaxCalls,
    IN void PAPI * SecurityDescriptor OPTIONAL
    )
{
    RPC_POLICY Policy ;

    if (FireWallFlag)
        {
        Policy.Length = sizeof(RPC_POLICY) ;
        Policy.NICFlags = RPC_C_BIND_TO_ALL_NICS ;
        return RpcServerUseAllProtseqsEx(MaxCalls, SecurityDescriptor, &Policy) ;
        }
    else
        {
        return RpcServerUseAllProtseqs(MaxCalls, SecurityDescriptor) ;
        }
}

RPC_STATUS
RpcServerUseProtseqIfWrapper (
    IN unsigned char PAPI * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void PAPI * SecurityDescriptor
    )
{
    RPC_POLICY Policy ;

    if (FireWallFlag)
        {
        Policy.Length = sizeof(RPC_POLICY) ;
        Policy.NICFlags = RPC_C_BIND_TO_ALL_NICS ;
        return RpcServerUseProtseqIfExA(Protseq, MaxCalls, IfSpec,
                    SecurityDescriptor, &Policy) ;
        }
    else
        {
        return RpcServerUseProtseqIfA(Protseq, MaxCalls, IfSpec, SecurityDescriptor) ;
        }
}

RPC_STATUS
RpcServerUseAllProtseqsIfWrapper (
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void PAPI * SecurityDescriptor OPTIONAL
    )
{
    RPC_POLICY Policy ;

    if (FireWallFlag)
        {
        Policy.Length = sizeof(RPC_POLICY) ;
        Policy.NICFlags = RPC_C_BIND_TO_ALL_NICS ;
        return RpcServerUseAllProtseqsIfEx(MaxCalls, IfSpec, SecurityDescriptor, &Policy) ;
        }
    else
        {
        return RpcServerUseAllProtseqsIf(MaxCalls, IfSpec, SecurityDescriptor) ;
        }
}

#if 0
void
GlobalMutexRequest (
    void
    )
{
    I_RpcRequestMutex(&PrintMutex);
}

void
GlobalMutexClear (
    void
    )
{
    I_RpcClearMutex(PrintMutex);
}
#endif

void
OtherError ( // Some other error occured; again, we just print a message.
    IN char * Routine, // The routine where the error occured.
    IN char * Message
    )
{
    if (ErrorFlag)
        {
        I_RpcRequestMutex(&PrintMutex);
        PrintToConsole("    Error in %s (%s)\n",Routine,Message);
        I_RpcClearMutex(PrintMutex);
        }
}

void
Shutdown ( // Awaken the thread waiting on WaitForShutdown.
    )
{
    Status = RpcMgmtStopServerListening(0);
    if (Status)
        {
        ApiError("Shutdown","RpcMgmtStopServerListening",Status);
        }
    ShutdownCalled = 1 ;
}

RPC_STATUS
IfCallbackFunction(
    IN RPC_IF_HANDLE  InterfaceUuid,
    IN void *Context
    )
{
    return (RPC_S_OK) ;
}

RPC_STATUS
stub_RegisterIf (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID PAPI * MgrTypeUuid OPTIONAL,
    IN RPC_MGR_EPV PAPI * MgrEpv OPTIONAL
    )
{
    unsigned int Flags = 0;

    if (AutoListenFlag)
        {
        Flags |= RPC_IF_AUTOLISTEN ;
        ShutdownCalled = 0 ;
        }

    if (IFSecurity)
        {
        Flags |= RPC_IF_ALLOW_SECURE_ONLY;
        }

    return RpcServerRegisterIf2(IfSpec, MgrTypeUuid, MgrEpv,
                                               Flags, 1000, MaxRpcSize, 0);
}

RPC_STATUS
stub_ServerListen (
    IN unsigned int MinimumCallThreads,
    IN unsigned int MaxCalls,
    IN unsigned int DontWait
    )
{
    if (AutoListenFlag)
        {
        while (ShutdownCalled == 0)
            {
            PauseExecution(500) ;
            }
        return (RPC_S_OK) ;
        }
    else
        {
        return RpcServerListen(MinimumCallThreads, MaxCalls, DontWait) ;
        }
}

void IsabelleError (
    )
{
    IsabelleErrors += 1 ;
}

void HelgaError (
    )
{
    HelgaErrors += 1 ;
}

void SylviaError (
    )
{
    SylviaErrors += 1 ;
}

#define SIGFRIED 0
#define ELLIOTMINIMIZE 1
#define ELLIOTMAXIMIZE 2
#define ELLIOTNORMAL 3
#define ANDROMIDA 4
#define FREDRICK 7
#define ISABELLENORMAL 10
#define ISABELLEMINIMIZE 11
#define ISABELLEMAXIMIZE 12
#define CHRISTOPHER 13
#define CHRISTOPHERHELGA 14
#define CHRISTOPHERISABELLE 15
#define TYLER 17
#define CHRISTOPHERMUSTFAILONE 18
#define CHRISTOPHERMUSTFAILTWO 19
#define RICHARD 20
#define RICHARDHELPER 21
#define DAVIDFIRST 22
#define DAVIDSECOND 23
#define BARTHOLOMEW 24
#define GRANT 25
#define HERMAN 26
#define IVAN 27
#define JASON 28
#define KENNETH 29
#define TESTYIELD 30
#define SPIPE TESTYIELD
#define SECURITY_ERROR TESTYIELD


/*
Transports:

    Update this to add a new transport.
*/

char * NamepipeAddresses [] =
{
    "\\pipe\\sigfried",
    "\\pipe\\elliotmi",
    "\\pipe\\elliotma",
    "\\pipe\\elliotno",
    "\\pipe\\andromno",
    0,
    0,
    "\\pipe\\fredrick",
    0,
    0,
    "\\pipe\\isabelno",
    "\\pipe\\isabelmi",
    "\\pipe\\isabelma",
    "\\pipe\\christ",
    "\\pipe\\zippyhe",
    "\\pipe\\zippyis",
    0,
    "\\pipe\\tyler",
    "\\\blippo",
    "\\\\\\chrismft",
    "\\pipe\\richard",
    "\\pipe\\richardh",
    "\\pipe\\david1",
    "\\pipe\\david2",
    "\\pipe\\bart",
    "\\pipe\\grant",
    "\\pipe\\herman",
    "\\pipe\\ivan",
    "\\pipe\\jason",
    "\\pipe\\kenneth",
    "\\pipe\\testyield"
};

char * DspAddresses [] =
{
    "\\pipe\\sigfried",
    "\\pipe\\elliotmi",
    "\\pipe\\elliotma",
    "\\pipe\\elliotno",
    "\\pipe\\andromno",
    0,
    0,
    "\\pipe\\fredrick",
    0,
    0,
    "\\pipe\\isabelno",
    "\\pipe\\isabelmi",
    "\\pipe\\isabelma",
    "\\pipe\\christ",
    "\\pipe\\zippyhe",
    "\\pipe\\zippyis",
    0,
    "\\pipe\\tyler",
    "",
    "",
    "\\pipe\\richard",
    "\\pipe\\richardh",
    "\\pipe\\david1",
    "\\pipe\\david2",
    "\\pipe\\bart",
    "\\pipe\\grant",
    "\\pipe\\herman",
    "\\pipe\\ivan",
    "\\pipe\\jason",
    "\\pipe\\kenneth",
    "\\pipe\\testyield"
};

char * NetBiosAddresses [] =
{
    "201",    // sigfried
    "202",    // elliotmi
    "203",    // elliotma
    "204",    // elliotno
    "205",    // andromno
    0,
    0,
    "206",    // fredrick
    0,
    0,
    "207",    // isabelno
    "208",    // isabelmi
    "209",    // isabelma
    "210",    // christ
    "211",    // zippyhe
    "212",    // zippyis
    0,
    "214",    // tyler
    "300",    // christ fail 1
    "BadName",// christ fail 2
    "215",    // richard
    "216",    // richardh
    "217",    // david1
    "218",    // david2
    "219",    // bart
    "220",    // grant
    "221",    // herman
    "222",    // ivan
    "223",    // jason
    "224",     // kenneth
    "225"     //testyield
};

char * TCPAddresses [] =
{
    "2025", // SIGFRIED
    "2026", // ELLIOTMINIMIZE
    "2027", // ELLIOTMAXIMIZE
    "2028", // ELLIOTNORMAL
    "2029", // ANDROMIDA
    0,
    0,
    "2032", // FREDRICK
    0,
    0,
    "2035", // ISABELLENORMAL
    "2036", // ISABELLEMINIMIZE
    "2037", // ISABELLEMAXIMIZE
    "2038", // CHRISTOPHER
    "2039", // CHRISTOPHERHELGA
    "2040", // CHRISTOPHERISABELLE
    0,
    "2042", // TYLER
    "chrismfo",
    "chrismft",
    "2043", // RICHARD
    "2044", // RICHARDHELPER
    "2045", // D1
    "2046", // D2
    "2047", // BARTHOLOMEW
    "2048", // GRANT
    "2049", // HERMAN
    "2050", // IVAN
    "2051", // JASON
    "2052",  // KENNETH
    "2053"  // TESTYIELD
};

char * UDPAddresses [] =
{
    "2025", // SIGFRIED
    "2026", // ELLIOTMINIMIZE
    "2027", // ELLIOTMAXIMIZE
    "2028", // ELLIOTNORMAL
    "2029", // ANDROMIDA
    0,
    0,
    "2032", // FREDRICK
    0,
    0,
    "2035", // ISABELLENORMAL
    "2036", // ISABELLEMINIMIZE
    "2037", // ISABELLEMAXIMIZE
    "2038", // CHRISTOPHER
    "2039", // CHRISTOPHERHELGA
    "2040", // CHRISTOPHERISABELLE
    0,
    "2042", // TYLER
    "chrismfo",
    "chrismft",
    "2043", // RICHARD
    "2044", // RICHARDHELPER
    "2045", // D1
    "2046", // D2
    "2047", // BARTHOLOMEW
    "2048", // GRANT
    "2049", // HERMAN
    "2050", // IVAN
    "2051", // JASON
    "2052",  // KENNETH
    "2053"  // TESTYIELD
};

char * SPCAddresses [] =
{
    "sigfried",
    "elliotminimize",
    "elliotmaximize",
    "elliotnormal",
    "andromida",
    0,
    0,
    "fredrick",
    0,
    0,
    "isabellenormal",
    "isabelleminimize",
    "isabellemaximize",
    "christopher",
    "christopherhelga",
    "christopherisabelle",
    0,
    "tyler",
    "\\christophermustfailone",
    "christopher\\mustfailtwo",
    "richard",
    "richardhelper",
    "davidfirst",
    "davidsecond",
    "bartholomew",
    "grant",
    "herman",
    "ivan",
    "jason",
    "kenneth",
    "testyield"
};

char * SPXAddresses [] =
{
    "5000",    // sigfried
    "5001",    // elliotmi
    "5002",    // elliotma
    "5003",    // elliotno
    "5004",    // andromno
    "5005",
    "5006",
    "5007",    // fredrick
    "5008",
    "5009",
    "5010",    // isabelno
    "5011",    // isabelmi
    "5012",    // isabelma
    "5013",    // christ
    "5014",    // zippyhe
    "5015",    // zippyis
    "5016",
    "5017",    // tyler
    "hello",    // christ fail 1
    "50195019",    // christ fail 2
    "5020",    // richard
    "5021",    // richardh
    "5022",    // david1
    "5023",    // david2
    "5024",    // bart
    "5025",    // grant
    "5026",    // herman
    "5027",    // ivan
    "5028",    // jason
    "5029",     // kenneth
    "5030"     // testyield
};

char * IPXAddresses [] =
{
    "5000",    // sigfried
    "5001",    // elliotmi
    "5002",    // elliotma
    "5003",    // elliotno
    "5004",    // andromno
    "5005",
    "5006",
    "5007",    // fredrick
    "5008",
    "5009",
    "5010",    // isabelno
    "5011",    // isabelmi
    "5012",    // isabelma
    "5013",    // christ
    "5014",    // zippyhe
    "5015",    // zippyis
    "5016",
    "5017",    // tyler
    "hello",    // christ fail 1
    "50195019",    // christ fail 2
    "5020",    // richard
    "5021",    // richardh
    "5022",    // david1
    "5023",    // david2
    "5024",    // bart
    "5025",    // grant
    "5026",    // herman
    "5027",    // ivan
    "5028",    // jason
    "5029",     // kenneth
    "5030"     // testyield
};


char * VNSAddresses [] =
{
    "250",    // sigfried
    "251",    // elliotmi
    "252",    // elliotma
    "253",    // elliotno
    "254",    // andromno
    "255",
    "256",
    "257",    // fredrick
    "258",
    "259",
    "260",    // isabelno
    "261",    // isabelmi
    "262",    // isabelma
    "263",    // christ
    "264",    // zippyhe
    "265",    // zippyis
    "266",
    "267",    // tyler
    "hello",    // christ fail 1
    "50195019",    // christ fail 2
    "270",    // richard
    "271",    // richardh
    "272",    // david1
    "273",    // david2
    "274",    // bart
    "275",    // grant
    "276",    // herman
    "277",    // ivan
    "278",    // jason
    "279",     // kenneth
    "280"     // testyield
};

char * MSMQAddresses [] =
{
    "SIGFRIED",
    "ELLIOTMINIMIZE",
    "ELLIOTMAXIMIZE",
    "ELLIOTNORMAL",
    "ANDROMIDA",
    0,
    0,
    "FREDRICK",
    0,
    0,
    "ISABELLENORMAL",
    "ISABELLEMINIMIZE",
    "ISABELLEMAXIMIZE",
    "CHRISTOPHER",
    "CHRISTOPHERHELGA",
    "CHRISTOPHERISABELLE",
    0,
    "TYLER",
    " \\  \\  \\chrismfo",
    "chr\\\\\\\\  $$$$ismft",
    "RICHARD",
    "RICHARDHELPER",
    "D1",
    "D2",
    "BARTHOLOMEW",
    "GRANT",
    "HERMAN",
    "IVAN",
    "JASON",
    "KENNETH",
    "TESTYIELD"
};



unsigned char *
GetProtocolSequence (
    )
/*++

Routine Description:

    This routine is used to obtain an rpc protocol sequence.

Return Value:

    A pointer to an rpc protocol sequence is returned.  This pointer
    should not be freed.

Transports:

    Update this to add a new transport.

--*/
{
    if (TransportType == RPC_TRANSPORT_NAMEPIPE)
        return((unsigned char *) "ncacn_np");

    if (TransportType == RPC_LRPC)
        {
        return((unsigned char *) "ncalrpc");
        }

    if (TransportType == RPC_TRANSPORT_NETBIOS)
        return((unsigned char *) NetBiosProtocol);

    if (TransportType == RPC_TRANSPORT_SPX)
        return((unsigned char *) "ncacn_spx");

    if (TransportType == RPC_TRANSPORT_TCP)
        return((unsigned char *) "ncacn_ip_tcp");

    if (TransportType == RPC_TRANSPORT_UDP)
        return((unsigned char *) "ncadg_ip_udp");

    if (TransportType == RPC_TRANSPORT_IPX)
        return((unsigned char *) "ncadg_ipx");

    if (TransportType == RPC_TRANSPORT_DSP)
            return((unsigned char *) "ncacn_at_dsp") ;

    if (TransportType == RPC_TRANSPORT_VNS)
                return((unsigned char *) "ncacn_vns_spp") ;

    if (TransportType == RPC_TRANSPORT_MSMQ)
                return((unsigned char *) "ncadg_mq") ;

    return(0);
}


unsigned char *
GetEndpoint (
    IN unsigned int Endpoint
    )
/*++

Routine Description:

    This routine is used to obtain the endpoint corresponding to a
    give endpoint index.

Arguments:

    Endpoint - Supplies an index into a table of endpoints.

Return Value:

    A pointer to an endpoint from the table of endpoints will be returned.

Transports:

    Update this to add a new transport.

--*/
{
    if (TransportType == RPC_TRANSPORT_NAMEPIPE)
        return((unsigned char *) NamepipeAddresses[Endpoint]);

    else if (TransportType == RPC_TRANSPORT_NETBIOS)
        return((unsigned char *) NetBiosAddresses[Endpoint]);

    else if (TransportType == RPC_TRANSPORT_TCP)
        return((unsigned char *) TCPAddresses[Endpoint]);

    else if (TransportType == RPC_TRANSPORT_UDP)
        return((unsigned char *) UDPAddresses[Endpoint]);

    else if ((TransportType == RPC_LRPC) || (TransportType == RPC_WMSG))
        return((unsigned char *) SPCAddresses[Endpoint]);

    else if (TransportType == RPC_TRANSPORT_SPX)
        return((unsigned char *) SPXAddresses[Endpoint]);

    else if (TransportType == RPC_TRANSPORT_IPX)
        return((unsigned char *) IPXAddresses[Endpoint]);

    else if (TransportType == RPC_TRANSPORT_VNS)
        return((unsigned char *) VNSAddresses[Endpoint]);

    else if (TransportType == RPC_TRANSPORT_DSP)
                return ((unsigned char *) DspAddresses[Endpoint]) ;

    else if (TransportType == RPC_TRANSPORT_MSMQ)
                return ((unsigned char *) MSMQAddresses[Endpoint]) ;

    return(0);
}


/* --------------------------------------------------------------------

Helga Interface

-------------------------------------------------------------------- */

unsigned int HelgaCheckManagerEpv = 0;
RPC_MGR_EPV PAPI * HelgaManagerEpv;
unsigned int HelgaCheckObject = 0;
unsigned short HelgaMagicNumber;


int
CheckUuidValue (
    IN unsigned short MagicNumber,
    OUT UUID PAPI * Uuid
    )
/*++

Routine Description:

    This routine is used to check that a generated uuid value is correct.

Arguments:

    MagicNumber - Supplies a magic number which will be used to
        check a generated uuid.

    Uuid - Supplies a generated uuid to check.

Return Value:

    Zero will be returned if the uuid value is correct; otherwise, non-zero
    will be returned.

--*/
{
    if ( Uuid->Data1 != ((unsigned long) MagicNumber)
                * ((unsigned long) MagicNumber))
        return(1);
    if ( Uuid->Data2 != MagicNumber )
        return(1);
    if ( Uuid->Data3 != MagicNumber / 2 )
        return(1);
    if ( Uuid->Data4[0] != MagicNumber % 256 )
        return(1);
    if ( Uuid->Data4[1] != MagicNumber % 257 )
        return(1);
    if ( Uuid->Data4[2] != MagicNumber % 258 )
        return(1);
    if ( Uuid->Data4[3] != MagicNumber % 259 )
        return(1);
    if ( Uuid->Data4[4] != MagicNumber % 260 )
        return(1);
    if ( Uuid->Data4[5] != MagicNumber % 261 )
        return(1);
    if ( Uuid->Data4[6] != MagicNumber % 262 )
        return(1);
    if ( Uuid->Data4[7] != MagicNumber % 263 )
        return(1);
    return(0);
}


void
InitializeBuffer (
    IN OUT void PAPI * Buffer,
    IN unsigned int BufferLength
    )
/*++

Routine Description:

    This routine is used to initialize the buffer; the first long in the
    buffer is set to be the length of the buffer.  The rest of the buffer
    is initialized with a pattern which will be checked by the receiver.

Arguments:

    Buffer - Supplies the buffer to be initialized.

    BufferLength - Supplies the length of the buffer.

--*/
{
    unsigned long PAPI * Length;
    unsigned char PAPI * BufferScan;
    static unsigned char InitialValue = 69;
    unsigned char Value;

    Length = (unsigned long PAPI *) Buffer;
    *Length = BufferLength;
    Value = InitialValue;
    InitialValue += 1;

    for (BufferScan = (unsigned char PAPI *) (Length + 1), BufferLength -= 4;
        BufferLength > 0; BufferLength--, BufferScan++, Value++)
        *BufferScan = Value;
}


int
CheckBuffer (
    IN void PAPI * Buffer,
    IN unsigned long BufferLength
    )
/*++

Routine Description:

    We need to check that the correct bytes were sent.  We do not check
    the length of the buffer.

Arguments:

    Buffer - Supplies the buffer to be checked.

    BufferLength - Supplies the length of the buffer to be checked.

Return Value:

    A value of zero will be returned if the buffer contains the correct
    bytes; otherwise, non-zero will be returned.

--*/
{
    unsigned long PAPI * Length;
    unsigned char PAPI * BufferScan;
    unsigned char Value;

    Length = (unsigned long PAPI *) Buffer;

    for (BufferScan = (unsigned char PAPI *) (Length + 1),
                Value = *BufferScan, BufferLength -= 4;
                BufferLength > 0; BufferLength--, BufferScan++, Value++)
        {
        if (*BufferScan != Value)
            {
            return(1);
            }
        }

    return(0);
}



int
CheckInitialBuffer (
    IN void PAPI * Buffer,
    IN unsigned long BufferLength,
    OUT unsigned char * pNextValue
    )
/*++

Routine Description:

    We need to check that the correct bytes were sent.  We do not check
    the length of the buffer.

Arguments:

    Buffer - Supplies the buffer to be checked.

    BufferLength - Supplies the length of the buffer to be checked.

Return Value:

    A value of zero will be returned if the buffer contains the correct
    bytes; otherwise, non-zero will be returned.

--*/
{
    unsigned long PAPI * Length;
    unsigned char PAPI * BufferScan;
    unsigned char Value;

    Length = (unsigned long PAPI *) Buffer;

    for (BufferScan = (unsigned char PAPI *) (Length + 1),
                Value = *BufferScan, BufferLength -= 4;
                BufferLength > 0; BufferLength--, BufferScan++, Value++)
        {
        if (*BufferScan != Value)
            {
            return(1);
            }
        }

    *pNextValue = Value;

    return(0);
}



int
CheckContinuedBuffer (
    IN void PAPI * Buffer,
    IN unsigned long BufferLength,
    IN  unsigned char BeginningValue,
    OUT unsigned char * pNextValue
    )
/*++

Routine Description:

    We need to check that the correct bytes were sent.  We do not check
    the length of the buffer.

Arguments:

    Buffer - Supplies the buffer to be checked.

    BufferLength - Supplies the length of the buffer to be checked.

Return Value:

    A value of zero will be returned if the buffer contains the correct
    bytes; otherwise, non-zero will be returned.

    *pValue

--*/
{
    unsigned long PAPI * Length;
    unsigned char PAPI * BufferScan;
    unsigned char Value;

    for (BufferScan = (unsigned char PAPI *) Buffer, Value = BeginningValue;
         BufferLength > 0;
         BufferLength--, BufferScan++, Value++)
        {
        if (*BufferScan != Value)
            {
            return(1);
            }
        }

    *pNextValue = Value;

    return(0);
}


extern RPC_DISPATCH_TABLE HelgaDispatchTable;

RPC_PROTSEQ_ENDPOINT HelgaRpcProtseqEndpoint[] =
{
    {(unsigned char *) "ncacn_np",
#ifdef WIN32RPC
     (unsigned char *) "\\pipe\\zippyhe"},
#else // WIN32RPC
     (unsigned char *) "\\device\\namedpipe\\christopherhelga"},
#endif // WIN32RPC
    {(unsigned char *) "ncacn_ip_tcp", (unsigned char *) "2039"},
    {(unsigned char *) "ncadg_ip_udp", (unsigned char *) "2039"},
    {(unsigned char *) "ncalrpc", (unsigned char *) "christopherhelga"},
    {(unsigned char *) "ncacn_nb_nb", (unsigned char *) "211"},
    {(unsigned char *) "ncacn_spx", (unsigned char *) "5014"},
    {(unsigned char *) "ncadg_ipx", (unsigned char *) "5014"},
    {(unsigned char *) "ncacn_vns_spp", (unsigned char *) "264"},
    {(unsigned char *) "ncacn_at_dsp",(unsigned char *) "\\pipe\\zippyhe"},
    {(unsigned char *) "ncadg_mq",(unsigned char *) "christopherhelga"}
};

RPC_SERVER_INTERFACE HelgaInterfaceInformation =
{
    sizeof(RPC_SERVER_INTERFACE),
    {{1,2,2,{3,3,3,3,3,3,3,3}},
     {1,1}},
    {{0x8A885D04, 0x1CEB, 0x11C9, {0x9F, 0xE8, 0x08, 0x00, 0x2B, 0x10, 0x48, 0x60}},
     {2, 0}},
    &HelgaDispatchTable,
    sizeof(HelgaRpcProtseqEndpoint) / sizeof(RPC_PROTSEQ_ENDPOINT),
    HelgaRpcProtseqEndpoint,
    NULL,
    NULL,
    RPC_INTERFACE_HAS_PIPES
};

void __RPC_STUB
HelgaStub (
    PRPC_MESSAGE Callee
    )
{
    UUID ObjectUuid;

    CompleteReceive(Callee) ;

    if ( HelgaCheckObject != 0 )
        {
        Status = RpcBindingInqObject(Callee->Handle, &ObjectUuid);
        if (Status)
            {
            ApiError("HelgaStub", "RpcBindingInqObject", Status);
            HelgaError();
            }
        else if ( CheckUuidValue(HelgaMagicNumber, &ObjectUuid) != 0 )
            {
            OtherError("HelgaStub", "CheckUuidValue() != 0");
            HelgaError();
            }

        Status = RpcBindingInqObject(0, &ObjectUuid);  // zero handle
        if (Status)
            {
            ApiError("HelgaStub", "RpcBindingInqObject", Status);
            HelgaError();
            }
        else if ( CheckUuidValue(HelgaMagicNumber, &ObjectUuid) != 0 )
            {
            OtherError("HelgaStub", "CheckUuidValue() != 0");
            HelgaError();
            }
        }
    HelgaMagicNumber += 1;

    if ( Callee->ProcNum != 0 )
        {
        OtherError("HelgaStub", "Callee->ProcNum != 0");
        HelgaError();
        }

    if ( memcmp(Callee->RpcInterfaceInformation, &HelgaInterfaceInformation,
                sizeof(HelgaInterfaceInformation)) != 0 )
        {
        OtherError("HelgaStub",
                "Callee->RpcInteraceInformation != &HelgaInterfaceInformation");
        HelgaError();
        }

    if ( HelgaCheckManagerEpv != 0 )
        {
        if ( Callee->ManagerEpv != HelgaManagerEpv )
            {
            OtherError("HelgaStub", "Callee->ManagerEpv != HelgaManagerEpv");
            HelgaError();
            }
        }

    if (Callee->BufferLength != 0)
        {
        OtherError("HelgaStub","*BufferLength != 0");
        HelgaError();
        }

    Callee->BufferLength = 0;

    Status = I_RpcGetBuffer(Callee);

    if (Status)
        {
        ApiError("HelgaStub","I_RpcGetBuffer",Status);
        HelgaError();
        }
}

void __RPC_STUB
HelgaINStub (
    PRPC_MESSAGE Callee
    )
{
    unsigned long Length;
    UUID ObjectUuid;

    if ( HelgaCheckObject != 0 )
        {
        Status = RpcBindingInqObject(Callee->Handle, &ObjectUuid);
        if (Status)
            {
            ApiError("HelgaINStub", "RpcBindingInqObject", Status);
            HelgaError();
            }
        else if ( CheckUuidValue(HelgaMagicNumber, &ObjectUuid) != 0 )
            {
            OtherError("HelgaINStub", "CheckUuidValue() != 0");
            HelgaError();
            }
        }
    HelgaMagicNumber += 1;

    if ( Callee->ProcNum != 1 )
        {
        OtherError("HelgaINStub", "Callee->ProcNum != 0");
        HelgaError();
        }

    if ( memcmp(Callee->RpcInterfaceInformation, &HelgaInterfaceInformation,
                sizeof(HelgaInterfaceInformation)) != 0 )
        {
        OtherError("HelgaINStub",
                "Callee->RpcInteraceInformation != &HelgaInterfaceInformation");
        HelgaError();
        }

    if ( HelgaCheckManagerEpv != 0 )
        {
        if ( Callee->ManagerEpv != HelgaManagerEpv )
            {
            OtherError("HelgaINStub", "Callee->ManagerEpv != HelgaManagerEpv");
            HelgaError();
            }
        }

    //
    // Check the data we have so far.
    //
    Length = *(unsigned long *) Callee->Buffer;
    if (Length < Callee->BufferLength)
        {
        OtherError("HelgaINStub","*Length < *BufferLength");
        HelgaError();
        }

    if (0 == (Callee->RpcFlags & RPC_BUFFER_COMPLETE))
        {
        CompleteReceive(Callee) ;
        }

    if (Length != Callee->BufferLength)
        {
        OtherError("HelgaINStub","incomplete buffer marked as complete");
        HelgaError();
        }

    unsigned char InitialValue;
    if (CheckInitialBuffer(Callee->Buffer, Callee->BufferLength, &InitialValue) != 0)
        {
        OtherError("HelgaINStub","CheckBuffer Failed");
        HelgaError();
        }

    //
    // The [out] buffer.
    //
    Callee->BufferLength = 0;

    Status = I_RpcGetBuffer(Callee);

    if (Status)
        {
        ApiError("HelgaINStub","I_RpcGetBuffer",Status);
        HelgaError();
        }
}

void __RPC_STUB
HelgaOUTStub (
    PRPC_MESSAGE Callee
    )
{
    unsigned long * Length;
    unsigned int Size;
    UUID ObjectUuid;

    CompleteReceive(Callee) ;

    if ( HelgaCheckObject != 0 )
        {
        Status = RpcBindingInqObject(Callee->Handle, &ObjectUuid);
        if (Status)
            {
            ApiError("HelgaOUTStub", "RpcBindingInqObject", Status);
            HelgaError();
            }
        else if ( CheckUuidValue(HelgaMagicNumber, &ObjectUuid) != 0 )
            {
            OtherError("HelgaOUTStub", "CheckUuidValue() != 0");
            HelgaError();
            }
        }
    HelgaMagicNumber += 1;

    if ( Callee->ProcNum != 2 )
        {
        OtherError("HelgaOUTStub", "Callee->ProcNum != 0");
        HelgaError();
        }

    if ( memcmp(Callee->RpcInterfaceInformation, &HelgaInterfaceInformation,
                sizeof(HelgaInterfaceInformation)) != 0 )
        {
        OtherError("HelgaOUTStub",
                "Callee->RpcInteraceInformation != &HelgaInterfaceInformation");
        HelgaError();
        }

    if ( HelgaCheckManagerEpv != 0 )
        {
        if ( Callee->ManagerEpv != HelgaManagerEpv )
            {
            OtherError("HelgaOUTStub", "Callee->ManagerEpv != HelgaManagerEpv");
            HelgaError();
            }
        }

    if (Callee->BufferLength != sizeof(unsigned long))
        {
        //
        // secure datagram calls round the stub data length to a multiple
        // of eight.
        //
        if (!DatagramFlag || Callee->BufferLength != 8)
            {
            OtherError("HelgaOUTStub","*BufferLength != sizeof(unsigned int)");
            HelgaError();
            }
        }

    Length = (unsigned long *) Callee->Buffer;
    Size = (unsigned int) *Length;
    Callee->BufferLength = Size;

    Status = I_RpcGetBuffer(Callee);

    if (Status)
        {
        ApiError("HelgaOUTStub","I_RpcGetBuffer",Status);
        HelgaError();
        }
    else
        {
        InitializeBuffer(Callee->Buffer, Size);
        }
}

void __RPC_STUB
HelgaINOUTStub (
    PRPC_MESSAGE Callee
    )
{
    unsigned long Length;
    UUID ObjectUuid;

    if ( HelgaCheckObject != 0 )
        {
        Status = RpcBindingInqObject(Callee->Handle, &ObjectUuid);
        if (Status)
            {
            ApiError("HelgaINOUTStub", "RpcBindingInqObject", Status);
            HelgaError();
            }
        else if ( CheckUuidValue(HelgaMagicNumber, &ObjectUuid) != 0 )
            {
            OtherError("HelgaINOUTStub", "CheckUuidValue() != 0");
            HelgaError();
            }
        }
    HelgaMagicNumber += 1;

    if ( Callee->ProcNum != 3 )
        {
        OtherError("HelgaINOUTStub", "Callee->ProcNum != 0");
        HelgaError();
        }

    if ( memcmp(Callee->RpcInterfaceInformation, &HelgaInterfaceInformation,
                sizeof(HelgaInterfaceInformation)) != 0 )
        {
        OtherError("HelgaINOUTStub",
                "Callee->RpcInteraceInformation != &HelgaInterfaceInformation");
        HelgaError();
        }

    if ( HelgaCheckManagerEpv != 0 )
        {
        if ( Callee->ManagerEpv != HelgaManagerEpv )
            {
            OtherError("HelgaINOUTStub",
                    "Callee->ManagerEpv != HelgaManagerEpv");
            HelgaError();
            }
        }

    //
    // Check the data we have so far.
    //
    Length = *(unsigned long *) Callee->Buffer;
    if (Length < Callee->BufferLength)
        {
        OtherError("HelgaINOUTStub","*Length < *BufferLength");
        HelgaError();
        }

    unsigned char InitialValue;
    if (CheckInitialBuffer(Callee->Buffer, Callee->BufferLength, &InitialValue) != 0)
        {
        OtherError("HelgaINOUTStub","initial CheckBuffer Failed");
        HelgaError();
        }

    if (Length > Callee->BufferLength)
        {
        if (Callee->RpcFlags & RPC_BUFFER_COMPLETE)
            {
            OtherError("HelgaINOUTStub","incomplete buffer marked as complete");
            HelgaError();
            }
        }

    if (0 == (Callee->RpcFlags & RPC_BUFFER_COMPLETE))
        {
        //
        // Get the rest of the data and check it.
        //
        CompleteReceive(Callee) ;

        if (0 != CheckInitialBuffer(Callee->Buffer, Callee->BufferLength, &InitialValue))
            {
            OtherError("HelgaINOUTStub","second CheckBuffer Failed");
            HelgaError();
            }
        }

    Callee->BufferLength = Length;

    Status = I_RpcGetBuffer(Callee);

    if (Status)
        {
        ApiError("HelgaINOUTStub","I_RpcGetBuffer",Status);
        HelgaError();
        }
    else
        {
        InitializeBuffer(Callee->Buffer, Length);
        }
}

void Synchro(
    PRPC_MESSAGE Callee
    )
{
    PrintToConsole("Sychro called\n") ;
    RpcServerYield();
}

void SvrLazyFunc(
    PRPC_MESSAGE Callee
    )
{
    PrintToConsole("About to sleep\n") ;
    PauseExecution(100000) ;
    PrintToConsole("Waking up\n") ;

    Shutdown() ;
}

void HelgaLpcSecurity(
    PRPC_MESSAGE Callee
    )
{
    RPC_STATUS RpcStatus ;
    RPC_CHAR *UserName ;

    PrintToConsole("HelgaLpcSecurity\n") ;

    RpcStatus = RpcBindingInqAuthClient(Callee->Handle, (void **) &UserName,
                                        NULL, NULL, NULL, NULL) ;
    if ((RpcStatus != RPC_S_OK) && (RpcStatus != RPC_S_BINDING_HAS_NO_AUTH))
        {
        HelgaError() ;


        PrintToConsole("HelgaLpcSecurity: (1) UserName: %S\n", UserName) ;
        }

    UserName = NULL ;

    RpcStatus = RpcBindingInqAuthClient(Callee->Handle, (void **) &UserName,
                                        NULL, NULL, NULL, NULL) ;
    if ((RpcStatus != RPC_S_OK) && (RpcStatus != RPC_S_BINDING_HAS_NO_AUTH))
        {
        HelgaError() ;
        PrintToConsole("HelgaLpcSecurity: (2) UserName: %S\n", UserName) ;
        }
}

void
HelgaObjectUuids (
    PRPC_MESSAGE Callee
    )
{
    PrintToConsole("HelgaObjectUuids\n") ;

    char *Ptr = (char *) Callee->Buffer;
    BOOL fObjectUuid = *((BOOL *) Ptr);
    UUID MyObjectUuid;

    Status = RpcBindingInqObject(Callee->Handle, &MyObjectUuid);
    if (Status)
        {
        ApiError("HelgaStub", "RpcBindingInqObject", Status);
        HelgaError();
        RpcRaiseException(Status);
        }

    UUID Uuid;
    Ptr += sizeof(BOOL);

    if (fObjectUuid)
        {
        RpcpMemoryCopy(&Uuid, Ptr, sizeof(UUID));
        }
    else
        {
        RpcpMemorySet(&Uuid, 0, sizeof(UUID));
        }

    if (RpcpMemoryCompare(&Uuid, &MyObjectUuid, sizeof(UUID)))
        {
        HelgaError();
        RpcRaiseException(-1);
        }

    Callee->BufferLength = 0;

    Status = I_RpcGetBuffer(Callee);

    if (Status)
        {
        ApiError("HelgaStub","I_RpcGetBuffer",Status);
        HelgaError();
        RpcRaiseException(Status);
        }
}

void
HelgaConnId (
    PRPC_MESSAGE Callee
    )
{
    PrintToConsole("HelgaConnId\n") ;
    static void *OldId = 0;
    void *ConnId;
    BOOL fFirstTime;

    Status = I_RpcBindingInqConnId(
                                   Callee->Handle,
                                   &ConnId,
                                   &fFirstTime);
    if (Status)
        {
        HelgaError();
        ApiError("HelgaStub","I_RpcBindingInqConnId",Status);
        RpcRaiseException(Status);
        }

    PrintToConsole("HelgaConnId: ConnId: %p, fFirstTime: %d\n", ConnId, fFirstTime);

    char *Ptr = (char *) Callee->Buffer;
    BOOL fNewConnExpected = *((BOOL *) Ptr);


    if (fNewConnExpected != fFirstTime)
        {
        HelgaError();
        RpcRaiseException(-1);
        }

    if (fFirstTime)
        {
        OldId = ConnId;
        }
    else
        {
        if (ConnId != OldId)
            {
            HelgaError();
            RpcRaiseException(-1);
            }
        }

    Callee->BufferLength = 0;

    Status = I_RpcGetBuffer(Callee);

    if (Status)
        {
        ApiError("HelgaStub","I_RpcGetBuffer",Status);
        HelgaError();
        RpcRaiseException(Status);
        }
}

typedef struct _WIRE_CONTEXT
{
    unsigned long ContextType;
    UUID ContextUuid;
} WIRE_CONTEXT;

void UsvrRundown (
    void *Context
    )
{
    PrintToConsole("UsvrRundown called");
}

// partial replica of SCONTEXTItem in scontext.cxx
typedef struct tagUserContext
{
    void *R1;
    void *R2;
    void * userContext;       /* context for the user */
} UserContext;


// the buffer should be of type and size WIRE_CONTEXT
void OpenContextHandle (
    RPC_MESSAGE *Callee
    )
{
    void *pGuard;
    RPC_SERVER_INTERFACE *ServerIf;
    RPC_STATUS RpcStatus;
    void *Context;
    WIRE_CONTEXT WireContext;

    ASSERT(Callee->BufferLength == sizeof(WIRE_CONTEXT));

    if (Callee->ProcNum == 21)
        {
        ServerIf = &IsabelleInterfaceInformation;
        }
    else if (Callee->ProcNum == 10)
        {
        ServerIf = &HelgaInterfaceInformation;
        }
    else
        {
        ASSERT(0);
        }

    pGuard = &ServerIf->InterfaceId;

    Context = NDRSContextUnmarshall2(Callee->Handle,
        Callee->Buffer,
        10,
        pGuard,
        0);

    ((UserContext *)Context)->userContext = pGuard;

    Callee->BufferLength = 0;

    RpcStatus = I_RpcGetBuffer(Callee);
    if (RpcStatus != RPC_S_OK)
        {
        ApiError("Get Buffer", "I_RpcGetBuffer", Status) ;
        return ;
        }

    NDRSContextMarshall2(Callee->Handle,
        (NDR_SCONTEXT)Context,
        &WireContext,
        UsvrRundown,
        pGuard,
        0);
}

extern void
Foo_s (
    PRPC_MESSAGE Message
    ) ;

extern void
FooPipe_s (
    PRPC_MESSAGE Message
    )  ;

extern void
FooBar_s (
    PRPC_MESSAGE Message
    ) ;

void
FooCH_s (
    PRPC_MESSAGE Message
    ) ;



RPC_DISPATCH_FUNCTION HelgaDispatchFunctions[] =
{
        HelgaStub,
        HelgaINStub,
        HelgaOUTStub,
        HelgaINOUTStub,
        Synchro,
        SvrLazyFunc,
        HelgaLpcSecurity,
        Foo_s,
        HelgaObjectUuids,
        HelgaConnId,
        OpenContextHandle
};

RPC_DISPATCH_TABLE HelgaDispatchTable =
{
    11, HelgaDispatchFunctions
};

/* --------------------------------------------------------------------

Sylvia Interface

-------------------------------------------------------------------- */

extern RPC_DISPATCH_TABLE SylviaDispatchTable;

RPC_SERVER_INTERFACE SylviaInterfaceInformation =
{
    sizeof(RPC_SERVER_INTERFACE),
    {{3,2,2,{1,1,1,1,1,1,1,1}},
     {1,1}},
    {{0x8A885D04, 0x1CEB, 0x11C9, {0x9F, 0xE8, 0x08, 0x00, 0x2B, 0x10, 0x48, 0x60}},
     {2, 0}},
    &SylviaDispatchTable,
    0,
    0,
    0,
    0,
    RPC_INTERFACE_HAS_PIPES
};


unsigned int SylviaQueryBinding = 0;
unsigned int SylviaQueryProtocolStack = 0;
unsigned int SylviaQueryCall = 0;
char * SylviaTransportInfo = 0;

unsigned /*int*/ char // Specifies the new count of calls.
SylviaCallback (
    unsigned /*long*/ char Depth, // Specifies the depth of recursion desired.
    unsigned /*long*/ char Breadth, // Specifies the breadth desired.
    unsigned /*long*/ char Count // Specifies the count of calls up to this point.
    )
{
    RPC_MESSAGE Caller;
    unsigned /*long*/ char * plScan, ReturnValue;

    Caller.ProcNum = 0;
    Caller.Handle = I_RpcGetCurrentCallHandle();

    if (Caller.Handle == (RPC_BINDING_HANDLE) 0)
        {
        OtherError("SylviaCallback","Call == (RPC_BINDING_HANDLE) 0");
        SylviaError();
        return(0);
        }

    Caller.BufferLength = sizeof(unsigned /*long*/ char)*4+10240;
    Status = I_RpcGetBuffer(&Caller);
    if (Status)
        {
        ApiError("SylviaCallback","I_RpcGetBuffer",Status);
        SylviaError();
        return(0);
        }
    plScan = (unsigned /*long*/ char *) Caller.Buffer;
    plScan[0] = (unsigned char) Depth;
    plScan[1] = (unsigned char) Breadth;
    plScan[2] = (unsigned char) Count;

    Status = I_RpcSendReceive(&Caller);
    if (Status)
        {
        ApiError("SylviaCallback","I_RpcSendReceive",Status);
        SylviaError();
        return(0);
        }

    plScan = (unsigned /*long*/ char *) Caller.Buffer;
    ReturnValue = *plScan;
    Status = I_RpcFreeBuffer(&Caller);
    if (Status)
        {
        ApiError("SylviaCallback","I_RpcFreeBuffer",Status);
        SylviaError();
        return(0);
        }
    return(ReturnValue);
}

unsigned /*long*/ char
SylviaCallUserCode ( // The user code for SylviaCall.
    unsigned /*long*/ char Depth,
    unsigned /*long*/ char Breadth,
    unsigned /*long*/ char Count
    )
{
    if (Depth > 0)
        {
        if (Depth == Breadth)
            {
            Count = SylviaCallUserCode(Depth-1,Breadth,Count);
            }
        else
            Count = SylviaCallback(Depth-1,Breadth,Count);
        }
    return(Count+1);
}

void __RPC_STUB
SylviaCall (
    PRPC_MESSAGE Callee
    )
{
    unsigned /*long*/ char ReturnValue, *plScan;

    if ( Callee->ProcNum != 0 )
        {
        OtherError("SylviaCall", "Callee->ProcNum != 0");
        SylviaError();
        }

    if ( memcmp(Callee->RpcInterfaceInformation, &SylviaInterfaceInformation,
                sizeof(SylviaInterfaceInformation)) != 0 )
        {
        OtherError("SylviaCall",
                "Callee->RpcInteraceInformation != &SylviaInterfaceInformation");
        SylviaError();
        }

    if (Callee->BufferLength != sizeof(unsigned /*long*/ char)*4+10240)
        {
        OtherError("SylviaCall","*BufferLength != sizeof(unsigned  char)*4");
        SylviaError();
        }

    plScan = (unsigned /*long*/ char *) Callee->Buffer;

//    if (   SylviaQueryCall
//        && VerifyQueryCall(Callee->Handle,&SylviaProtocolStack))
//        {
//        OtherError("SylviaCallback","VerifyQueryCall");
//        SylviaError();
//        }

//    if (   SylviaQueryBinding
//        && VerifyQueryBinding(Callee->Handle,SylviaServer))
//        {
//        OtherError("SylviaCallback","VerifyQueryBinding");
//        SylviaError();
//        }

//    if (   SylviaQueryProtocolStack
//        && VerifyQueryProtocolStack(Callee->Handle,&SylviaProtocolStack,
//                        SylviaTransportInfo))
//        {
//        OtherError("SylviaCallback","VerifyQueryProtocolStack");
//        SylviaError();
//        }

    ReturnValue = (unsigned char) SylviaCallUserCode(plScan[0],plScan[1],plScan[2]);

//    if (   SylviaQueryCall
//        && VerifyQueryCall(Callee->Handle,&SylviaProtocolStack))
//        {
//        OtherError("SylviaCallback","VerifyQueryCall");
//        SylviaError();
//        }

//    if (   SylviaQueryBinding
//        && VerifyQueryBinding(Callee->Handle,SylviaServer))
//        {
//        OtherError("SylviaCallback","VerifyQueryBinding");
//        SylviaError();
//        }

//    if (   SylviaQueryProtocolStack
//        && VerifyQueryProtocolStack(Callee->Handle,&SylviaProtocolStack,
//                        SylviaTransportInfo))
//        {
//        OtherError("SylviaCallback","VerifyQueryProtocolStack");
//        SylviaError();
//        }

    Callee->BufferLength = sizeof(unsigned /*long*/ char);
    Status = I_RpcGetBuffer((PRPC_MESSAGE) Callee);
    if (Status)
        {
        ApiError("SylviaCall","I_RpcGetBuffer",Status);
        SylviaError();
        }
    plScan = (unsigned /*long*/ char *) Callee->Buffer;
    *plScan = ReturnValue;
}

RPC_DISPATCH_FUNCTION SylviaDispatchFunction[] = {SylviaCall};
RPC_DISPATCH_TABLE SylviaDispatchTable =
{
    1, SylviaDispatchFunction
};

/* --------------------------------------------------------------------

Isabelle Interface

-------------------------------------------------------------------- */


extern RPC_DISPATCH_TABLE IsabelleDispatchTable;

RPC_PROTSEQ_ENDPOINT IsabelleRpcProtseqEndpoint[] =
{
    {(unsigned char *) "ncacn_np",
#ifdef WIN32RPC
     (unsigned char *) "\\pipe\\zippyis"},
#else // WIN32RPC
     (unsigned char *) "\\device\\namedpipe\\christopherisabelle"},
#endif // WIN32RPC
    {(unsigned char *) "ncacn_ip_tcp",(unsigned char *) "2040"},
    {(unsigned char *) "ncadg_ip_udp",(unsigned char *) "2040"},
    {(unsigned char *) "ncalrpc",(unsigned char *) "christopherisabelle"},
    {(unsigned char *) "ncacn_nb_nb",(unsigned char *) "212"},
    {(unsigned char *) "ncacn_nb_tcp",(unsigned char *) "213"},
    {(unsigned char *) "ncacn_nb_ipx",(unsigned char *) "214"},
    {(unsigned char *) "ncacn_spx",(unsigned char *) "5015"},
    {(unsigned char *) "ncadg_ipx",(unsigned char *) "5015"},
    {(unsigned char *) "ncacn_vns_spp",(unsigned char *) "265"},
    {(unsigned char *) "ncacn_at_dsp", (unsigned char *) "\\pipe\\zippyis"},
    {(unsigned char *) "ncadg_mq", (unsigned char *) "christopherisabelle"}
};

RPC_SERVER_INTERFACE IsabelleInterfaceInformation =
{
    sizeof(RPC_SERVER_INTERFACE),
    {{9,8,8,{7,7,7,7,7,7,7,7}},
     {1,1}},
    {{0x8A885D04, 0x1CEB, 0x11C9, {0x9F, 0xE8, 0x08, 0x00, 0x2B, 0x10, 0x48, 0x60}},
     {2, 0}},
    &IsabelleDispatchTable,
    sizeof(IsabelleRpcProtseqEndpoint) / sizeof(RPC_PROTSEQ_ENDPOINT),
    IsabelleRpcProtseqEndpoint,
    0,
    0,
    RPC_INTERFACE_HAS_PIPES
};

void __RPC_STUB
IsabelleShutdown (
    PRPC_MESSAGE Callee
    )
{
    RPC_BINDING_HANDLE BindingHandle;
    unsigned char PAPI * StringBinding;
    unsigned int ClientLocalFlag = 0;
    RPC_STATUS IsClientLocalStatus;

    CompleteReceive(Callee) ;

    Status = I_RpcBindingIsClientLocal(0, &ClientLocalFlag);
    if ( (IsClientLocalStatus = Status) != RPC_S_CANNOT_SUPPORT )
        {
        if ( Status != RPC_S_OK )
            {
            ApiError("IsabelleShutdown", "I_RpcBindingIsClientLocal", Status);
            IsabelleError();
            }
        }

    if (Callee->BufferLength != 0)
        {
        OtherError("IsabelleShutdown","*BufferLength != 0");
        IsabelleError();
        }

    if (AutoListenFlag == 0)
        {
        Status = RpcMgmtIsServerListening(0);
        if (Status)
            {
            ApiError("IsabelleShutdown", "RpcMgmtIsServerListening", Status);
            IsabelleError();
            }
        }

    Status = RpcBindingServerFromClient(Callee->Handle, &BindingHandle);
    if (Status)
        {
        if ( Status != RPC_S_CANNOT_SUPPORT && (DatagramFlag == 0) )
            {
            ApiError("IsabelleShutdown", "RpcBindingServerFromClient", Status);
            IsabelleError();
            }

        if(IsClientLocalStatus == RPC_S_OK)
           {
               if ( ClientLocalFlag != 0 )
                 PrintToConsole("Local Client\n");
               else
                 PrintToConsole("Remote Client\n");
           }
        }
    else
        {
        Status = RpcBindingToStringBindingA(BindingHandle, &StringBinding);
        if (Status)
            {
            ApiError("IsabelleShutdown", "RpcBindingToStringBinding", Status);
            IsabelleError();
            }
        else
            {
            if ( ClientLocalFlag != 0 )
                {
                PrintToConsole("Local Client [%s]\n", StringBinding);
                }
            else
                {
                PrintToConsole("Remote Client [%s]\n", StringBinding);
                }
            RpcStringFreeA(&StringBinding);
            RpcBindingFree(&BindingHandle);
            }
        }

    Shutdown();

    Callee->BufferLength = 0;
    Status = I_RpcGetBuffer(Callee);

    if (Status)
        {
        ApiError("IsabelleShutdown","I_RpcGetBuffer",Status);
        IsabelleError();
        }
}


void __RPC_STUB
IsabelleNtSecurity (
    PRPC_MESSAGE CalleeMessage
    )
/*++

Routine Description:

    A client will call this routine with some quality of service
    specified.  The server will impersonate the client and check
    that the impersonation level is that specified.  The request
    buffer will contain the network options passed by the client
    to RpcBindingFromStringBinding.

Arguments:

    CalleeMessage - Supplies the request message and returns the
        response message for the remote procedure call.

--*/
{
    RPC_STATUS Status;

    Status = RpcImpersonateClient(0);
    if (Status != RPC_S_OK)
        {
        ApiError("IsabelleNtSecurity","RpcImpersonateClient",Status);
        IsabelleError();
        }
    else
        {
        Status = RpcRevertToSelf();
        if (Status != RPC_S_OK)
            {
            ApiError("IsabelleNtSecurity","RpcRevertToSelf",Status);
            IsabelleError();
            }
        else
            {
            Status = RpcImpersonateClient(CalleeMessage->Handle);
            if (Status != RPC_S_OK)
                {
                ApiError("IsabelleNtSecurity","RpcImpersonateClient",
                        Status);
                IsabelleError();
                }
            else
                {
                Status = RpcRevertToSelf();
                if (Status != RPC_S_OK)
                    {
                    ApiError("IsabelleNtSecurity","RpcRevertToSelf",Status);
                    IsabelleError();
                    }
                }
            }
        }

    CalleeMessage->BufferLength = 0;
    Status = I_RpcGetBuffer(CalleeMessage);

    if (Status)
        {
        ApiError("IsabelleNtSecurity","I_RpcGetBuffer",Status);
        IsabelleError();
        }

}

int ChristopherIsabelleError;

void __RPC_STUB
IsabelleToStringBinding (
    PRPC_MESSAGE Callee
    )
{
    unsigned char PAPI * StringBinding;

    if (Callee->BufferLength != 0)
        {
        OtherError("IsabelleToStringBinding","*BufferLength != 0");
        IsabelleError();
        }

    Status = RpcBindingToStringBindingA(Callee->Handle, &StringBinding);
    if (Status)
        {
        ApiError("Christopher","RpcBindingToStringBinding",Status);
        PrintToConsole("Christopher : FAIL - RpcBindingToStringBinding\n");
        ChristopherIsabelleError = 1;
        }
    else
        {
        PrintToConsole("Christopher : (RpcBindingToStringBinding)\n    ");
        PrintToConsole((char *) StringBinding);
        PrintToConsole("\n");

        Status = RpcStringFreeA(&StringBinding);
        if (Status)
            {
            ApiError("Christopher","RpcStringFree",Status);
            PrintToConsole("Christopher : FAIl - RpcStringFree\n");
            ChristopherIsabelleError = 1;
            }
        else
            {
            if (StringBinding != 0)
                {
                PrintToConsole("Christopher : FAIL - ");
                PrintToConsole("StringBinding != 0\n");
                ChristopherIsabelleError = 1;
                }
            }
        }

    Callee->BufferLength = 0;
    Status = I_RpcGetBuffer(Callee);

    if (Status)
        {
        ApiError("Christopher","I_RpcGetBuffer",Status);
        HelgaError();
        }
}

#define RICHARDHELPER_EXIT 1
#define RICHARDHELPER_EXECUTE 2
#define RICHARDHELPER_IGNORE 3
#define RICHARDHELPER_DELAY_EXIT 4


void
RichardHelperExit (
    void * Ignore
    )
{
    PauseExecution(2000L);
    PrintToConsole("Richard : RichardHelper Exiting\n");

#ifdef WIN32RPC

    ExitProcess(0);

#endif // WIN32RPC
}


void __RPC_STUB
IsabelleRichardHelper (
    PRPC_MESSAGE Callee
    )
/*++

Routine Description:

    This routine is the stub (and actually the manager code as well) for
    the IsabelleRichardHelper routine.  The client will call a stub and
    specify a command argument which will be passed in the buffer.  We
    need to extract the argument, and then execute the requested command.

Arguments:

    Callee - Supplies the input arguments and returns the output arguments
        and return value for the stub.

--*/
{
    unsigned /*long*/ char Command;
    RPC_STATUS RpcStatus = RPC_S_OK;

    if (   Callee->BufferLength != sizeof(unsigned char)
        && Callee->BufferLength != sizeof(unsigned long) )
        {
        OtherError("IsabelleRichardHelper",
                "*BufferLength != sizeof(unsigned long)");
        IsabelleError();
        Callee->BufferLength = 0;

         Status = I_RpcGetBuffer(Callee);

        if (Status)
            {
            ApiError("IsabelleRichardHelper","I_RpcGetBuffer",Status);
            IsabelleError();
            }
        return;
        }

    Command = *((unsigned char *) Callee->Buffer);

    if (Command == RICHARDHELPER_EXIT)
        {
        PrintToConsole("Richard : RichardHelper Exiting\n");
#ifdef OS2_12
        DosExit(EXIT_PROCESS, 0);

#endif // OS2_12

#ifdef WIN32RPC

        ExitProcess(0);

#endif // WIN32RPC
        }
    else if (Command == RICHARDHELPER_EXECUTE)
        {
#ifdef OS2_12

        USHORT Os2Status;
        RESULTCODES ResultCodes;
        char CommandLine[200], *pT;

        pT = CommandLine;
        *pT = 0;

        pT += strlen(strcpy(pT, "usvr")) + 1;
        pT += strlen(strcpy(pT, TransportOption));
        pT += strlen(strcpy(pT, "-error -richardhelper")) + 1;
        *pT = 0;

        Os2Status = DosExecPgm(0,0,EXEC_ASYNC, (unsigned char *)CommandLine, 0,
                &ResultCodes,(unsigned char *)"usvr.exe");
        if (Os2Status != 0)
            {
            OtherError("IsabelleRichardHelper","DosExecPgm Failed");
            IsabelleError();
            }

#endif // OS2_12

#ifdef WIN32RPC

        PROCESS_INFORMATION ProcessInformation;
        STARTUPINFOA StartupInfo;

        StartupInfo.cb = sizeof(STARTUPINFOA);
        StartupInfo.lpReserved = 0;
        StartupInfo.lpDesktop = 0;
        StartupInfo.lpTitle = 0;
        StartupInfo.dwX = 0;
        StartupInfo.dwY = 0;
        StartupInfo.dwXSize = 0;
        StartupInfo.dwYSize = 0;
        StartupInfo.dwFlags = 0;
        StartupInfo.wShowWindow = 0;
        StartupInfo.cbReserved2 = 0;
        StartupInfo.lpReserved2 = 0;

        char CommandLine[200];

    PrintToConsole("Spawning richardhelper\n") ;
        strcpy(CommandLine, "usvr ");
        strcat(CommandLine, TransportOption);

        strcat(CommandLine, " -richardhelper");

        if (CreateProcessA(0, CommandLine, 0, 0, FALSE,
                0, 0, 0, &StartupInfo, &ProcessInformation) == FALSE)
            {
            OtherError("IsabelleRichardHelper","CreateProcessA Failed");
            IsabelleError();
            }

#endif // WIN32RPC
        }
    else if (Command == RICHARDHELPER_DELAY_EXIT)
        {
        HANDLE HandleToThread ;
        unsigned long ThreadIdentifier;

        HandleToThread = CreateThread(
                                    0,
                                    0,
                                    (LPTHREAD_START_ROUTINE) RichardHelperExit,
                                    0,
                                    0,
                                    &ThreadIdentifier);

        if (HandleToThread == 0)
            {
            OtherError("IsabelleRichardHelper","Can Not Create Thread");
            IsabelleError();
            }
        }
    else if (Command != RICHARDHELPER_IGNORE)
        {
        OtherError("IsabelleRichardHelper","Unknown Command Requested");
        IsabelleError();
        OtherError("IsabelleRichardHelper","Unknown Command Requested");
        IsabelleError();
        OtherError("IsabelleRichardHelper","Unknown Command Requested");
        IsabelleError();
        OtherError("IsabelleRichardHelper","Unknown Command Requested");
        IsabelleError();
        OtherError("IsabelleRichardHelper","Unknown Command Requested");
        IsabelleError();
        OtherError("IsabelleRichardHelper","Unknown Command Requested");
        IsabelleError();
        OtherError("IsabelleRichardHelper","Unknown Command Requested");
        IsabelleError();
        OtherError("IsabelleRichardHelper","Unknown Command Requested");
        IsabelleError();
        OtherError("IsabelleRichardHelper","Unknown Command Requested");
        IsabelleError();
        OtherError("IsabelleRichardHelper","Unknown Command Requested");
        IsabelleError();
        OtherError("IsabelleRichardHelper","Unknown Command Requested");
        IsabelleError();
        }

    Callee->BufferLength = 0;
    Status = I_RpcGetBuffer(Callee);

    if (Status)
        {
        ApiError("IsabelleRichardHelper","I_RpcGetBuffer",Status);
        }

}


void __RPC_STUB
IsabelleRaiseException (
    PRPC_MESSAGE Callee
    )
/*++

Routine Description:

    This routine is the stub (and actually the manager code as well) for
    the IsabelleRaiseException routine.  The client will call a stub and
    specify an exception to be raised which will be passed in the buffer.  We
    need to extract the argument, and then raise the exception.

Arguments:

    Callee - Supplies the input arguments and returns the output arguments
        and return value for the stub.

--*/
{
    unsigned /*long*/ char Exception;

    CompleteReceive(Callee) ;

    if (   Callee->BufferLength != sizeof(unsigned long)
        && Callee->BufferLength != sizeof(unsigned char) )
        {
        OtherError("IsabelleRaiseException",
                "*BufferLength != 1 or 4");
        IsabelleError();
        Callee->BufferLength = 0;

        Status = I_RpcGetBuffer(Callee);

        if (Status)
            {
            ApiError("IsabelleRaiseException","I_RpcGetBuffer",Status);
            IsabelleError();
            }
        return;
        }

    Exception = *((unsigned /*long*/ char *) Callee->Buffer);

    RpcRaiseException((RPC_STATUS) Exception);

    // This should never be reached.

    OtherError("IsabelleRaiseException", "RpcRaiseException Failed");
    IsabelleError();

    Callee->BufferLength = 0;
    Status = I_RpcGetBuffer(Callee);

    if (Status)
        {
        ApiError("IsabelleRaiseException","I_RpcGetBuffer",Status);
        }

}

unsigned int IsabelleRundownFlag = 0;
void PAPI * IsabelleAssociationContext = 0;


void __RPC_STUB
IsabelleRundownRoutine (
    IN void PAPI * AssociationContext
    )
/*++

Routine Description:

    This routine will get called when the association closes.  We just
    need to check that the association context is correct, and then
    note that we got called.

Arguments:

    AssociationContext - Supplies the association context for the association
        which closed.

--*/
{
    if (AssociationContext == IsabelleAssociationContext)
        IsabelleRundownFlag += 1;
}


void __RPC_STUB
IsabelleSetRundown (
    IN PRPC_MESSAGE Callee
    )
/*++

Routine Description:

    We want to set an association context in this routine, and a rundown
    routine.  The rundown will set a flag when it is called.  Later, the
    client, will call another routine to check to set the flag has been
    set.

Arguments:

    Callee - Supplies the input arguments and returns the output arguments
        and return value for the stub.

--*/
{
    CompleteReceive(Callee) ;

    if (Callee->BufferLength != 0)
        {
        OtherError("IsabelleSetException", "*BufferLength != 0");
        IsabelleError();
        }

    IsabelleRundownFlag = 0;
    IsabelleAssociationContext = Callee->Buffer;

    Status = I_RpcMonitorAssociation(Callee->Handle, IsabelleRundownRoutine,
            IsabelleAssociationContext);
    if (Status)
        {
        ApiError("IsabelleSetRundown","I_RpcMonitorAssociation",Status);
        IsabelleError();
        }

    Callee->BufferLength = 0;
    Status = I_RpcGetBuffer(Callee);

    if (Status)
        {
        ApiError("IsabelleSetRundown","I_RpcGetBuffer",Status);
        }

}


void __RPC_STUB
IsabelleCheckRundown (
    PRPC_MESSAGE Callee
    )
/*++

Routine Description:

    This routine will be called to check that context rundown did, in
    fact, occur.

Arguments:

    Callee - Supplies the input arguments and returns the output arguments
        and return value for the stub.

--*/
{
    CompleteReceive(Callee) ;

    if (Callee->BufferLength != 0)
        {
        OtherError("IsabelleCheckRundown", "*BufferLength != 0");
        IsabelleError();
        }

    if (0 == DatagramFlag)
        {
        if (IsabelleRundownFlag != 1)
            {
            OtherError("IsabelleCheckRundown", "IsabelleRundownFlag != 1");
            IsabelleError();
            }
        }

    Callee->BufferLength = 0;
    Status = I_RpcGetBuffer(Callee);

    if (Status)
        {
        ApiError("IsabelleCheckRundown","I_RpcGetBuffer",Status);
        }

}


void __RPC_STUB
IsabelleCheckNoRundown (
    PRPC_MESSAGE Callee
    )
/*++

Routine Description:

    This routine will be called to check that context rundown did not
    occur.

Arguments:

    Callee - Supplies the input arguments and returns the output arguments
        and return value for the stub.

--*/
{
    CompleteReceive(Callee) ;

    if (Callee->BufferLength != 0)
        {
        OtherError("IsabelleCheckNoRundown", "*BufferLength != 0");
        IsabelleError();
        }

    if (IsabelleRundownFlag == 1)
        {
        OtherError("IsabelleCheckNoRundown", "IsabelleRundownFlag == 1");
        IsabelleError();
        }

    Callee->BufferLength = 0;
    Status = I_RpcGetBuffer(Callee);

    if (Status)
        {
        ApiError("IsabelleCheckNoRundown","I_RpcGetBuffer",Status);
        }

}


void __RPC_STUB
IsabelleCheckContext (
    PRPC_MESSAGE Callee
    )
/*++

Routine Description:

    This routine will be called to check the context for an association,
    and then to set a new context.

Arguments:

    Callee - Supplies the input arguments and returns the output arguments
        and return value for the stub.

--*/
{
    void PAPI * Context;

    CompleteReceive(Callee) ;

    if (Callee->BufferLength != 0)
        {
        OtherError("IsabelleCheckContext", "*BufferLength != 0");
        IsabelleError();
        }

    Status = I_RpcGetAssociationContext(Callee->Handle, &Context);
    if (Status)
        {
        ApiError("IsabelleCheckContext", "I_RpcGetAssociationContext",
                Status);
        IsabelleError();

        Callee->BufferLength = 0;

        Status = I_RpcGetBuffer(Callee);

        if (Status)
            {
            ApiError("IsabelleCheckContext","I_RpcGetBuffer",Status);
            IsabelleError();
            }

        return;
        }

    if (Context != IsabelleAssociationContext)
        {
        OtherError("IsabelleCheckContext",
                "Context != IsabelleAssociationContext");
        IsabelleError();

        Callee->BufferLength = 0;

        Status = I_RpcGetBuffer(Callee);

        if (Status)
            {
            ApiError("IsabelleCheckContext","I_RpcGetBuffer",Status);
            IsabelleError();
            }
        return;
        }

    Callee->BufferLength = 0;
    Status = I_RpcGetBuffer(Callee);

    if (Status)
        {
        ApiError("IsabelleCheckContext","I_RpcGetBuffer",Status);
        }

}

RPC_BINDING_VECTOR * BartholomewRpcBindingVector;
unsigned int BartholomewIndex;


unsigned char *
UnicodeToAnsiString (
    IN RPC_CHAR * WideCharString,
    OUT RPC_STATUS * RpcStatus
    )
/*++

Routine Description:

    This routine will convert a unicode string into an ansi string,
    including allocating memory for the ansi string.

Arguments:

    WideCharString - Supplies the unicode string to be converted into
        an ansi string.

    RpcStatus - Returns the status of the operation; this will be one
        of the following values.

        RPC_S_OK - The unicode string has successfully been converted
            into an ansi string.

        RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allocate
            the ansi string.

Return Value:

    A pointer to the ansi string will be returned.

--*/
{
    NTSTATUS NtStatus;
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    unsigned char * NewString;

    RtlInitUnicodeString(&UnicodeString,WideCharString);
    NtStatus = RtlUnicodeStringToAnsiString(&AnsiString,&UnicodeString,TRUE);
    if (!NT_SUCCESS(NtStatus))
        {
        *RpcStatus = RPC_S_OUT_OF_MEMORY;
        return(0);
        }

    NewString = new unsigned char[AnsiString.Length + 1];
    if (NewString == 0)
        {
        RtlFreeAnsiString(&AnsiString);
        *RpcStatus = RPC_S_OUT_OF_MEMORY;
        return(0);
        }

    memcpy(NewString,AnsiString.Buffer,AnsiString.Length + 1);
    RtlFreeAnsiString(&AnsiString);
    *RpcStatus = RPC_S_OK;
    return(NewString);
}


unsigned char PAPI *
StringBindingWithDynamicEndpoint (
    IN unsigned char PAPI * StringBinding,
    IN RPC_CHAR PAPI * DynamicEndpoint
    )
/*++

Routine Description:

    This routine adds the dynamic endpoint to the string binding.  A
    new string binding will be returned, and the supplied string binding
    and dynamic endpoint will be freed.

Arguments:

    StringBinding - Supplies the string binding to which the dynamic
        endpoint should be added.

    DynamicEndpoint - Supplies the dynamic endpoint.

Return Value:

    A new string binding will be returned which contains the dynamic
    endpoint if the operation is successful; otherwise, zero will be
    returned.

--*/
{
    unsigned char PAPI * ObjectUuid;
    unsigned char PAPI * RpcProtocolSequence;
    unsigned char PAPI * NetworkAddress;
    unsigned char PAPI * Endpoint;
    unsigned char PAPI * NetworkOptions;

    Status = RpcStringBindingParseA(StringBinding, &ObjectUuid,
            &RpcProtocolSequence, &NetworkAddress, &Endpoint,
            &NetworkOptions);
    if (Status)
        {
        ApiError("StringBindingWithDynamicEndpoint",
                "RpcStringBindingParse", Status);
        return(0);
        }

    Status = RpcStringFreeA(&StringBinding);
    if (Status)
        {
        ApiError("StringBindingWithDynamicEndpoint", "RpcStringFree", Status);
        return(0);
        }

    Status = RpcStringFreeA(&Endpoint);
    if (Status)
        {
        ApiError("StringBindingWithDynamicEndpoint", "RpcStringFree", Status);
        return(0);
        }

    Endpoint = UnicodeToAnsiString(DynamicEndpoint, &Status);
    if (Status)
        {
        ApiError("StringBindingWithDynamicEndpoint", "UnicodeToAnsiString",
                Status);
        return(0);
        }

    Status = RpcStringFreeW(&DynamicEndpoint);
    if (Status)
        {
        ApiError("StringBindingWithDynamicEndpoint", "RpcStringFreeW",
                Status);
        return(0);
        }

    Status = RpcStringBindingComposeA(ObjectUuid, RpcProtocolSequence,
            NetworkAddress, Endpoint, NetworkOptions, &StringBinding);
    if (Status)
        {
        ApiError("StringBindingWithDynamicEndpoint",
                "RpcStringBindingCompose", Status);
        return(0);
        }

    delete Endpoint;

    Status = RpcStringFreeA(&ObjectUuid);
    if (Status)
        {
        ApiError("StringBindingWithDynamicEndpoint", "RpcStringFree", Status);
        return(0);
        }

    Status = RpcStringFreeA(&RpcProtocolSequence);
    if (Status)
        {
        ApiError("StringBindingWithDynamicEndpoint", "RpcStringFree", Status);
        return(0);
        }

    Status = RpcStringFreeA(&NetworkAddress);
    if (Status)
        {
        ApiError("StringBindingWithDynamicEndpoint", "RpcStringFree", Status);
        return(0);
        }

    Status = RpcStringFreeA(&NetworkOptions);
    if (Status)
        {
        ApiError("StringBindingWithDynamicEndpoint", "RpcStringFree", Status);
        return(0);
        }

    return(StringBinding);
}


void __RPC_STUB
IsabelleGetStringBinding (
    PRPC_MESSAGE Callee
    )
/*++

Routine Description:

    This routine will be called to obtain a string binding for one of
    the protocol sequences supported by this server.

Arguments:

    Callee - Supplies the input arguments and returns the output arguments
        and return value for the stub.

--*/
{
    unsigned char * StringBinding;
    WCHAR * DynamicEndpointW;
        RPC_CHAR *DynamicEndpoint;
    unsigned int TransportType ;
    unsigned int CurTransportType;

    CompleteReceive(Callee) ;

    while (BartholomewRpcBindingVector == 0)
        {
        Sleep(100);
        }

    if (Callee->BufferLength != 0)
        {
        OtherError("IsabelleGetStringBinding", "*BufferLength != 0");
        IsabelleError();
        }

    Status = I_RpcBindingInqTransportType(Callee->Handle, &TransportType);

    if (Status)
        {
        ApiError("IsabelleGetStringBinding", "I_RpcBindingInqTransportType", Status);
        IsabelleError();
        return;
        }

    if (TransportType != TRANSPORT_TYPE_LPC)
        {
        while (BartholomewIndex < BartholomewRpcBindingVector->Count)
            {
            Status = I_RpcBindingInqTransportType(
                            BartholomewRpcBindingVector->BindingH[BartholomewIndex],
                            &CurTransportType);

            if (Status)
                {
                ApiError("IsabelleGetStringBinding",
                         "I_RpcBindingInqTransportType", Status);
                IsabelleError();
                return;
                }

            if (CurTransportType == TRANSPORT_TYPE_LPC)
                {
                BartholomewIndex ++;
                continue;
                }
            break;
            }
        }

    if (BartholomewIndex < BartholomewRpcBindingVector->Count)
        {
        Status = RpcBindingToStringBindingA(
                BartholomewRpcBindingVector->BindingH[BartholomewIndex],
                &StringBinding);
        if (Status)
            {
            ApiError("IsabelleGetStringBinding", "RpcBindingToStringBinding",
                    Status);
            IsabelleError();
            Callee->BufferLength = 0;

            Status = I_RpcGetBuffer(Callee);

            if (Status)
                {
                ApiError("IsabelleGetStringBinding","I_RpcGetBuffer",Status);
                IsabelleError();
                }
            return;
            }

        Status = I_RpcBindingInqDynamicEndpointW(
                BartholomewRpcBindingVector->BindingH[BartholomewIndex],
                &DynamicEndpointW);
        if (Status)
            {
            ApiError("IsabelleGetStringBinding",
                    "I_RpcBindingInqDynamicEndpoint", Status);
            IsabelleError();
            Callee->BufferLength = 0;

            Status = I_RpcGetBuffer(Callee);

            if (Status)
                {
                ApiError("IsabelleGetStringBinding","I_RpcGetBuffer",Status);
                IsabelleError();
                }
            return;
            }

        DynamicEndpoint = DynamicEndpointW;

        if (DynamicEndpoint != 0)
            {

            StringBinding = StringBindingWithDynamicEndpoint(StringBinding,
                    DynamicEndpoint);
            if (StringBinding == 0)
                {
                OtherError("IsabelleGetStringBinding",
                        "StringBinding == 0");
                IsabelleError();
                Callee->BufferLength = 0;

                Status = I_RpcGetBuffer(Callee);

                if (Status)
                    {
                    ApiError("IsabelleGetStringBinding","I_RpcGetBuffer",Status);
                    IsabelleError();
                    }
                return;
                }
            }

        Callee->BufferLength = strlen((char PAPI *) StringBinding) + 1;

        Status = I_RpcGetBuffer(Callee);
        if (Status)
            {
            ApiError("IsabelleGetStringBinding", "I_RpcGetBuffer", Status);
            IsabelleError();
            return;
            }

        memcpy(Callee->Buffer, StringBinding,
                strlen((char PAPI *) StringBinding) + 1);

        Status = RpcStringFreeA(&StringBinding);
        if (Status)
            {
            ApiError("IsabelleGetStringBinding", "RpcStringFree", Status);
            IsabelleError();
            return;
            }

        BartholomewIndex += 1;
        }
    else
        {
        Callee->BufferLength = 0;

        Status = I_RpcGetBuffer(Callee);

        if (Status)
            {
            ApiError("IsabelleGetStringBinding","I_RpcGetBuffer",Status);
            IsabelleError();
            }
        return;
        }
}

void IsabelleUnregisterInterfaces(
    PRPC_MESSAGE Callee
    )
{
    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("IsabelleUnregsterInterface","RpcServerUnregisterIf",Status);
        PrintToConsole("IsabelleUnregsterInterfaces : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }
}

void IsabelleRegisterInterfaces(
    PRPC_MESSAGE Callee
    )
{
    Status = stub_RegisterIf((RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0,0);
    if (Status)
        {
        ApiError("Hybrid","stub_RegisterIf",Status);
        PrintToConsole("Hybrid : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,0,0);
    if (Status)
        {
        ApiError("Hybrid","stub_RegisterIf",Status);
        PrintToConsole("Hybrid : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }
}

void PipeAlloc(
    PIPE_STATE *state,
    int requested_size,
    pipe_element_t **allocated_buf,
    int *allocated_size)
{
    if (state->BufferSize < requested_size)
        {
        if (state->AllocatedBuffer)
            {
            I_RpcFree(state->AllocatedBuffer) ;
            }

        state->AllocatedBuffer =  I_RpcAllocate(requested_size) ;
        if (state->AllocatedBuffer == 0)
            {
            *allocated_size = 0 ;
            state->BufferSize = 0 ;
            }
        else
            {
            *allocated_size = requested_size ;
            state->BufferSize = requested_size ;
            }

        *allocated_buf = (pipe_element_t *) state->AllocatedBuffer ;
        }
    else
        {
        *allocated_buf = (pipe_element_t *) state->AllocatedBuffer ;
        *allocated_size = state->BufferSize ;
        }
}

void PipePull(
    PIPE_STATE *state,
    pipe_element_t *buffer,
    int ecount,
    int *actual_transfer_count
    )
{
    int num_elements = 0;
    DWORD size = (DWORD) ecount * state->PipeElementSize ;
    RPC_MESSAGE Callee ;

    *actual_transfer_count = 0 ;

    if (state->EndOfPipe)
        {
        return ;
        }

    I_RpcReadPipeElementsFromBuffer(state, (char *) buffer, size, &num_elements) ;
    *actual_transfer_count += num_elements ;
    size -= num_elements * state->PipeElementSize ;

    if (state->EndOfPipe == 0 &&
        num_elements < ecount)
        {
        Callee.RpcFlags = RPC_BUFFER_PARTIAL ;

        Callee.Buffer = state->Buffer ;
        Callee.BufferLength = state->BufferLength ;

        Status = I_RpcReceive(&Callee, size) ;
        if (Status)
            {
            ApiError("PipePull", "I_RpcReceive", Status) ;
            num_elements = 0 ;
            return ;
            }

        state->Buffer = Callee.Buffer ;
        state->BufferLength = Callee.BufferLength ;
        state->CurPointer = (char *) Callee.Buffer ;
        state->BytesRemaining = Callee.BufferLength ;

        buffer = (pipe_element_t *)
                    ((char *) buffer + num_elements * state->PipeElementSize) ;

        num_elements = 0 ;
        I_RpcReadPipeElementsFromBuffer(state,
                                (char *) buffer, size, &num_elements) ;
        *actual_transfer_count += num_elements ;
        }
}

void PipePush(
    PIPE_STATE *state,
    pipe_element_t *buffer,
    int count
    )
{
    RPC_MESSAGE TempBuf ;
    int size = count * state->PipeElementSize + sizeof(DWORD) ;
    char *temp ;
    RPC_MESSAGE Callee ;

    Callee.Buffer = state->Buffer ;
    Callee.BufferLength = state->BufferLength ;
    Callee.Handle = state->BindingHandle;

    Status = I_RpcReallocPipeBuffer(&Callee, size+state->SendBufferOffset) ;
    if (Status)
        {
        ApiError("PipePush", "I_RpcGetBuffer", Status) ;
        return ;
        }

    temp = (char *) Callee.Buffer+state->SendBufferOffset ;

    *((DWORD *) temp) = count ;
    RpcpMemoryCopy(temp+sizeof(DWORD),
                               buffer, count * state->PipeElementSize) ;

    Callee.RpcFlags = RPC_BUFFER_PARTIAL ;

    Status = I_RpcSend(&Callee) ;
    if (Status == RPC_S_SEND_INCOMPLETE)
        {
        state->SendBufferOffset = Callee.BufferLength ;
        }
    else if (Status)
        {
        ApiError("PipePush", "I_RpcSend", Status) ;
        state->SendBufferOffset = 0 ;
        return;
        }
    else
        {
        state->SendBufferOffset = 0 ;
        }
}

void IsabelleMgrIN(
    pipe_t *pipe,
    int chunksize,
    int numchunks,
    int checksum,
    int buffsize,
    char *buffer
    )
{
    static pipe_element_t local_buf[CHUNK_SIZE] ;
    int num_elements ;
    int i, j ;
    int localchecksum = 0;

    PrintToConsole("IsabelleMgrIN: client chunk size: %d\n", chunksize) ;
    PrintToConsole("IsabelleMgrIN: client number of chunks: %d\n", numchunks) ;
    PrintToConsole("IsabelleMgrIN: buffer size: %d\n", buffsize) ;
    PrintToConsole("IsabelleMgrIN: checksum: %d\n", checksum) ;

    do
         {
         pipe->Pull(pipe->state,
                        local_buf,
                        CHUNK_SIZE,
                        &num_elements
                        ) ;

         for (i = 0; i <num_elements; i++)
             {
             localchecksum += local_buf[i] ;
             }
         }
     while ( num_elements > 0  );

     if (localchecksum != checksum)
         {
         IsabelleError() ;
         PrintToConsole("IsabelleMgrIN: checksums don't match\n") ;
         }
}

void IsabellePipeIN(
    PRPC_MESSAGE Callee
    )
{
    pipe_t mypipe ;
    PIPE_STATE pipestate ;
    pipe_element_t pipe_element ;
    DWORD size = 3* sizeof(int)  ;
    int chunksize, numchunks, checksum, buffsize ;
    char *buffer, *temp ;
    void *savedbuffer ;

    PrintToConsole("IsabellePipeIN called\n") ;

    if (!(Callee->RpcFlags & RPC_BUFFER_COMPLETE) &&
        Callee->BufferLength < size)
        {
        Callee->RpcFlags |= (RPC_BUFFER_PARTIAL | RPC_BUFFER_EXTRA) ;
        size = size - Callee->BufferLength ;

        Status = I_RpcReceive(Callee, size) ;
        if (Status)
            {
            ApiError("PipePull", "I_RpcReceive", Status) ;
            return ;
            }
        }

    temp = (char *) Callee->Buffer ;

    chunksize = *((int *) temp) ;
    temp += sizeof(int) ;

    numchunks = *((int *) temp) ;
    temp += sizeof(int) ;

    checksum = *((int *) temp) ;
    temp += sizeof(int) ;

    buffsize = *((int *) temp) ;
    temp += sizeof(int) ;

    size = 4 * sizeof(int) + buffsize + sizeof(DWORD) ;

    if (!(Callee->RpcFlags & RPC_BUFFER_COMPLETE) &&
        Callee->BufferLength < size)
        {
        Callee->RpcFlags |= (RPC_BUFFER_PARTIAL | RPC_BUFFER_EXTRA) ;
        size = size - Callee->BufferLength ;

        Status = I_RpcReceive(Callee, size) ;
        if (Status)
            {
            ApiError("PipePull", "I_RpcReceive", Status) ;
            return ;
            }
        }

    buffer = (char *) Callee->Buffer + 3 * sizeof(int) ;

    savedbuffer = Callee->Buffer ;
    Callee->Buffer = 0;

    pipestate.Buffer = Callee->Buffer ;
    pipestate.BufferLength = Callee->BufferLength ;
    pipestate.CurrentState = start ;
    pipestate.CurPointer = (char *) buffer+buffsize ;
    pipestate.BytesRemaining = Callee->BufferLength - 3 * sizeof(int) - buffsize ;
    pipestate.EndOfPipe = 0 ;
    pipestate.PipeElementSize = sizeof(pipe_element_t) ;
    pipestate.PartialPipeElement = &pipe_element ;
    pipestate.AllocatedBuffer = 0 ;
    pipestate.BufferSize = 0 ;

    mypipe.Pull = PipePull ;
    mypipe.Push = PipePush ;
    mypipe.state = &pipestate ;

    IsabelleMgrIN(&mypipe, chunksize, numchunks, checksum, buffsize, buffer) ;

    Callee->Buffer = savedbuffer ;
 }

void IsabelleMgrOUT(
    pipe_t *pipe,
    int *chunksize,
    int *numchunks,
    int *checksum,
    int *buffsize,
    char **buffer
    )
{
    static pipe_element_t local_buf[CHUNK_SIZE] ;
    static int buf[BUFF_SIZE] ;
    int i ;
    char j = 0;
    int localchecksum = 0;

    PrintToConsole("IsabelleMgrOUT called\n") ;

    for (i = 0; i < CHUNK_SIZE; i++, j++)
        {
        RpcpMemorySet((char *) &(local_buf[i]), j, sizeof(pipe_element_t)) ;
        localchecksum += local_buf[i] ;
        }

    for (i = 0; i < NUM_CHUNKS; i++)
        {
        pipe->Push(pipe->state,
                        local_buf,
                        CHUNK_SIZE
                        ) ;
        }
    pipe->Push(pipe->state, local_buf, 0) ;

    for (i = 0; i < BUFF_SIZE; i++)
        {
        local_buf[i] = i ;
        }

    *chunksize = CHUNK_SIZE ;
    *numchunks = NUM_CHUNKS ;
    *checksum = localchecksum * NUM_CHUNKS;
    *buffsize = BUFF_SIZE ;
    *buffer = (char *) buf ;
}

void IsabellePipeOUT(
    PRPC_MESSAGE Callee
    )
{
    pipe_t mypipe ;
    char *Temp ;
    PIPE_STATE pipestate ;
    pipe_element_t pipe_element ;
    int size ;
    char *buffer ;
    int chunksize, numchunks, buffsize, checksum ;
    RPC_MESSAGE TempBuffer ;
    void *savedbuffer ;

    PrintToConsole("IsabellePipeOUT called\n") ;

    pipestate.Buffer = Callee->Buffer ;
    pipestate.BufferLength = Callee->BufferLength ;
    pipestate.CurrentState = start ;
    pipestate.CurPointer = (char *) Callee->Buffer ;
    pipestate.BytesRemaining = Callee->BufferLength ;
    pipestate.EndOfPipe = 0 ;
    pipestate.PipeElementSize = sizeof(pipe_element_t) ;
    pipestate.PartialPipeElement = &pipe_element ;
    pipestate.AllocatedBuffer = 0 ;
    pipestate.BufferSize = 0 ;
    pipestate.SendBufferOffset = 0 ;
    pipestate.BindingHandle = Callee->Handle;

    Callee->Buffer = 0;

    mypipe.Pull = PipePull ;
    mypipe.Push = PipePush ;
    mypipe.state = &pipestate ;

    IsabelleMgrOUT(&mypipe, &chunksize, &numchunks, &checksum, &buffsize, &buffer) ;

    size = 3 *sizeof(int) + buffsize ;

    Status = I_RpcReallocPipeBuffer(Callee, size+pipestate.SendBufferOffset) ;
    if (Status)
        {
        ApiError("PipePull", "I_RpcReceive", Status) ;
        return ;
        }

    Temp = (char *) Callee->Buffer+pipestate.SendBufferOffset ;

    *((int *) Temp) = chunksize ;
    Temp += sizeof(int) ;

    *((int *) Temp) = numchunks ;
    Temp += sizeof(int) ;

    *((int *) Temp) = checksum ;
    Temp += sizeof(int) ;

    *((int *) Temp) = buffsize ;
    Temp += sizeof(int) ;

    RpcpMemoryCopy(Temp, buffer, buffsize) ;
}

void IsabelleMgrINOUT(
    pipe_t *pipe
    )
{
    int num_elements ;
    int i;
    char j = 0;
    static pipe_element_t local_buf[CHUNK_SIZE] ;
    char *PipeData ;
    int localchecksum = 0;
    int outchecksum = 0;

    do
         {
         pipe->Pull(pipe->state,
                        local_buf,
                        CHUNK_SIZE,
                        &num_elements
                        ) ;

         for (i = 0; i <num_elements; i++)
             {
             localchecksum += local_buf[i] ;
             }
         }
     while ( num_elements > 0  );

     PrintToConsole("IsabelleMgrINOUT: checksum (IN) = %d\n", localchecksum) ;

     for (i = 0; i < CHUNK_SIZE; i++, j++)
        {
        RpcpMemorySet((char *) &(local_buf[i]), j, sizeof(pipe_element_t)) ;
        outchecksum += local_buf[i] ;
        }

    PrintToConsole("IsabelleMgrINOUT: checksum (OUT) = %d\n",
                            outchecksum * NUM_CHUNKS) ;

     for (i = 0; i <NUM_CHUNKS; i++)
         {
         pipe->Push(pipe->state, local_buf, CHUNK_SIZE) ;
         }

     pipe->Push(pipe->state, local_buf, 0) ;
}

void IsabellePipeINOUT(
    PRPC_MESSAGE Callee
    )
{
    pipe_t mypipe ;
    PIPE_STATE pipestate ;
    pipe_element_t pipe_element ;
    DWORD size = sizeof(pipe_element_t) + sizeof(DWORD) ;

    PrintToConsole("IsabellePipeINOUT called\n") ;

    if (!(Callee->RpcFlags & RPC_BUFFER_COMPLETE) &&
        Callee->BufferLength < size)
        {
        Callee->RpcFlags |= (RPC_BUFFER_PARTIAL | RPC_BUFFER_EXTRA) ;
        size = size - Callee->BufferLength ;

        Status = I_RpcReceive(Callee, size) ;
        if (Status)
            {
            ApiError("PipePull", "I_RpcReceive", Status) ;
            return ;
            }
        }


    pipestate.Buffer = Callee->Buffer ;
    pipestate.BufferLength = Callee->BufferLength ;
    pipestate.CurrentState = start ;
    pipestate.CurPointer = (char *) Callee->Buffer ;
    pipestate.BytesRemaining = Callee->BufferLength ;
    pipestate.EndOfPipe = 0 ;
    pipestate.PipeElementSize = sizeof(pipe_element_t) ;
    pipestate.PartialPipeElement = &pipe_element ;
    pipestate.AllocatedBuffer = 0 ;
    pipestate.BufferSize = 0 ;
    pipestate.SendBufferOffset = 0 ;

    Callee->Buffer = 0;

    mypipe.Pull = PipePull ;
    mypipe.Push = PipePush ;
    mypipe.state = &pipestate ;

    IsabelleMgrINOUT(&mypipe) ;
}

void GetServerType(
    PRPC_MESSAGE Callee
    )
{
    RPC_STATUS RpcStatus;
    OSVERSIONINFO *pOsVer;

    Callee->BufferLength = sizeof(OSVERSIONINFO);
    RpcStatus = I_RpcGetBuffer(Callee);
    if (RpcStatus != RPC_S_OK)
        {
        ApiError("Get Buffer", "I_RpcGetBuffer", Status) ;
        return ;
        }

    pOsVer = (OSVERSIONINFO *)Callee->Buffer;
    pOsVer->dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(pOsVer);
}

void UnregisterHelgaEx(
    PRPC_MESSAGE Callee
    )
{
    Status = RpcServerUnregisterIfEx(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, TRUE);
    if (Status)
        {
        ApiError("UnregisterHelgaEx","RpcServerUnregisterIfEx",Status);
        PrintToConsole("David : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }
}

RPC_DISPATCH_FUNCTION IsabelleDispatchFunction[] =
{
        IsabelleShutdown,
        IsabelleNtSecurity,
        IsabelleToStringBinding,
        IsabelleRichardHelper,
        IsabelleRaiseException,
        IsabelleSetRundown,
        IsabelleCheckRundown,
        IsabelleCheckContext,
        IsabelleGetStringBinding,
        IsabelleCheckNoRundown,
        Synchro,
        IsabelleUnregisterInterfaces,
        IsabelleRegisterInterfaces,
        IsabellePipeIN,
        IsabellePipeOUT,
        IsabellePipeINOUT,
        Foo_s,
        FooPipe_s,
        FooBar_s,
        FooCH_s,
        GetServerType,
        OpenContextHandle,
        UnregisterHelgaEx
};

RPC_DISPATCH_TABLE IsabelleDispatchTable =
{
    23, IsabelleDispatchFunction
};


int
InquireBindings (
    char * TestName
    )
/*++

Routine Description:

    This routine is used to test RpcServerInqBindings and
    RpcBindingVectorFree.  We call RpcServerInqBindings, and then
    use RpcBindingToStringBinding to get string bindings to print
    to the console.

Arguments:

    TestName - Supplies the name of the test, Christopher or Bartholomew
        which is invoking this routine.  This is necessary so that we
        can print out appropriate messages.

Return Value:

    Zero will be returned if this test completes successfully; otherwise,
    non-zero will be returned.

--*/
{
    RPC_BINDING_VECTOR * RpcBindingVector;
    unsigned int Index;
    unsigned char * StringBinding;

    Status = RpcServerInqBindings(&RpcBindingVector);
    if (Status)
        {
        ApiError(TestName,"RpcServerInqBindings",Status);
        PrintToConsole(TestName);
        PrintToConsole(" : FAIL - RpcServerInqBindings\n");
        return(1);
        }

    PrintToConsole("%s: (RpcServerInqBindings)\n", TestName);
    for (Index = 0; Index < RpcBindingVector->Count; Index++)
        {
        unsigned int   Transport;
        char *TransportName;

        Status = RpcBindingToStringBindingA(RpcBindingVector->BindingH[Index],
                &StringBinding);
        if (Status)
            {
            ApiError(TestName,"RpcBindingToStringBinding",Status);
            PrintToConsole(TestName);
            PrintToConsole(" : FAIL - RpcBindingToStringBinding\n");
            return(1);
            }

        Status =
        I_RpcBindingInqTransportType(RpcBindingVector->BindingH[Index],
                                     &Transport);

        if (Status)
            {
            ApiError(TestName,"I_RpcBindingInqTransportType",Status);
            PrintToConsole(TestName);
            PrintToConsole(" : FAIL - I_RpcBindingInqTransportType\n");
            return(1);
            }

        if (Transport == TRANSPORT_TYPE_CN)
            {
            TransportName = "cn";
            }
        else if (Transport == TRANSPORT_TYPE_DG)
            {
            TransportName = "dg";
            }
        else if (Transport == TRANSPORT_TYPE_LPC)
            {
            TransportName = "lpc";
            }
        else
            {
            PrintToConsole(TestName);
            PrintToConsole(" : FAIL - Unknown transport (I_RpcBindingInqTransportType)\n");
            return(1);
            }

        PrintToConsole("    %s - ( %s )\n",
                       (char *) StringBinding,
                       TransportName );

        Status = RpcStringFreeA(&StringBinding);
        if (Status)
            {
            ApiError(TestName,"RpcStringFree",Status);
            PrintToConsole(TestName);
            PrintToConsole(" : FAIL - RpcStringFree\n");
            return(1);
            }

        if (StringBinding != 0)
            {
            PrintToConsole(TestName);
            PrintToConsole(" : FAIL - StringBinding != 0\n");
            return(1);
            }
        }

    Status = RpcBindingVectorFree(&RpcBindingVector);
    if (Status)
        {
        ApiError(TestName,"RpcBindingVectorFree",Status);
        PrintToConsole(TestName);
        PrintToConsole(" : FAIL - RpcBindingVectorFree\n");
        return(1);
        }

    if (RpcBindingVector != 0)
        {
        PrintToConsole(TestName);
        PrintToConsole(" : FAIL - RpcBindingVector != 0\n");
        return(1);
        }

    return(0);
}


void
Sigfried (
    )
/*++

Routine Description:

    This routine is used to perform a build verification test of the
    rpc runtime.  This test checks for basic functionality of the
    runtime.  It works with Sebastian in uclnt.exe.

--*/
{
    PrintToConsole("Sigfried : Verify Basic Server Functionality\n");

    Status = stub_RegisterIf((RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0,0);
    if (Status)
        {
        ApiError("Sigfried","stub_RegisterIf",Status);
        PrintToConsole("Sigfried : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,0,0);
    if (Status)
        {
        ApiError("Sigfried","stub_RegisterIf",Status);
        PrintToConsole("Sigfried : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(SIGFRIED), 0);
    if (Status)
        {
        ApiError("Sigfried","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Sigfried : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

//    if ( InquireBindings("Sigfried") != 0 )
//        {
//        return;
//        }

    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("Sigfried","stub_ServerListen",Status);
        PrintToConsole("Sigfried : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (HelgaErrors != 0)
        {
        PrintToConsole("Sigfried : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Sigfried : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Sigfried","RpcServerUnregisterIf",Status);
        PrintToConsole("Sigfried : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Sigfried","RpcServerUnregisterIf",Status);
        PrintToConsole("Sigfried : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("Sigfried : PASS\n");
}


void
Hybrid (
    )
/*++

Routine Description:

    This routine is used to perform a build verification test of the
    rpc runtime.  This test checks for basic functionality of the
    runtime.  It works with Sebastian in uclnt.exe.

--*/
{
    PrintToConsole("Hybrid : Verify Basic Server Functionality\n");

    Status = stub_RegisterIf((RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0,0);
    if (Status)
        {
        ApiError("Hybrid","stub_RegisterIf",Status);
        PrintToConsole("Hybrid : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,0,0);
    if (Status)
        {
        ApiError("Hybrid","stub_RegisterIf",Status);
        PrintToConsole("Hybrid : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(SIGFRIED), 0);
    if (Status)
        {
        ApiError("Hybrid","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Hybrid : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

//    if ( InquireBindings("Sigfried") != 0 )
//        {
//        return;
//        }

    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("Hybrid","stub_ServerListen",Status);
        PrintToConsole("Hybrid : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (HelgaErrors != 0)
        {
        PrintToConsole("Hybrid : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Hybrid : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Hybrid","RpcServerUnregisterIf",Status);
        PrintToConsole("Hybrid : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Hybrid","RpcServerUnregisterIf",Status);
        PrintToConsole("Hybrid : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("Hybrid : PASS\n");
}


void
LpcSecurity (
    )
/*++

Routine Description:

    This routine is used to perform a build verification test of the
    rpc runtime.  This test checks for basic functionality of the
    runtime.  It works with Sebastian in uclnt.exe.

--*/
{
    PrintToConsole("LpcSecurity : Verify Basic Server Functionality\n");

    Status = stub_RegisterIf((RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0,0);
    if (Status)
        {
        ApiError("LpcSecurity","stub_RegisterIf",Status);
        PrintToConsole("LpcSecurity : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,0,0);
    if (Status)
        {
        ApiError("LpcSecurity","stub_RegisterIf",Status);
        PrintToConsole("LpcSecurity : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(SIGFRIED), 0);
    if (Status)
        {
        ApiError("LpcSecurity","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("LpcSecurity : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

//    if ( InquireBindings("Sigfried") != 0 )
//        {
//        return;
//        }

    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("LpcSecurity","stub_ServerListen",Status);
        PrintToConsole("LpcSecurity : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (HelgaErrors != 0)
        {
        PrintToConsole("LpcSecurity : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("LpcSecurity : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("LpcSecurity","RpcServerUnregisterIf",Status);
        PrintToConsole("LpcSecurity : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("LpcSecurity","RpcServerUnregisterIf",Status);
        PrintToConsole("LpcSecurity : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("LpcSecurity : PASS\n");
}

void
TestObjectUuids (
    )
/*++

Routine Description:

    This routine is used to perform a build verification test of the
    rpc runtime.  This test checks for basic functionality of the
    runtime.  It works with Sebastian in uclnt.exe.

--*/
{
    PrintToConsole("TestObjectUuids : Verify Basic Server Functionality\n");

    Status = stub_RegisterIf((RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0,0);
    if (Status)
        {
        ApiError("TestObjectUuids","stub_RegisterIf",Status);
        PrintToConsole("TestObjectUuids : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,0,0);
    if (Status)
        {
        ApiError("TestObjectUuids","stub_RegisterIf",Status);
        PrintToConsole("TestObjectUuids : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(SIGFRIED), 0);
    if (Status)
        {
        ApiError("TestObjectUuids","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("TestObjectUuids : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

//    if ( InquireBindings("Sigfried") != 0 )
//        {
//        return;
//        }

    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("TestObjectUuids","stub_ServerListen",Status);
        PrintToConsole("TestObjectUuids : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (HelgaErrors != 0)
        {
        PrintToConsole("TestObjectUuids : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("TestObjectUuids : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("TestObjectUuids","RpcServerUnregisterIf",Status);
        PrintToConsole("TestObjectUuids : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("TestObjectUuids","RpcServerUnregisterIf",Status);
        PrintToConsole("TestObjectUuids : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("TestObjectUuids : PASS\n");
}


void
SPipe (
    )
/*++

Routine Description:

    This routine is used to perform a build verification test of the
    rpc runtime.  This test checks for basic functionality of the
    runtime.  It works with Sebastian in uclnt.exe.

--*/
{
    PrintToConsole("SPipe : Test Pipes\n");

    Status = RpcServerRegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,0,0);
    if (Status)
        {
        ApiError("SPipe","RpcServerRegisterIf",Status);
        PrintToConsole("SPipe : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerRegisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation,0,0);
    if (Status)
        {
        ApiError("SPipe","RpcServerRegisterIf",Status);
        PrintToConsole("SPipe : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(SPIPE), 0);
    if (Status)
        {
        ApiError("SPipe","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("SPipe : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    Status = RpcServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("SPipe","RpcServerListen",Status);
        PrintToConsole("SPipe : FAIL - RpcServerListen Failed\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("SPipe : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("SPipe","RpcServerUnregisterIf",Status);
        PrintToConsole("SPipe : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    PrintToConsole("SPipe : PASS\n");
}


void
Grant (
    )
/*++

Routine Description:

    This routine is used to perform a build verification test of the
    rpc runtime.  This test checks for basic functionality of the
    runtime.  It works with Graham in uclnt.exe.

--*/
{
    PrintToConsole("Grant : Verify Basic Server Functionality\n");

    Status = stub_RegisterIf((RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, (RPC_MGR_EPV PAPI *) 722);
    if (Status)
        {
        ApiError("Grant","stub_RegisterIf",Status);
        PrintToConsole("Grant : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Grant","stub_RegisterIf",Status);
        PrintToConsole("Grant : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(GRANT), 0);
    if (Status)
        {
        ApiError("Grant","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Grant : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    HelgaCheckManagerEpv = 1;
    HelgaManagerEpv = (RPC_MGR_EPV PAPI *) 722;
    if (DatagramFlag == 0)
        {
        HelgaCheckObject = 1;
        }
    HelgaMagicNumber = 106;
    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    HelgaCheckObject = 0;
    HelgaCheckManagerEpv = 0;
    if (Status)
        {
        ApiError("Grant","stub_ServerListen",Status);
        PrintToConsole("Grant : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (HelgaErrors != 0)
        {
        PrintToConsole("Grant : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Grant : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Grant","RpcServerUnregisterIf",Status);
        PrintToConsole("Grant : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Grant","RpcServerUnregisterIf",Status);
        PrintToConsole("Grant : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("Grant : PASS\n");
}


void
Elliot (
    )
/*++

Routine Description:

    This routine tests callbacks, multiple address, and multiple
    interfaces. It works with Edward in uclnt.exe.  We also test
    client side binding as well.  This test is named after a famous
    (at least in his mind) cat.

--*/
{
    PrintToConsole("Elliot : Verify Multiple Addresses and Interfaces, ");
    PrintToConsole("and Callbacks\n");

    Status = RpcImpersonateClient(0);
    if ( Status != RPC_S_NO_CALL_ACTIVE )
        {
        ApiError("Elliot", "RpcImpersonateClient", Status);
        PrintToConsole("Elliot : FAIL - RpcImpersonateClient\n");
        return;
        }

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(ELLIOTMAXIMIZE), 0);
    if (Status)
        {
        ApiError("Elliot","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Elliot : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    Status = stub_RegisterIf((RPC_IF_HANDLE) &SylviaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Elliot","stub_RegisterIf",Status);
        PrintToConsole("Elliot : FAIL - Unable to Register Interface ");
        PrintToConsole("(Sylvia)\n");
        return;
        }

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(ELLIOTMINIMIZE), 0);
    if (Status)
        {
        ApiError("Elliot","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Elliot : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(ELLIOTNORMAL), 0);
    if (Status)
        {
        ApiError("Elliot","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Elliot : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    Status = stub_RegisterIf((RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Elliot","stub_RegisterIf",Status);
        PrintToConsole("Elliot : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Elliot","stub_RegisterIf",Status);
        PrintToConsole("Elliot : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    PrintToConsole("Elliot: Start listening\n") ;
    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 1);
    if (Status)
        {
        ApiError("Elliot","stub_ServerListen",Status);
        PrintToConsole("Elliot : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (AutoListenFlag == 0)
        {
        PrintToConsole("Elliot: RpcMgmtWaitServerListen\n") ;
        Status = RpcMgmtWaitServerListen();
        if (Status)
            {
            ApiError("Elliot","RpcMgmtWaitServerListen",Status);
            PrintToConsole("Elliot : FAIL - RpcMgmtWaitServerListen Failed\n");
            return;
            }
        }

    if (HelgaErrors != 0)
        {
        PrintToConsole("Elliot : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    if (SylviaErrors != 0)
        {
        PrintToConsole("Elliot : FAIL - Error(s) in Sylvia Interface\n");
        SylviaErrors = 0;
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Elliot : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    if (AutoListenFlag)
        {
        // unregister the interfaces individually
        Status = RpcServerUnregisterIf(
         (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
        if (Status)
            {
            ApiError("Elliot","RpcServerUnregisterIf",Status);
            PrintToConsole("Elliot : FAIL - Unable to Unregister Interface ");
            PrintToConsole("(Isabelle)\n");
            return;
            }

        Status = RpcServerUnregisterIf(
         (RPC_IF_HANDLE) &SylviaInterfaceInformation, 0, 0);
        if (Status)
            {
            ApiError("Elliot","RpcServerUnregisterIf",Status);
            PrintToConsole("Elliot : FAIL - Unable to Unregister Interface ");
            PrintToConsole("(Sylvia)\n");
            return;
            }

        Status = RpcServerUnregisterIf(
         (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
        if (Status)
            {
            ApiError("Elliot","RpcServerUnregisterIf",Status);
            PrintToConsole("Elliot : FAIL - Unable to Unregister Interface ");
            PrintToConsole("(Helga)\n");
            return;
            }
        }
    else
        {
        Status = RpcServerUnregisterIf(0, 0, 0);
        if (Status)
            {
            ApiError("Elliot","RpcServerUnregisterIf",Status);
            PrintToConsole("Elliot : FAIL - Unable to Unregister All Interfaces\n");
            return;
            }
        }

    PrintToConsole("Elliot : PASS\n");
}


void
Andromida (
    )
/*++

Routine Description:

    This routine is used to perform multithreaded client tests.  This
    test works with the Astro test in uclnt.exe.

--*/
{
    PrintToConsole("Andromida : Multithreaded Clients\n");

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(ANDROMIDA), 0);
    if (Status)
        {
        ApiError("Andromida","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Andromida : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    Status = stub_RegisterIf((RPC_IF_HANDLE) &SylviaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Andromida","stub_RegisterIf",Status);
        PrintToConsole("Andromida : FAIL - Unable to Register Interface ");
        PrintToConsole("(Sylvia)\n");
        return;
        }

    Status = stub_RegisterIf((RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Andromida","stub_RegisterIf",Status);
        PrintToConsole("Andromida : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Andromida","stub_RegisterIf",Status);
        PrintToConsole("Andromida : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("Andromida","stub_ServerListen",Status);
        PrintToConsole("Andromida : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (HelgaErrors != 0)
        {
        PrintToConsole("Andromida : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    if (SylviaErrors != 0)
        {
        PrintToConsole("Andromida : FAIL - Error(s) in Sylvia Interface\n");
        SylviaErrors = 0;
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Andromida : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Andromida","RpcServerUnregisterIf",Status);
        PrintToConsole("Andromida : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Andromida","RpcServerUnregisterIf",Status);
        PrintToConsole("Andromida : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &SylviaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Andromida","RpcServerUnregisterIf",Status);
        PrintToConsole("Andromida : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Sylvia)\n");
        return;
        }

    PrintToConsole("Andromida : PASS\n");
}


void
Fredrick (
    )
/*++

Routine Description:

    This routine is used to verify all client DCE rpc runtime APIs.  It
    works with Fitzgerald in uclnt.exe.

--*/
{
    PrintToConsole("Fredrick : Verify All Client APIs\n");

    if (TransportType == RPC_TRANSPORT_TCP)
        {
        struct hostent *he;
        WSADATA data;
        struct in_addr addr;
        u_long AddrAsLong;
        RPC_CHAR Buffer[50];
        RPC_POLICY Policy;

        if ( WSAStartup(2, &data) != NO_ERROR)
            {
            ApiError("Fredrick","WSAStartup",Status);
            PrintToConsole("Fredrick : FAIL - Unable to call WSAStartup\n");
            return;
            }

        // Get Dns hostname
        he = gethostbyname( "" );
        if (he == NULL)
            {
            ApiError("Fredrick","gethostbyname",Status);
            PrintToConsole("Fredrick : FAIL - Unable to call gethostbyname\n");
            return;
            }

//        AddrAsLong = ntohl(*(DWORD *)he->h_addr_list[0]);
        memcpy(&addr, (DWORD *)he->h_addr_list[0], sizeof(addr));
        swprintf(Buffer, L"%d.%d.%d.%d", addr.S_un.S_un_b.s_b1, addr.S_un.S_un_b.s_b2,
            addr.S_un.S_un_b.s_b3, addr.S_un.S_un_b.s_b4);

        Policy.Length = sizeof(RPC_POLICY);
        Policy.EndpointFlags = 0;
        Policy.NICFlags = 0;
        Status = I_RpcServerUseProtseqEp2(Buffer, L"ncacn_ip_tcp", 3, L"2500", NULL, &Policy);
        if (Status)
            {
            ApiError("Fredrick","I_RpcServerUseProtseqEp2",Status);
            PrintToConsole("Fredrick : FAIL - Unable to Use Protseq Endpoint\n");
            return;
            }
        }

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(FREDRICK), 0);
    if (Status)
        {
        ApiError("Fredrick","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Fredrick : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    Status = stub_RegisterIf((RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Fredrick","stub_RegisterIf",Status);
        PrintToConsole("Fredrick : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Fredrick","stub_RegisterIf",Status);
        PrintToConsole("Fredrick : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("Fredrick","stub_ServerListen",Status);
        PrintToConsole("Fredrick : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (HelgaErrors != 0)
        {
        PrintToConsole("Fredrick : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Fredrick : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    PauseExecution(10000L);

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Fredrick","RpcServerUnregisterIf",Status);
        PrintToConsole("Fredrick : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Fredrick","RpcServerUnregisterIf",Status);
        PrintToConsole("Fredrick : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("Fredrick : PASS\n");
}


void
GenerateUuidValue (
    IN unsigned short MagicNumber,
    OUT UUID PAPI * Uuid
    )
/*++

Routine Description:

    This routine is used to generate a value for a uuid.  The magic
    number argument is used in mysterious and wonderful ways to
    generate a uuid (which is not necessarily correct).

Arguments:

    MagicNumber - Supplies a magic number which will be used to
        generate a uuid.

    Uuid - Returns the generated uuid.

--*/
{
    Uuid->Data1 = ((unsigned long) MagicNumber)
        * ((unsigned long) MagicNumber);
    Uuid->Data2 = MagicNumber;
    Uuid->Data3 = MagicNumber / 2;
    Uuid->Data4[0] = MagicNumber % 256;
    Uuid->Data4[1] = MagicNumber % 257;
    Uuid->Data4[2] = MagicNumber % 258;
    Uuid->Data4[3] = MagicNumber % 259;
    Uuid->Data4[4] = MagicNumber % 260;
    Uuid->Data4[5] = MagicNumber % 261;
    Uuid->Data4[6] = MagicNumber % 262;
    Uuid->Data4[7] = MagicNumber % 263;
}


int
ChristopherObjectSetType (
    IN unsigned short ObjectMagicNumber,
    IN unsigned short TypeMagicNumber,
    IN unsigned int MustFailFlag
    )
/*++

Routine Description:

    This routine calls the RpcObjectSetType routine.  The object uuid
    is generated using the object magic number argument, and the type
    uuid uses the type magic number argument.

Arguments:

    ObjectMagicNumber - Supplies the magic number to be used to generate
        the object uuid to be passed to RpcObjectSetType.

    TypeMagicNumber - Supplies the magic number to use to generate the
        type uuid.

    MustFailFlag - Supplies a flag indicating whether or not the call
        to RpcObjectSetType must succeed or fail.  If this flag is
        zero, then RpcObjectSetType must return RPC_S_OK, otherwise,
        the test fails.  If the flag is non-zero, then RpcObjectSetType
        must return RPC_S_ALREADY_REGISTERED.

Return Value:

    Zero will be returned if the test completes successfully; otherise,
    non-zero will be returned.

--*/
{
    UUID ObjectUuid;
    UUID TypeUuid;

    GenerateUuidValue(ObjectMagicNumber,&ObjectUuid);
    GenerateUuidValue(TypeMagicNumber,&TypeUuid);

    Status = RpcObjectSetType(&ObjectUuid,&TypeUuid);
    if (MustFailFlag == 0)
        {
        if (Status)
            {
            ApiError("Christopher","RpcObjectSetType",Status);
            PrintToConsole("Christopher : FAIL - Can not Set Object Type\n");
            return(1);
            }
        }
    else
        {
        if (Status != RPC_S_ALREADY_REGISTERED)
            {
            PrintToConsole("Christopher : FAIL - RpcObjectSetType did not");
            PrintToConsole(" fail as expected\n");
            return(1);
            }
        }

    return(0);
}


int
ChristopherObjectSetNullType (
    IN unsigned short ObjectMagicNumber,
    IN unsigned int UseNullUuidFlag,
    IN unsigned int MustFailFlag
    )
/*++

Routine Description:

    This routine calls the RpcObjectSetType routine.  The object uuid
    is generated using the object magic number argument, and the type
    uuid is either not specified, or is the null uuid.

Arguments:

    ObjectMagicNumber - Supplies the magic number to be used to generate
        the object uuid to be passed to RpcObjectSetType.

    UseNullUuidFlag - Supplies a flag indicating whether to specify
        the null uuid for the type uuid or nothing.  If this flag is
        non-zero the null uuid will be specified as the type uuid;
        otherwise, the type uuid will not be specified.

    MustFailFlag - Supplies a flag indicating whether or not the call
        to RpcObjectSetType must succeed or fail.  If this flag is
        zero, then RpcObjectSetType must return RPC_S_OK, otherwise,
        the test fails.  If the flag is non-zero, then RpcObjectSetType
        must return RPC_S_OBJECT_NOT_FOUND.

Return Value:

    Zero will be returned if the test completes successfully; otherise,
    non-zero will be returned.

--*/
{
    UUID ObjectUuid;
    UUID TypeUuid;

    GenerateUuidValue(ObjectMagicNumber,&ObjectUuid);
    memset(&TypeUuid,0,sizeof(UUID));

    if (UseNullUuidFlag == 0)
        Status = RpcObjectSetType(&ObjectUuid,&TypeUuid);
    else
        Status = RpcObjectSetType(&ObjectUuid,0);
    if (MustFailFlag == 0)
        {
        if (Status)
            {
            ApiError("Christopher","RpcObjectSetType",Status);
            PrintToConsole("Christopher : FAIL - Can not Set Object Type\n");
            return(1);
            }
        }
    else
        {
        if (Status != RPC_S_OK)
            {
            PrintToConsole("Christopher : FAIL - RpcObjectSetType did not");
            PrintToConsole(" fail as expected\n");
            return(1);
            }
        }

    return(0);
}


int
ChristopherObjectInqType (
    IN unsigned short ObjectMagicNumber,
    IN unsigned short TypeMagicNumber,
    IN unsigned int MustFailFlag
    )
/*++

Routine Description:

    This routine calls the RpcObjectInqType routine.  The object uuid
    is generated using the object magic number argument, and the type
    uuid uses the type magic number argument.

Arguments:

    ObjectMagicNumber - Supplies the magic number to be used to generate
        the object uuid to be passed to RpcObjectInqType.

    TypeMagicNumber - Supplies the magic number to use to generate the
        expected type uuid.

    MustFailFlag - Supplies a flag indicating whether or not the call
        to RpcObjectInqType must fail or succeed.  If this flag is
        non-zero, RpcObjectInqType must return RPC_S_OBJECT_NOT_FOUND,
        otherwise the test fails.  If the flag is zero, then
        RpcObjectInqType must succeed.

Return Value:

    Zero will be returned if the test completes successfully; otherise,
    non-zero will be returned.

--*/
{
    UUID ObjectUuid;
    UUID TypeUuid;
    UUID ExpectedTypeUuid;

    GenerateUuidValue(ObjectMagicNumber,&ObjectUuid);
    GenerateUuidValue(TypeMagicNumber,&ExpectedTypeUuid);

    Status = RpcObjectInqType(&ObjectUuid,&TypeUuid);
    if (MustFailFlag == 0)
        {
        if (Status)
            {
            ApiError("Christopher","RpcObjectInqType",Status);
            PrintToConsole("Christopher : FAIL - Can not Inquire");
            PrintToConsole(" Object Type\n");
            return(1);
            }

        if (memcmp(&ExpectedTypeUuid,&TypeUuid,sizeof(UUID)) != 0)
            {
            PrintToConsole("Christopher : FAIL - TypeUuid != ");
            PrintToConsole("ExpectedTypeUuid\n");
            return(1);
            }
        }
    else
        {
        if (Status != RPC_S_OBJECT_NOT_FOUND)
            {
            PrintToConsole("Christopher : FAIL - RpcObjectInqType ");
            PrintToConsole("succeeded\n");
            return(1);
            }
        }

    return(0);
}

static UUID ChristopherObjectUuid;
static UUID ChristopherTypeUuid;


void
ChristopherRpcObjectInqFn (
    IN UUID PAPI * ObjectUuid,
    OUT UUID PAPI * TypeUuid,
    OUT RPC_STATUS PAPI * Status
    )
/*++

Routine Description:

    This routine is the object inquiry function we will pass to the
    runtime.  If the object uuid specified is equal to the global
    object uuid, we will return the global type uuid and RPC_S_OK;
    otherwise, we will return RPC_S_OBJECT_NOT_FOUND.

Arguments:

    ObjectUuid - Supplies the object uuid to compare with the global
        object uuid.

    TypeUuid - Returns the type uuid if the object uuid is found.

    Status - Returns the status of the operations.  This will be
        either RPC_S_OK or RPC_S_OBJECT_NOT_FOUND.

--*/
{
    if (memcmp(ObjectUuid,&ChristopherObjectUuid,sizeof(UUID)) != 0)
        {
        *Status = RPC_S_OBJECT_NOT_FOUND;
        return;
        }

    memcpy(TypeUuid,&ChristopherTypeUuid,sizeof(UUID));
    *Status = RPC_S_OK;
    return;
}


int
ChristopherTestObject (
    )
/*++

Routine Description:

    This routine is used by Christopher to test RpcObjectInqType,
    RpcObjectSetInqFn, and RpcObjectSetType.

Return Value:

    Zero will be returned if all of the tests complete successfully,
    otherwise, non-zero will be returned.

--*/
{
    if (ChristopherObjectSetType(12345,2987,0))
        return(1);

    if (ChristopherObjectInqType(12345,2987,0))
        return(1);

    if (ChristopherObjectInqType(5421,2987,1))
        return(1);

    if (ChristopherObjectSetType(12345,2987,1))
        return(1);

    if (ChristopherObjectSetType(12,2987,0))
        return(1);

    if (ChristopherObjectSetType(123,2987,0))
        return(1);

    if (ChristopherObjectSetType(1234,2987,0))
        return(1);

    if (ChristopherObjectInqType(12,2987,0))
        return(1);

    if (ChristopherObjectInqType(123,2987,0))
        return(1);

    if (ChristopherObjectInqType(1234,2987,0))
        return(1);

    if (ChristopherObjectInqType(12345,2987,0))
        return(1);

    if (ChristopherObjectSetNullType(123,0,0))
        return(1);

    if (ChristopherObjectSetNullType(1234,1,0))
        return(1);

    if (ChristopherObjectInqType(123,2987,1))
        return(1);

    if (ChristopherObjectInqType(1234,2987,1))
        return(1);

    if (ChristopherObjectSetNullType(5421,0,1))
        return(1);

    if (ChristopherObjectSetNullType(421,0,1))
        return(1);

    Status = RpcObjectSetInqFn(&ChristopherRpcObjectInqFn);
    if (Status)
        {
        ApiError("Christopher","RpcObjectSetInqFn",Status);
        PrintToConsole("Christopher : FAIL - RpcObjectSetInqFn ");
        PrintToConsole("(ChristopherRpcObjectInqFn)\n");
        return(1);
        }

    GenerateUuidValue(10666,&ChristopherObjectUuid);
    GenerateUuidValue(8466,&ChristopherTypeUuid);

    if (ChristopherObjectInqType(96,2987,1))
        return(1);

    if (ChristopherObjectInqType(10666,8466,0))
        return(1);

    Status = RpcObjectSetInqFn(0);
    if (Status)
        {
        ApiError("Christopher","RpcObjectSetInqFn",Status);
        PrintToConsole("Christopher : FAIL - RpcObjectSetInqFn (0)\n");
        return(1);
        }

    if (ChristopherObjectInqType(10666,8466,1))
        return(1);

    return(0);
}


int
ChristopherTestInquire (
    )
/*++

Routine Description:

    Christopher uses this routine to test RpcServerInqIf and RpcIfInqId.

Return Value:

    Zero will be returned if all of the test successfully pass.  Otherwise,
    non-zero will be returned.

--*/
{
    RPC_IF_ID RpcIfId;
    UUID TypeUuid;
    RPC_MGR_EPV PAPI * ManagerEpv;

    Status = RpcIfInqId((RPC_IF_HANDLE) &IsabelleInterfaceInformation,
        &RpcIfId);
    if (Status)
        {
        ApiError("Christopher","RpcIfInqId",Status);
        PrintToConsole("Christopher : FAIL - Error in RpcIfInqId\n");
        return(1);
        }

    if (   (RpcIfId.VersMajor != 1)
        || (RpcIfId.VersMinor != 1)
        || (RpcIfId.Uuid.Data1 != 9)
        || (RpcIfId.Uuid.Data2 != 8)
        || (RpcIfId.Uuid.Data3 != 8)
        || (RpcIfId.Uuid.Data4[0] != 7)
        || (RpcIfId.Uuid.Data4[1] != 7)
        || (RpcIfId.Uuid.Data4[2] != 7)
        || (RpcIfId.Uuid.Data4[3] != 7)
        || (RpcIfId.Uuid.Data4[4] != 7)
        || (RpcIfId.Uuid.Data4[5] != 7)
        || (RpcIfId.Uuid.Data4[6] != 7)
        || (RpcIfId.Uuid.Data4[7] != 7))
        {
        PrintToConsole("Christopher : FAIL - Wrong RpcIfId\n");
        return(1);
        }

    TypeUuid.Data1 = 0x12345678;
    TypeUuid.Data2 = 0x9ABC;
    TypeUuid.Data3 = 0xDEF0;
    TypeUuid.Data4[0] = 0x12;
    TypeUuid.Data4[1] = 0x34;
    TypeUuid.Data4[2] = 0x56;
    TypeUuid.Data4[3] = 0x78;
    TypeUuid.Data4[4] = 0x9A;
    TypeUuid.Data4[5] = 0xBC;
    TypeUuid.Data4[6] = 0xDE;
    TypeUuid.Data4[7] = 0xF0;

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            &TypeUuid, (RPC_MGR_EPV PAPI *) 38756);
    if (Status)
        {
        ApiError("Christopher","stub_RegisterIf",Status);
        PrintToConsole("Christopher : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return(1);
        }

    Status = RpcServerInqIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            &TypeUuid,&ManagerEpv);
    if (Status)
        {
        ApiError("Christopher","RpcServerInqIf",Status);
        PrintToConsole("Christopher : FAIL - RpcServerInqIf\n");
        return(1);
        }

    if (ManagerEpv != (RPC_MGR_EPV PAPI *) 38756)
        {
        PrintToConsole("Christopher : FAIL - ManagerEpv != 38756\n");
        return(1);
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Christopher","RpcServerUnregisterIf",Status);
        PrintToConsole("Christopher : FAIL - Unable to Unregister");
        PrintToConsole(" Interface (Isabelle)\n");
        return(1);
        }

    return(0);
}


void
Christopher (
    )
/*++

Routine Description:

    We verify all server side APIs in this routine.  The idea is to
    emphasize complete coverage, rather than indepth coverage.  Actually,
    by all server side APIs, I really mean all server side APIs except
    for security and name service.  The following list is the APIs
    which will be tested by this routine.

    RpcBindingInqObject [SCONNECTION]
    RpcBindingToStringBinding [SCONNECTION]
    RpcBindingToStringBinding [SVR_BINDING_HANDLE]
    RpcBindingVectorFree
    RpcIfInqId
    RpcNetworkInqProtseqs
    RpcObjectInqType
    RpcObjectSetInqFn
    RpcObjectSetType
    RpcProtseqVectorFree
    RpcServerInqBindings
    RpcServerInqIf
    RpcServerListen
    stub_RegisterIf
    RpcServerUnregisterIf
    RpcServerUseAllProtseqs
    RpcServerUseAllProtseqsIf
    RpcServerUseProtseq
    RpcServerUseProtseqEpWrapper
    RpcServerUseProtseqIf
    RpcMgmtStopServerListening
    RpcMgmtInqIfIds
    RpcIfIdVectorFree

--*/
{
    RPC_PROTSEQ_VECTORA * RpcProtseqVector;
    unsigned int Index;
    UUID TypeUuid;
    UUID ObjectUuid;
    RPC_IF_ID_VECTOR * InterfaceIdVector;
    unsigned char * String;

    PrintToConsole("Christopher : Verify All Server APIs\n");

    Status = RpcNetworkInqProtseqsA(&RpcProtseqVector);
    if (Status)
        {
        ApiError("Christopher","RpcNetworkInqProtseqs",Status);
        PrintToConsole("Christopher : FAIL - RpcNetworkInqProtseqs\n");
        return;
        }

    PrintToConsole("Christopher : (RpcNetworkInqProtseqs)\n");
    for (Index = 0; Index < RpcProtseqVector->Count; Index++)
        {
        PrintToConsole("    ");
        PrintToConsole((char *) RpcProtseqVector->Protseq[Index]);
        PrintToConsole("\n");
        }

    Status = RpcProtseqVectorFreeA(&RpcProtseqVector);
    if (Status)
        {
        ApiError("Christopher","RpcProtseqVectorFree",Status);
        PrintToConsole("Christopher : FAIL - RpcProtseqVectorFree\n");
        return;
        }

    Status = RpcProtseqVectorFreeA(&RpcProtseqVector);
    if (Status)
        {
        ApiError("Christopher","RpcProtseqVectorFree",Status);
        PrintToConsole("Christopher : FAIL - RpcProtseqVectorFree\n");
        return;
        }

    ChristopherIsabelleError = 0;

    // This routine will test RpcServerInqIf and RpcIfInqId for us.

    if (ChristopherTestInquire() != 0)
        return;

    // We test RpcObjectInqType, RpcObjectSetInqFn, and RpcObjectSetType
    // in this routine.

    if (ChristopherTestObject() != 0)
        return;

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(CHRISTOPHER), 0);
    if (Status)
        {
        ApiError("Christopher","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Christopher : FAIL - Unable to Use Protseq ");
        PrintToConsole("Endpoint\n");
        return;
        }

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(CHRISTOPHER), 0);
    if (Status != RPC_S_DUPLICATE_ENDPOINT)
        {
        ApiError("Christopher","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Christopher : FAIL - Able to Add Duplicate ");
        PrintToConsole("Endpoint\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Christopher","stub_RegisterIf",Status);
        PrintToConsole("Christopher : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    // added for synchro support
    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Christopher","stub_RegisterIf",Status);
        PrintToConsole("Christopher : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    GenerateUuidValue(288, &ObjectUuid);
    GenerateUuidValue(3010, &TypeUuid);
    Status = RpcObjectSetType(&ObjectUuid, &TypeUuid);
    if (Status)
        {
        ApiError("Christopher","RpcObjectSetType",Status);
        PrintToConsole("Christopher : FAIL - Unable to Set Object Type\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation,
            &TypeUuid, (RPC_MGR_EPV PAPI *) 9814);
    if (Status)
        {
        ApiError("Christopher","stub_RegisterIf",Status);
        PrintToConsole("Christopher : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            &TypeUuid, (RPC_MGR_EPV PAPI *) 9814);
    if (Status)
        {
        ApiError("Christopher","stub_RegisterIf",Status);
        PrintToConsole("Christopher : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUseAllProtseqsIfWrapper(1,
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0);
    if (Status)
        {
        ApiError("Christopher","RpcServerUseAllProtseqsIfWrapper",Status);
        PrintToConsole("Christopher : FAIL - Unable to Use All Protseqs ");
        PrintToConsole("from Interface\n");
        return;
        }

    Status = RpcServerUseProtseqIfWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0);
    if (Status)
        {
        ApiError("Christopher","RpcServerUseProtseqIfWrapper",Status);
        PrintToConsole("Christopher : FAIL - Unable to Use Protseq From ");
        PrintToConsole("Interface\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &SylviaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Christopher","stub_RegisterIf",Status);
        PrintToConsole("Christopher : FAIL - Unable to Register Interface ");
        PrintToConsole("(Sylvia)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &SylviaInterfaceInformation,
            &TypeUuid, (RPC_MGR_EPV PAPI *) 9814);
    if (Status)
        {
        ApiError("Christopher","stub_RegisterIf",Status);
        PrintToConsole("Christopher : FAIL - Unable to Register Interface ");
        PrintToConsole("(Sylvia)\n");
        return;
        }

    if (AutoListenFlag == 0)
        {
        Status = stub_ServerListen(123, 122, 0);
        if ( Status != RPC_S_MAX_CALLS_TOO_SMALL )
            {
            ApiError("Christopher", "stub_ServerListen", Status);
            PrintToConsole("Christopher : FAIL - stub_ServerListen\n");
            return;
            }
        }

    PrintToConsole("Christopher : Start Listening\n") ;
    HelgaManagerEpv = (RPC_MGR_EPV PAPI *) 9814;
    HelgaCheckManagerEpv = 1;
    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    HelgaCheckManagerEpv = 0;
    if (Status)
        {
        ApiError("Christopher","stub_ServerListen",Status);
        PrintToConsole("Christopher : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (ChristopherIsabelleError != 0)
        {
        ChristopherIsabelleError = 0;
        return;
        }

    Status = RpcMgmtInqIfIds(0, &InterfaceIdVector);
    if ( Status != RPC_S_OK )
        {
        ApiError("Christopher", "RpcMgmtInqIfIds", Status);
        PrintToConsole("Christopher : FAIL - Unable to Inquire Interface Ids\n");
        return;
        }

    for (Index = 0; Index < InterfaceIdVector->Count; Index++)
        {
        PrintToConsole("    ");
        UuidToStringA(&(InterfaceIdVector->IfId[Index]->Uuid), &String);
        PrintToConsole((char *) String);
        RpcStringFreeA(&String);
        PrintToConsole(" %d.%d\n", InterfaceIdVector->IfId[Index]->VersMajor,
                InterfaceIdVector->IfId[Index]->VersMinor);
        }

    Status = RpcIfIdVectorFree(&InterfaceIdVector);
    if (   ( Status != RPC_S_OK )
        || ( InterfaceIdVector != 0 ) )
        {
        ApiError("Christopher", "RpcIfIdVectorFree", Status);
        PrintToConsole("Christopher : FAIL - Unable to Free IfIdVector\n");
        return;
        }

    if (HelgaErrors != 0)
        {
        PrintToConsole("Christopher : FAIL - Error(s) in Helga");
        PrintToConsole(" Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 1);
    if (Status)
        {
        ApiError("Christopher","RpcServerUnregisterIf",Status);
        PrintToConsole("Christopher : FAIL - Unable to Unregister");
        PrintToConsole(" Interface (Helga)\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Christopher : FAIL - Error(s) in Isabelle");
        PrintToConsole(" Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 1);
    if (Status)
        {
        ApiError("Christopher","RpcServerUnregisterIf",Status);
        PrintToConsole("Christopher : FAIL - Unable to Unregister");
        PrintToConsole(" Interface (Isabelle)\n");
        return;
        }

    if (SylviaErrors != 0)
        {
        PrintToConsole("Christopher : FAIL - Error(s) in Sylvia Interface\n");
        SylviaErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &SylviaInterfaceInformation, 0, 1);
    if (Status)
        {
        ApiError("Christopher","RpcServerUnregisterIf",Status);
        PrintToConsole("Christopher : FAIL - Unable to Unregister");
        PrintToConsole(" Interface (Sylvia)\n");
        return;
        }

    Status = RpcServerUseProtseqWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS, 0);
    if (Status)
        {
        ApiError("Christopher","RpcServerUseProtseq",Status);
        PrintToConsole("Christopher : FAIL - Unable to Use Protseq\n");
        return;
        }

    Status = RpcServerUseAllProtseqsWrapper(1, 0);
    if (Status)
        {
        ApiError("Christopher","RpcServerUseAllProtseqsWrapper",Status);
        PrintToConsole("Christopher : FAIL - Unable to Use All Protseqs\n");
        return;
        }

    if (InquireBindings("Christopher") != 0)
        return;

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(CHRISTOPHERMUSTFAILONE), 0);
    if (Status != RPC_S_INVALID_ENDPOINT_FORMAT)
        {
        PrintToConsole("Christopher : FAIL - Status != ");
        PrintToConsole("RPC_S_INVALID_ENDPOINT_FORMAT");
        PrintToConsole(" (ChristopherMustFailOne)\n");
        return;
        }

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(CHRISTOPHERMUSTFAILTWO), 0);
    if (Status != RPC_S_INVALID_ENDPOINT_FORMAT)
        {
        PrintToConsole("Christopher : FAIL - Status != ");
        PrintToConsole("RPC_S_INVALID_ENDPOINT_FORMAT");
        PrintToConsole(" (ChristopherMustFailTwo)\n");
        return;
        }

// SkipInvalidEndpointFormat:

    Status = RpcServerUseProtseqEpWrapper((unsigned char *) "ncacn_bad",
            MAX_CALL_REQUESTS, GetEndpoint(CHRISTOPHERMUSTFAILONE), 0);
    if (Status != RPC_S_PROTSEQ_NOT_SUPPORTED)
        {
        PrintToConsole("Christopher : FAIL - Status != ");
        PrintToConsole("RPC_S_PROTSEQ_NOT_SUPPORTED (ncacn_bad)\n");
        return;
        }

    Status = RpcServerUseProtseqEpWrapper((unsigned char *) "mkm_np",
            MAX_CALL_REQUESTS, GetEndpoint(CHRISTOPHERMUSTFAILONE), 0);
    if (Status != RPC_S_PROTSEQ_NOT_SUPPORTED)
        {
        PrintToConsole("Christopher : FAIL - Status != ");
        PrintToConsole("RPC_S_PROTSEQ_NOT_SUPPORTED (bad_np)\n");
        return;
        }

    PrintToConsole("Christopher : PASS\n");
}


void
David (
    )
/*++

Routine Description:

    This routine is used to test association context rundown support;
    it works with Daniel in uclnt.exe.

--*/
{
    PrintToConsole("David : Association Context and Rundown\n");

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(DAVIDFIRST), 0);
    if (Status)
        {
        ApiError("David","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("David : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(DAVIDSECOND), 0);
    if (Status)
        {
        ApiError("David","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("David : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("David","stub_RegisterIf",Status);
        PrintToConsole("David : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    // Synchro support
    Status = stub_RegisterIf((RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("David","stub_RegisterIf",Status);
        PrintToConsole("David : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("David: Start Listening\n") ;
    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("David","stub_ServerListen",Status);
        PrintToConsole("David : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("David : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("David","RpcServerUnregisterIf",Status);
        PrintToConsole("David : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    // we don't unregister helga, as a method of isabelle should have
    // been called to do that

    PrintToConsole("David : PASS\n");
}


void
Tyler ( // Perform security tests.  This particular test works with
        // Thomas which lives in uclnt.cxx.
    )
/*++

Routine Description:

    Tyler works with Thomas, which lives in uclnt.exe, to perform build
    verification tests of security.

--*/
{
    SECURITY_DESCRIPTOR sd, *psd;

    PrintToConsole("Tyler : Test Security\n");

    if (TransportType == RPC_LRPC)
        {
        // ncalrpc needs a security descriptor.

        psd = &sd;

        InitializeSecurityDescriptor(
                        psd,
                        SECURITY_DESCRIPTOR_REVISION
                        );

        if ( FALSE == SetSecurityDescriptorDacl (
                            psd,
                            TRUE,                 // Dacl present
                            NULL,                 // NULL Dacl
                            FALSE                 // Not defaulted
                            ) )
            {
            ApiError("Tyler","SetSecurityDescriptorDacl",0);
            return;
            }
        }
    else
        {
        psd = 0;
        }


    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(TYLER), psd);
    if (Status)
        {
        ApiError("Tyler","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Tyler : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Tyler","stub_RegisterIf",Status);
        PrintToConsole("Tyler : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Tyler","stub_RegisterIf",Status);
        PrintToConsole("Tyler : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = RpcServerRegisterAuthInfoA((unsigned char PAPI *)
            "ServerPrincipal", ulSecurityPackage, 0, 0); //hack
    if (Status)
        {
        ApiError("Tyler", "RpcServerRegisterAuthInfo", Status);
        PrintToConsole("Tyler : FAIL - Unable to Register AuthInfo\n");
        return;
        }

    PrintToConsole("Tyler : Listening\n") ;
    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("Tyler","stub_ServerListen",Status);
        PrintToConsole("Tyler : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Tyler : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    if (HelgaErrors != 0)
        {
        PrintToConsole("Tyler : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Tyler","RpcServerUnregisterIf",Status);
        PrintToConsole("Tyler : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Tyler","RpcServerUnregisterIf",Status);
        PrintToConsole("Tyler : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("Tyler : PASS\n");
}


void
Terry ( // Perform security tests.  This particular test works with
        // Tim which lives in uclnt.cxx.
    )
/*++

Routine Description:

    Terry works with Tim, which lives in uclnt.exe, to perform build
    verification tests of NT security.

--*/
{
    PrintToConsole("Terry : Test Security\n");

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(TYLER), 0);
    if (Status)
        {
        ApiError("Terry","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Terry : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Terry","stub_RegisterIf",Status);
        PrintToConsole("Terry : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Terry","stub_RegisterIf",Status);
        PrintToConsole("Terry : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = RpcServerRegisterAuthInfoA((unsigned char PAPI *)
            "ServerPrincipal", ulSecurityPackage, 0, 0);
    if (Status)
        {
        ApiError("Terry", "RpcServerRegisterAuthInfo", Status);
        PrintToConsole("Terry : FAIL - Unable to Register AuthInfo\n");
        return;
        }

    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("Terry","stub_ServerListen",Status);
        PrintToConsole("Terry : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Terry : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    if (HelgaErrors != 0)
        {
        PrintToConsole("Terry : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Terry","RpcServerUnregisterIf",Status);
        PrintToConsole("Terry : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Terry","RpcServerUnregisterIf",Status);
        PrintToConsole("Terry : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("Terry : PASS\n");
}


void
RichardHelper (
    )
/*++

Routine Description:

    This routine will be used as a helper by Richard.  The description
    of Richard will explain how it is used.

--*/
{

    PrintToConsole("Richard : RichardHelper Executed\n");

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(RICHARDHELPER), 0);
    if (Status)
        {
        ApiError("RichardHelper", "RpcServerUseProtseqEpWrapper", Status);
        PrintToConsole("RichardHelper : FAIL - Unable to Use Protseq ");
        PrintToConsole("Endpoint\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("RichardHelper","stub_RegisterIf",Status);
        PrintToConsole("RichardHelper : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("RichardHelper","stub_RegisterIf",Status);
        PrintToConsole("RichardHelper : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("RichardHelper","stub_ServerListen",Status);
        PrintToConsole("RichardHelper : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("RichardHelper : FAIL - Error(s) in Isabelle");
        PrintToConsole(" Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("RichardHelper","RpcServerUnregisterIf",Status);
        PrintToConsole("RichardHelper : FAIL - Unable to Unregister ");
        PrintToConsole("Interface (Isabelle)\n");
        return;
        }

   Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("RichardHelper","RpcServerUnregisterIf",Status);
        PrintToConsole("RichardHelper : FAIL - Unable to Unregister ");
        PrintToConsole("Interface (Helga)\n");
        return;
        }
}


void
Richard (
    )
/*++

Description:

    Richard works with Robert (in uclnt.cxx) to test call and callback
    failures.  In particular, we want to test that a call failing does
    not invalidate the binding handle.  We will do this using the
    RichardHelper routine.

--*/
{
    PrintToConsole("Richard : Test Call and Callback Failures\n");

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(RICHARD), 0);
    if (Status)
        {
        ApiError("Richard","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Richard : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Richard","stub_RegisterIf",Status);
        PrintToConsole("Richard : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Richard","stub_RegisterIf",Status);
        PrintToConsole("Richard : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }


    PrintToConsole("Richard : Listening\n") ;
    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("Richard","stub_ServerListen",Status);
        PrintToConsole("Richard : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Richard : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Richard","RpcServerUnregisterIf",Status);
        PrintToConsole("Richard : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Richard","RpcServerUnregisterIf",Status);
        PrintToConsole("Richard : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("Richard : PASS\n");
}

void
Kenneth (
    )
/*++

Description:

    Kenneth works with Keith (in uclnt.cxx) to auto reconnect.

--*/
{
    PrintToConsole("Kenneth : Test Auto Reconnect\n");

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(KENNETH), 0);
    if (Status)
        {
        ApiError("Kenneth","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Kenneth : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Kenneth","stub_RegisterIf",Status);
        PrintToConsole("Kenneth : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    // Synchro support
    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Kenneth","stub_RegisterIf",Status);
        PrintToConsole("Kenneth : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("Kenneth : Listening\n") ;
    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("Kenneth","stub_ServerListen",Status);
        PrintToConsole("Kenneth : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Kenneth : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Kenneth","RpcServerUnregisterIf",Status);
        PrintToConsole("Kenneth : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    // synchro support
    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Kenneth","RpcServerUnregisterIf",Status);
        PrintToConsole("Kenneth : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("Kenneth : PASS\n");
}


void
BartholomewHelper (
    )
/*++

Routine Description:

    Bartholomew will use this routine to help with testing resolving
    endpoints.  We just need to use some protocol sequences and then
    register with the endpoint mapper before returning (and exiting).

--*/
{
    PrintToConsole("Bartholomew : BartholomewHelper Executed\n");

    Status = RpcServerUseAllProtseqsWrapper(1, 0);
    if (Status)
        {
        ApiError("BartholomewHelper","RpcServerUseAllProtseqsWrapper",Status);
        PrintToConsole("BartholomewHelper : FAIL - Unable to Use All Protseqs\n");
        return;
        }

    Status = RpcServerInqBindings(&BartholomewRpcBindingVector);
    if (Status)
        {
        ApiError("BartholomewHelper", "RpcServerInqBindings", Status);
        PrintToConsole("BartholomewHelper : FAIL - RpcServerInqBindings\n");
        return;
        }

    Status = RpcEpRegisterA((RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            BartholomewRpcBindingVector, 0,
            (unsigned char PAPI *) "usvr.exe");
    if (Status)
        {
        ApiError("BartholomewHelper", "RpcEpRegister", Status);
        PrintToConsole("BartholomewHelper : FAIL - RpcEpRegister Failed\n");
        return;
        }

    Status = RpcEpRegisterNoReplaceA(
            (RPC_IF_HANDLE) &SylviaInterfaceInformation,
            BartholomewRpcBindingVector, 0,
            (unsigned char PAPI *) "usvr.exe");
    if (Status)
        {
        ApiError("BartholomewHelper", "RpcEpRegisterNoReplace", Status);
        PrintToConsole("BartholomewHelper : FAIL - RpcEpRegister Failed\n");
        return;
        }

    PrintToConsole("Bartholomew : BartholomewHelper Exiting\n");
}


void
Bartholomew (
    )
/*++

Routine Description:

    This routine works with Benjamin in uclnt.exe to test that dynamic
    endpoints work.  What we actually do is inquire all bindings supported
    by this server, and then have the client bind to each of them, and
    make a call.

--*/
{
    PrintToConsole("Bartholomew : Test Dynamic Endpoints\n");

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(BARTHOLOMEW), 0);
    if (Status)
        {
        ApiError("Bartholomew", "RpcServerUseProtseqEpWrapper", Status);
        PrintToConsole("Bartholomew : FAIL - Unable to Use Protseq ");
        PrintToConsole("Endpoint\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Bartholomew","stub_RegisterIf",Status);
        PrintToConsole("Bartholomew : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    // Synchro support
    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Bartholomew","stub_RegisterIf",Status);
        PrintToConsole("Bartholomew : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &SylviaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Bartholomew","stub_RegisterIf",Status);
        PrintToConsole("Bartholomew : FAIL - Unable to Register Interface ");
        PrintToConsole("(Sylvia)\n");
        return;
        }

    Status = RpcServerUseProtseqWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS, 0);
    if (Status)
        {
        ApiError("Bartholomew","RpcServerUseProtseq",Status);
        PrintToConsole("Bartholomew : FAIL - Unable to Use Protseq\n");
        return;
        }

    Status = RpcServerUseAllProtseqsWrapper(1, 0);
    if (Status)
        {
        ApiError("Bartholomew","RpcServerUseAllProtseqsWrapper",Status);
        PrintToConsole("Bartholomew : FAIL - Unable to Use All Protseqs\n");
        return;
        }

    if ( InquireBindings("Bartholomew") != 0 )
        {
        return;
        }

    Status = RpcServerInqBindings(&BartholomewRpcBindingVector);
    if (Status)
        {
        ApiError("Bartholomew", "RpcServerInqBindings", Status);
        PrintToConsole("Bartholomew : FAIL - RpcServerInqBindings\n");
        return;
        }

    BartholomewIndex = 0;

    if ( UseEndpointMapperFlag != 0 )
        {
        Status = RpcEpRegisterA((RPC_IF_HANDLE) &IsabelleInterfaceInformation,
                BartholomewRpcBindingVector, 0,
                (unsigned char PAPI *) "usvr.exe");
        if (Status)
            {
            ApiError("Bartholomew", "RpcEpRegister", Status);
            PrintToConsole("Bartholomew : FAIL - RpcEpRegister Failed\n");
            return;
            }

        Status = RpcEpRegisterNoReplaceA(
                (RPC_IF_HANDLE) &SylviaInterfaceInformation,
                BartholomewRpcBindingVector, 0,
                (unsigned char PAPI *) "usvr.exe");
        if (Status)
            {
            ApiError("Bartholomew", "RpcEpRegisterNoReplace", Status);
            PrintToConsole("Bartholomew : FAIL - RpcEpRegister Failed\n");
            return;
            }

#ifdef WIN32RPC

        PROCESS_INFORMATION ProcessInformation;
        STARTUPINFOA StartupInfo;

        StartupInfo.cb = sizeof(STARTUPINFOA);
        StartupInfo.lpReserved = 0;
        StartupInfo.lpDesktop = 0;
        StartupInfo.lpTitle = 0;
        StartupInfo.dwX = 0;
        StartupInfo.dwY = 0;
        StartupInfo.dwXSize = 0;
        StartupInfo.dwYSize = 0;
        StartupInfo.dwFlags = 0;
        StartupInfo.wShowWindow = 0;
        StartupInfo.cbReserved2 = 0;
        StartupInfo.lpReserved2 = 0;

        char CommandLine[200];

        strcpy(CommandLine, "usvr ");
        strcat(CommandLine, TransportOption);

        strcat(CommandLine, " -bartholomewhelper");

        if (CreateProcessA(0, CommandLine, 0, 0, FALSE,
                0, 0, 0, &StartupInfo, &ProcessInformation) == FALSE)
            {
            OtherError("Bartholomew","CreateProcessA Failed");
            PrintToConsole("Bartholomew : FAIL - CreateProcess Failed\n");
            return;
            }

#endif // WIN32RPC

        PauseExecution(2000L);
        }

    PrintToConsole("Bartholomew : Listening\n") ;
    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("Bartholomew","stub_ServerListen",Status);
        PrintToConsole("Bartholomew : FAIL - stub_ServerListen Failed\n");
        return;
        }

    Status = RpcBindingVectorFree(&BartholomewRpcBindingVector);
    if (Status)
        {
        ApiError("Bartholomew", "RpcBindingVectorFree", Status);
        PrintToConsole("Bartholomew : FAIL - RpcBindingVectorFree\n");
        return;
        }

    if (BartholomewRpcBindingVector != 0)
        {
        PrintToConsole("Bartholomew : FAIL - ");
        PrintToConsole("BartholomewRpcBindingVector != 0\n");
        return;
        }

    // Synchro support
    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Bartholomew","RpcServerUnregisterIf",Status);
        PrintToConsole("Bartholomew : FAIL - Unable to Unregister ");
        PrintToConsole("Interface (Helga)\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Bartholomew : FAIL - Error(s) in Isabelle");
        PrintToConsole(" Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Bartholomew","RpcServerUnregisterIf",Status);
        PrintToConsole("Bartholomew : FAIL - Unable to Unregister ");
        PrintToConsole("Interface (Isabelle)\n");
        return;
        }

    if (SylviaErrors != 0)
        {
        PrintToConsole("Bartholomew : FAIL - Error(s) in Sylvia");
        PrintToConsole(" Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &SylviaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Bartholomew","RpcServerUnregisterIf",Status);
        PrintToConsole("Bartholomew : FAIL - Unable to Unregister ");
        PrintToConsole("Interface (Sylvia)\n");
        return;
        }

    PrintToConsole("Bartholomew : PASS\n");
}

void
TestYield (
    )
/*++

Routine Description:

    This routine works with Harold in uclnt.exe to test that idle
    connections get cleaned up properly, and that context is maintained.

--*/
{
    PrintToConsole("TestYeild : Test Yielding\n");

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(TESTYIELD), 0);
    if (Status)
        {
        ApiError("TestYield","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("TestYield: FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    // Synchro support
    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("TestYield","stub_RegisterIf",Status);
        PrintToConsole("TestYield: FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("TestYield","stub_ServerListen",Status);
        PrintToConsole("TestYield: FAIL - stub_ServerListen Failed\n");
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Herman","RpcServerUnregisterIf",Status);
        PrintToConsole("Herman : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("TestYield: PASS\n");
}


void
Herman (
    )
/*++

Routine Description:

    This routine works with Harold in uclnt.exe to test that idle
    connections get cleaned up properly, and that context is maintained.

--*/
{
    PrintToConsole("Herman : Test Idle Connection Cleanup and Context\n");

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(HERMAN), 0);
    if (Status)
        {
        ApiError("Herman","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Herman : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    // Synchro support
    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Herman","stub_RegisterIf",Status);
        PrintToConsole("Herman : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Herman","stub_RegisterIf",Status);
        PrintToConsole("Herman : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("Herman","stub_ServerListen",Status);
        PrintToConsole("Herman : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Herman : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Herman","RpcServerUnregisterIf",Status);
        PrintToConsole("Herman : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Herman","RpcServerUnregisterIf",Status);
        PrintToConsole("Herman : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("Herman : PASS\n");
}


void
Ivan (
    )
/*++

Routine Description:

    This routine stress tests the runtime.  It works with Isaac in uclnt.exe.

--*/
{
    PrintToConsole("Ivan : Stress Test\n");

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(IVAN), 0);
    if (Status)
        {
        ApiError("Ivan","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Ivan : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Ivan","stub_RegisterIf",Status);
        PrintToConsole("Ivan : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Ivan","stub_RegisterIf",Status);
        PrintToConsole("Ivan : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("Ivan","stub_ServerListen",Status);
        PrintToConsole("Ivan : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Ivan : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Ivan","RpcServerUnregisterIf",Status);
        PrintToConsole("Ivan : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    if (HelgaErrors != 0)
        {
        PrintToConsole("Ivan : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Ivan","RpcServerUnregisterIf",Status);
        PrintToConsole("Ivan : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("Ivan : PASS\n");
}


void
Jason (
    )
/*++

Routine Description:

    This routine helps perform performance tests of the runtime.  It works
    with James in uclnt.exe.

--*/
{
    PrintToConsole("Jason : Timing Tests With %d Listen Threads\n",
            MinimumListenThreads);

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(JASON), 0);
    if (Status)
        {
        ApiError("Jason","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Jason : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Jason","stub_RegisterIf",Status);
        PrintToConsole("Jason : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Jason","stub_RegisterIf",Status);
        PrintToConsole("Jason : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("Jason","stub_ServerListen",Status);
        PrintToConsole("Jason : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Jason : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Jason","RpcServerUnregisterIf",Status);
        PrintToConsole("Jason : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    if (HelgaErrors != 0)
        {
        PrintToConsole("Jason : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Jason","RpcServerUnregisterIf",Status);
        PrintToConsole("Jason : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("Jason : PASS\n");
}

void
WaitForAddressListChange (
    IN void *Ignore
    )
{
    OVERLAPPED ol;
    SOCKET sock;
    HANDLE hEvent;
    SOCKADDR_IN sockaddr;
    DWORD           byteRet;

    hEvent = CreateEvent(0, FALSE, FALSE, 0);
    if (hEvent == 0)
        {
        ApiError("WaitForAddressListChange", "CreateEventW", 0);
        return ;
        }

    sock = WSASocket(AF_INET,
                      SOCK_STREAM,
                      IPPROTO_TCP,
                      0,
                      0,
                      WSA_FLAG_OVERLAPPED);
    if (sock == INVALID_SOCKET)
        {
        ApiError("WaitForAddressListChange", "WSASocketW", GetLastError());
        return;
        }

    sockaddr.sin_addr.s_addr = INADDR_ANY;
    sockaddr.sin_family = AF_INET;
    sockaddr.sin_port = 0;

    if (bind(sock,(struct sockaddr *) &sockaddr, sizeof(SOCKADDR_IN)))
        {
        closesocket(sock);
        return;
        }

    if(listen(sock, 10) == SOCKET_ERROR)
        {
        closesocket(sock);
        return;
        }

    while (1)
        {
        ol.hEvent = hEvent;
        ol.Offset = 0;
        ol.OffsetHigh = 0;

        if (WSAIoctl(sock,
                     SIO_ADDRESS_LIST_CHANGE,
                     0, 0, 0, 0, &byteRet, &ol, 0) == SOCKET_ERROR)
            {
            if (WSAGetLastError() != ERROR_IO_PENDING)
                {
                ApiError("WaitForAddressListChange", "DeviceIoControl",
                         GetLastError());
                return;
                }

            //
            // Wait for the IO to complete
            //
            WaitForSingleObject(hEvent,INFINITE);
            }
        //
        // figure out the new address list
        //

        //
        // First find out how big a buffer do we need.
        //
        byteRet = 0;
        if (WSAIoctl(sock,
                    SIO_ADDRESS_LIST_QUERY,
                    0, 0, 0, 0, &byteRet, NULL, NULL) == 0)
            {
            I_RpcRequestMutex(&PrintMutex);
            PrintToConsole("The Address list has changed, it is now empty\n");
            I_RpcClearMutex(PrintMutex);
            continue;
            }
        else
            {
            if (WSAGetLastError() != WSAEFAULT || byteRet == 0 )
                {
                ApiError("WaitForAddressListChange", "SIO_ADDRESS_LIST_QUERY",
                         WSAGetLastError());
                return;
                }
            }

        LPSOCKET_ADDRESS_LIST  interfaceList =
            (LPSOCKET_ADDRESS_LIST) I_RpcAllocate(byteRet);
        if( interfaceList == NULL )
            {
            ApiError("WaitForAddressListChange", "I_RpcAllocate", 0);
            return;
            }


        if (WSAIoctl(sock,
                    SIO_ADDRESS_LIST_QUERY,
                    0, 0, interfaceList, byteRet,&byteRet,NULL, NULL) != ERROR_SUCCESS)
            {
            ApiError("WaitForAddressListChange", "SIO_ADDRESS_LIST_QUERY",
                     WSAGetLastError());
            return;
            }

        I_RpcRequestMutex(&PrintMutex);
        PrintToConsole("The Address list has changed:\n");
        int i;
        for (i = 0; i < interfaceList->iAddressCount; i++)
            {
            PrintToConsole("AF: %d, Address: ",
                           interfaceList->Address[i].lpSockaddr->sa_family);
            int j;
            for (j = 0; j<14; j++)
                {
                PrintToConsole("%u ",
                               (unsigned char) interfaceList->Address[i].lpSockaddr->sa_data[j]);
                }
            PrintToConsole("\n");
            }
        PrintToConsole("\n");
        I_RpcClearMutex(PrintMutex);
        }


}
static unsigned long DefaultThreadStackSize = 0;

int
TestPNP (
    )
{
    unsigned long ThreadIdentifier;
    HANDLE NotificationHandle = 0;
    WSAOVERLAPPED Overlapped;
    unsigned long bytes;
    HANDLE hEvent;
    WSADATA data;
    int retval ;

    if (WSAStartup(2, &data) != NO_ERROR)
        {
        return -1;
        }

    //
    // Create another thread to go off and wait on address list
    // changes
    //
    if (CreateThread(0,
                     DefaultThreadStackSize,
                     (LPTHREAD_START_ROUTINE) WaitForAddressListChange,
                     0,
                     0,
                     &ThreadIdentifier) == 0)
        {
        ApiError("TestPNP", "CreateThread", GetLastError());
        return -1;
        }

    hEvent = CreateEvent(0, FALSE, FALSE, 0);
    if (hEvent == 0)
        {
        ApiError("TestPNP", "CreateEventW", 0);
        return -1;
        }

    retval = WSAProviderConfigChange(
                    &NotificationHandle,
                    &Overlapped,
                    0
                    );

    if (retval != 0 || NotificationHandle == 0)
        {
        ApiError("TestPNP", "WSAProviderConfigChange", retval);
        return -1;
        }

    while (1)
        {
        Overlapped.hEvent = hEvent;
        Overlapped.Offset = 0;
        Overlapped.OffsetHigh = 0;

        retval = WSAProviderConfigChange(
                        &NotificationHandle,
                        &Overlapped,
                        0
                        );

        if (retval != 0)
            {
            if (GetLastError() == WSA_IO_PENDING)
                {
                WaitForSingleObject(hEvent,INFINITE);
                }
            else
                {
                ApiError("TestPNP", "WSAProviderConfigChange", retval);
                return -1;
                }
            }

        WSAPROTOCOL_INFO *lpProtocolBuffer;
        DWORD dwBufferLength = 1;
        int ProtocolCount;

        while (1)
            {
            lpProtocolBuffer = (WSAPROTOCOL_INFO *) I_RpcAllocate(dwBufferLength);
            if (lpProtocolBuffer == 0)
                {
                ApiError("TestPNP", "I_RpcAllocate", 0);
                return -1;
                }

            ProtocolCount = WSAEnumProtocols(
                                      0,
                                      lpProtocolBuffer,
                                      &dwBufferLength
                                      );
            if (ProtocolCount != SOCKET_ERROR)
                {
                break;
                }

            I_RpcFree(lpProtocolBuffer);

            if (GetLastError() != WSAENOBUFS)
                {
                return -1;
                }
            }

        int i;
        //
        // take the print mutex for the entire output, so we don't
        // garble it with the other thread
        //
        I_RpcRequestMutex(&PrintMutex);
        PrintToConsole("LoadedProtocols:\n");
        for (i = 0; i < ProtocolCount; i++)
            {
            PrintToConsole("SocketType: %d, Protocol:%d, Address Family: %d\n",
                           lpProtocolBuffer[i].iSocketType,
                           lpProtocolBuffer[i].iProtocol,
                           lpProtocolBuffer[i].iAddressFamily);

            }
        PrintToConsole("\n");
        I_RpcClearMutex(PrintMutex);
        }
}

void
RpcYield()
{
    RpcServerYield();
}

#if !defined (_M_AXP64)
void FireWall (
    )
{
    PMIB_IFTABLE pMib;
    DWORD Size = 20*sizeof(MIB_IFROW)+sizeof(DWORD);
    UINT i, j;

    for (i = 0; i < 2; i++)
        {
        pMib = (PMIB_IFTABLE) I_RpcAllocate(Size);
        if (pMib == 0)
            {
            return;
            }

        RpcpMemorySet(pMib, 0, Size);

        Status = GetIfTable(pMib, &Size, 0);
        if (Status == 0)
            {
            break;
            }
        }

    if (Status != RPC_S_OK)
        {
        return;
        }

    for (i = 1; i < pMib->dwNumEntries+1; i++)
        {
        for (j = 0; j < pMib->dwNumEntries; j++)
            {
            if (pMib->table[j].dwIndex == i)
                {
                PrintToConsole("IF[%d]: Ethernet: %s\n", i,
                               (char *) pMib->table[j].bDescr);
                break;
                }
            }
        }
}
#endif


extern void
Async (
    ) ;

int __cdecl
main (
    int argc,
    char * argv[]
    )

/*
Transports:

    Update this to add a new transport.
*/

{
    int argscan, testflag = 0;
    RPC_STATS_VECTOR * Statistics;
    char *option ;

    TransportType = RPC_TRANSPORT_NAMEPIPE;

    for (argscan = 1; argscan < argc; argscan++)
        {
        if (strcmp(argv[argscan], "-p") == 0)
        {
            ulSecurityPackage = (unsigned long) atol(argv[argscan+1]);
            argscan++;
        }
        else if (strcmp(argv[argscan],"-warn") == 0)
            WarnFlag = 1;
        else if (strcmp(argv[argscan],"-error") == 0)
            ErrorFlag = 1;
        else if (strcmp(argv[argscan],"-v") == 0)
            Verbose = 1;
        else if (strcmp(argv[argscan],"-verbose") == 0)
            Verbose = 1;
        else if (strcmp(argv[argscan],"-rpcss") == 0)
            {
            UseEndpointMapperFlag = 1;
            }
        else if (strcmp(argv[argscan],"-nosecuritytests") == 0)
            {
            NoSecurityTests = 1;
            }
        else if (strcmp(argv[argscan],"-sigfried") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            Sigfried();
           }
       else if (strcmp(argv[argscan],"-hybrid") == 0)
           {
           testflag = 1;
           PrintToConsole("RPC Runtime Hybrid Server Test\n");
           Hybrid();
           }
       else if (strcmp(argv[argscan],"-lpcsecurity") == 0)
           {
           testflag = 1;
           PrintToConsole("RPC Runtime Lpc Security Test\n");
           LpcSecurity();
           }
       else if (strcmp(argv[argscan],"-objuuid") == 0)
           {
           testflag = 1;
           PrintToConsole("RPC Obj Uuid test\n");
           TestObjectUuids();
           }
       else if (strcmp(argv[argscan],"-connid") == 0)
           {
           testflag = 1;
           PrintToConsole("RPC Conn Id test\n");
           TestObjectUuids();
           }
       else if (strcmp(argv[argscan],"-async") == 0)
           {
           testflag = 1;
           PrintToConsole("RPC Runtime Async RPC Tests\n");
           Async();
           }
       else if (strcmp(argv[argscan],"-ee") == 0)
           {
           PrintToConsole("enabling extended errors\n");
           fExtendedError = TRUE;
           }
       else if (strcmp(argv[argscan],"-dgtransport") == 0)
           {
           testflag = 1;
           PrintToConsole("datagram transport tests \n");
           DgTransport();
           }
       else if (strcmp(argv[argscan],"-sendack") == 0)
           {
           testflag = 1;
           PrintToConsole("RPC Runtime datagram delayed-ack Tests\n");
           SendAck();
           }
       else if (strcmp(argv[argscan],"-securityerror") == 0)
           {
           int testnum;

           testflag = 1;
           PrintToConsole("security provider error tests \n");

           argscan++ ;

           if (argscan == argc)
               {
               PrintToConsole("-securityerror: you must specify a test #, or zero for all, or '?' for help\n");
               return 1;
               }

           if (strcmp(argv[argscan], "?") == 0)
               {
               testnum = 100 ;
               }
           else
               {
               testnum = atoi(argv[argscan]) ;
               }
           SecurityErrorWrapper(testnum);
           }
        else if (strcmp(argv[argscan],"-grant") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            Grant();
            }
        else if (strcmp(argv[argscan],"-elliot") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            Elliot();
            }
        else if (strcmp(argv[argscan],"-andromida") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            Andromida();
            }
        else if (strcmp(argv[argscan],"-fredrick") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            Fredrick();
            }
        else if (strcmp(argv[argscan],"-christopher") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            Christopher();
            }
        else if (strcmp(argv[argscan],"-david") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            David();
            }
        else if (strcmp(argv[argscan],"-tyler") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            Tyler();
            }
        else if (strcmp(argv[argscan],"-terry") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            Terry();
            }
        else if (strcmp(argv[argscan],"-richardhelper") == 0)
            {
            testflag = 1;
            RichardHelper();
            return(0);
            }
        else if (strcmp(argv[argscan],"-bartholomewhelper") == 0)
            {
            testflag = 1;
            BartholomewHelper();
            return(0);
            }
        else if (strcmp(argv[argscan],"-richard") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            Richard();
            }
        else if (strcmp(argv[argscan],"-bartholomew") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            Bartholomew();
            }
        else if (strcmp(argv[argscan],"-herman") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            Herman();
            }
        else if (strcmp(argv[argscan],"-ivan") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            Ivan();
            }
        else if (strcmp(argv[argscan],"-jason") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            Jason();
            }
        else if (strcmp(argv[argscan],"-kenneth") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            Kenneth();
            }
        else if (strcmp(argv[argscan],"-pipe") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            SPipe();
            }
        else if (strcmp(argv[argscan],"-testyield") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            TestYield();
            }
        else if (strcmp(argv[argscan],"-yield") == 0)
            {
            testflag = 1;
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            RpcYield();
            }
        else if (strcmp(argv[argscan],"-pnp") == 0)
            {
            testflag = 1;
            PrintToConsole("Test PNP stuff\n");
            TestPNP();
            }
        else if (strcmp(argv[argscan],"-namepipe") == 0)
            {
            TransportType = RPC_TRANSPORT_NAMEPIPE;
            TransportOption = argv[argscan];
            }
        else if (strcmp(argv[argscan],"-lrpc") == 0)
            {
            TransportType = RPC_LRPC;
            TransportOption = argv[argscan];
            }
        else if (strcmp(argv[argscan],"-tcp") == 0)
            {
            TransportType = RPC_TRANSPORT_TCP;
            TransportOption = argv[argscan];
            }
        else if (strcmp(argv[argscan],"-udp") == 0)
            {
            DatagramFlag = 1;
            TransportType = RPC_TRANSPORT_UDP;
            TransportOption = argv[argscan];
            }
        else if (strcmp(argv[argscan],"-dnet") == 0)
            {
            TransportType = RPC_TRANSPORT_DNET;
            TransportOption = argv[argscan];
            }
        else if (strcmp(argv[argscan],"-spx") == 0)
            {
            TransportType = RPC_TRANSPORT_SPX;
            TransportOption = argv[argscan];
            }
        else if (strcmp(argv[argscan],"-ipx") == 0)
            {
            DatagramFlag = 1;
            TransportType = RPC_TRANSPORT_IPX;
            TransportOption = argv[argscan];
            }
        else if (strcmp(argv[argscan],"-vns") == 0)
            {
            TransportType = RPC_TRANSPORT_VNS;
            TransportOption = argv[argscan];
            }

        else if (strcmp(argv[argscan], "-dsp") == 0)
            {
            TransportType = RPC_TRANSPORT_DSP ;
            TransportOption = argv[argscan] ;
            }

        else if (strcmp(argv[argscan], "-msmq") == 0)
            {
            DatagramFlag = 1;
            TransportType = RPC_TRANSPORT_MSMQ ;
            TransportOption = argv[argscan] ;
            }

        else if (strcmp(argv[argscan], "-autolisten") == 0)
            {
            AutoListenFlag = 1 ;
            }
        else if (strcmp(argv[argscan], "-ifsecurity") == 0)
            {
            IFSecurity = 1;
            }
        else if (strcmp(argv[argscan], "-firewall") == 0)
            {
            testflag = 1;
            FireWallFlag = 1 ;
#if !defined (_M_AXP64)
            FireWall();
#else
            PrintToConsole("FAIL: The firewall test is not supported under Win64 or Win9x\n");
                        return (1);
#endif
            }

        else if (strcmp(argv[argscan],"-protocol") == 0)
            {
            strcpy(NetBiosProtocol+sizeof("ncacn_nb_")-1, argv[argscan+1]);
            argscan++;
            }
        else if (strcmp(argv[argscan],"-netbios") == 0)
            {
            TransportType = RPC_TRANSPORT_NETBIOS;
            TransportOption = argv[argscan];
            }
        else if (strncmp(argv[argscan], "-listen:", strlen("-listen:"))
                    == 0 )
            {
            MinimumListenThreads = atoi(argv[argscan] + strlen("-listen:"));
            if ( MinimumListenThreads == 0 )
                {
                MinimumListenThreads = 1;
                }
            }
        else if (strncmp(argv[argscan], "-rpcsize:", strlen("-rpcsize:"))
                    == 0 )
            {
            MaxRpcSize = atoi(argv[argscan] + strlen("-rpcsize:"));
            }
        else if (argv[argscan][0] == '-')
            {
            PrintToConsole("unknown option '%s'\n", argv[argscan]);
            return 1;
            }
        else
            {
            PrintToConsole("RPC Runtime Server Build Verification Test\n");
            PrintToConsole("Usage : usvr\n");
            PrintToConsole("        -warn : turn on warning messages\n");
            PrintToConsole("        -error : turn on error messages\n");
            PrintToConsole("        -sigfried\n");
            PrintToConsole("        -grant\n");
            PrintToConsole("        -elliot\n");
            PrintToConsole("        -andromida\n");
            PrintToConsole("        -fredrick\n");
            PrintToConsole("        -christopher\n");
            PrintToConsole("        -david\n");
            PrintToConsole("        -tyler\n");
            PrintToConsole("        -terry\n");
            PrintToConsole("        -richard\n");
            PrintToConsole("        -bartholomew\n");
            PrintToConsole("        -herman\n");
            PrintToConsole("        -ivan\n");
            PrintToConsole("        -jason\n");
            PrintToConsole("        -kenneth\n");
            PrintToConsole("        -namepipe\n");
            PrintToConsole("        -lrpc\n");
            PrintToConsole("        -tcp\n");
            PrintToConsole("        -udp\n");
            PrintToConsole("        -dnet\n");
            PrintToConsole("        -netbios\n");
            PrintToConsole("        -spx\n");
            PrintToConsole("        -dsp\n") ;
            PrintToConsole("        -vns\n") ;
            PrintToConsole("        -msmq\n") ;
            PrintToConsole("        -listen:<listen threads>\n");
            PrintToConsole("        -rpcss\n");
            PrintToConsole("        -p <security provider #>\n");
            PrintToConsole("        -nosecuritytests") ;
            return(1);
            }
        }


    if (!testflag)
        {
        PrintToConsole("RPC Runtime Server Build Verification Test\n");
    PrintToConsole("Sigfried\n") ;
        Sigfried();
    PrintToConsole("Grant\n") ;
        Grant();
    PrintToConsole("Elliot\n") ;
        Elliot();
    PrintToConsole("Andromida\n") ;
        Andromida();
    PrintToConsole("Fredrick\n") ;
        Fredrick();
    PrintToConsole("Christopher\n") ;
        Christopher();
    PrintToConsole("David\n") ;
        David();
        if ( NoSecurityTests == 0)
            {
        PrintToConsole("Tyler\n") ;
            Tyler();
            }
        if ( TransportType != RPC_LRPC )
            {
        PrintToConsole("Richard\n") ;
            Richard();
            }
    PrintToConsole("Kenneth\n") ;
        Kenneth();
    PrintToConsole("Bartholomew\n") ;
        Bartholomew();
    PrintToConsole("Async\n") ;
        Async();
        }

    Status = RpcMgmtInqStats(0,&Statistics);
    if (Status)
        {
        ApiError("main", "RpcMgmtInqStats", Status);
        return(0);
        }

    PrintToConsole("\nCalls (and Callbacks) Received : %lu",
            Statistics->Stats[RPC_C_STATS_CALLS_IN]);
    PrintToConsole("\nCallbacks Sent : %lu",
            Statistics->Stats[RPC_C_STATS_CALLS_OUT]);
    PrintToConsole("\nPackets Received : %lu\nPackets Sent : %lu\n",
            Statistics->Stats[RPC_C_STATS_PKTS_IN],
            Statistics->Stats[RPC_C_STATS_PKTS_OUT]);

    Status = RpcMgmtStatsVectorFree(&Statistics);
    if (Status)
        ApiError("main", "RpcMgmtStatsVectorFree", Status);

    return(0); // To keep the compiler happy.
}


//
// BVT for Async RPC
//

//
// Server side code
//

//
// the following routines outline the server side code for a simple async function.
//

#define TRACE(_x) { \
    if (Verbose) \
        {\
        PrintToConsole _x;\
        }\
    }

#if 0
//
// Begin, Approximate idl file
//
interface FooInterface {
    int Foo (handle_t hBinding, [in] int sizein, [in] int *bufferin,
                [in, out] int *sizeout, [out] int **bufferout) ;
    }
// End, idl file

//
// Begin, Corresponding ACF file
//
interface FooInterface {
    [async] Foo () ;
    }
// End, acf file

//
// look at asyncstub.h for the generated header
// file for function Foo
//
#endif

////////////////////////////////////////////////////////////
// Begin, stubs for Foo                                                      //
////////////////////////////////////////////////////////////

RPC_STATUS RPC_ENTRY
MyRpcAbortAsyncCall (
    IN PRPC_ASYNC_STATE pAsync,
    IN unsigned long ExceptionCode
    )
/*++

Routine Description:


Arguments:
 pAsync - the async handle being registered

Return Value:
    RPC_S_OK - the call succeeded.
    RPC_S_INVALID_HANDLE - the handle was bad.

--*/

{
    return I_RpcAsyncAbortCall(pAsync, ExceptionCode);
}


typedef struct {
    RPC_ASYNC_STUB_STATE StubState ;
    RPC_ASYNC_STATE AsyncState ;
    void *state ;
    int sizeout ;
    int *bufferout ;
    } FOO_ASYNC_SERVER_STATE;


RPC_STATUS
FooComplete (
    IN PRPC_ASYNC_STATE pAsync,
    IN void *Reply
    )
/*++

Routine Description:
    This is a generated stub. It is the completion routine for the function
    Foo. When the server app is done with processing a particular call to
    Foo, It calls Foo_complete to complete the call.

Arguments:

 pAsync - The async handle. This handle is always the first parameter of every
    Foo_complete routine.
--*/

{
    int *Ptr ;
    RPC_MESSAGE Message ;
    RPC_STATUS RpcStatus ;
    FOO_ASYNC_SERVER_STATE *StubInfo =
            (FOO_ASYNC_SERVER_STATE *) pAsync->StubInfo ;

    TRACE(("FooComplete called: %d\n", *((int *) Reply))) ;

    Message.ProcNum = RPC_FLAGS_VALID_BIT ;
    Message.RpcFlags = RPC_BUFFER_ASYNC;
    Message.BufferLength = 8 + StubInfo->sizeout  ;
    Message.Handle = StubInfo->StubState.CallHandle ;

    RpcStatus = I_RpcGetBuffer(&Message) ;
    if (RpcStatus)
        {
        return RpcStatus ;
        }

    Ptr = (int *) Message.Buffer ;
    *Ptr++ = *((int *) Reply) ;
    *Ptr++ = StubInfo->sizeout ;
    RpcpMemoryCopy(Ptr, StubInfo->bufferout, StubInfo->sizeout) ;

    I_RpcFree(StubInfo->bufferout) ;

    // send the async reply
    Message.RpcFlags = RPC_BUFFER_ASYNC;
    RpcStatus = I_RpcSend(&Message) ;
    if (RpcStatus)
        {
        return RpcStatus ;
        }

    I_RpcFree(pAsync->StubInfo) ;

    return RPC_S_OK ;
}


void
Foo_s (
    PRPC_MESSAGE Message
    )
/*++

Routine Description:

 Generated stub for Foo.

--*/

{
    int sizein ;
    int *bufferin ;
    int *Ptr ;
    FOO_ASYNC_SERVER_STATE *StubInfo;
    RPC_STATUS RpcStatus ;

    if ((Message->RpcFlags & RPC_BUFFER_COMPLETE) == 0)
        {
        Message->RpcFlags = RPC_BUFFER_EXTRA;
        RpcStatus = I_RpcReceive (Message, 0) ;
        if (RpcStatus)
            {
            RpcRaiseException(RpcStatus) ;
            }
        }

    StubInfo = (FOO_ASYNC_SERVER_STATE *)
               I_RpcAllocate(sizeof(FOO_ASYNC_SERVER_STATE)) ;

    if (StubInfo == 0)
        {
        RpcRaiseException(RPC_S_OUT_OF_MEMORY) ;
        }

    StubInfo->AsyncState.Size = sizeof(RPC_ASYNC_STATE) ;
    StubInfo->AsyncState.StubInfo = (void *) StubInfo ;
    StubInfo->AsyncState.Flags = 0;
    StubInfo->AsyncState.NotificationType = RpcNotificationTypeNone;

    StubInfo->StubState.CallHandle = Message->Handle ;
    StubInfo->StubState.Flags = 0;
    StubInfo->StubState.CompletionRoutine = FooComplete ;

    RpcStatus = I_RpcAsyncSetHandle(
                        Message,
                        (PRPC_ASYNC_STATE) &(StubInfo->AsyncState)) ;
    if (RpcStatus)
        {
        RpcRaiseException(RpcStatus) ;
        }

    // unmarshall the received data
    Ptr = (int *) Message->Buffer ;
    sizein = *Ptr++ ;
    bufferin = Ptr ;

    Ptr += (sizein+3)/sizeof(int) ;
    StubInfo->sizeout = *Ptr ;

    Foo ((PRPC_ASYNC_STATE) &(StubInfo->AsyncState),
            Message->Handle,
            sizein,
            bufferin,
            &(StubInfo->sizeout),
            &(StubInfo->bufferout)) ;

}

////////////////////////////////////////////////////////////
// End, stubs for Foo                                                         //
////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////
// Begin, Application                                                       //
//////////////////////////////////////////////////////////

typedef struct {
    PRPC_ASYNC_STATE pAsync ;
    RPC_BINDING_HANDLE hBinding ;
    int *sizeout ;
    int **bufferout ;
    } CALL_COOKIE ;


void
ThreadProc(
    CALL_COOKIE *Cookie
    )
/*++

Routine Description:

    The thread that calls Foo_complete. Foo_complete is being called
    in a separate thread to show that it infact can be.

Arguments:
    pAsync - the async handle on which Foo_complete needs to be called.

--*/

{
    int retval = 1;
    UUID ObjectUuid;

    TRACE(("Foo: Sending back async reply\n"));

    Status = RpcBindingInqObject(Cookie->hBinding, &ObjectUuid);
    if (Status)
        {
        goto Cleanup;
        }

    if (CheckUuidValue(UUID_ASYNC_EXCEPTION, &ObjectUuid) == 0)
        {
        MyRpcAbortAsyncCall(Cookie->pAsync, ASYNC_EXCEPT) ;
        return ;
        }

    *(Cookie->bufferout) = (int *) I_RpcAllocate(*(Cookie->sizeout)) ;
    if (*(Cookie->bufferout) == 0)
        {
        goto Cleanup;
        }

    if (CheckUuidValue(UUID_SLEEP_1000, &ObjectUuid) == 0)
        {
        Sleep(1000);
        }
    if (CheckUuidValue(UUID_SLEEP_2000, &ObjectUuid) == 0)
        {
        Sleep(2000);
        }
    else if (CheckUuidValue(UUID_TEST_CANCEL, &ObjectUuid) == 0)
        {
        if (RpcServerTestCancel(RpcAsyncGetCallHandle(Cookie->pAsync)) == RPC_S_OK)
            {
            PrintToConsole("Async: Call was cancelled\n");
            MyRpcAbortAsyncCall(Cookie->pAsync, ASYNC_EXCEPT) ;
            return;
            }
        }
    else if (CheckUuidValue(UUID_EXTENDED_ERROR, &ObjectUuid) == 0)
        {
        RPC_EXTENDED_ERROR_INFO ErrorInfo;

        ErrorInfo.Version = RPC_EEINFO_VERSION;
        ErrorInfo.ComputerName = NULL;
        ErrorInfo.Flags = 0;
        ErrorInfo.NumberOfParameters = 1;
        ErrorInfo.DetectionLocation = 0;
        ErrorInfo.GeneratingComponent = 0;
        ErrorInfo.ProcessID = 0;
        ErrorInfo.Status = EXTENDED_ERROR_EXCEPTION;
        ErrorInfo.Parameters[0].ParameterType = eeptAnsiString;

        ErrorInfo.Parameters[0].u.AnsiString = "first element of three generated by usvr in ThreadProc()";
        RpcErrorAddRecord(&ErrorInfo);

        ErrorInfo.Parameters[0].u.AnsiString = "second element of three generated by usvr in ThreadProc()";
        RpcErrorAddRecord(&ErrorInfo);

        ErrorInfo.Parameters[0].u.AnsiString = "third element of three generated by usvr in ThreadProc()";
        RpcErrorAddRecord(&ErrorInfo);
        MyRpcAbortAsyncCall(Cookie->pAsync, EXTENDED_ERROR_EXCEPTION);
        return;
        }

    Status = MyRpcCompleteAsyncCall(Cookie->pAsync, &retval) ;
    if (Status != RPC_S_OK)
        {
        PrintToConsole("Async: RpcCompleteAsyncCall return: %d\n",
                       Status);
        }

    Sleep(100);
    return;

Cleanup:

    PrintToConsole("ThreadProc: an unknown error occurred; returning out-of-memory\n");

    MyRpcAbortAsyncCall(Cookie->pAsync, RPC_S_OUT_OF_MEMORY) ;
    IsabelleError() ;
}

int Count = 0;


void
Foo (
    IN PRPC_ASYNC_STATE pAsync,
    IN RPC_BINDING_HANDLE hBinding,
    IN int sizein,
    IN int *bufferin,
    IN OUT int *sizeout,
    OUT int **bufferout
    )
/*++

Routine Description:

    This is a actual manager routine. It can spawn off an async operation
    (a thread in this case) to do the rest of the work, and send back the
    reply when it is done.

Arguments:
    pAsync - Async handle. This is always the first parameter of every async
    handle.
--*/

{
  unsigned long ThreadIdentifier;
  HANDLE HandleToThread ;
  CALL_COOKIE *CallCookie ;
  UUID ObjectUuid;

  Status = RpcBindingInqObject(hBinding, &ObjectUuid);
  if (Status)
      {
      PrintToConsole("Foo: can't inq object uuid, error = %d\n", Status);
      RpcRaiseException(Status);
      }

  if (CheckUuidValue(UUID_SYNC_EXCEPTION, &ObjectUuid) == 0)
      {
      RpcRaiseException(SYNC_EXCEPT) ;
      }

  Count++ ;
  TRACE(("Foo: Count %d\n", Count)) ;
  if ((Count % 7) == 0)
      {
      Sleep(100) ;
      }

  CallCookie = new CALL_COOKIE ;
  if (CallCookie == 0)
      {
      RpcRaiseException(APP_ERROR) ;
      }

  CallCookie->pAsync = pAsync ;
  CallCookie->sizeout = sizeout ;
  CallCookie->bufferout = bufferout ;
  CallCookie->hBinding = hBinding;

  if (*sizeout > 100000)
      {
      DebugBreak();
      }

  if (RpcServerTestCancel(RpcAsyncGetCallHandle(pAsync)) == RPC_S_OK)
      {
      PrintToConsole("Async: Call was cancelled\n");
      }

  if ((Count % 3) == 0)
      {
      ThreadProc(CallCookie);
      }
  else
      {
      HandleToThread = CreateThread(
                                0,
                                DefaultThreadStackSize,
                                (LPTHREAD_START_ROUTINE) ThreadProc,
                                CallCookie,
                                0,
                                &ThreadIdentifier);

      if (HandleToThread == 0)
        {
        PrintToConsole("Foo: Error, could not create thread\n") ;
        return ;
        }

       CloseHandle(HandleToThread);
      }

  // return to the server stub.
}

///////////////////////////////////////////////////////////
// End, Application                                                          //
//////////////////////////////////////////////////////////

//
// the following function outline the server side code for a simple async
// function using pipes.
//


////////////////////////////////////////////////////////////
// Begin, stubs for FooPipe                                                 //
////////////////////////////////////////////////////////////

typedef struct {
    RPC_ASYNC_STUB_STATE StubState ;
    RPC_ASYNC_STATE AsyncState ;
    void *state ;
    async_intpipe inpipe ;
    async_intpipe outpipe ;
    int checksum_out ;
    } FOOPIPE_ASYNC_SERVER_STATE;

#define ASYNC_CHUNK_SIZE 1000
#define ASYNC_NUM_CHUNKS 20



RPC_STATUS
PipeSendFunction (
    PRPC_ASYNC_STATE pAsync,
    void *context,
    int *buffer,
    int num_elements
    )
/*++

Routine Description:

 this function is always implemented by the stubs. This routine is called by
 the application, to send pipe data.

Arguments:

 pAsync - Async Handle. The async handle is always the first parameter of every
              async routine.

--*/
{
    unsigned int Flags = 0;
    RPC_STATUS RpcStatus ;
    RPC_MESSAGE Message ;
    FOOPIPE_ASYNC_SERVER_STATE *StubInfo =
        (FOOPIPE_ASYNC_SERVER_STATE *) pAsync->StubInfo ;
    int calculated_length = num_elements * sizeof(int) + sizeof(int) ;
    char *ptr ;

    Message.ProcNum = RPC_FLAGS_VALID_BIT ;
    Message.Handle = StubInfo->StubState.CallHandle ;

    if (StubInfo->StubState.State == SEND_INCOMPLETE)
        {
        calculated_length += StubInfo->StubState.BufferLength ;
        }

    if (StubInfo->StubState.Buffer == 0)
        {
        Message.RpcFlags = RPC_BUFFER_ASYNC | RPC_BUFFER_PARTIAL ;
        Message.BufferLength = calculated_length ;

        RpcStatus = I_RpcGetBuffer(&Message) ;
        if (RpcStatus != RPC_S_OK)
            {
            return RpcStatus;
            }
        }
    else
        {
        Message.RpcFlags = RPC_BUFFER_ASYNC ;
        Message.Buffer = StubInfo->StubState.Buffer ;
        Message.BufferLength = StubInfo->StubState.BufferLength;

        RpcStatus = I_RpcReallocPipeBuffer(&Message, calculated_length) ;
        if (RpcStatus != RPC_S_OK)
            {
            return RpcStatus;
            }
        }

    ptr = (char *) Message.Buffer ;

    if (StubInfo->StubState.State == SEND_INCOMPLETE)
        {
        ptr += StubInfo->StubState.BufferLength ;
        }

    *((int *) ptr) = num_elements ;
    RpcpMemoryCopy(ptr+sizeof(int), buffer, num_elements *sizeof(int)) ;

    Message.RpcFlags = RPC_BUFFER_PARTIAL | RPC_BUFFER_ASYNC;

    RpcStatus = I_RpcSend(&Message) ;
    if (RpcStatus == RPC_S_OK)
        {
        StubInfo->StubState.State = SEND_COMPLETE ;
        }
    else if (RpcStatus == RPC_S_SEND_INCOMPLETE)
        {
        StubInfo->StubState.State = SEND_INCOMPLETE ;
        }
    else
        {
        return RpcStatus;
        }

    StubInfo->StubState.Buffer = Message.Buffer ;
    StubInfo->StubState.BufferLength = Message.BufferLength ;

    return RPC_S_OK;
}


RPC_STATUS
PipeReceiveFunction (
    PRPC_ASYNC_STATE pAsync,
    int *buffer,
    int requested_count,
    int *actual_count
    )
/*++
Function Name:PipeReceiveFunction

Parameters:

Description:

Returns:

--*/
{
    int num_elements = 0;
    RPC_MESSAGE Callee ;
    FOOPIPE_ASYNC_SERVER_STATE *StubInfo =
        (FOOPIPE_ASYNC_SERVER_STATE *) pAsync->StubInfo ;
    PIPE_STATE *state = &(StubInfo->StubState.PipeState);
    DWORD size = (DWORD) requested_count * state->PipeElementSize ;

    *actual_count = 0 ;

    if (state->EndOfPipe)
        {
        return RPC_S_OK;
        }

    I_RpcReadPipeElementsFromBuffer(
                                    state,
                                    (char *) buffer,
                                    size,
                                    &num_elements) ;

    *actual_count += num_elements ;
    size -= num_elements * state->PipeElementSize ;

    if (state->EndOfPipe == 0 &&
        num_elements < requested_count)
        {
        Callee.ProcNum = RPC_FLAGS_VALID_BIT ;
        Callee.Handle = StubInfo->StubState.CallHandle ;

        Callee.RpcFlags = RPC_BUFFER_PARTIAL | RPC_BUFFER_ASYNC ;
        if (num_elements)
            {
            Callee.RpcFlags |= RPC_BUFFER_NONOTIFY;
            }

        Callee.Buffer = 0 ;
        Callee.BufferLength = 0 ;

        Status = I_RpcReceive(&Callee, size) ;
        if (Status)
            {
            ApiError("PipePull", "I_RpcReceive", Status) ;

            if (Status == RPC_S_ASYNC_CALL_PENDING)
                {
                if (num_elements)
                    {
                    Status = RPC_S_OK;
                    }
                }
            else
                {
                num_elements = 0 ;
                }

            return Status;
            }

        state->Buffer = Callee.Buffer ;
        state->BufferLength = Callee.BufferLength ;
        state->CurPointer = (char *) Callee.Buffer ;
        state->BytesRemaining = Callee.BufferLength ;

        buffer = (pipe_element_t *)
                    ((char *) buffer + num_elements * state->PipeElementSize) ;

        num_elements = 0 ;
        I_RpcReadPipeElementsFromBuffer(
                                        state,
                                        (char *) buffer,
                                        size,
                                        &num_elements) ;

        *actual_count += num_elements ;
        }

    return RPC_S_OK;
}



RPC_STATUS
FooPipeComplete (
    IN PRPC_ASYNC_STATE pAsync,
    IN void *Reply
    )
/*++

Routine Description:
    Stub for the completion routine of FooPipe.

Arguments:

 pAsync - async handle
--*/

{
    RPC_MESSAGE Message ;
    RPC_STATUS RpcStatus ;
    char *ptr ;
    int calculated_length = 8 ;
    FOOPIPE_ASYNC_SERVER_STATE *StubInfo =
        (FOOPIPE_ASYNC_SERVER_STATE *) pAsync->StubInfo ;

    TRACE(("FooPipeComplete called: %d\n", *((int *) Reply))) ;

    Message.ProcNum = RPC_FLAGS_VALID_BIT ;
    Message.Handle = StubInfo->StubState.CallHandle ;
    Message.Buffer = StubInfo->StubState.Buffer ;
    Message.BufferLength = StubInfo->StubState.BufferLength ;

    if (StubInfo->StubState.State == SEND_INCOMPLETE)
        {
        calculated_length += StubInfo->StubState.BufferLength ;
        }

    // if we had [out] pipes, I_RpcGetBuffer must have
    // been called
    Message.RpcFlags = RPC_BUFFER_ASYNC ;

    RpcStatus = I_RpcReallocPipeBuffer(&Message, calculated_length) ;
    if (RpcStatus != RPC_S_OK)
        {
        return RpcStatus ;
        }

    ptr = (char *) Message.Buffer ;

    if (StubInfo->StubState.State == SEND_INCOMPLETE)
        {
        ptr += StubInfo->StubState.BufferLength ;
        }

    *((int *) ptr) = *((int *) Reply);
    *(((int *) ptr)+1) = StubInfo->checksum_out ;

    // send the async reply
    Message.RpcFlags = RPC_BUFFER_ASYNC;
    RpcStatus = I_RpcSend(&Message) ;
    if (RpcStatus)
        {
        return RpcStatus ;
        }

    I_RpcFree(StubInfo) ;

    return RPC_S_OK ;
}

int tempint ;


void
FooPipe_s (
    PRPC_MESSAGE Message
    )
/*++

Routine Description:

    server stub for the FooPipe function.

--*/

{
    int checksum_in;
    FOOPIPE_ASYNC_SERVER_STATE *StubInfo ;
    RPC_STATUS RpcStatus ;
    unsigned long non_pipe_size = sizeof(int) ;

    if (Message->BufferLength < non_pipe_size)
        {
        Message->RpcFlags = RPC_BUFFER_PARTIAL
                                        | RPC_BUFFER_EXTRA;

              RpcStatus = I_RpcReceive(
                                 Message,
                                 non_pipe_size - Message->BufferLength) ;
        if (RpcStatus)
            {
            RpcRaiseException(RpcStatus) ;
            }
        }

    //
    // allocate a handle on the heap, initialize it
    // and register it with the RPC runtime.
    //

    StubInfo = (FOOPIPE_ASYNC_SERVER_STATE *)
                I_RpcAllocate(sizeof(FOOPIPE_ASYNC_SERVER_STATE)) ;

    StubInfo->AsyncState.Size = sizeof(RPC_ASYNC_STATE) ;
    StubInfo->AsyncState.Flags = 0;
    StubInfo->AsyncState.StubInfo = (void *) StubInfo ;
    StubInfo->AsyncState.NotificationType = RpcNotificationTypeNone;

    StubInfo->StubState.Length = sizeof(FOOPIPE_ASYNC_SERVER_STATE) ;
    StubInfo->StubState.CallHandle = Message->Handle ;

    StubInfo->StubState.PipeState.Buffer = 0;
    StubInfo->StubState.PipeState.CurrentState = start;
    StubInfo->StubState.PipeState.EndOfPipe = 0;
    StubInfo->StubState.PipeState.PipeElementSize = sizeof(int);
    StubInfo->StubState.PipeState.PartialPipeElement = &tempint;
    StubInfo->StubState.PipeState.PreviousBuffer = 0;
    StubInfo->StubState.Buffer = 0;

    if (Message->BufferLength > non_pipe_size)
        {
        StubInfo->StubState.PipeState.CurPointer = (char *) Message->Buffer + sizeof(int);
        StubInfo->StubState.PipeState.BytesRemaining =
                    Message->BufferLength - non_pipe_size;
        }
    else
        {
        StubInfo->StubState.PipeState.CurPointer = 0;
        StubInfo->StubState.PipeState.BytesRemaining = 0;
        }

    RpcStatus = I_RpcAsyncSetHandle(
                            Message,
                            (PRPC_ASYNC_STATE) &(StubInfo->AsyncState)) ;
    if (RpcStatus != RPC_S_OK)
        {
        RpcRaiseException(RpcStatus) ;
        }

    // unmarshall the received data
    checksum_in = *((int *) Message->Buffer) ;

    StubInfo->StubState.CompletionRoutine = FooPipeComplete ;
    StubInfo->inpipe.PipeReceive = PipeReceiveFunction;
    StubInfo->outpipe.PipeSend = PipeSendFunction ;

    FooPipe ((PRPC_ASYNC_STATE) &(StubInfo->AsyncState),
                Message->Handle,
                checksum_in,
                &(StubInfo->inpipe),
                &(StubInfo->outpipe),
                &(StubInfo->checksum_out)) ;
}

////////////////////////////////////////////////////////////
// End, stubs for FooPipe                                                   //
////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////
// Begin, Application                                                       //
//////////////////////////////////////////////////////////

typedef struct {
    PRPC_ASYNC_STATE pAsync ;
    int checksum_in ;
    async_intpipe *inpipe ;
    async_intpipe *outpipe ;
    int *checksum_out ;
    int i ;
    int PipeChecksum ;
    int ExpectedValue;
    int PipeBuffer[ASYNC_CHUNK_SIZE] ;
    } PIPE_CALL_COOKIE ;


int PipeCount = 0;

void
FooPipeAPCRoutine (
    IN PRPC_ASYNC_STATE pAsync,
    IN void *Context,
    IN RPC_ASYNC_EVENT Event
    )
/*++

Routine Description:

 description

Arguments:


--*/

{
    RPC_STATUS Status;
    PIPE_CALL_COOKIE *Cookie = (PIPE_CALL_COOKIE *) pAsync->UserInfo ;

    switch (Event)
        {
        case RpcSendComplete:
            if (Cookie->i <ASYNC_NUM_CHUNKS)
                {
                Cookie->i++ ;
                Status = Cookie->outpipe->PipeSend(
                             pAsync,
                             0,
                             (int *) Cookie->PipeBuffer,
                             ASYNC_CHUNK_SIZE) ;
                }
            else
                {
                ASSERT(Cookie->i == ASYNC_NUM_CHUNKS);

                Cookie->i++ ;
                pAsync->Flags = 0;
                Status = Cookie->outpipe->PipeSend(
                            pAsync,
                            0, 0, 0) ;
                }

            if (Status != RPC_S_OK)
                {
                PrintToConsole("PipeSend failed\n");
                }
            break;

        case RpcCallComplete:
#if DBG
            PrintToConsole("usvr: call complete APC !!\n");
#endif
            break;
        }
}


void
ThreadProcPipes(
    IN PIPE_CALL_COOKIE  *Cookie
    )
/*++

Routine Description:

    The thread that calls FooPipe_complete. FooPipe_complete is being called
    in a separate thread to show that it infact can be.

Arguments:
    pAsync - the async handle on which Foo_complete needs to be called.

--*/

{
    int *ptr ;
    int  i ;
    int retval ;
    int Checksum = 0;
    RPC_STATUS Status ;
    int num_elements;
    BOOL fDone = 0;

    RpcTryExcept
        {
        TRACE(("FooPipe: sending pipe data\n")) ;

        while (!fDone)
            {
            Status = Cookie->inpipe->PipeReceive(
                                                  Cookie->pAsync,
                                                  (int *) Cookie->PipeBuffer,
                                                  ASYNC_CHUNK_SIZE,
                                                  &num_elements);

            switch (Status)
                {
                case RPC_S_ASYNC_CALL_PENDING:
                    if (SleepEx(INFINITE, TRUE) != WAIT_IO_COMPLETION)
                        {
                        RpcRaiseException(APP_ERROR) ;
                        }
                    break;

                case RPC_S_OK:
                    if (num_elements == 0)
                        {
                        fDone = 1;
                        }
                    else
                        {
                        for (i = 0; i <num_elements; i++)
                            {
                            if (Cookie->PipeBuffer[i] != Cookie->ExpectedValue)
                                {
                                printf("pipe recv fn: elt %d contains %lx, expected %lx\n",
                                       i, Cookie->PipeBuffer[i], Cookie->ExpectedValue);
                                DebugBreak();
                                }

                            Cookie->ExpectedValue =
                                (Cookie->PipeBuffer[i]+1) % ASYNC_CHUNK_SIZE;
                            Cookie->PipeChecksum += Cookie->PipeBuffer[i] ;
                            }
                        }
                    break;

                default:
                    fDone = 1;
                    break;
                }

            //
            // This code is for testing flow control
            //
            PipeCount++;
            if ((PipeCount % 3) == 0)
                {
                Sleep(100);
                }
            }

        if (Status != RPC_S_OK)
            {
            RpcRaiseException(Status);
            }

        TRACE(("FooPipe: sending pipe data\n")) ;

        ptr = (int *) Cookie->PipeBuffer ;
        for (i = 0; i <ASYNC_CHUNK_SIZE; i++)
            {
            *ptr++ = i;
            Checksum += i ;
            }

        TRACE(("FooPipe: [out] Block checksum: %d\n", Checksum)) ;
        Checksum *= ASYNC_NUM_CHUNKS ;

        TRACE(("FooPipe: [out] Total checksum: %d\n", Checksum)) ;


        Cookie->i = 1;

        Status = Cookie->outpipe->PipeSend(
                     Cookie->pAsync,
                     0,
                     Cookie->PipeBuffer,
                     ASYNC_CHUNK_SIZE) ;

        if (Status != RPC_S_OK)
            {
            RpcRaiseException(Status);
            }

        while (Cookie->i < ASYNC_NUM_CHUNKS+1)
            {
            if (SleepEx(INFINITE, TRUE) != WAIT_IO_COMPLETION)
                {
                RpcRaiseException(APP_ERROR) ;
                }
            }

        TRACE(("FooPipe: sending non pipe reply\n")) ;

        *(Cookie->checksum_out) = Checksum ;

        if (Cookie->checksum_in != Cookie->PipeChecksum)
            {
            PrintToConsole("FooPipe: Checksum Error, expected: %d, checksum: %d\n",
                    Cookie->checksum_in, Cookie->PipeChecksum) ;
            IsabelleError() ;
            retval = 0;
            }
        else
            {
            retval = 1;
            }

        Status = MyRpcCompleteAsyncCall(Cookie->pAsync, &retval) ;
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        IsabelleError() ;
        MyRpcCompleteAsyncCall(Cookie->pAsync, &retval) ;

        PrintToConsole("FooPipe: Exception : 0x%lX\n", GetExceptionCode()) ;
        }
    RpcEndExcept

    Sleep(100);
}


void
FooPipe (
    IN PRPC_ASYNC_STATE pAsync,
    IN RPC_BINDING_HANDLE hBinding,
    IN int checksum_in,
    IN async_intpipe *inpipe,
    OUT async_intpipe *outpipe,
    OUT int *checksum_out
    )
/*++

Routine Description:

    The manager routine that implements FooPipe. It sets up the receive
    and alloc function pointer for each of the pipes on which data is to
    be received, and call RpcRegisterAsycnHandle on the async handle.
    It then spawns off an async operation (creates a thread in this case),
    to process the async call.
Arguments:

 pAsync - Async Handle. The async handle is always the first parameter of every
              async routine.
--*/

{
    unsigned long ThreadIdentifier;
    HANDLE HandleToThread ;
    RPC_STATUS RpcStatus ;
    PIPE_CALL_COOKIE *PipeCallCookie ;

    PipeCallCookie = new PIPE_CALL_COOKIE ;
    if (PipeCallCookie == 0)
        {
        RpcRaiseException(APP_ERROR) ;
        }

    PipeCallCookie->pAsync = pAsync ;
    PipeCallCookie->inpipe = inpipe ;
    PipeCallCookie->outpipe = outpipe ;
    PipeCallCookie->checksum_in = checksum_in ;
    PipeCallCookie->checksum_out = checksum_out ;
    PipeCallCookie->PipeChecksum = 0;
    PipeCallCookie->ExpectedValue = 0;

    HandleToThread = CreateThread(0,
                                    DefaultThreadStackSize,
                                    (LPTHREAD_START_ROUTINE) ThreadProcPipes,
                                    PipeCallCookie,
                                    0,
                                    &ThreadIdentifier);

    if (HandleToThread == 0)
        {
        PrintToConsole("FooPipe: Can't create thread\n") ;
        RpcRaiseException(RPC_S_OUT_OF_MEMORY) ;
        }

    pAsync->Flags = RPC_C_NOTIFY_ON_SEND_COMPLETE ;
    pAsync->UserInfo = (void *) PipeCallCookie ;
    pAsync->NotificationType = RpcNotificationTypeApc ;
    pAsync->u.APC.NotificationRoutine = FooPipeAPCRoutine ;
    pAsync->u.APC.hThread = HandleToThread ;

    RpcStatus = RpcAsyncRegisterInfo(pAsync) ;
    if (RpcStatus != RPC_S_OK)
        {
        RpcRaiseException(RpcStatus) ;
        }
}

///////////////////
// misc stuff       ///
///////////////////

int
FooBar (
    IN RPC_BINDING_HANDLE hBinding,
    IN int sizein,
    IN int *bufferin,
    IN OUT int *sizeout,
    OUT int **bufferout
    )
{
    UUID ObjectUuid;

    Status = RpcBindingInqObject(hBinding, &ObjectUuid);
    if (Status)
        {
        PrintToConsole("FooBar: can't inq object uuid, error = %d\n", Status);
        RpcRaiseException(Status);
        }

    if (CheckUuidValue(UUID_SYNC_EXCEPTION, &ObjectUuid) == 0)
        {
        RpcRaiseException(SYNC_EXCEPT) ;
        }

    *bufferout = (int *) I_RpcAllocate(*sizeout) ;
    if (*bufferout == 0)
        {
        RpcRaiseException(APP_ERROR) ;
        }

    return 1;
}


void
FooBar_s (
    PRPC_MESSAGE Message
    )
/*++

Routine Description:

 Generated stub for FooBar.

--*/

{
    int *bufferin ;
    int *bufferout ;
    int sizein, sizeout ;
    int *Ptr ;
    int retval ;
    RPC_STATUS RpcStatus ;

    if ((Message->RpcFlags & RPC_BUFFER_COMPLETE) == 0)
        {
        Message->RpcFlags = RPC_BUFFER_EXTRA;
        RpcStatus = I_RpcReceive (Message, 0) ;
        if (RpcStatus)
            {
            RpcRaiseException(RpcStatus) ;
            }
        }

    // unmarshall the received data
    Ptr = (int *) Message->Buffer ;
    sizein = *Ptr++ ;
    bufferin = Ptr ;

    Ptr += (sizein+3)/sizeof(int) ;

    sizeout = *Ptr ;

    retval = FooBar (Message->Handle, sizein, bufferin, &sizeout, &bufferout) ;

    Message->BufferLength = sizeout+8;

    RpcStatus = I_RpcGetBuffer(Message) ;
    if (RpcStatus != RPC_S_OK)
        {
        RpcRaiseException(RpcStatus) ;
        }

    Ptr = (int *) Message->Buffer ;
    *Ptr++ = retval ;
    *Ptr++ = sizeout ;
    RpcpMemoryCopy(Ptr, bufferout, sizeout) ;

    I_RpcFree(bufferout) ;
}

////////////////////////////////////////////////////////////
// Begin, stubs for FooCH                                                      //
////////////////////////////////////////////////////////////
void
FooCH (
    IN PRPC_ASYNC_STATE pAsync,
    IN RPC_BINDING_HANDLE hBinding,
    IN int sizein,
    IN int *bufferin,
    IN OUT int *sizeout,
    OUT int **bufferout
    ) ;

typedef struct {
    RPC_ASYNC_STUB_STATE StubState ;
    RPC_ASYNC_STATE AsyncState ;
    void *state ;
    int sizeout ;
    int *bufferout ;
    } FOOCH_ASYNC_SERVER_STATE;


RPC_STATUS
FooCHComplete (
    IN PRPC_ASYNC_STATE pAsync,
    IN void *Reply
    )
/*++

Routine Description:
    This is a generated stub. It is the completion routine for the function
    FooCH. When the server app is done with processing a particular call to
    FooCH, It calls FooCH_complete to complete the call.

Arguments:

 pAsync - The async handle. This handle is always the first parameter of every
    FooCH_complete routine.
--*/

{
    int *Ptr ;
    RPC_MESSAGE Message ;
    RPC_STATUS RpcStatus ;
    FOOCH_ASYNC_SERVER_STATE *StubInfo =
            (FOOCH_ASYNC_SERVER_STATE *) pAsync->StubInfo ;

    TRACE(("FooCHComplete called: %d\n", *((int *) Reply))) ;

    Message.ProcNum = RPC_FLAGS_VALID_BIT ;
    Message.RpcFlags = RPC_BUFFER_ASYNC;
    Message.BufferLength = 8 + StubInfo->sizeout  ;
    Message.Handle = StubInfo->StubState.CallHandle ;

    RpcStatus = I_RpcGetBuffer(&Message) ;
    if (RpcStatus)
        {
        return RpcStatus ;
        }

    Ptr = (int *) Message.Buffer ;
    *Ptr++ = *((int *) Reply) ;
    *Ptr++ = StubInfo->sizeout ;
    RpcpMemoryCopy(Ptr, StubInfo->bufferout, StubInfo->sizeout) ;

    I_RpcFree(StubInfo->bufferout) ;

    // send the async reply
    Message.RpcFlags = RPC_BUFFER_ASYNC;
    RpcStatus = I_RpcSend(&Message) ;
    if (RpcStatus)
        {
        return RpcStatus ;
        }

    I_RpcFree(pAsync->StubInfo) ;

    return RPC_S_OK ;
}


void
FooCH_s (
    PRPC_MESSAGE Message
    )
/*++

Routine Description:

 Generated stub for FooCH.

--*/

{
    int sizein ;
    int *bufferin ;
    int *Ptr ;
    FOOCH_ASYNC_SERVER_STATE *StubInfo;
    RPC_STATUS RpcStatus ;
    NDR_SCONTEXT Context ;

    if ((Message->RpcFlags & RPC_BUFFER_COMPLETE) == 0)
        {
        Message->RpcFlags = RPC_BUFFER_EXTRA;
        RpcStatus = I_RpcReceive (Message, 0) ;
        if (RpcStatus)
            {
            RpcRaiseException(RpcStatus) ;
            }
        }

    // allocate a handle and tell the runtime about it
    StubInfo = (FOOCH_ASYNC_SERVER_STATE *)
                   I_RpcAllocate(sizeof(FOOCH_ASYNC_SERVER_STATE)) ;

    if (StubInfo == 0)
        {
        RpcRaiseException(RPC_S_OUT_OF_MEMORY) ;
        }

    StubInfo->AsyncState.Size = sizeof(RPC_ASYNC_STATE) ;
    StubInfo->AsyncState.StubInfo = (void *) StubInfo ;
    StubInfo->AsyncState.Flags = 0;
    StubInfo->AsyncState.NotificationType = RpcNotificationTypeNone;

    StubInfo->StubState.CompletionRoutine = FooCHComplete ;
    StubInfo->StubState.CallHandle = Message->Handle ;
    StubInfo->StubState.Flags = 0;

    RpcStatus = I_RpcAsyncSetHandle(
                            Message,
                            (PRPC_ASYNC_STATE) &(StubInfo->AsyncState)) ;

    if (RpcStatus != RPC_S_OK)
        {
        RpcRaiseException(RpcStatus) ;
        }


    // unmarshall the received data
    Ptr = (int *) Message->Buffer ;
    Context = NDRSContextUnmarshallEx (
                  Message->Handle,
                  0,
                  Message->DataRepresentation );
    if (Context == 0)
        {
        RpcRaiseException(RPC_X_SS_CONTEXT_MISMATCH) ;
        }

    Ptr += 20/sizeof(int) ;

    sizein = *Ptr++ ;
    bufferin = Ptr ;

    Ptr += (sizein+3)/sizeof(int) ;
    StubInfo->sizeout = *Ptr ;

    {
    RPC_STATUS Status = 0;
    UUID ObjectUuid;

    Status = RpcBindingInqObject(Message->Handle, &ObjectUuid);
    if (Status)
        {
        PrintToConsole("FooBar: can't inq object uuid, error = %d\n", Status);
        RpcRaiseException(Status);
        }

    if (CheckUuidValue(UUID_SYNC_EXCEPTION, &ObjectUuid) == 0)
        {
        RpcRaiseException(SYNC_EXCEPT) ;
        }

    if (CheckUuidValue(UUID_ASYNC_EXCEPTION, &ObjectUuid) == 0)
        {
        StubInfo->sizeout = SIZEOUT_ASYNC_EXCEPTION;
        }
    }

    FooCH ((PRPC_ASYNC_STATE) &(StubInfo->AsyncState),
            (void PAPI *) *NDRSContextValue(Context),
            sizein,
            bufferin,
            &(StubInfo->sizeout),
            &(StubInfo->bufferout)) ;

}

////////////////////////////////////////////////////////////
// End, stubs for FooCH                                                         //
////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////
// Begin, Application                                                       //
//////////////////////////////////////////////////////////

typedef struct {
    PRPC_ASYNC_STATE pAsync ;
    int *sizeout ;
    int **bufferout ;
    BOOL fException;
    } FOOCH_CALL_COOKIE ;


void
FooCHThreadProc(
    FOOCH_CALL_COOKIE *Cookie
    )
/*++

Routine Description:

    The thread that calls FooCH_complete. FooCH_complete is being called
    in a separate thread to show that it infact can be.

Arguments:
    pAsync - the async handle on which FooCH_complete needs to be called.

--*/

{
    int retval = 1;

    TRACE(("FOOCH: Sending back aync reply\n")) ;

    if (Cookie->fException)
        {
        MyRpcAbortAsyncCall(Cookie->pAsync, ASYNC_EXCEPT) ;
        return ;
        }

    *(Cookie->bufferout) = (int *) I_RpcAllocate(*(Cookie->sizeout)) ;
    if (*(Cookie->bufferout) == 0)
        {
        MyRpcAbortAsyncCall(Cookie->pAsync, RPC_S_OUT_OF_MEMORY) ;
        IsabelleError() ;
        return ;
        }

    Status = MyRpcCompleteAsyncCall(Cookie->pAsync, &retval) ;
    if (Status != RPC_S_OK)
        {
        IsabelleError() ;
        }
}


void
FooCH (
    IN PRPC_ASYNC_STATE pAsync,
    IN void PAPI *ContextHandle,
    IN int sizein,
    IN int *bufferin,
    IN OUT int *sizeout,
    OUT int **bufferout
    )
/*++

Routine Description:

    This is a actual manager routine. It can spawn off an async operation
    (a thread in this case) to do the rest of the work, and send back the
    reply when it is done.

Arguments:
    pAsync - Async handle. This is always the first parameter of every async
    handle.
--*/

{
  unsigned long ThreadIdentifier;
  HANDLE HandleToThread ;
  FOOCH_CALL_COOKIE *CallCookie ;

  CallCookie = new FOOCH_CALL_COOKIE ;
  if (CallCookie == 0)
      {
      RpcRaiseException(APP_ERROR) ;
      }

  CallCookie->pAsync = pAsync ;
  CallCookie->sizeout = sizeout ;
  CallCookie->bufferout = bufferout ;
  CallCookie->fException = FALSE;

  if (*sizeout == SIZEOUT_ASYNC_EXCEPTION)
      {
      CallCookie->fException = TRUE;
      }

  HandleToThread = CreateThread(
                                0,
                                DefaultThreadStackSize,
                                (LPTHREAD_START_ROUTINE) FooCHThreadProc,
                                CallCookie,
                                0,
                                &ThreadIdentifier);

  if (HandleToThread == 0)
      {
      PrintToConsole("FooCH: Error, could not create thread\n") ;
      return ;
      }

  // return to the server stub.
}

///////////////////////////////////////////////////////////
// End, Application                                                          //
//////////////////////////////////////////////////////////


void
Async (
    )
/*++
Routine Description:
     Register the interfaces and start listening

--*/
{
    PrintToConsole("Async : Test Async RPC\n");

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &SylviaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError("Async","stub_RegisterIf",Status);
        PrintToConsole("Async : FAIL - Unable to Register Interface ");
        PrintToConsole("(Sylvia)\n");
        return;
        }

    //
    // synchronous listen blocks inside GenericServerListen
    //
    Status = GenericServerListen( "Async", BARTHOLOMEW );
    if (Status)
        {
        return;
        }

    Status = GenericServerUnlisten( "Async" );
    if (Status)
        {
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &SylviaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Async","RpcServerUnregisterIf",Status);
        PrintToConsole("Async : FAIL - Unable to Unregister ");
        PrintToConsole("Interface (Sylvia)\n");
        return;
        }

    PrintToConsole("Async : PASS\n");
}



void
SendAck (
    )
/*++
Routine Description:
     Register the interfaces and start listening

--*/
        {
    PrintToConsole("SendAck : Test datagram delayed ACK\n");

    Status = GenericServerListen( "SendAck", BARTHOLOMEW );
        if (Status)
            {
        return;
        }

    Status = GenericServerUnlisten( "SendAck" );
    if (Status)
        {
            return;
            }
        }


void
DgTransport (
    )
/*++
Routine Description:
     Register the interfaces and start listening

--*/
{
    PrintToConsole("DgTransport : Test datagram transport\n");

    Status = GenericServerListen( "DgTransport", BARTHOLOMEW );
    if (Status)
        {
        return;
        }

    Status = GenericServerUnlisten( "DgTransport" );
    if (Status)
        {
        return;
        }
        }

PVOID LastConnectionCreated = 0;

PVOID MySecurityContext = 0;

DWORD ChosenErrorCode = 0;

void
ShutdownHookFn(
    DWORD id,
    PVOID subject,
    PVOID object
    )
{
    switch (id)
        {
        case TH_RPC_LOG_EVENT:
            {
            RPC_EVENT * event = (RPC_EVENT *) subject;

//            TRACE(("  hook: %c %c %p %p\n", event->Subject, event->Verb, event->SubjectPointer, event->ObjectPointer));

            //
            // Record sconnection creation.
            //
            if (event->Subject == SU_SCONN &&
                event->Verb    == EV_CREATE)
                {
                TRACE(("  hook: created connection %p\n", event->SubjectPointer));
                LastConnectionCreated = event->SubjectPointer;
                }

            break;
            }

        case TH_RPC_SECURITY_SERVER_CONTEXT_CREATED:
            {
            if (object == LastConnectionCreated)
                {
                TRACE(("  hook: connection %p created security context %p\n", LastConnectionCreated, subject));
                MySecurityContext = subject;
                }

            break;
            }

        default:
            {
            break;
            }
        }
}

void
SecurityContextHook(
    DWORD id,
    PVOID subject,
    PVOID object
    )
{
    if (subject == MySecurityContext)
        {
        TRACE(("  hook executed: context %p, hook ID %x, error code is 0x%x\n", subject, id, ChosenErrorCode));

        DWORD * pStatus = (DWORD *) object;

        *pStatus = ChosenErrorCode;
        }
    else
        {
        TRACE(("  hook: ignoring notification, my cxt = %p, context %p, hook ID %x, error code is 0x%x\n",
               MySecurityContext, subject, id, ChosenErrorCode));
        }
}

void
TestSecurityError (
    RPC_TEST_HOOK_ID id,
    DWORD error
    );

void
SecurityErrorWrapper(
    int subtest
    )
{
    //
    // Set up the test hook.
    //
    {
    HMODULE hRpc = GetModuleHandle(L"RPCRT4.DLL");

    if (!hRpc)
        {
        ApiError("","GetModuleHandle",GetLastError());
        return;
        }

    SetTestHookFn = (SET_TEST_HOOK_FN) GetProcAddress( hRpc, "I_RpcSetTestHook" );

    if (!SetTestHookFn)
        {
        ApiError("", "GetProcAddress: I_RpcSetTestHook", GetLastError());
        }
    }

    switch (subtest)
        {
        default:
            {
            PrintToConsole("unknown security-error case!\n");

            // no break here

            }
        case 100:
            {
            //
            // wants a list
            //
            PrintToConsole("cases:\n"
                           "\n"
                           "    1 - AcceptFirstTime returns SEC_E_SHUTDOWN_IN_PROGRESS\n"
                           "    2 - AcceptThirdLeg  returns SEC_E_SHUTDOWN_IN_PROGRESS\n"
                           );
            return;
            }

        case 0:
            {
            PrintToConsole("running all sub tests\n");
            }

        case 1:
            {
            PrintToConsole("subtest 1: AcceptFirstTime returns SEC_E_SHUTDOWN_IN_PROGRESS\n");

            TestSecurityError( TH_SECURITY_FN_ACCEPT1, SEC_E_SHUTDOWN_IN_PROGRESS );

            if (subtest)
                {
                break;
                }
            }

        case 2:
            {
            PrintToConsole("subtest 1: AcceptThirdLeg returns SEC_E_SHUTDOWN_IN_PROGRESS\n");

            TestSecurityError( TH_SECURITY_FN_ACCEPT3, SEC_E_SHUTDOWN_IN_PROGRESS );

            if (subtest)
                {
                break;
                }
            }
        }
}


void
TestSecurityError (
    RPC_TEST_HOOK_ID id,
    DWORD error
    )
/*++
Routine Description:
     Register the interfaces and start listening

--*/
{

    //
    // Set test hooks.
    //
    (*SetTestHookFn)( TH_RPC_LOG_EVENT, ShutdownHookFn );
    (*SetTestHookFn)( TH_RPC_SECURITY_SERVER_CONTEXT_CREATED, ShutdownHookFn );

    ChosenErrorCode = error;

    (*SetTestHookFn)( id, SecurityContextHook );

    //
    // Wait for the client to make the call.
    //
    Status = GenericServerListen( "SecurityShutdown", SECURITY_ERROR );
    if (Status)
        {
        return;
        }

    //
    // Remove test hooks.
    //
    (*SetTestHookFn)( TH_RPC_LOG_EVENT, 0 );
    (*SetTestHookFn)( TH_RPC_SECURITY_SERVER_CONTEXT_CREATED, 0 );

    (*SetTestHookFn)( id, 0 );

    //
    // Clean up.
    //
    Status = GenericServerUnlisten( "SecurityShutdown" );
    if (Status)
        {
        return;
        }
}


DWORD
GenericServerUnlisten(
    char * name
    )
{
    // Synchro support
    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError(name,"RpcServerUnregisterIf",Status);
        PrintToConsole("%s : FAIL - Unable to Unregister ", name);
        PrintToConsole("Interface (Helga)\n");
        return Status;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("%s : FAIL - Error(s) in Isabelle", name);
        PrintToConsole(" Interface\n");
        IsabelleErrors = 0;
        return Status;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError(name,"RpcServerUnregisterIf",Status);
        PrintToConsole("%s : FAIL - Unable to Unregister ", name);
        PrintToConsole("Interface (Isabelle)\n");
        return Status;
        }

    if (SylviaErrors != 0)
        {
        PrintToConsole("%s : FAIL - Error(s) in Sylvia", name);
        PrintToConsole(" Interface\n");
        HelgaErrors = 0;
        return Status;
        }

    return 0;
}


DWORD
GenericServerListen(
    char * name,
    int endpoint
    )
{
    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(endpoint), 0);
    if (Status)
        {
        ApiError(name, "RpcServerUseProtseqEpWrapper", Status);
        PrintToConsole("%s : FAIL - Unable to Use Protseq endpoint \n", name);
        return Status;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError(name,"stub_RegisterIf",Status);
        PrintToConsole("%s : FAIL - Unable to Register Interface ", name);
        PrintToConsole("(Isabelle)\n");
        return Status;
        }

    // Synchro support
    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0, 0);
    if (Status)
        {
        ApiError(name,"stub_RegisterIf",Status);
        PrintToConsole("%s : FAIL - Unable to Register Interface ", name);
        PrintToConsole("(Helga)\n");
        return Status;
        }

    if (!NoSecurityTests)
        {
        Status = RpcServerRegisterAuthInfoA((unsigned char PAPI *) "ServerPrincipal", 10, 0, 0);
        if (Status)
            {
            ApiError(name, "RpcServerRegisterAuthInfo", Status);
            PrintToConsole("%s : FAIL - Unable to Register AuthInfo\n", name);
            return Status;
            }
        }

    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError(name,"stub_ServerListen",Status);
        PrintToConsole("%s : FAIL - stub_ServerListen Failed\n", name);
        return Status;
        }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\uclnt.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 2000


Module Name:

    uclnt.cxx

Abstract:

    This module is half of the build verification for the RPC runtime;
    the other half can be found in the file usvr.cxx.  These two
    executables (uclnt.exe and usvr.exe) work together to test all
    runtime APIs.

Author:

    Michael Montague (mikemon) 01-Jan-1990

Revision History:

--*/

#include <precomp.hxx>
#include <osfpcket.hxx>
#include <ntsecapi.h>
#include <lm.h>

#include "pipe.h"
#include "astub.h"

#define UCLNT

#define swaplong(Value)

#define swapshort(Value)

#define EXPORT

#include <sysinc.h>

#include <rpc.h>
#include <rpcdcep.h>

#include <rpcndr.h>

BOOL  IsWMSG = FALSE ;

extern RPC_CLIENT_INTERFACE HelgaInterfaceInformation ;


/*
Transports:

    Update this to add a new transport.
*/

#define RPC_TRANSPORT_NAMEPIPE  1
#define RPC_LRPC                2
#define RPC_TRANSPORT_TCP       3
#define RPC_TRANSPORT_DNET      4
#define RPC_TRANSPORT_NETBIOS   5
#define RPC_TRANSPORT_SPX       6
#define RPC_TRANSPORT_UDP       7
#define RPC_TRANSPORT_IPX       8
#define RPC_TRANSPORT_DSP       9
#define RPC_TRANSPORT_VNS       10
#define RPC_WMSG                11
#define RPC_TRANSPORT_MSMQ      12

//
// constants
//

#define RETRYCOUNT 10
#define RETRYDELAY 500L

#define LONG_TESTDELAY 10000L

#define EXTENDED_ERROR_EXCEPTION 77777

//
// global variables
//

long TestDelay = 3000L;
int  NumberOfTestsRun = 0;
static unsigned long DefaultThreadStackSize = 0;
BOOL fNonCausal = 0;

unsigned long HelgaMaxSize = 0xffffffff;

unsigned int NoCallBacksFlag = 0;
unsigned int UseEndpointMapperFlag = 0;
unsigned int MaybeTests      = 0;
unsigned int IdempotentTests = 0;
unsigned int BroadcastTests  = 0;
unsigned int NoSecurityTests = 0;
unsigned int HackForOldStubs = 0;
unsigned int DatagramTests   = 0;
unsigned int fUniqueBinding  = 0;

int Subtest = 0;
int Verbose = 0;
int IFSecurityFlag = 0;

int AutoListenFlag = 1;

char *SecurityUser     = NULL;
char *SecurityDomain   = NULL;
char *SecurityPassword = NULL;
char *gPrincName = NULL;

unsigned long ulSecurityPackage = 10 ;
unsigned long TransportType;
unsigned int WarnFlag = 0; // Flag for warning messages.
unsigned int ErrorFlag = 1; // Flag for error messages.

char NetBiosProtocol[20] = "ncacn_nb_nb";  // NetBios transport protocol

char * Server ;

RPC_STATUS Status; // Contains the status of the last RPC API call.

/* volatile */ int fShutdown; // Flag indicating that shutdown should occur.

#define CHUNK_SIZE   50
#define NUM_CHUNKS 100
#define BUFF_SIZE 100

// if you change the type of the pipe element
// make sure you change the pull and push routines
// to correctly initialize the pipe element
typedef int pipe_element_t ;

typedef struct {
    void (PAPI *Pull) (
        char PAPI *state,
        pipe_element_t PAPI *buffer,
        int max_buf,
        int PAPI *size_to_send
        ) ;

    void (PAPI *Push) (
        char PAPI *state,
        pipe_element_t PAPI *input_buffer,
        int ecount
        ) ;

    void (PAPI *Alloc) (
        char PAPI *state,
        int requested_size,
        pipe_element_t PAPI * PAPI *allocate_buf,
        int PAPI *allocated_size
        ) ;

    char PAPI *state ;
    } pipe_t ;


static CRITICAL_SECTION TestMutex;

//
// forward declarations
//

void
DgTransport (
    int testnum
    );

void
SecurityErrorWrapper(
    int subtest
    );

DWORD
DumpEeInfo(
    int indentlevel
    );

DWORD
HelgaSendReceiveFailure (
    RPC_BINDING_HANDLE Binding, // Specifies the binding to use in making the
                       // remote procedure call.
    int ProcNum
    );

int
FooSync (
    RPC_BINDING_HANDLE hBinding,
    /* [in] */ int sizein,
    /* [in] */ int *bufferin,
    /* [in, out] */ int *sizeout,
    /* [out] */ int **bufferout
    );

//
// function definitions
//

void
TestMutexRequest (
    void
    )
{
    EnterCriticalSection(&TestMutex);
}

void
TestMutexClear (
    void
    )
{
    LeaveCriticalSection(&TestMutex);
}

void
ApiError ( // An API error occured; we just print a message.
    IN char * Routine, // The routine which called the API.
    IN char * API,
    IN RPC_STATUS status
    )
{
    if (ErrorFlag)
        {
        TestMutexRequest();
        PrintToConsole("    ApiError in %s (%s = %u)\n",Routine,API,status);
        TestMutexClear();
        }

   // _asm {int 3} ;
}

void
PauseExecution (
    unsigned long milliseconds
    )
{
    Sleep(milliseconds);
}

void
OtherError ( // Some other error occured; again, we just print a message.
    IN char * Routine, // The routine where the error occured.
    IN char * Message
    )
{
    if (ErrorFlag)
        {
        TestMutexRequest();
        PrintToConsole("    Error in %s (%s)\n",Routine,Message);
        TestMutexClear();
        }
}

unsigned int IsabelleErrors = 0;
unsigned int HelgaErrors = 0;
unsigned int SylviaErrors = 0;

void IsabelleError (
    )
{
    IsabelleErrors += 1 ;
}

void HelgaError (
    )
{
    HelgaErrors += 1 ;
}

void SylviaError (
    )
{
    SylviaErrors += 1 ;
}

#define SIGFRIED 0
#define ELLIOTMINIMIZE 1
#define ELLIOTMAXIMIZE 2
#define ELLIOTNORMAL 3
#define ANDROMIDA 4
#define FREDRICK 7
#define ISABELLENORMAL 10
#define ISABELLEMINIMIZE 11
#define ISABELLEMAXIMIZE 12
#define CHRISTOPHER 13
#define CHRISTOPHERHELGA 14
#define CHRISTOPHERISABELLE 15
#define TYLER 17
#define RICHARD 18
#define RICHARDHELPER 19
#define NOENDPOINT 20
#define DAVIDFIRST 21
#define DAVIDSECOND 22
#define BARTHOLOMEW 23
#define GRANT 24
#define HERMAN 25
#define IVAN 26
#define JASON 27
#define KENNETH 28
#define TESTYIELD 29
#define SPIPE TESTYIELD
#define SECURITY_ERROR TESTYIELD

/*
Transports:

    Update this to add a new transport.
*/

char * NamepipeAddresses [] =
{
    "\\pipe\\sigfried",
    "\\pipe\\elliotmi",
    "\\pipe\\elliotma",
    "\\pipe\\elliotno",
    "\\pipe\\andromno",
    0,
    0,
    "\\pipe\\fredrick",
    0,
    0,
    "\\pipe\\isabelno",
    "\\pipe\\isabelmi",
    "\\pipe\\isabelma",
    "\\pipe\\christ",
    "\\pipe\\zippyhe",
    "\\pipe\\zippyis",
    0,
    "\\pipe\\tyler",
    "\\pipe\\richard",
    "\\pipe\\richardh",
    0,
    "\\pipe\\david1",
    "\\pipe\\david2",
    "\\pipe\\bart",
    "\\pipe\\grant",
    "\\pipe\\herman",
    "\\pipe\\ivan",
    "\\pipe\\jason",
    "\\pipe\\kenneth",
    "\\pipe\\testyield"
};

char * DspAddresses [] =
{
    "\\pipe\\sigfried",
    "\\pipe\\elliotmi",
    "\\pipe\\elliotma",
    "\\pipe\\elliotno",
    "\\pipe\\andromno",
    0,
    0,
    "\\pipe\\fredrick",
    0,
    0,
    "\\pipe\\isabelno",
    "\\pipe\\isabelmi",
    "\\pipe\\isabelma",
    "\\pipe\\christ",
    "\\pipe\\zippyhe",
    "\\pipe\\zippyis",
    0,
    "\\pipe\\tyler",
    "\\pipe\\richard",
    "\\pipe\\richardh",
    0,
    "\\pipe\\david1",
    "\\pipe\\david2",
    "\\pipe\\bart",
    "\\pipe\\grant",
    "\\pipe\\herman",
    "\\pipe\\ivan",
    "\\pipe\\jason",
    "\\pipe\\kenneth",
    "\\pipe\\testyield"
};

char * TCPDefaultServer =
    "serverhost";
char * UDPDefaultServer =
    "serverhost";

char * NetBiosAddresses [] =
{
    "201",    // sigfried
    "202",    // elliotmi
    "203",    // elliotma
    "204",    // elliotno
    "205",    // andromno
    0,
    0,
    "206",    // fredrick
    0,
    0,
    "207",    // isabelno
    "208",    // isabelmi
    "209",    // isabelma
    "210",    // christ
    "211",    // zippyhe
    "212",    // zippyis
    0,
    "214",     // tyler
    "215",    // richard
    "216",    // richardh
    0,
    "217",    // david1
    "218",    // david2
    "219",    // bart
    "220",    // grant
    "221",    // herman
    "222",    // ivan
    "223",    // jason
    "224",     // kenneth
    "225"     // testyield
};

char * TCPAddresses [] =
{
    "2025", // SIGFRIED
    "2026", // ELLIOTMINIMIZE
    "2027", // ELLIOTMAXIMIZE
    "2028", // ELLIOTNORMAL
    "2029", // ANDROMIDA
    0,
    0,
    "2032", // FREDRICK
    0,
    0,
    "2035", // ISABELLENORMAL
    "2036", // ISABELLEMINIMIZE
    "2037", // ISABELLEMAXIMIZE
    "2038", // CHRISTOPHER
    "2039", // CHRISTOPHERHELGA
    "2040", // CHRISTOPHERISABELLE
    0,
    "2042", // TYLER
    "2043", // RICHARD
    "2044", // RICHARDHELPER
    0,
    "2045", //D1
    "2046", //D2
    "2047", // Bartholomew
    "2048", // Grant
    "2049", // Herman
    "2050", // Ivan
    "2051", // Jason
    "2052",  // Kenneth
    "2053"   // TestYield
};

char * UDPAddresses [] =
{
    "2025", // SIGFRIED
    "2026", // ELLIOTMINIMIZE
    "2027", // ELLIOTMAXIMIZE
    "2028", // ELLIOTNORMAL
    "2029", // ANDROMIDA
    0,
    0,
    "2032", // FREDRICK
    0,
    0,
    "2035", // ISABELLENORMAL
    "2036", // ISABELLEMINIMIZE
    "2037", // ISABELLEMAXIMIZE
    "2038", // CHRISTOPHER
    "2039", // CHRISTOPHERHELGA
    "2040", // CHRISTOPHERISABELLE
    0,
    "2042", // TYLER
    "2043", // RICHARD
    "2044", // RICHARDHELPER
    0,
    "2045", //D1
    "2046", //D2
    "2047", // Bartholomew
    "2048", // Grant
    "2049", // Herman
    "2050", // Ivan
    "2051", // Jason
    "2052",  // Kenneth
    "2053"  // TestYield
};

char * SPCAddresses [] =
{
    "sigfried",
    "elliotminimize",
    "elliotmaximize",
    "elliotnormal",
    "andromida",
    0,
    0,
    "fredrick",
    0,
    0,
    "isabellenormal",
    "isabelleminimize",
    "isabellemaximize",
    "christopher",
    "christopherhelga",
    "christopherisabelle",
    0,
    "tyler",
    "richard",
    "richardhelper",
     0,
    "davidfirst",
    "davidsecond",
    "bartholomew",
    "grant",
    "herman",
    "ivan",
    "jason",
    "kenneth",
    "testyield"
};

char * SPXAddresses [] =
{
    "5000",    // sigfried
    "5001",    // elliotmi
    "5002",    // elliotma
    "5003",    // elliotno
    "5004",    // andromno
    "5005",
    "5006",
    "5007",    // fredrick
    "5008",
    "5009",
    "5010",    // isabelno
    "5011",    // isabelmi
    "5012",    // isabelma
    "5013",    // christ
    "5014",    // zippyhe
    "5015",    // zippyis
    "5016",
    "5017",    // tyler
    "5020",    // richard
    "5021",    // richardh
    0,
    "5022",    // david1
    "5023",    // david2
    "5024",    // bart
    "5025",    // grant
    "5026",    // herman
    "5027",    // ivan
    "5028",    // jason
    "5029",     // kenneth
    "5030"     // testyield
};

char * IPXAddresses [] =
{
    "5000",    // sigfried
    "5001",    // elliotmi
    "5002",    // elliotma
    "5003",    // elliotno
    "5004",    // andromno
    "5005",
    "5006",
    "5007",    // fredrick
    "5008",
    "5009",
    "5010",    // isabelno
    "5011",    // isabelmi
    "5012",    // isabelma
    "5013",    // christ
    "5014",    // zippyhe
    "5015",    // zippyis
    "5016",
    "5017",    // tyler
    "5020",    // richard
    "5021",    // richardh
    0,
    "5022",    // david1
    "5023",    // david2
    "5024",    // bart
    "5025",    // grant
    "5026",    // herman
    "5027",    // ivan
    "5028",    // jason
    "5029",     // kenneth
    "5030"     // testyield
};

char * VNSAddresses [] =
{
    "250",    // sigfried
    "251",    // elliotmi
    "252",    // elliotma
    "253",    // elliotno
    "254",    // andromno
    "255",
    "256",
    "257",    // fredrick
    "258",
    "259",
    "260",    // isabelno
    "261",    // isabelmi
    "262",    // isabelma
    "263",    // christ
    "264",    // zippyhe
    "265",    // zippyis
    "266",
    "267",    // tyler
    "270",    // richard
    "271",    // richardh
    0,
    "272",    // david1
    "273",    // david2
    "274",    // bart
    "275",    // grant
    "276",    // herman
    "277",    // ivan
    "278",    // jason
    "279",     // kenneth
    "280"     // testyield
};

char * MSMQAddresses [] =
{
    "SIGFRIED",
    "ELLIOTMINIMIZE",
    "ELLIOTMAXIMIZE",
    "ELLIOTNORMAL",
    "ANDROMIDA",
    0,
    0,
    "FREDRICK",
    0,
    0,
    "ISABELLENORMAL",
    "ISABELLEMINIMIZE",
    "ISABELLEMAXIMIZE",
    "CHRISTOPHER",
    "CHRISTOPHERHELGA",
    "CHRISTOPHERISABELLE",
    0,
    "TYLER",
    "RICHARD",
    "RICHARDHELPER",
    0,
    "D1",
    "D2",
    "Bartholomew",
    "Grant",
    "Herman",
    "Ivan",
    "Jason",
    "Kenneth",
    "TestYield"
};


unsigned char PAPI *
GetStringBinding (
    IN unsigned int Address,
    IN char PAPI * ObjectUuid, OPTIONAL
    IN unsigned char PAPI * NetworkOptions OPTIONAL
    )
/*++

Routine Description:

    A string binding for the desired address is constructed.

Arguments:

    Address - Supplies an index into a table of endpoints.

    ObjectUuid - Optionally supplies the string representation of a UUID
        to be specified as the object uuid in the string binding.

    NetworkOptions - Optionally supplies the network options for this
        string binding.

Return Value:

    The constructed string binding will be returned.

Transports:

    Update this to add a new transport.

--*/
{
    unsigned char PAPI * StringBinding;

    if (TransportType == RPC_TRANSPORT_NAMEPIPE)
        {
        Status = RpcStringBindingComposeA((unsigned char PAPI *) ObjectUuid,
                (unsigned char PAPI *) "ncacn_np",
#ifdef WIN32RPC
                (unsigned char PAPI *) ((Server)? Server: "\\\\."),
#else
                (unsigned char PAPI *) Server,
#endif
                (unsigned char PAPI *) NamepipeAddresses[Address],
                NetworkOptions, &StringBinding);
        }

    if (TransportType == RPC_TRANSPORT_NETBIOS)
        {

        Status = RpcStringBindingComposeA((unsigned char PAPI *) ObjectUuid,
                (unsigned char PAPI *) NetBiosProtocol,
                (unsigned char PAPI *) Server,
                (unsigned char PAPI *) NetBiosAddresses[Address],
                NetworkOptions, &StringBinding);
        }

    if (TransportType == RPC_LRPC)
        {
        Status = RpcStringBindingComposeA((unsigned char PAPI *) ObjectUuid,
                (unsigned char PAPI *) "ncalrpc", NULL,
                (unsigned char PAPI *) SPCAddresses[Address], NetworkOptions,
                &StringBinding);
        }

    if (TransportType == RPC_TRANSPORT_TCP)
        {
        Status = RpcStringBindingComposeA((unsigned char PAPI *) ObjectUuid,
                (unsigned char PAPI *) "ncacn_ip_tcp",
                (unsigned char PAPI *) Server,
                (unsigned char PAPI *) TCPAddresses[Address],
                NetworkOptions,
                &StringBinding);
        }

    if (TransportType == RPC_TRANSPORT_UDP)
        {
        Status = RpcStringBindingComposeA((unsigned char PAPI *) ObjectUuid,
                (unsigned char PAPI *) "ncadg_ip_udp",
                (unsigned char PAPI *) Server,
                (unsigned char PAPI *) UDPAddresses[Address],
                NetworkOptions,
                &StringBinding);
        }


    if (TransportType == RPC_TRANSPORT_SPX)
        {

        Status = RpcStringBindingComposeA((unsigned char PAPI *) ObjectUuid,
                (unsigned char PAPI *) "ncacn_spx",
                (unsigned char PAPI *) Server,
                (unsigned char PAPI *) SPXAddresses[Address],
                NetworkOptions, &StringBinding);
        }

    if (TransportType == RPC_TRANSPORT_IPX)
        {

        Status = RpcStringBindingComposeA((unsigned char PAPI *) ObjectUuid,
                (unsigned char PAPI *) "ncadg_ipx",
                (unsigned char PAPI *) Server,
                (unsigned char PAPI *) IPXAddresses[Address],
                NetworkOptions, &StringBinding);
        }

   if (TransportType == RPC_TRANSPORT_DSP)
    {
    Status = RpcStringBindingComposeA((unsigned char PAPI *) ObjectUuid,
                (unsigned char PAPI *) "ncacn_at_dsp",
                (unsigned char PAPI *) Server,
                (unsigned char PAPI *) DspAddresses[Address],
                NetworkOptions, &StringBinding);
    }
    if (TransportType == RPC_TRANSPORT_VNS)
    {
    Status = RpcStringBindingComposeA((unsigned char PAPI *) ObjectUuid,
                (unsigned char PAPI *) "ncacn_vns_spp",
                (unsigned char PAPI *) Server,
                (unsigned char PAPI *) VNSAddresses[Address],
                NetworkOptions, &StringBinding);
    }

    if (TransportType == RPC_TRANSPORT_MSMQ)
    {
    Status = RpcStringBindingComposeA((unsigned char PAPI *) ObjectUuid,
                (unsigned char PAPI *) "ncadg_mq",
                (unsigned char PAPI *) Server,
                (unsigned char PAPI *) MSMQAddresses[Address],
                NetworkOptions, &StringBinding);
    }

   if (Status)
        {
        ApiError("GetStringBinding","RpcStringBindingCompose",Status);
        PrintToConsole("GetStringBinding failed in ");
        PrintToConsole("RpcStringBindingCompose\n");
        return(0);
        }

   return(StringBinding);
}


RPC_STATUS
GetBinding (
    IN unsigned int Address,
    OUT RPC_BINDING_HANDLE PAPI * Binding
    )
/*++

Routine Description:

    A binding for the desired address is constructed.  This is a wrapper
    around GetStringBinding and RpcBindingFromStringBinding.

Arguments:

    Address - Supplies an index into a table of endpoints.

    Binding - A pointer to the location to store the returned binding
    handle.

Return Value:

    The status code from RpcBindingFromStringBinding is returned.

--*/
{
    unsigned char PAPI * StringBinding;
    RPC_STATUS FreeStatus;

    StringBinding = GetStringBinding(Address, 0, 0);

    Status = RpcBindingFromStringBindingA(StringBinding, Binding);

    if (Status)
            ApiError("GetBinding","RpcBindingFromStringBinding",Status);

    if (IFSecurityFlag)
        {
        Status = RpcBindingSetAuthInfo(
                          *Binding, NULL,
                          RPC_C_AUTHN_LEVEL_CONNECT,
                          10,
                          NULL,
                          NULL);
        if (Status != RPC_S_OK)
            {
            ApiError("GetBinding","RpcBindingSetAuthInfo",Status);
            return Status;
            }
        }

    if (StringBinding)
     {
     FreeStatus = RpcStringFreeA(&StringBinding);

     if (FreeStatus)
          {
              ApiError("GetBinding","RpcStringFree",FreeStatus);
              PrintToConsole("GetBinding failed in ");
                  PrintToConsole("RpcStringFree\n");
          }
     }

    if (fUniqueBinding)
        {
        Status = RpcBindingSetOption( *Binding, RPC_C_OPT_UNIQUE_BINDING, TRUE );
        if (Status != RPC_S_OK)
            {
            ApiError("GetBinding","RpcBindingSetOption",Status);
            return Status;
            }
        }

    return(Status);
}


RPC_STATUS
UclntSendReceive (
    IN OUT PRPC_MESSAGE RpcMessage
    )
/*++

Routine Description:

    This routine takes care of retrying to send the remote procedure
    call.

Arguments:

    RpcMessage - Supplies and returns the message for I_RpcSendReceive.

Return Value:

    The result of I_RpcSendReceive will be returned.

--*/
{
    Status = I_RpcSendReceive(RpcMessage);

    return(Status);
}


RPC_STATUS
UclntGetBuffer (
    IN OUT PRPC_MESSAGE RpcMessage
    )
/*++

Routine Description:

    This routine takes care of retrying to getting a buffer.

Arguments:

    RpcMessage - Supplies and returns the message for I_RpcGetBuffer.

Return Value:

    The result of I_RpcGetBuffer will be returned.

--*/
{
    unsigned int RetryCount;
    RPC_BINDING_HANDLE Handle = RpcMessage->Handle;

    for (RetryCount = 0; RetryCount < RETRYCOUNT; RetryCount++)
        {
        RpcMessage->Handle = Handle;
        Status = I_RpcGetBuffer(RpcMessage);
        if (   (Status != RPC_S_SERVER_TOO_BUSY)
            && (Status != RPC_S_CALL_FAILED_DNE))
            break;
        PauseExecution(RETRYDELAY);
        }
    return(Status);
}

/* --------------------------------------------------------------------

Isabelle Interface

-------------------------------------------------------------------- */


RPC_PROTSEQ_ENDPOINT IsabelleRpcProtseqEndpoint[] =
{
    {(unsigned char *) "ncacn_np",
#ifdef WIN32RPC
     (unsigned char *) "\\pipe\\zippyis"},
#else // WIN32RPC
     (unsigned char *) "\\device\\namedpipe\\christopherisabelle"},
#endif // WIN32RPC
    {(unsigned char *) "ncacn_ip_tcp",(unsigned char *) "2040"}
    ,{(unsigned char *) "ncadg_ip_udp",(unsigned char *) "2040"}
    ,{(unsigned char *) "ncalrpc",(unsigned char *) "christopherisabelle"}
    ,{(unsigned char *) "ncacn_nb_nb",(unsigned char *) "212"}
    ,{(unsigned char *) "ncacn_spx",(unsigned char *) "5015"}
    ,{(unsigned char *) "ncadg_ipx",(unsigned char *) "5015"}
    ,{(unsigned char *) "ncacn_vns_spp", (unsigned char *) "265"}
    ,{(unsigned char *) "ncacn_at_dsp", (unsigned char *) "\\pipe\\zippyis"}
    ,{(unsigned char *) "ncadg_mq", (unsigned char *) "christopherisabelle"}
};

RPC_CLIENT_INTERFACE IsabelleInterfaceInformation =
{
    sizeof(RPC_CLIENT_INTERFACE),
    {{9,8,8,{7,7,7,7,7,7,7,7}},
     {1,1}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},
     {2,0}}, /* {4,5}}, */
    0,
    sizeof(IsabelleRpcProtseqEndpoint) / sizeof(RPC_PROTSEQ_ENDPOINT),
    IsabelleRpcProtseqEndpoint,
    0,
    NULL,
    RPC_INTERFACE_HAS_PIPES
};

void
IsabelleShutdown (
    RPC_BINDING_HANDLE Binding // Specifies the binding to use in making the
                       // remote procedure call.
    )
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 0 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("IsabelleShutdown", "I_RpcGetBuffer", Status);
        IsabelleError();
        return;
        }

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("IsabelleShutdown","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }
    else
        {
        if (Caller.BufferLength != 0)
            {
            OtherError("IsabelleShutdown","BufferLength != 0");
            IsabelleError();
            return;
            }
        Status = I_RpcFreeBuffer(&Caller);
        if (Status)
            {
            ApiError("IsabelleShutdown","I_RpcFreeBuffer",Status);
            IsabelleError();
            return;
            }
        }
}

void
IsabelleNtSecurity (
    RPC_BINDING_HANDLE Binding, // Specifies the binding to use in making the
                        // remote procedure call.
    unsigned int BufferLength,
    void PAPI * Buffer
    )
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = BufferLength;
    Caller.ProcNum = 1 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("IsabelleNtSecurity","I_RpcGetBuffer",Status);
        IsabelleError();
        return;
        }
    RpcpMemoryCopy(Caller.Buffer,Buffer,BufferLength);

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("IsabelleNtSecurity","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }
    else
        {
        if (Caller.BufferLength != 0)
            {
            OtherError("IsabelleNtSecurity","BufferLength != 0");
            IsabelleError();
            return;
            }
        Status = I_RpcFreeBuffer(&Caller);
        if (Status)
            {
            ApiError("IsabelleNtSecurity","I_RpcFreeBuffer",Status);
            IsabelleError();
            return;
            }
        }
}

void
IsabelleToStringBinding (
    RPC_BINDING_HANDLE Binding // Specifies the binding to use in making the
                       // remote procedure call.
    )
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 2 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("IsabelleToStringBinding", "I_RpcGetBuffer", Status);
        IsabelleError();
        return;
        }

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("IsabelleToStringBinding","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }
    else
        {
        if (Caller.BufferLength != 0)
            {
            OtherError("IsabelleToStringBinding","BufferLength != 0");
            IsabelleError();
            return;
            }
        Status = I_RpcFreeBuffer(&Caller);
        if (Status)
            {
            ApiError("IsabelleToStringBinding","I_RpcFreeBuffer",Status);
            IsabelleError();
            return;
            }
        }
}

#define RICHARDHELPER_EXIT 1
#define RICHARDHELPER_EXECUTE 2
#define RICHARDHELPER_IGNORE 3
#define RICHARDHELPER_DELAY_EXIT 4


RPC_STATUS
IsabelleRichardHelper (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned /*long*/ char Command
    )
/*++

Routine Description:

    This routine is the caller stub for the IsabelleRichardHelper routine
    on the server side.  We marshall the command, and use the supplied
    binding handle to direct the call.

Arguments:

    Binding - Supplies a binding to direct the call.

    Command - Supplies a command for IsabelleRichardHelper to execute
        on the server side.  Command must be one of the following
        values.

        RICHARDHELPER_EXIT - This value will cause the server to exit.

        RICHARDHELPER_EXECUTE - The server will execute usvr.exe with
            this the -richardhelper flag.

        RICHARDHELPER_IGNORE - The server will do nothing except return.

Return Value:

    The status of the operation will be returned.  This will be the
    status codes returned from RpcGetBuffer and/or RpcSendReceive.

--*/
{
    RPC_MESSAGE Caller;
    unsigned /*long*/ char PAPI * plScan;

    Caller.Handle = Binding;
    Caller.BufferLength = sizeof(unsigned /*long*/ char);
    Caller.ProcNum = 3 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status != RPC_S_OK)
        return(Status);

    plScan = (unsigned /*long*/ char PAPI *) Caller.Buffer;
    *plScan = Command;

    Status = UclntSendReceive(&Caller);

    if (Status != RPC_S_OK)
        return(Status);

    return(I_RpcFreeBuffer(&Caller));
}


RPC_STATUS
IsabelleRaiseException (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned /*long*/ char Exception
    )
/*++

Routine Description:

    This routine is the caller stub for the IsabelleRaiseException routine
    on the server side.  We marshall the exception code, and use the supplied
    binding handle to direct the call.

Arguments:

    Binding - Supplies a binding to direct the call.

    Exception - Supplies the exception to be raised by IsabelleRaiseException.

Return Value:

    The exception raised will be returned.

--*/
{
    RPC_MESSAGE Caller;
    unsigned /*long*/ char PAPI * plScan;

    Caller.Handle = Binding;
    Caller.BufferLength = sizeof(unsigned /*long*/ char);
    Caller.ProcNum = 4 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status != RPC_S_OK)
        return(Status);

    plScan = (unsigned /*long*/ char PAPI *) Caller.Buffer;
    *plScan = Exception;

    Status = UclntSendReceive(&Caller);

    return(Status);
}


void
IsabelleSetRundown (
    RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:

    This is the caller stub which will request that the server set
    a rundown routine for the association over which the call came.

Arguments:

    Binding - Supplies a binding handle to be used to direct the
        remote procedure call.

--*/
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 5 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("IsabelleSetRundown", "I_RpcGetBuffer", Status);
        IsabelleError();
        return;
        }

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("IsabelleSetRundown","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }
    else
        {
        if (Caller.BufferLength != 0)
            {
            OtherError("IsabelleSetRundown","BufferLength != 0");
            IsabelleError();
            return;
            }
        Status = I_RpcFreeBuffer(&Caller);
        if (Status)
            {
            ApiError("IsabelleSetRundown","I_RpcFreeBuffer",Status);
            IsabelleError();
            return;
            }
        }
}


void
IsabelleCheckRundown (
    RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:

    This is the caller stub which will request that the server check
    that the rundown routine actually got called.

Arguments:

    Binding - Supplies a binding handle to be used to direct the
        remote procedure call.

--*/
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 6| HackForOldStubs ;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("IsabelleCheckRundown", "I_RpcGetBuffer", Status);
        IsabelleError();
        return;
        }

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("IsabelleCheckRundown","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }
    else
        {
        if (Caller.BufferLength != 0)
            {
            OtherError("IsabelleCheckRundown","BufferLength != 0");
            IsabelleError();
            return;
            }
        Status = I_RpcFreeBuffer(&Caller);
        if (Status)
            {
            ApiError("IsabelleCheckRundown","I_RpcFreeBuffer",Status);
            IsabelleError();
            return;
            }
        }
}

void
IsabelleMustFail (
    RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:

Arguments:

    Binding - Supplies a binding handle to be used to direct the
        remote procedure call.

--*/
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 6| HackForOldStubs ;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        return;
        }

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        return;
        }

    PrintToConsole("IsabelleMustFail: This call is supposed to fail\n") ;
    IsabelleError();
}


void
IsabelleCheckContext (
    RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:

    This is the caller stub which will request that the server check
    the association context for this association (the one the call comes
    in other), and then to set a new association context.

Arguments:

    Binding - Supplies a binding handle to be used to direct the
        remote procedure call.

--*/
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 7 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("IsabelleCheckContext", "I_RpcGetBuffer", Status);
        IsabelleError();
        return;
        }

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("IsabelleCheckContext","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }
    else
        {
        if (Caller.BufferLength != 0)
            {
            OtherError("IsabelleCheckContext","BufferLength != 0");
            IsabelleError();
            return;
            }
        Status = I_RpcFreeBuffer(&Caller);
        if (Status)
            {
            ApiError("IsabelleCheckContext","I_RpcFreeBuffer",Status);
            IsabelleError();
            return;
            }
        }
}


unsigned char *
IsabelleGetStringBinding (
    RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:

    This is the caller stub which will request that the server return
    the next string binding from the list of bindings supported by the
    server.

Arguments:

    Binding - Supplies a binding handle to be used to direct the
        remote procedure call.

Return Value:

    A copy of the string binding will be returned.  This can be freed
    using the delete operator.  If there are no more string bindings,
    or an error occurs, zero will be returned.

--*/
{
    RPC_MESSAGE Caller;
    unsigned char * StringBinding;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 8 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("IsabelleGetStringBinding", "I_RpcGetBuffer", Status);
        IsabelleError();
        return(0);
        }

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("IsabelleGetStringBinding","I_RpcSendReceive",Status);
        IsabelleError();
        return(0);
        }

    if (Caller.BufferLength != 0)
        {
        StringBinding = new unsigned char[Caller.BufferLength];
        RpcpMemoryCopy(StringBinding,Caller.Buffer,Caller.BufferLength);
        }
    else
        StringBinding = 0;

    Status = I_RpcFreeBuffer(&Caller);
    if (Status)
        {
        ApiError("IsabelleGetStringBinding","I_RpcFreeBuffer",Status);
        IsabelleError();
        return(0);
        }
    return(StringBinding);
}


void
IsabelleCheckNoRundown (
    RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:

    This is the caller stub which will request that the server check
    that the rundown routine did not get called.

Arguments:

    Binding - Supplies a binding handle to be used to direct the
        remote procedure call.

--*/
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 9| HackForOldStubs ;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("IsabelleCheckNoRundown", "I_RpcGetBuffer", Status);
        IsabelleError();
        return;
        }

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("IsabelleCheckNoRundown","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }
    else
        {
        if (Caller.BufferLength != 0)
            {
            OtherError("IsabelleCheckNoRundown","BufferLength != 0");
            IsabelleError();
            return;
            }
        Status = I_RpcFreeBuffer(&Caller);
        if (Status)
            {
            ApiError("IsabelleCheckNoRundown","I_RpcFreeBuffer",Status);
            IsabelleError();
            return;
            }
        }
}


void
IsabelleUnregisterInterfaces (
    RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:

Arguments:

    Binding - Supplies a binding handle to be used to direct the
        remote procedure call.

--*/
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 11| HackForOldStubs ;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("IsabelleUnregisterInterfaces", "I_RpcGetBuffer", Status);
        IsabelleError();
        return;
        }

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("IsabelleUnregisterInterfaces","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }

    Status = I_RpcFreeBuffer(&Caller);
    if (Status)
        {
        ApiError("IsabelleUnregisterInterfaces","I_RpcFreeBuffer",Status);
        IsabelleError();
        return;
        }
}


void
IsabelleRegisterInterfaces (
    RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:


Arguments:

    Binding - Supplies a binding handle to be used to direct the
        remote procedure call.

--*/
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 12| HackForOldStubs ;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("IsabelleRegisterInterfaces", "I_RpcGetBuffer", Status);
        IsabelleError();
        return;
        }

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("IsabelleRegisterInterfaces","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }

    Status = I_RpcFreeBuffer(&Caller);
    if (Status)
        {
        ApiError("IsabelleRegisterInterfaces","I_RpcFreeBuffer",Status);
        IsabelleError();
        return;
        }
}

void PipeAlloc(
    char PAPI *state,
    int requested_size,
    pipe_element_t PAPI * PAPI *allocated_buf,
    int PAPI * allocated_size)
{
    static int size = 0;
    static void PAPI *buffer = NULL;

    if (size < requested_size)
        {
        if (buffer)
            {
            I_RpcFree(buffer) ;
            }

        buffer =  I_RpcAllocate(requested_size) ;
        if (buffer == 0)
            {
            *allocated_size = 0 ;
            size = 0 ;
            }
        else
            {
            *allocated_size = requested_size ;
            size = requested_size ;
            }

        *allocated_buf = (pipe_element_t PAPI *) buffer ;
        }
    else
        {
        *allocated_buf = (pipe_element_t PAPI *) buffer ;
        *allocated_size = size ;
        }
}

void PipePull(
    char PAPI *state,
    pipe_element_t PAPI *buffer,
    int num_buf_elem,
    int PAPI *size_to_send
    )
{
    int i ;
    char j = 0;

    if (*((int PAPI *)state) <= 0)
        {
        *size_to_send = 0 ;
        return ;
        }

    // fill pipe elements
    for (i = 0; i<num_buf_elem; i++, j++)
        {
        buffer[i] = i ;
        }

    *size_to_send = num_buf_elem ;
    --*((int PAPI *) state) ;
}

int localchecksum ;

void  PipePush(
    char PAPI *state,
    pipe_element_t PAPI *input_buffer,
    int ecount
    )
{
    char PAPI *temp = (char PAPI *) input_buffer ;
    int i, j ;

    for (i = 0; i < ecount; i++)
        {
        localchecksum += input_buffer[i] ;
        }
}

void
IsabellePipeIN (
    RPC_BINDING_HANDLE Binding,
    pipe_t PAPI *pipe,
    int chunksize,
    int numchunks,
    long checksum,
    int buffsize,
    char PAPI *buffer
    )
{
    RPC_MESSAGE Caller, TempBuf;
    pipe_element_t PAPI *buf ;
    int num_buf_bytes ;
    int count ;
    int num_buf_elem ;
    DWORD size = 0 ;
    char PAPI *Temp ;
    int BufferOffset = 0 ;
    int LengthToSend ;

    Caller.Handle = Binding;
    Caller.BufferLength = 3 * sizeof(int) + buffsize;
    Caller.ProcNum = 13 | HackForOldStubs | RPC_FLAGS_VALID_BIT;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = RPC_BUFFER_PARTIAL ;

    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("IsabellePipeIN", "I_RpcGetBuffer", Status);
        IsabelleError();
        return;
        }

    // marshal the fixed parameters
    Temp = (char PAPI *) Caller.Buffer ;
    *((int PAPI *) Temp) = chunksize ;
    Temp += sizeof(int) ;

    *((int PAPI *) Temp) = numchunks ;
    Temp += sizeof(int) ;

    *((long PAPI *) Temp) = checksum ;
    Temp += sizeof(long) ;

    *((int PAPI *) Temp) = buffsize ;
    Temp += sizeof(int) ;


    RpcpMemoryCopy(Temp, buffer, buffsize) ;

    // send the marshalled parameters
    Status = I_RpcSend(&Caller);

    if (Status == RPC_S_SEND_INCOMPLETE)
        {
        BufferOffset = Caller.BufferLength ;
        }
    else if (Status)
        {
        ApiError("IsabellePipeIN","I_RpcSend",Status);
        IsabelleError();
        return;
        }

    do
        {
        pipe->Alloc(pipe->state,
                        chunksize * sizeof(pipe_element_t) + sizeof(DWORD),
                        &buf,
                        &num_buf_bytes
                        ) ;

        num_buf_elem = (num_buf_bytes -sizeof(DWORD)) / sizeof(pipe_element_t) ;

        pipe->Pull(pipe->state,
                       (pipe_element_t PAPI *) ((char PAPI *) buf+sizeof(DWORD)),
                       num_buf_elem,
                       &count
                       ) ;

        *((DWORD PAPI *) buf) = count ;
        LengthToSend = (count * sizeof(pipe_element_t)) + sizeof(DWORD) ;

        Status = I_RpcReallocPipeBuffer(&Caller, LengthToSend+BufferOffset) ;

        if (Status)
            {
            ApiError("IsabellePipeIN","I_RpcReallocPipeBuffer",Status);
            IsabelleError();
            return;
            }

        if (count == 0)
            {
            Caller.RpcFlags = 0 ;
            }

        RpcpMemoryCopy((char PAPI *) Caller.Buffer+BufferOffset, buf, LengthToSend) ;

        Status = I_RpcSend(&Caller) ;
        if (Status == RPC_S_SEND_INCOMPLETE)
            {
            BufferOffset = Caller.BufferLength ;
            }
        else if (Status)
            {
            ApiError("IsabellePipeIN","I_RpcSend",Status);
            IsabelleError();
            return;
            }
        else
            {
            BufferOffset = 0 ;
            }
        }
    while (count > 0) ;

    size = 0 ;
    Caller.RpcFlags = 0 ;

    Status = I_RpcReceive(&Caller, size) ;

    if (Status == RPC_S_OK)
       {
        if (Caller.BufferLength != 0)
            {
            OtherError("IsabellePipeIN","BufferLength != 0");
            IsabelleError();
            return;
            }
        Status = I_RpcFreeBuffer(&Caller);
        if (Status)
            {
            ApiError("IsabellePipeIN","I_RpcFreeBuffer",Status);
            IsabelleError();
            return;
            }
        }
}

void LocalPipePull(
    PIPE_STATE PAPI *state,
    void PAPI *buffer,
    int max_buf,
    int PAPI *actual_transfer_count
    )
{
    unsigned num_elements = 0 ;
    DWORD size = (DWORD) max_buf;
    int bytescopied ;
    RPC_MESSAGE Caller ;

    *actual_transfer_count = 0 ;

    if (state->EndOfPipe)
        {
        return ;
        }

    I_RpcReadPipeElementsFromBuffer(state, (char PAPI *) buffer, max_buf, (int *) &num_elements) ;
    *actual_transfer_count += num_elements ;
    bytescopied = num_elements * sizeof(pipe_element_t) ;

    if (state->EndOfPipe == 0 &&
        num_elements < (max_buf / sizeof(pipe_element_t)))
        {
        Caller.RpcFlags = RPC_BUFFER_PARTIAL ;
        Caller.Buffer = state->Buffer ;
        Caller.BufferLength = state->BufferLength ;

        Status = I_RpcReceive(&Caller, size) ;
        if (Status)
            {
            ApiError("PipePull", "I_RpcReceive", Status) ;
            return ;
            }

        num_elements = 0 ;
        state->Buffer = Caller.Buffer ;
        state->BufferLength = Caller.BufferLength ;

        state->CurPointer = (char PAPI *) Caller.Buffer ;
        state->BytesRemaining = Caller.BufferLength ;

        I_RpcReadPipeElementsFromBuffer(
                        (PIPE_STATE PAPI *) state,
                        (char PAPI *) buffer+bytescopied,
                        max_buf - bytescopied, (int *) &num_elements) ;

        *actual_transfer_count += num_elements ;
        }
}

void
IsabellePipeOUT (
    RPC_BINDING_HANDLE Binding,
    pipe_t PAPI *pipe,
    int chunksize
    )
{
    RPC_MESSAGE Caller;
    int num_elements ;
    int count ;
    DWORD size = chunksize * sizeof(pipe_element_t) + sizeof(DWORD) *2;
    int max_buf ;
    PIPE_STATE localstate ;
    pipe_element_t PAPI *buf ;
    pipe_element_t pipe_element ;
    int rchunksize, rnumchunks, rbuffsize, rchecksum ;
    char PAPI *temp, PAPI *cur ;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 14 | HackForOldStubs | RPC_FLAGS_VALID_BIT;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = RPC_BUFFER_PARTIAL ;

    Status = I_RpcGetBuffer(&Caller) ;
    if (Status)
        {
        ApiError("IsabellePipeOUT","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }

    Caller.RpcFlags = 0;
    Status = I_RpcSend(&Caller) ;
    if (Status)
        {
        ApiError("IsabellePipeOUT","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }

    Caller.RpcFlags |= RPC_BUFFER_PARTIAL ;

    Status = I_RpcReceive(&Caller, size) ;
    if (Status)
        {
        ApiError("IsabellePipeOUT", "I_RpcReceive", Status) ;
        IsabelleError() ;
        return ;
        }

    localstate.Buffer = Caller.Buffer ;
    localstate.BufferLength = Caller.BufferLength ;
    localstate.CurrentState = start ;
    localstate.CurPointer = (char PAPI *) Caller.Buffer ;
    localstate.BytesRemaining = Caller.BufferLength ;
    localstate.EndOfPipe = 0 ;
    localstate.PipeElementSize = sizeof(pipe_element_t) ;
    localstate.PartialPipeElement = &pipe_element ;
    localchecksum = 0;

    do
        {
        pipe->Alloc(pipe->state,
                        size,
                        &buf,
                        &max_buf
                        ) ;

        LocalPipePull(&localstate, buf, max_buf, &num_elements) ;

        pipe->Push(pipe->state,
                        buf,
                        num_elements) ;
        }
    while (num_elements > 0);

    if (!(Caller.RpcFlags & RPC_BUFFER_COMPLETE))
        {
        Caller.RpcFlags = 0 ;
        Status = I_RpcReceive(&Caller, size) ;
        if (Status)
            {
            ApiError("IsabellePipeOUT", "I_RpcReceive", Status) ;
            IsabelleError() ;
            return ;
            }
        }

    if (localstate.BytesRemaining > 0)
        {
        // this might be quite inefficient... need to improve
        // Also, CurPointer may be a pointer in Caller.Buffer
        // need to keep track of this in the state.

        temp = (char PAPI *) I_RpcAllocate(Caller.BufferLength + localstate.BytesRemaining) ;
        RpcpMemoryCopy(temp, localstate.CurPointer, localstate.BytesRemaining) ;
        RpcpMemoryCopy(temp+localstate.BytesRemaining,
                                  Caller.Buffer, Caller.BufferLength) ;
        cur = temp ;
        }
    else
        {
        temp = 0;
        cur = (char PAPI *) Caller.Buffer ;
        }

    rchunksize = *((int PAPI *) cur) ;
    cur += sizeof(int) ;

    rnumchunks = *((int PAPI *) cur) ;
    cur += sizeof(int) ;

    rchecksum = *((int PAPI *) cur) ;
    cur += sizeof(int) ;

    rbuffsize = *((int PAPI *) cur) ;
    cur += sizeof(int) ;

    PrintToConsole("IsabellePipeOUT: chunksize = %d\n", rchunksize)  ;
    PrintToConsole("IsabellePipeOUT: numchunks = %d\n", rnumchunks)  ;
    PrintToConsole("IsabellePipeOUT: buffsize = %d\n", rbuffsize)  ;
    PrintToConsole("IsabellePipeOUT: checksum = %d\n", rchecksum) ;

    if (temp)
        {
        I_RpcFree(temp) ;
        }

    Status = I_RpcFreeBuffer(&Caller) ;
    if (Status)
        {
        ApiError("IsabellePipeOUT","I_RpcSendReceive",Status);
        IsabelleError() ;
        return;
        }

    if (rchecksum != localchecksum)
        {
        IsabelleError() ;
        }
}

void
IsabellePipeINOUT (
    RPC_BINDING_HANDLE Binding,
    pipe_t PAPI *pipe,
    int chunksize,
    int checksum
    )
{
    RPC_MESSAGE Caller, TempBuf;
    pipe_element_t PAPI *buf ;
    int num_buf_bytes ;
    int count ;
    int num_buf_elem ;
    DWORD size = chunksize * sizeof(pipe_element_t) + sizeof(DWORD) * 2;
    PIPE_STATE localstate ;
    int max_buf ;
    int num_elements ;
    pipe_element_t pipe_element ;
    int BufferOffset = 0 ;
    int LengthToSend ;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 15 | HackForOldStubs | RPC_FLAGS_VALID_BIT;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = RPC_BUFFER_PARTIAL ;

    Status = UclntGetBuffer(&Caller) ;
    if (Status)
        {
        ApiError("IsabellePipeINOUT","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }

    // send the marshalled parameters
    Status = I_RpcSend(&Caller);

    if (Status == RPC_S_SEND_INCOMPLETE)
        {
        BufferOffset = Caller.BufferLength ;
        }
    else if (Status)
        {
        ApiError("IsabellePipeINOUT","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }

    do
        {
        pipe->Alloc(pipe->state,
                         size,
                         &buf,
                         &num_buf_bytes
                         ) ;

        num_buf_elem = (num_buf_bytes -sizeof(DWORD)) / sizeof(pipe_element_t) ;

        pipe->Pull(pipe->state,
                       (pipe_element_t PAPI *) ((char PAPI *) buf+sizeof(DWORD)),
                       num_buf_elem,
                       &count
                       ) ;

        *((DWORD PAPI *) buf) = count ;

        LengthToSend = (count * sizeof(pipe_element_t)) + sizeof(DWORD) ;

        Status = I_RpcReallocPipeBuffer(&Caller, LengthToSend+BufferOffset) ;

        if (Status)
            {
            ApiError("IsabellePipeINOUT","I_RpcGetBuffer",Status);
            IsabelleError();
            return;
            }

        if (count == 0)
            {
            Caller.RpcFlags = 0 ;
            }

        RpcpMemoryCopy((char PAPI *) Caller.Buffer+BufferOffset, buf, LengthToSend) ;

        Status = I_RpcSend(&Caller) ;
        if (Status == RPC_S_SEND_INCOMPLETE)
            {
            BufferOffset = Caller.BufferLength ;
            }
        else if (Status)
            {
            ApiError("IsabellePipeINOUT","I_RpcSend",Status);
            IsabelleError();
            return;
            }
        else
            {
            BufferOffset = 0 ;
            }
        }
    while (count > 0) ;

    Caller.RpcFlags |= RPC_BUFFER_PARTIAL ;

    Status = I_RpcReceive(&Caller, size) ;
    if (Status)
        {
        ApiError("IsabellePipeINOUT", "I_RpcReceive", Status) ;
        IsabelleError() ;
        return ;
        }

    PrintToConsole("IsabellePipeINOUT: checksum (IN) = %d\n",
                                checksum) ;

    localstate.Buffer = Caller.Buffer ;
    localstate.CurrentState = start ;
    localstate.CurPointer = (char PAPI *) Caller.Buffer ;
    localstate.BytesRemaining = Caller.BufferLength ;
    localstate.EndOfPipe = 0 ;
    localstate.PipeElementSize = sizeof(pipe_element_t) ;
    localstate.PartialPipeElement = &pipe_element ;
    localchecksum = 0;

    do
        {
        pipe->Alloc(pipe->state,
                        size,
                        &buf,
                        &max_buf
                        ) ;

        LocalPipePull(&localstate, buf, max_buf, &num_elements) ;

        pipe->Push(pipe->state,
                         buf,
                         num_elements
                         ) ;
        }
    while (num_elements > 0);

    if (!(Caller.RpcFlags & RPC_BUFFER_COMPLETE))
        {
        Status = I_RpcReceive(&Caller, size) ;
        if (Status)
            {
            ApiError("IsabellePipeINOUT", "I_RpcReceive", Status) ;
            IsabelleError() ;
            return ;
            }
        }

    Status = I_RpcFreeBuffer(&Caller) ;
    if (Status)
        {
        ApiError("IsabellePipeINOUT","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }

    PrintToConsole("IsabellePipeINOUT: checksum (OUT) = %d\n", localchecksum) ;
}

BOOL IsServerNTSystem(RPC_BINDING_HANDLE Binding)
{
    OSVERSIONINFO *pOsVer;
    BOOL fResult;
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 20| HackForOldStubs ;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("IsServerNTSystem", "I_RpcGetBuffer", Status);
        IsabelleError();
        return TRUE;
        }

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("IsServerNTSystem","I_RpcSendReceive",Status);
        IsabelleError();
        return TRUE;
        }

    pOsVer = (OSVERSIONINFO *)Caller.Buffer;
    if (pOsVer->dwPlatformId == VER_PLATFORM_WIN32_NT)
        fResult = TRUE;
    else
        fResult = FALSE;

    Status = I_RpcFreeBuffer(&Caller);
    if (Status)
        {
        ApiError("IsServerNTSystem","I_RpcFreeBuffer",Status);
        IsabelleError();
        }

    return fResult;
}

typedef struct _WIRE_CONTEXT
{
    unsigned long ContextType;
    UUID ContextUuid;
} WIRE_CONTEXT;

typedef struct _CCONTEXT {

    RPC_BINDING_HANDLE hRPC;    // binding handle assoicated with context

    unsigned long MagicValue;
    WIRE_CONTEXT NDR;

} CCONTEXT, *PCCONTEXT;

const ULONG CONTEXT_MAGIC_VALUE = 0xFEDCBA98;

void
UnregisterHelgaEx (
    RPC_BINDING_HANDLE Binding
    )
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 22| HackForOldStubs ;
    Caller.RpcInterfaceInformation = &IsabelleInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("UnregisterHelgaEx", "I_RpcGetBuffer", Status);
        IsabelleError();
        return;
        }

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("UnregisterHelgaEx","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }

    Status = I_RpcFreeBuffer(&Caller);
    if (Status)
        {
        ApiError("UnregisterHelgaEx","I_RpcFreeBuffer",Status);
        IsabelleError();
        }
}

void OpenContextHandle(
    IN RPC_BINDING_HANDLE Binding,
    IN RPC_CLIENT_INTERFACE *If,
    OUT CCONTEXT *ContextHandle
    )
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = sizeof(WIRE_CONTEXT);
    if (If == &IsabelleInterfaceInformation)
        Caller.ProcNum = 21| HackForOldStubs ;
    else if (If == &HelgaInterfaceInformation)
        Caller.ProcNum = 10| HackForOldStubs ;
    else
        {
        ASSERT(0);
        }
    Caller.RpcInterfaceInformation = If;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("OpenContextHandle", "I_RpcGetBuffer", Status);
        IsabelleError();
        return;
        }

    memset(Caller.Buffer, 0, sizeof(WIRE_CONTEXT));

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("OpenContextHandle","I_RpcSendReceive",Status);
        IsabelleError();
        return;
        }

    if (ContextHandle)
        {
        Status = RpcBindingCopy(Binding, &ContextHandle->hRPC);
        if (Status)
            {
            ApiError("OpenContextHandle","RpcBindingCopy", Status);
            IsabelleError();
            }

        ContextHandle->MagicValue = CONTEXT_MAGIC_VALUE;
        memcpy(&ContextHandle->NDR, Caller.Buffer, sizeof(WIRE_CONTEXT));
        }

    Status = I_RpcFreeBuffer(&Caller);
    if (Status)
        {
        ApiError("OpenContextHandle","I_RpcFreeBuffer",Status);
        IsabelleError();
        }
}

/* -----------------------------------------------------------------

Synchronize Routine

--------------------------------------------------------------------*/
void Synchro(
     unsigned int Address // Specifies the binding to use in making the call
    )
{
    RPC_BINDING_HANDLE Binding ;
    int fPrint = 0;
    RPC_MESSAGE Caller;

    if (AutoListenFlag)
        {
        Caller.BufferLength = 0;
        Caller.ProcNum = 4 | HackForOldStubs ;
        Caller.RpcInterfaceInformation = &HelgaInterfaceInformation ;
        Caller.RpcFlags = 0;
        }

    Status = GetBinding(Address, &Binding);
    if (Status)
        {
        ApiError("Synchro","GetBinding",Status);
        PrintToConsole("Synchro : FAIL - Unable to Bind\n");

        return;
        }

#ifdef __RPC_WIN32__
    if (AutoListenFlag)
        {
        Caller.Handle = Binding;

        while(1)
            {
            while(UclntGetBuffer(&Caller))
                {
                Caller.Handle = Binding;
                PrintToConsole(".");
                fPrint = 1;
                PauseExecution(100);
                }

            if( UclntSendReceive(&Caller) == 0)
                {
                PrintToConsole("\n");
                break ;
                }

            PauseExecution(100) ;
            PrintToConsole(".");
            fPrint = 1;
            Caller.Handle = Binding ;
            }


       // SendReceive okay, free buffer now.
       Status = I_RpcFreeBuffer(&Caller);
       if (Status)
           ApiError("Synchro","I_RpcFreeBuffer",Status);
        }
    else
        {
        while(RpcMgmtIsServerListening(Binding) != RPC_S_OK)
            {
            PrintToConsole(".");
            fPrint = 1;
            PauseExecution(100) ;
            }
        }

#else
    Caller.Handle = Binding;

    while(1)
        {
        while(UclntGetBuffer(&Caller))
            {
            Caller.Handle = Binding;
            PrintToConsole(".");
            fPrint = 1;
            PauseExecution(100);
            }

        if( UclntSendReceive(&Caller) == 0)
            {
            PrintToConsole("\n");
            break ;
            }

        PauseExecution(100) ;
        PrintToConsole(".");
        fPrint = 1;
        }


   // SendReceive okay, free buffer now.
   Status = I_RpcFreeBuffer(&Caller);
   if (Status)
       ApiError("Synchro","I_RpcFreeBuffer",Status);
#endif

    Status = RpcBindingFree(&Binding);
    if (Status)
        {
        ApiError("Synchro","RpcBindingFree",Status);
        PrintToConsole("Synchro : FAIL - Unable to Free Binding");
        return;
        }

    if (fPrint)
        {
        PrintToConsole("\n");
        }
}

/* --------------------------------------------------------------------

Helga Interface

-------------------------------------------------------------------- */

void
InitializeBuffer (
    IN OUT void PAPI * Buffer,
    IN unsigned int BufferLength
    )
/*++

Routine Description:

    This routine is used to initialize the buffer; the first long in the
    buffer is set to be the length of the buffer.  The rest of the buffer
    is initialized with a pattern which will be checked by the receiver.

Arguments:

    Buffer - Supplies the buffer to be initialized.

    BufferLength - Supplies the length of the buffer.

--*/
{
    unsigned long PAPI * Length;
    unsigned char PAPI * BufferScan;
    static unsigned char InitialValue = 96;
    unsigned char Value;

    Length = (unsigned long PAPI *) Buffer;
    *Length = BufferLength;
    swaplong(*Length) ;

    Value = InitialValue;
    InitialValue += 1;

    for (BufferScan = (unsigned char PAPI *) (Length + 1), BufferLength -= 4;
        BufferLength > 0; BufferLength--, BufferScan++, Value++)
        *BufferScan = Value;
}


int
CheckBuffer (
    IN void PAPI * Buffer,
    IN unsigned long BufferLength
    )
/*++

Routine Description:

    We need to check that the correct bytes were sent.  We do not check
    the length of the buffer.

Arguments:

    Buffer - Supplies the buffer to be checked.

    BufferLength - Supplies the length of the buffer to be checked.

Return Value:

    A value of zero will be returned if the buffer contains the correct
    bytes; otherwise, non-zero will be returned.

--*/
{
    unsigned long PAPI * Length;
    unsigned char PAPI * BufferScan;
    unsigned char Value = 0;

    Length = (unsigned long PAPI *) Buffer;
    swaplong(*Length) ;

    for (BufferScan = (unsigned char PAPI *) (Length + 1),
                Value = *BufferScan, BufferLength -= 4;
                BufferLength > 0; BufferLength--, BufferScan++, Value++)
        if (*BufferScan != Value)
            return(1);

    return(0);
}


RPC_PROTSEQ_ENDPOINT HelgaRpcProtseqEndpoint[] =
{
    {(unsigned char *) "ncacn_np",
#ifdef WIN32RPC
     (unsigned char *) "\\pipe\\zippyhe"},
#else // WIN32RPC
     (unsigned char *) "\\device\\namedpipe\\christopherhelga"},
#endif // WIN32RPC
    {(unsigned char *) "ncacn_ip_tcp", (unsigned char *) "2039"}
   ,{(unsigned char *) "ncadg_ip_udp", (unsigned char *) "2039"}
   ,{(unsigned char *) "ncalrpc",(unsigned char *) "christopherhelga"}
   ,{(unsigned char *) "ncacn_nb_nb",(unsigned char *) "211"}
   ,{(unsigned char *) "ncacn_spx", (unsigned char *) "5014"}
   ,{(unsigned char *) "ncadg_ipx", (unsigned char *) "5014"}
   ,{(unsigned char *) "ncacn_vns_spp", (unsigned char *) "264"}
   ,{(unsigned char *) "ncacn_at_dsp", (unsigned char *) "\\pipe\\zippyhe"}
   ,{(unsigned char *) "ncadg_mq", (unsigned char *) "christopherhelga"}
};

RPC_CLIENT_INTERFACE HelgaInterfaceInformation =
{
    sizeof(RPC_CLIENT_INTERFACE),
    {{1,2,2,{3,3,3,3,3,3,3,3}},
     {1,1}},
    {{0x8A885D04, 0x1CEB, 0x11C9, {0x9F, 0xE8, 0x08, 0x00, 0x2B, 0x10, 0x48, 0x60}},
     {2, 0}},
    0,
    sizeof(HelgaRpcProtseqEndpoint) / sizeof(RPC_PROTSEQ_ENDPOINT),
    HelgaRpcProtseqEndpoint,
    0,
    NULL,
    RPC_INTERFACE_HAS_PIPES
};

// Send a 0 length packet and expect a 0 length one in reply

void
Helga (
    RPC_BINDING_HANDLE Binding // Specifies the binding to use in making the
                       // remote procedure call.
    )
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 0 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &HelgaInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("Helga","I_RpcGetBuffer",Status);
        HelgaError();
        return;
        }

    Status = UclntSendReceive(&Caller);
    if (Status)
        {
        ApiError("Helga","I_RpcSendReceive",Status);
        HelgaError();
        return;
        }
    else
        {
        if (Caller.BufferLength != 0)
            {
            OtherError("Helga","BufferLength != 0");
            HelgaError();
            return;
            }
        Status = I_RpcFreeBuffer(&Caller);
        if (Status)
            {
            ApiError("Helga","I_RpcFreeBuffer",Status);
            HelgaError();
            return;
            }
        }
}
// Send a 0 length packet and expect a 0 length one in reply

DWORD
HelgaSendReceiveFailure (
    RPC_BINDING_HANDLE Binding, // Specifies the binding to use in making the
                       // remote procedure call.
    int ProcNum
    )
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = ProcNum | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &HelgaInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("Helga","I_RpcGetBuffer",Status);
        HelgaError();
        return -1;
        }

    Status = UclntSendReceive(&Caller);
    if (!Status)
        {
        ApiError("HelgaSendReceiveFailure","I_RpcSendReceive",Status);
        HelgaError();

        I_RpcFreeBuffer(&Caller);
        return -1;
        }

    return Status;
}

void
HelgaSyncLpcSecurity (
    RPC_BINDING_HANDLE Binding
    )
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 6 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &HelgaInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("HelgaLpcSecurity","I_RpcGetBuffer",Status);
        HelgaError();
        return;
        }

    Status = UclntSendReceive(&Caller);
    if (Status)
        {
        ApiError("HelgaLpcSecurity","I_RpcSendReceive",Status);
        HelgaError();
        return;
        }
    if (Caller.BufferLength != 0)
        {
        OtherError("HelgaLpcSecurity","BufferLength != 0");
        HelgaError();
        return;
        }
    Status = I_RpcFreeBuffer(&Caller);
    if (Status)
        {
        ApiError("HelgaLpcSecurity","I_RpcFreeBuffer",Status);
        HelgaError();
        return;
        }
}

void
HelgaAsyncLpcSecurity (
    RPC_BINDING_HANDLE Binding
    )
{
    RPC_MESSAGE Caller;
    RPC_ASYNC_STATE Async;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 6 | HackForOldStubs | RPC_FLAGS_VALID_BIT;
    Caller.RpcInterfaceInformation = &HelgaInterfaceInformation;
    Caller.RpcFlags = RPC_BUFFER_ASYNC;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("HelgaLpcSecurity","I_RpcGetBuffer",Status);
        HelgaError();
        return;
        }

    Async.u.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL) ;
    if (Async.u.hEvent == 0)
        {
        HelgaError();
        return;
        }

    Async.NotificationType = RpcNotificationTypeEvent ;

    Status = I_RpcAsyncSetHandle(&Caller, (PRPC_ASYNC_STATE) &Async);
    if (Status)
        {
        HelgaError();
        return;
        }

    Caller.RpcFlags = RPC_BUFFER_ASYNC;
    Status = I_RpcSend(&Caller);
    if (Status)
        {
        ApiError("HelgaLpcSecurity","I_RpcSend",Status);
        HelgaError();
        return;
        }

    if (Caller.BufferLength != 0)
        {
        OtherError("HelgaLpcSecurity","BufferLength != 0");
        HelgaError();
        return;
        }

    WaitForSingleObject(Async.u.hEvent, INFINITE);

    Caller.RpcFlags = RPC_BUFFER_ASYNC;
    Status = I_RpcReceive(&Caller, 0);
    if (Status)
        {
        HelgaError();
        return;
        }

    Status = I_RpcFreeBuffer(&Caller);
    if (Status)
        {
        ApiError("HelgaLpcSecurity","I_RpcFreeBuffer",Status);
        HelgaError();
        return;
        }
}


void
HelgaLpcSecurity (
    RPC_BINDING_HANDLE Binding,
    BOOL fAsync
    )
{
    if (fAsync)
        {
        HelgaAsyncLpcSecurity(Binding);
        }
    else
        {
        HelgaSyncLpcSecurity(Binding);
        }
}

void
HelgaMustFail (
    RPC_BINDING_HANDLE Binding // Specifies the binding to use in making the
                       // remote procedure call.
    )
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 0 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &HelgaInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        PrintToConsole("HelgaMustFail: I_RpcGetBuffer: %d\n", Status) ;
        return;
        }

    Status = UclntSendReceive(&Caller);
    if (Status)
        {
        PrintToConsole("HelgaMustFail: I_RpcSendReceive: %d\n", Status) ;
        return;
        }

    PrintToConsole("HelgaMustFail: This call is supposed to fail\n") ;
    HelgaError();
}

void
HelgaUsingContextHandle (
    void PAPI * ContextHandle
    )
{
    RPC_MESSAGE Caller;

    Caller.Handle = NDRCContextBinding(ContextHandle);
    Caller.BufferLength = 0;
    Caller.ProcNum = 0| HackForOldStubs ;
    Caller.RpcInterfaceInformation = &HelgaInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("Helga","I_RpcGetBuffer",Status);
        HelgaError();
        return;
        }

    Status = UclntSendReceive(&Caller);
    if (Status)
        {
        ApiError("Helga","I_RpcSendReceive",Status);
        HelgaError();
        return;
        }
    else
        {
        if (Caller.BufferLength != 0)
            {
            OtherError("Helga","BufferLength != 0");
            HelgaError();
            return;
            }
        Status = I_RpcFreeBuffer(&Caller);
        if (Status)
            {
            ApiError("Helga","I_RpcFreeBuffer",Status);
            HelgaError();
            return;
            }
        }
}

// Send a packet of a requested size, the expected reply is 0 length
// The first long of the packet is the expected size on the server size

void
HelgaIN (
    RPC_BINDING_HANDLE Binding, // Specifies the binding to use in making the
                        // remote procedure call.
    unsigned long BufferLength // Specifies the length of the buffer.
    )
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = BufferLength;
    Caller.ProcNum = 1 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &HelgaInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("HelgaIN","I_RpcGetBuffer",Status);
        HelgaError();
        return;
        }

    InitializeBuffer(Caller.Buffer, BufferLength);

    Status = UclntSendReceive(&Caller);
    if (Status)
        {
        ApiError("HelgaIN","I_RpcSendReceive",Status);
        HelgaError();
        return;
        }
    else
        {
        if (Caller.BufferLength != 0)
            {
            OtherError("HelgaIN","BufferLength != 0");
            HelgaError();
            return;
            }
        Status = I_RpcFreeBuffer(&Caller);
        if (Status)
            {
            ApiError("HelgaIN","I_RpcFreeBuffer",Status);
            HelgaError();
            return;
            }
        }
}

// Send a packet which contains a single long, which is the size
// of the packet the server will send in reply

void
HelgaOUT (
    RPC_BINDING_HANDLE Binding, // Specifies the binding to use in making the
                       // remote procedure call.
    unsigned long BufferLength // Specifies the length of the buffer.
    )
{
    RPC_MESSAGE Caller;
    unsigned long PAPI * Length;

    Caller.Handle = Binding;
    Caller.BufferLength = sizeof(unsigned long);
    Caller.ProcNum = 2 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &HelgaInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("HelgaOUT","I_RpcGetBuffer",Status);
        HelgaError();
        return;
        }

    Length = (unsigned long PAPI *) Caller.Buffer;
    *Length = BufferLength;
    swaplong(*Length) ;

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("HelgaOUT","I_RpcSendReceive",Status);
        HelgaError();
        return;
        }
    else
        {
        Length = (unsigned long PAPI *) Caller.Buffer;
            swaplong(*Length) ;
        if (Caller.BufferLength != *Length)
            {
            OtherError("HelgaOUT","BufferLength != *Length");
            HelgaError();
            return;
            }
        if (CheckBuffer(Caller.Buffer, Caller.BufferLength) != 0)
            {
            OtherError("HelgaOUT","CheckBuffer Failed");
            HelgaError();
            return;
            }
        Status = I_RpcFreeBuffer(&Caller);
        if (Status)
            {
            ApiError("HelgaOUT","I_RpcFreeBuffer",Status);
            HelgaError();
            return;
            }
        }
}

// Send a packet, which the first long is the size of the packet, whoes
// reply should be a packet of the same size

void
HelgaINOUT (
    RPC_BINDING_HANDLE Binding, // Specifies the binding to use in making the
                            // remote procedure call.
    unsigned long BufferLength  // Specifies the length of the buffer.
    )
{
    RPC_MESSAGE Caller;
    unsigned long PAPI * Length;

    Caller.Handle = Binding;
    Caller.BufferLength = BufferLength;
    Caller.ProcNum = 3 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &HelgaInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }

    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("HelgaINOUT","I_RpcGetBuffer",Status);
        HelgaError();
        return;
        }

    InitializeBuffer(Caller.Buffer, BufferLength);

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("HelgaINOUT","I_RpcSendReceive",Status);
        HelgaError();
        return;
        }
    else
        {
        Length = (unsigned long PAPI *) Caller.Buffer;
            swaplong(*Length) ;
        if (Caller.BufferLength != *Length)
            {
            OtherError("HelgaINOUT","BufferLength != *Length");
            HelgaError();
            return;
            }
        if (CheckBuffer(Caller.Buffer, Caller.BufferLength) != 0)
            {
            OtherError("HelgaINOUT","CheckBuffer Failed");
            HelgaError();
            return;
            }
        Status = I_RpcFreeBuffer(&Caller);
        if (Status)
            {
            ApiError("HelgaINOUT","I_RpcFreeBuffer",Status);
            HelgaError();
            return;
            }
        }
}

unsigned long
HelgaSizes[] =
{
    128, 256, 512, 1024, 1024*2, 1024*4, 1024*8,
    10000, 15000, 20000, 60000, 30000, 40000, 100000, 1024*82,
    0
};

#if 0
unsigned long
HelgaSizes[] =
{
    128, 128,
    0
};
#endif

void
TestHelgaInterface (
    RPC_BINDING_HANDLE HelgaBinding,
    unsigned long SizeUpperBound
    )
/*++

Routine Description:

    The various tests uses this routine to test the Helga interface in
    different scenarios.  We run each of the routines for a variety of
    input and output buffer sizes.  This is controlled by the array,
    HelgaSizes.

Arguments:

    HelgaBinding - Supplies the binding handle to use when calling each
        of the Helga caller stubs.

--*/
{
    int Count;

    Helga(HelgaBinding);

    for (Count = 0; HelgaSizes[Count] != 0; Count++)
        {
        if (HelgaSizes[Count] <= SizeUpperBound)
            {
            HelgaIN(HelgaBinding,HelgaSizes[Count]);
            }
        }

    for (Count = 0; HelgaSizes[Count] != 0; Count++)
        {
        if (HelgaSizes[Count] <= SizeUpperBound)
            {
            HelgaOUT(HelgaBinding,HelgaSizes[Count]);
            }
        }

    for (Count = 0; HelgaSizes[Count] != 0; Count++)
        {
        if (HelgaSizes[Count] <= SizeUpperBound)
            {
            HelgaINOUT(HelgaBinding,HelgaSizes[Count]);
            }
        }
}

RPC_CLIENT_INTERFACE HelgaInterfaceWrongTransferSyntax =
{
    sizeof(RPC_CLIENT_INTERFACE),
    {{1,2,2,{3,3,3,3,3,3,3,3}},
     {1,1}},
    {{0xb4537da9, 0x3d03, 0x4f6b, {0xb5, 0x94, 0x52, 0xb2, 0x87, 0x4e, 0xe9, 0xd0}},
     {1, 0}},
    0,
    0,
    0,
    0,
    0,
    RPC_INTERFACE_HAS_PIPES
};

RPC_CLIENT_INTERFACE HelgaInterfaceWrongGuid =
{
    sizeof(RPC_CLIENT_INTERFACE),
    {{1,2,4,{3,3,3,3,3,3,3,3}},
     {1,1}},
    {{0x8A885D04, 0x1CEB, 0x11C9, {0x9F, 0xE8, 0x08, 0x00, 0x2B, 0x10, 0x48, 0x60}},
     {2,0}},
    0,
    0,
    0,
    0,
    0,
    RPC_INTERFACE_HAS_PIPES
};


int
HelgaWrongInterfaceGuid (
    RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:

    This routine makes a remote procedure call using the wrong interface
    GUID (not supported by the server).  The call must fail, otherwise,
    there is a bug in the runtime. (Otherwise there are no bugs in the
    runtime -- I wish.)

Arguments:

    Binding - Supplies the binding handle to use in trying to make the
        remote procedure call.

Return Value:

    Zero will be returned in the call fails as expected.  Otherwise,
    non-zero will be returned.

--*/
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 0 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &HelgaInterfaceWrongGuid;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);
    if (Status == RPC_S_UNKNOWN_IF)
        return(0);

    Status = UclntSendReceive(&Caller);
    if (Status == RPC_S_UNKNOWN_IF)
        return(0);

    return(1);
}


int
HelgaWrongTransferSyntax (
    RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:

    This routine makes a remote procedure call using the wrong transfer
    syntax (not supported by the server).  The call must fail, otherwise,
    there is a bug in the runtime. (Otherwise there are no bugs in the
    runtime -- I wish.)

Arguments:

    Binding - Supplies the binding handle to use in trying to make the
        remote procedure call.

Return Value:

    Zero will be returned in the call fails as expected.  Otherwise,
    non-zero will be returned.

--*/
{
    RPC_MESSAGE Caller;

    Caller.Handle = Binding;
    Caller.BufferLength = 0;
    Caller.ProcNum = 0 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &HelgaInterfaceWrongTransferSyntax;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);
    if (Status == RPC_S_UNSUPPORTED_TRANS_SYN)
        return(0);

    Status = UclntSendReceive(&Caller);
    if (Status == RPC_S_UNSUPPORTED_TRANS_SYN)
        return(0);

    return(1);
}

/* --------------------------------------------------------------------

Sylvia Interface

-------------------------------------------------------------------- */

extern RPC_DISPATCH_TABLE SylviaDispatchTable;

RPC_CLIENT_INTERFACE SylviaInterfaceInformation =
{
    sizeof(RPC_CLIENT_INTERFACE),
    {{3,2,2,{1,1,1,1,1,1,1,1}},
     {1,1}},
    {{0x8A885D04, 0x1CEB, 0x11C9, {0x9F, 0xE8, 0x08, 0x00, 0x2B, 0x10, 0x48, 0x60}},
     {2, 0}},
    &SylviaDispatchTable,
    0,
    0,
    0,
    0,
    RPC_INTERFACE_HAS_PIPES
};

unsigned int
LocalSylviaCall (
    unsigned /*long*/ char Depth,
    unsigned /*long*/ char Breadth,
    unsigned /*long*/ char Count
    )
{
    if (Depth > 0)
        {
        if (Depth == Breadth)
            {
            Count = (unsigned char) LocalSylviaCall(Depth-1,Breadth,Count);
            }
        else
            Count = (unsigned char) LocalSylviaCall(Depth-1,Breadth,Count);
        }
    return(Count+1);
}


unsigned /*long*/ char // Specifies the new count of calls.
SylviaCall (
    RPC_BINDING_HANDLE Binding,
    unsigned /*long*/ char Depth, // Specifies the depth of recursion desired.
    unsigned /*long*/ char Breadth, // Specifies the breadth desired.
    unsigned /*long*/ char Count // Specifies the count of calls up to this point.
    )
{
    RPC_MESSAGE Caller;
    unsigned /*long*/ char PAPI * plScan, ReturnValue ;

    if ( NoCallBacksFlag != 0 )
        {
        return((unsigned char) LocalSylviaCall(Depth, Breadth, Count));
        }

    Caller.Handle = Binding;
    Caller.BufferLength = sizeof(unsigned /*long*/ char) *4+10240;
    Caller.ProcNum = 0 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &SylviaInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }


    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("SylviaCall","I_RpcGetBuffer",Status);
        SylviaError();
        return(0);
        }
    plScan = (unsigned /*long*/ char PAPI *) Caller.Buffer;
    plScan[0] = (unsigned char) Depth;
    plScan[1] = (unsigned char) Breadth;
    plScan[2] = (unsigned char) Count;

    Status = UclntSendReceive(&Caller);

    if (Status)
        {
        ApiError("SylviaCall","I_RpcSendReceive",Status);
        SylviaError();
        return(0);
        }

    plScan = (unsigned /*long*/ char PAPI *) Caller.Buffer;
    ReturnValue = *plScan;
    Status = I_RpcFreeBuffer(&Caller);
    if (Status)
        {
        ApiError("SylviaCall","I_RpcFreeBuffer",Status);
        SylviaError();
        return(0);
        }
    return(ReturnValue);
}

RPC_BINDING_HANDLE SylviaBinding;

unsigned int
SylviaCallbackUserCode (
    unsigned /*long*/ char Depth,
    unsigned /*long*/ char Breadth,
    unsigned /*long*/ char Count
    ); // Prototype to keep the compiler happy because we recursively call
       // this routine.

unsigned int
SylviaCallbackUserCode ( // The user code for SylviaCallback.
    unsigned /*long*/ char Depth,
    unsigned /*long*/ char Breadth,
    unsigned /*long*/ char Count
    )
{
    if (Depth > 0)
        {
        if (Depth == Breadth)
            {
            Count = (unsigned char) SylviaCallbackUserCode(Depth-1,Breadth,Count);
            }
        else
            Count = SylviaCall(SylviaBinding,Depth-1,Breadth,Count);
        }
    return(Count+1);
}

void __RPC_STUB
SylviaCallback (
    PRPC_MESSAGE Callee
    )
{
    unsigned /*long*/ char ReturnValue, PAPI *plScan;

    if ( Callee->ProcNum != 0 )
        {
        OtherError("SylviaCallback", "Callee->ProcNum != 0");
        SylviaError();
        }

    if ( RpcpMemoryCompare(Callee->RpcInterfaceInformation,
                &SylviaInterfaceInformation,
                sizeof(SylviaInterfaceInformation)) != 0 )
        {
        OtherError("SylviaCallback",
                "Callee->RpcInteraceInformation != &SylviaInterfaceInformation");
        SylviaError();
        }

    if (Callee->BufferLength != sizeof(unsigned /*long*/ char)*4+10240)
        {
        OtherError("SylviaCallback",
                "Callee->BufferLength != sizeof(unsigned int)*4");
        SylviaError();
        }

    plScan = (unsigned /*long*/ char PAPI *) Callee->Buffer;

    ReturnValue = (unsigned char) SylviaCallbackUserCode(plScan[0],plScan[1],plScan[2]);

    Callee->BufferLength = sizeof(unsigned char /*long*/);
    Status = I_RpcGetBuffer(Callee);

    if (Status)
        {
        ApiError("SylviaCallback","I_RpcGetBuffer",Status);
        SylviaError();
        }
    plScan = (unsigned /*long*/ char PAPI *) Callee->Buffer;
    *plScan = ReturnValue;
}

RPC_DISPATCH_FUNCTION SylviaDispatchFunction[] = {SylviaCallback};

RPC_DISPATCH_TABLE SylviaDispatchTable =
{
    1, SylviaDispatchFunction
};


void
GenerateUuidValue (
    IN unsigned short MagicNumber,
    OUT UUID PAPI * Uuid
    )
/*++

Routine Description:

    This routine is used to generate a value for a uuid.  The magic
    number argument is used in mysterious and wonderful ways to
    generate a uuid (which is not necessarily correct).

Arguments:

    MagicNumber - Supplies a magic number which will be used to
        generate a uuid.

    Uuid - Returns the generated uuid.

--*/
{

    Uuid->Data1= (unsigned long) MagicNumber * (unsigned long) MagicNumber ;
    //swaplong(Uuid->Data1) ;

    Uuid->Data2 = MagicNumber;
    Uuid->Data3 = MagicNumber / 2;

    //swapshort(Uuid->Data2) ;
    //swapshort(Uuid->Data3) ;

    Uuid->Data4[0] = MagicNumber % 256;
    Uuid->Data4[1] = MagicNumber % 257;
    Uuid->Data4[2] = MagicNumber % 258;
    Uuid->Data4[3] = MagicNumber % 259;
    Uuid->Data4[4] = MagicNumber % 260;
    Uuid->Data4[5] = MagicNumber % 261;
    Uuid->Data4[6] = MagicNumber % 262;
    Uuid->Data4[7] = MagicNumber % 263;
}


int
CheckUuidValue (
    IN unsigned short MagicNumber,
    OUT UUID PAPI * Uuid
    )
/*++

Routine Description:

    This routine is used to check that a generated uuid value is correct.

Arguments:

    MagicNumber - Supplies a magic number which will be used to
        check a generated uuid.

    Uuid - Supplies a generated uuid to check.

Return Value:

    Zero will be returned if the uuid value is correct; otherwise, non-zero
    will be returned.

--*/
{
 //   swaplong(Uuid->Data1) ;
    if ( Uuid->Data1 != ((unsigned long) MagicNumber)
                * ((unsigned long) MagicNumber))
        return(1);

//    swapshort(Uuid->Data2) ;
    if ( Uuid->Data2 != MagicNumber )
        return(1);

//    swapshort(Uuid->Data3) ;
    if ( Uuid->Data3 != MagicNumber / 2 )
        return(1);
    if ( Uuid->Data4[0] != MagicNumber % 256 )
        return(1);
    if ( Uuid->Data4[1] != MagicNumber % 257 )
        return(1);
    if ( Uuid->Data4[2] != MagicNumber % 258 )
        return(1);
    if ( Uuid->Data4[3] != MagicNumber % 259 )
        return(1);
    if ( Uuid->Data4[4] != MagicNumber % 260 )
        return(1);
    if ( Uuid->Data4[5] != MagicNumber % 261 )
        return(1);
    if ( Uuid->Data4[6] != MagicNumber % 262 )
        return(1);
    if ( Uuid->Data4[7] != MagicNumber % 263 )
        return(1);
    return(0);
}

static unsigned int TryFinallyCount;
static unsigned int TryFinallyFailed;

void
TheodoreTryFinally (
    unsigned int count,
    unsigned int raise
    )
{
    if (count == 0)
        {
        if (raise)
            RpcRaiseException(437);
        return;
        }

    RpcTryFinally
        {
        TryFinallyCount += 1;
        TheodoreTryFinally(count-1,raise);
        }
    RpcFinally
        {
        TryFinallyCount -= 1;
        if (   (RpcAbnormalTermination() && !raise)
            || (!RpcAbnormalTermination() && raise))
            TryFinallyFailed += 1;
        }
    RpcEndFinally
}

void
Theodore ( // This test checks the exception handling support provided
           // by the RPC runtime.  No remote procedure calls occur.
    )
{
    unsigned int TryFinallyPass = 0;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("Theodore : Verify exception handling support\n");

    TryFinallyCount = 0;
    TryFinallyFailed = 0;

    RpcTryExcept
        {
        RpcTryExcept
            {
            TheodoreTryFinally(20,1);
            }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
            if (   (RpcExceptionCode() == 437)
                && (TryFinallyCount == 0))
                TryFinallyPass = 1;
            }
        RpcEndExcept
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        PrintToConsole("Theodore : FAIL in RpcTryExcept (%u)\n",TryFinallyCount);
        return;
        }
    RpcEndExcept

    if (!TryFinallyPass)
        {
        PrintToConsole("Theodore : FAIL in RpcTryFinally\n");
        return;
        }

    if (TryFinallyFailed)
        {
        PrintToConsole("Theodore : FAIL in RpcTryFinally\n");
        return;
        }

    TryFinallyCount = 0;
    TryFinallyFailed = 0;

    RpcTryExcept
        {
        TheodoreTryFinally(20,0);
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        PrintToConsole("Theodore : FAIL in RpcTryExcept\n");
        return;
        }
    RpcEndExcept

    if (TryFinallyFailed)
        {
        PrintToConsole("Theodore : FAIL in RpcTryFinally\n");
        return;
        }


    PrintToConsole("Theodore : PASS\n");
}


void
Sebastian (
    )
/*++

Routine Description:

    We perform a build verification test in the routine.  This test
    checks for basic functionality of the runtime.  It works with
    Sigfried in usvr.exe.  This particular test is dedicated to a cat.

--*/
{
    RPC_BINDING_HANDLE HelgaBinding;
    RPC_BINDING_HANDLE IsabelleBinding;
    int HelgaCount;

    Synchro(SIGFRIED) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("Sebastian : Verify Basic Client Functionality\n");

    Status = GetBinding(SIGFRIED, &HelgaBinding);
    if (Status)
        {
        ApiError("Sebastian","GetBinding",Status);
        PrintToConsole("Sebastian : FAIL - Unable to Bind (Sigfried)\n");
        return;
        }

    Status = GetBinding(SIGFRIED, &IsabelleBinding);
    if (Status)
        {
        ApiError("Sebastian","GetBinding",Status);
        PrintToConsole("Sebastian : FAIL - Unable to Bind (Sigfried)\n");
        return;
        }

    for (HelgaCount = 0; HelgaCount < 100; HelgaCount++)
        {
        Status = RpcBindingFree(&HelgaBinding);
        if (Status)
            {
            ApiError("Sebastian","RpcBindingFree",Status);
            PrintToConsole("Sebastian : FAIL - Unable to Free Binding");
            PrintToConsole(" (HelgaBinding)\n");
            return;
            }

        Status = GetBinding(SIGFRIED, &HelgaBinding);
        if (Status)
            {
            ApiError("Sebastian","GetBinding",Status);
            PrintToConsole("Sebastian : FAIL - Unable to Bind (Sigfried)\n");
            return;
            }

        Helga(HelgaBinding);
        }

    TestHelgaInterface(HelgaBinding, HelgaMaxSize);


    IsabelleShutdown(IsabelleBinding);
    if (HelgaErrors != 0)
        {
        PrintToConsole("Sebastian : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcBindingFree(&HelgaBinding);
    if (Status)
        {
        ApiError("Sebastian","RpcBindingFree",Status);
        PrintToConsole("Sebastian : FAIL - Unable to Free Binding");
        PrintToConsole(" (HelgaBinding)\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Sebastian : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&IsabelleBinding);
    if (Status)
        {
        ApiError("Sebastian","RpcBindingFree",Status);
        PrintToConsole("Sebastian : FAIL - Unable to Free Binding");
        PrintToConsole(" (IsabelleBinding)\n");
        return;
        }

    PrintToConsole("Sebastian : PASS\n");
}

void
Pipe (
    )
/*++

Routine Description:

    We perform a build verification test in the routine.  This test
    checks for basic functionality of the runtime.  It works with
    Sigfried in usvr.exe.  This particular test is dedicated to a cat.

--*/
{
    RPC_BINDING_HANDLE IsabelleBinding;
    pipe_t pipe ;
    int state ;
    int local_buf[BUFF_SIZE] ;
    int i ;
    long checksum ;

    Synchro(SPIPE) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("PIPE : Verify Basic Client Functionality\n");

    Status = GetBinding(SPIPE, &IsabelleBinding);
    if (Status)
        {
        ApiError("PIPE","GetBinding",Status);
        PrintToConsole("PIPE : FAIL - Unable to Bind (Sigfried)\n");
        return;
        }

    pipe.Alloc = PipeAlloc ;
    pipe.Pull = PipePull ;
    pipe.Push = PipePush ;
    pipe.state = (char PAPI *) &state ;

    for (i = 0; i < BUFF_SIZE; i++)
        {
        local_buf[i] = i ;
        }

    state = NUM_CHUNKS ;
    checksum = (long) (CHUNK_SIZE-1) * (long) CHUNK_SIZE /2  *
                        (long) NUM_CHUNKS ;
    IsabellePipeIN(IsabelleBinding, &pipe,
                        CHUNK_SIZE, NUM_CHUNKS, checksum,
                        BUFF_SIZE * sizeof(int), (char PAPI *) local_buf) ;

    if (IsabelleErrors != 0)
        {
        PrintToConsole("PIPE : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    IsabellePipeOUT(IsabelleBinding, &pipe, CHUNK_SIZE) ;
    if (IsabelleErrors != 0)
        {
        PrintToConsole("PIPE : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    state = NUM_CHUNKS ;
    IsabellePipeINOUT(IsabelleBinding, &pipe, CHUNK_SIZE, checksum) ;
    if (IsabelleErrors != 0)
        {
        PrintToConsole("PIPE : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    IsabelleShutdown(IsabelleBinding);

    if (IsabelleErrors != 0)
        {
        PrintToConsole("PIPE : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&IsabelleBinding);
    if (Status)
        {
        ApiError("PIPE","RpcBindingFree",Status);
        PrintToConsole("PIPE : FAIL - Unable to Free Binding");
        PrintToConsole(" (IsabelleBinding)\n");
        return;
        }

    PrintToConsole("PIPE : PASS\n");
}

void
LpcSecurityHelper (
    BOOL fAsync,
    BOOL fDynamic
    )
{
    RPC_SECURITY_QOS QOS;
    RPC_BINDING_HANDLE HelgaBinding;

    Status = GetBinding(SIGFRIED, &HelgaBinding);
    if (Status)
        {
        ApiError("LpcSecurity","GetBinding",Status);
        PrintToConsole("LpcSecurity : FAIL - Unable to Bind (Sigfried)\n");
        return;
        }


    QOS.Version = RPC_C_SECURITY_QOS_VERSION;
    QOS.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;
    QOS.Capabilities = RPC_C_QOS_CAPABILITIES_DEFAULT;

    if (fDynamic)
        {
        QOS.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
        }
    else
        {
        QOS.IdentityTracking = RPC_C_QOS_IDENTITY_STATIC;
        }

    Status = RpcBindingSetAuthInfoEx(
                          HelgaBinding,
                          RPC_STRING_LITERAL("ServerPrincipal"),
                          RPC_C_AUTHN_LEVEL_CONNECT,
                          10,
                          NULL,
                          0,
                          &QOS);
    if (Status != RPC_S_OK)
        {
        ApiError("LpcSecurity","RpcBindingSetAuthInfoEx",Status);
        goto Cleanup;
        }


    //
    // Logon as local administrator and call again
    //
    HANDLE hToken;

    if (LogonUser(
              RPC_T("Administrator"),
              NULL,
              RPC_T(""),
              LOGON32_LOGON_BATCH,
              LOGON32_PROVIDER_DEFAULT,
              &hToken) == 0)
        {
        ApiError("LpcSecurity","LogonUser",GetLastError());
        goto Cleanup;
        }

    if (ImpersonateLoggedOnUser(hToken) == 0)
        {
        ApiError("LpcSecurity","LogonUser",GetLastError());
        goto Cleanup;
        }

    if (fDynamic)
        {
        PrintToConsole("LpcSecurity: Expected: Administrator\n");
        }
    else
        {
        PrintToConsole("LpcSecurity: Expected: REDMOND\\mazharm\n");
        }

    HelgaLpcSecurity(HelgaBinding, fAsync) ;

    RevertToSelf();

    PrintToConsole("LpcSecurity: Expected: REDMOND\\mazharm\n");
    HelgaLpcSecurity(HelgaBinding, fAsync) ;

    CloseHandle(hToken);

Cleanup:
    Status = RpcBindingFree(&HelgaBinding);
    if (Status)
        {
        ApiError("LpcSecurity","RpcBindingFree",Status);
        PrintToConsole("LpcSecurity : FAIL - Unable to Free Binding");
        PrintToConsole(" (HelgaBinding)\n");
        return;
        }
}

void
LpcSecurityTwoHandles (
    BOOL fAsync
    )
{
    RPC_SECURITY_QOS QOS;
    RPC_BINDING_HANDLE HelgaBinding;
    RPC_BINDING_HANDLE HelgaBinding1;

    Status = GetBinding(SIGFRIED, &HelgaBinding);
    if (Status)
        {
        ApiError("LpcSecurity","GetBinding",Status);
        PrintToConsole("LpcSecurity : FAIL - Unable to Bind (Sigfried)\n");
        return;
        }

    Status = GetBinding(SIGFRIED, &HelgaBinding1);
    if (Status)
        {
        ApiError("LpcSecurity","GetBinding",Status);
        PrintToConsole("LpcSecurity : FAIL - Unable to Bind (Sigfried)\n");
        return;
        }

    QOS.Version = RPC_C_SECURITY_QOS_VERSION;
    QOS.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;
    QOS.Capabilities = RPC_C_QOS_CAPABILITIES_DEFAULT;
    QOS.IdentityTracking = RPC_C_QOS_IDENTITY_STATIC;

    Status = RpcBindingSetAuthInfoExA(
                          HelgaBinding,
                          (unsigned char *) "ServerPrincipal",
                          RPC_C_AUTHN_LEVEL_CONNECT,
                          10,
                          NULL,
                          0,
                          &QOS);
    if (Status != RPC_S_OK)
        {
        ApiError("LpcSecurity","RpcBindingSetAuthInfoEx",Status);
        goto Cleanup;
        }

    //
    // Logon as local administrator and call again
    //
    HANDLE hToken;

    if (LogonUserA(
              "Administrator",
              NULL,
              "",
              LOGON32_LOGON_BATCH,
              LOGON32_PROVIDER_DEFAULT,
              &hToken) == 0)
        {
        ApiError("LpcSecurity","LogonUser",GetLastError());
        goto Cleanup;
        }

    if (ImpersonateLoggedOnUser(hToken) == 0)
        {
        ApiError("LpcSecurity","LogonUser",GetLastError());
        goto Cleanup;
        }

    QOS.Version = RPC_C_SECURITY_QOS_VERSION;
    QOS.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;
    QOS.Capabilities = RPC_C_QOS_CAPABILITIES_DEFAULT;
    QOS.IdentityTracking = RPC_C_QOS_IDENTITY_STATIC;

    Status = RpcBindingSetAuthInfoExA(
                          HelgaBinding1,
                          (unsigned char *) "ServerPrincipal",
                          RPC_C_AUTHN_LEVEL_CONNECT,
                          10,
                          NULL,
                          0,
                          &QOS);
    if (Status != RPC_S_OK)
        {
        ApiError("LpcSecurity","RpcBindingSetAuthInfoEx",Status);
        goto Cleanup;
        }

    PrintToConsole("LpcSecurity: Expected: REDMOND\\mazharm\n");
    HelgaLpcSecurity(HelgaBinding, fAsync);


    PrintToConsole("LpcSecurity: Expected: Administrator\n");
    HelgaLpcSecurity(HelgaBinding1, fAsync);

    RevertToSelf();

    PrintToConsole("LpcSecurity: Expected: REDMOND\\mazharm\n");
    HelgaLpcSecurity(HelgaBinding, fAsync) ;


    PrintToConsole("LpcSecurity: Expected: Administrator\n");
    HelgaLpcSecurity(HelgaBinding1, fAsync);

    CloseHandle(hToken);

Cleanup:
    Status = RpcBindingFree(&HelgaBinding);
    if (Status)
        {
        ApiError("LpcSecurity","RpcBindingFree",Status);
        PrintToConsole("LpcSecurity : FAIL - Unable to Free Binding");
        PrintToConsole(" (HelgaBinding)\n");
        return;
        }
    Status = RpcBindingFree(&HelgaBinding1);
    if (Status)
        {
        ApiError("LpcSecurity","RpcBindingFree",Status);
        PrintToConsole("LpcSecurity : FAIL - Unable to Free Binding");
        PrintToConsole(" (HelgaBinding)\n");
        return;
        }
}

void
LpcSecurity (
    )
/*++

Routine Description:

    We perform a build verification test in the routine.  This test
    checks for basic functionality of the runtime.  It works with
    Sigfried in usvr.exe.  This particular test is dedicated to a cat.

--*/
{
    RPC_BINDING_HANDLE IsabelleBinding;
    int HelgaCount;

    Synchro(SIGFRIED) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("LpcSecurity : Verify Basic Client Functionality\n");

    Status = GetBinding(SIGFRIED, &IsabelleBinding);
    if (Status)
        {
        ApiError("LpcSecurity","GetBinding",Status);
        PrintToConsole("LpcSecurity : FAIL - Unable to Bind (Sigfried)\n");
        return;
        }

#if 0
    //
    // Sync call with static
    //
    PrintToConsole("LpcSecurity: Sync call with static tracking\n");
    LpcSecurityHelper(0, 0);
#endif

    //
    // Sync call with dynamic binding
    //
    PrintToConsole("LpcSecurity: Sync call with dynamic tracking\n");
    LpcSecurityHelper(0, 1);

#if 0
    //
    // Async call with static binding
    //
    PrintToConsole("LpcSecurity: Async call with static tracking \n");
    LpcSecurityHelper(1, 0);
#endif

    //
    // Async call with dynamic binding
    //
    PrintToConsole("LpcSecurity: Async call with dynamic tracking \n");

    LpcSecurityHelper(1, 1);

#if 0
    //
    // Async call with static,using two handles
    //
    LpcSecurityTwoHandles(1);

    //
    // Sync call with static using two handle
    //
    LpcSecurityTwoHandles(0);
#endif

    IsabelleShutdown(IsabelleBinding);
    if (HelgaErrors != 0)
        {
        PrintToConsole("LpcSecurity : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("LpcSecurity : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&IsabelleBinding);
    if (Status)
        {
        ApiError("LpcSecurity","RpcBindingFree",Status);
        PrintToConsole("LpcSecurity : FAIL - Unable to Free Binding");
        PrintToConsole(" (IsabelleBinding)\n");
        return;
        }

    PrintToConsole("LpcSecurity : PASS\n");
}


RPC_STATUS
UclntGetBufferWithObject (
    IN OUT PRPC_MESSAGE RpcMessage,
    IN UUID *ObjectUuid
    )
/*++

Routine Description:

    This routine takes care of retrying to getting a buffer.

Arguments:

    RpcMessage - Supplies and returns the message for I_RpcGetBuffer.

Return Value:

    The result of I_RpcGetBuffer will be returned.

--*/
{
    unsigned int RetryCount;

    for (RetryCount = 0; RetryCount < RETRYCOUNT; RetryCount++)
        {
        Status = I_RpcGetBufferWithObject(RpcMessage, ObjectUuid);
        if (   (Status != RPC_S_SERVER_TOO_BUSY)
            && (Status != RPC_S_CALL_FAILED_DNE))
            break;
        PauseExecution(RETRYDELAY);
        }
    return(Status);
}


void
HelgaObjectUuids (
    RPC_BINDING_HANDLE HelgaBinding,
    UUID *ObjectUuid
    )
{
    RPC_MESSAGE Caller;

    Caller.Handle = HelgaBinding;
    Caller.BufferLength = sizeof(BOOL)+sizeof(UUID);
    Caller.ProcNum = 8 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &HelgaInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }

    if (ObjectUuid)
        {
        Status = UclntGetBufferWithObject(&Caller, ObjectUuid);
        }
    else
        {
        Status = UclntGetBuffer(&Caller);
        }

    if (Status)
        {
        ApiError("Helga","I_RpcGetBuffer",Status);
        HelgaError();
        return;
        }

    char *Ptr = (char *) Caller.Buffer;
    if (ObjectUuid)
        {
        *((LONG *) Ptr) = 1;
        Ptr += sizeof(BOOL);
        RpcpMemoryCopy(Ptr, ObjectUuid, sizeof(UUID));
        }
    else
        {
        *((LONG *) Ptr) = 0;
        }

    Status = UclntSendReceive(&Caller);
    if (Status)
        {
        ApiError("Helga","I_RpcSendReceive",Status);
        HelgaError();
        return;
        }

    if (Caller.BufferLength != 0)
        {
        OtherError("Helga","BufferLength != 0");
        HelgaError();
        return;
        }

    Status = I_RpcFreeBuffer(&Caller);
    if (Status)
        {
        ApiError("Helga","I_RpcFreeBuffer",Status);
        HelgaError();
        return;
        }
}

void
TestObjectUuids (
    )
/*++

Routine Description:

    We perform a build verification test in the routine.  This test
    checks for basic functionality of the runtime.  It works with
    Sigfried in usvr.exe.  This particular test is dedicated to a cat.

--*/
{
    RPC_BINDING_HANDLE HelgaBinding;
    RPC_BINDING_HANDLE IsabelleBinding;
    int HelgaCount;

    Synchro(SIGFRIED) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("TestObjectUuids : Verify Basic Client Functionality\n");

    Status = GetBinding(SIGFRIED, &HelgaBinding);
    if (Status)
        {
        ApiError("TestObjectUuids","GetBinding",Status);
        PrintToConsole("TestObjectUuids : FAIL - Unable to Bind (Sigfried)\n");
        return;
        }


    Status = GetBinding(SIGFRIED, &IsabelleBinding);
    if (Status)
        {
        ApiError("TestObjectUuids","GetBinding",Status);
        PrintToConsole("TestObjectUuids : FAIL - Unable to Bind (Sigfried)\n");
        return;
        }

    HelgaObjectUuids(HelgaBinding, 0);

    UUID MyUuid;

    RpcpMemorySet(&MyUuid, 'M', sizeof(UUID));
    HelgaObjectUuids(HelgaBinding, &MyUuid);

    HelgaObjectUuids(HelgaBinding, 0);

    IsabelleShutdown(IsabelleBinding);
    if (HelgaErrors != 0)
        {
        PrintToConsole("TestObjectUuids : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcBindingFree(&HelgaBinding);
    if (Status)
        {
        ApiError("TestObjectUuids","RpcBindingFree",Status);
        PrintToConsole("TestObjectUuids : FAIL - Unable to Free Binding");
        PrintToConsole(" (HelgaBinding)\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("TestObjectUuids : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&IsabelleBinding);
    if (Status)
        {
        ApiError("TestObjectUuids","RpcBindingFree",Status);
        PrintToConsole("TestObjectUuids : FAIL - Unable to Free Binding");
        PrintToConsole(" (IsabelleBinding)\n");
        return;
        }

    PrintToConsole("TestObjectUuids : PASS\n");
}

void
HelgaConnId (
    RPC_BINDING_HANDLE HelgaBinding,
    BOOL fNewConnExpected
    )
{
    RPC_MESSAGE Caller;

    Caller.Handle = HelgaBinding;
    Caller.BufferLength = sizeof(BOOL)+sizeof(UUID);
    Caller.ProcNum = 9 | HackForOldStubs ;
    Caller.RpcInterfaceInformation = &HelgaInterfaceInformation;
    Caller.RpcFlags = 0;
    if (IdempotentTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }
    if (MaybeTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_MAYBE;
        }
    if (BroadcastTests != 0)
        {
          Caller.RpcFlags |= RPC_NCA_FLAGS_BROADCAST;
        }

    Status = UclntGetBuffer(&Caller);

    if (Status)
        {
        ApiError("Helga","I_RpcGetBuffer",Status);
        HelgaError();
        return;
        }

    char *Ptr = (char *) Caller.Buffer;
    *((BOOL *) Ptr) = fNewConnExpected;

    Status = UclntSendReceive(&Caller);
    if (Status)
        {
        ApiError("Helga","I_RpcSendReceive",Status);
        HelgaError();
        return;
        }

    if (Caller.BufferLength != 0)
        {
        OtherError("Helga","BufferLength != 0");
        HelgaError();
        return;
        }

    Status = I_RpcFreeBuffer(&Caller);
    if (Status)
        {
        ApiError("Helga","I_RpcFreeBuffer",Status);
        HelgaError();
        return;
        }
}

void
TestConnId (
    )
/*++

Routine Description:

    We perform a build verification test in the routine.  This test
    checks for basic functionality of the runtime.  It works with
    Sigfried in usvr.exe.  This particular test is dedicated to a cat.

--*/
{
    RPC_BINDING_HANDLE HelgaBinding;
    RPC_BINDING_HANDLE IsabelleBinding;
    int HelgaCount;

    Synchro(SIGFRIED) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("TestConnId : Verify Basic Client Functionality\n");

    Status = GetBinding(SIGFRIED, &HelgaBinding);
    if (Status)
        {
        ApiError("TestConnId","GetBinding",Status);
        PrintToConsole("TestConnId : FAIL - Unable to Bind (Sigfried)\n");
        return;
        }


    Status = GetBinding(SIGFRIED, &IsabelleBinding);
    if (Status)
        {
        ApiError("TestConnId","GetBinding",Status);
        PrintToConsole("TestConnId : FAIL - Unable to Bind (Sigfried)\n");
        return;
        }

    HelgaConnId(HelgaBinding, 1);
    HelgaConnId(HelgaBinding, 0);

    RpcBindingFree(&HelgaBinding);

    Status = GetBinding(SIGFRIED, &HelgaBinding);
    if (Status)
        {
        ApiError("TestConnId","GetBinding",Status);
        PrintToConsole("TestConnId : FAIL - Unable to Bind (Sigfried)\n");
        return;
        }

    HelgaConnId(HelgaBinding, 1);
    HelgaConnId(HelgaBinding, 0);

    IsabelleShutdown(IsabelleBinding);
    if (HelgaErrors != 0)
        {
        PrintToConsole("TestConnId : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcBindingFree(&HelgaBinding);
    if (Status)
        {
        ApiError("TestConnId","RpcBindingFree",Status);
        PrintToConsole("TestConnId : FAIL - Unable to Free Binding");
        PrintToConsole(" (HelgaBinding)\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("TestConnId : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&IsabelleBinding);
    if (Status)
        {
        ApiError("TestConnId","RpcBindingFree",Status);
        PrintToConsole("TestConnId : FAIL - Unable to Free Binding");
        PrintToConsole(" (IsabelleBinding)\n");
        return;
        }

    PrintToConsole("TestConnId : PASS\n");
}

void
Hybrid (
    )
/*++

Routine Description:

    We perform a build verification test in the routine.  This test
    checks for basic functionality of the runtime.  It works with
    Hybrid in usvr.exe.  This particular test is dedicated to a cat.

--*/
{
    RPC_BINDING_HANDLE HelgaBinding;
    RPC_BINDING_HANDLE IsabelleBinding;
    int HelgaCount;

    Synchro(SIGFRIED) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("Hybrid : Verify Basic Client Functionality\n");

    Status = GetBinding(SIGFRIED, &HelgaBinding);
    if (Status)
        {
        ApiError("Hybrid","GetBinding",Status);
        PrintToConsole("Hybrid : FAIL - Unable to Bind (Sigfried)\n");
        return;
        }


    Status = GetBinding(SIGFRIED, &IsabelleBinding);
    if (Status)
        {
        ApiError("Hybrid","GetBinding",Status);
        PrintToConsole("Hybrid : FAIL - Unable to Bind (Sigfried)\n");
        return;
        }


    for (HelgaCount = 0; HelgaCount < 30; HelgaCount++)
        {
        Helga(HelgaBinding);

        IsabelleUnregisterInterfaces(IsabelleBinding) ;

        HelgaMustFail(HelgaBinding) ;

        IsabelleRegisterInterfaces(IsabelleBinding) ;
        }

    for (HelgaCount = 0; HelgaCount < 5; HelgaCount++)
        {
        TestHelgaInterface(HelgaBinding, HelgaMaxSize);

        IsabelleUnregisterInterfaces(IsabelleBinding) ;

        HelgaMustFail(HelgaBinding) ;

        IsabelleRegisterInterfaces(IsabelleBinding) ;
        }

    IsabelleShutdown(IsabelleBinding);
    if (HelgaErrors != 0)
        {
        PrintToConsole("Hybrid : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcBindingFree(&HelgaBinding);
    if (Status)
        {
        ApiError("Hybrid","RpcBindingFree",Status);
        PrintToConsole("Hybrid : FAIL - Unable to Free Binding");
        PrintToConsole(" (HelgaBinding)\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Hybrid : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&IsabelleBinding);
    if (Status)
        {
        ApiError("Hybrid","RpcBindingFree",Status);
        PrintToConsole("Hybrid : FAIL - Unable to Free Binding");
        PrintToConsole(" (IsabelleBinding)\n");
        return;
        }

    PrintToConsole("Hybrid : PASS\n");
}

void
Graham (
    )
/*++

Routine Description:

    We perform a build verification test in the routine.  This test
    checks for basic functionality of the runtime.  It works with
    Grant in usvr.exe.  This particular test is dedicated to a cat.

--*/
{
    RPC_BINDING_HANDLE HelgaBinding;
    RPC_BINDING_HANDLE IsabelleBinding;
    UUID ObjectUuid;
    unsigned short MagicValue;
    unsigned int Count;

    Synchro(GRANT) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("Graham : Verify Basic Client Functionality\n");

    Status = GetBinding(GRANT, &HelgaBinding);
    if (Status)
        {
        ApiError("Graham","GetBinding",Status);
        PrintToConsole("Graham : FAIL - Unable to Bind (Grant)\n");
        return;
        }


    Status = GetBinding(GRANT, &IsabelleBinding);
    if (Status)
        {
        ApiError("Graham","GetBinding",Status);
        PrintToConsole("Graham : FAIL - Unable to Bind (Grant)\n");
        return;
        }

    MagicValue = 106;

    GenerateUuidValue(MagicValue, &ObjectUuid);
    Status = RpcBindingSetObject(HelgaBinding, &ObjectUuid);
    if (Status)
        {
        ApiError("Graham", "RpcBindingSetObject", Status);
        PrintToConsole("Graham : FAIL - Unable to Set Object\n");
        return;
        }
    MagicValue += 1;

    Helga(HelgaBinding);

    GenerateUuidValue(MagicValue, &ObjectUuid);
    Status = RpcBindingSetObject(HelgaBinding, &ObjectUuid);
    if (Status)
        {
        ApiError("Graham", "RpcBindingSetObject", Status);
        PrintToConsole("Graham : FAIL - Unable to Set Object\n");
        return;
        }
    MagicValue += 1;

    for (Count = 0; HelgaSizes[Count] != 0; Count++)
        {
        if (HelgaSizes[Count] > HelgaMaxSize)
            continue;

        HelgaIN(HelgaBinding,HelgaSizes[Count]);

        GenerateUuidValue(MagicValue, &ObjectUuid);
        Status = RpcBindingSetObject(HelgaBinding, &ObjectUuid);
        if (Status)
            {
            ApiError("Graham", "RpcBindingSetObject", Status);
            PrintToConsole("Graham : FAIL - Unable to Set Object\n");
            return;
            }
        MagicValue += 1;
        }

    for (Count = 0; HelgaSizes[Count] != 0; Count++)
        {
        if (HelgaSizes[Count] > HelgaMaxSize)
            continue;

        HelgaOUT(HelgaBinding,HelgaSizes[Count]);

        GenerateUuidValue(MagicValue, &ObjectUuid);
        Status = RpcBindingSetObject(HelgaBinding, &ObjectUuid);
        if (Status)
            {
            ApiError("Graham", "RpcBindingSetObject", Status);
            PrintToConsole("Graham : FAIL - Unable to Set Object\n");
            return;
            }
        MagicValue += 1;
        }

    for (Count = 0; HelgaSizes[Count] != 0; Count++)
        {
        if (HelgaSizes[Count] > HelgaMaxSize)
            continue;

        HelgaINOUT(HelgaBinding,HelgaSizes[Count]);

        GenerateUuidValue(MagicValue, &ObjectUuid);
        Status = RpcBindingSetObject(HelgaBinding, &ObjectUuid);
        if (Status)
            {
            ApiError("Graham", "RpcBindingSetObject", Status);
            PrintToConsole("Graham : FAIL - Unable to Set Object\n");
            return;
            }
        MagicValue += 1;
        }

    IsabelleShutdown(IsabelleBinding);

    if (HelgaErrors != 0)
        {
        PrintToConsole("Graham : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    Status = RpcBindingFree(&HelgaBinding);
    if (Status)
        {
        ApiError("Graham","RpcBindingFree",Status);
        PrintToConsole("Graham : FAIL - Unable to Free Binding");
        PrintToConsole(" (HelgaBinding)\n");
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Graham : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&IsabelleBinding);
    if (Status)
        {
        ApiError("Graham","RpcBindingFree",Status);
        PrintToConsole("Graham : FAIL - Unable to Free Binding");
        PrintToConsole(" (IsabelleBinding)\n");
        return;
        }

    PrintToConsole("Graham : PASS\n");
}


void
Edward (
    )
/*++

Routine Description:

    This routine verifies server support of multiple addresses and
    interfaces, as well as callbacks.  In addition, we test binding
    here as well.  This test works with Elliot in usvr.exe.

--*/
{
    RPC_BINDING_HANDLE IsabelleBinding;
    RPC_BINDING_HANDLE SylviaMinimize;
    RPC_BINDING_HANDLE SylviaMaximize;
    RPC_BINDING_HANDLE HelgaMinimize;
    RPC_BINDING_HANDLE HelgaMaximize;
    RPC_BINDING_HANDLE EdwardMinimize;
    RPC_BINDING_HANDLE EdwardNormal;
    RPC_BINDING_HANDLE EdwardMaximize;

    Synchro(ELLIOTMINIMIZE) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("Edward : Verify Callbacks, Multiple Addresses");
    PrintToConsole(", and Multiple Interfaces\n");

    Status = GetBinding(ELLIOTMINIMIZE, &SylviaMinimize);
    if (Status)
        {
        ApiError("Edward","GetBinding",Status);
        PrintToConsole("Edward : FAIL - Unable to Bind (Elliot Minimize)\n");
        return;
        }


    Status = GetBinding(ELLIOTMAXIMIZE, &SylviaMaximize);
    if (Status)
        {
        ApiError("Edward","GetBinding",Status);
        PrintToConsole("Edward : FAIL - Unable to Bind (Elliot Maximize)\n");
        return;
        }

    Status = GetBinding(ELLIOTMINIMIZE, &HelgaMinimize);
    if (Status)
        {
        ApiError("Edward","GetBinding",Status);
        PrintToConsole("Edward : FAIL - Unable to Bind (Elliot Minimize)\n");
        return;
        }


    Status = GetBinding(ELLIOTMAXIMIZE, &HelgaMaximize);
    if (Status)
        {
        ApiError("Edward","GetBinding",Status);
        PrintToConsole("Edward : FAIL - Unable to Bind (ElliotMaximize)\n");
        return;
        }

    Status = GetBinding(ELLIOTMAXIMIZE, &IsabelleBinding);
    if (Status)
        {
        ApiError("Edward","GetBinding",Status);
        PrintToConsole("Edward : FAIL - Unable to Bind (Elliot Maximize)\n");
        return;
        }

    // First, we will test callbacks.

    SylviaBinding = SylviaMinimize;

    if (SylviaCall(SylviaBinding,5,0,0) != LocalSylviaCall(5,0,0))
        {
        PrintToConsole("Edward : FAIL - Incorrect result");
        PrintToConsole(" from SylviaCall(5,0,0)\n");
        return;
        }


    if (SylviaCall(SylviaBinding,10,5,0) != LocalSylviaCall(10,5,0))
        {
        PrintToConsole("Edward : FAIL - Incorrect result");
        PrintToConsole(" from SylviaCall(10,5,0)\n");
        return;
        }

    // And then we will test callbacks again using the maximize address.

    SylviaBinding = SylviaMaximize;

    if (SylviaCall(SylviaBinding,5,0,0) != LocalSylviaCall(5,0,0))
        {
        PrintToConsole("Edward : FAIL - Incorrect result from");
        PrintToConsole(" SylviaCall(5,0,0)\n");
        return;
        }

    if (SylviaCall(SylviaBinding,10,5,0) != LocalSylviaCall(10,5,0))
        {
        PrintToConsole("Edward : FAIL - Incorrect result");
        PrintToConsole(" from SylviaCall(10,5,0)\n");
        return;
        }

    // Ok, now we will insure that the Helga interface works.

    Helga(HelgaMinimize);
    HelgaIN(HelgaMinimize,1024*4);
    HelgaOUT(HelgaMinimize,1024*8);
    HelgaINOUT(HelgaMinimize,1024*16);

    Helga(HelgaMaximize);
    HelgaIN(HelgaMaximize,1024*4);
    HelgaOUT(HelgaMaximize,1024*8);
    HelgaINOUT(HelgaMaximize,1024*16);

    if (HelgaErrors != 0)
        {
        PrintToConsole("Edward : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    // Now we want to unbind both Sylvia binding handles, and then try
    // the Helga interface again.

    if (SylviaErrors != 0)
        {
        PrintToConsole("Edward : FAIL - Error(s) in Sylvia Interface\n");
        SylviaErrors = 0;
        return;
        }

    Status = RpcBindingFree(&SylviaMinimize);
    if (Status)
        {
        ApiError("Edward","RpcBindingFree",Status);
        PrintToConsole("Edward : FAIL - Unable to Free Binding ");
        PrintToConsole("(SylviaMinimize)\n");
        return;
        }

    Status = RpcBindingFree(&SylviaMaximize);
    if (Status)
        {
        ApiError("Edward","RpcBindingFree",Status);
        PrintToConsole("Edward : FAIL - Unable to Free Binding");
        PrintToConsole(" (SylviaMaximize)\n");
        return;
        }

    // Ok, now we will insure that the Helga interface still works.

    Helga(HelgaMinimize);
    HelgaIN(HelgaMinimize,1024*2);
    HelgaOUT(HelgaMinimize,1024*4);
    HelgaINOUT(HelgaMinimize,1024*8);

    Helga(HelgaMaximize);
    HelgaIN(HelgaMaximize,1024*2);
    HelgaOUT(HelgaMaximize,1024*4);
    HelgaINOUT(HelgaMaximize,1024*8);

    if (HelgaErrors != 0)
        {
        PrintToConsole("Edward : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    // Now we need to test the binding stuff.

    Status = GetBinding(ELLIOTMINIMIZE, &EdwardMinimize);
    if (Status)
        {
        ApiError("Edward","GetBinding",Status);
        PrintToConsole("Edward : FAIL - Unable to Bind (Elliot Minimize)\n");
        return;
        }

    Status = GetBinding(ELLIOTNORMAL, &EdwardNormal);
    if (Status)
        {
        ApiError("Edward","GetBinding",Status);
        PrintToConsole("Edward : FAIL - Unable to Bind (Elliot Normal)\n");
        return;
        }

    Status = GetBinding(ELLIOTMAXIMIZE, &EdwardMaximize);
    if (Status)
        {
        ApiError("Edward","GetBinding",Status);
        PrintToConsole("Edward : FAIL - Unable to Bind (Elliot Maximize)\n");
        return;
        }

    if (HelgaWrongInterfaceGuid(EdwardMinimize))
        {
        PrintToConsole("Edward : FAIL - HelgaWrongInterfaceGuid Succeeded\n");
        return;
        }

    if (HelgaWrongInterfaceGuid(EdwardNormal))
        {
        PrintToConsole("Edward : FAIL - HelgaWrongInterfaceGuid Succeeded\n");
        return;
        }

    if (HelgaWrongInterfaceGuid(EdwardMaximize))
        {
        PrintToConsole("Edward : FAIL - HelgaWrongInterfaceGuid Succeeded\n");
        return;
        }

    //Skip over the WrongTransfer Syntax tests for Datagram
    //Datagram doesnt req. any checks on Transfer syntaxes

    if (DatagramTests == 0)
        {
        if (HelgaWrongTransferSyntax(EdwardMinimize))
           {
           PrintToConsole("Edward : FAIL - HelgaWrongTransferSyntax");
           PrintToConsole(" Succeeded\n");
           return;
           }

        if (HelgaWrongTransferSyntax(EdwardNormal))
           {
           PrintToConsole("Edward : FAIL - HelgaWrongTransferSyntax");
           PrintToConsole(" Succeeded\n");
           return;
           }

        if (HelgaWrongTransferSyntax(EdwardMaximize))
           {
           PrintToConsole("Edward : FAIL - HelgaWrongTransferSyntax");
           PrintToConsole(" Succeeded\n");
           return;
           }
        }
    Status = RpcBindingFree(&EdwardMinimize);
    if (Status)
        {
        PrintToConsole("Edward : FAIL - Unable to Free Binding ");
        PrintToConsole("(EdwardMinimize)\n");
        return;
        }

    Status = RpcBindingFree(&EdwardNormal);
    if (Status)
        {
        PrintToConsole("Edward : FAIL - Unable to Free Binding ");
        PrintToConsole("(EdwardNormal)\n");
        return;
        }

    Status = RpcBindingFree(&EdwardMaximize);
    if (Status)
        {
        PrintToConsole("Edward : FAIL - Unable to Free Binding ");
        PrintToConsole("(EdwardMaximize)\n");
        return;
        }

    // Finally, we will tell the server to shutdown, and then we will
    // unbind the Helga bindings.

    IsabelleShutdown(IsabelleBinding);

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Edward : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&IsabelleBinding);
    if (Status)
        {
        PrintToConsole("Edward : FAIL - Unable to Free Binding");
        PrintToConsole(" (IsabelleBinding)\n");
        return;
        }

    Status = RpcBindingFree(&HelgaMaximize);
    if (Status)
        {
        PrintToConsole("Edward : FAIL - Unable to Free Binding ");
        PrintToConsole("(HelgaMaximize)\n");
        return;
        }

    Status = RpcBindingFree(&HelgaMinimize);
    if (Status)
        {
        PrintToConsole("Edward : FAIL - Unable to Free Binding");
        PrintToConsole(" (HelgaMinimize)\n");
        return;
        }

    PrintToConsole("Edward : PASS\n");
}

#ifdef NOVELL_NP
unsigned int AstroThreads = 1;
#else   // NOVELL_NP
unsigned int AstroThreads = 2;
#endif // NOVELL


#ifndef NOTHREADS

unsigned int AstroThreadCount;
/* volatile */ int fAstroResume;


void
AstroSylvia (
    IN void * Ignore
    )
/*++

Routine Description:

    This routine will be called by each thread created by the Astro
    test to make calls against the Sylvia interface.

Arguments:

    Ignore - Supplies an argument which we do not use.  The thread class
        takes a single argument, which we ignore.

--*/
{
    UNUSED(Ignore);

    if (SylviaCall(SylviaBinding,5,0,0) != LocalSylviaCall(5,0,0))
        {
        PrintToConsole("AstroSylvia : FAIL - Incorrect result from");
        PrintToConsole(" SylviaCall(5,0,0)\n");
        return;
        }

    if (SylviaCall(SylviaBinding,10,5,0) != LocalSylviaCall(10,5,0))
        {
        PrintToConsole("AstroSylvia : FAIL - Incorrect result from");
    PrintToConsole(" SylviaCall(10,5,0)\n");
        return;
        }

    TestMutexRequest();
    AstroThreadCount -= 1;
    if (AstroThreadCount == 0)
        {
        TestMutexClear();
        fAstroResume = 1;
        }
    else
        TestMutexClear();
}

MUTEX2 Mutex2(&Status);


void
AstroMutex (
   RPC_BINDING_HANDLE Dontcare
   )
{
    int i;

    while (1)
        {
        for (i = 0; i < 10; i++)
            {
            Mutex2.Request();
            PrintToConsole("Thread %d in the mutex\n", GetCurrentThreadId());
            Mutex2.Clear();
            PauseExecution(30*i);
            }
        }
}


void
AstroHelga (
    RPC_BINDING_HANDLE HelgaBinding
    )
/*++

Routine Description:

    This routine will be used by the Astro test to perform a test against
    the Helga interface.  More that one thread will execute this routine
    at a time.

Arguments:

    HelgaBinding - Supplies the binding handle to use in make calls using
        the Helga interface.

--*/
{

    TestHelgaInterface(HelgaBinding,
            ( HelgaMaxSize < 8*1024L ? HelgaMaxSize : 8*1024L ));

    TestMutexRequest();
    AstroThreadCount -= 1;
    if (AstroThreadCount == 0)
        {
        TestMutexClear();
        fAstroResume = 1;
        }
    else
        TestMutexClear();
}


void
AstroHelgaAndUnbind ( // Perform the a test using the Helga interface.  When
                      // done, unbind the binding handle.
    RPC_BINDING_HANDLE HelgaBinding // Binding to use to the Helga interface.
    )
/*++

Routine Description:

    This routine is the same as AstroHelga, except that we free the binding
    handle when we are done using it.

Arguments:

    HelgaBinding - Supplies the binding handle to use in making calls
        using the Helga interface.  When we are done with it, we free
        it.

--*/
{
    TestHelgaInterface(HelgaBinding,
        ( HelgaMaxSize < 8*1024L ? HelgaMaxSize : 8*1024L ));

    Status = RpcBindingFree(&HelgaBinding);
    if (Status)
        {
        ApiError("Astro","RpcBindingFree",Status);
        PrintToConsole("Astro : FAIL - Unable to Free Binding ");
        PrintToConsole("(HelgaBinding)\n");
        return;
        }

    TestMutexRequest();
    AstroThreadCount -= 1;
    if (AstroThreadCount == 0)
        {
        TestMutexClear();
        fAstroResume = 1;
        }
    else
        TestMutexClear();
}

typedef enum _ASTRO_BIND_OPTION
{
    AstroBindOnce,
    AstroBindThread,
    AstroBindSylvia,
    AstroDontBind
} ASTRO_BIND_OPTION;


int
PerformMultiThreadAstroTest (
    ASTRO_BIND_OPTION AstroBindOption,
    void (*AstroTestRoutine)(RPC_BINDING_HANDLE),
    unsigned int Address
    )
/*++

Routine Description:

    This routine takes care of performing all of the multi-threaded Astro
    tests.  We create the binding handles as well as creating the threads
    to perform each test.  We also wait around for all of the threads to
    complete.

Arguments:

    AstroBindOption - Supplies information indicating how the binding
        for this particular test should be done.

    AstroTestRoutine - Supplies the test routine to be executed by each
        thread performing the test.

    Address - Supplies the address index to be passed to GetStringBinding
        used to get a string binding.  The string binding is passed to
        RpcBindingFromStringBinding.

Return Value:

    A return value of zero indicates that the test succeeded.  Otherwise,
    the test failed.

--*/
{
    RPC_STATUS RpcStatus;
    RPC_BINDING_HANDLE BindingHandle;
    unsigned int ThreadCount;

    if (AstroBindOption == AstroBindOnce)
        {
        Status = GetBinding(Address, &BindingHandle);
        if (Status)
            {
            ApiError("Astro","GetBinding",Status);
            PrintToConsole("Astro : FAIL - Unable to Bind\n");
            return(1);
            }
        }
    else if (AstroBindOption == AstroBindSylvia)
        {
        Status = GetBinding(Address, &BindingHandle);
        SylviaBinding = BindingHandle;
        if (Status)
            {
            ApiError("Astro","GetBinding",Status);
            PrintToConsole("Astro : FAIL - Unable to Bind\n");
            return(1);
            }
        }

    AstroThreadCount = AstroThreads;
    fAstroResume = 0;

    for (ThreadCount = 0; ThreadCount < AstroThreads; ThreadCount++)
        {

        if (AstroBindOption == AstroBindThread)
            {
            Status = GetBinding(Address, &BindingHandle);
            if (Status)
                {
                ApiError("Astro","GetBinding",Status);
                PrintToConsole("Astro : FAIL - Unable to Bind\n");
                return(1);
                }
            }
        RpcStatus = RPC_S_OK;
        HANDLE HandleToThread;
        unsigned long ThreadId;

        HandleToThread = CreateThread(
                                      0,
                                      DefaultThreadStackSize,
                                      (LPTHREAD_START_ROUTINE) AstroTestRoutine,
                                      BindingHandle,
                                      0,
                                      &ThreadId);

        if (HandleToThread == 0)
            {
            OtherError("Astro", "CreateThread failed");
            PrintToConsole("Astro : FAIL - Unable to create thread\n");
            return(1);
            }
        }

    while (!fAstroResume)
        PauseExecution(200L);

    if (AstroThreadCount != 0)
        {
        PrintToConsole("Astro : FAIL - AstroThreadCount != 0\n");
        return(1);
        }

    if (HelgaErrors != 0)
        {
        PrintToConsole("Astro : FAIL - Error(s) in Helga Interface\n");
        return(1);
        }

    if (   (AstroBindOption == AstroBindOnce)
        || (AstroBindOption == AstroBindSylvia))
        {
        Status = RpcBindingFree(&BindingHandle);
        if (Status)
            {
            ApiError("Astro","RpcBindingFree",Status);
            PrintToConsole("Astro : FAIL - Unable to Free Binding ");
            PrintToConsole("(BindingHandle)\n");
            return(1);
            }
        }

    return(0);
}

#endif


void
Astro (
    )
/*++

Routine Description:

    This routine tests the runtime by having more than one thread
    simultaneously perform remote procedure calls.  This test works with
    the Andromida test in usvr.exe.

--*/
{
    RPC_BINDING_HANDLE IsabelleBinding;
    RPC_STATUS RpcStatus = RPC_S_OK;

    Synchro(ANDROMIDA) ;

    if ( NumberOfTestsRun++ )
        {
        PauseExecution(TestDelay);
        }

    PrintToConsole("Astro : Multithreaded Clients (%d)\n", AstroThreads);

    Status = GetBinding(ANDROMIDA, &IsabelleBinding);
    if (Status)
        {
        ApiError("Astro","GetBinding",Status);
        PrintToConsole("Astro : FAIL - Unable to Bind (Andromida)\n");
        return;
        }



#ifndef NOTHREADS

    if (PerformMultiThreadAstroTest(AstroBindOnce,AstroHelga,
            ANDROMIDA))
        return;

    if (PerformMultiThreadAstroTest(AstroBindThread, AstroHelgaAndUnbind,
            ANDROMIDA))
        return;

    if ( PerformMultiThreadAstroTest(AstroBindSylvia, AstroSylvia,
            ANDROMIDA) != 0 )
        {
        return;
        }

#endif

    IsabelleShutdown(IsabelleBinding);

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Astro : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcBindingFree(&IsabelleBinding);
    if (Status)
        {
        ApiError("Astro","RpcBindingFree",Status);
        PrintToConsole("Astro : FAIL - Unable to Free Binding");
        PrintToConsole(" (IsabelleBinding)\n");
        return;
        }

    PrintToConsole("Astro : PASS\n");
}


int
FitzgeraldCompose (
    IN char PAPI * ObjUuid OPTIONAL,
    IN char PAPI * Protseq,
    IN char PAPI * NetworkAddr,
    IN char PAPI * Endpoint OPTIONAL,
    IN char PAPI * NetworkOptions OPTIONAL,
    IN char PAPI * ExpectedStringBinding
    )
/*++

Routine Description:

    This routine is used by Fitzgerald to test the RpcStringBindingCompose
    API.

Arguments:

    ObjUuid - Optionally supplies the object UUID field to pass to
        RpcStringBindingCompose.

    Protseq - Supplies the RPC protocol sequence field to pass to
        RpcStringBindingCompose.

    NetworkAddr - Supplies the network address field to pass to
        RpcStringBindingCompose.

    Endpoint - Optionally supplies the endpoint field to pass to
        RpcStringBindingCompose.

    NetworkOptions - Optionally supplies the network options field to
        pass to RpcStringBindingCompose.

    ExpectedStringBinding - Supplies the expected string binding which
        should be obtained from RpcStringBindingCompose.

Return Value:

    0 - The test passed successfully.

    1 - The test failed.

--*/
{
    unsigned char PAPI * StringBinding;
    RPC_STATUS Status;

    Status = RpcStringBindingComposeA((unsigned char PAPI *) ObjUuid,
            (unsigned char PAPI *) Protseq,
            (unsigned char PAPI *) NetworkAddr,
            (unsigned char PAPI *) Endpoint,
            (unsigned char PAPI *) NetworkOptions,&StringBinding);
    if (Status)
        {
        ApiError("FitzgeraldCompose","RpcStringBindingCompose",Status);
        PrintToConsole("Fitzgerald : FAIL - Error in");
        PrintToConsole(" RpcStringBindingCompose\n");
        return(1);
        }

    if (strcmp((char PAPI *) StringBinding,
            (char PAPI *) ExpectedStringBinding) != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - StringBinding");
        PrintToConsole(" != ExpectedStringBinding\n");
        return(1);
        }

    Status = RpcStringFreeA(&StringBinding);
    if (Status)
        {
        ApiError("FitzgeraldCompose","RpcStringFree",Status);
        PrintToConsole("Fitzgerald : FAIL - Error in RpcStringFree\n");
        return(1);
        }

    return(0);
}


int
FitzgeraldParse (
    IN char PAPI * StringBinding,
    IN char PAPI * ExpectedObjUuid OPTIONAL,
    IN char PAPI * ExpectedProtseq OPTIONAL,
    IN char PAPI * ExpectedNetworkAddr OPTIONAL,
    IN char PAPI * ExpectedEndpoint OPTIONAL,
    IN char PAPI * ExpectedOptions OPTIONAL
    )
/*++

Routine Description:

    This routine is used by Fitzgerald to test the RpcStringBindingParse
    API.

Arguments:

    StringBinding - Supplies the string binding to be parsed.

    ExpectedObjUuid - Supplies a string containing the expected object
        UUID field.

    ExpectedProtseq - Supplies the expected RPC protocol sequence field.

    ExpectedNetworkAddr - Supplies the expected network address field.

    ExpectedEndpoint - Supplies the expected endpoint field.

    ExpectedOptions - Supplies the expected options field.

Return Value:

    0 - The test passed successfully.

    1 - The test failed.

--*/
{
    unsigned char PAPI * ObjUuid = 0;
    unsigned char PAPI * Protseq = 0;
    unsigned char PAPI * NetworkAddr = 0;
    unsigned char PAPI * Endpoint = 0;
    unsigned char PAPI * Options = 0;
    RPC_STATUS Status;

    Status = RpcStringBindingParseA((unsigned char PAPI *) StringBinding,
        (ARGUMENT_PRESENT(ExpectedObjUuid) ? (unsigned char PAPI * PAPI *) &ObjUuid : 0),
        (ARGUMENT_PRESENT(ExpectedProtseq) ? (unsigned char PAPI * PAPI *) &Protseq : 0),
        (ARGUMENT_PRESENT(ExpectedNetworkAddr) ? (unsigned char PAPI * PAPI *) &NetworkAddr : 0),
        (ARGUMENT_PRESENT(ExpectedEndpoint) ? (unsigned char PAPI * PAPI *) &Endpoint : 0),
        (ARGUMENT_PRESENT(ExpectedOptions) ? (unsigned char PAPI * PAPI *) &Options : 0));
    if (Status)
        {
        ApiError("FitzgeraldParse","RpcStringBindingParse",Status);
        PrintToConsole("Fitzgerald : FAIL - Error in");
        PrintToConsole(" RpcStringBindingParse\n");
        return(1);
        }

    if (strcmp(ExpectedObjUuid,(char PAPI *) ObjUuid) != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - ExpectedObjUuid != ObjUuid");
        return(1);
        }

    if (strcmp(ExpectedProtseq,(char PAPI *) Protseq) != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - ExpectedProtseq != Protseq");
        return(1);
        }

    if (strcmp(ExpectedNetworkAddr,(char PAPI *) NetworkAddr) != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - ExpectedNetworkAddr");
        PrintToConsole(" != NetworkAddr");
        return(1);
        }

    if (strcmp(ExpectedEndpoint,(char PAPI *) Endpoint) != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - ExpectedEndpoint != Endpoint");
        return(1);
        }

    if (strcmp(ExpectedOptions,(char PAPI *) Options) != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - ExpectedOptions != Options");
        return(1);
        }

    Status = RpcStringFreeA(&ObjUuid);
    if (Status)
        {
        ApiError("FitzgeraldParse","RpcStringFree",Status);
        PrintToConsole("Fitzgerald : FAIL - Error in RpcStringFree\n");
        return(1);
        }
    Status = RpcStringFreeA(&Protseq);
    if (Status)
        {
        ApiError("FitzgeraldParse","RpcStringFree",Status);
        PrintToConsole("Fitzgerald : FAIL - Error in RpcStringFree\n");
        return(1);
        }
    Status = RpcStringFreeA(&NetworkAddr);
    if (Status)
        {
        ApiError("FitzgeraldParse","RpcStringFree",Status);
        PrintToConsole("Fitzgerald : FAIL - Error in RpcStringFree\n");
        return(1);
        }
    Status = RpcStringFreeA(&Endpoint);
    if (Status)
        {
        ApiError("FitzgeraldParse","RpcStringFree",Status);
        PrintToConsole("Fitzgerald : FAIL - Error in RpcStringFree\n");
        return(1);
        }
    Status = RpcStringFreeA(&Options);
    if (Status)
        {
        ApiError("FitzgeraldParse","RpcStringFree",Status);
        PrintToConsole("Fitzgerald : FAIL - Error in RpcStringFree\n");
        return(1);
        }
    return(0);
}


int
FitzgeraldComposeAndParse (
    void
    )
/*++

Routine Description:

    This routine tests that the string binding (RpcStringBindingCompose and
    RpcStringBindingParse) and string (RpcStringFree) APIs are working
    correctly.  This is a build verification test; hence it focuses on
    testing that all functionality is there, testing error cases are
    not quite as important.

Return Value:

    Zero will be returned if all of the tests pass, otherwise, non-zero
    will be returned.

--*/
{
    unsigned char PAPI * StringBinding;

    if (FitzgeraldCompose(0,"ncacn_np","\\\\server","\\pipe\\endpoint",0,
            "ncacn_np:\\\\\\\\server[\\\\pipe\\\\endpoint]"))
        return(1);

    if (FitzgeraldCompose(0,"ncacn_np","\\\\server",0,0,
            "ncacn_np:\\\\\\\\server"))
        return(1);

    Status = RpcStringBindingComposeA(
            (unsigned char PAPI *) "12345678-9012-B456-8001-08002B033D7AA",
            (unsigned char PAPI *) "ncacn_np",
            (unsigned char PAPI *) "\\\\server", 0,0, &StringBinding);
    if ( Status != RPC_S_INVALID_STRING_UUID )
        {
        ApiError("FitzgeraldComposeAndParse", "RpcStringBindingCompose",
                Status);
        PrintToConsole("Fitzgerald : FAIL - Error ");
        PrintToConsole("in RpcStringBindingCompose\n");
        return(1);
        }

    if (FitzgeraldCompose("12345678-9012-B456-8001-08002B033D7A",
            "ncacn_np","\\\\server","\\pipe\\endpoint",0,
            "12345678-9012-b456-8001-08002b033d7a@ncacn_np:\\\\\\\\server[\\\\pipe\\\\endpoint]"))
        return(1);

    if (FitzgeraldCompose(0,"ncacn_np","\\\\server","\\pipe\\endpoint",
            "security=identify",
            "ncacn_np:\\\\\\\\server[\\\\pipe\\\\endpoint,security=identify]"))
        return(1);

    if (FitzgeraldCompose(0,"ncacn_np","\\\\server",0,"option=value",
            "ncacn_np:\\\\\\\\server[,option=value]"))
        return(1);

    if (FitzgeraldParse("12345678-9012-b456-8001-08002b033d7a@ncacn_np:\\\\\\\\server[\\\\pipe\\\\endpoint,security=identify]",
            "12345678-9012-b456-8001-08002b033d7a",
            "ncacn_np","\\\\server","\\pipe\\endpoint",
            "security=identify"))
        return(1);

    if (FitzgeraldParse("ncacn_np:\\\\\\\\server",
            "","ncacn_np","\\\\server","",""))
        return(1);

    if (FitzgeraldParse("ncacn_np:\\\\\\\\server[\\\\pipe\\\\endpoint]",
            "","ncacn_np","\\\\server","\\pipe\\endpoint",""))
        return(1);

    return(0);
}


int
FitzgeraldBindingCopy (
    )
/*++

Routine Description:

    Fitzgerald uses this routine to test the RpcBindingCopy API (we also
    use RpcBindingFromStringBinding and RpcBindingFree).

Return Value:

    Zero will be returned if all of the tests pass, otherwise, non-zero
    will be returned.

--*/
{
    RPC_BINDING_HANDLE BindingHandle;
    RPC_BINDING_HANDLE CopiedBeforeRpc;
    RPC_BINDING_HANDLE CopiedAfterRpc;

    Status = GetBinding(FREDRICK, &BindingHandle);
    if (Status)
        {
        ApiError("Fitzgerald","GetBinding",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Bind");
        PrintToConsole(" (Fredrick)");
        return(1);
        }

    Status = RpcBindingCopy(BindingHandle,&CopiedBeforeRpc);
    if (Status)
        {
        ApiError("Fitzgerald","RpcBindingCopy",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Copy Binding");
        PrintToConsole(" (BindingHandle)\n");
        return(1);
        }

    Helga(BindingHandle);

    if (HelgaErrors != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return(1);
        }

    Helga(CopiedBeforeRpc);

    if (HelgaErrors != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return(1);
        }

    Status = RpcBindingCopy(CopiedBeforeRpc,&CopiedAfterRpc);
    if (Status)
        {
        ApiError("Fitzgerald","RpcBindingCopy",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Copy Binding");
        PrintToConsole(" (CopiedBeforeRpc)\n");
        return(1);
        }

    Status = RpcBindingFree(&BindingHandle);
    if (Status)
        {
        ApiError("Fitzgerald","RpcBindingFree",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Free Binding");
        PrintToConsole(" (BindingHandle)\n");
        return(1);
        }

    Helga(CopiedBeforeRpc);

    if (HelgaErrors != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return(1);
        }

    Helga(CopiedAfterRpc);

    if (HelgaErrors != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return(1);
        }

    Status = RpcBindingFree(&CopiedBeforeRpc);
    if (Status)
        {
        ApiError("Fitzgerald","RpcBindingFree",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Free Binding");
        PrintToConsole(" (CopiedBeforeRpc)\n");
        return(1);
        }

    Helga(CopiedAfterRpc);

    if (HelgaErrors != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return(1);
        }

    Status = RpcBindingFree(&CopiedAfterRpc);
    if (Status)
        {
        ApiError("Fitzgerald","RpcBindingFree",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Free Binding");
        PrintToConsole(" (CopiedAfterRpc)\n");
        return(1);
        }

    return(0);
}


int
FitzgeraldToStringBinding (
    IN unsigned char PAPI * UseThisStringBinding,
    IN unsigned char PAPI * ExpectedStringBinding,
    IN UUID PAPI * ObjectUuid OPTIONAL
    )
/*++

Routine Description:

    This routine tests the RpcBindingToStringBinding API.

Arguments:

    UseThisStringBinding - Supplies the string binding to used in
        making the binding handle.

    ExpectedStringBinding - Supplies the expected string binding to be
        obtained from RpcBindingToStringBinding.

    ObjectUuid - Optionally supplies an object uuid which should be
        set in the binding handle.

Return Value:

    Zero will be returned if the test passes, otherwise, non-zero
    will be returned.

--*/
{
    RPC_BINDING_HANDLE BindingHandle;
    unsigned char PAPI * StringBinding;

    Status = RpcBindingFromStringBindingA(UseThisStringBinding,&BindingHandle);
    if (Status)
        {
        ApiError("Fitzgerald","RpcBindingFromStringBinding",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Bind");
        PrintToConsole(" (Fredrick)\n");
        return(1);
        }

    if (ARGUMENT_PRESENT(ObjectUuid))
        {
        Status = RpcBindingSetObject(BindingHandle,ObjectUuid);
        if (Status)
            {
            ApiError("Fitzgerald","RpcBindingSetObject",Status);
            PrintToConsole("Fitzgerald : FAIL - Error in ");
            PrintToConsole("RpcBindingSetObject\n");
            return(1);
            }
        }

    Status = RpcBindingToStringBindingA(BindingHandle,&StringBinding);
    if (Status)
        {
        ApiError("Fitzgerald","RpcBindingToStringBinding",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Create String Binding");
        PrintToConsole(" (BindingHandle)\n");
        return(1);
        }

    if (strcmp((char *) ExpectedStringBinding,(char *) StringBinding) != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - ExpectedStringBinding");
        PrintToConsole(" != StringBinding\n");
        return(1);
        }

    Status = RpcStringFreeA(&StringBinding);
    if (Status)
        {
        ApiError("Fitzgerald","RpcStringFree",Status);
        PrintToConsole("Fitzgerald : FAIL - Error in RpcStringFree\n");
        return(1);
        }

    Helga(BindingHandle);

    Status = RpcBindingToStringBindingA(BindingHandle,&StringBinding);
    if (Status)
        {
        ApiError("Fitzgerald","RpcBindingToStringBinding",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Create String Binding");
        PrintToConsole(" (BindingHandle)\n");
        return(1);
        }

    if (strcmp((char *) ExpectedStringBinding,(char *) StringBinding) != 0)
        {
        PrintToConsole("Fitzgerald : FAIL - ExpectedStringBinding");
        PrintToConsole(" != StringBinding\n");
        return(1);
        }

    Status = RpcStringFreeA(&StringBinding);
    if (Status)
        {
        ApiError("Fitzgerald","RpcStringFree",Status);
        PrintToConsole("Fitzgerald : FAIL - Error in RpcStringFree\n");
        return(1);
        }

    Status = RpcBindingFree(&BindingHandle);
    if (Status)
        {
        ApiError("Fitzgerald","RpcBindingCopy",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Free Binding");
        PrintToConsole(" (BindingHandle)\n");
        return(1);
        }

    return(0);
}


int
FitzgeraldInqSetObjectUuid (
    IN unsigned int SetObjectBeforeRpcFlag,
    IN unsigned int InqObjectBeforeRpcFlag,
    IN UUID PAPI * ObjectUuid,
    IN unsigned char PAPI * StringBinding
    )
/*++

Routine Description:

    This routine tests the RpcBindingInqObject and RpcBindingSetObject
    APIs.

Arguments:

    SetObjectBeforeRpcFlag - Supplies a flag that specifies when the
        object uuid in the binding handle should be set: one means
        the object uuid should be set before making a remote procedure
        call, and zero means afterward.

    InqObjectBeforeRpcFlag - Supplies a flag which is the same as the
        SetObjectBeforeRpcFlag, but it applies to inquiring the object
        uuid.

    ObjectUuid - Supplies the uuid to set in the binding handle.

    StringBinding - Supplies the string binding to use.

Return Value:

    Zero will be returned if all of the tests pass, otherwise, non-zero
    will be returned.

--*/
{
    UUID InqObjectUuid;
    RPC_BINDING_HANDLE BindingHandle;

    Status = RpcBindingFromStringBindingA(StringBinding,&BindingHandle);
    if (Status)
        {
        ApiError("Fitzgerald","RpcBindingFromStringBinding",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Bind");
        PrintToConsole(" (Fredrick)\n");
        return(1);
        }

    if (SetObjectBeforeRpcFlag == 1)
        {
        Status = RpcBindingSetObject(BindingHandle,ObjectUuid);
        if (Status)
            {
            ApiError("Fitzgerald","RpcBindingSetObject",Status);
            PrintToConsole("Fitzgerald : FAIL - Error in ");
            PrintToConsole("RpcBindingSetObject\n");
            return(1);
            }
        }

    if (InqObjectBeforeRpcFlag == 1)
        {
        Status = RpcBindingInqObject(BindingHandle,&InqObjectUuid);
        if (Status)
            {
            ApiError("Fitzgerald","RpcBindingInqObject",Status);
            PrintToConsole("Fitzgerald : FAIL - Error in ");
            PrintToConsole("RpcBindingInqObject\n");
            return(1);
            }

        if (   (InqObjectUuid.Data1 != ObjectUuid->Data1)
            || (InqObjectUuid.Data2 != ObjectUuid->Data2)
            || (InqObjectUuid.Data3 != ObjectUuid->Data3)
            || (InqObjectUuid.Data4[0] != ObjectUuid->Data4[0])
            || (InqObjectUuid.Data4[1] != ObjectUuid->Data4[1])
            || (InqObjectUuid.Data4[2] != ObjectUuid->Data4[2])
            || (InqObjectUuid.Data4[3] != ObjectUuid->Data4[3])
            || (InqObjectUuid.Data4[4] != ObjectUuid->Data4[4])
            || (InqObjectUuid.Data4[5] != ObjectUuid->Data4[5])
            || (InqObjectUuid.Data4[6] != ObjectUuid->Data4[6])
            || (InqObjectUuid.Data4[7] != ObjectUuid->Data4[7]))
            {
            PrintToConsole("Fitzgerald : FAIL - InqObjectUuid !=");
            PrintToConsole(" SetObjectUuid\n");
            return(1);
            }
        }

    Helga(BindingHandle);

    if (SetObjectBeforeRpcFlag == 0)
        {
        Status = RpcBindingSetObject(BindingHandle,ObjectUuid);
        if (Status)
            {
            ApiError("Fitzgerald","RpcBindingSetObject",Status);
            PrintToConsole("Fitzgerald : FAIL - Error in ");
            PrintToConsole("RpcBindingSetObject\n");
            return(1);
            }
        }

    if (InqObjectBeforeRpcFlag == 0)
        {
        Status = RpcBindingInqObject(BindingHandle,&InqObjectUuid);
        if (Status)
            {
            ApiError("Fitzgerald","RpcBindingInqObject",Status);
            PrintToConsole("Fitzgerald : FAIL - Error in ");
            PrintToConsole("RpcBindingInqObject\n");
            return(1);
            }

        if (   (InqObjectUuid.Data1 != ObjectUuid->Data1)
            || (InqObjectUuid.Data2 != ObjectUuid->Data2)
            || (InqObjectUuid.Data3 != ObjectUuid->Data3)
            || (InqObjectUuid.Data4[0] != ObjectUuid->Data4[0])
            || (InqObjectUuid.Data4[1] != ObjectUuid->Data4[1])
            || (InqObjectUuid.Data4[2] != ObjectUuid->Data4[2])
            || (InqObjectUuid.Data4[3] != ObjectUuid->Data4[3])
            || (InqObjectUuid.Data4[4] != ObjectUuid->Data4[4])
            || (InqObjectUuid.Data4[5] != ObjectUuid->Data4[5])
            || (InqObjectUuid.Data4[6] != ObjectUuid->Data4[6])
            || (InqObjectUuid.Data4[7] != ObjectUuid->Data4[7]))
            {
            PrintToConsole("Fitzgerald : FAIL - InqObjectUuid !=");
            PrintToConsole(" SetObjectUuid\n");
            return(1);
            }
        }

    Status = RpcBindingFree(&BindingHandle);
    if (Status)
        {
        ApiError("Fitzgerald","RpcBindingCopy",Status);
        PrintToConsole("Fitzgerald : FAIL - Unable to Free Binding");
        PrintToConsole(" (BindingHandle)\n");
        return(1);
    }
    return(0);
}


int
FitzgeraldStringBindingAndObject (
    )
/*++

Routine Description:

    Fitzgerald uses this routine to test the RpcBindingToStringBinding,
    RpcBindingInqObject, and RpcBindingSetObject APIs.  We need to test
    them together because we need to check that the object uuid gets
    placed into the string binding.

Return Value:

    Zero will be returned if all of the tests pass, otherwise, non-zero
    will be returned.

--*/
{
    UUID ObjectUuid;
    unsigned char PAPI * StringBinding1;
    unsigned char PAPI * StringBinding2;

    if (FitzgeraldToStringBinding(GetStringBinding(FREDRICK,0,0),
            GetStringBinding(FREDRICK,0,0), 0))
        return(1);

    if (FitzgeraldToStringBinding(GetStringBinding(