 to the key.
        if (ptsStop != ptsStart)
        {
            ptsStop += 1;
            *pptsKey   = (TCHAR *) malloc( ((ptsStop - ptsStart) + 1) *
                                           sizeof(TCHAR) );
      
            LOG_ASSERT_EXPR( *pptsKey != NULL,
                             IDS_NOT_ENOUGH_MEMORY,
                             dwResult,
                             ERROR_NOT_ENOUGH_MEMORY );
            _tcsncpy( *pptsKey, ptsStart, ptsStop - ptsStart );
            (*pptsKey)[ptsStop - ptsStart] = 0;
        }
        else
            *pptsKey = NULL;

        // Find the closing square bracket.
        ptsStart = bracket;
        bracket = _tcschr( ptsStart, TEXT(']') );
        LOG_ASSERT_EXPR( bracket != NULL,
                         IDS_INF_ERROR,
                         dwResult,
                         SPAPI_E_GENERAL_SYNTAX );

        // Copy the value name.
        *pptsValue = (TCHAR *) malloc( ((bracket - ptsStart) + 1) *
                                       sizeof(TCHAR) );
    
        LOG_ASSERT_EXPR( *pptsValue != NULL,
                         IDS_NOT_ENOUGH_MEMORY,
                         dwResult,
                         ERROR_NOT_ENOUGH_MEMORY );
        _tcsncpy( *pptsValue, ptsStart, bracket - ptsStart );
        (*pptsValue)[bracket - ptsStart] = 0;
    }

cleanup:
    if (ptsBuffer != NULL)
        free( ptsBuffer );
    return dwResult;
}

/***************************************************************************

        ParseRule

     Read a line from the rules inf file in one of the following formats.
When partial paths are specified, compute the full path. Create a rule
record from the line.

     reg_path2 is optional and reg_path is parsed by the function
ParseRegPath into a root, key, and value.
        reg-path1 = reg_path2

     If reg_path2 contains just a leaf name, generate a full path using
the path from reg_path1 and replacing its leaf with the leaf from reg_path2.

***************************************************************************/

DWORD ParseRule( INFCONTEXT *pic, HASH_NODE **pphnRule )
{
    TCHAR     *ptsBuffer;
    DWORD      dwReqLen;
    DWORD      dwResult = ERROR_SUCCESS;
    BOOL       fSuccess;
    TCHAR     *ptsLast;
    TCHAR     *ptsTemp;

    // Allocate a new rule.
    *pphnRule = (HASH_NODE *) malloc( sizeof(HASH_NODE) );
    LOG_ASSERT_EXPR( *pphnRule != NULL, IDS_NOT_ENOUGH_MEMORY, dwResult,
                     ERROR_NOT_ENOUGH_MEMORY );
    (*pphnRule)->dwAction    = 0;
    (*pphnRule)->phnNext     = 0;
    (*pphnRule)->ptsNewValue = NULL;
    (*pphnRule)->ptsNewKey   = NULL;
    (*pphnRule)->ptsFunction = NULL;
    (*pphnRule)->ptsFileDest = NULL;

    // Get the first reg path.
    dwResult = ParseRegPath( pic,
                             0,
                             &(*pphnRule)->ptsRoot,
                             &(*pphnRule)->ptsKey,
                             &(*pphnRule)->ptsValue );
    FAIL_ON_ERROR( dwResult );

    // Get the second reg path.
    dwResult = ParseRegPath( pic,
                             1,
                             &ptsBuffer,
                             &(*pphnRule)->ptsNewKey,
                             &(*pphnRule)->ptsNewValue );
    FAIL_ON_ERROR( dwResult );

    // Get the optional regfile destination
    fSuccess = SetupGetStringField( pic, 2, NULL, 0, &dwReqLen );
    if ((TRUE == fSuccess) && (dwReqLen > 0))
    {
        (*pphnRule)->ptsFileDest = (TCHAR *)malloc(dwReqLen * sizeof(TCHAR));
		LOG_ASSERT_EXPR( (*pphnRule)->ptsFileDest != NULL, IDS_NOT_ENOUGH_MEMORY, dwResult,
				         ERROR_NOT_ENOUGH_MEMORY );

        fSuccess = SetupGetStringField(pic, 2, (*pphnRule)->ptsFileDest, dwReqLen, NULL);
		LOG_ASSERT_GLE(fSuccess, dwResult);
    }

    // If the original key ends with a star, remove it and set the recursive
    // flag.
    if ((*pphnRule)->ptsKey != NULL)
    {
        dwReqLen = _tcslen( (*pphnRule)->ptsKey );
        if (dwReqLen > 2 &&
            (*pphnRule)->ptsKey[dwReqLen-1] == TEXT('*') &&
            (*pphnRule)->ptsKey[dwReqLen-2] == TEXT('\\'))
        {
            (*pphnRule)->dwAction |= recursive_fa;
            (*pphnRule)->ptsKey[dwReqLen-2] = 0;
        }
      
        // If there is a new key, set the rename_leaf or rename_path flag.
        if ((*pphnRule)->ptsNewKey != NULL)
            if ((*pphnRule)->dwAction & recursive_fa)
                (*pphnRule)->dwAction |= rename_path_fa;
            else
                (*pphnRule)->dwAction |= rename_leaf_fa;
    }

    // If there is a new value, set the rename_value flag.
    if ((*pphnRule)->ptsNewValue != NULL)
        (*pphnRule)->dwAction |= rename_value_fa;

    // If the new key did not contain a root, compute a full path for it.
    if (ptsBuffer == NULL &&
        (*pphnRule)->ptsKey != NULL &&
        (*pphnRule)->ptsNewKey != NULL)
    {
        // Find the last backslash in the key.
        ptsLast = (*pphnRule)->ptsKey;
        do
        {
            ptsTemp = _tcschr( ptsLast, TEXT('\\') );
            if (ptsTemp != NULL)
                ptsLast = ptsTemp+1;
        } while (ptsTemp != NULL);

        // Don't do anything if the original key contains just a leaf.
        if (ptsLast != (*pphnRule)->ptsKey)
        {

            // Allocate a ptsBuffer to hold the old path and the new leaf.
            free( ptsBuffer );
            dwReqLen = _tcslen( (*pphnRule)->ptsNewKey ) +
                (ptsLast - (*pphnRule)->ptsKey) + 2;
            ptsBuffer = (TCHAR *) malloc( dwReqLen*sizeof(TCHAR) );
            LOG_ASSERT_EXPR( ptsBuffer != NULL,
                             IDS_NOT_ENOUGH_MEMORY,
                             dwResult,
                             ERROR_NOT_ENOUGH_MEMORY );

            // Copy in the old path and the new leaf.
            _tcsncpy( ptsBuffer,
                      (*pphnRule)->ptsKey,
                      (ptsLast - (*pphnRule)->ptsKey) );
            _tcscpy( &ptsBuffer[ptsLast-(*pphnRule)->ptsKey],
                     (*pphnRule)->ptsNewKey );
            free( (*pphnRule)->ptsNewKey );
            (*pphnRule)->ptsNewKey = ptsBuffer;
        }
    }
    else
        free(ptsBuffer);

    // Consider freeing strings on error.
cleanup:
    if (dwResult != ERROR_SUCCESS)
    {
        if (*pphnRule != NULL)
        {
            free((*pphnRule)->ptsRoot);
            free((*pphnRule)->ptsKey);
            free((*pphnRule)->ptsValue);
            free((*pphnRule)->ptsNewKey);
            free((*pphnRule)->ptsNewValue);
            free((*pphnRule)->ptsFunction);
            free((*pphnRule)->ptsFileDest);
            free(*pphnRule);
            *pphnRule = NULL;
        }
    }
            
    return dwResult;
}


//---------------------------------------------------------------
// This function prints from an ascii format string to a unicode
// win32 file handle.  It is not thread safe.
DWORD Win32Printf( HANDLE file, char *format, ... )
{
    va_list     va;
    DWORD       dwWritten;
    DWORD       dwLen;
    DWORD       dwWideLength;
    WCHAR      *pwsBuffer = NULL;
    const ULONG LINEBUFSIZE = 4096;
#ifdef UNICODE  
    char *pszBuffer;
    int iCharLen;
    char szOutputBuffer[LINEBUFSIZE];
#endif  
    BOOL        fSuccess;
    TCHAR   tcsPrintBuffer[LINEBUFSIZE];
    TCHAR   *ptsFormat;


#ifdef UNICODE
    WCHAR wcsFormat[LINEBUFSIZE];

  
    dwWideLength = MultiByteToWideChar(CP_ACP, 0, format, -1, NULL, 0);
    if (dwWideLength >= LINEBUFSIZE)
    {
        pwsBuffer = (WCHAR *)_alloca( dwWideLength * sizeof(WCHAR));
        if (pwsBuffer == NULL)
            return ERROR_NOT_ENOUGH_MEMORY;
      
        ptsFormat = pwsBuffer;
        if (!MultiByteToWideChar( CP_ACP,
                                  0,
                                  format,
                                  -1,
                                  pwsBuffer,
                                  dwWideLength ))
            return GetLastError();
    }
    else
    {
        if (!MultiByteToWideChar(CP_ACP,
                                 0,
                                 format,
                                 -1,
                                 wcsFormat,
                                 LINEBUFSIZE))
        {
            return GetLastError();
        }
        ptsFormat = wcsFormat;
    }
#else
    ptsFormat = format;
#endif
  
    va_start( va, format );

    // The doc says if wvsprintf fails, return value is less than
    // the length of the expected output.  Since its hard to know the
    // correct output length, always clear the last error and always
    // check it.
    SetLastError(ERROR_SUCCESS);
    wvsprintf( tcsPrintBuffer, ptsFormat, va );
    va_end(va);
    if (GetLastError() != ERROR_SUCCESS)
        return GetLastError();

    // When printing to the console or logfile use ascii.
    // When printing to the migration file use Unicode.
    dwLen     = _tcslen(tcsPrintBuffer);
    if ((file != OutputFile) || OutputAnsi)
    {
#ifdef UNICODE

        //Convert to ANSI for output
      
        iCharLen = WideCharToMultiByte(CP_ACP,
                                   0,
                                   tcsPrintBuffer,
                                   -1,
                                   NULL,
                                   0,
                                   NULL,
                                   NULL);
        if (iCharLen >= LINEBUFSIZE)
        {
            pszBuffer = (char *)_alloca( iCharLen * sizeof(char));
            if (pszBuffer == NULL)
                return ERROR_OUTOFMEMORY;
          
            if (!WideCharToMultiByte(CP_ACP,
                                     0,
                                     tcsPrintBuffer,
                                     -1,
                                     pszBuffer,
                                     iCharLen,
                                     NULL,
                                     NULL))
                return GetLastError();
              
            pwsBuffer = (WCHAR *)pszBuffer;
        }
        else
        {
            if (!WideCharToMultiByte(CP_ACP,
                                     0,
                                     tcsPrintBuffer,
                                     -1,
                                     szOutputBuffer,
                                     LINEBUFSIZE,
                                     NULL,
                                     NULL))
                return GetLastError();
            pwsBuffer = (WCHAR *)szOutputBuffer;
        }
        dwWideLength = dwLen;
#else
        pwsBuffer = (WCHAR *) tcsPrintBuffer;
        dwWideLength    = dwLen;
#endif      
    }
    else
    {
#ifdef UNICODE
        pwsBuffer = tcsPrintBuffer;
        dwWideLength = dwLen * sizeof(WCHAR);
#else
        // Allocate a buffer to hold the unicode string.
        DEBUG_ASSERT( dwLen < LINEBUFSIZE );
        dwWideLength    = MultiByteToWideChar( CP_ACP,
                                               0,
                                               tcsPrintBuffer,
                                               dwLen,
                                               NULL,
                                               0 );
        pwsBuffer = (WCHAR *) _alloca( dwWideLength*sizeof(WCHAR) );
        if (pwsBuffer == NULL)
            return ERROR_NOT_ENOUGH_MEMORY;

        // Convert the buffer to unicode.
        dwWideLength = MultiByteToWideChar( CP_ACP,
                                            0,
                                            tcsPrintBuffer,
                                            dwLen,
                                            pwsBuffer,
                                            dwWideLength );
        if (dwWideLength == 0)
            return GetLastError();
        dwWideLength *= sizeof(WCHAR);
#endif    
    }

    // Write the unicode string.
    fSuccess = WriteFile( file, pwsBuffer, dwWideLength,  &dwWritten, NULL );
    if (!fSuccess || dwWideLength != dwWritten)
        return GetLastError();

    if (file == STDERR)
    {
        //Also write to the log file for these
        fSuccess = WriteFile( LogFile,
                              pwsBuffer,
                              dwWideLength,
                              &dwWritten,
                              NULL );
        if (!fSuccess || dwWideLength != dwWritten)
        {
            return GetLastError();
        }
    }

    return ERROR_SUCCESS;
}


//*****************************************************************
//
//  Synopsis:       Recursive function to make the command line. We have to do
//                  this because CStringList stores the parameter in reverse
//                  order.
//
//  Parameters:     h
//                      We need to know when we reach the end of the
//                      CStringList, which is denoted by pointing back to the
//                      head of the chain. But in a recursive function we lose
//                      the head of the chain so it is passed in.
//
//  History:        11/8/1999   Created by WeiruC.
//
//  Return Value:   Win32 error code.
//
//*****************************************************************

void MakeCommandLine(CStringList* h, CStringList* command, TCHAR* commandLine)
{
    if (h==NULL || command == NULL || commandLine == NULL)
    {
        if (DebugOutput)
        {
            Win32Printf(LogFile, "Error: NULL pointer passed to MakeCommandLine\r\n");
        }
        _tcscpy(commandLine, TEXT(""));
        return;
    }
    if(command->Next() != h)
    {
        MakeCommandLine(h, command->Next(), commandLine);
    }

    // No sizes of these buffers are passed in, so we must assume that there is enough space
    _tcscat(commandLine, TEXT("\""));
    _tcscat(commandLine, command->String());
    _tcscat(commandLine, TEXT("\""));
    _tcscat(commandLine, TEXT(" "));
}

//---------------------------------------------------------------
// This is a variation of strpbrk.  It searchs a string that may
// contain nulls for any character in the set.  It returns a pointer
// to the first character in the set or null if the string does
// not contain any characters in the set.  Since the function
// searchs past nulls in the str parameter, the len parameter
// indicates the actual length of str.  The set is an array of
// booleans.
UCHAR *mempbrk( UCHAR *str, DWORD len, const UCHAR set[256] )
{
  DWORD i;

  for (i = 0; i < len; i++)
    if (set[str[i]] != 0)
      return &str[i];
  return NULL;
}

//---------------------------------------------------------------
DWORD WriteKey( HANDLE outfile, DWORD type, TCHAR *rootname, TCHAR *key, TCHAR *value_name,
                UCHAR *data, DWORD data_len )
{
  DWORD  result = ERROR_SUCCESS;
  DWORD  j;
  UCHAR *curr;
  DWORD  orig   = 0;

  // If a string contains an embedded carriage return or linefeed, save
  // it as binary and convert it back to a string on read.
  if (type == REG_SZ || type == REG_MULTI_SZ || type == REG_EXPAND_SZ)
  {
    curr = mempbrk( data, data_len, NEWLINE_SET );
    if (curr != NULL)
    {
      if (type == REG_SZ)
        orig = 0x400000;
      else if (type == REG_MULTI_SZ)
        orig = 0x100000;
      else
        orig = 0x200000;
      type = REG_BINARY;
    }
  }

  if (NULL == rootname)
     rootname = TEXT("");
  if (NULL == key)
     key = TEXT("");
  if (NULL == value_name)
     value_name = TEXT("");

  switch (type)
  {
    case REG_DWORD:
      if (data == NULL)
         *data = 0;
      result = Win32Printf( outfile, "%s, \"%s\", \"%s\", 0x10001, 0x%x\r\n", rootname, key,
                            value_name, *((DWORD *) data) );
      FAIL_ON_ERROR( result );
      break;

    case REG_EXPAND_SZ:
    case REG_SZ:
      if (data == NULL)
        data = EMPTY_STRING;
      result = Win32Printf( outfile, "%s, \"%s\", \"%s\", 0x%x, \"%s\"\r\n", rootname,
                            key, value_name,
                            type == REG_SZ ? FLG_ADDREG_TYPE_SZ : FLG_ADDREG_TYPE_EXPAND_SZ,
                            data );
      FAIL_ON_ERROR( result );
      break;

    case REG_MULTI_SZ:

      // Print the start of the line and the first string.
      if (data == NULL)
        data = EMPTY_STRING;
      result = Win32Printf( outfile, "%s, \"%s\", \"%s\", 0x10000, \"%s\"", rootname,
                            key, value_name, data );
      FAIL_ON_ERROR( result );

      // Print each remaining string.
      curr = data+strlen((char *) data)+1;
      do
      {
        // Print a comma and the current string.
        Win32Printf( outfile, ", \"%s\"", curr );

        // Skip passed the current string and its null.
        curr += strlen((char *) curr)+1;
      } while ((DWORD) (curr - data) < data_len);

      // Print the trailing newline.
      result = Win32Printf( outfile, "\r\n" );
      FAIL_ON_ERROR( result );
      break;

    case REG_BINARY:
    case REG_NONE:
    default:   // Unknown types, just copy the type and treat the data as binary
      // Print the start of the line.
      result = Win32Printf( outfile, "%s, \"%s\", \"%s\", 0x%x", 
                            rootname, key, value_name,
                            ((type == REG_NONE ? 0x800000 : type ) | orig) );
      FAIL_ON_ERROR( result );

      // Print each byte in hex without the 0x prefix.
      for (j = 0; j < data_len; j++)
      {
        result = Win32Printf( outfile, ",%x", data[j] );
        FAIL_ON_ERROR( result );
        if ( (j+1) % 20 == 0)
        {
          result = Win32Printf( outfile, "\\\r\n" );
          FAIL_ON_ERROR( result );
        }
      }

      result = Win32Printf( outfile, "\r\n" );
      FAIL_ON_ERROR( result );
      break;
  }

cleanup:
  return result;
}

//---------------------------------------------------------------
//
DWORD LogReadRule( HASH_NODE *phnNode )
{
    DWORD dwRetval   = ERROR_SUCCESS;
    BOOL  fRuleFound = FALSE;

    dwRetval = Win32Printf(LogFile, "Read rule: ");
    FAIL_ON_ERROR( dwRetval );

    if (phnNode->dwAction & function_fa )
    { 
        dwRetval = Win32Printf(LogFile, "function");
        FAIL_ON_ERROR( dwRetval );
        fRuleFound = TRUE;
    }
    if (phnNode->dwAction & (rename_leaf_fa | rename_path_fa | rename_value_fa))
    {
        dwRetval = Win32Printf(LogFile, "rename" );
        FAIL_ON_ERROR( dwRetval );
        fRuleFound = TRUE;
    }
    if (phnNode->dwAction & file_fa)
    {
        dwRetval = Win32Printf(LogFile, "copy file");
        FAIL_ON_ERROR( dwRetval );
        fRuleFound = TRUE;
    }
    if (phnNode->dwAction & delete_fa ||
        phnNode->dwAction & suppress_fa)
    {
        dwRetval = Win32Printf(LogFile, "delete" );
        FAIL_ON_ERROR( dwRetval );
        fRuleFound = TRUE;
    }
    // If none of the above, then it must be an addreg
    if ( fRuleFound == FALSE )
    {
        dwRetval = Win32Printf(LogFile, "addreg" );
        FAIL_ON_ERROR( dwRetval );
    }

    dwRetval = Win32Printf(LogFile,
                           " %s\\%s ",
                           phnNode->ptsRoot,
                           phnNode->ptsKey);
    FAIL_ON_ERROR( dwRetval );

    if ( phnNode->ptsValue != NULL )
    {
        dwRetval = Win32Printf(LogFile,
                               "[%s] ",
                               phnNode->ptsValue );
        FAIL_ON_ERROR( dwRetval );
    }

    if ( phnNode->ptsNewKey != NULL || phnNode->ptsNewValue != NULL )
    {
        dwRetval = Win32Printf(LogFile, "to ");
        FAIL_ON_ERROR( dwRetval );
        if (phnNode->ptsNewKey != NULL)
        {
            dwRetval = Win32Printf(LogFile, 
                                   "%s ", 
                                   phnNode->ptsNewKey);
            FAIL_ON_ERROR( dwRetval );
        }
        if (phnNode->ptsNewValue != NULL)
        {
            dwRetval = Win32Printf(LogFile,
                                   "[%s]",
                                   phnNode->ptsNewValue);
            FAIL_ON_ERROR( dwRetval );
        }
    }

    dwRetval = Win32Printf(LogFile, "\r\n");
    FAIL_ON_ERROR( dwRetval );

cleanup:
    return (dwRetval);
}
//---------------------------------------------------------------
char *GetValueFromRegistry(const char *lpValue)
{
    HKEY  hKey;
    char  *buffer    = NULL;
    DWORD dwDataSize = 0;
    DWORD result;

    result = RegOpenKeyEx( HKEY_CURRENT_USER, LOADSTATE_KEY, 0, KEY_READ, &hKey );
    FAIL_ON_ERROR( result );

    // Determine size needed
    dwDataSize = 0;
    result = RegQueryValueExA( hKey, lpValue,  NULL, NULL, NULL, &dwDataSize);
    FAIL_ON_ERROR( result );
    buffer = (char *)malloc((dwDataSize + 1) * sizeof(char));
    if (NULL == buffer)
    {
        Win32PrintfResource(Console, IDS_NOT_ENOUGH_MEMORY);
        goto cleanup;
    }
    result = RegQueryValueExA( hKey, lpValue,  NULL, NULL, 
                               (LPBYTE)buffer, &dwDataSize);

cleanup:
    if ((ERROR_SUCCESS != result) && (NULL != buffer))
    {
        free(buffer);
        buffer = NULL;
    }
    RegCloseKey(hKey);

    return buffer;
}

#define MAX_VALUE_LENGTH 255
//---------------------------------------------------------------
DWORD OpenInfsFromRegistry()
{
    HKEY  hKey;
    DWORD dwIndex = 0;
    char  szData[MAX_PATH + 1];
    char  szValueName[MAX_VALUE_LENGTH];
    DWORD dwValueSize;
    DWORD dwDataSize;
    DWORD result = ERROR_SUCCESS;

    result = RegOpenKeyEx( HKEY_CURRENT_USER, LOADSTATE_KEY, 0, KEY_READ, &hKey );
    FAIL_ON_ERROR( result );

    do
    {
        dwDataSize  = MAX_PATH;
        dwValueSize = MAX_VALUE_LENGTH;
        result = RegEnumValueA(hKey, dwIndex, 
                               szValueName, &dwValueSize,
                               NULL, NULL,
                               (UCHAR *)szData, &dwDataSize);

        if (ERROR_NO_MORE_ITEMS != result)
        {
            FAIL_ON_ERROR( result );

            // If this is an Inf* key, then open the Inf file
            if (0 == strncmp(szValueName, "Inf", 3))
            {
                result = OpenInf( szData );
                FAIL_ON_ERROR( result );
            }

            dwIndex++;
        }
    } while (ERROR_SUCCESS == result);

cleanup:
    RegCloseKey(hKey);
    return result;
}

//---------------------------------------------------------------
DWORD ParseParams( int argc, char *argv[], BOOL scan, TCHAR *pszFullLogFilename )
{
  int i;
  BOOL  cleared_flags = FALSE;
  DWORD result;
  char *error;
  int iarg;
  BOOL fAppendLog = FALSE;
  BOOL fLogFile   = FALSE;
  TCHAR *logfile = NULL;
  TCHAR szArgv[MAX_PATH + 1];
  char *lpData;

  // Save the OS version.
  Win9x = (GetVersion() & 0x80000000);

  // Check all the parameters.
  for (i = 1; i < argc; i++)
  {
      if (argv[i][0] == '/' ||
          argv[i][0] == '-')
      {
          switch (tolower(argv[i][1]))
          {
          case 'a':
              OutputAnsi = TRUE;
              break;
          case 'f':
              CopyFiles = TRUE;
              if (!cleared_flags)
              {
                  CopyUser      = FALSE;
                  CopySystem    = FALSE;
                  SchedSystem   = FALSE;
                  cleared_flags = TRUE;
              }
              break;
          case 'i':
              // Verify that there is a file name.
              if (i == argc-1)
              {
                  Win32PrintfResourceA( Console, IDS_INF_REQUIRED );
                  PrintHelp( scan );
                  return ERROR_INVALID_PARAMETER;
              }

              // Open the inf file.
              i += 1;
              result = OpenInf( argv[i] );
              if (result != ERROR_SUCCESS)
                  return result;
              break;
          case 'l':
              // Verify that there is a file name.
              if (i == argc-1)
              {
                  Win32PrintfResourceA( Console, IDS_LOG_REQUIRED );
                  PrintHelp( scan );
                  return ERROR_INVALID_PARAMETER;
              }

              // Fail if the log file was already specified.
              if (fLogFile == TRUE)
              {
                  Win32PrintfResourceA( Console, IDS_LOG_ONCE );
                  PrintHelp( scan );
                  return ERROR_INVALID_PARAMETER;
              }

              i += 1;
#ifdef _UNICODE
              if (0 == MultiByteToWideChar (GetACP(), 0, argv[i], -1, szArgv, MAX_PATH))
              {
                  result = GetLastError();
                  Win32PrintfResourceA( Console, IDS_INVALID_PARAMETER, argv[i] );
                  return result;
              }
              logfile = szArgv;
#else
              logfile = argv[i];
#endif
              fLogFile = TRUE;
              break;
          case 'm':
              ReallyCopyFiles = FALSE;
              break;
          case 'p':
              UserPortion = TRUE;
              fAppendLog = TRUE;

              if (!scan)
              {
                  if (fLogFile == TRUE)
                  {
                      Win32PrintfResourceA( Console, IDS_LOG_ONCE );
                      PrintHelp( scan );
                      return ERROR_INVALID_PARAMETER;
                  }
                  lpData = GetValueFromRegistry("Logfile");
#ifdef _UNICODE
                  if (0 == MultiByteToWideChar (GetACP(), 0, lpData, -1, szArgv, MAX_PATH))
                  {
                      result = GetLastError();
                      Win32PrintfResourceA( Console, IDS_INVALID_PARAMETER, lpData);
                      return result;
                  }
                  logfile = szArgv;
#else
                  logfile = lpData;
#endif
                  fLogFile = TRUE;

                  MigrationPath = GetValueFromRegistry("Store");
                  if (MigrationPath != NULL)
                  {
                      MultiByteToWideChar(CP_ACP, 0,  MigrationPath, -1,
                                          wcsMigrationPath, MAX_PATH + 1);
                  }

                  OpenInfsFromRegistry();
              }
              break;
          case 'q':
              // TestMode will:
              // - skip version checking the OS 
              // - not create a user hive with /f (still will with /u)
              TestMode = TRUE;
              break;
          case 'r':  // run once
              SchedSystem = TRUE;
              if (!cleared_flags)
              {
                  CopyFiles     = FALSE;
                  CopySystem    = FALSE;
                  CopyUser      = FALSE;
                  cleared_flags = TRUE;
              }
              break;
          case 's':
              CopySystem = TRUE;
              if (!cleared_flags)
              {
                  CopyFiles     = FALSE;
                  CopyUser      = FALSE;
                  SchedSystem   = FALSE;
                  cleared_flags = TRUE;
              }
              break;
          case 'u':
              CopyUser = TRUE;
              if (!cleared_flags)
              {
                  CopyFiles     = FALSE;
                  CopySystem    = FALSE;
                  SchedSystem   = FALSE;
                  cleared_flags = TRUE;
              }
              break;
          case 'v':
              // Verify that there is a verbosity argument
              i += 1;
              if ((i == argc) || (1 != sscanf(argv[i], "%d", &iarg)))
              {
                  Win32PrintfResourceA( Console, IDS_VERBOSE_FLAG_REQUIRED );
                  PrintHelp( scan );
                  return ERROR_INVALID_PARAMETER;
              }

              if ( ( iarg & VERBOSE_BIT ) == VERBOSE_BIT )
              {
                  Verbose = TRUE;
              }
              if ( ( iarg & DEBUGOUTPUT_BIT ) == DEBUGOUTPUT_BIT )
              {
                  DebugOutput = TRUE;
              }
              if ( ( iarg & VERBOSEREG_BIT ) == VERBOSEREG_BIT )
              {
                  VerboseReg = TRUE;
              }
              break;
          case 'x':
              if (!cleared_flags)
              {
                  CopyFiles     = FALSE;
                  CopySystem    = FALSE;
                  CopyUser      = FALSE;
                  SchedSystem   = FALSE;
                  cleared_flags = TRUE;
              }
              break;
          case '9':
              Win9x = TRUE;
              break;

          default:

              // There should be no other switches defined.

              Win32PrintfResourceA( Console, IDS_INVALID_PARAMETER, argv[i] );
              PrintHelp( scan );
              return ERROR_INVALID_PARAMETER;
          }
      }
      else if (MigrationPath != NULL)
      {
        // The path to the server should be specified exactly once.
        Win32PrintfResourceA( Console, IDS_INVALID_PARAMETER, argv[i] );
        PrintHelp( scan );
        return ERROR_INVALID_PARAMETER;
      }
      else
      {
        // Save the migration path.
        MigrationPath = argv[i];
        DWORD ccMigPath;
        if (!(ccMigPath = MultiByteToWideChar(CP_ACP,
                                              0,
                                              MigrationPath,
                                              -1,
                                              wcsMigrationPath,
                                              MAX_PATH + 1)))
        {
            Win32PrintfResourceA( Console,
                                  IDS_INVALID_PARAMETER,
                                  MigrationPath );
            PrintHelp( scan );
            return ERROR_INVALID_PARAMETER;
        }
      }
  }

  // Verify that a path was specified.
  if (MigrationPath == NULL)
  {
    Win32PrintfResourceA( Console, IDS_MISSING_MIGRATION );
    PrintHelp( scan );
    return ERROR_INVALID_PARAMETER;
  }

  // Open LogFile
  if ( fLogFile == FALSE )
  {
      if (scan)
          logfile = TEXT("scanstate.log");
      else
          logfile = TEXT("loadstate.log");
  }
  if (fAppendLog == FALSE)
  {
     // Delete any previous log
     DeleteFile( logfile );
  }
  LogFile = CreateFile( logfile,
                        GENERIC_WRITE, 0, NULL,
                        fAppendLog ? OPEN_ALWAYS : CREATE_NEW,
                        FILE_ATTRIBUTE_NORMAL, NULL );
  if (LogFile == INVALID_HANDLE_VALUE)
  {
      result = GetLastError();
      Win32PrintfResourceA( Console, IDS_OPEN_LOG_ERROR, logfile );
      error = NULL;
      FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                      FORMAT_MESSAGE_FROM_SYSTEM,
                      0,
                      result,
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                     (char *) &error,
                      0,
                      NULL );
    if (error != NULL)
    {
        Win32Printf( Console, error );
        LocalFree( error );
    }
    return result;
  }
  else if (fAppendLog == TRUE)
  {
      // Move file pointer to the end of the file,
      // so we won't overwrite previous entries
      result = SetFilePointer( LogFile, 0, NULL, FILE_END);
      if ( result == INVALID_SET_FILE_POINTER )
      {
          result = GetLastError();
          Win32PrintfResourceA( Console, IDS_OPEN_LOG_ERROR, logfile );
          error = NULL;
          FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                          FORMAT_MESSAGE_FROM_SYSTEM,
                          0,
                          result,
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                         (char *) &error,
                          0,
                          NULL );
          if (error != NULL)
          {
              Win32Printf( Console, error );
              LocalFree( error );
          }
          return result;
      }
  }

  TCHAR *ptsFileNamePart;
  result = GetFullPathName( logfile, MAX_PATH, pszFullLogFilename, &ptsFileNamePart);
  if (0 == result)
  {
      return GetLastError();
  }

  return ERROR_SUCCESS; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\common\common.cxx ===
//--------------------------------------------------------------
//
// File:        common
//
// Contents:    Functions shared between ScanState and LoadState.
//
//---------------------------------------------------------------

#include <common.hxx>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <io.h>
#include <malloc.h>
#include <objerror.h>
#include <stdlib.h>

//---------------------------------------------------------------
// Constants.

const DWORD LINEBUFSIZE                 = 1024;

//---------------------------------------------------------------
// Types.

typedef struct
{
  TOKEN_PRIVILEGES    tp;
  LUID_AND_ATTRIBUTES luid2;
} TOKEN_PRIVILEGES2;

//---------------------------------------------------------------
// Globals.

HANDLE  Console       = INVALID_HANDLE_VALUE;
BOOL    CopyFiles     = TRUE;
BOOL    CopySystem    = TRUE;
BOOL    CopyUser      = TRUE;
HKEY    CurrentUser   = NULL;
BOOL    DebugOutput   = FALSE;
BOOL    ExcludeByDefault = TRUE;
HINF    InputInf      = INVALID_HANDLE_VALUE;
HANDLE  LogFile       = INVALID_HANDLE_VALUE;
BOOL    OutputAnsi    = FALSE;
HANDLE  OutputFile    = INVALID_HANDLE_VALUE;
char   *MigrationPath = NULL;
WCHAR   wcsMigrationPath[MAX_PATH + 1];
BOOL    ReallyCopyFiles = TRUE;
BOOL    SchedSystem   = TRUE;
HANDLE  STDERR        = INVALID_HANDLE_VALUE;
BOOL    TestMode      = FALSE;
BOOL    UserPortion   = FALSE;
BOOL    Verbose       = FALSE;
BOOL    VerboseReg    = FALSE;
BOOL    Win9x         = TRUE;

MRtlConvertSidToUnicodeString   GRtlConvertSidToUnicodeString = NULL;
MRtlInitUnicodeString           GRtlInitUnicodeString         = NULL;
MRtlFreeUnicodeString           GRtlFreeUnicodeString         = NULL;
MDuplicateTokenEx               GDuplicateTokenEx             = NULL;

//---------------------------------------------------------------
DWORD OpenFiles()
{
    DWORD result = ERROR_SUCCESS;

    // Open the console.
    Console = CreateFileA( "CONOUT$", GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
                          0, NULL );
    if (Console == INVALID_HANDLE_VALUE)
    {
        result = GetLastError();
        goto cleanup;
    }
    STDERR = GetStdHandle(STD_ERROR_HANDLE);

cleanup:
  return result;
}


//---------------------------------------------------------------
void CloseFiles()
{
  // Don't close Console.
  if (InputInf != INVALID_HANDLE_VALUE)
    SetupCloseInfFile( InputInf );
  if (LogFile != INVALID_HANDLE_VALUE)
    CloseHandle( LogFile );
  if (OutputFile != INVALID_HANDLE_VALUE)
    CloseHandle( OutputFile );
}

//---------------------------------------------------------------
DWORD EnableBackupPrivilege()
{
  HANDLE            process  = NULL;
  HANDLE            process2 = NULL;
  TOKEN_PRIVILEGES2 tp;
  LUID              backup;
  LUID              restore;
  BOOL              success;
  DWORD             result   = ERROR_SUCCESS;

  // Do nothing on Win9x.
  if (Win9x)
    return ERROR_SUCCESS;
  result = NtImports();
  LOG_ASSERT( result );

  // Get the process token
  success = OpenProcessToken( GetCurrentProcess(),
                              TOKEN_DUPLICATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                              &process );
  LOG_ASSERT_GLE( success, result );

  // Convert it into an impersonation token.
  success = GDuplicateTokenEx( process,
                               MAXIMUM_ALLOWED,
                               NULL, SecurityImpersonation, TokenImpersonation,
                               &process2 );
  LOG_ASSERT_GLE( success, result );

  // Get LUID for backup privilege.
  success = LookupPrivilegeValue(
        NULL,            // lookup privilege on local system
        SE_BACKUP_NAME,
        &backup );
  LOG_ASSERT_GLE( success, result );

  // Get LUID for restore privilege.
  success = LookupPrivilegeValue(
        NULL,            // lookup privilege on local system
        SE_RESTORE_NAME,
        &restore );
  LOG_ASSERT_GLE( success, result );

  // Fill in the token privilege structure.
  tp.tp.PrivilegeCount = 2;
  tp.tp.Privileges[0].Luid = backup;
  tp.tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
  tp.tp.Privileges[1].Luid = restore;
  tp.tp.Privileges[1].Attributes = SE_PRIVILEGE_ENABLED;

  // Enable the privilege or disable all privileges.
  success = AdjustTokenPrivileges( process2, FALSE, &tp.tp, 0, NULL, NULL );
  LOG_ASSERT_GLE( success, result );

  // Save the token on the thread.
  success = SetThreadToken( NULL, process2 );
  LOG_ASSERT_GLE( success, result );

  // Close the token handles.
cleanup:
  if (process != NULL)
    CloseHandle( process );
  if (process2 != NULL)
    CloseHandle( process2 );
  return result;
}

//---------------------------------------------------------------
DWORD MakeUnicode( char *buffer, WCHAR **wbuffer )
{
  DWORD len;
  DWORD wlen;

  // Allocate a buffer to hold the unicode string.
  len      = strlen( buffer ) + 1;
  wlen     = MultiByteToWideChar( CP_ACP, 0, buffer, len, NULL, 0 );
  *wbuffer = (WCHAR *) malloc( wlen*sizeof(WCHAR) );
  if (*wbuffer == NULL)
    return ERROR_NOT_ENOUGH_MEMORY;

  // Convert the buffer to unicode.
  wlen = MultiByteToWideChar( CP_ACP, 0, buffer, len, *wbuffer, wlen );
  if (wlen == 0)
    return GetLastError();
  return ERROR_SUCCESS;
}

//---------------------------------------------------------------
DWORD NtImports()
{
  DWORD      result = ERROR_SUCCESS;
  HINSTANCE  ntdll;
  HINSTANCE  advapi32;

  // Do nothing on Win9x.
  if (Win9x || GRtlConvertSidToUnicodeString != NULL)
    return ERROR_SUCCESS;

  // Load ntdll.dll
  ntdll = LoadLibraryA( "ntdll.dll" );
  if (ntdll == NULL)
  {
    result = GetLastError();
    goto cleanup;
  }

  // Get the functions
  GRtlConvertSidToUnicodeString = (MRtlConvertSidToUnicodeString) GetProcAddress( ntdll, "RtlConvertSidToUnicodeString" );
  GRtlInitUnicodeString         = (MRtlInitUnicodeString) GetProcAddress( ntdll, "RtlInitUnicodeString" );
  GRtlFreeUnicodeString         = (MRtlFreeUnicodeString) GetProcAddress( ntdll, "RtlFreeUnicodeString" );

  // Make sure all the functions were found.
  if (   GRtlConvertSidToUnicodeString == NULL
      || GRtlInitUnicodeString         == NULL
      || GRtlFreeUnicodeString         == NULL
     )
  {
    result = GetLastError();
    goto cleanup;
  }

  // Load advapi32.dll
  advapi32 = LoadLibraryA( "advapi32.dll" );
  if (advapi32 == NULL)
  {
    result = GetLastError();
    goto cleanup;
  }

  // Get the functions.
  GDuplicateTokenEx = (MDuplicateTokenEx) GetProcAddress( advapi32, "DuplicateTokenEx" );
  if (GDuplicateTokenEx == NULL)
  {
    result = GetLastError();
    goto cleanup;
  }

cleanup:
  if (result != ERROR_SUCCESS)
  {
    GRtlConvertSidToUnicodeString = NULL;
    GRtlInitUnicodeString         = NULL;
    GRtlFreeUnicodeString         = NULL;
    GDuplicateTokenEx             = NULL;
  }
  return result;
}

//---------------------------------------------------------------
DWORD OpenInf( char *file )
{
  BOOL  success;
  UINT  errorline;
  DWORD result = ERROR_SUCCESS;
  char *error;

  // If there have not been any INF files, open this as the first.
  if (InputInf == INVALID_HANDLE_VALUE)
  {
    InputInf = SetupOpenInfFileA( file, NULL, INF_STYLE_WIN4, &errorline );
    success = InputInf != INVALID_HANDLE_VALUE;
  }
  else
    success = SetupOpenAppendInfFileA( file, InputInf, &errorline );

  // If the open failed, print a message and exit.
  if (!success)
  {
    result = GetLastError();
    Win32PrintfResourceA( Console, IDS_OPEN_INF_ERROR, file );
    error = NULL;
    FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                   0, result,
                   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                   (char *)&error, 0, NULL );
    if (error != NULL)
    {
      Win32Printf( Console, error );
      LocalFree( error );
    }
  }
  return result;
}

//---------------------------------------------------------------
BOOL PopupError( char *expr, char *file, DWORD line )
{
  char  szModuleName[128];
  char  errMessage[128];  // generated error string
  DWORD tid = GetCurrentThreadId();
  DWORD pid = GetCurrentProcessId();
  char *pszModuleName;

  // Compute the name of the process.
  if (GetModuleFileNameA(NULL, szModuleName, 128))
  {
      pszModuleName = strrchr(szModuleName, '\\');
      if (!pszModuleName)
      {
          pszModuleName = szModuleName;
      }
      else
      {
          pszModuleName++;
      }
  }
  else
  {
      pszModuleName = "Unknown";
  }

  // Compute a title for the popup.
  wsprintfA(errMessage,"Process: %s File: %s line %u, thread id %d.%d",
            pszModuleName, file, line, pid, tid);

  // Return the result of the message bux.
  return MessageBoxA( NULL, expr, errMessage,
                      MB_SETFOREGROUND | MB_TASKMODAL | MB_ICONEXCLAMATION |
                      MB_OKCANCEL );
}

//---------------------------------------------------------------
void PrintHelp( BOOL scan )
{
  Win32PrintfResourceA( Console, IDS_WHAT );
  Win32PrintfResourceA( Console, scan ? IDS_CMD1S : IDS_CMD1L );
  Win32PrintfResourceA( Console, IDS_CMD2 );
  Win32PrintfResourceA( Console, IDS_CMD_I );
  Win32PrintfResourceA( Console, IDS_CMD_L );
  Win32PrintfResourceA( Console, IDS_CMD_V );
  if ( Verbose | VerboseReg | DebugOutput )
     Win32PrintfResourceA( Console, IDS_CMD_V_BITS );
  Win32PrintfResourceA( Console, IDS_CMD_X );
  Win32PrintfResourceA( Console, IDS_CMD_U );
  Win32PrintfResourceA( Console, IDS_CMD_F );
  Win32PrintfResourceA( Console, IDS_CMD_PATH );
}

//---------------------------------------------------------------
// This function converts a Win32 result into a resource id.
DWORD ResultToRC( DWORD result )
{
  if (result == ERROR_WRITE_FAULT)
    return IDS_WRITE_FAULT;
  else if (result == ERROR_NOT_ENOUGH_MEMORY)
    return IDS_NOT_ENOUGH_MEMORY;
  else if (result == ERROR_ACCESS_DENIED ||
           result == ERROR_PRIVILEGE_NOT_HELD)
    return IDS_MUST_BE_ADMIN;
  else if (result == SPAPI_E_SECTION_NOT_FOUND)
    return IDS_SECTION_NOT_FOUND;
  else
    return IDS_FAILED;
}


//---------------------------------------------------------------
// This function prints from a resource string as a format string
// to a unicode win32 file handle.  It is not thread safe.
// %s in a format string means a ascii parameter.
DWORD Win32PrintfResourceA( HANDLE file, DWORD resource_id, ... )
{
  BOOL     success;
  DWORD    len;
  va_list  va;
  char    *buffer  = NULL;
  DWORD    written;
  DWORD    wlen;
  WCHAR   *wbuffer = NULL;
  DWORD    result  = ERROR_SUCCESS;
  CHAR     PrintBuffer[LINEBUFSIZE];

  // Try to load the string.
  len = LoadStringA( NULL, resource_id, PrintBuffer, LINEBUFSIZE );
  DEBUG_ASSERT( len != 0 && len < LINEBUFSIZE );

  // Format the message.
  va_start( va, resource_id );
  success = FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                            PrintBuffer, 0,
                            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                            (char *) &buffer, 0, &va );
  va_end( va );
  DEBUG_ASSERT( success );
  if (!success)
  {
    result = GetLastError();
    goto cleanup;
  }

  // When printing to the console or logfile use ascii.
  // When printing to the migration file use Unicode.
  len     = strlen(buffer);
  if (file != OutputFile)
  {
    wbuffer = (WCHAR *) buffer;
    wlen    = len;
  }
  else
  {
    // Allocate a buffer to hold the unicode string.
    wlen    = MultiByteToWideChar( CP_ACP, 0, buffer, len, NULL, 0 );
    wbuffer = (WCHAR *) _alloca( wlen*sizeof(WCHAR) );
    if (wbuffer == NULL)
    {
      result = ERROR_NOT_ENOUGH_MEMORY;
      goto cleanup;
    }

    // Convert the buffer to unicode.
    wlen = MultiByteToWideChar( CP_ACP, 0, buffer, len, wbuffer, wlen );
    if (wlen == 0)
    {
      result = GetLastError();
      goto cleanup;
    }
    wlen *= sizeof(WCHAR);
  }

  // Write the unicode string.
  success = WriteFile( file, wbuffer, wlen,  &written, NULL );
  if (!success || wlen != written)
  {
    result = GetLastError();
    goto cleanup;
  }

  if (file == STDERR)
  {
      //Also write to the log file for these
      success = WriteFile( LogFile, wbuffer, wlen,  &written, NULL );
      if (!success || wlen != written)
      {
          result = GetLastError();
          goto cleanup;
      }
  }

cleanup:
  if (buffer != NULL)
    LocalFree( buffer );
  return result;
}

//---------------------------------------------------------------
// This function prints from a resource string as a format string
// to a unicode win32 file handle.  It is not thread safe.
// %s in a format string means a unicode parameter.
DWORD Win32PrintfResourceW( HANDLE file, DWORD resource_id, ... )
{
  BOOL     success;
  DWORD    len;
  va_list  va;
  CHAR    *buffer  = NULL;
  DWORD    written;
  DWORD    wlen;
  WCHAR   *wbuffer = NULL;
  DWORD    result  = ERROR_SUCCESS;
  WCHAR    PrintBuffer[LINEBUFSIZE];

  // Try to load the string.
  wlen = LoadStringW( NULL, resource_id, PrintBuffer, LINEBUFSIZE );
  DEBUG_ASSERT( wlen != 0 && wlen < LINEBUFSIZE );

  // Format the message.
  va_start( va, resource_id );
  success = FormatMessageW( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                            PrintBuffer, 0,
                            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                            (WCHAR *) &wbuffer, 0, &va );
  va_end( va );
  DEBUG_ASSERT( success && "The resource ids are probably wrong, try doing a clean compile" );
  if (!success)
  {
    result = GetLastError();
    goto cleanup;
  }

  // When printing to the console or logfile use ascii.
  // When printing to the migration file use Unicode.
  wlen     = wcslen(wbuffer);
  if (file == OutputFile)
  {
    buffer = (CHAR *) wbuffer;
    len    = wlen * sizeof(WCHAR);
  }
  else
  {
    // Allocate a buffer to hold the ascii string.
    len    = WideCharToMultiByte( CP_ACP, 0, wbuffer, wlen, NULL, 0, NULL, NULL );
    buffer = (CHAR *) _alloca( len );
    if (buffer == NULL)
    {
      result = ERROR_NOT_ENOUGH_MEMORY;
      goto cleanup;
    }

    // Convert the buffer to unicode.
    len = WideCharToMultiByte( CP_ACP, 0, wbuffer, wlen, buffer, len, NULL, NULL );
    if (len == 0)
    {
      result = GetLastError();
      goto cleanup;
    }
  }

  // Write the unicode string.
  success = WriteFile( file, buffer, len,  &written, NULL );
  if (!success || len != written)
  {
    result = GetLastError();
    goto cleanup;
  }

  if (file == STDERR)
  {
      //Also write to the log file for these
      success = WriteFile( LogFile, wbuffer, wlen,  &written, NULL );
      if (!success || wlen != written)
      {
          result = GetLastError();
          goto cleanup;
      }
  }

cleanup:
  if (wbuffer != NULL)
    LocalFree( wbuffer );
  return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\common\resource.h ===
#define IDS_COMPLETE_OK                   0
#define IDS_WRITE_FAULT                   1
#define IDS_NOT_ENOUGH_MEMORY             2
#define IDS_MUST_BE_ADMIN                 3
#define IDS_FAILED                        4
#define IDS_UNSUPPORTED_REGISTRY_KEY_TYPE 5
#define IDS_NOT_ENOUGH_DISK_SPACE         6
#define IDS_FILE_NOT_FOUND                7
#define IDS_SECTION_NOT_FOUND             8
#define IDS_INF_ERROR                     9
#define IDS_WRONG_OS                      10
#define IDS_CANT_LOAD_CURRENT_USER        11
#define IDS_COMPLETE_ERROR                12
#define IDS_OS5                           13
#define IDS_INF_REQUIRED                  14
#define IDS_OPEN_INF_ERROR                15
#define IDS_INVALID_PARAMETER             16
#define IDS_MISSING_MIGRATION             17
#define IDS_LOG_REQUIRED                  18
#define IDS_LOG_ONCE                      19
#define IDS_OPEN_LOG_ERROR                20
#define IDS_WHAT                          21
#define IDS_CMD1S                         22
#define IDS_CMD2                          23
#define IDS_CMD_I                         24
#define IDS_CMD_L                         25
#define IDS_CMD_X                         26
#define IDS_CMD_V                         27
#define IDS_CMD_F                         28
#define IDS_CMD_U                         29
#define IDS_CMD_PATH                      30
#define IDS_CMD1L                         31
#define IDS_INVALID_DOMAIN_USER           32
#define IDS_INVALID_USER                  33
#define IDS_OS_WARNING                    34
#define IDS_OS5_WARNING                   35
#define IDS_REG_ACCESS                    36
#define IDS_CANNOT_ENUM_NETSHARES         37
#define IDS_SHARE_PASSWORD_NOT_MIGRATED   38
#define IDS_RAS_PROTOCOL_NOT_SUPPORTED    39
#define IDS_RAS_NO_MODEM_LINE_DEVICE      40
#define IDS_VERBOSE_FLAG_REQUIRED         41
#define IDS_CMD_V_BITS                    42
#define IDS_FILENAME_TOOLONG              43
#define IDS_RAS_CANNOT_ENUM               44
#define IDS_RAS_ENTRY_NOT_MIGRATED        45
#define IDS_INF_EXISTS                    46
#define IDS_PRINTER_MIGRATED              47 
#define IDS_PRINTER_MISSINGNAME           48
#define IDS_PRINTER_MISSINGPORT           49
#define IDS_PRINTER_MISSINGDRIVER         50
#define IDS_PRINTER_MISSINGPROC           51
#define IDS_PRINTER_TRANSERROR            52
#define IDS_USER_PROFILE_FAILED           53

#define IDS_FILE_ENUMFAIL                  101
#define IDS_FILE_COPYERROR                 102
#define IDS_FILE_DIRECTORYERROR            103
#define IDS_SECTION_NAME_NOT_FOUND         104
#define IDS_ACCESS_DENIED                  105
#define IDS_GETSTRINGFIELD_ERROR           106
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\common\fileutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 1998.
//
//  File:	fileutil.cxx
//
//  Contents:	Utility functions for file migration
//
//  Classes:	
//
//  Functions:	
//
//  History:	07-Sep-99	PhilipLa	Created
//
//----------------------------------------------------------------------------

#include "common.hxx"
#include "fileutil.hxx"
#include <tchar.h>

#define LINEBUFSIZE 1024

DWORD StatePrintfA (HANDLE h, CHAR *szFormat, ...)
{
    CHAR szBuffer[LINEBUFSIZE];
#if 0    
#ifdef UNICODE
    WCHAR wszFormat[LINEBUFSIZE];

    //Convert to Unicode
    UINT uCodePage = AreFileApisANSI() ? CP_ACP : CP_OEMCP;
    
    if (0 == MultiByteToWideChar(uCodePage,
                                 0,
                                 szFormat,
                                 -1,
                                 wszFormat,
                                 LINEBUFSIZE))
    {
        return GetLastError();
    }
    ptsFormat = wszFormat;
#else
    ptsFormat = szFormat;
#endif
#endif
    
    va_list     va;
    ULONG       ulWritten;
    ULONG       ulLen;

    va_start (va, szFormat);
    ulLen = FormatMessageA(FORMAT_MESSAGE_FROM_STRING,
                           szFormat,
                           0,
                           0,
                           szBuffer,
                           LINEBUFSIZE,
                           &va);
    va_end(va);
    
    if (FALSE == WriteFile (h, szBuffer, ulLen, &ulWritten, NULL))
        return GetLastError();
    else
    {
        if (ulWritten != ulLen)        // incomplete write
            return ERROR_WRITE_FAULT;  // last error may not be set
    }

    return ERROR_SUCCESS;
}



BOOL MatchString(const TCHAR *ptsPattern,
                 const TCHAR *ptsString,
                 const BOOL bRequireNullPatMatch)
{
    ULONG iPat = 0;
    ULONG iStr = 0;
    
    TCHAR tcPat;
    TCHAR tcStr;

    if (ptsPattern[0] == 0)
    {
        //No pattern to match

        if (bRequireNullPatMatch == FALSE)
            return TRUE;

        if ( ptsString[0] == 0)
            return TRUE;

        return FALSE;
    }

    //Special case:  Empty string, * as pattern
    if (ptsString[0] == 0 &&
        ptsPattern[0] == TEXT('*') &&
        ptsPattern[1] == 0)
    {
        return TRUE;
    }
    
    while (ptsString[iStr])
    {
        tcPat = (TCHAR)_totlower(ptsPattern[iPat]);
        tcStr = (TCHAR)_totlower(ptsString[iStr]);
        
        if (tcPat == 0)
        {
            //Reached end of pattern, return FALSE;
            return FALSE;
        }

        if (tcPat == TEXT('?'))
        {
            // Never match '\'
            if (tcStr == TEXT('\\'))
            {
               return FALSE;
            }
            //Match any single character in the string and continue.
            iPat++;
            iStr++;
        }
        else if (tcPat != TEXT('*'))
        {
            //Match character
            if (tcPat != tcStr)
            {
                return FALSE;
            }
            iPat++;
            iStr++;
        }
        else
        {
            while (ptsPattern[iPat + 1] == TEXT('*'))
            {
                //Skip consecutive *s
                iPat++;
            }
        
            //If * all the way to the end, return true.
            if (ptsPattern[iPat + 1] == 0)
                return TRUE;

            // Lookahead one
            tcPat = (TCHAR)_totlower(ptsPattern[iPat + 1]);
            if ((tcPat == tcStr) ||
                (tcPat == TEXT('?')))
            {
                // Next character matches, continue with expression
                if (MatchString(ptsPattern + iPat + 1, ptsString + iStr, bRequireNullPatMatch))
                    return TRUE;
            }
            // Eat another character with the '*' pattern
            iStr++;
        }
    }

    if (!ptsPattern[iPat] && !ptsString[iStr])
        return TRUE;

    // If only ?s and *s left in pattern, then call it a match
    if ( _tcsspnp(ptsPattern+iPat, TEXT("?*")) == NULL )
        return TRUE;

    return FALSE;
}


BOOL IsPatternMatchFull(const TCHAR *ptsPatternFull,
                        const TCHAR *ptsPath,
                        const TCHAR *ptsFilename)
{
    TCHAR tsPatternPath[MAX_PATH + 1];
    TCHAR tsPatternFile[MAX_PATH + 1];
    TCHAR tsPatternExt[MAX_PATH + 1];

    DeconstructFilename(ptsPatternFull,
                        tsPatternPath,
                        tsPatternFile,
                        tsPatternExt);
    
    return IsPatternMatch(tsPatternPath,
                          tsPatternFile,
                          tsPatternExt,
                          ptsPath,
                          ptsFilename);
}

BOOL IsPatternMatch(const TCHAR *ptsPatternDir,
                    const TCHAR *ptsPatternFile,
                    const TCHAR *ptsPatternExt,
                    const TCHAR *ptsPath,
                    const TCHAR *ptsFilename)
{
    BOOL fRet;
    TCHAR tsFilePath[MAX_PATH];
    TCHAR tsFileName[MAX_PATH];
    TCHAR tsFileExt[MAX_PATH];
    BOOL bRequireNullMatch = FALSE;


    DeconstructFilename(ptsFilename,
                        NULL,
                        tsFileName,
                        tsFileExt);

    //Special case:  Directories have a ptsFilename of NULL, but shouldn't
    //match on *.*

    if ((ptsFilename == NULL) &&
        (ptsPatternDir[0] == 0))
    {
        //Return FALSE;
        fRet = FALSE;
    }
    else
    {
        if ((ptsPatternFile == NULL) && (ptsPatternExt == NULL) &&
            (tsFileName[0] == 0) && (tsFileExt[0] == 0))
        {
            //Directory only
            fRet = MatchString(ptsPatternDir,
                               ptsPath,
                               FALSE);
        }
        else
        {
            // If filename or extension is specified in the pattern, 
            // match a null file piece only if pattern is null too.
            // i.e.: ".txt" and "*."
            if ( ptsPatternFile[0] != 0 || ptsPatternExt[0] != 0 )
                bRequireNullMatch = TRUE;
            
            fRet = (MatchString(ptsPatternDir,
                                ptsPath,
                                FALSE) &&
                    MatchString(ptsPatternFile,
                                tsFileName,
                                bRequireNullMatch) &&
                    MatchString(ptsPatternExt,
                                tsFileExt,
                                bRequireNullMatch));
        }
    }

    return fRet;
}


BOOL DeconstructFilename(const TCHAR *ptsString,
                         TCHAR *ptsPath,
                         TCHAR *ptsName,
                         TCHAR *ptsExt)
{
    const TCHAR *ptsLastSlash;
    const TCHAR *ptsLastDot;

    ptsLastSlash = (ptsString) ? _tcsrchr(ptsString, TEXT('\\')) : NULL;

    if (ptsLastSlash == NULL)
    {
        if (ptsPath)
            ptsPath[0] = 0;
        ptsLastSlash = ptsString;
    }
    else
    {
        if (ptsPath)
        {
            if (ptsLastSlash - ptsString + 1 > MAX_PATH)
            {
                if (DebugOutput)
                {
                    Win32Printf(LogFile, 
                                "Error: ptsString too long %*s\r\n", 
                                ptsLastSlash - ptsString + 1,
                                ptsString);
                }
                ptsPath[0] = 0;
                return FALSE;
            }
            _tcsncpy(ptsPath, ptsString, ptsLastSlash - ptsString + 1);
            ptsPath[ptsLastSlash - ptsString + 1] = 0;
        }
        ptsLastSlash++;
    }

    
    ptsLastDot = (ptsLastSlash) ? _tcsrchr(ptsLastSlash, TEXT('.')) : NULL;

    if (ptsLastDot == NULL)
    {
        if (ptsExt)
            ptsExt[0] = 0;
        if (ptsName)
        {
            if (ptsLastSlash)
            {
                if (_tcslen(ptsLastSlash) > MAX_PATH)
                {
                    if (DebugOutput)
                    {
                        Win32Printf(LogFile, "Error: ptsLastSlash too long %s\r\n", ptsLastSlash);
                    }
                    ptsName[0] = 0;
                    return FALSE;
                }
                _tcscpy(ptsName, ptsLastSlash);
            }
            else
            {
                ptsName[0] = 0;
            }
        }
    }
    else
    {
        if (ptsExt)
        {
            if (_tcslen(ptsLastDot+1) > MAX_PATH)
            {
                if (DebugOutput)
                {
                    Win32Printf(LogFile, "Error: ptsLastDot too long %s\r\n", ptsLastDot+1);
                }
                ptsExt[0] = 0;
                return FALSE;
            }
            _tcscpy(ptsExt, ptsLastDot + 1);
        }
        if (ptsName)
        {
            if (ptsLastDot - ptsLastSlash > MAX_PATH)
            {
                if (DebugOutput)
                {
                    Win32Printf(LogFile, 
                                "Error: ptsLastSlash Too Long %*s\r\n", 
                                ptsLastDot - ptsLastSlash,
                                ptsLastSlash);
                }
                ptsName[0] = 0;
                return FALSE;
            }
            _tcsncpy(ptsName, ptsLastSlash, ptsLastDot - ptsLastSlash);
            ptsName[ptsLastDot - ptsLastSlash] = 0;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\imported\net\rras\ras\inc\rasmxs.h ===
//****************************************************************************
//
//                     Microsoft NT Remote Access Service
//
//      Copyright (C) 1992-93 Microsft Corporation. All rights reserved.
//
//  Filename: rasmxs.h
//
//  Revision History:
//
//  Jun 24, 1992   J. Perry Hannah   Created
//
//
//  Description: This file contains name strings for standard macros and
//               variables found in modem.inf, pad.inf, and switch.inf.
//               This header file will be needed by all users.
//
//****************************************************************************


#ifndef _RASMXS_
#define _RASMXS_


//  General Defines  *********************************************************
//

#include <rasfile.h>


#define  MAX_PHONE_NUMBER_LENGTH    RAS_MAXLINEBUFLEN

#define  MXS_PAD_TXT                "pad"
#define  MXS_MODEM_TXT              "modem"
#define  MXS_SWITCH_TXT             "switch"
#define  MXS_NULL_TXT               "null"

#define  ATTRIB_VARIABLE            0x08
#define  ATTRIB_BINARYMACRO         0x04
#define  ATTRIB_USERSETTABLE        0x02
#define  ATTRIB_ENABLED             0x01


//  Unary Macros  ************************************************************
//
                                                                    //Used in:

#define  MXS_PHONENUMBER_KEY        "PhoneNumber"                   //modem.inf
#define  MXS_CARRIERBPS_KEY         "CarrierBps"                    //modem.inf
#define  MXS_CONNECTBPS_KEY         "ConnectBps"                    //modem.inf

#define  MXS_X25PAD_KEY             "X25Pad"                        //pad.inf
#define  MXS_X25ADDRESS_KEY         "X25Address"                    //pad.inf
#define  MXS_DIAGNOSTICS_KEY        "Diagnostics"                   //pad.inf
#define  MXS_USERDATA_KEY           "UserData"                      //pad.inf
#define  MXS_FACILITIES_KEY         "Facilities"                    //pad.inf

#define  MXS_MESSAGE_KEY	    "Message"			    //all

#define  MXS_USERNAME_KEY	    "UserName"			    //all
#define  MXS_PASSWORD_KEY	    "Password"			    // all


//  Binary Macros  ***********************************************************
//

#define  MXS_SPEAKER_KEY            "Speaker"                       //modem.inf
#define  MXS_HDWFLOWCONTROL_KEY     "HwFlowControl"                 //modem.inf
#define  MXS_PROTOCOL_KEY           "Protocol"                      //modem.inf
#define  MXS_COMPRESSION_KEY        "Compression"                   //modem.inf
#define  MXS_AUTODIAL_KEY           "AutoDial"                      //modem.inf


//  Binary Macro Suffixes  ***************************************************
//

#define  MXS_ON_SUFX                "_on"                           //all
#define  MXS_OFF_SUFX               "_off"                          //all


//  INF File Variables  ******************************************************
//

#define  MXS_DEFAULTOFF_KEY         "DEFAULTOFF"                    //modem.inf
#define  MXS_CALLBACKTIME_KEY       "CALLBACKTIME"                  //modem.inf
#define  MXS_MAXCARRIERBPS_KEY      "MAXCARRIERBPS"                 //modem.inf
#define  MXS_MAXCONNECTBPS_KEY      "MAXCONNECTBPS"                 //modem.inf


//  Keywork Prefixes  ********************************************************
//

#define  MXS_COMMAND_PRFX           "COMMAND"                       //all
#define  MXS_CONNECT_PRFX           "CONNECT"                       //all
#define  MXS_ERROR_PRFX             "ERROR"                         //all
#define  MXS_OK_PRFX                "OK"                            //all


//  Modem Command Keywords  **************************************************
//

#define  MXS_GENERIC_COMMAND        "COMMAND"
#define  MXS_INIT_COMMAND           "COMMAND_INIT"
#define  MXS_DIAL_COMMAND           "COMMAND_DIAL"
#define  MXS_LISTEN_COMMAND         "COMMAND_LISTEN"


//  Modem Response Keywords  *************************************************
//

#define  MXS_OK_KEY                 "OK"

#define  MXS_CONNECT_KEY            "CONNECT"
#define  MXS_CONNECT_EC_KEY         "CONNECT_EC"

#define  MXS_ERROR_KEY              "ERROR"
#define  MXS_ERROR_BUSY_KEY         "ERROR_BUSY"
#define  MXS_ERROR_NO_ANSWER_KEY    "ERROR_NO_ANSWER"
#define  MXS_ERROR_VOICE_KEY        "ERROR_VOICE"
#define  MXS_ERROR_NO_CARRIER_KEY   "ERROR_NO_CARRIER"
#define  MXS_ERROR_NO_DIALTONE_KEY  "ERROR_NO_DIALTONE"
#define  MXS_ERROR_DIAGNOSTICS_KEY  "ERROR_DIAGNOSTICS"

#define  MXS_NORESPONSE             "NoResponse"
#define  MXS_NOECHO                 "NoEcho"



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\imported\net\rras\ras\inc\isdn.h ===
//****************************************************************************
//
//                     Microsoft NT Remote Access Service
//
//                     Copyright 1992-93
//
//  Filename: isdn.h
//
//  Revision History:
//
//  Feb 28, 1993	Gurdeep Pall Created
//
//
//  Description: This file contains all the device and media DLL interface
//		 information specific to ISDN.
//
//****************************************************************************


#ifndef _ISDNINCLUDE_
#define _ISDNINCLUDE_

#define ISDN_TXT "isdn"

// ISDN Media Parameter
//
#define ISDN_LINETYPE_KEY	"LineType"	// Param type NUMBER
#define ISDN_LINETYPE_VALUE_64DATA	0
#define ISDN_LINETYPE_VALUE_56DATA	1
#define ISDN_LINETYPE_VALUE_56VOICE	2
#define ISDN_LINETYPE_STRING_64DATA	"0"
#define ISDN_LINETYPE_STRING_56DATA	"1"
#define ISDN_LINETYPE_STRING_56VOICE	"2"


#define ISDN_FALLBACK_KEY	"Fallback"	// Param type NUMBER
#define ISDN_FALLBACK_VALUE_ON		1
#define ISDN_FALLBACK_VALUE_OFF 	0
#define ISDN_FALLBACK_STRING_ON		"1"
#define ISDN_FALLBACK_STRING_OFF	"0"



#define ISDN_COMPRESSION_KEY	"EnableCompression" // Param type NUMBER
#define ISDN_COMPRESSION_VALUE_ON	1
#define ISDN_COMPRESSION_VALUE_OFF	0
#define ISDN_COMPRESSION_STRING_ON	"1"
#define ISDN_COMPRESSION_STRING_OFF	"0"


#define ISDN_CHANNEL_AGG_KEY	"ChannelAggregation"// Param type NUMBER


// ISDN Device Parameter
//
#define ISDN_PHONENUMBER_KEY	"PhoneNumber"	// Param type STRING
#define MAX_PHONENUMBER_LEN	255

#define CONNECTBPS_KEY		"ConnectBPS"	// Param type STRING


//  Statistics information and indices.
//
#define NUM_ISDN_STATS		10

#define BYTES_XMITED		0	// Generic Stats
#define BYTES_RCVED             1
#define FRAMES_XMITED           2
#define FRAMES_RCVED            3

#define CRC_ERR 		4	// Isdn Stats
#define TIMEOUT_ERR             5
#define ALIGNMENT_ERR           6
#define SERIAL_OVERRUN_ERR      7
#define FRAMING_ERR             8
#define BUFFER_OVERRUN_ERR      9

#endif // _ISDNINCLUDE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\imported\net\inc\rasapip.h ===
/*++

Copyright (C) 1994-98 Microsft Corporation. All rights reserved.

Module Name:

    rasapip.h

Abstract:

    This file has definitions for private apis for ras connections.
    These apis are exported from rasapi32.dll

Author:

    Rao Salapaka (raos) 30-Jan-1998

Revision History:

--*/

#ifndef _RASAPIP_
#define _RASAPIP_

#include <windef.h> //for MAX_PATH

#ifdef __cplusplus
extern "C" {
#endif


#define RASAPIP_MAX_DEVICE_NAME     128
#define RASAPIP_MAX_ENTRY_NAME      256

#define RAS_DEVICE_TYPE(_x)     ((_x) & 0x0000FFFF)

#define RAS_DEVICE_CLASS(_x)    ((_x) & 0xFFFF0000)

enum _RASDEVICETYPE
{
    RDT_Modem = 0,

    RDT_X25,

    RDT_Isdn,

    RDT_Serial,

    RDT_FrameRelay,

    RDT_Atm,

    RDT_Sonet,

    RDT_Sw56,

    RDT_Tunnel_Pptp,

    RDT_Tunnel_L2tp,

    RDT_Irda,

    RDT_Parallel,

    RDT_Other,

    //
    // The following flags when set
    // specify the class of the device
    //
    RDT_Tunnel = 0x00010000,

    RDT_Direct  = 0x00020000,

    RDT_Null_Modem = 0x000040000
};


typedef enum _RASDEVICETYPE RASDEVICETYPE;

typedef struct _RASENUMENTRYDETAILS
{
    DWORD   dwSize;
    DWORD   dwFlags;                    // same as RASENTRYNAME.dwFlags
    DWORD   dwType;                     // same as RASENTRY.dwType
    GUID    guidId;                     // same as RASENTRY.guidId
    BOOL    fShowMonitorIconInTaskBar;  // same as RASENTRY.fShowMonitorIconInTaskBar
    RASDEVICETYPE rdt;
    WCHAR   szDeviceName[RASAPIP_MAX_DEVICE_NAME];
    WCHAR   szEntryName[RASAPIP_MAX_ENTRY_NAME + 1];
    WCHAR   szPhonebookPath[MAX_PATH + 1];

} RASENUMENTRYDETAILS, *LPRASENUMENTRYDETAILS;

DWORD
APIENTRY
DwDeleteSubEntry(
    IN      LPCWSTR lpszPhonebook,
    IN      LPCWSTR lpszEntry,
    IN      DWORD   dwSubEntryId
    );

DWORD
APIENTRY
DwEnumEntryDetails (
    IN     LPCWSTR               lpszPhonebookPath,
    OUT    LPRASENUMENTRYDETAILS lprasentryname,
    IN OUT LPDWORD               lpcb,
    OUT    LPDWORD               lpcEntries
    );

DWORD
APIENTRY
DwCloneEntry(
    IN      LPCWSTR lpwszPhonebookPath,
    IN      LPCWSTR lpwszSrcEntryName,
    IN      LPCWSTR lpwszDstEntryName
    );


// Implemented in rasman.dll
//
DWORD
APIENTRY
RasReferenceRasman (
    IN BOOL fAttach
    );

DWORD 
APIENTRY RasInitialize () ;


// Implemented in netcfgx.dll
//
HRESULT
WINAPI
RasAddBindings (
    IN OUT UINT*    pcIpOut,
    IN OUT UINT*    pcNbfIn,
    IN OUT UINT*    pcNbfOut);

HRESULT
WINAPI
RasCountBindings (
    OUT UINT*   pcIpOut,
    OUT UINT*   pcNbfIn,
    OUT UINT*   pcNbfOut);

HRESULT
WINAPI
RasRemoveBindings (
    IN OUT UINT*        pcIpOutBindings,
    IN     const GUID*  pguidIpOutBindings,
    IN OUT UINT*        pcNbfIn,
    IN OUT UINT*        pcNbfOut);

//+---------------------------------------------------------------------------
// RAS Event notifications into netman.
//
typedef enum _RASEVENTTYPE
{
    ENTRY_ADDED,
    ENTRY_DELETED,
    ENTRY_MODIFIED,
    ENTRY_RENAMED,
    ENTRY_CONNECTED,
    ENTRY_CONNECTING,
    ENTRY_DISCONNECTING,
    ENTRY_DISCONNECTED,
    INCOMING_CONNECTED,
    INCOMING_DISCONNECTED,
    SERVICE_EVENT,
    ENTRY_BANDWIDTH_ADDED,
    ENTRY_BANDWIDTH_REMOVED,
    DEVICE_ADDED,
    DEVICE_REMOVED
} RASEVENTTYPE;

typedef enum _SERVICEEVENTTYPE
{
    RAS_SERVICE_STARTED,
    RAS_SERVICE_STOPPED,
} SERVICEEVENTTYPE;

typedef enum _RASSERVICE
{
    RASMAN,
    RASAUTO,
    REMOTEACCESS,
} RASSERVICE;

typedef struct _RASEVENT
{
    RASEVENTTYPE    Type;

    union
    {
    // ENTRY_ADDED,
    // ENTRY_MODIFIED,
        struct
        {
            RASENUMENTRYDETAILS     Details;
        };

    // ENTRY_DELETED,
    // ENTRY_CONNECTED,
    // ENTRY_CONNECTING,
    // ENTRY_DISCONNECTING,
    // ENTRY_DISCONNECTED,
    // INCOMING_CONNECTED,
    // INCOMING_DISCONNECTED,
    // ENTRY_BANDWIDTH_ADDED
    // ENTRY_BANDWIDTH_REMOVED
    //  guidId is valid

    // ENTRY_RENAMED,
        struct
        {
            GUID    guidId;
            WCHAR   pszwNewName [RASAPIP_MAX_ENTRY_NAME + 1];
        };

    // SERVICE_EVENT,
        struct
        {
            SERVICEEVENTTYPE    Event;
            RASSERVICE          Service;
        };
        
        // DEVICE_ADDED
        // DEVICE_REMOVED
        RASDEVICETYPE DeviceType;
    };
} RASEVENT;

typedef struct _RASENTRYHEADER
{
    DWORD dwEntryType;
    WCHAR szEntryName[RASAPIP_MAX_ENTRY_NAME + 1];
} RASENTRYHEADER, *PRASENTRYHEADER;

// Implemented in netman.dll
//
typedef VOID (APIENTRY *RASEVENTNOTIFYPROC)(const RASEVENT* pEvent);

VOID
APIENTRY
RasEventNotify (
    const RASEVENT* pEvent);

DWORD
APIENTRY
DwEnumEntriesForAllUsers(
            DWORD *lpcb,
            DWORD *lpcEntries,
            RASENTRYHEADER * pRasEntryHeader);


#ifdef __cplusplus
}
#endif


#endif  // _RASAPIP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\imported\net\rras\ras\inc\rasfile.h ===
/*****************************************************************************
**              Microsoft Rasfile Library
**              Copyright (C) Microsoft Corp., 1992
**
** File Name : rasfile.h
**
** Revision History :
**      July 10, 1992   David Kays      Created
**      Dec  12, 1992   Ram Cherala     Added RFM_KEEPDISKFILEOPEN
**
** Description :
**      Rasfile file export include file.
******************************************************************************/

#ifndef _RASFILE_
#define _RASFILE_

//
// RASFILE load modes
//
#define RFM_SYSFORMAT           0x01    // DOS config.sys style file
#define RFM_CREATE              0x02    // create file if it does't exist
#define RFM_READONLY            0x04    // open file for read only
#define RFM_LOADCOMMENTS        0x08    // load comment lines into memory
#define RFM_ENUMSECTIONS        0x10    // only section headers loaded
#define RFM_KEEPDISKFILEOPEN    0x20    // if not set close the disk file

//
// RASFILE line type bit-masks.
// The ANY types are shorthand for multiple line types.
//
#define RFL_SECTION             0x01
#define RFL_GROUP               0x02
#define RFL_ANYHEADER           (RFL_SECTION | RFL_GROUP)
#define RFL_BLANK               0x04
#define RFL_COMMENT             0x08
#define RFL_ANYINACTIVE         (RFL_BLANK | RFL_COMMENT)
#define RFL_KEYVALUE            0x10
#define RFL_COMMAND             0x20
#define RFL_ANYACTIVE           (RFL_KEYVALUE | RFL_COMMAND)
#define RFL_ANY                 0x3F

//
// RASFILE search scope.
//
typedef enum
{
    RFS_FILE,
    RFS_SECTION,
    RFS_GROUP
} RFSCOPE;

typedef int     HRASFILE;
typedef BOOL    (*PFBISGROUP)();

#define INVALID_HRASFILE     -1
#define RAS_MAXLINEBUFLEN    600
#define RAS_MAXSECTIONNAME   RAS_MAXLINEBUFLEN

//
// RasfileLoad parameters as returned by RasfileLoadInfo.
//
typedef struct _RASFILELOADINFO
{
    CHAR        szPath[ MAX_PATH ];
    DWORD       dwMode;
    CHAR        szSection[ RAS_MAXSECTIONNAME + 1 ];
    PFBISGROUP  pfbIsGroup;
} RASFILELOADINFO;


//
// RASFILE APIs
//

// file management routines
HRASFILE APIENTRY  RasfileLoad( LPCSTR, DWORD, LPCSTR, PFBISGROUP);
BOOL APIENTRY    RasfileWrite( HRASFILE, LPCSTR );
BOOL APIENTRY    RasfileClose( HRASFILE );
VOID APIENTRY    RasfileLoadInfo( HRASFILE, RASFILELOADINFO* );

// file navigation routines
BOOL APIENTRY    RasfileFindFirstLine( HRASFILE, BYTE, RFSCOPE );
BOOL APIENTRY    RasfileFindLastLine( HRASFILE, BYTE, RFSCOPE );
BOOL APIENTRY    RasfileFindPrevLine( HRASFILE, BYTE, RFSCOPE );
BOOL APIENTRY    RasfileFindNextLine( HRASFILE, BYTE, RFSCOPE );
BOOL APIENTRY    RasfileFindNextKeyLine( HRASFILE, LPCSTR, RFSCOPE );
BOOL APIENTRY    RasfileFindMarkedLine( HRASFILE, BYTE );
BOOL APIENTRY    RasfileFindSectionLine( HRASFILE, LPCSTR, BOOL );

// file editing routines
const LPCSTR APIENTRY    RasfileGetLine( HRASFILE );
BOOL APIENTRY    RasfileGetLineText( HRASFILE, LPSTR );
BOOL APIENTRY    RasfilePutLineText( HRASFILE, LPCSTR );
BYTE APIENTRY    RasfileGetLineMark( HRASFILE );
BOOL APIENTRY    RasfilePutLineMark( HRASFILE, BYTE );
BYTE APIENTRY    RasfileGetLineType( HRASFILE );
BOOL APIENTRY    RasfileInsertLine( HRASFILE, LPCSTR, BOOL );
BOOL APIENTRY    RasfileDeleteLine( HRASFILE );
BOOL APIENTRY    RasfileGetSectionName( HRASFILE, LPSTR );
BOOL APIENTRY    RasfilePutSectionName( HRASFILE, LPCSTR );
BOOL APIENTRY    RasfileGetKeyValueFields( HRASFILE, LPSTR, LPSTR );
BOOL APIENTRY    RasfilePutKeyValueFields( HRASFILE, LPCSTR, LPCSTR );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\imported\net\rras\ras\inc\rasman.h ===
//****************************************************************************
//
//		       Microsoft NT Remote Access Service
//
//		       Copyright 1992-93
//
//
//  Revision History
//
//
//  5/26/92	Gurdeep Singh Pall	Created
//
//
//  Description: This file contains all structure and constant definitions for
//		 RAS Manager Component.
//
//****************************************************************************


#ifndef _RASMAN_
#define _RASMAN_

#define RASMERGE

#include <windows.h>
#include <mprapi.h>                         // defines for MAX_MEDIA_NAME, MAX_DEVICE_NAME
                                            // MAX_PORT_NAME
#include <ras.h>

#include <rpc.h>    // for RPC_BIND_HANDLE

#include <rasapip.h> // for RASEVENT

#define WM_RASAPICOMPLETE           0xCCCC	// From the "user" window msg range

#define RASMAN_SERVICE_NAME         "RASMAN"

#define MAX_USERKEY_SIZE            132

#define MAX_PARAM_KEY_SIZE          32

#define MAX_XPORT_NAME	            128

#define MAX_IDENTIFIER_SIZE         32

#define MAX_STAT_NAME	            32

#define MAX_CHALLENGE_SIZE          8

#define MAX_RESPONSE_SIZE           24

#define MAX_USERNAME_SIZE           UNLEN

#define MAX_DOMAIN_SIZE             DNLEN

#define MAX_PASSWORD_SIZE           PWLEN

#define MAX_LAN_NETS	            16

#define MAX_PROTOCOLS_PER_PORT	    4

#define MAX_DLL_NAME_SIZE	        8

#define MAX_ENTRYPOINT_NAME_SIZE    32

#define MAX_ARG_STRING_SIZE         128

#define MAX_ENTRYNAME_SIZE          256

#define MAX_PHONENUMBER_SIZE        128

#define MAX_CALLBACKNUMBER_SIZE     MAX_PHONENUMBER_SIZE

#define MAX_PHONEENTRY_SIZE         (MAX_PHONENUMBER_SIZE < MAX_ENTRYNAME_SIZE \
                                    ? MAX_ENTRYNAME_SIZE                       \
                                    : MAX_PHONENUMBER_SIZE)

#define RASMAN_MAX_PROTOCOLS        32  // matches MAX_PROTOCOLS defined in wanpub.h

#define RASMAN_PROTOCOL_ADDED       1
#define RASMAN_PROTOCOL_REMOVED     2

#define INVALID_TAPI_ID             0xffffffff

//
// Defines for Ndiswan DriverCaps
//

#define RAS_NDISWAN_40BIT_ENABLED       0x00000000

#define RAS_NDISWAN_128BIT_ENABLED      0x00000001

typedef  HANDLE  HPORT ;

typedef  HANDLE  HBUNDLE ;

typedef  HANDLE  HCONN;

#define INVALID_HPORT       ((HPORT) -1)

enum RASMAN_STATUS {

	OPEN	= 0,

	CLOSED	= 1,

    UNAVAILABLE = 2,

    REMOVED = 3

}   ;

typedef enum RASMAN_STATUS	RASMAN_STATUS ;


#define CALL_NONE                   0x00
#define CALL_IN                     0x01
#define CALL_OUT                    0x02
#define CALL_ROUTER                 0x04
#define CALL_LOGON                  0x08

typedef DWORD RASMAN_USAGE ;


enum RAS_FORMAT {

	Number	    = 0,

	String	    = 1

} ;

typedef enum RAS_FORMAT	RAS_FORMAT ;


union RAS_VALUE {

	DWORD	Number ;

	struct	
	{
		DWORD	Length ;
		PCHAR	Data ;
	} String ;

    struct
    {
        DWORD   Length;
        DWORD   dwOffset;
    } String_OffSet;
} ;

typedef union RAS_VALUE	RAS_VALUE ;



enum RASMAN_STATE {

	CONNECTING	= 0,

	LISTENING	= 1,

	CONNECTED	= 2,

	DISCONNECTING	= 3,

	DISCONNECTED	= 4,

	LISTENCOMPLETED	= 5,

} ;

typedef enum RASMAN_STATE	RASMAN_STATE ;

enum RASMAN_CONNECTION_STATE {

    RCS_NOT_CONNECTED = 0,

    RCS_CONNECTING,

    RCS_CONNECTED
};

typedef enum RASMAN_CONNECTION_STATE RASMAN_CONNECTION_STATE;

enum RASMAN_DISCONNECT_REASON {

    USER_REQUESTED = 0,

    REMOTE_DISCONNECTION = 1,

    HARDWARE_FAILURE = 2,

    NOT_DISCONNECTED = 3
} ;

typedef enum RASMAN_DISCONNECT_REASON	RASMAN_DISCONNECT_REASON ;


struct RAS_PARAMS {

    CHAR P_Key	[MAX_PARAM_KEY_SIZE] ;

    RAS_FORMAT P_Type ;

    BYTE P_Attributes ;

    RAS_VALUE P_Value ;

} ;

typedef struct RAS_PARAMS	RAS_PARAMS ;


struct RASMAN_PORT {

    HPORT P_Handle ;

    CHAR P_PortName  [MAX_PORT_NAME] ;

    RASMAN_STATUS P_Status ;

    RASDEVICETYPE P_rdtDeviceType;

    RASMAN_USAGE P_ConfiguredUsage ;

    RASMAN_USAGE P_CurrentUsage ;

    CHAR P_MediaName [MAX_MEDIA_NAME] ;

    CHAR P_DeviceType[MAX_DEVICETYPE_NAME] ;

    CHAR P_DeviceName[MAX_DEVICE_NAME+1] ;

    DWORD P_LineDeviceId ;

    DWORD P_AddressId ;

} ;

typedef struct RASMAN_PORT	RASMAN_PORT ;

struct RASMAN_PORT_400 {

    HPORT       P_Handle ;

    CHAR        P_PortName  [MAX_PORT_NAME] ;

    RASMAN_STATUS   P_Status ;

    RASMAN_USAGE    P_ConfiguredUsage ;

    RASMAN_USAGE    P_CurrentUsage ;

    CHAR        P_MediaName [MAX_MEDIA_NAME] ;

    CHAR        P_DeviceType[MAX_DEVICETYPE_NAME] ;

    CHAR        P_DeviceName[MAX_DEVICE_NAME+1] ;

    DWORD       P_LineDeviceId ;    // only valid for TAPI devices

    DWORD       P_AddressId ;       // only valid for TAPI devices

} ;

typedef struct RASMAN_PORT_400	RASMAN_PORT_400 ;



struct RASMAN_PORTINFO {

    WORD	PI_NumOfParams ;

    RAS_PARAMS	PI_Params[1] ;

} ;

typedef struct RASMAN_PORTINFO RASMAN_PORTINFO ;


struct RASMAN_DEVICE {

    CHAR	D_Name	[MAX_DEVICE_NAME+1] ;

} ;

typedef struct RASMAN_DEVICE	RASMAN_DEVICE ;


struct RASMAN_DEVICEINFO {

    WORD	DI_NumOfParams ;

    RAS_PARAMS	DI_Params[1] ;

} ;

typedef struct RASMAN_DEVICEINFO   RASMAN_DEVICEINFO ;



enum RAS_PROTOCOLTYPE {

	ASYBEUI     = 0x80D5,

	IPX	    = 0x8137,

	IP	    = 0x0800,

	ARP	    = 0x0806,

	APPLETALK   = 0x80F3,

	XNS	    = 0x0600,

	RASAUTH     = 0x8FFF,

	INVALID_TYPE= 0x2222
} ;

typedef enum RAS_PROTOCOLTYPE RAS_PROTOCOLTYPE ;




struct RASMAN_PROTOCOLINFO {

    CHAR		PI_XportName	[MAX_XPORT_NAME] ;

    RAS_PROTOCOLTYPE	PI_Type ;

} ;

typedef struct RASMAN_PROTOCOLINFO RASMAN_PROTOCOLINFO ;

struct	RASMAN_ROUTEINFO {

    RAS_PROTOCOLTYPE RI_Type ;

    BYTE	RI_LanaNum ;

    WCHAR	RI_XportName	[MAX_XPORT_NAME] ;

    WCHAR	RI_AdapterName	[MAX_XPORT_NAME] ;

} ;

typedef struct RASMAN_ROUTEINFO    RASMAN_ROUTEINFO ;


struct RAS_PROTOCOLS {

    RASMAN_ROUTEINFO   RP_ProtocolInfo[MAX_PROTOCOLS_PER_PORT] ;
} ;

typedef struct RAS_PROTOCOLS RAS_PROTOCOLS ;

typedef struct _RAS_CALLEDID_INFO
{
    DWORD           dwSize;

    BYTE            bCalledId[1];

} RAS_CALLEDID_INFO, *PRAS_CALLEDID_INFO;

typedef struct _RAS_DEVICE_INFO
{
    DWORD           dwVersion;

    BOOL            fWrite;

    BOOL            fRasEnabled;

    BOOL            fRouterEnabled;

    DWORD           dwTapiLineId;

    DWORD           dwError;

    DWORD           dwNumEndPoints;

    DWORD           dwMaxOutCalls;

    DWORD           dwMaxInCalls;

    DWORD           dwMinWanEndPoints;

    DWORD           dwMaxWanEndPoints;

    RASDEVICETYPE   eDeviceType;

    GUID            guidDevice;

    CHAR            szPortName[MAX_PORT_NAME + 1];

    CHAR            szDeviceName[MAX_DEVICE_NAME + 1];

} RAS_DEVICE_INFO, *PRAS_DEVICE_INFO;


struct  RASMAN_INFO {

    RASMAN_STATUS       RI_PortStatus ;

    RASMAN_STATE        RI_ConnState ;

    DWORD           RI_LinkSpeed ;

    DWORD           RI_LastError ;

    RASMAN_USAGE        RI_CurrentUsage ;

    CHAR            RI_DeviceTypeConnecting [MAX_DEVICETYPE_NAME] ;

    CHAR            RI_DeviceConnecting [MAX_DEVICE_NAME + 1] ;

    CHAR            RI_szDeviceType[MAX_DEVICETYPE_NAME];

    CHAR            RI_szDeviceName[MAX_DEVICE_NAME + 1];

    CHAR            RI_szPortName[MAX_PORT_NAME + 1];

    RASMAN_DISCONNECT_REASON    RI_DisconnectReason ;

    DWORD           RI_OwnershipFlag ;

    DWORD           RI_ConnectDuration ;

    DWORD           RI_BytesReceived ;

    //
    // If this port belongs to a connection, then
    // the following fields are filled in.
    //
    CHAR            RI_Phonebook[MAX_PATH+1];

    CHAR            RI_PhoneEntry[MAX_PHONEENTRY_SIZE+1];

    HCONN           RI_ConnectionHandle;

    DWORD           RI_SubEntry;

    RASDEVICETYPE   RI_rdtDeviceType;

    GUID            RI_GuidEntry;

} ;


typedef struct RASMAN_INFO	  RASMAN_INFO ;

struct  RASMAN_INFO_400 {

    RASMAN_STATUS       RI_PortStatus ;

    RASMAN_STATE        RI_ConnState ;

    DWORD           RI_LinkSpeed ;

    DWORD           RI_LastError ;

    RASMAN_USAGE        RI_CurrentUsage ;

    CHAR            RI_DeviceTypeConnecting [MAX_DEVICETYPE_NAME] ;

    CHAR            RI_DeviceConnecting [MAX_DEVICE_NAME+1] ;

    RASMAN_DISCONNECT_REASON    RI_DisconnectReason ;

    DWORD           RI_OwnershipFlag ;

    DWORD           RI_ConnectDuration ;

    DWORD           RI_BytesReceived ;

    //
    // If this port belongs to a connection, then
    // the following fields are filled in.
    //
    CHAR            RI_Phonebook[MAX_PATH+1];

    CHAR            RI_PhoneEntry[MAX_PHONEENTRY_SIZE+1];

    HCONN           RI_ConnectionHandle;

    DWORD           RI_SubEntry;
} ;


typedef struct RASMAN_INFO_400	  RASMAN_INFO_400 ;


struct	RAS_STATISTICS {

    WORD    S_NumOfStatistics ;

    ULONG   S_Statistics[1] ;

} ;

typedef struct RAS_STATISTICS	RAS_STATISTICS ;

#define MAX_STATISTICS		14
#define MAX_STATISTICS_EX	(MAX_STATISTICS * 2)

#define MAX_STATISTICS_EXT  12

struct RAS_DEVCONFIG
{
    DWORD dwOffsetofModemSettings;
    DWORD dwSizeofModemSettings;
    DWORD dwOffsetofExtendedCaps;
    DWORD dwSizeofExtendedCaps;
    BYTE  abInfo[1];
};

typedef struct RAS_DEVCONFIG RAS_DEVCONFIG;

#ifdef RASMERGE
//
// These structures have been added temporarily
// to rasman.h when the RAS ui was moved over.
// They are necessary to get the UI to compile,
// but are not used internally.  These structures
// should be removed when the UI is converted to
// mpradmin APIs.  (adiscolo 16-Sep-1996)
//
typedef struct _RAS_PORT_STATISTICS
{
    // The connection statistics are followed by port statistics
    // A connection is across multiple ports.
    DWORD   dwBytesXmited;
    DWORD   dwBytesRcved;
    DWORD   dwFramesXmited;
    DWORD   dwFramesRcved;
    DWORD   dwCrcErr;
    DWORD   dwTimeoutErr;
    DWORD   dwAlignmentErr;
    DWORD   dwHardwareOverrunErr;
    DWORD   dwFramingErr;
    DWORD   dwBufferOverrunErr;
    DWORD   dwBytesXmitedUncompressed;
    DWORD   dwBytesRcvedUncompressed;
    DWORD   dwBytesXmitedCompressed;
    DWORD   dwBytesRcvedCompressed;

    // the following are the port statistics
    DWORD   dwPortBytesXmited;
    DWORD   dwPortBytesRcved;
    DWORD   dwPortFramesXmited;
    DWORD   dwPortFramesRcved;
    DWORD   dwPortCrcErr;
    DWORD   dwPortTimeoutErr;
    DWORD   dwPortAlignmentErr;
    DWORD   dwPortHardwareOverrunErr;
    DWORD   dwPortFramingErr;
    DWORD   dwPortBufferOverrunErr;
    DWORD   dwPortBytesXmitedUncompressed;
    DWORD   dwPortBytesRcvedUncompressed;
    DWORD   dwPortBytesXmitedCompressed;
    DWORD   dwPortBytesRcvedCompressed;

} RAS_PORT_STATISTICS, *PRAS_PORT_STATISTICS;

#define RASSAPI_MAX_PARAM_KEY_SIZE        32

enum RAS_PARAMS_FORMAT {

    ParamNumber     = 0,

    ParamString     = 1

} ;
typedef enum RAS_PARAMS_FORMAT  RAS_PARAMS_FORMAT ;

union RAS_PARAMS_VALUE {

    DWORD   Number ;

    struct  {
        DWORD   Length ;
        PCHAR   Data ;
        } String ;
} ;
typedef union RAS_PARAMS_VALUE  RAS_PARAMS_VALUE ;

struct RAS_PARAMETERS {

    CHAR    P_Key   [RASSAPI_MAX_PARAM_KEY_SIZE] ;

    RAS_PARAMS_FORMAT   P_Type ;

    BYTE    P_Attributes ;

    RAS_PARAMS_VALUE    P_Value ;

} ;
typedef struct RAS_PARAMETERS   RAS_PARAMETERS ;
#endif // RASMERGE

#define BYTES_XMITED		        0	// Generic Stats

#define BYTES_RCVED                 1

#define FRAMES_XMITED               2

#define FRAMES_RCVED                3

#define CRC_ERR 		            4	// Hardware Stats

#define TIMEOUT_ERR                 5

#define ALIGNMENT_ERR               6

#define HARDWARE_OVERRUN_ERR	    7

#define FRAMING_ERR                 8

#define BUFFER_OVERRUN_ERR          9

#define BYTES_XMITED_UNCOMPRESSED   10	// Compression Stats

#define BYTES_RCVED_UNCOMPRESSED    11

#define BYTES_XMITED_COMPRESSED	    12

#define BYTES_RCVED_COMPRESSED	    13

#define COMPRESSION_RATIO_IN        10
#define COMPRESSION_RATIO_OUT       11

#define MSTYPE_COMPRESSION	        0x00000001

#define MSTYPE_ENCRYPTION_40        0x00000010

#define MSTYPE_ENCRYPTION_40F       0x00000020

#define MSTYPE_ENCRYPTION_128       0x00000040

#define MSTYPE_ENCRYPTION_56        0x00000080

#define MSTYPE_HISTORYLESS          0x01000000

#define MACTYPE_NT31RAS             254

#define MAX_SESSIONKEY_SIZE         8

#define MAX_USERSESSIONKEY_SIZE     16

#define MAX_NT_RESPONSE_SIZE        24

#define MAX_COMPVALUE_SIZE          32

#define MAX_COMPOUI_SIZE            3

#define MAX_EAPKEY_SIZE             256

#define VERSION_40                  4

#define VERSION_50                  5

//
// Information stored in rasman per-connection.
//
#define CONNECTION_PPPMODE_INDEX            0
#define CONNECTION_PPPRESULT_INDEX          1
#define CONNECTION_AMBRESULT_INDEX          2
#define CONNECTION_SLIPRESULT_INDEX         3
#define CONNECTION_PPPREPLYMESSAGE_INDEX    4
#define CONNECTION_IPSEC_INFO_INDEX         5

//
// Information stored in rasman per-port.
//
#define PORT_PHONENUMBER_INDEX                  0
#define PORT_DEVICENAME_INDEX                   1
#define PORT_DEVICETYPE_INDEX                   2
#define PORT_CONNSTATE_INDEX                    3
#define PORT_CONNERROR_INDEX                    4
#define PORT_CONNRESPONSE_INDEX                 5
#define PORT_CUSTOMAUTHDATA_INDEX               6
#define PORT_CUSTOMAUTHINTERACTIVEDATA_INDEX    7
#define PORT_IPSEC_INFO_INDEX                   8
#define PORT_USERSID_INDEX                      9
#define PORT_DIALPARAMSUID_INDEX                10
#define PORT_OLDPASSWORD_INDEX                  11

//
// IPSEC DOI ESP algorithms
//
#define RASMAN_IPSEC_ESP_DES                0x00000001
#define RASMAN_IPSEC_ESP_DES_40             0x00000002
#define RASMAN_IPSEC_ESP_3_DES              0x00000004
#define RASMAN_IPSEC_ESP_MAX                0x00000008


//
// Defines for COMPRESS_INFO AuthType field
//
#define AUTH_USE_MSCHAPV1        0x00000001
#define AUTH_USE_MSCHAPV2        0x00000002
#define AUTH_USE_EAP             0x00000003

//
// Defines for COMPRESS_INFO flags
//
#define CCP_PAUSE_DATA          0x00000001  // this bit is set if the bundle
                                            // should pause data transfer.
                                            // the bit is cleared if the bundle
                                            // should resume data transfer
#define CCP_IS_SERVER           0x00000002  // this bit is set if the bundle
                                            // is the server
                                            // the bit is cleared if the bundle
                                            // is the client
#define CCP_SET_KEYS            0x00000004  // indicates that the key
                                            // information is valid
#define CCP_SET_COMPTYPE        0x00000008  // indicates that the comptype

enum RAS_L2TP_ENCRYPTION
{
    RAS_L2TP_NO_ENCRYPTION = 0,     // Request no encryption

    RAS_L2TP_OPTIONAL_ENCRYPTION,   // Request encryption but none OK

    RAS_L2TP_REQUIRE_ENCRYPTION,    // Require encryption of any strength

    RAS_L2TP_REQUIRE_MAX_ENCRYPTION // Require maximum strength encryption
};

typedef enum RAS_L2TP_ENCRYPTION RAS_L2TP_ENCRYPTION;

struct RAS_COMPRESSION_INFO	{

    //
    // May be used for encryption, non-zero if supported.
    //

    UCHAR RCI_LMSessionKey[MAX_SESSIONKEY_SIZE];

    //
    // Used for 128Bit encryption, non-zero if supported.
    //

    UCHAR RCI_UserSessionKey[MAX_USERSESSIONKEY_SIZE];

    //
    // Used for 128Bit encryption, only valid if RCI_UserSessionKey is valid.
    //

    UCHAR RCI_Challenge[MAX_CHALLENGE_SIZE];

    UCHAR RCI_NTResponse[MAX_NT_RESPONSE_SIZE];

    //
    // bit 0 = MPPPC, bit 5 = encryption
    //

    ULONG RCI_MSCompressionType;

    ULONG RCI_AuthType;

    //
    // 0=OUI, 1-253 = Public, 254 = NT31 RAS, 255=Not supported
    //

    UCHAR   RCI_MacCompressionType;

    WORD    RCI_MacCompressionValueLength ;

    union {
    struct {        // Proprietary: used for comp type 0

        UCHAR RCI_CompOUI[MAX_COMPOUI_SIZE];

        UCHAR RCI_CompSubType;

        UCHAR RCI_CompValues[MAX_COMPVALUE_SIZE];

    } RCI_Proprietary;

    struct {        // Public: used for comp type 1-254

        UCHAR RCI_CompValues[MAX_COMPVALUE_SIZE];

    } RCI_Public;

    } RCI_Info ;

    ULONG RCI_Flags;

    ULONG RCI_EapKeyLength;

    UCHAR RCI_EapKey[MAX_EAPKEY_SIZE];

};

typedef struct RAS_COMPRESSION_INFO RAS_COMPRESSION_INFO;


struct PROTOCOL_CONFIG_INFO {

    DWORD  P_Length ;

    BYTE   P_Info[1] ;
} ;

typedef struct PROTOCOL_CONFIG_INFO PROTOCOL_CONFIG_INFO ;


struct RASMAN_PPPFEATURES {

    DWORD MRU;
    DWORD ACCM;
    DWORD AuthProtocol;
    DWORD MagicNumber;
    BOOL  PFC;
    BOOL  ACFC;

} ;

typedef struct RASMAN_PPPFEATURES RASMAN_PPPFEATURES ;


enum RAS_FRAMING {PPP, RAS, AUTODETECT, SLIP, SLIPCOMP, SLIPCOMPAUTO} ;

typedef enum RAS_FRAMING RAS_FRAMING ;

struct RAS_FRAMING_CAPABILITIES {

    DWORD	RFC_MaxFrameSize;
    DWORD   RFC_MaxReconstructedFrameSize;
    DWORD	RFC_FramingBits;
    DWORD	RFC_DesiredACCM;

} ;

typedef struct RAS_FRAMING_CAPABILITIES RAS_FRAMING_CAPABILITIES ;


struct RAS_FRAMING_INFO {

    DWORD RFI_MaxSendFrameSize;
    DWORD RFI_MaxRecvFrameSize;
    DWORD RFI_MaxRSendFrameSize;
    DWORD RFI_MaxRRecvFrameSize;
    DWORD RFI_HeaderPadding;
    DWORD RFI_TailPadding;
    DWORD RFI_SendFramingBits;
    DWORD RFI_RecvFramingBits;
    DWORD RFI_SendCompressionBits;
    DWORD RFI_RecvCompressionBits;
    DWORD RFI_SendACCM;
    DWORD RFI_RecvACCM;

} ;

typedef struct RAS_FRAMING_INFO RAS_FRAMING_INFO ;


// NDIS WAN Framing bits: used with RasPortGetFramingEx and RasPortSetFramingEx
//			  APIs.
//

#define OLD_RAS_FRAMING                     0x00000001

#define RAS_COMPRESSION                     0x00000002

#define PPP_MULTILINK_FRAMING               0x00000010

#define PPP_SHORT_SEQUENCE_HDR_FORMAT       0x00000020

#define PPP_FRAMING                         0x00000100

#define PPP_COMPRESS_ADDRESS_CONTROL        0x00000200

#define PPP_COMPRESS_PROTOCOL_FIELD         0x00000400

#define PPP_ACCM_SUPPORTED                  0x00000800

#define SLIP_FRAMING                        0x00001000

#define SLIP_VJ_COMPRESSION                 0x00002000

#define SLIP_VJ_AUTODETECT                  0x00004000

#define MEDIA_NRZ_ENCODING                  0x00010000

#define MEDIA_NRZI_ENCODING                 0x00020000

#define MEDIA_NLPID                         0x00040000

#define RFC_1356_FRAMING                    0x00100000

#define RFC_1483_FRAMING                    0x00200000

#define RFC_1490_FRAMING                    0x00400000

#define SHIVA_FRAMING			            0x01000000



// Defines for RAS_PROTOCOLCOMPRESSION
//
#define VJ_IP_COMPRESSION	     0x002d
#define NO_PROTOCOL_COMPRESSION      0x0000

struct RAS_PROTOCOLCOMPRESSION {

    union {

	struct {

	    WORD    RP_IPCompressionProtocol;

	    BYTE    RP_MaxSlotID;		// How many slots to allocate

	    BYTE    RP_CompSlotID;		// 1 = Slot ID was negotiated

	} RP_IP ;

	struct {

	    WORD    RP_IPXCompressionProtocol;

	} RP_IPX ;

    } RP_ProtocolType ;

} ;

typedef struct RAS_PROTOCOLCOMPRESSION RAS_PROTOCOLCOMPRESSION ;

#define RAS_VERSION         5

#define PT_WORKSTATION      1

#define PT_SERVER           2

#define GUIDSTRLEN          39

typedef DWORD               PRODUCT_TYPE;

enum _DEVICE_STATUS
{
    DS_Enabled = 0,

    DS_Disabled,

    DS_Unavailable,

    DS_Removed
};

typedef enum _DEVICE_STATUS DEVICE_STATUS;

typedef struct DeviceInfo
{
    //
    // Private fields which are used
    // internally in rastapi/rasman
    //
    struct DeviceInfo   *Next;

    BOOL                fValid;                             // Is this information valid

    DWORD               dwCurrentEndPoints;                 // Current number of ports on this adapter

    DWORD               dwCurrentDialedInClients;           // Number of clients dialed in currently

    DWORD               dwInstanceNumber;                   // Instance Number

    DWORD               dwNextPortNumber;                   // The number assigned next to distinguish rasman

    DEVICE_STATUS       eDeviceStatus;                      // Status of the device

    RAS_CALLEDID_INFO   *pCalledID;                         // Called id information read from registry

    RAS_DEVICE_INFO     rdiDeviceInfo;                      // Device info structure

} DeviceInfo, *pDeviceInfo;

//
// Definitions for Ras{Get,Set}DialParams
//
// The dwMask values control/specify which fields
// of the RAS_DIALPARAMS are stored/retrieved.
//
// NOTE: these values have to match the RASCF_*
// values in ras.h.
//
#define DLPARAMS_MASK_USERNAME       0x00000001

#define DLPARAMS_MASK_PASSWORD       0x00000002

#define DLPARAMS_MASK_DOMAIN         0x00000004

#define DLPARAMS_MASK_PHONENUMBER    0x00000008

#define DLPARAMS_MASK_CALLBACKNUMBER 0x00000010

#define DLPARAMS_MASK_SUBENTRY       0x00000020

#define DLPARAMS_MASK_OLDSTYLE       0x80000000

typedef struct _RAS_DIALPARAMS {

    DWORD DP_Uid;

    WCHAR DP_PhoneNumber[MAX_PHONENUMBER_SIZE + 1];

    WCHAR DP_CallbackNumber[MAX_CALLBACKNUMBER_SIZE + 1];

    WCHAR DP_UserName[MAX_USERNAME_SIZE + 1];

    WCHAR DP_Password[MAX_PASSWORD_SIZE + 1];

    WCHAR DP_Domain[MAX_DOMAIN_SIZE + 1];

    DWORD DP_SubEntry;

} RAS_DIALPARAMS, *PRAS_DIALPARAMS;


//
// Connection Flags
//
#define CONNECTION_REDIALONLINKFAILURE      0x00000001
#define CONNECTION_SHAREFILEANDPRINT        0x00000002
#define CONNECTION_BINDMSNETCLIENT          0x00000004

//
// Definitions for Ras{Get,Set}ConnectionParams
//
typedef struct _RAS_CONNECTIONPARAMS {
    //
    // Phonebook and entry name.
    //
    CHAR CP_Phonebook[MAX_PATH + 1];

    CHAR CP_PhoneEntry[MAX_PHONEENTRY_SIZE + 1];

    //
    // Idle disconnect parameters
    //
    DWORD CP_IdleDisconnectSeconds;

    //
    // Connection Flags
    //
    DWORD CP_ConnectionFlags;

} RAS_CONNECTIONPARAMS, *PRAS_CONNECTIONPARAMS;

//
// Flags for RasAddNotification.
//
// Note: the NOTIF_* values must match the
// RASCN_* values in ras.h
//
#define NOTIF_CONNECT           0x00000001

#define NOTIF_DISCONNECT        0x00000002

#define NOTIF_BANDWIDTHADDED    0x00000004

#define NOTIF_BANDWIDTHREMOVED  0x00000008


//
// Overlapped I/O structure
// used by the device and media DLLs.
//
// This structure is used with the I/O
// completion port associated with each
// of the port handles.
//
// This structure is also used by the
// rasapi32 dialing machine and PPP event
// mechanism.
//
typedef struct _RAS_OVERLAPPED {

    OVERLAPPED RO_Overlapped;   // the I/O overlapped structure

    DWORD      RO_EventType;    // OVEVT_* flags below

    PVOID      RO_Info;         // optional

    HANDLE     RO_hInfo;        // optional

} RAS_OVERLAPPED, *PRAS_OVERLAPPED;


typedef struct _NEW_PORT_NOTIF {

    PVOID          *NPN_pmiNewPort;
    CHAR            NPN_MediaName[MAX_MEDIA_NAME];

} NEW_PORT_NOTIF, *PNEW_PORT_NOTIF;

typedef struct _REMOVE_LINE_NOTIF {

    DWORD dwLineId;

} REMOVE_LINE_NOTIF, *PREMOVE_LINE_NOTIF;

typedef struct _PORT_USAGE_NOTIF {

    PVOID          *PUN_pmiPort;
    CHAR            PUN_MediaName[MAX_MEDIA_NAME];

} PORT_USAGE_NOTIF, *PPORT_USAGE_NOTIF;

typedef struct _PNP_EVENT_NOTIF {

    DWORD           dwEvent;
    RASMAN_PORT     RasPort;

} PNP_EVENT_NOTIF, *PPNP_EVENT_NOTIF;


#define PNP_NOTIFCALLBACK           0x00000001
#define PNP_NOTIFEVENT              0x00000002

#define PNPNOTIFEVENT_CREATE        0x00000001
#define PNPNOTIFEVENT_REMOVE        0x00000002
#define PNPNOTIFEVENT_USAGE         0x00000004

#define LEGACY_PPTP                 0
#define LEGACY_L2TP                 1
#define LEGACY_MAX                  2

//
// RAS_OVERLAPPED.RO_EventTypes for device
// and medial DLLs.
//
#define OVEVT_DEV_IGNORED           0   // ignored

#define OVEVT_DEV_STATECHANGE       1   // disconnect event

#define OVEVT_DEV_ASYNCOP           2   // async operation event

#define OVEVT_DEV_SHUTDOWN          4   // shutdown event

#define OVEVT_RASMAN_TIMER				6	// timer

#define OVEVT_RASMAN_CLOSE				7	// close event posted by a client to rasman

#define OVEVT_RASMAN_FINAL_CLOSE		8	// event posted by ppp engine when it has shut down

#define OVEVT_RASMAN_RECV_PACKET		9	// event posted by tapi/...

#define OVEVT_RASMAN_THRESHOLD			10	// event notifying setting of a threshold event

#define OVEVT_DEV_CREATE                11  // new port event (PnP)

#define OVEVT_DEV_REMOVE                12  // device remove event (PnP)

#define OVEVT_DEV_CONFIGCHANGE          13  // pptp config changed (PnP)

#define OVEVT_DEV_RASCONFIGCHANGE       14  // Configuration of some device changed (PnP)

#define OVEVT_RASMAN_ADJUST_TIMER       15  // someone added a timer element..

#define OVEVT_RASMAN_HIBERNATE          16  // ndiswan is asking rasman to hibernate

#define OVEVT_RASMAN_PROTOCOL_EVENT     17  // ndiswan indicates a protocol event

#define OVEVT_RASMAN_POST_RECV_PKT      18  // post receive packet in rasmans thread

//
// RAS_OVERLAPPED.RO_EventTypes for rasapi32
// dialing machine and PPP.
//
#define OVEVT_DIAL_IGNORED          0   // ignored

#define OVEVT_DIAL_DROP             1   // port disconnected

#define OVEVT_DIAL_STATECHANGE      2   // rasdial state change

#define OVEVT_DIAL_PPP              3   // PPP event received

#define OVEVT_DIAL_LAST             4   // no more events on this port

#define OVEVT_DIAL_SHUTDOWN         5   // shutdown event

#define REQUEST_BUFFER_SIZE         2500

#define RECEIVE_OUTOF_PROCESS       0x00000001

#define RECEIVE_WAITING             0x00000002

#define RECEIVE_PPPSTARTED          0x00000004

#define RECEIVE_PPPLISTEN           0x00000008

#define RECEIVE_PPPSTOPPED          0x00000010

#define RECEIVE_PPPSTART            0x00000020

typedef struct _RAS_RPC
{

    RPC_BINDING_HANDLE hRpcBinding;
    BOOL               fLocal;
    DWORD              dwVersion;
    TCHAR              szServer[MAX_COMPUTERNAME_LENGTH + 1];

} RAS_RPC, *PRAS_RPC;

typedef struct _RAS_CUSTOM_AUTH_DATA
{

    DWORD   cbCustomAuthData;
    BYTE    abCustomAuthData[1];

} RAS_CUSTOM_AUTH_DATA, *PRAS_CUSTOM_AUTH_DATA;

typedef struct _RAS_CONNECT_INFO
{

    DWORD dwCallerIdSize;
    CHAR  *pszCallerId;
    DWORD dwCalledIdSize;
    CHAR  *pszCalledId;
    DWORD dwConnectResponseSize;
    CHAR  *pszConnectResponse;
    DWORD dwAltCalledIdSize;
    CHAR  *pszAltCalledId;
    BYTE  abdata[1];

} RAS_CONNECT_INFO, *PRAS_CONNECT_INFO;

typedef struct _RASTAPI_CONNECT_INFO
{

    DWORD dwCallerIdSize;
    DWORD dwCallerIdOffset;
    DWORD dwCalledIdSize;
    DWORD dwCalledIdOffset;
    DWORD dwConnectResponseSize;
    DWORD dwConnectResponseOffset;
    DWORD dwAltCalledIdSize;
    DWORD dwAltCalledIdOffset;
    BYTE  abdata[1];

} RASTAPI_CONNECT_INFO, *PRASTAPI_CONNECT_INFO;


typedef struct _EAPLOGONINFO
{
    DWORD dwSize;
    DWORD dwLogonInfoSize;
    DWORD dwOffsetLogonInfo;
    DWORD dwPINInfoSize;
    DWORD dwOffsetPINInfo;
    BYTE  abdata[1];
} EAPLOGONINFO, *PEAPLOGONINFO;



//
// Structure used in IOCTL_NDISWAN_GET_DRIVER_INFO
//
typedef struct _RAS_NDISWAN_DRIVER_INFO
{
    OUT     ULONG   DriverCaps;
    OUT     ULONG   Reserved;
} RAS_NDISWAN_DRIVER_INFO, *P_NDISWAN_DRIVER_INFO;


//
// Structure used in IOCTL_NDISWAN_GET_BANDWIDTH_UTILIZATION
//
typedef struct _RAS_GET_BANDWIDTH_UTILIZATION
{
    OUT ULONG      ulUpperXmitUtil;
    OUT ULONG      ulLowerXmitUtil;
    OUT ULONG      ulUpperRecvUtil;
    OUT ULONG      ulLowerRecvUtil;
} RAS_GET_BANDWIDTH_UTILIZATION, *PRAS_GET_BANDWIDTH_UTILIZATION;

//
// This structure should match the WAN_PROTOCOL_INFO in wanpub.h
//
typedef struct _RASMAN_PROTOCOL_INFO
{
	USHORT	ProtocolType;       // protocol's Ethertype
	USHORT	PPPId;              // protocol's PPP ID
	ULONG	MTU;                // MTU being used
	ULONG	TunnelMTU;          // MTU used for tunnels
    ULONG   PacketQueueDepth;   // max depth of packet queue (in seconds)
} RASMAN_PROTOCOL_INFO, *PRASMAN_PROTOCOL_INFO;

//
// Structure used in IOCTL_NDISWAN_GET_PROTOCOL_INFO
//
typedef struct _RASMAN_GET_PROTOCOL_INFO
{
    OUT ULONG                ulNumProtocols;
    OUT RASMAN_PROTOCOL_INFO ProtocolInfo[RASMAN_MAX_PROTOCOLS];
} RASMAN_GET_PROTOCOL_INFO, *PRASMAN_GET_PROTOCOL_INFO;


//
// RAS Manager entrypoint Prototypes
//

DWORD RasStartRasAutoIfRequired(void);

DWORD APIENTRY RasPortOpen(PCHAR,
                           HPORT*,
                           HANDLE);

DWORD APIENTRY RasPortClose(HPORT);

DWORD APIENTRY RasPortEnum(HANDLE,
                           PBYTE,
                           PDWORD,
                           PDWORD);

DWORD APIENTRY RasPortGetInfo(HANDLE,
                              HPORT,
                              PBYTE,
                              PDWORD);

DWORD APIENTRY RasPortSetInfo(HPORT,
                              RASMAN_PORTINFO*);

DWORD APIENTRY RasPortDisconnect(HPORT,
                                 HANDLE);

DWORD APIENTRY RasPortSend(HPORT,
                           PBYTE,
                           DWORD);

DWORD APIENTRY RasPortReceive(HPORT,
                              PBYTE,
                              PDWORD,
                              DWORD,
                              HANDLE);

DWORD APIENTRY RasPortListen(HPORT,
                             DWORD,
                             HANDLE);

DWORD APIENTRY RasPortConnectComplete(HPORT);

DWORD APIENTRY RasPortGetStatistics(HANDLE,
                                    HPORT,
                                    PBYTE,
                                    PDWORD);

DWORD APIENTRY RasPortClearStatistics(HANDLE,
                                      HPORT);

DWORD APIENTRY RasPortGetStatisticsEx(HANDLE,
                                      HPORT,
                                      PBYTE,
                                      PDWORD);

DWORD APIENTRY RasDeviceEnum(HANDLE,
                             PCHAR,
                             PBYTE,
                             PDWORD,
                             PDWORD);

DWORD APIENTRY RasDeviceGetInfo(HANDLE,
                                HPORT,
                                PCHAR,
                                PCHAR,
                                PBYTE,
                                PDWORD);

DWORD APIENTRY RasDeviceSetInfo(HPORT,
                                PCHAR,
                                PCHAR,
                                RASMAN_DEVICEINFO*);

DWORD APIENTRY RasDeviceConnect(HPORT,
                                PCHAR,
                                PCHAR,
                                DWORD,
                                HANDLE);

DWORD APIENTRY RasGetInfo( HANDLE,
                           HPORT,
                           RASMAN_INFO*);

DWORD APIENTRY RasGetInfoEx( HANDLE,
                             RASMAN_INFO*,
                             PWORD);

DWORD APIENTRY RasGetBuffer( PBYTE*,
                             PDWORD);

DWORD APIENTRY RasFreeBuffer(PBYTE);

DWORD APIENTRY RasProtocolEnum( PBYTE,
                                PDWORD,
                                PDWORD);

DWORD APIENTRY RasAllocateRoute( HPORT,
                                 RAS_PROTOCOLTYPE,
                                 BOOL,
                                 RASMAN_ROUTEINFO*);

DWORD APIENTRY RasActivateRoute( HPORT,
                                 RAS_PROTOCOLTYPE,
                                 RASMAN_ROUTEINFO*,
                                 PROTOCOL_CONFIG_INFO*);

DWORD APIENTRY RasActivateRouteEx( HPORT,
                                   RAS_PROTOCOLTYPE,
                                   DWORD,
                                   RASMAN_ROUTEINFO*,
                                   PROTOCOL_CONFIG_INFO*);

DWORD APIENTRY RasDeAllocateRoute( HBUNDLE,
                                   RAS_PROTOCOLTYPE);

DWORD APIENTRY RasCompressionGetInfo( HPORT,
                                      RAS_COMPRESSION_INFO* Send,
                                      RAS_COMPRESSION_INFO* Recv);

DWORD APIENTRY RasCompressionSetInfo( HPORT,
                                      RAS_COMPRESSION_INFO* Send,
                                      RAS_COMPRESSION_INFO* Recv);

DWORD APIENTRY RasGetUserCredentials( PBYTE,
                                      PLUID,
                                      PWCHAR,
                                      PBYTE,
                                      PBYTE,
                                      PBYTE,
                                      PBYTE) ;

DWORD APIENTRY RasSetCachedCredentials( PCHAR,
                                        PCHAR,
                                        PCHAR ) ;

DWORD APIENTRY RasRequestNotification ( HPORT,
                                        HANDLE) ;

DWORD APIENTRY RasPortCancelReceive (HPORT) ;

DWORD APIENTRY RasPortEnumProtocols ( HANDLE,
                                      HPORT,
                                      RAS_PROTOCOLS*,
                                      PDWORD) ;

DWORD APIENTRY RasEnumLanNets ( DWORD *,
                                UCHAR *) ;

DWORD APIENTRY RasPortSetFraming ( HPORT,
                                   RAS_FRAMING,
                                   RASMAN_PPPFEATURES*,
                                   RASMAN_PPPFEATURES*) ;

DWORD APIENTRY RasPortRegisterSlip ( HPORT,
                                     DWORD,
                                     DWORD,
                                     BOOL,
                                     WCHAR*,
                                     WCHAR*,
                                     WCHAR*,
                                     WCHAR*) ;

DWORD APIENTRY RasPortStoreUserData ( HPORT,
                                      PBYTE,
                                      DWORD) ;

DWORD APIENTRY RasPortRetrieveUserData ( HPORT,
                                         PBYTE,
                                         DWORD *) ;

DWORD APIENTRY RasPortGetFramingEx ( HANDLE,
                                     HPORT,
                                     RAS_FRAMING_INFO *) ;

DWORD APIENTRY RasPortSetFramingEx ( HPORT,
                                     RAS_FRAMING_INFO *) ;

DWORD APIENTRY RasPortGetProtocolCompression ( HPORT,
                                               RAS_PROTOCOLTYPE,
                                               RAS_PROTOCOLCOMPRESSION *,
                                               RAS_PROTOCOLCOMPRESSION *) ;

DWORD APIENTRY RasPortSetProtocolCompression ( HPORT,
                                               RAS_PROTOCOLTYPE,
                                               RAS_PROTOCOLCOMPRESSION *,
                                               RAS_PROTOCOLCOMPRESSION *) ;

DWORD APIENTRY RasGetFramingCapabilities ( HPORT,
                                           RAS_FRAMING_CAPABILITIES*) ;

//DWORD APIENTRY RasInitialize () ;

DWORD APIENTRY RasPortReserve ( PCHAR,
                                HPORT*) ;

DWORD APIENTRY RasPortFree (HPORT) ;

DWORD APIENTRY RasPortBundle( HPORT,
                              HPORT );

DWORD APIENTRY RasPortGetBundledPort ( HPORT oldport,
                                       HPORT *pnewport) ;

DWORD APIENTRY RasBundleGetPort ( HANDLE hConnection,
                                  HBUNDLE hbundle,
                                  HPORT *phport) ;

DWORD APIENTRY RasPortGetBundle ( HANDLE hConnection,
                                  HPORT hport,
                                  HBUNDLE *phbundle) ;

DWORD APIENTRY RasReferenceRasman (BOOL fAttach);

DWORD APIENTRY RasGetAttachedCount ( DWORD *pdwAttachedCount );

DWORD APIENTRY RasGetDialParams ( DWORD dwUID,
                                  LPDWORD lpdwMask,
                                  PRAS_DIALPARAMS pDialParams);

DWORD APIENTRY RasSetDialParams ( DWORD dwOldUID,
                                  DWORD dwMask,
                                  PRAS_DIALPARAMS pDialParams,
                                  BOOL fDelete);

DWORD APIENTRY RasCreateConnection( HCONN *lphconn,
                                    DWORD dwSubEntries,
                                    DWORD *lpdwEntryAlreadyConnected,
                                    DWORD *lpdwSubEntryInfo,
                                    DWORD dwDialMode,
                                    GUID *pGuidEntry,
                                    CHAR *lpszPhonebookPath,
                                    CHAR *lpszEntryName,
                                    CHAR *lpszRefPbkPath,
                                    CHAR *lpszRefEntryName);

DWORD APIENTRY RasDestroyConnection (HCONN hconn);

DWORD APIENTRY RasConnectionEnum (HANDLE hConnection,
                                  HCONN *lphconn,
                                  LPDWORD lpdwcbConnections,
                                  LPDWORD lpdwcConnections);

DWORD APIENTRY RasAddConnectionPort ( HCONN hconn,
                                      HPORT hport,
                                      DWORD dwSubEntry);

DWORD APIENTRY RasEnumConnectionPorts ( HANDLE hConnection,
                                        HCONN hconn,
                                        RASMAN_PORT *pPorts,
                                        LPDWORD lpdwcbPorts,
                                        LPDWORD lpdwcPorts);

DWORD APIENTRY RasGetConnectionParams ( HCONN hconn,
                                        PRAS_CONNECTIONPARAMS pConnectionParams);

DWORD APIENTRY RasSetConnectionParams ( HCONN hconn,
                                        PRAS_CONNECTIONPARAMS pConnectionParams);

DWORD APIENTRY RasGetConnectionUserData ( HPORT hconn,
                                          DWORD dwTag,
                                          PBYTE pBuf,
                                          LPDWORD lpdwcbBuf);

DWORD APIENTRY RasSetConnectionUserData ( HPORT hconn,
                                          DWORD dwTag,
                                          PBYTE pBuf,
                                          DWORD dwcbBuf);

DWORD APIENTRY RasGetPortUserData ( HPORT hport,
                                    DWORD dwTag,
                                    PBYTE pBuf,
                                    LPDWORD lpdwcbBuf);

DWORD APIENTRY RasSetPortUserData ( HPORT hport,
                                    DWORD dwTag,
                                    PBYTE pBuf,
                                    DWORD dwcbBuf);

DWORD APIENTRY RasAddNotification ( HCONN hconn,
                                    HANDLE hevent,
                                    DWORD dwfFlags);

DWORD APIENTRY RasSignalNewConnection( HCONN hconn);

DWORD APIENTRY RasSetDevConfig( HPORT hport,
                                PCHAR devicetype,
                                PBYTE config,
                                DWORD size);

DWORD APIENTRY RasGetDevConfig( HANDLE hConnection,
                                HPORT hport,
                                PCHAR devicetype,
                                PBYTE config,
                                DWORD* size);

DWORD APIENTRY RasGetTimeSinceLastActivity( HPORT hport,
                                            LPDWORD lpdwTimeSinceLastActivity );

DWORD APIENTRY RasBundleGetStatistics( HANDLE,
                                       HPORT,
                                       PBYTE,
                                       PDWORD);

DWORD APIENTRY RasBundleGetStatisticsEx( HANDLE,
                                         HPORT,
                                         PBYTE,
                                         PDWORD);

DWORD APIENTRY RasBundleClearStatistics(HANDLE,
                                        HPORT);

DWORD APIENTRY RasBundleClearStatisticsEx(HANDLE,
                                          HCONN);

DWORD APIENTRY RasPnPControl( DWORD,
                              HPORT);

DWORD APIENTRY RasSetIoCompletionPort( HPORT,
                                       HANDLE,
                                       PRAS_OVERLAPPED,
                                       PRAS_OVERLAPPED,
                                       PRAS_OVERLAPPED,
                                       PRAS_OVERLAPPED);

DWORD APIENTRY RasSetRouterUsage( HPORT,
                                  BOOL);

DWORD APIENTRY RasServerPortClose( HPORT );

DWORD APIENTRY RasSetRasdialInfo( HPORT,
                                   CHAR *,
                                   CHAR *,
                                   CHAR *,
                                   DWORD,
                                   PBYTE);

DWORD APIENTRY RasSendPppMessageToRasman( HPORT,
                                          LPBYTE);

DWORD APIENTRY RasGetNumPortOpen ();

// DWORD APIENTRY RasNotifyConfigChange();

DWORD _RasmanInit( LPDWORD pNumPorts);

VOID _RasmanEngine();

DWORD APIENTRY RasRegisterPnPEvent ( HANDLE, BOOL );

DWORD APIENTRY RasRegisterPnPHandler ( PAPCFUNC,
                                       HANDLE,
                                       BOOL);

DWORD APIENTRY RasRpcConnect ( LPWSTR,
                               HANDLE *);

DWORD APIENTRY RasRpcDisconnect( HANDLE *);

DWORD APIENTRY RasRpcConnectServer(LPTSTR lpszServer,
                                   HANDLE *pHConnection);

DWORD APIENTRY RasRpcDisconnectServer(HANDLE hConnection);

DWORD APIENTRY RasSetBapPolicy ( HCONN,
                                 DWORD,
                                 DWORD,
                                 DWORD,
                                 DWORD );

DWORD APIENTRY RasPppStarted ( HPORT hPort );

DWORD APIENTRY RasRefConnection ( HCONN hConn,
                                  BOOL AddRef,
                                  DWORD *pdwRefCount );

DWORD APIENTRY RasPppGetEapInfo ( HCONN  hConn,
                                  DWORD  dwSubEntry,
                                  PDWORD pdwContextId,
                                  PDWORD pdwEapTypeId,
                                  PDWORD pdwSizeofEapUIData,
                                  PBYTE  pbdata );

DWORD APIENTRY RasPppSetEapInfo ( HPORT hPort,
                                  DWORD dwSizeOfEapUIdata,
                                  DWORD dwContextId,
                                  PBYTE pbdata);

DWORD APIENTRY RasSetDeviceConfigInfo( HANDLE hConnection,
                                       DWORD  cDevices,
                                       DWORD  cbBuffer,
                                       BYTE   *pbBuffer);

DWORD APIENTRY RasGetDeviceConfigInfo( HANDLE hConnection,
                                       DWORD  *dwVersion,
                                       DWORD  *pcDevices,
                                       DWORD  *pcbdata,
                                       BYTE   *pbBuffer);

DWORD APIENTRY RasFindPrerequisiteEntry(
                            HCONN hConn,
                            HCONN *phConnPrerequisiteEntry);

DWORD APIENTRY RasPortOpenEx(CHAR   *pszDeviceName,
                             DWORD  dwDeviceLineCounter,
                             HPORT  *phport,
                             HANDLE hnotifier,
                             DWORD  dwFlags);

DWORD APIENTRY RasLinkGetStatistics( HANDLE hConnection,
                                     HCONN hConn,
                                     DWORD dwSubEntry,
                                     PBYTE pbStats);

DWORD APIENTRY RasConnectionGetStatistics(HANDLE hConnection,
                                          HCONN hConn,
                                          PBYTE pbStats);

DWORD APIENTRY RasGetHportFromConnection(HANDLE hConnection,
                                         HCONN hConn,
                                         HPORT *phport);

DWORD APIENTRY RasReferenceCustomCount(HCONN  hConn,
                                       BOOL   fAddref,
                                       CHAR*  pszPhonebookPath,
                                       CHAR*  pszEntryName,
                                       DWORD* pdwCount);

DWORD APIENTRY RasGetHConnFromEntry(HCONN *phConn,
                                    CHAR  *pszPhonebookPath,
                                    CHAR  *pszEntryName);

DWORD APIENTRY RasGetConnectInfo(
            HPORT            hPort,
            DWORD            *pdwSize,
            RAS_CONNECT_INFO *pConnectInfo
            );

DWORD APIENTRY RasGetDeviceName(
            RASDEVICETYPE   eDeviceType,
            CHAR            *pszDeviceName
            );

DWORD APIENTRY RasGetCalledIdInfo(
            HANDLE              hConneciton,
            RAS_DEVICE_INFO     *pDeviceInfo,
            DWORD               *pdwSize,
            RAS_CALLEDID_INFO   *pCalledIdInfo
            );

DWORD APIENTRY RasSetCalledIdInfo(
            HANDLE              hConnection,
            RAS_DEVICE_INFO     *pDeviceInfo,
            RAS_CALLEDID_INFO   *pCalledIdInfo,
            BOOL                fWrite
            );


DWORD APIENTRY RasEnableIpSec(HPORT hPort,
                              BOOL  fEnable,
                              BOOL  fServer,
                              RAS_L2TP_ENCRYPTION eDataEncryption
                              );

DWORD APIENTRY RasIsIpSecEnabled(HPORT hPort,
                                 BOOL  *pfIsIpSecEnabled);

DWORD APIENTRY RasGetEapUserInfo(HANDLE hToken,
                                 PBYTE  pbEapInfo,
                                 DWORD  *pdwInfoSize,
                                 GUID   *pGuid,
                                 BOOL   fRouter,
                                 DWORD  dwEapTypeId
                                 );

DWORD APIENTRY RasSetEapUserInfo(HANDLE hToken,
                                 GUID   *pGuid,
                                 PBYTE  pbUserInfo,
                                 DWORD  dwInfoSize,
                                 BOOL   fClear,
                                 BOOL   fRouter,
                                 DWORD  dwEapTypeId
                                 );

DWORD APIENTRY RasSetEapLogonInfo(HPORT hPort,
                                  BOOL fLogon,
                                  RASEAPINFO *pEapInfo);

DWORD APIENTRY RasSendNotification(RASEVENT *pRasEvent);

DWORD APIENTRY RasGetNdiswanDriverCaps(
                HANDLE                  hConnection,
                RAS_NDISWAN_DRIVER_INFO *pInfo);

DWORD APIENTRY RasGetBandwidthUtilization(
                HPORT hPort,
                RAS_GET_BANDWIDTH_UTILIZATION *pUtilization);

DWORD APIENTRY RasGetProtocolInfo(
                      HANDLE hConnection,
                      RASMAN_GET_PROTOCOL_INFO *pInfo);

BOOL IsRasmanProcess();

DWORD APIENTRY RasGetCustomScriptDll(CHAR *pszCustomDll);

DWORD DwRasGetHostByName(CHAR *pszHostName, 
                   DWORD **ppdwAddress, 
                   DWORD *pcAddresses);

DWORD RasIsTrustedCustomDll(
            HANDLE hConnection,
            WCHAR *pwszCustomDll, 
            BOOL *pfResult);

DWORD RasDoIke(
            HANDLE hConnection,
            HPORT  hPort,
            DWORD  *pdwStatus);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\imported\net\rras\inc\rasppp.h ===
/* Copyright (c) 1993, Microsoft Corporation, all rights reserved
**
** rasppp.h
** Remote Access PPP
** Public PPP client API and server API header
*/

#ifndef _RASPPP_H_
#define _RASPPP_H_

#include <ras.h>
#include <mprapi.h>     // For definitions of IPADDRESSLEN,IPXADDRESSLEN 
                        // and ATADDRESSLEN

#define MAXPPPFRAMESIZE 1500
#define PARAMETERBUFLEN 500

/*---------------------------------------------------------------------------
** PPP Engine -> Client/DDM messages
**---------------------------------------------------------------------------
*/

/* Client PPP configuration values set with RasPppStart.
*/
typedef struct _PPP_CONFIG_INFO
{
    DWORD dwConfigMask;
    DWORD dwCallbackDelay;
}
PPP_CONFIG_INFO;

/* dwConfigMask bit values.
**
** Note: Due to the implentation of compression and encryption in the drivers,
**       'UseSwCompression' and 'RequireMsChap' must be set, whenever
**       'RequireEncryption' is set.
*/
#define PPPCFG_UseCallbackDelay         0x00000001
#define PPPCFG_UseSwCompression         0x00000002
#define PPPCFG_ProjectNbf               0x00000004
#define PPPCFG_ProjectIp                0x00000008
#define PPPCFG_ProjectIpx               0x00000010
#define PPPCFG_ProjectAt                0x00000020
#define PPPCFG_NegotiateSPAP            0x00000040
#define PPPCFG_RequireEncryption        0x00000080
#define PPPCFG_NegotiateMSCHAP          0x00000100
#define PPPCFG_UseLcpExtensions         0x00000200
#define PPPCFG_NegotiateMultilink       0x00000400
#define PPPCFG_AuthenticatePeer         0x00000800
#define PPPCFG_RequireStrongEncryption  0x00001000
#define PPPCFG_NegotiateBacp            0x00002000
#define PPPCFG_AllowNoAuthentication    0x00004000
#define PPPCFG_NegotiateEAP             0x00008000
#define PPPCFG_NegotiatePAP             0x00010000
#define PPPCFG_NegotiateMD5CHAP         0x00020000
#define PPPCFG_RequireIPSEC             0x00040000
#define PPPCFG_DisableEncryption        0x00080000
#define PPPCFG_UseLmPassword            0x00200000
#define PPPCFG_AllowNoAuthOnDCPorts     0x00400000
#define PPPCFG_NegotiateStrongMSCHAP    0x00800000
#define PPPCFG_NoCallback               0x01000000


/* PPP error notification returned by RasPppGetInfo.
*/
typedef struct _PPP_FAILURE
{
    DWORD dwError;
    DWORD dwExtendedError;  // 0 if none
}
PPP_FAILURE;


/* PPP control protocol results returned by RasPppGetInfo.
*/
typedef struct _PPP_NBFCP_RESULT
{
    DWORD dwError;
    DWORD dwNetBiosError;
    CHAR  szName[ NETBIOS_NAME_LEN + 1 ];
    WCHAR wszWksta[ NETBIOS_NAME_LEN + 1 ];
}
PPP_NBFCP_RESULT;

typedef struct _PPP_IPCP_RESULT
{
    DWORD dwError;

    BOOL  fSendVJHCompression;
    BOOL  fReceiveVJHCompression;

    DWORD dwLocalAddress;
    DWORD dwLocalWINSAddress;
    DWORD dwLocalWINSBackupAddress;
    DWORD dwLocalDNSAddress;
    DWORD dwLocalDNSBackupAddress;

    DWORD dwRemoteAddress;
    DWORD dwRemoteWINSAddress;
    DWORD dwRemoteWINSBackupAddress;
    DWORD dwRemoteDNSAddress;
    DWORD dwRemoteDNSBackupAddress;
}
PPP_IPCP_RESULT;

typedef struct _PPP_IPXCP_RESULT
{
    DWORD dwError;
    BYTE  bLocalAddress[10];
    BYTE  bRemoteAddress[10];
}
PPP_IPXCP_RESULT;

typedef struct _PPP_ATCP_RESULT
{
    DWORD dwError;
    DWORD dwLocalAddress;
    DWORD dwRemoteAddress;
}
PPP_ATCP_RESULT;

typedef struct _PPP_CCP_RESULT
{
    DWORD dwError;
    DWORD dwSendProtocol;
    DWORD dwSendProtocolData;
    DWORD dwReceiveProtocol;
    DWORD dwReceiveProtocolData;
}
PPP_CCP_RESULT;

#define PPPLCPO_PFC           0x00000001
#define PPPLCPO_ACFC          0x00000002
#define PPPLCPO_SSHF          0x00000004
#define PPPLCPO_DES_56        0x00000008
#define PPPLCPO_3_DES         0x00000010

typedef struct _PPP_LCP_RESULT
{
    /* Valid handle indicates one of the possibly multiple connections to
    ** which this connection is bundled. INVALID_HANDLE_VALUE indicates the
    ** connection is not bundled.
    */
    HPORT hportBundleMember;

    DWORD dwLocalAuthProtocol;
    DWORD dwLocalAuthProtocolData;
    DWORD dwLocalEapTypeId;
    DWORD dwLocalFramingType;
    DWORD dwLocalOptions;               // Look at PPPLCPO_*
    DWORD dwRemoteAuthProtocol;
    DWORD dwRemoteAuthProtocolData;
    DWORD dwRemoteEapTypeId;
    DWORD dwRemoteFramingType;
    DWORD dwRemoteOptions;              // Look at PPPLCPO_*
    CHAR* szReplyMessage;
}
PPP_LCP_RESULT;


typedef struct _PPP_PROJECTION_RESULT
{
    PPP_NBFCP_RESULT nbf;
    PPP_IPCP_RESULT  ip;
    PPP_IPXCP_RESULT ipx;
    PPP_ATCP_RESULT  at;
    PPP_CCP_RESULT   ccp;
    PPP_LCP_RESULT   lcp;
}
PPP_PROJECTION_RESULT;

/* PPP error notification 
*/
typedef struct _PPPDDM_FAILURE
{
    DWORD dwError;
    CHAR  szUserName[ UNLEN + 1 ];
    CHAR  szLogonDomain[ DNLEN + 1 ];
}
PPPDDM_FAILURE;


/* Call back configuration information received by PPPDDMMSG routine.
*/
typedef struct _PPPDDM_CALLBACK_REQUEST
{
    BOOL  fUseCallbackDelay;
    DWORD dwCallbackDelay;
    CHAR  szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
}
PPPDDM_CALLBACK_REQUEST;

/* BAP request to callback the remote peer
*/
typedef struct _PPPDDM_BAP_CALLBACK_REQUEST
{
    HCONN hConnection;
    CHAR  szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
}
PPPDDM_BAP_CALLBACK_REQUEST;

/* Authentication information received by PPPDDMMSG routine.
*/
typedef struct _PPPDDM_AUTH_RESULT
{
    CHAR    szUserName[ UNLEN + 1 ];
    CHAR    szLogonDomain[ DNLEN + 1 ];
    BOOL    fAdvancedServer;
}
PPPDDM_AUTH_RESULT;

/* Notification of a new BAP link up
*/
typedef struct _PPPDDM_NEW_BAP_LINKUP
{
    HRASCONN    hRasConn;

}PPPDDM_NEW_BAP_LINKUP;

/* Notification of a new Bundle
*/
typedef struct _PPPDDM_NEW_BUNDLE
{
    PBYTE   pClientInterface;

} PPPDDM_NEW_BUNDLE;

/* Client should invoke EAP UI dialog
*/
typedef struct _PPP_INVOKE_EAP_UI
{
    DWORD       dwEapTypeId;
    DWORD       dwContextId;
    PBYTE       pUIContextData;
    DWORD       dwSizeOfUIContextData;

}PPP_INVOKE_EAP_UI;

/* Client should save per-connection data
*/
typedef struct _PPP_SET_CUSTOM_AUTH_DATA
{
    BYTE*       pConnectionData;
    DWORD       dwSizeOfConnectionData;

}PPP_SET_CUSTOM_AUTH_DATA;

/* Notification of port addition\removal\usage change
*/
typedef struct _PPPDDM_PNP_NOTIFICATION 
{
    PNP_EVENT_NOTIF PnPNotification;

} PPPDDM_PNP_NOTIFICATION;

/* Notification of PPP session termination
*/
typedef struct _PPPDDM_STOPPED
{
    DWORD   dwReason;

} PPPDDM_STOPPED;

typedef enum _PPP_MSG_ID
{
    PPPMSG_PppDone = 0,             // PPP negotiated all successfully.
    PPPMSG_PppFailure,              // PPP failure (fatal error including
                                    // authentication failure with no
                                    // retries), disconnect line.
    PPPMSG_AuthRetry,               // Authentication failed, have retries.
    PPPMSG_Projecting,              // Executing specified NCPs.
    PPPMSG_ProjectionResult,        // NCP completion status.
    PPPMSG_CallbackRequest = 5,     // Server needs "set-by-caller" number.
    PPPMSG_Callback,                // Server is about to call you back.
    PPPMSG_ChangePwRequest,         // Server needs new password (expired).
    PPPMSG_LinkSpeed,               // Calculating link speed.
    PPPMSG_Progress,                // A retry or other sub-state of
                                    // progress has been reached in the
                                    // current state.
    PPPMSG_Stopped = 10,            // Response to RasPppStop indicating
                                    // PPP engine has stopped.
    PPPMSG_InvokeEapUI,             // Client should invoke EAP UI dialog
    PPPMSG_SetCustomAuthData,       // Save per-connection data
    PPPDDMMSG_PppDone,              // PPP negotiated successfully.
    PPPDDMMSG_PppFailure,           // PPP server failure (fatal error),
                                    // disconnect line.
    PPPDDMMSG_CallbackRequest = 15, // Callback client now.
    PPPDDMMSG_BapCallbackRequest,   // Callback remote BAP peer.
    PPPDDMMSG_Authenticated,        // Client has been authenticated.
    PPPDDMMSG_Stopped,              // Response to PppDdmStop indicating
                                    // PPP engine has stopped.
    PPPDDMMSG_NewLink,              // Client is a new link in a bundle
    PPPDDMMSG_NewBundle = 20,       // Client is a new bundle
    PPPDDMMSG_NewBapLinkUp,         // Client is a new BAP link in a bundle
    PPPDDMMSG_PnPNotification,      // Port is being added or removed or usage
                                    // is being changed, transport being added
                                    // or removed etc.
    PPPDDMMSG_PortCleanedUp         // PPP port control block is now cleaned up
        
} PPP_MSG_ID;

/* Client/DDM notifications read with RasPppGetInfo.
*/
typedef struct _PPP_MESSAGE
{
    struct _PPP_MESSAGE *   pNext;
    DWORD                   dwError;
    PPP_MSG_ID              dwMsgId;
    HPORT                   hPort;

    union
    {
        /* dwMsgId is PPPMSG_ProjectionResult or PPPDDMMSG_Done.
        */
        PPP_PROJECTION_RESULT ProjectionResult;

        /* dwMsgId is PPPMSG_Failure.
        */
        PPP_FAILURE Failure;

        /* dwMsgId is PPPMSG_InvokeEapUI         
        */
        PPP_INVOKE_EAP_UI InvokeEapUI;

        /* dwMsgId is PPPMSG_SetCustomAuthData         
        */
        PPP_SET_CUSTOM_AUTH_DATA SetCustomAuthData;

        /* dwMsgId is PPPDDMMSG_Failure.
        */
        PPPDDM_FAILURE DdmFailure;

        /* dwMsgId is PPPDDMMSG_Authenticated.
        */
        PPPDDM_AUTH_RESULT AuthResult;

        /* dwMsgId is PPPDDMMSG_CallbackRequest.
        */
        PPPDDM_CALLBACK_REQUEST CallbackRequest;

        /* dwMsgId is PPPDDMMSG_BapCallbackRequest.
        */
        PPPDDM_BAP_CALLBACK_REQUEST BapCallbackRequest;

        /* dwMsgId is PPPDDMMSG_NewBapLinkUp         
        */
        PPPDDM_NEW_BAP_LINKUP BapNewLinkUp;

        /* dwMsgId is PPPDDMMSG_NewBundle   
        */
        PPPDDM_NEW_BUNDLE DdmNewBundle;

        /* dwMsgId is PPPDDMMSG_PnPNotification   
        */
        PPPDDM_PNP_NOTIFICATION DdmPnPNotification;

        /* dwMsgId is PPPDDMMSG_Stopped   
        */
        PPPDDM_STOPPED DdmStopped;
    }
    ExtraInfo;
}
PPP_MESSAGE;

/*---------------------------------------------------------------------------
** Client/DDM -> Engine messages
**---------------------------------------------------------------------------
*/

/* Set of interface handles passed from DIM to PPP
*/
typedef struct _PPP_INTERFACE_INFO
{
    ROUTER_INTERFACE_TYPE   IfType;
    HANDLE                  hIPInterface;
    HANDLE                  hIPXInterface;
    CHAR                    szzParameters[ PARAMETERBUFLEN ];
}
PPP_INTERFACE_INFO;

typedef struct _PPP_BAPPARAMS
{
    DWORD               dwDialMode;
    DWORD               dwDialExtraPercent;
    DWORD               dwDialExtraSampleSeconds;
    DWORD               dwHangUpExtraPercent;
    DWORD               dwHangUpExtraSampleSeconds;
}
PPP_BAPPARAMS;

typedef struct _PPP_EAP_UI_DATA
{
    DWORD               dwContextId;
    PBYTE               pEapUIData;
    DWORD               dwSizeOfEapUIData;
}
PPP_EAP_UI_DATA;

#define  PPPFLAGS_DisableNetbt         0x00000001

/* Parameters to start client PPP on a port.
*/
typedef struct _PPP_START
{
    CHAR                szPortName[ MAX_PORT_NAME +1 ];
    CHAR                szUserName[ UNLEN + 1 ];
    CHAR                szPassword[ PWLEN + 1 ];
    CHAR                szDomain[ DNLEN + 1 ];
    LUID                Luid;
    PPP_CONFIG_INFO     ConfigInfo;
    CHAR                szzParameters[ PARAMETERBUFLEN ];
    BOOL                fThisIsACallback;
    BOOL                fRedialOnLinkFailure;
    HANDLE              hEvent;
    DWORD               dwPid;
    PPP_INTERFACE_INFO  PppInterfaceInfo;
    DWORD               dwAutoDisconnectTime;
    PPP_BAPPARAMS       BapParams;    
    CHAR *              pszPhonebookPath;
    CHAR *              pszEntryName;
    CHAR *              pszPhoneNumber;
    HANDLE              hToken;
    PRAS_CUSTOM_AUTH_DATA pCustomAuthConnData;
    DWORD               dwEapTypeId;
    BOOL                fLogon;
    BOOL                fNonInteractive;
    DWORD               dwFlags;
    PRAS_CUSTOM_AUTH_DATA pCustomAuthUserData;
    PPP_EAP_UI_DATA     EapUIData;
}
PPP_START;

/* Parameters to stop client/server PPP on a port.
*/
typedef struct _PPP_STOP
{
    DWORD               dwStopReason;
}
PPP_STOP;

/* Parameters to start server PPP on a port.
*/
typedef struct _PPPDDM_START
{
    DWORD               dwAuthRetries;
    CHAR                szPortName[MAX_PORT_NAME+1];
    CHAR                achFirstFrame[ MAXPPPFRAMESIZE ];
    DWORD               cbFirstFrame;
}
PPPDDM_START;

/* Parameters to notify PPP that callback is complete.
*/
typedef struct _PPP_CALLBACK_DONE
{
    CHAR                szCallbackNumber[ MAX_PHONE_NUMBER_LEN + 1 ];
}
PPP_CALLBACK_DONE;

/* Parameters to notify server of "set-by-caller" callback options.
*/
typedef struct _PPP_CALLBACK
{
    CHAR                szCallbackNumber[ RAS_MaxCallbackNumber + 1 ];
}
PPP_CALLBACK;


/* Parameters to notify server of new password after it's told client the
** password has expired.  The user name and old password are also provided
** since they are required to support the auto-logon case.
*/
typedef struct _PPP_CHANGEPW
{
    CHAR                szUserName[ UNLEN + 1 ];
    CHAR                szOldPassword[ PWLEN + 1 ];
    CHAR                szNewPassword[ PWLEN + 1 ];
}
PPP_CHANGEPW;


/* Parameters to notify server of new authentication credentials after it's
** told client the original credentials are invalid but a retry is allowed.
*/
typedef struct _PPP_RETRY
{
    CHAR                szUserName[ UNLEN + 1 ];
    CHAR                szPassword[ PWLEN + 1 ];
    CHAR                szDomain[ DNLEN + 1 ];
}
PPP_RETRY;

/*
** Parameters to notify PPP that a packet has arrived from the peer
*/
typedef struct _PPP_RECEIVE 
{
    DWORD               dwNumBytes;     // The number of bytes in the buffer
    BYTE*               pbBuffer;       // The data sent by the peer
}
PPP_RECEIVE;

/*
** Parameters to notify PPP that a BAP event (add/drop link) has fired
*/
typedef struct _PPP_BAP_EVENT
{
    BOOL                fAdd;           // Add a link iff TRUE
    BOOL                fTransmit;      // Send threshold iff TRUE
    DWORD               dwSendPercent;  // Send bandwidth utilization
    DWORD               dwRecvPercent;  // Recv bandwidth utilization
}
PPP_BAP_EVENT;

typedef struct _PPP_BAP_CALLBACK_RESULT 
{
    DWORD               dwCallbackResultCode;
}
PPP_BAP_CALLBACK_RESULT;

typedef struct _PPP_DHCP_INFORM 
{
    WCHAR*              wszDevice;
    DWORD               dwNumDNSAddresses;
    DWORD*              pdwDNSAddresses;
    DWORD               dwWINSAddress1;
    DWORD               dwWINSAddress2;
    CHAR*               szDomainName;
}
PPP_DHCP_INFORM;

typedef struct _PPP_PROTOCOL_EVENT
{
    USHORT              usProtocolType;
    ULONG               ulFlags;
} 
PPP_PROTOCOL_EVENT;

typedef struct _PPP_IP_ADDRESS_LEASE_EXPIRED
{
    ULONG               nboIpAddr;
}
PPP_IP_ADDRESS_LEASE_EXPIRED;

/* Client/DDM->Engine messages.
*/
typedef struct _PPPE_MESSAGE
{
    DWORD   dwMsgId;
    HPORT   hPort;
    HCONN   hConnection;

    union
    {
        PPP_START           Start;              // PPPEMSG_Start
        PPP_STOP            Stop;               // PPPEMSG_Stop
        PPP_CALLBACK        Callback;           // PPPEMSG_Callback
        PPP_CHANGEPW        ChangePw;           // PPPEMSG_ChangePw
        PPP_RETRY           Retry;              // PPPEMSG_Retry
        PPP_RECEIVE         Receive;            // PPPEMSG_Receive
        PPP_BAP_EVENT       BapEvent;           // PPPEMSG_BapEvent
        PPPDDM_START        DdmStart;           // PPPEMSG_DdmStart
        PPP_CALLBACK_DONE   CallbackDone;       // PPPEMSG_DdmCallbackDone
        PPP_INTERFACE_INFO  InterfaceInfo;      // PPPEMSG_DdmInterfaceInfo
        PPP_BAP_CALLBACK_RESULT 
                            BapCallbackResult;  // PPPEMSG_DdmBapCallbackResult
        PPP_DHCP_INFORM     DhcpInform;         // PPPEMSG_DhcpInform
        PPP_EAP_UI_DATA     EapUIData;          // PPPEMSG_EapUIData
        PPP_PROTOCOL_EVENT  ProtocolEvent;      // PPPEMSG_ProtocolEvent
        PPP_IP_ADDRESS_LEASE_EXPIRED            // PPPEMSG_IpAddressLeaseExpired
                            IpAddressLeaseExpired;
    }
    ExtraInfo;
}
PPPE_MESSAGE;

/* PPPE_MESSAGE dwMsgId codes for client and DDM sessions.
*/
typedef enum _PPPE_MSG_ID
{
    PPPEMSG_Start,              // Starts client PPP on a port.
    PPPEMSG_Stop,               // Stops PPP on a port.
    PPPEMSG_Callback,           // Provides "set-by-caller" number to server.
    PPPEMSG_ChangePw,           // Provides new password (expired) to server.
    PPPEMSG_Retry,              // Provides new credentials for authentication.
    PPPEMSG_Receive,            // A packet has arrived.
    PPPEMSG_LineDown,           // The line has gone down.
    PPPEMSG_ListenResult,       // The result of a call to RasPortListen
    PPPEMSG_BapEvent,           // A BAP event (add/drop link) has fired.
    PPPEMSG_DdmStart,           // Starts server PPP on a port.
    PPPEMSG_DdmCallbackDone,    // Notify PPP that callback is complete.
    PPPEMSG_DdmInterfaceInfo,   // Interface handles from DDM
    PPPEMSG_DdmBapCallbackResult,// Result of a BAP callback request.
    PPPEMSG_DhcpInform,         // The result of a DHCPINFORM
    PPPEMSG_EapUIData,          // Data from EAP interactive UI
    PPPEMSG_DdmChangeNotification, // Change notification in DDM
    PPPEMSG_ProtocolEvent,      // Protocol added/removed notification
    PPPEMSG_IpAddressLeaseExpired  // IP address lease expired. Used by rasiphlp

} PPPE_MSG_ID;

//
// Prototypes of function exported by RASPPP.DLL for use by RASMAN
//

DWORD APIENTRY
StartPPP(
    DWORD NumPorts
    /*,DWORD (*SendPPPMessageToRasman)( PPP_MESSAGE * PppMsg )*/
);

DWORD APIENTRY
StopPPP(
    HANDLE hEventStopPPP
);

DWORD APIENTRY
SendPPPMessageToEngine(
    IN PPPE_MESSAGE* pMessage
);

//
// PPP client side Apis
//

DWORD APIENTRY
RasPppStop(
    IN HPORT                hPort
);

DWORD APIENTRY
RasPppCallback(
    IN HPORT                hPort,
    IN CHAR*                pszCallbackNumber
);

DWORD APIENTRY
RasPppChangePassword(
    IN HPORT                hPort,
    IN CHAR*                pszUserName,
    IN CHAR*                pszOldPassword,
    IN CHAR*                pszNewPassword
);

DWORD APIENTRY
RasPppGetInfo(
    IN  HPORT               hPort,
    OUT PPP_MESSAGE*        pMsg
);

DWORD APIENTRY
RasPppRetry(
    IN HPORT                hPort,
    IN CHAR*                pszUserName,
    IN CHAR*                pszPassword,
    IN CHAR*                pszDomain
);

DWORD APIENTRY
RasPppStart(
    IN HPORT                hPort,
    IN CHAR*                pszPortName,
    IN CHAR*                pszUserName,
    IN CHAR*                pszPassword,
    IN CHAR*                pszDomain,
    IN LUID*                pLuid,
    IN PPP_CONFIG_INFO*     pConfigInfo,
    IN LPVOID               pPppInterfaceInfo,
    IN CHAR*                pszzParameters,
    IN BOOL                 fThisIsACallback,
    IN HANDLE               hEvent,
    IN DWORD                dwAutoDisconnectTime,
    IN BOOL                 fRedialOnLinkFailure,
    IN PPP_BAPPARAMS*       pBapParams,
    IN BOOL                 fNonInteractive,
    IN DWORD                dwEapTypeId,
    IN DWORD                dwFlags
);

//
// DDM API prototypes
//
DWORD
PppDdmInit(
    IN  VOID    (*SendPPPMessageToDdm)( PPP_MESSAGE * PppMsg ),
    IN  DWORD   dwServerFlags,
    IN  DWORD   dwLoggingLevel,
    IN  DWORD   dwNASIpAddress,
    IN  BOOL    fRadiusAuthentication,
    IN  LPVOID  lpfnRasAuthProviderAuthenticateUser,
    IN  LPVOID  lpfnRasAuthProviderFreeAttributes,
    IN  LPVOID  lpfnRasAcctProviderStartAccounting,
    IN  LPVOID  lpfnRasAcctProviderInterimAccounting,
    IN  LPVOID  lpfnRasAcctProviderStopAccounting,
    IN  LPVOID  lpfnRasAcctProviderFreeAttributes,
    IN  LPVOID  lpfnGetNextAccountingSessionId
);

VOID
PppDdmDeInit(
);

DWORD
PppDdmCallbackDone(
    IN HPORT                hPort,
    IN WCHAR*               pwszCallbackNumber
);

DWORD
PppDdmStart(
    IN HPORT                hPort,
    IN WCHAR*               wszPortName,
    IN CHAR*                pchFirstFrame,
    IN DWORD                cbFirstFrame,
    IN DWORD                dwAuthRetries
);

DWORD
PppDdmStop(
    IN HPORT                hPort,
    IN DWORD                dwStopReason 
);

DWORD
PppDdmChangeNotification(
    IN DWORD                dwServerFlags,
    IN DWORD                dwLoggingLevel
);

DWORD
PppDdmSendInterfaceInfo(
    IN HCONN                hConnection,
    IN PPP_INTERFACE_INFO * pInterfaceInfo 
);

DWORD
PppDdmBapCallbackResult(
    IN HCONN                hConnection,
    IN DWORD                dwBapCallbackResultCode
);

#endif // _RASPPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\imported\net\rras\ras\inc\serial.h ===
//****************************************************************************
//
//                     Microsoft NT Remote Access Service
//
//      Copyright (C) 1992-93 Microsft Corporation. All rights reserved.
//
//  Filename: serial.h
//
//  Revision History:
//
//  July 27, 1992   Gurdeep Pall Created
//
//
//  Description: This file contains name strings for standard parameter
//               names used for serial Media.
//
//****************************************************************************


#ifndef _SERIALDLLINCLUDE_
#define _SERIALDLLINCLUDE_


//  General Defines  *********************************************************
//

#define MAX_BPS_STR_LEN     11  //Longest string from a DWORD + zero byte

#define SERIAL_TXT          "serial"


//  Serial.ini File Defines  *************************************************
//

#define SER_MAXCONNECTBPS_KEY   "MAXCONNECTBPS"
#define SER_MAXCARRIERBPS_KEY   "MAXCARRIERBPS"
#define SER_INITBPS_KEY         "INITIALBPS"

#define SER_DEVICETYPE_KEY      "DEVICETYPE"
#define SER_DEVICENAME_KEY      "DEVICENAME"

#define SER_USAGE_KEY           "USAGE"
#define SER_USAGE_VALUE_CLIENT  "Client"
#define SER_USAGE_VALUE_SERVER  "Server"
//#define SER_USAGE_VALUE_BOTH    "ClientAndServer"
#define SER_USAGE_VALUE_ROUTER  "Router"
#define SER_USAGE_VALUE_NONE    "None"

#define SER_DEFAULTOFF_KEY      "DEFAULTOFF"
#define SER_C_DEFAULTOFF_KEY    "CLIENT_DEFAULTOFF"


//  PortGetInfo and PortSetInfo Defines  *************************************
//

#define SER_PORTNAME_KEY        "PortName"
#define SER_CONNECTBPS_KEY      "ConnectBPS"
#define SER_DATABITS_KEY        "WordSize"

#define SER_PARITY_KEY          "Parity"
#define SER_STOPBITS_KEY        "StopBits"
#define SER_HDWFLOWCTRLON_KEY   "HdwFlowControlEnabled"

#define SER_CARRIERBPS_KEY      "CarrierBPS"
#define SER_ERRORCONTROLON_KEY  "ErrorControlEnabled"
#define SER_DEFAULTOFFSTR_KEY   "DEFAULTOFF"
#define SER_C_DEFAULTOFFSTR_KEY "CLIENT_DEFAULTOFF"

#define SER_PORTOPEN_KEY        "PortOpenFlag"


//  Statistics Indicies  *****************************************************
//

#define NUM_RAS_SERIAL_STATS    14

#define BYTES_XMITED            0       //Generic Stats
#define BYTES_RCVED             1
#define FRAMES_XMITED           2
#define FRAMES_RCVED            3

#define CRC_ERR                 4       //Serial Stats
#define TIMEOUT_ERR             5
#define ALIGNMENT_ERR           6
#define SERIAL_OVERRUN_ERR      7
#define FRAMING_ERR             8
#define BUFFER_OVERRUN_ERR      9

#define BYTES_XMITED_UNCOMP     10      //Compression Stats
#define BYTES_RCVED_UNCOMP      11
#define BYTES_XMITED_COMP       12
#define BYTES_RCVED_COMP        13



#endif // _SERIALDLLINCLUDE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\imported\net\rras\ras\ui\inc\eapcfg.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// eapcfg.h
// EAP configuration library
// Public header
//
// 11/25/97 Steve Cobb


#ifndef _EAPCFG_H_
#define _EAPCFG_H_


//----------------------------------------------------------------------------
// Constants
//----------------------------------------------------------------------------

// The default EAP key code, i.e. TLS.
//
#define EAPCFG_DefaultKey 13


//----------------------------------------------------------------------------
// Datatypes
//----------------------------------------------------------------------------

// EAP configuration DLL entrypoints.  These definitions must match the
// raseapif.h prototypes for RasEapInvokeConfigUI and RasEapFreeUserData.
//
typedef DWORD (APIENTRY * RASEAPFREE)( PBYTE );
typedef DWORD (APIENTRY * RASEAPINVOKECONFIGUI)( DWORD, HWND, DWORD, PBYTE, DWORD, PBYTE*, DWORD*);
typedef DWORD (APIENTRY * RASEAPGETIDENTITY)( DWORD, HWND, DWORD, const WCHAR*, const WCHAR*, PBYTE, DWORD, PBYTE, DWORD, PBYTE*, DWORD*, WCHAR** );

// Flags
//
#define EAPCFG_FLAG_RequireUsername   0x1
#define EAPCFG_FLAG_RequirePassword   0x2

// EAP configuration package definition.
//
typedef struct
_EAPCFG
{
    // The package's unique EAP algorithm code.
    //
    DWORD dwKey;

    // The friendly name of the package suitable for display to the user.
    //
    TCHAR* pszFriendlyName;

    // The SystemRoot-relative path to the package's configuration DLL.  May
    // be NULL indicating there is none.
    //
    TCHAR* pszConfigDll;

    // The SystemRoot-relative path to the package's identity DLL.  May
    // be NULL indicating there is none.
    //
    TCHAR* pszIdentityDll;

    // Flags that specify what standard credentials are required at dial
    // time.
    //
    DWORD dwStdCredentialFlags;

    // True if user is to be forced to run the configuration API for the
    // package, i.e. defaults are not sufficient.
    //
    BOOL fForceConfig;

    // True if the package provides MPPE encryption keys, false if not.
    //
    BOOL fProvidesMppeKeys;

    // The package's default configuration blob, which can be overwritten by
    // the configuration DLL.  May be NULL and 0 indicating there is none.
    //
    BYTE* pData;
    DWORD cbData;

    // Eap per user data to be stored in HKCU. This data is returned from
    // the EapInvokeConfigUI entrypoint in the eap dll.
    //
    BYTE* pUserData;
    DWORD cbUserData;

    // Set when the configuration DLL has been called on the package.  This is
    // not a registry setting.  It is provided for the convenience of the UI
    // only.
    //
    BOOL fConfigDllCalled;

    // Specifies the class ID of the configuration UI for remote machines.
    GUID guidConfigCLSID;
}
EAPCFG;


//----------------------------------------------------------------------------
// Prototypes
//----------------------------------------------------------------------------

DTLNODE*
CreateEapcfgNode(
    void );

VOID
DestroyEapcfgNode(
    IN OUT DTLNODE* pNode );

DTLNODE*
EapcfgNodeFromKey(
    IN DTLLIST* pList,
    IN DWORD dwKey );

DTLLIST*
ReadEapcfgList(
    IN TCHAR* pszMachine );


#endif // _EAPCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\imported\net\rras\ras\ui\inc\intl.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** intl.h
** Remote Access international helpers
** Public header
*/

#ifndef _INTL_H_
#define _INTL_H_

/*----------------------------------------------------------------------------
** Constants
**----------------------------------------------------------------------------
*/

/* Flags to GetDurationString.
*/
#define GDSFLAG_Mseconds 0x00000001
#define GDSFLAG_Seconds  0x00000002
#define GDSFLAG_Minutes  0x00000004
#define GDSFLAG_Hours    0x00000008
#define GDSFLAG_Days     0x00000010
#define GDSFLAG_All      0x0000001F


/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

DWORD
GetDurationString(
    IN DWORD dwMilliseconds,
    IN DWORD dwFormatFlags,
    IN OUT PTSTR pszBuffer,
    IN OUT DWORD *pdwBufSize );

DWORD
GetNumberString(
    IN DWORD dwNumber,
    IN OUT PTSTR pszBuffer,
    IN OUT PDWORD pdwBufSize );

PTSTR
padultoa(
    UINT  val,
    PTSTR pszBuf,
    INT   width );


#endif // _INTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\imported\net\rras\ras\ui\inc\dtl.h ===
// Copyright (c) 1992, Microsoft Corporation, all rights reserved
//
// dtl.h
// Double-threaded linked list header
//
// 06/28/92 Steve Cobb

#ifndef _DTL_H_
#define _DTL_H_


#include <nouiutil.h>  // Heap definitions

// Forward declarations
//
typedef struct _DTLNODE DTLNODE;
typedef struct _DTLLIST DTLLIST;


// Double-threaded linked list node control block.  There is one node for each
// entry in a list.
//
// Applications should not access this structure directly.
//
typedef struct
_DTLNODE
{
    DTLNODE* pdtlnodePrev; // Address of previous node or NULL if none
    DTLNODE* pdtlnodeNext; // Address of next node or NULL if none
    VOID*    pData;        // Address of user's data
    LONG_PTR lNodeId;      // User-defined node identification code
}
DTLNODE;


// Double-threaded linked list control block.  There is one for each list.
//
// Applications should not access this structure directly.
//
typedef struct
_DTLLIST
{
    DTLNODE* pdtlnodeFirst; // Address of first node or NULL if none
    DTLNODE* pdtlnodeLast;  // Address of last node or NULL if none
    LONG     lNodes;        // Number of nodes in list
    LONG_PTR lListId;       // User-defined list identification code
}
DTLLIST;


// List node duplication function.  See DuplicateList.
//
typedef DTLNODE* (*PDUPNODE)( IN DTLNODE* );

// List node free function.  See FreeList.
//
typedef VOID (*PDESTROYNODE)( IN DTLNODE* );

// List node comparison function.  See MergeSort.
//
typedef IN (*PCOMPARENODE)( IN DTLNODE*, IN DTLNODE* );


// Macros and function prototypes.
//
#define DtlGetData( pdtlnode )        ((pdtlnode)->pData)
#define DtlGetNodeId( pdtlnode )      ((pdtlnode)->lNodeId)
#define DtlGetFirstNode( pdtllist )   ((pdtllist)->pdtlnodeFirst)
#define DtlGetListId( pdtllist )      ((pdtllist)->lListId)
#define DtlGetNextNode( pdtlnode )    ((pdtlnode)->pdtlnodeNext)
#define DtlGetNodes( pdtllist )       ((pdtllist)->lNodes)
#define DtlGetPrevNode( pdtlnode )    ((pdtlnode)->pdtlnodePrev)
#define DtlGetLastNode( pdtllist )    ((pdtllist)->pdtlnodeLast)
#define DtlPutData( pdtlnode, p )     ((pdtlnode)->pData = (p))
#define DtlPutNodeId( pdtlnode, l )   ((pdtlnode)->lNodeId = (LONG )(l))
#define DtlPutListCode( pdtllist, l ) ((pdtllist)->lListId = (LONG )(l))

DTLNODE* DtlAddNodeAfter( DTLLIST*, DTLNODE*, DTLNODE* );
DTLNODE* DtlAddNodeBefore( DTLLIST*, DTLNODE*, DTLNODE* );
DTLNODE* DtlAddNodeFirst( DTLLIST*, DTLNODE* );
DTLNODE* DtlAddNodeLast( DTLLIST*, DTLNODE* );
DTLLIST* DtlCreateList( LONG );
DTLNODE* DtlCreateNode( VOID*, LONG_PTR );
DTLNODE* DtlCreateSizedNode( LONG, LONG_PTR );
VOID     DtlDestroyList( DTLLIST*, PDESTROYNODE );
VOID     DtlDestroyNode( DTLNODE* );
DTLNODE* DtlDeleteNode( DTLLIST*, DTLNODE* );
DTLLIST* DtlDuplicateList( DTLLIST*, PDUPNODE, PDESTROYNODE );
VOID     DtlMergeSort( DTLLIST*, PCOMPARENODE );
VOID     DtlSwapLists( DTLLIST*, DTLLIST* );

DTLNODE* DtlNodeFromIndex( DTLLIST*, LONG );
DTLNODE* DtlRemoveNode( DTLLIST*, DTLNODE* );


#endif // _DTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\imported\net\rras\ras\ui\inc\list.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    list.h
//============================================================================


#ifndef InitializeListHead


//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\imported\net\rras\ras\ui\inc\loaddlls.h ===
/* Copyright (c) 1996, Microsoft Corporation, all rights reserved
**
** loaddlls.h
** RAS DLL load public header
**
** 02/17/96 Steve Cobb
*/

#ifndef _LOADDLLS_H_
#define _LOADDLLS_H_


#include <ras.h>    // Win32 RAS APIs
#include <rasdlg.h> // Win32 RAS UI APIs
#include <rasman.h> // RAS connection manager service
#include <rasppp.h> // PPP structure definitions

#define RASMERGE

/*----------------------------------------------------------------------------
** Datatypes and global declarations (defined in loaddlls.c)
**----------------------------------------------------------------------------
*/

/* RASAPI32.DLL entry points.
*/
#ifndef RASMERGE
extern HINSTANCE g_hRasapi32Dll;
#endif

typedef DWORD (APIENTRY * PRASCONNECTIONNOTIFICATION)( HRASCONN, HANDLE, DWORD );
extern PRASCONNECTIONNOTIFICATION g_pRasConnectionNotification;

typedef DWORD (APIENTRY * PRASDELETEENTRY)( LPTSTR, LPTSTR );
extern PRASDELETEENTRY g_pRasDeleteEntry;

typedef DWORD (APIENTRY * PRASDIAL)( LPRASDIALEXTENSIONS, LPTSTR, LPRASDIALPARAMS, DWORD, LPVOID, LPHRASCONN );
extern PRASDIAL g_pRasDial;

typedef DWORD (APIENTRY * PRASENUMENTRIES)( LPTSTR, LPTSTR, LPRASENTRYNAME, LPDWORD, LPDWORD );
extern PRASENUMENTRIES g_pRasEnumEntries;

typedef DWORD (APIENTRY * PRASENUMCONNECTIONS)( LPRASCONN, LPDWORD, LPDWORD );
extern PRASENUMCONNECTIONS g_pRasEnumConnections;

typedef DWORD (APIENTRY * PRASGETCONNECTSTATUS)( HRASCONN, LPRASCONNSTATUS );
extern PRASGETCONNECTSTATUS g_pRasGetConnectStatus;

typedef VOID (APIENTRY * PRASGETCONNECTRESPONSE)( HRASCONN, CHAR* );
extern PRASGETCONNECTRESPONSE g_pRasGetConnectResponse;

typedef DWORD (APIENTRY * PRASGETCREDENTIALS)( LPTSTR, LPTSTR, LPRASCREDENTIALS );
extern PRASGETCREDENTIALS g_pRasGetCredentials;

typedef DWORD (APIENTRY * PRASGETENTRYDIALPARAMS)( LPTSTR, LPRASDIALPARAMS, LPBOOL );
extern PRASGETENTRYDIALPARAMS g_pRasGetEntryDialParams;

typedef DWORD (APIENTRY * PRASGETERRORSTRING)( UINT, LPTSTR, DWORD );
extern PRASGETERRORSTRING g_pRasGetErrorString;

typedef DWORD (APIENTRY * PRASHANGUP)( HRASCONN );
extern PRASHANGUP g_pRasHangUp;

typedef DWORD (APIENTRY * PRASGETAUTODIALENABLE)( DWORD, LPBOOL );
extern PRASGETAUTODIALENABLE g_pRasGetAutodialEnable;

typedef DWORD (APIENTRY * PRASGETAUTODIALPARAM)( DWORD, LPVOID, LPDWORD );
extern PRASGETAUTODIALPARAM g_pRasGetAutodialParam;

typedef DWORD (APIENTRY * PRASGETPROJECTIONINFO)( HRASCONN, RASPROJECTION, LPVOID, LPDWORD );
extern PRASGETPROJECTIONINFO g_pRasGetProjectionInfo;

typedef DWORD (APIENTRY * PRASSETAUTODIALENABLE)( DWORD, BOOL );
extern PRASSETAUTODIALENABLE g_pRasSetAutodialEnable;

typedef DWORD (APIENTRY * PRASSETAUTODIALPARAM)( DWORD, LPVOID, DWORD );
extern PRASSETAUTODIALPARAM g_pRasSetAutodialParam;

typedef DWORD (APIENTRY * PRASGETSUBENTRYHANDLE)( HRASCONN, DWORD, LPHRASCONN );
extern PRASGETSUBENTRYHANDLE g_pRasGetSubEntryHandle;

typedef HPORT (APIENTRY * PRASGETHPORT)( HRASCONN );
extern PRASGETHPORT g_pRasGetHport;

typedef DWORD (APIENTRY * PRASSETCREDENTIALS)( LPTSTR, LPTSTR, LPRASCREDENTIALS, BOOL );
extern PRASSETCREDENTIALS g_pRasSetCredentials;

typedef DWORD (APIENTRY * PRASSETOLDPASSWORD)( HRASCONN, CHAR* );
extern PRASSETOLDPASSWORD g_pRasSetOldPassword;

typedef DWORD (APIENTRY * PRASGETCOUNTRYINFO)( LPRASCTRYINFO, LPDWORD );
extern PRASGETCOUNTRYINFO g_pRasGetCountryInfo;

typedef DWORD (APIENTRY * PRASINVOKEEAPUI)(HRASCONN, DWORD dwSubEntry, LPRASDIALEXTENSIONS, HWND );
extern PRASINVOKEEAPUI g_pRasInvokeEapUI;

typedef DWORD (APIENTRY * PRASSETEAPUSERDATA)( HANDLE, LPCTSTR, LPCTSTR, LPBYTE, LPDWORD );
extern PRASSETEAPUSERDATA g_pRasSetEapUserData;

typedef DWORD (APIENTRY * PRASGETENTRYPROPERTIES) (LPCTSTR, LPCTSTR, LPRASENTRY, LPDWORD, LPBYTE, LPDWORD);
extern PRASGETENTRYPROPERTIES g_pRasGetEntryProperties;

typedef DWORD (APIENTRY * PRASVALIDATEENTRYNAME) (LPCWSTR, LPCWSTR);
extern PRASVALIDATEENTRYNAME g_pRasValidateEntryName;


/* RASDLG.DLL entry points
*/
#ifndef RASMERGE
extern HINSTANCE g_hRasdlgDll;
#endif

typedef DWORD (APIENTRY * PRASPHONEBOOKDLG)( LPTSTR, LPTSTR, LPRASPBDLG );
extern PRASPHONEBOOKDLG g_pRasPhonebookDlg;

typedef DWORD (APIENTRY * PRASENTRYDLG)( LPTSTR, LPTSTR, LPRASENTRYDLG );
extern PRASENTRYDLG g_pRasEntryDlg;

typedef DWORD (APIENTRY * PROUTERENTRYDLG)( LPTSTR, LPTSTR, LPTSTR, LPRASENTRYDLG );
extern PROUTERENTRYDLG g_pRouterEntryDlg;

typedef DWORD (APIENTRY * PRASDIALDLG)( LPTSTR, LPTSTR, LPTSTR, LPRASDIALDLG );
extern PRASDIALDLG g_pRasDialDlg;

typedef DWORD (APIENTRY * PRASMONITORDLG)( LPTSTR, LPRASMONITORDLG );
extern PRASMONITORDLG g_pRasMonitorDlg;


/* RASMAN.DLL entry points
*/
#ifndef RASMERGE
extern HINSTANCE g_hRasmanDll;
#endif

typedef DWORD (APIENTRY * PRASPORTCLEARSTATISTICS)( HANDLE, HPORT );
extern PRASPORTCLEARSTATISTICS g_pRasPortClearStatistics;

typedef DWORD (APIENTRY * PRASBUNDLECLEARSTATISTICS)( HANDLE, HPORT );
extern PRASBUNDLECLEARSTATISTICS g_pRasBundleClearStatistics;

typedef DWORD (APIENTRY * PRASBUNDLECLEARSTATISTICSEX)( HANDLE, HCONN );
extern PRASBUNDLECLEARSTATISTICSEX g_pRasBundleClearStatisticsEx;

typedef DWORD (APIENTRY * PRASDEVICEENUM)( HANDLE, PCHAR, PBYTE, PDWORD, PDWORD );
extern PRASDEVICEENUM g_pRasDeviceEnum;

typedef DWORD (APIENTRY * PRASDEVICEGETINFO)( HANDLE, HPORT, PCHAR, PCHAR, PBYTE, PDWORD );
extern PRASDEVICEGETINFO g_pRasDeviceGetInfo;

typedef DWORD (APIENTRY * PRASFREEBUFFER)( PBYTE );
extern PRASFREEBUFFER g_pRasFreeBuffer;

typedef DWORD (APIENTRY * PRASGETBUFFER)( PBYTE*, PDWORD );
extern PRASGETBUFFER g_pRasGetBuffer;

typedef DWORD (APIENTRY * PRASPORTGETFRAMINGEX)( HANDLE, HPORT, RAS_FRAMING_INFO* );
extern PRASPORTGETFRAMINGEX g_pRasPortGetFramingEx;

typedef DWORD (APIENTRY * PRASGETINFO)( HANDLE, HPORT, RASMAN_INFO* );
extern PRASGETINFO g_pRasGetInfo;

typedef DWORD (APIENTRY * PRASGETNDISWANDRIVERCAPS)( HANDLE, RAS_NDISWAN_DRIVER_INFO* );
extern PRASGETNDISWANDRIVERCAPS g_pRasGetNdiswanDriverCaps;

typedef DWORD (APIENTRY * PRASINITIALIZE)();
extern PRASINITIALIZE g_pRasInitialize;

typedef DWORD (APIENTRY * PRASINITIALIZENOWAIT)();
extern PRASINITIALIZE g_pRasInitializeNoWait;

typedef DWORD (APIENTRY * PRASPORTCANCELRECEIVE)( HPORT );
extern PRASPORTCANCELRECEIVE g_pRasPortCancelReceive;

typedef DWORD (APIENTRY * PRASPORTENUM)( HANDLE, PBYTE, PDWORD, PDWORD );
extern PRASPORTENUM g_pRasPortEnum;

typedef DWORD (APIENTRY * PRASPORTGETINFO)( HANDLE, HPORT, PBYTE, PDWORD );
extern PRASPORTGETINFO g_pRasPortGetInfo;

typedef DWORD (APIENTRY * PRASPORTGETSTATISTICS)( HANDLE, HPORT, PBYTE, PDWORD );
extern PRASPORTGETSTATISTICS g_pRasPortGetStatistics;

typedef DWORD (APIENTRY * PRASBUNDLEGETSTATISTICS)( HANDLE, HPORT, PBYTE, PDWORD );
extern PRASBUNDLEGETSTATISTICS g_pRasBundleGetStatistics;

typedef DWORD (APIENTRY * PRASPORTGETSTATISTICSEX)( HANDLE, HPORT, PBYTE, PDWORD );
extern PRASPORTGETSTATISTICSEX g_pRasPortGetStatisticsEx;

typedef DWORD (APIENTRY * PRASBUNDLEGETSTATISTICSEX)(HANDLE, HPORT, PBYTE, PDWORD);
extern PRASBUNDLEGETSTATISTICSEX g_pRasBundleGetStatisticsEx;

typedef DWORD (APIENTRY * PRASPORTRECEIVE)( HPORT, PBYTE, PDWORD, DWORD, HANDLE );
extern PRASPORTRECEIVE g_pRasPortReceive;

typedef DWORD (APIENTRY * PRASPORTRECEIVEEX ) ( HPORT, PBYTE, PDWORD );
extern PRASPORTRECEIVEEX g_pRasPortReceiveEx;

typedef DWORD (APIENTRY * PRASPORTSEND)( HPORT, PBYTE, DWORD );
extern PRASPORTSEND g_pRasPortSend;

typedef DWORD (APIENTRY * PRASPORTGETBUNDLE)(HANDLE,  HPORT, HBUNDLE* );
extern PRASPORTGETBUNDLE g_pRasPortGetBundle;

typedef DWORD (APIENTRY * PRASGETDEVCONFIG)( HANDLE, HPORT, PCHAR, PBYTE, DWORD* );
extern PRASGETDEVCONFIG g_pRasGetDevConfig;

typedef DWORD (APIENTRY * PRASSETDEVCONFIG)(HPORT, PCHAR, PBYTE, DWORD );
extern PRASSETDEVCONFIG g_pRasSetDevConfig;

typedef DWORD (APIENTRY * PRASPORTOPEN)(PCHAR, HPORT*, HANDLE);
extern PRASPORTOPEN g_pRasPortOpen;

typedef DWORD (APIENTRY * PRASPORTREGISTERSLIP)(HPORT, DWORD, DWORD, BOOL,
                                                WCHAR*, WCHAR*, WCHAR*, WCHAR*);
extern PRASPORTREGISTERSLIP g_pRasPortRegisterSlip;

typedef DWORD (APIENTRY * PRASALLOCATEROUTE)(HPORT, RAS_PROTOCOLTYPE, BOOL,
                                             RASMAN_ROUTEINFO*);
extern PRASALLOCATEROUTE g_pRasAllocateRoute;

typedef DWORD (APIENTRY * PRASACTIVATEROUTE)(HPORT, RAS_PROTOCOLTYPE,
                                            RASMAN_ROUTEINFO*, PROTOCOL_CONFIG_INFO*);
extern PRASACTIVATEROUTE g_pRasActivateRoute;

typedef DWORD (APIENTRY * PRASACTIVATEROUTEEX)(HPORT, RAS_PROTOCOLTYPE, DWORD,
                                               RASMAN_ROUTEINFO*, PROTOCOL_CONFIG_INFO*);
extern PRASACTIVATEROUTEEX g_pRasActivateRouteEx;

typedef DWORD (APIENTRY * PRASDEVICESETINFO)(HPORT, PCHAR, PCHAR, RASMAN_DEVICEINFO*);
extern PRASDEVICESETINFO g_pRasDeviceSetInfo;

typedef DWORD (APIENTRY * PRASDEVICECONNECT)(HPORT, PCHAR, PCHAR, DWORD, HANDLE);
extern PRASDEVICECONNECT g_pRasDeviceConnect;

typedef DWORD (APIENTRY * PRASPORTSETINFO)(HPORT, RASMAN_PORTINFO*);
extern PRASPORTSETINFO g_pRasPortSetInfo;

typedef DWORD (APIENTRY * PRASPORTCLOSE)(HPORT);
extern PRASPORTCLOSE g_pRasPortClose;

typedef DWORD (APIENTRY * PRASPORTLISTEN)(HPORT, DWORD, HANDLE);
extern PRASPORTLISTEN g_pRasPortListen;

typedef DWORD (APIENTRY * PRASPORTCONNECTCOMPLETE)(HPORT);
extern PRASPORTCONNECTCOMPLETE g_pRasPortConnectComplete;

typedef DWORD (APIENTRY * PRASPORTDISCONNECT)(HPORT, HANDLE);
extern PRASPORTDISCONNECT g_pRasPortDisconnect;

typedef DWORD (APIENTRY * PRASREQUESTNOTIFICATION)(HPORT, HANDLE);
extern PRASREQUESTNOTIFICATION g_pRasRequestNotification;

typedef DWORD (APIENTRY * PRASPORTENUMPROTOCOLS)(HANDLE, HPORT, RAS_PROTOCOLS*, PDWORD);
extern PRASPORTENUMPROTOCOLS g_pRasPortEnumProtocols;

typedef DWORD (APIENTRY * PRASPORTSETFRAMING)(HPORT, RAS_FRAMING,
                                             RASMAN_PPPFEATURES*, RASMAN_PPPFEATURES*);
extern PRASPORTSETFRAMING g_pRasPortSetFraming;

typedef DWORD (APIENTRY * PRASPORTSETFRAMINGEX)(HPORT, RAS_FRAMING_INFO*);
extern PRASPORTSETFRAMINGEX g_pRasPortSetFramingEx;

typedef DWORD (APIENTRY * PRASSETCACHEDCREDENTIALS)(PCHAR, PCHAR, PCHAR);
extern PRASSETCACHEDCREDENTIALS g_pRasSetCachedCredentials;

typedef DWORD (APIENTRY * PRASGETDIALPARAMS)(DWORD, LPDWORD, PRAS_DIALPARAMS);
extern PRASGETDIALPARAMS g_pRasGetDialParams;

typedef DWORD (APIENTRY * PRASSETDIALPARAMS)(DWORD, DWORD, PRAS_DIALPARAMS, BOOL);
extern PRASSETDIALPARAMS g_pRasSetDialParams;

typedef DWORD (APIENTRY * PRASCREATECONNECTION) ( HCONN *, DWORD, DWORD *, DWORD *,
                                                  DWORD, GUID *, CHAR *, CHAR *,CHAR *, 
                                                  CHAR *);
extern PRASCREATECONNECTION g_pRasCreateConnection;

typedef DWORD (APIENTRY * PRASDESTROYCONNECTION)(HCONN);
extern PRASDESTROYCONNECTION g_pRasDestroyConnection;

typedef DWORD (APIENTRY * PRASCONNECTIONENUM)(HANDLE, HCONN*, LPDWORD, LPDWORD);
extern PRASCONNECTIONENUM g_pRasConnectionEnum;

typedef DWORD (APIENTRY * PRASADDCONNECTIONPORT)(HCONN, HPORT, DWORD);
extern PRASADDCONNECTIONPORT g_pRasAddConnectionPort;

typedef DWORD (APIENTRY * PRASENUMCONNECTIONPORTS)(HANDLE, HCONN, RASMAN_PORT*,
                                                   LPDWORD, LPDWORD);
extern PRASENUMCONNECTIONPORTS g_pRasEnumConnectionPorts;

typedef DWORD (APIENTRY * PRASGETCONNECTIONPARAMS)(HCONN, PRAS_CONNECTIONPARAMS);
extern PRASGETCONNECTIONPARAMS g_pRasGetConnectionParams;

typedef DWORD (APIENTRY * PRASSETCONNECTIONPARAMS)(HCONN, PRAS_CONNECTIONPARAMS);
extern PRASSETCONNECTIONPARAMS g_pRasSetConnectionParams;

typedef DWORD (APIENTRY * PRASGETCONNECTIONUSERDATA)(HCONN, DWORD, PBYTE, LPDWORD);
extern PRASGETCONNECTIONUSERDATA g_pRasGetConnectionUserData;

typedef DWORD (APIENTRY * PRASSETCONNECTIONUSERDATA)(HCONN, DWORD, PBYTE, DWORD);
extern PRASSETCONNECTIONUSERDATA g_pRasSetConnectionUserData;

typedef DWORD (APIENTRY * PRASGETPORTUSERDATA)(HCONN, DWORD, PBYTE, LPDWORD);
extern PRASGETPORTUSERDATA g_pRasGetPortUserData;

typedef DWORD (APIENTRY * PRASSETPORTUSERDATA)(HCONN, DWORD, PBYTE, DWORD);
extern PRASSETPORTUSERDATA g_pRasSetPortUserData;

typedef DWORD (APIENTRY * PRASADDNOTIFICATION)(HCONN, HANDLE, DWORD);
extern PRASADDNOTIFICATION g_pRasAddNotification;

typedef DWORD (APIENTRY * PRASSIGNALNEWCONNECTION)(HCONN);
extern PRASSIGNALNEWCONNECTION g_pRasSignalNewConnection;

typedef DWORD (APIENTRY * PRASPPPSTOP)(HPORT);
extern PRASPPPSTOP g_pRasPppStop;

typedef DWORD (APIENTRY * PRASPPPCALLBACK)(HPORT, CHAR*);
extern PRASPPPCALLBACK g_pRasPppCallback;

typedef DWORD (APIENTRY * PRASPPPCHANGEPASSWORD)(HPORT, CHAR*, CHAR*, CHAR*);
extern PRASPPPCHANGEPASSWORD g_pRasPppChangePassword;

typedef DWORD (APIENTRY * PRASPPPGETINFO)(HPORT, PPP_MESSAGE*);
extern PRASPPPGETINFO g_pRasPppGetInfo;

typedef DWORD (APIENTRY * PRASPPPRETRY)(HPORT, CHAR*, CHAR*, CHAR*);
extern PRASPPPRETRY g_pRasPppRetry;

typedef DWORD (APIENTRY *PRASPPPSTART)(HPORT, CHAR*, CHAR*, CHAR*, CHAR*, LUID*,
                                       PPP_CONFIG_INFO*, LPVOID, CHAR*,
                                       BOOL, HANDLE, DWORD, BOOL, PPP_BAPPARAMS*,
                                       BOOL, DWORD, DWORD);
extern PRASPPPSTART g_pRasPppStart;

typedef DWORD (APIENTRY * PRASSETIOCOMPLETIONPORT)(HPORT, HANDLE, PRAS_OVERLAPPED,
                                                   PRAS_OVERLAPPED, PRAS_OVERLAPPED,
                                                   PRAS_OVERLAPPED);
extern PRASSETIOCOMPLETIONPORT g_pRasSetIoCompletionPort;

typedef DWORD (APIENTRY * PRASSENDPPPMESSAGETORASMAN) (PPP_MESSAGE *pPppMessage);
extern PRASSENDPPPMESSAGETORASMAN g_pRasSendPppMessageToRasman;

typedef DWORD (APIENTRY * PRASSETRASDIALINFO) (HPORT, CHAR*, CHAR*, CHAR *, DWORD, PBYTE);
extern PRASSETRASDIALINFO g_pRasSetRasdialInfo;

typedef DWORD (APIENTRY * PRASRPCCONNECT ) ( LPCTSTR, HANDLE * );
extern PRASRPCCONNECT g_pRasRpcConnect;

typedef DWORD (APIENTRY * PRASRPCDISCONNECT ) ( HANDLE * );
extern PRASRPCDISCONNECT g_pRasRpcDisconnect;

typedef DWORD (APIENTRY * PRASNUMPORTOPEN ) ();
extern PRASNUMPORTOPEN g_pRasNumPortOpen;

typedef DWORD (APIENTRY *PRASREFCONNECTION ) ( HCONN, BOOL, DWORD * );
extern PRASREFCONNECTION g_pRasRefConnection;

typedef DWORD (APIENTRY *PRASPPPGETEAPINFO) ( HCONN, DWORD, DWORD *, DWORD *,
                                              DWORD *, PBYTE);
extern PRASPPPGETEAPINFO g_pRasPppGetEapInfo;

typedef DWORD( APIENTRY *PRASPPPSETEAPINFO) (HPORT, DWORD, DWORD, PBYTE);
extern PRASPPPSETEAPINFO g_pRasPppSetEapInfo;

typedef DWORD(APIENTRY *PRASFINDPREREQUISITEENTRY) (HCONN, HCONN *);
extern PRASFINDPREREQUISITEENTRY g_pRasFindPrerequisiteEntry;

typedef DWORD(APIENTRY *PRASPORTOPENEX) (CHAR *, DWORD, HPORT *, HANDLE, DWORD);
extern PRASPORTOPENEX g_pRasPortOpenEx;

typedef DWORD(APIENTRY *PRASLINKGETSTATISTICS) (HANDLE, HCONN, DWORD, PBYTE);
extern PRASLINKGETSTATISTICS g_pRasLinkGetStatistics;

typedef DWORD(APIENTRY *PRASCONNECTIONGETSTATISTICS) (HANDLE, HCONN, PBYTE);
extern PRASCONNECTIONGETSTATISTICS g_pRasConnectionGetStatistics;

typedef DWORD(APIENTRY *PRASGETHPORTFROMCONNECTION) (HANDLE, HCONN, HPORT *);
extern PRASGETHPORTFROMCONNECTION g_pRasGetHportFromConnection;

typedef DWORD(APIENTRY *PRASRPCBIND) (LPWSTR, HANDLE *);
extern PRASRPCBIND g_pRasRpcBind;

typedef DWORD(APIENTRY *PRASREFERENCECUSTOMCOUNT) (HCONN ,BOOL, CHAR *, CHAR *, DWORD *);
extern PRASREFERENCECUSTOMCOUNT g_pRasReferenceCustomCount;

typedef DWORD(APIENTRY *PRASGETHCONNFROMENTRY) (HCONN *, CHAR *, CHAR *);
extern PRASGETHCONNFROMENTRY g_pRasGetHConnFromEntry;

typedef DWORD(APIENTRY *PRASGETDEVICENAME) (RASDEVICETYPE, CHAR *);
extern PRASGETDEVICENAME g_pRasGetDeviceName;

typedef DWORD(APIENTRY *PRASENABLEIPSEC) (HPORT, BOOL, BOOL, RAS_L2TP_ENCRYPTION);
extern PRASENABLEIPSEC g_pRasEnableIpSec;

typedef DWORD(APIENTRY *PRASISIPSECENABLED) (HPORT, BOOL *);
extern PRASISIPSECENABLED g_pRasIsIpSecEnabled;

typedef DWORD(APIENTRY *PRASGETEAPUSERINFO) (HANDLE, PBYTE, DWORD *, GUID *, BOOL, DWORD);
extern PRASGETEAPUSERINFO g_pRasGetEapUserInfo;
 
typedef DWORD(APIENTRY *PRASSETEAPUSERINFO) (HANDLE, GUID *, PBYTE, DWORD, BOOL, BOOL, DWORD);
extern PRASSETEAPUSERINFO g_pRasSetEapUserInfo;

typedef DWORD(APIENTRY *PRASSETEAPLOGONINFO) (HPORT, BOOL, RASEAPINFO *);
extern PRASSETEAPLOGONINFO g_pRasSetEapLogonInfo;

typedef DWORD(APIENTRY *PRASSTARTRASAUTOIFREQUIRED) (VOID);
extern PRASSTARTRASAUTOIFREQUIRED g_pRasStartRasAutoIfRequired;

/* MPRAPI.DLL entry points
*/
#ifndef RASMERGE
extern HINSTANCE g_hMpradminDll;
#endif

typedef DWORD (APIENTRY * PMPRADMININTERFACECREATE)(HANDLE,DWORD,LPBYTE,HANDLE*);
extern PMPRADMININTERFACECREATE g_pMprAdminInterfaceCreate;
typedef DWORD (APIENTRY * PMPRADMININTERFACEDELETE)(HANDLE,HANDLE);
extern PMPRADMININTERFACEDELETE g_pMprAdminInterfaceDelete;
typedef DWORD (APIENTRY * PMPRADMININTERFACEGETHANDLE)(HANDLE,LPWSTR,HANDLE*,BOOL);
extern PMPRADMININTERFACEGETHANDLE g_pMprAdminInterfaceGetHandle;
typedef DWORD (APIENTRY * PMPRADMININTERFACEGETCREDENTIALS)(LPWSTR,LPWSTR,LPWSTR,LPWSTR,LPWSTR);
extern PMPRADMININTERFACEGETCREDENTIALS g_pMprAdminInterfaceGetCredentials;
typedef DWORD (APIENTRY * PMPRADMININTERFACESETCREDENTIALS)(LPWSTR,LPWSTR,LPWSTR,LPWSTR,LPWSTR);
extern PMPRADMININTERFACESETCREDENTIALS g_pMprAdminInterfaceSetCredentials;
typedef DWORD (APIENTRY * PMPRADMININTERFACETRANSPORTADD)(HANDLE,HANDLE,DWORD,LPBYTE,DWORD);
extern PMPRADMININTERFACETRANSPORTADD g_pMprAdminInterfaceTransportAdd;
typedef DWORD (APIENTRY * PMPRADMININTERFACETRANSPORTSETINFO)(HANDLE,HANDLE,DWORD,LPBYTE,DWORD);
extern PMPRADMININTERFACETRANSPORTSETINFO g_pMprAdminInterfaceTransportSetInfo;
typedef DWORD (APIENTRY * PMPRADMINSERVERDISCONNECT)(HANDLE);
extern PMPRADMINSERVERDISCONNECT g_pMprAdminServerDisconnect;
typedef DWORD (APIENTRY * PMPRADMINSERVERCONNECT)(LPWSTR,HANDLE*);
extern PMPRADMINSERVERCONNECT g_pMprAdminServerConnect;
typedef DWORD (APIENTRY * PMPRADMINTRANSPORTSETINFO)(HANDLE,DWORD,LPBYTE,DWORD,LPBYTE,DWORD);
extern PMPRADMINTRANSPORTSETINFO g_pMprAdminTransportSetInfo;
typedef DWORD (APIENTRY * PRASADMINSERVERCONNECT)(LPWSTR, HANDLE*);
extern PRASADMINSERVERCONNECT g_pRasAdminServerConnect;
typedef DWORD (APIENTRY * PRASADMINSERVERDISCONNECT)(HANDLE);
extern PRASADMINSERVERDISCONNECT g_pRasAdminServerDisconnect;
typedef DWORD (APIENTRY * PRASADMINBUFFERFREE)(LPVOID);
extern PRASADMINBUFFERFREE g_pRasAdminBufferFree;
typedef DWORD (APIENTRY * PRASADMINCONNECTIONENUM)(HANDLE, DWORD, LPBYTE*, DWORD, LPDWORD, LPDWORD, LPDWORD);
extern PRASADMINCONNECTIONENUM g_pRasAdminConnectionEnum;
typedef DWORD (APIENTRY * PRASADMINCONNECTIONGETINFO)(HANDLE, DWORD, HANDLE, LPBYTE*);
extern PRASADMINCONNECTIONGETINFO g_pRasAdminConnectionGetInfo;
typedef DWORD (APIENTRY * PRASADMINPORTENUM)(HANDLE, DWORD, HANDLE, LPBYTE*, DWORD, LPDWORD, LPDWORD, LPDWORD);
extern PRASADMINPORTENUM g_pRasAdminPortEnum;
typedef DWORD (APIENTRY * PRASADMINPORTGETINFO)(HANDLE, DWORD, HANDLE, LPBYTE*);
extern PRASADMINPORTGETINFO g_pRasAdminPortGetInfo;
typedef DWORD (APIENTRY * PRASADMINPORTDISCONNECT)(HANDLE, HANDLE);
extern PRASADMINPORTDISCONNECT g_pRasAdminPortDisconnect;
typedef DWORD (APIENTRY * PRASADMINUSERSETINFO)(LPCWSTR,LPCWSTR,DWORD,LPBYTE);
extern PRASADMINUSERSETINFO g_pRasAdminUserSetInfo;
typedef DWORD (APIENTRY * PMPRADMINUSERSERVERCONNECT)(PWCHAR, BOOL, PHANDLE);
extern PMPRADMINUSERSERVERCONNECT g_pMprAdminUserServerConnect;
typedef DWORD (APIENTRY * PMPRADMINUSERSERVERDISCONNECT)(HANDLE);
extern PMPRADMINUSERSERVERDISCONNECT g_pMprAdminUserServerDisconnect;
typedef DWORD (APIENTRY * PMPRADMINUSEROPEN)(HANDLE, PWCHAR, PHANDLE);
extern PMPRADMINUSEROPEN g_pMprAdminUserOpen;
typedef DWORD (APIENTRY * PMPRADMINUSERCLOSE)(HANDLE);
extern PMPRADMINUSERCLOSE g_pMprAdminUserClose;
typedef DWORD (APIENTRY * PMPRADMINUSERWRITE)(HANDLE, DWORD, LPBYTE);
extern PMPRADMINUSERWRITE g_pMprAdminUserWrite;
typedef DWORD (APIENTRY * PMPRCONFIGBUFFERFREE)(LPVOID);
extern PMPRCONFIGBUFFERFREE g_pMprConfigBufferFree;
typedef DWORD (APIENTRY * PMPRCONFIGSERVERCONNECT)(LPWSTR,HANDLE*);
extern PMPRCONFIGSERVERCONNECT g_pMprConfigServerConnect;
typedef VOID (APIENTRY * PMPRCONFIGSERVERDISCONNECT)(HANDLE);
extern PMPRCONFIGSERVERDISCONNECT g_pMprConfigServerDisconnect;
typedef DWORD (APIENTRY * PMPRCONFIGTRANSPORTGETINFO)(HANDLE,HANDLE,LPBYTE*,LPDWORD,LPBYTE*,LPDWORD,LPWSTR*);
extern PMPRCONFIGTRANSPORTGETINFO g_pMprConfigTransportGetInfo;
typedef DWORD (APIENTRY * PMPRCONFIGTRANSPORTSETINFO)(HANDLE,HANDLE,LPBYTE,DWORD,LPBYTE,DWORD,LPWSTR);
extern PMPRCONFIGTRANSPORTSETINFO g_pMprConfigTransportSetInfo;
typedef DWORD (APIENTRY * PMPRCONFIGTRANSPORTGETHANDLE)(HANDLE,DWORD,HANDLE*);
extern PMPRCONFIGTRANSPORTGETHANDLE g_pMprConfigTransportGetHandle;
typedef DWORD (APIENTRY * PMPRCONFIGINTERFACECREATE)(HANDLE,DWORD,LPBYTE,HANDLE*);
extern PMPRCONFIGINTERFACECREATE g_pMprConfigInterfaceCreate;
typedef DWORD (APIENTRY * PMPRCONFIGINTERFACEDELETE)(HANDLE,HANDLE);
extern PMPRCONFIGINTERFACEDELETE g_pMprConfigInterfaceDelete;
typedef DWORD (APIENTRY * PMPRCONFIGINTERFACEGETHANDLE)(HANDLE,LPWSTR,HANDLE*);
extern PMPRCONFIGINTERFACEGETHANDLE g_pMprConfigInterfaceGetHandle;
typedef DWORD (APIENTRY * PMPRCONFIGINTERFACEENUM)(HANDLE,DWORD,LPBYTE*,DWORD,LPDWORD,LPDWORD,LPDWORD);
extern PMPRCONFIGINTERFACEENUM g_pMprConfigInterfaceEnum;
typedef DWORD (APIENTRY * PMPRCONFIGINTERFACETRANSPORTADD)(HANDLE,HANDLE,DWORD,LPWSTR,LPBYTE,DWORD,HANDLE*);
extern PMPRCONFIGINTERFACETRANSPORTADD g_pMprConfigInterfaceTransportAdd;
typedef DWORD (APIENTRY * PMPRCONFIGINTERFACETRANSPORTGETINFO)(HANDLE,HANDLE,HANDLE,LPBYTE*,LPDWORD);
extern PMPRCONFIGINTERFACETRANSPORTGETINFO g_pMprConfigInterfaceTransportGetInfo;
typedef DWORD (APIENTRY * PMPRCONFIGINTERFACETRANSPORTSETINFO)(HANDLE,HANDLE,HANDLE,LPBYTE,DWORD);
extern PMPRCONFIGINTERFACETRANSPORTSETINFO g_pMprConfigInterfaceTransportSetInfo;
typedef DWORD (APIENTRY * PMPRCONFIGINTERFACETRANSPORTGETHANDLE)(HANDLE,HANDLE,DWORD,HANDLE*);
extern PMPRCONFIGINTERFACETRANSPORTGETHANDLE g_pMprConfigInterfaceTransportGetHandle;
typedef DWORD (APIENTRY * PMPRINFOCREATE)(DWORD,LPVOID*);
extern PMPRINFOCREATE g_pMprInfoCreate;
typedef DWORD (APIENTRY * PMPRINFODELETE)(LPVOID);
extern PMPRINFODELETE g_pMprInfoDelete;
typedef DWORD (APIENTRY * PMPRINFODUPLICATE)(LPVOID,LPVOID*);
extern PMPRINFODUPLICATE g_pMprInfoDuplicate;
typedef DWORD (APIENTRY * PMPRINFOBLOCKADD)(LPVOID,DWORD,DWORD,DWORD,LPBYTE,LPVOID*);
extern PMPRINFOBLOCKADD g_pMprInfoBlockAdd;
typedef DWORD (APIENTRY * PMPRINFOBLOCKREMOVE)(LPVOID,DWORD,LPVOID*);
extern PMPRINFOBLOCKREMOVE g_pMprInfoBlockRemove;
typedef DWORD (APIENTRY * PMPRINFOBLOCKSET)(LPVOID,DWORD,DWORD,DWORD,LPBYTE,LPVOID*);
extern PMPRINFOBLOCKSET g_pMprInfoBlockSet;
typedef DWORD (APIENTRY * PMPRINFOBLOCKFIND)(LPVOID,DWORD,LPDWORD,LPDWORD,LPBYTE*);
extern PMPRINFOBLOCKFIND g_pMprInfoBlockFind;

//
// Miscellaneous entry points.
//
// These are included for consistency because they
// are remotable by the RAS RPC interface.
//
typedef DWORD (*PGETINSTALLEDPROTOCOLS)();
extern PGETINSTALLEDPROTOCOLS g_pGetInstalledProtocols;

typedef DWORD (*PGETINSTALLEDPROTOCOLSEX)(HANDLE, BOOL, BOOL, BOOL);
extern PGETINSTALLEDPROTOCOLSEX g_pGetInstalledProtocolsEx;

typedef DWORD (*PGETUSERPREFERENCES)(HANDLE, PBUSER*, DWORD);
extern PGETUSERPREFERENCES g_pGetUserPreferences;

typedef DWORD (*PSETUSERPREFERENCES)(HANDLE, PBUSER*, DWORD);
extern PSETUSERPREFERENCES g_pSetUserPreferences;

typedef DWORD (WINAPI *PGETSYSTEMDIRECTORY)(HANDLE, LPTSTR, UINT);
extern PGETSYSTEMDIRECTORY g_pGetSystemDirectory;

/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

BOOL
IsRasmanServiceRunning(
    void );

DWORD
LoadMpradminDll(
    void );

DWORD
LoadRasapi32Dll(
    void );

DWORD
LoadRasdlgDll(
    void );

DWORD
LoadRasmanDll(
    void );

#if 0

DWORD
LoadRasRpcDll(
    LPTSTR  lpszServer
    );

#endif    

BOOL
Rasapi32DllLoaded(
    void
    );

BOOL
RasRpcDllLoaded(
    void
    );

LPTSTR
RemoteGetServerName(
        HANDLE hConnection
        );

DWORD
RemoteGetServerVersion(
    HANDLE hConnection
    );

BOOL
IsRasRemoteConnection(
    HANDLE hConnection
    );

VOID
UnloadMpradminDll(
    void );

VOID
UnloadRasapi32Dll(
    void );

VOID
UnloadRasdlgDll(
    void );

VOID
UnloadRasmanDll(
    void );

DWORD
UnloadRasRpcDll(
    void );

DWORD
InitializeConnection(
    LPTSTR lpszServer,
    HANDLE *pHConnection);

VOID
UninitializeConnection(
    HANDLE hConnection);


DWORD
RemoteGetInstalledProtocols(
    HANDLE hConnection
    );

DWORD
RemoteGetInstalledProtocolsEx(
    HANDLE hConnection,
    BOOL fRouter,
    BOOL fRasCli,
    BOOL fRasSrv );

UINT WINAPI
RemoteGetSystemDirectory(
    HANDLE hConnection,
    LPTSTR lpBuffer,
    UINT uSize );

DWORD
RemoteGetUserPreferences(
    HANDLE hConnection,
    OUT PBUSER* pPbuser,
    IN DWORD dwMode );

DWORD APIENTRY
RemoteRasDeleteEntry(
    HANDLE hConnection,
    LPTSTR lpszPhonebook,
    LPTSTR lpszEntry );


DWORD APIENTRY
RemoteRasDeviceEnum(
    HANDLE hConnection,
    PCHAR pszDeviceType,
    PBYTE lpDevices,
    PDWORD pwcbDevices,
    PDWORD pwcDevices );

DWORD APIENTRY
RemoteRasEnumConnections(
    HANDLE hConnection,
    LPRASCONN lpRasConn,
    LPDWORD lpdwcbRasConn,
    LPDWORD lpdwcRasConn );

DWORD APIENTRY
RemoteRasGetCountryInfo(
    HANDLE hConnection,
    LPRASCTRYINFO lpRasCountryInfo,
    LPDWORD lpdwcbRasCountryInfo );


DWORD APIENTRY
RemoteRasGetDevConfig(
    HANDLE hConnection,
    HPORT hport,
    PCHAR pszDeviceType,
    PBYTE lpConfig,
    LPDWORD lpcbConfig );

DWORD APIENTRY
RemoteRasGetErrorString(
    HANDLE hConnection,
    UINT uErrorValue,
    LPTSTR lpszBuf,
    DWORD cbBuf );


DWORD APIENTRY
RemoteRasPortEnum(
    HANDLE hConnection,
    PBYTE lpPorts,
    PDWORD pdwcbPorts,
    PDWORD pdwcPorts );

DWORD
RemoteSetUserPreferences(
    HANDLE hConnection,
    OUT PBUSER* pPbuser,
    IN DWORD dwMode );

DWORD APIENTRY
RemoteRasPortGetInfo(
    HANDLE hConnection,
        HPORT porthandle,
        PBYTE buffer,
        PDWORD pSize );

UINT WINAPI
RasGetSystemDirectory(
    HANDLE hConnection,
    LPTSTR lpBuffer,
    UINT uSize
    );

#endif // _LOADDLLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\imported\net\rras\ras\ui\inc\pbk.h ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// pbk.h
// Remote Access phonebook file (.PBK) library
// Public header
//
// 06/20/95 Steve Cobb


#ifndef _PBK_H_
#define _PBK_H_


#include <windows.h>  // Win32 core
#include <nouiutil.h> // No-HWNDs utility library
#include <ras.h>      // Win32 RAS
#include <raserror.h> // Win32 RAS error codes
#include <rasfile.h>  // RAS configuration file library
#include <rasman.h>   // RAS Manager library
#include <rpc.h>      // UUID support
#include <rasapip.h>

//----------------------------------------------------------------------------
// Constants
//----------------------------------------------------------------------------

#define GLOBALSECTIONNAME    "."
#define GLOBALSECTIONNAMENEW ".GlobalSection"
#define PREFIXSECTIONNAME    ".Prefix"
#define SUFFIXSECTIONNAME    ".Suffix"

#define GROUPID_Media          "MEDIA="
#define GROUPKEY_Media         "MEDIA"
#define GROUPID_Device         "DEVICE="
#define GROUPKEY_Device        "DEVICE"
#define GROUPID_NetComponents  "NETCOMPONENTS="
#define GROUPKEY_NetComponents "NETCOMPONENTS"

// Pbport flags
//
#define PBP_F_PptpDevice    0x00000001
#define PBP_F_L2tpDevice    0x00000002
#define PBP_F_NullModem     0x00000004
#define PBP_F_BogusDevice   0x00000008      // pmay: 233287

// ReadPhonebookFile flags
//
#define RPBF_ReadOnly    0x00000001
#define RPBF_HeadersOnly 0x00000002
#define RPBF_NoList      0x00000004
#define RPBF_NoCreate    0x00000008
#define RPBF_Router      0x00000010
#define RPBF_NoUser      0x00000020
#define RPBF_HeaderType  0x00000040

// Base protocol definitions (see dwBaseProtocol).
//
#define BP_Ppp      1
#define BP_Slip     2
#define BP_Ras      3

#ifdef AMB

// Authentication strategy definitions (see dwAuthentication).
//
#define AS_Default    -1
#define AS_PppThenAmb 0
#define AS_AmbThenPpp 1
#define AS_PppOnly    2
#define AS_AmbOnly    3

#endif

// Net protocol bit definitions (see dwfExcludedProtocols)
//
// (The NP_* definitions have moved to nouiutil.h with the
//  GetInstalledProtocols routine)

// IP address source definitions (see dwIpAddressSource)
//
#define ASRC_ServerAssigned  1 // For router means "the ones in NCPA"
#define ASRC_RequireSpecific 2
#define ASRC_None            3 // Router only

// Security restrictions on authentication (see dwAuthRestrictions)
//
// Note: AR_AuthTerminal is defunct and is not written to the phonebook by the
//       new library.  It is, however, read and translated into AR_AuthAny,
//       fAutoLogon=0, and an after dialing terminal.
//
// Note: The AR_AuthXXX ordinals are replaced with AR_F_AuthXXX flags in NT5
//       to support the fact that these flags are not mutually exclusive.
//       You'll know if you need to upgrade the dwAuthRestrictions variable
//       because old phone books have this value set to 0 or have some of the
//       bottom 3 bits set.
//
// Note: The AR_F_AuthCustom bit is used a little differently.  It indicates
//       that the settings are made in "advanced" mode rather than "typical"
//       mode.  In "typical" mode the bits MUST correspond to one of the
//       AR_F_TypicalXxx sets.
//
// Note: The AR_F_AuthEAP bit is mutually exclusive of all other bits, except
//       the AR_F_AuthCustom bit.  When AR_F_AuthEap is specified without the
//       AR_F_AuthCustom bit EAP_TLS_PROTOCOL should be assumed.
//
// Note: The AR_F_AuthW95MSCHAP flag will not be set in the UI unless
//       AR_F_AuthMSCHAP is set.  This is a usability decision to steer user
//       away from misinterpreting the meaning of the W95 bit.
//
// The old scalar values (which should no eliminated from all non-PBK-upgrade
// code).
//
#define AR_AuthAny         0  // Upgrade to AR_F_TypicalUnsecure
#define AR_AuthTerminal    1  // Eliminate during upgrade
#define AR_AuthEncrypted   2  // Upgrade to AR_F_TypicalSecure
#define AR_AuthMsEncrypted 3  // Upgrade to AR_F_AuthMSCHAP
#define AR_AuthCustom      4  // Upgrade ORs in AR_F_AuthEAP

// The new bitmask style flags.
//
#define AR_F_AuthPAP       0x00000008
#define AR_F_AuthSPAP      0x00000010
#define AR_F_AuthMD5CHAP   0x00000020
#define AR_F_AuthMSCHAP    0x00000040
#define AR_F_AuthEAP       0x00000080  // See note above
#define AR_F_AuthCustom    0x00000100  // See note above
#define AR_F_AuthMSCHAP2   0x00000200
#define AR_F_AuthW95MSCHAP 0x00000400  // See note above

#define AR_F_AuthAnyMSCHAP (AR_F_AuthMSCHAP | AR_F_AuthW95MSCHAP | AR_F_AuthMSCHAP2)
#define AR_F_AuthNoMPPE    (AR_F_AuthPAP | AR_F_AuthSPAP | AR_F_AuthMD5CHAP)

// "Typical" authentication setting masks.  See 'dwAuthRestrictions'.
//
#define AR_F_TypicalUnsecure   (AR_F_AuthPAP | AR_F_AuthSPAP | AR_F_AuthMD5CHAP | AR_F_AuthMSCHAP | AR_F_AuthMSCHAP2)
#define AR_F_TypicalSecure     (AR_F_AuthMD5CHAP | AR_F_AuthMSCHAP | AR_F_AuthMSCHAP2)
#define AR_F_TypicalCardOrCert (AR_F_AuthEAP)

// "Typical" authentication setting constants.  See 'dwTypicalAuth'.
//
#define TA_Unsecure   1
#define TA_Secure     2
#define TA_CardOrCert 3

// Script mode (see dwScriptMode)
//
#define SM_None               0
#define SM_Terminal           1
#define SM_ScriptWithTerminal 2
#define SM_ScriptOnly         3

// Miscellaneous "no value" constants.
//
#define XN_None  0   // No X25 network
#define CPW_None -1  // No cached password

// Description field.  Move to ras.h if/when supported by
// RasGet/SetEntryProperties API.
//
#define RAS_MaxDescription 200

// 'OverridePref' bits.  Set indicates the corresponding value read from the
// phonebook should be used.  Clear indicates the global user preference
// should be used.
//
#define RASOR_RedialAttempts          0x00000001 // Always set in NT5
#define RASOR_RedialSeconds           0x00000002 // Always set in NT5
#define RASOR_IdleDisconnectSeconds   0x00000004 // Always set in NT5
#define RASOR_RedialOnLinkFailure     0x00000008 // Always set in NT5
#define RASOR_PopupOnTopWhenRedialing 0x00000010
#define RASOR_CallbackMode            0x00000020

// 'DwDataEncryption' codes.  These are now bitmask-ish for the convenience of
// the UI in building capability masks, though more than one bit will never be
// set in 'dwDataEncryption'.
//
#define DE_None          0x00000000 // Do not encrypt
#define DE_IfPossible    0x00000008 // Request encryption but none OK
#define DE_Require       0x00000100 // Require encryption of any strength
#define DE_RequireMax    0x00000200 // Require maximum strength encryption

// The following bit values are now defunct and are converted during phonebook
// upgrade to one of the above set.  References should be eliminated from
// non-PBK code.
//
#define DE_Mppe40bit    0x00000001 // Old DE_Weak. Setting for "Always encrypt data"
#define DE_Mppe128bit   0x00000002 // Old De_Strong. Setting for "Always encrypt data"
#define DE_IpsecDefault 0x00000004 // Setting for "Always encrypt data" for l2tp
#define DE_VpnAlways    0x00000010 // Setting for vpn conn to "Always encrypt data"
#define DE_PhysAlways   (DE_Mppe40bit | DE_Mppe128bit)

// 'dwDnsFlags' settings
//
// Used to determine the dns suffix registration behavior for an entry
//
// When 'dwDnsFlags' is 0, it means 'do not register'
//
#define DNS_RegPrimary         0x1     // register w/ primary domain suffix
#define DNS_RegPerConnection   0x2     // register w/ per-connection suffix
#define DNS_RegDhcpInform      0x4     // register w/ dhcp informed suffix
#define DNS_RegDefault         (DNS_RegPrimary)

//-----------------------------------------------------------------------------
// Data types
//-----------------------------------------------------------------------------

// Provides shorthand to identify devices without re-parsing RAS Manager
// strings.  "Other" is anything not recognized as another specific type.
//
// Note: This datatype is stored in the registry preferences so the values
//       must not change over time.  For this reason, I have hard-coded the
//       value of each enumberated type.
//
typedef enum
_PBDEVICETYPE
{
    PBDT_None = 0,
    PBDT_Null = 1,
    PBDT_Other = 2,
    PBDT_Modem = 3,
    PBDT_Pad = 4,
    PBDT_Switch = 5,
    PBDT_Isdn = 6,
    PBDT_X25 = 7,
    PBDT_ComPort = 8,           // added for dcc wizard (nt5)
    PBDT_Irda = 10,             // added for nt5
    PBDT_Vpn = 11,
    PBDT_Serial = 12,
    PBDT_Atm = 13,
    PBDT_Parallel = 14,
    PBDT_Sonet = 15,
    PBDT_Sw56 = 16,
    PBDT_FrameRelay = 17
}
PBDEVICETYPE;


// RAS port information read from RASMAN.
//
// Each port (and link) is uniquely identified by port name.  If it were only
// that simple...
//
// In the old RAS model, the port name was the unique identifier that was
// presented to the user, and the user can have two same-type devices on two
// different ports.
//
// In TAPI/Unimodem, the "friendly" device name is the unique identifier
// that's presented to the user and the corresponding port is a property of
// the device.  If the port is changed and you dial it still finds the device
// you originally selected.  If you swap two devices on two ports it uses the
// one with the matching unique device name.  NT5 will follow this model.
//
typedef struct
_PBPORT
{
    // The port name is always unique, if configured.  Unconfigured port names
    // might not be unique.  This is never NULL.
    //
    TCHAR* pszPort;

    // Indicates the port is actually configured and not a remnant of an old
    // configuration read from the phonebook.
    //
    BOOL fConfigured;

    // The device name is the one from RASMAN when 'fConfigured' or the one
    // from the phonebook if not.  May be NULL with unconfigured ports as it
    // was not stored in old phonebooks.
    //
    TCHAR* pszDevice;

    // The media as it appears in the MEDIA= lines in the phonebook.  This is
    // usually but not always (for obscure historical reasons) the same as the
    // RASMAN media.  See PbMedia.
    //
    TCHAR* pszMedia;

    // Shorthand device type code derived from the RASMAN device type string.
    //
    PBDEVICETYPE pbdevicetype;

    // RASET_* entry type code of the link.  This is provided for the
    // convenience of the UI during link configuration.
    //
    DWORD dwType;

    // PBP_F_* flags that yield additional information concerning this port
    // that may be of use in rendering UI.
    DWORD dwFlags;

    // These are default settings read from RASMAN and are valid for modems
    // only.  See AppendPbportToList.
    //
    DWORD dwBpsDefault;
    BOOL fHwFlowDefault;
    BOOL fEcDefault;
    BOOL fEccDefault;
    DWORD fSpeakerDefault;
    DWORD dwModemProtDefault;
    DTLLIST* pListProtocols;

    // These are valid only for modems.
    //
    BOOL fScriptBeforeTerminal;
    BOOL fScriptBefore;
    TCHAR* pszScriptBefore;
}
PBPORT;


// Phonebook entry link phone number information.
//
typedef struct
_PBPHONE
{
    TCHAR* pszAreaCode;
    DWORD dwCountryCode;
    DWORD dwCountryID;
    TCHAR* pszPhoneNumber;
    BOOL fUseDialingRules;
    TCHAR* pszComment;
}
PBPHONE;


// Phonebook entry link information.  One per link, multiple per multi-link.
//
typedef struct
_PBLINK
{
    // Information about the port/device to which this link is attached.
    //
    PBPORT pbport;

    // These fields are set for modems only.  See SetDefaultModemSettings.
    //
    DWORD dwBps;
    BOOL fHwFlow;
    BOOL fEc;
    BOOL fEcc;
    DWORD fSpeaker;
    DWORD dwModemProtocol;          // pmay: 228565

    // These fields are set for ISDN only.  'LChannels' and 'fCompression' are
    // not used unless 'fProprietaryIsdn' is set.
    //
    BOOL fProprietaryIsdn;
    LONG lLineType;
    BOOL fFallback;
    BOOL fCompression;
    LONG lChannels;

    // Address and size of opaque device configuration block created/edited by
    // TAPI.  Currently, there are no TAPI devices that provide blob-editing
    // acceptable to RAS so these field are unused.
    //
    BYTE* pTapiBlob;
    DWORD cbTapiBlob;

    // Phone number information for the link.
    //
    // Note: The 'iLastSelectedPhone' field is used only when
    //       'fTryNextAlternateOnFail' is clear.  Otherwise, it is ignored and
    //       assumed 0 (top of list).  See bug 150958.
    //
    DTLLIST* pdtllistPhones;
    DWORD iLastSelectedPhone;
    BOOL fPromoteAlternates;
    BOOL fTryNextAlternateOnFail;

    // Indicates the link is enabled.  All links appearing in the file are
    // enabled.  This is provided for the convenience of the UI during link
    // configuration.
    //
    BOOL fEnabled;
}
PBLINK;


// Phonebook entry information.
//
typedef struct
_PBENTRY
{
    // Arbitrary name of entry and it's RASET_* entry type code.
    //
    TCHAR* pszEntryName;
    DWORD dwType;

    // General page fields.
    //
    DTLLIST* pdtllistLinks;
    BOOL fSharedPhoneNumbers;
    BOOL fShowMonitorIconInTaskBar;
    TCHAR* pszPrerequisiteEntry;
    TCHAR* pszPrerequisitePbk;
    TCHAR* pszPreferredPort;
    TCHAR* pszPreferredDevice;

    // Options page fields.
    //
    // Note: Fields marked (1) are ignored when 'fAutoLogon' is set.  Field
    //       marked (2) *may* be set when 'fPreviewUserPw' is not also set.
    //       In this case it means to include the domain in the authentication
    //       but to to prompt only when the 'fPreviewUserPw' is set.
    //       Otherwise, "save PW" with a domain does not include the domain
    //       (MarkL problem) which is wrong.  See also bug 212963 and 261374.
    //
    BOOL fShowDialingProgress;
    BOOL fPreviewUserPw;          // See above: 1
    BOOL fPreviewDomain;          // See above: 1, 2
    BOOL fPreviewPhoneNumber;

    DWORD dwDialMode;
    DWORD dwDialPercent;
    DWORD dwDialSeconds;
    DWORD dwHangUpPercent;
    DWORD dwHangUpSeconds;

    // These fields are used in place of the equivalent user preference only
    // when the corresponding 'dwfOverridePref' bit is set.  In NT5, the
    // indicated fields become always per-entry, i.e. the corresponding
    // override bits are always set.
    //
    DWORD dwfOverridePref;

    DWORD dwRedialAttempts;       // Always per-entry in NT5
    DWORD dwRedialSeconds;        // Always per-entry in NT5
    LONG lIdleDisconnectSeconds;  // Always per-entry in NT5
    BOOL fRedialOnLinkFailure;    // Always per-entry in NT5

    // Security page fields.
    //
    DWORD dwAuthRestrictions;
    DWORD dwVpnStrategy;          // Valid for vpn entries only.  see VS_xxx
    DWORD dwDataEncryption;
    BOOL fAutoLogon;              // See dependencies on Option page flags

    // The selection in the "Typical" security listbox.  This is for the UI's
    // use only.  Others should refer to 'dwAuthRestrictions' for this
    // information.
    //
    DWORD dwTypicalAuth;

    // Note: CustomAuth fields have meaning only when dwAuthRestrictions
    //       includes AR_F_AuthCustom.  If the AR_F_Eap flag is set without
    //       AR_F_AuthCustom, it should be assumed to be the
    //       'EAPCFG_DefaultKey' protocol, currently EAP_TLS_PROTOCOL.
    //
    DWORD dwCustomAuthKey;
    BYTE* pCustomAuthData;
    DWORD cbCustomAuthData;

    BOOL fScriptAfterTerminal;
    BOOL fScriptAfter;
    TCHAR* pszScriptAfter;
    DWORD dwCustomScript;

    TCHAR* pszX25Network;
    TCHAR* pszX25Address;
    TCHAR* pszX25UserData;
    TCHAR* pszX25Facilities;

    // Network page fields.
    //
    DWORD dwBaseProtocol;
    DWORD dwfExcludedProtocols;
    BOOL fLcpExtensions;
    BOOL fSwCompression;
    BOOL fNegotiateMultilinkAlways;
    BOOL fSkipNwcWarning;
    BOOL fSkipDownLevelDialog;
    BOOL fSkipDoubleDialDialog;

    BOOL fShareMsFilePrint;
    BOOL fBindMsNetClient;

    // List of KEYVALUE nodes containing any key/value pairs found in the
    // NETCOMPONENT group of the entry.
    //
    DTLLIST* pdtllistNetComponents;

#ifdef AMB

    // Note: dwAuthentication is read-only.  The phonebook file value of this
    //       parameter is set by the RasDial API based on the result of
    //       authentication attempts.
    //
    DWORD dwAuthentication;

#endif

    // TCPIP settings sheet PPP or SLIP configuration information.
    // 'DwBaseProtocol' determines which.
    //
    BOOL fIpPrioritizeRemote;
    BOOL fIpHeaderCompression;
    TCHAR* pszIpAddress;
    TCHAR* pszIpDnsAddress;
    TCHAR* pszIpDns2Address;
    TCHAR* pszIpWinsAddress;
    TCHAR* pszIpWins2Address;
    DWORD dwIpAddressSource; // PPP only
    DWORD dwIpNameSource;    // PPP only
    DWORD dwFrameSize;       // SLIP only
    DWORD dwIpDnsFlags;        // DNS_* values
    TCHAR* pszIpDnsSuffix;     // The dns suffix for this connection

    // Router page.
    //
    DWORD dwCallbackMode;
    BOOL fAuthenticateServer;

    // Other fields not shown in UI.
    //
    TCHAR* pszCustomDialDll;
    TCHAR* pszCustomDialFunc;

    //
    // custom dialer name
    //
    TCHAR* pszCustomDialerName;

    // The UID of the cached password is fixed at entry creation.  The GUID is
    // also created at entry creation and used for inter-machine uniqueness.
    // This is currently used to identify an IP configuration to the external
    // TCP/IP dialogs.
    //
    DWORD dwDialParamsUID;
    GUID* pGuid;

    // To translate user's old entries, the user name and domain are read and
    // used as authentication defaults if no cached credentials exist.  They
    // are not rewritten to the entry.
    //
    TCHAR* pszOldUser;
    TCHAR* pszOldDomain;

    // Status flags.  'fDirty' is set when the entry has changed so as to
    // differ from the phonebook file on disk.  'fCustom' is set when the
    // entry contains a MEDIA and DEVICE (so RASAPI is able to read it) but
    // was not created by us.  When 'fCustom' is set only 'pszEntry' is
    // guaranteed valid and the entry cannot be edited.
    //
    BOOL fDirty;
    BOOL fCustom;
}
PBENTRY;


// Phonebook (.PBK) file information.
//
typedef struct
_PBFILE
{
    // Handle of phone book file.
    //
    HRASFILE hrasfile;

    // Fully qualified path to the phonebook.
    //
    TCHAR* pszPath;

    // Phonebook mode, system, personal, or alternate.
    //
    DWORD dwPhonebookMode;

    // Unsorted list of PBENTRY.  The list is manipulated by the Entry
    // dialogs.
    //
    DTLLIST* pdtllistEntries;

    HANDLE hConnection;
}
PBFILE;

typedef void (WINAPI *PBKENUMCALLBACK)( PBFILE *, VOID * );


// The callback number for a device.  This type is a node in the
// 'pdllistCallbackNumbers' below.
//
typedef struct
_CALLBACKNUMBER
{
    TCHAR* pszDevice;
    TCHAR* pszCallbackNumber;
}
CALLBACKNUMBER;


//----------------------------------------------------------------------------
// Prototypes
//----------------------------------------------------------------------------

VOID
ChangeEntryType(
    PBENTRY* ppbentry,
    DWORD dwType );

DTLNODE*
CloneEntryNode(
    DTLNODE* pdtlnodeSrc );

VOID
ClosePhonebookFile(
    IN OUT PBFILE* pFile );

DWORD
CopyToPbport(
    IN PBPORT* ppbportDst,
    IN PBPORT* ppbportSrc );

DTLNODE*
CreateEntryNode(
    BOOL fCreateLink );

DTLNODE*
CreateLinkNode(
    void );

DTLNODE*
CreatePhoneNode(
    void );

DTLNODE*
CreatePortNode(
    void );

VOID
DestroyEntryNode(
    IN DTLNODE* pdtlnode );

VOID
DestroyEntryTypeNode(
    IN DTLNODE *pdtlnode );

VOID
DestroyLinkNode(
    IN DTLNODE* pdtlnode );

VOID
DestroyPhoneNode(
    IN DTLNODE* pdtlnode );

VOID
DestroyPortNode(
    IN DTLNODE* pdtlnode );

DTLNODE*
DuplicateEntryNode(
    DTLNODE* pdtlnodeSrc );

DTLNODE*
DuplicateLinkNode(
    IN DTLNODE* pdtlnodeSrc );

DTLNODE*
DuplicatePhoneNode(
    IN DTLNODE* pdtlnodeSrc );

VOID
EnableOrDisableNetComponent(
    IN PBENTRY* pEntry,
    IN LPCTSTR  pszComponent,
    IN BOOL     fEnable);

BOOL
FIsNetComponentListed(
    IN PBENTRY*     pEntry,
    IN LPCTSTR      pszComponent,
    OUT BOOL*       pfEnabled,
    OUT KEYVALUE**  ppKv);

DTLNODE*
EntryNodeFromName(
    IN DTLLIST* pdtllistEntries,
    IN LPCTSTR pszName );

DWORD
EntryTypeFromPbport(
    IN PBPORT* ppbport );

BOOL
GetDefaultPhonebookPath(
    IN DWORD dwFlags,
    OUT TCHAR** ppszPath );

DWORD
GetOverridableParam(
    IN PBUSER* pUser,
    IN PBENTRY* pEntry,
    IN DWORD dwfRasorBit );

BOOL
GetPhonebookPath(
    IN PBUSER* pUser,
    IN DWORD dwFlags,
    OUT TCHAR** ppszPath,
    OUT DWORD* pdwPhonebookMode );

BOOL
GetPhonebookDirectory(
    IN DWORD dwPhonebookMode,
    OUT TCHAR* pszPathBuf );

BOOL
GetPersonalPhonebookPath(
    IN TCHAR* pszFile,
    OUT TCHAR* pszPathBuf );

BOOL
GetPublicPhonebookPath(
    OUT TCHAR* pszPathBuf );

DWORD
InitializePbk(
    void );

DWORD
InitPersonalPhonebook(
    OUT TCHAR** ppszFile );

BOOL
IsPublicPhonebook(
    IN LPCTSTR pszPhonebookPath );

DWORD
GetPbkAndEntryName(
    IN  LPCTSTR          pszPhonebook,
    IN  LPCTSTR          pszEntry,
    IN  DWORD            dwFlags,
    OUT PBFILE           *pFile,
    OUT DTLNODE          **ppdtlnode);

DWORD
LoadPadsList(
    OUT DTLLIST** ppdtllistPads );

DWORD
LoadPhonebookFile(
    IN TCHAR* pszPhonebookPath,
    IN TCHAR* pszSection,
    IN BOOL fHeadersOnly,
    IN BOOL fReadOnly,
    OUT HRASFILE* phrasfile,
    OUT BOOL* pfPersonal );

DWORD
LoadPortsList(
    OUT DTLLIST** ppdtllistPorts );

DWORD
LoadPortsList2(
    IN  HANDLE hConnection,
    OUT DTLLIST** ppdtllistPorts,
    IN  BOOL fRouter );

DWORD
LoadScriptsList(
    IN  HANDLE    hConnection,
    OUT DTLLIST** ppdtllistScripts );

PBDEVICETYPE
PbdevicetypeFromPszType(
    IN TCHAR* pszDeviceType );

PBDEVICETYPE
PbdevicetypeFromPszTypeA(
    IN CHAR* pszDeviceType );

PBPORT*
PpbportFromPortAndDeviceName(
    IN DTLLIST* pdtllistPorts,
    IN TCHAR* pszPort,
    IN TCHAR* pszDevice );

PBPORT*
PpbportFromNT4PortandDevice(
    IN DTLLIST* pdtlllistPorts,
    IN TCHAR*   pszPort,
    IN TCHAR*   pszDevice);

DWORD
RdtFromPbdt(PBDEVICETYPE pbdt,
            DWORD dwFlags);

DWORD
ReadPhonebookFile(
    IN LPCTSTR pszPhonebookPath,
    IN PBUSER* pUser,
    IN LPCTSTR pszSection,
    IN DWORD dwFlags,
    OUT PBFILE* pFile );

TCHAR *pszDeviceTypeFromRdt(
    RASDEVICETYPE rdt);

BOOL
SetDefaultModemSettings(
    IN PBLINK* pLink );

DWORD
SetPersonalPhonebookInfo(
    IN BOOL fPersonal,
    IN TCHAR* pszPath );

VOID
TerminatePbk(
    void );

DWORD
WritePhonebookFile(
    IN PBFILE* pFile,
    IN LPCTSTR pszSectionToDelete );

DWORD
UpgradePhonebookFile(
    IN LPCTSTR pszPhonebookPath,
    IN PBUSER* pUser,
    OUT BOOL* pfUpgraded );

BOOL
ValidateAreaCode(
    IN OUT TCHAR* pszAreaCode );

BOOL
ValidateEntryName(
    IN LPCTSTR pszEntry );


BOOL 
IsRouterPhonebook(LPCTSTR pszPhonebook);

DWORD
DwSendRasNotification(RASEVENTTYPE Type,
                      PBENTRY *pEntry,
                      LPCTSTR  pszPhonebookPath);

DWORD
DwGetCustomDllEntryPoint(
        LPCTSTR    lpszPhonebook,
        LPCTSTR    lpszEntry,
        BOOL       *pfCustomDllSpecified,
        FARPROC    *pfnCustomEntryPoint,
        HINSTANCE  *phInstDll,
        DWORD      dwFnId,
        LPTSTR     pszCustomDialerName
        );

DWORD
DwCustomDialDlg(
        LPTSTR          lpszPhonebook,
        LPTSTR          lpszEntry,
        LPTSTR          lpszPhoneNumber,
        LPRASDIALDLG    lpInfo,
        DWORD           dwFlags,
        BOOL            *pfStatus,
        PVOID           pvInfo,
        LPTSTR          pszCustomDialer);


DWORD
DwCustomEntryDlg(
        LPTSTR          lpszPhonebook,
        LPTSTR          lpszEntry,
        LPRASENTRYDLG   lpInfo,
        BOOL            *pfStatus);

DWORD
DwCustomDeleteEntryNotify(
        LPCTSTR          lpszPhonebook,
        LPCTSTR          lpszEntry,
        LPTSTR           pszCustomDialer);
        


DWORD
DwGetExpandedDllPath(LPTSTR pszDllPath,
                     LPTSTR *ppszExpandedDllPath);

DWORD
DwGetEntryMode( LPCTSTR pszPhonebook,
                LPCTSTR pszEntry,
                PBFILE *pFileIn,
                DWORD  *pdwFlags);

DWORD
DwEnumeratePhonebooksFromDirectory(
    TCHAR *pszDir,
    DWORD dwFlags,
    PBKENUMCALLBACK pfnCallback,
    VOID *pvContext
    );

DWORD
DwGetCustomAuthData(
    PBENTRY *pEntry,
    DWORD *pcbCustomAuthData,
    PBYTE *ppCustomAuthData
    );

DWORD
DwSetCustomAuthData(
    PBENTRY *pEntry,
    DWORD cbCustomAuthData,
    PBYTE pCustomAuthData
    );
    
    
                
#endif // _PBK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\imported\net\rras\ras\ui\inc\nouiutil.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** nouiutil.h
** No UI helper routines (no HWNDs required)
** Public header
**
** 08/25/95 Steve Cobb
*/

#pragma once
#ifndef _NOUIUTIL_H_
#define _NOUIUTIL_H_


/* Maximum length of string returned by LToT without terminating null.
*/
#define MAXLTOTLEN 11

/* Heap allocation macros allowing easy substitution of alternate heap.  These
** are used by the other utility sections.
*/
#ifndef EXCL_HEAPDEFS
#define Malloc(c)    (void*)GlobalAlloc(0,(c))
#define Realloc(p,c) (void*)GlobalReAlloc((p),(c),GMEM_MOVEABLE)
#define Free(p)      (void*)GlobalFree(p)
#endif

/* Bits returned by GetInstalledProtocols.
*/
#define NP_Nbf      0x1
#define NP_Ipx      0x2
#define NP_Ip       0x4
#define NP_Netmon   0x8

/* Definition of comparison function required by ShellSort and
** ShellSortIndirect.
** The comparison is essentially <arg1> - <arg2>, thus the function should
** return negative if the first item is less than the second, zero
** if the items are equal, and positive if the first item is greater
** than the second.
*/
typedef INT (*PFNCOMPARE)( VOID*, VOID* );

/* Linked list library.
*/
#ifndef EXCL_DTL_H
#include <dtl.h>
#endif

/* International formatting library.
*/
#ifndef EXCL_INTL_H
#include <intl.h>
#endif

/* User preference library.
*/
#ifndef EXCL_PBUSER_H
#include <pbuser.h>
#endif

/* RasApi utility library.
*/
#ifndef EXCL_RAUTIL_H
#include <rautil.h>
#endif

/* RasMan utility library.
*/
#ifndef EXCL_RMUTIL_H
#include <rmutil.h>
#endif

/* RAS DLL entrypoint loader library.
*/
#ifndef EXCL_LOADDLLS_H
#include <loaddlls.h>
#endif

/* EAP configuration utility library.
*/
#ifndef EXCL_EAPCFG_H
#include <eapcfg.h>
#endif

/* Node types used by MultiSz calls.
*/
#define NT_Psz 1
#define NT_Kv  2

//
// Defs to determine which entrypoint to load
//
#define CUSTOM_RASDIALDLG           0
#define CUSTOM_RASENTRYDLG          1
#define CUSTOM_RASDIAL              2
#define CUSTOM_RASDELETEENTRYNOTIFY 3

/*----------------------------------------------------------------------------
** Datatypes
**----------------------------------------------------------------------------
*/

/* Key/Value string pair.  The contents of a Kv node.
*/
#define KEYVALUE struct tagKEYVALUE
KEYVALUE
{
    TCHAR* pszKey;
    TCHAR* pszValue;
};

/* RAS-relevant Unimodem settings.
*/
#define UNIMODEMINFO struct tagUNIMODEMINFO
UNIMODEMINFO
{
    BOOL  fHwFlow;
    BOOL  fEc;
    BOOL  fEcc;
    DWORD dwBps;
    BOOL  fSpeaker;
    BOOL  fOperatorDial;
    BOOL  fUnimodemPreTerminal;
    DWORD dwModemProtocol;      // selected modem protocol
    DTLLIST *pListProtocols;    // list of available protocols
};


/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

INT
ComparePszNode(
    IN DTLNODE* pNode1,
    IN DTLNODE* pNode2 );

DWORD
CreateDirectoriesOnPath(
    LPTSTR                  pszPath,
    LPSECURITY_ATTRIBUTES   psa);

DTLNODE*
CreateKvNode(
    IN LPCTSTR pszKey,
    IN LPCTSTR pszValue );

DTLNODE*
CreatePszNode(
    IN LPCTSTR psz );

VOID
DestroyKvNode(
    IN DTLNODE* pdtlnode );

VOID
DestroyPszNode(
    IN DTLNODE* pdtlnode );

BOOL
DeviceAndPortFromPsz(
    IN  TCHAR*  pszDP,
    OUT TCHAR** ppszDevice,
    OUT TCHAR** ppszPort );

DTLNODE*
DuplicateKvNode(
    IN DTLNODE* pdtlnode );

DTLNODE*
DuplicatePszNode(
    IN DTLNODE* pdtlnode );

BOOL
FFileExists(
    IN TCHAR* pszPath );

BOOL
FIsTcpipInstalled();

BOOL
FIsUserAdminOrPowerUser();

VOID*
Free0(
    VOID* p );

DWORD
GetInstalledProtocols(
    VOID );

DWORD
GetInstalledProtocolsEx(
    HANDLE hConnection,
    BOOL fRouter,
    BOOL fRasCli,
    BOOL fRasSrv );

VOID
GetRegBinary(
    IN HKEY hkey,
    IN TCHAR* pszName,
    OUT BYTE** ppbResult,
    OUT DWORD* pcbResult );

VOID
GetRegDword(
    IN HKEY hkey,
    IN TCHAR* pszName,
    OUT DWORD* pdwResult );

DWORD
GetRegExpandSz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    OUT TCHAR** ppszResult );

DWORD
GetRegMultiSz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    IN OUT DTLLIST** ppListResult,
    IN DWORD dwNodeType );

DWORD
GetRegSz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    OUT TCHAR** ppszResult );

DWORD
GetRegSzz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    OUT TCHAR** ppszResult );

CHAR
HexChar(
    IN BYTE byte );

BYTE
HexValue(
    IN CHAR byte );

void
IpHostAddrToPsz(
    IN  DWORD   dwAddr,
    OUT LPTSTR  pszBuffer );

BOOL
IsAllWhite(
    IN LPCTSTR psz );

BOOL
IsNullTerminatedA(
    IN CHAR* psz,
    IN DWORD dwSize );

DWORD
IpPszToHostAddr(
    IN  LPCTSTR cp );

DWORD
GetRasUnimodemBlob(
    IN  HANDLE hConnection,
    IN  HPORT  hport,
    IN  CHAR*  pszDeviceType,
    OUT BYTE** ppBlob,
    OUT DWORD* pcbBlob );

VOID
GetRasUnimodemInfo(
    IN  HANDLE        hConnection,
    IN  HPORT         hport,
    IN  CHAR*         pszDeviceType,
    OUT UNIMODEMINFO* pInfo );

TCHAR*
LToT(
    LONG   lValue,
    TCHAR* pszBuf,
    INT    nRadix );

TCHAR*
PszFromDeviceAndPort(
    IN TCHAR* pszDevice,
    IN TCHAR* pszPort );

LPCTSTR
PszLoadStringPcch (
        HINSTANCE   hinst,
        UINT        unId,
        int*        pcch);

LPCTSTR
PszLoadString (
        HINSTANCE   hinst,
        UINT        unId);

DWORD
RegDeleteTree(
    IN HKEY RootKey,
    IN TCHAR* SubKeyName );

BOOL
RegValueExists(
    IN HKEY hkey,
    IN TCHAR* pszValue );

BOOL
RestartComputer();

TCHAR*
StripPath(
    IN TCHAR* pszPath );

LONG
TToL(
    TCHAR *pszBuf );

TCHAR*
PszFromError(
    IN DWORD dwError );

TCHAR*
PszFromId(
    IN HINSTANCE hInstance,
    IN DWORD     dwStringId );

BOOL
RestartComputer();

VOID
SanitizeUnimodemBlob(
    IN OUT BYTE* pBlob );

VOID
SetDefaultUnimodemInfo(
    OUT UNIMODEMINFO* pInfo );

HFONT
SetFont(
    HWND   hwndCtrl,
    TCHAR* pszFaceName,
    BYTE   bfPitchAndFamily,
    INT    nPointSize,
    BOOL   fUnderline,
    BOOL   fStrikeout,
    BOOL   fItalic,
    BOOL   fBold );

DWORD
SetRegDword(
    IN HKEY hkey,
    IN TCHAR* pszName,
    IN DWORD dwValue );

DWORD
SetRegMultiSz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    IN DTLLIST* pListValues,
    IN DWORD dwNodeType );

DWORD
SetRegSz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    IN TCHAR* pszValue );

DWORD
SetRegSzz(
    IN HKEY hkey,
    IN TCHAR* pszName,
    IN TCHAR* pszValue );

DWORD
ShellSort(
    IN VOID*        pItemTable,
    IN DWORD        dwItemSize,
    IN DWORD        dwItemCount,
    IN PFNCOMPARE   pfnCompare );

VOID
ShellSortIndirect(
    IN VOID*        pItemTable,
    IN VOID**       ppItemTable,
    IN DWORD        dwItemSize,
    IN DWORD        dwItemCount,
    IN PFNCOMPARE   pfnCompare );

TCHAR*
StrDup(
    LPCTSTR psz );

CHAR*
StrDupAFromT(
    LPCTSTR psz );

CHAR*
StrDupAFromTAnsi(
    LPCTSTR psz);
    
TCHAR*
StrDupTFromA(
    LPCSTR psz );

TCHAR*
StrDupTFromW(
    LPCWSTR psz );

WCHAR*
StrDupWFromA(
    LPCSTR psz );

TCHAR*
StrDupTFromAUsingAnsiEncoding(
    LPCSTR psz );
    
WCHAR*
StrDupWFromAUsingAnsiEncoding(
    LPCSTR psz );
    
WCHAR*
StrDupWFromT(
    LPCTSTR psz );

DWORD
StrCpyWFromA(
    WCHAR* pszDst,
    LPCSTR pszSrc,
    DWORD dwDstChars);
    
DWORD
StrCpyAFromW(
    LPSTR pszDst,
    LPCWSTR pszSrc, 
    DWORD dwDstChars);
    
DWORD
StrCpyWFromAUsingAnsiEncoding(
    WCHAR* pszDst,
    LPCSTR pszSrc,
    DWORD dwDstChars);
    
DWORD
StrCpyAFromWUsingAnsiEncoding(
    LPSTR pszDst,
    LPCWSTR pszSrc, 
    DWORD dwDstChars);
    
int
StrNCmpA(
    IN CHAR* psz1,
    IN CHAR* psz2,
    IN INT   nLen );

CHAR*
StrStrA(
    IN CHAR* psz1,
    IN CHAR* psz2 );

VOID
UnimodemInfoFromBlob(
    IN  BYTE*         pBlob,
    OUT UNIMODEMINFO* pInfo );

VOID
UnimodemInfoToBlob(
    IN     UNIMODEMINFO* pInfo,
    IN OUT BYTE*         pBlob );

TCHAR*
UnNull(
    TCHAR* psz );

#endif // _NOUIUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\imported\net\rras\ras\ui\inc\rautil.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** rautil.h
** Remote Access RASAPI utility library
** Public header
**
** 12/26/95 Steve Cobb
*/

#ifndef _RAUTIL_H_
#define _RAUTIL_H_


#include <list.h>    // for LIST_ENTRY definitions
#include <serial.h>  // RAS serial media header, for SERIAL_TXT
#include <isdn.h>    // RAS ISDN media header, for ISDN_TXT
#include <x25.h>     // RAS X.25 media header, for X25_TXT
#include <rasmxs.h>  // RAS modem/X.25/switch device header, for MXS_*_TXT
#include <ras.h>     // Win32 RAS header, for constants


/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

DWORD
FreeRasconnList(
    LIST_ENTRY *pListHead );

DWORD
GetRasconnList(
    LIST_ENTRY *pListHead );

DWORD
GetRasconnTable(
    OUT RASCONN** ppConnTable,
    OUT DWORD*    pdwConnCount );

DWORD
GetRasEntrynameTable(
    OUT RASENTRYNAME**  ppEntrynameTable,
    OUT DWORD*          pdwEntrynameCount );

DWORD
GetRasProjectionInfo(
    IN  HRASCONN    hrasconn,
    OUT RASAMB*     pamb,
    OUT RASPPPNBF*  pnbf,
    OUT RASPPPIP*   pip,
    OUT RASPPPIPX*  pipx,
    OUT RASPPPLCP*  plcp,
    OUT RASSLIP*    pslip,
    OUT RASPPPCCP*  pccp);

HRASCONN
HrasconnFromEntry(
    IN TCHAR* pszPhonebook,
    IN TCHAR* pszEntry );


#endif // _RAUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\imported\net\rras\ras\ui\inc\x25.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** x25.h
** Remote Access Connection Manager
** Native X.25 media/device header
*/


#ifndef _X25MEDIA_
#define _X25MEDIA_


/* Media/device identification string.
*/
#define X25_TXT "x25"

/* Device parameter key strings.
*/
#define X25_ADDRESS_KEY    "X25Address"
#define X25_USERDATA_KEY   "UserData"
#define X25_FACILITIES_KEY "Facilities"


#endif // _X25MEDIA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\imported\net\rras\ras\ui\inc\rmutil.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** rmutil.h
** Remote Access RASMAN utility library
** Public header
**
** 06/20/95 Steve Cobb
** 12/26/95 Merge Abolade Gbadesin routines
*/

#ifndef _RMUTIL_H_
#define _RMUTIL_H_


#include <rasman.h>  // RAS connection manager header
#include <serial.h>  // RAS serial media header, for SERIAL_TXT
#include <isdn.h>    // RAS ISDN media header, for ISDN_TXT
#include <x25.h>     // RAS X.25 media header, for X25_TXT
#include <rasmxs.h>  // RAS modem/X.25/switch device header, for MXS_*_TXT
#include <ras.h>     // Win32 RAS header, for constants

/* Private RASAPI32 entrypoints.
*/
extern HPORT APIENTRY RasGetHport( HRASCONN );
extern DWORD APIENTRY RasSetOldPassword( HRASCONN, CHAR* );


/*----------------------------------------------------------------------------
** Constants
**----------------------------------------------------------------------------
*/

/* String translation flags.
*/
#define XLATE_Ctrl      0x00000001
#define XLATE_Cr        0x00000002
#define XLATE_CrSpecial 0x00000004
#define XLATE_Lf        0x00000008
#define XLATE_LfSpecial 0x00000010
#define XLATE_LAngle    0x00000020
#define XLATE_RAngle    0x00000040
#define XLATE_BSlash    0x00000080
#define XLATE_SSpace    0x00000100

#define XLATE_None          0
#define XLATE_Diagnostic    (XLATE_Ctrl)
#define XLATE_ErrorResponse (XLATE_Ctrl | XLATE_LAngle | XLATE_RAngle \
                               | XLATE_BSlash | XLATE_CrSpecial \
                               | XLATE_LfSpecial)

/*----------------------------------------------------------------------------
** Datatypes
**----------------------------------------------------------------------------
*/
struct RASDEV {

    HANDLE          RD_Handle;
    DWORD           RD_Flags;
    PTSTR           RD_DeviceName;
    TCHAR           RD_PortName[MAX_PORT_NAME + 1];
    TCHAR           RD_DeviceType[RAS_MaxDeviceType + 1];

};

typedef struct RASDEV RASDEV, *PRASDEV, FAR *LPRASDEV;

#define RDFLAG_DialIn       0x00000001
#define RDFLAG_DialOut      0x00000002
#define RDFLAG_Router       0x00000004
#define RDFLAG_IsDialedIn   0x00000008
#define RDFLAG_IsDialedOut  0x00000010
#define RDFLAG_IsRouter     0x00000020
#define RDFLAG_User1        0x80000000


struct RASDEVSTATS {

    DWORD           RDS_Condition;
    DWORD           RDS_Flags;
    DWORD           RDS_LineSpeed;
    DWORD           RDS_ConnectTime;
    DWORD           RDS_InBytes;
    DWORD           RDS_InFrames;
    DWORD           RDS_InCompRatio;
    DWORD           RDS_OutBytes;
    DWORD           RDS_OutFrames;
    DWORD           RDS_OutCompRatio;
    DWORD           RDS_InBytesTotal;
    DWORD           RDS_OutBytesTotal;
    DWORD           RDS_ErrCRC;
    DWORD           RDS_ErrTimeout;
    DWORD           RDS_ErrAlignment;
    DWORD           RDS_ErrFraming;
    DWORD           RDS_ErrHwOverruns;
    DWORD           RDS_ErrBufOverruns;
    HRASCONN        RDS_Hrasconn;

};

typedef struct RASDEVSTATS RASDEVSTATS, *PRASDEVSTATS;


struct RASCONNENTRY {

    LIST_ENTRY      RCE_Node;
    RASCONN        *RCE_Entry;
    LIST_ENTRY      RCE_Links;

};

typedef struct RASCONNENTRY RASCONNENTRY, *PRASCONNENTRY;


struct RASCONNLINK {

    LIST_ENTRY      RCL_Node;
    RASCONN         RCL_Link;

};

typedef struct RASCONNLINK RASCONNLINK, *PRASCONNLINK;


/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

DWORD
ClearRasdevStats(
    IN RASDEV*  pdev,
    IN BOOL     fBundle );

DWORD
DeviceIdFromDeviceName(
    TCHAR* pszDeviceName );

DWORD
FreeRasdevTable(
    RASDEV* pDevTable,
    DWORD   iDevCount );

DWORD
GetRasConnection0Table(
    OUT RAS_CONNECTION_0 ** ppRc0Table,
    OUT DWORD *             piRc0Count );

DWORD
GetConnectTime(
    IN  HRASCONN hrasconn,
    OUT DWORD*   pdwConnectTime );

DWORD
GetRasconnFraming(
    IN  HRASCONN hrasconn,
    OUT DWORD*   pdwSendFraming,
    OUT DWORD*   pdwRecvFraming );

DWORD
GetRasconnFromRasdev(
    IN  RASDEV*   pdev,
    OUT RASCONN** ppconn,
    IN  RASCONN*  pConnTable OPTIONAL,
    IN  DWORD     iConnCount OPTIONAL );

DWORD
GetRasdevBundle(
    IN  RASDEV*  pdev,
    OUT DWORD*   pdwBundle );

DWORD
GetRasdevFraming(
    IN  RASDEV*  pdev,
    OUT DWORD*   pdwFraming );

DWORD
GetRasdevFromRasconn(
    IN  RASCONN* pconn,
    OUT RASDEV** ppdev,
    IN  RASDEV*  pDevTable OPTIONAL,
    IN  DWORD    iDevCount OPTIONAL );

DWORD
GetRasdevFromRasPort0(
    IN  RAS_PORT_0* pport,
    OUT RASDEV**    ppdev,
    IN  RASDEV*     pDevTable OPTIONAL,
    IN  DWORD       iDevCount OPTIONAL );

DWORD
GetRasDeviceString(
    IN  HPORT  hport,
    IN  CHAR*  pszDeviceType,
    IN  CHAR*  pszDeviceName,
    IN  CHAR*  pszKey,
    OUT CHAR** ppszValue,
    IN  DWORD  dwXlate );

DWORD
GetRasdevStats(
    IN  RASDEV*      pdev,
    OUT RASDEVSTATS* pstats );

DWORD
GetRasdevTable(
    OUT RASDEV** ppDevTable,
    OUT DWORD*   piDevCount );

DWORD
GetRasMessage(
    IN  HRASCONN hrasconn,
    OUT TCHAR**  ppszMessage );

DWORD
GetRasPads(
    OUT RASMAN_DEVICE** ppDevices,
    OUT DWORD*          pdwEntries );

DWORD
GetRasPort0FromRasdev(
    IN  RASDEV*         pdev,
    OUT RAS_PORT_0**    ppport,
    IN  RAS_PORT_0*     pPortTable OPTIONAL,
    IN  DWORD           iPortCount OPTIONAL );

DWORD
GetRasPort0Info(
    IN  HANDLE          hPort,
    OUT RAS_PORT_1 *    pRasPort1 );

DWORD
GetRasPort0Table(
    OUT RAS_PORT_0 **   ppPortTable,
    OUT DWORD *         piPortCount );

TCHAR *
GetRasPort0UserString(
    IN  RAS_PORT_0 *    pport,
    IN  TCHAR *         pszUser );

VOID
GetRasPortMaxBps(
    IN  HPORT  hport,
    OUT DWORD* pdwMaxConnectBps,
    OUT DWORD* pdwMaxCarrierBps );

VOID
GetRasPortModemSettings(
    IN  HPORT hport,
    OUT BOOL* pfHwFlowDefault,
    OUT BOOL* pfEcDefault,
    OUT BOOL* pfEccDefault );

DWORD
GetRasPorts(
    IN  HANDLE        hConnection,
    OUT RASMAN_PORT** ppPorts,
    OUT DWORD*        pdwEntries );

DWORD
GetRasPortString(
    IN  HPORT  hport,
    IN  CHAR*  pszKey,
    OUT CHAR** ppszValue,
    IN  DWORD  dwXlate );

DWORD
GetRasSwitches(
    IN  HANDLE          hConnection,
    OUT RASMAN_DEVICE** ppDevices,
    OUT DWORD*          pdwEntries );

TCHAR*
GetRasX25Diagnostic(
    IN HRASCONN hrasconn );

BOOL
IsRasdevBundled(
    IN  RASDEV* prasdev,
    IN  RASDEV* pDevTable,
    IN  DWORD   iDevCount );

CHAR*
PszFromRasValue(
    IN RAS_VALUE* prasvalue,
    IN DWORD      dwXlate );

DWORD
RasPort0Hangup(
    IN  HANDLE      hPort );

#endif // _RMUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\imported\net\rras\ras\ui\inc\pbuser.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** pbuser.h
** Remote Access phonebook user preference library
** Public header
**
** 06/20/95 Steve Cobb
*/

#ifndef _PBUSER_H_
#define _PBUSER_H_

/*----------------------------------------------------------------------------
** Constants
**----------------------------------------------------------------------------
*/

/* User preference modes
*/
#define UPM_Normal 0
#define UPM_Logon  1
#define UPM_Router 2


/* User preference key and values.
*/
#define REGKEY_HkcuOldRas                TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Network\\RemoteAccess")
#define REGKEY_HkcuOldRasParent          TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Network")
#define REGKEY_HkcuOldRasRoot            TEXT("RemoteAccess")
#define REGKEY_HkuOldRasLogon            TEXT(".DEFAULT\\Software\\Microsoft\\RAS Phonebook")
#define REGKEY_HkcuRas                   TEXT("Software\\Microsoft\\RAS Phonebook")
#define REGKEY_HkuRasLogon               TEXT(".DEFAULT\\Software\\Microsoft\\RAS Logon Phonebook")
#define REGKEY_HklmRouter                TEXT("Software\\Microsoft\\Router Phonebook")
#define REGKEY_Callback                  TEXT("Callback")
#define REGKEY_Location                  TEXT("Location")
#define REGVAL_szNumber                  TEXT("Number")
#define REGVAL_dwDeviceType              TEXT("DeviceType")
#define REGVAL_dwPhonebookMode           TEXT("PhonebookMode")
#define REGVAL_szUsePersonalPhonebook    TEXT("UsePersonalPhonebook")
#define REGVAL_szPersonalPhonebookPath   TEXT("PersonalPhonebookPath")
#define REGVAL_szPersonalPhonebookFile   TEXT("PersonalPhonebookFile")
#define REGVAL_szAlternatePhonebookPath  TEXT("AlternatePhonebookPath")
#define REGVAL_fOperatorDial             TEXT("OperatorDial")
#define REGVAL_fPreviewPhoneNumber       TEXT("PreviewPhoneNumber")
#define REGVAL_fUseLocation              TEXT("UseLocation")
#define REGVAL_fShowLights               TEXT("ShowLights")
#define REGVAL_fShowConnectStatus        TEXT("ShowConnectStatus")
#define REGVAL_fNewEntryWizard           TEXT("NewEntryWizard")
#define REGVAL_dwRedialAttempts          TEXT("RedialAttempts")
#define REGVAL_dwRedialSeconds           TEXT("RedialSeconds")
#define REGVAL_dwIdleDisconnectSeconds   TEXT("IdleHangUpSeconds")
#define REGVAL_dwCallbackMode            TEXT("CallbackMode")
#define REGVAL_mszPhonebooks             TEXT("Phonebooks")
#define REGVAL_mszAreaCodes              TEXT("AreaCodes")
#define REGVAL_mszPrefixes               TEXT("Prefixes")
#define REGVAL_mszSuffixes               TEXT("Suffixes")
#define REGVAL_szLastCallbackByCaller    TEXT("LastCallbackByCaller")
#define REGVAL_dwPrefix                  TEXT("Prefix")
#define REGVAL_dwSuffix                  TEXT("Suffix")
#define REGVAL_dwXWindow                 TEXT("WindowX")
#define REGVAL_dwYWindow                 TEXT("WindowY")
#define REGVAL_szDefaultEntry            TEXT("DefaultEntry")
#define REGVAL_fCloseOnDial              TEXT("CloseOnDial")
#define REGVAL_fAllowLogonPhonebookEdits TEXT("AllowLogonPhonebookEdits")
#define REGVAL_fAllowLogonLocationEdits  TEXT("AllowLogonLocationEdits")
#define REGVAL_fUseAreaAndCountry        TEXT("UseAreaAndCountry")
#define REGKEY_Rasmon                    TEXT("Software\\Microsoft\\RAS Monitor")
#define REGVAL_dwMode                    TEXT("Mode")
#define REGVAL_dwFlags                   TEXT("Flags")
#define REGVAL_dwX                       TEXT("x")
#define REGVAL_dwY                       TEXT("y")
#define REGVAL_dwCx                      TEXT("cx")
#define REGVAL_dwCy                      TEXT("cy")
#define REGVAL_dwCxCol1                  TEXT("cxCol1")
#define REGVAL_dwStartPage               TEXT("StartPage")
#define REGVAL_dwXDlg                    TEXT("xDlg")
#define REGVAL_dwYDlg                    TEXT("yDlg")
#define REGVAL_dwCxDlgCol1               TEXT("cxDlgCol1")
#define REGVAL_dwCxDlgCol2               TEXT("cxDlgCol2")
#define REGVAL_szLastDevice              TEXT("LastDevice")
#define REGVAL_mszDeviceList             TEXT("DeviceList")
#define REGVAL_fSkipConnectComplete      TEXT("SkipConnectComplete")
#define REGVAL_fRedialOnLinkFailure      TEXT("RedialOnLinkFailure")
#define REGVAL_fExpandAutoDialQuery      TEXT("ExpandAutoDialQuery")
#define REGVAL_fPopupOnTopWhenRedialing  TEXT("PopupOnTopWhenRedialing")
#define REGVAL_dwVersion                 TEXT("Version")


/* Callback modes (see dwCallbackMode below).
*/
#define CBM_No    0
#define CBM_Maybe 1
#define CBM_Yes   2


/* Phonebook modes (see dwPhonebookMode below).
*/
#define PBM_System    0
#define PBM_Personal  1
#define PBM_Alternate 2
#define PBM_Router    3


/* RASMON Preferences constants;
*/

/* Display Mode constants
*/

#define RMDM_Desktop            0x0
#define RMDM_Taskbar            0x1


/* Flags values
*/

#define RMFLAG_SoundOnConnect           0x00000001
#define RMFLAG_SoundOnDisconnect        0x00000002
#define RMFLAG_SoundOnTransmit          0x00000004
#define RMFLAG_SoundOnError             0x00000008
#define RMFLAG_Topmost                  0x00000010
#define RMFLAG_Titlebar                 0x00000020
#define RMFLAG_Tasklist                 0x00000040
#define RMFLAG_Header                   0x00000080
#define RMFLAG_AllDevices               0x00000100


/* RASMON refresh rate in milliseconds
*/

#define RMRR_RefreshRate        250



/*----------------------------------------------------------------------------
** Datatypes
**----------------------------------------------------------------------------
*/

/* Information about a callback number.  See 'PBUSER.pdtllistCallback'.  Note
** that 'dwDeviceType' is a PBK PBDEVICETYPE enumeration cast to a DWORD.
*/
#define CALLBACKINFO struct tagCALLBACKINFO
CALLBACKINFO
{
    TCHAR* pszPortName;
    TCHAR* pszDeviceName;
    TCHAR* pszNumber;
    DWORD  dwDeviceType;
};


/* Information associated with a TAPI location number.
*/
#define LOCATIONINFO struct tagLOCATIONINFO
LOCATIONINFO
{
    DWORD  dwLocationId;
    DWORD  iPrefix;
    DWORD  iSuffix;
};


/* User preference information read from the "CURRENT_USER" registry.  This
** information applies to all "normal" user phonebooks plus the system
** phonebook.  The router phonebook may work differently.
*/
#define PBUSER struct tagPBUSER
PBUSER
{
    /* Appearance page.
    */
    BOOL fOperatorDial;
    BOOL fPreviewPhoneNumber;
    BOOL fUseLocation;
    BOOL fShowLights;
    BOOL fShowConnectStatus;
    BOOL fCloseOnDial;
    BOOL fAllowLogonPhonebookEdits;
    BOOL fAllowLogonLocationEdits;
    BOOL fSkipConnectComplete;
    BOOL fNewEntryWizard;

    /* Auto-dial page.
    */
    DWORD dwRedialAttempts;
    DWORD dwRedialSeconds;
    DWORD dwIdleDisconnectSeconds;
    BOOL  fRedialOnLinkFailure;
    BOOL  fPopupOnTopWhenRedialing;
    BOOL  fExpandAutoDialQuery;

    /* Callback page.
    **
    ** This list is of CALLBACKINFO.
    */
    DWORD    dwCallbackMode;
    DTLLIST* pdtllistCallback;
    TCHAR*   pszLastCallbackByCaller;

    /* Phone list page.
    */
    DWORD    dwPhonebookMode;
    TCHAR*   pszPersonalFile;
    TCHAR*   pszAlternatePath;
    DTLLIST* pdtllistPhonebooks;

    /* Area code strings, in MRU order.
    */
    DTLLIST* pdtllistAreaCodes;
    BOOL     fUseAreaAndCountry;

    /* Prefix/suffix information, i.e. the ordered string lists and the
    ** settings for a particular TAPI location.
    */
    DTLLIST* pdtllistPrefixes;
    DTLLIST* pdtllistSuffixes;
    DTLLIST* pdtllistLocations;

    /* Phonebook window position and last entry selected used by RASPHONE.EXE.
    */
    DWORD  dwXPhonebook;
    DWORD  dwYPhonebook;
    TCHAR* pszDefaultEntry;

    /* Set true if the structure has been initialized.
    */
    BOOL fInitialized;

    /* Set true if something's changed since the structure was read.
    */
    BOOL fDirty;
};


/* RASMON user preference information read from the "CURRENT_USER" registry.
*/
#define RMUSER struct tagRMUSER
RMUSER
{

    /* Display Mode (desktop or taskbar)
    */
    DWORD dwMode;

    /* Flags field:
    ** RMFLAG_Sound*:       sounds (connect, disconnect, transmission, errors)
    ** RMFLAG_Topmost:      make window topmost
    ** RMFLAG_Titlebar:     show titlebar
    ** RMFLAG_Tasklist:     include in tasklist
    ** RMFLAG_Header:       show header-control
    ** RMFLAG_AllDevices:   show a set of master lights (for all devices).
    */
    DWORD dwFlags;

    /* Names of devices for which status should be displayed;
    ** This is a null-terminated list of null-terminated strings.
    */
    TCHAR *pszzDeviceList;

    /* Screen position variables for desktop display mode
    */
    INT x;
    INT y;
    INT cx;
    INT cy;

    /* Saved width of left column in desktop window
    */
    INT cxCol1;

    /* Screen position for Dial-Up Networking Monitor property sheet
    /* and saved widths of the treelist columns in Summary property page 
    */
    INT xDlg;
    INT yDlg;
    INT cxDlgCol1;
    INT cxDlgCol2;

    /* Starting page for property sheet
    */
    DWORD dwStartPage;

    /* Name of device last selected on Status page
    */
    TCHAR *pszLastDevice;

};



/*----------------------------------------------------------------------------
** Prototypes
**----------------------------------------------------------------------------
*/

DTLNODE*
CreateLocationNode(
    IN DWORD dwLocationId,
    IN DWORD iPrefix,
    IN DWORD iSuffix );

DTLNODE*
CreateCallbackNode(
    IN TCHAR* pszPortName,
    IN TCHAR* pszDeviceName,
    IN TCHAR* pszNumber,
    IN DWORD  dwDeviceType );

VOID
DestroyLocationNode(
    IN DTLNODE* pNode );

VOID
DestroyCallbackNode(
    IN DTLNODE* pNode );

VOID
DestroyUserPreferences(
    IN PBUSER* pUser );

DTLNODE*
DuplicateLocationNode(
    IN DTLNODE* pNode );

DWORD
GetUserPreferences(
    IN HANDLE   hConnection,
    OUT PBUSER* pUser,
    IN  DWORD   dwMode );

DWORD
SetUserPreferences(
    IN HANDLE  hConnection,
    IN PBUSER* pUser,
    IN DWORD   dwMode );

// These two are provided as an optimization.  
// They write directly to the registry.
DWORD GetUserManualDialEnabling (
    IN OUT PBOOL pbEnabled,
    IN DWORD dwMode );
    
DWORD SetUserManualDialEnabling (
    IN BOOL bEnable,
    IN DWORD dwMode );

DWORD
GetRasmonPreferences(
    OUT RMUSER* pUser );

DWORD
SetRasmonPreferences(
    IN  RMUSER* pUser );

DWORD
SetRasmonDlgPreferences(
    IN  RMUSER* pUser );

DWORD
SetRasmonUserPreferences(
    IN  RMUSER* pUser );

DWORD
SetRasmonWndPreferences(
    IN  RMUSER* pUser );

VOID
DestroyRasmonPreferences(
    IN  RMUSER* pUser );

#endif // _PBUSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\loadras\loadhead.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 1998.
//
//  File:       loadhead.cxx
//
//  Contents:   Precompiled headers for loadstate directory
//
//  Classes:
//
//  Functions:
//
//  History:    02-Sep-99       PhilipLa        Created
//
//----------------------------------------------------------------------------


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <stdio.h>
#include <io.h>
#include <malloc.h>

#include <tchar.h>
#include <setupapi.h>
#include <mbstring.h>

#include <shlobj.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\loadstate\loadhead.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 1998.
//
//  File:       loadhead.cxx
//
//  Contents:   Precompiled headers for loadstate directory
//
//  Classes:
//
//  Functions:
//
//  History:    02-Sep-99       PhilipLa        Created
//
//----------------------------------------------------------------------------


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <stdio.h>
#include <io.h>
#include <malloc.h>

#include <tchar.h>
#include <setupapi.h>
#include <mbstring.h>

#include <shlobj.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\loadras\tstr.c ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    tstr.c

ABSTRACT
    String conversion routines

AUTHOR
    Anthony Discolo (adiscolo) 19-Dec-1996

REVISION HISTORY

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <tapi.h>


CHAR *
strdupA(
    IN LPCSTR psz
    )
{
    INT cb = strlen(psz);
    CHAR *pszNew = NULL;

    if (cb) {
        pszNew = malloc(cb + 1);
        if (pszNew == NULL) {
            DbgPrint("strdupA: LocalAlloc failed\n");
            return NULL;
        }
        strcpy(pszNew, psz);
    }

    return pszNew;
}


WCHAR *
strdupW(
    IN LPCWSTR psz
    )
{
    INT cb = wcslen(psz);
    WCHAR *pszNew = NULL;

    if (cb) {
        pszNew = malloc((cb + 1) * sizeof (WCHAR));
        if (pszNew == NULL) {
            DbgPrint("strdupW: LocalAlloc failed\n");
            return NULL;
        }
        wcscpy(pszNew, psz);
    }

    return pszNew;
}


CHAR *
StrdupWtoA(
    IN LPCWSTR psz,
    IN DWORD dwCp
    )
{
    CHAR* pszNew = NULL;

    if (psz != NULL) {
        DWORD cb;

        cb = WideCharToMultiByte(dwCp, 0, psz, -1, NULL, 0, NULL, NULL);
        ASSERT(cb);

        pszNew = (CHAR*)malloc(cb);
        if (pszNew == NULL) {
            return NULL;
        }

        cb = WideCharToMultiByte(dwCp, 0, psz, -1, pszNew, cb, NULL, NULL);
        if (!cb) {
            free(pszNew);
            return NULL;
        }
    }

    return pszNew;
}


WCHAR *
StrdupAtoW(
    IN LPCSTR psz,
    IN DWORD dwCp
    )
{
    WCHAR* pszNew = NULL;

    if (psz != NULL) {
        DWORD cb;

        cb = MultiByteToWideChar(dwCp, 0, psz, -1, NULL, 0);
        ASSERT(cb);

        pszNew = malloc(cb * sizeof(WCHAR));
        if (pszNew == NULL) {
            return NULL;
        }

        cb = MultiByteToWideChar(dwCp, 0, psz, -1, pszNew, cb);
        if (!cb) {
            free(pszNew);
            return NULL;
        }
    }

    return pszNew;
}


VOID
StrcpyWtoA(
    OUT CHAR *pszDst,
    IN LPCWSTR pszSrc,
    IN DWORD dwCp
    )
{
    *pszDst = '\0';
    if (pszSrc != NULL) {
        DWORD cb;

        cb = WideCharToMultiByte(dwCp, 0, pszSrc, -1, NULL, 0, NULL, NULL);
        ASSERT(cb);

        cb = WideCharToMultiByte(dwCp, 0, pszSrc, -1, pszDst, cb, NULL, NULL);
    }
}


VOID
StrcpyAtoW(
    OUT WCHAR *pszDst,
    IN LPCSTR pszSrc,
    IN DWORD dwCp
    )
{
    *pszDst = L'\0';
    if (pszSrc != NULL) {
        DWORD cb;

        cb = MultiByteToWideChar(dwCp, 0, pszSrc, -1, NULL, 0);
        ASSERT(cb);

        cb = MultiByteToWideChar(dwCp, 0, pszSrc, -1, pszDst, cb);
    }
}


VOID
StrncpyWtoA(
    OUT CHAR *pszDst,
    IN LPCWSTR pszSrc,
    INT cb,
    DWORD dwCp
    )
{
    *pszDst = '\0';
    if (pszSrc != NULL) {
        cb = WideCharToMultiByte(dwCp, 0, pszSrc, -1, pszDst, cb, NULL, NULL);
    }
}


VOID
StrncpyAtoW(
    OUT WCHAR *pszDst,
    IN LPCSTR pszSrc,
    INT cb,
    DWORD dwCp
    )
{
    *pszDst = L'\0';
    if (pszSrc != NULL) {
        cb = MultiByteToWideChar(dwCp, 0, pszSrc, -1, pszDst, cb);
    }
}

size_t
wcslenU(
    IN const WCHAR UNALIGNED *pszU
    )
{
    size_t len = 0;

    if (pszU == NULL)
        return 0;
    while (*pszU != L'\0') {
        pszU++;
        len++;
    }
    return len;
}


WCHAR *
strdupWU(
    IN const WCHAR UNALIGNED *pszU
    )
{
    WCHAR *psz;
    DWORD dwcb;

    if (pszU == NULL)
        return NULL;
    dwcb = (wcslenU(pszU) + 1) * sizeof (WCHAR);
    psz = malloc(dwcb);
    if (psz == NULL)
        return NULL;
    RtlCopyMemory(psz, pszU, dwcb);

    return psz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\loadras\loadras.cxx ===
//--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999 - 2000.
//
//
// File:        loadras
//
// Contents:    Load system settings.
//
//    chrisab   24-Mar-00   Created
//
//---------------------------------------------------------------

#include "loadhead.cxx"
#pragma hdrstop

#undef WINVER
#define WINVER  0x0500

#include <common.hxx>
#include <stdlib.h>
#include <winsock.h>
#include <objerror.h>
#include <loadstate.hxx>
#include <bothchar.hxx>
#include <winnetwk.h>
#include <ras.h>
#include <raserror.h>

#include <loadras.hxx>

extern "C" {
#include "tstr.h"
#include <pbk.h>            // Ras phone book include
}


#define PRIVATE_RAS         // Access the RAS phone book directly instead of using
                            // the public RAS APIs.

#define SIZEOF_STRUCT(structname, uptomember)  ((int)((LPBYTE)(&((structname*)0)->uptomember) - ((LPBYTE)((structname*)0))))

//
// TRUE when rasman.dll has been
// successfully loaded and initailized.
// See LoadRasmanDllAndInit().
//
DWORD FRasInitialized = FALSE;
BOOL g_FRunningInAppCompatMode = FALSE;
DWORD DwRasInitializeError;

CRITICAL_SECTION    PhonebookLock;


// Debugging only
#ifdef NEVER
DWORD RasDumpEntry(TCHAR *strEntryName, RASENTRY *pInRasEntry)
{

  DWORD dwErr = ERROR_SUCCESS;
  DWORD dwSize = sizeof(RASENTRY);
  RASENTRY RasEntry, *pRasEntry;
  RASDIALPARAMS RasDialParams;

  // If no name passed in, print what pInRasEntry pts to
  if( strEntryName == NULL )
  {
    if( pInRasEntry == NULL )
    {
      return ERROR_INVALID_HANDLE;
    }

    pRasEntry = pInRasEntry;
  }
  // Otherwise, if there's a buffer passed in, use that.
  else
  {
    if( pInRasEntry == NULL )
    {
      pRasEntry = &RasEntry;
    }
    else
    {
      pRasEntry = pInRasEntry;
    }

    ZeroMemory( pRasEntry, sizeof(RASENTRY) );
    pRasEntry->dwSize = sizeof(RASENTRY);

    dwErr = RasGetEntryPropertiesW(NULL,
                                  strEntryName,
                                  pRasEntry,
                                  &dwSize,
                                  NULL,
                                  NULL);
    if( dwErr )
      return dwErr;
  }

  if( strEntryName )
  {
    printf(  "--- Dumping Ras entry %ls ---\n", strEntryName);
  }
  else
  {
    printf(  "--- Dumping Ras entry at %p ---\n", pRasEntry);
  }

  printf( "dwfOptions         = %x\n", pRasEntry->dwfOptions);
  printf( "dwFramingProtocol  = %d\n", pRasEntry->dwFramingProtocol);

  printf( "    Win2k Extended Info\n");
  printf( "dwType            = %d\n", pRasEntry->dwType);
  printf( "dwEncryptionType  = %d\n", pRasEntry->dwEncryptionType);
  printf( "dwCustomAuthKey   = %d\n", pRasEntry->dwCustomAuthKey);
  printf( "szCustomDialDll   = [%ls]\n", pRasEntry->szCustomDialDll);
  printf( "dwVpnStrategy     = %d\n", pRasEntry->dwVpnStrategy);

  printf( "\n\n");
  return dwErr;
}

DWORD RasDumpPhoneBookEntry(TCHAR *tszEntryName, PBENTRY *pEntry)
{
  DWORD dwErr;
  PBFILE pbfile;
  DTLNODE *pdtlnode;
  BOOL     fCreated;

  if( !pEntry && !tszEntryName )
    return ERROR_INVALID_PARAMETER;

  if( tszEntryName )
  {
    // Check and see if the entry name already exists in the phone book
    dwErr = GetPbkAndEntryName(NULL,
                               tszEntryName,
                               0,
                               &pbfile,
                               &pdtlnode);

    // if failed for some other reason than the entry doesn't exist, bail.
    if( (dwErr != SUCCESS) && (dwErr != ERROR_CANNOT_FIND_PHONEBOOK_ENTRY) )
    {
      return dwErr;
    }

    if( pdtlnode == NULL )
    {
      dwErr = ERROR_NOT_ENOUGH_MEMORY;
      return dwErr;
    }

    pEntry = (PBENTRY *) DtlGetData(pdtlnode);

    printf( "--- Dumping Phonebook Entry %ls ---\n", tszEntryName);

  }
  else
  {
    printf( "--- Dumping Phonebook Entry at %p ---\n", pEntry);
  }

  printf( "  pszEntryName       = %ls\n", pEntry->pszEntryName);
  printf( "  dwType             = %d\n", pEntry->dwType);
  printf( "  fSharedPhoneNum    = %d\n", pEntry->fSharedPhoneNumbers);
  printf( "  dwDataEncryption   = 0x%x\n", pEntry->dwDataEncryption);
  printf( "  dwAuthRestrictions = 0x%x\n", pEntry->dwAuthRestrictions);

  printf( "  dwTypicalAuth      = 0x%x\n", pEntry->dwTypicalAuth);
  printf( "  dwCustomAuthKey    = 0x%x\n", pEntry->dwCustomAuthKey);

  printf( "  fAutoLogon         = %d\n", pEntry->fAutoLogon);
  printf( "  fPreviewUserPw     = %d\n", pEntry->fPreviewUserPw);
  printf( "  fPreviewDomain     = %d\n", pEntry->fPreviewDomain);

  printf( "\n\n");
  return 0;
}
#endif // NEVER - Debugging only


DWORD InitializeLoadRAS(DWORD dwReason)
{
  DWORD dwErr = ERROR_SUCCESS;

  if( dwReason == DLL_PROCESS_ATTACH )
  {
    InitializeCriticalSection(&PhonebookLock);

    if( InitializePbk() != 0 )
      return FALSE;
  }
  else if( dwReason == DLL_PROCESS_DETACH )
  {
    TerminatePbk();
  }

  return dwErr;
}


BOOL
FRunningInAppCompatMode()
{
    BOOL fResult = FALSE;
    TCHAR *pszCommandLine = NULL;
    TCHAR *psz;

    pszCommandLine = StrDup(GetCommandLine());

    if(NULL == pszCommandLine)
    {
        goto done;
    }

    psz = pszCommandLine + lstrlen(pszCommandLine);

    while(      (TEXT('\\') != *psz)
            &&  (psz != pszCommandLine))
    {
        psz--;
    }

    if(TEXT('\\') == *psz)
    {
        psz++;
    }

    if(     (0 == lstrcmpi(psz, TEXT("INETINFO.EXE")))
        ||  (0 == lstrcmpi(psz, TEXT("WSPSRV.EXE"))))
    {
        fResult = TRUE;
    }

done:

    if(NULL != pszCommandLine)
    {
        Free(pszCommandLine);
    }

    return fResult;
}



DWORD
LoadRasmanDllAndInit()
{
    if (FRasInitialized)
    {
        return 0;
    }

    if (LoadRasmanDll())
    {
        return GetLastError();
    }

    //
    // Success is returned if RasInitialize fails, in which
    // case none of the APIs will ever do anything but report
    // that RasInitialize failed.  All this is to avoid the
    // ugly system popup if RasMan service can't start.
    //
    if ((DwRasInitializeError = g_pRasInitialize()) != 0)
    {
        return DwRasInitializeError;
    }

    FRasInitialized = TRUE;

    g_FRunningInAppCompatMode = FRunningInAppCompatMode();

    // pmay: 300166
    //
    // We don't start rasauto automatically anymore.
    //
    // g_pRasStartRasAutoIfRequired();

    return 0;
}

DWORD
IpAddrToString(
    IN RASIPADDR* pipaddr,
    OUT LPTSTR*   ppszIpAddr
    )
{
    DWORD   dwErr;
    PCHAR   psz;
    LPTSTR  pszIpAddr;
    PULONG  pul = (PULONG)pipaddr;
    struct  in_addr in_addr;

    pszIpAddr = (TCHAR *) Malloc(17 * sizeof(TCHAR));
    if (pszIpAddr == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    in_addr.s_addr = *pul;

    psz = inet_ntoa(in_addr);

    if (psz == NULL)
    {
        DbgPrint("IpAddrToString: inet_ntoa failed!\n");
        Free(pszIpAddr);
        return WSAGetLastError();
    }

    strcpyAtoT(pszIpAddr, psz);

    *ppszIpAddr = pszIpAddr;

    return 0;
}

VOID
GetDevicePortName(
    IN TCHAR *pszDevicePortName,
    OUT TCHAR *pszDeviceName,
    OUT TCHAR *pszPortName
    )
{
    DWORD i, dwStart;

    //
    // Copy the device name.
    //
    lstrcpy(pszDeviceName, pszDevicePortName);

    //
    // Check to see if there is a NULL
    // within MAX_PORT_NAME characters
    // after the device name's NULL.If
    // there is, the copy the characters
    // between the NULLs as the port name.
    //
    *pszPortName = TEXT('\0');

    dwStart = lstrlen(pszDeviceName) + 1;

    for (i = 0; i < MAX_PORT_NAME; i++)
    {
        if (pszDevicePortName[dwStart + i] == TEXT('\0'))
        {
            lstrcpy(
                pszPortName,
                &pszDevicePortName[dwStart]);

            break;

        }
    }
}


DWORD
CreateAndInitializePhone(
            LPTSTR      lpszAreaCode,
            DWORD       dwCountryCode,
            DWORD       dwCountryID,
            LPTSTR      lpszPhoneNumber,
            BOOL        fUseDialingRules,
            LPTSTR      lpszComment,
            DTLNODE**   ppdtlnode)
{
    DWORD    dwRetCode = ERROR_SUCCESS;
    PBPHONE* pPhone;
    DTLNODE* pdtlnode;

    pdtlnode = CreatePhoneNode();
    if (pdtlnode == NULL)
    {
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    pPhone = (PBPHONE *) DtlGetData(pdtlnode);

    if(lpszAreaCode)
    {
        pPhone->pszAreaCode = StrDup(lpszAreaCode);
        if(NULL == pPhone->pszAreaCode)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }
    }
    else
    {
        pPhone->pszAreaCode = NULL;
    }

    pPhone->dwCountryCode   = dwCountryCode;
    pPhone->dwCountryID     = dwCountryID;

    pPhone->fUseDialingRules = fUseDialingRules;

    if(lpszPhoneNumber)
    {
        pPhone->pszPhoneNumber  = StrDup(lpszPhoneNumber);
        if(NULL == pPhone->pszPhoneNumber)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }
    }
    else
    {
        pPhone->pszPhoneNumber = NULL;
    }

    if(pPhone->pszComment)
    {
        pPhone->pszComment = StrDup(lpszComment);
        if(NULL == pPhone->pszComment)
        {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }
    }
    else
    {
        pPhone->pszComment = NULL;
    }

    *ppdtlnode = pdtlnode;

done:
    return dwRetCode;
}


void
SetBogusPortInformation(PBLINK *pLink, DWORD dwType)
{
    PBPORT *pPort = &pLink->pbport;

    if (dwType == RASET_Phone)
    {
        pPort->pszMedia = StrDup( TEXT(SERIAL_TXT) );
        pPort->pbdevicetype = PBDT_Modem;

        pPort->dwFlags |= PBP_F_BogusDevice;
    }
    else if (dwType == RASET_Vpn)
    {
        pPort->pszMedia = StrDup( TEXT("rastapi") );
        pPort->pbdevicetype = PBDT_Vpn;
    }
    else
    {
        pPort->pszMedia = StrDup( TEXT(SERIAL_TXT) );
        pPort->pbdevicetype = PBDT_Null;

        pPort->dwFlags |= PBP_F_BogusDevice;
    }
}


DWORD
WinState_RasEntryToPhonebookEntry(
    IN LPCTSTR      lpszEntry,
    IN LPRASENTRY   lpRasEntry,
    IN DWORD        dwcb,
    IN LPBYTE       lpbDeviceConfig,
    IN DWORD        dwcbDeviceConfig,
    OUT PBENTRY     *pEntry
    )
{
    DWORD           dwErr, dwcbStr;
    DTLNODE         *pdtlnode;
    PBDEVICETYPE    pbdevicetype;
    PBLINK          *pLink;
    DTLLIST         *pdtllistPorts;
    PBPORT          *pPort;
    DWORD           i, cwDevices;
    RASMAN_DEVICE   *pDevices;
    TCHAR           szDeviceName[RAS_MaxDeviceName + 1];
    TCHAR           szPortName[MAX_PORT_NAME];
    DTLNODE         *pNodePhone;
    LPTSTR          pszAreaCode;
    PBPHONE         *pPhone;
    BOOL            fScriptBefore;
    BOOL            fScriptBeforeTerminal = FALSE;
    LPTSTR          pszScriptBefore;
    BOOL            fNewEntry = FALSE;


    //
    // Set up to access information for the first link.
    //
    pdtlnode = DtlGetFirstNode(pEntry->pdtllistLinks);

    pLink = (PBLINK *)DtlGetData(pdtlnode);

    ASSERT(NULL != pLink);

    fScriptBefore = pLink->pbport.fScriptBeforeTerminal;
    pszScriptBefore = pLink->pbport.pszScriptBefore;

    if(NULL == pEntry->pszEntryName)
    {
        fNewEntry = TRUE;
    }

    //
    // Get entry name.
    //
    Free0( pEntry->pszEntryName );

    pEntry->pszEntryName = StrDup(lpszEntry);

    //
    // Get dwfOptions.
    //
    pEntry->dwIpAddressSource =
      lpRasEntry->dwfOptions & RASEO_SpecificIpAddr ?
        ASRC_RequireSpecific : ASRC_ServerAssigned;

    pEntry->dwIpNameSource =
      lpRasEntry->dwfOptions & RASEO_SpecificNameServers ?
        ASRC_RequireSpecific : ASRC_ServerAssigned;

    switch (lpRasEntry->dwFramingProtocol)
    {
    case RASFP_Ppp:

        //
        // Get PPP-based information.
        //
        pEntry->dwBaseProtocol = BP_Ppp;

#if AMB
        pEntry->dwAuthentication = AS_PppThenAmb;
#endif

        pEntry->fIpHeaderCompression =
          (BOOL)lpRasEntry->dwfOptions & RASEO_IpHeaderCompression;

        pEntry->fIpPrioritizeRemote =
          (BOOL)lpRasEntry->dwfOptions & RASEO_RemoteDefaultGateway;

        //
        // Get specified IP addresses.
        //
        if (pEntry->dwIpAddressSource == ASRC_RequireSpecific)
        {
            dwErr = IpAddrToString(
                                &lpRasEntry->ipaddr,
                                &pEntry->pszIpAddress);
            if (dwErr)
                return dwErr;
        }
        else
        {
            pEntry->pszIpAddress = NULL;
        }

        if (pEntry->dwIpNameSource == ASRC_RequireSpecific)
        {
            dwErr = IpAddrToString(
                        &lpRasEntry->ipaddrDns,
                        &pEntry->pszIpDnsAddress);

            if (dwErr)
            {
                return dwErr;
            }

            dwErr = IpAddrToString(
                        &lpRasEntry->ipaddrDnsAlt,
                        &pEntry->pszIpDns2Address);

            if (dwErr)
            {
                return dwErr;
            }

            dwErr = IpAddrToString(
                        &lpRasEntry->ipaddrWins,
                        &pEntry->pszIpWinsAddress);

            if (dwErr)
            {
                return dwErr;
            }

            dwErr = IpAddrToString(
                        &lpRasEntry->ipaddrWinsAlt,
                        &pEntry->pszIpWins2Address);
            if (dwErr)
            {
                return dwErr;
            }
        }
        else
        {
            pEntry->pszIpDnsAddress     = NULL;
            pEntry->pszIpDns2Address    = NULL;
            pEntry->pszIpWinsAddress    = NULL;
            pEntry->pszIpWins2Address   = NULL;
        }

        //
        // Get protocol information.
        //
        pEntry->dwfExcludedProtocols = 0;

        if (!(lpRasEntry->dwfNetProtocols & RASNP_NetBEUI))
        {
            pEntry->dwfExcludedProtocols |= NP_Nbf;
        }

        if (!(lpRasEntry->dwfNetProtocols & RASNP_Ipx))
        {
            pEntry->dwfExcludedProtocols |= NP_Ipx;
        }

        if (!(lpRasEntry->dwfNetProtocols & RASNP_Ip))
        {
            pEntry->dwfExcludedProtocols |= NP_Ip;
        }

        break;

    case RASFP_Slip:

        //
        // Get SLIP-based information.
        //
        pEntry->dwBaseProtocol   = BP_Slip;
#if AMB
        pEntry->dwAuthentication = AS_PppThenAmb;
#endif

        pEntry->dwFrameSize      = lpRasEntry->dwFrameSize;

        pEntry->fIpHeaderCompression =
          (BOOL)lpRasEntry->dwfOptions & RASEO_IpHeaderCompression;

        pEntry->fIpPrioritizeRemote =
          (BOOL)lpRasEntry->dwfOptions & RASEO_RemoteDefaultGateway;

        //
        // Get protocol information.
        //
        pEntry->dwfExcludedProtocols = (NP_Nbf|NP_Ipx);

        if (pEntry->dwIpAddressSource == ASRC_RequireSpecific)
        {
            dwErr = IpAddrToString(
                        &lpRasEntry->ipaddr,
                        &pEntry->pszIpAddress);

            if (dwErr)
            {
                return dwErr;
            }
        }
        else
        {
            pEntry->pszIpAddress = NULL;
        }
        if (pEntry->dwIpNameSource == ASRC_RequireSpecific)
        {
            dwErr = IpAddrToString(
                        &lpRasEntry->ipaddrDns,
                        &pEntry->pszIpDnsAddress);

            if (dwErr)
            {
                return dwErr;
            }

            dwErr = IpAddrToString(
                            &lpRasEntry->ipaddrDnsAlt,
                            &pEntry->pszIpDns2Address);

            if (dwErr)
            {
                return dwErr;
            }

            dwErr = IpAddrToString(
                        &lpRasEntry->ipaddrWins,
                        &pEntry->pszIpWinsAddress);

            if (dwErr)
            {
                return dwErr;
            }

            dwErr = IpAddrToString(
                        &lpRasEntry->ipaddrWinsAlt,
                        &pEntry->pszIpWins2Address);

            if (dwErr)
            {
                return dwErr;
            }
        }
        else
        {
            pEntry->pszIpDnsAddress   = NULL;
            pEntry->pszIpDns2Address  = NULL;
            pEntry->pszIpWinsAddress  = NULL;
            pEntry->pszIpWins2Address = NULL;
        }
        break;
    case RASFP_Ras:

        //
        // Get AMB-based information.
        //
        pEntry->dwBaseProtocol   = BP_Ras;
#if AMB
        pEntry->dwAuthentication = AS_AmbOnly;
#endif

        break;
    }

    pEntry->fLcpExtensions =
      (BOOL)!(lpRasEntry->dwfOptions & RASEO_DisableLcpExtensions);

    //
    // If terminal before/after dial options are set,
    // then update the entry.  Otherwise, leave it as it
    // is.
    //
    if(lpRasEntry->dwfOptions & RASEO_TerminalBeforeDial)
    {
        fScriptBeforeTerminal = TRUE;
    }

    if(lpRasEntry->dwfOptions & RASEO_TerminalAfterDial)
    {
        pEntry->fScriptAfterTerminal = TRUE;
    }
    else
    {
        pEntry->fScriptAfterTerminal = FALSE;
    }


    pEntry->fShowMonitorIconInTaskBar =
        (BOOL) (lpRasEntry->dwfOptions & RASEO_ModemLights);

    pEntry->fSwCompression =
      (BOOL)(lpRasEntry->dwfOptions & RASEO_SwCompression);

    if (lpRasEntry->dwfOptions & RASEO_RequireMsEncryptedPw)
    {
        pEntry->dwAuthRestrictions = AR_F_AuthMSCHAP;
    }
    else if (lpRasEntry->dwfOptions & RASEO_RequireEncryptedPw)
    {
        pEntry->dwAuthRestrictions =    AR_F_AuthSPAP
                                    |   AR_F_AuthMD5CHAP
                                    |   AR_F_AuthMSCHAP;
    }
    else
    {
        pEntry->dwAuthRestrictions = AR_F_TypicalUnsecure;
    }

    pEntry->dwDataEncryption =
        (lpRasEntry->dwfOptions & RASEO_RequireDataEncryption)
      ? DE_Mppe40bit
      : DE_None;

    pEntry->fAutoLogon =
      (BOOL)(lpRasEntry->dwfOptions & RASEO_UseLogonCredentials);

    pLink->fPromoteAlternates =
      (BOOL)(lpRasEntry->dwfOptions & RASEO_PromoteAlternates);

    pEntry->fShareMsFilePrint = pEntry->fBindMsNetClient =
      (BOOL) !(lpRasEntry->dwfOptions & RASEO_SecureLocalFiles);

    //
    // Make sure that the network components section in the
    // phonebook correspond to the values user is setting.
    //
    EnableOrDisableNetComponent(
            pEntry,
            TEXT("ms_msclient"),
            pEntry->fBindMsNetClient);

    EnableOrDisableNetComponent(
            pEntry,
            TEXT("ms_server"),
            pEntry->fShareMsFilePrint);

    if (*lpRasEntry->szAreaCode != TEXT('\0'))
    {
        //
        // Make sure the area code does not contain
        // non-numeric characters.
        //
        if (!ValidateAreaCode(lpRasEntry->szAreaCode))
        {
            return ERROR_INVALID_PARAMETER;
        }

        pszAreaCode = StrDup(lpRasEntry->szAreaCode);
    }
    else
    {
        pszAreaCode = NULL;
    }

    //
    // Get script information.
    //
    if (lpRasEntry->szScript[0] == TEXT('['))
    {
        //
        // Verify the switch is valid.
        //
        dwErr = GetRasSwitches(NULL, &pDevices, &cwDevices);
        if (!dwErr)
        {
            CHAR szScriptA[MAX_PATH];

            strcpyTtoA(szScriptA, lpRasEntry->szScript);
            for (i = 0; i < cwDevices; i++)
            {
                if (!_stricmp(pDevices[i].D_Name, &szScriptA[1]))
                {
                    pEntry->fScriptAfter = TRUE;

                    pEntry->pszScriptAfter =
                            StrDup(&lpRasEntry->szScript[1]);

                    if (pEntry->pszScriptAfter == NULL)
                    {
                        dwErr = GetLastError();
                    }
                    break;
                }
            }
            Free(pDevices);

            if (dwErr)
            {
                return dwErr;
            }
        }
    }
    else if (lpRasEntry->szScript[0] != TEXT('\0'))
    {
        pEntry->fScriptAfter = TRUE;

        pEntry->pszScriptAfter = StrDup(lpRasEntry->szScript);

        if (pEntry->pszScriptAfter == NULL)
        {
            return GetLastError();
        }
    }
    else
    {
        if(pEntry->pszScriptAfter)
        {
            Free(pEntry->pszScriptAfter);
            pEntry->pszScriptAfter = NULL;
        }

        pEntry->fScriptAfter = FALSE;

        if(pLink->pbport.pszScriptBefore)
        {
            Free(pLink->pbport.pszScriptBefore);
            pLink->pbport.pszScriptBefore = NULL;
            pszScriptBefore = NULL;
        }

        pLink->pbport.fScriptBefore = FALSE;
        fScriptBefore = FALSE;
    }

    //
    // Get X.25 information.
    //
    pEntry->pszX25Network = NULL;
    if (*lpRasEntry->szX25PadType != TEXT('\0'))
    {
        //
        // Verify the X25 network is valid.
        //
        dwErr = GetRasPads(&pDevices, &cwDevices);
        if (!dwErr)
        {
            CHAR szX25PadTypeA[RAS_MaxPadType + 1];

            strcpyTtoA(szX25PadTypeA, lpRasEntry->szX25PadType);

            for (i = 0; i < cwDevices; i++)
            {
                if (!_stricmp(pDevices[i].D_Name, szX25PadTypeA))
                {
                    pEntry->pszX25Network = StrDup(lpRasEntry->szX25PadType);
                    break;
                }
            }

            Free(pDevices);
        }
    }

    pEntry->pszX25Address =
        lstrlen(lpRasEntry->szX25Address)
        ? StrDup(lpRasEntry->szX25Address)
        : NULL;

    pEntry->pszX25Facilities =
        lstrlen(lpRasEntry->szX25Facilities)
        ? StrDup(lpRasEntry->szX25Facilities)
        : NULL;

    pEntry->pszX25UserData =
        lstrlen(lpRasEntry->szX25UserData)
        ? StrDup(lpRasEntry->szX25UserData)
        : NULL;

    //
    // Get custom dial UI information.
    //
    pEntry->pszCustomDialDll =
        lstrlen(lpRasEntry->szAutodialDll)
        ? StrDup(lpRasEntry->szAutodialDll)
        : NULL;

    pEntry->pszCustomDialFunc =
        lstrlen(lpRasEntry->szAutodialFunc)
        ? StrDup(lpRasEntry->szAutodialFunc)
        : NULL;

    //
    // Get primary phone number.  Clear out any existing
    // numbers.
    //
    DtlDestroyList(pLink->pdtllistPhones, DestroyPhoneNode);

    pLink->pdtllistPhones = DtlCreateList(0);

    if(NULL == pLink->pdtllistPhones)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if (*lpRasEntry->szLocalPhoneNumber != '\0')
    {

        if(CreateAndInitializePhone(
                        pszAreaCode,
                        lpRasEntry->dwCountryCode,
                        lpRasEntry->dwCountryID,
                        lpRasEntry->szLocalPhoneNumber,
                        !!(lpRasEntry->dwfOptions
                         & RASEO_UseCountryAndAreaCodes),
                        lpRasEntry->szDeviceName,
                        &pdtlnode))
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        DtlAddNodeFirst(pLink->pdtllistPhones, pdtlnode);
    }

    //
    // Get the alternate phone numbers.
    //
    if (lpRasEntry->dwAlternateOffset)
    {
        PTCHAR UNALIGNED pszPhoneNumber =
        (PTCHAR)((ULONG_PTR)lpRasEntry
                + lpRasEntry->dwAlternateOffset);

        while (*pszPhoneNumber != TEXT('\0'))
        {

            if(CreateAndInitializePhone(
                            pszAreaCode,
                            lpRasEntry->dwCountryCode,
                            lpRasEntry->dwCountryID,
                            pszPhoneNumber,
                            !!(lpRasEntry->dwfOptions
                             & RASEO_UseCountryAndAreaCodes),
                            lpRasEntry->szDeviceName,
                            &pdtlnode))
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            DtlAddNodeLast(pLink->pdtllistPhones, pdtlnode);

            pszPhoneNumber += lstrlen(pszPhoneNumber) + 1;
        }
    }

    //
    // Get device information.
    //
    dwErr = LoadPortsList(&pdtllistPorts);

    if (dwErr)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get the encoded device name/port
    // and check for a match.
    //
    GetDevicePortName(
        lpRasEntry->szDeviceName,
        szDeviceName, szPortName);

    pPort = PpbportFromPortAndDeviceName(
                pdtllistPorts,
                szPortName,
                ((szDeviceName[ 0 ]) ? szDeviceName : NULL) );

    if (pPort != NULL)
    {
        if (CopyToPbport(&pLink->pbport, pPort))
        {
            pPort = NULL;
        }
    }

    //
    // Search for a device name match.
    //
    if (pPort == NULL)
    {
        for (pdtlnode = DtlGetFirstNode(pdtllistPorts);
             pdtlnode != NULL;
             pdtlnode = DtlGetNextNode(pdtlnode))
        {
            PBPORT *pPortTmp = (PBPORT *)DtlGetData(pdtlnode);

            if (    (pPortTmp->pszDevice != NULL)
                &&  (!lstrcmpi(pPortTmp->pszDevice, szDeviceName))
                &&  (!CopyToPbport(&pLink->pbport, pPortTmp)))
            {
                pPort = pPortTmp;
                break;
            }
        }
    }

    //
    // If we don't have a match, then
    // pick the first device of the
    // same type.
    //
    if (pPort == NULL)
    {
        pbdevicetype = PbdevicetypeFromPszType(
                        lpRasEntry->szDeviceType
                        );

        //
        // Initialize dwErr in case
        // we fall through the loop
        // without finding a match.
        //
        // dwErr = ERROR_INVALID_PARAMETER;

        //
        // Look for a port with the same
        // device type.
        //
        for (pdtlnode = DtlGetFirstNode(pdtllistPorts);
             pdtlnode != NULL;
             pdtlnode = DtlGetNextNode(pdtlnode))
        {
            pPort = (PBPORT *)DtlGetData(pdtlnode);

            if (pPort->pbdevicetype == pbdevicetype)
            {
                dwErr = CopyToPbport(&pLink->pbport, pPort);

                break;
            }
        }

        if(     (NULL == pdtlnode)
            &&  (fNewEntry))
        {
            //
            // Hack to make CM connections work.
            // Remove this code after beta
            // and just return an error in this case. The api
            // should not be setting bogus information.
            //
            SetBogusPortInformation(pLink, pEntry->dwType);

        }

        //
        // If the device is a modem,
        // then set the default modem settings.
        //
        if (pbdevicetype == PBDT_Modem)
        {
            SetDefaultModemSettings(pLink);
        }
    }

    // pmay: 401682
    //
    // Update the preferred device.  Whenever this api is called,
    // we can assume that the user wants the given device to
    // be sticky.
    //
    if (pPort)
    {
        Free0(pEntry->pszPreferredDevice);
        pEntry->pszPreferredDevice = StrDup(pPort->pszDevice);

        Free0(pEntry->pszPreferredPort);
        pEntry->pszPreferredPort = StrDup(pPort->pszPort);;
    }

    //
    // Copy the remembered values
    //
    pLink->pbport.fScriptBefore = fScriptBefore;
    pLink->pbport.fScriptBeforeTerminal = fScriptBeforeTerminal;
    pLink->pbport.pszScriptBefore = pszScriptBefore;

    DtlDestroyList(pdtllistPorts, DestroyPortNode);

    if (dwErr)
    {
        return dwErr;
    }

    //
    // Copy the TAPI configuration blob.
    //
    if (lpbDeviceConfig != NULL && dwcbDeviceConfig)
    {
        Free0(pLink->pTapiBlob);

        pLink->pTapiBlob = (unsigned char *) Malloc(dwcbDeviceConfig);

        if (pLink->pTapiBlob == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        memcpy(pLink->pTapiBlob,
               lpbDeviceConfig,
               dwcbDeviceConfig);

        pLink->cbTapiBlob = dwcbDeviceConfig;
    }

    //
    // Copy the following fields over only for
    // a V401 structure or above.
    //
    // Winstate only supporting NT5 and above.
    //
    if ( lpRasEntry->dwSize == sizeof (RASENTRY) )
    {
        //
        // Get multilink and idle timeout information.
        //
        pEntry->dwDialMode =    lpRasEntry->dwDialMode
                             == RASEDM_DialAsNeeded
                             ?  RASEDM_DialAsNeeded
                             :  RASEDM_DialAll;

        pEntry->dwDialPercent =
                lpRasEntry->dwDialExtraPercent;

        pEntry->dwDialSeconds =
            lpRasEntry->dwDialExtraSampleSeconds;

        pEntry->dwHangUpPercent =
                lpRasEntry->dwHangUpExtraPercent;

        pEntry->dwHangUpSeconds =
                lpRasEntry->dwHangUpExtraSampleSeconds;

        //
        // Get idle disconnect information.
        //
        pEntry->lIdleDisconnectSeconds =
                    lpRasEntry->dwIdleDisconnectSeconds;

        //
        // if the user is setting the dwIdleDisconnect
        // Seconds through apis then override the user
        // preferences.
        //
        if (pEntry->lIdleDisconnectSeconds)
        {
            pEntry->dwfOverridePref |= RASOR_IdleDisconnectSeconds;
        }

        //
        // CustomScript
        //
        pEntry->dwCustomScript = !!(    RASEO_CustomScript
                                    &   lpRasEntry->dwfOptions);
    }

    if(RASET_Phone != lpRasEntry->dwType)
    {
        pEntry->fPreviewPhoneNumber = FALSE;
        pEntry->fSharedPhoneNumbers = FALSE;
    }

    //
    // Copy the following information only if its nt5
    //
    if(lpRasEntry->dwSize == sizeof(RASENTRY))
    {
        //
        // Connection type
        //
        pEntry->dwType = lpRasEntry->dwType;

        //
        // Clear the Encryption type. We set it below
        // for nt5 - default to Mppe40Bit.
        //
        pEntry->dwDataEncryption = 0;

        /*
        if(     (ET_40Bit & lpRasEntry->dwEncryptionType)
            ||  (   (0 == lpRasEntry->dwEncryptionType)
                &&  (  RASEO_RequireDataEncryption
                     & lpRasEntry->dwfOptions)))
        {
            pEntry->dwDataEncryption |= DE_Mppe40bit;
        }

        if(ET_128Bit & lpRasEntry->dwEncryptionType)
        {
            pEntry->dwDataEncryption |= DE_Mppe128bit;
        }
        */

        if(     (ET_Require == lpRasEntry->dwEncryptionType)
            ||  (   (0 == lpRasEntry->dwEncryptionType)
                &&  (   RASEO_RequireDataEncryption
                    &   lpRasEntry->dwfOptions)))
        {
            pEntry->dwDataEncryption = DE_Require;
        }
        else if (ET_RequireMax == lpRasEntry->dwEncryptionType)
        {
            pEntry->dwDataEncryption = DE_RequireMax;
        }
        else if (ET_Optional == lpRasEntry->dwEncryptionType)
        {
            pEntry->dwDataEncryption = DE_IfPossible;
        }

        //
        // Clear the authrestrictions for nt5 if the user didn't
        // specify any authentication protocol.
        //
        if(     (!(lpRasEntry->dwfOptions & RASEO_RequireMsEncryptedPw))
            &&  (!(lpRasEntry->dwfOptions & RASEO_RequireEncryptedPw)))
        {
            pEntry->dwAuthRestrictions = 0;
        }

        //
        // Set the new authentication bits based on options defined
        // in NT5.
        //
        if(RASEO_RequireCHAP & lpRasEntry->dwfOptions)
        {
            pEntry->dwAuthRestrictions |= AR_F_AuthMD5CHAP;
        }

        if(RASEO_RequireMsCHAP & lpRasEntry->dwfOptions)
        {
            pEntry->dwAuthRestrictions |= AR_F_AuthMSCHAP;
        }

        if(RASEO_RequireMsCHAP2 & lpRasEntry->dwfOptions)
        {
            pEntry->dwAuthRestrictions |= AR_F_AuthMSCHAP2;
        }

        if(RASEO_RequireW95MSCHAP & lpRasEntry->dwfOptions)
        {
            pEntry->dwAuthRestrictions |= (AR_F_AuthW95MSCHAP | AR_F_AuthCustom);
        }

        if(RASEO_RequirePAP & lpRasEntry->dwfOptions)
        {
            pEntry->dwAuthRestrictions |= AR_F_AuthPAP;
        }

        if(RASEO_RequireSPAP & lpRasEntry->dwfOptions)
        {
            pEntry->dwAuthRestrictions |= AR_F_AuthSPAP;
        }

        if(RASEO_RequireEAP & lpRasEntry->dwfOptions)
        {
            pEntry->dwAuthRestrictions |= AR_F_AuthEAP;

            if(     (0 != lpRasEntry->dwCustomAuthKey)
                &&  (-1  != lpRasEntry->dwCustomAuthKey))
            {
                pEntry->dwCustomAuthKey =
                    lpRasEntry->dwCustomAuthKey;
            }
        }

        if(RASEO_Custom & lpRasEntry->dwfOptions)
        {
            pEntry->dwAuthRestrictions |= AR_F_AuthCustom;
        }

        if(0 == pEntry->dwAuthRestrictions)
        {
            pEntry->dwAuthRestrictions = AR_F_TypicalUnsecure;
        }

        //
        // Get custom dial UI information.
        //
        pEntry->pszCustomDialerName =
            lstrlen(lpRasEntry->szCustomDialDll)
            ? StrDup(lpRasEntry->szCustomDialDll)
            : NULL;

        //
        // Set fSharedPhoneNumbers/fPreviewPhoneNumbers
        //
        pEntry->fSharedPhoneNumbers = !!( RASEO_SharedPhoneNumbers
                                        & lpRasEntry->dwfOptions);

        pEntry->fPreviewPhoneNumber = !!(  RASEO_PreviewPhoneNumber
                                          & lpRasEntry->dwfOptions);

        pEntry->fPreviewUserPw = !!(  RASEO_PreviewUserPw
                                    & lpRasEntry->dwfOptions);

        pEntry->fPreviewDomain = !!(  RASEO_PreviewDomain
                                    & lpRasEntry->dwfOptions);

        pEntry->fShowDialingProgress = !!(  RASEO_ShowDialingProgress
                                          & lpRasEntry->dwfOptions);

        //
        // Vpn strategy
        //
        pEntry->dwVpnStrategy = lpRasEntry->dwVpnStrategy;

    }

    //
    //  The following are "adjustments" made for State Migration.
    //  chrisab 2-Apr-00
    //
    //  Bug 90555 and 90561
    //
    if( (lpRasEntry->dwfOptions & RASEO_RequireEncryptedPw) ||
        (lpRasEntry->dwfOptions & RASEO_RequireMsEncryptedPw) )
    {
      pEntry->dwTypicalAuth = TA_Secure;
    }
    else
    {
      pEntry->dwTypicalAuth = TA_Unsecure;
    }

    //
    //  Bug #90554
    //  Set log on to network option
    //
    if( lpRasEntry->dwfOptions & RASEO_NetworkLogon )
    {
      pEntry->fPreviewDomain = TRUE;
    }

    //
    // Set dirty bit so this entry will get written out.
    //
    pEntry->fDirty = TRUE;

    return 0;
}


//
//  WinState_RasSetEntryProperties()
//
//  This function replaces the Win32 RAS API RasSetEntryProperties().
//  If the define PRIvATE_RAS
//
DWORD WinState_RasSetEntryPropertiesW(
  IN LPCWSTR      lpszPhonebook,
  IN LPCWSTR      lpszEntry,
  IN LPRASENTRYW  lpRasEntry,
  IN DWORD        dwcbRasEntry,
  IN LPBYTE       lpbDeviceConfig,
  IN DWORD        dwcbDeviceConfig
  )
{
#ifndef PRIVATE_RAS
  return RasSetEntryProperties(lpszPhonebook,
                               lpszEntry,
                               lpRasEntry,
                               dwcbRasEntry,
                               lpbDeviceConfig,
                               dwcbDeviceConfig);
#else
  DWORD dwErr;
  PBFILE pbfile;
  DTLNODE *pdtlnode;
  PBENTRY *pEntry;
  BOOL     fCreated;

  // Initialize RASMAN.DLL for stuff needed by phonebook APIs.
  dwErr = LoadRasmanDllAndInit();
  if( dwErr )
  {
    return dwErr;
  }

  if( DwRasInitializeError )
  {
    return DwRasInitializeError;
  }

  // Parameter validation.
  if( lpRasEntry == NULL )
  {
    return ERROR_INVALID_PARAMETER;
  }

  // WinState only supporting NT5 and above.
  if (    (lpRasEntry->dwSize != sizeof (RASENTRYW))
      &&  (lpRasEntry->dwSize != SIZEOF_STRUCT (RASENTRYW, dwType))
      &&  (lpRasEntry->dwSize != SIZEOF_STRUCT (RASENTRYW, dwSubEntries)))

  {
      return ERROR_INVALID_SIZE;
  }

  if (dwcbRasEntry < lpRasEntry->dwSize)
  {
      return ERROR_BUFFER_TOO_SMALL;
  }

  //
  // Load the phonebook file.
  //
  EnterCriticalSection(&PhonebookLock);

  // Check and see if the entry name already exists in the phone book
  dwErr = GetPbkAndEntryName(lpszPhonebook,
                             lpszEntry,
                             0,
                             &pbfile,
                             &pdtlnode);

  // if failed for some other reason than the entry doesn't exist, bail.
  if( (dwErr != SUCCESS) && (dwErr != ERROR_CANNOT_FIND_PHONEBOOK_ENTRY) )
  {
    return dwErr;
  }

  // If the entry already exists...
  if( pdtlnode != NULL )
  {
    DTLNODE *pdtlnodeNew = DuplicateEntryNode(pdtlnode);
    DtlRemoveNode(pbfile.pdtllistEntries, pdtlnode);
    DestroyEntryNode(pdtlnode);
    pdtlnode = pdtlnodeNew;
  }
  // New Entry
  else
  {
    dwErr = ReadPhonebookFile(lpszPhonebook,
                              NULL,
                              NULL,
                              0,
                              &pbfile);

    if( dwErr )
    {
      return ERROR_CANNOT_OPEN_PHONEBOOK;
    }

    pdtlnode = CreateEntryNode(TRUE);
    fCreated = TRUE;
  }

  if( pdtlnode == NULL )
  {
    dwErr = ERROR_NOT_ENOUGH_MEMORY;
    goto cleanup;
  }

  //
  //  Add the node to the list of entries
  //
  DtlAddNodeLast(pbfile.pdtllistEntries, pdtlnode);
  pEntry = (PBENTRY *) DtlGetData(pdtlnode);

  //
  //  Convert the RASENTRY to a PBENTRY
  //  (Call our private version of this)
  //
  dwErr = WinState_RasEntryToPhonebookEntry(
              lpszEntry,
              lpRasEntry,
              dwcbRasEntry,
              lpbDeviceConfig,
              dwcbDeviceConfig,
              pEntry);
  if( dwErr )
  {
    goto cleanup;
  }

  //
  //  Write out the phonebook file
  //
  dwErr = WritePhonebookFile(&pbfile, NULL);
  if( dwErr == ERROR_SUCCESS )
  {
    dwErr = DwSendRasNotification(
        (fCreated) ?
        ENTRY_ADDED :
        ENTRY_MODIFIED,
        pEntry,
        pbfile.pszPath);
     dwErr = ERROR_SUCCESS;
  }

cleanup:
  ClosePhonebookFile(&pbfile);

  LeaveCriticalSection(&PhonebookLock);

  return dwErr;
#endif
}


//
//   DllMain()
//
BOOL
DllMain(
    HANDLE hinstDll,
    DWORD  fdwReason,
    LPVOID lpReserved )
{
  if( InitializeLoadRAS(fdwReason) == ERROR_SUCCESS )
    return TRUE;
  return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\loadras\tstr.h ===
/*++

Copyright(c) 1995 Microsoft Corporation

MODULE NAME
    tstr.h

ABSTRACT
    String conversion routines

AUTHOR
    Anthony Discolo (adiscolo) 19-Dec-1996

REVISION HISTORY

--*/

#ifndef _TSTR_H_
#define _TSTR_H_

CHAR *
StrdupWtoA(
    IN LPCWSTR psz,
    IN DWORD dwCp
    );

WCHAR *
StrdupAtoW(
    IN LPCSTR psz,
    IN DWORD dwCp
    );

VOID
StrcpyWtoA(
    OUT CHAR *pszDst,
    IN LPCWSTR pszSrc,
    IN DWORD dwCp
    );

VOID
StrcpyAtoW(
    OUT WCHAR *pszDst,
    IN LPCSTR pszSrc,
    IN DWORD dwCp
    );

VOID
StrncpyWtoA(
    OUT CHAR *pszDst,
    IN LPCWSTR pszSrc,
    INT cb,
    IN DWORD dwCp
    );

VOID
StrncpyAtoW(
    OUT WCHAR *pszDst,
    IN LPCSTR pszSrc,
    INT cb,
    IN DWORD dwCp
    );

CHAR *
strdupA(
    IN LPCSTR psz
    );

WCHAR *
strdupW(
    IN LPCWSTR psz
    );

size_t
wcslenU(
    IN const WCHAR UNALIGNED *psz
    );

WCHAR *
strdupWU(
    IN const WCHAR UNALIGNED *psz
    );

// 
// Define string conversion variants for code pages used
// in public RAS api's.
//
#define strdupWtoA(_x) StrdupWtoA((_x), CP_UTF8)
#define strdupAtoW(_x) StrdupAtoW((_x), CP_UTF8)
#define strcpyWtoA(_x, _y) StrcpyWtoA((_x), (_y), CP_UTF8)
#define strcpyAtoW(_x, _y) StrcpyAtoW((_x), (_y), CP_UTF8)
#define strncpyWtoA(_x, _y, _z) StrncpyWtoA((_x), (_y), (_z), CP_UTF8)
#define strncpyAtoW(_x, _y, _z) StrncpyAtoW((_x), (_y), (_z), CP_UTF8)

#define strdupWtoAAnsi(_x) StrdupWtoA((_x), CP_ACP)
#define strdupAtoWAnsi(_x) StrdupAtoW((_x), CP_ACP)
#define strcpyWtoAAnsi(_x, _y) StrcpyWtoA((_x), (_y), CP_ACP)
#define strcpyAtoWAnsi(_x, _y) StrcpyAtoW((_x), (_y), CP_ACP)
#define strncpyWtoAAnsi(_x, _y, _z) StrncpyWtoA((_x), (_y), (_z), CP_ACP)
#define strncpyAtoWAnsi(_x, _y, _z) StrncpyAtoW((_x), (_y), (_z), CP_ACP)

#ifdef UNICODE
#define strdupTtoA      strdupWtoA
#define strdupTtoW      strdupW
#define strdupAtoT      strdupAtoW
#define strdupWtoT      strdupW
#define strcpyTtoA      strcpyWtoA
#define strcpyTtoW      wcscpy
#define strcpyAtoT      strcpyAtoW
#define strcpyWtoT      wcscpy
#define strncpyTtoA     strncpyWtoA
#define strncpyTtoW     wcsncpy
#define strncpyAtoT     strncpyAtoW
#define strncpyWtoT     wcsncpy

#define strdupTtoAAnsi      strdupWtoAAnsi
#define strdupTtoWAnsi      strdupW
#define strdupAtoTAnsi      strdupAtoWAnsi
#define strdupWtoTAnsi      strdupW
#define strcpyTtoAAnsi      strcpyWtoAAnsi
#define strcpyTtoWAnsi      wcscpy
#define strcpyAtoTAnsi      strcpyAtoWAnsi
#define strcpyWtoTAnsi      wcscpy
#define strncpyTtoAAnsi     strncpyWtoAAnsi
#define strncpyTtoWAnsi     wcsncpy
#define strncpyAtoTAnsi     strncpyAtoWAnsi
#define strncpyWtoTAnsi     wcsncpy

#else
#define strdupTtoA      strdupA
#define strdupTtoW      strdupAtoW
#define strdupAtoT      strdupA
#define strdupWtoT      strdupWtoA
#define strcpyTtoA      strcpy
#define strcpyTtoW      strcpyAtoW
#define strcpyAtoT      strcpy
#define strcpyWtoT      strcpyWtoA
#define strncpyTtoA     strncpy
#define strncpyTtoW     strncpyAtoW
#define strncpyAtoT     strncpy
#define strncpyWtoT     strncpyWtoA

#define strdupTtoAAnsi      strdupA
#define strdupTtoWAnsi      strdupAtoWAnsi
#define strdupAtoTAnsi      strdupA
#define strdupWtoTAnsi      strdupWtoAAnsi
#define strcpyTtoAAnsi      strcpy
#define strcpyTtoWAnsi      strcpyAtoWAnsi
#define strcpyAtoTAnsi      strcpy
#define strcpyWtoTAnsi      strcpyWtoAAnsi
#define strncpyTtoAAnsi     strncpy
#define strncpyTtoWAnsi     strncpyAtoWAnsi
#define strncpyAtoTAnsi     strncpy
#define strncpyWtoTAnsi     strncpyWtoAAnsi

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\loadstate\loadfiles.cxx ===
//--------------------------------------------------------------
//
// File:        loadfiles
//
// Contents:    Load files.
//
//---------------------------------------------------------------

#include "loadhead.cxx"
#pragma hdrstop

#include <common.hxx>
#include <loadstate.hxx>
#include <bothchar.hxx>

#include <section.hxx>
#include <special.hxx>

#include <fileutil.cxx>

#define CREATE_DIRECTORY_MAX_PATH 248
//---------------------------------------------------------------

CSection *g_pcsSectionList = NULL;

CSpecialDirectory g_csdCurrent;
CSpecialDirectory g_csdOld;

CRuleList g_crlExcludeWildcards;
CRuleList g_crlIncludeWildcards;


//---------------------------------------------------------------
DWORD ComputeTemp()
{
  return ERROR_SUCCESS;
}


//---------------------------------------------------------------
void EraseTemp()
{                                             
}

DWORD FixShellShortcut(const TCHAR *ptsFile)
{
    HRESULT hr;
    IShellLink *pisl = NULL;
    IPersistFile *pipf = NULL;
    TCHAR *ptsDest = NULL;
    WIN32_FIND_DATA wfd;
    

    if (DebugOutput)
        Win32Printf(LogFile,
                    "Called FixShellShortcut for %s\r\n",
                    ptsFile);
    
    hr = CoCreateInstance(CLSID_ShellLink,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IShellLink,
                          (void **)&pisl);
    if (FAILED(hr))
        goto cleanup;

    hr = pisl->QueryInterface(IID_IPersistFile,
                              (void **)&pipf);
    if (FAILED(hr))
        goto cleanup;

    hr = pipf->Load(ptsFile,
                    0);
    if (FAILED(hr))
        goto cleanup;
    
    TCHAR ptsPath[MAX_PATH + 1];
    
    hr = pisl->GetPath(ptsPath,
                       MAX_PATH + 1,
                       &wfd,
                       SLGP_RAWPATH);
    if (FAILED(hr))
        goto cleanup;

    if (DebugOutput)
        Win32Printf(LogFile,
                    "Retrieved path %s from shell link %s\r\n",
                    ptsPath,
                    ptsFile);

    
    hr = WhereIsThisFile(ptsPath, &ptsDest);
    if (hr == ERROR_SUCCESS)
    {
        //Change the shortcut

        //Expand any environment strings in the original data with
        //the values for the user we're loading for.  If the final
        //paths match, we'll retain the version of the data with the
        //unexpanded environment variables in it.  Otherwise, we take
        //the full path.


        //We could be much smarter here if we wanted to.
        //For instance:
        //  1)  Check the old path against the old special directories
        //      list, and try to remap things that match.
        //  2)  Double check to make sure the shortcut is actually
        //      broken before we go ahead and fix it.
        TCHAR tsExpand[MAX_PATH + 1];
        TCHAR tsTemp[MAX_PATH + 1];
        TCHAR *ptsFinalDest;
        
        if (_tcslen(ptsPath) > MAX_PATH)
        {
            if (DebugOutput)
                Win32Printf(LogFile, "Error: ptsPath too long %s\r\n", ptsPath);
            goto cleanup;
        }
        _tcscpy(tsExpand, ptsPath);
        hr = ExpandEnvStringForUser(tsExpand,
                                    tsTemp,
                                    &ptsFinalDest);
        if (hr)
            goto cleanup;

        if (_tcsicmp(ptsDest, ptsFinalDest) == 0)
        {
            //They're the same, use the string with the environment
            //variables in it.
            ptsFinalDest = ptsPath;
        }
        else
        {
            ptsFinalDest = ptsDest;
        }
        
        hr = pisl->SetPath(ptsFinalDest);
        if (FAILED(hr))
            goto cleanup;

        if (DebugOutput)
            Win32Printf(LogFile,
                        "FixShellShortcut fixed %s from %s to %s\r\n",
                        ptsFile,
                        ptsPath,
                        ptsFinalDest);
    }

    //If this function failed, we leave the shortcut alone.  A possible
    //change is to delete the shortcut for this case.

cleanup:
    if (ptsDest != NULL)
        free(ptsDest);

    if (pipf != NULL)
        pipf->Release();

    if (pisl != NULL)
        pisl->Release();
    
    return ERROR_SUCCESS;
}

DWORD ExpandEnvStringForUser(TCHAR *ptsString,
                             TCHAR *ptsTemp,
                             TCHAR **pptsFinal)
{
    return g_csdCurrent.ExpandMacro(ptsString,
                                    ptsTemp,
                                    pptsFinal,
                                    FALSE);
}


//---------------------------------------------------------------
DWORD WhereIsThisFile( const TCHAR *ptsFile, TCHAR **pptsNewFile )
{
    CSection *pcsCurrent = g_pcsSectionList;
    TCHAR tsExpName[MAX_PATH + 1];
    TCHAR tsTemp[MAX_PATH + 1];
    TCHAR *ptsFullName;
    DWORD dwErr;

    if (_tcslen(ptsFile) > MAX_PATH)
    {
        if (DebugOutput)
            Win32Printf(LogFile, "Error: ptsFile too long %s\r\n", ptsFile);
        return ERROR_FILENAME_EXCED_RANGE;
    }

    _tcscpy(tsExpName, ptsFile);
    dwErr = g_csdOld.ExpandMacro(tsExpName, tsTemp, &ptsFullName, FALSE);
    if (dwErr)
        return dwErr;
    
    while (pcsCurrent != NULL)
    {
        TCHAR *ptsFileOnly;
        ptsFileOnly = _tcsrchr(ptsFullName, '\\');

        if ((NULL == ptsFileOnly) ||
            (_tcsnicmp(ptsFullName,
                       pcsCurrent->GetSectionPath(),
                       pcsCurrent->GetSectionPathLength()) == 0))
        {
            //Section matches, search for file
            if (NULL == ptsFileOnly)
            {
                ptsFileOnly = ptsFullName;
            }
            else
            {
                ptsFileOnly = ptsFullName + pcsCurrent->GetSectionPathLength() + 1;
            }
            
            for (ULONG i = 0; i < pcsCurrent->GetNameCount(); i++)
            {
                const TCHAR *ptsCurrent = pcsCurrent->GetFullFileName(i);

                if (_tcsicmp(ptsFileOnly,
                             ptsCurrent) == 0)
                {
                    TCHAR tsDest[MAX_PATH + 1];
                    const TCHAR *ptsDest = pcsCurrent->GetDestination(i);

                    if (ptsDest == NULL)
                    {
                        DWORD dwDestLen = pcsCurrent->GetSectionDestLength();
                        
                        if (dwDestLen + _tcslen(ptsCurrent) + 1 > MAX_PATH)
                        {
                            if (Verbose)
                            {
                                Win32Printf(LogFile, 
                                            "Error: destination too long %s\\%s\r\n",
                                            pcsCurrent->GetSectionDest(),
                                            ptsCurrent);
                            }
                            return ERROR_FILENAME_EXCED_RANGE;
                        }
                        _tcscpy(tsDest, pcsCurrent->GetSectionDest());
                        tsDest[dwDestLen] = TEXT('\\');
                        _tcscpy(tsDest + dwDestLen + 1, ptsCurrent);
                        ptsDest = tsDest;
                    }
                    
                    //Bingo, direct hit.
                    *pptsNewFile = (TCHAR *) malloc(
                        (_tcslen(ptsDest) + 1) * sizeof(TCHAR));

                    if (*pptsNewFile == NULL)
                        return ERROR_NOT_ENOUGH_MEMORY;
                    _tcscpy( *pptsNewFile, ptsDest);

                    if (DebugOutput)
                        Win32Printf(LogFile,
                                    "WhereIsThisFile(%ws) found %ws\r\n",
                                    ptsFile,
                                    *pptsNewFile);

                    return ERROR_SUCCESS;
                }
            }
        }
        pcsCurrent = pcsCurrent->GetNextSection();
    }
    
    return ERROR_NOT_FOUND;
}


DWORD AddInfSectionToRuleList(INFCONTEXT *pic,
                              CRuleList *pfl,
                              BOOL fAllowRename)
{
    TCHAR buf[MAX_PATH + 1];
    TCHAR bufMacro[MAX_PATH + 1];
    TCHAR *ptsFinalName;
    TCHAR bufTag[MAX_PATH + 1];
    DWORD dwErr;
    CRuleList *prl;
    
    do
    {
        DWORD dwIndex;
        DWORD cFields;
        BOOL fDirectoryTag = FALSE;
        cFields = SetupGetFieldCount(pic);

        if (((cFields != 1) && !fAllowRename) ||
            ((cFields > 2) && fAllowRename))
        {
            Win32PrintfResource(LogFile, IDS_INF_ERROR);
            if (Verbose)
                Win32Printf(STDERR,
                            "Line contains more than one file name\r\n");
            return ERROR_INVALID_PARAMETER;
        }

        if (!SetupGetStringField(pic,
                                 1,
                                 buf,
                                 MAX_PATH + 1,
                                 NULL))
        {
            dwErr = GetLastError();
            Win32PrintfResource(LogFile, IDS_INF_ERROR);
            if (Verbose)
                Win32Printf(STDERR,
                            "SetupGetStringField returned %lu\r\n",
                            dwErr);
            return dwErr;
        }

        if (SetupGetStringField(pic,
                                 0,
                                 bufTag,
                                 MAX_PATH + 1,
                                 NULL))
        {
            if (_tcsicmp(bufTag, buf))
            {
                //Someone put a field identifier on there.  The only
                //one we recognize is 'dir'
                if (_tcsicmp(bufTag, TEXT("dir")))
                {
                    Win32PrintfResource(LogFile, IDS_INF_ERROR);
                    if (Verbose)
                        Win32Printf(STDERR,
                                    "Unknown tag %s\r\n",
                                    bufTag);
                    return ERROR_INVALID_PARAMETER;
                }
                fDirectoryTag = TRUE;
            }
        }

        dwErr = g_csdOld.ExpandMacro(buf, bufMacro, &ptsFinalName, TRUE);
        if (dwErr)
            return dwErr;

        if (fDirectoryTag)
        {
            //Append a backslash

            if (_tcslen(ptsFinalName) >= MAX_PATH)
            {
                if (DebugOutput)
                {
                    Win32Printf(LogFile, "Error: ptsFinalName too long %s\r\n", ptsFinalName);
                }
                return ERROR_FILENAME_EXCED_RANGE;
            }

            _tcscat(ptsFinalName, TEXT("\\"));
        }

        dwErr = pfl->SetName(ptsFinalName, &prl);
        if (dwErr)
        {
            return dwErr;
        }

        if (cFields == 2)
        {
            if (!SetupGetStringField(pic,
                                     2,
                                     buf,
                                     MAX_PATH + 1,
                                     NULL))
            {
                dwErr = GetLastError();
                Win32PrintfResource(LogFile, IDS_INF_ERROR);
                if (Verbose)
                    Win32Printf(STDERR,
                                "SetupGetStringField returned %lu\r\n",
                                dwErr);
                return dwErr;
            }
            dwErr = prl->SetDestination(buf);
            if (dwErr)
            {
                return dwErr;
            }
        }
    }
    while (SetupFindNextLine(pic, pic));

    return ERROR_SUCCESS;
}

DWORD ProcessCopyFiles(HINF hi, const TCHAR *ptsName)
{
    DWORD dwErr;
    INFCONTEXT ic;

    if (!SetupFindFirstLine(hi,
                            ptsName,
                            NULL,
                            &ic))
    {
        dwErr = GetLastError();
        Win32PrintfResource(LogFile, IDS_SECTION_NAME_NOT_FOUND, ptsName);
        if (Verbose)
            Win32Printf(STDERR,
                        "SetupFindFirstLine failed on section %s with %lu\r\n",
                        ptsName,
                        dwErr);
        return dwErr;
    }

    dwErr = AddInfSectionToRuleList(&ic, &g_crlIncludeWildcards, TRUE);

    return dwErr;
}

DWORD ProcessDelFiles(HINF hi, const TCHAR *ptsName)
{
    DWORD dwErr;
    INFCONTEXT ic;

    if (!SetupFindFirstLine(hi,
                            ptsName,
                            NULL,
                            &ic))
    {
        dwErr = GetLastError();
        Win32PrintfResource(LogFile, IDS_SECTION_NAME_NOT_FOUND, ptsName);
        if (Verbose)
            Win32Printf(STDERR,
                        "SetupFindFirstLine failed on section %s with %lu\r\n",
                        ptsName,
                        dwErr);
        return dwErr;
    }

    dwErr = AddInfSectionToRuleList(&ic, &g_crlExcludeWildcards, FALSE);

    return dwErr;
}

DWORD ProcessRules(HINF hi)
{
    DWORD dwErr;
    INFCONTEXT ic;

    if (!SetupFindFirstLine(hi,
                            EXTENSION_SECTION,
                            NULL,
                            &ic))
    {
        //Ignore - this section is optional
        return ERROR_SUCCESS;
    }

    do
    {
        DWORD cFields;
        cFields = SetupGetFieldCount(&ic);
        TCHAR buf[MAX_PATH + 1];

        if (!SetupGetStringField(&ic,
                                 0,
                                 buf,
                                 MAX_PATH + 1,
                                 NULL))
        {
            dwErr = GetLastError();
            Win32PrintfResource(LogFile, IDS_INF_ERROR);
            if (Verbose)
                Win32Printf(STDERR,
                            "SetupGetStringField failed with %lu\r\n",
                            dwErr);
            return dwErr;
        }

        if (_tcsicmp(buf, COPYFILES_LABEL) == 0)
        {
            //Add files in all sections to the include list
            for (DWORD j = 1; j < cFields + 1; j++)
            {
                if (!SetupGetStringField(&ic,
                                         j,
                                         buf,
                                         MAX_PATH + 1,
                                         NULL))
                {

                    dwErr = GetLastError();
                    Win32PrintfResource(LogFile, IDS_INF_ERROR);
                    if (Verbose)
                        Win32Printf(STDERR,
                                    "SetupGetStringField failed with %lu\r\n",
                                    dwErr);
                    return dwErr;
                }
                dwErr = ProcessCopyFiles(hi, buf);
                if (dwErr != 0)
                    return dwErr;
            }
        }
        else if (_tcsicmp(buf, DELFILES_LABEL) == 0)
        {
            //Add files in all sections to the include list
            for (DWORD j = 1; j < cFields + 1; j++)
            {
                if (!SetupGetStringField(&ic,
                                         j,
                                         buf,
                                         MAX_PATH + 1,
                                         NULL))
                {

                    dwErr = GetLastError();
                    Win32PrintfResource(LogFile, IDS_INF_ERROR);
                    if (Verbose)
                        Win32Printf(STDERR,
                                    "SetupGetStringField failed with %lu\r\n",
                                    dwErr);
                    return dwErr;
                }
                dwErr = ProcessDelFiles(hi, buf);
                if (dwErr != 0)
                    return dwErr;
            }
        }
    }
    while (SetupFindNextLine(&ic, &ic));

    return ERROR_SUCCESS;
}
    
DWORD ProcessSpecialDirs(HINF hi)
{
    DWORD dwErr;
    INFCONTEXT ic;
    
    if (!SetupFindFirstLine(hi,
                            SPECIALDIRS_SECTION,
                            NULL,
                            &ic))
    {
        dwErr = GetLastError();
        Win32PrintfResource(LogFile,
                            IDS_SECTION_NAME_NOT_FOUND,
                            SPECIALDIRS_SECTION);
        if (Verbose)
            Win32Printf(STDERR,
                        "SetupFindFirstLine failed with %lu\r\n",
                        dwErr);
        return dwErr;
    }

    do
    {
        TCHAR bufName[MAX_PATH + 1];
        TCHAR bufPath[MAX_PATH + 2];
        DWORD cFields;
        cFields = SetupGetFieldCount(&ic);

        if (cFields != 1)
        {
            Win32PrintfResource(LogFile, IDS_INF_ERROR);
            if (Verbose)
                Win32Printf(STDERR,
                            "INF line contains too many fields in "
                            "section %s\r\n",
                            SPECIALDIRS_SECTION);
            return ERROR_INVALID_PARAMETER;
        }

        if (!SetupGetStringField(&ic,
                                 0,
                                 bufName,
                                 MAX_PATH + 1,
                                 NULL))
        {
            dwErr = GetLastError();
            Win32PrintfResource(LogFile, IDS_INF_ERROR);
            if (Verbose)
                Win32Printf(STDERR,
                            "SetupGetStringField returned %lu\r\n",
                            dwErr);
            return dwErr;
        }

        if (!SetupGetStringField(&ic,
                                 1,
                                 bufPath,
                                 MAX_PATH + 1,
                                 NULL))
        {
            dwErr = GetLastError();
            Win32PrintfResource(LogFile, IDS_INF_ERROR);
            if (Verbose)
                Win32Printf(STDERR,
                            "SetupGetStringField returned %lu\r\n",
                            dwErr);
            return dwErr;
        }


        dwErr = g_csdOld.InitFromInf(bufName, bufPath);
        if (dwErr)
            return dwErr;
    }
    while (SetupFindNextLine(&ic, &ic));

    return ERROR_SUCCESS;
}

DWORD AddLoadFileSection(HINF hi, TCHAR *ptsName, CSection **ppcs)
{
    DWORD dwErr;
    INFCONTEXT ic;
    CSection *pcsSection;
    TCHAR tsSection[MAX_PATH + 1];
    TCHAR buf[MAX_PATH + 1];
    TCHAR bufDest[MAX_PATH + 1];
    TCHAR bufMacro[MAX_PATH + 1];
    TCHAR *ptsFinalName;

    pcsSection = new CSection;
    if (pcsSection == NULL)
    {
        Win32PrintfResource(LogFile, IDS_NOT_ENOUGH_MEMORY);
        return ERROR_OUTOFMEMORY;
    }

    if (ppcs)
        *ppcs = pcsSection;

    if (g_pcsSectionList == NULL)
    {
        g_pcsSectionList = pcsSection;
    }
    else
    {
        g_pcsSectionList->AddToList(pcsSection);
    }

    dwErr = pcsSection->SetSectionTitle(ptsName);
    if (dwErr)
    {
       return dwErr;
    }

    if (_tcslen(ptsName) > MAX_PATH)
    {
        if (DebugOutput)
            Win32Printf(LogFile, "Error: ptsName too long %s\r\n", ptsName);
        return ERROR_FILENAME_EXCED_RANGE;
    }
    _tcscpy(buf, ptsName);
    dwErr = g_csdOld.ExpandMacro(buf, bufMacro, &ptsFinalName, TRUE);
    if (dwErr)
    {
        //Try with the current list
        dwErr = g_csdCurrent.ExpandMacro(buf, bufMacro, &ptsFinalName, FALSE);
        if (dwErr)
            return dwErr;
    }

    dwErr = pcsSection->SetSectionPath(ptsFinalName);
    if (dwErr)
    {
        return dwErr;
    }

    const TCHAR *ptsSectionPath = pcsSection->GetSectionPath();

    if (_tcslen(ptsSectionPath) + 1 > MAX_PATH)
    {
        if (DebugOutput)
            Win32Printf(LogFile, "Error: ptsSectionPath too long %s\r\n", ptsSectionPath);
        return ERROR_FILENAME_EXCED_RANGE;
    }
    _tcscpy(tsSection, ptsSectionPath);
    _tcscat(tsSection, TEXT("\\"));

    if (!SetupFindFirstLine(hi,
                            ptsName,
                            NULL,
                            &ic))
    {
        dwErr = GetLastError();
        Win32PrintfResource(LogFile, IDS_SECTION_NAME_NOT_FOUND, ptsName);
        if (Verbose)
            Win32Printf(STDERR,
                        "SetupFindFirstLine failed on section %s with %lu\r\n",
                        ptsName,
                        dwErr);
        return dwErr;
    }

    do
    {
        DWORD cFields;
        cFields = SetupGetFieldCount(&ic);

        if ((cFields != 1) && (cFields != 2))
        {
            Win32PrintfResource(LogFile, IDS_INF_ERROR);
            if (Verbose)
                Win32Printf(STDERR,
                            "INF line contains too many fields in "
                            "section %s\r\n",
                            ptsName);
            return ERROR_INVALID_PARAMETER;
        }

        if (!SetupGetStringField(&ic,
                                 1,
                                 buf,
                                 MAX_PATH + 1,
                                 NULL))
        {
            dwErr = GetLastError();
            Win32PrintfResource(LogFile, IDS_INF_ERROR);
            if (Verbose)
                Win32Printf(STDERR,
                            "SetupGetStringField returned %lu\r\n",
                            dwErr);
            return dwErr;
        }

        dwErr = g_csdCurrent.ExpandMacro(buf,
                                         bufMacro,
                                         &ptsFinalName,
                                         TRUE);
        if (dwErr)
            return dwErr;
        
        //Check if we're supposed to exclude this file by a rule
        CRuleList *prl;
        if (!g_crlExcludeWildcards.MatchAgainstRuleList(tsSection,
                                                        buf,
                                                        &prl,
                                                        NULL))
        {
            DWORD i;
            dwErr = pcsSection->SetName(ptsFinalName, &i, FALSE);
            if (dwErr)
                return dwErr;
            
            if (cFields == 2)
            {
                if (!SetupGetStringField(&ic,
                                         2,
                                         bufDest,
                                         MAX_PATH + 1,
                                         NULL))
                {
                    dwErr = GetLastError();
                    Win32PrintfResource(LogFile, IDS_INF_ERROR);
                    if (Verbose)
                        Win32Printf(STDERR,
                                    "SetupGetStringField returned %lu\r\n",
                                    dwErr);
                    return dwErr;
                }
                dwErr = g_csdCurrent.ExpandMacro(bufDest,
                                                 bufMacro,
                                                 &ptsFinalName,
                                                 TRUE);
                if (dwErr)
                    return dwErr;
                
                dwErr = pcsSection->SetDestination(ptsFinalName, i);
                if (dwErr)
                    return dwErr;
            }
        }
        else
        {
            if (Verbose)
                Win32Printf(LogFile,
                            "Excluding %s by rule %s\r\n",
                            buf,
                            prl->GetFullName());
        }
    }
    while (SetupFindNextLine(&ic, &ic));

    return ERROR_SUCCESS;
}


DWORD CopyAllFiles(void)
{
    DWORD dwErr;
    CSection *pcs = g_pcsSectionList;

    DWORD ccMigPath;
    TCHAR tsFinalSource[MAX_PATH + 1];
    TCHAR tsSectionDest[MAX_PATH + 1];
    TCHAR tsFinalDest[MAX_PATH + 1];
    TCHAR *ptsJustFile;
    DWORD ccPredictedLength;
    DWORD dwReturnUp = ERROR_SUCCESS;

#ifdef UNICODE
    if (_tcslen(wcsMigrationPath) > MAX_PATH)
    {
        if (DebugOutput)
            Win32Printf(LogFile, "Error: wcsMigrationPath too long %s\r\n", wcsMigrationPath);
        return ERROR_FILENAME_EXCED_RANGE;
    }
    wcscpy(tsFinalSource, wcsMigrationPath);
    ccMigPath = wcslen(wcsMigrationPath);
#else
    if (_tcslen(MigrationPath) > MAX_PATH)
    {
        if (DebugOutput)
            Win32Printf(LogFile, "Error: MigrationPath too long %s\r\n", MigrationPath);
        return ERROR_FILENAME_EXCED_RANGE;
    }
    strcpy(tsFinalSource, MigrationPath);
    ccMigPath = strlen(MigrationPath);
#endif

    while (pcs != NULL)
    {
        ULONG ulNameCount = pcs->GetNameCount();

        //Add section to source path
        const TCHAR *ptsSection = pcs->GetSectionPath();

        DWORD ccSection = pcs->GetSectionPathLength() + ccMigPath;
        if ( ccSection + 1 > MAX_PATH )
        {
            Win32PrintfResource(LogFile,
                                IDS_FILE_COPYERROR,
                                ptsSection);
            if (Verbose)
            {
                Win32Printf(STDERR,
                            "Skipping Too Long Source Filename: %s\\%s\r\n",
                            tsFinalSource,
                            ptsSection);
            }
            if (dwReturnUp == ERROR_SUCCESS)
            {
                dwReturnUp = ERROR_FILENAME_EXCED_RANGE;
            }
            pcs = pcs->GetNextSection();
            continue;
        }
        tsFinalSource[ccMigPath] = TEXT('\\');
        tsFinalSource[ccMigPath + 1] = ptsSection[0];
        _tcscpy(tsFinalSource + ccMigPath + 2, ptsSection + 2);

        tsFinalSource[ccSection++] = TEXT('\\');
        tsFinalSource[ccSection] = 0;

        // Build Destination Path
        INT_PTR ccDest = pcs->GetSectionDestLength();
        if ( ccDest + 1 > MAX_PATH )
        {
            Win32PrintfResource(LogFile,
                                IDS_FILE_COPYERROR,
                                pcs->GetSectionDest);
            if (Verbose)
            {
                Win32Printf(STDERR,
                            "Skipping Too Long Destination Filename: %s\r\n",
                            pcs->GetSectionDest);
            } 
            if (dwReturnUp == ERROR_SUCCESS)
            {
                dwReturnUp = ERROR_FILENAME_EXCED_RANGE;
            }
            pcs = pcs->GetNextSection();
            continue;
        }
           
        _tcscpy(tsSectionDest, pcs->GetSectionDest());
        if (tsSectionDest[ccDest - 1] != TEXT('\\'))
        {
            tsSectionDest[ccDest++] = TEXT('\\');
            tsSectionDest[ccDest] = 0;
        }

        for (ULONG i = 0; i < ulNameCount; i++)
        {
            TCHAR *ptsDestFinal;
            const TCHAR *ptsName = pcs->GetFullFileName(i);
            const TCHAR *ptsDest = pcs->GetDestination(i);

            if (ptsDest != NULL)
            {
                TCHAR *ptsTopDir;

                // File is explicitly being migrated
                // Build the destination filename with these pieces:
                // - Destination dir specified in the file rule
                // - Last piece of the path in the section heading
                // - Filename

                DWORD ccFinalDest = _tcslen(ptsDest);
                if (ccFinalDest > MAX_PATH)
                {
                    Win32PrintfResource(LogFile, IDS_FILE_COPYERROR, ptsName);
                    if (Verbose)
                        Win32Printf(STDERR, "Skipping Too Long Destination Filename: %s\r\n",
                                    ptsDest);
                    continue;
                }
                _tcscpy(tsFinalDest, ptsDest);

                if (tsFinalDest[ccFinalDest] != TEXT('\\') && ccFinalDest < MAX_PATH)
                {
                    tsFinalDest[ccFinalDest++] = TEXT('\\');
                }

                ptsTopDir = _tcsrchr( ptsSection, TEXT('\\'));
                if (ptsTopDir != NULL)
                {
                    ptsTopDir++;  // move past the '\'
                }

                // Skip this if we're going to create a filename that is too long
                ccPredictedLength = ccFinalDest + _tcslen(ptsName);
                if (ptsTopDir != NULL)
                {
                    ccPredictedLength += _tcslen(ptsTopDir) + 1;
                }
                if ( ccPredictedLength > MAX_PATH )
                {
                    Win32PrintfResource(LogFile,
                                        IDS_FILE_COPYERROR,
                                        ptsName);
                    if (Verbose)
                    {
                        tsFinalDest[ccFinalDest] = 0; // Null terminate for printing
                        if (ptsTopDir == NULL)
                            Win32Printf(STDERR,
                                    "Skipping Too Long Destination Filename: %s%s\r\n",
                                    tsFinalDest,
                                    ptsName);
                        else
                            Win32Printf(STDERR,
                                    "Skipping Too Long Destination Filename: %s%s\\%s\r\n",
                                    tsFinalDest,
                                    ptsTopDir,
                                    ptsName);
                    }
                    if (dwReturnUp == ERROR_SUCCESS)
                    { 
                        dwReturnUp = ERROR_FILENAME_EXCED_RANGE;
                    }
                    continue;
                }

                if (ptsTopDir != NULL)
                {
                    _tcscpy(tsFinalDest + ccFinalDest, ptsTopDir);
                    ccFinalDest += _tcslen(ptsTopDir);
                    if (tsFinalDest[ccFinalDest] != TEXT('\\') )
                    {
                        tsFinalDest[ccFinalDest++] = TEXT('\\');
                    }
                }
                _tcscpy(tsFinalDest + ccFinalDest, ptsName);
                ptsDestFinal = tsFinalDest;
            }
            else
            {
                if ( ccDest + _tcslen(ptsName) > MAX_PATH )
                {
                    Win32PrintfResource(LogFile,
                                        IDS_FILE_COPYERROR,
                                        ptsName);
                    if (Verbose)
                    {
                        tsFinalDest[ccDest] = 0; // Null terminate for printing
                        Win32Printf(STDERR,
                                    "Skipping Too Long Destination Filename: %s%s\r\n",
                                    tsFinalDest,
                                    ptsName);
                    }
                    if (dwReturnUp == ERROR_SUCCESS)
                    {
                        dwReturnUp = ERROR_FILENAME_EXCED_RANGE;
                    }
                    continue;
                }
                //Use section destination
                _tcscpy(tsSectionDest + ccDest, ptsName);
                ptsDestFinal = tsSectionDest;
            }

            DWORD_PTR ccDestDir;
            // If the directory is more than 248 characters, then CreateDirectory will fail
            // There is no system define for 248, unfortunately.. It's only mentioned in the
            // documentation.  How odd.
            ptsJustFile = _tcsrchr(ptsDestFinal, '\\');
            if ( ptsJustFile == NULL )
            {
                ccDestDir = _tcslen(ptsDestFinal);
            }
            else
            {
                ccDestDir = ptsJustFile - ptsDestFinal;
                ptsJustFile++;       // Move past the '\'
            }
            if ( ccDestDir > CREATE_DIRECTORY_MAX_PATH )
            {
                Win32PrintfResource(LogFile,
                                    IDS_FILE_COPYERROR,
                                    ptsName);
                if (Verbose)
                {
                    ptsDestFinal[ccDestDir] = 0;  // Null terminate for printing
                    Win32Printf(STDERR,
                                "Skipping Too Long Destination Directory: %s for %s\r\n",
                                ptsDestFinal,
                                ptsJustFile ? ptsJustFile : TEXT("file list") );
                }
                if (dwReturnUp == ERROR_SUCCESS)
                {
                    dwReturnUp = ERROR_FILENAME_EXCED_RANGE;
                }
                continue;
            }

            // Windows appears to enforce that an existing file cannot exceed MAX_PATH,
            // but we'll check just to make sure.
            if ( (ccSection + _tcslen(ptsName)) > MAX_PATH )
            {
                Win32PrintfResource(LogFile,
                                    IDS_FILE_COPYERROR,
                                    ptsName);
                if (Verbose)
                {
                    tsFinalSource[ccSection] = 0;  // Null terminate for printing
                    Win32Printf(STDERR,
                                "Skipping Too Long Source Filename: %s\\%s\r\n",
                                tsFinalSource,
                                ptsName);
                }
                if (dwReturnUp == ERROR_SUCCESS)
                {
                    dwReturnUp = ERROR_FILENAME_EXCED_RANGE;
                }
                continue;
            }
            _tcscpy(tsFinalSource + ccSection, ptsName);

            // Store the full destination in the file list
            pcs->SetDestination(ptsDestFinal, i);

            //Finally we have the filenames constructed, now try
            //the CopyFile operation

            BOOL fPath = FALSE;
            ULONG ulVersion = 1;
            TCHAR tsCollision[MAX_PATH + 1];
            INT_PTR ccExt;
            TCHAR *ptsDestOriginal = ptsDestFinal;

            if (DebugOutput)
            {
                Win32Printf(LogFile, "Copying %s to %s\r\n", tsFinalSource, ptsDestFinal);
            }

            while (!CopyFile(tsFinalSource,
                             ptsDestFinal,
                             TRUE))
            {
                dwErr = GetLastError();

                if (dwErr == ERROR_PATH_NOT_FOUND)
                {
                    if (fPath)
                    {
                        //We already tried to create the path, so something
                        //else must be wrong.  Punt-arooney.
                        break;
                    }

                    dwErr = ERROR_SUCCESS;

                    TCHAR *ptsPos;
                    DWORD dwPos;
                    //Try to create all the necessary directories
                    TCHAR ptsDirectory[MAX_PATH + 1];

                    // ptsDestFinal was built inside this function and verified to 
                    // be less than MAX_PATH in length
                    _tcscpy(ptsDirectory, ptsDestFinal); 
                    dwPos = 0;

                    // Skip any leading drive specifier.
                    if (ptsDirectory[0] == TEXT('\\'))
                        dwPos = 1;
                    else if (ptsDirectory[0] != 0 &&
                             ptsDirectory[1] == TEXT(':'))
                        if (ptsDirectory[2] == TEXT('\\'))
                            dwPos = 3;
                        else
                            dwPos = 2;

                    //Create every directory along this path
                    while (ptsPos = _tcschr(ptsDirectory + dwPos, TEXT('\\')))
                    {
                        *ptsPos = 0;
                        //Create the directory

                        if (!CreateDirectory(ptsDirectory,
                                             NULL))
                        {
                            dwErr = GetLastError();
                            if (dwErr != ERROR_ALREADY_EXISTS)
                            {
                                break;
                            }
                            dwErr = ERROR_SUCCESS;
                        }

                        //Put the backslash back in
                        *ptsPos = TEXT('\\');
                        //Update dwLen
                        dwPos = ptsPos - ptsDirectory + 1;
                    }
                    if (dwErr)
                        break;
                    fPath = TRUE;
                }
                else if (dwErr == ERROR_FILE_EXISTS)
                {
                    TCHAR tsSquigs[MAX_PATH];
                    TCHAR *ptsDestSquig;
                    INT_PTR ccSquig;

                    //Add squiggles until we get an OK name.
                    if (ptsDestFinal != tsCollision)
                    {
                        TCHAR *ptsDestExt;

                        //First time
                        ptsDestExt = _tcsrchr(ptsDestOriginal, TEXT('.'));
                        if (ptsDestExt == NULL)
                        {
                            //No extension, just tack onto the end.
                            ccExt = _tcslen(ptsDestOriginal);
                        }
                        else 
                        {
                            ccExt = ptsDestExt - ptsDestOriginal;
                        }

                        // ptsDestOriginal was built inside this function and verified to 
                        // be less than MAX_PATH in length
                        _tcscpy(tsCollision, ptsDestOriginal);
                        ptsDestFinal = tsCollision;

                        // temporarily terminate the original to find the squig.
                        if( ptsDestExt != NULL )
                          *ptsDestExt = TEXT('\0');
                        
                        ptsDestSquig = _tcsrchr(ptsDestOriginal, TEXT('('));
                        if( ptsDestSquig == NULL )
                        {
                          ccSquig = ccExt;
                        }
                        else
                        {
                          ccSquig = ptsDestSquig - ptsDestOriginal;
                        }
                        
                        // put the period back where we took it off.
                        if( ptsDestExt != NULL )
                          *ptsDestExt = TEXT('.');
                        
                    }
                    wsprintf(tsSquigs,
                             TEXT("(%lu)"),
                             ulVersion++);
                    if (_tcslen(ptsDestOriginal) + _tcslen(tsSquigs) > MAX_PATH)
                    {
                        Win32PrintfResource(LogFile,
                                            IDS_FILE_COPYERROR,
                                            tsFinalSource);
                        if (Verbose)
                        {
                            Win32Printf(STDERR,
                                        "Could Not Copy To Too Long Destination Filename %s\r\n",
                                        ptsDestOriginal);
                        }
                        if (dwReturnUp == ERROR_SUCCESS)
                        {
                            dwReturnUp = ERROR_FILENAME_EXCED_RANGE;
                        }
                        continue;
                    }
                    wsprintf(tsCollision + ccSquig,
                             TEXT("%s%s"),
                             tsSquigs,
                             ptsDestOriginal + ccExt);

                    //Go back around and try again.
                }
                else
                {
                    Win32PrintfResource(LogFile,
                                        IDS_FILE_COPYERROR,
                                        tsFinalSource);
                    if (Verbose)
                    {
                        Win32Printf(STDERR,
                                    "Error %lu trying to copy %s to %s\r\n",
                                    dwErr,
                                    tsFinalSource,
                                    ptsDestFinal);
                    }
                    dwReturnUp = dwErr;
                    break;
                }
            }
            if (ptsDestFinal == tsCollision)
            {
                dwErr = pcs->SetDestination(tsCollision, i);
                Win32Printf(LogFile,
                            "Filename collision on %s, file renamed to %s\r\n",
                            ptsDestOriginal,
                            ptsDestFinal);
            }

            //Check if the file has a .lnk extension.
            TCHAR *ptsLastDot;
            ptsLastDot = _tcsrchr(ptsDestFinal, TEXT('.'));
            if (ptsLastDot != NULL)
            {
                if (_tcsicmp(ptsLastDot + 1, TEXT("lnk")) == 0)
                {
                    //It's a link, try to fix it.  Ignore errors.
                    FixShellShortcut(ptsDestFinal);
                }
            }
        }
        pcs = pcs->GetNextSection();
    }

    return dwReturnUp;
}


DWORD ParseInputFile(HINF hi)
{
    DWORD dwErr;
    CSection *pcs;
    BOOL fMapping = FALSE;
    INFCONTEXT ic;
    INFCONTEXT icDestinationDirs;
    INFCONTEXT icDirectoryMapping;
    TCHAR tsFirstDestKey[MAX_PATH + 1];
    TCHAR tsFirstMapping[10];

    dwErr = ProcessSpecialDirs(hi);
    if (dwErr)
        return dwErr;

    dwErr = ProcessRules(hi);
    if (dwErr)
        return dwErr;

    if (!SetupFindFirstLine(hi,
                            COPYFILE_SECTION,
                            NULL,
                            &ic))
    {
        dwErr = GetLastError();

        if (dwErr == ERROR_LINE_NOT_FOUND)
        {
            if (Verbose)
                Win32Printf(LogFile,
                            "Warning:  No [Copy These Files] section found.\r\n");
            return ERROR_SUCCESS;
        }
        
        Win32PrintfResource(LogFile,
                            IDS_SECTION_NAME_NOT_FOUND,
                            COPYFILE_SECTION);
        if (Verbose)
            Win32Printf(STDERR,
                        "SetupFindFirstLine failed with %lu\r\n",
                        dwErr);
        return dwErr;
    }


    if (!SetupFindFirstLine(hi,
                            DESTINATIONDIRS_SECTION,
                            NULL,
                            &icDestinationDirs))
    {
        dwErr = GetLastError();
        Win32PrintfResource(LogFile,
                            IDS_SECTION_NAME_NOT_FOUND,
                            DESTINATIONDIRS_SECTION);
        if (Verbose)
            Win32Printf(STDERR,
                        "SetupFindFirstLine failed with %lu\r\n",
                        dwErr);
        return dwErr;
    }

    //Get the key for the first line, we'll need it later.
    if (!SetupGetStringField(&icDestinationDirs,
                             0,
                             tsFirstDestKey,
                             MAX_PATH + 1,
                             NULL))
    {
        //Error
        dwErr = GetLastError();
        Win32PrintfResource(LogFile, IDS_INF_ERROR);
        if (Verbose)
            Win32Printf(STDERR,
                        "SetupGetStringField couldn't get "
                        "first line in %s\r\n",
                        DESTINATIONDIRS_SECTION);
        return dwErr;
    }


    if (SetupFindFirstLine(hi,
                            DIRECTORYMAPPING_SECTION,
                            NULL,
                            &icDirectoryMapping))
    {
        fMapping = TRUE;
        //Get the first key, we'll need it later.

        if (!SetupGetStringField(&icDirectoryMapping,
                                 0,
                                 tsFirstMapping,
                                 10,
                                 NULL))
        {
            //Error
            dwErr = GetLastError();
            Win32PrintfResource(LogFile, IDS_INF_ERROR);
            if (Verbose)
                Win32Printf(STDERR,
                            "SetupGetStringField couldn't get "
                            "first line in %s, error %lX\r\n",
                            DIRECTORYMAPPING_SECTION,
                            dwErr);
            return dwErr;
        }

    }
    else
    {
        //Ignore errors here, this section is optional
    }

    do
    {
        DWORD cFields;
        cFields = SetupGetFieldCount(&ic);
        TCHAR buf[MAX_PATH + 1];

        if (cFields != 1)
        {
            Win32PrintfResource(LogFile, IDS_INF_ERROR);
            return ERROR_INVALID_PARAMETER;
        }

        if (!SetupGetStringField(&ic,
                                 0,
                                 buf,
                                 MAX_PATH + 1,
                                 NULL))
        {
            dwErr = GetLastError();
            Win32PrintfResource(LogFile, IDS_INF_ERROR);
            if (Verbose)
                Win32Printf(STDERR,
                            "SetupGetStringField failed with %lu\r\n",
                            dwErr);
            return dwErr;
        }

        dwErr = AddLoadFileSection(hi, buf, &pcs);
        if (dwErr)
            return dwErr;


        if (fMapping)
        {
            INFCONTEXT icMap;
            TCHAR tsMapping[MAX_PATH + 1];

            //Find the destination path for this directory.

            //First we have to check the first line, because
            // of SetupFindNextMatchLine

            if (_tcscmp(tsFirstDestKey, pcs->GetSectionTitle()) == 0)
            {
                //It's the first line
                icMap = icDestinationDirs;
            }
            else if (!SetupFindNextMatchLine(&icDestinationDirs,
                                             pcs->GetSectionTitle(),
                                             &icMap))
            {
                //This is an error - we should have output this line
                //ourselves in scanstate.
                dwErr = GetLastError();
                Win32PrintfResource(LogFile, IDS_INF_ERROR);
                if (Verbose)
                    Win32Printf(STDERR,
                                "SetupFindNextMatch couldn't find "
                                "destination dir for %s\r\n",
                                pcs->GetSectionTitle());
                return dwErr;
            }

            if (!SetupGetStringField(&icMap,
                                     1,
                                     tsMapping,
                                     MAX_PATH + 1,
                                     NULL))
            {
                //Error, malformed INF
                dwErr = GetLastError();
                Win32PrintfResource(LogFile, IDS_INF_ERROR);
                if (Verbose)
                    Win32Printf(STDERR,
                                "SetupGetIntField couldn't get "
                                "destination dir for %s\r\n",
                                pcs->GetSectionTitle());
                return dwErr;
            }

            //Now look this up in the DirectoryMapping section
            if (_tcscmp(tsFirstMapping, tsMapping) == 0)
                icMap = icDirectoryMapping;
            if ((_tcscmp(tsFirstMapping, tsMapping) == 0) ||
                (SetupFindNextMatchLine(&icDirectoryMapping,
                                        tsMapping,
                                        &icMap)))
            {
                TCHAR bufDest[MAX_PATH + 1];
                if (!SetupGetStringField(&icMap,
                                         1,
                                         bufDest,
                                         MAX_PATH + 1,
                                         NULL))
                {
                    //Error
                    dwErr = GetLastError();
                    Win32PrintfResource(LogFile, IDS_INF_ERROR);
                    if (Verbose)
                        Win32Printf(STDERR,
                                    "SetupGetStringField couldn't get "
                                    "directory mapping for %s\r\n",
                                    tsMapping);
                    return dwErr;
                }
                dwErr = pcs->SetSectionDest(bufDest);
                if (dwErr)
                {
                    return dwErr;
                }
            }
            else
            {
                //Fall through
            }

        }


        if ((pcs->GetSectionDest())[0] == 0)
        {
            //Check for implicit relocation, for special directories
            TCHAR bufMacro[MAX_PATH + 1];
            TCHAR *ptsFinal;
            const TCHAR *ptsSectionTitle = pcs->GetSectionTitle();
            
            if (_tcslen(ptsSectionTitle) > MAX_PATH)
            {
                if (DebugOutput)
                    Win32Printf(LogFile, "Error: ptsSectionTitle too long %s\r\n", ptsSectionTitle);
                return ERROR_FILENAME_EXCED_RANGE;
            }
            _tcscpy(buf, ptsSectionTitle);
            dwErr = g_csdCurrent.ExpandMacro(buf, bufMacro, &ptsFinal, TRUE);
            if (dwErr)
                return dwErr;
            
            //Compare to section path - if they're different, set the
            //section destination to the new section
            if (_tcsicmp(ptsFinal, pcs->GetSectionPath()) != 0)
            {
                dwErr = pcs->SetSectionDest(ptsFinal);
                if (dwErr)
                {
                    return dwErr;
                }
            }
        }
        
        if ((pcs->GetSectionDest())[0] == 0)
        {
            dwErr = pcs->SetSectionDest(pcs->GetSectionPath());
            if (dwErr)
            {
                return dwErr;
            }
        }
    }
    while (SetupFindNextLine(&ic, &ic));

    return ERROR_SUCCESS;
}


//---------------------------------------------------------------
DWORD LoadFiles()
{
    DWORD dwErr = ERROR_SUCCESS;

    if (UserPath == NULL)
    {
        UserPath = (TCHAR *) malloc(MAX_PATH + 1);
        if (UserPath == NULL)
        {
            Win32PrintfResource(LogFile, IDS_NOT_ENOUGH_MEMORY);
            dwErr = ERROR_OUTOFMEMORY;
            return dwErr;
        }
        
        //We need this but it hasn't been set in LoadUser, so get the
        //USERPROFILE variable for the current user and put it in there.
        dwErr = GetEnvironmentVariable(TEXT("USERPROFILE"),
                                       UserPath,
                                       MAX_PATH + 1);
        if (dwErr == 0)
        {
            //Fatal error.
            Win32PrintfResource(LogFile, IDS_NOT_ENOUGH_MEMORY);
            dwErr = ERROR_OUTOFMEMORY;
            return dwErr;
        }
    }
                                       
    dwErr = g_csdCurrent.InitForUser(CurrentUser);
    if (dwErr)
        return dwErr;

    if (DebugOutput)
    {
        for (ULONG i = 0; i < g_csdCurrent.GetDirectoryCount(); i++)
        {
            if (g_csdCurrent.GetDirectoryPath(i) != NULL)
            {
                Win32Printf(LogFile,
                            "%s=%s\r\n",
                            g_csdCurrent.GetDirectoryName(i),
                            g_csdCurrent.GetDirectoryPath(i));
            }
        }
        Win32Printf(LogFile, "\r\n");
    }

    dwErr = ParseInputFile(InputInf);

    if (dwErr)
        return dwErr;

    //If CopyFiles is FALSE, do nothing
    if (!CopyFiles)
        return ERROR_SUCCESS;

    dwErr = CopyAllFiles();
    if (dwErr)
        return dwErr;

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\loadstate\loadsys.cxx ===
//--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999 - 2000.
//
//
// File:        loadsys
//
// Contents:    Load system settings.
//
//---------------------------------------------------------------

#include "loadhead.cxx"
#pragma hdrstop

#include <common.hxx>
#include <stdlib.h>
#include <objerror.h>
#include <loadstate.hxx>
#include <bothchar.hxx>
#include <winnetwk.h>
#include <lmshare.h>
#include <lmaccess.h>
#include <winspool.h>
#include <winuserp.h> // in \nt\private\inc
#include <wingdip.h>  // in \nt\private\inc
#include <ntlsa.h>    // for domain/workgroup membership
#include <ntexapi.h>  // for NtSetDefaultLocale
#include <devguid.h>  // for modem device class
#include <ras.h>
#include <raserror.h>

#include <loadras.hxx> // State Migration private RAS Phonebook APIs


const TCHAR NETSHARES_SECTION[]  = TEXT("NetShares");
const TCHAR PRINTERS_SECTION[]   = TEXT("Printers");
const TCHAR PRINTER_DRIVER_MAP[] = TEXT("Printer Driver Mapping");
const TCHAR RAS_SECTION[]        = TEXT("RAS");
const TCHAR ACCESS_SECTION[]     = TEXT("Accessibility");
const TCHAR DESKTOP_SECTION[]    = TEXT("Desktop");
const TCHAR KEYBOARDLAYOUT_MAP[] = TEXT("Keyboard.Layout.Mappings");
const TCHAR REGKEY_PRELOAD[]     = TEXT("Keyboard Layout\\Preload");
const TCHAR REGKEY_SUBSTITUTES[] = TEXT("Keyboard Layout\\Substitutes");
const TCHAR REGKEY_INTL[]        = TEXT("Control Panel\\International");
const TCHAR SCHED_PARAMS[]       = TEXT(" /s /p");


const DWORD INTL_NT4 = 0x200;  // platform ID from intl.inf
const DWORD INTL_95 = 0x001;   // platform ID from intl.inf
const DWORD INTL_98 = 0x002;   // platform ID from intl.inf
const int   SIZE_128 = 128;    // for user locale strings

// Types and defines
#define IS_IME_KBDLAYOUT(hkl) ((HIWORD((ULONG_PTR)(hkl)) & 0xf000) == 0xe000)
#define ChkErr(s) if ((dwErr = (s)) != ERROR_SUCCESS) goto Err;
#define ChkBoolErr(s) if ((success = (s)) == FALSE) { \
                          dwErr = GetLastError(); \
                          goto Err;\
                      }


#define PRIVATE_RAS            // Define this to use our private 
                               // RasSetEntryProperties implementation.

//
// private structure needed by ConvertRecentDocsMRU
//
typedef struct {
    // Link structure
    WORD wSize;
    //ITEMIDLIST idl; // variable-length struct
    // String, plus three bytes appended to struct
} LINKSTRUCT, *PLINKSTRUCT;

//
// Win95 uses a mix of LOGFONTA and a weird 16-bit LOGFONT
// structure that uses SHORTs instead of LONGs.
//

typedef struct {
    SHORT lfHeight;
    SHORT lfWidth;
    SHORT lfEscapement;
    SHORT lfOrientation;
    SHORT lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    char lfFaceName[LF_FACESIZE];
} SHORT_LOGFONT, *PSHORT_LOGFONT;

#define COLOR_MAX_V1 25
#define COLOR_MAX_V3 25
#define COLOR_MAX_V4 29
#define COLOR_MAX_NT 29     // this is a modified version 2 format, similar to 4

//
// NT uses only UNICODE structures, and pads the members
// to 32-bit boundaries.
//

typedef struct {
    SHORT version;              // 2 for NT UNICODE
    WORD  wDummy;               // for alignment
    NONCLIENTMETRICSW ncm;
    LOGFONTW lfIconTitle;
    COLORREF rgb[COLOR_MAX_NT];
} SCHEMEDATA_NT, *PSCHEMEDATA_NT;

//
// Win95 uses NONCLIENTMETRICSA which has LOGFONTA members,
// but it uses a 16-bit LOGFONT as well.
//

#pragma pack(push)
#pragma pack(1)

typedef struct {
    SHORT version;              // 1 for Win95 ANSI
    NONCLIENTMETRICSA ncm;
    SHORT_LOGFONT lfIconTitle;
    COLORREF rgb[COLOR_MAX_V1];
} SCHEMEDATA_V1, *PSCHEMEDATA_V1;

typedef struct {
    SHORT version;              // 1 for Win95 ANSI

    NONCLIENTMETRICSA ncm;
    SHORT_LOGFONT lfIconTitle;
    COLORREF rgb[COLOR_MAX_V4];
} SCHEMEDATA_V1A, *PSCHEMEDATA_V1A;

typedef struct {
    SHORT version;              // 3 for Win98 ANSI, 4 for portable format
    WORD Dummy;
    NONCLIENTMETRICSA ncm;
    LOGFONTA lfIconTitle;
    COLORREF rgb[COLOR_MAX_V3];
} SCHEMEDATA_V3, *PSCHEMEDATA_V3;

typedef struct {
    SHORT version;              // 4 for Win32 format (whatever that means)
    WORD Dummy;
    NONCLIENTMETRICSA ncm;
    LOGFONTA lfIconTitle;
    COLORREF rgb[COLOR_MAX_V4];
} SCHEMEDATA_V4, *PSCHEMEDATA_V4;

#pragma pack(pop)

typedef struct _APPLET_TIME_ZONE_INFORMATION
{
    LONG       Bias;
    LONG       StandardBias;
    LONG       DaylightBias;
    SYSTEMTIME StandardDate;
    SYSTEMTIME DaylightDate;
} APPLET_TIME_ZONE_INFORMATION;

// RAS api functions
typedef DWORD
(*MRasSetEntryDialParams)(
    IN LPCTSTR lpszPhonebook,
    IN LPRASDIALPARAMS lprasdialparams,
    IN BOOL fRemovePassword);

typedef DWORD
(*MRasGetEntryProperties)(
    IN LPCTSTR lpszPhonebook,
    IN LPCTSTR lpszEntry,
    OUT LPRASENTRYW lpRasEntry,
    OUT LPDWORD lpdwEntryInfoSize,
    OUT LPBYTE lpbDeviceInfo,
    OUT LPDWORD lpdwDeviceInfoSize);

#ifdef PRIVATE_RAS
typedef DWORD
(*MWinState_RasSetEntryProperties)(
  IN LPCWSTR      lpszPhonebook,
  IN LPCWSTR      lpszEntry,
  IN LPRASENTRYW  lpRasEntry,
  IN DWORD        dwcbRasEntry,
  IN LPBYTE       lpbDeviceConfig,
  IN DWORD        dwcbDeviceConfig);
#else  
typedef DWORD
(*MRasSetEntryProperties)(
    IN LPCTSTR lpszPhonebook,
    IN LPCTSTR lpszEntry,
    IN LPRASENTRY lpRasEntry,
    IN DWORD dwEntryInfoSize,
    IN LPBYTE lpbDeviceInfo,
    IN DWORD dwDeviceInfoSize);
#endif
    
// Statics
#ifdef PRIVATE_RAS
static MWinState_RasSetEntryProperties GWinState_RasSetEntryProperties = NULL;
#else
static MRasSetEntryProperties GRasSetEntryProperties = NULL;
#endif
static MRasSetEntryDialParams GRasSetEntryDialParams = NULL;
static MRasGetEntryProperties GRasGetEntryProperties = NULL;

//+---------------------------------------------------------------------------
//
//  Function:   InitializeRasApi
//
//  Synopsis:   Loads rasapi32.dll, if it exists
//
//  Arguments:  none
//
//  Returns:    Appropriate status code
//
//  History:    24-Feb-00   Jay Thaler   Created
//
//----------------------------------------------------------------------------
DWORD InitializeRasApi()
{
  DWORD      result = ERROR_SUCCESS;
  HINSTANCE  rasdll;
  HINSTANCE  loadrasdll;    // State Mig. RAS Wrapper

  //  
  // Load rasapi32.dll
  // If this fails, RAS isn't installed and we won't migrate RAS conectoids
  //
  rasdll = LoadLibraryA( "rasapi32.dll" );
  if (rasdll == NULL)
  {
    result = GetLastError();
    if (Verbose && DebugOutput)
    {
         Win32Printf(STDERR, "Warning: rasapi32.dll not loaded: %d\r\n", result);
    }
    goto cleanup;
  }

  GRasSetEntryDialParams = (MRasSetEntryDialParams)GetProcAddress(rasdll, "RasSetEntryDialParamsW");
  if (GRasSetEntryDialParams == NULL)
  {
      result = GetLastError();
      goto cleanup;
  }

#ifndef PRIVATE_RAS
  GRasSetEntryProperties = (MRasSetEntryProperties)GetProcAddress(rasdll, "RasSetEntryPropertiesW");
  if (GRasSetEntryProperties == NULL)
  {
      result = GetLastError();
      goto cleanup;
  }
#else
  //
  //  Load the private wrapper for RAS APIs
  //
  loadrasdll = LoadLibraryA( "loadras.dll" );
  if (loadrasdll == NULL)
  {
    result = GetLastError();
    if (Verbose && DebugOutput)
    {
         Win32Printf(STDERR, "Warning: loadras.dll not loaded: %d\r\n", result);
    }
    goto cleanup;
  }

  GWinState_RasSetEntryProperties = 
      (MWinState_RasSetEntryProperties)GetProcAddress(loadrasdll, "WinState_RasSetEntryPropertiesW");
  if (GWinState_RasSetEntryProperties == NULL)
  {
      result = GetLastError();
      goto cleanup;
  }
#endif

cleanup:
  if (result != ERROR_SUCCESS)
  {
#ifdef PRIVATE_RAS
      GWinState_RasSetEntryProperties = NULL;
#else
      GRasSetEntryProperties = NULL;
#endif      
      GRasSetEntryDialParams = NULL;
  }
  return result;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetInfField
//
//  Synopsis:   returns an allocated string for current line field #N
//
//  Arguments:  [ppBuffer] -- output buffer
//              [pContext] -- INF file context
//              [nArg] -- argument field number
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD GetInfField (TCHAR **ppBuffer, INFCONTEXT *pContext, DWORD nArg)
{
    ULONG len = 0;
    DWORD dwErr = ERROR_SUCCESS;
    TCHAR *buffer;

    *ppBuffer = NULL;
    if (!SetupGetStringField ( pContext, nArg, NULL, 0, &len ))
        return ERROR_BAD_FORMAT;


    // Allocate a buffer.  Some callers need an extra char for processing
    buffer = (TCHAR *) malloc( (len+1)*sizeof(TCHAR) );
    if (buffer == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        if (!SetupGetStringField( pContext, nArg, buffer, len, &len ))
        {
            free( buffer );
            dwErr = ERROR_BAD_FORMAT;
        }
        else *ppBuffer = buffer;
    }

    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   LogFormatError
//
//  Synopsis:   logs error message in current locale
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD LogFormatError (DWORD dwErr)
{
    DWORD dwRet = ERROR_SUCCESS;
    TCHAR *pcs = NULL;

    if (0 != FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM |
                            FORMAT_MESSAGE_ALLOCATE_BUFFER, NULL,
                            dwErr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                            (TCHAR*) &pcs, 0, NULL))
    {
        dwRet = Win32Printf (LogFile, "%ws\r\n", pcs);
        LocalFree (pcs);
    }
    else dwRet = GetLastError();

    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsDefaultShare
//
//  Synopsis:   check if share name is a known system default share
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

BOOL IsDefaultShare (TCHAR *buffer)
{
    ULONG ul = lstrlen(buffer);
    if (buffer[ul - 1] == '$')
    {
        if (lstrcmp (buffer, TEXT("IPC$")) == 0) return TRUE;
        if (lstrcmp (buffer, TEXT("ADMIN$")) == 0) return TRUE;
        if (ul == 2 && IsCharAlpha (buffer[0])) return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   LoadNetShares
//
//  Synopsis:   loads network share settings
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//  NOTES:      This code could be updated to do the following:
//                 1. Get the correct disk type from the field instead of
//                    using STYPE_DISKTREE.
//                 2. Store (and retrieve) the correct max user count
//                 3. Handle custom access permissions
//
//----------------------------------------------------------------------------

DWORD LoadNetShares ()
{
    DWORD dwErr = ERROR_SUCCESS;
    INFCONTEXT  context;
    NETRESOURCE nr;
    BOOL success;
    TCHAR * buffer = NULL;
    TCHAR * buffer2 = NULL;

    success = SetupFindFirstLine(InputInf, NETSHARES_SECTION, NULL, &context);
    if (!success)
        return ERROR_SUCCESS;  // line not found

    do
    {
        BOOL fPersist = FALSE;
        BOOL bIgnore = FALSE;

        ZeroMemory (&nr, sizeof(nr));
        // loop through all the network shares and connect to them

        dwErr = GetInfField (&buffer, &context, 1);
        if (dwErr != ERROR_SUCCESS)
        {
            Win32Printf (LogFile, "Missing share name in [%ws]\r\n", 
                                   NETSHARES_SECTION);
            break;
        }
        nr.dwType = RESOURCETYPE_DISK;
        nr.lpLocalName = buffer;

        dwErr = GetInfField (&buffer2, &context, 2);
        if (dwErr != ERROR_SUCCESS)
        {
            Win32Printf (LogFile, "Missing remote name in [%ws]\r\n",
                                   NETSHARES_SECTION);
            free (buffer);
            break;
        }
        nr.lpRemoteName = buffer2;

        if (buffer2[0] != L'\0' && buffer2[0] == L'\\' && buffer2[1] == L'\\')
        {
            TCHAR *buffer3 = NULL;
            if (ERROR_SUCCESS == GetInfField (&buffer3, &context, 3))
            {
                if (lstrcmp (buffer3, TEXT("persist")) == 0)
                    fPersist = TRUE;
                free (buffer3);
            }
            dwErr = WNetAddConnection2 (&nr, NULL, NULL,
                                    fPersist ? CONNECT_UPDATE_PROFILE : 0);
        }
        else
        {
            TCHAR *buffer3 = NULL;
            TCHAR *buffer4 = NULL;
            SHARE_INFO_2 si2;
            DWORD dwPerm = ACCESS_READ;  // default access

            if (!IsDefaultShare(buffer))  // ignore system shares
            {

                dwErr = GetInfField (&buffer3, &context, 3);
                if (dwErr == ERROR_SUCCESS)
                {
                    dwPerm = _wtoi (buffer3);   // share permission bits
                }

                dwErr = GetInfField (&buffer4, &context, 4);
                ZeroMemory (&si2, sizeof(si2));
                si2.shi2_netname = buffer;
                si2.shi2_type = STYPE_DISKTREE;  // should get type from field
                si2.shi2_remark = buffer4;
                si2.shi2_permissions = dwPerm;

                if (lstrlen(buffer2) == 2 && buffer2[1] == ':')
                    lstrcat ((TCHAR*)buffer2, TEXT("\\"));

                si2.shi2_path = buffer2;
                si2.shi2_max_uses = SHI_USES_UNLIMITED; // should get number

                // should handle custom access permissions here

                dwErr = NetShareAdd (NULL, 2, (BYTE *) &si2, NULL);

                if (buffer3 != NULL)
                    free (buffer3);
                if (buffer4 != NULL)
                    free (buffer4);
            }
            else bIgnore = TRUE;
        }

        if (dwErr != ERROR_SUCCESS)
        {
            LogFormatError (dwErr);  // log error and keep on going
            dwErr = ERROR_SUCCESS;
        }
        else  // log that the share was successfully added
        {
            Win32Printf (LogFile, "NetShare %ws %ws %ws\r\n", buffer, buffer2,
                   bIgnore ? TEXT("not processed") : TEXT("added"));
        }

        free (buffer);
        free (buffer2);

        if (dwErr != ERROR_SUCCESS)
           break;

        // Advance to the next line.
        success = SetupFindNextLine( &context, &context );
    } while (success);

    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   TranslatePrinterDriver
//
//  Synopsis:   converts Win9x printer driver names to NT driver names
//
//  Arguments:  [pcs9x] -- Win9x printer driver name
//              [pcsNT] -- NT printer driver name
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD TranslatePrinterDriver (WCHAR *pcs9x, WCHAR **ppcsNT)
{
    DWORD dwErr = ERROR_SUCCESS;
    HINF hInf;
    INFCONTEXT InfContext;

    *ppcsNT = NULL;

    //
    // See in prtupg9x.inf to see if the driver has a different name on NT
    //
    if ( SetupFindFirstLine(InputInf,
                            PRINTER_DRIVER_MAP,
                            pcs9x,
                            &InfContext) )
    {
        dwErr = GetInfField (ppcsNT, &InfContext, 1);
    }

    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   LoadPrinters
//
//  Synopsis:   loads printers settings
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD LoadPrinters ()
{
    DWORD dwErr = ERROR_SUCCESS;

    INFCONTEXT  context;
    BOOL success;
    TCHAR * buffer = NULL;
    DWORD dwReturnUp = ERROR_SUCCESS;

    success = SetupFindFirstLine(InputInf, PRINTERS_SECTION, NULL, &context);
    if (!success)
        return ERROR_SUCCESS;  // line not found

    do
    {
        dwErr = GetInfField (&buffer, &context, 1);
        if (dwErr != ERROR_SUCCESS)
        {
            Win32PrintfResource (LogFile, IDS_PRINTER_MISSINGNAME,
                                  PRINTERS_SECTION);
            break;
        }

        if (!AddPrinterConnection (buffer)) 
        {
            dwErr = GetLastError();
            LogFormatError (dwErr);  // log error and keep on going
            dwReturnUp = dwErr;
            dwErr = ERROR_SUCCESS;
        } 
        else 
        {
            Win32PrintfResource (LogFile, IDS_PRINTER_MIGRATED,
                                 buffer, buffer);
        }

        free (buffer);    buffer = NULL;

        // Advance to the next line.
        success = SetupFindNextLine( &context, &context );
    }
    while (success);

    if (buffer)  free (buffer);

    return dwReturnUp;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetOSMajorID
//
//  Synopsis:   translate GetVersion IDs to INTL IDs
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD GetOSMajorID ()
{
    if (SourceVersion & 0x80000000)
    {
        if ((SourceVersion & 0xFFFF) == 0x004)
            return INTL_NT4;
    }
    else if ((SourceVersion & 0xFFFF) == 0xA04)
        return INTL_98;
    else if ((SourceVersion & 0xFFFF) == 0x004)
        return INTL_95;

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsInExcludeList
//
//  Synopsis:   check if langid is in the exclude list to block migration
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

BOOL IsInExcludeList( HINF Inf, LANGID LangID)
{
    TCHAR LangIDStr[9];
    TCHAR *Field;
    INFCONTEXT InfContext;
    int iOSID;
    int iLangID;

    wsprintf(LangIDStr,TEXT("0000%04X"),LangID);
    if (SetupFindFirstLine( Inf,
                            TEXT("ExcludeSourceLocale"),
                            LangIDStr,
                            &InfContext ))
    {
        do {
            //
            // if in excluded field, this is not what we want
            //
            if (ERROR_SUCCESS == SetupGetIntField (&InfContext, 0, &iLangID) &&
                (iLangID == LangID))
            {

            //
            // if it is in major version list, we also got what we want
            //
                if (ERROR_SUCCESS == SetupGetIntField (&InfContext, 1, &iOSID))
                {
                    if (iOSID & GetOSMajorID())
                    {
                        return TRUE;
                    }
                }
            }
        } while ( SetupFindNextLine(&InfContext, &InfContext));
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CheckLanguageVersion
//
//  Synopsis:   verifies that source and target languages allow migration
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

BOOL CheckLanguageVersion (HINF Inf, LANGID SourceLangID, LANGID TargetLangID)
{
    TCHAR SourceLangIDStr[9];
    LANGID SrcLANGID;
    TCHAR * Field;
    INFCONTEXT InfContext;
    int iOSID;
    int iLangID;

    if (SourceLangID == 0 || TargetLangID == 0)
    {
        return TRUE;
    }
    if (SourceLangID == TargetLangID)
    {
        //
        // special case, for Middle East version,
        // NT5 is localized build but NT4 is not
        //
        // they don't allow NT5 localized build to upgrade NT4,
        // although they are same language
        //
        // so we need to exclude these
        //
        return ((IsInExcludeList(Inf, SourceLangID) == FALSE));
    }
    //
    // if Src != Dst, then we need to look up inf file to see
    //
    // if we can open a backdoor for Target language
    //

    //
    // find alternative SourceLangID
    //

    wsprintf(SourceLangIDStr,TEXT("0000%04X"),SourceLangID);

    if (SetupFindFirstLine( Inf,
                            TEXT("AlternativeSourceLocale"),
                            SourceLangIDStr,
                            &InfContext ))
    {
        do {
            //
            // Check if we found alternative locale
            //
            //
            if (ERROR_SUCCESS == SetupGetIntField (&InfContext, 0, &iLangID) &&
                (iLangID == SourceLangID))
            {
                if (ERROR_SUCCESS == GetInfField (&Field, &InfContext, 1))
                {
                    LANGID AltTargetLangID = LANGIDFROMLCID(
                                             _tcstoul(Field,NULL,16));
                    free (Field);
                    if (TargetLangID != AltTargetLangID)
                    {
                        continue;
                    }

                }
            

                //
                // We are here if we found alternative target lang,
                //
                // now check the version criteria
                //
                //
                // if it is in major version list, we also got what we want
                //
                if (ERROR_SUCCESS == SetupGetIntField (&InfContext, 2, &iOSID))
                {
                    if (iOSID & GetOSMajorID())
                    {
                        return TRUE;
                    }
                }
            }
        } while ( SetupFindNextLine(&InfContext,&InfContext));
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   LoadVerifyOSLang
//
//  Synopsis:   verifies that source and target languages allow migration
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD LoadVerifyOSLang ()
{
    DWORD dwErr = ERROR_SUCCESS;
    INFCONTEXT InfContext;
    LANGID langidLoad = 0;
    LANGID langidScan = 0;
    UINT  errorline;
    TCHAR  tcsInf [MAX_PATH+1];

    if (0 == GetWindowsDirectory ((TCHAR*)tcsInf, MAX_PATH))
        return GetLastError();

    // This inf file must exist for all Windows 2000 localized versions
    _tcsncat (tcsInf, TEXT("\\inf\\intl.inf"), MAX_PATH-_tcslen(tcsInf));

    HINF Inf = SetupOpenInfFile(tcsInf, NULL, INF_STYLE_WIN4, &errorline );

    if (INVALID_HANDLE_VALUE == Inf)
    {
        dwErr = GetLastError();
        Win32Printf (LogFile, "%systemroot%\\system\\inf\\intl.inf"
                              "could not be opened Error=%d\r\n", dwErr);
    }
    else
    {
        if (SetupFindFirstLine( Inf,
                            TEXT("DefaultValues"),
                            TEXT("Locale"),
                            &InfContext ))
        {
            TCHAR *pLoadLang = NULL;
            dwErr = GetInfField (&pLoadLang, &InfContext, 1);
            if (ERROR_SUCCESS == dwErr)
            {
                langidLoad = (LANGID)_tcstoul(pLoadLang,NULL,16);
                free (pLoadLang);

                if ( SetupFindFirstLine(InputInf,
                            SOURCE_SECTION,
                            LOCALE,
                            &InfContext) )
                {
                    TCHAR *pScanLang = NULL;
                    dwErr = GetInfField (&pScanLang, &InfContext, 1);
                    if (ERROR_SUCCESS == dwErr)
                    {
                        langidScan = (LANGID)_tcstoul(pScanLang,NULL,16);
                        free (pScanLang);

                        if (FALSE == CheckLanguageVersion(Inf,
                                               langidScan,langidLoad))
                        {
                            dwErr = ERROR_INSTALL_LANGUAGE_UNSUPPORTED;
                            LogFormatError (dwErr);
                        }
                    }
                    else
                    {
                        Win32Printf (LogFile, "locale missing in [%ws]\r\n",
                                     SOURCE_SECTION);
                        LogFormatError (dwErr);
                    }
                }
            }
        }
        else
        {
            dwErr = GetLastError();
            Win32Printf (LogFile, "intl.inf: default locale missing\r\n");
            LogFormatError (dwErr);
        }
        SetupCloseInfFile (Inf);
    }

    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   MigrateKeyboardSubstitutes
//
//  Synopsis:   changes the user keyboard layouts
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD MigrateKeyboardSubstitutes (TCHAR *tcsName)
{
    DWORD dwErr = ERROR_SUCCESS;
    ULONG ulOrig = _tcstoul(tcsName, NULL, 16);
    ULONG ulLang = LOWORD(ulOrig);
    HKEY hKey = NULL;
    BOOL fFound = FALSE;

    if (IS_IME_KBDLAYOUT(ulOrig) || ulLang == ulOrig)
        return ERROR_SUCCESS;

    if (ERROR_SUCCESS == RegOpenKeyEx (
                           CurrentUser ? CurrentUser : HKEY_CURRENT_USER,
                           REGKEY_SUBSTITUTES,
                           NULL,
                           KEY_READ | KEY_WRITE,
                           &hKey))
    {
        DWORD dwIndex = 0;
        ULONG ulIndex;
        ULONG ulValue;
        TCHAR tcsIndex[KL_NAMELENGTH];
        TCHAR tcsValue[KL_NAMELENGTH];

        while (dwErr == ERROR_SUCCESS)
        {
            DWORD cbIndex = sizeof (tcsIndex);
            DWORD cbValue = sizeof(tcsValue);
            dwErr = RegEnumValue (hKey, dwIndex, tcsIndex, &cbIndex,
                                  NULL, NULL, (BYTE*) tcsValue, &cbValue);

            if (ERROR_SUCCESS == dwErr)
            {
                ulIndex = _tcstoul(tcsIndex, NULL, 16);
                ulValue = _tcstoul(tcsValue, NULL, 16);
                if (ulIndex == ulLang && ulValue == ulOrig)
                {
                    fFound = TRUE;
                    break;
                }
            }
            dwIndex++;
        }
        if (dwErr == ERROR_NO_MORE_ITEMS)
            dwErr = ERROR_SUCCESS;

        if (!fFound)  // add a new value
        {
            wsprintf (tcsIndex, TEXT("%08x"), ulLang);
            dwErr = RegSetValueEx (hKey,  tcsIndex, 0, REG_SZ, (BYTE*)tcsName,
                                   (_tcslen(tcsName)+1)*sizeof(TCHAR));
        }

        RegCloseKey (hKey);
    }
    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   MigrateKeyboardPreloads
//
//  Synopsis:   changes the user keyboard layouts
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD MigrateKeyboardPreloads (TCHAR *tcsName)
{
    DWORD dwErr = ERROR_SUCCESS;
    ULONG ul = _tcstoul(tcsName, NULL, 16);
    HKEY hKey = NULL;
    BOOL fFound = FALSE;
    
    // look for a preload with this locale
    if (!IS_IME_KBDLAYOUT(ul))
        ul = LOWORD(ul);

    if (ERROR_SUCCESS == RegOpenKeyEx (
                           CurrentUser ? CurrentUser : HKEY_CURRENT_USER,
                           REGKEY_PRELOAD,
                           NULL,
                           KEY_READ | KEY_WRITE,
                           &hKey))
    {
        DWORD dwIndex = 0;
        ULONG ulIndexMax = 0;
        ULONG ulIndex;
        ULONG ulValue;
        TCHAR tcsIndex[KL_NAMELENGTH];
        TCHAR tcsValue[KL_NAMELENGTH];

        while (dwErr == ERROR_SUCCESS)
        {
            DWORD cbIndex = sizeof (tcsIndex);
            DWORD cbValue = sizeof(tcsValue);
            dwErr = RegEnumValue (hKey, dwIndex, tcsIndex, &cbIndex,
                                  NULL, NULL, (BYTE*)tcsValue, &cbValue);

            if (ERROR_SUCCESS == dwErr)
            {
                ulIndex = _tcstoul(tcsIndex, NULL, 10);
                if (ulIndex > ulIndexMax)
                    ulIndexMax = ulIndex;
                ulValue = _tcstoul(tcsValue, NULL, 16);
                if (ulValue == ul)
                {
                    fFound = TRUE;
                    break;
                }
            }
            dwIndex++;
        }
        if (dwErr == ERROR_NO_MORE_ITEMS)
            dwErr = ERROR_SUCCESS;

        if (!fFound)  // add a new value
        {
            wsprintf (tcsIndex, TEXT("%d"), ulIndexMax+1);
            wsprintf (tcsValue, TEXT("%08x"), ul);
            dwErr = RegSetValueEx (hKey,  tcsIndex, 0, REG_SZ, (BYTE*)tcsValue, 
                                   (_tcslen(tcsValue)+1)*sizeof(TCHAR));
        }
        RegCloseKey (hKey);
    }
    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   LoadKeyboardLayouts
//
//  Synopsis:   changes the user keyboard layouts
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD LoadKeyboardLayouts ()
{
    DWORD dwErr = ERROR_SUCCESS;
    INFCONTEXT InfContext;
    BOOL fFound;

    // translate input locales if source is Win9x
    if (!(SourceVersion & 0x80000000))
        return ERROR_SUCCESS;

    if (SetupFindFirstLine(InputInf, SOURCE_SECTION, INPUTLOCALE, &InfContext))
    {
        TCHAR *pLayout = NULL;
        UINT   iLayouts = SetupGetFieldCount(&InfContext);
        for (UINT i = 1; i <= iLayouts; i++)
        {
            dwErr = GetInfField (&pLayout, &InfContext, i);
            if (ERROR_SUCCESS == dwErr)
            {
                INFCONTEXT InfContext2;
                //
                // See in usermig.inf to see if different ID exists
                //
                if ( SetupFindFirstLine(InputInf,
                            KEYBOARDLAYOUT_MAP,
                            pLayout,
                            &InfContext2) )
                {
                    TCHAR *pMap = NULL;
                    if (ERROR_SUCCESS == GetInfField (&pMap, &InfContext2, 1))
                    {
                        free (pLayout);
                        pLayout = pMap;
                    }
                }

                dwErr = MigrateKeyboardPreloads (pLayout);
                if (ERROR_SUCCESS == dwErr)
                    dwErr = MigrateKeyboardSubstitutes (pLayout);

                if (CurrentUser == HKEY_CURRENT_USER)
                {
                    TCHAR kbname[KL_NAMELENGTH];
                    GetKeyboardLayoutName (kbname);
                    if (i == 1 && lstrcmp(kbname, pLayout) != 0) // load default
                    {
                        ULONG ulLayout = _tcstoul(pLayout, NULL, 16);
                        HKL   hklCurrent = GetKeyboardLayout(0);
                        if (Verbose)
                            printf ("Loading keyboard layout %ws \n", pLayout);

                        HKL hkl = LoadKeyboardLayoutEx (hklCurrent, pLayout,
                               KLF_REORDER | KLF_ACTIVATE | KLF_SETFORPROCESS |
                               KLF_SUBSTITUTE_OK);
                        if (hkl != NULL)
                        { 
                            SystemParametersInfo (SPI_SETDEFAULTINPUTLANG, 0,
                                          (VOID *) &hkl, 0);
                            if (Verbose)
                            {
#ifdef _WIN64
                                printf ("Activated keyboard layout %08I64x\n",hkl);
#else
                                printf ("Activated keyboard layout %08x\n",hkl);
#endif
                            }
                        }
                    }
                    else if (i > 1)  // load the alternates
                    {
                        LoadKeyboardLayout (pLayout, KLF_SUBSTITUTE_OK);
                    }
                }
                free (pLayout);

                if (dwErr != ERROR_SUCCESS)
                    break;
            }
            else
            {
                Win32Printf (LogFile,"Could not read keyboard layout %d\r\n",i);
            }
        }
    }

    if (dwErr != ERROR_SUCCESS)
        Win32Printf (LogFile, "Could not load all keyboard layouts\r\n");
    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   EnumerateModems
//
//  Synopsis:   enumerates the modem devices on the system
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD EnumerateModems (TCHAR *ptsPort, ULONG ulLen)
{
    DWORD dwErr = ERROR_SUCCESS;
    UINT  i = 0;
    BOOL fDetected = FALSE;
    SP_DEVINFO_DATA sdd;

    HDEVINFO hdi = SetupDiGetClassDevs (&GUID_DEVCLASS_MODEM,
                                    NULL,
                                    NULL,
                                    DIGCF_PRESENT );

    if (hdi != INVALID_HANDLE_VALUE)
    {
        ZeroMemory (&sdd, sizeof(sdd));
        sdd.cbSize = sizeof(sdd);
        sdd.ClassGuid = GUID_DEVCLASS_MODEM;

        while (SetupDiEnumDeviceInfo (hdi, i++, &sdd))
        {
            HKEY hKey = SetupDiOpenDevRegKey (hdi,
                                              &sdd,
                                              DICS_FLAG_GLOBAL,
                                              0,
                                              DIREG_DRV,
                                              KEY_READ);
            if (hKey != INVALID_HANDLE_VALUE)
            {
                ULONG ulLenQuery = ulLen;
                dwErr = RegQueryValueEx(hKey,
                                        TEXT("AttachedTo"),
                                        NULL,
                                        NULL,
                                        (BYTE *)ptsPort,
                                        &ulLenQuery);
                RegCloseKey (hKey);

                if (dwErr == ERROR_SUCCESS)  // found a modem
                {
                    fDetected = TRUE;
                    break;
                }
            } 
            else dwErr = GetLastError();
        }
        if (!fDetected)
            dwErr = ERROR_NO_MORE_DEVICES; // no modem detected
    }
    else dwErr = GetLastError();
 
    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RasGetPhoneBookFile
//
//  Synopsis:   determines location of RAS settings in phonebook file
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD RasGetPhoneBookFile(TCHAR *strPhoneBook)
{
    const TCHAR RASPHONE_SUBPATH[] = TEXT("\\ras\\rasphone.pbk");

    if (0 == GetSystemDirectory ((TCHAR*)strPhoneBook, MAX_PATH))
        return GetLastError();

    _tcsncat(strPhoneBook, (TCHAR *) RASPHONE_SUBPATH, 
             MAX_PATH-_tcslen(strPhoneBook));

    return ERROR_SUCCESS;
}



//+---------------------------------------------------------------------------
//
//  Function:   LoadRas
//
//  Synopsis:   create the phonebook file for RAS settings
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD LoadRas()
{
    DWORD dwErr = ERROR_SUCCESS;
    BOOL success;
    INFCONTEXT context;
    RASENTRY RasEntry;
    RASDIALPARAMS RasDialParams;

    success = SetupFindFirstLine(InputInf, RAS_SECTION, NULL, &context);
    if (!success)
        return ERROR_SUCCESS;  // line not found

    do {
        ZeroMemory( &RasEntry, sizeof(RASENTRY) );
        ZeroMemory( &RasDialParams, sizeof(RASDIALPARAMS) );

        RasDialParams.dwSize = sizeof(RASDIALPARAMS);
        RasEntry.dwSize = sizeof(RASENTRY);

        ChkBoolErr( SetupGetStringField( &context, 1,  RasDialParams.szEntryName, 
                                                       RAS_MaxEntryName + 1, NULL) );
        // load RasEntry structure
        ChkBoolErr( SetupGetIntField( &context,    2,  (int*)&RasEntry.dwfOptions) );
        ChkBoolErr( SetupGetIntField( &context,    3,  (int*)&RasEntry.dwCountryID) );
        ChkBoolErr( SetupGetIntField( &context,    4,  (int*)&RasEntry.dwCountryCode) );
        ChkBoolErr( SetupGetStringField( &context, 5,  RasEntry.szAreaCode, 
                                                       RAS_MaxAreaCode + 1, NULL) );
        ChkBoolErr( SetupGetStringField( &context, 6,  RasEntry.szLocalPhoneNumber, 
                                                       RAS_MaxPhoneNumber + 1, NULL) );
        ChkBoolErr( SetupGetIntField( &context,    7,  (int*)&RasEntry.dwAlternateOffset) );
        ChkBoolErr( SetupGetIntField( &context,    8,  (int*)&RasEntry.ipaddr) );
        ChkBoolErr( SetupGetIntField( &context,    9,  (int*)&RasEntry.ipaddrDns) );
        ChkBoolErr( SetupGetIntField( &context,    10, (int*)&RasEntry.ipaddrDnsAlt) );
        ChkBoolErr( SetupGetIntField( &context,    11, (int*)&RasEntry.ipaddrWins) );
        ChkBoolErr( SetupGetIntField( &context,    12, (int*)&RasEntry.ipaddrWinsAlt) );
        ChkBoolErr( SetupGetIntField( &context,    13, (int*)&RasEntry.dwFrameSize) );
        ChkBoolErr( SetupGetIntField( &context,    14, (int*)&RasEntry.dwfNetProtocols) );
        ChkBoolErr( SetupGetIntField( &context,    15, (int*)&RasEntry.dwFramingProtocol) );
        ChkBoolErr( SetupGetStringField( &context, 16, RasEntry.szScript, MAX_PATH, NULL) );
        ChkBoolErr( SetupGetStringField( &context, 17, RasEntry.szAutodialDll, MAX_PATH, NULL) );
        ChkBoolErr( SetupGetStringField( &context, 18, RasEntry.szAutodialFunc, MAX_PATH, NULL) );
        ChkBoolErr( SetupGetStringField( &context, 19, RasEntry.szDeviceType, 
                                                       RAS_MaxDeviceType + 1, NULL) );
        ChkBoolErr( SetupGetStringField( &context, 20, RasEntry.szDeviceName, 
                                                       RAS_MaxDeviceName + 1, NULL) );
        ChkBoolErr( SetupGetStringField( &context, 21, RasEntry.szX25PadType, 
                                                       RAS_MaxPadType + 1, NULL) );
        ChkBoolErr( SetupGetStringField( &context, 22, RasEntry.szX25Address, 
                                                       RAS_MaxX25Address + 1, NULL) );
        ChkBoolErr( SetupGetStringField( &context, 23, RasEntry.szX25Facilities, 
                                                       RAS_MaxFacilities + 1, NULL) );
        ChkBoolErr( SetupGetStringField( &context, 24, RasEntry.szX25UserData, 
                                                       RAS_MaxUserData + 1, NULL) );
        ChkBoolErr( SetupGetIntField( &context,    25, (int*)&RasEntry.dwChannels) );
    
        // load RasDialParams structure
        ChkBoolErr( SetupGetStringField( &context, 26, RasDialParams.szPhoneNumber, 
                                                       RAS_MaxPhoneNumber + 1, NULL) );
        ChkBoolErr( SetupGetStringField( &context, 27, RasDialParams.szCallbackNumber, 
                                                       RAS_MaxCallbackNumber+1, NULL) );
        ChkBoolErr( SetupGetStringField( &context, 28, RasDialParams.szUserName, UNLEN+1, NULL) );
        ChkBoolErr( SetupGetStringField( &context, 29, RasDialParams.szPassword, PWLEN+1, NULL) );
        ChkBoolErr( SetupGetStringField( &context, 30, RasDialParams.szDomain, DNLEN+1, NULL) );
    
        // Set default options that do not exist on pre-Win2000 OS, but are 
        // set by default when you create a connection via the Win2000 GUI.
        RasEntry.dwfOptions |= RASEO_PreviewUserPw;
        RasEntry.dwfOptions |= RASEO_ShowDialingProgress;
        RasEntry.dwfOptions |= RASEO_ModemLights;

        // New Win2k encryption field
        if( RasEntry.dwfOptions & RASEO_RequireDataEncryption )
        {
          RasEntry.dwEncryptionType = ET_Require;
        }
        else
        {
          RasEntry.dwEncryptionType = ET_Optional;
        }

#ifdef PRIVATE_RAS                                       
        dwErr = GWinState_RasSetEntryProperties(NULL,  // Current user default phonebook
                                       RasDialParams.szEntryName,
                                       &RasEntry,
                                       sizeof(RASENTRY),
                                       NULL,
                                       NULL);
#else
        dwErr = GRasSetEntryProperties(NULL,  // Current user default phonebook
                                       RasDialParams.szEntryName,
                                       &RasEntry,
                                       sizeof(RASENTRY),
                                       NULL,
                                       NULL);
#endif                                       
        if ( dwErr != ERROR_SUCCESS)
        {
           Win32PrintfResource (LogFile, IDS_RAS_ENTRY_NOT_MIGRATED, RasDialParams.szEntryName);
           if (DebugOutput)
               Win32Printf(LogFile, "RasSetEntryProperties failed: Error %d\r\n", dwErr);
        }

        dwErr = GRasSetEntryDialParams(NULL,
                                       &RasDialParams,
                                       TRUE);   // Never put password in
        if ( dwErr != ERROR_SUCCESS)
        {
           Win32PrintfResource (LogFile, IDS_RAS_ENTRY_NOT_MIGRATED, RasDialParams.szEntryName);
           if (DebugOutput)
               Win32Printf(LogFile, "RasSetEntryDialParams failed: Error %d\r\n", dwErr);
        }

        // Advance to the next line.
        success = SetupFindNextLine( &context, &context );
    } while (success);
    
Err:
    return dwErr;
   
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertLFShort
//
//  Synopsis:   convert Win9x 16-bit LOGFONTs to NT formats
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD ConvertLFShort (LOGFONTW *plfDest, const SHORT_LOGFONT *plfSrc)
{
    plfDest->lfHeight = plfSrc->lfHeight;
    plfDest->lfWidth = plfSrc->lfWidth;
    plfDest->lfEscapement = plfSrc->lfEscapement;
    plfDest->lfOrientation = plfSrc->lfOrientation;
    plfDest->lfWeight = plfSrc->lfWeight;
    plfDest->lfItalic = plfSrc->lfItalic;
    plfDest->lfUnderline = plfSrc->lfUnderline;
    plfDest->lfStrikeOut = plfSrc->lfStrikeOut;
    plfDest->lfCharSet = plfSrc->lfCharSet;
    plfDest->lfOutPrecision = plfSrc->lfOutPrecision;
    plfDest->lfClipPrecision = plfSrc->lfClipPrecision;
    plfDest->lfQuality = plfSrc->lfQuality;
    plfDest->lfPitchAndFamily = plfSrc->lfPitchAndFamily;
    ZeroMemory (plfDest->lfFaceName, sizeof(plfDest->lfFaceName));

    if (0 == MultiByteToWideChar (GetACP(),
                         0,
                         plfSrc->lfFaceName,
                         -1,
                         plfDest->lfFaceName,
                         sizeof (plfDest->lfFaceName) / sizeof (WCHAR)))
        return GetLastError();

    return ERROR_SUCCESS;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertLF
//
//  Synopsis:   convert Win9x LOGFONTs to NT formats
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD ConvertLF (LOGFONTW *plfDest, const LOGFONTA *plfSrc)
{
    plfDest->lfHeight = plfSrc->lfHeight;
    plfDest->lfWidth = plfSrc->lfWidth;
    plfDest->lfEscapement = plfSrc->lfEscapement;
    plfDest->lfOrientation = plfSrc->lfOrientation;
    plfDest->lfWeight = plfSrc->lfWeight;
    plfDest->lfItalic = plfSrc->lfItalic;
    plfDest->lfUnderline = plfSrc->lfUnderline;
    plfDest->lfStrikeOut = plfSrc->lfStrikeOut;
    plfDest->lfCharSet = plfSrc->lfCharSet;
    plfDest->lfOutPrecision = plfSrc->lfOutPrecision;
    plfDest->lfClipPrecision = plfSrc->lfClipPrecision;
    plfDest->lfQuality = plfSrc->lfQuality;
    plfDest->lfPitchAndFamily = plfSrc->lfPitchAndFamily;
    ZeroMemory (plfDest->lfFaceName, sizeof(plfDest->lfFaceName));

    if (0 == MultiByteToWideChar (GetACP(),
                         0,
                         plfSrc->lfFaceName,
                         -1,
                         plfDest->lfFaceName,
                         sizeof (plfDest->lfFaceName) / sizeof (WCHAR)))
        return GetLastError();

    return ERROR_SUCCESS;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertNonClientMetrics
//
//  Synopsis:   convert Win9x client metrics to NT formats
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

void ConvertNonClientMetrics (NONCLIENTMETRICSW *Dest, NONCLIENTMETRICSA *Src)
{
    Dest->cbSize = sizeof (NONCLIENTMETRICSW);
    Dest->iBorderWidth = Src->iBorderWidth;
    Dest->iScrollWidth = Src->iScrollWidth;
    Dest->iScrollHeight = Src->iScrollHeight;
    Dest->iCaptionWidth = Src->iCaptionWidth;
    Dest->iCaptionHeight = Src->iCaptionHeight;
    Dest->iSmCaptionWidth = Src->iSmCaptionWidth;
    Dest->iSmCaptionHeight = Src->iSmCaptionHeight;
    Dest->iMenuWidth = Src->iMenuWidth;
    Dest->iMenuHeight = Src->iMenuHeight;

    ConvertLF (&Dest->lfCaptionFont, &Src->lfCaptionFont);
    ConvertLF (&Dest->lfSmCaptionFont, &Src->lfSmCaptionFont);
    ConvertLF (&Dest->lfMenuFont, &Src->lfMenuFont);
    ConvertLF (&Dest->lfStatusFont, &Src->lfStatusFont);
    ConvertLF (&Dest->lfMessageFont, &Src->lfMessageFont);
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertAppearanceScheme
//
//  Synopsis:   convert Win9x schemes to NT formats
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD ConvertAppearanceScheme (DWORD *ptype, BYTE **pdata, DWORD *pdata_len)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwSize = *pdata_len;

    if (*ptype == REG_BINARY &&
       (dwSize == sizeof(SCHEMEDATA_V1) ||
        dwSize == sizeof(SCHEMEDATA_V3) ||
        dwSize == sizeof(SCHEMEDATA_V4) ||
        dwSize == sizeof(SCHEMEDATA_V1A)))
    {
        SCHEMEDATA_NT sd_nt;
        SCHEMEDATA_V1 * psd_v1;
        SCHEMEDATA_V3 * psd_v3;
        SCHEMEDATA_V4 * psd_v4;
        SCHEMEDATA_V1A * psd_v1a;
        BOOL Copy3dValues = FALSE;
        BOOL shouldChange = TRUE;

        psd_v1 = (SCHEMEDATA_V1 *) *pdata;
        if (psd_v1->version == 1)
        {
             sd_nt.version = 2;
             ConvertNonClientMetrics (&sd_nt.ncm, &psd_v1->ncm);
             ConvertLFShort (&sd_nt.lfIconTitle, &psd_v1->lfIconTitle);

             ZeroMemory (sd_nt.rgb, sizeof (sd_nt.rgb));
             CopyMemory ( &sd_nt.rgb, &psd_v1->rgb,
                        min (sizeof (psd_v1->rgb), sizeof (sd_nt.rgb)));

             Copy3dValues = TRUE;
        }
        else if (psd_v1->version == 3 && dwSize==sizeof(SCHEMEDATA_V1A))
        {
             psd_v1a = (PSCHEMEDATA_V1A) psd_v1;
             sd_nt.version = 2;
             ConvertNonClientMetrics (&sd_nt.ncm, &psd_v1a->ncm);
             ConvertLFShort (&sd_nt.lfIconTitle, &psd_v1a->lfIconTitle);

             ZeroMemory (sd_nt.rgb, sizeof (sd_nt.rgb));
             CopyMemory ( &sd_nt.rgb, &psd_v1a->rgb,
                        min (sizeof (psd_v1a->rgb), sizeof (sd_nt.rgb)) );

             Copy3dValues = TRUE;
        }
        else if (psd_v1->version == 3 && dwSize==sizeof(SCHEMEDATA_V3))
        {
             psd_v3 = (PSCHEMEDATA_V3) psd_v1;

             sd_nt.version = 2;
             ConvertNonClientMetrics (&sd_nt.ncm, &psd_v3->ncm);
             ConvertLF (&sd_nt.lfIconTitle, &psd_v3->lfIconTitle);

             ZeroMemory (sd_nt.rgb, sizeof (sd_nt.rgb));
             CopyMemory ( &sd_nt.rgb, &psd_v3->rgb,
                        min (sizeof (psd_v3->rgb), sizeof (sd_nt.rgb)) );

             Copy3dValues = TRUE;

        }
        else if (psd_v1->version == 4)
        {
             psd_v4 = (PSCHEMEDATA_V4) psd_v1;

             sd_nt.version = 2;
             ConvertNonClientMetrics (&sd_nt.ncm, &psd_v4->ncm);
             ConvertLF (&sd_nt.lfIconTitle, &psd_v4->lfIconTitle);

             ZeroMemory (sd_nt.rgb, sizeof (sd_nt.rgb));
             CopyMemory ( &sd_nt.rgb, &psd_v4->rgb,
                        min (sizeof (psd_v4->rgb), sizeof (sd_nt.rgb)) );
        }
        else shouldChange = FALSE;

        if (Copy3dValues)
        {
             //
             // Make sure the NT structure has values for 3D colors
             //

             sd_nt.rgb[COLOR_HOTLIGHT] = sd_nt.rgb[COLOR_ACTIVECAPTION];
             sd_nt.rgb[COLOR_GRADIENTACTIVECAPTION] = 
                        sd_nt.rgb[COLOR_ACTIVECAPTION];
             sd_nt.rgb[COLOR_GRADIENTINACTIVECAPTION] =
                        sd_nt.rgb[COLOR_INACTIVECAPTION];
        }
        if (shouldChange)
        {
            BYTE *pnew_data;
            if (NULL == (pnew_data = (BYTE *)malloc (sizeof(sd_nt))))
                return ERROR_NOT_ENOUGH_MEMORY;

            CopyMemory (pnew_data, &sd_nt, sizeof(sd_nt));

            free (*pdata);
            *pdata = pnew_data;
            *pdata_len = sizeof(sd_nt);
        }
    }
    else if (Verbose)
        printf ("ConvertAppearanceScheme type=%d, size=%d\n",*ptype,*pdata_len);
    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertRecentDocsMRU
//
//  Synopsis:   convert Win9x "Start Menu" "Documents" settings
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD ConvertRecentDocsMRU (DWORD *ptype, BYTE **pdata, DWORD *pdata_len)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (*ptype == REG_BINARY)
    {
        LINKSTRUCT *pls95, *plsNT;
        CHAR *str, *strEnd;
        WCHAR *wstr, *wstrEnd;
        DWORD dwLinkSize, dwNewSize;
        DWORD dwRenewSize;

        str = (CHAR *) *pdata;
        dwNewSize = strlen(str);
        strEnd = str + dwNewSize;

        pls95 = (LINKSTRUCT *) strEnd;
        dwLinkSize = dwNewSize + 1 + pls95->wSize + sizeof (WORD);

        if (dwLinkSize != *pdata_len)
        {
            return ERROR_SUCCESS;  // length mismatch, do not transform
        }

        dwNewSize = MultiByteToWideChar (GetACP(),0,str,-1, NULL, 0);
        if (dwNewSize == 0)
            return GetLastError();

        if (NULL == (wstr = (WCHAR *) malloc (
                            (dwNewSize + 1)*sizeof(WCHAR) + dwLinkSize)))
            return ERROR_NOT_ENOUGH_MEMORY;

        if (0 == MultiByteToWideChar (GetACP(),0,str,-1,wstr,dwNewSize))
            dwErr = GetLastError();
        
        if (ERROR_SUCCESS == dwErr)
        {
            wstrEnd = wstr + wcslen(wstr);

            plsNT = (PLINKSTRUCT) ((LPBYTE) wstr + ((DWORD)(wstrEnd-wstr)));
            CopyMemory (plsNT, pls95, dwLinkSize);

            free (*pdata);
            *pdata = (BYTE *) wstr;
            *pdata_len = dwNewSize;
        }
        else free (wstr);
    }
    
    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertLogFont
//
//  Synopsis:   convert Win9x font binary data
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD ConvertLogFont (DWORD *ptype, BYTE **pdata, DWORD *pdata_len)
{
    if (*ptype == REG_BINARY && *pdata_len == sizeof(SHORT_LOGFONT))
    {
       BYTE *pnew_data;
       LOGFONTW lfNT;
       ConvertLFShort (&lfNT, (SHORT_LOGFONT *) *pdata);

       if (NULL == (pnew_data = (BYTE *)malloc (sizeof(lfNT))))
           return ERROR_NOT_ENOUGH_MEMORY;

       CopyMemory (pnew_data, &lfNT, sizeof(lfNT));

       free (*pdata);
       *pdata = pnew_data;
       *pdata_len = sizeof(lfNT);
    }
    return ERROR_SUCCESS;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertToDword
//
//  Synopsis:   convert string data to DWORD
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD ConvertToDword (DWORD *ptype, BYTE **pdata, DWORD *pdata_len)
{
    if (*ptype == REG_SZ || *ptype == REG_EXPAND_SZ)
    {
       BYTE *pnew_data;
       DWORD dwValue = _tcstoul ((PCTSTR) *pdata, NULL, 10);
       if (NULL == (pnew_data = (BYTE *)malloc (sizeof(dwValue))))
           return ERROR_NOT_ENOUGH_MEMORY;

       CopyMemory (pnew_data, &dwValue, sizeof(dwValue));

       free (*pdata);
       *pdata = pnew_data;
       *pdata_len = sizeof(dwValue);
       *ptype = REG_DWORD;
    }
    return ERROR_SUCCESS;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertToString
//
//  Synopsis:   convert DWORD to a string
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD ConvertToString (DWORD *ptype, BYTE **pdata, DWORD *pdata_len)
{
    if (*ptype == REG_DWORD)
    {
        BYTE *pnew_data;
        DWORD dwSize;
        TCHAR tcsValue[16];
        wsprintf (tcsValue, TEXT("%lu"), * ((DWORD *) *pdata));

        dwSize = (_tcslen (tcsValue) + 1) * sizeof(TCHAR);

        if (NULL == (pnew_data = (BYTE *)malloc (dwSize)))
            return ERROR_NOT_ENOUGH_MEMORY;

        CopyMemory (pnew_data, tcsValue, dwSize);

        free (*pdata);
        *pdata = pnew_data;
        *pdata_len = dwSize;
        *ptype = REG_SZ;
    }
    return ERROR_SUCCESS;
}

//+---------------------------------------------------------------------------
//
//  Function:   AntiAlias
//
//  Synopsis:   convert FontSmoothing from "1" to "2"
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD AntiAlias (DWORD *ptype, BYTE **pdata, DWORD *pdata_len)
{
    if (*ptype == REG_SZ)
    {
        DWORD dwValue = _tcstoul ((TCHAR *) *pdata, NULL, 10);
        if (dwValue > 0)
            wsprintf ((TCHAR *) *pdata, TEXT("%d"), FE_AA_ON);
    }
    return ERROR_SUCCESS;
}

//+--------------------------------------------------------------------------
//
//  Function:   FixActiveDesktop
//
//  Synopsis:   convert active desktop blob
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//---------------------------------------------------------------------------

DWORD FixActiveDesktop (DWORD *ptype, BYTE **pdata, DWORD *pdata_len)
{
    const USHORT BadBufferSize = 16;
    const USHORT GoodBufferSize = 28;

    BYTE BadBuffer[BadBufferSize] =
        {0x10, 0x00, 0x00, 0x00,
         0x01, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00};

    BYTE GoodBuffer[GoodBufferSize] =
        {0x1C, 0x00, 0x00, 0x00,
         0x20, 0x08, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00,
         0x0A, 0x00, 0x00, 0x00};

    if (*ptype == REG_BINARY && *pdata_len == BadBufferSize)
    {
        BOOL shouldChange = TRUE;
        for (USHORT i = 0; i < BadBufferSize; i++)
        {
            if ((*pdata)[i] != BadBuffer[i])
            {
                shouldChange = FALSE;
                break;
            }
        }
        if (shouldChange)
        {
            BYTE *pnew_data;
            if (NULL == (pnew_data = (BYTE *)malloc (sizeof(GoodBuffer))))
                return ERROR_NOT_ENOUGH_MEMORY;

            CopyMemory (pnew_data, GoodBuffer, sizeof(GoodBuffer));

            free (*pdata);
            *pdata = pnew_data;
            *pdata_len = sizeof(GoodBuffer);
        }
    }
    return ERROR_SUCCESS;
}

//+--------------------------------------------------------------------------
//
//  Function:   LoadTimeZone
//
//  Synopsis:   set the current timezone
//
//  Arguments:  
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//---------------------------------------------------------------------------

DWORD LoadTimeZone ()
{
    const int TZNAME_SIZE = 32; 
    const TCHAR REGKEY_TIMEZONES[] = 
        _T("Software\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones");

    const TCHAR REGVAL_TZI[] = _T("TZI");
    const TCHAR REGVAL_DLT[] = _T("Dlt");

    DWORD dwErr = ERROR_SUCCESS;
    const int LINEBUFSIZE = 1024;
    HKEY hKey = NULL;
    INFCONTEXT InfContext;
    TCHAR tcsTimeZone[LINEBUFSIZE];
    TIME_ZONE_INFORMATION tzi;
    APPLET_TIME_ZONE_INFORMATION atzi;

    if (TIME_ZONE_ID_INVALID == GetTimeZoneInformation (&tzi))
    {
        Win32Printf (LogFile, "Could not get time zone information\r\n");
        ChkErr (GetLastError());
    }

    if (SetupFindFirstLine(InputInf, SOURCE_SECTION, TIMEZONE, &InfContext))
    {
        TCHAR *buffer = NULL;
        TCHAR *buffer2 = NULL;

        ChkErr (GetInfField (&buffer, &InfContext, 1));

        if (lstrcmp (tzi.StandardName, buffer) != 0)
        {

            _tcsncpy (tcsTimeZone, (TCHAR*) REGKEY_TIMEZONES, LINEBUFSIZE);
            _tcsncat (tcsTimeZone, TEXT("\\"), 
                      LINEBUFSIZE - _tcslen(tcsTimeZone) - 1);
            _tcsncat (tcsTimeZone, buffer,
                      LINEBUFSIZE - _tcslen(tcsTimeZone) - 1);

            if (RegOpenKey (HKEY_LOCAL_MACHINE, tcsTimeZone, &hKey) == 
                            ERROR_SUCCESS)
            {
                ULONG ulLen = sizeof(atzi);
                if (ERROR_SUCCESS ==  RegQueryValueEx(hKey,
                         REGVAL_TZI, 0, NULL, (LPBYTE)&atzi, &ulLen))
                {
                    tzi.Bias = atzi.Bias;
                    tzi.StandardBias = atzi.StandardBias;
                    tzi.DaylightBias = atzi.DaylightBias;
                    tzi.StandardDate = atzi.StandardDate;
                    tzi.DaylightDate = atzi.DaylightDate;
                    _tcsncpy (tzi.StandardName, buffer, TZNAME_SIZE);

                    ULONG ulLen = TZNAME_SIZE;
                    if (ERROR_SUCCESS != RegQueryValueEx(hKey, REGVAL_DLT,
                         0, NULL, (LPBYTE) &tzi.DaylightName, &ulLen))
                        _tcscpy (tzi.DaylightName, TEXT(""));

                    // SetTimeZoneInformation will update local time
                    // since the UTC time has not changed
                    if (FALSE == SetTimeZoneInformation (&tzi)) 
                        dwErr = GetLastError();

                    if (Verbose)
                        printf ("TimeZone = %ws\n", tzi.StandardName);
                }
            }
        }
        free (buffer);
    }

Err:
    if (hKey != NULL)
        RegCloseKey (hKey);
    return dwErr;
}

//+--------------------------------------------------------------------------
//
//  Function:   SaveLocaleInfo
//
//  Synopsis:   formats a locale setting for registry update
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//---------------------------------------------------------------------------

DWORD SaveLocaleInfo(HKEY hKey, LCID lcid, LCTYPE LCType, TCHAR *pIniString)
{
    DWORD dwErr = ERROR_SUCCESS;
    TCHAR ptcsBuffer[SIZE_128];

    if (GetLocaleInfo( lcid,
                       LCType | LOCALE_NOUSEROVERRIDE,
                       ptcsBuffer,
                       SIZE_128 ))
    {
        dwErr = RegSetValueEx( hKey,
                               pIniString,
                               0L,
                               REG_SZ,
                               (BYTE *)ptcsBuffer,
                               (lstrlen(ptcsBuffer)+1) * sizeof(TCHAR));
    }
    return dwErr;
}

//+--------------------------------------------------------------------------
//
//  Function:   LoadInstallUserLocale
//
//  Synopsis:   sets the current user locale
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//---------------------------------------------------------------------------

DWORD LoadInstallUserLocale ()
{
    HKEY hKey = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    LCID lcid = 0;
    TCHAR *ptcsUserLocale = NULL;
    TCHAR ptcsOldLocale[25];
    INFCONTEXT infcontext;
    ULONG ulLen = 0;

    if (SetupFindFirstLine(InputInf, SOURCE_SECTION, USERLOCALE, &infcontext))
    {
        dwErr = GetInfField (&ptcsUserLocale, &infcontext, 1);
        if (ERROR_SUCCESS == dwErr)
        {
             lcid = (LCID)_tcstoul(ptcsUserLocale,NULL,16);
        }
    }
    
    //
    // Revert to current user locale if missing from INF
    //
    if (lcid == 0)
    {
        free (ptcsUserLocale);
        return ERROR_SUCCESS;
    }

    //
    //  Make sure the locale is valid.
    //
    if (!IsValidLocale(lcid, LCID_INSTALLED))
    {
        ChkErr (ERROR_INSTALL_LANGUAGE_UNSUPPORTED);
    }

    //
    //  Set the locale value in the user's control panel international
    //  section of the registry.
    //
    ChkErr(RegOpenKeyEx(CurrentUser ? CurrentUser : HKEY_CURRENT_USER,
                       REGKEY_INTL,
                       0L,
                       KEY_READ | KEY_WRITE,
                       &hKey ));

    //
    // Update user locale only if it's different
    //
    ulLen = sizeof (ptcsOldLocale);
    if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                         TEXT("Locale"),
                                         NULL,NULL,
                                         (BYTE*)ptcsOldLocale, &ulLen) &&
        lstrcmp (ptcsUserLocale, ptcsOldLocale) == 0)
    {
        free (ptcsUserLocale);
        RegCloseKey (hKey);
        return ERROR_SUCCESS;
    }

    ChkErr (RegSetValueEx( hKey,
                        TEXT("Locale"),
                        0L,
                        REG_SZ,
                        (LPBYTE)ptcsUserLocale,
                (lstrlen(ptcsUserLocale)+1) * sizeof(TCHAR)));

    //
    //  When the locale changes, update ALL registry information.
    //

    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_ICALENDARTYPE,     TEXT("iCalendarType")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_ICOUNTRY,          TEXT("iCountry")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_ICURRDIGITS,       TEXT("iCurrDigits")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_ICURRENCY,         TEXT("iCurrency")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_IDATE,             TEXT("iDate")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_IDIGITS,           TEXT("iDigits")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_IFIRSTDAYOFWEEK,   TEXT("iFirstDayOfWeek" )));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_IFIRSTWEEKOFYEAR,  TEXT("iFirstWeekOfYear")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_ILZERO,            TEXT("iLzero")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_IMEASURE,          TEXT("iMeasure")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_INEGCURR,          TEXT("iNegCurr")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_INEGNUMBER,        TEXT("iNegNumber")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_ITIME,             TEXT("iTime")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_ITIMEMARKPOSN,     TEXT("iTimePrefix")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_ITLZERO,           TEXT("iTLZero")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_IDIGITSUBSTITUTION,TEXT("NumShape")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_S1159,             TEXT("s1159")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_S2359,             TEXT("s2359")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_SCOUNTRY,          TEXT("sCountry")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_SCURRENCY,         TEXT("sCurrency")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_SDATE,             TEXT("sDate")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_SDECIMAL,          TEXT("sDecimal")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_SGROUPING,         TEXT("sGrouping")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_SABBREVLANGNAME,   TEXT("sLanguage")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_SLIST,             TEXT("sList")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_SLONGDATE,         TEXT("sLongDate")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_SMONDECIMALSEP,    TEXT("sMonDecimalSep")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_SMONGROUPING,      TEXT("sMonGrouping")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_SMONTHOUSANDSEP,   TEXT("sMonThousandSep")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_SNATIVEDIGITS,     TEXT("sNativeDigits")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_SNEGATIVESIGN,     TEXT("sNegativeSign")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_SPOSITIVESIGN,     TEXT("sPositiveSign")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_SSHORTDATE,        TEXT("sShortDate")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_STHOUSAND,         TEXT("sThousand")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_STIME,             TEXT("sTime")));
    ChkErr(SaveLocaleInfo(hKey, lcid, LOCALE_STIMEFORMAT,       TEXT("sTimeFormat")));

    //
    //  Set the user's default locale in the system so that any new
    //  process will use the new locale.
    //
    if (CurrentUser == HKEY_CURRENT_USER)
        NtSetDefaultLocale(TRUE, lcid);

Err:
    //
    //  Flush the International key.
    //
    if (hKey != NULL)
    {
        RegFlushKey(hKey);
        RegCloseKey(hKey);
    }

    if (ptcsUserLocale != NULL)
        free (ptcsUserLocale);

    //
    //  Return success.
    //
    return (dwErr);
}

#if 0
//+--------------------------------------------------------------------------
//
//  Function:   ReadVersionKey
//
//  Synopsis:   helper function that reads a value in CurrentVersion key
//
//  Arguments:  
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//---------------------------------------------------------------------------

DWORD ReadVersionKey (TCHAR *pValueName, TCHAR *pValue, ULONG ulLen)
{
    HKEY hKey = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    static const TCHAR REGKEY_VERSION[] =
                TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion");

    ChkErr (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_VERSION, 
                         NULL, KEY_READ, &hKey));
    ChkErr (RegQueryValueEx(hKey,pValueName,NULL,NULL,(BYTE*)pValue, &ulLen));
Err:
    if (hKey != NULL)
        RegCloseKey (hKey);
    return dwErr;
}
#endif

#if 0
//+--------------------------------------------------------------------------
//
//  Function:   GetDomainMembershipInfo
//
//  Synopsis:   return domain or workgroup name
//
//  Arguments:  [szname] -- output string for sysprep
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//---------------------------------------------------------------------------

NTSTATUS GetDomainMembershipInfo (TCHAR *szName)
{
    NTSTATUS                     ntstatus;
    POLICY_PRIMARY_DOMAIN_INFO*  ppdi;
    LSA_OBJECT_ATTRIBUTES        loa;
    LSA_HANDLE                   hLsa = 0;

    loa.Length                    = sizeof(LSA_OBJECT_ATTRIBUTES);
    loa.RootDirectory             = NULL;
    loa.ObjectName                = NULL;
    loa.Attributes                = 0;
    loa.SecurityDescriptor        = NULL;
    loa.SecurityQualityOfService  = NULL;

    ntstatus = LsaOpenPolicy(NULL, &loa, POLICY_VIEW_LOCAL_INFORMATION, &hLsa);
    if (LSA_SUCCESS(ntstatus))
    {
        ntstatus = LsaQueryInformationPolicy( hLsa,
                                              PolicyPrimaryDomainInformation,
                                              (VOID **) &ppdi );
        if( LSA_SUCCESS( ntstatus ) )
        {
            lstrcpy (szName, (ppdi->Sid > 0 ) ? TEXT("JoinDomain=") :
                                                TEXT("JoinWorkgroup="));
            lstrcat( szName, ppdi->Name.Buffer );
        }
        LsaClose (hLsa);
    }
    return (ntstatus);
}
#endif

#if 0
//+--------------------------------------------------------------------------
//
//  Function:   SysprepFile
//
//  Synopsis:   generates the sysprep unattended file
//
//  Arguments:  [dwLangGroup] -- language group to install
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//---------------------------------------------------------------------------

DWORD SysprepFile (DWORD dwLangGroup)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwTimeZone = 0;
    INFCONTEXT InfContext;
    TCHAR * pFullName = NULL;
    TCHAR * pOrgName = NULL;
    const int MAX_WORKGROUP_LENGTH = 15;
    const int NAME_LENGTH = 128;
    const TCHAR REGVAL_FULLNAME[] = TEXT("RegisteredOwner");
    const TCHAR REGVAL_ORGNAME[] = TEXT("RegisteredOrganization");
    const TCHAR REGVAL_INSTALLPATH[] = TEXT("SourcePath");
    TCHAR szFullName[NAME_LENGTH] = TEXT("");
    TCHAR szOrgName[NAME_LENGTH] = TEXT("");
    TCHAR szInstall[MAX_PATH];
    TCHAR szTargetPath[MAX_PATH];
    TCHAR szComputerName[NAME_LENGTH];
    TCHAR *pTargetPath;
    CHAR *pFile = NULL;
    ULONG ulLen;
    TCHAR szJoin [MAX_WORKGROUP_LENGTH + 1 + NAME_LENGTH];

    CHAR szSysprep[] = "[Unattended]\r\n"
                       "OemSkipEula=Yes\r\n"
                       "InstallFilesPath=%ws\r\n"
                       "TargetPath=%ws\r\n"
                       "\r\n"
                       "[GuiUnattended]\r\n"
                       "AdminPassword=*\r\n"
                       "OEMSkipRegional=1\r\n"
                       "TimeZone=%x\r\n"
                       "OemSkipWelcome=1\r\n"
                       "\r\n"
                       "[UserData]\r\n"
                       "FullName=\"%ws\"\r\n"
                       "OrgName=\"%ws\"\r\n"
                       "ComputerName=%ws\r\n"
                       "\r\n"
                       "[Identification]\r\n"
                       "%ws\r\n"
                       "\r\n"
                       "[RegionalSettings]\r\n"
                       "LanguageGroup=%d\r\n"
                       "\r\n"
                       "[Networking]\r\n"
                       "InstallDefaultComponents=Yes\r\n";


    if (FALSE == GetWindowsDirectory ((TCHAR*) szTargetPath, MAX_PATH))
        ChkErr (GetLastError());

    if (szTargetPath[1] == ':' && szTargetPath[2] == '\\')
        pTargetPath = &szTargetPath[2];
    else
        pTargetPath = &szTargetPath[0];

    ulLen = NAME_LENGTH;
    if (FALSE == GetComputerName ((TCHAR*) szComputerName, &ulLen))
        ChkErr (GetLastError());

    if (SetupFindFirstLine(InputInf, SOURCE_SECTION, FULLNAME, &InfContext))
    {
        ChkErr (GetInfField (&pFullName, &InfContext, 1));
    }
    else  // use the current fullname
    {
        ChkErr(ReadVersionKey((TCHAR*)REGVAL_FULLNAME, 
                               szFullName, sizeof(szFullName)));
        pFullName = szFullName;
    }

    if (SetupFindFirstLine(InputInf, SOURCE_SECTION, ORGNAME, &InfContext))
    {
        ChkErr (GetInfField (&pOrgName, &InfContext, 1));
    }
    else // use the current org name
    {
        ChkErr(ReadVersionKey((TCHAR*)REGVAL_ORGNAME, 
                               szFullName, sizeof(szFullName)));
        pFullName = szOrgName;
    }

    if (ERROR_SUCCESS != ReadVersionKey((TCHAR*)REGVAL_INSTALLPATH,
                                        szInstall, sizeof(szInstall)))
    {
        lstrcpy ((TCHAR *)szInstall, TEXT(""));   // prompt for media?
    }

    if(!LSA_SUCCESS(GetDomainMembershipInfo(szJoin)))
        lstrcpy (szJoin, TEXT(""));

    if ((pFile = (CHAR *) malloc (4096)) == NULL)
        ChkErr (ERROR_NOT_ENOUGH_MEMORY);

    wsprintfA (pFile, szSysprep,  szInstall, pTargetPath, dwTimeZone, 
               pFullName, pOrgName, szComputerName, szJoin, dwLangGroup);

    hFile = CreateFile (
            TEXT("sysprep.inf"),
            GENERIC_READ | GENERIC_WRITE,
            0,                                  // No sharing.
            NULL,                               // No inheritance
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL                                // No template file.
            );
    
    if (INVALID_HANDLE_VALUE == hFile)
        ChkErr (GetLastError());

    if (FALSE == WriteFile (hFile, pFile, lstrlenA(pFile), &ulLen, NULL))
        ChkErr (GetLastError());

Err:
    if (pFullName != NULL)
        free (pFullName);
    if (pOrgName != NULL)
        free (pOrgName);
    if (pFile != NULL)
        free (pFile);
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle (hFile);
    return dwErr;
}
#endif



//+---------------------------------------------------------------------------
//
//  Function:   LoadSystem
//
//  Synopsis:   load system settings
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD LoadSystem(int argc, char *argv[])
{
    DWORD  dwErr           = ERROR_SUCCESS;
    DWORD  ccLen;
    WCHAR *pBuf            = NULL;
    HKEY   hKey;
    WCHAR *pwMigrationPath = NULL;
    int    i;
    DWORD  dwInfCount      = 0;

    if ((dwErr = LoadVerifyOSLang()) != ERROR_SUCCESS)
        return dwErr;

    // If the schedule flag is set, write a run once to schedule
    // applying the system settings.
    if (SchedSystem)
    {
        WCHAR wcsModule[MAX_PATH];
        DWORD ccModule = MAX_PATH;

        if (0 == GetModuleFileName (NULL, wcsModule, ccModule))
        {
            dwErr = GetLastError();
			goto cleanup;
		}

        
        // Convert the migration path to unicode.
        dwErr = MakeUnicode( MigrationPath, &pwMigrationPath );

        if (dwErr != ERROR_SUCCESS)
			goto cleanup;

        // Build a command line containing:
        //  /p parameter, to indicate running the user portion
        //  /s parameter, to indicate migrating system settings
        //  path to migration.inf
        ccLen = wcslen(wcsModule) + wcslen(SCHED_PARAMS) + 1;
        pBuf = (WCHAR *) malloc( ccLen * sizeof(WCHAR) );
        if (pBuf == NULL)
        {
			dwErr = ERROR_NOT_ENOUGH_MEMORY;
			goto cleanup;
		}
        wcscpy( pBuf, wcsModule );
        wcscat( pBuf, SCHED_PARAMS);
      
        // Open the run once key.
        dwErr = RegOpenKeyEx(CurrentUser ? CurrentUser : HKEY_CURRENT_USER,
                             L"Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce",
                             0, KEY_WRITE, &hKey );
        if (dwErr != ERROR_SUCCESS)
			goto cleanup;

		// Write the command to the registry.
		dwErr = RegSetValueEx( hKey, TEXT("loadstate"), 0, REG_SZ,
                               (UCHAR *) pBuf, ccLen*sizeof(WCHAR) );
		if (dwErr != ERROR_SUCCESS)
			goto cleanup;
        RegCloseKey( hKey );

        dwErr = RegCreateKeyEx(CurrentUser ? CurrentUser : HKEY_CURRENT_USER,
                               L"Software\\Microsoft\\Windows\\CurrentVersion\\Loadstate",
                               0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, NULL );
        if (dwErr != ERROR_SUCCESS)
            goto cleanup;

        // Write LogFile   path to registry
        dwErr = RegSetValueEx( hKey, TEXT("Logfile"), 0, REG_SZ,
                               (UCHAR *)szLogFile, (_tcslen(szLogFile) * sizeof(TCHAR)) );
        if (dwErr != ERROR_SUCCESS)
            goto cleanup;

        // Write Migration path to registry
        dwErr = RegSetValueEx( hKey, TEXT("Store"), 0, REG_SZ,
                               (UCHAR *)pwMigrationPath, (_tcslen(pwMigrationPath) * sizeof(TCHAR)) );
        if (dwErr != ERROR_SUCCESS)
            goto cleanup;

        TCHAR szInfFile[MAX_PATH + 1];
        TCHAR szFullInfFile[MAX_PATH + 1];
        TCHAR szKeyName[6];
        TCHAR *ptsFileNamePart;

        // Prevent KeyName buffer overflow
        if ( argc > 99) 
        {
            if (Verbose)
            {
                Win32Printf(LogFile, "ERROR: Too many command line arguments [%d]\r\n", argc);
            }
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
            
        // Write InfFile  paths to registry
        for (i = 1; i < argc; i++)
        {
            if ((argv[i][0] == '/' || argv[i][0] == '-') &&
                (tolower(argv[i][1]) == 'i'))
            {
                i++;
                _stprintf(szKeyName, TEXT("Inf%d"), ++dwInfCount);

                if (0 == MultiByteToWideChar (GetACP(), 0, argv[i], -1, szInfFile, MAX_PATH))
                {
                    dwErr = GetLastError();
                    goto cleanup;
                }
                dwErr = GetFullPathName( szInfFile,
                                         MAX_PATH, 
                                         szFullInfFile, 
                                         &ptsFileNamePart);
                if (0 == dwErr)
                {
                    dwErr = GetLastError();
                    goto cleanup;
                }
                dwErr = RegSetValueEx( hKey, szKeyName, 0, REG_SZ,
                                       (UCHAR *)szFullInfFile, (_tcslen(szFullInfFile) * sizeof(TCHAR)) );
                if (dwErr != ERROR_SUCCESS)
                    goto cleanup;
            }
		}
        RegCloseKey( hKey );

cleanup:
        if (dwErr != ERROR_SUCCESS)
            LogFormatError (dwErr);

        free( pBuf );
        free( pwMigrationPath );
    }
    else
    {
        if (!CopySystem)
            return ERROR_SUCCESS;

        ChkErr (LoadNetShares());
        ChkErr (LoadPrinters());

        dwErr = InitializeRasApi();
        if ( dwErr == ERROR_SUCCESS )
        {
            ChkErr (LoadRas());
        }
        else
        {
            // No problem, just skip Ras processing
            dwErr = ERROR_SUCCESS;
        }

        if (CopyUser == FALSE)
        {
            if (CurrentUser == NULL)
                CurrentUser = HKEY_CURRENT_USER;

            ChkErr(InitializeHash());
        }

        ChkErr(CopyInf (ACCESS_SECTION));
        ChkErr(CopyInf (DESKTOP_SECTION));
        ChkErr(LoadKeyboardLayouts());
        ChkErr (LoadTimeZone());
        ChkErr (LoadInstallUserLocale());
    }

Err:
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\loadstate\loaduser.cxx ===
//--------------------------------------------------------------
//
// File:        loaduser
//
// Contents:    Load a user hive.
//
//---------------------------------------------------------------

#include "loadhead.cxx"
#pragma hdrstop

#include <common.hxx>
#include <objerror.h>
#include <userenv.h>
#include <userenvp.h>

#include <loadstate.hxx>
#include <bothchar.cxx>


class CRegFileList
{
public:
    inline CRegFileList(TCHAR *ptsRoot,
                        TCHAR *ptsKey,
                        TCHAR *ptsVal,
                        TCHAR *ptsData,
                        DWORD dwValueType);
    inline ~CRegFileList();

    inline void SetNext(CRegFileList *prfl);
    inline CRegFileList * GetNext(void) const;

    inline void GetData(const TCHAR **pptsRoot,
                        const TCHAR **pptsKey,
                        const TCHAR **pptsVal,
                        const TCHAR **pptsData,
                        DWORD *pdwValType) const;
private:
    TCHAR _tsRootName[MAX_PATH + 1];
    TCHAR _tsKeyName[MAX_PATH + 1];
    TCHAR _tsValueName[MAX_PATH + 1];
    TCHAR _tsData[MAX_PATH + 1];
    DWORD _dwValueType;
    CRegFileList *_prflNext;
};


inline CRegFileList::CRegFileList(TCHAR *ptsRoot,
                                  TCHAR *ptsKey,
                                  TCHAR *ptsVal,
                                  TCHAR *ptsData,
                                  DWORD dwValueType)
{
    if (ptsRoot != NULL && _tcslen(ptsRoot) <= MAX_PATH)
        _tcscpy(_tsRootName, ptsRoot);
    else
        _tsRootName[0] = 0;

    if (ptsKey != NULL && _tcslen(ptsKey) <= MAX_PATH)
        _tcscpy(_tsKeyName, ptsKey);
    else
        _tsKeyName[0] = 0;

    if (ptsVal != NULL && _tcslen(ptsVal) <= MAX_PATH)
        _tcscpy(_tsValueName, ptsVal);
    else
        _tsValueName[0] = 0;
 
    if (ptsData != NULL && _tcslen(ptsData) <= MAX_PATH)
        _tcscpy(_tsData, ptsData);
    else
        _tsData[0] = 0;

    _dwValueType = dwValueType;
    _prflNext = NULL;
}

inline CRegFileList::~CRegFileList(void)
{
}

inline void CRegFileList::SetNext(CRegFileList *prfl)
{
    _prflNext = prfl;
}

inline CRegFileList * CRegFileList::GetNext(void) const
{
    return _prflNext;
}

inline void CRegFileList::GetData(const TCHAR **pptsRoot,
                                  const TCHAR **pptsKey,
                                  const TCHAR **pptsVal,
                                  const TCHAR **pptsData,
                                  DWORD *pdwValType) const
{
    *pptsRoot = _tsRootName;
    *pptsKey = _tsKeyName;
    *pptsVal = _tsValueName;
    *pptsData = _tsData;
    *pdwValType = _dwValueType;
}


CRegFileList *g_prflStart;

//---------------------------------------------------------------
// Constants.
const DWORD SID_GUESS  = 80;
const TCHAR HIVEFILE[] = TEXT("\\ntuser.dat");
const TCHAR HIVEPATH[] = TEXT("%temp%\\ntuser.dat");

const DWORD NUM_HASH_BUCKETS = 121;

const TCHAR FORCE_SECTION[]    = TEXT("Force Win9x Settings");
const TCHAR RENAME_SECTION[]   = TEXT("Map Win9x to WinNT");
const TCHAR FUNCTION_SECTION[] = TEXT("Win9x Data Conversion");
const TCHAR SUPPRESS_SECTION[] = TEXT("Suppress Win9x Settings");
const TCHAR FILE_SECTION[]     = TEXT("Map paths");
const TCHAR DELETE_SECTION[]   = TEXT("Suppress WinNT Settings");

//---------------------------------------------------------------
// Macros

// If this symbol is defined, loaduser will apply the state to the
// specified user and cannot be run as that user.
// If this symbols is not defined, loaduser will apply state to the
// current user.
#define SPECIFIC_USER 1

//---------------------------------------------------------------
// Globals.

HASH_HEAD HashTable[NUM_HASH_BUCKETS];
FUNCTION_FA_MAP FunctionTable[] = {
    { TEXT("ConvertRecentDocsMRU"), ConvertRecentDocsMRU },
    { TEXT("ConvertAppearanceScheme"), ConvertAppearanceScheme },
    { TEXT("ConvertLogFont"), ConvertLogFont },
    { TEXT("ConvertToDword"), ConvertToDword },
    { TEXT("ConvertToString"), ConvertToString },
    { TEXT("AntiAlias"), AntiAlias },
    { TEXT("FixActiveDesktop"), FixActiveDesktop },
    { NULL, NULL }
};

//---------------------------------------------------------------
DWORD ShiftXOR( DWORD x, TCHAR c )
{
    if (x & 0x80000000)
        return  (x << 1) ^ c | 1;
    else
        return (x << 1) ^ c;
}

//---------------------------------------------------------------
// Create a case insensitive hash of the input.
DWORD Hash( TCHAR *ptsRoot, TCHAR *ptsKey, TCHAR *ptsValue )
{
    DWORD x = 0;
    DWORD i;

    // Hash the ptsRoot.
    if (ptsRoot != NULL)
        for (i = 0; ptsRoot[i] != 0; i++)
            x = ShiftXOR( x, _totupper(ptsRoot[i]) );

    // Hash the key.
    if (ptsKey != NULL)
        for (i = 0; ptsKey[i] != 0; i++)
            x = ShiftXOR( x, _totupper(ptsKey[i]) );

    // Hash the value.
    if (ptsValue != NULL)
        for (i = 0; ptsValue[i] != 0; i++)
            x = ShiftXOR( x, _totupper(ptsValue[i]) );
    return x;
}

//---------------------------------------------------------------
DWORD null_tcsicmp( TCHAR *x, TCHAR *y )
{
    if (x == NULL)
        if (y == NULL)
            return 0;
        else
            return -1;
    else
        if (y == NULL)
            return 1;
        else
            return _tcsicmp( x, y );
}

//---------------------------------------------------------------
// Do a case insensitive comparision of the input.
BOOL Match( HASH_NODE *phnCurrent,
            DWORD dwHash,
            TCHAR *ptsRoot,
            TCHAR *ptsKey,
            TCHAR *ptsValue)
{
    return phnCurrent->dwHash == dwHash &&
        null_tcsicmp( phnCurrent->ptsRoot, ptsRoot ) == 0 &&
        null_tcsicmp( phnCurrent->ptsKey, ptsKey ) == 0 &&
        null_tcsicmp( phnCurrent->ptsValue, ptsValue ) == 0;
}


//---------------------------------------------------------------
HASH_NODE *Lookup( TCHAR *ptsRoot, TCHAR *ptsKey, TCHAR *ptsValue )
{
    DWORD      dwHash   = Hash( ptsRoot, ptsKey, ptsValue );
    DWORD      dwBucket = dwHash % NUM_HASH_BUCKETS;
    HASH_NODE *phnCurrent   = (HASH_NODE *) HashTable[dwBucket].phhNext;

    // Look at all the nodes in the bucket.
    while (phnCurrent != (HASH_NODE *) &HashTable[dwBucket])
        if (Match( phnCurrent, dwHash, ptsRoot, ptsKey, ptsValue ))
            return phnCurrent;
        else
            phnCurrent = phnCurrent->phnNext;
    return NULL;
}

//---------------------------------------------------------------
void Insert( HASH_NODE *phnNode )
{
    DWORD      dwHash   = Hash( phnNode->ptsRoot,
                                phnNode->ptsKey,
                                phnNode->ptsValue );
    DWORD      dwBucket = dwHash % NUM_HASH_BUCKETS;
    HASH_NODE *phnCurrent;

    // Look for an existing node.

    phnCurrent = Lookup( phnNode->ptsRoot,
                         phnNode->ptsKey,
                         phnNode->ptsValue );

    // If found, copy in the state of the new node and free it.
    if (phnCurrent != NULL)
    {
        // Assume that the new value or key have not been set.
        if (phnNode->dwAction & rename_value_fa)
        {
            if (phnCurrent->ptsNewValue != NULL)
            {
                //Skip
                if (_tcsicmp(phnCurrent->ptsNewValue, phnNode->ptsNewValue))
                    Win32Printf(LogFile,
                                "Warning: Skipping rename rule for %s\\%s [%s]"
                                " to %s due to previous rename rule "
                                "to %s.\r\n",
                                phnNode->ptsRoot,
                                phnNode->ptsKey,
                                phnNode->ptsValue,
                                phnNode->ptsNewValue,
                                phnCurrent->ptsNewValue);
                goto cleanup;
            }
            else
                phnCurrent->ptsNewValue = phnNode->ptsNewValue;
        }

        if (phnNode->dwAction & (rename_leaf_fa | rename_path_fa))
        {
            if (phnCurrent->ptsNewKey != NULL)
            {
                //Skip
                if (_tcsicmp(phnCurrent->ptsNewKey, phnNode->ptsNewKey))
                    Win32Printf(LogFile,
                                "Warning: Skipping rename rule for %s\\%s "
                                "to %s due to previous rename rule to %s.\r\n",
                                phnNode->ptsRoot,
                                phnNode->ptsKey,
                                phnNode->ptsNewKey,
                                phnCurrent->ptsNewKey);
                goto cleanup;
            }
            else
                phnCurrent->ptsNewKey = phnNode->ptsNewKey;
        }

        if (phnNode->dwAction & function_fa)
        {
            if (phnCurrent->ptsFunction != NULL)
            {
                //Skip
                if (_tcsicmp(phnCurrent->ptsNewKey, phnNode->ptsNewKey))
                    Win32Printf(LogFile,
                                "Warning: Skipping function rule for %s\\%s "
                                "to %s due to previous function call"
                                " to %s.\r\n",
                                phnNode->ptsRoot,
                                phnNode->ptsKey,
                                phnNode->ptsNewKey,
                                phnCurrent->ptsFunction);
                goto cleanup;
            }
            else
                phnCurrent->ptsFunction = phnNode->ptsNewKey;
        }

        phnCurrent->dwAction |= phnNode->dwAction;

        if (VerboseReg)
            LogReadRule( phnNode );

    cleanup:
        free( phnNode->ptsRoot );
        free( phnNode->ptsKey );
        free( phnNode->ptsValue );
        free( phnNode );
    }

    // Insert the node.
    else
    {
        phnCurrent   = (HASH_NODE *) &HashTable[dwBucket];
        phnNode->dwHash       = dwHash;
        phnNode->phnNext       = phnCurrent->phnNext;
        phnNode->phnPrev       = phnCurrent;
        phnCurrent->phnNext->phnPrev = phnNode;
        phnCurrent->phnNext       = phnNode;

        if (phnNode->dwAction & function_fa)
        {
            phnNode->ptsFunction = phnNode->ptsNewKey;
            phnNode->ptsNewKey = NULL;
        }
        if (VerboseReg)
            LogReadRule( phnNode );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteInf
//
//  Synopsis:   deletes values copied from .DEFAULT user hive
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD DeleteInf ()
{
    DWORD dwResult = ERROR_SUCCESS;
    HKEY hRootKey = NULL;
    HKEY hKey = NULL;

    for (DWORD dwBucket = 0;  dwBucket < NUM_HASH_BUCKETS; dwBucket++)
    {
        HASH_NODE *phnCurrent = (HASH_NODE *) HashTable[dwBucket].phhNext;

        // Look at all the nodes in the bucket.
        while (phnCurrent != (HASH_NODE *) &HashTable[dwBucket])
        {
            if (phnCurrent->dwAction & delete_fa)
            {
                if (phnCurrent->ptsRoot != NULL)
                {
                    if (_tcsicmp( TEXT("HKLM"), phnCurrent->ptsRoot ) == 0)
                        hRootKey = HKEY_LOCAL_MACHINE;
                    else
                        hRootKey = CurrentUser;
                    dwResult = RegOpenKeyEx( hRootKey,
                                           phnCurrent->ptsKey,
                                           NULL,
                                           KEY_ALL_ACCESS,
                                           &hKey );
                    if (dwResult == ERROR_SUCCESS)
                    {
                        dwResult = RegDeleteValue (hKey, phnCurrent->ptsValue);
                        RegCloseKey (hKey);
                        if (dwResult != ERROR_SUCCESS)
                        {
                            if (Verbose)
                                Win32Printf(LogFile,
                                            "Warning. Cannot delete %s\\%s\n",
                                            phnCurrent->ptsKey,
                                            phnCurrent->ptsValue);
                            dwResult = ERROR_SUCCESS;
                        }
                    }
                    else dwResult = ERROR_SUCCESS;  // keep on going
                }
            }
            phnCurrent = phnCurrent->phnNext;
        }
    }
    return dwResult;
}


DWORD ApplyRule(HASH_NODE *phnRule,
                TCHAR *ptsKeyMatch,
                TCHAR **pptsRoot,
                TCHAR **pptsKey,
                TCHAR **pptsValue,
                DWORD *pdwType,
                BYTE **ppbData,
                DWORD *pdwDataLen,
                BOOL *pfForce)
{
    DWORD dwResult = ERROR_SUCCESS;

    if (phnRule->dwAction & force_fa)
    {
        if (DebugOutput || VerboseReg)
            Win32Printf(LogFile,
                        "Applying force rule to %s\\%s [%s]\r\n",
                        *pptsRoot,
                        *pptsKey,
                        (*pptsValue) ? *pptsValue : TEXT("NULL"));

        *pfForce = TRUE;
    }

    if (phnRule->dwAction & function_fa)
    {
        FUNCTION_FA_MAP *pMap = FunctionTable;
        while (pMap != NULL && pMap->ptsName != NULL)
        {
            if (lstrcmp (pMap->ptsName, phnRule->ptsFunction) == 0 &&
                pMap->pfunction)
            {
                dwResult = (pMap->pfunction) (pdwType,
                                              ppbData,
                                              pdwDataLen);
                LOG_ASSERT (dwResult);
            }
            pMap++;
        }
        if (DebugOutput || VerboseReg)
            Win32Printf(LogFile,
                        "Applying function_fa rule to %s\\%s [%s] "
                        "(function %s)\r\n",
                        *pptsRoot,
                        *pptsKey,
                        (*pptsValue) ? *pptsValue : TEXT("NULL"),
                        phnRule->ptsFunction);

    }

    // Replace the path matched with the new path and leave the
    // portion of the path that was not matched.
    if (phnRule->dwAction & rename_path_fa)
    {
        DWORD dwLen = _tcslen( phnRule->ptsNewKey ) + _tcslen(ptsKeyMatch);
        TCHAR * ptsBuffer = (TCHAR *) malloc( (dwLen + 1) *sizeof(TCHAR) );
        LOG_ASSERT_EXPR( ptsBuffer != NULL,
                         IDS_NOT_ENOUGH_MEMORY,
                         dwResult,
                         ERROR_NOT_ENOUGH_MEMORY );
        _tcscpy( ptsBuffer, phnRule->ptsNewKey );
        _tcscat( ptsBuffer, ptsKeyMatch );

        if (DebugOutput || VerboseReg)
            Win32Printf(LogFile,
                        "Applying rename_path rule to %s\\%s [%s], "
                        "result %s\r\n",
                        *pptsRoot,
                        *pptsKey,
                        (*pptsValue) ? *pptsValue : TEXT("NULL"),
                        ptsBuffer);
        free( *pptsKey );
        *pptsKey = ptsBuffer;
    }

    // Replace the entire key with the new key.
    if (phnRule->dwAction & rename_leaf_fa)
    {
        DWORD dwLen = _tcslen( phnRule->ptsNewKey ) + 1;
        TCHAR *ptsBuffer = (TCHAR *) malloc( dwLen*sizeof(TCHAR) );
        LOG_ASSERT_EXPR( ptsBuffer != NULL,
                         IDS_NOT_ENOUGH_MEMORY,
                         dwResult,
                         ERROR_NOT_ENOUGH_MEMORY );
        _tcscpy( ptsBuffer, phnRule->ptsNewKey );
        if (DebugOutput || VerboseReg)
            Win32Printf(LogFile,
                        "Applying rename_leaf rule to %s\\%s [%s], "
                        "result %s\r\n",
                        *pptsRoot,
                        *pptsKey,
                        (*pptsValue) ? *pptsValue : TEXT("NULL"),
                        ptsBuffer);
        free( *pptsKey );
        *pptsKey = ptsBuffer;
    }

    // Replace the entire value with the new value.
    if (phnRule->dwAction & rename_value_fa)
    {
        DWORD dwLen = _tcslen( phnRule->ptsNewValue ) + 1;
        TCHAR *ptsBuffer = (TCHAR *) malloc( dwLen*sizeof(TCHAR) );
        LOG_ASSERT_EXPR( ptsBuffer != NULL,
                         IDS_NOT_ENOUGH_MEMORY,
                         dwResult,
                         ERROR_NOT_ENOUGH_MEMORY );
        _tcscpy( ptsBuffer, phnRule->ptsNewValue );
        if (DebugOutput || VerboseReg)
            Win32Printf(LogFile,
                        "Applying rename_value rule to %s\\%s [%s], "
                        "result %s\r\n",
                        *pptsRoot,
                        *pptsKey,
                        (*pptsValue) ? *pptsValue : TEXT("NULL"),
                        ptsBuffer);

        free( *pptsValue );
        *pptsValue = ptsBuffer;
    }

    // Ask what the new path should be.
    if ((phnRule->dwAction & file_fa) && *pptsValue != NULL)
    {
        //Nothing to do here, we'll do this in Filter
    }

    if (!(SourceVersion & 0x80000000))
        *pfForce = TRUE;

cleanup:
    return dwResult;
}

/***************************************************************************

        Filter

     Look for a rule for each component of the path.  If found, apply it.

***************************************************************************/
DWORD Filter( TCHAR **pptsRoot,
              TCHAR **pptsKey,
              TCHAR **pptsValue,
              DWORD *pdwType,
              BYTE **ppbData,
              DWORD *pdwDataLen,
              BOOL *pfForce )
{
    DWORD     dwKeyLen  = _tcslen( *pptsKey ) + 1;
    TCHAR     *ptsKeyPath = (TCHAR *) _alloca( dwKeyLen*sizeof(TCHAR) );
    TCHAR     *ptsFrom;
    TCHAR     *ptsTo;
    TCHAR     *ptsEnd;
    HASH_NODE *phnRule     = NULL;
    DWORD      dwResult   = ERROR_SUCCESS;
    BOOL       fSuppress = FALSE;
    BOOL       fFileRuleFound = FALSE;

    //Make copies of all the initial keys
    TCHAR *ptsRootBuf = (TCHAR *) _alloca((_tcslen(*pptsRoot) + 1) *
                                          sizeof(TCHAR));
    TCHAR *ptsKeyBuf = (TCHAR *) _alloca( dwKeyLen * sizeof(TCHAR) );
    TCHAR *ptsValBuf = NULL;

    if (*pptsValue)
    {
        ptsValBuf = (TCHAR *) _alloca((_tcslen(*pptsValue) + 1) *
                                         sizeof(TCHAR));
        _tcscpy(ptsValBuf, *pptsValue);
    }

    _tcscpy(ptsRootBuf, *pptsRoot);
    _tcscpy(ptsKeyBuf, *pptsKey);

    ptsFrom = ptsKeyBuf;

    phnRule = NULL;

    // Loop over each part of the key path.
    ptsTo   = ptsKeyPath;

    while (ptsFrom[0] != 0)
    {
        // Copy the next segment from pptsKey to ptsKeyPath.
        ptsEnd = _tcschr( &ptsFrom[1], L'\\' );
        if (ptsEnd == NULL)
            ptsEnd = ptsKeyBuf+dwKeyLen-1;
        _tcsncpy( ptsTo, ptsFrom, ptsEnd-ptsFrom );
        ptsTo[ptsEnd-ptsFrom] = 0;
        ptsTo += ptsEnd-ptsFrom;
        ptsFrom = ptsEnd;

        if ( *pptsValue != NULL )
        {
            // First look up each piece with value attached
            phnRule = Lookup( ptsRootBuf, ptsKeyPath, ptsValBuf );
 
            // Apply only if recursive or at the end of the key
            if (phnRule != NULL && 
                ((phnRule->dwAction & recursive_fa) || (ptsFrom[0]==0)))
            {
                dwResult = ApplyRule(phnRule,
                                     ptsFrom,
                                     pptsRoot,
                                     pptsKey,
                                     pptsValue,
                                     pdwType,
                                     ppbData,
                                     pdwDataLen,
                                     pfForce);
                if (dwResult)
                    goto cleanup;
                if (phnRule->dwAction & suppress_fa)
                {
                    fSuppress = TRUE;
                }
                if (phnRule->dwAction & file_fa && 
                    (REG_SZ == *pdwType || REG_EXPAND_SZ == *pdwType || REG_MULTI_SZ == *pdwType))
                {
                    fSuppress = TRUE;
                    fFileRuleFound = TRUE;
                }
            }
        }

        // Check with no value attached
        phnRule = Lookup( ptsRootBuf, ptsKeyPath, NULL );

        // Apply only if recursive or at the end of the key
        if (phnRule != NULL && 
            ((phnRule->dwAction & recursive_fa) || (ptsFrom[0]==0)))
        {
            dwResult = ApplyRule(phnRule,
                                 ptsFrom,
                                 pptsRoot,
                                 pptsKey,
                                 pptsValue,
                                 pdwType,
                                 ppbData,
                                 pdwDataLen,
                                 pfForce);
            if (dwResult)
                goto cleanup;

            if (phnRule->dwAction & suppress_fa)
            {
                fSuppress = TRUE;
            }
            if (phnRule->dwAction & file_fa && 
                (REG_SZ == *pdwType || REG_EXPAND_SZ == *pdwType || REG_MULTI_SZ == *pdwType))
            {
                fSuppress = TRUE;
                fFileRuleFound = TRUE;
            }
        }
    }

    if (fFileRuleFound)
    {
        //Add to the list of files to be fixed up later.
        CRegFileList *prfl = new CRegFileList(*pptsRoot,
                                              *pptsKey,
                                              *pptsValue,
                                              (TCHAR *)*ppbData,
                                              *pdwType);

        if (prfl == NULL)
        {
            Win32PrintfResource(LogFile,
                                IDS_NOT_ENOUGH_MEMORY);
            dwResult = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        if (DebugOutput || VerboseReg)
            Win32Printf(LogFile,
                        "Applying file_fa rule to %s\\%s [%s], "
                        "data = %s\r\n",
                        *pptsRoot,
                        *pptsKey,
                        (*pptsValue) ? *pptsValue : TEXT("NULL"),
                        (TCHAR *)*ppbData);

        prfl->SetNext(g_prflStart);
        g_prflStart = prfl;
    }

    if (fSuppress)
    {
        free(*pptsKey);
        free(*pptsValue);
        *pptsRoot = NULL;
        *pptsKey = NULL;
        *pptsValue = NULL;
    }

cleanup:
    if (Verbose && dwResult != ERROR_SUCCESS)
        printf( "Filter failed with 0x%x\r\n", dwResult );
    return dwResult;
}

//---------------------------------------------------------------
DWORD LoadSectionRules( const TCHAR *ptsSection, DWORD dwFlags )
{
    INFCONTEXT  ic;
    DWORD       dwResult = ERROR_SUCCESS;
    BOOL        fSuccess;
    HASH_NODE  *phnRule;

    // Open the section.
    fSuccess = SetupFindFirstLine( InputInf, ptsSection, NULL, &ic );

    // Read all the rules in the section.
    while (fSuccess)
    {
        // Parse the rule.
        dwResult = ParseRule( &ic, &phnRule );
        FAIL_ON_ERROR( dwResult );
        if (dwFlags == function_fa)  // remove the rename flags
        {
            phnRule->dwAction = function_fa;
        }
        else
        {
            phnRule->dwAction |= dwFlags;
        }

        // Save the rule in the hash table.
        Insert( phnRule );
        phnRule = NULL;

        // Advance to the next line.
        fSuccess = SetupFindNextLine( &ic, &ic );
    }

cleanup:
    return dwResult;
}

/***************************************************************************

        InitializeHash

     Read the filtering rules from the specified INF file.  Read the rules
from the sections for forcing, suppressing, renaming, and functions.

***************************************************************************/
DWORD InitializeHash()
{
    DWORD        i;
    DWORD        dwResult = ERROR_SUCCESS;
    INFCONTEXT   ic;
    BOOL         fSuccess;
    TCHAR       *ptsBuffer;
    CStringList *pslAdd        = NULL;
    CStringList *pslRen        = NULL;
    CStringList *pslFile       = NULL;
    CStringList *pslDel        = NULL;
    CStringList *pslCurr;

    // Initialize the hash table.
    for (i = 0; i < NUM_HASH_BUCKETS; i++)
    {
        HashTable[i].phhNext = &HashTable[i];
        HashTable[i].phhPrev = &HashTable[i];
    }

    // Load rules from the filter sections.

    // Since we try to force by default, it is okay to load in the Win9x force rules
    // and apply them even if the source is NT.  If they exist, we'll force overwriting,
    // but if not, no harm done.
    dwResult = LoadSectionRules( FORCE_SECTION, force_fa );
    LOG_ASSERT( dwResult );

    // We shouldn't write these keys regardless of the source OS
    dwResult = LoadSectionRules( SUPPRESS_SECTION, suppress_fa );
    LOG_ASSERT( dwResult );

    // This section describes keys that should be removed from the default hive before 
    // migrating the settings.  It is not specific to any source OS.
    dwResult = LoadSectionRules( DELETE_SECTION, delete_fa );
    LOG_ASSERT( dwResult );

    if (SourceVersion & 0x80000000)
    {
        dwResult = LoadSectionRules( RENAME_SECTION, 0 );
        LOG_ASSERT( dwResult );
        dwResult = LoadSectionRules( FILE_SECTION, file_fa );
        LOG_ASSERT( dwResult );
        dwResult = LoadSectionRules( FUNCTION_SECTION, function_fa );
        LOG_ASSERT( dwResult );
    }

    // Load from copied rules sections.
    dwResult = LoadSectionRules( EXTENSION_ADDREG_SECTION, force_fa );
    LOG_ASSERT( dwResult );
    dwResult = LoadSectionRules( EXTENSION_RENREG_SECTION, 0 );
    LOG_ASSERT( dwResult );
    dwResult = LoadSectionRules( EXTENSION_REGFILE_SECTION, file_fa );
    LOG_ASSERT( dwResult );
    dwResult = LoadSectionRules( EXTENSION_DELREG_SECTION, suppress_fa );
    LOG_ASSERT( dwResult );

    // Open the section list.
    fSuccess = SetupFindFirstLine( InputInf, EXTENSION_SECTION, NULL, &ic );
    if (!fSuccess)
        return ERROR_SUCCESS;

    // Allocate the section name lists.
    pslAdd  = new CStringList( 0 );
    pslRen  = new CStringList( 0 );
    pslFile = new CStringList( 0 );
    pslDel  = new CStringList( 0 );
    if (pslAdd == NULL || pslRen == NULL || pslFile == NULL || pslDel == NULL)
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        LOG_ASSERT( dwResult );
    }

    // Make lists of the names of sections of each type.
    do
    {
        // Parse the line.
        dwResult = ParseSectionList( &ic, &ptsBuffer, &pslCurr );
        FAIL_ON_ERROR( dwResult );

        // Save the value if its one of the ones we are looking for.
        if (ptsBuffer != NULL)
        {
            if (_tcsicmp( ptsBuffer, ADDREG_LABEL ) == 0)
                pslAdd->Add( pslCurr );
            else if (_tcsicmp( ptsBuffer, RENREG_LABEL ) == 0)
                pslRen->Add( pslCurr );
            else if (_tcsicmp( ptsBuffer, REGFILE_LABEL ) == 0)
                pslFile->Add( pslCurr );
            else if (_tcsicmp( ptsBuffer, DELREG_LABEL ) == 0)
                pslDel->Add( pslCurr );
            else if (!_tcsicmp( ptsBuffer, COPYFILES_LABEL ) &&
                     !_tcsicmp( ptsBuffer, DELFILES_LABEL ))
                LOG_ASSERT_EXPR( FALSE, IDS_INF_ERROR, dwResult, SPAPI_E_GENERAL_SYNTAX );
            free( ptsBuffer );
        }

        // Advance to the next line.
        fSuccess = SetupFindNextLine( &ic, &ic );

    } while( fSuccess);

    // Process all the addreg sections.
    for (pslCurr = pslAdd->Next();
         pslCurr != pslAdd;
         pslCurr = pslCurr->Next())
    {
        dwResult = LoadSectionRules( pslCurr->String(), force_fa );
        LOG_ASSERT( dwResult );
    }

    // Process all the renreg sections.
    for (pslCurr = pslRen->Next();
         pslCurr != pslRen;
         pslCurr = pslCurr->Next())
    {
        dwResult = LoadSectionRules( pslCurr->String(), 0 );
        LOG_ASSERT( dwResult );
    }

    // Process all the regfile sections.
    for (pslCurr = pslFile->Next();
         pslCurr != pslFile;
         pslCurr = pslCurr->Next())
    {
        dwResult = LoadSectionRules( pslCurr->String(), file_fa );
        LOG_ASSERT( dwResult );
    }

    // Process all the delreg sections.
    for (pslCurr = pslDel->Next();
         pslCurr != pslDel;
         pslCurr = pslCurr->Next())
    {
        dwResult = LoadSectionRules( pslCurr->String(), suppress_fa );
        LOG_ASSERT( dwResult );
    }

cleanup:
    if (pslAdd != NULL)
        delete pslAdd;
    if (pslRen != NULL)
        delete pslRen;
    if (pslFile != NULL)
        delete pslFile;
    if (pslDel != NULL)
        delete pslDel;
    return dwResult;
}

/***************************************************************************

        ParseAssignment

     Parse the line into a variable name and a value name.  Allow optional
whitespace and quotes around the variable or value names.  This function
allocates buffers for the variable and value names which the caller must
free.  Return a NULL pointer for the variable name if the line cannot be
parsed.

Note:     The caller is required to free the following variables even if
          this function fails.
          pptsVar
          pptsValue

***************************************************************************/
DWORD ParseAssignment( INFCONTEXT *pic,
                       DWORD dwLen,
                       TCHAR **pptsVar,
                       TCHAR **pptsValue )
{
    BOOL  fSuccess;
    DWORD dwResult = ERROR_SUCCESS;
    DWORD dwVarLen;
    DWORD dwValueLen;    

    // Initialize out params
    *pptsVar = *pptsValue = NULL;

    // Query the two lengths we need
    fSuccess = SetupGetStringField( pic, 0, NULL, 0, &dwVarLen );
    LOG_ASSERT_GLE( fSuccess, dwResult );

    fSuccess = SetupGetStringField( pic, 1, NULL, 0, &dwValueLen );
    LOG_ASSERT_GLE( fSuccess, dwResult );

    // Allocate memory for both
    *pptsVar = (TCHAR *) malloc( dwVarLen * sizeof(TCHAR) );
    *pptsValue = (TCHAR *) malloc( dwValueLen * sizeof(TCHAR) );
    if( *pptsVar == NULL || *pptsValue == NULL )
    {
      free(*pptsVar);
      free(*pptsValue);
      *pptsVar = *pptsValue = NULL;

      Win32PrintfResource( LogFile, IDS_NOT_ENOUGH_MEMORY );
      return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Read the variable name
    fSuccess = SetupGetStringField( pic, 0, *pptsVar, dwVarLen, NULL );
    LOG_ASSERT_EXPR(fSuccess, IDS_GETSTRINGFIELD_ERROR, 
                    dwResult, SPAPI_E_SECTION_NAME_TOO_LONG);

    // Read the value name
    fSuccess = SetupGetStringField( pic, 1, *pptsValue, dwValueLen, NULL );
    LOG_ASSERT_EXPR(fSuccess, IDS_GETSTRINGFIELD_ERROR, 
                    dwResult, SPAPI_E_SECTION_NAME_TOO_LONG);

cleanup:
    return dwResult;
}


/***************************************************************************

        ReadUser

     Read the user section of migration.inf and return the values for the
name of the settings section, the user name, and the domain name.

Note:     The caller is required to free the following variables even if
          this function fails.
          pptsSettingsSection
          pptsDomainName
          pptsUsername

***************************************************************************/
DWORD ReadUser( TCHAR **pptsSettingsSection,
                TCHAR **pptsDomainName,
                TCHAR **pptsUsername )
{
    DWORD       dwResult;
    BOOL        fSuccess;
    INFCONTEXT  ic;
    DWORD       dwReqLen;
    TCHAR      *var;
    TCHAR      *value;
    TCHAR      *user_section = NULL;

    // Find the section for users.
    fSuccess = SetupFindFirstLine( InputInf, USERS_SECTION, NULL, &ic );
    if (fSuccess == FALSE)
    {
        dwResult = GetLastError();
        if (Verbose)
            Win32Printf(LogFile, 
                        "ERROR: Could not find %s in Input INF: %d\r\n", 
                        USERS_SECTION, dwResult);
        LOG_ASSERT( dwResult );
    }

    // Find the name of the section containing user info.
    do
    {
        // Find the length of the line.
        dwReqLen = 0;
        fSuccess = SetupGetLineText( &ic, NULL, NULL, NULL, NULL, 0, &dwReqLen );
        if (dwReqLen == 0)
            LOG_ASSERT_GLE( fSuccess, dwResult );

        // Parse the line.
        dwResult = ParseAssignment( &ic, dwReqLen, &var, &value );
        FAIL_ON_ERROR( dwResult );

        // Save the value if its one of the ones we are looking for.
        if (var != NULL)
        {
            if (_tcsicmp( var, TEXT("section") ) == 0)
                user_section = value;
            else
                free( value );
            free( var );
        }

        // Advance to the next line.
        fSuccess = SetupFindNextLine( &ic, &ic );

    } while( fSuccess);

    // Find the section for the user.
    fSuccess = SetupFindFirstLine( InputInf, user_section, NULL, &ic );
    LOG_ASSERT_GLE( fSuccess, dwResult );

    // Read each line in the section.
    do
    {
        // Find the length of the line.
        dwReqLen = 0;
        fSuccess = SetupGetLineText( &ic, NULL, NULL, NULL, NULL, 0, &dwReqLen );
        if (dwReqLen == 0)
            LOG_ASSERT_GLE( fSuccess, dwResult );

        // Parse the line.
        dwResult = ParseAssignment( &ic, dwReqLen, &var, &value );
        FAIL_ON_ERROR( dwResult );

        // Save the value if its one of the ones we are looking for.
        if (var != NULL)
        {
            if (_tcsicmp( var, TEXT("user") ) == 0)
                *pptsUsername = value;
            else if (_tcsicmp( var, TEXT("domain") ) == 0)
                *pptsDomainName = value;
            else if (_tcsicmp( var, TEXT("section") ) == 0)
                *pptsSettingsSection = value;
            else
                free( value );
            free( var );
        }

        // Advance to the next line.
        fSuccess = SetupFindNextLine( &ic, &ic );

    } while( fSuccess);

    // It is an error if the username, domainname, or settings section
    // isn't specified.
    if (*pptsUsername == NULL || *pptsDomainName == NULL || *pptsSettingsSection == NULL)
    {
        Win32PrintfResource( LogFile, IDS_INF_ERROR );
        dwResult = SPAPI_E_GENERAL_SYNTAX;
    }

cleanup:
    if (user_section != NULL)
        free( user_section );
    return dwResult;
}

/***************************************************************************

        ParseRegistry

     Parse a line describing a registry key or value.

reg-root-string, [subkey], [value-name], [flags], [value]

reg-root-string         One of HKCR, HKCU, HKLM, HKU, HKR
subkey                  String name of subkey, may be quoted.
value-name              String name of value, may be quoted.
flags                   One of the following
  0x0                           REG_SZ
  0x10000                       REG_MULTI_SZ
  0x20000                       REG_EXPAND_SZ
  0x1                           REG_BINARY
  0x10001                       REG_DWORD

  0x100001                      REG_MULTI_SZ stored as binary because it
                                contains embedded newlines.
  0x200001                      REG_EXPAND_SZ stored as binary because it
                                contains embedded newlines.
  0x400001                      REG_SZ stored as binary because it
                                contains embedded newlines.
  0x800000                      REG_NONE
  other                         custom registry type directly copied 

value                   Depends on flags
  REG_SZ                        String, may be quoted.
  REG_MULTI_SZ                  List of comma separated strings, each of
                                which may be quoted.
  REG_EXPAND_SZ                 String, may be quoted.
  REG_BINARY                    List of comma separated bytes in hex.
  REG_DWORD                     Integer

Note:     The caller is required to free the following variables even if
          this function fails.
          pptsRootName
          key_name
          value_name
          data

***************************************************************************/
DWORD ParseRegistry( INFCONTEXT *pic, DWORD line_len,
                     TCHAR **pptsRootName, TCHAR **key_name,
                     TCHAR **value_name,
                     DWORD *value_type, TCHAR **data, DWORD *data_len )
{
    DWORD  len;
    DWORD  temp;
    BYTE  *bytes;
    DWORD  size = line_len*sizeof(TCHAR);
    DWORD  req_size;
    BOOL   fSuccess;
    DWORD  dwResult = ERROR_SUCCESS;

    // Allocate memory for all the parameters.
    *key_name   = (TCHAR *) malloc( size );
    *value_name = (TCHAR *) malloc( size );
    *data       = (TCHAR *) malloc( size );
    *pptsRootName  = (TCHAR *) malloc( size );
    if (*key_name == NULL || *value_name == NULL || *data == NULL ||
        *pptsRootName == NULL)
    {
        free( *key_name );
        free( *value_name );
        free( *data );
        free( *pptsRootName );
        *key_name   = NULL;
        *value_name = NULL;
        *data       = NULL;
        *pptsRootName  = NULL;
        Win32PrintfResource( LogFile, IDS_NOT_ENOUGH_MEMORY );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Get the reg-root-string.
    fSuccess = SetupGetStringField( pic, 1, *pptsRootName, line_len, &req_size );
    LOG_ASSERT_EXPR( fSuccess, IDS_INF_ERROR, dwResult, SPAPI_E_GENERAL_SYNTAX );

    // Verify that it is HKR or HKLM.
    fSuccess = (_tcsicmp( TEXT("HKR"), *pptsRootName ) == 0) ||
        (_tcsicmp( TEXT("HKLM"), *pptsRootName ) == 0);
    LOG_ASSERT_EXPR( fSuccess, IDS_INF_ERROR, dwResult, SPAPI_E_GENERAL_SYNTAX );

    // Get the subkey.
    fSuccess = SetupGetStringField( pic, 2, *key_name, line_len, &req_size );
    LOG_ASSERT_EXPR( fSuccess, IDS_INF_ERROR, dwResult, SPAPI_E_GENERAL_SYNTAX );

    // Get the value name.
    fSuccess = SetupGetStringField( pic, 3, *value_name, line_len, &req_size );
    LOG_ASSERT_EXPR( fSuccess, IDS_INF_ERROR, dwResult, SPAPI_E_GENERAL_SYNTAX );

    // Get the flags.  _tcstol detects a leading 0x and converts from hex.
    fSuccess = SetupGetIntField( pic, 4, (int *) value_type );

    // Read the data based on the data type.
    if (fSuccess)  // value_type is valid
    {
        // Read a string.
        if (*value_type == 0)
        {
            fSuccess = SetupGetStringField( pic, 5, *data, line_len, &req_size );
            LOG_ASSERT_EXPR( fSuccess, IDS_INF_ERROR, dwResult, SPAPI_E_GENERAL_SYNTAX );

            *data_len = req_size*sizeof(TCHAR);
            *value_type = REG_SZ;
        }

        // Read an expand string.
        else if (*value_type == 0x20000)
        {
            fSuccess = SetupGetStringField( pic, 5, *data, line_len, &req_size );
            LOG_ASSERT_EXPR( fSuccess, IDS_INF_ERROR, dwResult, SPAPI_E_GENERAL_SYNTAX );
            *data_len = req_size*sizeof(TCHAR);
            *value_type = REG_EXPAND_SZ;
        }

        // Read a multi string.
        else if (*value_type == 0x10000)
        {
            fSuccess = SetupGetMultiSzField( pic, 5, *data, line_len, &req_size );
            LOG_ASSERT_EXPR( fSuccess, IDS_INF_ERROR, dwResult, SPAPI_E_GENERAL_SYNTAX );
            *data_len = req_size*sizeof(TCHAR);
            *value_type = REG_MULTI_SZ;
        }

        // Read a dword.
        else if (*value_type == 0x10001)
        {
            fSuccess = SetupGetIntField( pic, 5, (int *) *data );
            LOG_ASSERT_EXPR( fSuccess, IDS_INF_ERROR, dwResult, SPAPI_E_GENERAL_SYNTAX );
            *data_len = sizeof(DWORD);
            *value_type = REG_DWORD;
        }

        // Read a binary.
        else
        {
            fSuccess = SetupGetBinaryField( pic, 5, (BYTE *) *data, size, &req_size );
            LOG_ASSERT_EXPR( fSuccess, IDS_INF_ERROR, dwResult, SPAPI_E_GENERAL_SYNTAX );
            *data_len = req_size;
            if (*value_type == 1)
                *value_type = REG_BINARY;
            else if (*value_type == 0x100001)
                *value_type = REG_MULTI_SZ;
            else if (*value_type == 0x200001)
                *value_type = REG_EXPAND_SZ;
            else if (*value_type == 0x400001)
                *value_type = REG_SZ;
            else if (*value_type == 0x800000)
                *value_type = REG_NONE;
        }
    }
    else
    {
        *value_type = REG_NONE;
        *data_len = 0;
        *data = NULL;
    }

cleanup:
    return dwResult;
}

//---------------------------------------------------------------
DWORD CopyInf( const TCHAR *ptsSettingsSection )
{
    DWORD       dwResult;
    BOOL        fSuccess;
    INFCONTEXT  ic;
    DWORD       line_len   = 0;
    DWORD       dwReqLen;
    TCHAR      *ptsKeyName   = NULL;
    TCHAR      *ptsValueName = NULL;
    TCHAR      *ptsRootName  = NULL;
    DWORD       dwValueType;
    BYTE       *data       = NULL;
    DWORD       dwDataLen;
    HKEY        hKey        = NULL;
    BOOL        fForce;
    BOOL        fExist;
    HKEY        hRootKey;

    if (Verbose)
    {
        Win32Printf(LogFile, "Processing Section [%s]\r\n", ptsSettingsSection);
    }
    // Find the section.
    fSuccess = SetupFindFirstLine( InputInf, ptsSettingsSection, NULL, &ic );
    if (!fSuccess)
        return ERROR_SUCCESS;

    // Process each line in the section.
    do
    {
        // Determine the line length.
        fForce = FALSE;
        fSuccess = SetupGetLineText( &ic,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     0,
                                     &dwReqLen );
        if (dwReqLen == 0)
            LOG_ASSERT_GLE( fSuccess, dwResult );

        // Parse the line.
        dwResult = ParseRegistry( &ic,
                                  dwReqLen,
                                  &ptsRootName,
                                  &ptsKeyName,
                                  &ptsValueName,
                                  &dwValueType,
                                  (TCHAR **) &data,
                                  &dwDataLen );
        FAIL_ON_ERROR( dwResult );

        if (ptsKeyName != NULL)
        {
            if ( VerboseReg )
            {
               Win32Printf(LogFile,
                           "Processing Key: ");
               WriteKey( LogFile, dwValueType, ptsRootName, ptsKeyName, ptsValueName, data, dwDataLen);
            }
            
            dwResult = Filter( &ptsRootName,
                               &ptsKeyName,
                               &ptsValueName,
                               &dwValueType,
                               &data,
                               &dwDataLen,
                               &fForce );
            FAIL_ON_ERROR( dwResult );

            // Create or open the key.
            if (ptsRootName != NULL)
            {
                if (_tcsicmp( TEXT("HKLM"), ptsRootName ) == 0)
                {
                    if (UserPortion)
                    {
                        goto cleanup;
                    }
                    hRootKey = HKEY_LOCAL_MACHINE;
                }
                else
                {
                    hRootKey = CurrentUser;
                }

                dwResult = RegCreateKeyEx( hRootKey,
                                           ptsKeyName,
                                           0,
                                           NULL,
                                           REG_OPTION_NON_VOLATILE,
                                           KEY_ALL_ACCESS,
                                           NULL,
                                           &hKey,
                                           NULL );
#ifndef SPECIFIC_USER
                if (dwResult == ERROR_ACCESS_DENIED)
                {
                    Win32PrintfResource( LogFile,
                                         IDS_REG_ACCESS,
                                         ptsRootName,
                                         ptsKeyName,
                                         NULL );
                    dwResult = ERROR_SUCCESS;
                }
                else
#endif
                    if (data != NULL)
                    {
                        LOG_ASSERT( dwResult );

                        // ptsValueName == NULL means key's unnamed
                        // or default value
                        if (!fForce)
                            fExist = RegQueryValueEx( hKey,
                                                      ptsValueName,
                                                      NULL,
                                                      NULL,
                                                      NULL,
                                                      NULL ) == ERROR_SUCCESS;

                        // Set values that don't exist or are forced.
                        if (fForce || !fExist)
                        {
                            if ( VerboseReg )
                            {
                               Win32Printf(LogFile,
                                           "=> Writing Key: ");
                               WriteKey( LogFile, dwValueType, ptsRootName, ptsKeyName, ptsValueName, data, dwDataLen);
                            }
                            dwResult = RegSetValueEx( hKey,
                                                      ptsValueName,
                                                      NULL,
                                                      dwValueType,
                                                      data,
                                                      dwDataLen );
                            LOG_ASSERT( dwResult );
                        }
                    }
            
            }


            // Free strings from the parser.
            free( ptsRootName );
            free( ptsKeyName );
            free( ptsValueName );
            free( data );
            RegCloseKey( hKey );
            ptsRootName  = NULL;
            hKey         = NULL;
            ptsKeyName   = NULL;
            ptsValueName = NULL;
            data         = NULL;
        }

        // Skip to the next line.
        fSuccess = SetupFindNextLine( &ic, &ic );

    } while(fSuccess);

cleanup:
    // Close the key.
    if (hKey != NULL)
        RegCloseKey( hKey );

    // Free strings from the parser.
    free( ptsRootName );
    free( ptsKeyName );
    free( ptsValueName );
    free( data );
    return dwResult;
}

/***************************************************************************

        BuildHive

    This function creates a hive for the specified user by copying the
default hive and adding all the registry keys in migration.inf according
to the registry rules.  The function returns the path to the hive.  The
caller is required to free the path to the hive even when this function
fails.

***************************************************************************/
DWORD BuildHive( TCHAR *ptsSettingsSection, TCHAR **pptsHiveName )
{
    TCHAR tsDefaultUser[MAX_PATH];
    DWORD dwDefaultUserLen = sizeof(tsDefaultUser);
    DWORD dwResult = ERROR_SUCCESS;
    DWORD dwLen;
    BOOL  fSuccess;

#ifdef SPECIFIC_USER
    // Find the location of the default user profile.
    fSuccess = GetDefaultUserProfileDirectory( tsDefaultUser,
                                               &dwDefaultUserLen );
    LOG_ASSERT_GLE( fSuccess, dwResult );
    if (dwDefaultUserLen + sizeof(HIVEFILE)+2 > MAX_PATH*sizeof(TCHAR) )
    {
        Win32PrintfResource( LogFile, IDS_FAILED );
        dwResult = ERROR_INTERNAL_ERROR;
        goto cleanup;
    }
    _tcscat( tsDefaultUser, HIVEFILE );

    // Compute a path for the temporary hive.
    *pptsHiveName = (TCHAR *) malloc( MAX_PATH*sizeof(TCHAR) );
    LOG_ASSERT_EXPR( *pptsHiveName != NULL, IDS_NOT_ENOUGH_MEMORY, dwResult,
                     ERROR_NOT_ENOUGH_MEMORY );
    dwLen = ExpandEnvironmentStrings( HIVEPATH, *pptsHiveName, MAX_PATH );
    LOG_ASSERT_EXPR( dwLen != 0 && dwLen <= MAX_PATH, IDS_FAILED, dwResult,
                     ERROR_INTERNAL_ERROR );

    // To handle errors better, preemptively unload any old key in the
    // registry at the path this function uses.
    RegUnLoadKey( HKEY_USERS, BUILDKEY );

    // Copy the default user hive to the temporary location.
    fSuccess = CopyFile( tsDefaultUser, *pptsHiveName, FALSE );
    LOG_ASSERT_GLE( fSuccess, dwResult );

    if (DebugOutput)
        Win32Printf(LogFile, "Loading the hive from %s\r\n", *pptsHiveName);
    // Load the hive.
    dwResult = RegLoadKey( HKEY_USERS, BUILDKEY, *pptsHiveName );
    LOG_ASSERT( dwResult );

    // Open the registry key.
    dwResult = RegOpenKeyEx( HKEY_USERS,
                             BUILDKEY,
                             0,
                             KEY_ALL_ACCESS,
                             &CurrentUser );
    LOG_ASSERT( dwResult );
#else
    dwResult = RegOpenKeyEx( HKEY_CURRENT_USER,
                             NULL,
                             0,
                             KEY_ALL_ACCESS,
                             &CurrentUser );
    LOG_ASSERT( dwResult );
#endif

    dwResult = DeleteInf ();  // delete unwanted .DEFAULT values
    FAIL_ON_ERROR (dwResult);

    // Process the INF file.
    dwResult = CopyInf( ptsSettingsSection );
    FAIL_ON_ERROR( dwResult );

cleanup:
    return dwResult;
}

//---------------------------------------------------------------
void CleanupUser()
{
    // Close the key.
    if (CurrentUser != NULL)
    {
        RegCloseKey( CurrentUser );
        CurrentUser = NULL;
    }

    // Unload the hive.
    RegUnLoadKey( HKEY_USERS, BUILDKEY );
}

//---------------------------------------------------------------
DWORD CreateUserProfileFromName( TCHAR *ptsDomainName,
                                 TCHAR *ptsUsername,
                                 TCHAR *ptsHiveName )
{
    SID                 *pSid;
    DWORD                dwSidLen      = SID_GUESS;
    TCHAR               *ptsFullName;
    DWORD                dwDomainLen;
    DWORD                dwUserLen;
    SID_NAME_USE         sid_use;
    DWORD                dwResult       = ERROR_SUCCESS;
    BOOL                 fSuccess;

#ifdef SPECIFIC_USER
    // Create the user profile when /u or (/f without /q flag) was used
    if ((FALSE == CopyUser) && 
        ((FALSE == CopyFiles) || (TRUE == TestMode)))
#endif
        return ERROR_SUCCESS;

#ifdef SPECIFIC_USER
    //Close the registry keys and stuff, we'll get them back after we create
    //the profile.
    CleanupUser();

    dwDomainLen   = _tcslen( ptsDomainName ) + 1;
    dwUserLen     = _tcslen( ptsUsername ) + 1;

    // Allocate space to hold the sid and construct the full domain\username.
    pSid       = (SID *) _alloca( dwSidLen );
    ptsFullName  = (TCHAR *) _alloca( (dwDomainLen + dwUserLen + 2) *
                                      sizeof(TCHAR) );

    _tcscpy( ptsFullName, ptsDomainName );
    ptsFullName[dwDomainLen-1] = L'\\';
    _tcscpy( &ptsFullName[dwDomainLen], ptsUsername );

    // Get the SID for the specified user.
    fSuccess = LookupAccountName( NULL,
                                  ptsFullName,
                                  pSid,
                                  &dwSidLen,
                                  ptsDomainName,
                                  &dwDomainLen,
                                  &sid_use);
    if (!fSuccess)
    {
        // Try allocating a bigger buffer.
        if (dwSidLen > SID_GUESS)
        {
            pSid       = (SID *) _alloca( dwSidLen );
            fSuccess = LookupAccountName( NULL,
                                          ptsFullName,
                                          pSid,
                                          &dwSidLen,
                                          ptsDomainName,
                                          &dwDomainLen,
                                          &sid_use);
        }
        if (fSuccess == FALSE)
        {
            dwResult = GetLastError();
            if (DebugOutput)
            {
                Win32Printf(LogFile, 
                            "Could not find account name for %s: %d\r\n", 
                            ptsFullName, dwResult);
            }
        }
        LOG_ASSERT( dwResult );
    }

    // Allocate memory to hold the path to the user profile.
    UserPath = (TCHAR *) malloc( MAX_PATH*sizeof(TCHAR) );
    UserPath[0]=0;
    LOG_ASSERT_EXPR( UserPath != NULL, IDS_NOT_ENOUGH_MEMORY, dwResult,
                     ERROR_NOT_ENOUGH_MEMORY );

    // Create the user profile directory.
    fSuccess = CreateUserProfile( pSid,
                                  ptsUsername,
                                  ptsHiveName,
                                  UserPath,
                                  MAX_PATH*sizeof(TCHAR) );
    if (DebugOutput)
        Win32Printf(LogFile, 
                    "Creating Profile for %s in %s from %s\r\n", 
                    ptsUsername, UserPath, ptsHiveName);
    if (fSuccess == FALSE)
    {
        dwResult = GetLastError();
        if (dwResult == ERROR_SHARING_VIOLATION)
        {
            Win32PrintfResource( LogFile, IDS_CANT_LOAD_CURRENT_USER );
            goto cleanup;
        }
        LOG_ASSERT( dwResult );
    }
    if (0 == UserPath[0])
    {
        Win32PrintfResource( LogFile, IDS_USER_PROFILE_FAILED );
        dwResult = ERROR_INTERNAL_ERROR;
        goto cleanup;
    }

    //Reopen the new hive
    TCHAR _tcsHivePath[MAX_PATH + 1];
    if (_tcslen(UserPath) + _tcslen(HIVEFILE) > MAX_PATH)
    {
        if (DebugOutput)
        {
            Win32Printf(LogFile, "Error: hivepath too long %s%s\r\n", UserPath, HIVEFILE);
        }
        dwResult = ERROR_FILENAME_EXCED_RANGE;
        goto cleanup;
    }
    _tcscpy(_tcsHivePath, UserPath);
    _tcscat(_tcsHivePath, HIVEFILE);

    dwResult = RegLoadKey(HKEY_USERS, BUILDKEY, _tcsHivePath);
    if (DebugOutput)
        Win32Printf(LogFile, "Loading hive from %s\r\n", _tcsHivePath);
    if (dwResult)
    {
        LOG_ASSERT( dwResult );
    }

    //Reopen the registry from the new location
    dwResult = RegOpenKeyEx(HKEY_USERS,
                            BUILDKEY,
                            0,
                            KEY_ALL_ACCESS,
                            &CurrentUser);
    if (dwResult)
    {
        LOG_ASSERT(dwResult);
    }

cleanup:
    return dwResult;
#endif
}

//---------------------------------------------------------------
DWORD FixSpecial()
{
    CRegFileList *prfl = g_prflStart;
    DWORD dwResult = ERROR_SUCCESS;

    while (prfl != NULL)
    {
        const TCHAR *ptsRoot, *ptsKey, *ptsVal, *ptsData;
        DWORD dwValueType;
        TCHAR *ptsLocation, *ptsFinalValue;
        TCHAR tsExpand[MAX_PATH + 1];
        TCHAR tsTemp[MAX_PATH + 1];

        prfl->GetData(&ptsRoot, &ptsKey, &ptsVal, &ptsData, &dwValueType);

        dwResult = WhereIsThisFile(ptsData, &ptsLocation);
        if (ERROR_NOT_FOUND == dwResult)
        {
            ptsLocation = (TCHAR *)ptsData;
        }
        else if (ERROR_SUCCESS != dwResult)
        {
            return dwResult;
        }


        //Expand any environment strings in the original data with
        //the values for the user we're loading for.  If the final
        //paths match, we'll retain the version of the data with the
        //unexpanded environment variables in it.  Otherwise, we take
        //the full path.
        if (_tcslen(ptsData) > MAX_PATH)
        {
            if (DebugOutput)
            {
                Win32Printf(LogFile, "Error: ptsData too long %s\r\n", ptsData);
            }
            return ERROR_FILENAME_EXCED_RANGE;
        }
        _tcscpy(tsExpand, ptsData);
        dwResult = ExpandEnvStringForUser(tsExpand,
                                          tsTemp,
                                          &ptsFinalValue);
        if (dwResult)
            return dwResult;

        if (_tcsicmp(ptsLocation, ptsFinalValue) == 0)
        {
            //They're the same, use the string with the environment
            //variables in it.
            ptsFinalValue = (TCHAR *)ptsData;
        }
        else
        {
            ptsFinalValue = ptsLocation;
        }

        if (ptsRoot != NULL)
        {
            HKEY hRootKey;
            HKEY hKey;

            if (_tcsicmp(TEXT("HKLM"), ptsRoot) == 0)
                hRootKey = HKEY_LOCAL_MACHINE;
            else
                hRootKey = CurrentUser;

            dwResult = RegCreateKeyEx(hRootKey,
                                      ptsKey,
                                      NULL,
                                      NULL,
                                      REG_OPTION_NON_VOLATILE,
                                      KEY_ALL_ACCESS,
                                      NULL,
                                      &hKey,
                                      NULL);

            LOG_ASSERT(dwResult);
            if ( VerboseReg )
            {
               Win32Printf(LogFile,
                           "=> Writing Key: ");
               WriteKey(LogFile, 
                        dwValueType, (TCHAR *)ptsRoot, (TCHAR *)ptsKey, (TCHAR *)ptsVal, (UCHAR *)ptsFinalValue, _tcslen(ptsFinalValue)+1);
            }

            dwResult = RegSetValueEx(hKey,
                                     ptsVal,
                                     NULL,
                                     dwValueType,
                                     (BYTE *)ptsFinalValue,
                                     (_tcslen(ptsFinalValue) + 1) *
                                     sizeof(TCHAR));
            RegCloseKey(hKey);
            LOG_ASSERT(dwResult);
        }

        free(ptsLocation);

//  Next:
        CRegFileList *prflPrev;
        prflPrev = prfl;

        prfl = prfl->GetNext();
        delete prflPrev;
        g_prflStart = prfl;
    }

cleanup:
    return dwResult;
}

//---------------------------------------------------------------
DWORD LoadUser( TCHAR **pptsDomainName,
                TCHAR **pptsUsername,
                TCHAR **pptsHiveName )
{
    TCHAR *ptsSettingsSection = NULL;
    DWORD  dwResult;

    // Initialize the hash table with the filter rules.
    dwResult = InitializeHash( );
    FAIL_ON_ERROR( dwResult );

    // Fetch user info only if /u or (/f without /q) flag was used
    if ((FALSE == CopyUser) && 
        ((FALSE == CopyFiles) || (TRUE == TestMode)))
    {
        // Open the registry key.
        dwResult = RegOpenKeyEx( HKEY_CURRENT_USER,
                                 NULL,
                                 0,
                                 KEY_ALL_ACCESS,
                                 &CurrentUser );
        LOG_ASSERT( dwResult );
        return ERROR_SUCCESS;
    }

    // Read the user information from the inf file.
    dwResult = ReadUser( &ptsSettingsSection, pptsDomainName, pptsUsername );
    FAIL_ON_ERROR( dwResult );

#ifdef SPECIFIC_USER
    // Enable some privileges.
    dwResult = EnableBackupPrivilege();
    FAIL_ON_ERROR( dwResult );
#endif

    // If the user was on a Win9x machine,
    // apply all the settings to a new hive.
    dwResult = BuildHive( ptsSettingsSection, pptsHiveName );
    FAIL_ON_ERROR( dwResult );

cleanup:
    if (ptsSettingsSection != NULL)
        free( ptsSettingsSection );
    return dwResult;
}

//---------------------------------------------------------------
DWORD ProcessExtensions()
{
    // Apply registry keys in the copied state section.
    return CopyInf( EXTENSION_STATE_SECTION );
}


//*****************************************************************
//
//  Synopsis:       Build a file list string out of a CStringList.
//
//  History:        11/14/1999   Created by WeiruC.
//
//  Return Value:   Win32 error code.
//
//*****************************************************************

DWORD BuildFileListString(CStringList* fileList, TCHAR** tcsFileList)
{
    DWORD       cFileListBuffer = 10240;  // length of file list string buffer
    DWORD       cFileListString = 0;      // length of file list string
    DWORD       rv = ERROR_SUCCESS;       // return value
    TCHAR*      tcsTargetFileName = NULL;
    TCHAR*      tmpStringBuffer;
    CStringList*    cur;

    *tcsFileList = new TCHAR[cFileListBuffer];
    **tcsFileList = TEXT('\0');

    if(fileList == NULL || (fileList->String())[0] == TEXT('\0'))
    {
        return rv;
    }

    cur = fileList->Next();

    //
    // For every file in the source file list, call Phil's code to figure out
    // where that file is migrated to, and then add it to the target file list
    // string.
    //

    do
    {
        rv = WhereIsThisFile(cur->String(), &tcsTargetFileName);
        if(rv == ERROR_SUCCESS)
        {
            if(cFileListBuffer - cFileListString <= _tcslen(tcsTargetFileName))
            {
                //
                // String buffer is not big enough. Double it.
                //

                tmpStringBuffer = *tcsFileList;
                *tcsFileList = new TCHAR[cFileListBuffer *= 2];
                _tcscpy(*tcsFileList, tmpStringBuffer);
                delete []tmpStringBuffer;
            }

            //
            // Add the new file name to the new file list.
            //

            _tcscat(*tcsFileList, tcsTargetFileName);
            _tcscat(*tcsFileList, TEXT(" "));

            cFileListString += _tcslen(tcsTargetFileName) + 1;
        }

        if(tcsTargetFileName != NULL)
        {
            free(tcsTargetFileName);
            tcsTargetFileName = NULL;
        }

        if(cur == fileList)
        {
            break;
        }

        //
        // Go to the next file.
        //

        cur = cur->Next();
    }
    while(TRUE);

    if(tcsTargetFileName != NULL)
    {
        free(tcsTargetFileName);
    }

    return rv;
}


//*****************************************************************
//
//  Synopsis:       Run an executable in a child process.
//
//  History:        11/14/1999   Created by WeiruC.
//
//  Return Value:   Win32 error code.
//
//*****************************************************************

DWORD RunCommandInChildProcess(CStringList*  command, CStringList* fileList)
{
    SECURITY_ATTRIBUTES     sa;                 // allow handles to be inherited
    DWORD                   rv = ERROR_SUCCESS; // return value
    STARTUPINFO             si;
    PROCESS_INFORMATION     pi;
    TCHAR*                  tcsFileList = NULL;
    TCHAR*                  cur;
    CStringList*            tmp;                // used when growing the string
    TCHAR                   fileName[MAX_PATH + 1];
    TCHAR*                  commandLine = NULL; // command line
    DWORD                   commandLineLen = 0; // command line length
    DWORD                   cFileList = 10240;  // string length of tcsFileList

    ZeroMemory(&si, sizeof(STARTUPINFO));
    si.cb = sizeof(STARTUPINFO);

    //
    // Build the file list string. We ignore error here. If a file is not picked
    // up, we'll still pass it to the command. We'll let the user's executable
    // handle the error.
    //

    BuildFileListString(fileList, &tcsFileList);

    //
    // Initialize the command line. We can either do two loops to count how big
    // a string we need for the command line, or do one loops and just set a
    // max limit on how long the command line is allowed. We probably won't
    // have that many commands or arguments anyway.
    //

    commandLineLen += _tcslen(command->String()) + 3;   // '"' + '"' + ' '
    commandLineLen += _tcslen(tcsFileList) + 1;         // ' '
    for(tmp = command->Next(); tmp != command; tmp = tmp->Next())
    {
        commandLineLen += _tcslen(tmp->String()) + 3;   // '"' + '"' + ' '
    }
    commandLine = new TCHAR[commandLineLen + _tcslen(tcsFileList) + 1];
    commandLine[0] = TEXT('\0');
    MakeCommandLine(command, command->Next(), commandLine);
    _tcscat(commandLine, tcsFileList);

    if(!CreateProcess(NULL,
                      commandLine,
                      NULL,
                      NULL,
                      TRUE,
                      0,
                      NULL,
                      NULL,
                      &si,
                      &pi))
    {
        rv = GetLastError();
        goto cleanup;
    }

cleanup:

    if(tcsFileList != NULL)
    {
        delete []tcsFileList;
    }

    if(commandLine != NULL)
    {
        delete []commandLine;
    }

    return rv;
}


//*****************************************************************
//
//  Synopsis:       Process the [Run These Commands] extension section in an inf
//                  file.
//
//  History:        11/14/1999   Created by WeiruC.
//
//  Return Value:   Win32 error code.
//
//*****************************************************************

DWORD ProcessExecExtensions()
{
    DWORD           rv = ERROR_SUCCESS;     // return value
    BOOL            success = TRUE;         // value returned by setup functions
    INFCONTEXT      context;                // used by setup inf functions
    INFCONTEXT      contextOutput;          // Run These Commands Output section
    TCHAR*          label = NULL;           // label in inf file
    TCHAR*          labelOutput = NULL;     // label in inf file
    CStringList*    command = NULL;         // command
    CStringList*    fileList = NULL;        // file list from Scanstate

    if(InputInf == INVALID_HANDLE_VALUE)
    {
        return ERROR_SUCCESS;
    }

    //
    // Find the section in the inf file. If it doesn't exist, do nothing and
    // return ERROR_SUCCESS.
    //

    if(!SetupFindFirstLine(InputInf, EXECUTABLE_EXT_SECTION, NULL, &context))
    {
        return ERROR_SUCCESS;
    }

    //
    // Process each line in the section:
    //     Find matching file list from Scanstate
    //     run the command
    //

    do
    {
        //
        // Parse the line.
        //

        rv = ParseSectionList(&context, &label, &command);
        FAIL_ON_ERROR(rv);

        if((command->String())[0] != TEXT('\0'))
        {
            //
            // Find matching output from Scanstate.
            //

            if(SetupFindFirstLine(InputInf,
                                   EXECUTABLE_EXTOUT_SECTION,
                                   label,
                                   &contextOutput))
            {
                //
                // Parse the line.
                //

                rv = ParseSectionList(&contextOutput, &labelOutput, &fileList);
                FAIL_ON_ERROR(rv);
            }

            //
            // Create a child process to run the command. Ignore error and
            // continue to run the next command.
            //

            RunCommandInChildProcess(command, fileList);
        }

        //
        // Clean up and reinitialize.
        //

        if(label)
        {
            free(label);
            label = NULL;
        }
        if(labelOutput)
        {
            free(labelOutput);
            labelOutput = NULL;
        }
        if(command)
        {
            delete command;
            command = NULL;
        }
        if(fileList)
        {
            delete fileList;
            fileList = NULL;
        }
    }
    while(SetupFindNextLine(&context, &context));

cleanup:

    if(label)
    {
        free(label);
    }
    if(labelOutput)
    {
        free(labelOutput);
        labelOutput = NULL;
    }
    if(command)
    {
        delete command;
    }
    if(fileList)
    {
        delete fileList;
        fileList = NULL;
    }

    return rv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\scanstate\scanhead.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 1998.
//
//  File:	headers.cxx
//
//  Contents:	Precompiled headers for userfile directory
//
//  Classes:	
//
//  Functions:	
//
//  History:	02-Sep-99	PhilipLa	Created
//
//----------------------------------------------------------------------------


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <stdio.h>
#include <io.h>
#include <malloc.h>

#include <tchar.h>
#include <setupapi.h>
#include <mbstring.h>

#include <shlobj.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\loadstate\loadstate.cxx ===
//--------------------------------------------------------------
//
// File:        loadstate
//
// Contents:    Load a machine state.
//
//---------------------------------------------------------------

#include "loadhead.cxx"
#pragma hdrstop

#include <common.hxx>
#include <objerror.h>
#include <loadstate.hxx>
#include <bothchar.hxx>

//---------------------------------------------------------------
// Constants.

const char MIGRATEINF[] = "\\migration.inf";

//---------------------------------------------------------------
// Types.

//---------------------------------------------------------------
// Macros

//---------------------------------------------------------------
// Globals.

DWORD SourceVersion = 0;
TCHAR szLogFile[MAX_PATH+1];



//---------------------------------------------------------------
DWORD GetSourceVersion()
{
  DWORD       dwResult = ERROR_SUCCESS;
  BOOL        fSuccess;
  INFCONTEXT  ic;
  DWORD       dwRealLen;
  TCHAR      *ptsVar   = NULL;
  
  // Find the section.
  fSuccess = SetupFindFirstLine( InputInf, SOURCE_SECTION, NULL, &ic );
  LOG_ASSERT_GLE( fSuccess, dwResult );

  // Find the version.
  do
  {
    // Get the correct length
    fSuccess = SetupGetStringField( &ic, 0, NULL, 0, &dwRealLen );
    LOG_ASSERT_GLE( fSuccess, dwResult );

    // Presumably we have the correct length now...
    ptsVar = (TCHAR *) malloc(dwRealLen * sizeof(TCHAR));
    LOG_ASSERT_EXPR( ptsVar != NULL, IDS_NOT_ENOUGH_MEMORY, dwResult,
                     ERROR_NOT_ENOUGH_MEMORY );

    fSuccess = SetupGetStringField( &ic, 0, ptsVar, dwRealLen, NULL);
    LOG_ASSERT_EXPR(fSuccess, IDS_GETSTRINGFIELD_ERROR, 
                    dwResult, SPAPI_E_SECTION_NAME_TOO_LONG);

    // Save the value if it is the one we are looking for.
    if (_tcsicmp( ptsVar, VERSION ) == 0)
    {
      fSuccess = SetupGetIntField( &ic, 1, (int *) &SourceVersion );
      LOG_ASSERT_EXPR( fSuccess, IDS_INF_ERROR, dwResult, SPAPI_E_GENERAL_SYNTAX );
      break;
    }
    free( ptsVar );
    ptsVar = NULL;

    // Advance to the next line.
    fSuccess = SetupFindNextLine( &ic, &ic );

  } while( fSuccess);

  // If the version wasn't found, return an error.
  LOG_ASSERT_EXPR( SourceVersion != 0, IDS_INF_ERROR, dwResult, SPAPI_E_GENERAL_SYNTAX );

cleanup:
  if (ptsVar != NULL)
    free( ptsVar );
  return dwResult;
}


/***************************************************************************

          main

     Load machine state from migration.inf.

***************************************************************************/

int _cdecl main(int argc, char *argv[])
{
  DWORD        dwResult;
  TCHAR       *ptsHiveName   = NULL;
  DWORD        dwLen;
  char        *pszMigrate;
  DWORD        dwReturnToDos = ERROR_SUCCESS;

  dwResult = CoInitialize(NULL);
  if (FAILED(dwResult))
      goto cleanup;

  dwResult = OpenFiles();
  if (dwResult != ERROR_SUCCESS) goto cleanup;

  // Parse the parameters.
  dwResult = ParseParams( argc, argv, FALSE, szLogFile );
  if (dwResult != ERROR_SUCCESS) goto cleanup;

  // Determine the operating system.
  if (FALSE == TestMode)
  {
    LOG_ASSERT_EXPR( (GetVersion() & 0xffff) == 5, IDS_OS5, dwResult,
                     ERROR_BAD_ENVIRONMENT );
  }
  else if ((GetVersion() & 0xffff) != 5)
    Win32PrintfResource( LogFile, IDS_OS5_WARNING );

  // Append migration.inf.
  dwLen = strlen(MigrationPath) + sizeof(MIGRATEINF) + 2;
  pszMigrate = (char *) _alloca( dwLen );
  strcpy( pszMigrate, MigrationPath );
  strcat( pszMigrate, MIGRATEINF );
  dwResult = OpenInf( pszMigrate );
  if (dwResult != ERROR_SUCCESS) goto cleanup;

  // Read the source OS version.
  dwResult = GetSourceVersion();
  if (dwResult != ERROR_SUCCESS) goto cleanup;

  // Compute the temp directory.
  dwResult = ComputeTemp();
  if (dwResult != ERROR_SUCCESS) goto cleanup;

  // Copy the user registry.
  if (DebugOutput)
      Win32Printf(LogFile, "Loading User settings \r\n");
  dwResult = LoadUser( &DomainName, &UserName, &ptsHiveName );
  if (dwResult != ERROR_SUCCESS) goto cleanup;

  // Copy system settings.
  if (DebugOutput)
      Win32Printf(LogFile, "Loading System settings\r\n");
  dwResult = LoadSystem(argc, argv);
  if (dwResult != ERROR_SUCCESS) goto cleanup;

  // Create the user profile.
  if (DebugOutput)
      Win32Printf(LogFile, "Creating User Profile for %s, domain %s, hive %s\r\n", UserName, DomainName, ptsHiveName);
  dwResult = CreateUserProfileFromName( DomainName, UserName, ptsHiveName );
  if (dwResult != ERROR_SUCCESS) goto cleanup;

  // Copy files.
  if (DebugOutput)
      Win32Printf(LogFile, "Loading files\r\n");
  dwResult = LoadFiles();
  if (dwResult == ERROR_FILENAME_EXCED_RANGE)
  {
      dwReturnToDos = dwResult;
  }
  else if (dwResult != ERROR_SUCCESS)
  {
      goto cleanup;
  }

  // Process the extentions.
  if (DebugOutput)
      Win32Printf(LogFile, "Processing Extensions\r\n");
  dwResult = ProcessExtensions();
  if (dwResult != ERROR_SUCCESS) goto cleanup;

  //Fix registry entries with filenames in them
  if (DebugOutput)
      Win32Printf(LogFile, "Fixing special filenames\r\n");
  dwResult = FixSpecial();
  if (dwResult != ERROR_SUCCESS) goto cleanup;

  // Process the executable extentions.
  if (DebugOutput)
      Win32Printf(LogFile, "Processing Exec Extenstions\r\n");
  dwResult = ProcessExecExtensions();
  if (dwResult != ERROR_SUCCESS) goto cleanup;

cleanup:
  // Clean up user stuff and ignore failures.
  if (DebugOutput)
      Win32Printf(LogFile, "Load complete. Cleaning up.\r\n");

  CleanupUser();

  // Close any open files and ignore failures.
  CloseFiles();

  // Erase the temp directory and ignore failures.
  EraseTemp();

  // Delete loadstate key in registry if success
  if (ERROR_SUCCESS == dwResult)
  {
      HKEY hKey;
      RegOpenKeyEx( HKEY_CURRENT_USER,
                    TEXT("Software\\Microsoft\\Windows\\CurrentVersion"),
                    0, KEY_WRITE, &hKey );
      RegDeleteKey(hKey, TEXT("Loadstate"));
      RegCloseKey(hKey);
  }

  // Free strings.
  if (DomainName != NULL)
    free( DomainName );
  if (UserName != NULL)
    free( UserName );
  if (ptsHiveName != NULL )
    free( ptsHiveName );
  if (UserPath != NULL)
      free (UserPath);

  CoUninitialize();

  if (dwResult == ERROR_SUCCESS)
  {
      dwResult = dwReturnToDos;
  }

  // Print a message.
  if (Console != INVALID_HANDLE_VALUE)
    if (dwResult == ERROR_SUCCESS)
      Win32PrintfResource( Console, IDS_COMPLETE_OK );
    else
      Win32PrintfResource( Console, IDS_COMPLETE_ERROR, szLogFile );

  if (Verbose)
  {
    printf( "Returning 0x%x to DOS.\r\n", dwResult );
  }
  return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\scanstate\scanstate.cxx ===
//--------------------------------------------------------------
//
// File:        scanstate
//
// Contents:    Scans the machine and produces an INF file
//              describing the machine state.
//
//---------------------------------------------------------------

#include "scanhead.cxx"
#pragma hdrstop

#include <common.hxx>
#include <stdio.h>
#include <io.h>
#include <malloc.h>

#include <setupapi.h>

#include <scanstate.hxx>
#include <bothchar.hxx>

//---------------------------------------------------------------
// Constants.

const char MIGRATEINF[] = "\\migration.inf";


//---------------------------------------------------------------
// Types.

//---------------------------------------------------------------
// Globals.

/***************************************************************************

 Function:    main

***************************************************************************/

int _cdecl main(int argc, char *argv[])
{
  DWORD        result;
  BOOL         success;
  DWORD        len;
  DWORD        dwVersion;
  char        *migrate;
  char        *error;
  // logfile is not used outside this function so it doesn't need to be 
  // global like loadstate's is. 
  char        logfile[MAX_PATH+1];

  logfile[0] = '\0';

  result = OpenFiles();
  if (result != ERROR_SUCCESS)
  {
      goto cleanup;
  }


  // Parse the parameters.
  result = ParseParams( argc, argv, TRUE, logfile );
  if (result != ERROR_SUCCESS) goto cleanup;

  // Determine the operating system.    Major Minor
  //                         NT4          4     0
  //                         Win95        4     0
  //                         Win98        4    10
  //                         Millenium    4    90
  dwVersion = GetVersion() & 0xFFFF;   // check minor, major numbers
  if (FALSE == TestMode)
  {
    LOG_ASSERT_EXPR((dwVersion==4 || dwVersion==0xA04), IDS_WRONG_OS, result,
                     ERROR_BAD_ENVIRONMENT );
  }
  else if (dwVersion != 4 && dwVersion != 0xA04)
    Win32PrintfResource( LogFile, IDS_OS_WARNING );

  // Load any NT 4 APIs needed.
  result = NtImports();
  LOG_ASSERT( result );

  // Compute the name of migration.inf
  len = strlen(MigrationPath) + sizeof(MIGRATEINF) + 2;
  migrate = (char *) _alloca( len );
  strcpy( migrate, MigrationPath );
  strcat( migrate, MIGRATEINF );

  // Create the INF file. If the file already exists, but we're using the private
  // debugging flag "/q", overwrite it.
  OutputFile = CreateFileA( migrate, 
                            GENERIC_WRITE, 
                            0, 
                            NULL, 
                            !TestMode ? CREATE_NEW : CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL, 
                            NULL );

  // If the open failed, print a message and exit.
  if (OutputFile == INVALID_HANDLE_VALUE)
  {
    result = GetLastError();
    if (result == ERROR_FILE_EXISTS)
    {
        Win32PrintfResource( Console, IDS_INF_EXISTS, migrate );
    }
    else
    {
        Win32PrintfResource( Console, IDS_OPEN_INF_ERROR, migrate );
    }
    error = NULL;
    FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                    0, result,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                   (char *) &error, 0, NULL );
    
    if (error != NULL)
    {
      Win32Printf( Console, error );
      LocalFree( error );
    }
    goto cleanup;
  }

  //Write the Unicode signature - don't use Win32Printf because that will
  //pad the string with zeroes.

  if (!OutputAnsi)
  {
      USHORT sig;
      ULONG cbWritten;
      sig = 0xfeff;
      result = WriteFile(OutputFile, &sig, sizeof(USHORT), &cbWritten, NULL);
      if (!result || cbWritten != sizeof(USHORT))
          return GetLastError();
  }


  // Write the version header for the user to the INF file.
  result = Win32Printf( OutputFile, "[version]\r\nSignature=""$Windows NT$""\r\n\r\n" );
  LOG_ASSERT( result );

  DWORD dwLangID;
  result = ScanGetLang (&dwLangID);
  if (result != ERROR_SUCCESS) goto cleanup;

  // Write the OS version to the INF file.
  result = Win32Printf( OutputFile, "[%s]\r\n%s=0x%x\r\n%s=%04x\r\n%s=%08x\r\n",
                        SOURCE_SECTION, VERSION, GetVersion(),
                        LOCALE, dwLangID, USERLOCALE, GetUserDefaultLCID());
  LOG_ASSERT( result );

  if (DebugOutput)
      Win32Printf(LogFile, "Writing machine settings to output file\r\n");

  // Write the machine settings, errors are ignored
  // The destination machine should have reasonable defaults for these settings
  ScanGetKeyboardLayouts (OutputFile);
  ScanGetTimeZone (OutputFile);
  ScanGetFullName (OutputFile);
  ScanGetOrgName (OutputFile);
  result = Win32Printf (OutputFile, "\r\n");
  if (result != ERROR_SUCCESS) goto cleanup;

  // Initialize file migration structures
  if (DebugOutput)
      Win32Printf(LogFile, "Initializing file migration structures\r\n");
  result = InitializeFiles();
  if (result != ERROR_SUCCESS) goto cleanup;

  // Compute the temp directory.
  result = ComputeTemp();
  if (result != ERROR_SUCCESS) goto cleanup;

  // Copy the user registry.
  if (DebugOutput)
      Win32Printf(LogFile, "Initiating ScanUser\r\n");
  result = ScanUser();
  if (result != ERROR_SUCCESS) goto cleanup;

  // Process the extension sections.
  if (DebugOutput)
      Win32Printf(LogFile, "Processing the extension sections\r\n");
  result = ProcessExtensions();
  if (result != ERROR_SUCCESS) goto cleanup;

  // Process the executable extension sections.
  if (DebugOutput)
      Win32Printf(LogFile, "Processing the executable extension sections\r\n");
  result = ProcessExecExtensions();
  if (result != ERROR_SUCCESS) goto cleanup;

  // Copy system settings.
  if (DebugOutput)
      Win32Printf(LogFile, "Scanning system settings\r\n");
  result = ScanSystem();
  if (result != ERROR_SUCCESS) goto cleanup;

  // Copy files.
  if (DebugOutput)
      Win32Printf(LogFile, "Scanning files\r\n");
  result = ScanFiles();
  if (result != ERROR_SUCCESS) goto cleanup;

  if (DebugOutput)
      Win32Printf(LogFile, "ScanState complete. Cleaning up\r\n");
  // Clean up user stuff and ignore failures.
  CleanupUser();

  // Clean up file migration stuff and ignore failures.
  CleanupFiles();

cleanup:
  // Clean up user stuff and ignore failures.
  CleanupUser();

  // Close any open files and ignore failures.
  CloseFiles();

  // Erase the temp directory and ignore failures.
  EraseTemp();

  // Print a message.
  if (Console != INVALID_HANDLE_VALUE)
    if (result == ERROR_SUCCESS)
      Win32PrintfResource( Console, IDS_COMPLETE_OK );
    else
      Win32PrintfResource( Console, IDS_COMPLETE_ERROR, logfile );

  if (Verbose)
    printf( "Returning to dos: 0x%x\r\n", result );

  // All done printing stuff, close the console handle
  if (Console != INVALID_HANDLE_VALUE)
    CloseHandle( Console );

  return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\scanstate\scanfiles.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 1998.
//
//  File:       scanfiles.cxx
//
//  Contents:   User file migration code
//
//  Classes:
//
//  Functions:
//
//  History:    28-Sep-99       PhilipLa        Created
//
//----------------------------------------------------------------------------

#include "scanhead.cxx"
#pragma hdrstop

#include <common.hxx>
#include <filelist.hxx>
#include <section.hxx>
#include <special.hxx>

#include <scanstate.hxx>

#include <bothchar.hxx>

#include <fileutil.cxx>

CSection *g_pcsSectionList = NULL;

CRuleList g_crlExcludeWildcards;
CRuleList g_crlIncludeWildcards;

CSpecialDirectory g_csd;
CSysFileList g_sfl;


DWORD ProcessSysFiles(HINF hi, const TCHAR *ptsName);

DWORD InitializeFiles()
{
    DWORD dwErr;

    dwErr = g_csd.Init();
    if (dwErr)
    {
      return dwErr;
    }

    if (CopyFiles)
    {
        dwErr = ProcessSysFiles(InputInf, SYSFILES_LABEL);
        if (dwErr != 0)
            return dwErr;
    }
    return ERROR_SUCCESS;
}

void CleanupFiles(void)
{
    FreeSectionList(g_pcsSectionList);
    g_pcsSectionList = NULL;
}


//---------------------------------------------------------------
DWORD ComputeTemp()
{
  return ERROR_SUCCESS;
}

//---------------------------------------------------------------
void EraseTemp()
{
}

//---------------------------------------------------------------
DWORD PickUpThisFile( char *file, char * dest)
{
    DWORD dwErr;
    DWORD dwIndex;

    if ((file == NULL) ||
        (file[0] == 0))
    {
        //Wacky NULL strings must not be added as rules.
        //Ignore them and return success.
        return ERROR_SUCCESS;
    }
    
    if (Verbose)
        Win32Printf(LogFile,
                    "Copy %s to the destination machine.\r\n",
                    file );

    TCHAR *ptsFile, *ptsDest;
    TCHAR tsFileName[MAX_PATH + 1];
    TCHAR tsTemp[MAX_PATH + 1];
    
#ifdef _UNICODE
    TCHAR tsDest[MAX_PATH + 1];

    if (!(MultiByteToWideChar(AreFileAPIsAnsi() ? CP_ACP : CP_OEMCP,
                              MB_ERR_INVALID_CHARS,
                              file,
                              -1,
                              tsFileName
                              MAX_PATH + 1)))
    {
        dwErr = GetLastError();
        Win32PrintfResource(LogFile, IDS_INVALID_PARAMETER);
        if (Verbose)
            Win32Printf(STDERR,
                        "Couldn't convert output path %s to Unicode.\r\n",
                        file);
        return dwErr;
    }

    if (dest &&
        (!(MultiByteToWideChar(AreFileAPIsAnsi() ? CP_ACP : CP_OEMCP,
                               MB_ERR_INVALID_CHARS,
                               dest,
                               -1,
                               tsDest,
                               MAX_PATH + 1))))
    {
        dwErr = GetLastError();
        Win32PrintfResource(LogFile, IDS_INVALID_PARAMETER);
        if (Verbose)
            Win32Printf(STDERR,
                        "Couldn't convert output path %s to Unicode.\r\n",
                        dest);
        return dwErr;
    }

    ptsFile = tsFileName;
    ptsDest = tsDest;
#else
    ptsFile = file;
    ptsDest = dest;
#endif //_UNICODE

    if (_tcslen(ptsFile) > MAX_PATH)
    {
        if (DebugOutput)
        {
            Win32Printf(LogFile, "Error: ptsFile too long %s\r\n", ptsFile);
        }
        return ERROR_FILENAME_EXCED_RANGE;
    }
    _tcscpy(tsTemp, ptsFile);
    dwErr = g_csd.ExpandMacro(tsTemp, tsFileName, &ptsFile, TRUE);
    if (dwErr)
        return dwErr;
    
    CRuleList *prlDest;
    dwErr = g_crlIncludeWildcards.SetName(ptsFile, &prlDest);
    if (!dwErr && ptsDest)
        dwErr = prlDest->SetDestination(ptsDest);

    //Remove it from the system files list if it's in there.
    g_sfl.RemoveName(ptsFile);
    
    return dwErr;
}


DWORD CopyAFile(const TCHAR *ptsSourcePath, const TCHAR *ptsName)
{
    BOOL fPath = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwLen;
    TCHAR ptsMigrationPath[MAX_PATH + 1];
    TCHAR ptsPath[MAX_PATH + 1];
    TCHAR ptsSourceFullPath[MAX_PATH + 1];

    // If the source filename is too long, skip it
    if ( (_tcslen(ptsName) + _tcslen(ptsSourcePath) + 1) > MAX_PATH )
    {
        Win32PrintfResource(LogFile,
                            IDS_FILE_COPYERROR,
                            ptsName);
        if (Verbose)
            Win32Printf(STDERR,
                        "Could Not Copy Too Long Source Filename: %s\\%s\r\n",
                        ptsSourcePath,
                        ptsName);
        return ERROR_FILENAME_EXCED_RANGE;
    }

    _tcscpy(ptsSourceFullPath, ptsSourcePath);
    _tcscat(ptsSourceFullPath, TEXT("\\"));
    _tcscat(ptsSourceFullPath, ptsName);

#ifdef _UNICODE
    if (!(dwLen = MultiByteToWideChar(AreFileAPIsAnsi() ? CP_ACP : CP_OEMCP,
                                      MB_ERR_INVALID_CHARS,
                                      MigrationPath,
                                      -1,
                                      ptsMigrationPath,
                                      MAX_PATH + 1)))
    {
        dwErr = GetLastError();
        Win32PrintfResource(LogFile, IDS_INVALID_PARAMETER);
        if (Verbose)
            Win32Printf(STDERR,
                        "Couldn't convert output path %s to Unicode.\r\n",
                        MigrationPath);
        return dwErr;
    }
#else
    dwLen = _tcslen(MigrationPath);
    if (dwLen > MAX_PATH)
    {
        if (DebugOutput)
        {
            Win32Printf(LogFile, "Error: MigrationPath too long %s\r\n", MigrationPath);
        }
        return ERROR_FILENAME_EXCED_RANGE;
    }
    _tcscpy(ptsMigrationPath, MigrationPath);
#endif

    // If the destination path is too long, skip this file
    if ( (dwLen + _tcslen(ptsSourcePath) + _tcslen(ptsName)+1) > MAX_PATH )
    {
        Win32PrintfResource(LogFile,
                            IDS_FILE_COPYERROR,
                            ptsName);
        if (Verbose)
            Win32Printf(STDERR,
                        "Could Not Copy To Too Long Destination Filename: %s\\%c%s\\%s\r\n",
                        ptsMigrationPath,
                        ptsSourcePath[0],
                        ptsSourcePath+2,
                        ptsName);
        return ERROR_FILENAME_EXCED_RANGE;
    }

    _tcscpy(ptsPath, ptsMigrationPath);

    ptsPath[dwLen++] = TEXT('\\');

    //Copy drive letter
    ptsPath[dwLen++] = ptsSourcePath[0];

    //Skip the colon
    _tcscpy(ptsPath + dwLen, ptsSourcePath + 2);
    dwLen = dwLen + _tcslen(ptsSourcePath) - 2;

    ptsPath[dwLen++] = TEXT('\\');
    _tcscpy(ptsPath + dwLen, ptsName);

    if (ReallyCopyFiles)
    {
        while (!CopyFile(ptsSourceFullPath,
                         ptsPath,
                         TRUE))
        {
            dwErr = GetLastError();

            if (dwErr == ERROR_PATH_NOT_FOUND)
            {
                if (fPath)
                {
                    //We already tried to create the path, so something
                    //else must be wrong.  Punt-arooney.
                    break;
                }

                dwErr = ERROR_SUCCESS;

                TCHAR *ptsPos;
                DWORD dwPos;
                //Try to create all the necessary directories
                TCHAR ptsDirectory[MAX_PATH + 1];

                // ptsPath is built inside this function and guarenteed to be less than MAX_PATH
                _tcscpy(ptsDirectory, ptsPath);
                dwPos = _tcslen(ptsMigrationPath) + 1;

                //Create every directory along this path
                while (ptsPos = _tcschr(ptsDirectory + dwPos, TEXT('\\')))
                {
                    *ptsPos = TEXT(0);
                    //Create the directory

                    if (!CreateDirectory(ptsDirectory,
                                         NULL))
                    {
                        dwErr = GetLastError();
                        if (dwErr != ERROR_ALREADY_EXISTS)
                        {
                            if (Verbose)
                                Win32Printf(STDERR,
                                            "Error %lu trying to create "
                                            "directory %s\r\n",
                                            dwErr,
                                            ptsDirectory);

                            break;
                        }
                        dwErr = ERROR_SUCCESS;
                    }

                    //Put the backslash back in
                    *ptsPos = TEXT('\\');
                    //Update dwLen
                    dwPos = ptsPos - ptsDirectory + 1;
                }
                if (dwErr)
                    break;
                fPath = TRUE;
            }
            else if (dwErr == ERROR_ACCESS_DENIED)
            {
                // Ignore files that we don't have permission to copy anyway
                Win32PrintfResource(LogFile,
                                    IDS_ACCESS_DENIED,
                                    ptsSourceFullPath);
                dwErr = ERROR_SUCCESS;
                break;
            }
            else
            {
                break;
            }
        }
    }


    if (dwErr)
    {
        Win32PrintfResource(LogFile,
                            IDS_FILE_COPYERROR,
                            ptsSourceFullPath);
        if (Verbose)
            Win32Printf(STDERR,
                        "Error %lu while copying from %s to %s\r\n",
                        dwErr,
                        ptsSourceFullPath,
                        ptsPath);
    }
    return dwErr;
}


const TCHAR * GetSpecialDirectoryName(const TCHAR *ptsPath)
{
    TCHAR buf[MAX_PATH + 1];

    if (_tcslen(ptsPath) > MAX_PATH)
    {
        if (DebugOutput)
        {
            Win32Printf(LogFile, "Error: ptsPath too long %s\r\n", ptsPath);
        }
        return NULL;
    }
    _tcscpy(buf, ptsPath);

    DEBUG_ASSERT(buf[_tcslen(ptsPath) - 1] == TEXT('\\'));
    
    buf[_tcslen(ptsPath) - 1] = 0;

    for (ULONG i = 0; i < g_csd.GetDirectoryCount(); i++)
    {
        if (g_csd.GetDirectoryPath(i) &&
            (_tcsicmp(buf, g_csd.GetDirectoryPath(i)) == 0))
        {
            return g_csd.GetDirectoryName(i);
        }
    }
    return NULL;
}


BOOL ExcludeFile(const TCHAR *ptsRoot,
                 const TCHAR *ptsName,
                 const WIN32_FIND_DATA *pwfd,
                 CRuleList **pprlMatch,
                 DWORD *pdwMatchFit)
{
    BOOL f;
    TCHAR *ptsExt;

    // This used to exclude HIDDEN and SYSTEM files, 
    // but it turns out we do want to migrate those
    // if we have a matching rule.  Note that system
    // files will be excluded if they are listed in the
    // system files section of the INF files.
    if (pwfd->dwFileAttributes & FILE_ATTRIBUTE_TEMPORARY)
    {
        if (pprlMatch)
            *pprlMatch = NULL;

        //Infinite strength on this hit, we should never take these
        //files even if we have a good include rule.
        if (pdwMatchFit)
            *pdwMatchFit = MAX_WEIGHT;
        return TRUE;
    }

    f = g_crlExcludeWildcards.MatchAgainstRuleList(ptsRoot,
                                                   ptsName,
                                                   pprlMatch,
                                                   pdwMatchFit);

    if (!f && !CopyFiles)
    {
        //User specified no file copy, so pretend there's a low
        //priority rule that returned a hit.  Any explicit include
        //(which will only be coming from PickUpThisFile) will win.
        if (pprlMatch)
            *pprlMatch = NULL;
        if (pdwMatchFit)
            *pdwMatchFit = 1;
        return TRUE;
    }
    return f;
}


BOOL IncludeFile(const TCHAR *ptsRoot,
                 const TCHAR *ptsName,
                 const WIN32_FIND_DATA *pwfd,
                 CRuleList **pprlMatch)
{
    CRuleList *prlExclude = NULL;
    CRuleList *prlInclude = NULL;
    
    DWORD dwBestExcludeFit = 0;
    DWORD dwBestIncludeFit = 0;

    ExcludeFile(ptsRoot,
                ptsName,
                pwfd,
                &prlExclude,
                &dwBestExcludeFit);
                
    g_crlIncludeWildcards.MatchAgainstRuleList(ptsRoot,
                                               ptsName,
                                               &prlInclude,
                                               &dwBestIncludeFit);

    if (DebugOutput)
        Win32Printf(LogFile, "File %s%s rule weighting: \r\n  Best exclude %lu = %s\r\n  Best include %lu = %s\r\n",
                ptsRoot,
                    (ptsName == NULL) ? TEXT("") : ptsName,
                    dwBestExcludeFit,
                    ((prlExclude == NULL) ?
                     TEXT("NULL") :
                     prlExclude->GetFullName()),
                    dwBestIncludeFit,
                    ((prlInclude == NULL) ?
                     TEXT("NULL") :
                     prlInclude->GetFullName()));

    
    // Include the file when Include rating is stronger than Exclude rating, OR
    // There is an Exclude and Include rule that both match this equally, OR
    // No rules match this and we include by default, OR
    // No rules match this and it's a directory

    if ( (dwBestIncludeFit > dwBestExcludeFit) ||
         ( (dwBestIncludeFit == dwBestExcludeFit) &&
           ( (ExcludeByDefault == FALSE) ||
             (dwBestIncludeFit > 0) || 
             (pwfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))))
    {
        if (ptsName && g_sfl.LookupName(ptsName))
        {
            // If this file is listed as a system file in our rules, 
            // then always exclude it
            if (pprlMatch)
                *pprlMatch = NULL;
            
            return FALSE;
        }
        
        //Include the file
        if (pprlMatch)
            *pprlMatch = prlInclude;
        return TRUE;
    }
    else
    {
        if (pprlMatch)
            *pprlMatch = prlExclude;
        return FALSE;
    }
}

BOOL PathPrefix(const TCHAR *ptsPath, const TCHAR *ptsInclude)
{
    TCHAR ptsIncludePath[MAX_PATH + 1];
    TCHAR ptsWildPath[MAX_PATH + 1];

    if (_tcslen(ptsPath) + 2 > MAX_PATH)
    {
        if (DebugOutput)
        {
            Win32Printf(LogFile, "Error: ptsPath too long %s\r\n", ptsPath);
        }
        return FALSE;
    }
    _tcscpy(ptsWildPath, ptsPath);
    _tcscat(ptsWildPath, TEXT("*\\"));

    DeconstructFilename(ptsInclude,
                        ptsIncludePath,
                        NULL,
                        NULL);

    if (ptsIncludePath[0])
    {
        BOOL fRet = IsPatternMatchFull(ptsWildPath, ptsIncludePath, NULL) ||
                    IsPatternMatchFull(ptsIncludePath, ptsPath, NULL);
        return fRet;
    }
    return FALSE;
}

BOOL IncludeDirectory(const TCHAR *ptsPath, const WIN32_FIND_DATA *pwfd)
{
    CRuleList *prl = g_crlIncludeWildcards.GetNextRule();
    while (prl != NULL)
    {
        if (PathPrefix(ptsPath, prl->GetFullName()))
        {
            return TRUE;
        }
        prl = prl->GetNextRule();
    }
    return FALSE;
}


DWORD ProcessFileTree(TCHAR *ptsRoot,
                      CSection *pcsSection,
                      ULONG cRecursionLevel)
{
    DWORD dwErr;
    HANDLE hNext;
    WIN32_FIND_DATA wfd;
    TCHAR ptsStart[MAX_PATH];
    const TCHAR *ptsSpecialName = GetSpecialDirectoryName(ptsRoot);

    if ((cRecursionLevel < 2) || (ptsSpecialName != NULL))
    {
        pcsSection = new CSection;
        if (pcsSection == NULL)
        {
            Win32PrintfResource(LogFile, IDS_NOT_ENOUGH_MEMORY);
            return ERROR_OUTOFMEMORY;
        }

        if (g_pcsSectionList == NULL)
        {
            g_pcsSectionList = pcsSection;
        }
        else
        {
            g_pcsSectionList->AddToList(pcsSection);
        }
        dwErr = pcsSection->SetSectionTitle((ptsSpecialName == NULL) ?
                                             ptsRoot :
                                             ptsSpecialName);
        if (dwErr)
        {
            return dwErr;
        }
        dwErr = pcsSection->SetSectionPath(ptsRoot);
        if (dwErr)
        {
            return dwErr;
        }
    }

    if (_tcslen(ptsRoot) + 3 >= MAX_PATH)
    {
        if (DebugOutput)
        {
            Win32Printf(LogFile, "Error: ptsRoot too long %s\r\n", ptsRoot);
        }
        return ERROR_FILENAME_EXCED_RANGE;
    }
    _tcscpy(ptsStart, ptsRoot);
    _tcscat(ptsStart, TEXT("*.*"));

    hNext = FindFirstFile(ptsStart, &wfd);

    if (hNext == INVALID_HANDLE_VALUE)
    {
        dwErr = GetLastError();
        Win32PrintfResource(LogFile, IDS_FILE_ENUMFAIL, ptsStart);
        return dwErr;
    }

    //Files first, then directories
    do
    {
        CRuleList *prl = NULL;
        DWORD dwIndex;

        TCHAR *ptsName = ((wfd.cFileName) ?
                          wfd.cFileName :
                          wfd.cAlternateFileName);

        if (!(wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
            IncludeFile(ptsRoot, ptsName, &wfd, &prl))
        {
            ULONG i;
            TCHAR buf[MAX_PATH+1];
            TCHAR *ptsScratch;

            ptsScratch = ptsRoot + pcsSection->GetSectionPathLength() + 1;
            if (_tcslen(ptsScratch) + _tcslen(ptsName) > MAX_PATH)
            {
                if (DebugOutput)
                {
                    Win32Printf(LogFile, "Error: buf too long %s%s\r\n", ptsScratch, ptsName);
                }
                return ERROR_FILENAME_EXCED_RANGE;
            }
            _tcscpy(buf, ptsScratch);
            _tcscat(buf, ptsName);

//                Win32Printf(STDOUT, "%s%s\r\n", ptsRoot, ptsName);
            dwErr = pcsSection->SetName(buf, &i, FALSE);
            if (dwErr)
                return dwErr;
            if ((prl != NULL) && (prl->GetDestination() != NULL))
            {
                dwErr = pcsSection->SetDestination(
                    prl->GetDestination(),
                    i);
                if (dwErr)
                    return dwErr;
            }

        }
    }
    while (0 != FindNextFile(hNext, &wfd));


    hNext = FindFirstFile(ptsStart, &wfd);

    if (hNext == INVALID_HANDLE_VALUE)
    {
        dwErr = GetLastError();
        Win32PrintfResource(LogFile, IDS_FILE_ENUMFAIL, ptsStart);
        return dwErr;
    }

    do
    {
        TCHAR ptsPath[MAX_PATH + 1];
        TCHAR *ptsName = ((wfd.cFileName) ?
                          wfd.cFileName :
                          wfd.cAlternateFileName);


        if (_tcslen(ptsRoot) + _tcslen(ptsName) + 1 > MAX_PATH)
        {
            if (DebugOutput)
            {
                Win32Printf(LogFile, "Error: filename too long %s%s\\\r\n", ptsRoot, ptsName);
            }
            return ERROR_FILENAME_EXCED_RANGE;
        }
        _tcscpy(ptsPath, ptsRoot);
        _tcscat(ptsPath, ptsName);
        _tcscat(ptsPath, TEXT("\\"));


        if ((wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
            _tcscmp(ptsName, TEXT(".")) &&
            _tcscmp(ptsName, TEXT("..")))
        {
            if (IncludeFile(ptsPath, NULL, &wfd, NULL) ||
                IncludeDirectory(ptsPath, &wfd))
            {
                ProcessFileTree(ptsPath, pcsSection, cRecursionLevel + 1);
            }
        }
    }
    while (0 != FindNextFile(hNext, &wfd));

    return 0;
}


DWORD AddInfSectionToRuleList(INFCONTEXT *pic,
                              CRuleList *pfl,
                              BOOL fAllowRename)
{
    TCHAR buf[MAX_PATH + 1];
    TCHAR bufMacro[MAX_PATH + 1];
    TCHAR *ptsFinalName;
    TCHAR bufTag[MAX_PATH + 1];
    DWORD dwErr;
    CRuleList *prl;
    
    do
    {
        DWORD dwIndex;
        DWORD cFields;
        BOOL fDirectoryTag = FALSE;
        cFields = SetupGetFieldCount(pic);

        if (((cFields != 1) && !fAllowRename) ||
            ((cFields > 2) && fAllowRename))
        {
            Win32PrintfResource(LogFile, IDS_INF_ERROR);
            if (Verbose)
                Win32Printf(STDERR,
                            "Line contains more than one file name\r\n");
            return ERROR_INVALID_PARAMETER;
        }

        if (!SetupGetStringField(pic,
                                 1,
                                 buf,
                                 MAX_PATH + 1,
                                 NULL))
        {
            dwErr = GetLastError();
            Win32PrintfResource(LogFile, IDS_INF_ERROR);
            if (Verbose)
                Win32Printf(STDERR,
                            "SetupGetStringField returned %lu\r\n",
                            dwErr);
            return dwErr;
        }

        if (SetupGetStringField(pic,
                                 0,
                                 bufTag,
                                 MAX_PATH + 1,
                                 NULL))
        {
            if (_tcsicmp(bufTag, buf))
            {
                //Someone put a field identifier on there.  The only
                //one we recognize is 'dir'
                if (_tcsicmp(bufTag, TEXT("dir")))
                {
                    Win32PrintfResource(LogFile, IDS_INF_ERROR);
                    if (Verbose)
                        Win32Printf(STDERR,
                                    "Unknown tag %s\r\n",
                                    bufTag);
                    return ERROR_INVALID_PARAMETER;
                }
                fDirectoryTag = TRUE;
            }
        }

        dwErr = g_csd.ExpandMacro(buf, bufMacro, &ptsFinalName, TRUE);
        if (dwErr)
            return dwErr;

        DWORD ccFinalName = _tcslen(ptsFinalName);
        if ((fDirectoryTag) && (ptsFinalName[ccFinalName-1] != '\\'))
        {
            //Append a backslash if there isn't one already
            if (ccFinalName > MAX_PATH)
            {
                if (DebugOutput)
                {
                    Win32Printf(LogFile, "Error: ptsFinalName too long: %s\\\r\n", ptsFinalName);
                }
                return ERROR_FILENAME_EXCED_RANGE;
            }
            else
            {
                _tcscat(ptsFinalName, TEXT("\\"));
            }
        }

        dwErr = pfl->SetName(ptsFinalName, &prl);
        if (dwErr)
        {
            return dwErr;
        }

        if (cFields == 2)
        {
            if (!SetupGetStringField(pic,
                                     2,
                                     buf,
                                     MAX_PATH + 1,
                                     NULL))
            {
                dwErr = GetLastError();
                Win32PrintfResource(LogFile, IDS_INF_ERROR);
                if (Verbose)
                    Win32Printf(STDERR,
                                "SetupGetStringField returned %lu\r\n",
                                dwErr);
                return dwErr;
            }
            dwErr = prl->SetDestination(buf);
            if (dwErr)
            {
                return dwErr;
            }
        }
    }
    while (SetupFindNextLine(pic, pic));

    return ERROR_SUCCESS;
}


DWORD ProcessCopyFiles(HINF hi, const TCHAR *ptsName)
{
    DWORD dwErr;
    INFCONTEXT ic;

    if (!SetupFindFirstLine(hi,
                            ptsName,
                            NULL,
                            &ic))
    {
        dwErr = GetLastError();
        Win32PrintfResource(LogFile, IDS_SECTION_NAME_NOT_FOUND, ptsName);
        if (Verbose)
            Win32Printf(STDERR,
                        "SetupFindFirstLine failed on section %s with %lu\r\n",
                        ptsName,
                        dwErr);
        return dwErr;
    }

    dwErr = AddInfSectionToRuleList(&ic, &g_crlIncludeWildcards, TRUE);

    return dwErr;
}

DWORD ProcessDelFiles(HINF hi, const TCHAR *ptsName)
{
    DWORD dwErr;
    INFCONTEXT ic;

    if (!SetupFindFirstLine(hi,
                            ptsName,
                            NULL,
                            &ic))
    {
        dwErr = GetLastError();
        Win32PrintfResource(LogFile, IDS_SECTION_NAME_NOT_FOUND, ptsName);
        if (Verbose)
            Win32Printf(STDERR,
                        "SetupFindFirstLine failed on section %s with %lu\r\n",
                        ptsName,
                        dwErr);
        return dwErr;
    }

    dwErr = AddInfSectionToRuleList(&ic, &g_crlExcludeWildcards, FALSE);

    return dwErr;
}


DWORD ProcessSysFiles(HINF hi, const TCHAR *ptsName)
{
    DWORD dwErr;
    INFCONTEXT ic;

    if (!SetupFindFirstLine(hi,
                            ptsName,
                            NULL,
                            &ic))
    {
        dwErr = GetLastError();
        Win32PrintfResource(LogFile, IDS_SECTION_NAME_NOT_FOUND, ptsName);
        if (Verbose)
            Win32Printf(STDERR,
                        "SetupFindFirstLine failed on section %s with %lu\r\n",
                        ptsName,
                        dwErr);
        return dwErr;
    }

    LONG cLines = SetupGetLineCount(hi,
                                    ptsName);
    if (cLines == -1)
    {
        //Error
        dwErr = GetLastError();
        Win32PrintfResource(LogFile, IDS_INF_ERROR);
        if (Verbose)
            Win32Printf(STDERR,
                        "Couldn't get line count for System Files section\r\n");
        return ERROR_INVALID_PARAMETER;
    }

    g_sfl.SetInitialSize(cLines);

        
    TCHAR buf[MAX_PATH + 1];
    TCHAR bufMacro[MAX_PATH + 1];
    TCHAR *ptsFinalName;

    do
    {
        DWORD cFields;
        cFields = SetupGetFieldCount(&ic);

        if (cFields != 1)
        {
            Win32PrintfResource(LogFile, IDS_INF_ERROR);
            if (Verbose)
                Win32Printf(STDERR,
                            "Sys file line contains multiple fields\r\n");
            return ERROR_INVALID_PARAMETER;
        }

        if (!SetupGetStringField(&ic,
                                 1,
                                 buf,
                                 MAX_PATH + 1,
                                 NULL))
        {
            dwErr = GetLastError();
            Win32PrintfResource(LogFile, IDS_INF_ERROR);
            if (Verbose)
                Win32Printf(STDERR,
                            "SetupGetStringField returned %lu\r\n",
                            dwErr);
            return dwErr;
        }

        dwErr = g_csd.ExpandMacro(buf, bufMacro, &ptsFinalName, TRUE);
        if (dwErr)
            return dwErr;

        //Add the name to the sys file list
        dwErr = g_sfl.AddName(ptsFinalName);
        if (dwErr)
            return dwErr;
        
    } while (SetupFindNextLine(&ic, &ic));
    

    return ERROR_SUCCESS;
}


DWORD ParseInputFile(HINF hi)
{
    DWORD dwErr;
    INFCONTEXT ic;

    if (!SetupFindFirstLine(hi,
                            EXTENSION_SECTION,
                            NULL,
                            &ic))
    {
        dwErr = GetLastError();
        Win32PrintfResource(LogFile,
                            IDS_SECTION_NAME_NOT_FOUND,
                            EXTENSION_SECTION);
        if (Verbose)
            Win32Printf(STDERR,
                        "SetupFindFirstLine failed with %lu\r\n", dwErr);
        return dwErr;
    }

    do
    {
        DWORD cFields;
        cFields = SetupGetFieldCount(&ic);
        TCHAR buf[MAX_PATH + 1];

        if (!SetupGetStringField(&ic,
                                 0,
                                 buf,
                                 MAX_PATH + 1,
                                 NULL))
        {
            dwErr = GetLastError();
            Win32PrintfResource(LogFile, IDS_INF_ERROR);
            if (Verbose)
                Win32Printf(STDERR,
                            "SetupGetStringField failed with %lu\r\n",
                            dwErr);
            return dwErr;
        }

        if (_tcsicmp(buf, COPYFILES_LABEL) == 0)
        {
            //Add files in all sections to the include list
            for (DWORD j = 1; j < cFields + 1; j++)
            {
                if (!SetupGetStringField(&ic,
                                         j,
                                         buf,
                                         MAX_PATH + 1,
                                         NULL))
                {

                    dwErr = GetLastError();
                    Win32PrintfResource(LogFile, IDS_INF_ERROR);
                    if (Verbose)
                        Win32Printf(STDERR,
                                    "SetupGetStringField failed with %lu\r\n",
                                    dwErr);
                    return dwErr;
                }
                dwErr = ProcessCopyFiles(hi, buf);
                if (dwErr != 0)
                    return dwErr;
            }
        }
        else if (_tcsicmp(buf, DELFILES_LABEL) == 0)
        {
            //Add files in all sections to the include list
            for (DWORD j = 1; j < cFields + 1; j++)
            {
                if (!SetupGetStringField(&ic,
                                         j,
                                         buf,
                                         MAX_PATH + 1,
                                         NULL))
                {

                    dwErr = GetLastError();
                    Win32PrintfResource(LogFile, IDS_INF_ERROR);
                    if (Verbose)
                        Win32Printf(STDERR,
                                    "SetupGetStringField failed with %lu\r\n",
                                    dwErr);
                    return dwErr;
                }
                dwErr = ProcessDelFiles(hi, buf);
                if (dwErr != 0)
                    return dwErr;
            }
        }
    }
    while (SetupFindNextLine(&ic, &ic));

    return ERROR_SUCCESS;
}

DWORD OutputSectionList(CSection *pcs)
{
    DWORD dwErr = ERROR_SUCCESS;
    CSection *pcsTemp = pcs;

    Win32Printf(OutputFile, "[%s]\r\n", COPYFILE_SECTION);
    while (pcsTemp != NULL)
    {
        if (pcsTemp->GetNameCount() != 0)
            Win32Printf(OutputFile,"%s\r\n", pcsTemp->GetSectionTitle());
        pcsTemp = pcsTemp->GetNextSection();
    }

    Win32Printf(OutputFile, "\r\n");

    pcsTemp = pcs;
    while (pcsTemp != NULL)
    {
        if (pcsTemp->GetNameCount() != 0)
        {
            Win32Printf(OutputFile,"[%s]\r\n", pcsTemp->GetSectionTitle());

            for (ULONG i = 0; i < pcsTemp->GetNameCount(); i++)
            {
                Win32Printf(OutputFile,"\"%s\"", pcsTemp->GetFullFileName(i));
                if (pcsTemp->GetDestination(i) != NULL)
                {
                    Win32Printf(OutputFile,",\"%s\"", pcsTemp->GetDestination(i));
                }
                Win32Printf(OutputFile, "\r\n");
                if ((dwErr = CopyAFile(pcsTemp->GetSectionPath(),
                                       pcsTemp->GetFullFileName(i))))
                {
                    return dwErr;
                }
            }
            Win32Printf(OutputFile, "\r\n");
        }
        pcsTemp = pcsTemp->GetNextSection();
    }

    pcsTemp = pcs;

    DWORD dwSection = 10000;
    Win32Printf(OutputFile, "[%s]\r\n", DESTINATIONDIRS_SECTION);
    while (pcsTemp != NULL)
    {
        if (pcsTemp->GetNameCount() != 0)
        {
            Win32Printf(OutputFile,"%s=%lu\r\n",
                         pcsTemp->GetSectionTitle(),
                         dwSection++);
        }
        pcsTemp = pcsTemp->GetNextSection();
    }
    Win32Printf(OutputFile,"\r\n");

    return dwErr;
}

void OutputSpecialDirectoryList(CSpecialDirectory *psd)
{
    Win32Printf(OutputFile, "[%s]\r\n", SPECIALDIRS_SECTION);
    for (ULONG i = 0; i < psd->GetDirectoryCount(); i++)
    {
        if (psd->GetDirectoryPath(i) != NULL)
        {
            Win32Printf(OutputFile,
                         "%s=\"%s\"\r\n",
                         psd->GetDirectoryName(i),
                         psd->GetDirectoryPath(i));
        }
    }
    Win32Printf(OutputFile, "\r\n");
}


DWORD ScanFiles()
{
    DWORD dwErr;
    DWORD dwDrives;
    TCHAR tcDriveName[5];


    //If we're copying files, grab all the rules from the input file
    //Otherwise, we'll only take things specified by PickUpThisFile
    if (CopyFiles)
    {
        dwErr = ParseInputFile(InputInf);

        if (dwErr)
            return dwErr;
    }
    
    dwDrives = GetLogicalDrives();

    for (int i = 0; i < 26; i++)
    {
        if (dwDrives & 1)
        {
            tcDriveName[0] = (TCHAR)'A' + i;
            tcDriveName[1] = (TCHAR)':';
            tcDriveName[2] = (TCHAR)'\\';
            tcDriveName[3] = 0;


            UINT uiDriveType = GetDriveType(tcDriveName);
            TCHAR *tcDriveTypeName;

            if (uiDriveType == DRIVE_FIXED)
            {
                ProcessFileTree(tcDriveName, NULL, 0);
            }
            else if (uiDriveType == DRIVE_NO_ROOT_DIR)
            {
                if (Verbose)
                    Win32Printf(STDERR,
                                "Warning:  GetDriveType returned "
                                "DRIVE_NO_ROOT_DIR for drive %s\r\n",
                                tcDriveName);
            }
        }
        dwDrives = dwDrives >> 1;
    }

    dwErr = OutputSectionList(g_pcsSectionList);
    if (dwErr)
        return dwErr;

    OutputSpecialDirectoryList(&g_csd);

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\scanstate\scansys.cxx ===
//--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999 - 2000.
//
// File:        scansys
//
// Contents:    Scan system settings.
//
//---------------------------------------------------------------

#include <scanhead.cxx>
#pragma hdrstop

#include <common.hxx>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <io.h>
#include <objerror.h>
#include <scanstate.hxx>

#include <winuser.h>
#include <winnetwk.h>
#include <winspool.h>
#include <lmerr.h>
#include <lmaccess.h>

// We need to define WINVER to a pre-2000 definition in order to
// pull in the right structure definitions and sizes for correct
// operation on 9x and NT.
#undef WINVER
#define WINVER 0x400

#include <ras.h>
#include <raserror.h>
#include "bothchar.hxx"
#include "scansys.hxx"

//---------------------------------------------------------------

const CHAR SHARES[] = "[NetShares]\r\n";
const CHAR PRINTERS[] = "[Printers]\r\n";
const CHAR RAS[] = "[RAS]\r\n";

#define LINEBUFSIZE 1024

// longest ip address is: XXX.XXX.XXX.XXX\0
#define MAX_IP_ADDRESS 16

const CHAR REGKEY_TIMEZONE[] = "System\\CurrentControlSet\\Control\\TimeZoneInformation";
const CHAR REGVAL_TIMEZONE[] = "StandardName";
const CHAR REGKEY_VERSION[] = "Software\\Microsoft\\Windows NT\\CurrentVersion";
const CHAR REGKEY_VERSION_9x[] = "Software\\Microsoft\\Windows\\CurrentVersion";
const CHAR REGVAL_FULLNAME[] = "RegisteredOwner";
const CHAR REGVAL_ORGNAME[] = "RegisteredOrganization";

const CHAR REGKEY_RAS[] = "System\\CurrentControlSet\\Services\\RemoteAccess";

const CHAR SCRNSAVE[] = "SCRNSAVE.EXE";

const CHAR REGKEY_NT4_PBK[] = "Software\\Microsoft\\RAS Phonebook";
const CHAR REGVAL_NT4_PRS_PBK_LOC[] = "PersonalPhonebookFile";
const CHAR REGVAL_NT4_ALT_PBK_LOC[] = "AlternatePhonebookPath";

const CHAR RAS_NT4_RAS_PATH[] = "system32\\ras";
const CHAR RAS_NT4_SYSTEM_PHONEBOOK[] = "rasphone.pbk";

#define ChkErr(s) if ((dwErr = (s)) != ERROR_SUCCESS) goto Err;

//+---------------------------------------------------------------------------
// Types
// RAS api functions
typedef DWORD
(*MRasEnumEntries)(
    IN LPCSTR reserved,
    IN LPCSTR lpszPhonebook,
    OUT LPRASENTRYNAMEA lprasentryname,
    OUT LPDWORD lpcb,
    OUT LPDWORD lpcEntries);
typedef DWORD
(*MRasGetEntryProperties)(
    IN LPCSTR lpszPhonebook,
    IN LPCSTR lpszEntry,
    OUT LPRASENTRYA lpRasEntry,
    OUT LPDWORD lpdwEntryInfoSize,
    OUT LPBYTE lpbDeviceInfo,
    OUT LPDWORD lpdwDeviceInfoSize);
typedef DWORD
(*MRasGetEntryDialParams)(
    IN LPCSTR lpszPhonebook,
    OUT LPRASDIALPARAMSA lprasdialparams,
    OUT LPBOOL lpfPassword);

//+---------------------------------------------------------------------------
// Statics
static MRasEnumEntries        GRasEnumEntries        = NULL;
static MRasGetEntryProperties GRasGetEntryProperties = NULL;
static MRasGetEntryDialParams GRasGetEntryDialParams = NULL;

//+---------------------------------------------------------------------------
//
//  Function:   InitializeRasApi
//
//  Synopsis:   Loads rasapi32.dll if it exists
//
//  Arguments:  none
//
//  Returns:    Appropriate status code
//
//  History:    24-Feb-00   Jay Thaler   Created
DWORD InitializeRasApi()
{
  DWORD      result = ERROR_SUCCESS;
  HINSTANCE  rasdll;

  // Load rasapi32.dll
  rasdll = LoadLibraryA( "rasapi32.dll" );
  if (rasdll == NULL)
  {
    result = GetLastError();
    if (DebugOutput)
    {
        Win32Printf(STDERR, "Warning: rasapi32.dll not loaded: %d\r\n", result);
    }
    goto cleanup;
  }

  GRasEnumEntries        = (MRasEnumEntries)GetProcAddress(rasdll, "RasEnumEntriesA");
  if (GRasEnumEntries == NULL)
  {
    result = GetLastError();
    goto cleanup;
  }

  GRasGetEntryProperties = (MRasGetEntryProperties)GetProcAddress(rasdll, "RasGetEntryPropertiesA");
  if (GRasGetEntryProperties == NULL)
  {
    result = GetLastError();
    goto cleanup;
  }

  GRasGetEntryDialParams = (MRasGetEntryDialParams)GetProcAddress(rasdll, "RasGetEntryDialParamsA");
  if (GRasGetEntryDialParams == NULL)
  {
    result = GetLastError();
    goto cleanup;
  }

cleanup:
  if (result != ERROR_SUCCESS)
  {
      GRasEnumEntries        = NULL;
      GRasGetEntryProperties = NULL;
      GRasGetEntryDialParams = NULL;
  }
  return result;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetInfField
//
//  Synopsis:   returns an allocated string for current line field #N
//
//  Arguments:  [ppBuffer] -- output buffer
//              [pContext] -- INF file context
//              [nArg] -- argument field number
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD GetInfField (TCHAR **ppBuffer, INFCONTEXT *pContext, DWORD nArg)
{
    ULONG len = 0;
    DWORD dwErr = ERROR_SUCCESS;
    TCHAR *buffer;

    *ppBuffer = NULL;
    if (!SetupGetStringField ( pContext, nArg, NULL, 0, &len ))
        return ERROR_BAD_FORMAT;

    // Allocate a buffer.
    buffer = (TCHAR *) malloc( len*sizeof(TCHAR) );
    if (buffer == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        if (!SetupGetStringField ( pContext, nArg, buffer, len, &len ))
        {
            free( buffer );
            dwErr = ERROR_BAD_FORMAT;
        }
        else *ppBuffer = buffer;
    }

    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   LogFormatError
//
//  Synopsis:   logs error message in current locale
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD LogFormatError (DWORD dwErr)
{
    DWORD dwRet = ERROR_SUCCESS;
    TCHAR *pcs = NULL;

    if (0 != FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM |
                            FORMAT_MESSAGE_ALLOCATE_BUFFER, NULL,
                            dwErr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                            (TCHAR*) &pcs, 0, NULL))
    {
        dwRet = Win32Printf (LogFile, "%s\r\n", pcs);
        LocalFree (pcs);
    }
    else dwRet = GetLastError();

    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   ScanGenerateEncryptKey
//
//  Synopsis:   decode the RAS address BLOB
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

BYTE ScanGenerateEncryptKey (CHAR *szKey)
{
    BYTE   bKey;
    BYTE*  pKey;

    for (bKey = 0, pKey = (BYTE*)szKey; *pKey != 0; pKey++)
    {
        bKey += *pKey;
    };

    return bKey;
}

//+---------------------------------------------------------------------------
//
//  Function:   ScanDecryptEntry
//
//  Synopsis:   decode the RAS address BLOB
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

void ScanDecryptEntry (CHAR * szEntry, BYTE * pEnt, DWORD cb)
{
    // Generate the encryption key from the entry name
    BYTE bKey = ScanGenerateEncryptKey(szEntry);

    // Encrypt the address entry one byte at a time
    for (;cb > 0; cb--, pEnt++)
    {
        *pEnt ^= bKey;
    };
    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsRasInstalled
//
//  Synopsis:   determines if RAS is installed
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

BOOL IsRasInstalled ()
{
    HKEY hKey = NULL;
    if (ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                       REGKEY_RAS,
                                       NULL,
                                       KEY_READ,
                                       &hKey))
    {
        RegCloseKey (hKey);
        return TRUE;
    }
    return FALSE;
}

//----------------------------------------------------------------------------
DWORD RasReadIpAddress(HINF h,
                       const TCHAR *pszEntryName,
                       const TCHAR *pszKeyName,
                       RASIPADDR *lpIpAddr)
{
    BOOL        fSuccess;
    INFCONTEXT  IpAddrLine;
    TCHAR       szIpAddr[MAX_IP_ADDRESS];
    DWORD       dwAddr1, dwAddr2, dwAddr3, dwAddr4;
    DWORD       dwErr = ERROR_SUCCESS;

    fSuccess = SetupFindFirstLine(h,
                                  pszEntryName,
                                  pszKeyName,
                                  &IpAddrLine);

    if (fSuccess == FALSE)
    {
        dwErr = GetLastError();
        Win32PrintfResource(LogFile, IDS_RAS_ENTRY_NOT_MIGRATED, pszEntryName);
        if (DebugOutput)
        {
            Win32Printf(LogFile,
                        "SetupFindFirstLine: Error %d looking for %s[%s]\r\n",
                        dwErr, pszEntryName, pszKeyName);
        }
        goto cleanup;
    }

    fSuccess = SetupGetStringField(&IpAddrLine, 1, szIpAddr, MAX_IP_ADDRESS, 0);
    if (fSuccess == FALSE)
    {
        dwErr = GetLastError();
        Win32PrintfResource(LogFile, IDS_RAS_ENTRY_NOT_MIGRATED, pszEntryName);
        if (DebugOutput)
        {
            Win32Printf(LogFile,
                        "SetupGetStringField: Error %d reading %s[%s]\r\n",
                        dwErr, pszEntryName, pszKeyName);
        }
        goto cleanup;
    }
    if (_stscanf(szIpAddr, "%d.%d.%d.%d",
                 &dwAddr1, &dwAddr2, &dwAddr3, &dwAddr4) != 4)
    {
        if (DebugOutput)
        {
            Win32Printf(LogFile,
                        "szIpAddr for %s[%s] is not an address: %s\r\n",
                        pszEntryName, pszKeyName, szIpAddr);
        }
        dwErr = ERROR_BAD_FORMAT;
        goto cleanup;
    }
    lpIpAddr->a = (BYTE)dwAddr1;
    lpIpAddr->b = (BYTE)dwAddr2;
    lpIpAddr->c = (BYTE)dwAddr3;
    lpIpAddr->d = (BYTE)dwAddr4;

cleanup:
    return dwErr;
}

//----------------------------------------------------------------------------
DWORD ScanRasPhonebook( HANDLE h, LPCTSTR lpPbkFileName )
{
    DWORD           dwErr = ERROR_SUCCESS;
    LPRASENTRYNAMEA lpRasEntryName;
    DWORD           i = 0;
    DWORD           dwRasEntrySize = 0;
    DWORD           dwRasEntryNameSize = 0;
    DWORD           dwBufferSize   = 0;
    DWORD           cEntries = 0;
    LPRASENTRYA     lpRasEntry = NULL;
    RASDIALPARAMSA  RasDialParams;
    BOOL            bPasswordRead = FALSE;
    HINF            hPbkFile = INVALID_HANDLE_VALUE;

    // Make sure the file exists
    if(GetFileAttributes(lpPbkFileName) == -1)
    {
        ChkErr( GetLastError() );
    }

    lpRasEntryName = (LPRASENTRYNAMEA)GlobalAlloc(GPTR, sizeof(RASENTRYNAMEA));
    lpRasEntryName->dwSize = sizeof(RASENTRYNAMEA);   // Should be 264 when WINVER < 0x500

    dwErr = GRasEnumEntries(NULL,
                          lpPbkFileName,
                          lpRasEntryName,
                          &dwRasEntryNameSize,
                          &cEntries);
    if (dwErr == ERROR_INVALID_SIZE || dwErr == ERROR_BUFFER_TOO_SMALL )
    {
        lpRasEntryName = (LPRASENTRYNAMEA)GlobalAlloc(GPTR, dwRasEntryNameSize);
        if ( cEntries > 1 )
        {
            lpRasEntryName->dwSize = dwRasEntryNameSize / cEntries;
        }
        else
        {
            lpRasEntryName->dwSize = dwRasEntryNameSize;
        }
        dwErr = GRasEnumEntries(NULL,
                                lpPbkFileName,
                                lpRasEntryName,
                                &dwRasEntryNameSize,
                                &cEntries);
    }

    if (dwErr != ERROR_SUCCESS)
    {
        // The resource file specifies %1!d! which requires an int argument in this case
        Win32PrintfResource (LogFile, IDS_RAS_CANNOT_ENUM, dwErr);
        goto Err;
    }

    for(i=0; i < cEntries; i++)
    {
        // Read size needed
        GRasGetEntryProperties(lpPbkFileName,
                               lpRasEntryName->szEntryName,
                               NULL,
                               &dwRasEntrySize,
                               NULL,
                               0);

        if (lpRasEntry == NULL)
        {
            lpRasEntry = (LPRASENTRYA)malloc(dwRasEntrySize);
        }
        else if (dwRasEntrySize > dwBufferSize)
        {
            lpRasEntry = (LPRASENTRYA)realloc(lpRasEntry, dwRasEntrySize);
            dwBufferSize = dwRasEntrySize;
        }

        ZeroMemory( lpRasEntry, dwBufferSize );
        lpRasEntry->dwSize = sizeof(RASENTRYA);

        dwErr = GRasGetEntryProperties( lpPbkFileName,
                                       lpRasEntryName->szEntryName,
                                       lpRasEntry,
                                       &dwRasEntrySize,
                                       NULL,
                                       0 );
        if (dwErr != ERROR_SUCCESS)
        {
            // Log Error
            Win32PrintfResource (LogFile, IDS_RAS_ENTRY_NOT_MIGRATED, lpRasEntryName->szEntryName);
            if (DebugOutput)
            {
                Win32Printf(LogFile, "RasGetEntryProperties: Error %d\r\n", dwErr );
            }
            goto Err;
        }

        if ((lpPbkFileName != NULL) &&
            (lpRasEntry->dwFramingProtocol == RASFP_Slip))
        {

            // We read from a PBK file (not Win9x) and we're using SLIP.
            // This means the ipAddress, DNS addresses, and WINS addresses
            // were probably lost.  Those bastards!
            UINT        dwErrorLine;

            hPbkFile = SetupOpenInfFile(lpPbkFileName,
                                        NULL,
                                        INF_STYLE_OLDNT | INF_STYLE_WIN4,
                                        &dwErrorLine);
            if (hPbkFile == INVALID_HANDLE_VALUE)
            {
                dwErr = GetLastError();
                Win32PrintfResource(LogFile, IDS_RAS_ENTRY_NOT_MIGRATED,
                                    lpRasEntryName->szEntryName);
                if (DebugOutput)
                {
                    Win32Printf(LogFile,
                                "SetupOpenInfFile: Error 0x%X opening %s, line %d\r\n",
                                dwErr, lpPbkFileName, dwErrorLine );
                }
                goto Err;
            }

            // Check IpAddress
            if ((*(DWORD*)&lpRasEntry->ipaddr) == 0 )
            {
                ChkErr( RasReadIpAddress(hPbkFile,
                                         lpRasEntryName->szEntryName,
                                         TEXT("IpAddress"),
                                         &(lpRasEntry->ipaddr)) );
            }
            if ((*(DWORD*)&lpRasEntry->ipaddr) != 0 )
            {
                lpRasEntry->dwfOptions |= RASEO_SpecificIpAddr;
            }

            // Check ipaddrDns
            if ((*(DWORD*)&lpRasEntry->ipaddrDns) == 0 )
            {
                ChkErr( RasReadIpAddress(hPbkFile,
                                         lpRasEntryName->szEntryName,
                                         TEXT("IpDnsAddress"),
                                         &(lpRasEntry->ipaddrDns)) );
            }
            if ((*(DWORD*)&lpRasEntry->ipaddrDns) != 0 )
            {
                lpRasEntry->dwfOptions |= RASEO_SpecificNameServers;
            }

            // Check ipaddrDnsAlt
            if ((*(DWORD*)&lpRasEntry->ipaddrDnsAlt) == 0 )
            {
                ChkErr( RasReadIpAddress(hPbkFile,
                                         lpRasEntryName->szEntryName,
                                         TEXT("IpDns2Address"),
                                         &(lpRasEntry->ipaddrDnsAlt)) );
            }
            if ((*(DWORD*)&lpRasEntry->ipaddrDnsAlt) != 0 )
            {
                lpRasEntry->dwfOptions |= RASEO_SpecificNameServers;
            }

            // Check ipaddrWins
            if ((*(DWORD*)&lpRasEntry->ipaddrWins) == 0 )
            {
                ChkErr( RasReadIpAddress(hPbkFile,
                                         lpRasEntryName->szEntryName,
                                         TEXT("IpWinsAddress"),
                                         &(lpRasEntry->ipaddrWins)) );
            }
            if ((*(DWORD*)&lpRasEntry->ipaddrWins) != 0 )
            {
                lpRasEntry->dwfOptions |= RASEO_SpecificNameServers;
            }

            // Check ipaddrWinsAlt
            if ((*(DWORD*)&lpRasEntry->ipaddrWinsAlt) == 0 )
            {
                ChkErr( RasReadIpAddress(hPbkFile,
                                         lpRasEntryName->szEntryName,
                                         TEXT("IpWins2Address"),
                                         &(lpRasEntry->ipaddrWinsAlt)) );
            }
            if ((*(DWORD*)&lpRasEntry->ipaddrWinsAlt) != 0 )
            {
                lpRasEntry->dwfOptions |= RASEO_SpecificNameServers;
            }
        }

        ChkErr (Win32Printf(h, "\"%s\",", lpRasEntryName->szEntryName) );
        ChkErr (Win32Printf(h, "0x%0X,",  lpRasEntry->dwfOptions ) );
        ChkErr (Win32Printf(h, "%d,",     lpRasEntry->dwCountryID ) );
        ChkErr (Win32Printf(h, "%d,",     lpRasEntry->dwCountryCode ) );
        ChkErr (Win32Printf(h, "\"%s\",", lpRasEntry->szAreaCode ) );
        ChkErr (Win32Printf(h, "\"%s\",", lpRasEntry->szLocalPhoneNumber) );
        ChkErr (Win32Printf(h, "%d,",     0) );   // lpRasEntry->dwAlternateOffset
        ChkErr (Win32Printf(h, "0x%08X,", lpRasEntry->ipaddr ) );
        ChkErr (Win32Printf(h, "0x%08X,", lpRasEntry->ipaddrDns ) );
        ChkErr (Win32Printf(h, "0x%08X,", lpRasEntry->ipaddrDnsAlt) );
        ChkErr (Win32Printf(h, "0x%08X,", lpRasEntry->ipaddrWins ) );
        ChkErr (Win32Printf(h, "0x%08X,", lpRasEntry->ipaddrWinsAlt) );
        ChkErr (Win32Printf(h, "%d,",     lpRasEntry->dwFrameSize ) );
        ChkErr (Win32Printf(h, "%d,",     lpRasEntry->dwfNetProtocols ) );
        ChkErr (Win32Printf(h, "%d,",     lpRasEntry->dwFramingProtocol) );
        ChkErr (Win32Printf(h, "\"%s\",", lpRasEntry->szScript ) );
        ChkErr (Win32Printf(h, "\"%s\",", lpRasEntry->szAutodialDll ) );
        ChkErr (Win32Printf(h, "\"%s\",", lpRasEntry->szAutodialFunc ) );
        ChkErr (Win32Printf(h, "\"%s\",", lpRasEntry->szDeviceType ) );
        ChkErr (Win32Printf(h, "\"%s\",", lpRasEntry->szDeviceName ) );
        ChkErr (Win32Printf(h, "\"%s\",", lpRasEntry->szX25PadType ) );
        ChkErr (Win32Printf(h, "\"%s\",", lpRasEntry->szX25Address ) );
        ChkErr (Win32Printf(h, "\"%s\",", lpRasEntry->szX25Facilities ) );
        ChkErr (Win32Printf(h, "\"%s\",", lpRasEntry->szX25UserData ) );
        ChkErr (Win32Printf(h, "%d,",     lpRasEntry->dwChannels ) );

        ZeroMemory( &RasDialParams, sizeof(RASDIALPARAMSA) );

        lstrcpyA( RasDialParams.szEntryName, lpRasEntryName->szEntryName);
        RasDialParams.dwSize = sizeof(RASDIALPARAMSA);

        dwErr = GRasGetEntryDialParams( lpPbkFileName,
                                       &RasDialParams,
                                       &bPasswordRead );
        if ( dwErr != ERROR_SUCCESS )
        {
            Win32PrintfResource (LogFile, IDS_RAS_ENTRY_NOT_MIGRATED, lpRasEntryName->szEntryName);
            if (DebugOutput)
            {
                Win32Printf(LogFile, "RasGetDialParams: Error %d\n", dwErr );
            }
            goto Err;
        }

        ChkErr (Win32Printf(h, "%s,", RasDialParams.szPhoneNumber ) );
        ChkErr (Win32Printf(h, "%s,", RasDialParams.szCallbackNumber ) );
        ChkErr (Win32Printf(h, "%s,", RasDialParams.szUserName ) );
        ChkErr (Win32Printf(h, "%s,", RasDialParams.szPassword ) );
        ChkErr (Win32Printf(h, "%s\r\n", RasDialParams.szDomain) );

        lpRasEntryName++;
    }

Err:

    if (hPbkFile != INVALID_HANDLE_VALUE)
        SetupCloseInfFile(hPbkFile);

    Win32Printf(h, "\r\n" );
    if (lpRasEntry != NULL)
        free (lpRasEntry);

    if (lpRasEntryName != NULL)
        GlobalFree (lpRasEntryName);
    return dwErr;
}

DWORD ScanRasPerPhonebook (HANDLE h)
{
    DWORD          dwErr = ERROR_SUCCESS;
    CHAR           szValue[LINEBUFSIZE];
    CHAR           szPbkFileName[MAX_PATH];
    TCHAR          szWinDir[MAX_PATH];

    if (Win9x)
    {
        // System phonebook
        dwErr = ScanRasPhonebook( h, NULL );
        if (ERROR_CANNOT_OPEN_PHONEBOOK == dwErr)
        {
            // 9x stores Ras in the registry. If it can't find the registry,
            // assume there are no Ras connections that need migrating.
            dwErr = ERROR_SUCCESS;
        }
    }
    else
    {
        // Scan system pbk
        dwErr = GetWindowsDirectory(szWinDir, MAX_PATH );
        if (dwErr <= 0 || dwErr > MAX_PATH)
        {
            if (Verbose)
            {
                Win32Printf(LogFile,
                            "Error: Could not retrieve Windows directory: %d\r\n",
                            dwErr);
            }
            goto Err;
        }

        if ( (_tcslen(szWinDir) +
              _tcslen(RAS_NT4_RAS_PATH) +
              _tcslen(RAS_NT4_SYSTEM_PHONEBOOK) + 3) > MAX_PATH )
        {
            Win32PrintfResource(LogFile,
                                IDS_FILENAME_TOOLONG,
                                RAS_NT4_SYSTEM_PHONEBOOK);
            if (Verbose)
            {
                Win32Printf(STDERR,
                            "Error: Too Long Phonebook Filename: %s\\%s\\%s\r\n",
                            szWinDir,
                            RAS_NT4_RAS_PATH,
                            RAS_NT4_SYSTEM_PHONEBOOK);
            }
            dwErr = ERROR_FILENAME_EXCED_RANGE;
            goto Err;
        }

        sprintf( szPbkFileName, "%s\\%s\\%s",
                 szWinDir, RAS_NT4_RAS_PATH, RAS_NT4_SYSTEM_PHONEBOOK );
        // Make sure the file exists
        dwErr = GetFileAttributes(szPbkFileName);
        if (-1 == dwErr)
        {
            dwErr = GetLastError();
            if (dwErr == ERROR_FILE_NOT_FOUND ||
                dwErr == ERROR_PATH_NOT_FOUND)
            {
                // This phonebook file doesn't exist, which is fine.  Just skip it.
                dwErr = ERROR_SUCCESS;
            }
            else
            {
                goto Err;
            }
        }
        else
        {
            ChkErr( ScanRasPhonebook( h, szPbkFileName ) );
        }

        // Scan personal pbk
        dwErr = ScanReadKey (HKEY_CURRENT_USER,
                             (CHAR*) REGKEY_NT4_PBK,
                             (CHAR*) REGVAL_NT4_PRS_PBK_LOC,
                             (CHAR*) szValue, sizeof(szValue));
        if ( dwErr == ERROR_SUCCESS && szValue[0] != '\0')
        {
            if ( (_tcslen(szWinDir) +
                  _tcslen(RAS_NT4_RAS_PATH) +
                  _tcslen(szValue) + 3) > MAX_PATH )
            {
                 Win32PrintfResource(LogFile,
                                     IDS_FILENAME_TOOLONG,
                                     szValue);
                 if (Verbose)
                 {
                     Win32Printf(STDERR,
                                 "Error: Too Long Phonebook Filename: %s\\%s\\%s\r\n",
                                 szWinDir,
                                 RAS_NT4_RAS_PATH,
                                 szValue);
                 }
                 dwErr = ERROR_FILENAME_EXCED_RANGE;
                 goto Err;
            }

            sprintf( szPbkFileName, "%s\\%s\\%s", szWinDir, RAS_NT4_RAS_PATH, szValue );

            // Make sure the file exists
            dwErr = GetFileAttributes(szPbkFileName);
            if (-1 == dwErr)
            {
                dwErr = GetLastError();
                if (dwErr == ERROR_FILE_NOT_FOUND ||
                    dwErr == ERROR_PATH_NOT_FOUND)
                {
                    // This phonebook file doesn't exist. Just skip it
                    dwErr = ERROR_SUCCESS;
                }
                else
                {
                    goto Err;
                }
            }
            else
            {
                ChkErr( ScanRasPhonebook( h, szPbkFileName ) );
            }
        }
        else if (dwErr == ERROR_FILE_NOT_FOUND)
        {
            // Just because there is no personal pbk defined in the registry doesn't
            // mean there was a fatal error.  Just skip it and move on with life.
            dwErr = ERROR_SUCCESS;
        }
        else if (dwErr != ERROR_SUCCESS)
        {
            if (DebugOutput)
            {
                Win32Printf(LogFile, "ScanReadKey for personal PBK returned %d\r\n", dwErr);
            }
            goto Err;
        }

        // Scan alternate pbk
        dwErr = ScanReadKey (HKEY_CURRENT_USER,
                             (CHAR*) REGKEY_NT4_PBK,
                             (CHAR*) REGVAL_NT4_ALT_PBK_LOC,
                             (CHAR*) szValue, sizeof(szValue));
        if ( dwErr == ERROR_SUCCESS && szValue[0] != '\0')
        {
            // Make sure the file exists
            dwErr = GetFileAttributes(szValue);
            if (-1 == dwErr)
            {
                dwErr = GetLastError();
                if (dwErr == ERROR_FILE_NOT_FOUND ||
                    dwErr == ERROR_PATH_NOT_FOUND)
                {
                    // This phonebook file doesn't exist. Just skip it.
                    dwErr = ERROR_SUCCESS;
                }
                else
                {
                    return dwErr;
                }
            }
            else
            {
                ChkErr( ScanRasPhonebook( h, szValue ) );
            }
        }
        else if (dwErr == ERROR_FILE_NOT_FOUND)
        {
            // Just because there is no alternate pbk defined in the registry doesn't
            // mean there was a fatal error.  Just skip it and move on with life.
            dwErr = ERROR_SUCCESS;
        }
        else if ( dwErr != ERROR_SUCCESS )
        {
            if (DebugOutput)
            {
                Win32Printf(LogFile, "ScanReadKey for alternate pbk returned: %d\r\n", dwErr);
            }
            goto Err;
        }
    }

Err:
    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ScanRasSettings
//
//  Synopsis:   scans RAS settings for current user
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD ScanRasSettings (HANDLE h)
{
    DWORD          dwErr = ERROR_SUCCESS;

   if (IsRasInstalled())
    {
        ChkErr (Win32Printf (h, (CHAR *) RAS));
        ChkErr (ScanRasPerPhonebook (h));
    }
Err:
    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ScanEnumerateShares
//
//  Synopsis:   lists public (non-system) network shares
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD ScanEnumerateShares (HANDLE h)
{

    short nLevel = (short) (Win9x ? 50 : 502);
    DWORD dwErr = ERROR_SUCCESS;
    const int MAX_ENTRIES = 64;

    ScanNetShareEnumNT pNetShareEnum = NULL;
    ScanNetShareEnum9x pNetShareEnum9x = NULL;
    ScanNetAccessEnum9x pNetAccessEnum9x = NULL;

    HINSTANCE hInst = LoadLibraryA (Win9x ? "svrapi.dll" : "netapi32.dll");
    if (hInst == 0)
    {
        ChkErr (ERROR_INVALID_DLL);
    }

    ChkErr (Win32Printf (h, (CHAR *) SHARES));
    if (Win9x)
    {
        USHORT cbBuffer;
        USHORT nEntriesRead = 0;
        USHORT nTotalEntries = 0;
        USHORT i;
        static _share_info_50 pBuf[MAX_ENTRIES];
        _share_info_50* pTmpBuf = NULL;

        cbBuffer = MAX_ENTRIES * sizeof(_share_info_50);

        pNetShareEnum9x = (ScanNetShareEnum9x) GetProcAddress (hInst,
                            "NetShareEnum");
        if (pNetShareEnum9x == NULL)
        {
            ChkErr (ERROR_INVALID_DLL);
        }
        pNetAccessEnum9x = (ScanNetAccessEnum9x) GetProcAddress (hInst,
                            "NetAccessEnum");
        if (pNetAccessEnum9x == NULL)
        {
            ChkErr (ERROR_INVALID_DLL);
        }

        //
        // Call the NetShareEnum function to list the
        //  shares, specifying information level 50.
        //
        dwErr = (*pNetShareEnum9x)(NULL,
                          (short) nLevel,
                          (char *) pBuf,
                          cbBuffer,
                          &nEntriesRead,
                          &nTotalEntries);

        if (dwErr == ERROR_SUCCESS)
        {
            if (nTotalEntries > 0 && nEntriesRead != nTotalEntries)
                ChkErr (ERROR_MORE_DATA);

            for (i = 0; i < nEntriesRead; i++)
            {
                DWORD dwPerms = 0;
                pTmpBuf = &pBuf[i];

                // Require share to be a user-defined, persistent disk share
                if ((pTmpBuf->shi50_flags & SHI50F_SYSTEM) ||
                   !(pTmpBuf->shi50_flags & SHI50F_PERSIST) ||
                    pTmpBuf->shi50_type != STYPE_DISKTREE )
                {
                    continue;
                }

                if (pTmpBuf->shi50_flags & SHI50F_RDONLY)
                    dwPerms = ACCESS_READ;
                else if (pTmpBuf->shi50_flags & SHI50F_FULL)
                    dwPerms = ACCESS_ALL;
                //
                // Display the information for each entry retrieved.
                //
                ChkErr (Win32Printf (h, "%s, %s, %d, %s\r\n",
                        pTmpBuf->shi50_netname, pTmpBuf->shi50_path,
                        dwPerms, pTmpBuf->shi50_remark));

                //
                // Process custom access permissions
                //
                if ((pTmpBuf->shi50_flags & SHI50F_ACCESSMASK) ==
                                                SHI50F_ACCESSMASK)
                {
                   static CHAR AccessInfoBuf[16384];
                   WORD wItemsAvail, wItemsRead;
                   access_info_2 *pai;
                   access_list_2 *pal;

                   dwErr = (*pNetAccessEnum9x) (NULL,
                                     pTmpBuf->shi50_path,
                                     0,
                                     2,
                                     AccessInfoBuf,
                                     sizeof (AccessInfoBuf),
                                     &wItemsRead,
                                     &wItemsAvail
                                     );

                   if (dwErr != NERR_ACFNotLoaded)
                   {
                       BOOL LostCustomAccess = FALSE;
                       if (dwErr == ERROR_SUCCESS)
                       {
                            pai = (access_info_2 *) AccessInfoBuf;
                            pal = (access_list_2 *) (&pai[1]);

                            for (int i = 0 ; i < pai->acc2_count ; i++)
                            {
#if 0
                    // turn off custom access support
                    // implementation is incomplete
                                if (pal->acl2_access & READ_ACCESS_FLAGS)
                                    Win32Printf (h, "  %s, read\r\n",
                                                    pal->acl2_ugname);
                                else if(pal->acl2_access & FULL_ACCESS_FLAGS)
                                    Win32Printf (h, "  %s, full\r\n",
                                                    pal->acl2_ugname);
                                else
#endif
                                    LostCustomAccess = TRUE;

                                pal++;
                            }
                            if (LostCustomAccess)
                                Win32Printf (LogFile, "Warning custom access"
                                   " not migrated %s\r\n",
                                   pTmpBuf->shi50_netname);
                            pTmpBuf->shi50_flags |= SHI50F_ACLS;
                       }
                       else ChkErr (dwErr);
                   }
                }
                if (!(pTmpBuf->shi50_flags & SHI50F_ACLS) &&
                         (pTmpBuf->shi50_rw_password[0] ||
                          pTmpBuf->shi50_ro_password[0]))
                {
                    Win32PrintfResource (LogFile,
                                         IDS_SHARE_PASSWORD_NOT_MIGRATED,
                                         pTmpBuf->shi50_netname);
                }
            }
        }
        else if (dwErr == NERR_ServerNotStarted)
        {
             dwErr = ERROR_SUCCESS;
        }
    }
    else
    {
        ULONG cbBuffer = MAX_ENTRIES * sizeof(SHARE_INFO_502);
        ULONG nEntriesRead = 0;
        ULONG nTotalEntries = 0;
        ULONG i;
        SHARE_INFO_502* pBuf = NULL;
        SHARE_INFO_502* pTmpBuf = NULL;

        pNetShareEnum = (ScanNetShareEnumNT) GetProcAddress(hInst,
                                             "NetShareEnum");
        if (pNetShareEnum == NULL)
        {
            ChkErr (ERROR_INVALID_DLL);
        }
        //
        // Call the NetShareEnum function to list the
        //  shares, specifying information level 502.
        //
        dwErr = (*pNetShareEnum)(NULL,
                          nLevel,
                          (BYTE **) &pBuf,
                          cbBuffer,
                          &nEntriesRead,
                          &nTotalEntries,
                          NULL);

        //
        // Loop through the entries; process errors.
        //
        if (dwErr == ERROR_SUCCESS)
        {
            if ((pTmpBuf = pBuf) != NULL)
            {
                for (i = 0; (i < nEntriesRead); i++)
                {
                    //
                    // Display the information for each entry retrieved.
                    //
                    ChkErr (Win32Printf (h, "%ws, %ws, %d, %ws\r\n",
                        pTmpBuf->shi502_netname, pTmpBuf->shi502_path,
                        pTmpBuf->shi502_permissions, pTmpBuf->shi502_remark));

                    pTmpBuf++;
                }
            }
        }
        else
        {
            Win32PrintfResource (LogFile, IDS_CANNOT_ENUM_NETSHARES);
            LogFormatError (dwErr);
            dwErr = ERROR_SUCCESS;  // continue with other settings
        }

        if (pBuf != NULL)
        {
           ScanNetApiBufferFreeNT pNetApiBufferFree = NULL;

           pNetApiBufferFree = (ScanNetApiBufferFreeNT) GetProcAddress (hInst,
                                   "NetApiBufferFree");
           if (pNetApiBufferFree != NULL)
               (*pNetApiBufferFree) (pBuf);
        }
    }


Err:
    if (Verbose && dwErr != ERROR_SUCCESS)
        Win32Printf (LogFile, "Out ScanEnumerateShares => 0x%x\r\n", dwErr);
   return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ScanEnumeratePrinters
//
//  Synopsis:   list connected printers
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD ScanEnumeratePrinters (HANDLE h)
{
    DWORD dwErr;
    DWORD cbBuffer = 16384;      // 16K is a good size
    DWORD cbReceived;
    DWORD nPrinters;
    DWORD i;
    PRINTER_INFO_2 *pPrinterEnum;

    for(i = 0; i < 2; i++)
    {
       dwErr = ERROR_SUCCESS;

       pPrinterEnum = (PRINTER_INFO_2 *) GlobalAlloc(GPTR, cbBuffer);
       if (pPrinterEnum == NULL)
           ChkErr (ERROR_NOT_ENOUGH_MEMORY);

       if (FALSE == EnumPrintersA (Win9x ? PRINTER_ENUM_LOCAL :
                                  PRINTER_ENUM_LOCAL|PRINTER_ENUM_CONNECTIONS,
                                  NULL,
                                  2,
                                  (BYTE *) pPrinterEnum,
                                  cbBuffer,
                                  &cbReceived,
                                  &nPrinters))
       {
           dwErr = GetLastError();
           if (RPC_S_SERVER_UNAVAILABLE == dwErr)
           {
               // If the print spooler is turned off, then
               // assume there are no printers to migrate
               dwErr = ERROR_SUCCESS;
               goto Err;
           }

           if( dwErr == ERROR_INSUFFICIENT_BUFFER || dwErr == ERROR_MORE_DATA )
           {
              GlobalFree(pPrinterEnum);
              cbBuffer = cbReceived;

              // Try again.
              continue;
           }
       }

       // Success, or some other error besides buffer to small.. so bail.
       break;
    }
    ChkErr (dwErr);

    ChkErr (Win32Printf (h, (CHAR *) PRINTERS));
    for (i=0; i < nPrinters; i++)
    {
        if (Win9x)
        {
            ChkErr (Win32Printf(h, "%s\r\n", pPrinterEnum[i].pPortName));
        }
        else
        {
            ChkErr (Win32Printf(h, "%s\r\n", pPrinterEnum[i].pPrinterName));
        }
    }

Err:
    if (pPrinterEnum != NULL)
        GlobalFree (pPrinterEnum);

    if (Verbose && dwErr != ERROR_SUCCESS)
        Win32Printf (LogFile, "Out ScanEnumeratePrinters => 0x%x\r\n", dwErr);
    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ScanEnumerateNetResources
//
//  Synopsis:   lists connected remote drives and resources
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD ScanEnumerateNetResources (HANDLE h, DWORD dwScope, NETRESOURCEA *lpnr)
{

  DWORD dwErr, dwResultEnum;
  HANDLE hEnum;
  DWORD cbBuffer = 16384;      // 16K is a good size
  DWORD cEntries = 0xFFFFFFFF; // enumerate all possible entries
  LPNETRESOURCEA lpnrLocal;     // pointer to enumerated structures
  DWORD i;

  dwErr = WNetOpenEnumA(dwScope,
                          RESOURCETYPE_ANY,
                          0,        // enumerate all resources
                          lpnr,     // NULL first time this function is called
                          &hEnum);  // handle to resource

  if (dwErr != NO_ERROR)
  {
    // An application-defined error handler is demonstrated in the
    // section titled "Retrieving Network Errors."

    return dwErr;
  }

  lpnrLocal = (LPNETRESOURCEA) GlobalAlloc(GPTR, cbBuffer);
    if (lpnrLocal == NULL)
        ChkErr (ERROR_NOT_ENOUGH_MEMORY);

  do
  {
    ZeroMemory(lpnrLocal, cbBuffer);

    dwResultEnum = WNetEnumResourceA (hEnum,      // resource handle
                                    &cEntries,  // defined locally as 0xFFFFFFFF
                                    lpnrLocal,  // LPNETRESOURCE
                                    &cbBuffer); // buffer size

    if (dwResultEnum == NO_ERROR)
    {
      for(i = 0; i < cEntries; i++)
      {
        // Following is an application-defined function for
        // displaying contents of NETRESOURCE structures.

        if (lpnrLocal[i].lpLocalName != NULL)
        {
            ChkErr (Win32Printf (h, "%s, %s, %s\r\n", lpnrLocal[i].lpLocalName,
            lpnrLocal[i].lpRemoteName == NULL ? "" : lpnrLocal[i].lpRemoteName,
            lpnrLocal[i].dwScope == RESOURCE_REMEMBERED ? "persist" : ""));
        }

#if 0
        // If this NETRESOURCE is a container, call the function
        // recursively.

        // Looking at the docs, it appears that the dwUsage is only applicable for
        // GLOBALNET enumerations, and not for CONNECTED enumerations.  We shouldn't
        // have to worry about recursively finding resources, because all we care
        // about is what is currently connected.  This was a problem for Netware
        // shares, in which case it recursively found itself until it aborted or AV'd.

        if(RESOURCEUSAGE_CONTAINER == (lpnrLocal[i].dwUsage
                                       & RESOURCEUSAGE_CONTAINER))
          if((dwErr = ScanEnumerateNetResources (h, dwScope, &lpnrLocal[i])) !=
                         ERROR_SUCCESS)
             return dwErr;
#endif
      }
    }
  }
  while(dwResultEnum != ERROR_NO_MORE_ITEMS);

    if (lpnrLocal != NULL)
        GlobalFree((HGLOBAL)lpnrLocal);

    dwErr = WNetCloseEnum(hEnum);

Err:
    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ScanReadKey
//
//  Synopsis:   retrieves a string or blob from the registry
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD ScanReadKey (HKEY hKeyStart,
                   CHAR *szKey,
                   CHAR *szName,
                   CHAR *szValue,
                   ULONG ulLen)
{
    HKEY hKey = NULL;
    DWORD dwErr = ERROR_SUCCESS;

    ChkErr (RegOpenKeyExA(hKeyStart, szKey, NULL, KEY_READ, &hKey));
    ChkErr (RegQueryValueExA(hKey, szName, NULL, NULL,(BYTE*)szValue, &ulLen));

Err:
    if (hKey != NULL)
        RegCloseKey (hKey);

    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ScanGetTimeZone
//
//  Synopsis:   retrieves the time zone name
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD ScanGetTimeZone (HANDLE h)
{
    CHAR szValue[LINEBUFSIZE];
    DWORD dwErr =  ERROR_SUCCESS;

    if (ERROR_SUCCESS == ScanReadKey (HKEY_LOCAL_MACHINE,
                                     (CHAR*) REGKEY_TIMEZONE,
                                     (CHAR*) REGVAL_TIMEZONE,
                                     (CHAR*) szValue, sizeof(szValue)))
    {
        dwErr = Win32Printf (h, "%s=%s\r\n", TIMEZONE, szValue);
    }

    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ScanGetComputerName
//
//  Synopsis:   retrieves the current NETBIOS machine name
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

#if 0   // currently not used, but may be needed in the future
DWORD ScanGetComputerName (CHAR *szValue, ULONG ulLen)
{
    if (FALSE == GetComputerNameA(szValue, &ulLen))
        return GetLastError();

    return ERROR_SUCCESS;
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   ScanGetFullName
//
//  Synopsis:   retrieves the registered name
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD ScanGetFullName (HANDLE h)
{
    CHAR szValue[LINEBUFSIZE];
    DWORD dwErr =  ERROR_SUCCESS;

    if (ERROR_SUCCESS == ScanReadKey (HKEY_LOCAL_MACHINE,
                        Win9x ? (CHAR*)REGKEY_VERSION_9x :(CHAR*)REGKEY_VERSION,
                        (CHAR*) REGVAL_FULLNAME, szValue, sizeof(szValue)))
    {
        dwErr = Win32Printf (h, "%s=%s\r\n", FULLNAME, szValue);
    }

    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ScanGetOrgName
//
//  Synopsis:   retrieves the organization name
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD ScanGetOrgName (HANDLE h)
{
    CHAR szValue[LINEBUFSIZE];
    DWORD dwErr = ERROR_SUCCESS;

    if (ERROR_SUCCESS == ScanReadKey (HKEY_LOCAL_MACHINE,
                        Win9x ? (CHAR*)REGKEY_VERSION_9x :(CHAR*)REGKEY_VERSION,
                        (CHAR*)REGVAL_ORGNAME, szValue, sizeof(szValue)))
    {
        dwErr = Win32Printf (h, "%s=%s\r\n", ORGNAME, szValue);
    }

    return dwErr;
}

//
// IsLanguageMatched : if source and target language are matched (or compatible)
//
//      1. if SourceNativeLangID == TargetNativeLangID
//
//      2. if SourceNativeLangID's alternative ID == TargetNative LangID
//

typedef struct _tagLANGINFO {
    LANGID LangID;
    INT    Count;
} LANGINFO,*PLANGINFO;

//+---------------------------------------------------------------------------
//
//  Function:   EnumLangProc
//
//  Synopsis:   callback to pull out the langid while enumerating
//
//  Arguments:
//
//  Returns:    bool to continue to stop enumeration
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

BOOL CALLBACK EnumLangProc(
    HANDLE hModule,     // resource-module handle
    LPCTSTR lpszType,   // pointer to resource type
    LPCTSTR lpszName,   // pointer to resource name
    WORD wIDLanguage,   // resource language identifier
    LONG_PTR lParam     // application-defined parameter
   )
{
    PLANGINFO LangInfo;

    LangInfo = (PLANGINFO) lParam;

    LangInfo->Count++;

    //
    // for localized build contains multiple resource,
    // it usually contains 0409 as backup lang.
    //
    // if LangInfo->LangID != 0 means we already assigned an ID to it
    //
    // so when wIDLanguage == 0x409, we keep the one we got from last time
    //
    if ((wIDLanguage == 0x409) && (LangInfo->LangID != 0)) {
        return TRUE;
    }

    LangInfo->LangID  = wIDLanguage;

    return TRUE;        // continue enumeration
}

//+---------------------------------------------------------------------------
//
//  Function:   GetNTDLLNativeLangID
//
//  Synopsis:   pull the language id from ntdll for NT systems only
//
//  Arguments:
//
//  Returns:    Native lang ID in ntdll.dll
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

LANGID GetNTDLLNativeLangID()
{
    LPCTSTR Type = (LPCTSTR) RT_VERSION;
    LPCTSTR Name = (LPCTSTR) 1;

    LANGINFO LangInfo;

    ZeroMemory(&LangInfo,sizeof(LangInfo));

    EnumResourceLanguages(
            GetModuleHandle(TEXT("ntdll.dll")),
            Type,
            Name,
            (ENUMRESLANGPROC) EnumLangProc,
            (LONG_PTR) &LangInfo
            );

    return LangInfo.LangID;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsHongKongVersion
//
//  Synopsis:   identifies HongKong NT 4.0  (English UI w/ Chinese locale)
//
//  Arguments:
//
//  Returns:    TRUE/FALSE
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

BOOL IsHongKongVersion()
{
    HMODULE hMod;
    BOOL bRet = FALSE;
    typedef BOOL (*IMMRELEASECONTEXT) (HWND,HANDLE);
    IMMRELEASECONTEXT pImmReleaseContext;

    LANGID TmpID = GetNTDLLNativeLangID();

    if (((GetVersion() >> 16) == 1381) && (TmpID == 0x0409))
    {

        hMod = LoadLibrary(TEXT("imm32.dll"));
        if (hMod)
        {
            pImmReleaseContext = (IMMRELEASECONTEXT)
                GetProcAddress(hMod,"ImmReleaseContext");

            if (pImmReleaseContext) {
                bRet = pImmReleaseContext(NULL,NULL);
            }

            FreeLibrary(hMod);
        }
    }
    return (bRet);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetDefaultUserLangID
//
//  Synopsis:   retrieves the language of the OS
//
//  Arguments:
//
//  Returns:    .DEFAULT user's LANGID
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

LANGID GetDefaultUserLangID()
{
    LONG            dwErr;
    HKEY            hkey;
    DWORD           dwSize;
    CHAR            buffer[512];
    LANGID          langid = 0;

    dwErr = RegOpenKeyEx( HKEY_USERS,
                          TEXT(".DEFAULT\\Control Panel\\International"),
                          0,
                          KEY_READ,
                          &hkey );

    if( dwErr == ERROR_SUCCESS )
    {

        dwSize = sizeof(buffer);
        dwErr = RegQueryValueExA(hkey,
                                 "Locale",
                                 NULL,  //reserved
                                 NULL,  //type
                                 (BYTE *)buffer,
                                 &dwSize );

        if(dwErr == ERROR_SUCCESS)
        {
            langid = LANGIDFROMLCID(strtoul(buffer,NULL,16));

        }
        RegCloseKey(hkey);
    }
    return langid;
}

//+---------------------------------------------------------------------------
//
//  Function:   ScanGetLang
//
//  Synopsis:   retrieves the language of the OS
//
//  Arguments:  [pdwLang] -- output Language ID
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD ScanGetLang (DWORD *pdwLang)
{
    HKEY hKey;
    DWORD dwErr = ERROR_SUCCESS;
    DWORD langid = 0;
    DWORD dwSize;
    BYTE buffer[LINEBUFSIZE];

    if (Win9x)
    {
        dwErr = RegOpenKeyEx( HKEY_USERS,
                    TEXT(".Default\\Control Panel\\desktop\\ResourceLocale"),
                    0, KEY_READ, &hKey );

        if (dwErr == ERROR_SUCCESS)
        {
            dwSize = sizeof(buffer);
            dwErr = RegQueryValueExA( hKey,
                                     "",
                                     NULL,  //reserved
                                     NULL,  //type
                                     buffer,
                                     &dwSize );

            if(dwErr == ERROR_SUCCESS)
            {
                langid = LANGIDFROMLCID(strtoul((CHAR*)buffer,NULL,16));
                *pdwLang = langid;
            }
            RegCloseKey(hKey);
        }
        if ( dwErr != ERROR_SUCCESS )
        {
           dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    TEXT("System\\CurrentControlSet\\Control\\Nls\\Locale"),
                    0, KEY_READ, &hKey );

           if (dwErr == ERROR_SUCCESS)
           {
              dwSize = sizeof(buffer);
              dwErr = RegQueryValueExA( hKey,
                                        "",
                                        NULL,  //reserved
                                        NULL,  //type
                                        buffer,
                                        &dwSize );

              if (dwErr == ERROR_SUCCESS)
              {
                  langid = LANGIDFROMLCID(strtoul((CHAR*)buffer,NULL,16));
                  *pdwLang = langid;
              }
              RegCloseKey(hKey);
           }
        }
    }
    else
    {
         langid = GetNTDLLNativeLangID();
         if (langid == 0x0409)
         {
             if (IsHongKongVersion())  // block Pan-Chinese upgrade to English
             {
                 langid = 0x0C04;      // map to Chinese (Hong Kong SAR)
             }
         }
         *pdwLang = langid;
    }
    if (Verbose && dwErr != ERROR_SUCCESS)
        Win32Printf (LogFile, "ScanGetLang %d, LangID=%x\n", dwErr, langid);
    return dwErr;
}

#define ACCESS_KEY TEXT("Control Panel\\Accessibility\\")

//+---------------------------------------------------------------------------
//
//  Function:   ScanConvertFlags
//
//  Synopsis:   convert accessibility flags
//
//  Arguments:  [pcsObject] -- registry key name
//              [pOptions]  -- conversion table
//              [dwForceValues] -- force these options to be on
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD ScanConvertFlags (HANDLE h,
                        TCHAR *pcsObject,
                        ACCESS_OPTION *pOptions,
                        DWORD dwForceValues)
{
    HKEY hKey = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    DWORD Flags;
    DWORD dw;
    BYTE  *lpBuffer = NULL;
    DWORD dwBufferSize = 0;
    DWORD dwRequiredSize;

    if (ERROR_SUCCESS == RegOpenKeyEx( HKEY_CURRENT_USER,
                    pcsObject, 0, KEY_READ, &hKey ))
    {
        //
        // Get flag settings from Win95 registry and convert them to Flags
        //

        Flags = 0;

        while (pOptions->ValueName)
        {
            // How big of a buffer do we need?
            RegQueryValueEx(hKey, pOptions->ValueName, NULL, NULL, NULL, &dwRequiredSize);
            if (dwRequiredSize > dwBufferSize)
            {
                if (lpBuffer == NULL)
                {
                    lpBuffer = (BYTE *)malloc(dwRequiredSize * sizeof(BYTE));
                }
                else
                {
                    lpBuffer = (BYTE *)realloc(lpBuffer, dwRequiredSize * sizeof(BYTE));
                }
                dwBufferSize = dwRequiredSize;
            }

            ZeroMemory(lpBuffer, dwBufferSize);

            // Read value
            if (ERROR_SUCCESS == RegQueryValueEx( hKey,
                                      pOptions->ValueName,
                                      NULL,  //reserved
                                      NULL,  //type
                                      lpBuffer,
                                      &dwBufferSize ))
            {
                // Convert to int
                dw = atoi((const char *)lpBuffer);

                //
                // Most flags are identical on Win9x and NT, but there's one
                // MouseKey flag that needs to be inverted.
                //

                if (pOptions->FlagVal & SPECIAL_INVERT_OPTION)
                {
                    if (dw == 0)
                    {
                        Flags |= (pOptions->FlagVal & (~SPECIAL_INVERT_OPTION));
                    }
                }
                else if (dw != 0)
                {
                    Flags |= pOptions->FlagVal;
                }
            }
            pOptions++;
        }
        Flags |= dwForceValues;
        Win32Printf (h, "HKR, \"%s\", \"Flags\", 0x0, \"%d\"\r\n",
                     pcsObject, Flags);

        RegCloseKey (hKey);
    }
    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ScanAccessibility
//
//  Synopsis:   convertes Accessibility settings
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD ScanAccessibility (HANDLE h)
{
    DWORD dwErr = ERROR_SUCCESS;

    const TCHAR ACCESS_AVAILABLE[] =          TEXT("Available");
    const TCHAR ACCESS_CLICKON[] =            TEXT("ClickOn");
    const TCHAR ACCESS_CONFIRMHOTKEY[] =      TEXT("ConfirmHotKey");
    const TCHAR ACCESS_HOTKEYACTIVE[] =       TEXT("HotKeyActive");
    const TCHAR ACCESS_HOTKEYSOUND[] =        TEXT("HotKeySound");
    const TCHAR ACCESS_ON[] =                 TEXT("On");
    const TCHAR ACCESS_ONOFFFEEDBACK[] =      TEXT("OnOffFeedback");
    const TCHAR ACCESS_SHOWSTATUSINDICATOR[]= TEXT("ShowStatusIndicator");
    const TCHAR ACCESS_MODIFIERS[] =          TEXT("Modifiers");
    const TCHAR ACCESS_REPLACENUMBERS[] =     TEXT("ReplaceNumbers");
    const TCHAR ACCESS_AUDIBLEFEEDBACK[] =    TEXT("AudibleFeedback");
    const TCHAR ACCESS_TRISTATE[] =           TEXT("TriState");
    const TCHAR ACCESS_TWOKEYSOFF[] =         TEXT("TwoKeysOff");
    const TCHAR ACCESS_HOTKEYAVAILABLE[] =    TEXT("HotKeyAvailable");

    ACCESS_OPTION FilterKeys[] = {
        ACCESS_ON,                     BASICS_ON,
        ACCESS_AVAILABLE,              BASICS_AVAILABLE,
        ACCESS_HOTKEYACTIVE,           BASICS_HOTKEYACTIVE,
        ACCESS_CONFIRMHOTKEY,          BASICS_CONFIRMHOTKEY,
        ACCESS_HOTKEYSOUND,            BASICS_HOTKEYSOUND,
        ACCESS_SHOWSTATUSINDICATOR,    BASICS_INDICATOR,
        ACCESS_CLICKON,                FKF_CLICKON,
        NULL,                       0
    };

    ACCESS_OPTION MouseKeys[] = {
        ACCESS_ON,                     BASICS_ON,
        ACCESS_AVAILABLE,              BASICS_AVAILABLE,
        ACCESS_HOTKEYACTIVE,           BASICS_HOTKEYACTIVE,
        ACCESS_CONFIRMHOTKEY,          BASICS_CONFIRMHOTKEY,
        ACCESS_HOTKEYSOUND,            BASICS_HOTKEYSOUND,
        ACCESS_SHOWSTATUSINDICATOR,    BASICS_INDICATOR,
        ACCESS_MODIFIERS,              MKF_MODIFIERS|SPECIAL_INVERT_OPTION,
        ACCESS_REPLACENUMBERS,         MKF_REPLACENUMBERS,
        NULL,                       0
    };

    ACCESS_OPTION StickyKeys[] = {
        ACCESS_ON,                     BASICS_ON,
        ACCESS_AVAILABLE,              BASICS_AVAILABLE,
        ACCESS_HOTKEYACTIVE,           BASICS_HOTKEYACTIVE,
        ACCESS_CONFIRMHOTKEY,          BASICS_CONFIRMHOTKEY,
        ACCESS_HOTKEYSOUND,            BASICS_HOTKEYSOUND,
        ACCESS_SHOWSTATUSINDICATOR,    BASICS_INDICATOR,
        ACCESS_AUDIBLEFEEDBACK,        SKF_AUDIBLEFEEDBACK,
        ACCESS_TRISTATE,               SKF_TRISTATE,
        ACCESS_TWOKEYSOFF,             SKF_TWOKEYSOFF,
        NULL,                       0
    };

    ACCESS_OPTION SoundSentry[] = {
        ACCESS_ON,                     BASICS_ON,
        ACCESS_AVAILABLE,              BASICS_AVAILABLE,
        ACCESS_SHOWSTATUSINDICATOR,    BASICS_INDICATOR,
        NULL,                       0
    };

    ACCESS_OPTION TimeOut[] = {
        ACCESS_ON,                     BASICS_ON,
        ACCESS_ONOFFFEEDBACK,          ATF_ONOFFFEEDBACK,
        NULL,                       0
    };

    ACCESS_OPTION ToggleKeys[] = {
        ACCESS_ON,                     BASICS_ON,
        ACCESS_AVAILABLE,              BASICS_AVAILABLE,
        ACCESS_HOTKEYACTIVE,           BASICS_HOTKEYACTIVE,
        ACCESS_CONFIRMHOTKEY,          BASICS_CONFIRMHOTKEY,
        ACCESS_HOTKEYSOUND,            BASICS_HOTKEYSOUND,
        ACCESS_SHOWSTATUSINDICATOR,    BASICS_INDICATOR,
        NULL,                       0
    };

    ACCESS_OPTION HighContrast[] = {
        ACCESS_ON,                     BASICS_ON,
        ACCESS_AVAILABLE,              BASICS_AVAILABLE,
        ACCESS_HOTKEYACTIVE,           BASICS_HOTKEYACTIVE,
        ACCESS_CONFIRMHOTKEY,          BASICS_CONFIRMHOTKEY,
        ACCESS_HOTKEYSOUND,            BASICS_HOTKEYSOUND,
        ACCESS_SHOWSTATUSINDICATOR,    BASICS_INDICATOR,
        ACCESS_HOTKEYAVAILABLE,        HCF_HOTKEYAVAILABLE,
        NULL,                       0
    };

    ChkErr (Win32Printf (h, "\r\n[Accessibility]\r\n"));
    ChkErr (ScanConvertFlags (h, ACCESS_KEY "KeyboardResponse", &FilterKeys[0],  BASICS_AVAILABLE));
    ChkErr (ScanConvertFlags (h, ACCESS_KEY "MouseKeys",   &MouseKeys[0],   BASICS_AVAILABLE));
    ChkErr (ScanConvertFlags (h, ACCESS_KEY "StickyKeys",  &StickyKeys[0],  BASICS_AVAILABLE));
    ChkErr (ScanConvertFlags (h, ACCESS_KEY "SoundSentry", &SoundSentry[0], BASICS_AVAILABLE));
    ChkErr (ScanConvertFlags (h, ACCESS_KEY "TimeOut",     &TimeOut[0],     0));
    ChkErr (ScanConvertFlags (h, ACCESS_KEY "ToggleKeys",  &ToggleKeys[0],  0));
    ChkErr (ScanConvertFlags (h, ACCESS_KEY "HighContrast",&HighContrast[0],
        BASICS_AVAILABLE | BASICS_INDICATOR | HCF_HOTKEYAVAILABLE));

Err:
    if (Verbose && dwErr != ERROR_SUCCESS)
        Win32Printf (LogFile, "Out ScanAccessibility => %d\n", dwErr);
    return dwErr;
}

#define DESKTOP_KEY TEXT("Control Panel\\desktop")

//+--------------------------------------------------------------------------
//
//  Function:   ScanGetScreenSaverExe
//
//  Synopsis:   get screen saver name from system.ini
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//---------------------------------------------------------------------------

DWORD ScanGetScreenSaverExe (HANDLE h)
{
    DWORD dwErr = ERROR_SUCCESS;
    TCHAR IniFileSetting[MAX_PATH];

    GetPrivateProfileString (
            TEXT("boot"),
            SCRNSAVE,
            TEXT(""),
            IniFileSetting,
            MAX_PATH,
            TEXT("SYSTEM.INI"));

    if (IniFileSetting[0] == '\0')
        return ERROR_SUCCESS;

    dwErr = Win32Printf (h, "HKR, \"%s\", \"%s\", 0x%x, \"%s\"\r\n",
                 DESKTOP_KEY, SCRNSAVE, FLG_ADDREG_TYPE_SZ, IniFileSetting);

    return dwErr;
}

//+--------------------------------------------------------------------------
//
//  Function:   ScanDesktop
//
//  Synopsis:   convert desktop settings
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//---------------------------------------------------------------------------

DWORD ScanDesktop (HANDLE h)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (Win9x)  // screen savers are already in the registry on NT
    {
        ChkErr (Win32Printf (h, "\r\n[Desktop]\r\n"));
        ChkErr (ScanGetScreenSaverExe (h));
        ChkErr (Win32Printf (h, "\r\n"));

Err:
        if (Verbose && dwErr != ERROR_SUCCESS)
            Win32Printf (LogFile, "Out ScanDesktop => %x\r\n", dwErr);
    }
    return dwErr;
}

#define IS_IME_KBDLAYOUT(hkl) ((HIWORD((ULONG_PTR)(hkl)) & 0xf000) == 0xe000)

//+--------------------------------------------------------------------------
//
//  Function:   ScanGetKeyboardLayouts
//
//  Synopsis:   retrieve all active input locales
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//---------------------------------------------------------------------------

DWORD ScanGetKeyboardLayouts (HANDLE h)
{
    DWORD dwErr = ERROR_SUCCESS;
    TCHAR kbname[KL_NAMELENGTH];
    int nLayout = GetKeyboardLayoutList(0, NULL);
    HKL hkl = GetKeyboardLayout (0);
    HKL * phkl = new HKL [nLayout];
    if (phkl == NULL)
        ChkErr (ERROR_NOT_ENOUGH_MEMORY);

    if (FALSE != GetKeyboardLayoutName (kbname))
    {
        // get the default input locale
        //
        ChkErr (Win32Printf (h, "%s=%s", INPUTLOCALE, kbname));
        GetKeyboardLayoutList (nLayout, phkl);

        for (int i=0; i < nLayout; i++)
        {
            if (hkl != phkl[i])  // get the alternate layouts
            {
                if (0 == ActivateKeyboardLayout (phkl[i], 0))
                {
                    if (!IS_IME_KBDLAYOUT(phkl[i]))  // use locale default
                        wsprintf (kbname, "%08x", LOWORD(phkl[i]));
                    ChkErr (Win32Printf (h, ",%s", kbname));
                }
                else if (FALSE != GetKeyboardLayoutName (kbname))
                    ChkErr (Win32Printf (h, ",%s", kbname));
            }
        }
        ChkErr (Win32Printf (h, "\r\n"));
    }

Err:
    ActivateKeyboardLayout (hkl, 0);  // restore current input locale
    if (phkl != NULL)
        delete [] phkl;
    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ScanSystem
//
//  Synopsis:   scan system settings
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  History:    20-Sep-99   HenryLee    Created
//
//----------------------------------------------------------------------------

DWORD ScanSystem()
{
  DWORD result = ERROR_SUCCESS;

  if (!CopySystem && !SchedSystem)
    goto cleanup;

#if 0
  result = ScanEnumerateShares (OutputFile);
  if (result != ERROR_SUCCESS)
    goto cleanup;
#else
  Win32Printf (OutputFile, (CHAR *) SHARES);
#endif

  if (DebugOutput)
       Win32Printf(LogFile, " Enumerating Net Resources\r\n");
  result = ScanEnumerateNetResources (OutputFile, RESOURCE_CONNECTED, NULL);
  if (result != ERROR_SUCCESS)
    goto cleanup;

  if (DebugOutput)
       Win32Printf(LogFile, " Enumerating Printers\r\n");
  result = ScanEnumeratePrinters (OutputFile);
  if (result != ERROR_SUCCESS)
    goto cleanup;

  if (DebugOutput)
       Win32Printf(LogFile, " Scanning RAS Settings\r\n");
  result = InitializeRasApi();
  if (result == ERROR_SUCCESS)
  {
      result = ScanRasSettings (OutputFile);
      if (result != ERROR_SUCCESS)
          goto cleanup;
  }

  if (Win9x)  // Accessibility settings on NT are registry compatible and forced
  {
    if (DebugOutput)
         Win32Printf(LogFile, " Scanning Accessibility options\r\n");
    result = ScanAccessibility (OutputFile);  // convert the settings
    if (result != ERROR_SUCCESS)
        goto cleanup;
  }

  if (DebugOutput)
       Win32Printf(LogFile, " Scanning Desktop\r\n");
  result = ScanDesktop (OutputFile);
  if (result != ERROR_SUCCESS)
    goto cleanup;

cleanup:
    if (result != ERROR_SUCCESS)
        LogFormatError (result);

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\winstate\v1\scanstate\scanuser.cxx ===
//--------------------------------------------------------------
//
// File:        scanuser
//
// Contents:    Scans the machine and produces an INF file
//              describing the user hive
//
//---------------------------------------------------------------

#include <scanhead.cxx>
#pragma hdrstop

#include <common.hxx>

#include <scanstate.hxx>
#include <bothchar.cxx>

//---------------------------------------------------------------
// Constants.

const DWORD MAX_FILENAME = 256;
const DWORD MAX_REG_SIZE = 1024;

const char NTHIVEPATH[]   = "%userprofile%\\ntuser.dat";
const char NTHIVENAME[]   = "\\ntuser.dat";
const char WINHIVENAME[]  = "\\user.dat";

//---------------------------------------------------------------
// Types.


//---------------------------------------------------------------
// Globals.


//---------------------------------------------------------------
void CleanupUser()
{
  // Close the key.
  if (CurrentUser != NULL)
  {
    RegCloseKey( CurrentUser );
    CurrentUser = NULL;
  }

  // Unload the hive.
  RegUnLoadKey( HKEY_USERS, BUILDKEY );
}

//---------------------------------------------------------------
// This function writes a registry key to an inf file.  The function
// takes the following parameters:
//      root    - HKEY_LOCAL_MACHINE or HKEY_CURRENT_USER
//      key     - string key path
//      flags   - indicate whether to write this keys values or its
//                subkeys.
//      regfileDest - destination to which the file should be written if this is a regfile key
//      returns - IDS_OK on success or a resource id on error.
//
// Notes:
//     This function does not write log messages.
//     
//     RegEnumValue does not return ERROR_MORE_DATA for dwords
//
DWORD RegWriteToInf( char *rootname, char *key, char *value, DWORD flags, char *regfileDest )
{
  UCHAR         *data       = NULL;
  BOOL           wrote_value = FALSE;
  DWORD          i;
  DWORD          result;
  BOOL           success;
  DWORD          type;
  char          *full_name  = NULL;
  char          *leaf_name  = NULL;
  char          *value_name = NULL;
  DWORD          full_name_len;
  DWORD          leaf_name_len;
  DWORD          value_name_len;
  DWORD          max_value_name_len;
  DWORD          max_leaf_name_len;
  DWORD          data_len   = 80;
  DWORD          req_len;
  DWORD          num_values;
  DWORD          num_subkeys;
  HKEY           hkey = NULL;
  DWORD          key_len;
  HKEY           root;
  BOOL           nested_error = FALSE;

  // Convert the rootname to the root HKEY.
  if (_stricmp( rootname, "HKLM" ) == 0)
    root = HKEY_LOCAL_MACHINE;
  else if (_stricmp( rootname, "HKR" ) == 0)
    root = CurrentUser;
  else
  {
    if (DebugOutput)
        Win32Printf(LogFile, "RegWriteToInf: Invalid rootname %s\r\n", rootname);
    return ERROR_INVALID_PARAMETER;
  }

  // Compute the length of the key.
  if (key == NULL)
    key_len = 0;
  else
    key_len = strlen(key);

  // Find out how much memory to allocate for key names.
  // Open the key.
  result = RegOpenKeyExA( root, key, 0, KEY_READ, &hkey );
  if (result == ERROR_FILE_NOT_FOUND)
    return ERROR_SUCCESS;
  else if (result != ERROR_SUCCESS)
  {
    if (DebugOutput)
    {
        Win32Printf(LogFile, "RegOpenKey %s failed: %d\r\n", key, result);
    }
    goto cleanup;
  }

  // Query it.
  result = RegQueryInfoKeyA( hkey, NULL, NULL, NULL, &num_subkeys,
                             &max_leaf_name_len, NULL, &num_values,
                             &max_value_name_len, NULL, NULL, NULL );
  if (ERROR_SUCCESS != result)
  {
      if (DebugOutput)
      {
          Win32Printf(LogFile, "RegQueryInfoKey failed: %d\r\n", result);
      }
      goto cleanup;
  }

  // Allocate memory for the key and value names.
  max_leaf_name_len  += 1;
  max_value_name_len += 1;
  full_name_len = key_len+max_leaf_name_len+1;
  full_name     = (char *) malloc( full_name_len );
  value_name    = (char *) malloc( max_value_name_len );
  data          = (UCHAR *) malloc( data_len );
  if (full_name == NULL || value_name == NULL || data == NULL)
  {
    result = ERROR_NOT_ENOUGH_MEMORY;
    goto cleanup;
  }

  // Copy the key name into the full name buffer.
  leaf_name = full_name + key_len;
  if (key != NULL)
  {
    strcpy( full_name, key );
    leaf_name[0] = '\\';
    leaf_name += 1;
  }

  // If the caller specifed a value, only write that one.
  if (value != NULL)
  {
    req_len = data_len;
    result = RegQueryValueEx( hkey, value, NULL, &type, data, &req_len );
    if (result == ERROR_MORE_DATA)
    {
      free( data );
      data = (UCHAR *) malloc( req_len );
      data_len = req_len;
      if (data == NULL)
      {
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
      }
      result = RegQueryValueEx( hkey, value, NULL, &type, data, &req_len );
    }
    if (result == ERROR_SUCCESS)
    {
      result = WriteKey( OutputFile, type, rootname, key, value, data, req_len );
      if (ERROR_SUCCESS != result)
      {
          if (DebugOutput)
          {
              Win32Printf(LogFile, "WriteKey %s\\%s[%s] Failed: %d\r\n", 
                          rootname, key, value, result);
          }
          goto cleanup;
      }
      if ((flags & file_fa) && data != NULL &&
          (type == REG_SZ || type == REG_EXPAND_SZ))
      {
        result = PickUpThisFile( (TCHAR *)data, (TCHAR *)regfileDest );
        if (ERROR_SUCCESS != result)
        {
            if (DebugOutput)
            {
                Win32Printf(LogFile, "PickUpThisFile %s Failed: %d\r\n", data, result);
            }
            goto cleanup;
        }
      }
      wrote_value = TRUE;
    }
    result = ERROR_SUCCESS;
  }

  // Write values.
  else
  {
    i = 0;
    do
    {
      // Read a value name.
      req_len        = data_len;
      value_name_len = max_value_name_len;
      result = RegEnumValueA( hkey, i, value_name, &value_name_len, NULL,
                              &type, data, &req_len );
      if (result == ERROR_MORE_DATA)
      {
        free( data );
        data = (UCHAR *) malloc( req_len );
        data_len = req_len;
        if (data == NULL)
        {
          result = ERROR_NOT_ENOUGH_MEMORY;
          goto cleanup;
        }
        result = RegEnumValueA( hkey, i, value_name, &value_name_len, NULL,
                                &type, data, &req_len );
      }

      // Write the value name to the INF file.
      if (result == ERROR_SUCCESS)
      {
        i += 1;
        result = WriteKey( OutputFile, type, rootname, key, value_name, data, req_len );
        if (ERROR_SUCCESS != result)
        {
            if (DebugOutput)
            {
                Win32Printf(LogFile, "WriteKey %s\\%s[%s] failed: %d\r\n", 
                            rootname, key, value_name, result);
            }
            goto cleanup;
        }
        if ((flags & file_fa) && data != NULL &&
            (type == REG_SZ || type == REG_EXPAND_SZ))
        {
          result = PickUpThisFile( (TCHAR *)data, (TCHAR *)regfileDest );
          if (ERROR_SUCCESS != result)
          {
              if (DebugOutput)
              {
                  Win32Printf(LogFile, "PickUpThisFile %s failed: %d\r\n", 
                              data, result);
              }
              goto cleanup;
          }
        }
        wrote_value = TRUE;
      }
    } while (result == ERROR_SUCCESS);
    result = ERROR_SUCCESS;
  }

  // If sub keys need to be written, write them.
  if (flags & recursive_fa)
  {
    i = 0;
    do
    {
      // Look up the next key.
      leaf_name_len = max_leaf_name_len;
      result = RegEnumKeyExA( hkey, i, leaf_name, &leaf_name_len, NULL, NULL,
                              NULL, NULL );
      if (result == ERROR_SUCCESS)
      {
        i+= 1;
        wrote_value = TRUE;

        result = RegWriteToInf( rootname, full_name, value, flags, regfileDest );
        if (result != ERROR_SUCCESS)
        {
          if (Verbose)
          {
              Win32Printf(LogFile, "RegWriteToInf %s\\%s[%s] failed: %d\r\n", rootname, full_name, value, result);
          }
          nested_error = TRUE;
          goto cleanup;
        }
      }
    } while (result == ERROR_SUCCESS);
    result = ERROR_SUCCESS;
  }

  // If nothing was written, write an entry for this key.
  // But don't write the default if we wanted a specific value
  if (FALSE == wrote_value && NULL == value)
  {
    result = Win32Printf( OutputFile, "%s, \"%s\",\r\n", rootname, key );
    if (ERROR_SUCCESS != result)
    {
        if (DebugOutput)
        {
            Win32Printf(LogFile, "Win32Printf %s, %s failed: %d\r\n", rootname, key, result);
        }
        goto cleanup;
    }
  }

cleanup:
  if (data != NULL)
    free( data );
  if (hkey != NULL)
    RegCloseKey( hkey );
  if (full_name != NULL)
    free( full_name );
  if (value_name != NULL)
    free( value_name );

  // Skip secured keys after printing a warning.
  if (result == ERROR_ACCESS_DENIED)
  {
    Win32PrintfResource( LogFile, IDS_REG_ACCESS, rootname, key,
                         value == NULL ? "" : value );
    result = ERROR_SUCCESS;
  }
  if (Verbose && result != ERROR_SUCCESS && !nested_error)
    printf( "RegWriteToInf failed for root %s, key %s, value %s with error 0x%x\r\n",
            rootname, key, value, result );
  return result;
}

//---------------------------------------------------------------
// Return the value of a string registry key.  Allocate the buffer
// holding the return value.  The caller must free the buffer.
// Leave enough space at the end of the buffer for the caller to
// append WINHIVENAME or NTHIVENAME.
DWORD AllocRegQueryString( HKEY key, char *valuename, char **value )
{
  DWORD result;
  DWORD len      = 0;
  DWORD type;
  char  *tmp     = NULL;
  char  *expand  = NULL;

  // Find out how long the value is.
  *value = NULL;
  RegQueryValueEx( key, valuename, NULL, NULL, NULL, &len );


  // Allocate a buffer with some extra space.
  tmp = (char *) malloc( len + max(sizeof(WINHIVENAME), sizeof(NTHIVENAME)) + 1 );
  if (tmp == NULL)
  {
    result = ERROR_NOT_ENOUGH_MEMORY;
    goto cleanup;
  }

  // Get the value.
  result = RegQueryValueEx( key, valuename, NULL, &type, (UCHAR *) tmp,
                            &len );
  if (result == ERROR_SUCCESS && type != REG_SZ && type != REG_EXPAND_SZ)
    result = ERROR_INVALID_PARAMETER;

  // Expand environment strings.
  if (result == ERROR_SUCCESS)
  {
    if (type == REG_EXPAND_SZ)
    {
      len = ExpandEnvironmentStrings( tmp, NULL, 0 );
      expand = (char *) malloc( len + max(sizeof(WINHIVENAME), sizeof(NTHIVENAME)) + 1 );
      if (expand == NULL)
      {
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
      }
      len = ExpandEnvironmentStrings( tmp, expand, len );
      if (len == 0)
      {
        result = GetLastError();
        goto cleanup;
      }
      *value = expand;
      expand = NULL;
    }
    else
    {
      *value = tmp;
      tmp = NULL;
    }
  }

cleanup:
  free( expand );
  free( tmp );
  return result;
}

//---------------------------------------------------------------
DWORD GetDomainUserName( char **domain, char **user )
{
  DWORD        info_size   = 0;
  HANDLE       token       = NULL;
  DWORD        domain_len  = 0;
  DWORD        user_len    = 0;
  SID_NAME_USE ignore;
  BOOL         success;
  TOKEN_USER  *token_info  = NULL;
  DWORD        result      = ERROR_SUCCESS;
  HKEY         key         = NULL;

  // Open the registry key for the current user.
  result = RegOpenKeyEx( HKEY_CURRENT_USER, NULL, 0, KEY_READ, &CurrentUser );
  LOG_ASSERT( result );

  if (Win9x)
  {
    // Get the user name.
    user_len   = 0;
    GetUserName( NULL, &user_len );
    *user = (char *) malloc( user_len );
    LOG_ASSERT_EXPR( *user != NULL, IDS_NOT_ENOUGH_MEMORY, result,
                     ERROR_NOT_ENOUGH_MEMORY );
    success = GetUserName( *user, &user_len );
    LOG_ASSERT_GLE( success, result );

    // Return success regardless of whether or not the domain name is
    // available.
    result = RegOpenKeyExA( HKEY_LOCAL_MACHINE,
      "System\\CurrentControlSet\\Services\\MSNP32\\NetworkProvider", 0,
      KEY_QUERY_VALUE, &key );
    if (result == ERROR_SUCCESS)
      result = AllocRegQueryString( key, "AuthenticatingAgent", domain );
  }
  else
  {
    // Open the process's token.
    success = OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &token );
    LOG_ASSERT_GLE( success, result );

    // Compute the size of the SID.
    GetTokenInformation( token, TokenUser, NULL, 0, &info_size );

    // Allocate memory for the SID.
    token_info = (TOKEN_USER *) malloc( info_size );
    LOG_ASSERT_EXPR( token_info != NULL, IDS_NOT_ENOUGH_MEMORY, result,
                     ERROR_NOT_ENOUGH_MEMORY );

    // Lookup SID of process token.
    success = GetTokenInformation( token, TokenUser, token_info, info_size,
                                   &info_size );
    LOG_ASSERT_GLE( success, result );

    // Compute the size of the domain and user names.
    LookupAccountSidA( NULL, token_info->User.Sid, NULL,
                      &user_len, NULL, &domain_len, &ignore );

    // Allocate memory for the domain and user names.
    *user   = (char *) malloc( user_len );
    *domain = (char *) malloc( domain_len );
    LOG_ASSERT_EXPR( *user != NULL && *domain != NULL, IDS_NOT_ENOUGH_MEMORY,
                     result, ERROR_NOT_ENOUGH_MEMORY );

    // Get the domain name for the process sid.
    success = LookupAccountSidA( NULL, token_info->User.Sid, *user,
                                 &user_len, *domain, &domain_len, &ignore );
    LOG_ASSERT_GLE( success, result );
  }

cleanup:
  if (token != NULL)
    CloseHandle( token );
  if (token_info != NULL)
    free( token_info );
  if (key != NULL)
    RegCloseKey( key );
  return result;
}

#if 0
// The following three functions locate the hive for a specified user.
// Since we don't handle a specified user for scanstate, the code is
// disabled.
//---------------------------------------------------------------
DWORD LoggedOnUser( char *domain, char *user, BOOL *logged_on )
{
  DWORD        info_size   = 0;
  HANDLE       token       = NULL;
  char        *ldomain     = NULL;
  char        *luser       = NULL;
  DWORD        domain_len  = 0;
  DWORD        user_len    = 0;
  SID_NAME_USE ignore;
  BOOL         success;
  TOKEN_USER  *token_info  = NULL;
  DWORD        result      = ERROR_SUCCESS;

  // Get the logged on user name.
  *logged_on = FALSE;
  user_len   = 0;
  GetUserName( NULL, &user_len );
  luser = (char *) malloc( user_len );
  LOG_ASSERT_EXPR( luser != NULL, IDS_NOT_ENOUGH_MEMORY, result,
                   ERROR_NOT_ENOUGH_MEMORY );
  success = GetUserName( luser, &user_len );
  LOG_ASSERT_GLE( success, result );

  // Compare the user names.
  *logged_on = _stricmp( user, luser ) == 0;

  // We are done if the user names don't match, if there is no domain name,
  // or if we are running Win9x.
  if (!*logged_on || domain == NULL || Win9x)
    goto cleanup;

  // Open the process's token.
  success = OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &token );
  LOG_ASSERT_GLE( success, result );

  // Compute the size of the SID.
  GetTokenInformation( token, TokenUser, NULL, 0, &info_size );

  // Allocate memory for the SID.
  token_info = (TOKEN_USER *) malloc( info_size );
  LOG_ASSERT_EXPR( token_info != NULL, IDS_NOT_ENOUGH_MEMORY, result,
                   ERROR_NOT_ENOUGH_MEMORY );

  // Lookup SID of process token.
  success = GetTokenInformation( token, TokenUser, token_info, info_size,
                                 &info_size );
  LOG_ASSERT_GLE( success, result );

  // Compute the size of the domain and user names.
  LookupAccountSidA( NULL, token_info->User.Sid, NULL,
                    &user_len, NULL, &domain_len, &ignore );

  // Allocate memory for the domain and user names.
  free( luser );
  luser   = (char *) malloc( user_len );
  ldomain = (char *) malloc( domain_len );
  LOG_ASSERT_EXPR( luser != NULL && ldomain != NULL, IDS_NOT_ENOUGH_MEMORY,
                   result, ERROR_NOT_ENOUGH_MEMORY );

  // Get the domain name for the process sid.
  success = LookupAccountSidA( NULL, token_info->User.Sid, luser,
                               &user_len, ldomain, &domain_len, &ignore );
  LOG_ASSERT_GLE( success, result );

  // Compare the domain names.
  *logged_on = _stricmp( domain, ldomain ) == 0;

cleanup:
  if (token != NULL)
    CloseHandle( token );
  if (token_info != NULL)
    free( token_info );
  if (luser != NULL)
    free( luser );
  if (ldomain != NULL)
    free( ldomain );
  return result;
}

//---------------------------------------------------------------
// Lookup either the sid or domain name for the specified user.
// The caller may optionally specify the user's domain.
//
// Notes:
//     This function does not log errors.
DWORD LookupAccount( char **domain, char *user, char **sid )
{
  DWORD           result         = ERROR_SUCCESS;
  HKEY            key;
  char           *fullname       = NULL;
  BOOL            free_fullname  = FALSE;
  SID_NAME_USE    ignore;
  BOOL            success;
  DWORD           domain_len;
  DWORD           sid_len;
  char           *tmp            = NULL;
  SID            *sid_struct     = NULL;
  UNICODE_STRING  rtl_ustring;

  // For win9x, lookup the domain name from the registry.
  if (Win9x)
  {
    // There is no sid on win9x.
    if (sid != NULL)
      return ERROR_INVALID_PARAMETER;
    if (*domain != NULL)
      return ERROR_SUCCESS;

    // Return success regardless of whether or not the domain name is
    // available.
    result = RegOpenKeyExA( HKEY_LOCAL_MACHINE,
      "System\\CurrentControlSet\\Services\\MSNP32\\NetworkProvider", 0,
      KEY_QUERY_VALUE, &key );
    if (result == ERROR_SUCCESS)
    {
      result = AllocRegQueryString( key, "AuthenticatingAgent", domain );
      RegCloseKey( key );
    }
    return ERROR_SUCCESS;
  }

  // For NT, lookup the domainname and sid.
  else
  {
    // Do nothing if the caller doesn't want anything.
    if (sid == NULL && *domain != NULL)
      return ERROR_SUCCESS;

    // Initialize the RTL string.
    GRtlInitUnicodeString( &rtl_ustring, NULL );

    // Combine the domain name and user name.
    if (*domain != NULL)
    {
      domain_len = strlen( *domain ) + strlen( user ) + 2;
      fullname = (char *) malloc( domain_len );
      if (fullname == NULL)
      {
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
      }
      free_fullname = TRUE;
      strcpy( fullname, *domain );
      strcat( fullname, "\\" );
      strcat( fullname, user );
    }
    else
    {
      free_fullname = FALSE;
      fullname = user;
    }

    // Compute how much memory to allocate for the domainname and sid
    // structure.
    sid_len    = 0;
    domain_len = 0;
    LookupAccountNameA( NULL, fullname, NULL, &sid_len, NULL,
                        &domain_len, &ignore );

    // Allocate memory.
    sid_struct = (SID *) malloc( sid_len );
    tmp        = (char *) malloc( domain_len );
    if (sid_struct == NULL || tmp == NULL)
    {
      result = ERROR_NOT_ENOUGH_MEMORY;
      goto cleanup;
    }

    // Get the domain name and sid.
    success = LookupAccountNameA( NULL, fullname, sid_struct, &sid_len,
                                  tmp, &domain_len, &ignore );
    if (!success)
    {
      result = GetLastError();
      goto cleanup;
    }

    // If the caller wants the sid, convert it to a string.
    if (sid != NULL)
    {
      // Convert user SID to a RTL unicode string.
      result = GRtlConvertSidToUnicodeString( &rtl_ustring, sid_struct, TRUE );
      FAIL_ON_ERROR( result );

      // Convert the string to ascii.
      sid_len = WideCharToMultiByte( CP_ACP, 0, rtl_ustring.Buffer, -1,
                                     NULL, 0, NULL, NULL );
      *sid = (char *) malloc( sid_len );
      if (*sid == NULL)
      {
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
      }
      sid_len = WideCharToMultiByte( CP_ACP, 0, rtl_ustring.Buffer, -1,
                                     *sid, sid_len, NULL, NULL );
      if (sid_len == 0)
      {
        result = GetLastError();
        goto cleanup;
      }
    }

    // If the caller wants the domain, return it.
    if (*domain == NULL)
    {
      *domain = tmp;
      tmp     = NULL;
    }
  }

cleanup:
  if (free_fullname)
    free( fullname );
  if (!Win9x)
    GRtlFreeUnicodeString( &rtl_ustring );
  free( sid_struct );
  free( tmp );
  return result;
}

/***************************************************************************

        ReadUser

     This function determines the username and domainname of the user whose
hive is being migrated.  It also sets the global CurrentUser to point to
that hive.  The name of the user is read from the [Users] section of the
input inf.  If that section is empty, the current user is used.

     On NT the following key contains the path to the user profile.

HKLM\Software\Microsoft\Windows NT\CurrentVersion\ProfileList\SID\ProfileImagePath

     On Win9x, profiles exist if the UserProfiles value is set to 1.  If
it is not set, only the profile for the logged in username can be moved.
If it is set, the username can be looked up in the ProfileList.  The domain
name of the last user to log in can be found under AuthenticatingAgent.

HKLM\Network\Logon\UserProfiles
HKLM\Network\Logon\Username
HKLM\Software\Microsoft\Windows\CurrentVersion\ProfileList\username\ProfileImagePath
HKLM\System\CurrentControlSet\Services\MSNP32\NetworkProvider\AuthenticatingAgent

***************************************************************************/
DWORD ReadUser( char **user, char **domain )
{
  DWORD        result  = ERROR_SUCCESS;
  BOOL         success;
  INFCONTEXT   context;
  DWORD        len;
  char        *tmp;
  char        *sid;
  char        *hive         = NULL;
  HKEY         profile_list = NULL;
  HKEY         profile      = NULL;
  HKEY         key          = NULL;
  DWORD        user_profiles;
  BOOL         logged_on    = TRUE;

  // Enable privileges needed to load a hive.
  *user   = NULL;
  *domain = NULL;
  result = EnableBackupPrivilege();
  FAIL_ON_ERROR( result );

  // Unload the key this program uses to avoid problems.
  RegUnLoadKey( HKEY_USERS, BUILDKEY );

  // Look for a users section in the input inf.
  if (InputInf != INVALID_HANDLE_VALUE)
  {
    // This section should contain zero or one lines.
    success = SetupFindFirstLineA( InputInf, USERS_SECTION, NULL, &context );
    if (success)
    {
      // Get the correct length
      success = SetupGetStringField( &context, 1, NULL, 0, &len);
      if( success )
      {
        // Allocate a buffer to hold the domain\user name.
        *domain = (char *) malloc(len * sizeof(char));
        LOG_ASSERT_EXPR( *domain != NULL, IDS_NOT_ENOUGH_MEMORY, result,
                         ERROR_NOT_ENOUGH_MEMORY );
        
        // Since the previous SetupGetStringField call succeeded, we
        // expect this one to as well. If not, serious problem.
        success = SetupGetStringField( &context, 1, *domain, len, NULL );
        LOG_ASSERT_EXPR(success, IDS_GETSTRINGFIELD_ERROR, 
                        result, SPAPI_E_SECTION_NAME_TOO_LONG);
  
        // Determine if the string contains a domain name and user name or
        // just a user name.
        tmp = strchr( *domain, '\\' );
        if (tmp == NULL)
        {
          *user   = *domain;
          *domain = NULL;
        }
        else
        {
          *user = (char *) malloc( len );
          LOG_ASSERT_EXPR( *user != NULL, IDS_NOT_ENOUGH_MEMORY, result,
                           ERROR_NOT_ENOUGH_MEMORY );
          strcpy( *user, tmp+1 );
          tmp[0] = 0;
        }

        // Don't load the hive for the currently logged in user.
        result = LoggedOnUser( *domain, *user, &logged_on );
        FAIL_ON_ERROR( result );
        if (!logged_on)
        {
          // Compute hive path and domain name for NT.
          if (!Win9x)
          {
            // Lookup the SID for the user.
            result = LookupAccount( domain, *user, &sid );
            if (result != ERROR_SUCCESS && result != ERROR_NOT_ENOUGH_MEMORY)
            {
              if (*domain != NULL)
                Win32PrintfResource( LogFile, IDS_INVALID_DOMAIN_USER, *domain,
                                     *user );
              else
                Win32PrintfResource( LogFile, IDS_INVALID_USER, *user );
              result = ERROR_INVALID_PARAMETER;
              goto cleanup;
            }
            LOG_ASSERT( result );

            // Look up the profile for the SID.
            result = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                   "Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",
                                   0, KEY_READ, &profile_list );
            LOG_ASSERT( result );
            result = RegOpenKeyEx( profile_list, sid, 0, KEY_READ, &profile );
            if (result != ERROR_SUCCESS && result != ERROR_ACCESS_DENIED)
            {
              if (*domain != NULL)
                Win32PrintfResource( LogFile, IDS_INVALID_DOMAIN_USER, *domain,
                                     *user );
              else
                Win32PrintfResource( LogFile, IDS_INVALID_USER, *user );
              result = ERROR_INVALID_PARAMETER;
              goto cleanup;
            }
            LOG_ASSERT( result );

            // Get the path to the hive from the registry.
            result = AllocRegQueryString( profile, "ProfileImagePath", &hive );
            LOG_ASSERT( result );
            strcat( hive, NTHIVENAME );
          }

          // Compute the hive path and domain name for Win9x.
          else
          {
            // See if profiles are enabled.
            result = RegOpenKeyEx( HKEY_LOCAL_MACHINE, "Network\\Logon",
                                   0, KEY_READ, &key );
            LOG_ASSERT( result );
            len = sizeof( user_profiles );
            result = RegQueryValueEx( key, "UserProfiles", NULL, NULL,
                                      (UCHAR *) &user_profiles, &len );

            // If they are not, verify that the current user is the requested
            // user.
            if (result != ERROR_SUCCESS || user_profiles != 1)
            {
              result = AllocRegQueryString( key, "Username", &tmp );
              LOG_ASSERT( result );
              success = _stricmp( *user, tmp );
              free( tmp );
              if (!success)
              {
                if (*domain != NULL)
                  Win32PrintfResource( LogFile, IDS_INVALID_DOMAIN_USER, *domain,
                                       *user );
                else
                  Win32PrintfResource( LogFile, IDS_INVALID_USER, *user );
                result = ERROR_INVALID_PARAMETER;
                goto cleanup;
              }
            }

            // If they are, look up the profile for the user.
            else
            {
              // Open the profile list key.
              result = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                     "Software\\Microsoft\\Windows\\CurrentVersion\\ProfileList",
                                     0, KEY_READ, &profile_list );
              LOG_ASSERT( result );

              // Open the profile key.
              result = RegOpenKeyEx( profile_list, *user, 0, KEY_READ, &profile );
              if (result != ERROR_SUCCESS && result != ERROR_ACCESS_DENIED)
              {
                if (*domain != NULL)
                  Win32PrintfResource( LogFile, IDS_INVALID_DOMAIN_USER, *domain,
                                       *user );
                else
                  Win32PrintfResource( LogFile, IDS_INVALID_USER, *user );
                result = ERROR_INVALID_PARAMETER;
                goto cleanup;
              }
              LOG_ASSERT( result );

              // Get the path to the hive.
              result = AllocRegQueryString( profile, "ProfileImagePath", &hive );
              LOG_ASSERT( result );
              strcat( hive, WINHIVENAME );
            }
          }

          // Load the hive.
          if (hive != NULL)
          {
            result = RegLoadKey( HKEY_USERS, BUILDKEY, hive );
            LOG_ASSERT( result );

            // Open a key to the hive.
            result = RegOpenKeyEx( HKEY_USERS, BUILDKEY, 0, KEY_READ, &CurrentUser );
            LOG_ASSERT( result );
          }
        }
      }
    }

    // The section was empty, free the domain buffer.
    else
    {
      free( *domain );
      *domain = NULL;
    }
  }

  // If the user wasn't specified, find the current user.
  if (*user == NULL)
  {
    len = 0;
    GetUserName( NULL, &len );
    *user = (char *) malloc( len );
    LOG_ASSERT_EXPR( *user != NULL, IDS_NOT_ENOUGH_MEMORY, result,
                     ERROR_NOT_ENOUGH_MEMORY );
    success = GetUserName( *user, &len );
    LOG_ASSERT_GLE( success, result );
  }

  // If the domain still isn't known, look it up.
  if (*domain == NULL)
  {
    result = LookupAccount( domain, *user, NULL );
    LOG_ASSERT( result );
  }

  // Open the registry key for the current user.
  if (CurrentUser == NULL)
  {
    result = RegOpenKeyEx( HKEY_CURRENT_USER, NULL, 0, KEY_READ, &CurrentUser );
    LOG_ASSERT( result );
  }

cleanup:
  if (profile_list != NULL)
    RegCloseKey( profile_list );
  if (profile != NULL)
    RegCloseKey( profile );
  if (key != NULL)
    RegCloseKey( key );
  free( hive );
  if (result != ERROR_SUCCESS)
  {
    free( *user );
    free( *domain );
    *user   = NULL;
    *domain = NULL;
  }
  return result;
}
#endif
//---------------------------------------------------------------
// This function writes all the per user settings to the inf file.
//
DWORD ScanUser()
{
  DWORD        i;
  DWORD        result = ERROR_SUCCESS;
  char        *domain = NULL;
  char        *user   = NULL;
  HKEY         key;
  BOOL         success;
  DWORD        type;

  // Get the username and domainname to move.  Also sets CurrentUser.
  result = GetDomainUserName( &domain, &user );
  FAIL_ON_ERROR( result );

  // Dump user details only if /u or /f is specified
  if (!CopyUser && !CopyFiles)
    goto cleanup;

  // Write the users section.
  result = Win32Printf( OutputFile, "[%s]\r\n", USERS_SECTION );
  LOG_ASSERT( result );
  result = Win32Printf( OutputFile, "section=user1\r\n\r\n" );
  LOG_ASSERT( result );

  // Write the user1 section header.
  result = Win32Printf( OutputFile, "[user1]\r\n" );
  LOG_ASSERT( result );
  result = Win32Printf( OutputFile, "user=%s\r\n", user );
  LOG_ASSERT( result );

  // Write the domain name.
  if (domain != NULL)
  {
    result = Win32Printf( OutputFile, "domain=%s\r\n", domain );
    LOG_ASSERT( result );
  }

  // Write the section name.
  result = Win32Printf( OutputFile, "section=%s\r\n", SCAN_USER );
  LOG_ASSERT( result );

  // Leave a trailing blank line.
  result = Win32Printf( OutputFile, "\r\n" );
  LOG_ASSERT( result );

  // Copy User registry settings only if /u was specified
  if (!CopyUser)
    goto cleanup;

  // Write the section header.
  result = Win32Printf( OutputFile, "[%s]\r\n", SCAN_USER );
  LOG_ASSERT( result );

  // Write the current user hive to the INF file.
  result = RegWriteToInf( "HKR", NULL, NULL, recursive_fa, NULL );
  LOG_ASSERT( result );

  // Leave a trailing blank line.
  result = Win32Printf( OutputFile, "\r\n" );
  LOG_ASSERT( result );

cleanup:
  free( user );
  free( domain );
  if (Verbose)
    printf( "ScanUser is returning 0x%x\r\n", result );
  return result;
}

//---------------------------------------------------------------
DWORD WriteRule( HASH_NODE *rule )
{
  DWORD result;

  if (VerboseReg)
     LogReadRule( rule );

  // Write the original key.
  result = Win32Printf( OutputFile, "\"%s\\%s",
                        rule->ptsRoot, rule->ptsKey );
  LOG_ASSERT( result );
  if (rule->dwAction & recursive_fa)
  {
    result = Win32Printf( OutputFile, "\\*" );
    LOG_ASSERT( result );
  }
  if (rule->ptsValue != NULL)
    result = Win32Printf( OutputFile, " [%s]\" = ", rule->ptsValue );
  else
    result = Win32Printf( OutputFile, "\" = " );
  LOG_ASSERT( result );

  // Write the replacement key.
  if (rule->ptsNewKey != NULL || rule->ptsNewValue != NULL)
  {
    LOG_ASSERT( result );
    if (rule->ptsNewKey != NULL)
    {
      result = Win32Printf( OutputFile, "\"%s\\%s",
                            rule->ptsRoot, rule->ptsNewKey );
      LOG_ASSERT( result );
    }
    else
    {
      result = Win32Printf( OutputFile, "\"" );
    }

    if (rule->ptsNewValue != NULL)
      result = Win32Printf( OutputFile, "[%s]\"\r\n", rule->ptsNewValue );
    else
      result = Win32Printf( OutputFile, "\"\r\n" );
    LOG_ASSERT( result );
  }
  else
  {
    result = Win32Printf( OutputFile, "\r\n" );
    LOG_ASSERT( result );
  }

cleanup:
  return result;
}

//---------------------------------------------------------------
DWORD WriteSectionRules( HASH_NODE *rule_list )
{
  DWORD result = ERROR_SUCCESS;

  // Write each rule.
  while (rule_list != NULL)
  {
    result = WriteRule( rule_list );
    FAIL_ON_ERROR( result );
    rule_list = rule_list->phnNext;
  }

cleanup:
  return result;
}

//---------------------------------------------------------------
DWORD WriteSectionKeys( CStringList *list, HASH_NODE **rule_list, DWORD flags )
{
  CStringList *curr;
  DWORD        result = ERROR_SUCCESS;
  BOOL         success;
  DWORD        req_len;
  HASH_NODE   *rule;
  INFCONTEXT   context;

  // Process all the addreg sections.
  *rule_list = NULL;
  for (curr = list->Next(); curr != list; curr = curr->Next())
  {
    // Find the section.
    success = SetupFindFirstLineA( InputInf, curr->String(), NULL, &context );
    if (!success)
    {
      Win32PrintfResource( LogFile, IDS_SECTION_NAME_NOT_FOUND, curr->String() );
      result = GetLastError();
      goto cleanup;
    }

    // Process each line in the section.
    do
    {
      // Parse the line.
      result = ParseRule( &context, &rule );
      LOG_ASSERT( result );

      // Add the rule to the rule_list.
      if (*rule_list == NULL)
      {
        *rule_list = rule;
        rule->phnNext = NULL;
      }
      else
      {
        rule->phnNext = *rule_list;
        *rule_list = rule;
      }

      // Allow WriteRule to see that it's a file_fa rule for logging output
      rule->dwAction |= flags;

      // Dump the registry keys affected by the rule.
      result = RegWriteToInf( rule->ptsRoot, rule->ptsKey, rule->ptsValue,
                              rule->dwAction, rule->ptsFileDest );
      LOG_ASSERT( result );

      // Advance to the next line.
      success = SetupFindNextLine( &context, &context );

    } while( success);
  }

cleanup:
  return result;
}

//---------------------------------------------------------------
void FreeList( HASH_NODE *list )
{
  HASH_NODE *next;

  while (list != NULL)
  {
    next = list->phnNext;
    free( list->ptsRoot );
    free( list->ptsKey );
    free( list->ptsValue );
    free( list->ptsNewKey );
    free( list->ptsNewValue );
    free( list->ptsFileDest );
    free( list );
    list = next;
  }
}

//---------------------------------------------------------------
// This function reads the extension sections and processes them.
// All AddReg, RenReg, RegPath, and RegFile sections are read.
// All keys they reference are copied into migration.inf.
// All extension sections are copied into migration.inf.
//
// Notes:
//
DWORD ProcessExtensions()
{
  DWORD        result;
  char        *buffer;
  DWORD        len;
  BOOL         success;
  CStringList *add        = NULL;
  CStringList *ren        = NULL;
  CStringList *file       = NULL;
  CStringList *del        = NULL;
  HASH_NODE   *add_rules  = NULL;
  HASH_NODE   *ren_rules  = NULL;
  HASH_NODE   *file_rules = NULL;
  HASH_NODE   *rule;
  CStringList *curr;
  INFCONTEXT   context;

  // Find the section for extensions, if it is not present, do nothing.
  if (InputInf == INVALID_HANDLE_VALUE)
    return ERROR_SUCCESS;
  success = SetupFindFirstLineA( InputInf, EXTENSION_SECTION, NULL, &context );
  if (!success)
    return ERROR_SUCCESS;

  // Allocate the section name lists.
  add  = new CStringList( 0 );
  ren  = new CStringList( 0 );
  file = new CStringList( 0 );
  del  = new CStringList( 0 );
  if (add == NULL || ren == NULL || file == NULL || del == NULL)
  {
    result = ERROR_NOT_ENOUGH_MEMORY;
    LOG_ASSERT( result );
  }

  // Make lists of the names of sections of each type.
  do
  {
    // Parse the line.
    result = ParseSectionList( &context, &buffer, &curr );
    FAIL_ON_ERROR( result );

    // Save the value if its one of the ones we are looking for.
    if (buffer != NULL)
    {
      if (_stricmp( buffer, ADDREG_LABEL ) == 0)
        add->Add( curr );
      else if (_stricmp( buffer, RENREG_LABEL ) == 0)
        ren->Add( curr );
      else if (_stricmp( buffer, REGFILE_LABEL ) == 0)
        file->Add( curr );
      else if (_stricmp( buffer, DELREG_LABEL ) == 0)
        del->Add( curr );
      else if (!_stricmp( buffer, COPYFILES_LABEL ) &&
               !_stricmp( buffer, DELFILES_LABEL))
        LOG_ASSERT_EXPR( FALSE, IDS_INF_ERROR, result, SPAPI_E_GENERAL_SYNTAX );

      free( buffer );
    }

    // Advance to the next line.
    success = SetupFindNextLine( &context, &context );

  } while( success);

  // Write the extension state section name.
  result = Win32Printf( OutputFile, "[%s]\r\n", EXTENSION_STATE_SECTION );
  LOG_ASSERT( result );

  // Write the registry keys listed in all the sections.
  result = WriteSectionKeys( add, &add_rules, 0 );
  LOG_ASSERT( result );
  result = WriteSectionKeys( ren, &ren_rules, 0 );
  LOG_ASSERT( result );
  result = WriteSectionKeys( file, &file_rules, file_fa );
  LOG_ASSERT( result );

  // Write the extension add rule section name.
  result = Win32Printf( OutputFile, "\r\n\r\n[%s]\r\n", EXTENSION_ADDREG_SECTION );
  LOG_ASSERT( result );

  // Write all the add rules.
  result = WriteSectionRules( add_rules );
  LOG_ASSERT( result );

  // Write the extension ren rule section name.
  result = Win32Printf( OutputFile, "\r\n\r\n[%s]\r\n", EXTENSION_RENREG_SECTION );
  LOG_ASSERT( result );

  // Write all the ren rules.
  result = WriteSectionRules( ren_rules );
  LOG_ASSERT( result );

  // Write the extension file rule section name.
  result = Win32Printf( OutputFile, "\r\n\r\n[%s]\r\n", EXTENSION_REGFILE_SECTION );
  LOG_ASSERT( result );

  // Write all the file rules.
  result = WriteSectionRules( file_rules );
  LOG_ASSERT( result );

  // Write the extension delete rule section name.
  result = Win32Printf( OutputFile, "\r\n\r\n[%s]\r\n", EXTENSION_DELREG_SECTION );
  LOG_ASSERT( result );

  // Find and print all the delete rules.
  for (curr = del->Next(); curr != del; curr = curr->Next())
  {
    // Find the section.
    success = SetupFindFirstLineA( InputInf, curr->String(), NULL, &context );

    // Process each line in the section.
    while (success)
    {
      // Parse the line.
      result = ParseRule( &context, &rule );
      LOG_ASSERT( result );

      // Print the rule.
      result = WriteRule( rule );
      FAIL_ON_ERROR( result );
      free( rule->ptsRoot );
      free( rule->ptsKey );
      free( rule->ptsValue );
      free( rule->ptsNewKey );
      free( rule->ptsNewValue );
      free( rule->ptsFileDest );
      free( rule );

      // Advance to the next line.
      success = SetupFindNextLine( &context, &context );
    }
  }

  // Leave a trailing blank line.
  result = Win32Printf( OutputFile, "\r\n\r\n" );
  LOG_ASSERT( result );

cleanup:
  if (add != NULL)
    delete add;
  if (ren != NULL)
    delete ren;
  if (file != NULL)
    delete file;
  if (del != NULL)
    delete del;
  if (add_rules != NULL)
    FreeList( add_rules );
  if (ren_rules != NULL)
    FreeList( ren_rules );
  if (file_rules != NULL)
    FreeList( file_rules );
  return result;
}


//*****************************************************************
//
//  Synopsis:       Run an executable in a child process.
//
//  History:        11/8/1999   Created by WeiruC.
//
//  Return Value:   Win32 error code.
//
//*****************************************************************

DWORD RunCommandInChildProcess(CStringList*  command)
{
    SECURITY_ATTRIBUTES     sa;                 // allow handles to be inherited
    HANDLE                  hSavedStdout;       // temp storage for stdout
    DWORD                   rv = ERROR_SUCCESS; // return value
    HANDLE                  hWritePipe = INVALID_HANDLE_VALUE;
    HANDLE                  hReadPipe = INVALID_HANDLE_VALUE;
    HANDLE                  hReadPipeDup = INVALID_HANDLE_VALUE;
    STARTUPINFO             si;
    PROCESS_INFORMATION     pi;
    TCHAR*                  buffer = NULL;      // output from the command
    TCHAR*                  cur, *cur1, *cur2;  // cur pointers on the buffer
    TCHAR                   tmpCharHolder;
    TCHAR*                  tmpBuffer;
    TCHAR                   fileName[MAX_PATH + 1];
    TCHAR*                  commandLine = NULL; // command line
    DWORD                   commandLineLen = 0; // command line length
    DWORD                   cRead;              // # of bytes read
    DWORD                   cReadTotal = 0;     // total # of bytes read
    DWORD                   bufferSize = 10240; // ReadFile buffer size counter
    CStringList*            tmp;

    //
    // We want to read from the child process's stdout. A trick is used here
    // to redirect the child process's stdout to a pipe from which we can
    // read its output. This is done by redirect this process's stdout to a
    // pipe. And then let the child process inherit the redirected stdout
    // from this process.
    //

    //
    // Set bInheritHandle flag to TRUE so that piple handles are inherited.
    //

    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = TRUE;

    //
    // Save current stdout to be restored later.
    //

    hSavedStdout = GetStdHandle(STD_OUTPUT_HANDLE);
    if(hSavedStdout == INVALID_HANDLE_VALUE)
    {
        rv = GetLastError();
        goto cleanup;
    }

    //
    // Create a pipe, one end of it is for the child process's stdout.
    //

    if(!CreatePipe(&hReadPipe, &hWritePipe, &sa, 0))
    {
        rv = GetLastError();
        goto cleanup;
    }

    //
    // Set the write end of the pipe to be stdout. This will be inherited by
    // the child process.
    //

    if(!SetStdHandle(STD_OUTPUT_HANDLE, hWritePipe))
    {
        rv = GetLastError();
        goto cleanup;
    }

    //
    // We don't want the child process to inherit the read handle. So
    // duplicate it, make it non-inheritable and close out the inheritable
    // one.
    //

    if(!DuplicateHandle(GetCurrentProcess(),
                        hReadPipe,
                        GetCurrentProcess(),
                        &hReadPipeDup,
                        0,
                        FALSE,          // set handle to be non-inheritable
                        DUPLICATE_SAME_ACCESS))
    {
        rv = GetLastError();
        goto cleanup;
    }
    CloseHandle(hReadPipe);
    hReadPipe = INVALID_HANDLE_VALUE;

    //
    // Create the child process.
    //

    ZeroMemory(&si, sizeof(STARTUPINFO));
    si.cb = sizeof(STARTUPINFO);

    //
    // Initialize the command line. We can either do two loops to count how big
    // a string we need for the command line, or do one loops and just set a
    // max limit on how long the command line is allowed. We probably won't
    // have that many commands or arguments anyway.
    //

    commandLineLen += _tcslen(command->String()) + 3;   // '"' + '"' + ' '
    for(tmp = command->Next(); tmp != command; tmp = tmp->Next())
    {
        commandLineLen += _tcslen(tmp->String()) + 3;   // '"' + '"' + ' '
    }
    commandLine = new TCHAR[commandLineLen + 1];
    commandLine[0] = TEXT('\0');
    MakeCommandLine(command, command->Next(), commandLine);

    if(!CreateProcess(NULL,
                      commandLine,
                      NULL,
                      NULL,
                      TRUE,
                      0,
                      NULL,
                      NULL,
                      &si,
                      &pi))
    {
        rv = GetLastError();
        goto cleanup;
    }

    //
    // Restore stdout.
    //

    if(!SetStdHandle(STD_OUTPUT_HANDLE, hSavedStdout))
    {
        rv = GetLastError();
        goto cleanup;
    }

    //
    // Close the write end of the pipe before read from the child process's
    // stdout. Check the error code here because if we failed to close the
    // handle ReadFile from the child process's stdout will hang because
    // this is the same handle.
    //

    if(!CloseHandle(hWritePipe))
    {
        rv = GetLastError();
        goto cleanup;
    }
    hWritePipe = INVALID_HANDLE_VALUE;

    //
    // Read from the child process the list of files. File names are
    // separated by comma. No white space allowed between file names. If the
    // buffer is not big enough, grow it.
    //

    buffer = new TCHAR[bufferSize];
    cur = buffer;
    do
    {
        if(!ReadFile(hReadPipeDup,
                     cur,
                     bufferSize - cReadTotal,
                     &cRead,
                     NULL)
           ||
           cRead == 0)
        {
            break;
        }

        cReadTotal += cRead;
        cRead = 0;

        //
        // If the buffer is full, grow it by doubling it.
        //

        if(cReadTotal == bufferSize)
        {
            tmpBuffer = buffer;
            buffer = new TCHAR[bufferSize *= 2];
            CopyMemory(buffer, tmpBuffer, cReadTotal);
            delete []tmpBuffer;
        }

        //
        // Set the current pointer to the right position in the buffer.
        //

        cur = buffer + cReadTotal;
    }
    while(TRUE);

    //
    // No output from the child process.
    //

    if(cReadTotal == 0)
    {
        goto cleanup;
    }

    //
    // Terminate the string.
    //

    buffer[cReadTotal] = TEXT('\0');

    //
    // Pick up all the files in the list.
    //

    cur1 = buffer;
    cur2 = buffer;
    do
    {
        while(*cur2 != TEXT(',') && *cur2 != TEXT('"') && *cur2 != TEXT('\0'))
        {
            cur2++;
        }

        switch(*cur2)
        {
            case TEXT(','):

                if(cur1 == cur2)
                {
                    rv = ERROR_INVALID_FUNCTION;
                    goto cleanup;
                }

                tmpCharHolder = *cur2;
                *cur2 = TEXT('\0');

                break;

            case TEXT('"'):

                cur2++;
                cur2 = _tcschr(cur2, TEXT('"'));
                if(cur1 == cur2)
                {
                    rv = ERROR_INVALID_FUNCTION;
                    goto cleanup;
                }

                cur2++;
                if(*cur2 != TEXT(',') && *cur2 != TEXT('\0'))
                {
                    rv = ERROR_INVALID_FUNCTION;
                    goto cleanup;
                }

                tmpCharHolder = *cur2;
                *cur2 = TEXT('\0');

                break;

            case TEXT('\0'):

                tmpCharHolder = *cur2;

                break;

            default:

                rv = ERROR_INVALID_FUNCTION;
                goto cleanup;
        }

        //
        // Call Phil's code to pick up this file. Ignore error.
        //

        PickUpThisFile(cur1, NULL);

        //
        // Restore *cur2.
        //

        *cur2 = tmpCharHolder;

        if(*cur2 == TEXT('\0'))
        {
            break;
        }

        //
        // Advance to the next file name.
        //

        cur2++;
        cur1 = cur2;
    }
    while(TRUE);

    rv = Win32Printf(OutputFile, "%s\r\n", buffer);
    FAIL_ON_ERROR(rv);

cleanup:

    if(hReadPipe != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hReadPipe);
    }

    if(hWritePipe != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hWritePipe);
    }

    if(hReadPipeDup != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hReadPipeDup);
    }

    if(buffer != NULL)
    {
        delete []buffer;
    }

    if(commandLine != NULL)
    {
        delete []commandLine;
    }

    return rv;
}


//*****************************************************************
//
//  Synopsis:       Process the [Run These Commands] extension section in an inf
//                  file. User's executable can output a list of files with each
//                  file name separated by comma.
//
//  History:        11/3/1999   Created by WeiruC.
//
//  Return Value:   Win32 error code.
//
//*****************************************************************

DWORD ProcessExecExtensions()
{
    DWORD           rv = ERROR_SUCCESS;     // return value
    BOOL            success = TRUE;         // value returned by setup functions
    INFCONTEXT      context;                // used by setup inf functions
    char*           label = NULL;           // label in inf file
    CStringList*    command = NULL;         // command

    if(InputInf == INVALID_HANDLE_VALUE)
    {
        return ERROR_SUCCESS;
    }

    //
    // Find the section in the inf file. If it doesn't exist, do nothing and
    // return ERROR_SUCCESS.
    //

    if(!SetupFindFirstLineA(InputInf, EXECUTABLE_EXT_SECTION, NULL, &context))
    {
        return ERROR_SUCCESS;
    }

    //
    // Write the extension section head in migration.inf
    //

    rv = Win32Printf(OutputFile, "[%s]\r\n", EXECUTABLE_EXTOUT_SECTION);
    LOG_ASSERT(rv);

    //
    // Process each line in the section: run the command, write results to
    // migration.inf.
    //

    do
    {
        //
        // Parse the line.
        //

        rv = ParseSectionList(&context, &label, &command);
        FAIL_ON_ERROR(rv);

        if((command->String())[0] != TEXT('\0'))
        {
            //
            // Write the label to migration.inf.
            //

            rv = Win32Printf(OutputFile, "%s = ", label);
            FAIL_ON_ERROR(rv);

            //
            // Create a child process to run the command. Ignore error and
            // continue to run the next command.
            //

            RunCommandInChildProcess(command);
        }

        //
        // Clean up and reinitialize.
        //

        if(label)
        {
            free(label);
            label = NULL;
        }
        if(command)
        {
            delete command;
            command = NULL;
        }
    }
    while(SetupFindNextLine(&context, &context));

cleanup:

    if(label)
    {
        free(label);
    }
    if(command)
    {
        delete command;
    }

    return rv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\BasicOZ\BasicConfig.h ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//


//
// Conversions
//
#define K               * 1024
#define M               K K

//
// Configuration information
//
#define NCPUS           1
#define MAXPAGEFRAMES   (256 M / NTSPACE_PAGESIZE)
#define MAXPROCESSES    256
#define MAXMAPPINGS     (MAXPROCESSES * 8)
#define MAXTHREADS      (MAXPROCESSES * 4)
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\BasicOZ\BasicOZ.h ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include "BasicTypes.h"
#include "BasicConfig.h"
#include "DeviceDefs.h"
#include "SpaceOps.h"

//
// Configuration information
//
#define NCPUS           1
#define MAXPAGEFRAMES   (256 M / NTSPACE_PAGESIZE)
#define MAXPROCESSES    256
#define MAXMAPPINGS     (MAXPROCESSES * 8)
#define MAXTHREADS      (MAXPROCESSES * 4)

//
// Error stuff
//
int bugcheck(char *errstr);
#define BUGCHECK(CONSTMSG) bugcheck("SPACE bugcheck in " __FUNCTION__ " (" __FILE__ "):  " CONSTMSG)

//
// misc
//

void zero(void *ptr, ulong nbytes);
boolean capture     (void *kptr, void *uptr, ulong nbytes);
boolean szcapture   (char *kptr, char *uptr, ulong nbytes);

//
// Process/thread definitions
//

ulong CurrentUserCtx;
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\BasicOZ\BasicOZServices.inc ===
;;
;; Copyright (c) Microsoft Corporation. All rights reserved. 
;; 
;; You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
;; If you do not agree to the terms, do not use the code.
;;

; included in Machine.asm

; external declarations of C routines
    EXTERN C foo:PROC
;   EXTERN C ConsolePrint:PROC
;   EXTERN C ConsoleGetline:PROC

; public declarations of asm dispatch routines
    PUBLIC C dispatch_foo
;   PUBLIC C dispatch_ConsolePrint
;   PUBLIC C dispatch_ConsoleGetline

; define dynamic stubs for server side
    DynamicInvoke   foo
;   DynamicInvoke   ConsolePrint
;   DynamicInvoke   ConsoleGetline

; define stubs for client side
    SystemCall      foo,                BASICSERV_foo
;   SystemCall      ConsolePrint,       BASICSERV_ConsolePrint
;   SystemCall      ConsoleGetline,     BASICSERV_ConsoleGetline
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\BasicOZ\Config.inc ===
;;
;; Copyright (c) Microsoft Corporation. All rights reserved. 
;; 
;; You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
;; If you do not agree to the terms, do not use the code.
;;

    MAXDYNAMICSTACKS                    equ     1024            ;; must fit in 12 bits (i.e. <= 4094)

    BASEVECTOR                          equ     071001000H
    EMULATIONVECTOR                     equ     (BASEVECTOR +  0)
    SERVICEVECTOR                       equ     (BASEVECTOR +  4)
    LIBRARYVECTOR                       equ     (BASEVECTOR +  8)

    NOSTACKS_PARAM_EMPTYLIST            equ     0
    NOSTACKS_PARAM_STACKCORRUPT         equ     1
    NOSTACKS_PARAM_LISTNOLONGEREMPTY    equ     2

;; one guard page, one stack page - 64KB each
    DYNSTACK_ALLOCSIZE                  equ     (64*1024)       ;; NTSPACE_PAGESIZE
    DYNSTACK_BASEMASK                   equ     (DYNSTACK_ALLOCSIZE-1)
    DYNSTACK_INDEXMASK                  equ     0fffH
    DYNSTACK_EMPTYINDEX                 equ     DYNSTACK_INDEXMASK

    DYNSTACK_SEQUENCEMASK               equ     0fffff000H
    DYNSTACK_SEQUENCEINCR               equ     000001000H
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\BasicOZ\Boot.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include "BasicOZ.h"

void
boot()
{
}

void consolePrint(ushort msg[]);

extern dispatch_foo();
ulong
foo()
{
    consolePrint(L"In foo - now returning\n");
    return 0xfeed;
}


ulong physbasepage;
ulong nphysmempages;

ushort *
tohex(
        ushort *buffer,
        ulong   value
    )
{
    int     i;

    for (i = 0;  i < 8;  i++)
        buffer[i] = L"0123456789ABCDEF"[(value>>(28-4*i)) & 0xf];
    buffer[8] = L'\0';
    return buffer;
}

// Send
// Receive

ushort consolebuffer[512] = L"Hello Outer SPACE!\n";
ulong  mappedconsolebuffer;
ulong  maxoutputchars = sizeof(consolebuffer) / sizeof(consolebuffer[0]) - 1;
ulong  maxinputchars  = sizeof(consolebuffer) / sizeof(consolebuffer[0]) - 1;

ulong
mapconsolebuffer()
{
    ulong page0, page1;

    // XXX: reserving iopage 0/1 for our consolebuffer
    // XXX: assuming we know the mapping of the kernel pages -- which we really need to (somehow) get when we are booted
    // XXX: maybe by accessing our own image??
    // XXX: for now we happen to know that:  60010000 is physical page 0
    page0 = ADDR2PAGE((ulong)consolebuffer - 0x60010000);
    page1 = ADDR2PAGE((ulong)consolebuffer - 0x60010000 + sizeof(consolebuffer));

    SPACE_MapIO(CONSOLEDEVICE_ID, 1, 0, page0);
    if (page1 != page0)
        SPACE_MapIO(CONSOLEDEVICE_ID, 1, 1, page1);

    return 0 + ((NTSPACE_PAGESIZE-1) & (ulong)consolebuffer);   // logical map is iospace 0, so just add offset of consolebuffer
}

void
consolePrint(ushort msg[])
{
    ulong  n = 0;

    if (mappedconsolebuffer == 0)
            mappedconsolebuffer = mapconsolebuffer();

    n = 0;
    while (msg[n] && n < maxoutputchars) consolebuffer[n] = msg[n], n++;
    consolebuffer[n] = L'0';

    (void) SPACE_AccessDevice(CONSOLEDEVICE_ID, CONSOLEOP_PRINT, CONSOLEDEVICE_IORegister, mappedconsolebuffer, n);
}

void
consolePrintX(ulong x)
{
    ushort buffer[9];
    consolePrint(tohex(buffer, x));
}

ushort *
consoleGetline()
{
    if (mappedconsolebuffer == 0)
            mappedconsolebuffer = mapconsolebuffer();
    (void) SPACE_AccessDevice(CONSOLEDEVICE_ID, CONSOLEOP_GETLINE, CONSOLEDEVICE_IORegister, mappedconsolebuffer, maxinputchars);

    return consolebuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\BasicOZ\Image.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include "BasicOZ.h"
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\BasicOZ\IO.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include "BasicOZ.h"
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\BasicOZ\Process.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include "BasicOZ.h"
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\BasicOZ\Namespace.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include "BasicOZ.h"
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\BasicOZ\Runtime.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include "BasicOZ.h"
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\BasicOZ\Scalars.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include "BasicOZ.h"
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\BasicOZ\IPC.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include "BasicOZ.h"
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\BasicOZ\Thread.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include "BasicOZ.h"
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\BasicOZ\VirtualMemory.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include "BasicOZ.h"
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\BasicOZ\Object.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include "BasicOZ.h"
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\BasicOZ\Syscalls.inc ===
;;
;; Copyright (c) Microsoft Corporation. All rights reserved. 
;; 
;; You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
;; If you do not agree to the terms, do not use the code.
;;

    BASICSERV_NOSTACK_BUGCHECK                  equ      99     ; no stack
    BASICSERV_NOSTACK_SLEEP                     equ       0     ; no stack
    BASICSERV_NOSTACK_WAKEUP                    equ       1     ; no stack

    BASICSERV_foo                               equ      13

    BASICSERV_ConsolePrint                      equ      80
    BASICSERV_ConsoleGetline                    equ      81
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\BasicOZ\SPACEOps.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include "BasicOZ.h"

//
// HW Emulation calls
//
typedef ulong64 EMULscalar0  ();                            // common scalar cases
typedef ulong64 EMULscalar1  (ulong   arg0);
typedef ulong64 EMULscalar1x (ulong64 arg0);
typedef ulong64 EMULscalar2  (ulong   arg0,  ulong arg1);
typedef ulong64 EMULscalar5  (ulong   arg0,  ulong arg1,   ulong arg2,   ulong arg3,   ulong arg4);

typedef ulong   EMULvector   (ulong *args);                 // vector case
typedef void    EMULbidir    (ulong *args);                 // up to 5 ulongs in, 5 ulongs out

typedef union {
    ulong64 all;
    ulong   part[2];
} Split64;

EMULscalar0     trapNoop;
void
SPACE_Noop()
{
    (void) trapNoop();
}

EMULvector     trapMapMemory;
void
SPACE_MapMemory(
        ulong ctx,
        ulong vpage,
        ulong ppage,
        ulong readmask,
        ulong writemask
    )
{
    XMapMemory u = { ctx, vpage, ppage, readmask, writemask };
    (void) trapMapMemory(u.args);
}

EMULscalar1    trapCleanCtx;
void
SPACE_CleanCtx(
        ulong ctx
    )
{
    (void) trapCleanCtx(ctx);
}

EMULvector     trapCreatePortal;
ulong
SPACE_CreatePortal(
        uchar type,
        uchar mode,
        uchar irql,
        // fill
        ulong ctx,
        ulong handler,
        ulong protmask
    )
{
    XCreatePortal u = { type, mode, irql, 0, ctx, handler, protmask };
    return trapCreatePortal(u.args);
}

EMULscalar1x   trapDestroyPortal;
void
SPACE_DestroyPortal(
        ulong portalid
    )
{
    (void) trapDestroyPortal(portalid);
}

EMULvector     trapMapTrap;
void
SPACE_MapTrap(
        ulong  ctx,
        uchar  traptype,
        uchar  global,
        // fill
        ulong  indexbase,
        ulong  indexlimit,
        ulong  portalid
    )
{
    XMapTrap u = { ctx, traptype, global, 0, indexbase, indexlimit, portalid };
    (void) trapMapTrap(u.args);
}

EMULscalar0    trapSuspend;
SPACETOKEN
SPACE_Suspend()
{
    return  trapSuspend();
}

EMULscalar1x   trapResume;
void
SPACE_Resume      (ulong64 result)
{
    (void) trapResume(result);
}

EMULscalar2    trapUnsuspend;
void
SPACE_Unsuspend(
        SPACETOKEN token
    )
{
    Split64 x;
    x.all  = token;
    (void) trapUnsuspend(x.part[1], x.part[0]);     // note order
}

EMULscalar2    trapDiscardToken;
void
SPACE_DiscardToken(
        SPACETOKEN token
    )
{
    Split64 x;
    x.all  = token;
    (void) trapDiscardToken(x.part[1], x.part[0]);     // note order
}

EMULscalar0    trapPopCaller;
void
SPACE_PopCaller()
{
    (void) trapPopCaller();
}

EMULvector     trapStartCPU;
void
SPACE_StartCPU(
        ulong boot_cpu,
        ulong boot_ctx,
        ulong boot_mode,
        ulong boot_pc,
        ulong boot_arg
    )
{
    XStartCPU u = { boot_cpu, boot_ctx, boot_mode, boot_pc, boot_arg };
    (void) trapStartCPU(u.args);
}

EMULscalar1    trapHaltCPU;
void
SPACE_HaltCPU(
       ulong reason
   )
{
    (void) trapHaltCPU(reason);
}

EMULvector     trapMapIO;
void
SPACE_MapIO(
        uchar deviceid,
        uchar writable,
        // fill
        ulong iospacepage,
        ulong physpage
    )
{
    XMapIO u = { deviceid, writable, 0, iospacepage, physpage };
    (void) trapMapIO(u.args);
}

EMULvector     trapAccessDevice;
ulong64
SPACE_AccessDevice(
        ushort deviceid,
        uchar op,
        uchar deviceregister,
        ulong value,
        ulong valuex
    )
{
    XAccessDevice u = { deviceid, op, deviceregister, value, valuex };
    return trapAccessDevice(u.args);
}

EMULvector     trapInterruptCPU;
void
SPACE_InterruptCPU(
        ushort targetcpu,
        uchar interrupt,
        uchar irql
    )
{
    XInterruptCPU u = { targetcpu, interrupt, irql };
    (void) trapInterruptCPU(u.args);
}

EMULvector     trapManageIRQL;
IRQLOps
SPACE_ManageIRQL(
        IRQLOps irqlop,
        uchar irql
        //fill
    )
{
    XManageIRQL u = { irqlop, irql, 0 };
    return (IRQLOps) trapManageIRQL(u.args);
}

EMULbidir      trapGetSPACEParams;
void
SPACE_GetSPACEParams(
        SPACEParams *p
    )
{
    trapGetSPACEParams((ulong *)p);
}

EMULvector     trapSPACEBreak;
void
SPACE_SPACEBreak(
        ulong   breakvalue,
        char   *breakmsg
    )
{
    XSPACEBreak u = { 0 };

    char *p       = breakmsg;
    char *q       = u.breakmsg;
    int n         = sizeof(u.breakmsg);

    u.breakvalue    = breakvalue;
    while (n-- > 0  &&  (*q++ = *p++))
        {}

    (void) trapSPACEBreak(u.args);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\INC\BasicTypes.h ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

typedef unsigned long      ulong;
typedef unsigned short     ushort;
typedef unsigned char      uchar;
typedef unsigned __int64   ulong64;
typedef int                boolean;
typedef void              *pvoid;

typedef enum {
    OZ_SUCCESS,
    OZ_FAILED
} OZStatus;

#define OZ_PAGESIZE (1 << NTSPACE_PAGEBITS)

//
// A few macros to simplify C
//

#define K               * 1024
#define M               K K

#define unless(x)       if (!(x))
#define until(x)        while (!(x))
#define asizeof(a)      (sizeof(a)/sizeof(a[0]))
#define xor(a,b)        (!(a) == !(b))

//
// A few standard macros
//
#define NULL  ((void *)0)
#define FALSE 0
#define TRUE  1
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\BasicOZ\DRIVERS\Console.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include "..\BasicOZ.h"

//
// Console driver
//
// The console 'hardware' consists of one register and two operations:
//      CONSOLEOP_PRINT   - writes a mapped UNICODE buffer to the console
//      CONSOLEOP_GETLINE - reads a NUL terminated line into a mapped UNICODE buffer, truncating if necessary
// To get a mapped buffer the physical addresses of the page(s) containing the buffer are mapped into IO space by MapIO.
// The device register is accessed by
//      (void) SPACE_AccessDevice(CONSOLEDEVICE_ID, CONSOLEOP_PRINT,   CONSOLEDEVICE_IORegister, mappedconsolebuffer, noutputchars);
// or
//      (void) SPACE_AccessDevice(CONSOLEDEVICE_ID, CONSOLEOP_GETLINE, CONSOLEDEVICE_IORegister, mappedconsolebuffer, maxinputchars) 
//
// The driver provides two system calls:
//      boolean ConsolePrint  (ushort *virtualbuffer, ulong noutputchars)
//      boolean ConsoleGetline(ushort *virtualbuffer, ulong maxinputchars)
// So all the driver needs to do is handle the mapping of the buffer into IO space for the current address space.
//
//

extern ulong mappedconsolebuffer;

boolean
ConsolePrint(
        ushort *virtualbuffer,
        ulong   noutputchars
    )
{
    ulong noutputbytes  = noutputchars * sizeof(ushort);

    (void) SPACE_AccessDevice(CONSOLEDEVICE_ID, CONSOLEOP_PRINT,   CONSOLEDEVICE_IORegister, mappedconsolebuffer, noutputchars);
    return TRUE;
}

boolean
ConsoleGetline(
        ushort *virtualbuffer,
        ulong   maxinputchars
    )
{
    ulong maxinputbytes  = maxinputchars * sizeof(ushort);

    (void) SPACE_AccessDevice(CONSOLEDEVICE_ID, CONSOLEOP_GETLINE,   CONSOLEDEVICE_IORegister, mappedconsolebuffer, maxinputchars);
    return TRUE;
}

//
// Version of ConsolePrint to print from kernel mode, as well as some print utility routines
//
void
debugprint(
        ushort *virtualbuffer,
        ulong   noutputchars
    )
{
    ulong noutputbytes  = noutputchars * sizeof(ushort);

    (void) SPACE_AccessDevice(CONSOLEDEVICE_ID, CONSOLEOP_PRINT,   CONSOLEDEVICE_IORegister, mappedconsolebuffer, noutputchars);
}

static
ushort *
tohex(
        ushort *buffer,
        ulong   value
    )
{
    int     i;

    for (i = 0;  i < 8;  i++)
        buffer[i] = L"0123456789ABCDEF"[(value>>(28-4*i)) & 0xf];
    buffer[8] = L'\0';
    return buffer;
}

void
debugprintx(ulong x)
{
    ushort buffer[9];
    debugprint(tohex(buffer, x), sizeof(buffer)-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\INC\BasicOZsyscalls.h ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

boolean
sys_ConsolePrint(
        ushort *virtualbuffer,
        ulong   noutputchars
    );

boolean
sys_ConsoleGetline(
        ushort *virtualbuffer,
        ulong   maxinputchars
    );

ulong
sys_foo();
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\BasicOZ\i386\Machine.asm ===
;;
;; Copyright (c) Microsoft Corporation. All rights reserved. 
;; 
;; You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
;; If you do not agree to the terms, do not use the code.
;;

TITLE   "BasicOZ machine-level code"

include ..\INC\TrapValues.inc
include Config.inc
include Syscalls.inc

.686
;;.model flat,c

;
; Machine-level code for BasicOZ
;
;;.data
_DATA   SEGMENT PAGE PUBLIC 'DATA'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING
        ORG     $ + 64*1024-4        ; aligned 4KB stack
        mainstacktop        DWORD   0

; variables containing bootstrap vectors
        PUBLIC C _pemulationvector
        PUBLIC C _pservicevector
        PUBLIC C _plibraryvector
        _pemulationvector   DWORD   0
        _pservicevector     DWORD   0
        _plibraryvector     DWORD   0

; variables for dynamic stack allocation
; stacks are linked by integers not pointers, so that a sizable sequence number can be used in 32-bit Compare&Swap operations
; the stacks themselves are pointed by at by pstackvector[], but the pstackvector[] entries are not updated except when
; an allocated stack is deleted
;
; the stacks are linked through an index stored at the beginning of each stack region
; stacks are size DYNSTACK_ALLOCSIZE

        _stackhead          DWORD   DYNSTACK_EMPTYINDEX ; sequence [20b] / index [12b] (empty)
        _dynamicstackhint   DWORD   0                   ; where to start searching for an available index
        _dynamicstackuninit DWORD   1                   ; no dynamic stacks have been allocated
        _pstackvector       DWORD   0
        ORG     $ + 4*(MAXDYNAMICSTACKS-2)
                            DWORD   0                   ; need to allocate something or space from ORG is released since at end of segment

_DATA   ENDS
        EXTERN  _boot:proc
;;.code
_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        SUBTTL "BasicOZ boot"
        PUBLIC C _basicoz
_basicoz:
        ; establish system pointers
        mov     eax,                EMULATIONVECTOR
        mov     eax,                [eax]
        mov     _pemulationvector,  eax

        mov     eax,                SERVICEVECTOR
        mov     eax,                [eax]
        mov     _pservicevector,    eax

        mov     eax,                LIBRARYVECTOR
        mov     eax,                [eax]
        mov     _plibraryvector,    eax

        ; setup the boot stack
        lea     esp,                mainstacktop
        mov     ebp,                esp

        xor     eax,eax

        call    _boot
@@:
        mov     eax,                _pemulationvector
        jmp     dword ptr [eax+4*TRAPEMUL_Resume]
        jmp     @B
        ;notreached

; Macro for dynamic allocation of a stack for this domain and then calling a C function
; If the pool of dynamic stacks is exhausted, we trap (will wait and then retry)
; N.B. This is only a macro so we can save a register, otherwise handler could be passed in to a routine.

DynamicInvoke macro  handler
    EXTERNDEF  C dispatch_&handler&:PROC
    EXTERNDEF  C &handler&:PROC
    ;; available registers:  eax, esp, ebp
    ;; parameter registers:  ebx, ecx, edx, edi, esi
    ;; set ebp, esp to stack when done, with parameters pushed onto stack
dispatch_&handler& LABEL PROC
    mov         eax,                _stackhead              ;; head sequence/index
    mov         ebp,                eax                     ;; temporarily stash [_stackhead]
    and         eax,                DYNSTACK_INDEXMASK      ;; extract index
    cmp         eax,                DYNSTACK_EMPTYINDEX
    jnz         @F
    ;; XXX: how do we get to our sleep parameters without clobbering the original parameter registers??
    lea         eax,                _stackhead              ;; &_stackhead is pattern for wakeup
    mov         esp,                _pservicevector         ;;
    jmp         dword ptr [esp+4*BASICSERV_NOSTACK_SLEEP]   ;;
    ;; XXX: how to we really get back here????????????????????????????????????????????????????????????????????????????????????????
    jmp         dispatch_&handler&                          ;; restart after trap returns
@@:
    ;; ebp is [_stackhead]
    ;; eax is head index isolated from ebp
    mov         esp,                _pstackvector[4*eax]    ;; base of the allocated stack, address of 'next' index
    mov         eax,                ebp
    and         eax,                DYNSTACK_SEQUENCEMASK   ;; extract sequence from head sequence/index
    add         eax,                DYNSTACK_SEQUENCEINCR   ;; increment sequence
    or          eax,                [esp]                   ;; insert index of next stack
    mov         esp,                eax
    mov         eax,                ebp                     ;; retrieve [_stackhead] into EAX for cmpxchg
    ;; ebp remembers the allocated sequence/index
    ;; esp is new head sequence/index
    ;; eax is old head sequence/index
    lock cmpxchg dword ptr _stackhead, esp                  ;; update the head if eax == [_stackhead]
    jne         dispatch_&handler&                          ;; if failed, restart at the top
    ;; esp now scratch
    ;; eax is old head sequence/index
    and         eax,                DYNSTACK_INDEXMASK      ;; extract index
    mov         esp,                _pstackvector[4*eax]
    add         esp,                DYNSTACK_ALLOCSIZE      ;; points just off the allocatedstack
    ;; remember our stack index on the stack
    and         ebp,                DYNSTACK_INDEXMASK
    push        ebp
    ;; push parameters
    push        esi
    push        edi
    push        edx
    push        ecx
    push        ebx
    ;; clear the registers (for debugging sanity)
    xor         eax,                eax
    mov         ebp,                eax
    mov         esi,                eax
    mov         edi,                eax
    mov         edx,                eax
    mov         ecx,                eax
    mov         ebx,                eax
    call        &handler&

    ; free the stack and RESUME
    jmp         trapResume
    endm

        EXTERNDEF C trapResume:Proc
trapResume LABEL PROC
    ; esp points into the allocated stack or is NULL if there was no stack
    ; eax/edx contain the return values -- so must preserve them
    ; all other registers are scratch
    mov         esi,                _pemulationvector
    or          esp,                esp                     ; if ESP is NULL just trap to emulated resume instruction
    jnz         @F
    jmp         dword ptr [esi+4*TRAPEMUL_Resume]
@@:
    ; get our stack index
    and         esp,                NOT DYNSTACK_BASEMASK
    mov         ebx,                (DYNSTACK_ALLOCSIZE-4)[esp]

    ; ASSERT: ebx < MAXDYNAMICSTACKS && _pstackvector[ebx] == esp
    mov         esi,                _pservicevector
    cmp         ebx,                MAXDYNAMICSTACKS
    jb          @F
    jmp         dword ptr [esi+4*BASICSERV_NOSTACK_BUGCHECK] ; with ESP at stack allocation, EBX stack index
@@:
    cmp         esp,                _pstackvector[4*ebx]
    je          @F
    jmp         dword ptr [esi+4*BASICSERV_NOSTACK_BUGCHECK] ; with ESP at stack allocation, EBX stack index
@@:

    ; esp points at the base of the stack allocation
    ; ebx is the stack index
    ; eax/edx are the return values
    mov         ebp,                eax                     ; stash eax, as we will need the register for cmpxchg
    mov         eax,                _stackhead              ; [_stackhead]
@@:
    mov         ecx,                eax  
    and         ecx,                DYNSTACK_INDEXMASK      ; extract head index
    mov         [esp],              ecx                     ; put old index into the next link in the stack we are freeing
    mov         ecx,                eax
    and         ecx,                DYNSTACK_SEQUENCEMASK   ; extract sequence
    add         ecx,                DYNSTACK_SEQUENCEINCR   ; increment sequence
    or          ecx,                ebx                     ; insert new index

    lock cmpxchg dword ptr _stackhead, ecx                  ; update the head to point at freed stack if eax == [_stackhead]
    jne         @B                                          ; if _stackhead changed since we read it, retry (eax has new _stackhead)

    ; if we freed the only stack and it isn't the first stack, let somebody wakeup and run on it now
    ; ebp/edx are the return values

    mov         esi,                _pservicevector
    and         eax,                DYNSTACK_INDEXMASK      ; extract previous head index
    cmp         eax,                DYNSTACK_EMPTYINDEX
    jne         @F
    lea         ecx,                _stackhead              ;; &_stackhead is pattern for wakeup (passed in ecx)
    mov         eax,                ebp                     ;; restore EAX value  (EDX value wasn't changed)
    jmp         dword ptr [esi+4*BASICSERV_NOSTACK_WAKEUP]  ;; must preserve EAX/EDX (the return values) and call Resume for us
@@:
    ; eax gets the return value
    ; callee must preserve edi, as it has our return value
    mov         eax,                ebp                     ;; restore EAX value  (EDX value wasn't changed)
    mov         esi,                _pemulationvector



    jmp         dword ptr [esi+4*TRAPEMUL_Resume]
    ;notreached

;
; routine to add a dynamic stacks
; argument is the base of a stack allocation of size DYNSTACK_ALLOCSIZE and must be aligned
; returns 1 if successful, or 0 if there already were MAXDYNAMICSTACKS
;
    EXTERNDEF C AddDynamicStack:Proc
AddDynamicStack LABEL PROC
    ; scratch registers:  eax ecx edx
    ; preserve registers: ebx esi edi (and ebp/esp of course)
    ; find empty location in pstackvector

    mov         ecx,                _dynamicstackhint       ; index hint
@@:
    ; search for index, starting at the hint
    ; (the stack indices may be sparse, if we start reclaiming stacks as we will likely pick whatever was at the front of the list)
    mov         eax,                _pstackvector[4*ecx]
    or          eax,                eax
    jz          @F                                          ; found first unused index
    inc         ecx
    cmp         ecx,                MAXDYNAMICSTACKS
    jl          @B

    ; return failure
    xor         eax,                eax
    ret
@@:
    ; save a new hint
    mov         eax,                ecx
    inc         eax
    mov         _dynamicstackhint,  eax

    ; write stack allocation to vector
    mov         edx,                4[esp]                  ; get stack allocation
    mov         _pstackvector[4*ecx],  edx
    
    ; insert the new stack at the head
    ;   ecx is the index of the new stack
    ;   edx is the location where we write the next index (i.e. the base of the stack allocation)
    ;   eax is scratch
    ;   save ebx and esi so we can use them too
    push        ebx
    push        esi
    mov         eax,                _stackhead              ; [_stackhead]
@@:
    mov         ebx,                eax  
    and         ebx,                DYNSTACK_INDEXMASK      ; extract head index
    mov         [edx],              ebx                     ; put old head index into the next link in the stack we are freeing
    mov         esi,                eax
    and         esi,                DYNSTACK_SEQUENCEMASK   ; extract sequence
    add         esi,                DYNSTACK_SEQUENCEINCR   ; increment sequence
    or          esi,                ecx                     ; insert new index

    lock cmpxchg dword ptr _stackhead, esi                  ; update the head to point at freed stack if eax == [_stackhead]
    jne         @B                                          ; if _stackhead changed since we read it, retry (eax has new _stackhead]

    ; if this is the first initialization, or there was already a free stack, we are done
    mov         esi,                _dynamicstackuninit
    or          esi,                esi
    jnz         @F
    cmp         ebx,                DYNSTACK_EMPTYINDEX
    jne         @F

    ; else let somebody wakeup and run on the stack we just added  (our caller should beware!)
    ; restore ebx and esi
    pop         esi
    pop         ebx

    lea         ecx,                _stackhead              ;; &_stackhead is pattern for wakeup (passed in ecx)
    mov         eax,                _pservicevector
    jmp         dword ptr [eax+4*BASICSERV_NOSTACK_WAKEUP]  ;; must return EAX=0 to our caller when it eventually calls Resume to return the CPU

@@:
    ; set _dynamicstackuninit = FALSE
    xor         ebx,                 ebx
    mov         _dynamicstackuninit, ebx                    ;; we have now initialized the first stack

    ; restore ebx and esi and return success
    pop         esi
    pop         ebx
    mov         eax,                1
    ret

;
; Handle the rest of the hardware emulation calls
;

EmulationCall macro  name
    EXTERNDEF C trap&name:PROC
trap&name& LABEL PROC
    mov         eax,                _pemulationvector
    mov         eax,                [eax+4*TRAPEMUL_&name]
    jmp         eax
    endm

    EmulationCall Noop
    EmulationCall MapMemory
    EmulationCall MapIO
    EmulationCall MapTrap
    EmulationCall CreatePortal
    EmulationCall DestroyPortal
    EmulationCall CleanCtx
    ; Special:    Resume            ; trapResume has to release the stack, so it is handcoded above
    EmulationCall Suspend
    EmulationCall Unsuspend
    EmulationCall PopCaller
    EmulationCall DiscardToken
    EmulationCall StartCPU
    EmulationCall InterruptCPU
    EmulationCall AccessDevice
    EmulationCall ManageIRQL
    EmulationCall HaltCPU
    EmulationCall GetSPACEParams
    EmulationCall SPACEBreak

;
; Define the dispatch entries here
;
; System calls implemented by BasicOZ are defined in the included file
;


SystemCall macro  name,index
    EXTERNDEF C sys_&name:PROC
sys_&name& LABEL PROC
    mov         eax,                _pservicevector
    mov         eax,                [eax+4*index]
    jmp         eax
    endm

include BasicOZServices.inc

_TEXT   ENDS

; End of file
    end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\INC\SystemLib.h ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include <ntstatus.h>

//
// Library offsets into libraryvector
//
#define SYSLIB_StudyImage             0

//
// General Definitions
//
#define COUNTBY(a,s)  (((a) + ((s)-1)) / (s))

#define NTSPACE_PAGESIZE (64 * 1024)

typedef ULONG SPACEStatus;

//
// Definitions for StudyImage()
//

typedef struct {
    ULONG       nPages;
    PVOID       MemoryAddress;
    ULONG_PTR   VirtualAddress;
    ULONG       Writable;
} ImageSection;

SPACEStatus
StudyImage(
        PVOID           imagebase,
        ULONG           imagesize,
        ImageSection    imagesections[],
        PULONG          pnimagesections,
        ULONG_PTR      *entrypoint
    );

//
// SPACEStatus codes
//


#define SPACEStatus_ACCESS_VIOLATION		STATUS_ACCESS_VIOLATION
#define SPACEStatus_BLOCK				    STATUS_BLOCK
#define SPACEStatus_BUFFER_OVERFLOW			STATUS_BUFFER_OVERFLOW
#define SPACEStatus_DEVICE_ALREADY_ATTACHED	STATUS_DEVICE_ALREADY_ATTACHED
#define SPACEStatus_ILLEGAL_INSTRUCTION		STATUS_ILLEGAL_INSTRUCTION
#define SPACEStatus_INTERNAL_ERROR			STATUS_INTERNAL_ERROR
#define SPACEStatus_INVALID_IMAGE_FORMAT	STATUS_INVALID_IMAGE_FORMAT
#define SPACEStatus_NO_MEMORY				STATUS_NO_MEMORY
#define SPACEStatus_NO_SUCH_DEVICE			STATUS_NO_SUCH_DEVICE
#define SPACEStatus_SPACE_INTERRUPT			STATUS_SPACE_INTERRUPT
#define SPACEStatus_SUCCESS				    STATUS_SUCCESS
#define SPACEStatus_UNSUCCESSFUL			STATUS_UNSUCCESSFUL
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\SPACE\Config.h ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

//
// Configuration for LoadKernel
//

#define BASICOZKERNEL L"BasicOZ.boz"

//
// Configuration for Memory
//

#define CTXBITS     16
#define MODEBITS     5

#define MAXCTXS     (1 << CTXBITS)
#define MAXMODES    (1 << MODEBITS)

#define PHYSMEMSIZE (256 M)

#define MINIMUM_VPAGE     (ADDR2PAGE(0x10000000))
#define MAXIMUM_VPAGE     (ADDR2PAGE(0x70000000) - 1)

//
// Configuration for CPU
//

#define MAXCPUS     256

//
// Configuration for IO
//

#define IRQLBITS     6
#define MAXIRQLS    (1 << IRQLBITS)
#define MAXDEVICES  32      // bitmask must fit in ULONG

//
// Configruation parameters specific to the SPACE implementation on NT
//

// NT VM section alignment requirement
// (Note protections could be on a 4KB/8KB granularity).

//
// 32-bit virtual addresses (maximum range is actually limited to less than 0..2^31)
// Pagesize is 64KB, so addresses are 1 + 8 + 7 + 16
//
#define NTSPACE_TOPBITS   8
#define NTSPACE_MIDBITS   7
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\INC\SPACEOps.h ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

// Some basic types
typedef unsigned long      ulong;
typedef unsigned short     ushort;
typedef unsigned char      uchar;
typedef unsigned __int64   ulong64;
typedef int                boolean;


typedef ulong64 SPACETOKEN;

// space context/modes
#define KERNELCTX           0
#define KERNELMODE          0
#define USERMODE            1

// SPACE paging macros
#define NTSPACE_PAGEBITS 16
#define NTSPACE_PAGESIZE  (1 << NTSPACE_PAGEBITS)
#define PAGE2ADDR(p) ((ulong)((p) << NTSPACE_PAGEBITS))
#define ADDR2PAGE(a) ((ulong)((a) >> NTSPACE_PAGEBITS))

#define IOCTX     (-2)
#define GLOBALCTX (-1)

// IO Definitions
#define IRQLBITS     6
#define MAXDEVICES  32      // bitmask must fit in unsigned long

// Definitions for read/write masks
#define BITMASK(x) ((ulong) (1 << (x)))

#define NOACCESS            ((ulong)  0)
#define ALLACCESS           ((ulong) -1)
#define ACCESSMASK(x)       BITMASK(x)
#define ACCESSOK(mask,mode) ((mask) & ACCESSMASK(mode))

//
// HW Emulation calls
//

// used with GetSPACEParams()
// no longer than 5 ulongs
typedef struct {
        ulong       vpage_base;
        ulong       vpage_limit;
        ulong       maxctxs;
        uchar       maxmodes;
        uchar       maxirqls;
        uchar       maxdevices;
        uchar       physbasepage;   // small number of pages used to boot BasicOZ
        ulong       nphysmempages;
} SPACEParams;
typedef union {
    SPACEParams params;
    ulong           registers[5];
} XSPACEParams;



#ifdef SPACE_EXE
#   define  EMULCPU     ulong cpu,
#   define  EMULCPUx    ulong cpu
#   define  EMULRETURN  NTSTATUS
#   define  E(n)        n
#else
#   define  EMULCPU
#   define  EMULCPUx
#   define  EMULRETURN  void
#   define  E(n)        SPACE_ ## n
void SPACE_Noop();
void SPACE_GetSPACEParams(SPACEParams *p);
#endif


struct regargs {
    ulong args[5];
};

EMULRETURN E(MapMemory) (EMULCPU  ulong ctx, ulong vpage, ulong ppage, ulong readmask, ulong writemask);
typedef union {
    struct {
        ulong ctx;
        ulong vpage;
        ulong ppage;
        ulong readmask;
        ulong writemask;
    };
    struct regargs;
} XMapMemory;
#define NTSPACE_INVALIDPAGE (0xffffffff)

EMULRETURN E(CleanCtx) (EMULCPU  ulong ctx);

ulong E(CreatePortal)       (EMULCPU  uchar type, uchar mode, uchar irql, ulong ctx, ulong handler, ulong protmask);
typedef union {
    struct {
        uchar type;
        uchar mode;
        uchar irql;
        uchar spare;
        ulong ctx;
        ulong handler;
        ulong protmask;
    };
    struct regargs;
} XCreatePortal;

typedef enum portaltype {
    emulationcall = 0,  // deliberate by program, only certain registers saved/restored
    servicecall   = 1,  // deliberate by program, only certain registers saved/restored
    interrupt     = 2,  // IRQL raised, lowered upon return, interrupted instruction resumed, all registers saved/restored
    exception     = 3,  // these are fatal, limited parameters, chain destroyed, cannot be resumed [analysis introduces much complexity]
    fault         = 4,  // parameters explain fault, faulting instruction resumed, all registers saved/restored [used only for accessfault]
    vaddr         = 5,  // pagefaults, based on virtual address range.  otherwise same as fault
} Portaltype;

EMULRETURN E(DestroyPortal) (EMULCPU  ulong portalid);

EMULRETURN E(MapTrap)       (EMULCPU  ulong ctx, uchar traptype, uchar global, ulong indexbase, ulong indexlimit, ulong portalid);
typedef union {
    struct {
        ulong  ctx;
        uchar  traptype;
        uchar  global;
        ushort spare;
        ulong  indexbase;
        ulong  indexlimit;
        ulong  portalid;
    };
    struct regargs;
} XMapTrap;

// traptypes must agree with Portaltypes and PCBCalltype (for now -- otherwise need a function for cross-checking them)
typedef enum {
    trapemul   = 0,
    trapserv   = 1,
    trapintr   = 2,
    trapexcept = 3,
    trapfault  = 4,
    trapvaddr  = 5
} Traptype;

SPACETOKEN  E(Suspend)      (EMULCPUx);
EMULRETURN  E(Resume)       (EMULCPU  ulong64 result);
EMULRETURN  E(Unsuspend)    (EMULCPU  SPACETOKEN token);
EMULRETURN  E(DiscardToken) (EMULCPU  SPACETOKEN token);
EMULRETURN  E(PopCaller)    (EMULCPUx);

EMULRETURN  E(StartCPU)     (EMULCPU  ulong boot_cpu, ulong boot_ctx, ulong boot_mode, ulong boot_pc, ulong boot_arg);
typedef union {
    struct {
        ulong boot_cpu;
        ulong boot_ctx;
        ulong boot_mode;
        ulong boot_pc;
        ulong boot_arg;
    };
    struct regargs;
} XStartCPU;

EMULRETURN  E(HaltCPU)      (EMULCPU  ulong reason);

EMULRETURN  E(MapIO)        (EMULCPU  uchar deviceid, uchar writable, ulong iospacepage, ulong physpage);
typedef union {
    struct {
        uchar  deviceid;
        uchar  writable;
        ushort spare;
        ulong  iospacepage;
        ulong  physpage;
    };
    struct regargs;
} XMapIO;

ulong64     E(AccessDevice) (EMULCPU  ushort deviceid, uchar op, uchar deviceregister, ulong value, ulong valuex);
typedef union {
    struct {
        ushort deviceid;
        uchar  op;
        uchar  deviceregister;
        ulong  value;
        ulong  valuex;
    };
    struct regargs;
} XAccessDevice;

void  E(InterruptCPU)       (EMULCPU  ushort targetcpu, uchar interrupt, uchar irql);
typedef union {
    struct {
        ushort targetcpu;
        uchar  interrupt;
        uchar  irql;
    };
    struct regargs;
} XInterruptCPU;


typedef enum {
    raiseirql, setirql, lowerirql
} IRQLOps;

IRQLOps E(ManageIRQL)       (EMULCPU  IRQLOps irqlop, uchar irql);
typedef union {
    struct {
        uchar  irqlop;
        uchar  irql;
        ushort spare;
    };
    struct regargs;
} XManageIRQL;

void E(SPACEBreak)          (EMULCPU  ulong breakvalue, char breakmsg[]);       // breakmsg limited to 16 characters because we pack in registers
typedef union {
    struct {
        ulong  breakvalue;
        uchar  breakmsg[16];
    };
    struct regargs;
} XSPACEBreak;
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\INC\TrapValues.inc ===
;;
;; Copyright (c) Microsoft Corporation. All rights reserved. 
;; 
;; You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
;; If you do not agree to the terms, do not use the code.
;;

; NOTE: Definitions must match SPACE\TrapValues.h
; NOTE: TRAPEMUL_* must match Bootstrap.asm

;
; trap types
;

; emulated SPACE hardware instructions, like resume
;
     TRAPEMUL_Noop            equ  0
     TRAPEMUL_MapMemory       equ  1
     TRAPEMUL_MapIO           equ  2
     TRAPEMUL_MapTrap         equ  3
     TRAPEMUL_CreatePortal    equ  4
     TRAPEMUL_DestroyPortal   equ  5
     TRAPEMUL_CleanCtx        equ  6
     TRAPEMUL_Resume          equ  7
     TRAPEMUL_Suspend         equ  8
     TRAPEMUL_Unsuspend       equ  9
     TRAPEMUL_PopCaller       equ 10
     TRAPEMUL_DiscardToken    equ 11
     TRAPEMUL_StartCPU        equ 12
     TRAPEMUL_InterruptCPU    equ 13
     TRAPEMUL_AccessDevice    equ 14
     TRAPEMUL_ManageIRQL      equ 15
     TRAPEMUL_HaltCPU         equ 16
     TRAPEMUL_GetSPACEParams  equ 17
     TRAPEMUL_SPACEBreak      equ 18

; implement service call
     TRAPSERV_MAXCALLS        equ 256
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\INC\DeviceDefs.h ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

//
// System constants needed by drivers defined here
//
#define NTSPACE_PAGEBITS 16
#define NTSPACE_PAGESIZE  (1 << NTSPACE_PAGEBITS)

//
// Basic IO Device Emulations
//


//
// Define a 'console' device for printing messages and reading lines
//
//
#define CONSOLEDEVICE_ID               2


// Console Device
//  IORegister:      PRINT:     Write logical address of the string to be output to the 'console' and length of the string
//                   GETLINE:   Write logical address of the buffer to be read into, and the limit (including the NUL);
// Transfers are synchronous -- ie. no explicit DMA happens.

#define CONSOLEDEVICE_IORegister       0

//
// Define 'console' device ops
//
#define CONSOLEOP_PRINT                0
#define CONSOLEOP_GETLINE              1
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\INC\OZOps.h ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\SPACE\Debug.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include "Defs.h"

#define TERSE

char *TRACE_fmt  = "TRACE: %s(): line %4d in %s\n";
char *STRACE_fmt = "TRACE: %s(): line %4d in %s <%s> [%08x %08x %08x %08x]\n";

char *portaltypestrings[] = {
    "emulationcall", // 0
    "servicecall",   // 1
    "interrupt",     // 2
    "exception",     // 3
    "fault",         // 4
    "vaddr"          // 5
};

#define PORTALTYPESTRING(t) (((t) < ASIZEOF(portaltypestrings))? portaltypestrings[(t)] : "<unknown>")

char *EMULStrings[] = {
    "Noop",           //  0
    "MapMemory",      //  1
    "MapIO",          //  2
    "MapTrap",        //  3
    "CreatePortal",   //  4
    "DestroyPortal",  //  5
    "CleanCtx",       //  6
    "Resume",         //  7
    "Suspend",        //  8
    "Unsuspend",      //  9
    "PopCaller",      // 10
    "DiscardToken",   // 11
    "StartCPU",       // 12
    "InterruptCPU",   // 13
    "AccessDevice",   // 14
    "ManageIRQL",     // 15
    "HaltCPU",        // 16
    "GetSPACEParams"  // 17
};

void
dump_Portal(
        Portal *p,
        int     emultype,
        char   *msg
    )
{
    if (p == NULL) {
        printf("dump_Portal(NULL): %s\n", msg);
        return;
    }

#ifdef TERSE
    printf("Portal <%x>  [%s]:  [%8x] => %08x Hash refcount=%x destroyed=%x type=%x <%s> %s\n",
           p, msg, (ULONG)p->hash.value, p->hash.link, p->refcount, p->destroyed, p->type, PORTALTYPESTRING(p->type),
           (emultype<0)? "<unknown>" : EMULStrings[emultype]);
    printf("  xxx=%x ctx/mode/irql=%x/%x/%x  protmask=%x  handler/arg=%x/%x\n",
           p->reserved, p->ctx, p->mode, p->irql, p->protmask, p->handler, p->arg);
#else
    printf("Portal <%x>  [%s]\n",   p, msg);

    printf("  [%8x] => %08x  Hash\n", (ULONG)p->hash.value, p->hash.link);
    printf("  %8x  refcount\n",     p->refcount);
    printf("  %8x  type <%s>\n",    p->type, PORTALTYPESTRING(p->type));
    printf("  %8x  destroyed\n",    p->destroyed);
    printf("  %8x  reserved\n",     p->reserved);
    printf("  %8x  ctx\n",          p->ctx);
    printf("  %8x  mode\n",         p->mode);
    printf("  %8x  irql\n",         p->irql);
    printf("  %8x  protmask\n",     p->protmask);
    printf("  %8x  handler\n",      p->handler);
    printf("  %8x  arg\n",          p->arg);

    printf("+++\n");
#endif
}

void
dump_Domain(
        Domain *p,
        char   *msg
    )
{
    EXCEPTION_MESSAGE *xm;
    EXCEPTION_RECORD  *xr;
    NTThreadDescr     *td;
    int i;

    if (p == NULL) {
        printf("dump_Domain(NULL): %s\n", msg);
        return;
    }

    printf("Domain [%s]:  ntprocess=%x  NTTheadDescr[]\n", msg, p->ntprocess);

    for (i = 0;  i < MAXCPUS;  i++) {
        td = p->cpus[i];
        if (td) {
            xm = &td->ntreplymessage;
            xr = &td->ntreplymessage.ExceptionRecord;
            printf(" %2d: NTthread cid/handle: %4d./%4x  cpu: %2x  trappednotinterrupted: %c  interrupteip: %8x  " "\n"//ntstack: %8x\n"
                   "               ntreplymsg: <msgid: %08x type: %08x pid/tid: %07d./%07d.  ReturnedStatus: %08x>\n"
                   "                     xrec: (code:  %08x addr: %08x args:    %08x/%08x>\n",
                    i, (ULONG)td->hash.value, td->ntcputhread, td->cpu, (td->trappednotinterrupted? 'T' : 'F'), td->interrupteip, //td->ntstackpointer,
                    xm->hdr.MessageId, xm->hdr.u2.s2.Type, xm->hdr.ClientId.UniqueProcess, xm->hdr.ClientId.UniqueThread, xm->ReturnedStatus,
                    xr->ExceptionCode, xr->ExceptionAddress, xr->ExceptionInformation[0], xr->ExceptionInformation[1]);
        }
    }
    printf("\n");
}

void
dump_Space(
        Space  *p,
        char   *msg
    )
{
    int i, n;

    if (p == NULL) {
        printf("dump_Space(NULL): %s\n", msg);
        return;
    }

    printf("Space [%s]:\n", msg);
    printf("  map:\t\t%x\t- dump with: dm ctxid\n", p->rootmap);
    printf("  trapvector:\t%x\t- dump with: dt ctxid\n", p->trapvector);

    for (n = 0, i = 0;  i < MAXMODES;  i++) if (p->domains[i]) n++;

    printf("  domains:\t<%x>\t- dump with: dd ctxid mode\n", n);
    for (i = 0;  i < MAXMODES;  i++) {
        if (p->domains[i])
            printf(" %2d: \t\t%x\t- dump with: dd ctxid %d\n", i, p->domains[i]);
    }
    printf("\n");
}

char *pcbcalltypestrings[] = {
    "unknowncall",     // 0,    // emulation calls don't use PCBs
    "servicetra",      // 1,
    "interruptcall",   // 2,
    "accessviolation", // 3,
    "raiseexception",  // 4,
    "pagefault"        // 5
};

#define PCBCALLTYPESTRING(t) (((t) < ASIZEOF(pcbcalltypestrings))? pcbcalltypestrings[(t)] : "<unknown>")

void
dump_PCB(
        PCB   *p,
        char  *msg
    )
{
#ifdef TERSE
    printf("PCB <%x>  [%s]  [%8x] => %08x Hash\n", p, msg, (ULONG)p->hash.value, p->hash.link);
    printf("  old ctx/mode/irql=%x/%x/%x  chain=%x  type=%x <%s> retarg=%x token: alloc=%x owner ctx/mode=%x/%x\n",
        p->oldctx, p->oldmode, p->oldirql, p->chainlink, p->pcbcalltype, PCBCALLTYPESTRING(p->pcbcalltype),
        p->returnargflag, p->tokenallocated, p->tokenowner_ctx, p->tokenowner_mode);
    dump_CONTEXT(&p->ntcontext, "pcb->ntcontext");
#else
    printf("PCB <%x>  [%s]\n",   p, msg);

    printf("  [%8x] => %08x  Hash\n", (ULONG)p->hash.value, p->hash.link);
    printf("  %8x  chainlink\n",        p->chainlink);
    printf("  %8x  type <%s>\n",        p->pcbcalltype,        PCBCALLTYPESTRING(p->pcbcalltype));
    printf("  %8x  tokenallocated\n",   p->tokenallocated);
    printf("  %8x  returnargflag\n",    p->returnargflag);
    printf("  %8x  oldctx\n",           p->oldctx);
    printf("  %8x  oldmode\n",          p->oldmode);
    printf("  %8x  oldirql\n",          p->oldirql);
    printf("  %8x  tokenowner_ctx\n",   p->tokenowner_ctx);
    printf("  %8x  tokenowner_mode\n",  p->tokenowner_mode);
    dump_CONTEXT(&p->ntcontext, "pcb->ntcontext");
    printf("+++\n");
#endif
}

void
out_vector(
        char   *tname,
        Portal *p[],
        int     nentries
    )
{
    int i, maxvalid;

    printf("  %13s", tname);

    // don't print extra lines of 'xxx'
    maxvalid = nentries;
    while (maxvalid > 16) {           // we can print at least these many on a line
        if (p[maxvalid-1] != NULL)
            break;
        maxvalid--;
    }

    for (i = 0;  i < maxvalid;  i++) {
        if (p[i] == NULL)
            printf(" xxx");
        else
            printf(" %3x", (ULONG)p[i]->hash.value);
    }
    if (maxvalid < nentries)
        printf(" ...");
    printf("\n");
}

void
dump_Trapvector(
        Trapvector *t,
        char       *msg
    )
{
    struct copy_of_private_VADNode_from_trap_c {
        ULONG       VirtualPageBase;
        ULONG       VirtualPageLimit;
        Portal     *Portal;
    } *ptr;

    if (t == NULL) {
        printf("dump_Trapvector(NULL): %s\n", msg);
        return;
    }

    printf("Trapvector <%x>: %s\n", t, msg);

    out_vector("emulation:",     t->emulation,   NTRAP_EMULCALLS);
    out_vector("servicecall:",   t->servicecall, NTRAP_SERVCALLS);
    out_vector("interrupts:",    t->interrupts,  NTRAP_INTERRUPTS);
    out_vector("exceptions:",    t->exceptions,  NTRAP_EXCEPTIONS);
    out_vector("faults:",        t->faults,      NTRAP_FAULTS);

    for (ptr = RtlEnumerateGenericTableAvl(&t->vadtree, TRUE);  ptr != NULL;  ptr = RtlEnumerateGenericTableAvl(&t->vadtree, FALSE)) {
            printf("  %08x->%08x:  %4x\n", ptr->VirtualPageBase, ptr->VirtualPageLimit,
                                           ptr->Portal? ((ULONG)ptr->Portal->hash.value) : 0xdead);
    }
}

void
dump_CONTEXT(
        CONTEXT *p,
        char    *msg
    )
{
#ifdef TERSE
    printf("CONTEXT <%x> %s: ctxflags=%x segs Cs/Ss=%x/%x Ds=%x\n", p, msg, p->ContextFlags, p->SegCs, p->SegSs, p->SegDs);
    printf("  Ebx=%x  Ecx=%X  Edx=%x  Edi=%x  Esi=%x  Eax=%x  Eip=%x Ebp/Esp=%x/%x EF=%x\n",
            p->Ebx, p->Ecx, p->Edx, p->Edi, p->Esi, p->Eax, p->Eip, p->Ebp, p->Esp, p->EFlags);
#else
    printf("CONTEXT <%x>  [%s]\n",   p, msg);
    printf("  %8x  ContextFlags\n", p->ContextFlags);
    printf("  %8x  SegGs\n",        p->SegGs);
    printf("  %8x  SegFs\n",        p->SegFs);
    printf("  %8x  SegEs\n",        p->SegEs);
    printf("  %8x  SegDs\n",        p->SegDs);
    printf("\n");
    printf("  %8x  SegCs\n",        p->SegCs);
    printf("  %8x  SegSs\n",        p->SegSs);
    printf("\n");
    printf("  %8x  Edi\n",          p->Edi);
    printf("  %8x  Esi\n",          p->Esi);
    printf("  %8x  Ebx\n",          p->Ebx);
    printf("  %8x  Edx\n",          p->Edx);
    printf("  %8x  Ecx\n",          p->Ecx);
    printf("  %8x  Eax\n",          p->Eax);
    printf("\n");
    printf("  %8x  Eip\n",          p->Eip);
    printf("  %8x  Ebp\n",          p->Ebp);
    printf("  %8x  Esp\n",          p->Esp);
    printf("  %8x  EFlags\n",       p->EFlags);
    printf("\n");
    printf("+++\n");
#endif
}

void
dump_data(
        PCHAR p,
        ULONG n,
        char *msg
    )
{
    ULONG i, x;

    x = 0;
    printf("  %s\n", msg);
    for (i = 0;  i < n;  i++) {
        if (x == 0)
            printf("    ");
        printf(" %0x", p[i]);
        if (x == 15) {
            printf("\n");
            x = 0;
        } else {
            x++;
        }
    }

    printf("\n");
}

#define DUMP_DATA(base, offset, count) dump_data( (offset) + (PCHAR)(base), (count), "DATA");


char *CPUStateStrings[] = {
    "Uninitialized",    // 0,
    "Running",          // 1,
    "Halted"            // 2,
};

#define CPUSTATESTRING(t) (((t) < ASIZEOF(CPUStateStrings))? CPUStateStrings[(t)] : "<unknown>")

void
dump_CPUHardware(
        CPUHardware *p,
        char        *msg
    )
{
#ifdef TERSE
    printf("CPUHardware <%x>  [%s]  cpustate=%x <%s>  ctx/mode/irql=%x/%x/%x chain=%x intq=%x pend=%x\n",
            p, msg, p->cpustate, CPUSTATESTRING(p->cpustate), p->ctx, p->mode, p->irql,
            p->currentchain, p->queuehead, p->pendinginterrupt);
    if (p->currentchain)
        dump_PCB(p->currentchain, "currentchain");
#else
    printf("CPUHardware <%x>  [%s]\n",   p, msg);

    printf("  %8x  cpustate <%s>\n",    p->cpustate,        CPUSTATESTRING(p->cpustate));
    printf("  %8x  ctx\n",              p->ctx);
    printf("  %8x  mode\n",             p->mode);
    printf("  %8x  irql\n",             p->irql);
    printf("  %8x  currentchain\n",     p->currentchain);
    printf("  %8x  queuehead\n",        p->queuehead);
    printf("  %8x  pendinginterrupt\n", p->pendinginterrupt);

    if (p->currentchain)
        dump_PCB(p->currentchain, "currentchain");
    printf("+++\n");
#endif
}

void
dump_PORT_MESSAGE(
        PPORT_MESSAGE p,
        char         *msg
    )
{
    printf("PORT_MESSAGE <%x>  [%s]\n",   p, msg);
    printf("  %8x Length\n",                    p->u1.Length);
    printf("  %8x Type\n",                      p->u2.s2.Type);
    printf("  %8x DataInfoOffset\n",            p->u2.s2.DataInfoOffset);
    printf("  %8x ClientId.UniqueProcess\n",    p->ClientId.UniqueProcess);
    printf("  %8x ClientId.UniqueThread\n",     p->ClientId.UniqueThread);
    printf("  %8x MessageId\n",                 p->MessageId);
    printf("x %8x CallbackId\n",                p->CallbackId);
    DUMP_DATA(p, sizeof(PORT_MESSAGE), 32);
    printf("+++\n");
}

void
dump_EXCEPTION_MESSAGE(
        EXCEPTION_MESSAGE *p,
        char              *msg
    )
{
    EXCEPTION_RECORD  *x = &p->ExceptionRecord;

#ifdef TERSE
    printf("  xrec: code/addr=%x  info=%x/%x\n",
            x->ExceptionCode, x->ExceptionAddress, x->ExceptionInformation[0], x->ExceptionInformation[1]);
#else
    dump_PORT_MESSAGE(&p->hdr, msg);
    printf("  %8x ApiNumber\n",                 p->ApiNumber);
    printf("  %8x ReturnedSTatus\n",            p->ReturnedStatus);
    printf("  %8x &ExceptionRecord\n",         &p->ExceptionRecord);

    printf("     %8x .code\n",                  x->ExceptionCode);
    printf("     %8x .address\n",               x->ExceptionAddress);
    printf("     %8x .information[0]\n",        x->ExceptionInformation[0]);
    printf("     %8x .information[1]\n",        x->ExceptionInformation[1]);

    printf("  %8x FirstChance\n",               p->FirstChance);
    printf("+++\n");
#endif
}

//
// see VPageToMap -- this must match that function
//
#define NTSPACE_TOPMASK ((1 << NTSPACE_TOPBITS) - 1)
#define NTSPACE_MIDMASK ((1 << NTSPACE_MIDBITS) - 1)

#define TOPVADBITS(va) (((va) >> (NTSPACE_PAGEBITS + NTSPACE_MIDBITS)) &  NTSPACE_TOPMASK)
#define MIDVADBITS(va) (((va) >> (NTSPACE_PAGEBITS                  )) &  NTSPACE_MIDMASK)

#define NTSPACE_MAPDIRENTRIES (1 << NTSPACE_TOPBITS)
#define NTSPACE_MAPTABENTRIES (1 << NTSPACE_MIDBITS)

void
dump_Rootmap(
    ULONG  ctx,
    char  *msg
)
{

    Space     *space;
    ULONG      vdir, vpage;
    ULONG_PTR  virtualpage;

    Mapping  **rootmap;
    Mapping  *dmap, *pmap;

    printf("Rootmap for ctx %x: %x\n", ctx, msg);

    if (ctx == IOCTX) {
        space = iospace;
        printf("Using IOSPACE\n");
    } else if (ctx >= MAXCTXS) {
        printf("bad context: %x\n", ctx);
        return;
    } else {
        space = spaces[ctx];
    }

    if (space == NULL) {
        printf("empty ctx: %x\n", ctx);
        return;
    }

    rootmap = space->rootmap;

    if (rootmap == NULL) {
        printf("no rootmap for ctx: %x\n", ctx);
        return;
    }

    for (vdir = 0;  vdir < NTSPACE_MAPDIRENTRIES;  vdir++) {
        if (dmap = rootmap[vdir]) {
            for ( vpage = 0;  vpage < NTSPACE_MAPTABENTRIES;  vpage++) {
                pmap = dmap + vpage;
                if (pmap && (pmap->physpage || pmap->readmask || pmap->writemask)) {
                    virtualpage = vdir  * NTSPACE_MAPTABENTRIES + vpage ;
                    printf("MAP <%x>:  %08x -> %08x  [R: %08x  W: %08x]\n", pmap, virtualpage, pmap->physpage, pmap->readmask, pmap->writemask);
                }
            }
        }
    }
}

void
dump_ProcessVirtualRegions(
        HANDLE     process,
        ULONG_PTR  start,
        ULONG_PTR  limit,
        char       *msg
    )
{
    MEMORY_BASIC_INFORMATION32 m;
    NTSTATUS s;
    ULONG ptr;

    if (start == 0 && limit == 0) {
        start = PAGE2ADDR(spaceparams.vpage_base);
        limit = PAGE2ADDR(spaceparams.vpage_limit);
    }

    printf("Process Virtual Regions: start=%08x  limit=%08x  process=%x   <%s>\n", start, limit, process, msg);

    ptr = start;
    while (ptr < limit) {
        s = NtQueryVirtualMemory (process, (PVOID)ptr, MemoryBasicInformation, &m, sizeof(m), NULL);
        if (!NT_SUCCESS(s)) {
           printf("ERR: NtQueryVirtualMemory returns %x\n", s);
           if (s == STATUS_INVALID_HANDLE) {
               printf("Aborting\n");
               return;
           }
           ptr += 64*1024;

        } else if (m.State != MEM_FREE) {
           printf("   ptr=%08x:  Base=%08x AllocBase=%08x AllocProt=%-4x Region=%08x State=%4x  Prot=%4x  Type=%2x\n",
                ptr, m.BaseAddress, m.AllocationBase, m.AllocationProtect, m.RegionSize, m.State, m.Protect, m.Type);
           ptr += m.RegionSize;

        } else {
           ptr += m.RegionSize;
        }
    }
    printf("+++\n");
}

char *spacebreakhelp =
     "\nCommands:\n"
     "\tg - go (continue)\n"
     "\t! - launch ntsd debugger on OZ\n"
     "\td? id - dump data structure 'x'\n"
     "\t\tdc cpuid\t - dump CPUHardware for cpu\n"
     "\t\tdd ctxid mode\t - dump Domain for space ctxid and mode\n"
     "\t\tdh ctxid\t - dump handles for space ctxid\n"
     "\t\tdm ctxid\t - dump Map for ctxid\n"
     "\t\tdp portalid\t - dump Portal for portalid\n"
     "\t\tds ctxid\t - dump Space for space ctxid\n"
     "\t\tdt ctxid\t - dump trapvector for space ctxid (or -1 for GLOBALCTX)\n"
     "\t\tdv handleid [01] - dump NT virtual regions for process with handleid [all addresses]\n"
     "\t\tdx handleid [01]- get/dump NT thread context for thread with handleid [or by CID]\n"
     "\t\tdr handleid address\t - dump remote data from process handleid at address\n"
     "\t\tdw handleid address value\t - write remote value in process handleid at address\n"
     "\tq - quit\n" 
     "\t? - this help\n";

BOOLEAN spacebreak_disabled = 0;

void
spacebreak(
        char        *why,
        CLIENT_ID   *pcid,
        char        *fcn,
        char        *file,
        int          line
    )
{
    BOOLEAN  continueflag;
    char     buf[128];
    char    *cmdline;

    char  cmdchar;
    char  optchar;
    ulong idparam0;
    ulong idparam1;
    ulong idparam2;

    int system(const char *command);
    

    fflush(stdout);

    if (spacebreak_disabled)
        return;

    fprintf(stderr, "SPACEBREAK: %s() at %d in %s: %s\n", fcn, line, file, why);

    if (pcid)
        fprintf(stderr, "To start debugger on BasicOZ:  (thread %d), process:  ntsd -p %d\n", pcid->UniqueThread, pcid->UniqueProcess);

    continueflag = 0;
    while (!continueflag) {
         fprintf(stderr, "debug cmd> ");

         cmdline = fgets(buf, sizeof(buf)-1, stdin);
         if (cmdline == NULL) {
             continueflag = 1;
             continue;
         }

         cmdchar   = '$';     // noop
         optchar   =  0;
         idparam0  =  0;
         idparam1  =  0;
         idparam2  =  0;
         sscanf(cmdline, "%c%c %x %x %x\n", &cmdchar, &optchar, &idparam0, &idparam1, &idparam2);

         switch (cmdchar) {
         case 'g':
             if (optchar == '$') {
                 fprintf(stderr, "\ncontinuing with no more breaks.\n\n");
                 spacebreak_disabled = 1;
             } else {
                 fprintf(stderr, "\ncontinuing...\n");
             }
             continueflag = 1;
             break;

         case '!':
             if (pcid) {
                 fprintf(stderr, "\nlaunching debugger ...\n");
                 sprintf(buf, "start ntsd -p %d", pcid->UniqueProcess);
                 system(buf);
             } else {
                 fprintf(stderr, "\ncannot automatically launch debugger from this point\n\n");
             }
             break;

         case 'd': {
                switch (optchar) {
                case 'm':
                    dump_Rootmap(idparam0, "dump Maps for ctx");
                    break;
                case 'c':
                    if (idparam0 < MAXCPUS)
                        dump_CPUHardware(cpuhardware+idparam0, "dump CPUHardware for id");
                    else
                        printf("Bad id\n");
                    break;
                case 'd':
                    if (idparam0 >= MAXCTXS) {
                        printf("Bad ctx: %x\n", idparam0);
                    } else if (idparam1 >= MAXMODES) {
                        printf("Bad mode: %x\n", idparam1);
                    } else if (spaces[idparam0] == NULL) {
                        printf("Space NULL for ctx %x\n", idparam0);
                    } else if (spaces[idparam0]->domains[idparam1] == NULL) {
                        printf("Domain NULL for mode %x in ctx %x\n", idparam1, idparam0);
                    } else  {
                        dump_Domain(spaces[idparam0]->domains[idparam1], "dump Domain");
                    }
                    break;
                case 'h':
                    if (idparam0 < MAXCTXS && spaces[idparam0]) {
                        ulong i;
                        for (i = 0;  i < MAXMODES;  i++)
                            if (spaces[idparam0]->domains[i])
                                printf("ctx %3x mode %2x ntprocess handle %x\n", idparam0, i, spaces[idparam0]->domains[i]->ntprocess);
                    } else
                        printf("Bad id\n");
                    break;
                case 'v': {
                    ULONG_PTR start;
                    ULONG_PTR limit;
                    char     *msg;
                    switch (idparam1) {
                        case 0:
                            start = PAGE2ADDR(spaceparams.vpage_base);
                            limit = PAGE2ADDR(spaceparams.vpage_limit);
                            msg = "dump_ProcessVirtualRegions [SPACE] for id";
                            break;
                        default:
                            start = 0;
                            limit = 0x7ffe1000;
                            msg = "dump_ProcessVirtualRegions [NTUSER] for id";
                            break;
                        }
                        dump_ProcessVirtualRegions((PVOID)idparam0, start, limit, msg);
                    }
                    break;
                case 'p':
                    dump_Portal(lookupportal(idparam0), -1, "dump Portal");
                    break;
                case 'r': {
                    ULONG       b[4];
                    ULONG       readsize;
                    NTSTATUS    s;

                    s = NtReadVirtualMemory((HANDLE)idparam0, (PVOID)idparam1, (PVOID)b, sizeof(b), &readsize);
                    if (NT_SUCCESS(s) && readsize == sizeof(b))
                        fprintf(stderr, "  <process %08x> %08x:  %08x %08x %08x %08x\n", idparam0, idparam1, b[0], b[1], b[2], b[3]);
                    else
                        fprintf(stderr, "  %08x:  pr: NtReadVirtualMemory(process %08x at %08x) size %x\n", s, idparam0, idparam1, readsize);
                    break;
                }
                case 'w': {
                    ULONG       b;
                    ULONG       iosize;
                    NTSTATUS    s;

                    s = NtReadVirtualMemory((HANDLE)idparam0, (PVOID)idparam1, &b, sizeof(b), &iosize);
                    if (!NT_SUCCESS(s) || iosize != sizeof(b)) {
                        fprintf(stderr, "  %08x:  pr: NtReadVirtualMemory(process %08x at %08x) size %x\n", s, idparam0, idparam1, iosize);
                        break;
                    }
                    s = NtWriteVirtualMemory((HANDLE)idparam0, (PVOID)idparam1, (PVOID)&idparam2, sizeof(b), &iosize);
                    if (!NT_SUCCESS(s) || iosize != sizeof(b)) {
                        fprintf(stderr, "  %08x:  pr: NtWriteVirtualMemory(process %08x at %08x) size %x\n", s, idparam0, idparam1, iosize);
                    } else {
                        fprintf(stderr, "  <process %08x> %08x:  %08x -> %08x\n", idparam0, idparam1, b, idparam2);
                    }
                    break;
                }
                case 's':
                    if (idparam0 < MAXCTXS) {
                        dump_Space(spaces[idparam0], "dump Space");
                    } else if (idparam0 == IOCTX) {
                        dump_Space(iospace, "dump IOSpace");
                    } else {
                        printf("Bad ctx\n");
                    }
                    break;
                case 't':
                    if (idparam0 < MAXCTXS && spaces[idparam0]) {
                        dump_Trapvector(spaces[idparam0]->trapvector, "Spaces[] Trapvector");
                    } else if (idparam0 == GLOBALCTX) {
                        extern Trapvector  GlobalTrapVector;
                        dump_Trapvector(&GlobalTrapVector, "dump GlobalTrapVector");
                    } else {
                        printf("Bad ctx\n");
                    }
                    break;
                case 'x':
                {
                    CONTEXT        ntcontext;
                    NTThreadDescr *ntthreaddescr;
                    NTSTATUS       s;

                    if (idparam1 == 1) {
                        // idparam0 is the CID not the handle, so look up the handle
                        ntthreaddescr = LookupNTThread((HANDLE)idparam0);
                        if (ntthreaddescr == NULL) {
                            fprintf(stderr, "\nUnknown thread CID %x\n", idparam0);
                            break;
                        }
                        idparam0 = (ULONG)ntthreaddescr->ntcputhread;
                    }
                    ntcontext.ContextFlags = CONTEXT_INTEGER | CONTEXT_CONTROL;
                    s = NtGetContextThread((HANDLE)idparam0, &ntcontext);
                    if (NT_SUCCESS(s))
                        dump_CONTEXT(&ntcontext, buf);
                    else
                        fprintf(stderr, "%08x:  px: NtGetContextThread\n", s);
                    break;
                }
                default:
                    fprintf(stderr, "\nUnknown ds specifier: %c\n", optchar);
                    fprintf(stderr, spacebreakhelp);
                }
             }
             break;

         case '?':
         default:
             fprintf(stderr, spacebreakhelp);
             break;

         case '$':
         case '\n':
             break;

         case 'q':
         case '\0':
             die("spacebreak quit", 0, 0);
             //notreached
         }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\SPACE\CPU.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include "Defs.h"

Hashentry *NTThreadHash[511];

NTThreadDescr *LookupNTThread(
        HANDLE    ntthreadid
    )
{
    Hashentry *ptr = LookupHashEntry(NTThreadHash, ASIZEOF(NTThreadHash), HANDLEVALUE(ntthreadid), NULL);

    return ptr?  CONTAINING_RECORD(ptr, NTThreadDescr, hash)  :  NULL;
}


CONTEXT ntstartcontext;

void
StartNTCPUThread(
        ULONG           cpu,
        NTThreadDescr  *ntthreaddescr,
        PCB            *pcb
    )
{
    Hashentry                  **prevlink;
    Hashentry                   *ptr;
    Domain                      *domain;
    HANDLE                       ntcputhread = NULL;
    OBJECT_ATTRIBUTES            obja;
    INITIAL_TEB                  teb = { 0 };
    CLIENT_ID                    cid;
    NTSTATUS                     s;
    UNICODE_STRING               imgname;
    UNICODE_STRING               imgpath;
    UNICODE_STRING               dllpath;
	PRTL_USER_PROCESS_PARAMETERS processparameters;
	RTL_USER_PROCESS_INFORMATION processinformation={0};
    CPUHardware                 *pcpu = cpuhardware +cpu;

//STRACE("[cpu,ctx,mode,eip]", cpu, pcb->oldctx, pcb->oldmode, pcb->ntcontext.Eip)

    domain = spaces[pcb->oldctx]->domains[pcb->oldmode];

    if (domain->cpus[cpu]->ntcputhread) {
        BUGCHECK("CPU thread already exists");
    }

    if (domain->ntprocess == NULL) {
        // create process and first CPU thread for domain
        s = RtlDosPathNameToNtPathName_U(L"bootstrap.exe", &imgpath, NULL, NULL);
        FATALFAIL(s, "RtlDosPathnameToNtPathName_U");

        RtlInitUnicodeString(&imgname, L"bootstrap.exe");
        RtlInitUnicodeString(&dllpath, L"c:\\");
        s = RtlCreateProcessParameters(&processparameters, &imgname, &dllpath, 0, 0, 0, 0, 0, 0, 0);
        FATALFAIL(s, "RtlCreateProcessParameters");

        s = RtlCreateUserProcess(&imgpath,
                OBJ_CASE_INSENSITIVE,
                processparameters,
                NULL,
                NULL,
                NULL,
                FALSE,
                NULL,
                // in Windows XP we can provide the exception port here, and bypass the TCB privilege check
                spaceglobals.spaceport,
                &processinformation
            );
        FATALFAIL(s, "RtlCreateUserProcess");

        // We will fault in the missing pages on demand

        domain->ntprocess = processinformation.Process;
        ntcputhread = processinformation.Thread;
        cid = processinformation.ClientId;

        if (ntstartcontext.Eip == 0) {
            ntstartcontext.ContextFlags = CONTEXT_INTEGER | CONTEXT_CONTROL | CONTEXT_SEGMENTS;
            s = NtGetContextThread(ntcputhread, &ntstartcontext);
            FATALFAIL(s, "NtGetContextThread bootstrap");
        }

    } else {
        ntstartcontext.Eip   || BUGCHECK("StartNTCPU - ntstartcontext uninitialized");
        InitializeObjectAttributes(&obja, NULL, 0, NULL, NULL);
        s = NtCreateThread(&ntcputhread,
            THREAD_ALL_ACCESS,
            &obja,
            domain->ntprocess,
            &cid,
            &ntstartcontext,
            &teb,
            TRUE);

        FATALFAIL(s, "NtCreateThread");
    }

    domain->cpus[cpu]->ntcputhread   = ntcputhread;

    // hash ntcputhread into NTThreadHash table based on cid
    ptr = LookupHashEntry(NTThreadHash, ASIZEOF(NTThreadHash), HANDLEVALUE(cid.UniqueThread), &prevlink);
    if (ptr) BUGCHECK("StartNTCPU - CID already hashed");

    domain->cpus[cpu]->hash.value = HANDLEVALUE(cid.UniqueThread);
    domain->cpus[cpu]->hash.link = *prevlink;
    *prevlink = &domain->cpus[cpu]->hash;

    // run the thread, which should immediately call Resume
    pcpu->cpustate = Running;
    pcpu->currentchain = pcb;

    s = NtResumeThread(ntcputhread, NULL);
    FATALFAIL(s, "NtResumeThread");
}

//
//
//
NTSTATUS
StartCPU(
        ULONG       xxcpu,
        ULONG       boot_cpu,
        ULONG       boot_ctx,
        ULONG       boot_mode,
        ULONG_PTR   boot_pc,
        ULONG_PTR   boot_arg
        )
{
    CPUHardware    *pcpu;
    PCB            *pcb;

//STRACE("[cpu,ctx,mode,eip]", boot_cpu, boot_ctx, boot_mode, boot_pc)
    if (boot_cpu >= MAXCPUS) {
        return STATUS_ILLEGAL_INSTRUCTION;
    }

    pcpu = &cpuhardware[boot_cpu];

    if (pcpu->cpustate != Uninitialized && pcpu->cpustate != Halted) {
        return STATUS_ILLEGAL_INSTRUCTION;
    }

    pcb = malloc(sizeof(*pcb));
    pcb || FATALFAIL(STATUS_NO_MEMORY, "PCB in StartCPU");
    ZERO(pcb);

    pcpu->irql        = 0;

    pcb->oldctx        = boot_ctx;
    pcb->oldmode       = boot_mode;
    pcb->returnargflag = 0;
    pcb->ntcontext.ContextFlags = CONTEXT_INTEGER | CONTEXT_CONTROL;
    pcb->ntcontext.Eip = boot_pc;

    setselectors(&pcb->ntcontext);

    pcpu->currentchain = pcb;

    switch (pcpu->cpustate) {
        case Uninitialized: {
            NTThreadDescr  *ntthreaddescr;

            instantiatentthreaddescr(boot_ctx, boot_mode, boot_cpu);
            ntthreaddescr = spaces[boot_ctx]->domains[boot_mode]->cpus[boot_cpu];
            StartNTCPUThread(boot_cpu, ntthreaddescr, pcb);
            break;
        }

        case Halted:
            pcpu->cpustate = Running;
            (void) Resume(boot_cpu, 0);
            break;

        default:
            return STATUS_ILLEGAL_INSTRUCTION;
    }
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\SPACE\Defs-crt.h ===
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include <stdio.h>

//#include <stdlib.h>
void   __cdecl _exit(int);

//#include <malloc.h>
void *  __cdecl malloc(size_t);
void *  __cdecl free(void *);
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\SPACE\Debug.h ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#ifndef DEVICES

void
dump_Portal(
        Portal *p,
        int     emultype,
        char   *msg
    );

void
dump_Space(
        Space  *p,
        char   *msg
    );

void
dump_Domain(
        Domain *p,
        char   *msg
    );

void
dump_PCB(
        PCB   *p,
        char  *msg
    );

void
dump_CONTEXT(
        CONTEXT *p,
        char    *msg
    );

void
dump_data(
        PCHAR p,
        ULONG n,
        char *msg
    );

void
dump_CPUHardware(
        CPUHardware *p,
        char        *msg
    );

void
dump_EXCEPTION_MESSAGE(
        EXCEPTION_MESSAGE *p,
        char              *msg
    );

void
dump_PORT_MESSAGE(
        PPORT_MESSAGE p,
        char         *msg
    );

void
dump_ProcessVirtualRegions(
        HANDLE process,
        ULONG  start,
        ULONG  limit,
        char  *msg
    );

void
dump_Rootmap(
    ULONG  ctx,
    char  *msg
);

void
dump_Trapvector(
        Trapvector *t,
        char       *msg
    );

void
spacebreak(
        char        *why,
        CLIENT_ID   *pcid,
        char        *fcn,
        char        *file,
        int          line
    );

#define SPACEBREAK(why, pcid) spacebreak((why), (pcid), __FUNCTION__, __FILE__, __LINE__)

extern char *EMULStrings[];

#endif // !DEVICES


// DEBUG MACROS
extern char *TRACE_fmt;
extern char *STRACE_fmt;

#define MASH(a,b) (((a)<<16) | (b))
#define TRACE                   printf(TRACE_fmt,  __FUNCTION__, __LINE__, __FILE__);
#define STRACE(m,v0,v1,v2,v3)   printf(STRACE_fmt, __FUNCTION__, __LINE__, __FILE__, (m), (v0), (v1), (v2), (v3));
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\SPACE\Interrupt.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include "Defs.h"

void
InterruptCPU(
        ULONG       cpu,
        USHORT      targetcpu,
        UCHAR       interrupt,
        UCHAR       irql
    )
{
    NTSTATUS s;
    InterruptMsg    im;

//STRACE("[cpu, targetcpu, interrupt, irql]", cpu, targetcpu, interrupt, irql)
    im.hdr.u1.s1.DataLength       = sizeof(InterruptMsg) - sizeof(PORT_MESSAGE);
    im.hdr.u1.s1.TotalLength      = sizeof(InterruptMsg);
    im.hdr.u2.s2.Type             = LPC_DATAGRAM;
    im.hdr.u2.s2.DataInfoOffset   = 0;

    im.interrupt = interrupt;
    im.irql      = irql;
    im.cpu       = targetcpu;

    s = NtRequestPort( spaceglobals.spaceport, (PPORT_MESSAGE)&im );
	FATALFAIL(s, "NtRequestPort");
}

ULONG
ManageIRQL(
        ULONG      cpu,
        IRQLOps    irqlop,
        UCHAR      irql
        )
{
    CPUHardware    *pcpu        = cpuhardware + cpu;
    InterruptItem  *item;
    InterruptItem **plink;
    InterruptItem **savedplink;
    UCHAR           oirql       = pcpu->irql;
    UCHAR           highestirql;
    IRQLOps         op = irqlop;

//STRACE("[cpu, irqlop, newirql, oldirql]", cpu, irqlop, irql, oirql)
    switch(op) {
    case raiseirql:
        if (irql < oirql) irql = oirql;     // will set irql to at least oirql
        break;
    case setirql:
        break;
    case lowerirql:
        if (irql > oirql) irql = oirql;     // will set irql to no more than oirql
        break;
    }

    pcpu->irql = irql;

    // if the IRQL did not go lower, then none of the pending interrupts
    // will fire, and we can just return
    if (irql >= oirql)
        return oirql;

    // search for the highest-priority queued interrupt deepest in queue.  if we find one that 
    // can be interrupted we will prevent any code running before the interrupt is delivered
    plink = &pcpu->queuehead;
    savedplink = NULL;
    highestirql = 0;
    while ((item = *plink)) {
        if (item->irql >= highestirql) {
            highestirql = item->irql;
            savedplink = plink;
        }
        plink = &item->link;
    }

    // if we found one, dequeue and set it as the pending interrupt on the current CPU
    if (savedplink) {
        item = *savedplink;
        *savedplink = item->link;
        item->link = NULL;
        pcpu->pendinginterrupt = item;
    }

    return oirql;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\SPACE\Devices.h ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include <nt.h>
#include <ntrtl.h>

#include "Defs-crt.h"
#include "Config.h"

//
// Definitions for IO Device Emulation
//

typedef ULONGLONG (*DEVICEACCESS)        (ULONG cpu, int op, ULONG deviceregister, ULONG value, ULONG valuex);
typedef VOID      (*DMACOMPLETECALLBACK) (ULONG cpu, ULONG deviceid, ULONG bytecount, PVOID callbackcontext);

NTSTATUS    StartDMA        (ULONG cpu, ULONG deviceid, PCHAR devicememory, ULONG_PTR base, ULONG bytecount,
                             BOOLEAN writememory, DMACOMPLETECALLBACK callback, PVOID callbackcontext);

void        InterruptCPU    (ULONG cpu, USHORT targetcpu, UCHAR interrupt, UCHAR irql);

NTSTATUS    RegisterDevice  (ULONG cpu, ULONG deviceid, DEVICEACCESS deviceroutine, ULONG interrupt);
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\SPACE\Emulation.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include "Defs.h"

void
UnexpectedMessage(
        PORT_MESSAGE        *msg,
        EXCEPTION_MESSAGE   *xmsg,
        BOOLEAN              fatal
    )
{
    NTSTATUS s;

    printf("Unexpected message: type=%d ClientId=%d/%d (%x/%x)",
            msg->u2.s2.Type, msg->ClientId.UniqueProcess, msg->ClientId.UniqueThread,
                             msg->ClientId.UniqueProcess, msg->ClientId.UniqueThread);
    if (xmsg)
        printf("  Api %d ReturnedStatus %x FirstChance %d\n", xmsg->ApiNumber, xmsg->ReturnedStatus, xmsg->FirstChance);
    printf("\n");

    if (fatal)
        die("Unexpected message\n", NULL, 0);

    s = NtReplyPort(spaceglobals.spaceport, xmsg? (PPORT_MESSAGE)xmsg : msg);
    FATALFAIL(s, "UnexpectedExceptionMessage: NtReplyPort");
}


void EmulateTrap(ULONG cpu, ULONG xcode, ULONG arg0, ULONG arg1);

typedef enum {
    EMULRETURNING,
    EMULCOMPLETED,
    EMULILLEGAL,
    EMULDENIED,
    EMULINTERRUPTPENDING
} EMULRESULT;

EMULRESULT EmulateHardware(NTThreadDescr *ntthreaddescr, ULONG trapdecodeiwhole);

//
//
//
UCHAR msgbuffer[256];

void
SPACEEmulation()
{
    PPORT_MESSAGE       msg = (PPORT_MESSAGE)msgbuffer;
    NTSTATUS            s;

    for (;;) {
		s = NtReplyWaitReceivePort(spaceglobals.spaceport, NULL, NULL, msg);
        FATALFAIL(s, "NtReplyWaitReceivePort");

//------- DEBUG
if (1) {
 EXCEPTION_MESSAGE *x = (EXCEPTION_MESSAGE *)msg;
 EXCEPTION_RECORD  *r = &x->ExceptionRecord;
 NTThreadDescr     *t;
 NTSTATUS           s;
 CONTEXT            ntctx;
 int icpu = -1;

 t = LookupNTThread(msg->ClientId.UniqueThread);
 if (t) icpu = t->cpu;

 printf("\nTOP-OF-LOOP:  CPU %2d. msg type %x from CIDs %d./%d.  <X: code/addr %08x/%08x  info[] %08x/%08x>\n",
    icpu, msg->u2.s2.Type, msg->ClientId.UniqueProcess, msg->ClientId.UniqueThread,
    r->ExceptionCode, r->ExceptionAddress, r->ExceptionInformation[0], r->ExceptionInformation[1]);

 ntctx.ContextFlags = CONTEXT_INTEGER | CONTEXT_CONTROL;
 if (t && t->ntcputhread) {
   s = NtGetContextThread(t->ntcputhread, &ntctx);
   if (NT_SUCCESS(s)) {
     printf(" REGISTERS: eip=%x esp/ebp=%x/%x eax=%x ebx=%x ecx=%x edx=%x edi=%x esi=%x\n",
         ntctx.Eip, ntctx.Esp, ntctx.Ebp, ntctx.Eax, ntctx.Ebx, ntctx.Ecx, ntctx.Edx, ntctx.Edi, ntctx.Esi);
     dump_CONTEXT(&ntctx, "LPC_EXCEPTION");
   }
 }
}
//-------
        //
        // Figure out what kind of message this is, and update the CPUHardware[] state appropriately
        //
        switch (msg->u2.s2.Type) {
		case LPC_EXCEPTION:
        {
  			EXCEPTION_MESSAGE *xmsg;
            EXCEPTION_RECORD  *xrec;
            CPUHardware       *pcpu;

            NTThreadDescr     *ntthreaddescr;
            ULONG              cpu;
            ULONG_PTR          arg0, arg1;

  			xmsg = (EXCEPTION_MESSAGE *) msg;
  			xmsg->ReturnedStatus = STATUS_SUCCESS;

            xrec = &xmsg->ExceptionRecord;

            // Figure out which CPU from the thread id
            ntthreaddescr = LookupNTThread(xmsg->hdr.ClientId.UniqueThread);
            if (ntthreaddescr == NULL) {
                UnexpectedMessage(msg, xmsg, FALSE);
                continue;
            }

            cpu = ntthreaddescr->cpu;
            pcpu = cpuhardware + cpu;

            // ASSERT(spaces[pcpu->ctx]->domains[pcpu->mode]->cpus[cpu]->hash.value == (ULONGLONG)xmsg->hdr.ClientId.UniqueThread);
            if (spaces[pcpu->ctx]->domains[pcpu->mode]->cpus[cpu]->hash.value != HANDLEVALUE(xmsg->hdr.ClientId.UniqueThread))
                FATALFAIL(STATUS_UNSUCCESSFUL, "clientid check");

            ntthreaddescr->ntreplymessage = *xmsg;
            ntthreaddescr->trappednotinterrupted = 1;

            switch (xmsg->ApiNumber) {
            case 0: // DbgKmExceptionApi
                // If Interrupted, then we have already handed the cpu to an interrupt
                // Just ignore this message and when the interrupt resumes the instruction
                // that caused this message will re-execute and cause it again.
                // Restarting is idempotent, but we don't want to fail to make progress or do this excessively
                // so we only retry the first interrupt, and only if the current EIP is the same as at the time of the interrupt.
                if (ntthreaddescr->trappednotinterrupted == 0 && ntthreaddescr->interrupteip) {
                    CONTEXT ntcontext;
                    ntcontext.ContextFlags = CONTEXT_INTEGER | CONTEXT_CONTROL;

                    pcpu->currentchain || BUGCHECK("NtGetContextThread for msg");
                    s = NtGetContextThread(ntthreaddescr->ntcputhread, &ntcontext);
                    FATALFAIL(s, "NtGetContextThread for msg");

                    (ntthreaddescr->interrupteip == pcpu->currentchain->ntcontext.Eip) || BUGCHECK("interrupteip");
                    if (ntthreaddescr->interrupteip == ntcontext.Eip) {
                        ntthreaddescr->interrupteip = 0;
                        s = NtReplyPort(spaceglobals.spaceport, (PPORT_MESSAGE)xmsg);
                        FATALFAIL(s, "SPACEEmulation: NtReplyPort");
                        continue;
                    }
                }
                ntthreaddescr->interrupteip = 0;

                switch (xrec->ExceptionCode) {
                case STATUS_INVALID_LOCK_SEQUENCE:  // SPACE Hardware Emulation
                    {
                        TrapDecode      trapdecode;

                        trapdecode.iwhole = getinstruction(ntthreaddescr->domain->ntprocess, xrec->ExceptionAddress);

                        // EmulateHardware
                        if (trapdecode.hwemulation) {
                            EMULRESULT er = EmulateHardware(ntthreaddescr, trapdecode.iwhole);
                            switch (er) {
                            case EMULCOMPLETED:
                                continue;

                            case EMULRETURNING:
                                ntthreaddescr->trappednotinterrupted  || BUGCHECK("EMULRETURNING from interrupt");
                                s = NtReplyPort(spaceglobals.spaceport, (PPORT_MESSAGE)xmsg);
                                continue;

                            case EMULINTERRUPTPENDING: {
                                    InterruptItem *item = pcpu->pendinginterrupt;
                                    pcpu->pendinginterrupt = NULL;

                                    // dispatch the pending interrupt (i.e we lowered the IRQL)
                                    EmulateTrap(cpu, STATUS_SPACE_INTERRUPT, item->interrupt, item->irql);
                                    free(item);
                                    continue;
                                }
                                continue;

                            case EMULDENIED:
                                // EmulateTrap
                                EmulateTrap(cpu, STATUS_ACCESS_DENIED, trapdecode.iwhole, 0);
                                continue;

                            case EMULILLEGAL:
                                // EmulateTrap
                                EmulateTrap(cpu, STATUS_ILLEGAL_INSTRUCTION, trapdecode.iwhole, 0);
                                continue;
                            }
                            BUGCHECK("NOT REACHABLE - HW Emulation");
                        }

                        // EmulateTrap for real illegal instruction
                        EmulateTrap(cpu, xrec->ExceptionCode, trapdecode.iwhole, 0);
                    }
                    continue;

                case STATUS_ILLEGAL_INSTRUCTION:
                    {
                        TrapDecode      trapdecode;

                        trapdecode.iwhole = getinstruction(ntthreaddescr->domain->ntprocess, xrec->ExceptionAddress);
                        if (trapdecode.servicecall)
                            EmulateTrap(cpu, xrec->ExceptionCode, trapdecode.iwhole, 0);
                        else
                            EmulateTrap(cpu, xrec->ExceptionCode, 0, 0);
                    }
                    continue;

                //
                // XXX: For future implementation of CC breakpoints
                // XXX: will skip breakpoints, so only for explicitly coded breakpoints (at present)
                //
                case STATUS_BREAKPOINT:
                {
                    CONTEXT tcontext = { 0 };
                    tcontext.ContextFlags = CONTEXT_INTEGER | CONTEXT_CONTROL;
                    s = NtGetContextThread(ntthreaddescr->ntcputhread, &tcontext);
                    FATALFAIL(s, "NtGetContextThread at breakpoint");
                    dump_CPUHardware(pcpu, "BREAKPOINT CPUHardware");
                    dump_CONTEXT(&tcontext, "BREAKPOINT tcontext");

                    SPACEBREAK("breakpoint", NULL);
                    tcontext.Eip++;     // skip explicitly coded breakpoint
                    s = NtSetContextThread(ntthreaddescr->ntcputhread, &tcontext);
                    FATALFAIL(s, "NtSetContextThread at breakpoint");
                    continue;
                }

                case STATUS_ACCESS_VIOLATION:
                    arg0 = xrec->ExceptionInformation[0];
                    arg1 = xrec->ExceptionInformation[1];
//------- DEBUG
STRACE("LPC_EXCEPTION: ACCESS_VIOLATION [xcode xaddr x0 x1]", xrec->ExceptionCode, xrec->ExceptionAddress,  arg0, arg1)
STRACE("                       current: [cpu ctx mode irql]", cpu, pcpu->ctx, pcpu->mode, pcpu->irql)
if (1) {
    CONTEXT tcontext = { 0 };
    tcontext.ContextFlags = CONTEXT_INTEGER | CONTEXT_CONTROL;
    s = NtGetContextThread(ntthreaddescr->ntcputhread, &tcontext);
    FATALFAIL(s, "NtGetContextThread at breakpoint");
    dump_CPUHardware(pcpu, "LPC_EXCEPTION CPUHardware");
    dump_CONTEXT(&tcontext, "LPC_EXCEPTION context");
}
SPACEBREAK("ACCESS VIOLATION", NULL);
//-------
                    EmulateTrap(cpu, xrec->ExceptionCode, arg0, arg1);
                    continue;

                default: 
                    UnexpectedMessage(msg, xmsg, FALSE);
                    continue;
                }
                BUGCHECK("NOT REACHABLE - xcode");
                continue;

            default:
                UnexpectedMessage(msg, xmsg, FALSE);
                continue;
            }
            BUGCHECK("NOT REACHABLE - xcode");
            continue;
        }
        BUGCHECK("NOT REACHABLE - LPC_EXCEPTION");
        continue;

		case LPC_DATAGRAM:      // used for delivering interrupts to a CPU
        {
            NTThreadDescr     *ntthreaddescr;
            InterruptMsg      *imsg             = (InterruptMsg *)msg;
            CPUHardware       *pcpu             = cpuhardware + imsg->cpu;

            ntthreaddescr = spaces[pcpu->ctx]->domains[pcpu->mode]->cpus[imsg->cpu];

            // suspend the thread
            // note that if it has already taken an exception and we just haven't seen the message
            // we'll ignore it when we do, and get it again when we re-execute the instruction later
            s = NtSuspendThread(ntthreaddescr->ntcputhread, NULL);
            FATALFAIL(s, "NtSuspendThread for msg");

            ntthreaddescr->trappednotinterrupted = 0;

            if (imsg->irql > pcpu->irql) {
                UCHAR oldirql = ManageIRQL(imsg->cpu, setirql, imsg->irql);
                EmulateTrap(imsg->cpu, STATUS_SPACE_INTERRUPT, imsg->interrupt, oldirql);
                (void) ManageIRQL(imsg->cpu, setirql, oldirql);
                !pcpu->pendinginterrupt  || BUGCHECK("pending interrupt within LPC_DATAGRAM processing");

            } else {
                InterruptItem  **queue = &pcpu->queuehead;
                InterruptItem   *item;

                // push interrupt onto CPU's queue for later dispatch
                item = malloc(sizeof(*item));
                item || FATALFAIL(STATUS_NO_MEMORY, "InterruptQueueItem");
                ZERO(item);

                item->irql = imsg->irql;
                item->interrupt = imsg->interrupt;
                item->link = *queue;
                *queue = item;
            }
        }
        continue;

        case LPC_CLIENT_DIED:
        case LPC_ERROR_EVENT:
        default:
            UnexpectedMessage(msg, NULL, FALSE);
            continue;
        }
        BUGCHECK("NOT REACHABLE - LPC_EXCEPTION");
        continue;
    }
}

//
// Free any resources that will not be released with our demise
//
void
cleanup()
{
    ULONG ctx;

    // kill all the processes we have created
    for (ctx = 0;  ctx <= spaceglobals.highestctx;  ctx++)
        CleanCtx(0, ctx);
}

//
// handle a trap/exception/fault/interrupt other than HW emulations
//
void
EmulateTrap(
        ULONG       cpu,
        ULONG       xcode,
        ULONG       arg0,
        ULONG       arg1
    )
{
    CPUHardware    *pcpu;
    ULONG           ctx, mode;
    PCB            *pcb;
    PCB            *temppcb;
    NTSTATUS        s;
    Portal         *portal;
    TrapDecode      trapdecode;
    NTThreadDescr  *oldntthreaddescr;
    NTThreadDescr  *newntthreaddescr;

    ULONG           oldirql;
    ULONG           newirql;
    ULONG           eipadjust       = 0;
    ULONG           faultinstr      = 0;
    ULONG           interruptcall   = 0;
    ULONG           servicetrap     = 0;
    ULONG           accessviolation = 0;
    ULONG           trapindex;

    PCBCalltype     calltype        = unknowncall;
    CONTEXT         newntcontext    = { 0 };
    ULONG           arg[5];

    arg[0] = arg[1] = arg[2] = arg[3] = arg[4] = 0;

    pcpu    = cpuhardware + cpu;
    ctx     = pcpu->ctx;
    mode    = pcpu->mode;
    oldirql = pcpu->irql;
    newirql = oldirql;

    // assertion
       spaces[ctx]
    && spaces[ctx]->domains[mode]
    && spaces[ctx]->domains[mode]->cpus[cpu]
    && spaces[ctx]->domains[mode]->cpus[cpu]->ntcputhread
    || BUGCHECK("internal EmulateTrap");

    oldntthreaddescr =  spaces[ctx]->domains[mode]->cpus[cpu];

    pcb = malloc(sizeof(*pcb));
    pcb || FATALFAIL(STATUS_NO_MEMORY, "PCB");
    ZERO(pcb);

    pcb->ntcontext.ContextFlags = CONTEXT_INTEGER | CONTEXT_CONTROL;
    s = NtGetContextThread(oldntthreaddescr->ntcputhread, &pcb->ntcontext);
    FATALFAIL(s, "NtGetContextThread for msg");

    switch (xcode) {
    case STATUS_SPACE_INTERRUPT:
        calltype          = interruptcall;
        trapindex         = arg0;                 // interrupt
        newirql           = arg1;

        (newirql > oldirql) || BUGCHECK("EmulateTrap: SPACE_INTERRUPT:  lowering IRQL");

        pcpu->irql = (UCHAR)newirql;

        // if we got here through a real interrupt, record Eip -- in case
        // we get an LPC trap message sent before we suspended the thread
        if (oldntthreaddescr->trappednotinterrupted == 0)
            oldntthreaddescr->interrupteip = pcb->ntcontext.Eip;
        portal = TrapToPortal(ctx, mode, trapintr, trapindex);
        break;

    case STATUS_ILLEGAL_INSTRUCTION:
    case STATUS_INVALID_LOCK_SEQUENCE:
        calltype          = servicetrap;
        trapdecode.iwhole = arg0;

        if (!trapdecode.servicecall) {
            portal = TrapToPortal(ctx, mode, trapexcept, TRAPEXCEPT_ILLEGALOP);
            break;
        }

        // system service request
        eipadjust         = trapdecode.skiplength;
        trapindex         = trapdecode.operation;   // system service index

        get5args(arg, &pcb->ntcontext);

        portal = TrapToPortal(ctx, mode, trapserv, trapindex);
        arg[3]            = portal->arg;
        set4args(&newntcontext, arg);
        break;

    case STATUS_ACCESS_VIOLATION:
        calltype          = accessviolation;
        eipadjust         = 0;                    // re-execute faulting instruction

        arg[0]            = arg0;                 // EXCEPTION_{READ,WRITE,EXECUTE}_FAULT
        arg[1]            = arg1;                 // faulting address

        portal = TrapToPortal(ctx, mode, trapvaddr, arg1);
        arg[2]            = portal->arg;

        set4args(&newntcontext, arg);
        break;

    case STATUS_ACCESS_DENIED:
        eipadjust         = 0;                    // re-execute faulting instruction
        portal = TrapToPortal(ctx, mode, trapexcept, TRAPEXCEPT_ACCESSDENIED);
        break;
    }

    pcb->pcbcalltype      = calltype;

    pcb->oldctx           = ctx;
    pcb->oldmode          = mode;
    pcb->oldirql          = oldirql;

    pcb->chainlink        = pcpu->currentchain;
    pcpu->currentchain    = pcb;
    pcpu->ctx             = portal->ctx;
    pcpu->mode            = (UCHAR)portal->mode;
    pcpu->irql            = (UCHAR)newirql;

    pcb->ntcontext.Eip   += eipadjust;

    portal || BUGCHECK("internal EmulateTrap with no portal");

    // get a CONTEXT structure by allocating a PCB, in case we need to start a new NT thread
    temppcb = malloc(sizeof(*temppcb));
    temppcb || FATALFAIL(STATUS_NO_MEMORY, "PCB");
    ZERO(temppcb);

    temppcb->ntcontext.ContextFlags = CONTEXT_INTEGER | CONTEXT_CONTROL;
    temppcb->ntcontext.Eip = portal->handler;

    setselectors(&temppcb->ntcontext);

    // find the NT thread for the current CPU in the domain we are returning to
    // it won't exist if nothing has ever run there before
    instantiatentthreaddescr(portal->ctx, portal->mode, cpu);
    newntthreaddescr      = spaces[portal->ctx]->domains[portal->mode]->cpus[cpu];

    if (newntthreaddescr->ntcputhread == NULL) {
        // Starting the CPU will push pcb onto the chain and then resume it
        StartNTCPUThread(cpu, newntthreaddescr, temppcb);
        return;
    }

    // restore context from temporary PCB onto an existing ntcputhread
    s = NtSetContextThread( newntthreaddescr->ntcputhread, &temppcb->ntcontext );
    FATALFAIL(s, "NtSetContextThread portal traversal");

    // free the temporary pcb
    free(temppcb);
//------- DEBUG
STRACE("Portal Traversal [portal pcb newEip trappednotinterrupted] (dumping)", portal, pcb, portal->handler, newntthreaddescr->trappednotinterrupted);
dump_CPUHardware(pcpu, "Portal Traversal: CPU context including old (PCB) CONTEXT");
dump_CONTEXT(&newntcontext, "Portal Traversal:  new CPU context");
//-------
    if (newntthreaddescr->trappednotinterrupted) {
        s = NtReplyPort(spaceglobals.spaceport, (PPORT_MESSAGE)&newntthreaddescr->ntreplymessage);
        FATALFAIL(s, "NtReplyPort portal traversal");
    } else {
        s = NtResumeThread(newntthreaddescr->ntcputhread, NULL);
        FATALFAIL(s, "NtResumeThread portal traversal");
    }
}

EMULRESULT
EmulateHardware(
        NTThreadDescr     *ntthreaddescr,
        ULONG              trapdecodeiwhole
        )
{
    CONTEXT         ntcontext       = { 0 };
    NTSTATUS        status;

    Portal         *portal;
    TrapDecode      trapdecode;
    ULONG           eipadjust       = 0;
    ULONG           trapindex;
    ULONG           arg[5];
    ULONGLONG       rvalue;
    ULONG           cpu             = ntthreaddescr->cpu;
    CPUHardware    *pcpu            = cpuhardware + cpu;

    arg[0] = arg[1] = arg[2] = arg[3] = arg[4] = 0;

    trapdecode.iwhole = trapdecodeiwhole;
    eipadjust = trapdecode.skiplength;
    trapindex = trapdecode.operation;   // HW emulation index

    ntcontext.ContextFlags = CONTEXT_INTEGER | CONTEXT_CONTROL;
    status = NtGetContextThread(ntthreaddescr->ntcputhread, &ntcontext);
    FATALFAIL(status, "NtGetContextThread for hw emul");

    get5args(arg, &ntcontext);
    ntcontext.Eip   += eipadjust;

    portal = TrapToPortal(pcpu->ctx, pcpu->mode, trapemul, trapindex);

    // permission was denied
    if (! ACCESSOK(portal->protmask, pcpu->mode))
        return EMULDENIED;

    status = STATUS_SUCCESS;

    switch (trapindex) {
    case TRAPEMUL_Noop:
//STRACE("TRAPEMUL_Noop", 0, 0, 0, trapindex)
        break;

    case TRAPEMUL_MapMemory:
        {   XMapMemory *u = (XMapMemory *) arg;
            status = MapMemory(cpu, u->ctx, u->vpage, u->ppage, u->readmask, u->writemask);
        }
        break;

    case TRAPEMUL_MapIO:
        {   XMapIO *u = (XMapIO *) arg;
            status = MapIO(cpu, u->deviceid, u->writable, u->iospacepage, u->physpage);
        }
        break;

    case TRAPEMUL_MapTrap:
        {   XMapTrap *u = (XMapTrap *) arg;
            status = MapTrap(cpu, u->ctx, u->traptype, u->global, u->indexbase, u->indexlimit, u->portalid);
        }
        break;

    case TRAPEMUL_CreatePortal:
        {   XCreatePortal *u = (XCreatePortal *) arg;
            rvalue = CreatePortal(cpu, u->type, u->mode, u->irql, u->ctx, u->handler, u->protmask);
        }
        retresultarg(&ntcontext, rvalue);
        break;

    case TRAPEMUL_DestroyPortal:
        status = DestroyPortal(cpu, arg[0]);
        break;

    case TRAPEMUL_CleanCtx:
        status = CleanCtx(cpu, arg[0]);
        break;

    case TRAPEMUL_Resume:
        status = Resume(cpu, makequad(arg[0], arg[1]));
        return NT_SUCCESS(status)?  EMULCOMPLETED : EMULILLEGAL;

    case TRAPEMUL_Suspend:
        rvalue = Suspend(cpu);
        retresultarg(&ntcontext, rvalue);
        break;

    case TRAPEMUL_Unsuspend:
        status = Unsuspend(cpu, makequad(arg[0], arg[1]));
        break;

    case TRAPEMUL_PopCaller:
        status = PopCaller(cpu);
        break;

    case TRAPEMUL_DiscardToken:
        status = DiscardToken(cpu, makequad(arg[0], arg[1]));
        break;

    case TRAPEMUL_StartCPU:
        {   XStartCPU *u = (XStartCPU *) arg;
            status = StartCPU(cpu, u->boot_cpu, u->boot_ctx, u->boot_mode, u->boot_pc, u->boot_arg);
        }
        break;

    case TRAPEMUL_InterruptCPU:
        {   XInterruptCPU *u = (XInterruptCPU *) arg;
            InterruptCPU(cpu, u->targetcpu, u->interrupt, u->irql);
        }
        break;

    case TRAPEMUL_AccessDevice:
        {   XAccessDevice *u = (XAccessDevice *) arg;
            rvalue = AccessDevice(cpu, u->deviceid, u->op, u->deviceregister, u->value, u->valuex);
        }
        retresultarg(&ntcontext, rvalue);
        break;

    case TRAPEMUL_ManageIRQL:
        {   XManageIRQL *u = (XManageIRQL *) arg;
            rvalue = ManageIRQL(cpu, u->irqlop, u->irql);
            if (cpuhardware[cpu].pendinginterrupt)
                EMULINTERRUPTPENDING;
        }
        retresultarg(&ntcontext, rvalue);
        break;

    case TRAPEMUL_HaltCPU:
        if (cpuhardware[cpu].currentchain)
            return EMULILLEGAL;
        printf("Processor halted: %08x\n", arg[0]);
        return EMULCOMPLETED;

    case TRAPEMUL_GetSPACEParams:
        {   XSPACEParams *u = (XSPACEParams *) arg;
            u->params = spaceparams;
            ret5args(&ntcontext, u->registers);
        }
        break;

    case TRAPEMUL_Break:
        {   XSPACEBreak *u = (XSPACEBreak *) arg;
            printf("Break: %08x: %.16s\n", u->breakvalue, u->breakmsg);
            SPACEBREAK("<break-in>", NULL);
        }
        break;

    default:
        return EMULILLEGAL;
    }

    if (!NT_SUCCESS(status))
        return EMULILLEGAL;

    // returning result
    status = NtSetContextThread(ntthreaddescr->ntcputhread, &ntcontext);
    FATALFAIL(status, "NtSetContextThread for SPACE hardware emulation");

    return EMULRETURNING;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\SPACE\IO.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include "Defs.h"

Hashentry *DeviceHash[31];

//
// Record this mapping, which the DMA routine may later use to perform DMA
// Changing while a DMA operation is in progress will cause an exception
//
NTSTATUS
MapIO(
        ULONG       cpu,
        UCHAR       deviceid,
        UCHAR       writable,
        ULONG       iospacepage,
        ULONG       physpage
     )
{
    ULONG        readmask;
    ULONG        writemask;

//STRACE("[deviceid, writable, iospacepage, physpage]", deviceid, writable, iospacepage, physpage)
    if (deviceid >= MAXDEVICES)
        return STATUS_ILLEGAL_INSTRUCTION;

    if (physpage >= spaceparams.nphysmempages && physpage != NTSPACE_INVALIDPAGE)
        return STATUS_ILLEGAL_INSTRUCTION;

    if (physpage < spaceparams.nphysmempages) {
        readmask = (1 << deviceid);
        writemask = writable? readmask : 0;
    } else if (physpage == NTSPACE_INVALIDPAGE) {
        readmask = writemask = 0;
    } else {
        return STATUS_ILLEGAL_INSTRUCTION;
    }

    return MapMemory(cpu, IOCTX, iospacepage, physpage, readmask, writemask);

    return STATUS_SUCCESS;
}

ULONGLONG
AccessDevice(
        ULONG      cpu,
        USHORT     deviceid,
        UCHAR      op,
        UCHAR      deviceregister,
        ULONG      value,
        ULONG      valuex
      )
{
    Hashentry  *ptr;
    Device     *dev;

    ptr = LookupHashEntry(DeviceHash, ASIZEOF(DeviceHash), deviceid, NULL);
//STRACE("[deviceid, op, deviceregister, ptr]", deviceid, op, deviceregister, ptr)

    if (ptr == NULL)
        return STATUS_NO_SUCH_DEVICE;

    dev = CONTAINING_RECORD(ptr, Device, hash);
    dev->accessfcn || BUGCHECK("no device accessfcn");
    return (dev->accessfcn)(cpu, op, deviceregister, value, valuex);
}

//
// Hardware devices
//      DMA, IRQLs, DEVICE REGISTERS
//
NTSTATUS
RegisterDevice(
        ULONG         cpu,
        ULONG         deviceid,
        DEVICEACCESS  deviceroutine,
        ULONG         interrupt
    )
{
    Hashentry  *ptr;
    Hashentry **prevlink = NULL;
    Device     *dev;

    ptr = LookupHashEntry(DeviceHash, ASIZEOF(DeviceHash), deviceid, &prevlink);
    if (ptr) {
        return STATUS_DEVICE_ALREADY_ATTACHED;
    }

    dev = malloc(sizeof(*dev));
    if (dev == NULL) {
        return STATUS_NO_MEMORY;
    }
    ZERO(dev);

    dev->hash.value = deviceid;
    dev->hash.link = *prevlink;
    dev->accessfcn = deviceroutine;

    *prevlink = &dev->hash;

//STRACE("[deviceid, deviceroutine, interrupt, dev]", deviceid, deviceroutine, interrupt, dev)
    return STATUS_SUCCESS;
}

//
// Emulate a hardware operation to do DMA
// to/from the devicememory from/to physical memory.
//

struct DMAargs {
        ULONG               cpu;
        ULONG               deviceid;
        PCHAR               vaddr;
        PCHAR               daddr;
        UCHAR               synchronous;
        SIZE_T              count;
        ULONG               todevice;
        DMACOMPLETECALLBACK callback;
        PVOID               callbackcontext;
};

// run a background thread to do the copy to/from the devicemem to physical memory
// TODO: use a pool of threads rather than creating threads on demand
void
DMAThread(
        struct DMAargs  *argp
    )
{
    PCHAR       vaddr;
    PCHAR       daddr;
    SIZE_T      count;
    ULONG       todevice;
    PCHAR       evaddr;
    NTSTATUS    s;

    vaddr    = argp->vaddr;
    daddr    = argp->daddr;
    count    = argp->count;
    todevice = argp->todevice;
    evaddr   = vaddr + count;

    if (todevice)
        memcpy(daddr, vaddr, count);    // dst, src, len
    else
        memcpy(vaddr, daddr, count);

    for (evaddr = vaddr + count;  vaddr < evaddr;  vaddr += NTSPACE_PAGESIZE) {
        s = NtUnmapViewOfSection ( NtCurrentProcess(), (PVOID)vaddr );
        FATALFAIL(s, "Unmap DMA memory");
    }

    if (argp->callback)
        (argp->callback)(argp->cpu, argp->deviceid, count, argp->callbackcontext);
    free(argp);

    if (!argp->synchronous)
        NtTerminateThread(NtCurrentThread(), STATUS_SUCCESS);
}

NTSTATUS
StartDMA(
        ULONG       cpu,
        ULONG       deviceid,
        PCHAR       devicememory,
        ULONG_PTR   base,
        ULONG       bytecount,
        BOOLEAN     writephysmem,
        DMACOMPLETECALLBACK callback,       // if NULL, synchronously copy the data
        PVOID callbackcontext
    )
{
    ULONG_PTR       pagebase;
    ULONG           pageoffset;
    ULONG           encompasscount;
    ULONG           npages;
    NTSTATUS        s;

    PCHAR           vaddr;
    PCHAR           basevaddr;
    ULONG           pageaccess;
    SIZE_T          pagesize;
    SIZE_T          totalsize;
    LARGE_INTEGER   ilarge;
    Mapping        *map;
    struct DMAargs *argp;
    ULONG           i;

//STRACE("[deviceid, devicememory, base, W/bytecount", deviceid, devicememory, base, (writephysmem<<31)|bytecount)
    // establish the counts and addresses
    pagebase = (base & ~(NTSPACE_PAGESIZE - 1));
    pageoffset = (base & (NTSPACE_PAGESIZE - 1));
    encompasscount = bytecount + pageoffset;
    npages = COUNTBY(encompasscount, NTSPACE_PAGESIZE);
    pageaccess = writephysmem? PAGE_READWRITE : PAGE_READONLY;

    // Check that all the mappings are valid
    for (i = 0;  i < npages;  i++) {
        map = VPageToMap(cpu, iospace, ADDR2PAGE(pagebase));
        if (!map)
            return STATUS_ACCESS_VIOLATION;
    }

    // allocate the structure for the parameters to the DMA thread
    argp = malloc(sizeof(*argp));
    argp || FATALFAIL(STATUS_NO_MEMORY, "No memory for DMA args");
    ZERO(argp);

    // find a sufficiently large virtual address space region we can use
    totalsize = npages * NTSPACE_PAGESIZE;
    vaddr = NULL;
    s = NtAllocateVirtualMemory(NtCurrentProcess(), (PVOID) &vaddr, 0, &totalsize, MEM_RESERVE, pageaccess);
    FATALFAIL(s, "Allocate DMA addresses");

    basevaddr = (PCHAR) vaddr;

    // now that we know vaddr, release the memory
    s = NtFreeVirtualMemory(NtCurrentProcess(), (PVOID) &vaddr, &totalsize, MEM_RELEASE);
    FATALFAIL(s, "Free DMA addresses");

    // map the physical pages into our address space
    pagesize   = NTSPACE_PAGESIZE;
    for (i = 0;  i < npages;  i++) {
        map = VPageToMap(cpu, iospace, ADDR2PAGE(pagebase));
        ilarge.QuadPart = PAGE2ADDR(map->physpage);

        s = NtMapViewOfSection ( spaceglobals.physmemsection, NtCurrentProcess(), (PVOID) &vaddr, 0,
                        NTSPACE_PAGESIZE, &ilarge, &pagesize, ViewUnmap, 0, pageaccess);
        FATALFAIL(s, "Map DMA memory");

        vaddr += NTSPACE_PAGESIZE;
        pagebase += NTSPACE_PAGESIZE;
    }

    argp->cpu      = cpu;
    argp->deviceid = deviceid;
    argp->vaddr    = basevaddr + pageoffset;
    argp->daddr    = devicememory;
    argp->count    = bytecount;
    argp->todevice = !writephysmem;
    argp->callback = callback;
    argp->callbackcontext = callbackcontext;

    //
    // If no callback routines was specified, then do the copy synchronously
    //
    if (callback == NULL) {
        argp->synchronous = 1;
        DMAThread(argp);
        return STATUS_SUCCESS;
    }

    //
    // Use an NT thread to run the DMA
    // TODO: use a pool of threads rather than creating them each time.
    //
    s = RtlCreateUserThread(NtCurrentProcess(), NULL, FALSE, 0, 0, 0, (PVOID)DMAThread, (PVOID)argp, NULL, NULL);
    FATALFAIL(s, "NtCreateThread for DMA");

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\SPACE\Defs.h ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdio.h>
#include "Defs-crt.h"

#define SPACE_EXE
#include "..\INC\SpaceOps.h"

#include "Config.h"
#include "TrapValues.h"

#define ASIZEOF(x) (sizeof(x)/sizeof((x)[0]))
#define K *1024
#define M *1024*1024

#define ZERO(x) RtlZeroMemory((x), sizeof(*(x)))

//
// General Definitions
//

#define COUNTBY(a,s)  (((a) + ((s)-1)) / (s))
#define ROUNDUP(a,s)  ((s) * COUNTBY(a,s))

//
// Definitions for Util
//

#define HASH(value,tablesize)     ((value) % (tablesize))

typedef struct hashentry{
    struct hashentry   *link;
    ULONGLONG           value;
} Hashentry;

//
// Returns an object from a hash table
//
Hashentry *
LookupHashEntry(
        Hashentry   *hashtable[],
        ULONG        tablesize,
        ULONGLONG    value,
        Hashentry ***pprevlink
    );

#define HANDLEVALUE(h) ((ULONGLONG)((ULONG)h >> 3))    // used for has values that have low order bits off

//
// Definitions for LoadKernel
//

// Structure used by LoadKernel to describe the sections of BasicOZ
typedef struct {
    ULONGLONG   VirtualAddress;
    ULONG       nPages;
    ULONG       Writable;
    ULONG       PhysicalBasepage;
} Section;

NTSTATUS LoadKernel(PWCHAR kernelname, PULONG_PTR entry, Section kernelsections[], int *nkernelsections);

//
// Definitions for Trap
//
ULONG trapvectorlimits[NTRAPTYPES];

//
// Definitions for Memory
//
typedef struct mapping {
    ULONG_PTR   physpage;
    ULONG       readmask;
    ULONG       writemask;
} Mapping;

// these pseudo-context values can be passed to functions, but are not stored in Portal or PCB ctx fields
#define MAXCTXS     (1 << CTXBITS)
#define MAXMODES    (1 << MODEBITS)

#  define EMULCTX   (-3)
//#define IOCTX     (-2)
//#define GLOBALCTX (-1)

//
// Spaces, domains, trapvectors, cpus -- these all implicitly exist.
// We create whatever data structures we need on-demand.
//

// XXX: from WRK sources
typedef struct {
    PORT_MESSAGE     hdr;
    int              ApiNumber;  // 0 for exceptions
    NTSTATUS         ReturnedStatus;
    EXCEPTION_RECORD ExceptionRecord;
    ULONG            FirstChance;
} EXCEPTION_MESSAGE;

typedef struct {
    Hashentry           hash;                   // hashed on ID of ntcputhread
    HANDLE              ntcputhread;
// XXX:   ULONG_PTR           ntstackpointer;         // used to fakeout NT exception dispatching at startup and portal traversal //----------
    struct domain      *domain;
    ULONG               cpu;
    BOOLEAN             trappednotinterrupted;  // awaiting replymessage not suspended
    ULONG               interrupteip;           // EIP saved at point of an InterruptCPU
    EXCEPTION_MESSAGE   ntreplymessage;
} NTThreadDescr;

NTThreadDescr *LookupNTThread(HANDLE ntthreadid);

typedef struct domain {
    HANDLE          ntprocess;
    // ULONG           mode;        // XXX; do not need this
    NTThreadDescr  *cpus[MAXCPUS];
} Domain;

#define PORTALTYPEBITS 3

typedef enum {
    unknowncall     = 0,    // emulation calls don't use PCBs
    servicetrap     = 1,
    interruptcall   = 2,
    accessviolation = 3,
    raiseexception  = 4,
    pagefault       = 5
} PCBCalltype;
#define PCBCALLTYPEBITS 3


typedef struct portal {
    Hashentry   hash;                   // hashed on portalid
    ULONG       refcount;
    ULONG       type      :PORTALTYPEBITS,
                destroyed :1,
                reserved  :1,
                ctx       :CTXBITS,
                mode      :MODEBITS,
                irql      :IRQLBITS;    // only used for interrupts
    ULONG       protmask;
    ULONG_PTR   handler;
    ULONG_PTR   arg;
} Portal;

Portal  *lookupportal      (ULONG   portalid);
void     referenceportal   (Portal *portal);
void     dereferenceportal (Portal *portal);

typedef struct trapvector {
    Portal        *emulation   [NTRAP_EMULCALLS];
    Portal        *servicecall [NTRAP_SERVCALLS];
    Portal        *interrupts  [NTRAP_INTERRUPTS];
    Portal        *exceptions  [NTRAP_EXCEPTIONS];
    Portal        *faults      [NTRAP_FAULTS];
    RTL_AVL_TABLE  vadtree;
} Trapvector;

typedef struct {
    struct mapping **rootmap;
    Domain          *domains[MAXMODES];
    Trapvector      *trapvector;
} Space;

Space *spaces[MAXCTXS];
Space *iospace;

void instantiatespace           (ULONG ctx);
void instantiatedomain          (ULONG ctx, ULONG mode);
void instantiatentthreaddescr   (ULONG ctx, ULONG mode, ULONG cpu);

Mapping *VPageToMap(ULONG cpu, Space *space, ULONG_PTR vpage);

//
// Definitions for Interrupt
//

typedef struct {
    PORT_MESSAGE        hdr;
    ULONG               cpu;
    UCHAR               interrupt;
    UCHAR               irql;
} InterruptMsg;

typedef struct interruptitem {
    struct interruptitem  *link;
    UCHAR                  interrupt;
    UCHAR                  irql;
} InterruptItem;


//
// Definitions for Portal
//
Portal *allocateportal();

//
// Definitions for CPU
//

typedef struct pcb {
    Hashentry   hash;
    struct pcb *chainlink;
    ULONG       pcbcalltype     :PCBCALLTYPEBITS,
                tokenallocated  :1,
                returnargflag   :1,
                oldctx          :CTXBITS,
                oldmode         :MODEBITS,
                oldirql         :IRQLBITS;    // used for interruptcall
    ULONG       tokenowner_ctx;               // used when tokenallocated
    ULONG       tokenowner_mode;
    CONTEXT     ntcontext;
} PCB;

typedef enum {
    Uninitialized = 0,  // initial state
    Running,
    Halted              // waiting for something to happen
} CPUState;

typedef struct cpuhardware {
    CPUState         cpustate;
    ULONG            ctx;
    UCHAR            mode;
    UCHAR            irql;
    PCB             *currentchain;
    InterruptItem   *queuehead;
    InterruptItem   *pendinginterrupt;
} CPUHardware;

CPUHardware cpuhardware[MAXCPUS];

void StartNTCPUThread(ULONG cpu, NTThreadDescr *ntthreaddescr, PCB *pcb);

Portal *TrapToPortal(ULONG ctx, ULONG mode, Traptype traptype, ULONG trapindex);

void cleantrapvector(Trapvector *trapvector);

//
// Definitions for Emulation
//

void SPACEEmulation();

//
// Definitions for IO
//

#include "Devices.h"

typedef struct {
    Hashentry     hash;
    DEVICEACCESS  accessfcn;
} Device;

void RegisterAllDevices();

// use a fake NT status code to signify interrupts
#define STATUS_SPACE_INTERRUPT STATUS_KERNEL_APC

//
// SPACE globals
//

typedef struct {
    HANDLE          physmemsection;
    HANDLE          spaceport;
    ULONG           highestctx;
} SPACEGlobals;

SPACEParams    spaceparams;
SPACEGlobals   spaceglobals;

#define MAXIMAGESECTIONS 4
Section kernelsections[MAXIMAGESECTIONS];
int     nkernelsections;


void cleanup();

//
// Processor-specific definitions
//

VOID  setselectors(CONTEXT *pctx);

typedef union {
    struct {
        ULONG   operation   :16,
                hwemulation :1,
                servicecall :1,
                illegalop   :1,
                skiplength  :3;
    };

    ULONG iwhole;
} TrapDecode;

ULONG getinstruction(HANDLE process, PVOID pc);

void get5args     (ULONG   *args5, CONTEXT *ctx);
void ret5args     (CONTEXT *ctx,   ULONG   *args5);
void set4args     (CONTEXT *ctx,   ULONG   *args4);

void retresultarg (CONTEXT *ctx, ULONGLONG resultarg);
void retresultarg2(CONTEXT *ctx, ULONG resultarg_low, ULONG resultarg_high);

ULONGLONG   makequad    (ULONG a,   ULONG b);
ULONG       splitquad   (PULONG ph, ULONGLONG v);

//
// Error reporting
//
int warn(char *msg, ULONG_PTR value);
int die (char *fmt, char *msg, ULONG_PTR value);

#define FATALFAIL(s,msg) (NT_SUCCESS(s) || die("Fatal error in [" __FILE__ "]  " __FUNCTION__ "(): %s <%x>\n", msg, s))
#define WARNFAIL(s,msg)  (NT_SUCCESS(s) || warn(msg, s))
#define CHKFAIL(s)       {if (! NT_SUCCESS(s)) goto FAILED;}

#define BUGCHECK(msg) die("SPACE Internal error in " __FUNCTION__ ": %s  [" __FILE__ " at %d]\n", msg, __LINE__)

#include "Debug.h"          // XXX for debugging
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\SPACE\LoadKernel.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include "Defs.h"

//
//
//
NTSTATUS
LoadKernel(
        PWCHAR      kernelname,   
        PULONG_PTR  entrypoint,
        Section     kernelsections[],
        int        *nkernelsections
    )
{
    HANDLE                  kernelhandle;
    NTSTATUS                s;
    IO_STATUS_BLOCK         iosb;
    OBJECT_ATTRIBUTES       obja;
    UNICODE_STRING          u;
    LARGE_INTEGER           fileoffset;
    ULONG                   length;

    PCHAR                   virtbase;
    SIZE_T                  viewsize;

    PCHAR                   addr;
    ULONG                   physbasepage;
    Section                *sect;

    IMAGE_SECTION_HEADER   *phdr;

    ULONG                   n;
    ULONG                   npages;

    WCHAR                   kernelfullpath[512];

    IMAGE_DOS_HEADER        DosHeader;
    IMAGE_NT_HEADERS32      NTHeaders;
    IMAGE_SECTION_HEADER    SectionTable[MAXIMAGESECTIONS];

    PIMAGE_OPTIONAL_HEADER  pOptionalHeader;
    PIMAGE_FILE_HEADER      pFileHeader;

    kernelfullpath[512-1] = L'\0';

    RtlGetFullPathName_U(kernelname, sizeof(kernelfullpath)-1, kernelfullpath, NULL)
    || BUGCHECK("RtlGetFullPathName... kernelname");

    RtlDosPathNameToNtPathName_U(kernelfullpath, &u, NULL, NULL);
    InitializeObjectAttributes(&obja, &u, 0, NULL, NULL);

    s = NtOpenFile(&kernelhandle, GENERIC_READ, &obja, &iosb, FILE_SHARE_VALID_FLAGS, FILE_NON_DIRECTORY_FILE);
    FATALFAIL(s, "OpenKernel");

    RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)u.Buffer);

    fileoffset.QuadPart = 0L;
    s = NtReadFile(kernelhandle, NULL, NULL, NULL, &iosb, &DosHeader, sizeof(DosHeader), &fileoffset, NULL);
    FATALFAIL(s, "Read DosHeader");

	(DosHeader.e_magic == IMAGE_DOS_SIGNATURE)  || FATALFAIL(STATUS_INVALID_IMAGE_FORMAT, "DOS Signature");

    fileoffset.QuadPart = DosHeader.e_lfanew;
    s = NtReadFile(kernelhandle, NULL, NULL, NULL, &iosb, &NTHeaders, sizeof(NTHeaders), &fileoffset, NULL);
    FATALFAIL(s, "Read NTHeader");

    pFileHeader     = &NTHeaders.FileHeader;
    pOptionalHeader = &NTHeaders.OptionalHeader;

	    NTHeaders.Signature == IMAGE_NT_SIGNATURE
	 && pFileHeader->SizeOfOptionalHeader == sizeof(IMAGE_OPTIONAL_HEADER)
	|| FATALFAIL(STATUS_INVALID_IMAGE_FORMAT, "Header sizes");

        pOptionalHeader->SectionAlignment == NTSPACE_PAGESIZE
     && pOptionalHeader->SizeOfImage % NTSPACE_PAGESIZE == 0
	|| FATALFAIL(STATUS_INVALID_IMAGE_FORMAT, "Optional header sizes");

    (pFileHeader->NumberOfSections <= MAXIMAGESECTIONS) || FATALFAIL(STATUS_INVALID_IMAGE_FORMAT, "Too many sections in image");
    (pFileHeader->NumberOfSections <= *nkernelsections) || FATALFAIL(STATUS_INVALID_IMAGE_FORMAT, "Too many sections for BasicOZ kernel");

    fileoffset.QuadPart += FIELD_OFFSET(IMAGE_NT_HEADERS, OptionalHeader) + pFileHeader->SizeOfOptionalHeader;
    length = sizeof(IMAGE_SECTION_HEADER) * pFileHeader->NumberOfSections;
    s = NtReadFile(kernelhandle, NULL, NULL, NULL, &iosb, &SectionTable, length, &fileoffset, NULL);
    FATALFAIL(s, "Read SectionHeaderTable");

    n = *nkernelsections = pFileHeader->NumberOfSections;

    // count the number of pages we need
    n = *nkernelsections;
    npages = 0;
    for (phdr = SectionTable;  n--;  phdr++) {
        npages += COUNTBY(phdr->Misc.VirtualSize, pOptionalHeader->SectionAlignment);
    }

    // map the pages so we can read them in from the kernel image
    virtbase = NULL;
    viewsize = 0;
    s = NtMapViewOfSection(spaceglobals.physmemsection, NtCurrentProcess(), &virtbase,
                        0, npages*NTSPACE_PAGESIZE, NULL, &viewsize, ViewUnmap, 0, PAGE_READWRITE);
    FATALFAIL(s, "Map 'physmem' Section");

    n = *nkernelsections;
    sect = kernelsections;
    phdr = SectionTable;

    printf("Loading kernel\n");

    addr = virtbase;
    physbasepage = spaceparams.physbasepage;

    while (n) {

        printf("%8.8s segment  virtual %08x  physical %08x  size %08x\n",
                phdr->Name, pOptionalHeader->ImageBase + phdr->VirtualAddress,
                physbasepage * NTSPACE_PAGESIZE, phdr->Misc.VirtualSize);

        fileoffset.QuadPart = phdr->PointerToRawData;
        length     = phdr->SizeOfRawData;
        s = NtReadFile(kernelhandle, NULL, NULL, NULL, &iosb, addr, length, &fileoffset, NULL);
        FATALFAIL(s, "Reading Section");


        sect->nPages = COUNTBY(phdr->Misc.VirtualSize, pOptionalHeader->SectionAlignment);
        sect->VirtualAddress = pOptionalHeader->ImageBase + phdr->VirtualAddress;
        sect->PhysicalBasepage = physbasepage;
        sect->Writable = !!(phdr->Characteristics & IMAGE_SCN_MEM_WRITE);

        addr += sect->nPages * NTSPACE_PAGESIZE;
        physbasepage += sect->nPages;

        sect++;
        phdr++;
        n--;

    }

    spaceparams.physbasepage = (UCHAR)physbasepage;

    (spaceparams.physbasepage == physbasepage) || BUGCHECK("LoadKernel used too many physical pages");

    s = NtUnmapViewOfSection(NtCurrentProcess(), virtbase);
    FATALFAIL(s, "Unmap 'physmem' Section");

    NtClose(kernelhandle);

    *entrypoint = pOptionalHeader->ImageBase + pOptionalHeader->AddressOfEntryPoint;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\SPACE\Processor.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include "Defs.h"

//
// read the faulting instruction and decode it
// e.g. for IA32 use combinations of lock prefix and ud2 and trailing data  (0xf0 and 0x0f 0x0b and 0xXXXX)
// [but could also use combinations involving other prefix groups, e.g. 0x66 and 0x67]
//      f0 0f 0b xx  -- HW emulation op xx
//      0f 0b xx xx  -- Service Call op xxxx
//

ULONG
getinstruction(
        HANDLE  process,
        PVOID   pc
    )
{
    TrapDecode  ti;
    ULONG       faultinstr = 0;
    ULONG       readsize = 0;
    NTSTATUS    s;

    ti.iwhole = 0;

    s = NtReadVirtualMemory(process, pc, &faultinstr, sizeof(faultinstr), &readsize);
    FATALFAIL(s, "NtReadVirtualMemory fault instruction");

           if ((faultinstr & 0xffffff) == 0x0b0ff0) {
        ti.skiplength = 4;
        ti.hwemulation = 1;
        ti.operation = (faultinstr >> 24);

    } else if ((faultinstr & 0xffff)   == 0x0b0f) {
        ti.skiplength = 4;
        ti.servicecall = 1;
        ti.operation = (faultinstr >> 16);

    } else {
        ti.illegalop = 1;
    }

    return  ti.iwhole;
}

VOID  setselectors(
        CONTEXT *pctx
    )
{
    if (!pctx->SegDs && (pctx->ContextFlags & CONTEXT_SEGMENTS) == CONTEXT_SEGMENTS) {
        pctx->SegGs = 0;
        pctx->SegFs = KGDT_R3_TEB   | 3;
        pctx->SegEs = KGDT_R3_DATA  | 3;
        pctx->SegDs = KGDT_R3_DATA  | 3;
    }

    if (!pctx->SegCs && (pctx->ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {
        pctx->SegSs = KGDT_R3_DATA  | 3;
        pctx->SegCs = KGDT_R3_CODE  | 3;
    }
}

void
get5args(
        ULONG     *args5,
        CONTEXT   *ctx
    )
{
    args5[0] = ctx->Ebx;
    args5[1] = ctx->Ecx;
    args5[2] = ctx->Edx;
    args5[3] = ctx->Edi;
    args5[4] = ctx->Esi;
//STRACE("[Ebx Ecx Edx Edi xEsi]", args5[0], args5[1], args5[2], args5[3])
}

void
ret5args(
        CONTEXT   *ctx,
        ULONG     *args5
    )
{
    ctx->Ebx = args5[0];
    ctx->Ecx = args5[1];
    ctx->Edx = args5[2];
    ctx->Edi = args5[3];
    ctx->Esi = args5[4];
//STRACE("[Ebx Ecx Edx Edi xEsi]", args5[0], args5[1], args5[2], args5[3])
}

void
set4args(
        CONTEXT   *ctx,
        ULONG     *args5
    )
{
    ctx->Ebx = args5[0];
    ctx->Ecx = args5[1];
    ctx->Edx = args5[2];
    ctx->Edi = args5[3];
//STRACE("[Ebx Ecx Edx Edi]", args5[0], args5[1], args5[2], args5[3])
}

void
retresultarg(
        CONTEXT   *ctx,
        ULONGLONG  resultarg
    )
{
    ULARGE_INTEGER x;
    x.QuadPart = resultarg;

    ctx->Eax = x.LowPart;
    ctx->Edx = x.HighPart;
//STRACE("[Eax Edx Eip Esp]", ctx->Eax, ctx->Edx, ctx->Eip, ctx->Esp)
}

void
retresultarg2(
        CONTEXT   *ctx,
        ULONG      resultarg_low,
        ULONG      resultarg_high
    )
{
    ctx->Eax = resultarg_low;
    ctx->Edx = resultarg_high;
//STRACE("[Eax Edx Eip Esp]", ctx->Eax, ctx->Edx, ctx->Eip, ctx->Esp)
}

ULONGLONG
makequad(ULONG a, ULONG b)
{
    ULARGE_INTEGER x;
    x.LowPart  = a;
    x.HighPart = b;
    return x.QuadPart;
}

ULONG
splitquad(PULONG ph, ULONGLONG v)
{
    ULARGE_INTEGER x;
    x.QuadPart = v;
    *ph = x.HighPart;
    return x.LowPart;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\SPACE\Memory.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include "Defs.h"

#define NTSPACE_TOPMASK ((1 << NTSPACE_TOPBITS) - 1)
#define NTSPACE_MIDMASK ((1 << NTSPACE_MIDBITS) - 1)

#define TOPVADBITS(va) (((va) >> (NTSPACE_PAGEBITS + NTSPACE_MIDBITS)) &  NTSPACE_TOPMASK)
#define MIDVADBITS(va) (((va) >> (NTSPACE_PAGEBITS                  )) &  NTSPACE_MIDMASK)
#define BOTVADBITS(va) (((va)                                        ) & (NTSPACE_PAGESIZE-1))

#define NTSPACE_MAPDIRENTRIES (1 << NTSPACE_TOPBITS)
#define NTSPACE_MAPTABENTRIES (1 << NTSPACE_MIDBITS)

Mapping *
VPageToMap(
        ULONG      cpu,
        Space     *space,
        ULONG_PTR  vpage
    )
{
    ULONG_PTR va    = PAGE2ADDR(vpage);
    ULONG     rooti = TOPVADBITS(va);

    Mapping **rootmap;
    Mapping  *pmap;

    if (space == NULL)
        return NULL;
    rootmap = space->rootmap;
    if (rootmap == NULL) {
        ULONG sz = NTSPACE_MAPDIRENTRIES * sizeof(Mapping *);
        rootmap = malloc(sz);
        rootmap != NULL  || FATALFAIL(STATUS_NO_MEMORY, "Allocating rootmap");

        RtlZeroMemory(rootmap, sz);
        space->rootmap = rootmap;
    }

    pmap = rootmap[rooti];

    if (pmap == NULL) {
        ULONG sz = NTSPACE_MAPTABENTRIES * sizeof(Mapping);
        pmap = malloc(sz);
        pmap != NULL  || FATALFAIL(STATUS_NO_MEMORY, "Allocating pagemap");


        RtlZeroMemory(pmap, sz);
        rootmap[rooti] = pmap;
    }

    return &pmap[MIDVADBITS(va)];
}

void
instantiatespace(
        ULONG ctx
    )
{
    if (spaces[ctx] == NULL) {
        spaces[ctx] = malloc(sizeof(Space));
        spaces[ctx] || FATALFAIL(STATUS_NO_MEMORY, "instantiate space");
        ZERO(spaces[ctx]);

        if (ctx > spaceglobals.highestctx)
            spaceglobals.highestctx = ctx;
    }

}

void
instantiatedomain(
        ULONG ctx,
        ULONG mode
    )
{
    instantiatespace(ctx);

    if (spaces[ctx]->domains[mode] == NULL) {
        spaces[ctx]->domains[mode] = malloc(sizeof(Domain));
        spaces[ctx]->domains[mode] || FATALFAIL(STATUS_NO_MEMORY, "instantiate domain");
        ZERO(spaces[ctx]->domains[mode]);
    }
}

void instantiatentthreaddescr(
        ULONG ctx,
        ULONG mode,
        ULONG cpu
    )
{
    NTThreadDescr **d;

    instantiatedomain(ctx,mode);
    d = &spaces[ctx]->domains[mode]->cpus[cpu];

    if (*d)  return;

    *d = malloc(sizeof(**d));
    *d || FATALFAIL(STATUS_NO_MEMORY, "instantiate ntthreaddescr");
    ZERO(*d);

    (*d)->domain = spaces[ctx]->domains[mode];
    (*d)->cpu = cpu;
}

NTSTATUS
CleanCtx(
        ULONG xcpu,
        ULONG ctx
    )
{
    Space      *space;
    Domain     *domain;
    Mapping   **pmap;
    Mapping   **epmap;
    ULONG       mode;
    ULONG       cpu;

    if (ctx == IOCTX) {
        space = iospace;
        iospace = NULL;
    } else if (ctx < MAXCTXS) {
        space = spaces[ctx];
        spaces[ctx] = NULL;
    } else {
        return STATUS_ILLEGAL_INSTRUCTION;
    }


    if (space == NULL)
        return STATUS_SUCCESS;

    //
    // free the domain structures, terminating the corresponding NT Process (and thus the CPU threads)
    // make sure the handles get closed
    //
    for (mode = 0;  mode < MAXMODES;  mode++) {
        domain = space->domains[mode];
        if (domain == NULL)
            continue;

        space->domains[mode] = NULL;
        for (cpu = 0;  cpu < MAXCPUS;  cpu++) {
            if (domain->cpus[cpu] && domain->cpus[cpu]->ntcputhread) {
                NtClose(domain->cpus[cpu]->ntcputhread);
            }
        }

        if (domain->ntprocess) {
            NtTerminateProcess(domain->ntprocess, STATUS_SUCCESS);
            NtClose(domain->ntprocess);
        }

        free(domain);
    }

    //
    // free the map tables and then the map directory
    //
    if (space->rootmap) {
        epmap = space->rootmap + NTSPACE_MAPDIRENTRIES;
        for (pmap = space->rootmap;  pmap < epmap;  pmap++) {
            if (pmap) {
                free(*pmap);
                *pmap = NULL;
            }
        }
        free(space->rootmap);
        space->rootmap = NULL;
    }

    //
    // clean the trapvector
    //
    cleantrapvector(space->trapvector);
    space->trapvector = NULL;

    //
    // free the space structure itself
    //
    free(space);

    return STATUS_SUCCESS;
}

//
// insert the specified mapping for the given context and virtual page
//
NTSTATUS
MapMemory(
        ULONG       cpu,
        ULONG       ctx,
        ULONG       vpage,
        ULONG       ppage,
        ULONG       readmask,
        ULONG       writemask
     )
{
    Space       **pspace;
    Mapping      *map;
    ULONG         bit_mask;
    int           d;

    ULONG       npages = 1;

//STRACE("[ctx/npages, vpage, ppage, masks]", MASH(ctx,npages), vpage, ppage, readmask|writemask)
    if (ppage >= spaceparams.nphysmempages && ppage != NTSPACE_INVALIDPAGE)
        return STATUS_ILLEGAL_INSTRUCTION;
    if (ppage == NTSPACE_INVALIDPAGE && (readmask|writemask))
        return STATUS_ILLEGAL_INSTRUCTION;
    if (ctx == IOCTX) {
        ;
    } else if (ctx > MAXCTXS || vpage < spaceparams.vpage_base || spaceparams.vpage_limit <= vpage) {
        return STATUS_ILLEGAL_INSTRUCTION;
    }

    // put this into the mapping tree for our space
    // based on the changes, update the view in all domains within the space
    pspace = (ctx == IOCTX)?  &iospace : &spaces[ctx];

    if (*pspace == NULL) {
        *pspace = malloc(sizeof(**pspace));
        *pspace || FATALFAIL(STATUS_NO_MEMORY, "MapMemory");
        ZERO(*pspace);
    }

    map = VPageToMap(cpu, *pspace, vpage);

    if (map == NULL)
        return STATUS_ILLEGAL_INSTRUCTION;

    // if ppage isn't changing, only affect is on domains which are getting different access to the page
    // otherwise ppage has changed, and we must change all domains with any access
    if (map->physpage == ppage) {
        bit_mask = (map->readmask ^ readmask) | (map->writemask ^ writemask);
    } else {
        bit_mask =  map->readmask | readmask  |  map->writemask | writemask;
    }

    map->physpage   = ppage;
    map->readmask   = readmask;
    map->writemask  = writemask;

    for (d = 0;  d < MAXMODES;  d++) {
        ULONG         domainmask = BITMASK(d);
        ULONG         pageaccess;
        ULONG_PTR     vaddr;
        ULONGLONG     paddr;
        SIZE_T        pagesize   = NTSPACE_PAGESIZE;
        Domain       *domain     = (*pspace)->domains[d];
        NTSTATUS      s;
        ULONG         i;

        if ((bit_mask & domainmask) == 0)
            continue;

        if (domain == NULL  || domain->ntprocess == NULL)
            continue;

        if (ppage == NTSPACE_INVALIDPAGE) {
            for (i = 0;  i < npages;  i++) {
                vaddr = PAGE2ADDR(vpage+i);
                s = NtUnmapViewOfSection ( domain->ntprocess, (PVOID)vaddr );
                if (!NT_SUCCESS(s)) return STATUS_ILLEGAL_INSTRUCTION;
            }
        } else {
            if (writemask & domainmask)
                pageaccess = PAGE_READWRITE;
            else if (readmask & domainmask)
                pageaccess = PAGE_READONLY;
            else
                pageaccess = PAGE_NOACCESS;

            // need multiple views, not a single large view, or won't be able to later unmap a single page
            for (i = 0;  i < npages;  i++) {
                vaddr = PAGE2ADDR(vpage+i);
                paddr = PAGE2ADDR(ppage+i);
                s = NtMapViewOfSection ( spaceglobals.physmemsection, domain->ntprocess, (PVOID)&vaddr, 0,
                        NTSPACE_PAGESIZE, (PLARGE_INTEGER)&paddr, &pagesize, ViewUnmap, 0, pageaccess);
                if (!NT_SUCCESS(s)) return STATUS_ILLEGAL_INSTRUCTION;
            }
        }
    }
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\SPACE\SystemLib.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "..\INC\SystemLib.h"

//
// Library functions
//


SPACEStatus
StudyImage(
        PVOID           imagebase,
        ULONG           imagesize,
        ImageSection    imagesections[],
        PULONG          pnimagesections,
        ULONG_PTR      *entrypoint
    )
{
    PIMAGE_DOS_HEADER       pDosHeader;
    PIMAGE_SECTION_HEADER   pSectHdr;

    PIMAGE_NT_HEADERS32     pNTHeaders;
    PIMAGE_OPTIONAL_HEADER  pOptionalHeader;
    PIMAGE_FILE_HEADER      pFileHeader;

    PCHAR                   pimage = (PCHAR)imagebase;
    ULONG                   remaining = imagesize;
    ULONG                   maximagesections;
    ImageSection           *pSection;
    ULONG                   image_signature;
    ULONG                   sizeofheaders;
    ULONG                   offset;
    ULONG                   i, n;
    ULONGLONG               virtualimagebase;

    pDosHeader = (IMAGE_DOS_HEADER *)pimage;
    
    if (imagesize < sizeof(*pDosHeader)
     || pDosHeader->e_magic != IMAGE_DOS_SIGNATURE
     || pDosHeader->e_lfanew + sizeof(image_signature) + sizeof(*pFileHeader) > imagesize
     )
        return STATUS_INVALID_IMAGE_FORMAT;

    pimage += pDosHeader->e_lfanew;

    pNTHeaders      = (PIMAGE_NT_HEADERS32)     pimage;
    pFileHeader     = (PIMAGE_FILE_HEADER)      &pNTHeaders->FileHeader;
    pOptionalHeader = (PIMAGE_OPTIONAL_HEADER)  &pNTHeaders->OptionalHeader;

    maximagesections = *pnimagesections;

	if (pNTHeaders->Signature != IMAGE_NT_SIGNATURE
	 || pFileHeader->SizeOfOptionalHeader > sizeof(IMAGE_OPTIONAL_HEADER)
	 || pOptionalHeader->SectionAlignment != NTSPACE_PAGESIZE
	 || pOptionalHeader->SizeOfImage % NTSPACE_PAGESIZE)
        return STATUS_INVALID_IMAGE_FORMAT;

    sizeofheaders = pDosHeader->e_lfanew + sizeof(pNTHeaders->Signature) + sizeof(pNTHeaders->FileHeader) + pFileHeader->SizeOfOptionalHeader;

    pimage += sizeofheaders;

    sizeofheaders += pDosHeader->e_lfanew + pFileHeader->NumberOfSections * sizeof(IMAGE_SECTION_HEADER);
    if (sizeofheaders > imagesize)
        return STATUS_INVALID_IMAGE_FORMAT;

    pSectHdr = (IMAGE_SECTION_HEADER *)pimage;
    n = pFileHeader->NumberOfSections;

    if (n > maximagesections)
        return STATUS_BUFFER_OVERFLOW;

    pSection = imagesections;
    virtualimagebase = pOptionalHeader->ImageBase;
    for (i = 0;  i < n;  i++) {

        offset = (ULONG)pSectHdr->PointerToRawData;

        pSection->nPages            = COUNTBY(pSectHdr->Misc.VirtualSize, pOptionalHeader->SectionAlignment);
        pSection->MemoryAddress     = (PVOID)     ((PCHAR)imagebase + offset);
        pSection->VirtualAddress    = (ULONG_PTR) (virtualimagebase + pSectHdr->VirtualAddress);
        pSection->Writable          = !!(pSectHdr->Characteristics & IMAGE_SCN_MEM_WRITE);

        if (offset + pSection->nPages * NTSPACE_PAGESIZE > imagesize)
            return STATUS_INVALID_IMAGE_FORMAT;

        pSection++, pSectHdr++;
    }

    *pnimagesections = n;
    *entrypoint = (ULONG_PTR) (virtualimagebase + pOptionalHeader->AddressOfEntryPoint);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\SPACE\SPACE.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include "Defs.h"

int
main(int ac, char *argv[])
{
    LARGE_INTEGER       physmemsize;
    OBJECT_ATTRIBUTES   obja;
    NTSTATUS            s;
    Section            *sect;
    ULONG               i, n;
    ULONG               kportalid, uportalid;
    ULONG_PTR           entrypoint;

    printf("Welcome to SPACE!\n");

    // Set global configuration parameters
    spaceparams.vpage_base    = MINIMUM_VPAGE;
    spaceparams.vpage_limit   = MAXIMUM_VPAGE;
    spaceparams.maxctxs       = MAXCTXS;
    spaceparams.maxmodes      = MAXMODES;
    spaceparams.maxirqls      = MAXIRQLS;
    spaceparams.maxdevices    = MAXDEVICES;
    

    // Create the Physical Memory
    physmemsize.QuadPart = ROUNDUP(PHYSMEMSIZE, NTSPACE_PAGESIZE);
    spaceparams.nphysmempages = (ULONG_PTR) physmemsize.QuadPart / NTSPACE_PAGESIZE;

    s = NtCreateSection( &spaceglobals.physmemsection, SECTION_ALL_ACCESS, NULL,
                         &physmemsize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL);
    FATALFAIL(s, "CreatePhysicalMemory");

    // Load BasicOZ kernel into physical memory
    nkernelsections = ASIZEOF(kernelsections);
    s = LoadKernel(BASICOZKERNEL, &entrypoint, kernelsections, &nkernelsections);
    FATALFAIL(s, "LoadKernel");

    for (sect = kernelsections, n = nkernelsections;  n;  sect++, n--) {
        ULONG vpage = ADDR2PAGE(sect->VirtualAddress);
        if (vpage < spaceparams.vpage_base || spaceparams.vpage_limit <= vpage)
            BUGCHECK("Bad virtual mappings for kernel executable");
    }

    // Create the shared exception port
    InitializeObjectAttributes(&obja, NULL, 0, NULL, NULL);
	s = NtCreatePort(&spaceglobals.spaceport, &obja, 0, 256, 4096 * 16);
    FATALFAIL(s, "Create Exception Port");

    // Start CPU 0 in space 0 at domain 0 
    // It will trap right away, and we'll pickup the message as soon as we enter SPACEEmulation()
    s = StartCPU(0, 0, KERNELCTX, KERNELMODE, entrypoint, 0);
    FATALFAIL(s, "StartCPU 0");

    // Map the physical pages into kernel space/domain for CPU 0
    for (sect = kernelsections, n = nkernelsections;  n;  sect++, n--) {
        ULONG readmask = ACCESSMASK(0);
        ULONG writemask = sect->Writable? readmask : NOACCESS;

        for (i = 0;  i < sect->nPages;  i++) {
            s = MapMemory(0, KERNELCTX, ADDR2PAGE(sect->VirtualAddress) + i, sect->PhysicalBasepage + i, readmask, writemask);
            FATALFAIL(s, "Map Kernel Memory");
        }
    }

    // Map in the emulation portals.  Only the type and ACCESSMASK matters in the portal.
    kportalid = CreatePortal(0, emulationcall, 0, 0, EMULCTX, 0, ACCESSMASK(KERNELMODE));
    uportalid = CreatePortal(0, emulationcall, 0, 0, EMULCTX, 0, ACCESSMASK(KERNELMODE) | ACCESSMASK(USERMODE));
    s = MapTrap(0, EMULCTX, trapemul, 1, TRAPEMUL_Noop,           0, uportalid);  FATALFAIL(s, "Map trapemul Noop");
    s = MapTrap(0, EMULCTX, trapemul, 1, TRAPEMUL_MapMemory,      0, kportalid);  FATALFAIL(s, "Map trapemul MapMemory");
    s = MapTrap(0, EMULCTX, trapemul, 1, TRAPEMUL_MapIO,          0, kportalid);  FATALFAIL(s, "Map trapemul MapIO");
    s = MapTrap(0, EMULCTX, trapemul, 1, TRAPEMUL_MapTrap,        0, kportalid);  FATALFAIL(s, "Map trapemul MapTrap");
    s = MapTrap(0, EMULCTX, trapemul, 1, TRAPEMUL_CreatePortal,   0, kportalid);  FATALFAIL(s, "Map trapemul CreatePortal");
    s = MapTrap(0, EMULCTX, trapemul, 1, TRAPEMUL_DestroyPortal,  0, kportalid);  FATALFAIL(s, "Map trapemul DestroyPortal");
    s = MapTrap(0, EMULCTX, trapemul, 1, TRAPEMUL_CleanCtx,       0, kportalid);  FATALFAIL(s, "Map trapemul CleanCtx");
    s = MapTrap(0, EMULCTX, trapemul, 1, TRAPEMUL_Resume,         0, uportalid);  FATALFAIL(s, "Map trapemul Resume");
    s = MapTrap(0, EMULCTX, trapemul, 1, TRAPEMUL_Suspend,        0, uportalid);  FATALFAIL(s, "Map trapemul Suspend");
    s = MapTrap(0, EMULCTX, trapemul, 1, TRAPEMUL_Unsuspend,      0, uportalid);  FATALFAIL(s, "Map trapemul Unsuspend");
    s = MapTrap(0, EMULCTX, trapemul, 1, TRAPEMUL_PopCaller,      0, uportalid);  FATALFAIL(s, "Map trapemul PopCaller");
    s = MapTrap(0, EMULCTX, trapemul, 1, TRAPEMUL_DiscardToken,   0, uportalid);  FATALFAIL(s, "Map trapemul DiscardToken");
    s = MapTrap(0, EMULCTX, trapemul, 1, TRAPEMUL_StartCPU,       0, kportalid);  FATALFAIL(s, "Map trapemul StartCPU");
    s = MapTrap(0, EMULCTX, trapemul, 1, TRAPEMUL_InterruptCPU,   0, kportalid);  FATALFAIL(s, "Map trapemul InterruptCPU");
    s = MapTrap(0, EMULCTX, trapemul, 1, TRAPEMUL_AccessDevice,   0, kportalid);  FATALFAIL(s, "Map trapemul AccessDevice");
    s = MapTrap(0, EMULCTX, trapemul, 1, TRAPEMUL_ManageIRQL,     0, kportalid);  FATALFAIL(s, "Map trapemul ManageIRQL");
    s = MapTrap(0, EMULCTX, trapemul, 1, TRAPEMUL_HaltCPU,        0, kportalid);  FATALFAIL(s, "Map trapemul HaltCPU");
    s = MapTrap(0, EMULCTX, trapemul, 1, TRAPEMUL_GetSPACEParams, 0, uportalid);  FATALFAIL(s, "Map trapemul GetSPACEParams");

    // Destroy the temporary portal (it won't actually be deleted because the references are held by the traps)
    (void) DestroyPortal(0, kportalid);
    (void) DestroyPortal(0, uportalid);

    // TODO: specify the actual handler to boot the system
    kportalid = CreatePortal(0, exception, KERNELMODE, 0, KERNELCTX, 0, ACCESSMASK(KERNELMODE) | ACCESSMASK(USERMODE));
    s = MapTrap(0, GLOBALCTX, trapexcept, 1, TRAPEXCEPT_ILLEGALOP, 0, kportalid);  FATALFAIL(s, "Map trapexcept ILLEGALOP");
    (void) DestroyPortal(0, kportalid);

    // Register the device emulations
    RegisterAllDevices();

    // Start SPACE Emulation loop
    SPACEEmulation();

    // Cleanup & Exit
    cleanup();
    printf("SPACE has shutdown.\n");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\SPACE\TrapValues.h ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

//
// trap types
//
#define TRAPTYPE_EMULATION    0      // emulated SPACE hardware instructions, like resume
         // N.B.: TRAPEMUL_* must match Bootstrap.asm
#define     TRAPEMUL_Noop             0
#define     TRAPEMUL_MapMemory        1
#define     TRAPEMUL_MapIO            2
#define     TRAPEMUL_MapTrap          3
#define     TRAPEMUL_CreatePortal     4
#define     TRAPEMUL_DestroyPortal    5
#define     TRAPEMUL_CleanCtx         6
#define     TRAPEMUL_Resume           7
#define     TRAPEMUL_Suspend          8
#define     TRAPEMUL_Unsuspend        9
#define     TRAPEMUL_PopCaller       10
#define     TRAPEMUL_DiscardToken    11
#define     TRAPEMUL_StartCPU        12
#define     TRAPEMUL_InterruptCPU    13
#define     TRAPEMUL_AccessDevice    14
#define     TRAPEMUL_ManageIRQL      15
#define     TRAPEMUL_HaltCPU         16
#define     TRAPEMUL_GetSPACEParams  17
#define     TRAPEMUL_Break           18
#define     NTRAP_EMULCALLS          19

#define TRAPTYPE_SERVICETRAP  1      // implement service call
#define     NTRAP_SERVCALLS         256

#define TRAPTYPE_INTERRUPT    2      // device interrupts
#define     NTRAP_INTERRUPTS         64

#define TRAPTYPE_EXCEPTION    3      // exceptions use intel trap numbers
#define     TRAPEXCEPT_DIVIDE         0
#define     TRAPEXCEPT_DEBUG          1
#define     TRAPEXCEPT_BREAKPOINT     3
#define     TRAPEXCEPT_INVALIDOPCODE  4
#define     TRAPEXCEPT_ILLEGALOP      5
#define     TRAPEXCEPT_ACCESSDENIED   6
#define     NTRAP_EXCEPTIONS          7

#define TRAPTYPE_FAULT        4      // pagefaults and protection faults
#define     TRAPFAULT_ACCESS          1
#define     TRAPFAULT_STACK           2 // N.B.: mapped to TRAPFAULT_ACCESS
#define     TRAPFAULT_PROTECTION      3 // N.B.: mapped to TRAPFAULT_ACCESS
#define     NTRAP_FAULTS              4

#define NTRAPTYPES            5      // Number of valid traptypes
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\SPACE\Portal.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include "Defs.h"

Hashentry *TokenHash[1023];
SPACETOKEN mastertoken = 1;

ULONGLONG   makequad    (ULONG a,   ULONG b);
ULONG       splitquad   (PULONG ph, ULONGLONG v);

Hashentry *PortalHash[4095];
ULONGLONG  nextportalid = 1;

SPACETOKEN
Suspend(
        ULONG       cpu
    )
{
    Hashentry **prevlink;
    PCB        *pcb         = cpuhardware[cpu].currentchain;
    ULONG       ownctx      = cpuhardware[cpu].ctx;
    ULONG       ownmode     = cpuhardware[cpu].mode;

    cpuhardware[cpu].currentchain = NULL;

    if (!pcb) return 0;

    pcb->hash.value = mastertoken++;
    prevlink = TokenHash + HASH(pcb->hash.value, ASIZEOF(TokenHash));

    pcb->hash.link = *prevlink;
    *prevlink = &pcb->hash;

    pcb->tokenallocated = 1;
    pcb->tokenowner_ctx   = ownctx;
    pcb->tokenowner_mode  = ownmode;

STRACE("[cpu, token, ownctx, ownmode]", cpu, (ULONG)pcb->hash.value, ownctx, ownmode)
    return pcb->hash.value;
}

NTSTATUS
Unsuspend(
        ULONG       cpu,
        SPACETOKEN  token
    )
{
    Hashentry  **prevlink = NULL;
    Hashentry   *ptr;
    PCB         *pcb = NULL;
    PCB         *chainpcb;

    // Find the chain for the token and make it the current one
    // If we already had a chain, we discard it
    // TODO: should it be an exception to find the current chain is not empty?

    ptr = LookupHashEntry(TokenHash, ASIZEOF(TokenHash), token, &prevlink);

    if (ptr == NULL)
        return STATUS_ILLEGAL_INSTRUCTION;

    // remove the pcb from the tokenhash
    *prevlink = pcb->hash.link;

    // discard the current chain
    chainpcb = cpuhardware[cpu].currentchain;
    while (chainpcb) {
        PCB *tpcb = chainpcb;
        chainpcb = chainpcb->chainlink;
        free(tpcb);
    }

    // make the token chain the new current chain
    cpuhardware[cpu].currentchain = pcb;

//STRACE("[cpu, token, newpcb, neweip]", cpu, (ULONG)token, pcb, pcb->ntcontext.Eip)
    return STATUS_SUCCESS;
}


NTSTATUS
Resume(
        ULONG       cpu,
        ULONGLONG   result
    )
{
    CPUHardware   *pcpu           = cpuhardware + cpu;
    NTThreadDescr *ntthreaddescr;
    PCB           *pcb            = NULL;

    NTSTATUS     s;

    pcb = pcpu->currentchain;

    // check for errors
    if (pcb == NULL) {
        return STATUS_ILLEGAL_INSTRUCTION;
    }

    // pop the pcb off the chain
    pcpu->currentchain = pcb->chainlink;

    // set the IRQL, if changing
    // if any pending interrupts are deliverable, pcpu->pendinginterrupt will be set
    if (pcb->oldirql != pcpu->irql) {
        (void) ManageIRQL(cpu, setirql, (UCHAR)pcb->oldirql);
    }

    // return the result, if appropriate
    if (pcb->returnargflag) {
        retresultarg(&pcb->ntcontext, result);
    }

    // find the NT thread for the current CPU in the domain we are returning to
    // it won't exist if nothing has ever run there before
    instantiatentthreaddescr(pcb->oldctx, pcb->oldmode, cpu);

    ntthreaddescr = spaces[pcb->oldctx]->domains[pcb->oldmode]->cpus[cpu];
    if (ntthreaddescr->ntcputhread == NULL) {
        // Starting the CPU will push pcb onto the chain and then resume it
        StartNTCPUThread(cpu, ntthreaddescr, pcb);
        return STATUS_SUCCESS;
    }

    // restore context from PCB onto an existing ntcputhread
    s = NtSetContextThread( ntthreaddescr->ntcputhread, &pcb->ntcontext );
    FATALFAIL(s, "NtSetContextThread failed");

    // Cannot reply to the port if there is a pending interrupt, as we can't let the CPU run
    if (!pcpu->pendinginterrupt) {
        // reply to the last message
        s = NtReplyPort( spaceglobals.spaceport,
                         (PPORT_MESSAGE)&spaces[pcb->oldctx]->domains[pcb->oldmode]->cpus[cpu]->ntreplymessage );
        FATALFAIL(s, "NtReplyPort failed");

    // free the pcb
    free(pcb);
}

    return STATUS_SUCCESS;
}


NTSTATUS
DiscardToken(
        ULONG       cpu,
        SPACETOKEN  token
    )
{
    Hashentry   *ptr;
    Hashentry  **prevlink  = NULL;
    PCB         *pcb;

    // lookup the token
    ptr = LookupHashEntry(TokenHash, ASIZEOF(TokenHash), token, &prevlink);
    if (ptr == NULL) {
        return STATUS_ILLEGAL_INSTRUCTION;
    }

    pcb = CONTAINING_RECORD(ptr, PCB, hash);

STRACE("[cpu, token, pcb, pcbeip]", cpu, (ULONG)token, pcb, pcb->ntcontext.Eip)
    // remove the pcb from the tokenhash
    *prevlink = pcb->hash.link;

    // free all the PCBs in the chain
    while (pcb) {
        PCB *tpcb = pcb;
        pcb = pcb->chainlink;
        free(tpcb);
    }

    return STATUS_SUCCESS;
}

//
// Pop the top PCB from the current chain
//
NTSTATUS
PopCaller(
        ULONG    cpu
    )
{
    PCB *pcb = cpuhardware[cpu].currentchain;
    if (pcb == NULL) {
        return STATUS_ILLEGAL_INSTRUCTION;
    }
    cpuhardware[cpu].currentchain = pcb->chainlink;
//STRACE("[cpu, pcb, pcbeip, x]", cpu, pcb, pcb->ntcontext.Eip, 0)
    free(pcb);

    return STATUS_SUCCESS;
}

Portal *
allocateportal()
{
    Hashentry **prevlink;
    Portal     *portal;

    portal = malloc(sizeof(*portal));
    portal || FATALFAIL(STATUS_NO_MEMORY, "instantiateportal");
    ZERO(portal);

    portal->hash.value = nextportalid++;
    prevlink = PortalHash + HASH(portal->hash.value, ASIZEOF(PortalHash));

    portal->hash.link = *prevlink;
    *prevlink = &portal->hash;

    return portal;
}

void
referenceportal(
        Portal *portal
    )
{
    portal->refcount++;
}

void
dereferenceportal(
        Portal *portal
    )
{
    if (portal->refcount == 0)
        BUGCHECK("Under-referenced portal");

    --portal->refcount;
    if (portal->refcount == 0 && portal->destroyed) {
        free(portal);
    }
}


ULONG
CreatePortal(
        ULONG       cpu,
        UCHAR       type,
        UCHAR       mode,
        UCHAR       irql,
        ULONG       ctx,
        ULONG       handler,
        ULONG       protmask
    )
{

    Portal *portal = allocateportal();

    portal->type	    = type;
	portal->mode	    = mode;
	portal->irql	    = irql;
	portal->ctx	        = ctx;
	portal->handler	    = handler;
	portal->protmask    = protmask;

    if (portal->hash.value != (ULONG)portal->hash.value) BUGCHECK("portalid overflow");

//STRACE("[irql/type, ctx/mode, handler, portalid]", MASH(irql,type), MASH(ctx,mode), handler, (ULONG)portal->hash.value)
    return (ULONG)portal->hash.value;
}

Portal *
lookupportal(
        ULONG       portalid
    )
{
    Hashentry   *ptr = LookupHashEntry(PortalHash, ASIZEOF(PortalHash), portalid, NULL);
    return ptr?  CONTAINING_RECORD(ptr, Portal, hash)  :  NULL;
}

NTSTATUS
DestroyPortal(
        ULONG    cpu,
        ULONG    portalid
    )
{
    Hashentry  **prevlink  =  NULL;
    Hashentry   *ptr = LookupHashEntry(PortalHash, ASIZEOF(PortalHash), portalid, &prevlink);
    Portal      *portal;

//STRACE("[portalid, ptr, x, x]", portalid, ptr, 0, 0)
    if (ptr == NULL)
        return STATUS_INVALID_HANDLE;

    portal = CONTAINING_RECORD(ptr, Portal, hash);

    // remove the portal from the portalhash
    *prevlink = portal->hash.link;

    // mark as destroyed, and free if refcount is 0
    portal->destroyed = 1;
    if (portal->refcount == 0) {
        free(portal);
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\SPACE\Trap.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include "Defs.h"

// The global trapvector preempts the per-space trapvectors
Trapvector  GlobalTrapVector;

ULONG trapvectorlimits[NTRAPTYPES] = {
    NTRAP_EMULCALLS,
    NTRAP_SERVCALLS,
    NTRAP_INTERRUPTS,
    NTRAP_EXCEPTIONS,
    NTRAP_FAULTS
};

VOID     InitVADTree (Trapvector *pTrapvector);
Portal **InsertVAD   (Trapvector *pTrapvector, ULONG VirtualPageBase, ULONG VirtualPageLimit);
Portal **LookupVAD   (Trapvector *pTrapvector, ULONG VirtualPage);
BOOLEAN  DeleteVAD   (Trapvector *pTrapvector, ULONG VirtualPage);

Trapvector *
instantiatetrapvector()
{
    Trapvector *trapvector = malloc(sizeof(*trapvector));
    trapvector || FATALFAIL(STATUS_NO_MEMORY, "MapTrap");
    ZERO(trapvector);

    InitVADTree(trapvector);
    return trapvector;
}

//
//
//
NTSTATUS
MapTrap(
        ULONG       cpu,
        ULONG       ctx,
        UCHAR       traptype,
        UCHAR       global,
        ULONG       indexbase,
        ULONG       indexlimit,
        ULONG       portalid
    )
{
    Trapvector  *trapvector;
    Portal     **pportal;
    Portal      *portal;
    ULONG        i;

//STRACE("[ctx, G/traptype/portalid, indexbase, indexlimit]", ctx, (global<<31)|MASH(traptype,portalid), indexbase, indexlimit)
    portal = NULL;

    if (traptype != trapvaddr && traptype >= NTRAPTYPES)
        return STATUS_ILLEGAL_INSTRUCTION;

    // validate the trapvector limits
    if (traptype != trapvaddr) {
        if (indexlimit == 0)
            indexlimit = indexbase;

        if (indexbase > indexlimit  ||  indexlimit > trapvectorlimits[traptype])
            return STATUS_ILLEGAL_INSTRUCTION;

    } else if (indexbase < spaceparams.vpage_base || indexlimit && spaceparams.vpage_limit < indexlimit) {
            return STATUS_ILLEGAL_INSTRUCTION;
    }


    // validate that the ctx matches the traptype
    switch (ctx) {
    case   IOCTX:
        return STATUS_ILLEGAL_INSTRUCTION;

    case   EMULCTX:
        if (traptype != trapemul)
            return STATUS_ILLEGAL_INSTRUCTION;
        break;

    case   GLOBALCTX:
        if (traptype == trapemul)
            return STATUS_ILLEGAL_INSTRUCTION;
        if (!global)
            return STATUS_ILLEGAL_INSTRUCTION;
        break;

    default:    // a space ctx
        if (traptype == trapemul)
            return STATUS_ILLEGAL_INSTRUCTION;
        if (global)
            return STATUS_ILLEGAL_INSTRUCTION;
        break;
    }

    // lookup the portalid
    if (portalid) {
        portal = lookupportal(portalid);
        if (portal == NULL)
            return STATUS_ILLEGAL_INSTRUCTION;
    }

    if (global) {
        trapvector = &GlobalTrapVector;
    } else {
        if (spaces[ctx] == NULL)
            instantiatespace(ctx);
        trapvector = spaces[ctx]->trapvector;

        if (trapvector == NULL) {
            if (!portal) return STATUS_SUCCESS;
            trapvector = spaces[ctx]->trapvector = instantiatetrapvector();
        }
    }

    if (portal && traptype != portal->type)
        return STATUS_ILLEGAL_INSTRUCTION;

    switch (traptype) {
    case trapemul:
        // for emulation 'traps' the portal only controls access
        pportal = trapvector->emulation;
        break;

    case trapserv:
        pportal = trapvector->servicecall;
        break;

    case trapintr:
        pportal = trapvector->interrupts;
        break;

    case trapexcept:
        pportal = trapvector->exceptions;
        break;

    case trapfault:
        pportal = trapvector->faults;
        indexbase = indexlimit = TRAPFAULT_ACCESS;
        break;

    case trapvaddr:
        if (indexbase >= indexlimit)
            return STATUS_ILLEGAL_INSTRUCTION;

        pportal = InsertVAD(trapvector, indexbase, indexlimit);
        if (!pportal)
            return STATUS_ILLEGAL_INSTRUCTION;
        if (*pportal)
            dereferenceportal(*pportal);
        referenceportal(portal);
        *pportal = portal;
        return STATUS_SUCCESS;

    default:
        // should not be reachable since we already checked
        return STATUS_ILLEGAL_INSTRUCTION;
    }

    i = indexbase;
    do {
        if (pportal[i])
            dereferenceportal(pportal[i]);

        referenceportal(portal);
        pportal[i] = portal;
    } while (indexlimit && ++i < indexlimit);

    return STATUS_SUCCESS;
}


Portal *TrapToPortal(
        ULONG       ctx,
        ULONG       mode,
        Traptype    traptype,
        ULONG       trapindex
    )
{
    Trapvector  *glob = &GlobalTrapVector;
    Trapvector  *loc  = spaces[ctx]->trapvector;
    Portal      *defportal;
    Portal      *portal;
    Portal     **pportal;

//STRACE(" [ctx/mode loc traptype trapindex]", MASH(ctx,mode), loc, traptype, trapindex)
    if (!loc)
        loc  = spaces[ctx]->trapvector = instantiatetrapvector();

    defportal = loc->exceptions[TRAPEXCEPT_ILLEGALOP];
    if (defportal == NULL)
        defportal = glob->exceptions[TRAPEXCEPT_ILLEGALOP];

    defportal || BUGCHECK("LookupPortal no illegalop portal");

    portal = NULL;

    switch (traptype) {
    case trapemul:
        if (trapindex >= trapvectorlimits[traptype])
            break;

        portal = loc->emulation[trapindex];
        if (portal == NULL)
            portal = glob->emulation[trapindex];
        break;

    case trapserv:
        if (trapindex >= trapvectorlimits[traptype])
            break;

        portal = loc->servicecall[trapindex];
        if (portal == NULL)
            portal = glob->servicecall[trapindex];
        break;

    case trapintr:
        if (trapindex >= trapvectorlimits[traptype])
            break;

        portal = loc->servicecall[trapindex];
        if (portal == NULL)
            portal = glob->servicecall[trapindex];
        break;

    case trapexcept:
        if (trapindex >= trapvectorlimits[traptype])
            break;

        portal = loc->exceptions[trapindex];
        if (portal == NULL)
            portal = glob->exceptions[trapindex];
        break;

    case trapvaddr:
        if (trapindex < spaceparams.vpage_base || spaceparams.vpage_limit < trapindex)
            break;

        portal = NULL;
        pportal = LookupVAD(loc, trapindex);
        if (!pportal)
            pportal = LookupVAD(glob, trapindex);
        if (pportal) {
            portal = *pportal;
        }
        if (portal)
            break;

        // fall through ...

    case trapfault:
        if (trapindex >= trapvectorlimits[traptype])
            break;

        // simplify by mapping all faults into TRAPFAULT_ACCESS
        portal = loc->faults[TRAPFAULT_ACCESS];
        if (!portal)
            portal = glob->faults[TRAPFAULT_ACCESS];
        break;

    default:
        BUGCHECK("LookupPortal bad calltype");
        //notreached
        return NULL;
    }

    if (!portal) {
        return defportal;
    }

    if (ACCESSOK(portal->protmask, mode)) {
        return portal;
    }
    
    portal = loc->exceptions[TRAPEXCEPT_ACCESSDENIED];
    if (portal == NULL)
        portal = glob->exceptions[TRAPEXCEPT_ACCESSDENIED];

    if (portal == NULL)
        portal = defportal;

dump_Portal(portal, -1, "ACCESSDENIED");
    return portal;
}

void
cleantrapvector(
        Trapvector *trapvector
    )
{
    PVOID ptr;

    if (trapvector == NULL)
        return;

    while (! RtlIsGenericTableEmptyAvl(&trapvector->vadtree)) {
        ptr = RtlGetElementGenericTableAvl(&trapvector->vadtree, 0);
        (void) RtlDeleteElementGenericTableAvl(&trapvector->vadtree, ptr);
    }

    free(trapvector);
}

//
// VADTree routines for mapping Virtual Pages to Portals
//

typedef struct {
    ULONG       VirtualPageBase;
    ULONG       VirtualPageLimit;
    Portal     *Portal;
} VADNode;

RTL_GENERIC_COMPARE_RESULTS
NTAPI
VADCompare(
        PRTL_AVL_TABLE  pVadTable,
        PVOID           pFirst,
        PVOID           pSecond
    )
{
    VADNode *pFirstVad  = pFirst;
    VADNode *pSecondVad = pSecond;

    if (pFirstVad->VirtualPageLimit <= pSecondVad->VirtualPageBase)
        return GenericLessThan;
    if (pSecondVad->VirtualPageLimit <= pFirstVad->VirtualPageBase)
        return GenericGreaterThan;

    // else ranges overlap
    return GenericEqual;
}

PVOID
NTAPI
VADAlloc(
        struct _RTL_AVL_TABLE *Table,
        CLONG ByteSize
    )
{
    VADNode *v = malloc(ByteSize);

    if (v) {
        v->VirtualPageBase  = 0;
        v->VirtualPageLimit = 0;
        v->Portal           = NULL;
    }
    return v;
}

VOID
NTAPI
VADFree(
        struct _RTL_AVL_TABLE *Table,
        PVOID Buffer
    )
{
    free(Buffer);
}

VOID
InitVADTree(
        Trapvector *pTrapvector
    )
{
   RtlInitializeGenericTableAvl (&pTrapvector->vadtree, VADCompare, VADAlloc, VADFree, NULL);
}


Portal **
InsertVAD(
        Trapvector *pTrapvector,
        ULONG        VirtualPageBase,
        ULONG        VirtualPageLimit
    )
{
    BOOLEAN newflag;
    VADNode v;
    VADNode *p;

    v.VirtualPageBase  = VirtualPageBase;
    v.VirtualPageLimit = VirtualPageLimit;
    v.Portal           = NULL;

    p = RtlInsertElementGenericTableAvl (&pTrapvector->vadtree, &v, sizeof(v), &newflag);

    // if not a new element, then we had a conflict with an existing node
    // but if successful -- return the Portal in the allocated node, not our stack buffer!
    return newflag? &p->Portal  :  NULL;
}

Portal **
LookupVAD(
        Trapvector *pTrapvector,
        ULONG        VirtualPage
    )
{
    VADNode v;
    VADNode *p;

    v.VirtualPageBase   = VirtualPage;
    v.VirtualPageLimit  = VirtualPage + 1;
    v.Portal            = NULL;

    p = RtlLookupElementGenericTableAvl (&pTrapvector->vadtree, &v);

//STRACE("[trapvector vpage p p->Portal]", pTrapvector, VirtualPage, p, (p? &p->Portal : NULL))
    return p? &p->Portal : NULL;
}

BOOLEAN
DeleteVAD(
        Trapvector *pTrapvector,
        ULONG        VirtualPage
    )
{
    VADNode v;

    v.VirtualPageBase   = VirtualPage;
    v.VirtualPageLimit  = VirtualPage + 1;
    v.Portal            = 0;

    return RtlDeleteElementGenericTableAvl (&pTrapvector->vadtree, &v);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\SPACE\Util.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include "Defs.h"

//
// Deal with warnings and fatal errors
//
int
warn(char *msg, ULONG_PTR value)
{
    fprintf(stderr, "WARNING: ");
    fprintf(stderr, msg, value);
    return 0;
}

int
die (char *fmt, char *msg, ULONG_PTR value)
{
    fflush(stdout);
    fprintf(stderr, fmt, msg, value);
    fflush(stderr);

    cleanup();
    _exit(1);
    return 1;
}

//
// Generic hash lookup
//
Hashentry *
LookupHashEntry(
        Hashentry   *hashtable[],
        ULONG        tablesize,
        ULONGLONG    value,
        Hashentry ***pprevlink
    )
{
    Hashentry  *ptr;
    Hashentry **pprev;

    pprev = hashtable + HASH(value, tablesize);

    while ((ptr = *pprev)  &&  ptr->value != value) {
        pprev = &ptr->link;
    }

    if (pprevlink)
        *pprevlink = pprev;

    return ptr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\SPACE\DEVICES\Devices.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
// 
// You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#define DEVICES

#include "Devices.h"

#include "..\INC\DeviceDefs.h"

//
// Define a 'console' device for outputing messages
//
//
#define CONSOLEDEVICE_IRQL         2
#define CONSOLEDEVICE_INTERRUPT    2

struct {
    HANDLE           consolehandle;
} consoledevice;


ULONGLONG
ConsoledeviceAccess(
        ULONG cpu,              // ignored.  device accessible on every CPU
        int op,
        ULONG deviceregister,
        ULONG value,            // address of buffer in iospace
        ULONG valuex            // character count
    )
{
    WCHAR               outbuf[2048];
    WCHAR              *wp;
    ULONG               outbytes;
    int                 n;

//STRACE("[deviceregister, value, valuex, x]", deviceregister, value, valuex, 0)
    outbytes = sizeof(outbuf) - sizeof(outbuf[0]);
    valuex *= sizeof(WCHAR);
    if (outbytes > valuex) {
        outbytes = valuex;
    }

    switch (deviceregister) {
    case CONSOLEDEVICE_IORegister:
        switch (op) {
        case CONSOLEOP_PRINT:
            // synchronously copy from logical address to our device buffer, for outbytes
            (void) StartDMA(cpu, CONSOLEDEVICE_ID, (PCHAR)outbuf, (ULONG_PTR)value, outbytes, FALSE, NULL, NULL);
            outbuf[outbytes / sizeof(outbuf[0])] = 0;
            // write out our device buffer
            printf("%ws", outbuf);
            break;

        case CONSOLEOP_GETLINE:
            printf("INPUT> ");
            wp = fgetws(outbuf, outbytes/sizeof(WCHAR), stdin);
            if (wp == NULL)
                return 0;
            n = 1;  while (*wp++)  n++; // count characters, including nul

            // pseudo-DMA back to 'physical memory'
            // synchronously copy string in our device buffer to the logical address in 'physical' memory
            (void) StartDMA(cpu, CONSOLEDEVICE_ID, (PCHAR)outbuf, (ULONG_PTR)value, n*sizeof(WCHAR), TRUE, NULL, NULL);
        }
        return 1;

    default:
        return 0;
    }
}

// register all the devices as being on CPU 0
void
RegisterAllDevices()
{
    (void) RegisterDevice(0, CONSOLEDEVICE_ID, ConsoledeviceAccess,    CONSOLEDEVICE_INTERRUPT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\ProjectOZ\SPACE\i386\Bootstrap.asm ===
;;
;; Copyright (c) Microsoft Corporation. All rights reserved. 
;; 
;; You may only use this code if you agree to the terms of the ProjectOZ License agreement (see License.txt).
;; If you do not agree to the terms, do not use the code.
;;

TITLE   "SPACE NT process bootstrap executable"

include ..\INC\TrapValues.inc

.686
.model flat,c

defemulcall macro icall
        DWORD           emul_&icall&
endm

defservcall macro icall
        DWORD           OZ_&icall&
endm

;
; assumes a stack is setup
; services not using a stack have to be invoked more directly
;
SPACECall macro  emulcall,icall,N,indirflag,vectoroutflag
    if emulcall gt 0
        emul_&icall& LABEL PROC
    else
        OZ_&icall&   LABEL PROC
    endif

    ;; get argument pointer
    if indirflag gt 0
        mov  eax,  4[esp]
    else
        lea  eax,  4[esp]
    endif

        ;; save registers -- just in case
        push ebx
        push edi
        push esi

        ;; pass 0-5 parameters via the registers
    if N gt 0
            mov  ebx,   [eax]
     if N gt 1
            mov  ecx,  4[eax]
      if N gt 2
            mov  edx,  8[eax]
       if N gt 3
            mov  edi, 12[eax]
        if N gt 4
            mov  esi, 16[eax]
         if N gt 5
            .ERR too many parameters for emulation call
         endif
        endif
       endif
      endif
     endif
    endif

    if emulcall gt 0
        ;; emulation call
        BYTE            0f0h, 0fh, 0bh      ;; lock ud2 - is the illegal instruction for emulation calls
        BYTE            TRAPEMUL_&icall     ;; call index
    else
        BYTE            0fh, 0bh            ;; ud2 - is the illegal instruction for service calls
        WORD            icall               ;; call index
    endif

    if vectoroutflag gt 0
        ;; return parameters
        mov  eax,   16[esp]                 ;; 4 + the C we pushed
        mov    [eax],  ebx
        mov   4[eax],  ecx
        mov   8[eax],  edx
        mov  12[eax],  edi
        mov  16[eax],  esi
        xor  eax,      eax
    endif

        ;; restore registers
        pop  esi
        pop  edi
        pop  ebx

        ;; return (return values are in eax/edx -- except if vectoroutflag)
        ret
endm


;
; initial trap to SPACE for NT threads
; implementing CPUs in domains
;
.code
        PAGE
        SUBTTL "SPACE 'CPU' bootstrap code"
        EXTERNDEF  C bootspacecpu:PROC

; pointers stored Hat known absolute address so we don't have to link
; Linked at:  71001000
        DWORD   emulationvector
        DWORD   servicevector
        DWORD   libraryvector

; must match TrapTypes.h
emulationvector:
        defemulcall  Noop           ;  0
        defemulcall  MapMemory      ;  1
        defemulcall  MapIO          ;  2
        defemulcall  MapTrap        ;  3
        defemulcall  CreatePortal   ;  4
        defemulcall  DestroyPortal  ;  5
        defemulcall  CleanCtx       ;  6
        defemulcall  Resume         ;  7
        defemulcall  Suspend        ;  8
        defemulcall  Unsuspend      ;  9
        defemulcall  PopCaller      ; 10
        defemulcall  DiscardToken   ; 11
        defemulcall  StartCPU       ; 12
        defemulcall  InterruptCPU   ; 13
        defemulcall  AccessDevice   ; 14
        defemulcall  ManageIrql     ; 15
        defemulcall  HaltCPU        ; 16
        defemulcall  GetSPACEParams ; 17
        defemulcall  SPACEBreak     ; 18

; must match SystemLib.h
        extern  StudyImage:PROC     ;   SPACEStatus StudyImage(void *imagebase, ulong imagesize, Section imagesections[], int *nimagesections)
libraryvector:
        DWORD   StudyImage          ;  0

;
; bootstrap call -- immediately invokes Resume instruction, passing the NT stack pointer as result
;
bootspacecpu:
        xor             ebx, ebx            ; set result to 0
        ; fall through to Resume

;
; Resume
; Handling is special, because we don't return, and our stack is already deleted 
; ebx already contains the result value
;
emul_Resume:
        BYTE 0f0h, 0fh, 0bh                 ; lock ud2 - is the illegal instruction for emulation calls
        BYTE TRAPEMUL_Resume                ; Resume()
        ;; not reached

;
; emit emulation calls - calling conventions must agree with definitions in SPACEOps.h, SPACEOps.c, and Bootstrap.asm
; third  parameter is 0 if a scalar call, 1 if a vector call, 2 if vector in/out call
;
;SPACECall: emulcall, icall,    N,indirflag,vectoroutflag   ; description
    SPACECall	1, Noop,			0, 0, 0 ; void  Noop()
    SPACECall	1, MapMemory,		5, 1, 0 ; void  MapMemory(ulong ctx, ulong vpage, ulong ppage, ulong readmask, ulong writemask)
    SPACECall	1, MapIO,			3, 1, 0 ; void  MapIO(ushort deviceid, uchar npages, uchar writable, ulong lbasepage, ulong ppage[])
    SPACECall	1, MapTrap,		    5, 1, 0 ; void  MapTrap(ulong ctx, uchar traptype, uchar global, 
                                            ;                     ulong indexbase, ulong indexlimit, ulong portalid)
    SPACECall	1, CreatePortal,    4, 1, 0 ; ulong portalid = CreatePortal(uchar type, uchar suspendflag, uchar mode, uchar irql,
                                            ;                               ulong ctx, ulong handler, ulong protmask)
    SPACECall	1, DestroyPortal,	1, 0, 0 ; void  DestroyPortal(ulong portalid)
    SPACECall	1, CleanCtx,		1, 0, 0 ; void  CleanCtx(ulong ctx)
;   SPACECall	1, Resume,			1, 0, 0 ; void  Resume(ulong result) -- cannot use SPACEcall because OZ already deleted stack
    SPACECall	1, Suspend,		    0, 1, 0 ; SPACETOKEN Suspend() - returns token
    SPACECall	1, Unsuspend,		2, 0, 0 ; void  Unsuspend(SPACETOKEN token)
    SPACECall	1, PopCaller,		0, 0, 0 ; void  PopCaller()
    SPACECall	1, DiscardToken,	2, 0, 0 ; void  DiscardToken(SPACETOKEN token)
    SPACECall	1, StartCPU,		5, 1, 0 ; void  StartCPU(ulong boot_cpu, ulong boot_ctx, ulong boot_mode, ulong boot_pc, ulong boot_arg)
    SPACECall	1, InterruptCPU,	1, 1, 0 ; void  InterruptCPU(uchar targetcpu, uchar interrupt, uchar irql)
    SPACECall	1, AccessDevice,	3, 1, 0 ; ulong AccessDevice(ushort deviceid, uchar op, uchar deviceregister, ulong value, ulong valuex)
    SPACECall	1, ManageIrql,		1, 1, 0 ; ulong ManageIrql(IrqlOps op, uchar irql)
    SPACECall	1, HaltCPU,		    0, 0, 0 ; void  HaltCPU()
    SPACECall	1, GetSPACEParams,	5, 1, 1 ; void  GetSPACEParams(...)
    SPACECall	1, SPACEBreak,	    5, 1, 1 ; void  SPACEBreak(ulong breakvalue, uchar breakmsg[16])


; the table of service calls for BasicOZ:
; emit actual service calls
        icall = 0
        while icall lt TRAPSERV_MAXCALLS
            ; XXX: nothing indirect or vectorout (so far), but could conditionally operate on the icall encodings if we wanted to add this
            SPACECall	0, %(icall), 5, 0, 0 ; ulong64 ServiceCall(arg0, arg1, arg2, arg3, arg4)
            icall = (icall+1)
        endm

; emit vector
servicevector:
        icall = 0
        while icall lt TRAPSERV_MAXCALLS
            defservcall %(icall)
            icall = (icall+1)
        endm

; end of file
    end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\Windows Undocumented File Formats\wuff_src\CHAP1\DUMP\DUMP.C ===
/**********************************************************************
 *
 * PROGRAM: DUMP.C
 *
 * PURPOSE: Produce a simple hex dump of a file.
 *
 * Copyright 1997, Mike Wallace and Pete Davis
 *
 * Chapter 1, Introduction and Overview, from Undocumented Windows
 * File Formats, published by R&D Books, an imprint of Miller Freeman, Inc.
 *
 **********************************************************************/

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
typedef unsigned char     BYTE;

/***************************************************
  Performs a Hex/ASCII dump of a file.
****************************************************/
void HexDump(FILE *File) {

   char        Buffer[16];
   long        counter, FileSize;
   int         BytesToPrint, Index;

   fseek(File, 0, 2);
   FileSize = ftell(File);
   fseek(File, 0, 0);
   printf("Offset                   Hex Values");
   printf("                           Ascii\n");
   printf("--------------------------------------");
   printf("-----------------------------------\n");

   for (counter = 0; counter < FileSize; counter+=16) {

      printf("0x%08lX: ", counter);
      BytesToPrint = fread(Buffer, 1, 16, File);
      for (Index=0; Index < BytesToPrint; Index++) 
          printf("%02X ", (BYTE) Buffer[Index]);
      for (Index=0; Index < 16-BytesToPrint; Index++) 
          printf("   ");
      for (Index=0; Index < BytesToPrint; Index++) 
          putchar( isprint( Buffer[Index] ) ? Buffer[Index] : '.' );
      putchar('\n');
   }
}

/***************************************************
  Show usage.
****************************************************/
void Usage() {

  printf("Usage:\n");
  printf(" DUMP filename\n\n");
  printf("   filename - Name of file to dump\n");
 
}

/***************************************************
  Open the file and dump it.
****************************************************/
int main(int argc, char *argv[]) {

    char filename[40];
    FILE *File;

    if (argc != 2) {
       Usage();
       return EXIT_FAILURE;
    }

    strcpy(filename, argv[1]);
    _strupr(filename);

    if ((File = fopen(filename, "rb")) == NULL) {
       printf("%s does not exist!", filename);
       return EXIT_FAILURE;
    }

    HexDump(File);
    fclose(File);

    return EXIT_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\Windows Undocumented File Formats\wuff_src\CHAP1\SETVAL\SETVAL.C ===
/**********************************************************************
 *
 * PROGRAM: SETVAL.C
 *
 * PURPOSE: Modify a byte in a file
 *
 * Copyright 1997, Mike Wallace and Pete Davis
 *
 * Chapter 1, Introduction and Overview, from Undocumented Windows
 * File Formats, published by R&D Books, an imprint of Miller Freeman, Inc.
 *
 **********************************************************************/

#include <stdio.h>
#include <string.h>

void usage()
{
  printf("Usage: SETVAL fn addr val\n");
  printf("  Where addr is the hex location of the byte\n");
  printf("  in the file to modify and val is the byte (in hex)\n");
  printf("  to set at that location.\n\n");
  printf(" Example:  SETVAL LIST.TXT 4B3 FF\n\n");
}

int main(int argc, char *argv[])
{
  char filename[256];
  char address[10], val[10];
  long nAddr = 0, nVal = 0;
  FILE *fp;

  if (argc != 4)
  {
    usage();
    return 0;
  }
  strcpy(filename, argv[1]);

  if ((fp = fopen(filename, "r+b")) == NULL)
  {
    printf("Bad filename supplied\n");
    return 0;
  }

  strcpy(address, argv[2]);
  strcpy(val, argv[3]);

  sscanf(address, "%lx", &nAddr);
  sscanf(val, "%lx", &nVal);

  if (nVal < 0 || nVal > 255)
  {
    usage();
    printf("Error: Supply a val between 0 and 255\n");
  }

  fseek(fp, 0, SEEK_END);
  if (ftell(fp) < nAddr)
  {
    printf("The address supplied is beyond the end of this file.\n");
    printf("Please supply a value within the scope of this file.\n");
    fclose(fp);
    return 0;
  }

  fseek(fp, nAddr + 1, SEEK_SET);
  fwrite(&nVal, 1, 1, fp);
  fclose(fp);

  printf("File modified successfully.\n");
  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\Windows Undocumented File Formats\wuff_src\CHAP10\LEDUMP.H ===
/**********************************************************************
 *
 * PROGRAM: LEDUMP.H
 *
 * PURPOSE: Header file for LEDUMP.C
 *
 * Copyright 1997, Mike Wallace and Pete Davis
 *
 * Chapter 10, LE File Format, from Undocumented Windows File Formats,
 * published by R&D Books, an imprint of Miller Freeman, Inc.
 *
 **********************************************************************/

/* Mini-MZ Header. Need only 2 fields */
typedef struct tagMZHEADER
{
	char	MZMagic[2];
	char	Stuff[58];		/* Stuff we don't care about */
	long	LEOff;
} MZHEADER;

/* LE Header structure */
typedef struct tagLEHEADER
{
	char	LEMagic[2];
	BYTE	ByteOrder;
	BYTE	WordOrder;
	DWORD	FormatLevel;
	WORD	CPUType;
	WORD	OSType;
	DWORD	ModuleVer;
	DWORD	ModuleFlags;
	DWORD	NumPages;
	DWORD	EIPObjNum;
	DWORD	EIP;
	DWORD	ESPObjNum;
	DWORD	ESP;
	DWORD	PageSize;
	DWORD	LastPageSize;
	DWORD	FixupSize;
	DWORD	FixupChecksum;
	DWORD	LoaderSize;
	DWORD	LoaderChecksum;
	DWORD	ObjTblOffset;
	DWORD	NumObjects;
	DWORD	ObjPageTbl;
	DWORD	ObjIterPage;
	DWORD	ResourceTbl;
	DWORD	NumResources;
	DWORD	ResNameTable;
	DWORD	EntryTable;
	DWORD	ModDirectTable;
	DWORD	NumModDirect;
	DWORD	FixUpPageTable;
	DWORD	FixUpRecTable;
	DWORD	ImportModTable;
	DWORD	NumImports;
	DWORD	ImportProcTable;
	DWORD	PerPageChecksum;
	DWORD	DataPages;
	DWORD	NumPreloadPages;
	DWORD	NonResTable;
	DWORD	NonResSize;
	DWORD	NonResChecksum;
	DWORD	AutoDSObj;
	DWORD	DebugInfoOff;
	DWORD	DebugInfoLen;
	DWORD	NumInstPreload;
	DWORD	NumInstDemand;
	DWORD	HeapSize;
} LEHEADER;
	
/* Defines for Byte and Word Order */
#define ORD_LITTLEENDIAN	0x00
#define	ORD_BIGENDIAN		0x01

/* Defines for CPU Type */
#define CPU_286				0x01
#define CPU_386				0x02
#define CPU_486				0x03

/* Defines for OS Type */
#define OS_UNKNOWN			0x00
#define OS_OS2				0x01
#define OS_WINDOWS			0x02
#define OS_DOS4X			0x03
#define OS_WINDOWS386		0x04

/* Defines for Module Flags */
#define MOD_PERPROCESSLIBINIT	0x00000004
#define MOD_INTERNALFIXUPS		0x00000010
#define MOD_EXTERNALFIXUPS		0x00000020
#define MOD_INCOMPAT_PM			0x00000100
#define MOD_COMPAT_PM			0x00000200
#define MOD_USES_PM				0x00000300
#define MOD_NOTLOADABLE			0x00002000
#define MOD_MODTYPEMASK			0x00038000
#define MOD_PROGRAMMOD			0x00000000
#define MOD_LIBMOD				0x00008000
#define MOD_PROTLIBMOD			0x00018000
#define MOD_PHYSDEVICEDRVR		0x00020000
#define MOD_VIRTDEVICEDRVR		0x00028000
#define MOD_PERPROCLIBTERM		0x40000000

	
/* Object Table Entry Records */
typedef struct tagOBJTBLENTRY
{
	DWORD	VirtualSize;
	DWORD	RelocBaseAddr;
	DWORD	ObjectFlags;
	DWORD	PageTableIndex;
	DWORD	NumPgTblEntries;
	DWORD	Reserved;
} OBJTBLENTRY;

/* Defines for Object Flags */
#define OBJ_READABLE		0x0001
#define OBJ_WRITEABLE		0x0002
#define OBJ_EXECUTABLE		0x0004
#define OBJ_RESOURCE		0x0008
#define OBJ_DISCARDABLE		0x0010
#define OBJ_SHARED			0x0020
#define OBJ_PRELOAD			0x0040
#define OBJ_INVALID			0x0080
#define OBJ_ZEROFILLED		0x0100
#define OBJ_RESIDENT		0x0200
#define OBJ_RESIDENTCONTIG	0x0300
#define OBJ_RESIDENTLOCK	0x0400
#define OBJ_RESERVED		0x0800
#define OBJ_1616ALIAS		0x1000
#define OBJ_BIGDEFAULT		0x2000
#define OBJ_CONFORM			0x4000
#define OBJ_PRIVILEGE		0x8000


/* Object Page Table Entries */
typedef struct tagOBJPAGETBLENTRY
{
	DWORD	PageDataOffset;
	WORD	DataSize;
	WORD	ObjPageFlags;
} OBJPAGETBLENTRY;

/* Defines for Object Page Flags */
#define OPG_LEGAL			0x00
#define OPG_ITERATEDDATA	0x01
#define OPG_INVALID			0x02
#define OPG_ZEROFILL		0x03
#define OPG_RANGE			0x04


typedef struct tagFIXUPREC
{
	BYTE	Src;
	BYTE	Flags;
	WORD	SrcOff_Cnt;
} FIXUPREC;

typedef struct tagPROCBYNAME
{
	WORD	ModuleOrd;
	DWORD	ProcNameOff;
} PROCBYNAME;

typedef struct tagPROCBYORD
{
	WORD	ModuleOrd;
	WORD	ImportOrd;
};
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\Windows Undocumented File Formats\wuff_src\CHAP10\LEDUMP.C ===
/**********************************************************************
 *
 * PROGRAM: LEDUMP.C
 *
 * PURPOSE: Dump 'LE' file info
 *
 * Copyright 1997, Mike Wallace and Pete Davis
 *
 * Chapter 10, LE File Format, from Undocumented Windows File Formats,
 * published by R&D Books, an imprint of Miller Freeman, Inc.
 *
 **********************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <windows.h>
#include "ledump.h"

/* Make this big thing global since we'll need it everywhere. */
LEHEADER	LEHeader;
long		LEStart;	/* Keep track of start of LE Header */


BOOL SkipMZ(FILE *LEFile)
{
	MZHEADER MZHeader;

	fread(&MZHeader, sizeof(MZHeader), 1, LEFile);
	if (MZHeader.MZMagic[0] != 'M' || MZHeader.MZMagic[1] != 'Z')
	{
		printf("This is not an executable file!\n");
		return FALSE;
	}

	if (!MZHeader.LEOff)
	{
		printf("This is a DOS executable.\n");
		return FALSE;
	}

	fseek(LEFile, MZHeader.LEOff, SEEK_SET);
	return TRUE;
}

void DumpHeaderInfo()
{
	DWORD Flags;
	
	Flags = LEHeader.ModuleFlags; /* Get it into an easier to type variable */
	
	printf("CPU Required: ");
	switch(LEHeader.CPUType)
	{
		case CPU_286:
			printf("80286\n");
			break;
		case CPU_386:
			printf("80386\n");
			break;
		case CPU_486:
			printf("80486\n");
			break;
	}
	
	printf("OS Required: ");
	switch(LEHeader.OSType)
	{
		case OS_UNKNOWN:
			printf("Unknown\n");
			break;
		case OS_OS2:
			printf("OS/2\n");
			break;
		case OS_WINDOWS:
			printf("Windows\n");
			break;
		case OS_DOS4X:
			printf("DOS 4.x\n");
			break;
		case OS_WINDOWS386:
			printf("Windows 386 Enhanced Mode\n");
			break;
	}
	
	printf("Initial EIP: %lX:%08lX\n", LEHeader.EIPObjNum, LEHeader.EIP);
	printf("Initial ESP: %lX:%08lX\n", LEHeader.ESPObjNum, LEHeader.ESP);
	
	printf("Flags: 0x%08lX\n", Flags);
	if (Flags & MOD_PERPROCESSLIBINIT)
		printf("- Per Process Library Initialization\n");
	if (Flags & MOD_INTERNALFIXUPS)
		printf("- Internal Fixups\n");
	if (Flags & MOD_EXTERNALFIXUPS)
		printf("- External Fixups\n");
	if ( (Flags & MOD_USES_PM) == MOD_USES_PM)
		printf("- Uses Presentation Manager\n");
	else
	{
		if (Flags & MOD_INCOMPAT_PM)
			printf("- Incompatible with Presentation Manager\n");
		if (Flags & MOD_COMPAT_PM)
			printf("- Compatible with Presentation Manager\n");
	}
	if (Flags & MOD_NOTLOADABLE)
		printf("- Module is not loadable.\n");
	if ( (Flags & MOD_PROTLIBMOD) == MOD_PROTLIBMOD)
		printf("- Protected Memory Library Module\n");
	else if ( (Flags & MOD_VIRTDEVICEDRVR) == MOD_VIRTDEVICEDRVR)
		printf("- Virtual Device Driver Module\n");
	else
	{
		if (Flags & MOD_LIBMOD)
			printf("- Library Module\n");
		if (Flags & MOD_PHYSDEVICEDRVR)
			printf("- Physical Device Driver\n");
	}
	if (Flags & MOD_PERPROCLIBTERM)
		printf("- Per-Process Library Termination\n");
		
	printf("\n");
}

void DumpObjectTable(FILE *LEFile)
{
	DWORD 		i;
	OBJTBLENTRY	ote;
	
	printf("There are %ld objects in the Object Table.\n", LEHeader.NumObjects);
	
	fseek(LEFile, LEStart + LEHeader.ObjTblOffset, SEEK_SET);
	for (i=1; i<=LEHeader.NumObjects; i++)
	{
		fread(&ote, sizeof(ote), 1, LEFile);
		printf("Segment #: %ld  Size: 0x%08lX  Reloc Addr: 0x%08lX   # Pages: %ld\n",
				i, ote.VirtualSize, ote.RelocBaseAddr, ote.NumPgTblEntries);
		if (i == LEHeader.AutoDSObj)
			printf("Auto Data Segment\n");
		printf("Flags:\n");
		if (ote.ObjectFlags & OBJ_READABLE)
			printf("Readable\n");
		if (ote.ObjectFlags & OBJ_WRITEABLE)
			printf("Writeable\n");
		if (ote.ObjectFlags & OBJ_EXECUTABLE)
			printf("Executable\n");
		if (ote.ObjectFlags & OBJ_RESOURCE)
			printf("Resource\n");
		if (ote.ObjectFlags & OBJ_DISCARDABLE)
			printf("Discardable\n");
		if (ote.ObjectFlags & OBJ_SHARED)
			printf("Shared\n");
		if (ote.ObjectFlags & OBJ_PRELOAD)
			printf("Preload\n");
		if (ote.ObjectFlags & OBJ_INVALID)
			printf("Invalid\n");
		if ( (ote.ObjectFlags & OBJ_RESIDENTCONTIG) == OBJ_RESIDENTCONTIG)
			printf("Resident & Contiguous\n");
		else
		{
			if (ote.ObjectFlags & OBJ_ZEROFILLED)
				printf("Zero-Filled\n");
			if (ote.ObjectFlags & OBJ_RESIDENT)
				printf("Resident\n");
		}
		if (ote.ObjectFlags & OBJ_RESERVED)
			printf("Reserved\n");
		if (ote.ObjectFlags & OBJ_1616ALIAS)
			printf("16:16 Alias Required\n");
		if (ote.ObjectFlags & OBJ_BIGDEFAULT)
			printf("'Big' bit for segment descriptor\n");
		if (ote.ObjectFlags & OBJ_CONFORM)
			printf("Object is conforming to code\n");
		if (ote.ObjectFlags & OBJ_PRIVILEGE)
			printf("Object I/O privilege level\n");
		printf("\n");
	}
}

void DumpNameTable(FILE *LEFile, DWORD size)
{
	DWORD	Curr;
	BYTE	len;
	char	Name[257];
	WORD	Ord;
	
	Curr = 0;
	while (Curr < size)
	{
		fread(&len, sizeof(len), 1, LEFile);
		Curr += (len + sizeof(len) + sizeof(Ord));
		fread(Name, len, 1, LEFile);
		Name[len] = 0x00;
		fread(&Ord, sizeof(Ord), 1, LEFile);
		printf("%u         %s\n", Ord, Name);
	}
	
}

/* Dumps the Resident and Non-Resident Name Tables */
void DumpNameTables(FILE *LEFile)
{
	printf("\nResident Name Table\n");
	printf("Ordinal   Name\n");
	fseek(LEFile, LEStart + LEHeader.ResNameTable, SEEK_SET);
	DumpNameTable(LEFile, (LEHeader.EntryTable - LEHeader.ResNameTable) - 1);
	printf("\n");
	printf("Non-Resident Name Table\n");
	printf("Ordinal   Name\n");
	fseek(LEFile, LEHeader.NonResTable, SEEK_SET);
	DumpNameTable(LEFile, LEHeader.NonResSize - 1);
	
}
/*
void DumpImports(FILE *LEFile)
{
	FIXUPREC	FixupRec;
	PROCBYNAME	ProcByName;
	PROCBYORD	ProcByOrd;
	long		CurrLoc;
	
	fseek(LEFile, LEStart+LEHeader.FixupRecTable, SEEK_SET);
	

}
*/
void Check4HeaderSurprises()
{
	if (LEHeader.ByteOrder != ORD_LITTLEENDIAN)
		printf("Byte Order is not Little Endian!\n");
	if (LEHeader.WordOrder != ORD_LITTLEENDIAN)
		printf("Word Order is not Little Endian!\n");
	
	if (LEHeader.CPUType < CPU_386)
		printf("Doesn't require a 386 or better!\n");
	if (LEHeader.OSType != OS_WINDOWS386) 
		printf("Not a Windows386 VxD!\n"); 

	if (LEHeader.ResourceTbl)
		printf("Resource Table Found!\n");
	if (LEHeader.NumResources)
		printf("Num Resources Found!\n");
	if (LEHeader.ModDirectTable)
		printf("Module Directive Table Found!\n");
	if (LEHeader.NumModDirect)
		printf("NumModDirect Found!\n");
	if (LEHeader.NumInstPreload)
		printf("Instance Preloads Found!\n");
	if (LEHeader.NumInstDemand)
		printf("Instance Demands Found!\n");
	if (LEHeader.FixupChecksum)
		printf("Fixup Checksum Found!\n");
	if (LEHeader.LoaderChecksum)
		printf("Loader Checksum Found!\n");
	if (LEHeader.PerPageChecksum)
		printf("Per-Page Checksum Found!\n");
	if (LEHeader.NonResChecksum)
		printf("Non-Resident Name Table Checksum Found!\n");
}

void DumpLEFile(FILE *LEFile)
{
	LEStart = ftell(LEFile);

	fread(&LEHeader, sizeof(LEHeader), 1, LEFile);
	if (LEHeader.LEMagic[0] != 'L' || LEHeader.LEMagic[1] != 'E') 
	{
		printf("This is not an 'LE' executable.\n\n");
		return;
	}
	
	DumpHeaderInfo();
	
	Check4HeaderSurprises();
	
	DumpObjectTable(LEFile);
	
	DumpNameTables(LEFile);

//	if (LEHeader.NumImports)	
//		DumpImports(LEFile);

}

void Usage(void)
{
	printf("Usage: LEDump filename[.386]\n\n");
}

int main(int argc, char *argv[]) 
{

	char 	filename[256];
	FILE 	*LEFile;

	if (argc < 2) {
		Usage();
		return EXIT_FAILURE;
	}
	
	strcpy(filename, argv[1]);
	
	if (!strchr(filename, '.'))
		strcat(filename, ".386");
		
	if ((LEFile = fopen(filename, "rb")) == NULL) {
		printf("%s does not exist!\n", filename);
		return EXIT_FAILURE;
	}
	
	if (SkipMZ(LEFile)) 
	{
		printf("Dumping %s\n", filename);
		DumpLEFile(LEFile);
	}
	fclose(LEFile);
	return EXIT_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\Windows Undocumented File Formats\wuff_src\CHAP3\SHEDEDIT.H ===
/**********************************************************************
 *
 * PROGRAM: SHEDEDIT.H
 *
 * PURPOSE: Header file for SHGDUMP.C
 *
 * Copyright 1997, Mike Wallace and Pete Davis
 *
 * Chapter 3, Segmented Hypergraphic (.SHG) File Format, 
 * from Undocumented Windows File Formats, published by R&D Books,
 * an imprint of Miller Freeman, Inc.
 *
 **********************************************************************/

/* Structures for .SHG files */

/* SHG File Header */
typedef struct tagSHGFILEHEADER
{
  char  sfType[2];    /* Must be 'lp' or 0x706C     */
  WORD  sfNumObjects; /* Number of objects in file  */
  DWORD *sfObjectOff; /* Offsets to objects in file */
}
SHGFILEHEADER;

/* SHG Image Header */
typedef struct tagSHGIMAGEHEADER
{
  BYTE  siImageType;      /* 0x06=.BMP  0x08=.WMF                */
  BYTE  siCompression;    /* 0x00 = None, 0x01 = RLE, 0x02= LZ77 */
  BYTE  siDPI;            /* Dots Per Inch x 2 (0x10 for .wmf)   */
}  
SHGIMAGEHEADER;

/* Defines for image type and compression type */
#define IT_BMP   0x06
#define IT_WMF   0x08
#define IC_NONE  0x00
#define IC_RLE   0x01
#define IC_LZ77  0x02
#define IC_BOTH  0x03

/* SHG Bitmap Header */
typedef struct tagSHGBITMAPHEADER
{
  BYTE  sbIsZero;      /* Always 0x00                   */
  BYTE  sbDPI;         /* Dots Per Inch x 2             */
  WORD  sbTwoHund;     /* 0x0200                        */
  WORD  sbNumBits;     /* Number bits per pixel x 2     */
  DWORD sbWidth;       /* Width x 2                     */
  DWORD sbHeight;      /* Height x 2                    */
  DWORD sbNumQuads;    /* Number RGB Quads x 2          */
  WORD  sbNumImp;      /* Number of 'important' RGB Qds */
  DWORD sbCmpSize;     /* Size of Compressed BMP x 2    */
  DWORD sbSizeHS;      /* Size of Hotspot Data area x 2 */
  DWORD sbunk1; 
  DWORD sbSizeImage;   /* size ImageHdr+BmpHdr+ImageDat */
}
SHGBITMAPHEADER;

/* SHG Metafile Header */
typedef struct tagSHGMETAFILEHEADER
{
  WORD  smXWidth;    /* Width of image in metafile units  */
  WORD  smYHeight;   /* Height of image in metafile units */
  DWORD smUncSize;   /* Size of uncompressed metafile     */
  DWORD smCmpSize;   /* Size of compressed metafile       */
  DWORD smSizeHS;    /* Size of hot spot data area x 2    */
  DWORD smUnk1; 
  DWORD smSizeImage; /* Size ImageHdr+wmfHdr+ImageDat     */
}
SHGMETAFILEHEADER;

/* Documented in "Microsoft Windows 3.1 Programmer's 
   Referenece Volume 4, Resources." Not in WINDOWS.H.
   This is the header for a Placeable Metafile        */
typedef struct tagMETAFILEHEADER
{
  DWORD  key;
  HANDLE hmf;      /* Must be 0 */
  RECT   bbox;
  WORD   inch; 
  DWORD  reserved; /* Must be 0 */
  WORD   checksum;
}
METAFILEHEADER;

/* Hot Spot Header */
typedef struct tagHOTSPOTHEADER
{
  BYTE  hhOne;           /* Always 0x01                   */
  WORD  hhNumHS;         /* Number of Hot Spots           */
  DWORD hhContextOffset; /* Offset to Cntxt Strings & IDs */
}
HOTSPOTHEADER;

/* Hot Spot Record */
typedef struct tagHOTSPOTRECORD
{
  WORD  hrType; /* Hot Spot Type. See below */
  BYTE  hrZero; /* Always 0                 */
  WORD  hrLeft; /* Bounding box of Hot Spot */
  WORD  hrTop;
  WORD  hrRight;
  WORD  hrBottom;
  DWORD hrMacOffset; /* Offset to macro for Hot Spot */
}
HOTSPOTRECORD;

#define HS_INVISJUMP  0x04E7
#define HS_INVISPOPUP 0x04E6
#define HS_INVISMACRO 0x04CC
#define HS_VISJUMP    0x00E3
#define HS_VISPOPUP   0x00E2
#define HS_VISMACRO   0x00C8
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\Windows Undocumented File Formats\wuff_src\CHAP4\HLPDUMP2.C ===
/**********************************************************************
 *
 * PROGRAM: HLPDUMP2.C
 *
 * PURPOSE: A dump program that lets you view internal WinHelp files
 *
 * Copyright 1997, Mike Wallace and Pete Davis
 *
 * Chapter 4, Windows Help File Format, from Undocumented Windows
 * File Formats, published by R&D Books, an imprint of Miller Freeman, Inc.
 *
 **********************************************************************/

#define MEM_DEBUG 1

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <conio.h>
#include <ctype.h>
#include <limits.h>
#include <string.h>
#include "winhelp.h"
#include "hlpdump2.h"

#define HLP_DEBUG 1

#define CHECK_SIGNATURE(is, shouldbe) \
         {if (is != shouldbe) { \
            printf("Signature should be %x, but is %x\n"); \
            return;} }
             

/* Tells us if a particular bit is set or not */
#define BITSET(bitmap, bit) \
        ((bitmap & (1 << bit)) ? 1 : 0 )

/* Sum of set bits in a byte + 8 */
#define BYTESTOREAD(bitmap) \
        ( BITSET(bitmap, 0) + BITSET(bitmap, 1) + \
          BITSET(bitmap, 2) + BITSET(bitmap, 3) + \
          BITSET(bitmap, 4) + BITSET(bitmap, 5) + \
          BITSET(bitmap, 6) + BITSET(bitmap, 7) + 8 )


/***************************************************
  Loads the HFSFileHeader
****************************************************/

long LoadHeader(FILE *HelpFile) 
{
  HFSFILEHEADER fileHeader;
  
  fread(&fileHeader, sizeof(HFSFILEHEADER), 1, HelpFile);
  
#ifdef HLP_DEBUG
  printf("DEBUG -> LoadHeader()\n");
  printf("File plus Header: %ld\n", fileHeader.FilePlusHeader);
  printf("File size: %ld\n", fileHeader.FileSize);
  printf("File type: 0x%02x\n\n", fileHeader.FileType);
#endif
  
  return fileHeader.FileSize;
}


/*************************************************
  Decompresses the data using Microsoft's LZ77
derivative (called Zeck Compression)
**************************************************/ 

long Decompress(FILE *HelpFile, long CompSize, char *Buffer) {

long InBytes = 0;        /* How many bytes read in                    */
long OutBytes = 0;       /* How many bytes written out                */
BYTE BitMap, Set[16];    /* Bitmap and bytes associated with it       */
long NumToRead;          /* Number of bytes to read for next group    */
long counter, Index;     /* Going through next 8-16 codes or chars    */
long Length, Distance;   /* Code length and distance back in 'window' */
char *CurrPos;           /* Where we are at any given moment          */
char *CodePtr;           /* Pointer to back-up in LZ77 'window'       */


  CurrPos = Buffer;

  /* Go through until we're done */
  while (InBytes < CompSize) {

    /* Get BitMap and data following it */
    BitMap = (BYTE) fgetc(HelpFile);
    NumToRead = BYTESTOREAD(BitMap);

    /* If we're trying to read more than we've 
       got left, only read what we have left.  */
    NumToRead = (CompSize - InBytes) < NumToRead ? 
                                    CompSize-InBytes : NumToRead;

    fread(Set, 1, (int) NumToRead, HelpFile);    
    InBytes += NumToRead + 1;

    /* Go through and decode data */
    for (counter = 0, Index = 0; counter < 8; counter++) {

      /* It's a code, so decode it and copy the data */
      if (BITSET(BitMap, counter)) {
        Length = ((Set[Index+1] & 0xF0) >> 4) + 3;
        Distance = ((Set[Index+1] & 0x0F) << 8) + Set[Index] + 1;
        CodePtr = CurrPos - Distance;

        /* Copy data from 'window' */
        while (Length) {
          *CurrPos++ = *CodePtr++;
          OutBytes++;
          Length--;
        } 
        Index += 2;
      } 
      else {
        *CurrPos++ = Set[Index++];
        OutBytes++;
      }
    } /* for */
  } /* while  */
  return OutBytes;
} 


/***************************************************
  Performs a Hex/ASCII dump of an HFS file.
****************************************************/

void HexDumpData(FILE *HelpFile, long fileSize) 
{
  char           Buffer[16];
  long           counter;
  long           BytesToPrint, Index;

  printf("Offset                   Hex Values                           Ascii\n");
  printf("-------------------------------------------------------------------------\n");

  for (counter = 0; counter < fileSize; counter+=16) {

    printf("0x%08lX: ", counter);

    /* If this is the last line, how many bytes are in it? */
    BytesToPrint = ((fileSize - counter) > 16) ? 16 : (fileSize - counter);
    fread(Buffer, BytesToPrint, 1, HelpFile);

    /* Dump Hex */
    for (Index=0; Index < BytesToPrint; Index++)
      printf("%02X ", (BYTE) Buffer[Index]);

    /* If last line, fill in blanks */
    for (Index=0; Index < 16-BytesToPrint; Index++) 
      printf("   ");

    /* Dump Ascii */
    for (Index=0; Index < BytesToPrint; Index++) 
      putchar( isprint( Buffer[Index] ) ? Buffer[Index] : '.' );

    putchar('\n');
  }

  free(Buffer);
}


/***************************************************
  Performs a Hex/ASCII dump of an HFS file.
****************************************************/

void HexDumpFile(FILE *HelpFile, long FileStart) 
{
  long           fileSize;

  fseek(HelpFile, FileStart, SEEK_SET);

  fileSize = LoadHeader(HelpFile);  
  
  printf("File Size: 0x%08lX\n\n", fileSize);
  
  HexDumpData(HelpFile, fileSize);
}

/***************************************************
  Dumps the |SYSTEM info
****************************************************/

void SystemDump(FILE *HelpFile, long FileStart) 
{

  char            HelpFileTitle[33];
  SYSTEMREC       SystemRec;
  long            CurrentLocation;
  struct tm       *TimeRec;
  SECWINDOW       *SWin;     /* Secondary Window record */
  long            fileSize;
  SYSTEMHEADER    SysHeader;

  fseek(HelpFile, FileStart, SEEK_SET);

  fileSize = LoadHeader(HelpFile);

  fread(&SysHeader, sizeof(SysHeader), 1, HelpFile);
  printf("|SYSTEM Dump\n\n\n");

  /* Figure out Version and Revision */
  if (SysHeader.Revision == 0x15) printf("HC.EXE  3.10 Help Compiler used\n");
  else if (SysHeader.Revision == 0x21) printf("HCW.EXE. 4.00 or MVC.EXE\n");

  printf("\nVersion: %d\nRevision: %d\n", SysHeader.Version, SysHeader.Revision);
  printf("Flag: 0x%04X  - ",SysHeader.Flags);

  /* Determine compression, if any. */
  if (SysHeader.Flags == NO_COMPRESSION) printf("No compression\n");
  else if (SysHeader.Flags & COMPRESSION_HIGH) printf("High Compression\n");
  else printf("Unknown Compression: 0x%02x\n", SysHeader.Flags);

  TimeRec=localtime(&SysHeader.GenDate);
  printf("Help File Generated: %s", asctime(TimeRec));

  /* If 3.0 get title */
  CurrentLocation=12;
  if (SysHeader.Revision == 0x0F) {
     fgets(HelpFileTitle, 33, HelpFile);
     printf("Help File Title: %s\n", HelpFileTitle);
  }

  /* Else, get 3.1 System records */
  else {
    while (CurrentLocation < fileSize) {

      /* Read in system record and SystemRec data */
      fread(&SystemRec, 4, 1, HelpFile);
      SystemRec.RData = malloc(SystemRec.DataSize);
      if (SystemRec.RData == NULL)
      {
        printf("Allocation of SystemRec.RData failed.");
        return;
      }
      fread(SystemRec.RData, SystemRec.DataSize, 1, HelpFile);
      CurrentLocation=CurrentLocation+4+SystemRec.DataSize;

      switch(SystemRec.RecordType) 
      {
        case 0x0001:  printf("Help File Title: %s\n", SystemRec.RData);
          break;

        case 0x0002:  printf("Copyright Notice: %s\n", SystemRec.RData);
          break;

        case 0x0003:  printf("Contents ID: 0x%04X\n", (long) *SystemRec.RData);
          break;

        case 0x0004:  printf("Macro Data: %s\n",SystemRec.RData);
          break;

        case 0x0005:  printf("Icon in System record\n");
          break;

        case 0x0006:  printf("\nSecondary window:\n");
                      SWin = (SECWINDOW *)SystemRec.RData;
                      printf("Flag: %d\n", SWin->Flags);
                      if (SWin->Flags & WSYSFLAG_TYPE) 
                        printf("Type: %s\n", SWin->Type);
                      if (SWin->Flags & WSYSFLAG_NAME) 
                        printf("Name: %s\n", SWin->Name);
                      if (SWin->Flags & WSYSFLAG_CAPTION) 
                        printf("Caption: %s\n", SWin->Caption);
                      if (SWin->Flags & WSYSFLAG_X) 
                        printf("X: %d\n", SWin->X);
                      if (SWin->Flags & WSYSFLAG_Y) 
                        printf("Y: %d\n", SWin->Y);
                      if (SWin->Flags & WSYSFLAG_WIDTH)
                        printf("Width: %d\n", SWin->Width);
                      if (SWin->Flags & WSYSFLAG_HEIGHT)
                        printf("Height: %d\n", SWin->Height);
                      if (SWin->Flags & WSYSFLAG_MAXIMIZE) 
                        printf("Maximize Flag: %d\n", SWin->Maximize);
                      if (SWin->Flags & WSYSFLAG_RGB) 
                        printf("RGB Foreground Colors Set\n");
                      if (SWin->Flags & WSYSFLAG_RGBNSR)
                        printf("RGB For Non-Scrollable Region Set\n");
                      if (SWin->Flags & WSYSFLAG_TOP) 
                        printf("Secondary Window is always On Top\n");
          break;

        case 0x0008:  printf("Citation: %s\n", SystemRec.RData);
          break;

        case 0x000A:  printf("\nContents File: %s\n\n",SystemRec.RData);
          break;                                                 
          
        default:      printf("\nUnknown record type: 0x%04X\n",SystemRec.RecordType);
                      /* Back-up and hex-dump the data */
                      fseek(HelpFile, 
                            ftell(HelpFile) - SystemRec.DataSize, 
                            SEEK_SET);
                      HexDumpData(HelpFile, SystemRec.DataSize);
      } /* switch */
     
      free(SystemRec.RData);

    } /* while */
  } /* else */
} /* SysDump */


/***************************************************
  Dumps the |FONT file
****************************************************/

void FontDump(FILE *HelpFile, long FileStart) 
{
  FONTHEADER      FontHdr;
  FONTDESCRIPTOR  FontDesc;
  char            AFont[32];
  long            FontStart, CurrLoc;
  long            fileSize;
  long            counter;
  long            NameLen;

  /* Go to the FONT file and get the headers */
  fseek(HelpFile, FileStart, SEEK_SET);
  fileSize = LoadHeader(HelpFile);

  fread(&FontHdr, sizeof(FontHdr), 1, HelpFile);

  printf("|FONTS\n\n Number Fonts: %d\n",FontHdr.NumFonts);
  printf("Font #  -  Font Name\n");


  /* Font names are 20 chars prior to Winhelp 4.0 */
  /* In WinHelp 4.0, they are 32 characters.      */
  if (SysInfo.Revision == 0x15)
  {
    NameLen = 20;
  }
  else
  {
    NameLen = 32;
  }

  /* Keep track of start of fonts */
  FontStart = ftell(HelpFile);
  for (counter = 0; counter < (long) FontHdr.NumFonts; counter++) 
  {
    fread(AFont, NameLen, 1, HelpFile);
    printf(" %3d    -  %s\n", counter, AFont);
  }

  /* Go to Font Descriptors. Don't actually need this, because we're
     there, but wanted to show how to get there using the offset.    */
  fseek(HelpFile, FontStart + (long)(FontHdr.DescriptorsOffset) - sizeof(FontHdr), SEEK_SET); 
  printf("\nNum Font Descriptors: %d\n", FontHdr.NumDescriptors);
  printf("Default Descriptor: %d\n\n", FontHdr.DefDescriptor);
  printf("Attributes: n=none  b=bold  i=ital  u=undr  s=strkout  d=dblundr  C=smallcaps\n\n");
  printf("Font Name                        PointSize  Family   FG RGB      BG RGB   Attr\n");
  printf("------------------------------------------------------------------------------\n");

  for (counter = 0; counter < (long) FontHdr.NumDescriptors; counter++) {
    fread(&FontDesc, sizeof(FontDesc), 1, HelpFile);
    CurrLoc = ftell(HelpFile);
    fseek(HelpFile, FontStart + (NameLen * FontDesc.FontName), SEEK_SET);
    fread(AFont, NameLen, 1, HelpFile);
    fseek(HelpFile, CurrLoc, SEEK_SET);
      
    /* write out info on Font descriptor */
    printf("%-32s    %4.1f    ", AFont, (float)(FontDesc.HalfPoints / 2));
    switch (FontDesc.FontFamily) {
      case FAM_MODERN: printf("Modern");
                          break;

      case FAM_ROMAN:  printf("Roman ");
                       break;

      case FAM_SWISS:  printf("Swiss ");
                       break;

      case FAM_SCRIPT: printf("Script");
                       break;

      case FAM_DECOR:  printf("Decor ");
                       break;

      default:         printf("0X%02X ", FontDesc.FontFamily);
                       break;
    } /* Switch */
    printf(" 0X%08lX  ",RGB(FontDesc.SRRGB.rgbRed,
                            FontDesc.SRRGB.rgbGreen,
                            FontDesc.SRRGB.rgbBlue));
    printf("0X%08lX    ",RGB(FontDesc.NSRRGB.rgbRed,
                             FontDesc.NSRRGB.rgbGreen,
                             FontDesc.NSRRGB.rgbBlue));

    if (FontDesc.Attributes == 0) putchar('n');
    if (FontDesc.Attributes & FONT_BOLD) putchar('b');
    if (FontDesc.Attributes & FONT_ITAL) putchar('i');
    if (FontDesc.Attributes & FONT_UNDR) putchar('u');
    if (FontDesc.Attributes & FONT_STRK) putchar('s');
    if (FontDesc.Attributes & FONT_DBUN) putchar('d');
    if (FontDesc.Attributes & FONT_SMCP) putchar('C');
    printf("\n");

#ifdef HLP_DEBUG
    printf("Unknown = %d\n", FontDesc.Unknown);
#endif
  }
}


/***************************************************
  Dumps the |CONTEXT file
****************************************************/

void ContextDump(FILE *HelpFile, long FileStart) 
{
  long            count;
  long            CurrPage, FirstPageLoc;
  long            TopicOffset, HashValue;
  BTREEHEADER     BTreeHdr;
  BTREELEAFHEADER CurrNode;

  /* Go to the TTLBTREE file and get the headers */
  fseek(HelpFile, FileStart, SEEK_SET);
  LoadHeader(HelpFile);
  fread(&BTreeHdr, sizeof(BTreeHdr), 1, HelpFile);

  /* Save the current location */
  FirstPageLoc = ftell(HelpFile);
   
  fseek(HelpFile, 
        FirstPageLoc+(BTreeHdr.RootPage * BTreeHdr.PageSize), 
        SEEK_SET);

  printf("# Context Hash Values in |CONTEXT %lu\n\n", BTreeHdr.TotalBtreeEntries);
  CurrPage = BTreeHdr.FirstLeaf;

  do 
  {
    fseek(HelpFile, 
          FirstPageLoc+(CurrPage * BTreeHdr.PageSize), 
          SEEK_SET);
    fread(&CurrNode, 8, 1, HelpFile);
    for(count = 1; count <= CurrNode.NEntries; count++) 
    {
      fread(&HashValue, sizeof(HashValue), 1, HelpFile);
      fread(&TopicOffset, sizeof(TopicOffset), 1, HelpFile);
      printf("Topic Offset:0x%08lX  Hash Value: 0x%08lX\n", TopicOffset, HashValue);
    }
    CurrPage = CurrNode.NextPage;
  } while(CurrPage != -1);
}


/***************************************************
  Prints a Phrase from the Phrase table.
****************************************************/
void PrintPhrase(long PhraseNum) 
{
  short *Offsets;
  char  *p;

  p = Phrases+Offsets[PhraseNum];
  while (p < Phrases + Offsets[PhraseNum + 1])
    putchar(*p++);
}


/***************************************************
  Dumps the Keyword B-Tree
****************************************************/

void KWBTreeDump(FILE *HelpFile, long FileStart) 
{
  char            Keyword[80], c;
  long            count, Index;
  long            CurrPage, FirstPageLoc;
  long            KeywordOffset;
  long            KeywordCount;
  BTREEHEADER     BTreeHdr;
  BTREELEAFHEADER CurrNode;

  /* Go to the KWBTREE file and get the headers */
  fseek(HelpFile, FileStart, SEEK_SET);
  LoadHeader(HelpFile);
  fread(&BTreeHdr, sizeof(BTreeHdr), 1, HelpFile);

  /* Save the current location */
  FirstPageLoc = ftell(HelpFile);
   
  fseek(HelpFile, 
        FirstPageLoc+(BTreeHdr.RootPage * BTreeHdr.PageSize), 
        SEEK_SET);

  printf("# Keywords - %lu\n\n", BTreeHdr.TotalBtreeEntries);
  CurrPage = BTreeHdr.FirstLeaf;

  do 
  {
    fseek(HelpFile, 
          FirstPageLoc+(CurrPage * BTreeHdr.PageSize), 
          SEEK_SET);
    fread(&CurrNode, 8, 1, HelpFile);
    for(count = 1; count <= CurrNode.NEntries; count++) 
    {
      Index = 0;
      while(c = (char) fgetc(HelpFile))
        Keyword[Index++] = c;
        
      Keyword[Index] = 0;
      fread(&KeywordCount, sizeof(KeywordCount), 1, HelpFile);
      fread(&KeywordOffset, sizeof(KeywordOffset), 1, HelpFile);

      printf("Offset: 0x%08lX  Count: %d  Keyword: %s\n", 
                          KeywordOffset, KeywordCount, Keyword);
    }
    CurrPage = CurrNode.NextPage;
  } while(CurrPage != -1);
}


/***************************************************
  Dumps the Keyword Data file
****************************************************/

void KWDataDump(FILE *HelpFile, long FileStart) 
{
  long fileSize;
  long nIndex;
  long Offset;
  
  /* Go to the KWDATA file and get the headers */
  fseek(HelpFile, FileStart, SEEK_SET);
  fileSize = LoadHeader(HelpFile);
          
  printf("Dumping Keyword Data File\n\n");
  /* Go through all keyword offsets (fileSize / 4) */
  for (nIndex = 0; nIndex < (fileSize / sizeof(Offset)); nIndex++)
  {
    fread(&Offset, sizeof(Offset), 1, HelpFile);
    printf("Index: %d   Offset: 0x%08lX\n", nIndex, Offset);
  }
}


/***************************************************
  Dumps the Keyword Map file
****************************************************/

void KWMapDump(FILE *HelpFile, long FileStart) 
{
  long      fileSize;
  long      nIndex;
  WORD      nKWMaps;
  KWMAPREC  kwMap;
  
  /* Go to the KWMAP file and get the headers */
  fseek(HelpFile, FileStart, SEEK_SET);
  fileSize = LoadHeader(HelpFile);
          
  printf("Dumping Keyword Map\n\n");
  
  fread(&nKWMaps, sizeof(nKWMaps), 1, HelpFile);
  
  /* Go through all keyword offsets (fileSize / 4) */
  for (nIndex = 0; nIndex < (int) nKWMaps; nIndex++)
  {
    fread(&kwMap, sizeof(KWMAPREC), 1, HelpFile);
    printf("Index: %d   First Keyword 0x%08lX    Leaf Page#: %05u\n", 
                          nIndex, kwMap.FirstRec, kwMap.PageNum);
  }
}


/***************************************************
  Dumps the Topic Titles B-Tree
****************************************************/

void TTLDump(FILE *HelpFile, long FileStart) 
{
  char            Title[80], c;
  long            count, Index;
  long            CurrPage, FirstPageLoc, TopicOffset;
  BTREEHEADER     BTreeHdr;
  BTREELEAFHEADER CurrNode;

  /* Go to the TTLBTREE file and get the headers */
  fseek(HelpFile, FileStart, SEEK_SET);
  LoadHeader(HelpFile);
  fread(&BTreeHdr, sizeof(BTreeHdr), 1, HelpFile);

  /* Save the current location */
  FirstPageLoc = ftell(HelpFile);
   
  fseek(HelpFile, 
        FirstPageLoc+(BTreeHdr.RootPage * BTreeHdr.PageSize), 
        SEEK_SET);

  printf("# Titles in |TTLBTREE %lu\n\n", BTreeHdr.TotalBtreeEntries);
  CurrPage = BTreeHdr.FirstLeaf;

  do 
  {
    fseek(HelpFile, 
          FirstPageLoc+(CurrPage * BTreeHdr.PageSize), 
          SEEK_SET);
    fread(&CurrNode, 8, 1, HelpFile);
    for(count = 1; count <= CurrNode.NEntries; count++) 
    {
      fread(&TopicOffset, sizeof(TopicOffset), 1, HelpFile);
      Index = 0;
      while(c = (char) fgetc(HelpFile))
        Title[Index++] = c;
        
      Title[Index] = 0;

      printf("Topic Offset:0x%08lX  Title: %s\n", TopicOffset, Title);
    }
    CurrPage = CurrNode.NextPage;

  } while(CurrPage != -1);
}


/***************************************************
  Dumps the |Phrases file
****************************************************/

void PhrasesDump(FILE *HelpFile, long FileStart) 
{
  long  nOuterIndex, nInnerIndex;
  WORD  start, len;
  
  PhrasesLoad(HelpFile, FileStart);

  printf("Phrase#     Phrase\n");
  for (nOuterIndex = 0; nOuterIndex < NumPhrases; nOuterIndex++)
  {
    start = (WORD) PhrOffsets[nOuterIndex] ;
    len = PhrOffsets[nOuterIndex + 1] - start;
    printf(" %5d     ", nOuterIndex + 1);
    for (nInnerIndex = 0; nInnerIndex < (int) len; nInnerIndex++)
    {
      printf("%c", (Phrases[start + nInnerIndex]));
    }
    printf("\n");
  }
}


/***************************************************
  Loads the |SYSTEM info
****************************************************/

int SysLoad(FILE *HelpFile, long FileStart) 
{
  fseek(HelpFile, FileStart, SEEK_SET);

  LoadHeader(HelpFile);
  
  fread(&SysInfo, sizeof(SYSTEMHEADER), 1, HelpFile);
  
#ifdef HLP_DEBUG
  printf("DEBUG -> SysLoad()\n");
  printf("Magic: 0x%02x\n", SysInfo.Magic);
  printf("Version: 0x%02x\n", SysInfo.Version);
  printf("Revision: 0x%02x\n", SysInfo.Revision);
  printf("Flags: 0x%04x\n\n", SysInfo.Flags);
#endif

  if (SysInfo.Magic != SYS_MAGIC)
  {
    return 0;
  }
  
  return 1;
}


/***************************************************
  Loads the compression phrases
****************************************************/

void PhrasesLoad(FILE *HelpFile, long FileStart) 
{
  PHRASEHEADER  phraseHeader;
  long          FileSize;
  long          DeCompSize;
  
  fseek(HelpFile, FileStart, SEEK_SET);
  FileSize = LoadHeader(HelpFile);

  fread(&phraseHeader, sizeof(phraseHeader), 1, HelpFile);
  
  if (SysInfo.Flags != NO_COMPRESSION)
  {
    if ((PhrOffsets = malloc(phraseHeader.PhrasesSize + 
                            (phraseHeader.NumPhrases + 1) * 2 + 10)) == NULL)
    {
      printf("Unable to allocate space for Phrases.\n");
      return;
    }

    /* Assign Phrases to  where the comrpessed phrases are */   
    Phrases = (char*) PhrOffsets + fread(PhrOffsets, 
                                         2, 
                                         phraseHeader.NumPhrases + 1, 
                                         HelpFile);

    DeCompSize = Decompress(HelpFile,
                            FileSize - (sizeof(phraseHeader) +
                            2 * (phraseHeader.NumPhrases + 1)),
                            Phrases);
    if (DeCompSize != (long) phraseHeader.PhrasesSize)
    {
      printf("Warning, Phrases did not decompress to the proper size.\n");
    }
  }
  else
  {
    if ((PhrOffsets = malloc(phraseHeader.PhrasesSize + 
                            (phraseHeader.NumPhrases + 1) * 2 + 10)) == NULL)
    {
      printf("Unable to allocate space for Phrases.\n");
      return;
    }
    /* Back up four bytes if phrases aren't compressed */
    /* because PhrasesSize field doesn't exist.        */
    fseek(HelpFile, -4, SEEK_CUR);
    fread(PhrOffsets, FileSize - 4, 1, HelpFile);
  }
  /* Reset Phrases to be equal to PhrOffsets */
  Phrases = (char *) PhrOffsets;  
  NumPhrases = phraseHeader.NumPhrases;
}


/***************************************************
  Finds an HFS File by traversing the HFS b-tree
  Note: This is the only place I actually traverse
  the b-tree instead of cycling through the leaf
  pages. I put this in specifically to show how to
  traverse the b-tree, since speed isn't a real
  concern for HelpDump.
****************************************************/

char FindFile(FILE *HelpFile, char* filename, long* offset)
{
  BTREEHEADER       HFSHeader;
  BTREEINDEXHEADER* HFSIndexHeader;
  BTREELEAFHEADER*  HFSLeafHeader;
  long              HFSStart;
  short*            pNextPage;
  char*             buffer;
  char*             currPtr;
  long              nKeys, nFiles;
  char              found = 0;
  long              currLevel = 1;

  /* Go to the HFS and read the header. */
  fseek(HelpFile, HelpHeader.HFSLoc, SEEK_SET);
  LoadHeader(HelpFile);
  fread(&HFSHeader, sizeof(HFSHeader), 1, HelpFile);

  /* Allocate space for read buffer */
  buffer = malloc(HFSHeader.PageSize);
  if (buffer == NULL)
  {
    printf("Unable to allocate space for buffer.\n");
    return found;
  }
  HFSIndexHeader = (BTREEINDEXHEADER*) buffer;

  HFSStart = ftell(HelpFile);
  
  /* Advance to root page */
  fseek(HelpFile, 
        (HFSHeader.RootPage * HFSHeader.PageSize) + HFSStart, 
        SEEK_SET);
      
  /* If there's only one page, then it must be a leaf */
  if (HFSHeader.TotalPages > 1)
  {
    /* Traverse b-tree looking for the key for the leaf page */  
    while (!found)
    {
      /* Read in the page */
      fread(buffer, HFSHeader.PageSize, 1, HelpFile);
      currPtr = buffer + sizeof(BTREEINDEXHEADER);
      pNextPage = (int *) currPtr;

      currPtr += sizeof(int);
      
      /* Go through all keys in the page */
      for (nKeys = 0; nKeys < HFSIndexHeader->NEntries; nKeys++)
      {
        /* If filename is less than key, this is our page. */
        if (strcmp(filename, currPtr) < 0)
        {
          break;
        }
        else
        {
          /* Advance to the next page# */
          while (*currPtr)
            currPtr++;
          currPtr++;
          pNextPage = (int *) currPtr;
          currPtr += sizeof(int);
        }
      }
      
      /* Advance to next page */
      fseek(HelpFile, 
            (*pNextPage * HFSHeader.PageSize) + HFSStart, 
            SEEK_SET);
      
      /* If this is the last index page */
      /* then pNextPage points to a     */
      /* leaf page                      */
      if (currLevel == HFSHeader.nLevels - 1)
      {
        found = 1;
      }
      currLevel++;
    }
  }
  
  fread(buffer, HFSHeader.PageSize, 1, HelpFile);
  HFSLeafHeader = (BTREELEAFHEADER*) buffer;
  currPtr = buffer + sizeof(BTREELEAFHEADER);


  found = 0;
  
  /* Loop through all files in this page */
  for (nFiles = 0; nFiles < HFSLeafHeader->NEntries; nFiles++)
  {
    if (strcmp(filename, currPtr))
    {  
      /* Advance to the file offset */
      while (*currPtr)
        currPtr++;
      
      /* Move past the null and file offset */
      /* to next file                       */
      currPtr += 5;    
    }
    else
    {
      /* Save the offset of the file */
      while (*currPtr)
        currPtr++;
      currPtr++;
      
      *offset = (long) *((long*) currPtr);
      found = 1;
      break;
    }
  }

  /* TRUE if file was found, FALSE if it wasn't */
  return found;
}


/***************************************************
  DumpFile
****************************************************/

void DumpFile(FILE *HelpFile)
{
  long fileOffset;
  char fileName[255];
  
  /* For many files we need to know information about    */
  /* The system, so we'll load the system data info here */
  /* if it's available                                   */
  SysLoaded = 0;
  strcpy(fileName, "|SYSTEM");
  if (FindFile(HelpFile, fileName, &fileOffset))
  {
     SysLoaded = (char) SysLoad(HelpFile, fileOffset);
  }

  /* If it's not a version 3 help file */
  /* then we can't handle it.          */
  if (SysInfo.Version != 0x03)
  {
    printf("Warning: Not a version 3 help file. Version is %d.\n",
           SysInfo.Version);
  }
  
  /* If it's version 3, but not revision   */
  /* 0x15 or 0x21, we also can't handle it */
  if (SysInfo.Revision != 0x15 && SysInfo.Revision != 0x21)
  {
    printf("Revision not 0x15 or 0x21. Revision is 0x%02x.\n",
           SysInfo.Revision);
  }
  
  /* If we're reading the |TOPIC file, then we need to */
  /* pre-load the phrases from the |Phrases file       */  
  if (!strcmp(HFSFileToRead, "|TOPIC") ||
      !strcmp(HFSFileToRead, "TOPIC"))
  {
    strcpy(fileName, "|Phrases");
    if (FindFile(HelpFile, fileName, &fileOffset))
    {
      PhrasesLoad(HelpFile, fileOffset);
    }
  }

  strcpy(fileName, HFSFileToRead);
  if (!FindFile(HelpFile, fileName, &fileOffset))
  {
    /* Append a "|" character to the beginning  */
    /* of the filename and try to find the file */
    strcpy(fileName, "|");
    strcat(fileName, HFSFileToRead);
    if (!FindFile(HelpFile, fileName, &fileOffset))
    {
      /* File not found */
      printf("Error: Unable to find HFS file %s or %s\n",
             HFSFileToRead, fileName);
      return;
    }
  }

  if (!ForceHex)
  {  
    if (!strcmp(fileName, "|SYSTEM"))
      SystemDump(HelpFile, fileOffset);
    else if (!strcmp(fileName, "|TTLBTREE"))
      TTLDump(HelpFile, fileOffset);
    else if (!strcmp(fileName, "|CONTEXT"))
      ContextDump(HelpFile, fileOffset);
    else if (!strcmp(fileName, "|FONT"))
      FontDump(HelpFile, fileOffset);
    else if (!strcmp(fileName, "|KWBTREE"))
      KWBTreeDump(HelpFile, fileOffset);
    else if (!strcmp(fileName, "|AWBTREE"))
      KWBTreeDump(HelpFile, fileOffset);
    else if (!strcmp(fileName, "|KWDATA"))
      KWDataDump(HelpFile, fileOffset);
    else if (!strcmp(fileName, "|AWDATA"))
      KWDataDump(HelpFile, fileOffset);
    else if (!strcmp(fileName, "|KWMAP"))
      KWMapDump(HelpFile, fileOffset);
    else if (!strcmp(fileName, "|Phrases"))
      PhrasesDump(HelpFile, fileOffset);
    else 
      HexDumpFile(HelpFile, fileOffset);
  }
  else
  {
    HexDumpFile(HelpFile, fileOffset);
  }  
}

/***************************************************
  List out all the HFS files in a .HLP file
****************************************************/

void ListFiles(FILE *HelpFile)
{
  BTREEHEADER       HFSHeader;
  BTREELEAFHEADER*  HFSLeafHeader;
  long              HFSStart;
  char*             buffer;
  char*             currPtr;
  long              nIndex, nFiles;
  long*             offset;

  /* Go to the HFS and read the header. */
  fseek(HelpFile, HelpHeader.HFSLoc, SEEK_SET);
  LoadHeader(HelpFile);
  fread(&HFSHeader, sizeof(HFSHeader), 1, HelpFile);

  CHECK_SIGNATURE(HFSHeader.Signature, 0x293B);

#ifdef HLP_DEBUG  
  printf("DEBUG -> ListFiles()\n");
  printf("B-Tree Page Size %d\n", HFSHeader.PageSize);
  printf("B-Tree First Leaf %d\n", HFSHeader.FirstLeaf);
  printf("B-Tree Num. Levels %d\n", HFSHeader.nLevels);
  printf("B-Tree Total Pages %d\n", HFSHeader.TotalPages);
  printf("B-Tree Total # Entries %ld\n", HFSHeader.TotalBtreeEntries);
#endif 
  /* Start of the HFS b-tree pages */
  HFSStart = ftell(HelpFile);

  /* Go to the first leaf page of the HFS */  
  fseek(HelpFile, HFSHeader.FirstLeaf * HFSHeader.PageSize, SEEK_CUR);

  /* Allocate space for read buffer and read first page */
  buffer = malloc(HFSHeader.PageSize);
  if (buffer == NULL)
  {
    printf("Unable to allocate space for buffer.\n");
    return;
  }
  HFSLeafHeader = (BTREELEAFHEADER*) buffer;
  
  printf("\nHFS Filename                 Offset\n");
  printf("-----------------------------------\n");
  
  /* Loop through all HFS leaf pages */
  for (nIndex = 0; nIndex < HFSHeader.TotalPages; nIndex++)
  {
    fread(buffer, HFSHeader.PageSize, 1, HelpFile);

    currPtr = buffer + sizeof(BTREELEAFHEADER);

    /* Loop through all files in this page */
    for (nFiles = 0; nFiles < HFSLeafHeader->NEntries; nFiles++)
    {

      /* Print filename */
      printf("%-30s", currPtr);
    
      /* Advance to next filename */
      while (*currPtr)
        currPtr++;
      currPtr++;
      
      offset = (long*) currPtr;
      /* print offset to file */
      printf("0x%08lX\n", *offset);

      /* Move past the file offset to next file */
      currPtr += 4;    
    }
  }
}

/***************************************************
  Check to make sure it's a help file. Then
  either dump the HFS directory or dump an HFS
  file.
****************************************************/

void HelpDump(FILE *HelpFile) 
{
  fread(&HelpHeader, sizeof(HelpHeader), 1, HelpFile);
  if (HelpHeader.MagicNumber != HF_MAGIC) 
  {
    printf("Fatal Error:\n");
    printf("  Not a valid WinHelp file!\n");
    return;
  }

  if (ReadHFSFile) 
     DumpFile(HelpFile);
  else
     ListFiles(HelpFile);

}


/***************************************************
  Show usage
****************************************************/

void Usage()
{
  printf("HLPDUMP2  (version 2.0 of Help Dump)\n");
  printf("By Pete Davis and Mike Wallace               Copyright 1997\n\n");
  printf("Usage: HLPDUMP2 helpfile[.hlp] [hfsfilename] [/H]\n\n");
  printf("where:\n");
  printf("  helpfile    - name of .HLP/.GID/.ANN/.BMK file to open\n");
  printf("  hfsfilename - name of HFS file to read\n");
  printf("  /H          - force a hex dump\n\n");
  printf("note: Do not include the pipe '|' character in the hfsfilename.\n");
}


/***************************************************
 Entry point to HLPDUMP2
****************************************************/

int main(int argc, char *argv[])
{
  char filename[_MAX_PATH];
  FILE *HelpFile;

  if (argc < 2) 
  {
    Usage();
    return EXIT_FAILURE;
  }
  ReadHFSFile = 0;
  if (argc >= 3) 
  {
    strcpy(HFSFileToRead, argv[2]);
    ReadHFSFile = 1;
  }

  /* Are we forcing a hex dump? */
  ForceHex = 0;
  if (argc == 4)
  {

  if (stricmp(argv[3], "/H"))
    {
      printf("Error: Argument 3 unrecognized\n");
      return EXIT_FAILURE;
    }
    ForceHex = 1;

  }
  strcpy(filename, argv[1]);
  strupr(filename);
  if (!strchr(filename, '.')) 
    strcat(filename, ".HLP");

  if ((HelpFile = fopen(filename, "rb")) == NULL) 
  {
    printf("%s does not exist!", filename);
    return EXIT_FAILURE;
  }

  printf("Dumping %s\n\n", filename);
  HelpDump(HelpFile);
  fclose(HelpFile);

  return EXIT_SUCCESS;
  
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\Windows Undocumented File Formats\wuff_src\CHAP3\SHGDUMP.C ===
/**********************************************************************
 *
 * PROGRAM: SHGDUMP.C
 *
 * PURPOSE: Dump the hotspot information for a SHG file
 *
 * Copyright 1997, Mike Wallace and Pete Davis
 *
 * Chapter 3, Segmented Hypergraphic (.SHG) File Format, 
 * from Undocumented Windows File Formats, published by R&D Books,
 * an imprint of Miller Freeman, Inc.
 *
 **********************************************************************/

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "shededit.h"

/* Flags an incorrect value for known fields */
#define CheckUVal(a,b) \
       {if (a != b) {  \
       printf("UINT: Not a 0x%04X?\n\n 0x%04x\n",b, a); exit(1); } }

#define CheckBVal(a,b) \
       {if (a != b) {  \
       printf("BYTE: Not a 0x%02X?\n\n 0x%02x\n",b, a); exit(1); } }

#define ReadString(f, s) { char *p = (char *)(s); \
                  while ((*p++ = fgetc(f)) != 0) ; *p = 0; }


/* Reads in a BYTE. If it's odd, it reads in a WORD. Returns 1/2 value */
WORD ReadWordVal(FILE *SHGFile)
{
  BYTE a, b;
  
  b = 0;
  fread(&a, sizeof(a), 1, SHGFile);
  if (a % 2) fread(&b, sizeof(b), 1, SHGFile);
  return (WORD) ((WORD)b*256 + a) /2;
}


/* Reads in a WORD. If it's odd, it reads in a DWORD. Returns 1/2 value */
DWORD ReadDWordVal(FILE *SHGFile)
{
  WORD a, b;
  
  b = 0;
  fread(&a, sizeof(a), 1, SHGFile);
  if (a % 2) fread(&b, sizeof(b), 1, SHGFile);
  return (DWORD) ((DWORD)b*65536 + a) /2;
}


/* Dumps HotSpot data from .SHG file */
void DumpHotSpots(FILE *SHGFile)
{
  HOTSPOTHEADER HSHead;
  HOTSPOTRECORD HSRec;
  WORD i, NumMacs = 0;
  char AString[128];
  long fileLoc;
  
  fread(&HSHead, sizeof(HSHead), 1, SHGFile);
  
  for(i = 1; i <= HSHead.hhNumHS; i++)
  {
    fileLoc = ftell(SHGFile);
    fread(&HSRec, sizeof(HSRec), 1, SHGFile);
    printf("Hot Spot %u (offset %ld) - ", i, fileLoc);
    switch(HSRec.hrType)
    {
      case HS_INVISJUMP:  printf("Invisible Jump\n");  break;
      case HS_VISJUMP:    printf("Visible Jump\n");    break;
      case HS_INVISPOPUP: printf("Invisible Popup\n"); break;
      case HS_VISPOPUP:   printf("Visible Popup\n");   break;

      case HS_INVISMACRO:
        printf("Invisible Macro\n");
        NumMacs++;
        break;

      case HS_VISMACRO:
        printf("Visible Macro\n"); 
        NumMacs++; 
        break;

      default:
        printf("Invalid Record Type\n"); 
        return;
    }
  }
  
  /* Print out the list of macros */
  for (i = 1; i <= NumMacs; i++)
  {
    ReadString(SHGFile, AString); 
    printf("Macro %u> %s\n", i, AString);
  }
  
  printf("\n");
  
  /* Print out the list of hotspot IDs */
  for(i = 1; i <= HSHead.hhNumHS; i++)
  {
    ReadString(SHGFile, AString);
    printf("Hotspot ID #%u> %s\n", i, AString);
    ReadString(SHGFile, AString);
    printf("Context String-> %s\n\n", AString);
  }
}


/* Reads in a bitmap header. Doubles the 
   size of certain fields when necessary. */
void ReadBMHeader(FILE *SHGFile, SHGBITMAPHEADER *SHGBM)
{
  /* Read first three fields unmodified */
  fread(&(SHGBM->sbIsZero), 1, 1, SHGFile);
  SHGBM->sbDPI = ReadWordVal(SHGFile);
  fread(&(SHGBM->sbTwoHund), 2, 1, SHGFile);
  SHGBM->sbNumBits = ReadWordVal(SHGFile);
  SHGBM->sbWidth = ReadDWordVal(SHGFile); 
  SHGBM->sbHeight = ReadDWordVal(SHGFile); 
  SHGBM->sbNumQuads = ReadDWordVal(SHGFile); 
  fread(&(SHGBM->sbNumImp), 2, 1, SHGFile);
  SHGBM->sbCmpSize = ReadDWordVal(SHGFile); 
  SHGBM->sbSizeHS = ReadDWordVal(SHGFile); 
  fread(&(SHGBM->sbunk1), 4, 1, SHGFile);
  fread(&(SHGBM->sbSizeImage), 4, 1, SHGFile);
}


/* Dump bitmap data in .SHG file */
void BitMapDump(FILE *SHGFile)
{
  RGBQUAD         AnRGBQuad;
  DWORD           i=0L;
  SHGBITMAPHEADER SHGBM;
  
  ReadBMHeader(SHGFile, &SHGBM);
  
  /* Read past bitmap quad info */
  for(i = 0L; i < SHGBM.sbNumQuads; i++)
  {
    fread(&AnRGBQuad, sizeof(AnRGBQuad), 1, SHGFile);
  }
  
  /* Jump past the image to the hotspot data */
  fseek(SHGFile, SHGBM.sbCmpSize, SEEK_CUR);
  
  if (SHGBM.sbSizeHS)
    DumpHotSpots(SHGFile);
  else
    printf("No Hot Spot data for this Bitmap.\n");
}


/* Reads in a metafile header. Doubles the
   size of certain fields when necessary. */
void ReadWMHeader(FILE *SHGFile, SHGMETAFILEHEADER *SHGWM)
{
  /* Read first two fields unmodified */
  fread(&(SHGWM->smXWidth), 4, 1, SHGFile);
  SHGWM->smUncSize = ReadDWordVal(SHGFile);
  SHGWM->smCmpSize = ReadDWordVal(SHGFile);
  SHGWM->smSizeHS  = ReadDWordVal(SHGFile); 
  fread(&(SHGWM->smUnk1), 4, 1, SHGFile);
  SHGWM->smSizeImage = ReadDWordVal(SHGFile);
}


/* Dump the .WMF data from the .SHG file */
void WMFDump(FILE *SHGFile, BOOL bCompUsed)
{
  SHGMETAFILEHEADER SHGWM;
  
  ReadWMHeader(SHGFile, &SHGWM);
  
  /* Jump to the hot spot information (how far we jump */
  /* is based on whether the image is compressed) */
  if (bCompUsed)
    fseek(SHGFile, SHGWM.smCmpSize, SEEK_CUR);
  else
    fseek(SHGFile, SHGWM.smUncSize, SEEK_CUR);
  
  if (SHGWM.smSizeHS)
    DumpHotSpots(SHGFile);
  else
    printf("No Hot Spot Data for this metafile.\n");
}


/* Dumps the .SHG file */
void SHGDump(FILE *SHGFile)
{
  SHGFILEHEADER SHGHead;
  SHGIMAGEHEADER SHGImage;
  WORD i;
  BOOL bCompUsed;
  
  /* Read in first 4 bytes */
  fread(&SHGHead, 4, 1, SHGFile);
  printf("Number of images = %d\n", SHGHead.sfNumObjects);
  SHGHead.sfObjectOff=malloc(4*SHGHead.sfNumObjects);
  fread(SHGHead.sfObjectOff, 4, SHGHead.sfNumObjects, SHGFile);
  
  /* Make sure it is an .SHG file */
  if (strncmp(SHGHead.sfType, "lp", 2))
  {
    printf("Invalid .SHG or .MRB file! \n\nType: %c%c\n", SHGHead.sfType[0],
           SHGHead.sfType[1]);
    exit(1);
  }
  
  for (i = 0; i < SHGHead.sfNumObjects; i++)
  {
    /* Jump to Image Header and read it in */
    fseek(SHGFile, SHGHead.sfObjectOff[i], SEEK_SET);
    fread(&SHGImage, sizeof(SHGImage), 1, SHGFile);
    
    if (SHGImage.siImageType == IT_BMP)
      printf("\nFile is a BITMAP using ");
    else
      printf("\nFile is a METAFILE using ");
    
    if (SHGImage.siCompression == IC_NONE)
      printf("no compression.\n");
    else if (SHGImage.siCompression == IC_RLE)
      printf("RLE compression.\n");
    else if (SHGImage.siCompression == IC_LZ77)
      printf("LZ77 compression.\n");
    else if (SHGImage.siCompression == IC_BOTH)
      printf("RLE and LZ77 compression.\n");
    else
      printf("unknown compression.\n");
    
    bCompUsed = (SHGImage.siCompression == IC_NONE) ? FALSE : TRUE;
    
    if (SHGImage.siImageType == IT_BMP)
      BitMapDump(SHGFile);
    else if (SHGImage.siImageType == IT_WMF)
      WMFDump(SHGFile, bCompUsed);
    else {
      printf("Unknown sfImageType value.\n");
      exit(1);
    }
  }
  
  free(SHGHead.sfObjectOff);
}


/* Show usage for SHGDUMP */
void Usage(void)
{
  printf("Usage:\n");
  printf(" SHGDUMP shgfile[.shg] \n");
  printf("   shgfile  - Name of .SHG file\n");
}


/* main routine */
int main(int argc, char *argv[])
{
  char inputFile[20];
  FILE *SHGFile;
  
  /* Check if the program was invoked correctly */
  if (argc < 2) {
    Usage();
    return EXIT_FAILURE;
  }
  
  /* Save the input filename */
  strcpy(inputFile, argv[1]);
  
  /* If no extension in the input filename, assume .shg */
  if (0 == strchr(inputFile, '.'))
    strcat(inputFile, ".SHG");
  
  /* Check that the input file exists */
  if ((SHGFile = fopen(inputFile, "rb")) == NULL)
  {
    printf("%s does not exist!", inputFile);
    return EXIT_FAILURE;
  }
  
  /* Dump the hotspot information */
  SHGDump(SHGFile);
  
  /* Close the file and exit */
  fclose(SHGFile);
  return EXIT_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\Windows Undocumented File Formats\wuff_src\CHAP4\HLPDUMP2.H ===
/**********************************************************************
 *
 * PROGRAM: HLPDUMP2.H
 *
 * PURPOSE: Header file for HLPDUMP2.C
 *
 * Copyright 1997, Mike Wallace and Pete Davis
 *
 * Chapter 4, Windows Help File Format, from Undocumented Windows
 * File Formats, published by R&D Books, an imprint of Miller Freeman, Inc.
 *
 **********************************************************************/

/***********************************************************
  Global Variables
************************************************************/

int          ReadHFSFile;
int          ForceHex;

/* While it appears HFS filenames don't exceed 8           */
/* it's safer to assume that the limit is higher.          */
char         HFSFileToRead[255];

char         SysLoaded;
HELPHEADER   HelpHeader;
SYSTEMHEADER SysInfo;
int*         PhrOffsets;
char*        Phrases;
int          NumPhrases;

/***********************************************************
  Function Prototypes
************************************************************/

long LoadHeader(FILE *);
long Decompress(FILE *, long, char *);
void HexDumpData(FILE *, long);
void HexDumpFile(FILE *, long);
void SystemDump(FILE *, long);
void FontDump(FILE *, long); 
void ContextDump(FILE *, long);
void PrintPhrase(long);
void KWBTreeDump(FILE *, long);
void KWDataDump(FILE *, long);
void KWMapDump(FILE *, long);
void TTLDump(FILE *, long);
void PhrasesDump(FILE *, long);
int SysLoad(FILE *, long);
void PhrasesLoad(FILE *, long);
char FindFile(FILE *, char*, long*);
void DumpFile(FILE *);
void ListFiles(FILE *);
void HelpDump(FILE *);
void Usage();
int  main(int, char**);
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\Windows Undocumented File Formats\wuff_src\CHAP4\WINHELP.H ===
/**********************************************************************
 *
 * PROGRAM: WINHELP.H
 *
 * PURPOSE: Sample header file for an .HLP file
 *
 * Copyright 1997, Mike Wallace and Pete Davis
 *
 * Chapter 4, Windows Help File Format, from Undocumented Windows
 * File Formats, published by R&D Books, an imprint of Miller Freeman, Inc.
 *
 **********************************************************************/

/* Force byte aligned packing of data structures */
#pragma pack(1)


/*
   The following are defined as based on the Windows 3.1
   Programmer's Reference.
*/
#ifndef _INC_WINDOWS
typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned long   DWORD;

typedef struct tagRGBTRIPLE
{
    BYTE    rgbBlue;
    BYTE    rgbGreen;
    BYTE    rgbRed;
} RGBTRIPLE;

typedef DWORD COLORREF;

#define RGB(r,g,b) ((COLORREF) \
            (((BYTE)(r)|((WORD)(g)<<8))|(((DWORD)(BYTE)(b))<<16)))

#endif

/* Define the size of a Topic Block 4k - sizeof(TOPICLINK) */
#define TopicBlockSize   4096L


/***********************************************************
   WinHelp Common Structures
************************************************************/

/* Help file Header record */
typedef struct tagHELPHEADER {
    DWORD   MagicNumber;      /* 0x00035F3F                */
    long    HFSLoc;           /* Pointer to WHIFS header   */
    long    Negative1;
    long    FileSize;         /* Size of entire .HLP File  */
} HELPHEADER;

#define HF_MAGIC  0x00035F3F

/* File Header for WHIFS files */
typedef struct tagHFSFILEHEADER {
    long    FilePlusHeader;  /* File size including this header */
    long    FileSize;        /* File size not including header  */
    char    FileType;      /*                                 */
} HFSFILEHEADER;

/* File types used by HFS               */
/* FT_NORMAL is a regular file                */
/* FT_HFS is the HFS directory file         */
/* FT_UNK Found in MSDNCD4.MVB |TTLBTREE file   */

#define FT_NORMAL 0x00
#define FT_HFS    0x04


/***********************************************************
   B-Tree related structures
************************************************************/

/* Keyword & TTL BTREE Headers - Slightly different than HFS B-tree Header.
   Both HFS and Keyword B-Trees use same leaf and index node headers.    */

typedef struct tagBTREEHEADER {
  WORD  Signature;        /* 0x293B                               */
  char  Unknown1;         /* 0x02 always                          */
  char  FileTypeFlag;     /* Same as FILEHEADER FileTypeFlag field*/
  short PageSize;         /* Size of tree pages                   */
  char  SortOrder[16];    /* Used for internationalization        */
  short FirstLeaf;      /* Probably First Leaf page!!!          */
  short NSplits;        /* # of page splits Btree has suffered  */
  short RootPage;       /* page #of root page                   */
  short Reserved2;
  short TotalPages;     /* total # of 2Kb pages in Btree        */
  short nLevels;        /* # of levels in this Btree            */
  DWORD TotalBtreeEntries;
} BTREEHEADER;

/* Modified B-Tree Leaf Header */
typedef struct tagBTREELEAFHEADER {
    WORD    Signature;      /* Signature word            */
    short   NEntries;       /* Number of entries         */
    short   PreviousPage;   /* Index of Previous Page    */
    short   NextPage;       /* Index of Next Page        */
} BTREELEAFHEADER;

/* Modified B-Tree Index node header */
typedef struct tagBTREEINDEXHEADER {
    WORD    Signature;      /* Signature byte            */
    short   NEntries;       /* Number of entries in node */
} BTREEINDEXHEADER;

/***********************************************************
   |Phrases header
************************************************************/

/* Phrases header. In uncompressed, last field doesn't exist */
typedef struct tagPHRASEHEADER    {
    short   NumPhrases;     /* Number of phrases in table                     */
    WORD    OneHundred;     /* 0x0100                                         */
    long    PhrasesSize;    /* Amount of space uncompressed phrases requires. */
} PHRASEHEADER;


/***********************************************************
   |FONT File structures
************************************************************/

/* Header for |FONT file */
typedef struct tagFONTHEADER {
    WORD    NumFonts;           /* Number of fonts in Font List */
    WORD    NumDescriptors;     /* Number of font descriptors   */
    WORD    DefDescriptor;      /* Default font descriptor      */
    WORD    DescriptorsOffset;  /* Offset to descriptor list    */
} FONTHEADER;

typedef struct tagFONTDESCRIPTOR {
    BYTE    Attributes;         /* Font Attributes See values below */
    BYTE    HalfPoints;         /* PointSize * 2                    */
    BYTE    FontFamily;         /* Font Family. See values below    */
    BYTE    FontName;           /* Number of font in Font List      */
    BYTE    Unknown;            /* Unknown                          */
    RGBTRIPLE SRRGB;            /* RGB values of foreground         */
    RGBTRIPLE NSRRGB;           /* background RGB Values (?? Not sure */
} FONTDESCRIPTOR;

/* Font Attributes */
#define FONT_NORM    0x00       /* Normal         */
#define FONT_BOLD    0x01       /* Bold           */
#define FONT_ITAL    0x02       /* Italics        */
#define FONT_UNDR    0x04       /* Underline      */
#define FONT_STRK    0x08       /* Strike Through */
#define FONT_DBUN    0x10       /* Dbl Underline  */
#define FONT_SMCP    0x20       /* Small Caps     */

/* Font Families */
#define FAM_MODERN   0x01
#define FAM_ROMAN    0x02
#define FAM_SWISS    0x03
#define FAM_TECH     0x03
#define FAM_NIL      0x03
#define FAM_SCRIPT   0x04
#define FAM_DECOR    0x05


/***********************************************************
   |SYSTEM file structures
************************************************************/

/* Header for |SYSTEM file */
typedef struct tagSYSTEMHEADER {
    BYTE    Magic;     /* 0x6C                  */
    BYTE    Version;   /* Version #             */
    BYTE    Revision;  /* Revision code         */
    BYTE    Always0;   /* Unknown               */
    WORD    Always1;   /* Always 0x0001         */
    DWORD   GenDate;   /* Date/Time that the help file was generated    */
    WORD    Flags;     /* Values seen: 0x0000 0x0004, 0x0008, 0x000A    */
} SYSTEMHEADER;

/* Magic number of SYSTEM record */
#define SYS_MAGIC     0x6C

/* Flags for |SYSTEM header Flags field below */
#define NO_COMPRESSION          0x0000
#define COMPRESSION_HIGH        0x0004

/* Help Compiler 3.1 System record. Multiple records possible */
typedef struct tagSYSTEMREC {
    WORD    RecordType;   /* Type of Data in record      */
    WORD    DataSize;     /* Size of RData               */
    char    *RData;       /* Raw data (Icon, title, etc) */
} SYSTEMREC;

/* Types for SYSTEMREC RecordType below */  
#define HPJ_TITLE       0x0001      /* Title from .HPJ file            */
#define HPJ_COPYRIGHT   0x0002      /* Copyright notice from .HPJ file */
#define HPJ_CONTENTS    0x0003      /* Contents=??? from .HPJ          */
#define MACRO_DATA      0x0004      /* SData = 4 nulls if no macros    */
#define ICON_DATA       0x0005
#define HPJ_SECWINDOWS  0x0006      /* Secondary window info in .HPJ   */
#define HPJ_CITATION    0x0008      /* CITATION= under [OPTIONS]       */


/* Secondary Window Record following type 0x0006 System Record */

typedef struct tagSECWINDOW {
    WORD    Flags;          /* Flags (See Below)        */
    BYTE    Type[10];       /* Type of window           */
    BYTE    Name[9];        /* Window name              */
    BYTE    Caption[51];    /* Caption for window       */
    WORD    X;              /* X coordinate to start at */
    WORD    Y;              /* Y coordinate to start at */
    WORD    Width;          /* Width to create for      */
    WORD    Height;         /* Height to create for     */
    WORD    Maximize;       /* Maximize flag            */
    BYTE    Rgb[3];
    BYTE    Unknown1;
    BYTE    RgbNsr[3];      /* RGB for non scrollable region */
    BYTE    Unknown2;
} SECWINDOW;

/** Values for Flags **/

#define WSYSFLAG_TYPE       0x0001  /* Type is valid        */
#define WSYSFLAG_NAME       0x0002  /* Name is valid        */
#define WSYSFLAG_CAPTION    0x0004  /* Ccaption is valid    */
#define WSYSFLAG_X          0x0008  /* X    is valid        */
#define WSYSFLAG_Y          0x0010  /* Y    is valid        */
#define WSYSFLAG_WIDTH      0x0020  /* Width    is valid    */
#define WSYSFLAG_HEIGHT     0x0040  /* Height   is valid    */
#define WSYSFLAG_MAXIMIZE   0x0080  /* Maximize is valid    */
#define WSYSFLAG_RGB        0x0100  /* Rgb  is valid        */
#define WSYSFLAG_RGBNSR     0x0200  /* RgbNsr   is valid    */
#define WSYSFLAG_TOP        0x0400  /* On top was set in HPJ file */


/***********************************************************
   Keyword file structures
************************************************************/

/* Keyword Map Record */
typedef struct tagKWMAPREC {
    long    FirstRec;       /* Index number of first keyword on leaf page    */
    WORD    PageNum;        /* Page number that keywords are associated with */
} KWMAPREC;

/* Record for the |KWBTREE file */
typedef struct tagKWBTREEREC {
    char     Keyword[80];     /* Variable Length Keyword      */
    short    Count;           /* Count of Keywords occurances */
    long     KWDataOffset;    /* Offset into |KWDATA file     */
} KWBTREEREC;


/***********************************************************
   |TOPIC file structures
************************************************************/

/* |TOPIC Block header - Header for a block of topic data. If
   uncompressed, there's only one of these at the beginning of the
   file. If the help file is compressed, then these occur in 4k
   increments. (e.g. 0x0000, 0x1000, 0x2000, 0x3000, 0x4000, etc. ) */

typedef long  TOPICOFFSET;

typedef struct tagTOPICBLOCKHEADER {
    long    LastTopicLink;   /* Offset of last topic link in previous block   */
    long    TopicData;       /* Offset of topic data start                    */
    long    LastTopicHeader; /* Offset of last topic header in previous block */
} TOPICBLOCKHEADER;

/* Linked list record for |TOPIC file */
typedef struct tagPARAGRAPH {
    long     BlockSize;   /* Size of this link + Data         */
    long     DataLen2;    /* Length of LinkData2              */
    long     PrevBlock;   /* Relative to first byte of |TOPIC */
    long     NextBlock;   /* Relative to first byte of |TOPIC */
    long     DataLen1;    /* Len(LinkData1 + 11(hdr size))    */
    BYTE     RecordType;  /* See below                        */
    BYTE     *LinkData1;  /* Data associated with this link   */
    BYTE     *LinkData2;  /* Second set of data               */
} PARAGRAPH;

/* Known record types for topic link */
#define TL_TOPICHDR    0x02  /* Topic header information */
#define TL_DISPLAY     0x20  /* Displayable information  */
#define TL_TABLE       0x23  /* WinHelp Table            */

/* Topic header. Starts inside LinkData of a type 0x02 record */
typedef struct tagTOPICHEADER {
    long          BlockSize; /* Size of topic, including internal topic links  */
    TOPICOFFSET   BrowseBck; /* Topic offset for prev topic in Browse sequence */
    TOPICOFFSET   BrowseFor; /* Topic offset for next topic in Browse sequence */
    DWORD         TopicNum;  /* Topic Number(?)                                */
    long          NonScroll; /* Start of Non-Scroll Region                     */
    long          Scroll;    /* Start of Scrolling Region of text.             */
    TOPICOFFSET   NextTopic; /* Start of next Type 0x02 record                 */
} TOPICHEADER;

/***********************************************************
   Structures for other system files
************************************************************/

/* Header for |TOMAP file */
typedef struct tagTOMAPHEADER {
    long    IndexTopic;   /* Index topic for help file */
    long    Reserved[15];
    short   ToMapLen;     /* Number of topic pointers  */
    long    *TopicPtr;    /* Pointer to all the topics */
} TOMAPHEADER;

/* Record from |CTXOMAP file. Created from the [MAP] section of .HPJ file */
typedef struct tagCTXOMAPREC {
    long     MapID;
    long     TopicOffset;
} CTXOMAPREC;


/* Record from |CONTEXT file */
typedef struct tagCONTEXTREC {
    long     HashValue;       /* Hash value of a phrase     */
    long     TopicOffset;     /* Topic offset of the phrase */
} CONTEXTREC;
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\Windows Undocumented File Formats\wuff_src\CHAP4\TOPICDMP\TOPICDMP.C ===
/**********************************************************************
 *
 * PROGRAM: TOPICDMP.C
 *
 * PURPOSE: Dump the topic file from a Windows .HLP or .MVB file
 *
 * Copyright 1997, Mike Wallace and Pete Davis
 *
 * Chapter 4, Windows Help File Format, from Undocumented Windows
 * File Formats, published by R&D Books, an imprint of Miller Freeman, Inc.
 *
 **********************************************************************/

#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <conio.h>
#include <ctype.h>
#include <limits.h>

#pragma pack(1)   /* Make sure we get byte alignment */
#include "whstruct.h"

HELPHEADER        HelpHeader;        /* Header for Help file.       */
WHIFSBTREEHEADER  WHIFSHeader;       /* WHIFS Header record         */
int               WHIFSLeafOne = -1; /* First WHIFS Leaf Node       */
long              FirstPageLoc;      /* Used by macros for b-trees  */
char              *PhrasesPtr; 
int               Compressed;        /* Is there compression?       */

#define MSG(s)              { puts(s); return; }
#define FAIL(s)             { puts(s); exit(1); }

#define GET_STRING(f, s) \
	{ char *p = (char *)(s); while (*p++ = fgetc(f)) ; *p = 0; }

#define BIT_SET(map, bit)   (((map) & (1 << (bit))) ? 1 : 0)

// Finds the first leaf in the WHIFS B-Tree
void WHIFSGetFirstLeaf(FILE *HelpFile) {
    int               CurrLevel = 1; /* Current Level in B-Tree */
    BTREEINDEXHEADER  CurrNode;      /* Current Node in B-Tree  */
    int               NextPage = 0;  /* Next Page to go to      */

    /* Go to the beginning of WHIFS B-Tree */
    fseek(HelpFile, HelpHeader.WHIFS, SEEK_SET);
    fread(&WHIFSHeader, sizeof(WHIFSHeader), 1, HelpFile);
    FirstPageLoc = HelpHeader.WHIFS + sizeof(WHIFSHeader);
    GotoWHIFSPage(WHIFSHeader.RootPage);  // macro in WHSTRUCT.H

    /* Find First Leaf */
    while (CurrLevel < WHIFSHeader.NLevels) {
       fread(&CurrNode, sizeof(CurrNode), 1, HelpFile);

       /* Next Page is conveniently the first byte of the page */
       fread(&NextPage, sizeof(int), 1, HelpFile);
       GotoWHIFSPage(NextPage);
       CurrLevel++;
    }
    /* First Leaf page is here */
    WHIFSLeafOne = NextPage;
}

// Get a WHIFS file by file number; returns offset and filename
void GetFile(FILE *HelpFile, DWORD Number, long *Offset, char *Name) {
    BTREENODEHEADER CurrentNode;      
    DWORD           CurrPage, counter = 0;
    char            c, TempFile[19];
    
    /* Skip pages we don't need */
    CurrentNode.NextPage = WHIFSLeafOne;
    do {
        CurrPage = CurrentNode.NextPage;
        GotoWHIFSPage(CurrPage);
        fread(&CurrentNode, sizeof(CurrentNode), 1, HelpFile);
        counter += CurrentNode.NEntries;
    } while (counter < Number);

    for (counter -= CurrentNode.NEntries; counter <= Number; counter++) {
        GET_STRING(HelpFile, TempFile);
        fread(Offset, sizeof(long), 1, HelpFile);
    }
    strcpy(Name, TempFile);
}

// Get SysHeader to see if compression used on help file
void SysLoad(FILE *HelpFile, long FileStart) {
   SYSTEMHEADER    SysHeader;
   FILEHEADER      FileHdr;
   fseek(HelpFile, FileStart, SEEK_SET);
   fread(&FileHdr, sizeof(FileHdr), 1, HelpFile);
   fread(&SysHeader, sizeof(SysHeader), 1, HelpFile);
   if (SysHeader.Revision != 21)
       FAIL("Sorry, TOPICDMP only works with Windows 3.1 help files");
   Compressed = (SysHeader.Flags & COMPRESSION_310) ||
                (SysHeader.Flags & COMPRESSION_UNKN);
}

// Decides how many bytes to read, depending on number of bits set
int BytesToRead(BYTE BitMap) {
    int TempSum, counter;
    TempSum = 8;
    for (counter = 0; counter < 8; counter ++)
       TempSum += BIT_SET(BitMap, counter);
    return TempSum;
}

// Decompresses the data using Microsoft's LZ77 derivative.
long Decompress(FILE *HelpFile, long CompSize, char *Buffer) {
   long InBytes = 0;        /* How many bytes read in                    */
   WORD OutBytes = 0;       /* How many bytes written out                */
   BYTE BitMap, Set[16];    /* Bitmap and bytes associated with it       */
   long NumToRead;          /* Number of bytes to read for next group    */
   int  counter, Index;     /* Going through next 8-16 codes or chars    */
   int  Length, Distance;   /* Code length and distance back in 'window' */
   char *CurrPos;           /* Where we are at any given moment          */
   char *CodePtr;           /* Pointer to back-up in LZ77 'window'       */

   CurrPos = Buffer;
   while (InBytes < CompSize) {
      BitMap = (BYTE) fgetc(HelpFile);
      NumToRead = BytesToRead(BitMap);

      if ((CompSize - InBytes) < NumToRead) 
          NumToRead = CompSize - InBytes;   // only read what we have left
      fread(Set, 1, (int) NumToRead, HelpFile);    
      InBytes += NumToRead + 1;

      /* Go through and decode data */
      for (counter = 0, Index = 0; counter < 8; counter++) {
         /* It's a code, so decode it and copy the data */
         if (BIT_SET(BitMap, counter)) {
            Length = ((Set[Index+1] & 0xF0) >> 4) + 3;
            Distance = (256 * (Set[Index+1] & 0x0F)) + Set[Index] + 1;
            CodePtr = CurrPos - Distance;   // ptr into decompress window
            while (Length)
               { *CurrPos++ = *CodePtr++; OutBytes++; Length--; } 
            Index += 2;  /* codes are 2 bytes */
         }
         else 
            { *CurrPos++ = Set[Index++]; OutBytes++; }
      }
   }
   return OutBytes;
} 
   
// Prints a Phrase from the Phrase table
void PrintPhrase(char *Phrases, int PhraseNum) {
    int *Offsets = (int *)Phrases;
    char *p = Phrases+Offsets[PhraseNum];
    while (p < Phrases + Offsets[PhraseNum + 1])
        { putchar(*p); p++; }
}

// Build up a table of phrases
void PhrasesLoad(FILE *HelpFile, long FileStart) {
   FILEHEADER      FileHdr;
   PHRASEHDR       PhraseHdr;
   int             *Offsets;
   char            *Phrases;
   long            DeCompSize;

   /* Go to the phrases file and get the headers */
   fseek(HelpFile, FileStart, SEEK_SET);
   fread(&FileHdr, sizeof(FileHdr), 1, HelpFile);
   fread(&PhraseHdr, sizeof(PhraseHdr), 1, HelpFile);

   /* Allocate space and decompress if it's compressed, else read in. */
   if (Compressed) {
      if ((Offsets = malloc((unsigned) (PhraseHdr.PhrasesSize + 
          (PhraseHdr.NumPhrases + 1) * 2))) == NULL)
        MSG("No room to decompress |Phrases");
      Phrases = Offsets + fread(Offsets,2,PhraseHdr.NumPhrases+1, HelpFile);
      DeCompSize = Decompress(HelpFile, (long)FileHdr.FileSize - 
          (sizeof(PhraseHdr) + 2 * (PhraseHdr.NumPhrases+1)), Phrases);
      if (DeCompSize != PhraseHdr.PhrasesSize) {
         printf("\n");
      }
   }
   else {
      if (!(Offsets=malloc((unsigned)(FileHdr.FileSize-sizeof(PhraseHdr)))))
         MSG("No room to decompress |Phrases");
      /* Backup 4 bytes for uncompressed Phrases (no PhrasesSize) */
      fseek(HelpFile, -4, SEEK_CUR);
      fread(Offsets, (unsigned) (FileHdr.FileSize - 4), 1, HelpFile);
   }
   PhrasesPtr = Phrases = (char *) Offsets;
}

/* Because the topic file is broken into 4k blocks, we'll have to handle
all the reads.  The idea is to filter out the TOPICBLOCKHEADERs and
do any decompression that needs doing. */
long TopicRead(BYTE *Dest, long NumBytes, FILE *HelpFile) {
   static long        CurrBlockLoc = 0;   /* Where we are in the block  */
   static BYTE        *DCmpBlock = NULL;  /* Block of uncompressed data */
   static long        DecompSize;         /* Size of block after decomp */
   static long        TopicStart, BlkNum; /* Start of |TOPIC file       */
   long               BytesLeft;          /* # Bytes left to return     */
   TOPICBLOCKHEADER   BlockHeader;
   TOPICLINK          *TempLink;
   long               EndOffset;

   /* If NumBytes = 0, then we're done and need to free memory */
   if (NumBytes == -1) { free(DCmpBlock); return 0; }

   if (!DCmpBlock) {
      if (Compressed) {
         if (! (DCmpBlock = malloc((unsigned) (4 * TopicBlockSize))))
             FAIL("Not enough memory to decompress |TOPIC file");
         TopicStart = ftell(HelpFile);
         BlkNum = 0;
      }
      else if (! (DCmpBlock = malloc((unsigned) TopicBlockSize)))
          FAIL("Not enough memory to handle |TOPIC file");
      DecompSize = 0;   /* Set initial size to 0 */
      /* Don't really need first block header, so get it out of the way */
      fread(&BlockHeader, sizeof(BlockHeader), 1, HelpFile);
   }

   BytesLeft = NumBytes;
   while (BytesLeft) {
      if (DecompSize == CurrBlockLoc) {
         BlkNum++;

         if (Compressed) {
            DecompSize = Decompress(HelpFile, (long)TopicBlockSize-1, 
				(char *)DCmpBlock);
            /* Align ourselves at next 4k block */
            fseek(HelpFile, TopicStart + (4096L * BlkNum), SEEK_SET);
         }
         else
            DecompSize=fread(DCmpBlock,1,(unsigned) TopicBlockSize, HelpFile);

         CurrBlockLoc = 0;
         fread(&BlockHeader, sizeof(BlockHeader), 1, HelpFile);

         // Get offset of last topic link. (Don't need block #, hence 3FFFh)
         EndOffset = BlockHeader.LastTopicLink & 0x3FFF;
         TempLink = (TOPICLINK*)(DCmpBlock + EndOffset-sizeof(BlockHeader));

         /* Actual end of the data (Don't include header) */
         EndOffset += (TempLink->BlockSize - sizeof(BlockHeader));

         // If end shorter than topic block use it; else topic block full
         if (EndOffset > DecompSize) {
             /* Adjust DecompSize if crossing 4k boundary */
             EndOffset = TempLink->BlockSize-((TempLink->NextBlock) & 0x3FFF);
             DecompSize = (BlockHeader.LastTopicLink & 0x3FFF) + EndOffset;
         }
         else DecompSize = EndOffset;
     } /* If */

     *(Dest++) = *(DCmpBlock + (CurrBlockLoc++) );
      BytesLeft--;
   } /* While (BytesLeft) */
   return NumBytes;
}

// Displays a string from a topic link record. Checks for Phrase
// replacement and non-printable chars
void TopicStringPrint(char *String, long Length) {
   BYTE            Byte1, Byte2;
   int             CurChar, PhraseNum;
   long            counter;

   for (counter = 0; counter < Length; counter++) {
      CurChar = * ((char *) (String + counter));

      /* Check for Phrase replacement! */
      if ((CurChar > 0) && (CurChar < 10)) {
         Byte1 = (BYTE) CurChar;
         counter++;
         CurChar = * ((char *) (String + counter));
         Byte2 = (BYTE) CurChar;
         PhraseNum = (256 * (Byte1 - 1) + Byte2);

         /* If there's a remainder, we have a space after the phrase */
         PrintPhrase(PhrasesPtr, PhraseNum / 2);
         if (PhraseNum % 2) putchar(' ');
      }
      else if (isprint(CurChar)) putchar(CurChar);
      else putchar(' ');	// could do newline for 0x00 0x00
   }
}

// Dump |TOPIC file, doing decompression and phrase substitution
void TopicDump(FILE *HelpFile, long FileStart) {
   FILEHEADER      FileHdr;
   TOPICHEADER     *TopicHdr;
   TOPICLINK       TopicLink;

   /* Go to the TOPIC file and get the headers */
   fseek(HelpFile, FileStart, SEEK_SET);
   fread(&FileHdr, sizeof(FileHdr), 1, HelpFile);

   do {
      TopicRead((BYTE *) &TopicLink, sizeof(TopicLink) - 4, HelpFile);

      if (Compressed)
         TopicLink.DataLen2 = TopicLink.BlockSize - TopicLink.DataLen1;

      TopicLink.LinkData1=(BYTE *) malloc((unsigned)(TopicLink.DataLen1-21));
      if(!TopicLink.LinkData1)
          MSG("Error allocating TopicLink.LinkData1");
      TopicRead(TopicLink.LinkData1, TopicLink.DataLen1 - 21, HelpFile);
      if (TopicLink.DataLen2 > 0) {
          TopicLink.LinkData2=(BYTE*)malloc((unsigned)(TopicLink.DataLen2+1));
          if(!TopicLink.LinkData2)
             MSG("Error allocating TopicLink.LinkData2");
          TopicRead(TopicLink.LinkData2, TopicLink.DataLen2, HelpFile);
      }

      /* Display a Topic Header record */
      if (TopicLink.RecordType == TL_TOPICHDR) {
         TopicHdr = (TOPICHEADER *)TopicLink.LinkData1;
         printf("================ Topic Block Data ====================\n");
         printf("Topic#: %ld - ", TopicHdr->TopicNum);

         if (TopicLink.DataLen2 > 0)
            TopicStringPrint(TopicLink.LinkData2, (long) TopicLink.DataLen2);
         else printf("\n");
      }

      /* Show a 'text' type record. */
      else if (TopicLink.RecordType == TL_DISPLAY) {
         printf("-- Topic Link Data\n");
         TopicStringPrint(TopicLink.LinkData2, (long) TopicLink.DataLen2);
      }
      printf("\n\n");
      free(TopicLink.LinkData1);
      if (TopicLink.DataLen2 > 0) free(TopicLink.LinkData2);
   } while(TopicLink.NextBlock != -1);
}

void DumpFile(FILE *HelpFile) {
    long    FileOffset, PhraseOffset, TopicOffset;
    DWORD   i;
    char    FileName[32];

    fread(&HelpHeader, sizeof(HelpHeader), 1, HelpFile);
    if (HelpHeader.MagicNumber != 0x35F3FL)
        MSG("Fatal Error:  Not a valid WinHelp file");
    WHIFSGetFirstLeaf(HelpFile);
    TopicOffset = PhraseOffset = 0;

    for (i=0; i<WHIFSHeader.TotalWHIFSEntries; i++) {
       GetFile(HelpFile, i, &FileOffset, FileName);
       if (! strcmp(FileName, "|SYSTEM")) SysLoad(HelpFile, FileOffset);
       else if (! strcmp(FileName, "|Phrases")) PhraseOffset = FileOffset;
       else if (! strcmp(FileName, "|TOPIC")) TopicOffset = FileOffset;
       }
       if (PhraseOffset) PhrasesLoad(HelpFile, PhraseOffset);
       if (TopicOffset) TopicDump(HelpFile, TopicOffset);
       else MSG("No Topic file found!");
}

int main(int argc, char *argv[]) {
    char filename[40];
    FILE *HelpFile;

    if (argc < 2) { 
       printf("Usage: TOPICDMP helpfile[.hlp]\n\n");
       printf("   helpfile      - Name of help file (.HLP or .MVB)\n\n");
       return EXIT_FAILURE;
       }

    if (! strchr(strcpy(filename, strupr(argv[1])), '.'))
       strcat(filename, ".HLP");

    if ((HelpFile = fopen(filename, "rb")) == NULL) {
       printf("Can't open %s!", filename);
       return EXIT_FAILURE;
    }

    DumpFile(HelpFile);
    fclose(HelpFile);
    return EXIT_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\Windows Undocumented File Formats\wuff_src\CHAP4\TOPICDMP\WHSTRUCT.H ===
/**********************************************************************
 *
 * PROGRAM: WHSTRUCT.H
 *
 * PURPOSE: Windows Help File Internal Records
 *
 * Copyright 1997, Mike Wallace and Pete Davis
 *
 * Chapter 4, Windows Help File Format, from Undocumented Windows
 * File Formats, published by R&D Books, an imprint of Miller Freeman, Inc.
 *
 **********************************************************************/

typedef unsigned long   DWORD;
typedef unsigned int    WORD;
typedef unsigned char   BYTE;

/* Define WHIFS Page Size and Page size for other B-Trees */
#define WHIFSPageSize 1024L
#define BTreePageSize 2048L

/* Define the size of a Topic Block 4k - sizeof(TOPICLINK) */
#define TopicBlockSize 4084L


#define GotoWHIFSPage(DestPage)     \
    fseek(HelpFile, FirstPageLoc+(DestPage * WHIFSPageSize), SEEK_SET)

#define GotoPage(DestPage)          \
    fseek(HelpFile, FirstPageLoc+(DestPage * BTreePageSize), SEEK_SET)

#define RGB(r,g,b) ((DWORD)(b*65536) + (DWORD)(g*256) + (DWORD) (r))

/* Help file Header record */
typedef struct HELPHEADER {
    DWORD   MagicNumber;      /* 0x00035F3F                */
    long    WHIFS;            /* Pointer to WHIFS header   */
    long    Negative1;
    long    FileSize;         /* Size of entire .HLP File  */
} HELPHEADER;


/* File Header for WHIFS files */
typedef struct FILEHEADER {
    long    FilePlusHeader;  /* File size including this header */
    long    FileSize;        /* File size not including header  */
    char    TermNull;
} FILEHEADER;


/* Help Directory BTREE */
typedef struct WHIFSBTREEHEADER {
    char    Magic[18];      /* Not exactly magic for some .MVB files   */
    char    Garbage[13];
    int     MustBeZero;     /* Probably shows up when Help > ~40 megs  */
    int     NSplits;        /* Number of page split Btree has suffered */
    int     RootPage;       /* Page # of root page                     */
    int     MustBeNegOne;   /* Probably shows up when B-Tree is HUGE!! */
    int     TotalPages;     /* total # to 2Kb pages in Btree           */
    int     NLevels;        /* Number of levels in this Btree          */
    DWORD   TotalWHIFSEntries;
} WHIFSBTREEHEADER;

/* Keyword & TTL BTREE Headers - Slightly different than WHIFS B-tree Header.
   Both WHIFS and Keyword B-Trees use same leaf and index node headers.    */

typedef struct BTREEHEADER {
    char    Unknown1[22];
    int     MustBeZero1;
    int     NSplits;        /* # of page splits Btree has suffered */
    int     RootPage;       /* page #of root page */
    int     MustBeNegOne1;
    int     TotalPages;     /* total # of 2Kb pages in Btree */
    int     NLevels;        /* # of levels in this Btree */
    DWORD   TotalBtreeEntries;
} BTREEHEADER;

/* Modified B-Tree Node header to handle a pointer to the page */
typedef struct BTREENODEHEADER {
    WORD    Signature;      /* Signature word            */
    int     NEntries;       /* Number of entries         */
    int     PreviousPage;   /* Index of Previous Page    */
    int     NextPage;       /* Index of Next Page        */
} BTREENODEHEADER;

/* Modified B-Tree Index header to handle a pointer to the page */
typedef struct BTREEINDEXHEADER {
    WORD    Signature;      /* Signature byte            */
    int     NEntries;       /* Number of entries in node */
} BTREEINDEXHEADER;


/* Phrase header In uncompressed, last field is empty */
typedef struct PHRASEHDR    {
    int     NumPhrases;     /* Number of phrases in table                     */
    WORD    OneHundred;     /* 0x0100                                         */
    long    PhrasesSize;    /* Amount of space uncompressed phrases requires. */
} PHRASEHDR;



/* Header for |FONT file */
typedef struct FONTHEADER {
    WORD    NumFonts;           /* Number of fonts in Font List */
    WORD    NumDescriptors;     /* Number of font descriptors   */
    WORD    DefDescriptor;      /* Default font descriptor      */
    WORD    DescriptorsOffset;  /* Offset to descriptor list    */
} FONTHEADER;

typedef struct FONTDESCRIPTOR {
    BYTE    Attributes;         /* Font Attributes See values below */
    BYTE    HalfPoints;         /* PointSize * 2                    */
    BYTE    FontFamily;         /* Font Family. See values below    */
    BYTE    FontName;           /* Number of font in Font List      */
    BYTE    Unknown;
    BYTE    FGRGB[3];           /* RGB values of foreground         */
    BYTE    BGRGB[3];           /* background RGB Values (?? Not sure */
} FONTDESCRIPTOR;

/* Font Attributes */
#define FONT_NORM    0x00       /* Normal         */
#define FONT_BOLD    0x01       /* Bold           */
#define FONT_ITAL    0x02       /* Italics        */
#define FONT_UNDR    0x04       /* Underline      */
#define FONT_STRK    0x08       /* Strike Through */
#define FONT_DBUN    0x10       /* Dbl Underline  */
#define FONT_SMCP    0x20       /* Small Caps     */

/* Font Families */
#define FAM_MODERN   0x01
#define FAM_ROMAN    0x02
#define FAM_SWISS    0x03
#define FAM_TECH     0x03
#define FAM_NIL      0x03
#define FAM_SCRIPT   0x04
#define FAM_DECOR    0x05


/* Header for |SYSTEM file */
typedef struct SYSTEMHEADER {
    BYTE    Magic;     /* 0x6C                  */
    BYTE    Version;   /* Version #             */
    BYTE    Revision;  /* Revision code         */
    BYTE    Always0;   /* Unknown               */
    WORD    Always1;   /* Always 0x0001         */
    DWORD   GenDate;   /* Date/Time that the help file was generated    */
    WORD    Flags;     /* Values seen: 0x0000 0x0004, 0x0008, 0x000A    */
} SYSTEMHEADER;

/* Flags for |SYSTEM header Flags field below */
#define NO_COMPRESSION_310      0x0000
#define COMPRESSION_310         0x0004
#define COMPRESSION_UNKN        0x0008
#define SYSFLAG_300             0x000A

/* Help Compiler 3.1 System record. Multiple records possible */
typedef struct SYSTEMREC {
    WORD    RecordType;   /* Type of Data in record      */
    WORD    DataSize;     /* Size of RData               */
    char    *RData;       /* Raw data (Icon, title, etc) */
} SYSTEMREC;

/* Types for SYSTEMREC RecordType below */  
#define HPJ_TITLE       0x0001      /* Title from .HPJ file            */
#define HPJ_COPYRIGHT   0x0002      /* Copyright notice from .HPJ file */
#define HPJ_CONTENTS    0x0003      /* Contents=??? from .HPJ          */
#define MACRO_DATA      0x0004      /* SData = 4 nulls if no macros    */
#define ICON_DATA       0x0005
#define HPJ_SECWINDOWS  0x0006      /* Secondary window info in .HPJ   */
#define HPJ_CITATION    0x0008      /* CITATION= under [OPTIONS]       */


/* Secondary Window Record following type 0x0006 System Record */

typedef struct SECWINDOW {
    WORD    Flags;          /* Flags (See Below)        */
    BYTE    Type[10];       /* Type of window           */
    BYTE    Name[9];        /* Window name              */
    BYTE    Caption[51];    /* Caption for window       */
    WORD    X;              /* X coordinate to start at */
    WORD    Y;              /* Y coordinate to start at */
    WORD    Width;          /* Width to create for      */
    WORD    Height;         /* Height to create for     */
    WORD    Maximize;       /* Maximize flag            */
    BYTE    Rgb[3];
    BYTE    Unknown1;
    BYTE    RgbNsr[3];      /* RGB for non scrollable region */
    BYTE    Unknown2;
} SECWINDOW;

/** Values for Flags **/

#define WSYSFLAG_TYPE       0x0001  /* Type is valid        */
#define WSYSFLAG_NAME       0x0002  /* Name is valid        */
#define WSYSFLAG_CAPTION    0x0004  /* Ccaption is valid    */
#define WSYSFLAG_X          0x0008  /* X    is valid        */
#define WSYSFLAG_Y          0x0010  /* Y    is valid        */
#define WSYSFLAG_WIDTH      0x0020  /* Width    is valid    */
#define WSYSFLAG_HEIGHT     0x0040  /* Height   is valid    */
#define WSYSFLAG_MAXIMIZE   0x0080  /* Maximize is valid    */
#define WSYSFLAG_RGB        0x0100  /* Rgb  is valid        */
#define WSYSFLAG_RGBNSR     0x0200  /* RgbNsr   is valid    */
#define WSYSFLAG_TOP        0x0400  /* On top was set in HPJ file */

/* Header for |TOMAP file */
typedef struct TOMAPHEADER {
    long    IndexTopic;   /* Index topic for help file */
    long    Reserved[15];
    int     ToMapLen;     /* Number of topic pointers  */
    long    *TopicPtr;    /* Pointer to all the topics */
} TOMAPHEADER;



/* Keyword Map Record */
typedef struct KWMAPREC {
    long    FirstRec;       /* Index number of first keyword on leaf page    */
    WORD    PageNum;        /* Page number that keywords are associated with */
} KWMAPREC;


/* |TOPIC Block header - Header for a block of topic data. If
uncompressed, there's only one of these at the beginning of the
file. If the help file is compressed, then these occur in 4k
increments. (e.g. 0x0000, 0x1000, 0x2000, 0x3000, 0x4000, etc. ) */
typedef struct TOPICBLOCKHEADER {
    long    LastTopicLink;   /* Offset of last topic link in previous block   */
    long    TopicData;       /* Offset of topic data start                    */
    long    LastTopicHeader; /* Offset of last topic header in previous block */
} TOPICBLOCKHEADER;


/* Linked list record for |TOPIC file */
typedef struct TOPICLINK {
    long     BlockSize;   /* Size of this link + Data         */
    long     DataLen2;    /* Length of LinkData2              */
    long     PrevBlock;   /* Relative to first byte of |TOPIC */
    long     NextBlock;   /* Relative to first byte of |TOPIC */
    long     DataLen1;    /* Len(LinkData1 + 11(hdr size))    */
    BYTE     RecordType;  /* See below                        */
    BYTE     *LinkData1;  /* Data associated with this link   */
    BYTE     *LinkData2;  /* Second set of data               */
} TOPICLINK;

/* Known record types for topic link */
#define TL_TOPICHDR    0x02  /* Topic header information */
#define TL_DISPLAY     0x20  /* Displayable information  */
#define TL_TABLE       0x23  /* WinHelp Table            */

/* Topic header. Starts inside LinkData of a type 0x02 record */
typedef struct TOPICHEADER {
    long     BlockSize; /* Size of topic, including internal topic links  */
    long     BrowseBck; /* Topic offset for prev topic in Browse sequence */
    long     BrowseFor; /* Topic offset for next topic in Browse sequence */
    DWORD    TopicNum;  /* Topic Number(?)                                */
    long     NonScroll; /* Start of Non-Scroll Region                     */
    long     Scroll;    /* Start of Scrolling Region of text.             */
    long     NextTopic; /* Start of next Type 0x02 record                 */
} TOPICHEADER;

/* Record from |CTXOMAP file. Created from the [MAP] section of .HPJ file */
typedef struct CTXOMAPREC {
    long     MapID;
    long     TopicOffset;
} CTXOMAPREC;


/* Record from |CONTEXT file */
typedef struct CONTEXTREC {
    long     HashValue;       /* Hash value of a phrase     */
    long     TopicOffset;     /* Topic offset of the phrase */
} CONTEXTREC;

/* Record for the |KWBTREE file */
typedef struct KWBTREEREC {
    char     Keyword[80];     /* Variable Length Keyword      */
    int      Count;           /* Count of Keywords occurances */
    long     KWDataOffset;    /* Offset into |KWDATA file     */
} KWBTREEREC;
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\Windows Undocumented File Formats\wuff_src\CHAP6\COMP.C ===
/**********************************************************************
 *
 * PROGRAM: COMP.C
 *
 * PURPOSE: Compress a file using something like Microsoft's derivative on LZ77
 * (i.e., it can be uncompressed using Microsoft's EXPAND.EXE)
 *
 * Copyright 1997, Mike Wallace and Pete Davis
 *
 * Chapter 6, Compression Algorithm and File Formats, from Undocumented Windows
 * File Formats, published by R&D Books, an imprint of Miller Freeman, Inc.
 *
 **********************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "decomp.h"

#define WINSIZE  4096
#define MAXLEN   18

#define COMP_CODE(x,y) ((((x-3) & 0x0F) << 8) + (((y - 0x10) & \
                       0x0F00) << 4) + ((y - 0x10) & 0x00FF))

#define LOBYTE(x) ((unsigned char)(x))
#define HIBYTE(x) ((unsigned char)(((unsigned short)(x) >> 8) & 0xFF))

#define DROP_INDEX(x) (x == 0) ? (WINSIZE - 1) : (x - 1)
#define ADD_INDEX(x)  ((x + 1) == WINSIZE) ? 0 : (x + 1)

/* This is our Compression Window */
unsigned char Window[WINSIZE];

/***************************************************
  Set bit number "bit" in byte "byte"
****************************************************/
void BitSet(int bit, char *byte)
{

   short result = 1;

   /* make sure bit range is 0,..,7 */
   if (bit < 0) bit = 0;
   else if (bit > 7) bit = 7;

   while (bit--)
      result *= 2;

   *byte = result | *byte;

} /* BitSet - end */


/*************************************************
  InBetween - detects if lower <= target <= higher
**************************************************/ 
int InBetween(int lower, int higher, int target)
{

  if(higher < lower)
     higher += WINSIZE;
  if((lower <= target) && (target <= higher))
     return 1;
  else
     return 0;

} /* InBetween - end */


/*************************************************
  Force FlagByte and DataBytes to print out
**************************************************/ 
void WriteFlagByte(FILE *outfile)
{

   int index = 0;

   if(FlagCount > 0) {
      DataBytes[DataCount] = '\0';
      fputc(FlagByte, outfile);
      for (; index < DataCount ; ++index)
         fprintf(outfile, "%c", DataBytes[index]);
      DataCount = FlagCount = 0;
      FlagByte = '\0';
      for (index = 0; index < 17; ++index)
         DataBytes[index] = ' ';
   }

} /* WriteFlagByte - end */


/*************************************************
  Check if FlagByte is full and should be printed out
**************************************************/ 
void CheckFlagByte(FILE *outfile)
{

   ++DataCount;
   if(++FlagCount == 8)
     WriteFlagByte( outfile );

} /* CheckFlagByte - end */


/*************************************************
  Saves an uncompressed data byte
**************************************************/ 
void GetNextChar( int *CurrPos, FILE *infile)
{

   unsigned char ch;

   fread(&ch, sizeof(char), 1, infile);
   if (!feof(infile))
      Window[*CurrPos = ADD_INDEX(*CurrPos)] = ch;

} /* GetNextChar - end */


/*************************************************
  Unreads the last character read
**************************************************/ 
void UnreadChar(unsigned char ch, FILE *infile, int *CurrPos, 
                unsigned char ch2)
{

   ungetc( ch, infile);
   Window[*CurrPos] = ch2;
   *CurrPos = DROP_INDEX(*CurrPos);

} /* UnreadChar - end */


/*************************************************
  Saves an uncompressed data byte
**************************************************/ 
void SaveUncompByte(unsigned char ch, FILE *outfile)
{

   BitSet(FlagCount, &FlagByte);
   DataBytes[DataCount] = ch;
   CheckFlagByte( outfile );

} /* SaveUncompByte - end */


/*************************************************
  Compresses the data using Microsoft's LZ77
derivative (Zeck).
**************************************************/ 
void Compress(FILE *infile, FILE *outfile)
{

   int count=0, shifter=0, CurrPos=0;
   int SavePos=0, iCompCode = 0, offset = 0;
   int newPos = 0;
   unsigned char ch;
   int bestcount = 0, bestoffset = 0;
   char oldchars[3];

   FlagCount = 0;
   DataCount = 0;
   FlagByte  = '\0';

   for (count = 0; count < WINSIZE; count ++)
      Window[count] = ' ';

   rewind( infile );

   /* Go through input file until we're done */
   fread(&ch, sizeof(char), 1, infile);
   Window[CurrPos] = ch;
   while (!feof(infile)) {

      /* if less than 3 chars from end, just write out remainder */
      if((InfileSize - ftell(infile)) < 2) {
         SaveUncompByte( Window[CurrPos], outfile);
         GetNextChar( &CurrPos, infile);
         continue;
      } 

      /* Find previous occurrence of character in window */
      for (count = 1, shifter = DROP_INDEX(CurrPos);
         (Window[shifter] != Window[CurrPos]) && (count < WINSIZE);
         ++count, shifter = DROP_INDEX(shifter)) {}

      /* check if char is unique so far in input file */
      if(count == WINSIZE) {
         SaveUncompByte( Window[CurrPos], outfile);
         GetNextChar( &CurrPos, infile);
         continue;
      }
      else {

         /* find out how many characters match */
         SavePos = CurrPos;
         oldchars[2] = oldchars[0] = Window[ADD_INDEX(CurrPos)];
         GetNextChar( &CurrPos, infile);
         for(count = 1, offset=shifter, shifter = ADD_INDEX(shifter);
            (!feof(infile)) && (Window[shifter] == Window[CurrPos]) && 
            (count < MAXLEN);) {
            ++count;
            if(count == 2)
               oldchars[1] = Window[ADD_INDEX(CurrPos)];
            oldchars[2] = Window[ADD_INDEX(CurrPos)];
            GetNextChar( &CurrPos, infile);
            shifter = ADD_INDEX(shifter); 
         }

         /* Since this is the first match, save it as the best so far */
         bestcount  = count;
         bestoffset = offset;

         if(((Window[shifter] != Window[CurrPos]) || (count == MAXLEN)) &&
            (!feof(infile)))
            UnreadChar( Window[CurrPos], infile, &CurrPos, oldchars[2]);

         /* Now find the best match for the string in the window */
         shifter = DROP_INDEX( offset );
         while((shifter != CurrPos) && (bestcount < MAXLEN) &&
            (!InBetween( SavePos, CurrPos, shifter))) {

            for( ; (shifter != CurrPos) && (Window[shifter] != Window[SavePos]);
               shifter = DROP_INDEX(shifter)) {}
            if(shifter == CurrPos)
               continue;
            for(count = 0, offset = shifter, newPos = SavePos;
               (!feof(infile)) && (Window[shifter] == Window[newPos]) &&
               (count < MAXLEN); ++count, newPos = ADD_INDEX(newPos)) {
               if (count >= (bestcount - 1)) {
                  if(count == 1)
                     oldchars[1] = Window[ADD_INDEX(CurrPos)];
                  oldchars[2] = Window[ADD_INDEX(CurrPos)];
                  GetNextChar( &CurrPos, infile );
               }
               shifter = ADD_INDEX(shifter);
            }

            if(((count >= MAXLEN) || ((Window[shifter] != Window[newPos]) && 
               (count >= bestcount))) && (!feof(infile)))
               UnreadChar( Window[CurrPos], infile, &CurrPos, oldchars[2]);

            if(count > bestcount) {
               bestcount = count;
               bestoffset = offset;
            }
            shifter = DROP_INDEX( offset );

         } /* while(shifter != CurrPos) */

         if(!feof(infile))
            GetNextChar( &CurrPos, infile );

         count = bestcount;
         offset = bestoffset;

         /* if count < 3, then not enough chars to compress */
         if (count < 3) {
            SaveUncompByte( Window[SavePos], outfile);
            fseek(infile, ftell(infile) - count, 0);
            Window[SavePos = ADD_INDEX(SavePos)] = oldchars[0];
            CurrPos = DROP_INDEX(CurrPos);
            if (count == 2) {
               Window[ADD_INDEX(SavePos)] = oldchars[1];
               CurrPos = DROP_INDEX(CurrPos);
            }

         }
         else {
            iCompCode = COMP_CODE(count, offset);
            DataBytes[DataCount]   = LOBYTE(iCompCode);
            DataBytes[++DataCount] = HIBYTE(iCompCode);
            CheckFlagByte( outfile );

            if (!feof(infile))
                UnreadChar( Window[CurrPos], infile, &CurrPos, oldchars[2]);
         }

         if((!feof(infile)) && (count <= MAXLEN))
            GetNextChar( &CurrPos, infile);

      }

   } /* while - end */

   WriteFlagByte( outfile );

} /* Compress - end */

/***************************************************
  Write the header that exists at the beginning of 
  every file compressed using MS's Zeck compression
****************************************************/
void WriteHeader(FILE *infile, FILE *outfile)
{

   COMPHEADER CompHeader;

   CompHeader.Magic1 = MAGIC1;
   CompHeader.Magic2 = MAGIC2;
   CompHeader.Is41 = 0x41;
   CompHeader.FileFix = '\0';  /* This stores the original last */
                               /* char. of the input filename   */

   fseek( infile, 0L, 2);
   CompHeader.DecompSize = InfileSize = ftell(infile);
   rewind( infile );

   rewind( outfile);
    
   fwrite(&CompHeader, sizeof(CompHeader), 1, outfile);

   Compress(infile, outfile);

} /* WriteHeader - end */


/***************************************************
  Show usage.
****************************************************/
void Usage( void )
{

   printf("Usage:\n");
   printf(" COMP file1.ext file2.ext\n\n");
   printf("   file1.ext - Name of uncompressed file\n");
   printf("   file2.ext - Name of compressed file\n\n");

} /* Usage - end */


/***************************************************
  Open the input and output files, and call routine
  to compress the data.
****************************************************/
int main(int argc, char *argv[])
{

   char filename[128];
   FILE *infile, *outfile;

   if (argc != 3) {
      Usage();
      return EXIT_FAILURE;
   }

   strcpy(filename, argv[1]);
   if ((infile = fopen(filename, "rb")) == NULL) {
      printf("%s does not exist\n", filename);
      return(EXIT_FAILURE);
   }

   strcpy(filename, argv[2]);
   if ((outfile=fopen(filename, "wb+")) == NULL) {
      printf("Error opening destination file\n");
      return(EXIT_FAILURE);
   }

   WriteHeader(infile, outfile);
   fclose(infile);
   fclose(outfile);

   return(EXIT_SUCCESS);

} /* main - end */

/* comp.c - end */
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\Windows Undocumented File Formats\wuff_src\CHAP6\DECOMP.C ===
/**********************************************************************
 *
 * PROGRAM: DECOMP.C
 *
 * PURPOSE: Decompress a file compressed with Microsoft's COMPRESS.EXE utility.
 * Functionally equivalent to EXPAND.EXE.
 *
 * Copyright 1997, Mike Wallace and Pete Davis
 *
 * Chapter 6, Compression Algorithm and File Formats, from Undocumented Windows
 * File Formats, published by R&D Books, an imprint of Miller Freeman, Inc.
 *
 **********************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "decomp.h"

#define WINSIZE  4096
#define LENGTH(x) ((((x) & 0x0F)) + 3)
#define OFFSET(x1, x2) ((((((x2 & 0xF0) >> 4) * 0x0100) + x1) & 0x0FFF) \
                       + 0x0010)

#define FAKE2REAL_POS(x)   ((x) & (WINSIZE - 1))
#define BITSET(byte, bit)  (((byte) & (1<<bit)) > 0)

/* This is our Compression Window */
char Window[WINSIZE];

/*************************************************
  Decides how many bytes to read, depending on the
  number of bits set in the Bitmap
**************************************************/
int BytesToRead(unsigned char BitMap) {

    int TempSum, counter, c;

    TempSum = 8;
    for (counter = 0; counter < 8; counter ++) {
        c = BITSET(BitMap, counter);
        TempSum += (1 - BITSET(BitMap, counter));
    }

    return TempSum;

} /* BytesToRead - end */


/*************************************************
  Decompresses the data using Microsoft's LZ77
derivative.
**************************************************/ 
void Decompress(FILE *infile, FILE *outfile, long CompSize) {

    unsigned char BitMap, byte1, byte2;
    int Length, counter;
    long Offset, CurrPos=0;

    for (counter = 0; counter < WINSIZE; counter ++)
        Window[counter] = ' ';

    /* Go through until we're done */
    while (CurrPos < CompSize) {

        /* Get BitMap and data following it */
        BitMap = fgetc(infile); 
        if (feof(infile)) return;
        (void) BytesToRead(BitMap);

        /* Go through and decode data */
        for (counter = 0; counter < 8; counter++) {

            /* It's a code, so decode it and copy the data */
            if (!BITSET(BitMap, counter)) {
                byte1 = fgetc(infile); 
                if (feof(infile)) return;
                byte2 = fgetc(infile); 
                Length = LENGTH(byte2);
                Offset = OFFSET(byte1, byte2);

                /* Copy data from 'window' */
                while (Length) {
                    byte1 = Window[FAKE2REAL_POS(Offset)];
                    Window[FAKE2REAL_POS(CurrPos)] = byte1;
                    fputc(byte1, outfile);
                    CurrPos++; 
                    Offset++; 
                    Length--;
                }
            }/* if */

            else {
                byte1 = fgetc(infile);
                Window[FAKE2REAL_POS(CurrPos)] = byte1;
                fputc(byte1, outfile); 
                CurrPos++;
            }
            if (feof(infile)) return;

        } /* for */

    } /* while  */

} /* Decompress - end */


/***************************************************
  Read the header at the beginning of the compressed
  file and verity it is a valid input file.
****************************************************/
void ReadHeader(FILE *infile, FILE *outfile) {

    COMPHEADER CompHeader;
    long       CompSize;

    fseek(infile, 0, SEEK_END);
    CompSize = ftell(infile);
    fseek(infile, 0, SEEK_SET);
    fread(&CompHeader, sizeof(CompHeader), 1, infile);
    if ((CompHeader.Magic1 != MAGIC1) || (CompHeader.Magic2 != MAGIC2)) {
        printf("Fatal Error:\n");
        printf("  Not a valid Compressed file file!\n");
        return;
    }

    printf("Decompressing file from %lu bytes to %lu bytes\n",
          CompSize, CompHeader.DecompSize);

    Decompress(infile, outfile, CompHeader.DecompSize);

    printf("Done!\n");

} /* ReadHeader - end */


/***************************************************
  Show usage.
****************************************************/
void Usage( void ) {

    printf("Usage:\n");
    printf(" DECOMP file1.ext file2.ext\n\n");
    printf("   file1.ext - Name of compressed file\n");
    printf("   file2.ext - Name of decompressed file\n\n");

} /* Usage - end */


/***************************************************
  Open the file and dump it.
****************************************************/
int main(int argc, char *argv[]) {

    char filename[128];
    FILE *infile, *outfile;

    if (argc < 3) {
        Usage();
        return EXIT_FAILURE;
    }

    strcpy(filename, argv[1]);
    if ((infile = fopen(filename, "rb")) == NULL) {
        printf("%s does not exist!", filename);
        return EXIT_FAILURE;
    }

    strcpy(filename, argv[2]);
    if ((outfile=fopen(filename, "wb")) == NULL) {
        printf("Error opening destination file!");
        return(EXIT_FAILURE);
    }

    ReadHeader(infile, outfile);
    fclose(infile);
    fclose(outfile);

    return(EXIT_SUCCESS);

} /* main - end */

/* decomp.c - end */
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\Windows Undocumented File Formats\wuff_src\CHAP6\DECOMP.H ===
/**********************************************************************
 *
 * PROGRAM: DECOMP.H
 *
 * PURPOSE: Header information for compressing/decompressing files using
 * Microsoft's LZ77 derivative.
 *
 * Copyright 1997, Mike Wallace and Pete Davis
 *
 * Chapter 6, Compression Algorithm and File Formats, from Undocumented Windows
 * File Formats, published by R&D Books, an imprint of Miller Freeman, Inc.
 *
 **********************************************************************/

typedef struct tagCOMPHEADER {
	long    Magic1;
	long    Magic2;
	char    Is41;        /* 0x41                          */
	char    FileFix;     /* Character saved for -r option */
	long    DecompSize;
} COMPHEADER;

/* Both of these numbers are constants */
/* in the LZEXPAND Library             */

/* First magic# "SZDD" */
#define MAGIC1 0x44445A53

/* Second magic# */
#define MAGIC2 0x3327F088

/* Define some global variables */
unsigned char FlagByte;       /* Byte at the start of each block of compressed data */
unsigned char DataBytes[17];  /* Block of compressed data */
int  DataCount=0,    /* Number of chars in current DataBytes[] */
     FlagCount=0;    /* Number of items in FlagByte */
long InfileSize=0L;  /* Size of input file */
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\Windows Undocumented File Formats\wuff_src\CHAP7\RES2RC.C ===
/**********************************************************************
 *
 * PROGRAM: RES2RC.C
 *
 * PURPOSE: Converts a .RES file to an .RC file
 *
 * Copyright 1997, Mike Wallace and Pete Davis
 *
 * Chapter 7, Resource (.RES) File Format, from Undocumented Windows
 * File Formats, published by R&D Books, an imprint of Miller Freeman, Inc.
 *
 **********************************************************************/

#include "restypes.h"

/***************************************************
   Read a byte from infile
****************************************************/
BYTE get_byte(FILE *infile) {

    BYTE ch;

    fread(&ch, sizeof(BYTE), 1, infile);
    return(ch);

} /* get_byte - end */


/***************************************************
   Read a word from infile
****************************************************/
WORD get_word(FILE *infile) {

    WORD num;

    fread(&num, sizeof(WORD), 1, infile);
    return(num);

} /* get_word - end */


/***************************************************
   Write out an integer to outfile
****************************************************/
void write_number(int num, FILE *outfile) {

    fprintf( outfile, "%d ", num);

} /* write_number - end */


/***************************************************
   Write out a word (unsigned short integer) to outfile
****************************************************/
void write_word(WORD num, FILE *outfile) {

    fprintf( outfile, "%hu", num);

} /* write_word - end */


/***************************************************
   Write out a dword (unsigned long) to outfile
****************************************************/
void write_dword(DWORD num, FILE *outfile) {

    fprintf( outfile, "%lu", num);

} /* write_dword - end */


/***************************************************
   Write out a character to outfile
****************************************************/
void write_char(char ch, FILE *outfile) {

   /* if the character is null, write out the string "\0" */
   if (ch == '\0')
      fprintf( outfile, "\\0");
   else
      fprintf( outfile, "%c", ch);

} /* write_char - end */


/***************************************************
   Write out an unsigned character to outfile
****************************************************/
void write_byte(BYTE ch, FILE *outfile) {

    fputc( ch, outfile);

} /* write_byte - end */


/***************************************************
   Write out a string to outfile, then add a newline
****************************************************/
void writeline(char *string, FILE *outfile) {

   if(strlen(string))
       fputs( string, outfile);

   fputc( CR, outfile);
   fputc( NL, outfile);

} /* writeline - end */


/***************************************************
   Write out a string to outfile
****************************************************/
void writestring(char *string, FILE *outfile) {

   if(strlen(string))
       fputs( string, outfile);

} /* writestring - end */


/***************************************************
   Increase the INDENT variable value by INDENT_SPACES
****************************************************/
void increase_indent( void ) {

    INDENT += INDENT_SPACES;

} /* increase_indent - end */


/***************************************************
   Decrease the INDENT variable value by INDENT_SPACES
****************************************************/
void decrease_indent( void ) {

    if((INDENT -= INDENT_SPACES) < 0)
       INDENT = 0;

} /* decrease_indent - end */


/***************************************************
   Write out INDENT spaces to outfile
****************************************************/
void write_indent(FILE *outfile) {

    int n;

    for(n = INDENT; (n); --n)
       write_char(' ', outfile);

} /* write_indent - end */


/***************************************************
   If the last stringtable wasn't closed, do so now.   
****************************************************/
void finish_off_stringtable(FILE *outfile) {

   if (StringCount)
      writeline("}", outfile);

} /* finish_off_stringtable - end */


/***************************************************
   Get name of custom resource
****************************************************/
void get_custom_type( BYTE ch, FILE *infile, FILE *outfile) {

   while(ch != 0x00) {
      write_char(ch, outfile);
      ch = get_byte(infile);
   }

} /* get_custom_type - end */


/***************************************************
   Get the resource name from the .res file (infile)
****************************************************/
DWORD write_item_text(FILE *infile, FILE *outfile) {

   BYTE  ch;
   DWORD length;

   ch = get_byte( infile );
   if(ch == 0x00)
      return(1);
   writestring("\"", outfile);
   length = 1;
   while(ch != 0x00) {
      ++length;
      write_char(ch, outfile);
      ch = get_byte( infile );
   }
   writestring("\"", outfile);
   return(length);

} /* write_item_text - end */


/***************************************************
   Returns the first new filename of the form
   <prefix>#.<suffix>
****************************************************/
char *get_data_filename(char *prefix, char *suffix) {

   FILE *fp;
   WORD number;
   char fname[13];
   char fname_start[3];
   char fname_end[5];
   int  name_length;

   /* form the prefix to the new filename */
   name_length = (strlen(prefix) > 2) ? 2 : strlen(prefix);
   strncpy(fname_start, prefix, name_length);
   fname_start[name_length] = '\0';

   /* form the suffix to the new filename */
   fname_end[0] = '.';
   name_length = (strlen(suffix) > 3) ? 3 : strlen(suffix);
   strncat( fname_end, suffix, name_length);
   fname_end[name_length + 1] = '\0';

   /* Keep forming new filenames until we get to one we can't open */
   number = 0;
   sprintf( fname, "%s%u%s", fname_start, number, fname_end);
   while((number < 1000) && ((fp = fopen( fname, "r")) != NULL)) {
      fclose(fp);
      ++number;
      sprintf( fname, "%s%u%s", fname_start, number, fname_end);
   }

   if(number == 1000)
      fname[0] = '\0';

   return(fname);

} /* get_data_filename - end */


/***************************************************
   Write out reslen bytes of data to datafile
****************************************************/
void write_data( FILE *infile, FILE *datafile, DWORD reslen ) {

   BYTE ch;

   ch = get_byte(infile);
   while(reslen) {
      fputc( ch, datafile);
      if(--reslen)
         ch = get_byte(infile);
   }
   
} /* write_data - end */


/***************************************************
   Retrieves the length of the resource from the .res file
****************************************************/
DWORD get_resource_length(FILE *infile) {

   DWORD reslen;

   fread(&reslen, sizeof(DWORD), 1, infile);

   return(reslen);

} /* get_resource_length - end */


/***************************************************
   Get the resource name from the .res file (infile)
****************************************************/
void get_resource_name(FILE *infile) {

   int resname;
   BYTE ch;

   ch = get_byte(infile);
   if(ch == 0xFF) {
       fread(&resname, sizeof(int), 1, infile);
   }
   else {
      ch = get_byte(infile);
      while((!feof(infile)) && (ch != 0x00)) {
         ch = get_byte(infile);
      }
   }

} /* get_resource_name - end */


/***************************************************
   Get the version name from the .res file (infile)
****************************************************/
void get_version_name(FILE *infile) {

   int  count=1; /* record number of chars read */
   BYTE ch;

   ch = get_byte(infile);
   while((!feof(infile)) && (ch != 0x00)) {
      ++count;
      ch = get_byte(infile);
   }

   /* Ensure number of characters read is a multiple of 4.    */
   /* According to the MS documentation, this is the format.  */
   /* See "MS Windows 3.1 Programmer's Reference" Vol.4, p.99 */
   count = count % 4;
   count = (count > 0) ? (4 - count) : 0;
   while ((!feof(infile)) && (count > 0)) {
      ch = get_byte(infile);
      --count;
   }

} /* get_version_name - end */


/***************************************************
   Get the resource number from the .res file (infile)
****************************************************/
WORD get_resource_number(FILE *infile) {

   WORD resname = 0;
   BYTE ch;

   ch = get_byte(infile);
   if(ch == 0xFF) {
       resname = get_word( infile );
   }
   else {
      ch = get_byte(infile);
      while((!feof(infile)) && (ch != 0x00)) {
         ch = get_byte(infile);
      }
   }

   return(resname);

} /* get_resource_number - end */


/***************************************************
   Get the resource name from the .res file (infile)
****************************************************/
void write_resource_name(FILE *infile, FILE *outfile) {

   int resname;
   BYTE ch;

   writeline( "", outfile);

   ch = get_byte(infile);
   if(ch == 0xFF) {
       fread(&resname, sizeof(int), 1, infile);
       write_number(resname, outfile);
   }
   else {
      write_char(ch, outfile);
      ch = get_byte(infile);
      while((!feof(infile)) && (ch != 0x00)) {
         write_char(ch, outfile);
         ch = get_byte(infile);
      }
   }

} /* write_resource_name - end */


/***************************************************
   Get the version number from the .res file (infile)
****************************************************/
void write_version_number(FILE *infile, FILE *outfile) {

   int resname;
   BYTE ch;

   writeline( "", outfile);

   ch = get_byte(infile);
   if(ch == 0xFF) {
       fread(&resname, sizeof(int), 1, infile);
       if (resname == (int) VS_VERSION_INFO)
          writestring("VS_VERSION_INFO ", outfile);
       else
          write_number(resname, outfile);
   }
   else {
      write_char(ch, outfile);
      ch = get_byte(infile);
      while((!feof(infile)) && (ch != 0x00)) {
         write_char(ch, outfile);
         ch = get_byte(infile);
      }
   }

} /* write_version_number - end */


/***************************************************
   Get the memory flags for the current resource.
****************************************************/
void get_mem_flags(FILE *infile) {

   /* Save the flag in a global variable.  See the header file! */
   prev_mem_flag = get_word( infile );
   return;

} /* get_mem_flags - end */


/***************************************************
   Write the memory flag values for the "special"
   resources - cursors and icons. They're different
   than the rest in that 0x20 means "discardable",
   not "pure".
****************************************************/
void write_special_mem_flag_values( WORD memtype, FILE *outfile) {

   if(memtype & 0x40)
      writestring(" PRELOAD", outfile);
   else
      writestring(" LOADONCALL", outfile);

   if(memtype & 0x10)
      writestring(" MOVEABLE", outfile);
   else
      writestring(" FIXED", outfile);

   if(memtype & 0x20)
      writestring(" DISCARDABLE", outfile);

} /* write_special_mem_flag_values - end */


/***************************************************
   Write the memory flag values for the current resource.
****************************************************/
void write_mem_flag_values( WORD memtype, FILE *outfile) {

   if(memtype & 0x40)
      writestring(" PRELOAD", outfile);
   else
      writestring(" LOADONCALL", outfile);

   if(memtype & 0x10)
      writestring(" MOVEABLE", outfile);
   else
      writestring(" FIXED", outfile);

/* This one isn't really used - "PURE" doesn't seem to make a difference.

   if(memtype & 0x20)
      writestring(" PURE", outfile);
*/

   if(memtype & 0x1000)
      writestring(" DISCARDABLE", outfile);

} /* write_mem_flag_values - end */


/***************************************************
   Get the memory flags for the current resource.
****************************************************/
void write_mem_flags(FILE *infile, FILE *outfile) {

   WORD memtype;

   memtype = get_word( infile );
   write_mem_flag_values( memtype, outfile );

} /* write_mem_flags - end */


/***************************************************
  Process the cursor resource
****************************************************/
void process_cursor( FILE *infile ) {

   DWORD reslen;

   /* Skip it for now.  We'll come back and get the information   */
   /* when we hit the group cursor resource - that has the header */
   /* that has to go at the start of the .cur file.               */

   get_resource_name(infile);
   get_mem_flags(infile);
   reslen = get_resource_length(infile);

   fseek(infile, reslen, 1);

} /* process_cursor - end */


/***************************************************
  Process the bitmap resource
****************************************************/
void process_bitmap(int restype, FILE *infile, FILE *outfile) {

   DWORD reslen;
   BITMAPFILEHEADER bmfh;
   char  datafilename[13];
   FILE  *datafile;

   write_resource_name(infile, outfile);
   write_char(' ', outfile);
   writestring(res_array[restype], outfile);
   write_mem_flags(infile, outfile);
   write_char(' ', outfile);

   reslen = get_resource_length(infile);

   strcpy(datafilename, get_data_filename("BM", "BMP"));
   if(strlen(datafilename) == 0) {
      writeline("<Unable to open output file>", outfile);
      fseek( infile, reslen, 1);
      return;
   }

   writeline( datafilename, outfile );

   if((datafile = fopen(datafilename, "wb")) == NULL) {
      printf("Unable to open file %s\n", datafilename);
      fseek( infile, reslen, 1);
      return;
   }

   bmfh.bfType      = 0x4D42;
   bmfh.bfSize      = reslen + sizeof(BITMAPFILEHEADER);
   bmfh.bfReserved1 = 0;
   bmfh.bfReserved2 = 0;
   bmfh.bfOffBits   = 0x76L;

   fwrite(&bmfh, sizeof(BITMAPFILEHEADER), 1, datafile);

   write_data( infile, datafile, reslen );
   fclose( datafile );

} /* process_bitmap - end */


/***************************************************
  Process the flags for a popup menu
****************************************************/
void process_popup_flags(DWORD menuitem, FILE *outfile) {

   if(menuitem & MF_GRAYED)
      writestring(", GRAYED", outfile);
   if(menuitem & MF_DISABLED)
      writestring(", INACTIVE", outfile);
   if(menuitem & MF_CHECKED)
      writestring(", CHECKED", outfile);
   if(menuitem & MF_MENUBARBREAK)
      writestring(", MENUBARBREAK", outfile);
   if(menuitem & MF_MENUBREAK)
      writestring(", MENUBREAK", outfile);
   if(menuitem & MF_END) {
   }

} /* process_popup_flags - end */


/***************************************************
  Process the flags for a normal menuitem
****************************************************/
void process_menuitem_flags(DWORD menuitem, FILE *outfile) {

   if(menuitem & MF_GRAYED)
      writestring(", GRAYED", outfile);
   if(menuitem & MF_DISABLED)
      writestring(", INACTIVE", outfile);
   if(menuitem & MF_CHECKED)
      writestring(", CHECKED", outfile);
   if(menuitem & MF_MENUBARBREAK)
      writestring(", MENUBARBREAK", outfile);
   if(menuitem & MF_MENUBREAK)
      writestring(", MENUBREAK", outfile);
   if(menuitem & MF_HELP)
      writestring(", HELP", outfile);
   if(menuitem & MF_END) {
      writeline("", outfile);
      decrease_indent();
      write_indent(outfile);
      writestring("}", outfile);
   }

} /* process_menuitem_flags - end */


/***************************************************
  Process a normal menu resource
****************************************************/
DWORD process_normal_menu(DWORD menuitem, FILE *infile, FILE *outfile) {

   WORD  menuid;
   DWORD bytesread;

   fread(&menuid, sizeof(menuid), 1, infile);
   bytesread = sizeof(menuid);

   increase_indent();
   write_indent(outfile);

   writestring("MENUITEM ", outfile);
   bytesread += write_item_text( infile, outfile);
   if((bytesread - 1) > sizeof(menuid)) {
      writestring(", ", outfile);
      write_word( menuid, outfile);
      process_menuitem_flags(menuitem, outfile);
   }
   else if((!menuid) && (!menuitem)) {
      /* *** remove the leading quote from above */
      writestring("SEPARATOR", outfile);
   }
   writeline("", outfile);

   decrease_indent();

   return(bytesread);

} /* process_normal_menu - end */


/***************************************************
  Process a popup menu resource
****************************************************/
DWORD process_popup_menu(DWORD menuitem, FILE *infile, FILE *outfile) {

   DWORD bytesread;

   increase_indent();
   write_indent(outfile);

   writestring("POPUP ", outfile);
   bytesread = write_item_text( infile, outfile);
   process_popup_flags(menuitem, outfile);
   writeline(" {", outfile);

   return(bytesread);

} /* process_popup_menu - end */


/***************************************************
  Process the menu resource
****************************************************/
void process_menu(int restype, FILE *infile, FILE *outfile) {

   DWORD reslen;
   DWORD bytesread;
   WORD  menuitem;
   WORD  popupmenuitem;
   struct MenuHeader menuhdr;

   write_resource_name(infile, outfile);
   write_char(' ', outfile);
   writestring(res_array[restype], outfile);
   write_mem_flags(infile, outfile);
   writeline(" {", outfile);
   reslen = get_resource_length(infile);

   fread(&menuhdr, sizeof(struct MenuHeader), 1, infile);
   reslen -= sizeof(struct MenuHeader);

   fread(&menuitem, sizeof(menuitem), 1, infile);
   reslen -= sizeof(menuitem);
   while(reslen) {

      if(menuitem & MF_POPUP) {
          popupmenuitem = menuitem;
          bytesread = process_popup_menu(  menuitem, infile, outfile);
      }
      else
          bytesread = process_normal_menu( menuitem, infile, outfile);

      reslen -= bytesread;

      if(reslen) {
         fread(&menuitem, sizeof(menuitem), 1, infile);
         reslen -= sizeof(menuitem);
      }
      else if(popupmenuitem & MF_END) /* check last popup was the end */
          writeline("}", outfile);

   }

} /* process_menu - end */


/***************************************************
  Process the icon resource
****************************************************/
void process_icon( FILE *infile ) {

   DWORD reslen;

   /* Skip it for now.  We'll come back and get the information */
   /* when we hit the group icon resource - that has the header */
   /* that has to go at the start of the .ico file.             */

   get_resource_name(infile);
   get_mem_flags(infile);
   reslen = get_resource_length(infile);

   fseek(infile, reslen, 1);

} /* process_icon - end */


/***************************************************
  Write the dialog box size and shape information
****************************************************/
void write_dialog_sizes( DIALOGHEADER dlg_hdr, FILE *outfile) {

   write_char(' ', outfile);
   write_word( dlg_hdr.x, outfile );
   writestring(", ", outfile);
   write_word( dlg_hdr.y, outfile );
   writestring(", ", outfile);
   write_word( dlg_hdr.width, outfile );
   writestring(", ", outfile);
   write_word( dlg_hdr.height, outfile );
   writeline("", outfile);

} /* write_dialog_sizes - end */


/***************************************************
  Check if the style is true; if so, write it out
****************************************************/
void check_for_style( DWORD style, char *name, FILE *outfile ) {

   static WORD first_style = 1;
   static WORD line_size = 6;          /* length of 'STYLE ' */

   if (style) {

      if (first_style) {
         writestring("STYLE ", outfile);
         first_style = 0;
      }
      else {
         writestring(" | ", outfile);
         line_size += 3;               /* add lenght of ' | ' */
      }

      /* this is an attempt to keep the line length reasonable */
      if ((line_size + strlen(name)) > 75) {
         writeline("", outfile);
         line_size = 6;
         writestring("      ", outfile);
      }

      writestring( name, outfile );
      line_size += strlen(name);

   } /* if (style) - end */

} /* check_for_style - end */


/***************************************************
  Write the dialog box style information
****************************************************/
void write_dialog_style( DIALOGHEADER dlg_hdr, FILE *outfile) {

   DWORD style;

   style = dlg_hdr.lStyle;

   check_for_style( style & WS_OVERLAPPED,   "WS_OVERLAPPED",   outfile );
   check_for_style( style & WS_POPUP,        "WS_POPUP",        outfile );
   check_for_style( style & WS_CHILD,        "WS_CHILD",        outfile );
   check_for_style( style & WS_CLIPSIBLINGS, "WS_CLIPSIBLINGS", outfile );
   check_for_style( style & WS_CLIPCHILDREN, "WS_CLIPCHILDREN", outfile );
   check_for_style( style & WS_VISIBLE,      "WS_VISIBLE",      outfile );
   check_for_style( style & WS_DISABLED,     "WS_DISABLED",     outfile );
   check_for_style( style & WS_MINIMIZE,     "WS_MINIMIZE",     outfile );
   check_for_style( style & WS_MAXIMIZE,     "WS_MAXIMIZE",     outfile );

   check_for_style( style & WS_BORDER,      "WS_BORDER",      outfile );
   check_for_style( style & WS_DLGFRAME,    "WS_DLGFRAME",    outfile );
   check_for_style( style & WS_VSCROLL,     "WS_VSCROLL",     outfile );
   check_for_style( style & WS_HSCROLL,     "WS_HSCROLL",     outfile );
   check_for_style( style & WS_SYSMENU,     "WS_SYSMENU",     outfile );
   check_for_style( style & WS_THICKFRAME,  "WS_THICKFRAME",  outfile );
   check_for_style( style & WS_MINIMIZEBOX, "WS_MINIMIZEBOX", outfile );
   check_for_style( style & WS_MAXIMIZEBOX, "WS_MAXIMIZEBOX", outfile );

   check_for_style( style & WS_GROUP,          "WS_GROUP",          outfile );
   check_for_style( style & WS_TABSTOP,        "WS_TABSTOP",        outfile );
   check_for_style( style & WS_EX_TOPMOST,     "WS_EX_TOPMOST",     outfile );
   check_for_style( style & WS_EX_ACCEPTFILES, "WS_EX_ACCEPTFILES", outfile );

   check_for_style( style & WS_EX_NOPARENTNOTIFY, "WS_EX_NOPARENTNOTIFY",
                    outfile );

   check_for_style( style & DS_ABSALIGN,   "DS_ABSALIGN",   outfile );
   check_for_style( style & DS_SYSMODAL,   "DS_SYSMODAL",   outfile );
   check_for_style( style & DS_LOCALEDIT,  "DS_LOCALEDIT",  outfile );
   check_for_style( style & DS_SETFONT,    "DS_SETFONT",    outfile );
   check_for_style( style & DS_MODALFRAME, "DS_MODALFRAME", outfile );
   check_for_style( style & DS_NOIDLEMSG,  "DS_NOIDLEMSG",  outfile );

   writeline("", outfile);

} /* write_dialog_style - end */


/***************************************************
  Write the dialog box menu name
****************************************************/
void write_dialog_menu( FILE *infile, FILE *outfile) {

   BYTE ch;
   WORD menuid;

   /* Read the first character and check for non-zero start byte */
   ch = get_byte(infile);

   /* if first byte is 0x00, no menu name */
   if(ch != 0x00) {

      writestring("MENU ", outfile);
      if(ch == 0xFF) {
         /* menu id is a number */
         menuid = get_word( infile );
         write_word(menuid, outfile);
      }
      else
         get_custom_type( ch, infile, outfile);

      writeline("", outfile);
   }

} /* write_dialog_menu - end */


/***************************************************
  Write the dialog box class name
****************************************************/
void write_dialog_class( FILE *infile, FILE *outfile) {

   BYTE ch;

   /* Read the first character and check for non-zero start byte */
   ch = get_byte(infile);

   /* get the resource type */
   if(ch != 0x00) {
      writestring("CLASS \"", outfile);
      get_custom_type( ch, infile, outfile);
      writeline("\"", outfile);
   }

} /* write_dialog_class - end */


/***************************************************
  Write the dialog box font information
****************************************************/
void write_dialog_font( FILE *infile, FILE *outfile) {

   WORD pointsize;

   writestring("FONT ", outfile);

   /* read and write the font point size */
   pointsize = get_word( infile );
   write_word( pointsize, outfile);
   writestring(", ", outfile);

   /* write the font name */
   (void) write_item_text( infile, outfile);

   writeline("", outfile);

} /* write_dialog_font - end */


/***************************************************
  Write the dialog box caption
****************************************************/
void write_dialog_caption( FILE *infile, FILE *outfile) {

   BYTE ch;

   /* Read the first character and check for non-zero start byte */
   ch = get_byte(infile);

   /* get the resource type */
   if(ch != 0x00) {
      writestring("CAPTION \"", outfile);
      get_custom_type( ch, infile, outfile);
      writeline("\"", outfile);
   }

} /* write_dialog_caption - end */


/***************************************************
  Write the start of the "CONTROL" string 
****************************************************/
void write_control_header( char *text, WORD id, FILE *outfile) {

   write_indent(outfile);

   writestring("CONTROL \"", outfile);
   writestring( text, outfile);
   writestring( "\", ", outfile);

   /* check if id is -1 */
   if (id != 0xFFFF)
      write_word( id, outfile);
   else
      writestring( "-1", outfile);

   writestring( ", ", outfile);

} /* write_control_header - end */


/***************************************************
  Write the end of the "CONTROL" statement.
****************************************************/
void write_control_end( CONTROLDATA ctrl, FILE *outfile) {

   char string[50];

   /* write the size/dimensions of the object */
   write_indent(outfile);
   sprintf( string, "%hu, %hu, %hu, %hu", ctrl.x, ctrl.y, 
            ctrl.width, ctrl.height);
   writeline( string, outfile);

} /* write_control_end - end */


/***************************************************
  Write the style for the dialog box
****************************************************/
void check_for_dlg_style( DWORD style, WORD *first_style, WORD *line_len,
                       char *style_name, FILE *outfile ) {

   if (style) {

      /* if first_style = 2, write out a leading comma */
      if (*first_style == 2) {
         writestring(", ", outfile);
         *first_style = 1;
      }

      if (*first_style == 1) {

         /* this is the first style, so just write out the style name */
         writestring( style_name, outfile);
         *first_style = 0;
         *line_len += strlen(style_name);

      }
      else {

         /* this is after first style, so write '|' for concat */
         writestring(" | ", outfile);
         *line_len += (3 + strlen(style_name));

         /* try to keep each line to a reasonable length */
         if (*line_len >= 75) {
            writeline("", outfile);
            write_indent(outfile);
            *line_len = strlen(style_name);
         }

         /* write out the name of the style */
         writestring(style_name, outfile);

      } /* if (*first_style) / else - end */

   } /* if (style) - end */

} /* check_for_dlg_style - end */


/***************************************************
  Process the button control in the dialog box
****************************************************/
void process_control_button( DWORD style, FILE *outfile ) {

   WORD first_style = 1;
   WORD line_len = 0;

   writestring( "\"button\", ", outfile);

   check_for_dlg_style( BS_LEFTTEXT & style, &first_style, &line_len,
                          "BS_LEFTTEXT", outfile );
   check_for_dlg_style( WS_TABSTOP & style, &first_style, &line_len,
                          "WS_TABSTOP", outfile );
   check_for_dlg_style( WS_GROUP & style, &first_style, &line_len,
                          "WS_GROUP", outfile );
   check_for_dlg_style( WS_DISABLED & style, &first_style, &line_len,
                          "WS_DISABLED", outfile );

   if(first_style == 0)
      writestring(" | ", outfile);

   /* checked for non-exclusive properties, now clear out high bits */
   style &= 0xF;

   if (style == BS_DEFPUSHBUTTON)
      writestring("BS_DEFPUSHBUTTON", outfile);
   else if (style == BS_CHECKBOX)
      writestring("BS_CHECKBOX", outfile);
   else if (style == BS_AUTOCHECKBOX)
      writestring("BS_AUTOCHECKBOX", outfile);
   else if (style == BS_RADIOBUTTON)
      writestring("BS_RADIOBUTTON", outfile);
   else if (style == BS_3STATE)
      writestring("BS_3STATE", outfile);
   else if (style == BS_AUTO3STATE)
      writestring("BS_AUTO3STATE", outfile);
   else if (style == BS_GROUPBOX)
      writestring("BS_GROUPBOX", outfile);
   else if (style == BS_USERBUTTON)
      writestring("BS_USERBUTTON", outfile);
   else if (style == BS_AUTORADIOBUTTON)
      writestring("BS_AUTORADIOBUTTON", outfile);
   else if (style == BS_OWNERDRAW)
      writestring("BS_OWNERDRAW", outfile);
   else
      writestring("BS_PUSHBUTTON", outfile);

   writeline(",", outfile);

} /* process_control_button - end */


/***************************************************
  Process the edit control in the dialog box
****************************************************/
void process_control_edit( CONTROLDATA ctrl, FILE *outfile ) {

   WORD first_style = 2;
   char string[100];
   WORD line_len = 0;
   DWORD style;

   style = ctrl.lStyle;

   write_indent(outfile);
   sprintf( string, "EDITTEXT %hu, %hu, %hu, %hu, %hu", ctrl.id, ctrl.x, 
            ctrl.y, ctrl.width, ctrl.height);
   line_len = strlen(string);
   writestring( string, outfile);

   check_for_dlg_style( ES_LEFT & style, &first_style, &line_len,
                          "ES_LEFT", outfile );
   check_for_dlg_style( ES_CENTER & style, &first_style, &line_len,
                          "ES_CENTER", outfile );
   check_for_dlg_style( ES_RIGHT & style, &first_style, &line_len,
                          "ES_RIGHT", outfile );
   check_for_dlg_style( ES_MULTILINE & style, &first_style, &line_len,
                          "ES_MULTILINE", outfile );
   check_for_dlg_style( ES_UPPERCASE & style, &first_style, &line_len,
                          "ES_UPPERCASE", outfile );
   check_for_dlg_style( ES_LOWERCASE & style, &first_style, &line_len,
                          "ES_LOWERCASE", outfile );
   check_for_dlg_style( ES_PASSWORD & style, &first_style, &line_len,
                          "ES_PASSWORD", outfile );
   check_for_dlg_style( ES_AUTOVSCROLL & style, &first_style, &line_len,
                          "ES_AUTOVSCROLL", outfile );
   check_for_dlg_style( ES_AUTOHSCROLL & style, &first_style, &line_len,
                          "ES_AUTOHSCROLL", outfile );
   check_for_dlg_style( ES_NOHIDESEL & style, &first_style, &line_len,
                          "ES_NOHIDESEL", outfile );
   check_for_dlg_style( ES_OEMCONVERT & style, &first_style, &line_len,
                          "ES_OEMCONVERT", outfile );
   check_for_dlg_style( ES_READONLY & style, &first_style, &line_len,
                          "ES_READONLY", outfile );
   check_for_dlg_style( ES_WANTRETURN & style, &first_style, &line_len,
                          "ES_WANTRETURN", outfile );

   check_for_dlg_style( WS_TABSTOP & style, &first_style, &line_len,
                          "WS_TABSTOP", outfile );
   check_for_dlg_style( WS_GROUP & style, &first_style, &line_len,
                          "WS_GROUP", outfile );
   check_for_dlg_style( WS_VSCROLL & style, &first_style, &line_len,
                          "WS_VSCROLL", outfile );
   check_for_dlg_style( WS_HSCROLL & style, &first_style, &line_len,
                          "WS_HSCROLL", outfile );
   check_for_dlg_style( WS_DISABLED & style, &first_style, &line_len,
                          "WS_DISABLED", outfile );

   writeline("", outfile);

} /* process_control_edit - end */


/***************************************************
  Process the static control in the dialog box
****************************************************/
void process_control_static( DWORD style, FILE *outfile ) {

   WORD first_style = 1;
   WORD line_len = 0;

   writestring( "\"static\", ", outfile);

   check_for_dlg_style( SS_NOPREFIX & style, &first_style, &line_len,
                          "SS_NOPREFIX", outfile );
   check_for_dlg_style( WS_GROUP & style, &first_style, &line_len,
                          "WS_GROUP", outfile );
   check_for_dlg_style( WS_TABSTOP & style, &first_style, &line_len,
                          "WS_TABSTOP", outfile );

   if(first_style == 0)
      writestring(" | ", outfile);

   style &= 0xF;

   if ( style == SS_CENTER )
      writestring( "SS_CENTER", outfile);
   else if ( style == SS_RIGHT )
      writestring( "SS_RIGHT", outfile);
   else if ( style == SS_ICON )
      writestring( "SS_ICON", outfile);
   else if ( style == SS_BLACKRECT )
      writestring( "SS_BLACKRECT", outfile);
   else if ( style == SS_GRAYRECT )
      writestring( "SS_GRAYRECT", outfile);
   else if ( style == SS_WHITERECT )
      writestring( "SS_WHITERECT", outfile);
   else if ( style == SS_BLACKFRAME )
      writestring( "SS_BLACKFRAME", outfile);
   else if ( style == SS_GRAYFRAME )
      writestring( "SS_GRAYFRAME", outfile);
   else if ( style == SS_WHITEFRAME )
      writestring( "SS_WHITEFRAME", outfile);
   else if ( style == SS_SIMPLE )
      writestring( "SS_SIMPLE", outfile);
   else if ( style == SS_LEFTNOWORDWRAP )
      writestring( "SS_LEFTNOWORDWRAP", outfile);
   else
      writestring( "SS_LEFT", outfile);

   writeline(",", outfile);

} /* process_control_static - end */


/***************************************************
  Process the list box control in the dialog box
****************************************************/
void process_control_listbox( CONTROLDATA ctrl, FILE *outfile ) {

   WORD first_style = 2;
   char string[100];
   WORD line_len = 0;
   DWORD style;

   style = ctrl.lStyle;

   write_indent(outfile);
   sprintf( string, "LISTBOX %hu, %hu, %hu, %hu, %hu", ctrl.id, ctrl.x, 
            ctrl.y, ctrl.width, ctrl.height);
   line_len = strlen(string);
   writestring( string, outfile);

   check_for_dlg_style( LBS_NOTIFY & style, &first_style, &line_len,
                          "LBS_NOTIFY", outfile );
   check_for_dlg_style( LBS_SORT & style, &first_style, &line_len,
                          "LBS_SORT", outfile );
   check_for_dlg_style( LBS_NOREDRAW & style, &first_style, &line_len,
                          "LBS_NOREDRAW", outfile );
   check_for_dlg_style( LBS_MULTIPLESEL & style, &first_style, &line_len,
                          "LBS_MULTIPLESEL", outfile );
   check_for_dlg_style( LBS_OWNERDRAWFIXED & style, &first_style, &line_len,
                          "LBS_OWNERDRAWFIXED", outfile );
   check_for_dlg_style( LBS_OWNERDRAWVARIABLE & style, &first_style, &line_len,
                          "LBS_OWNERDRAWVARIABLE", outfile );
   check_for_dlg_style( LBS_HASSTRINGS & style, &first_style, &line_len,
                          "LBS_HASSTRINGS", outfile );
   check_for_dlg_style( LBS_USETABSTOPS & style, &first_style, &line_len,
                          "LBS_USETABSTOPS", outfile );
   check_for_dlg_style( LBS_NOINTEGRALHEIGHT & style, &first_style, &line_len,
                          "LBS_NOINTEGRALHEIGHT", outfile );
   check_for_dlg_style( LBS_MULTICOLUMN & style, &first_style, &line_len,
                          "LBS_MULTICOLUMN", outfile );
   check_for_dlg_style( LBS_WANTKEYBOARDINPUT & style, &first_style, &line_len,
                          "LBS_WANTKEYBOARDINPUT", outfile );
   check_for_dlg_style( LBS_EXTENDEDSEL & style, &first_style, &line_len,
                          "LBS_EXTENDEDSEL", outfile );
   check_for_dlg_style( LBS_DISABLENOSCROLL & style, &first_style, &line_len,
                          "LBS_DISABLENOSCROLL", outfile );

   check_for_dlg_style( WS_BORDER & style, &first_style, &line_len,
                          "WS_BORDER", outfile );
   check_for_dlg_style( WS_VSCROLL & style, &first_style, &line_len,
                          "WS_VSCROLL", outfile );

   writeline("", outfile);

} /* process_control_listbox - end */


/***************************************************
  Process the scroll bar control in the dialog box
****************************************************/
void process_control_scrollbar( CONTROLDATA ctrl, FILE *outfile ) {

   WORD first_style = 2;
   char string[100];
   WORD line_len = 0;
   DWORD style;

   style = ctrl.lStyle;

   write_indent(outfile);
   sprintf( string, "SCROLLBAR %hu, %hu, %hu, %hu, %hu", ctrl.id, ctrl.x, 
            ctrl.y, ctrl.width, ctrl.height);
   line_len = strlen(string);
   writestring( string, outfile);

   check_for_dlg_style( SBS_HORZ & style, &first_style, &line_len,
                          "SBS_HORZ", outfile );
   check_for_dlg_style( SBS_VERT & style, &first_style, &line_len,
                          "SBS_VERT", outfile );
   check_for_dlg_style( SBS_TOPALIGN & style, &first_style, &line_len,
                          "SBS_TOPALIGN", outfile );
   check_for_dlg_style( SBS_BOTTOMALIGN & style, &first_style, &line_len,
                          "SBS_BOTTOMALIGN", outfile );
   check_for_dlg_style( SBS_SIZEBOX & style, &first_style, &line_len,
                          "SBS_SIZEBOX", outfile );

   check_for_dlg_style( WS_TABSTOP & style, &first_style, &line_len,
                          "WS_TABSTOP", outfile );
   check_for_dlg_style( WS_GROUP & style, &first_style, &line_len,
                          "WS_GROUP", outfile );
   check_for_dlg_style( WS_DISABLED & style, &first_style, &line_len,
                          "WS_DISABLED", outfile );

   writeline("", outfile);

} /* process_control_scrollbar - end */


/***************************************************
  Process the combo box control in the dialog box
****************************************************/
void process_control_combobox( CONTROLDATA ctrl, FILE *outfile) {

   WORD first_style = 2;
   WORD line_len = 0;
   char string[100];
   DWORD style;

   style = ctrl.lStyle;

   write_indent(outfile);
   sprintf( string, "COMBOBOX %hu, %hu, %hu, %hu, %hu", ctrl.id, ctrl.x, 
            ctrl.y, ctrl.width, ctrl.height);
   line_len = strlen(string);
   writestring( string, outfile);

   check_for_dlg_style( CBS_SIMPLE & style, &first_style, &line_len,
                          "CBS_SIMPLE", outfile );
   check_for_dlg_style( CBS_DROPDOWN & style, &first_style, &line_len,
                          "CBS_DROPDOWN", outfile );
   check_for_dlg_style( CBS_OWNERDRAWFIXED & style, &first_style, &line_len,
                          "CBS_OWNERDRAWFIXED", outfile );
   check_for_dlg_style( CBS_OWNERDRAWVARIABLE & style, &first_style, &line_len,
                          "CBS_OWNERDRAWVARIABLE", outfile );
   check_for_dlg_style( CBS_AUTOHSCROLL & style, &first_style, &line_len,
                          "CBS_AUTOHSCROLL", outfile );
   check_for_dlg_style( CBS_OEMCONVERT & style, &first_style, &line_len,
                          "CBS_OEMCONVERT", outfile );
   check_for_dlg_style( CBS_SORT & style, &first_style, &line_len,
                          "CBS_SORT", outfile );
   check_for_dlg_style( CBS_HASSTRINGS & style, &first_style, &line_len,
                          "CBS_HASSTRINGS", outfile );
   check_for_dlg_style( CBS_NOINTEGRALHEIGHT & style, &first_style, &line_len,
                          "CBS_NOINTEGRALHEIGHT", outfile );
   check_for_dlg_style( CBS_DISABLENOSCROLL & style, &first_style, &line_len,
                          "CBS_DISABLENOSCROLL", outfile );

   check_for_dlg_style( WS_TABSTOP & style, &first_style, &line_len,
                          "WS_TABSTOP", outfile );
   check_for_dlg_style( WS_GROUP & style, &first_style, &line_len,
                          "WS_GROUP", outfile );
   check_for_dlg_style( WS_VSCROLL & style, &first_style, &line_len,
                          "WS_VSCROLL", outfile );
   check_for_dlg_style( WS_DISABLED & style, &first_style, &line_len,
                          "WS_DISABLED", outfile );

   writeline("", outfile);

} /* process_control_combobox - end */


/***************************************************
  Process each control in the dialog box
****************************************************/
void process_control( FILE *infile, FILE *outfile ) {

   CONTROLDATA ctrl;
   BYTE class_id;
   BYTE ch;
   char ctrl_text[260];
   char ctrl_class[260];
   WORD index = 0;

   fread( &ctrl, sizeof(CONTROLDATA), 1, infile);

   /* read the class type (if 0x8?) or the string (otherwise) */
   ch = get_byte(infile);
   if (ch & 0x80) {
      class_id = ch;
   }
   else {
      class_id = 0x00;
      while (ch != 0x00) {
         if (index < 260) {
            ctrl_class[index] = ch;
            ++index;
         }
         ch = get_byte(infile);
      }
   }
   ctrl_class[index] = '\0';

   /* read the text field */
   ch = get_byte(infile);
   index = 0;
   while (ch != 0x00) {
      if (index < 260) {
         ctrl_text[index] = ch;
         ++index;
      }
      ch = get_byte(infile);
   }
   ctrl_text[index] = '\0';

   /* read the extra 0x00 */
   ch = get_byte(infile);
   if (ch != 0x00) {
      writestring("Error ** ch =>", outfile);
      write_char( ch, outfile);
      writeline("< - should be 00", outfile);
   }

   increase_indent();

   if (class_id & 0x80) {

      switch (class_id) {

         /* Control is a button */
         case 0x80: 
            write_control_header( ctrl_text, ctrl.id, outfile);
            process_control_button( ctrl.lStyle, outfile );
            write_control_end( ctrl, outfile);
            break;

         /* Control is an edit widget */
         case 0x81: 
            process_control_edit( ctrl, outfile );
            break;

         /* Control is a static widget */
         case 0x82: 
            write_control_header( ctrl_text, ctrl.id, outfile);
            process_control_static( ctrl.lStyle, outfile );
            write_control_end( ctrl, outfile);
            break;

         /* Control is a listbox */
         case 0x83: 
            process_control_listbox( ctrl, outfile );
            break;

         /* Control is a scrollbar */
         case 0x84: 
            process_control_scrollbar( ctrl, outfile );
            break;

         /* Control is a combobox */
         case 0x85: 
            process_control_combobox( ctrl, outfile );
            break;

         default: 
            break;  /* Unknown type, so skip */
      }

   }
   else {
      ; /* The resource type is unknown, so skip */
   }

   decrease_indent();

} /* process_control - end */


/***************************************************
  Process the dialog resource
****************************************************/
void process_dialog(int restype, FILE *infile, FILE *outfile) {

   DIALOGHEADER dlg_hdr;

   /* write the generic dialog box info */
   write_resource_name(infile, outfile);
   write_char(' ', outfile);
   writestring(res_array[restype], outfile);
   write_mem_flags(infile, outfile);

   /* get the dialog box resource length, and the dialog box header */
   (void) get_resource_length(infile);
   fread( &dlg_hdr, sizeof(DIALOGHEADER), 1, infile);

   write_dialog_sizes( dlg_hdr, outfile);
   write_dialog_style( dlg_hdr, outfile);
   write_dialog_menu(  infile,  outfile);
   write_dialog_class( infile,  outfile);
   write_dialog_caption( infile, outfile);

   if (dlg_hdr.lStyle & DS_SETFONT)
      write_dialog_font( infile, outfile);

   writeline("BEGIN", outfile);

   while(dlg_hdr.bNumberOfItems) {

      process_control( infile, outfile );

      dlg_hdr.bNumberOfItems -= 1;
   }


   writeline("END", outfile);

} /* process_dialog - end */


/***************************************************
  Process the string resource
****************************************************/
void process_string(int restype, FILE *infile, FILE *outfile) {

   WORD  sID;
   int   index;
   BYTE  ch;
   BYTE  strlen;

   sID = get_resource_number(infile);
   if (StringCount == 0) {
      writeline( "", outfile);
      writestring(res_array[restype], outfile);
      write_mem_flags(infile, outfile);
      writeline(" {", outfile);
   }
   else {
      get_mem_flags(infile);
   }

   ++StringCount;

   increase_indent();

   (void) get_resource_length(infile);

   for(index = 0; index < 16; ++index) {
      if((strlen = get_byte(infile)) != 0x00) {
         write_indent(outfile);
         sID = index + ((sID - 1) * 16);
         write_word( sID, outfile);
         writestring(", \"", outfile);
         while(strlen--) {
            ch = get_byte(infile);
            write_char(ch, outfile);
         }
         writeline("\"", outfile);
      }
   }

   decrease_indent();

   if(StringCount >= 16) {
      writeline("}", outfile);
      StringCount = 0;
   }

} /* process_string - end */


/***************************************************
  Process the fontdir resource
****************************************************/
void process_fontdir( FILE *infile ) {

   DWORD reslen;

   get_resource_name(infile);
   get_mem_flags(infile);
   reslen = get_resource_length(infile);

   fseek(infile, reslen, 1);

} /* process_fontdir - end */


/***************************************************
  Process the font resource
****************************************************/
void process_font(int restype, FILE *infile, FILE *outfile) {

   DWORD reslen;
   char  datafilename[13];
   FILE  *datafile;

   write_resource_name(infile, outfile);
   write_char(' ', outfile);
   writestring(res_array[restype], outfile);
   write_mem_flags(infile, outfile);
   write_char(' ', outfile);

   reslen = get_resource_length(infile);

   strcpy(datafilename, get_data_filename("FO", "FON"));
   if(strlen(datafilename) == 0) {
      writeline("<Unable to open output file>", outfile);
      fseek( infile, reslen, 1);
      return;
   }

   writeline( datafilename, outfile );

   if((datafile = fopen(datafilename, "wb")) == NULL) {
      printf("Unable to open file %s\n", datafilename);
      fseek( infile, reslen, 1);
      return;
   }

   write_data( infile, datafile, reslen );
   fclose( datafile );

} /* process_font - end */


/***************************************************
  Write the virtual character for the current accelerator
****************************************************/
void write_virtual_accel_event( WORD wEvent, FILE *outfile) {

   switch(wEvent) {

      case VK_LBUTTON:
         writestring( "VK_LBUTTON", outfile);
         break;

      case VK_RBUTTON:
         writestring( "VK_RBUTTON", outfile);
         break;

      case VK_CANCEL:
         writestring( "VK_CANCEL", outfile);
         break;

      case VK_MBUTTON:
         writestring( "VK_MBUTTON", outfile);
         break;

      case VK_BACK:
         writestring( "VK_BACK", outfile);
         break;

      case VK_TAB:
         writestring( "VK_TAB", outfile);
         break;

      case VK_CLEAR:
         writestring( "VK_CLEAR", outfile);
         break;

      case VK_RETURN:
         writestring( "VK_RETURN", outfile);
         break;

      case VK_SHIFT:
         writestring( "VK_SHIFT", outfile);
         break;

      case VK_CONTROL:
         writestring( "VK_CONTROL", outfile);
         break;

      case VK_MENU:
         writestring( "VK_MENU", outfile);
         break;

      case VK_PAUSE:
         writestring( "VK_PAUSE", outfile);
         break;

      case VK_CAPITAL:
         writestring( "VK_CAPITAL", outfile);
         break;

      case VK_ESCAPE:
         writestring( "VK_ESCAPE", outfile);
         break;

      case VK_SPACE:
         writestring( "VK_SPACE", outfile);
         break;

      case VK_PRIOR:
         writestring( "VK_PRIOR", outfile);
         break;

      case VK_NEXT:
         writestring( "VK_NEXT", outfile);
         break;

      case VK_END:
         writestring( "VK_END", outfile);
         break;

      case VK_HOME:
         writestring( "VK_HOME", outfile);
         break;

      case VK_LEFT:
         writestring( "VK_LEFT", outfile);
         break;

      case VK_UP:
         writestring( "VK_UP", outfile);
         break;

      case VK_RIGHT:
         writestring( "VK_RIGHT", outfile);
         break;

      case VK_DOWN:
         writestring( "VK_DOWN", outfile);
         break;

      case VK_SELECT:
         writestring( "VK_SELECT", outfile);
         break;

      case VK_PRINT:
         writestring( "VK_PRINT", outfile);
         break;

      case VK_EXECUTE:
         writestring( "VK_EXECUTE", outfile);
         break;

      case VK_SNAPSHOT:
         writestring( "VK_SNAPSHOT", outfile);
         break;

      case VK_INSERT:
         writestring( "VK_INSERT", outfile);
         break;

      case VK_DELETE:
         writestring( "VK_DELETE", outfile);
         break;

      case VK_HELP:
         writestring( "VK_HELP", outfile);
         break;

      case VK_NUMPAD0:
         writestring( "VK_NUMPAD0", outfile);
         break;

      case VK_NUMPAD1:
         writestring( "VK_NUMPAD1", outfile);
         break;

      case VK_NUMPAD2:
         writestring( "VK_NUMPAD2", outfile);
         break;

      case VK_NUMPAD3:
         writestring( "VK_NUMPAD3", outfile);
         break;

      case VK_NUMPAD4:
         writestring( "VK_NUMPAD4", outfile);
         break;

      case VK_NUMPAD5:
         writestring( "VK_NUMPAD5", outfile);
         break;

      case VK_NUMPAD6:
         writestring( "VK_NUMPAD6", outfile);
         break;

      case VK_NUMPAD7:
         writestring( "VK_NUMPAD7", outfile);
         break;

      case VK_NUMPAD8:
         writestring( "VK_NUMPAD8", outfile);
         break;

      case VK_NUMPAD9:
         writestring( "VK_NUMPAD9", outfile);
         break;

      case VK_MULTIPLY:
         writestring( "VK_MULTIPLY", outfile);
         break;

      case VK_ADD:
         writestring( "VK_ADD", outfile);
         break;

      case VK_SEPARATOR:
         writestring( "VK_SEPARATOR", outfile);
         break;

      case VK_SUBTRACT:
         writestring( "VK_SUBTRACT", outfile);
         break;

      case VK_DECIMAL:
         writestring( "VK_DECIMAL", outfile);
         break;

      case VK_DIVIDE:
         writestring( "VK_DIVIDE", outfile);
         break;

      case VK_F1:
         writestring( "VK_F1", outfile);
         break;

      case VK_F2:
         writestring( "VK_F2", outfile);
         break;

      case VK_F3:
         writestring( "VK_F3", outfile);
         break;

      case VK_F4:
         writestring( "VK_F4", outfile);
         break;

      case VK_F5:
         writestring( "VK_F5", outfile);
         break;

      case VK_F6:
         writestring( "VK_F6", outfile);
         break;

      case VK_F7:
         writestring( "VK_F7", outfile);
         break;

      case VK_F8:
         writestring( "VK_F8", outfile);
         break;

      case VK_F9:
         writestring( "VK_F9", outfile);
         break;

      case VK_F10:
         writestring( "VK_F10", outfile);
         break;

      case VK_F11:
         writestring( "VK_F11", outfile);
         break;

      case VK_F12:
         writestring( "VK_F12", outfile);
         break;

      case VK_F13:
         writestring( "VK_F13", outfile);
         break;

      case VK_F14:
         writestring( "VK_F14", outfile);
         break;

      case VK_F15:
         writestring( "VK_F15", outfile);
         break;

      case VK_F16:
         writestring( "VK_F16", outfile);
         break;

      case VK_F17:
         writestring( "VK_F17", outfile);
         break;

      case VK_F18:
         writestring( "VK_F18", outfile);
         break;

      case VK_F19:
         writestring( "VK_F19", outfile);
         break;

      case VK_F20:
         writestring( "VK_F20", outfile);
         break;

      case VK_F21:
         writestring( "VK_F21", outfile);
         break;

      case VK_F22:
         writestring( "VK_F22", outfile);
         break;

      case VK_F23:
         writestring( "VK_F23", outfile);
         break;

      case VK_F24:
         writestring( "VK_F24", outfile);
         break;

      case VK_NUMLOCK:
         writestring( "VK_NUMLOCK", outfile);
         break;

      case VK_SCROLL:
         writestring( "VK_SCROLL", outfile);
         break;

      default:
         write_word( wEvent, outfile);
         break;

    } /* switch(wEvent) - end */

} /* write_virtual_accel_event - end */


/***************************************************
  Write the character for the current accelerator
****************************************************/
int write_accel_event( WORD wEvent, FILE *outfile) {

   if(((wEvent >= 65) && (wEvent <= 90)) ||
      ((wEvent >= 97) && (wEvent <= 122))) {
      write_char('"', outfile);
      write_char((BYTE) wEvent, outfile);
      write_char('"', outfile);
      return(0);
   }

   if((wEvent >= 1) && (wEvent <= 26)) {
      write_char('"', outfile);
      write_char('^', outfile);
      write_char((BYTE) (wEvent + 64), outfile);
      write_char('"', outfile);
      return(0);
   }

   write_word( wEvent, outfile);
   return(1);

} /* write_accel_event - end */


/***************************************************
  Write the flags for the current accelerator
****************************************************/
void write_accel_flags( BYTE flags, FILE *outfile, int ascii_value_used) {

   if(flags & 0x02)
      writestring(", NOINVERT", outfile);
   if(flags & 0x04)
      writestring(", SHIFT", outfile);
   if(flags & 0x08)
      writestring(", CONTROL", outfile);
   if(flags & 0x10)
      writestring(", ALT", outfile);
   if(flags & 0x01)
      writestring(", VIRTKEY", outfile);
   else if (ascii_value_used)
      writestring(", ASCII", outfile);
   writeline("", outfile);

} /* write_accel_flags - end */


/***************************************************
  Process the accelerator resource
****************************************************/
void process_accelerator(int restype, FILE *infile, FILE *outfile) {

   DWORD  reslen;
   struct AccelTableEntry accelhdr;
   int    ascii_value_used;

   write_resource_name(infile, outfile);
   write_char(' ', outfile);
   writestring(res_array[restype], outfile);
   get_mem_flags(infile);
   writeline(" {", outfile);

   increase_indent();

   reslen = get_resource_length(infile);

   while(reslen) {

      write_indent(outfile);

      fread(&accelhdr, sizeof(struct AccelTableEntry), 1, infile);
      reslen -= sizeof(struct AccelTableEntry);

      if(accelhdr.fFlags & 0x01)
         write_virtual_accel_event( accelhdr.wEvent, outfile);
      else
         ascii_value_used = write_accel_event( accelhdr.wEvent, outfile);

      writestring(", ", outfile);
      write_word(accelhdr.wId, outfile);
      write_accel_flags( accelhdr.fFlags, outfile, ascii_value_used);

   }

   decrease_indent();

   writeline("}", outfile);

} /* process_accelerator - end */


/***************************************************
  Process the rcdata resource
****************************************************/
void process_rcdata(int restype, FILE *infile, FILE *outfile) {

   DWORD reslen;
   int ch;
   unsigned short ch_count;

   write_resource_name(infile, outfile);
   write_char(' ', outfile);
   writestring(res_array[restype], outfile);
   write_mem_flags(infile, outfile);
   writeline(" {", outfile);

   reslen = get_resource_length(infile);
   increase_indent();

   /* copy the data out to the .rc file */
   ch_count = 0;
   while (reslen--) {
      if (ch_count == 0) {
         write_indent(outfile);
         write_char('"', outfile);
      }
      ch = fgetc( infile );
      if ((ch >= 32) && (ch <= 126)) {
         fputc( ch, outfile);
         ++ch_count;
      }
      else {
         write_char('\\', outfile);
         fprintf( outfile, "%o", ch);
         ch_count += 4;
      }
      if (ch_count >= 60) {
         writeline("\"", outfile);
         ch_count = 0;
      }
   }

   /* if last string wasn't terminated with end quotes, do so now */
   if (ch_count > 0)
      writeline("\"", outfile);

   decrease_indent();

   writeline("}", outfile);

} /* process_rcdata - end */


/***************************************************
  Search infile for image #image_num of type image_type
****************************************************/
int search_for_image( WORD image_num, FILE *infile, int image_type ) {

   BYTE ch;
   long reslen;
   int  restype;
   WORD dest_image_num;

   fseek(infile, 0, 0);

   ch = get_byte(infile);
   while(!feof(infile)) {

      /* get the resource type */
      if(ch == 0xFF) {

         fread(&restype, sizeof(int), 1, infile);

         /* If it's not the right image type, skip it */
         if (restype != image_type) {
            
            get_resource_name(infile);
            get_mem_flags(infile);
            reslen = get_resource_length(infile);

            fseek(infile, reslen, 1);
         }
         else {
            dest_image_num = get_resource_number(infile);
            get_mem_flags(infile);
            reslen = get_resource_length(infile);

            if (dest_image_num == image_num)
               return(1);
            else
               fseek(infile, reslen, 1);
         }

      }
      else {

         /* read the name of the resource */
         while((ch = get_byte(infile)) != 0x00) {}

         get_resource_name(infile);
         get_mem_flags(infile);
         reslen = get_resource_length(infile);

         fseek(infile, reslen, 1);
      }

      ch = get_byte(infile);

   } /* while(not eof(infile)) - end */

   return(0);

} /* search_for_image - end */


/***************************************************
  Write the Cursor Directory entry to the cursor file
****************************************************/
void write_cursor_direntry( CURSORDIRENTRY cursorentry, FILE *datafile, 
                            FILE *infile, DWORD cursor_size) {

   CURSORRESENTRY cursorres;
   long filepos;
   WORD hotspot;

   cursorres.bWidth      = (BYTE) cursorentry.wWidth;
   cursorres.bHeight     = (BYTE) (cursorentry.wHeight - cursorentry.wWidth);
   cursorres.bColorCount = 0;
   cursorres.bReserved   = 0;

   /* Initialize to 0's */
   cursorres.wXHotSpot = 0;
   cursorres.wYHotSpot = 0;

   /* Save the current position of the input file */
   filepos = ftell(infile);

   /* Search for cursor resource number #wImageOffset to get the hotspots */
   if (search_for_image( cursorentry.wImageOffset, infile, CURSOR_TYPE)) {
      hotspot = get_word( infile );
      cursorres.wXHotSpot = hotspot;

      hotspot = get_word( infile );
      cursorres.wYHotSpot = hotspot;
   }

   /* return to the prior position in the input file */
   fseek(infile, filepos, 0);

   /* subtract size of 2 WORD values - X & Y Hot Spot - they occur */
   /* at the beginning of the cursor resource data, but really     */
   /* belong in the header, so they get subtracted from the length */
   cursorres.dwBytesInRes  = cursorentry.dwBytesInRes - (2 * sizeof(WORD));

   cursorres.dwImageOffset = cursor_size;

   fwrite( &cursorres, sizeof(CURSORRESENTRY), 1, datafile);

} /* write_cursor_direntry - end */


/***************************************************
  Process the group cursor resource
****************************************************/
void process_group_cursor(FILE *infile, FILE *outfile) {

   DWORD reslen;
   char  datafilename[13];
   FILE  *datafile;
   long  CurrPos;
   DWORD cursor_size;

   CURSORHEADER   cursorinfo;
   CURSORDIRENTRY cursorentry;
   WORD count;

   write_resource_name(infile, outfile);
   writestring(" CURSOR", outfile);

   /* Now write out the memory flags for the previous resource */
   /* (cursor), since that has the correct value; this must be */
   /* done before the succeeding call to get_mem_flags, since  */
   /* that will change the value of prev_mem_flag.             */
   write_special_mem_flag_values( prev_mem_flag, outfile);

   /* Now skip over the memory flag for this resource */
   get_mem_flags(infile);

   write_char(' ', outfile);

   reslen = get_resource_length(infile);

   /* Determine a unique .cur filename in the current directory */
   strcpy(datafilename, get_data_filename("CU", "CUR"));
   if(strlen(datafilename) == 0) {
      writeline("<Unable to open output file>", outfile);
      fseek( infile, reslen, 1);
      return;
   }

   /* Write the name of the new cursor file to the .rc file */
   writeline( datafilename, outfile );

   /* open .cur output file */
   if((datafile = fopen(datafilename, "wb")) == NULL) {
      printf("Unable to open file %s\n", datafilename);
      fseek( infile, reslen, 1);
      return;
   }

   fread( &cursorinfo, sizeof(CURSORHEADER), 1, infile);
   fwrite( &cursorinfo, sizeof(CURSORHEADER), 1, datafile);

   cursor_size = sizeof(CURSORHEADER) + (sizeof(CURSORRESENTRY) * cursorinfo.cdCount);
   CurrPos = ftell(infile);

   /* Loop through each Cursor entry in the Group Cursor resource */
   count = cursorinfo.cdCount;
   while (count--) {

      /* Read the header for this cursor, and save to the output file */
      fread( &cursorentry, sizeof(CURSORDIRENTRY), 1, infile);

      write_cursor_direntry( cursorentry, datafile, infile, cursor_size);
      cursor_size += cursorentry.dwBytesInRes;

   }

   fseek(infile, CurrPos, 0);

   /* Loop through each Cursor entry in the Group Cursor resource */
   count = cursorinfo.cdCount;
   while (count--) {

      fread( &cursorentry, sizeof(CURSORDIRENTRY), 1, infile);

      CurrPos += sizeof(CURSORDIRENTRY);

      /* Search for cursor resource number #wImageOffset */
      if (search_for_image( cursorentry.wImageOffset, infile, CURSOR_TYPE)) {

         /* skip the 2 WORDS for XHotSpot and YHotSpot */
         fseek(infile, 4, 1);

         /* subtract the size of the 2 WORDs at the start: hotspot data */
         write_data( infile, datafile, 
                     (cursorentry.dwBytesInRes - (2 * sizeof(WORD))));
      }

      fseek(infile, CurrPos, 0);

   }

   fclose( datafile );

} /* process_group_cursor - end */


/***************************************************
  Write the Icon Directory entry to the icon file
****************************************************/
void write_icon_direntry( ICONDIRENTRY iconentry, FILE *datafile, 
                          DWORD icon_size) {

   ICONRESENTRY iconres;

   iconres.bWidth        = iconentry.bWidth;
   iconres.bHeight       = iconentry.bHeight;
   iconres.bColorCount   = iconentry.bColorCount;
   iconres.bReserved     = iconentry.bReserved;

/* The Planes and BitCount values stored in the .ico file 
   seem to be ignored.

   iconres.wPlanes       = iconentry.wPlanes;
   iconres.wBitCount     = iconentry.wBitCount;

*/

   iconres.wPlanes       = 0;
   iconres.wBitCount     = 0;

   iconres.dwBytesInRes  = iconentry.dwBytesInRes;
   iconres.dwImageOffset = icon_size;

   fwrite( &iconres, sizeof(ICONRESENTRY), 1, datafile);

} /* write_icon_direntry - end */


/***************************************************
  Process the group icon resource
****************************************************/
void process_group_icon(FILE *infile, FILE *outfile) {

   DWORD reslen;
   char  datafilename[13];
   FILE  *datafile;
   long  CurrPos;
   DWORD icon_size;

   ICONHEADER   iconinfo;
   ICONDIRENTRY iconentry;
   WORD count;

   write_resource_name(infile, outfile);
   writestring(" ICON", outfile);

   /* Now write out the memory flags for the previous resource */
   /* (icon), since that has the correct value; this must be   */
   /* done before the succeeding call to get_mem_flags, since  */
   /* that will change the value of prev_mem_flag.             */
   write_special_mem_flag_values( prev_mem_flag, outfile);

   /* Now skip over the memory flag for this resource */
   get_mem_flags(infile);

   write_char(' ', outfile);

   reslen = get_resource_length(infile);

   /* Determine a unique .ico filename in the current directory */
   strcpy(datafilename, get_data_filename("IC", "ICO"));
   if(strlen(datafilename) == 0) {
      writeline("<Unable to open output file>", outfile);
      fseek( infile, reslen, 1);
      return;
   }

   /* Write the name of the new icon file to the .rc file */
   writeline( datafilename, outfile );

   /* Open the output file containing the icon resource data */
   if((datafile = fopen(datafilename, "wb")) == NULL) {
      printf("Unable to open file %s\n", datafilename);
      fseek( infile, reslen, 1);
      return;
   }

   fread( &iconinfo, sizeof(ICONHEADER), 1, infile);
   fwrite( &iconinfo, sizeof(ICONHEADER), 1, datafile);

   icon_size = sizeof(ICONHEADER) + (sizeof(ICONRESENTRY) * iconinfo.idCount);
   CurrPos = ftell(infile);

   /* Loop through each Icon entry in the Group Icon resource */
   count = iconinfo.idCount;
   while (count--) {

      fread( &iconentry, sizeof(ICONDIRENTRY), 1, infile);

      write_icon_direntry( iconentry, datafile, icon_size);
      icon_size += iconentry.dwBytesInRes;

   }

   fseek(infile, CurrPos, 0);

   /* Loop through each Icon entry in the Group Icon resource */
   count = iconinfo.idCount;
   while (count--) {

      fread( &iconentry, sizeof(ICONDIRENTRY), 1, infile);

      CurrPos += sizeof(ICONDIRENTRY);

      /* Search for icon resource number #wImageOffset */
      if (search_for_image( iconentry.wImageOffset, infile, ICON_TYPE)) {
         write_data( infile, datafile, iconentry.dwBytesInRes );
      }

      fseek(infile, CurrPos, 0);

   }

   fclose( datafile );

} /* process_group_icon - end */


/***************************************************
  Save a user-defined resource data to a file.
****************************************************/
void save_user_resource( FILE *infile, FILE *outfile) {

   DWORD reslen;
   char  datafilename[13];
   FILE  *datafile;

   reslen = get_resource_length(infile);

   strcpy(datafilename, get_data_filename("UR", "USR"));
   if(strlen(datafilename) == 0) {
      writeline("<Unable to open output file>", outfile);
      fseek( infile, reslen, 1);
      return;
   }

   writeline( datafilename, outfile );

   if((datafile = fopen(datafilename, "wb")) == NULL) {
      printf("Unable to open file %s\n", datafilename);
      fseek( infile, reslen, 1);
      return;
   }

   write_data(infile, datafile, reslen);
   fclose( datafile );

} /* save_user_resource - end */


/***************************************************
  Process a user-defined resource (by number).
****************************************************/
void process_user_resource_num(int restype, FILE *infile, FILE *outfile) {

   write_resource_name(infile, outfile);
   write_char(' ', outfile);
   write_number( restype, outfile);
   write_mem_flags(infile, outfile);
   write_char(' ', outfile);

   save_user_resource( infile, outfile );

} /* process_user_resource_num - end */


/***************************************************
  Read the name table, but ignore it.
****************************************************/
void process_name_table( FILE *infile, FILE *outfile) {

   DWORD reslen;

   writeline( "", outfile);
   writeline( "//", outfile);
   writeline( "// Name table found, but ignored.", outfile );
   writeline( "//", outfile);

   get_resource_name(infile);
   get_mem_flags(infile);

   reslen = get_resource_length(infile);
   fseek(infile, reslen, 1);

} /* process_name_table - end */


/***************************************************
  Checks if ver.h has been included; if not, does so
****************************************************/
void check_if_ver_header_included( FILE *outfile ) {

   if (VersionUsed == 0) {

      /* update VersionUsed so <ver.h> can't be included twice */
      VersionUsed = 1;

      writeline( "", outfile);
      writeline( "#include <ver.h>", outfile);

   }

} /* check_if_ver_header_included - end */


/***************************************************
  Process version fileflags
****************************************************/
void write_version_fileflags( DWORD style, FILE *outfile ) {

   WORD first_style = 1;
   WORD line_len = 0;

   writestring( " FILEFLAGS ", outfile);

   if (style == 0L)
      writeline( "0x0L", outfile);
   else {
      check_for_dlg_style( VS_FF_DEBUG & style, &first_style,
                           &line_len, "VS_FF_DEBUG", outfile);
      check_for_dlg_style( VS_FF_INFOINFERRED & style, &first_style, 
                           &line_len, "VS_FF_INFOINFERRED", outfile);
      check_for_dlg_style( VS_FF_PATCHED & style, &first_style, 
                           &line_len, "VS_FF_PATCHED", outfile);
      check_for_dlg_style( VS_FF_PRERELEASE & style, &first_style, 
                           &line_len, "VS_FF_PRERELEASE", outfile);
      check_for_dlg_style( VS_FF_PRIVATEBUILD & style, &first_style, 
                           &line_len, "VS_FF_PRIVATEBUILD", outfile);
      check_for_dlg_style( VS_FF_SPECIALBUILD & style, &first_style, 
                           &line_len, "VS_FF_SPECIALBUILD", outfile);

      writeline( "", outfile);
   }

} /* write_version_fileflags - end */


/***************************************************
  Process the version driver subtype
****************************************************/
void process_version_driver_subtype( DWORD driver_subtype, FILE *outfile ) {

   switch (driver_subtype) {

      case VFT2_UNKNOWN:
         writeline("VFT2_UNKNOWN", outfile);
         break;

      case VFT2_DRV_COMM:
         writeline("VFT2_DRV_COMM", outfile);
         break;

      case VFT2_DRV_PRINTER:
         writeline("VFT2_DRV_PRINTER", outfile);
         break;

      case VFT2_DRV_KEYBOARD:
         writeline("VFT2_DRV_KEYBOARD", outfile);
         break;

      case VFT2_DRV_LANGUAGE:
         writeline("VFT2_DRV_LANGUAGE", outfile);
         break;

      case VFT2_DRV_DISPLAY:
         writeline("VFT2_DRV_DISPLAY", outfile);
         break;

      case VFT2_DRV_MOUSE:
         writeline("VFT2_DRV_MOUSE", outfile);
         break;

      case VFT2_DRV_NETWORK:
         writeline("VFT2_DRV_NETWORK", outfile);
         break;

      case VFT2_DRV_SYSTEM:
         writeline("VFT2_DRV_SYSTEM", outfile);
         break;

      case VFT2_DRV_INSTALLABLE:
         writeline("VFT2_DRV_INSTALLABLE", outfile);
         break;

      case VFT2_DRV_SOUND:
         writeline("VFT2_DRV_SOUND", outfile);
         break;

      default:
         fprintf( outfile, "%lu", driver_subtype );
         writeline("", outfile);
         break;

   } /* switch (driver_subtype) - end */

} /* process_version_driver_subtype - end */


/***************************************************
  Process the version font subtype
****************************************************/
void process_version_font_subtype( DWORD font_subtype, FILE *outfile ) {

   switch (font_subtype) {

      case VFT2_UNKNOWN:
         writeline("VFT2_UNKNOWN", outfile);
         break;

      case VFT2_FONT_RASTER:
         writeline("VFT2_FONT_RASTER", outfile);
         break;

      case VFT2_FONT_VECTOR:
         writeline("VFT2_FONT_VECTOR", outfile);
         break;

      case VFT2_FONT_TRUETYPE:
         writeline("VFT2_FONT_TRUETYPE", outfile);
         break;

      default:
         fprintf( outfile, "%lu", font_subtype );
         writeline("", outfile);
         break;

   } /* switch (font_subtype) - end */

} /* process_version_font_subtype - end */


/***************************************************
  Process version information root block
****************************************************/
void process_version_root_block( FILE *infile, FILE *outfile) {

   VS_FIXEDFILEINFO infostruct;

   /* Process each field of the root block */
   fread( &infostruct, sizeof(VS_FIXEDFILEINFO), 1, infile);

   fprintf( outfile, " FILEVERSION %u,%u,%u,%u",
               HIWORD(infostruct.dwFileVersionMS),
               LOWORD(infostruct.dwFileVersionMS),
               HIWORD(infostruct.dwFileVersionLS),
               LOWORD(infostruct.dwFileVersionLS));
   writeline( "", outfile);

   fprintf( outfile, " PRODUCTVERSION %u,%u,%u,%u",
               HIWORD(infostruct.dwProductVersionMS),
               LOWORD(infostruct.dwProductVersionMS),
               HIWORD(infostruct.dwProductVersionLS),
               LOWORD(infostruct.dwProductVersionLS));
   writeline( "", outfile);

   write_version_fileflags( infostruct.dwFileFlags, outfile );

   if(infostruct.dwFileFlagsMask == VS_FFI_FILEFLAGSMASK)
      fprintf( outfile, " FILEFLAGSMASK VS_FFI_FILEFLAGSMASK");
   else
      fprintf( outfile, " FILEFLAGSMASK %lu", infostruct.dwFileFlagsMask);
   writeline( "", outfile);

   writestring( " FILEOS ", outfile);
   switch (infostruct.dwFileOS) {

      case VOS_UNKNOWN:
         writeline("VOS_UNKNOWN", outfile);
         break;

      case VOS_DOS:
         writeline("VOS_DOS", outfile);
         break;

      case VOS_OS216:
         writeline("VOS_OS216", outfile);
         break;

      case VOS_OS232:
         writeline("VOS_OS232", outfile);
         break;

      case VOS_NT:
         writeline("VOS_NT", outfile);
         break;

      case VOS_DOS_WINDOWS16:
         writeline("VOS_DOS_WINDOWS16", outfile);
         break;

      case VOS_DOS_WINDOWS32:
         writeline("VOS_DOS_WINDOWS32", outfile);
         break;

      case VOS_OS216_PM16:
         writeline("VOS_OS216_PM16", outfile);
         break;

      case VOS_OS232_PM32:
         writeline("VOS_OS232_PM32", outfile);
         break;

      case VOS_NT_WINDOWS32:
         writeline("VOS_NT_WINDOWS32", outfile);
         break;

      default:
         fprintf( outfile, "%lu", infostruct.dwFileOS );
         writeline("", outfile);
         break;

   } /* switch (FileOS) - end */

   writestring( " FILETYPE ", outfile);
   switch (infostruct.dwFileType) {

      case VFT_UNKNOWN:
         writeline("VFT_UNKNOWN", outfile);
         break;

      case VFT_APP:
         writeline("VFT_APP", outfile);
         break;

      case VFT_DLL:
         writeline("VFT_DLL", outfile);
         break;

      case VFT_DRV:
         writeline("VFT_DRV", outfile);
         break;

      case VFT_FONT:
         writeline("VFT_FONT", outfile);
         break;

      case VFT_VXD:
         writeline("VFT_VXD", outfile);
         break;

      case VFT_STATIC_LIB:
         writeline("VFT_STATIC_LIB", outfile);
         break;

      default:
         fprintf( outfile, "%lu", infostruct.dwFileType );
         writeline("", outfile);
         break;

   } /* switch (FileType) - end */

   writestring( " FILESUBTYPE ", outfile);
   switch (infostruct.dwFileType) {

      case VFT_DRV:
         process_version_driver_subtype( infostruct.dwFileSubtype, outfile);
         break;

      case VFT_FONT:
         process_version_font_subtype( infostruct.dwFileSubtype, outfile);
         break;

      default:
         fprintf( outfile, "%lu", infostruct.dwFileSubtype );
         writeline("", outfile);
         break;

   } /* switch (FileSubtype) - end */


} /* process_version_root_block - end */


/***************************************************
  Write out the name of the current block, and return
   whether it was string, variable or other type of
   block.
****************************************************/
int write_block_name( FILE *infile, FILE *outfile ) {

   int  count=1;      /* record number of chars read */
   int  blocktype=0;  /* record which type of block it is */
   BYTE ch;

   ch = get_byte(infile);
   if (ch == 'S')
      blocktype = STRINGBLOCK;
   else if (ch == 'V')
      blocktype = VARBLOCK;
   else
      blocktype = OTHERBLOCK;

   while((!feof(infile)) && (ch != 0x00)) {
      ++count;
      write_char( ch, outfile);
      ch = get_byte(infile);
   }

   /* Ensure number of characters read is a multiple of 4.    */
   /* According to the MS documentation, this is the format.  */
   /* See "MS Windows 3.1 Programmer's Reference" Vol.4, p.99 */
   count = count % 4;
   count = (count > 0) ? (4 - count) : 0;
   while ((!feof(infile)) && (count > 0)) {
      ch = get_byte(infile);
      --count;
   }

   return(blocktype);

} /* write_block_name - end */


/***************************************************
  Write out the name of the current block, and return
   the total number of characters in the field.
****************************************************/
WORD write_ver_field_name( FILE *infile, FILE *outfile ) {

   WORD count=1;      /* record number of chars read */
   WORD fieldsize=1;  /* record number of chars read */
   BYTE ch;

   ch = get_byte(infile);

   while((!feof(infile)) && (ch != 0x00)) {
      ++count;
      write_char( ch, outfile);
      ch = get_byte(infile);
   }
   fieldsize = count;

   /* Ensure number of characters read is a multiple of 4.    */
   /* According to the MS documentation, this is the format.  */
   /* See "MS Windows 3.1 Programmer's Reference" Vol.4, p.99 */
   count = count % 4;
   count = (count > 0) ? (4 - count) : 0;
   while ((!feof(infile)) && (count > 0)) {
      ++fieldsize;
      ch = get_byte(infile);
      --count;
   }

   return(fieldsize);

} /* write_ver_field_name - end */


/***************************************************
  Read "wordsize" # of bytes and write them to the   
   output file; these bytes are the second part of 
   the  'VALUE "---", "---"' line in a version info
   string block.  Return the number of bytes needed
   to align the string on a 32-bit boundary.
****************************************************/
WORD write_ver_field_name_size_n( FILE *infile, FILE *outfile,
                                  WORD wordsize ) {

   WORD count=0;      /* record number of chars read */
   WORD diff=0;
   BYTE ch;

   while((!feof(infile)) && (count < wordsize)) {
      ++count;
      ch = get_byte(infile);
      write_char( ch, outfile);
   }

   /* Ensure number of characters read is a multiple of 4.    */
   /* According to the MS documentation, this is the format.  */
   /* See "MS Windows 3.1 Programmer's Reference" Vol.4, p.99 */
   count = count % 4;
   count = (count > 0) ? (4 - count) : 0;
   diff = count;
   while ((!feof(infile)) && (count > 0)) {
      ch = get_byte(infile);
      --count;
   }

   return(diff);

} /* write_ver_field_name_size_n - end */


/***************************************************
  Process a version string block
****************************************************/
void process_version_string_block( WORD blocksize, FILE *infile, 
                                   FILE *outfile ) {

   WORD stringblocksize = 0;
   WORD subblocksize = 0;
   WORD subdatasize  = 0;
   WORD fieldsize = 0;
   WORD diff = 0;

   WORD totalblocksize = 0;  /* size so far of the entire block */
   WORD totalsubsize   = 0;  /* size so far of a subblock */

   /* add up: len(StringFileInfo\0) + sizeof(blocksize) +  */
   /* sizeof(datasize) (values already read in)         */
   totalblocksize = 16 + (2 * sizeof(WORD));

   while (totalblocksize < blocksize) {

      /* get the name of this entire string block */
      stringblocksize = get_word( infile );
      (void)get_word( infile );
      totalblocksize += stringblocksize;

      write_indent( outfile );
      writestring( "BLOCK \"", outfile);
      fieldsize = write_ver_field_name( infile, outfile );
      writeline( "\"", outfile);

      write_indent( outfile );
      writeline( "BEGIN", outfile);

      increase_indent();

      totalsubsize = fieldsize + (2 * sizeof(WORD)); 
      while (totalsubsize < stringblocksize) {

         subblocksize = get_word(infile);
         subdatasize  = get_word(infile);

         /* increment the byte counter by the size of the current block */
         totalsubsize += subblocksize;

         write_indent( outfile );
         writestring( "VALUE \"", outfile);
         (void)write_ver_field_name( infile, outfile );
         writestring( "\", \"", outfile);

         diff = write_ver_field_name_size_n( infile, outfile, subdatasize );

         totalsubsize += diff;
         totalblocksize += diff;

         writeline( "\"", outfile);

      } /* while (totalsubsize < stringblocksize) - end */

      decrease_indent();
      write_indent( outfile );
      writeline( "END", outfile);

   } /* while (totalblocksize < blocksize) - end */

} /* process_version_string_block - end */


/***************************************************
  Process a version variable block
****************************************************/
void process_version_var_block( WORD blocksize, FILE *infile, 
                                FILE *outfile ) {

   WORD subblocksize = 0;
   WORD subdatasize  = 0;
   WORD totalsize    = 0;

   WORD langid    = 0;
   WORD charsetid = 0;

   /* add up: len(VarFileInfo\0) + sizeof(blocksize) +  */
   /* sizeof(datasize) (values already read in)         */
   totalsize = 12 + (2 * sizeof(WORD));

   while (totalsize < blocksize) {

      subblocksize = get_word( infile );
      subdatasize  = get_word( infile );

      write_indent( outfile );
      writestring( "VALUE \"", outfile);
      (void)write_block_name( infile, outfile );
      writestring( "\", ", outfile);

      /* increment the byte counter by the size of the current block */
      totalsize += subblocksize;

      while (subdatasize) {

         langid = get_word( infile );
         charsetid = get_word( infile );

         fprintf( outfile, "0x%X, %d", langid, charsetid);

         /* take off the size of the 2 variables read above */
         subdatasize -= (2 * sizeof(WORD)); 

         /* if another entry after this one, write out a comma */
         if (subdatasize) {
            writeline( ",", outfile);
            write_indent( outfile );
         }
         else
            writeline( "", outfile);

      } /* while (subdatasize) - end */

   } /* while (totalsize < blocksize) - end */

} /* process_version_var_block - end */


/***************************************************
  Process an unknown type of version block
****************************************************/
void process_version_other_block( WORD blocksize, long currpos,
                                  FILE *infile, FILE *outfile ) {

   long newPos = 0L;

   write_indent( outfile );
   writeline("// Unknown block type - skipping", outfile);

   newPos = currpos + ((long) blocksize);
   fseek( infile, newPos, 0);

} /* process_version_other_block - end */


/***************************************************
  Process a version block, which can be either a
   StringFileInfo or VarFileInfo block.
****************************************************/
void process_version_block( FILE *infile, FILE *outfile ) {

   WORD blocksize = 0;   /* size of the next (complete) block */

   long currpos = 0L;    /* use in case the block type is unknown */

   int  block_type = 0;  /* mark block as StringFileInfo or VarStringInfo */

   INDENT = 0;           /* reset the amount of indentation */

   currpos = ftell(infile);

   blocksize = get_word(infile);
   (void) get_word(infile);     /* skip over the size of current dataset */

   increase_indent();
   write_indent( outfile );

   writestring( "BLOCK \"", outfile);
   block_type = write_block_name( infile, outfile );
   writeline( "\"", outfile);

   write_indent( outfile );
   writeline( "BEGIN", outfile);

   increase_indent();

   /* call the appropriate procedure for block_type */
   switch (block_type) {

      case STRINGBLOCK:
         process_version_string_block( blocksize, infile, outfile );
         break;

      case VARBLOCK:
         process_version_var_block( blocksize, infile, outfile );
         break;

      case OTHERBLOCK:
      default:
         process_version_other_block( blocksize, currpos, infile, outfile );
         break;

   } /* switch (block_type) - end */

   decrease_indent();
   write_indent( outfile );

   writeline( "END", outfile);

   decrease_indent();

} /* process_version_block - end */


/***************************************************
  Process version information
****************************************************/
void process_version_info( FILE *infile, FILE *outfile) {

   DWORD reslen = 0L;     /* total size of version info     */
   DWORD endpos = 0L;     /* ftell() of end of version info */
   DWORD currpos = 0L;    /* current position in input file */

   /* see if "#include <ver.h>" has already been written */
   check_if_ver_header_included( outfile );

   /* start writing out the version information */
   write_version_number(infile, outfile);
   writeline( "VERSIONINFO", outfile);

   /* version info doesn't seem to use memory flags, so skip them */
   get_mem_flags(infile);

   reslen = get_resource_length(infile);
   currpos = ftell(infile);
   endpos = currpos + reslen;

   /* get the name and size of the root block - we can ignore */
   /* this because we know what it's going to be.             */
   (void)get_word(infile); /* cbBlock */
   (void)get_word(infile); /* cbValue */

   get_version_name(infile); /* szKey[] */

   process_version_root_block(infile, outfile);

   writeline( "BEGIN", outfile);

   /* now go through all of the remaining blocks */
   currpos = ftell(infile);
   while (currpos < endpos) {

      process_version_block( infile, outfile );
      currpos = ftell(infile);

   }

   writeline( "END", outfile);

} /* process_version_info - end */


/***************************************************
  Call the appropriate function for each resource type
****************************************************/
void process_resource_by_number(FILE *infile, FILE *outfile) {

   int restype = 0;

   INDENT = 0;
   fread(&restype, sizeof(int), 1, infile);

   /* If we're in the middle of a string table, and the new resource */
   /* isn't a string table, finish it off */
   if ((restype != STRING_TYPE) && (StringCount)) {
      writeline("}", outfile);
      StringCount = 0;
   }

   switch(restype) {
      case RT_CURSOR:
         process_cursor( infile );
         break;

      case RT_BITMAP:
         process_bitmap(restype, infile, outfile);
         break;

      case RT_ICON:
         process_icon( infile );
         break;

      case RT_MENU:
         process_menu(restype, infile, outfile);
         break;

      case RT_DIALOG:
         process_dialog(restype, infile, outfile);
         break;

      case RT_STRING:
         process_string(restype, infile, outfile);
         break;

      case RT_FONTDIR:
         process_fontdir( infile );
         break;

      case RT_FONT:
         process_font(restype, infile, outfile);
         break;

      case RT_ACCELERATOR:
         process_accelerator(restype, infile, outfile);
         break;

      case RT_RCDATA:
         process_rcdata(restype, infile, outfile);
         break;

      case RT_GROUP_CURSOR:
         process_group_cursor(infile, outfile);
         break;

      case RT_GROUP_ICON:
         process_group_icon(infile, outfile);
         break;

      /* name tables aren't used in Win3.1, so no predefined "RT_????" */
      case 15:
         process_name_table(infile, outfile);
         break;

      /* there doesn't seem to be an RT_????? for version info */
      case 16:
         process_version_info( infile, outfile);
         break;

      default:
         process_user_resource_num(restype, infile, outfile);
         break;
   
    }

} /* process_resource_by_number - end */


/***************************************************
   Process user-defined resource (by name)
****************************************************/
void process_resource_by_name( BYTE ch, FILE *infile, FILE *outfile) {

   long  typeid_pos;  /* file position of type id */
   long  nameid_pos;  /* file position of name id */

   typeid_pos = ftell(infile);

   /* Skip the resource name */
   fseek( infile, -1, 1);
   get_resource_name(infile);

   /* Get the name of the resource itself */
   write_resource_name(infile, outfile);
   nameid_pos = ftell(infile);

   write_char(' ', outfile);

   /* now go back to the resource name and print it out */
   fseek( infile, typeid_pos, 0);
   get_custom_type( ch, infile, outfile );

   fseek( infile, nameid_pos, 0);
   write_mem_flags(infile, outfile);
   write_char(' ', outfile);

   save_user_resource( infile, outfile );

} /* process_resource_by_name - end */


/***************************************************
   Check the parameters passed on program invokation
****************************************************/
void check_usage(int argc) {

   if (argc != 3) {
      printf("Usage: res2rc <.res filename> <.rc output filename>\n");
      exit(1);
   }

} /* check_usage - end */


/***************************************************
   Write the header to the output file.
****************************************************/
void write_header( char *infname, char *outfname, FILE *outfile ) {

   writeline( "//", outfile);
   writestring( "// ", outfile);
   writestring( outfname, outfile);
   writestring( " - resource file decompiled from ", outfile);
   writeline( infname, outfile);
   writeline( "//", outfile);
   writeline( "#include <windows.h>", outfile);

} /* write_header - end */


/***************************************************
   Check if input file is a Win32 resource file
****************************************************/
void check_for_win32_res( FILE *infile ) {

   char ch;

   ch = get_byte(infile);
   if(ch == 0x00) {
      printf("Input file is a Win32 .res file.  Stopping.\n");
      exit(1);
   }
   rewind(infile);

} /* check_for_win32_res - end */


/***************************************************
   Read .res file and process each resource.
****************************************************/
int main(int argc, char *argv[]) {

   FILE *infile;
   FILE *outfile;
   BYTE ch;

   check_usage(argc);

   if((infile = fopen(argv[1], "rb")) == NULL) {
      printf("Error: Unable to open input file.\nStopping.\n");
      exit(1);
   }

   check_for_win32_res( infile );

   if((outfile = fopen(argv[2], "wb")) == NULL) {
      printf("Error: Unable to open output file.\nStopping.\n");
      exit(1);
   }

   write_header( argv[1], argv[2], outfile );

   StringCount   = 0;

   ch = get_byte(infile);

   while(!feof(infile)) {

      /* get the resource type */
      if(ch == 0xFF)
         process_resource_by_number(infile, outfile);
      else
         process_resource_by_name(ch, infile, outfile);

      ch = get_byte(infile);

   } /* while(not eof(infile)) - end */

   finish_off_stringtable(outfile);

   fclose(infile);

   return(0);

} /* main - end */

/* Res2Rc.c - end */
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\Windows Undocumented File Formats\wuff_src\CHAP8\PIFDUMP.C ===
/**********************************************************************
 *
 * PROGRAM: PIFDUMP.C
 *
 * PURPOSE: This program extracts information from an MS Windows
 *          PIF file (either 386 or 286 mode)
 *
 * Copyright 1997, Mike Wallace and Pete Davis
 *
 * Chapter 8, PIF File Format, from Undocumented Windows File Formats,
 * published by R&D Books, an imprint of Miller Freeman, Inc.
 *
 **********************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "windows.h"
#include "pifstruc.h"

#define SUCCESS       0
#define ERROR_FOUND   1


/******************************************************************\
 *                                                                *
 * Check how the program was called.  Required parameters are     *
 * the mode of information to extract (-3 for 386, -2 for 286)    *
 * and the input filename.                                        *
 *                                                                *
\******************************************************************/
int check_usage(int argc, char *argv[]) {

   int dump_type=0;

   if (argc == 3) {

      if (!strcmp(argv[1], "-2"))
         dump_type = 2;
      else if (!strcmp(argv[1], "-3"))
         dump_type = 3;

   } /* if (argc == 3) - end */

   if (dump_type == 0) {
      printf("Usage:  pifdump < -3 | -2 > <infile>\n");
      exit(0);
   }

   return(dump_type);

} /* check_usage - end */


/******************************************************************\
 *                                                                *
 * Strip out trailing spaces from text_string.                    *
 *                                                                *
\******************************************************************/
void trim(char text_string[], int size) {

   /* check for a non-positive size */
   if (size < 1) return;

   /* find last non-blank character, then set next char. to null */
   for (--size; (--size >= 0) && (text_string[size] != ' '); ) {}
   text_string[++size] = '\0';

} /* trim - end */


/******************************************************************\
 *                                                                *
 * If test_flag is non-zero, print str1, else print str2.         *
 *                                                                *
\******************************************************************/
void print_flag(WORD test_flag, char *str1, char *str2) {

   if (test_flag)
      puts(str1);
   else
      puts(str2);

} /* print_flag - end */


/******************************************************************\
 *                                                                *
 * Convert the hotkey from the PIF file into a readable character.*
 *                                                                *
\******************************************************************/
void convert_hotkey( WORD hotkey, WORD num_flag) {

   switch(hotkey) {

      case 30: putchar('a');    break;
      case 48: putchar('b');    break;
      case 46: putchar('c');    break;
      case 32: putchar('d');    break;
      case 18: putchar('e');    break;
      case 33: putchar('f');    break;
      case 34: putchar('g');    break;
      case 35: putchar('h');    break;
      case 23: putchar('i');    break;
      case 36: putchar('j');    break;
      case 37: putchar('k');    break;
      case 38: putchar('l');    break;
      case 50: putchar('m');    break;
      case 49: putchar('n');    break;
      case 24: putchar('o');    break;
      case 25: putchar('p');    break;
      case 16: putchar('q');    break;
      case 19: putchar('r');    break;
      case 31: putchar('s');    break;
      case 20: putchar('t');    break;
      case 22: putchar('u');    break;
      case 47: putchar('v');    break;
      case 17: putchar('w');    break;
      case 45: putchar('x');    break;
      case 21: putchar('y');    break;
      case 44: putchar('z');    break;
      case 2: putchar('1');     break;
      case 3: putchar('2');     break;
      case 4: putchar('3');     break;
      case 5: putchar('4');     break;
      case 6: putchar('5');     break;
      case 7: putchar('6');     break;
      case 8: putchar('7');     break;
      case 9: putchar('8');     break;
      case 10: putchar('9');    break;
      case 11: putchar('0');    break;
      case 27: putchar(']');    break;
      case 26: putchar('[');    break;
      case 39: putchar(';');    break;
      case 40: putchar('\'');   break;
      case 41: putchar('`');    break;
      case 51: putchar(',');    break;
      case 52: putchar('.');    break;
      case 53: print_flag(num_flag, "Num /", "/"); break;
      case 12: putchar('-');    break;
      case 13: putchar('=');    break;
      case 43: putchar('\\');   break;
      case 59: puts("F1");      break;
      case 60: puts("F2");      break;
      case 61: puts("F3");      break;
      case 62: puts("F4");      break;
      case 63: puts("F5");      break;
      case 64: puts("F6");      break;
      case 65: puts("F7");      break;
      case 66: puts("F8");      break;
      case 67: puts("F9");      break;
      case 68: puts("F10");     break;
      case 87: puts("F11");     break;
      case 88: puts("F12");     break;
      case 78: puts("Num +");   break;
      case 69: puts("NumLock"); break;
      case 76: puts("Num 5");   break;
      case 74: puts("Num -");   break;

      case 82: print_flag(num_flag, "Insert", "Num 0");  break;
      case 70: print_flag(num_flag, "Break", "Scroll Lock");  break;
      case 71: print_flag(num_flag, "Home", "Num 7");  break;
      case 72: print_flag(num_flag, "Up", "Num 8");  break;
      case 73: print_flag(num_flag, "Page Up", "Num 9");  break;
      case 75: print_flag(num_flag, "Left", "Num 4");  break;
      case 77: print_flag(num_flag, "Right", "Num 6");  break;
      case 79: print_flag(num_flag, "End", "Num 1");  break;
      case 80: print_flag(num_flag, "Down", "Num 2");  break;
      case 81: print_flag(num_flag, "Page Down", "Num 3");  break;
      case 83: print_flag(num_flag, "Delete", "Num Del");  break;

      default: printf("<Unknown: %d>", hotkey); break;
   }
   putchar('\n');

} /* convert_hotkey - end */


/******************************************************************\
 *                                                                *
 * Use the 8 bits in the 286-Flags BYTE to fill in the 8 bytes of *
 * the FLAGS286 structure.                                        *
 *                                                                *
\******************************************************************/
void fill_flags286( BYTE flags286, FLAGS286 *f286_data) {

   /* The comment at the end of each line converts decimal to binary */
   f286_data->AltTab286    = (BYTE)(flags286 & 1);    /* 1   = 00000001 */
   f286_data->AltEsc286    = (BYTE)(flags286 & 2);    /* 2   = 00000010 */
   f286_data->AltPrtScr286 = (BYTE)(flags286 & 4);    /* 4   = 00000100 */
   f286_data->PrtScr286    = (BYTE)(flags286 & 8);    /* 8   = 00001000 */
   f286_data->CtrlEsc286   = (BYTE)(flags286 & 16);   /* 16  = 00010000 */
   f286_data->NoSaveScreen = (BYTE)(flags286 & 32);   /* 32  = 00100000 */
   f286_data->Unused10[0]  = (BYTE)(flags286 & 64);   /* 64  = 01000000 */
   f286_data->Unused10[1]  = (BYTE)(flags286 & 128);  /* 128 = 10000000 */

} /* fill_flags286 - end */


/******************************************************************\
 *                                                                *
 * Use the 8 bits in the COM Ports BYTE to fill in the 8 BYTES of *
 * the COMPORT structure.                                         *
 *                                                                *
\******************************************************************/
void fill_com_ports( BYTE comports, COMPORT *com_ports) {

   /* The comment at the end of each line converts decimal to binary */
   com_ports->Unused11[0]  = (BYTE)(comports & 1);    /* 1   = 00000001 */
   com_ports->Unused11[1]  = (BYTE)(comports & 2);    /* 2   = 00000010 */
   com_ports->Unused11[2]  = (BYTE)(comports & 4);    /* 4   = 00000100 */
   com_ports->Unused11[3]  = (BYTE)(comports & 8);    /* 8   = 00001000 */
   com_ports->Unused11[4]  = (BYTE)(comports & 16);   /* 16  = 00010000 */
   com_ports->Unused11[5]  = (BYTE)(comports & 32);   /* 32  = 00100000 */
   com_ports->Com3         = (BYTE)(comports & 64);   /* 64  = 01000000 */
   com_ports->Com4         = (BYTE)(comports & 128);  /* 128 = 10000000 */

} /* fill_com_ports - end */


/******************************************************************\
 *                                                                *
 * Use the 16 bits in the video[2] bytes to fill in the 16 bytes  *
 * of the VIDEO structure.                                        *
 *                                                                *
\******************************************************************/
void fill_video( BYTE video[2], VIDEO *video_data) {

   /* The comment at the end of each line converts decimal to binary */
   video_data->EmulateText  = (BYTE)(video[0] & 1);    /* 1   = 00000001 */
   video_data->MonitorText  = (BYTE)(video[0] & 2);    /* 2   = 00000010 */
   video_data->MonitorLoGr  = (BYTE)(video[0] & 4);    /* 4   = 00000100 */
   video_data->MonitorHiGr  = (BYTE)(video[0] & 8);    /* 8   = 00001000 */
   video_data->InitModeText = (BYTE)(video[0] & 16);   /* 16  = 00010000 */
   video_data->InitModeLoGr = (BYTE)(video[0] & 32);   /* 32  = 00100000 */
   video_data->InitModeHiGr = (BYTE)(video[0] & 64);   /* 64  = 01000000 */
   video_data->RetainVideo  = (BYTE)(video[0] & 128);  /* 128 = 10000000 */

   video_data->VideoUnused[0] = (BYTE)(video[1] & 1);    /* 1   = 00000001 */
   video_data->VideoUnused[1] = (BYTE)(video[1] & 2);    /* 2   = 00000010 */
   video_data->VideoUnused[2] = (BYTE)(video[1] & 4);    /* 4   = 00000100 */
   video_data->VideoUnused[3] = (BYTE)(video[1] & 8);    /* 8   = 00001000 */
   video_data->VideoUnused[4] = (BYTE)(video[1] & 16);   /* 16  = 00010000 */
   video_data->VideoUnused[5] = (BYTE)(video[1] & 32);   /* 32  = 00100000 */
   video_data->VideoUnused[6] = (BYTE)(video[1] & 64);   /* 64  = 01000000 */
   video_data->VideoUnused[7] = (BYTE)(video[1] & 128);  /* 128 = 10000000 */

} /* fill_video - end */


/******************************************************************\
 *                                                                *
 * Use the 16 bits in the hotkey[2] bytes to fill in the 16 bytes *
 * of the HOTKEY structure.                                       *
 *                                                                *
\******************************************************************/
void fill_hotkey( BYTE hotkey[2], HOTKEY *hotkey_data) {

   /* The comment at the end of each line converts decimal to binary */
   hotkey_data->HOT_KEYSHIFT = (BYTE)(hotkey[0] & 1);    /* 1   = 00000001 */
   hotkey_data->Unused4      = (BYTE)(hotkey[0] & 2);    /* 2   = 00000010 */
   hotkey_data->HOT_KEYCTRL  = (BYTE)(hotkey[0] & 4);    /* 4   = 00000100 */
   hotkey_data->HOT_KEYALT   = (BYTE)(hotkey[0] & 8);    /* 8   = 00001000 */
   hotkey_data->Unused5[0]   = (BYTE)(hotkey[0] & 16);   /* 16  = 00010000 */
   hotkey_data->Unused5[1]   = (BYTE)(hotkey[0] & 32);   /* 32  = 00100000 */
   hotkey_data->Unused5[2]   = (BYTE)(hotkey[0] & 64);   /* 64  = 01000000 */
   hotkey_data->Unused5[3]   = (BYTE)(hotkey[0] & 128);  /* 128 = 10000000 */

   hotkey_data->Unused5[4]   = (BYTE)(hotkey[0] & 1);    /* 1   = 00000001 */
   hotkey_data->Unused5[5]   = (BYTE)(hotkey[0] & 2);    /* 2   = 00000010 */
   hotkey_data->Unused5[6]   = (BYTE)(hotkey[0] & 4);    /* 4   = 00000100 */
   hotkey_data->Unused5[7]   = (BYTE)(hotkey[0] & 8);    /* 8   = 00001000 */
   hotkey_data->Unused5[8]   = (BYTE)(hotkey[0] & 16);   /* 16  = 00010000 */
   hotkey_data->Unused5[9]   = (BYTE)(hotkey[0] & 32);   /* 32  = 00100000 */
   hotkey_data->Unused5[10]  = (BYTE)(hotkey[0] & 64);   /* 64  = 01000000 */
   hotkey_data->Unused5[11]  = (BYTE)(hotkey[0] & 128);  /* 128 = 10000000 */

} /* fill_hotkey - end */


/******************************************************************\
 *                                                                *
 * Use the 16 bits in the flags_XMS[2] bytes to fill in the 16    *
 * bytes of the FLAGSXMS structure.                               *
 *                                                                *
\******************************************************************/
void fill_flagsxms( BYTE fxms[2], FLAGSXMS *xms_data) {

   /* The comment at the end of each line converts decimal to binary */
   xms_data->XMS_Locked    = (BYTE)(fxms[0] & 1);    /* 1   = 00000001 */
   xms_data->Allow_FastPst = (BYTE)(fxms[0] & 2);    /* 2   = 00000010 */
   xms_data->Lock_App      = (BYTE)(fxms[0] & 4);    /* 4   = 00000100 */
   xms_data->Unused3[0]    = (BYTE)(fxms[0] & 8);    /* 8   = 00001000 */
   xms_data->Unused3[1]    = (BYTE)(fxms[0] & 16);   /* 16  = 00010000 */
   xms_data->Unused3[2]    = (BYTE)(fxms[0] & 32);   /* 32  = 00100000 */
   xms_data->Unused3[3]    = (BYTE)(fxms[0] & 64);   /* 64  = 01000000 */
   xms_data->Unused3[4]    = (BYTE)(fxms[0] & 128);  /* 128 = 10000000 */

   xms_data->Unused3[5]    = (BYTE)(fxms[0] & 1);    /* 1   = 00000001 */
   xms_data->Unused3[6]    = (BYTE)(fxms[0] & 2);    /* 2   = 00000010 */
   xms_data->Unused3[7]    = (BYTE)(fxms[0] & 4);    /* 4   = 00000100 */
   xms_data->Unused3[8]    = (BYTE)(fxms[0] & 8);    /* 8   = 00001000 */
   xms_data->Unused3[9]    = (BYTE)(fxms[0] & 16);   /* 16  = 00010000 */
   xms_data->Unused3[10]   = (BYTE)(fxms[0] & 32);   /* 32  = 00100000 */
   xms_data->Unused3[11]   = (BYTE)(fxms[0] & 64);   /* 64  = 01000000 */
   xms_data->Unused3[12]   = (BYTE)(fxms[0] & 128);  /* 128 = 10000000 */

} /* fill_flagsxms - end */


/******************************************************************\
 *                                                                *
 * Use the 16 bits in the 386-Flags[2] bytes to fill in the 16    *
 * bytes of the FLAGS386 structure.                               *
 *                                                                *
\******************************************************************/
void fill_flags386( BYTE flags386[2], FLAGS386 *f386_data) {

   /* The comment at the end of each line converts decimal to binary */
   f386_data->AllowCloseAct = (BYTE)(flags386[0] & 1);   /* 1   = 00000001 */
   f386_data->BackgroundOn  = (BYTE)(flags386[0] & 2);   /* 2   = 00000010 */
   f386_data->ExclusiveOn   = (BYTE)(flags386[0] & 4);   /* 4   = 00000100 */
   f386_data->FullScreenYes = (BYTE)(flags386[0] & 8);   /* 8   = 00001000 */
   f386_data->Unused0       = (BYTE)(flags386[0] & 16);  /* 16  = 00010000 */
   f386_data->SK_AltTab     = (BYTE)(flags386[0] & 32);  /* 32  = 00100000 */
   f386_data->SK_AltEsc     = (BYTE)(flags386[0] & 64);  /* 64  = 01000000 */
   f386_data->SK_AltSpace   = (BYTE)(flags386[0] & 128); /* 128 = 10000000 */

   f386_data->SK_AltEnter   = (BYTE)(flags386[1] & 1);   /* 1   = 00000001 */
   f386_data->SK_AltPrtSc   = (BYTE)(flags386[1] & 2);   /* 2   = 00000010 */
   f386_data->SK_PrtSc      = (BYTE)(flags386[1] & 4);   /* 4   = 00000100 */
   f386_data->SK_CtrlEsc    = (BYTE)(flags386[1] & 8);   /* 8   = 00001000 */
   f386_data->Detect_Idle   = (BYTE)(flags386[1] & 16);  /* 16  = 00010000 */
   f386_data->UseHMA        = (BYTE)(flags386[1] & 32);  /* 32  = 00100000 */
   f386_data->Unused1       = (BYTE)(flags386[1] & 64);  /* 64  = 01000000 */
   f386_data->EMS_Locked    = (BYTE)(flags386[1] & 128); /* 128 = 10000000 */

} /* fill_flags386 - end */


/******************************************************************\
 *                                                                *
 * Use the 8 bits in the PIF close_on_exit BYTE to fill in the    *
 * 8 BYTES of the CLOSEONEXIT structure.                          *
 *                                                                *
\******************************************************************/
void fill_close_on_exit( BYTE close_on_exit, CLOSEONEXIT *coe_data) {

   /* The comment at the end of each line converts decimal to binary */
   coe_data->Unused0       = (BYTE)(close_on_exit & 1);  /* 1   = 00000001 */
   coe_data->Graph286      = (BYTE)(close_on_exit & 2);  /* 2   = 00000010 */
   coe_data->PreventSwitch = (BYTE)(close_on_exit & 4);  /* 4   = 00000100 */
   coe_data->NoScreenExch  = (BYTE)(close_on_exit & 8);  /* 8   = 00001000 */
   coe_data->Close_OnExit  = (BYTE)(close_on_exit & 16); /* 16  = 00010000 */
   coe_data->Unused1       = (BYTE)(close_on_exit & 32); /* 32  = 00100000 */
   coe_data->Com2          = (BYTE)(close_on_exit & 64); /* 64  = 01000000 */
   coe_data->Com1          = (BYTE)(close_on_exit & 128);/* 128 = 10000000 */

} /* fill_close_on_exit - end */


/******************************************************************\
 *                                                                *
 * Search the linked list of records at the end of the PIF file   *
 * for the section with a title of "title".                       *
 *                                                                *
\******************************************************************/
long search_pif_file( char *title, FILE *infile) {

   SECTIONHDR sect_hdr;
   SECTIONNAME sect_name;

   long offset=0L;
   short match_found=0;
   short at_eof=0;

   /* Skip over "MICROSOFT PIFEX" header - it points to the first part */
   /* of the file (in its sect_hdr structure, next_section = 0x187,    */
   /* current_section = 0x0, and size_section = 0x171; next_section =  */
   /* 0x171 (size of section) + 0x10 (size of "MICROSOFT PIFEX\0") +   */
   /* 0x06 (size of section header).                                   */
   fread( &sect_name, sizeof(sect_name), 1, infile);
   fread( &sect_hdr,  sizeof(sect_hdr),  1, infile);

   if (strcmp(sect_name.name_string, "MICROSOFT PIFEX")) {
      printf("Invalid PIF file.  Stopping.\n");
      exit(1);
   }

   /* Now scan through remaining sections in the PIF file */
   while ((!match_found) && (!at_eof)) {

      if (feof(infile))
         at_eof = 1;
      else {

         /* Read in the name and header of the current section */
         fread( &sect_name, sizeof(sect_name), 1, infile);
         fread( &sect_hdr,  sizeof(sect_hdr),  1, infile);

         /* Check if section found, or at eof, or if can't fseek to the */
         /* next section (these 3 actions are mutually exclusive)       */
         if (!strcmp(title, sect_name.name_string))
            match_found = 1;
         else if (sect_hdr.next_section == 0xFFFF)
            at_eof = 1;
         else {

            /* Convert a WORD to signed long */
            offset = 0x0000FFFF & sect_hdr.next_section;
            if (fseek(infile, offset, 0)) {
               printf("Unable to fseek to %ld.  Stopping.\n", offset);
               exit(1);
            }

         } /* if (section-not-found && not-at-end) - end */

      } /* if (not at end of file) - end */

   } /* while (match-not-found && not-at-end-of-file) - end */

   if (match_found)
      offset = sect_hdr.current_section;
   else
      offset = -1;

   return(offset);

} /* search_pif_file - end */


/******************************************************************\
 *                                                                *
 * Read the first 286 block from the PIF file.                    *
 *                                                                *
\******************************************************************/
void read_286_block( DATA286 *data, FILE *infile ) {

   long offset=0L;

   if ((offset = search_pif_file("WINDOWS 286 3.0", infile)) == -1) {
      printf("Error: 286 Section not found.  Stopping.\n");
      exit(1);
   }
   else {

      /* Read 286 section into memory */
      fseek(infile, offset, 0);
      fread( data, sizeof(DATA286), 1, infile);

   }

} /* read_286_block - end */


/******************************************************************\
 *                                                                *
 * Read the first 386 block from the PIF file.                    *
 *                                                                *
\******************************************************************/
void read_386_block( DATA386 *data, FILE *infile ) {

   long offset=0L;

   if ((offset = search_pif_file("WINDOWS 386 3.0", infile)) == -1) {
      printf("Error: 386 Section not found.  Stopping.\n");
      exit(1);
   }
   else {

      /* Read 386 section into memory */
      fseek(infile, offset, 0);
      fread( data, sizeof(DATA386), 1, infile);

   }

} /* read_386_block - end */


/******************************************************************\
 *                                                                *
 * Process the PIF input file.  If the user passes in "-2",       *
 * print out "Standard Mode" dump; for "-3", print "Enhanced"     *
 * mode dump.                                                     *
 *                                                                *
\******************************************************************/
void main(int argc, char *argv[]) {

   int  dump_type=0;    /* 2=286 dump, 3=386 dump */

   FILE *infile;

   PIF      pif_header;
   DATA386  data386;
   DATA286  data286;

   CLOSEONEXIT close_onexit_data;
   FLAGS286    f286_data;
   FLAGS386    f386_data;
   COMPORT     com_ports;
   VIDEO       video_data;
   HOTKEY      hotkey_data;
   FLAGSXMS    xms_data;

   /* Determine (from command line) if user wants 286 or */
   /* 386 info; set dump_type to 2 or 3, respectively.   */
   dump_type = check_usage(argc, argv);

   /* Try to open the file.  If it fails, exit. */
   if ((infile = fopen(argv[2], "rb")) == NULL) {
      printf("Input file not found.  Stopping.\n");
      exit(0);
   }

   /* fopen() was successful, so read in the first header */
   printf("Extracting %d86 information from %s.\n\n", dump_type, argv[2]);
   fread( &pif_header, sizeof(pif_header), 1, infile);

   /* Retrieve 286 or 386 (Standard or Enhanced) info from PIF file */
   if (dump_type == 2) {
      read_286_block( &data286, infile);

      fill_flags286(  data286.flags_286, &f286_data);
      fill_com_ports( data286.com_ports, &com_ports);
   }
   else {
      read_386_block( &data386, infile);

      fill_flags386(  data386.flags_386, &f386_data);
      fill_video( data386.video, &video_data);
      fill_hotkey( data386.hot_key_state, &hotkey_data);
      fill_flagsxms( data386.flags_XMS, &xms_data);
   }

   /* We're done with the input file, so close it */
   fclose(infile);

   /* Initialize bit-replacement structures */
   fill_close_on_exit( pif_header.close_on_exit, &close_onexit_data);

   /* Remove trailing spaces from text fields */
   trim(pif_header.prog_path,  sizeof(pif_header.prog_path));
   trim(pif_header.title,      sizeof(pif_header.title));
   trim(pif_header.def_dir,    sizeof(pif_header.def_dir));
   trim(pif_header.prog_param, sizeof(pif_header.prog_param));

   trim(pif_header.shared_prog_name, sizeof(pif_header.shared_prog_name));
   trim(pif_header.shared_data_file, sizeof(pif_header.shared_data_file));

   /* Print out the data common to both groups */
   printf("Program Filename   :  %s\n", pif_header.prog_path);
   printf("Window Title       :  %s\n", pif_header.title);

   /* print optional parameters based on dump_type */
   printf("Opt. Parameters    :  ");
   if (dump_type == 2)
      printf( "%s\n", pif_header.prog_param);
   else 
      printf( "%s\n", data386.opt_params);

   printf("Startup Directory  :  %s\n", pif_header.def_dir);

   /* print out video data */
   if (dump_type == 2) {
      printf("Video Mode         :  ");
      if (close_onexit_data.Graph286)
         printf("Graphics/Mult. Text\n");
      else
         printf("Text\n");
   }
   else if (dump_type == 3) {
      printf("Video Memory       :");
      if (video_data.InitModeText)
         printf("  Text");
      if (video_data.InitModeLoGr)
         printf("  Low Graphics");
      if (video_data.InitModeHiGr)
         printf("  High Graphics");
      printf("\n");
   }

   if (dump_type == 3) {

      printf("Memory Requirements:  %dK Required\t %dK Desired\n",
             data386.mem_req, data386.mem_limit);
      printf("EMS Memory         :  %dK Required\t %dK Limit\n",
             data386.ems_min, data386.ems_max);
      printf("XMS Memory         :  %dK Required\t %dK Limit\n",
             data386.xms_min, data386.xms_max);

      if (f386_data.FullScreenYes)
         printf("Display Usage      :  Full Screen\n");
      else
         printf("Display Usage      :  Windowed\n");

      printf("Execution          :  ");
      if (f386_data.BackgroundOn)
         printf("Background  ");
      else
         printf("Foreground  ");

      if (f386_data.ExclusiveOn)
         printf("Exclusive\n");
      else
         printf("Non-exclusive\n");

      if (close_onexit_data.Close_OnExit)
         printf("Close Window On Exit\n");
      else
         printf("Don't Close Window On Exit\n");

   }
   else if (dump_type == 2) {

      printf("Memory Requirements:  %dK Required\n",
             pif_header.min_mem);
      printf("XMS Memory         :  %dK Required\t %dK Limit\n\n",
             data286.xmsReq286, data286.xmsLimit286);

      printf("Directly Modifies:");
      if (close_onexit_data.Com1)
         printf("   Com1");
      if (close_onexit_data.Com2)
         printf("   Com2");
      if (com_ports.Com3)
         printf("   Com3");
      if (com_ports.Com4)
         printf("   Com4");
      if (pif_header.flags1 & 16)    /* Check the 5th bit for keyboard */
         printf("   Keyboard");
      printf("\n");

      if (close_onexit_data.NoScreenExch)
         printf("No Screen Exchange\n");
      else
         printf("Screen Exchange Allowed\n");

      if (close_onexit_data.PreventSwitch)
         printf("Program Switch Prevented\n");
      else
         printf("Program Switch Allowed\n");

      if (close_onexit_data.Close_OnExit)
         printf("Close Window On Exit\n");
      else
         printf("Don't Close Window On Exit\n");

      if (f286_data.NoSaveScreen)
         printf("Save Screen is not Enabled\n");
      else
         printf("Save Screen is Enabled\n");

      printf("Reserve Shortcut Keys:");
      if (f286_data.AltTab286)
         printf("  Alt+Tab");
      if (f286_data.AltEsc286)
         printf("  Alt+Esc");
      if (f286_data.CtrlEsc286)
         printf("  Ctrl+Esc");
      if (f286_data.PrtScr286)
         printf("  PrtScr");
      if (f286_data.AltPrtScr286)
         printf("  Alt+PrtScr");
      printf("\n");
   }

   /* Print out the 386 Advanced screen data */
   if (dump_type == 3) {

      printf("\nAdvanced Options:\n\n");

      printf("Multitasking Options:\n");
      printf("Background Priority: %d\n", data386.back_pri);
      printf("Foreground Priority: %d\n", data386.for_pri);
      if (f386_data.Detect_Idle)
         printf("Detect Idle Time\n\n");
      else
         printf("Do not Detect Idle Time\n\n");

      printf("Memory Options:\n");
      if (f386_data.EMS_Locked)
         printf("EMS Memory Locked\n");
      else
         printf("EMS Memory Not Locked\n");

      if (xms_data.XMS_Locked)
         printf("XMS Memory Locked\n");
      else
         printf("XMS Memory Not Locked\n");

      if (!f386_data.UseHMA)
         printf("Use High Memory\n");
      else
         printf("Do Not Use High Memory\n");

      if (xms_data.Lock_App)
         printf("Lock Application Memory\n");
      else
         printf("Do Not Lock Application Memory\n");

      printf("\nMonitor Ports:");
      if (!video_data.MonitorText)
         printf("   Text");
      if (!video_data.MonitorLoGr)
         printf("   Low Gr");
      if (!video_data.MonitorHiGr)
         printf("   High Gr");
      if (video_data.EmulateText)
         printf("   Emul. Text");
      if (video_data.RetainVideo)
         printf("   Retain Video Mem");
      printf("\n\n");

      if (xms_data.Allow_FastPst)
         printf("Allow Fast Paste\n");
      else
         printf("Don't Allow Fast Paste\n");

      if (f386_data.AllowCloseAct)
         printf("Allow Close When Active\n");
      else
         printf("Don't Allow Close When Active\n");

      printf("\nReserved Shortcut Keys\n");
      if (f386_data.SK_AltTab)
         printf("   Alt+Tab");
      if (f386_data.SK_AltEsc)
         printf("   Alt+Esc");
      if (f386_data.SK_CtrlEsc)
         printf("   Ctrl+Esc");
      if (f386_data.SK_PrtSc)
         printf("   PrtScr");
      if (f386_data.SK_AltPrtSc)
         printf("   Alt+PrtScr");
      if (f386_data.SK_AltSpace)
         printf("   Alt+Space");
      if (f386_data.SK_AltEnter)
         printf("   Alt+Enter");

      printf("\n\nApplication Shortcut Key: ");
      if (data386.hot_key_flag == 0)
         printf("None\n");
      else {
         if (hotkey_data.HOT_KEYALT)
            printf("Alt+");
         if (hotkey_data.HOT_KEYCTRL)
            printf("Ctrl+");
         if (hotkey_data.HOT_KEYSHIFT)
            printf("Shift+");

         convert_hotkey(data386.hot_key_scan, data386.hk_numflag);
      }

   } /* if (dump_type = 3) - end */

} /* main - end */

/* pifdump.c - end */
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\Windows Undocumented File Formats\wuff_src\CHAP8\PIFSTRUC.H ===
/**********************************************************************
 *
 * PROGRAM: PIFDUMP.C
 *
 * PURPOSE: This program extracts information from an MS Windows
 *          PIF file (either 386 or 286 mode)
 *
 * Copyright 1997, Mike Wallace and Pete Davis
 *
 * Chapter 8, PIF File Format, from Undocumented Windows File Formats,
 * published by R&D Books, an imprint of Miller Freeman, Inc.
 *
 **********************************************************************/

#define MAX_PIFFILE_SIZE        0x3FF
#define PIFEX_OFFSET            0x171

typedef struct {
    char name_string[16];
} SECTIONNAME;

typedef struct {
    WORD next_section;        /* offset of section after this      */
                              /* last section if contents = FFFF   */
    WORD current_section;     /* offset of data                    */
    WORD size_section;        /* size of data section              */
} SECTIONHDR;


/* This is the structure of the CLOSEONEXIT byte; it's not used in the   */
/* code because we want to avoid bit-type structures; there is a routine */
/* in the code to extract these values from the byte.                    */
/* These bits are specific to "Standard" mode, except Close_OnExit (both) */
/*
typedef struct {
    int Unused0 :1;           * Unused?                                 * 
    int Graph286 :1;          * True if "Graphics/Mult. Text" is set;   * 
                       * If this field is not set, Video Mode is "Text" * 
    int PreventSwitch :1;     * True if "Prevent Program Switch" is set * 
    int NoScreenExch :1;      * True if "No Screen Exchange" is not set * 
    int Close_OnExit :1;      * True if "Close Window on Exit" is set   * 
    int Unused1 :1;           * Unused?                                 * 
    int Com2 :1;              * True if "Directly Modifies Com2" is set * 
    int Com1 :1;              * True if "Directly Modifies Com1" is set * 
} CLOSEONEXIT;
*/

/* This structure is used to hold the values from */
/* the close_on_exit BYTE in the PIF structure.   */
typedef struct {
    BYTE Unused0;            /* Unused?                                 */
    BYTE Graph286;           /* True if "Graphics/Mult. Text" is set;   */
                      /* If this field is not set, Video Mode is "Text" */
    BYTE PreventSwitch;      /* True if "Prevent Program Switch" is set */
    BYTE NoScreenExch;       /* True if "No Screen Exchange" is not set */
    BYTE Close_OnExit;       /* True if "Close Window on Exit" is set   */
    BYTE Unused1;            /* Unused?                                 */
    BYTE Com2;               /* True if "Directly Modifies Com2" is set */
    BYTE Com1;               /* True if "Directly Modifies Com1" is set */
} CLOSEONEXIT;


/* Assorted Enhanced mode normal & advanced flags */
/* First, here's the structure of the 386 flags in the file */
/*
typedef struct {
    int AllowCloseAct :1;    * True if "Allow Close When Active" (A) is set* 
    int BackgroundOn :1;     * True if "Execution: Background" is set    *
    int ExclusiveOn :1;      * True if "Execution: Exclusive" is set     *
    int FullScreenYes :1;    * True if "Display Usage: Full Screen" is   *
                            * set, else "Display Usage: Windowed" is set *
    int Unused0 :1;          * Unused?                                   *
    int SK_AltTab :1;        * True if shortcut key "Alt+Tab" (Adv) is set*
    int SK_AltEsc :1;        * True if shortcut key "Alt+Esc" (Adv) is set*
    int SK_AltSpace :1;      * True if shortcut key "Alt+Space" (Adv) set *
    int SK_AltEnter :1;      * True if shortcut key "Alt+Enter" (Adv) set *
    int SK_AltPrtSc :1;      * True if shortcut key "Alt+PrtSc" (Adv) set *
    int SK_PrtSc :1;         * True if shortcut key "PrtSc" (Adv) is set *
    int SK_CtrlEsc :1;       * True if shortcut key "Ctrl+Esc" (Adv) set *
    int Detect_Idle :1;      * True if "Detect Idle Time" (Adv.) is set  *
    int UseHMA :1;           * True if "Uses High Memory" is NOT set(Adv.)*
    int Unused1 :1;          * Unused?                                   *
    int EMS_Locked :1;       * True if "EMS Memory Locked" (Adv.) is set *
} FLAGS386;
*/

/* Here's the structure used by pifdump to store the data */
typedef struct {
    BYTE AllowCloseAct;    /* True if "Allow Close When Active" (A) is set*/
    BYTE BackgroundOn;     /* True if "Execution: Background" is set      */
    BYTE ExclusiveOn;      /* True if "Execution: Exclusive" is set       */
    BYTE FullScreenYes;    /* True if "Display Usage: Full Screen" is     */
                           /* set, else "Display Usage: Windowed" is set  */
    BYTE Unused0;          /* Unused?                                     */
    BYTE SK_AltTab;        /* True if shortcut key "Alt+Tab" (Adv) is set */
    BYTE SK_AltEsc;        /* True if shortcut key "Alt+Esc" (Adv) is set */
    BYTE SK_AltSpace;      /* True if shortcut key "Alt+Space" (Adv) set  */
    BYTE SK_AltEnter;      /* True if shortcut key "Alt+Enter" (Adv) set  */
    BYTE SK_AltPrtSc;      /* True if shortcut key "Alt+PrtSc" (Adv) set  */
    BYTE SK_PrtSc;         /* True if shortcut key "PrtSc" (Adv) is set   */
    BYTE SK_CtrlEsc;       /* True if shortcut key "Ctrl+Esc" (Adv) set   */
    BYTE Detect_Idle;      /* True if "Detect Idle Time" (Adv.) is set    */
    BYTE UseHMA;           /* True if "Uses High Memory" is NOT set(Adv.) */
    BYTE Unused1;          /* Unused?                                     */
    BYTE EMS_Locked;       /* True if "EMS Memory Locked" (Adv.) is set   */
} FLAGS386;


/* These bits are specific to "Enhanced" mode (Advanced) */
/* First, here's the structure of the XMS flags in the file */
/*
typedef struct {
    int XMS_Locked :1;       * Flag - True if "XMS Memory Locked" is set * 
    int Allow_FastPst :1;    * Flag - True if "Allow Fast Paste" is set  * 
    int Lock_App :1;         * Flag - True if "Lock App Memory" is set   * 
    int Unused3 :5+8;        * Unused?                                   * 
} FLAGSXMS;
*/

/* Here's the structure used by pifdump to store the data */
typedef struct {
    BYTE XMS_Locked;        /* Flag - True if "XMS Memory Locked" is set */
    BYTE Allow_FastPst;     /* Flag - True if "Allow Fast Paste" is set  */
    BYTE Lock_App;          /* Flag - True if "Lock App Memory" is set   */
    BYTE Unused3[13];       /* Unused?                                   */
} FLAGSXMS;


/* These bits are specific to "Enhanced" mode (Advanced and Normal) */
/* First, here's the structure of the video flags in the file */
/*
typedef struct {
    int EmulateText :1;     * True if "Monitor Ports: Emulate Text" (A) set* 
    int MonitorText :1;     * True if "Mon Ports: Text" (A) is NOT set     * 
    int MonitorLoGr :1;     * True if "Mon Ports: Low Graphics" (A) NOT set* 
    int MonitorHiGr :1;     * True if "Mon Ports: Hi Graphics" (A) NOT set * 
    int InitModeText :1;    * True if "Video Memory: Text" is set          * 
    int InitModeLoGr :1;    * True if "Video Memory: Low Graphics" is set  * 
    int InitModeHiGr :1;    * True if "Video Memory: Hi Graphics" is set   * 
    int RetainVideo :1;     * True if "Monitor Ports: Retain Video"(A) set * 
    int VideoUnused :8;     * Unused?                                      * 
} VIDEO;
*/

/* Here's the structure used by pifdump to store the data */
typedef struct {
    BYTE EmulateText;      /* True if "Monitor Ports: Emulate Text" (A) set*/
    BYTE MonitorText;      /* True if "Mon Ports: Text" (A) is NOT set     */
    BYTE MonitorLoGr;      /* True if "Mon Ports: Low Graphics" (A) NOT set*/
    BYTE MonitorHiGr;      /* True if "Mon Ports: Hi Graphics" (A) NOT set */
    BYTE InitModeText;     /* True if "Video Memory: Text" is set          */
    BYTE InitModeLoGr;     /* True if "Video Memory: Low Graphics" is set  */
    BYTE InitModeHiGr;     /* True if "Video Memory: Hi Graphics" is set   */
    BYTE RetainVideo;      /* True if "Monitor Ports: Retain Video"(A) set */
    BYTE VideoUnused[8];   /* Unused?                                      */
} VIDEO;


/* These bits are specific to "Enhanced" mode (Advanced) */
/* First, here's the structure of the hotkey flags in the file */
/*
typedef struct {
    int HOT_KEYSHIFT :1;     * Flag - marks whether hot key uses "shift" *
    int Unused4 :1;          * Unused?                                   *
    int HOT_KEYCTRL :1;      * Flag - marks whether hot key uses "ctrl"  *
    int HOT_KEYALT :1;       * Flag - marks whether hot key uses "alt"   *
    int Unused5 :4+8;        * Unused?                                   *
} HOTKEY;
*/

/* Here's the structure used by pifdump to store the data */
typedef struct {
    BYTE HOT_KEYSHIFT;      /* Flag - marks whether hot key uses "shift" */
    BYTE Unused4;           /* Unused?                                   */
    BYTE HOT_KEYCTRL;       /* Flag - marks whether hot key uses "ctrl"  */
    BYTE HOT_KEYALT;        /* Flag - marks whether hot key uses "alt"   */
    BYTE Unused5[12];       /* Unused?                                   */
} HOTKEY;


/* These bits are specific to "Standard" mode */
/* First, here's the structure of some 286 flags in the file */
/*
typedef struct {
    int AltTab286 :1;        * True if "Alt+Tab" shortcut key is set   * 
    int AltEsc286 :1;        * True if "Alt+Esc" shortcut key is set   * 
    int AltPrtScr286 :1;     * True if "Alt+PrtSc" shortcut key is set * 
    int PrtScr286 :1;        * True if "PrtSc" shortcut key is set     * 
    int CtrlEsc286 :1;       * True if "Ctrl+Esc" shortcut key is set  * 
    int NoSaveScreen :1;     * True if "No Save Screen" is set         * 
    int Unused10 :2;         * Unused?                                 * 
} FLAGS286;
*/

/* Here's the structure used by pifdump to store the data */
typedef struct {
    BYTE AltTab286;          /* True if "Alt+Tab" shortcut key is set   */
    BYTE AltEsc286;          /* True if "Alt+Esc" shortcut key is set   */
    BYTE AltPrtScr286;       /* True if "Alt+PrtSc" shortcut key is set */
    BYTE PrtScr286;          /* True if "PrtSc" shortcut key is set     */
    BYTE CtrlEsc286;         /* True if "Ctrl+Esc" shortcut key is set  */
    BYTE NoSaveScreen;       /* True if "No Save Screen" is set         */
    BYTE Unused10[2];        /* Unused?                                 */
} FLAGS286;


/* These bits are specific to "Standard" mode */
/* First, here's the structure of the COM port data in the file */
/*
typedef struct {
    int Unused11 :4+2;       * Unused?                                 *
    int Com3 :1;             * True if "Directly Modifies Com3" is set *
    int Com4 :1;             * True if "Directly Modifies Com4" is set *
} COMPORT;
*/

/* Here's the structure used by pifdump to store the data */
typedef struct {
    BYTE Unused11[6];       /* Unused?                                 */
    BYTE Com3;              /* True if "Directly Modifies Com3" is set */
    BYTE Com4;              /* True if "Directly Modifies Com4" is set */
} COMPORT;


/* This is the structure for an "Enhanced" mode record */
typedef struct {
    short mem_limit;         /* Memory Requirements: KB Desired      */
    short mem_req;           /* Memory Requirements: KB Required     */
    WORD for_pri;            /* foreground priority of task          */
    WORD back_pri;           /* background priority of task          */
    short ems_max;           /* EMS Memory: KB Limit                 */
    WORD ems_min;            /* EMS Memory: KB Required              */
    short xms_max;           /* XMS Memory: KB Limit                 */
    WORD xms_min;            /* XMS Memory: KB Required              */
    BYTE flags_386[2];       /* mix of 386 normal/advanced flags     */
                             /* These make up the FLAGS386 structure */
    BYTE flags_XMS[2];       /* flags for 386-advanced memory use    */
                             /* These make up the FLAGSXMS structure */
    BYTE video[2];           /* flags for graphics mode/monitor port */
                             /* These make up the VIDEO structure    */
    WORD zero1;              /* Unknown - always zero?               */
    WORD hot_key_scan;       /* determined by the hot key character  */
    BYTE hot_key_state[2];   /* determines alt/ctrl/shift status     */
                             /* These make up the HOTKEY structure   */
    WORD hot_key_flag;       /* 0=no hot key, 0xF= hot key defined   */
    WORD hk_numflag;         /* Flag if hotkey uses numeric keypad   */
    WORD zero2[4];           /* Unknown - always zero?               */
    char opt_params[64];     /* opt params for enhanced mode         */
} DATA386;

/* This is the structure for a "Standard" mode record */
typedef struct {
    WORD xmsLimit286;    /* If xmsReq286 < 128, this is 128, else it */
                         /* equals xmsReq286                         */
    WORD xmsReq286;      /* Memory Req.: KB Required field           */
    BYTE flags_286;      /* Structure for 286-specific fields        */
                         /* This byte makes up the FLAGS286 structure*/
    BYTE com_ports;      /* Information on modified COM ports        */
                         /* This byte makes up the COMPORT structure */
} DATA286;

/* This is the header that starts every MS Windows PIF file. */
typedef struct {

    /* from 0 -170 hex, not used by Windows, unless so indicated. */
    /* Note that in some cases the PIF editor fills in a value,     */
    /* even though it does not SEEM to be used        */

    BYTE resv1;
    BYTE checksum;               /* used by Windows                   */
    char title[30];              /* 02 used by 286,386 mode for title */
    short max_mem;               /* 20h used byt 286, 386 mem size  */
    short min_mem;               /* 22h, these 2 are duplicates see 19c */
    char prog_path[63];          /* 24h used by x86 modes for program & path*/
    BYTE close_on_exit;          /* 63h, 286 and 386 modes     */
                         /* This byte makes up the CLOSEONEXIT structure */
    BYTE def_drv;                /* 64h  */
    char def_dir[64];            /* 65h used by 286,386 mode for start dir */
    char prog_param[64];         /* a5, used by 286 */
    BYTE initial_screenMode;     /* usually zero, sometimes 0x7F */
    BYTE text_pages;             /* always 0x1                   */
    BYTE first_interrupt;        /* always 0x0                   */
    BYTE last_interrupt;         /* always 0xFF                  */
    BYTE rows;                   /* usually 25                   */
    BYTE cols;                   /* usually 80                   */
    BYTE window_pos_row;
    BYTE window_pos_col;
    WORD sys_memory;             /* always 7                     */
    char shared_prog_name[64];
    char shared_data_file[64];
    BYTE flags1;                 /* 5th bit=Directly Mods Keybd  */
    BYTE flags2;                 /* 170, usually zero            */

} PIF; /* PIF structure    */

typedef struct {
    SECTIONNAME SName;
    SECTIONHDR Hdr;
} BLOCKNT;

typedef struct {
    BYTE Hdr1[3];
    BYTE HChkSum;
} SECTIONHDR1;

typedef struct {
    SECTIONHDR1 CHdr1;
    char CAux[8+1+3];
} COMMENTS;

/* pifstruc.h - end */
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\Windows Undocumented File Formats\wuff_src\CHAP9\SUCKW3\SUCKW3.C ===
/**********************************************************************
 *
 * PROGRAM: SUCKW3.C
 *
 * PURPOSE: Extracts VxDs from a W3 file.
 *
 * Copyright 1997, Mike Wallace and Pete Davis
 *
 * Chapter 9, W3 and W4 File Formats, from Undocumented Windows File Formats,
 * published by R&D Books, an imprint of Miller Freeman, Inc.
 *
 **********************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "suckw3.h"

// Pass by the MZ Header
BOOL SkipMZ(FILE *inFile)
{
  MZHEADER  MZHeader;
  
  fread(&MZHeader, sizeof(MZHeader), 1, inFile);
  
  if (MZHeader.MZMagic[0] == 'W' && MZHeader.MZMagic[1] == '3')
  {
    fseek(inFile, 0, SEEK_SET);
    printf("Note: This is an extracted W3 file.\n");
    return TRUE;
  }
  
  if (MZHeader.MZMagic[0] != 'M' || MZHeader.MZMagic[1] != 'Z')
  {
    printf("This is not an executable\n");
    return FALSE;
  }
  
  if (!MZHeader.OtherOff)
  {
    printf("This is a DOS Executable\n");
    return FALSE;
  }

  fseek(inFile, MZHeader.OtherOff, SEEK_SET);
  return TRUE;
}

// List VxDs in the W3 file
void ListW3File(FILE *W3File)
{
  long    W3Start;
  W3HEADER  W3Hdr;
  WORD    i;
  VxDRECORD VxDRec;
  
  W3Start = ftell(W3File);
  
  fread(&W3Hdr, sizeof(W3Hdr), 1, W3File);
  if (W3Hdr.WinVer == 0x30A)
    printf("W3 File for Windows Version 3.1\n\n");
  else if (W3Hdr.WinVer == 0x400)
    printf("W3 File for Windows 95.\n\n");
  
  printf("%u VxDs in this W3 File.\n\n", W3Hdr.NumVxDs);
  
  printf("VxDName    VxDStart       VxDHdrLen\n");
  printf("-----------------------------------\n");
  for (i=0; i<W3Hdr.NumVxDs; i++)
  {
    fread(&VxDRec, sizeof(VxDRec), 1, W3File);
    printf("%-10s 0x%08lX     0x%08lX\n", 
      VxDRec.VxDName, VxDRec.VxDStart, VxDRec.VxDHdrSize);
  }
}

// Extract the VxD
void PullVxD(FILE *W3File, char *VxDName, long VxDStart)
{
  char    OutFile[12];
  FILE    *VxDFile;
  LEHEADER  LEHdr;
  long    Remaining;
  int     ToCopy;
  static char buffer[8192];
  
  fseek(W3File, VxDStart, SEEK_SET);

  strcpy(OutFile, VxDName);
  strcat(OutFile, ".386");
  if ((VxDFile = fopen(OutFile, "wb")) == NULL) 
    printf("Unable to create file %s!\n", OutFile);
  
  fread(&LEHdr, sizeof(LEHdr), 1, W3File);
  Remaining = LEHdr.NonResTable;
  
  // Patch values for Non-Resident Name Table
  LEHdr.NonResSize = strlen(VxDName) * 2 + 2;

  // Patch Data Pages offset
  LEHdr.DataPages -= VxDStart;
  
  // Write the new LE Header
  fwrite(&LEHdr, sizeof(LEHdr), 1, VxDFile);
  Remaining -= sizeof(LEHdr);
  
  // Copy remaining information
  while (Remaining)
  {
    ToCopy = Remaining > 4096 ? 4096 : (int) Remaining;
    fread(buffer, ToCopy, 1, W3File);
    fwrite(buffer, ToCopy, 1, VxDFile);
    Remaining -= ToCopy;
  }
  
  // Patch Non-Resident Name Table itself
  buffer[0]=strlen(VxDName);
  memcpy(&buffer[1], VxDName, strlen(VxDName));
  buffer[strlen(VxDName) + 1] = 0;
  buffer[strlen(VxDName) + 2] = 0;
  buffer[strlen(VxDName) + 3] = buffer[0];
  ToCopy = strlen(VxDName) + 4;
  memcpy(&buffer[ToCopy], VxDName, strlen(VxDName));
  ToCopy += strlen(VxDName);
  buffer[ToCopy] = 0x01;
  buffer[ToCopy + 1] = 0;
  ToCopy+=2;
  
  // Write the Non-Resident Name Table and close file.
  fwrite(buffer, ToCopy, 1, VxDFile);
  fclose(VxDFile);

}

// Find the VxD to "suck" out
void SuckVxD(FILE *W3File, char *VxDName)
{
  long    W3Start;
  W3HEADER  W3Hdr;
  WORD    i;
  VxDRECORD VxDRec;
  
  W3Start = ftell(W3File);
  
  fread(&W3Hdr, sizeof(W3Hdr), 1, W3File);
  
  // Try to find the VxD
  for(i=0; i<W3Hdr.NumVxDs; i++)
  {
    fread(&VxDRec, sizeof(VxDRec), 1, W3File);
    if (!memcmp(VxDRec.VxDName, VxDName, strlen(VxDName)))
    {
      printf("Extracting %s..\n", VxDName);
      PullVxD(W3File, VxDName, VxDRec.VxDStart);
      return;
    }
  }
  
  // Didn't find the VxD;
  printf("VxD %s not found in this W3 File.\n");
}


void Usage(void)
{
  printf("Usage: SUCKW3 W3Name [VxDName]\n\n");
  printf("W3Name   is the name of the W3 executable, probably\n");
  printf("         WIN386.EXE, VMM32.VXD, or VMM32.EXE\n");
  printf("VxDName  is, optionally, the name of the VxD to extract.\n\n");
  printf("Just providing the W3Name will give a directory\n");
  printf("of the contents of the W3 executable.\n");
}

int main(int argc, char *argv[]) 
{

  char  filename[256];
  char  VxDName[9];
  FILE  *W3File;

  if (argc < 2) {
    Usage();
    return EXIT_FAILURE;
  }
  
  strcpy(filename, argv[1]);
  
  if (argc == 3) 
  {
    if (strlen(argv[2]) > 8)
    {
      printf("Invalid VxDName. Must be 8 characters or less.\n");
      return EXIT_FAILURE;
    }
    strcpy(VxDName, argv[2]);
  }
  if (!strchr(filename, '.'))
    strcat(filename, ".EXE");
    
  if ((W3File = fopen(filename, "rb")) == NULL) 
  {
    printf("%s does not exist!\n", filename);
    return EXIT_FAILURE;
  }
  
  if (SkipMZ(W3File)) 
  { 
    if (argc == 2)
    {
      ListW3File(W3File);
    }
    if (argc == 3)
    {
      SuckVxD(W3File, VxDName);
    }
  }
  fclose(W3File);
  return EXIT_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\Windows Undocumented File Formats\wuff_src\CHAP7\RESTYPES.H ===
/**********************************************************************
 *
 * PROGRAM: RES2RC.C
 *
 * PURPOSE: Converts a .RES file to an .RC file
 *
 * Copyright 1997, Mike Wallace and Pete Davis
 *
 * Chapter 7, Resource (.RES) File Format, from Undocumented Windows
 * File Formats, published by R&D Books, an imprint of Miller Freeman, Inc.
 *
 **********************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "windows.h"
#include "ver.h"

/* Declare some global variables */

/* This is a list of known resource types, all handled by the program */
char *res_array[] = { "", "CURSOR", "BITMAP", "ICON", "MENU", "DIALOG",
 "STRINGTABLE", "FONTDIR", "FONT", "ACCELERATORS", "RCDATA", "", 
 "GROUP CURSOR", "", "GROUP ICON" };

int  INDENT=0;        /* records the current number of indented spaces */
WORD StringCount;
WORD VersionUsed = 0; /* records whether ver.h has been included */

/* Define a variable to hold the memory-flags field for the current  */
/* resource.  This is used because for 2 fields (cursor and icon),   */
/* each resource of either type is separated into 2 resources in the */
/* .res file by the rc compiler: data and header.  The correct memory*/
/* flags are set in the first occurrence, but I don't write out the  */
/* resource until I hit the header.  Since we want to write out the  */
/* correct memory flags (e.g., LOADONCALL), we save the flag value in*/
/* this variable, and then use it when we hit the header, instead of */
/* using the header's flag.  It is only saved in the get_mem_flags() */
/* function, since that is the only time we skip a resource header,  */
/* such as for cursors and icons.                                    */
WORD prev_mem_flag=0;

/* define the newline and carriage return characters */
#define NL 10
#define CR 13

/* define constants for different Version Info block types */
#define STRINGBLOCK 1
#define VARBLOCK    2
#define OTHERBLOCK  3

/* define the number of spaces to indent */
#define INDENT_SPACES 3

/* define integer values for some resource types - try to make more elegant */
#define CURSOR_TYPE 1
#define ICON_TYPE   3
#define STRING_TYPE 6

struct MenuHeader {
   WORD wVersion;
   WORD wReserved;
};

struct AccelTableEntry {
   BYTE fFlags;
   WORD wEvent;
   WORD wId;
};

/* structure of icon data in .res file */
typedef struct IconDirectoryEntry {
   BYTE  bWidth;
   BYTE  bHeight;
   BYTE  bColorCount;
   BYTE  bReserved;
   WORD  wPlanes;
   WORD  wBitCount;
   DWORD dwBytesInRes;
   WORD  wImageOffset;
} ICONDIRENTRY;

/* structure of icon data in .ico file */
typedef struct IconResourceEntry {
   BYTE  bWidth;
   BYTE  bHeight;
   BYTE  bColorCount;
   BYTE  bReserved;
   WORD  wPlanes;
   WORD  wBitCount;
   DWORD dwBytesInRes;
   DWORD dwImageOffset;
} ICONRESENTRY;

typedef struct ICONDIR {
   WORD          idReserved;
   WORD          idType;
   WORD          idCount;
} ICONHEADER;

/* structure of cursor data in .res file */
typedef struct CursorDirectoryEntry {
   WORD  wWidth;
   WORD  wHeight;
   WORD  wPlanes;
   WORD  wBitCount;
   DWORD dwBytesInRes;
   WORD  wImageOffset;
} CURSORDIRENTRY;

/* structure of cursor data in .cur file */
typedef struct CursorResourceEntry {
   BYTE  bWidth;
   BYTE  bHeight;
   BYTE  bColorCount;
   BYTE  bReserved;
   WORD  wXHotSpot;
   WORD  wYHotSpot;
   DWORD dwBytesInRes;
   DWORD dwImageOffset;
} CURSORRESENTRY;

typedef struct CURSORDIR {
   WORD cdReserved;
   WORD cdType;
   WORD cdCount;
} CURSORHEADER;

typedef struct DIALOGINFO {
   DWORD lStyle;
   BYTE  bNumberOfItems;
   WORD  x;
   WORD  y;
   WORD  width;
   WORD  height;
} DIALOGHEADER;

typedef struct DIALOGCONTROL {
   WORD  x;
   WORD  y;
   WORD  width;
   WORD  height;
   WORD  id;
   DWORD lStyle;
} CONTROLDATA;
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\Windows Undocumented File Formats\wuff_src\CHAP9\W4DECOMP\W4DECOMP.H ===
/**********************************************************************
 *
 * PROGRAM: W4DECOMP.H
 *
 * PURPOSE: Decompresses a W4 file into a W3 file.
 *
 * Copyright 1997, Mike Wallace and Pete Davis
 *
 * Chapter 9, W3 and W4 File Formats, from Undocumented Windows File Formats,
 * published by R&D Books, an imprint of Miller Freeman, Inc.
 *
 **********************************************************************/

typedef unsigned char  BOOL;
typedef unsigned short WORD;
typedef unsigned char  BYTE;
typedef unsigned long  DWORD;

#define FALSE 0;
#define TRUE 1;

typedef struct tagMZHEADER
{
  int   Magic;
  char  Stuff[58];
  long  OtherOff;
} MZHEADER;

typedef struct tagW4HEADER {
  WORD  Magic;
  WORD  Unknown1;
  WORD  ChunkSize;
  WORD  ChunkCount;
  WORD  DS;
  WORD  Unknown2;
  WORD  Unknown3;
  WORD  Unknown4;
} W4HEADER;

#define MZMAGIC 0x5A4D
#define W4MAGIC 0x3457
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\Windows Undocumented File Formats\wuff_src\CHAP9\W4DECOMP\W4DECOMP.C ===
/**********************************************************************
 *
 * PROGRAM: W4DECOMP.C
 *
 * PURPOSE: Decompresses a W4 file into a W3 file.
 *
 * Copyright 1997, Mike Wallace and Pete Davis
 *
 * Chapter 9, W3 and W4 File Formats, from Undocumented Windows File Formats,
 * published by R&D Books, an imprint of Miller Freeman, Inc.
 *
 **********************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <string.h>
#include "w4decomp.h"

void LoadMiniBuffer(DWORD *pMiniBuffer, 
                    BYTE **pSrcBuffer, 
                    WORD *pBitsUsed,
                    WORD *pBitCount)
{
  while ((*pBitsUsed)--)
  {
    *pMiniBuffer >>= 1;
    if (--(*pBitCount) == 0)
    {
      *pMiniBuffer += (DWORD) **pSrcBuffer << 24l;
      *pSrcBuffer += 1;
      *pBitCount = 8;
    }
  }
}


WORD W4Decompress(BYTE *pSrcBuffer, BYTE *pDestBuffer, WORD nSize)
{ 
  DWORD dwMiniBuffer = 0;
  WORD  nCount, nDepth;     // Count and Depth of a compressed "string"
  WORD  nBitCount;          // How many bits are left before we read
                            // another BYTE into dwMiniBuffer
  WORD  nBitsUsed;          // Number of bits used by the last "code",
                            // a code being a count or depth value.                            
  WORD  nDestIndex;         // Index into pDestBuffer
  WORD  nIndex;

  WORD  tmpSize = nSize;
  
  BYTE  *pTmpBuffer;
  
  pTmpBuffer = pSrcBuffer;
  
  // Load up dwMiniBuffer with first 4 bytes. We want it
  // to look like this:   
  //
  // msb              dwMiniBuffer              lsb
  //  +----------+----------+----------+---------+
  //  |  byte 3  |  byte 2  |  byte 1  |  byte 0 |
  //  +----------+----------+----------+---------+
  //
    
  nDestIndex = 0;           // start at byte 0 of dest buffer
  
  for (nIndex = 0; nIndex <= 3; nIndex++)
    dwMiniBuffer = (dwMiniBuffer >> 8) + ((DWORD)*pSrcBuffer++ << 24);
  
  nBitCount = 8;  // We start with 8 bits left before reading another BYTE
  
  nDepth = 1;      // Just allows us into the following loop.
  
  // While nDepth != 0. In other words, if there's nothing left
  // to decompress, then we're done.
  while (nDepth)
  {                     

    // Is the next piece of data an uncompressed byte?
    if (((dwMiniBuffer & 0x0003l) == 0x0001l) ||
        ((dwMiniBuffer & 0x0003l) == 0x0002l))
    {
 
      if (--nSize == 0xFFFF)
      {
        printf("Error: Over-run of data\n");
        return 0;
      }
 
      pDestBuffer[nDestIndex++] = (BYTE)(((dwMiniBuffer & 0x01FCl) >> 2l) |
                                         ((dwMiniBuffer & 0x0001l) << 7l));
      nBitsUsed = 9;
    }
    else // Depth data is compressed
    { 
      // (0-63)
      if ((dwMiniBuffer & 0x0003l) == 0x0000l)
      {
        nDepth = (WORD)((dwMiniBuffer & 0x00FCl) >> 2);
        nBitsUsed = 8;
      }
      // (64-319)
      else if ((dwMiniBuffer & 0x0007l) == 0x0003l)
      {
        nDepth = (WORD)((dwMiniBuffer & 0x07F8l) >> 3) + 0x0040;
        nBitsUsed = 11;
      }
      // (320-4414)
      else if ((dwMiniBuffer & 0x0007l) == 0x0007l)
      {
        nDepth = (WORD)((dwMiniBuffer & 0x07FF8l) >> 3) + 0x0140;
        nBitsUsed = 15;
      }
      else
      {
        printf("Error, invalid depth data. \n");
        return 0;
      }
          
      // If depth isn't 0 and not a CheckBuffer,
      // load buffer, as needed.
      if ((nDepth) && 
          (nDepth != 0x113F)) // 0x113F == (4415 - 320)
      {
        LoadMiniBuffer(&dwMiniBuffer, &pSrcBuffer, &nBitsUsed, &nBitCount);
        
        // Get count
        if ((dwMiniBuffer & 0x00001l) == 0x00001l) // 2
        {
          nCount = 2;
          nBitsUsed = 1;
        }
        else if ((dwMiniBuffer & 0x00003l) == 0x0002l) // 3-4
        {
          nCount = (WORD)((dwMiniBuffer & 0x0004l) >> 2l) + 3;
          nBitsUsed = 3;
        }
        else if ((dwMiniBuffer & 0x00007l) == 0x00004l) // 5-8
        {
          nCount = (WORD)((dwMiniBuffer & 0x00018l) >> 3l) + 5;
          nBitsUsed = 5;
        }
        else if ((dwMiniBuffer & 0x0000Fl) == 0x0008l) // 9-16
        {
          nCount = (WORD)((dwMiniBuffer & 0x00070l) >> 4l) + 9;
          nBitsUsed = 7;
        }
        else if ((dwMiniBuffer & 0x0001Fl) == 0x0010l) // 17-32
        {
          nCount = (WORD)((dwMiniBuffer & 0x001E0l) >> 5l) + 17;
          nBitsUsed = 9;
        }
        else if ((dwMiniBuffer & 0x0003Fl) == 0x00020l) // 33-64
        {
          nCount = (WORD)((dwMiniBuffer & 0x007C0l) >> 6l) + 33;
          nBitsUsed = 11;
        }
        else if ((dwMiniBuffer & 0x0007Fl) == 0x00040l) // 65-128
        {
          nCount = (WORD)((dwMiniBuffer & 0x01F80l) >> 7l) + 65;
          nBitsUsed = 13;
        }
        else if ((dwMiniBuffer & 0x000FFl) == 0x00080l) // 129-256
        {
          nCount = (WORD)((dwMiniBuffer & 0x07F00l) >> 8l) + 129;
          nBitsUsed = 15;
        }
        else if ((dwMiniBuffer & 0x001FFl) == 0x00100l) // 257-512
        {
          nCount = (WORD)((dwMiniBuffer & 0x01FE00l) >> 9l) + 257;
          nBitsUsed = 17;
        }
        else
        {
          // Bad data, but handle as if it were a quit condition
          printf("Bad count data, quiting at current point.\n");
          nDepth = 0;
          nCount = 0;
          nBitsUsed = 9;
        }
  
        // Copy "nCount" bytes of data from "nDepth" bytes back,      
        while (nCount--)
        {
          if (--nSize == 0xFFFF)
          {
            printf("Error: Over-run of data\n");
            return 0;
          }
          
          pDestBuffer[nDestIndex] = pDestBuffer[nDestIndex - nDepth];
          nDestIndex++;
        }
      }
      else
      {
        // If we get a Check Buffer and
        // size of the remaining data is 0,
        // then we're done.
        if ((nDepth == 0x113F) &&
            (nSize == 0x0000))
        { 
          nDepth = 0;
        }
      }
        
    } // else
    
    LoadMiniBuffer(&dwMiniBuffer, &pSrcBuffer, &nBitsUsed, &nBitCount);
    
  } // while(nDepth)

  return nDestIndex;
}

int ExtractW3(FILE *W4File, char *filename)
{
  FILE     *W3File;
  MZHEADER mzHeader;
  W4HEADER w4Header;
  DWORD    *pChunkTable;
  DWORD    start, end;
  BYTE     *pSrcBuffer, *pDestBuffer;
  WORD     nChunkIndex;
  WORD     nDestSize;
  DWORD    i;

  if ((W3File = fopen("LIBRARY.W3", "wb")) == NULL) 
  {
    printf("Unable to open file LIBRARY.W3 for output\n");
    return 1;
  }

  fread(&mzHeader, sizeof(mzHeader), 1, W4File);
  if (mzHeader.Magic != MZMAGIC)
  {
    printf("Not an executable file.\n");
    return 1;
  }
  
  fseek(W4File, mzHeader.OtherOff, SEEK_SET);
  
  fread(&w4Header, sizeof(w4Header), 1, W4File);
  
  if (w4Header.Magic != W4MAGIC)
  {
    printf("Not a W4 file.\n");
    fclose(W3File);
    return 1;
  }

  // Allocate space for chunk table
  pChunkTable = malloc(w4Header.ChunkCount * 4);
  
  if (pChunkTable == NULL)
  {
    printf("Not enough memory to allocate chunk table.\n");
    return 1;
  }

  // Allocate space for source buffer
  pSrcBuffer = malloc(w4Header.ChunkSize);
  
  if (pSrcBuffer == NULL)
  {
    printf("Not enough memory for source buffer.\n");
    return 1;
  }
  
  // Allocate space for destination buffer
  pDestBuffer = malloc(w4Header.ChunkSize * 2);
  
  if (pDestBuffer == NULL)
  {
    printf("Not enough memory for destination buffer.\n");
    return 1;
  }
  
  // Read chunk table
  fread(pChunkTable, w4Header.ChunkCount, 4, W4File);

  // Pad W3File so that offsets in the list of VxDs
  // will match up.
  printf("Padding W3 File.\n");
  fwrite(&mzHeader, sizeof(mzHeader), 1, W3File);
  
  end = mzHeader.OtherOff - sizeof(mzHeader);
  for (i = 0; i < end; i++)
  {
    fputc(0, W3File);
  }

  for (nChunkIndex = 0; nChunkIndex < w4Header.ChunkCount; nChunkIndex++)
  {
    start = pChunkTable[nChunkIndex];
    
    if (nChunkIndex == w4Header.ChunkCount)
    {
      end = fseek(W4File, 0l, SEEK_END);
    }
    else
    {
      end = pChunkTable[nChunkIndex + 1];
    }

    printf("Decompressing chunk %d   -   Compressed Size %d\n", nChunkIndex, (end - start));    
    // Go to and read the current chunk
    // Note: This code assumes that the chunk size
    //       is not beyond the ability of fread.
    fseek(W4File, start, SEEK_SET);
    fread(pSrcBuffer, (WORD)(end - start), 1, W4File);

    // Fill destination buffer with clear marker
    memset(pDestBuffer, 0xE5, w4Header.ChunkSize);
    
    if ((WORD)(end - start) != w4Header.ChunkSize)
    {
      nDestSize = W4Decompress(pSrcBuffer, pDestBuffer, w4Header.ChunkSize);
      
      // This is an error condition.
      if (!nDestSize)
      {
        fclose(W3File);
        return 1;
      }
      
      fwrite(pDestBuffer, (WORD)nDestSize, 1, W3File);
    }
    else
    {
      fwrite(pSrcBuffer, (WORD)(end - start), 1, W3File);
    }
  }
  
  fclose(W3File);
  free(pChunkTable);
  free(pSrcBuffer);
  free(pDestBuffer);
}


void Usage(void)
{
  printf("Usage: W4DECOMP W4Name\n\n");
  printf("W4Name   is the name of the W4 executable, probably\n");
  printf("         VMM32.VXD\n");
}

int main(int argc, char *argv[]) 
{

  char  filename[256];
  FILE  *W4File;

  if (argc < 2) {
    Usage();
    return 1;
  }
  
  strcpy(filename, argv[1]);
  
  if (!strchr(filename, '.'))
    strcat(filename, ".EXE");
    
  if ((W4File = fopen(filename, "rb")) == NULL) 
  {
    printf("%s does not exist!\n", filename);
    return 1;
  }
  
  ExtractW3(W4File, filename);

  fclose(W4File);
  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\Windows Undocumented File Formats\wuff_src\CHAP9\SUCKW3\SUCKW3.H ===
/**********************************************************************
 *
 * PROGRAM: SUCKW3.H
 *
 * PURPOSE: Extracts VxDs from a W3 file.
 *
 * Copyright 1997, Mike Wallace and Pete Davis
 *
 * Chapter 9, W3 and W4 File Formats, from Undocumented Windows File Formats,
 * published by R&D Books, an imprint of Miller Freeman, Inc.
 *
 **********************************************************************/

typedef unsigned short WORD;
typedef unsigned char BYTE;
typedef unsigned long DWORD;
typedef unsigned char BOOL;

#define TRUE	1
#define FALSE	0

typedef struct tagMZHEADER
{
	char	MZMagic[2];
	char	Stuff[58];
	long	OtherOff;
} MZHEADER;

typedef struct tagW3HEADER
{
	char	W3Magic[2];
	WORD	WinVer;
	WORD	NumVxDs;
	BYTE	Reserved[10];
} W3HEADER;

typedef struct tagVxDRECORD
{
	char	VxDName[8];
	long	VxDStart;
	long	VxDHdrSize;
} VxDRECORD;



/* LE Header structure */
typedef struct tagLEHEADER
{
	char	LEMagic[2];
	BYTE	ByteOrder;
	BYTE	WordOrder;
	DWORD	FormatLevel;
	WORD	CPUType;
	WORD	OSType;
	DWORD	ModuleVer;
	DWORD	ModuleFlags;
	DWORD	NumPages;
	DWORD	EIPObjNum;
	DWORD	EIP;
	DWORD	ESPObjNum;
	DWORD	ESP;
	DWORD	PageSize;
	DWORD	LastPageSize;
	DWORD	FixupSize;
	DWORD	FixupChecksum;
	DWORD	LoaderSize;
	DWORD	LoaderChecksum;
	DWORD	ObjTblOffset;
	DWORD	NumObjects;
	DWORD	ObjPageTbl;
	DWORD	ObjIterPage;
	DWORD	ResourceTbl;
	DWORD	NumResources;
	DWORD	ResNameTable;
	DWORD	EntryTable;
	DWORD	ModDirectTable;
	DWORD	NumModDirect;
	DWORD	FixUpPageTable;
	DWORD	FixUpRecTable;
	DWORD	ImportModTable;
	DWORD	NumImports;
	DWORD	ImportProcTable;
	DWORD	PerPageChecksum;
	DWORD	DataPages;
	DWORD	NumPreloadPages;
	DWORD	NonResTable;
	DWORD	NonResSize;
	DWORD	NonResChecksum;
	DWORD	AutoDSObj;
	DWORD	DebugInfoOff;
	DWORD	DebugInfoLen;
	DWORD	NumInstPreload;
	DWORD	NumInstDemand;
	DWORD	HeapSize;
} LEHEADER;
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\inc\ntdlltrc.h ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    NtdllTracer.h

Abstract:

	This file contains structures and functions definitions used in Ntdll 
	events tracing


--*/

#ifndef _NTDLL_WMI_TRACE_
#define _NTDLL_WMI_TRACE_

#define MEMORY_FROM_LOOKASIDE					1		//Activity from LookAside
#define MEMORY_FROM_LOWFRAG						2		//Activity from Low Frag Heap
#define MEMORY_FROM_MAINPATH					3		//Activity from Main Code Path
#define MEMORY_FROM_SLOWPATH                    4       //Activity from Slow Code Path

#define LOG_LOOKASIDE                           0x00000001       //Bit for LookAside trace

#define FAILED_TLSINDEX			-1
#define MAX_PID                 10

#ifndef UserSharedData
#define UserSharedData USER_SHARED_DATA
#endif

#define IN_TRACING    0x00000001      // Flag to see if this thread is tracing.
extern BOOLEAN bNtdllTrace;

#define IsCritSecLogging(CriticalSection) ((USER_SHARED_DATA->TraceLogging & ENABLECRITSECTRACE) \
    &&(bNtdllTrace || GlobalCounter != (USER_SHARED_DATA->TraceLogging >> 16)) \
    &&((HandleToUlong(NtCurrentTeb()->EtwTraceData) & IN_TRACING) != IN_TRACING))

extern 
ULONG GlobalCounter;

#define IsHeapLogging(HeapHandle) (USER_SHARED_DATA->TraceLogging & ENABLEHEAPTRACE &&\
    (bNtdllTrace || GlobalCounter != (USER_SHARED_DATA->TraceLogging >> 16))&& \
    ((HandleToUlong(NtCurrentTeb()->EtwTraceData) & IN_TRACING) != IN_TRACING))

//
// When calling from deep inside heap allocation routines, we do not want to 
// be initializing ETW process heap since that gets into recursive behaviour. 
//

#define IsDeepHeapLogging(HeapHandle) (USER_SHARED_DATA->TraceLogging & ENABLEHEAPTRACE &&\
    (bNtdllTrace || GlobalCounter != (USER_SHARED_DATA->TraceLogging >> 16))&& \
    (EtwpProcessHeap != NULL) && \
    ((HandleToUlong(NtCurrentTeb()->EtwTraceData) & IN_TRACING) != IN_TRACING))


typedef struct _THREAD_LOCAL_DATA THREAD_LOCAL_DATA, *PTHREAD_LOCAL_DATA, **PPTHREAD_LOCAL_DATA;

typedef struct _THREAD_LOCAL_DATA {

	PTHREAD_LOCAL_DATA  FLink;					//Forward Link
	PTHREAD_LOCAL_DATA  BLink;					//Backward Link
	PWMI_BUFFER_HEADER  pBuffer;				//Pointer to thread buffer info.
    LONG                ReferenceCount;

} THREAD_LOCAL_DATA, *PTHREAD_LOCAL_DATA, **PPTHREAD_LOCAL_DATA;

extern 
PVOID EtwpProcessHeap;

#ifndef EtwpGetCycleCount

__int64
EtwpGetCycleCount();

#endif // EtwpGetCycleCount

void 
ReleaseBufferLocation(PTHREAD_LOCAL_DATA pThreadLocalData);

NTSTATUS 
AcquireBufferLocation(PVOID *pEvent, PPTHREAD_LOCAL_DATA pThreadLocalData, PUSHORT ReqSize);

typedef struct _NTDLL_EVENT_COMMON {

  PVOID Handle;		        //Handle of Heap

}NTDLL_EVENT_COMMON, *PNTDLL_EVENT_COMMON;


typedef struct _NTDLL_EVENT_HANDLES {

	RTL_CRITICAL_SECTION	CriticalSection;			//Critical section
	ULONG					dwTlsIndex;					//TLS Index
	TRACEHANDLE				hRegistrationHandle;		//Registration Handle used for Unregistration.
	TRACEHANDLE				hLoggerHandle;				//Handle to Trace Logger
	PTHREAD_LOCAL_DATA		pThreadListHead;	        //Link List that contains all threads info invovled in tracing.

}NTDLL_EVENT_HANDLES, *PNTDLL_EVENT_HANDLES, **PPNTDLL_EVENT_HANDLES;

extern LONG TraceLevel;
extern PNTDLL_EVENT_HANDLES NtdllTraceHandles;
extern RTL_CRITICAL_SECTION UMLogCritSect;
extern RTL_CRITICAL_SECTION PMCritSect;
extern RTL_CRITICAL_SECTION LoaderLock;

#endif //_NTDLL_WMI_TRACE_
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\BUILD\WARNING.h ===
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#pragma warning(3:4092)   // sizeof returns 'unsigned long'
#pragma warning(4:4096)   // '__cdecl' must be used with '...'
#pragma warning(4:4121)   // structure is sensitive to alignment
#pragma warning(3:4125)   // decimal digit in octal sequence
#pragma warning(3:4130)   // logical operation on address of string constant
#pragma warning(3:4132)   // const object should be initialized
#if _DBG_MEMCPY_INLINE_
#pragma warning(disable:4163) // not available as an intrinsic function
#endif
#pragma warning(4:4206)   // Source File is empty
#pragma warning(4:4101)   // Unreferenced local variable
#pragma warning(4:4208)   // delete[exp] - exp evaluated but ignored
#pragma warning(3:4212)   // function declaration used ellipsis
#pragma warning(3:4242)   // convertion possible loss of data
#pragma warning(4:4267)   // convertion from size_t to smaller type
#pragma warning(4:4312)   // conversion to type of greater size
#pragma warning(disable:4324)  // structure padded due to __declspec(align())
#pragma warning(error:4700)    // Local used w/o being initialized
#pragma warning(error:4259)    // pure virtual function was not defined
#pragma warning(disable:4071)  // no function prototype given - formals unspecified
#pragma warning(error:4013)    // function' undefined - assuming extern returning int
#pragma warning(error:4551)    // Function call missing argument list
#pragma warning(error:4806)    // unsafe operation involving type 'bool'
#pragma warning(4:4509)   // use of SEH with destructor
#pragma warning(4:4177)   // pragma data_seg s/b at global scope
#pragma warning(disable:4274)  // #ident ignored
#pragma warning(disable:4786)  // identifier was truncated to 255 characters in debug information.
#pragma warning(disable:4503)  // decorated name length exceeded, name was truncated.
#pragma warning(disable:4263)  // Derived override doesn't match base - who cares...
#pragma warning(disable:4264)  // base function is hidden - again who cares.
#pragma warning(disable:4710)  // Function marked as inline - wasn't
#pragma warning(disable:4917)  // A GUID can only be associated with a class, interface or namespace
#pragma warning(error:4552)    // <<, >> ops used to no effect (probably missing an = sign)
#pragma warning(error:4553)    // == op used w/o effect (probably s/b an = sign)
#pragma warning(3:4288)   // nonstandard extension used (loop counter)
#pragma warning(3:4532)   // jump out of __finally block
#pragma warning(error:4312)  // cast of 32-bit int to 64-bit ptr
#pragma warning(error:4296)  // expression is always true/false
#pragma warning(3:4546)   // function call before comma missing argument list
// disable until __noop(arg,arg,arg) doesn't generate false hits.
// #pragma warning(3:4547)   // '<' : operator before comma has no effect; expected operator with side-effect
// #pragma warning(3:4548)   // expression before comma has no effect; expected expression with side-effect

#pragma warning(disable:4197)   // illegal use of const/volatile: qualifier ignored (disabled until sources fixed)
#pragma warning(disable:4675)	// picked overload found via Koenig lookup
#pragma warning(disable:4356)	// static member cannot be initialized via derived class

#ifndef __cplusplus
#undef try
#undef except
#undef finally
#undef leave
#define try                         __try
#define except                      __except
#define finally                     __finally
#define leave                       __leave
#endif

#if _MSC_VER <= 1400
#pragma warning(disable: 4068)	// turn off unknown pragma warning so prefast pragmas won't show
				// show up in build.wrn/build.err
#endif

#if defined(_M_IX86) && _MSC_FULL_VER >= 13102154
#define __TYPENAME typename
#else
#define __TYPENAME
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\cache\cc.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cc.h

Abstract:

    This module is a header file for the Memory Management based cache
    management routines for the common Cache subsystem.

--*/

#ifndef _CCh_
#define _CCh_

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4115)   // named type definition in parentheses

#include <ntos.h>
#include <NtIoLogc.h>

//
// Define macros to acquire and release cache manager locks.
//

#define CcAcquireMasterLock( OldIrql ) \
    *( OldIrql ) = KeAcquireQueuedSpinLock( LockQueueMasterLock )

#define CcReleaseMasterLock( OldIrql ) \
    KeReleaseQueuedSpinLock( LockQueueMasterLock, OldIrql )

#define CcAcquireMasterLockAtDpcLevel() \
    KeAcquireQueuedSpinLockAtDpcLevel( &KeGetCurrentPrcb()->LockQueue[LockQueueMasterLock] )

#define CcReleaseMasterLockFromDpcLevel() \
    KeReleaseQueuedSpinLockFromDpcLevel( &KeGetCurrentPrcb()->LockQueue[LockQueueMasterLock] )

#define CcAcquireVacbLock( OldIrql ) \
    *( OldIrql ) = KeAcquireQueuedSpinLock( LockQueueVacbLock )

#define CcReleaseVacbLock( OldIrql ) \
    KeReleaseQueuedSpinLock( LockQueueVacbLock, OldIrql )

#define CcAcquireVacbLockAtDpcLevel() \
    KeAcquireQueuedSpinLockAtDpcLevel( &KeGetCurrentPrcb()->LockQueue[LockQueueVacbLock] )

#define CcReleaseVacbLockFromDpcLevel() \
    KeReleaseQueuedSpinLockFromDpcLevel( &KeGetCurrentPrcb()->LockQueue[LockQueueVacbLock] )

#define CcAcquireWorkQueueLock( OldIrql ) \
    *( OldIrql ) = KeAcquireQueuedSpinLock( LockQueueWorkQueueLock )

#define CcReleaseWorkQueueLock( OldIrql ) \
    KeReleaseQueuedSpinLock( LockQueueWorkQueueLock, OldIrql )

#define CcAcquireWorkQueueLockAtDpcLevel() \
    KeAcquireQueuedSpinLockAtDpcLevel( &KeGetCurrentPrcb()->LockQueue[LockQueueWorkQueueLock] )

#define CcReleaseWorkQueueLockFromDpcLevel() \
    KeReleaseQueuedSpinLockFromDpcLevel( &KeGetCurrentPrcb()->LockQueue[LockQueueWorkQueueLock] )

#include <FsRtl.h>

//
//  Peek at number of available pages.
//

extern PFN_NUMBER MmAvailablePages;

//
//  Define our node type codes.
//

#define CACHE_NTC_SHARED_CACHE_MAP       (0x2FF)
#define CACHE_NTC_PRIVATE_CACHE_MAP      (0x2FE)
#define CACHE_NTC_BCB                    (0x2FD)
#define CACHE_NTC_DEFERRED_WRITE         (0x2FC)
#define CACHE_NTC_MBCB                   (0x2FB)
#define CACHE_NTC_OBCB                   (0x2FA)
#define CACHE_NTC_MBCB_GRANDE            (0x2F9)

//
//  The following definitions are used to generate meaningful blue bugcheck
//  screens.  On a bugcheck the file system can output 4 ulongs of useful
//  information.  The first ulong will have encoded in it a source file id
//  (in the high word) and the line number of the bugcheck (in the low word).
//  The other values can be whatever the caller of the bugcheck routine deems
//  necessary.
//
//  Each individual file that calls bugcheck needs to have defined at the
//  start of the file a constant called BugCheckFileId with one of the
//  CACHE_BUG_CHECK_ values defined below and then use CcBugCheck to bugcheck
//  the system.
//

#define CACHE_BUG_CHECK_CACHEDAT           (0x00010000)
#define CACHE_BUG_CHECK_CACHESUB           (0x00020000)
#define CACHE_BUG_CHECK_COPYSUP            (0x00030000)
#define CACHE_BUG_CHECK_FSSUP              (0x00040000)
#define CACHE_BUG_CHECK_LAZYRITE           (0x00050000)
#define CACHE_BUG_CHECK_LOGSUP             (0x00060000)
#define CACHE_BUG_CHECK_MDLSUP             (0x00070000)
#define CACHE_BUG_CHECK_PINSUP             (0x00080000)
#define CACHE_BUG_CHECK_VACBSUP            (0x00090000)

#define CcBugCheck(A,B,C) { KeBugCheckEx(CACHE_MANAGER, BugCheckFileId | __LINE__, A, B, C ); }

//
//  Define maximum View Size (These constants are currently so chosen so
//  as to be exactly a page worth of PTEs.
//

#define DEFAULT_CREATE_MODULO            ((ULONG)(0x00100000))
#define DEFAULT_EXTEND_MODULO            ((ULONG)(0x00100000))

//
//  For non FO_RANDOM_ACCESS files, define how far we go before umapping
//  views.
//

#define SEQUENTIAL_MAP_LIMIT        ((ULONG)(0x00080000))

//
//  Define some constants to drive read ahead and write behind
//

//
//  Set max read ahead.  Even though some drivers, such as AT, break up transfers >= 128kb,
//  we need to permit enough readahead to satisfy plausible cached read operation while
//  preventing denial of service attacks.
//
//  This value used to be set to 64k.  When doing cached reads in larger units (128k), we
//  would never be bringing in enough data to keep the user from blocking. 8mb is
//  arbitrarily chosen to be greater than plausible RAID bandwidth and user operation size
//  by a factor of 3-4.
//

#define MAX_READ_AHEAD                   (8 * 1024 * 1024)

//
//  Set maximum write behind / lazy write (most drivers break up transfers >= 64kb)
//

#define MAX_WRITE_BEHIND                 (MM_MAXIMUM_DISK_IO_SIZE)

//
//  Set a throttle for charging a given write against the total number of dirty
//  pages in the system, for the purpose of seeing when we should invoke write
//  throttling.
//
//  This must be the same as the throttle used for seeing when we must flush
//  temporary files in the lazy writer.  On the back of the envelope, here
//  is why:
//
//      RDP = Regular File Dirty Pages
//      TDP = Temporary File Dirty Pages
//      CWT = Charged Write Throttle
//          -> the maximum we will charge a user with when we see if
//              he should be throttled
//      TWT = Temporary Write Throttle
//          -> if we can't write this many pages, we must write temp data
//      DPT = Dirty Page Threshold
//          -> the limit when write throttling kicks in
//
//      PTD = Pages To Dirty
//      CDP = Charged Dirty Pages
//
//      Now, CDP = Min( PTD, CWT).
//
//      Excluding other effects, we throttle when:
//          #0  (RDP + TDP) + CPD >= DPT
//
//      To write temporary data, we must cause:
//          #1  (RDP + TDP) + TWT >= DPT
//
//      To release the throttle, we must eventually cause:
//          #2  (RDP + TDP) + CDP < DPT
//
//      Now, imagine TDP >> RDP (perhaps RDP == 0) and CDP == CWT for a particular
//      throttled write.
//
//      If CWT > TWT, as we drive RDP to zero (we never defer writing regular
//      data except for hotspots or other very temporary conditions), it is clear
//      that we may never trigger the writing of temporary data (#1) but also
//      never release the throttle (#2).  Simply, we would be willing to charge
//      for more dirty pages than we would be willing to guarantee are available
//      to dirty.  Hence, potential deadlock.
//
//      CWT < TWT I leave aside for the moment.  This would mean we try not to
//      allow temporary data to accumulate to the point that writes throttle as
//      a result.  Perhaps this would even be better than CWT == TWT.
//
//  It is legitimate to ask if throttling temporary data writes should be relaxed
//  if we see a large amount of dirty temp data accumulate (and it would be very
//  easy to keep track of this).  I don't claim to know the best answer to this,
//  but for now the attempt to avoid temporary data writes at all costs still
//  fits the reasonable operation mix, and we will only penalize the outside
//  oddcase with a little more throttle/release.
//

#define WRITE_CHARGE_THRESHOLD          (64 * PAGE_SIZE)

//
//  Define constants to control zeroing of file data: one constant to control
//  how much data we will actually zero ahead in the cache, and another to
//  control what the maximum transfer size is that we will use to write zeros.
//

#define MAX_ZERO_TRANSFER               (PAGE_SIZE * 128)
#define MIN_ZERO_TRANSFER               (0x10000)
#define MAX_ZEROS_IN_CACHE              (0x10000)

//
//  Definitions for multi-level Vacb structure.  The primary definition is the
//  VACB_LEVEL_SHIFT.  In a multi-level Vacb structure, level in the tree of
//  pointers has 2 ** VACB_LEVEL_SHIFT pointers.
//
//  For test, this value may be set as low as 4 (no lower), a value of 10 corresponds
//  to a convenient block size of 4KB.  (If set to 2, CcExtendVacbArray will try to
//  "push" the Vacb array allocated within the SharedCacheMap, and later someone will
//  try to deallocate the middle of the SharedCacheMap.  At 3, the MBCB_BITMAP_BLOCK_SIZE
//  is larger than MBCB_BITMAP_BLOCK_SIZE)
//
//  There is a bit of a trick as we make the jump to the multilevel structure in that
//  we need a real fixed reference count.
//

#define VACB_LEVEL_SHIFT                  (7)

//
//  This is how many bytes of pointers are at each level.  This is the size for both
//  the Vacb array and (optional) Bcb listheads.  It does not include the reference
//  block.
//

#define VACB_LEVEL_BLOCK_SIZE             ((1 << VACB_LEVEL_SHIFT) * sizeof(PVOID))

//
//  This is the last index for a level.
//

#define VACB_LAST_INDEX_FOR_LEVEL         ((1 << VACB_LEVEL_SHIFT) - 1)

//
//  This is the size of file which can be handled in a single level.
//

#define VACB_SIZE_OF_FIRST_LEVEL         (1 << (VACB_OFFSET_SHIFT + VACB_LEVEL_SHIFT))

//
//  This is the maximum number of levels it takes to support 63-bits.  It is
//  used for routines that must remember a path.
//

#define VACB_NUMBER_OF_LEVELS            (((63 - VACB_OFFSET_SHIFT)/VACB_LEVEL_SHIFT) + 1)

//
//  Define the reference structure for multilevel Vacb trees.
//

typedef struct _VACB_LEVEL_REFERENCE {

    LONG Reference;
    LONG SpecialReference;

} VACB_LEVEL_REFERENCE, *PVACB_LEVEL_REFERENCE;

//
//  Define the size of a bitmap allocated for a bitmap range, in bytes.
//

#define MBCB_BITMAP_BLOCK_SIZE           (VACB_LEVEL_BLOCK_SIZE)

//
//  Define how many bytes of a file are covered by an Mbcb bitmap range,
//  at a bit for each page.
//

#define MBCB_BITMAP_RANGE                (MBCB_BITMAP_BLOCK_SIZE * 8 * PAGE_SIZE)

//
//  Define the initial size of the Mbcb bitmap that is self-contained in the Mbcb.
//

#define MBCB_BITMAP_INITIAL_SIZE         (2 * sizeof(BITMAP_RANGE))

//
//  Define constants controlling when the Bcb list is broken into a
//  pendaflex-style array of listheads, and how the correct listhead
//  is found.  Begin when file size exceeds 2MB, and cover 512KB per
//  listhead.  At 512KB per listhead, the BcbListArray is the same
//  size as the Vacb array, i.e., it doubles the size.
//
//  The code handling these Bcb lists in the Vacb package contains
//  assumptions that the size is the same as that of the Vacb pointers.
//  Future work could undo this, but until then the size and shift
//  below cannot change.  There really isn't a good reason to want to
//  anyway.
//
//  Note that by definition a flat vacb array cannot fail to find an
//  exact match when searching for the listhead - this is only a
//  complication of the sparse structure.
//


#define BEGIN_BCB_LIST_ARRAY             (0x200000)
#define SIZE_PER_BCB_LIST                (VACB_MAPPING_GRANULARITY * 2)
#define BCB_LIST_SHIFT                   (VACB_OFFSET_SHIFT + 1)

//
//  Macros to lock/unlock a Vacb level as Bcbs are inserted/deleted
//

#define CcLockVacbLevel(SCM,OFF) {                                                               \
    if (((SCM)->SectionSize.QuadPart > VACB_SIZE_OF_FIRST_LEVEL) &&                              \
        FlagOn(SharedCacheMap->Flags, MODIFIED_WRITE_DISABLED)) {                                \
    CcAdjustVacbLevelLockCount((SCM),(OFF), +1);}                                                \
}

#define CcUnlockVacbLevel(SCM,OFF) {                                                             \
    if (((SCM)->SectionSize.QuadPart > VACB_SIZE_OF_FIRST_LEVEL) &&                              \
        FlagOn(SharedCacheMap->Flags, MODIFIED_WRITE_DISABLED)) {                                \
    CcAdjustVacbLevelLockCount((SCM),(OFF), -1);}                                                \
}

//
//  NOISE_BITS defines how many bits are masked off when testing for
//  sequential reads.  This allows the reader to skip up to 7 bytes
//  for alignment purposes, and we still consider the next read to be
//  sequential.  Starting and ending addresses are masked by this pattern
//  before comparison.
//

#define NOISE_BITS                       (0x7)

//
//  Define some constants to drive the Lazy Writer
//

#define LAZY_WRITER_IDLE_DELAY           ((LONG)(10000000))
#define LAZY_WRITER_COLLISION_DELAY      ((LONG)(1000000))

//
// the wait is in 100 nanosecond units to 10,000,000 = 1 second
//

#define NANO_FULL_SECOND ((LONGLONG)10000000)

//
//  The following target should best be a power of 2
//

#define LAZY_WRITER_MAX_AGE_TARGET       ((ULONG)(8))

//
//  Requeue information hint for the lazy writer.
//

#define CC_REQUEUE                       35422

//
//  The global Cache Manager debug level variable, its values are:
//
//      0x00000000      Always gets printed (used when about to bugcheck)
//
//      0x00000001      FsSup
//      0x00000002      CacheSub
//      0x00000004      CopySup
//      0x00000008      PinSup
//
//      0x00000010      MdlSup
//      0x00000020      LazyRite
//      0x00000040
//      0x00000080
//
//      0x00000100      Trace all Mm calls
//

#define mm (0x100)

//
//  Miscellaneous support macros.
//
//      ULONG
//      FlagOn (
//          IN ULONG Flags,
//          IN ULONG SingleFlag
//          );
//
//      BOOLEAN
//      BooleanFlagOn (
//          IN ULONG Flags,
//          IN ULONG SingleFlag
//          );
//
//      VOID
//      SetFlag (
//          IN ULONG Flags,
//          IN ULONG SingleFlag
//          );
//
//      VOID
//      ClearFlag (
//          IN ULONG Flags,
//          IN ULONG SingleFlag
//          );
//
//      ULONG
//      QuadAlign (
//          IN ULONG Pointer
//          );
//

#define FlagOn(F,SF) ( \
    (((F) & (SF)))     \
)

#define BooleanFlagOn(F,SF) (    \
    (BOOLEAN)(((F) & (SF)) != 0) \
)

#define SetFlag(F,SF) { \
    (F) |= (SF);        \
}

#define ClearFlag(F,SF) { \
    (F) &= ~(SF);         \
}

#define QuadAlign(P) (             \
    ((((P)) + 7) & (-8)) \
)

#define AlignedToSize(_Amount, _Size)                      \
    (ULONG)((((ULONG_PTR)(_Amount)) + ((_Size)-1)) & ~(ULONG_PTR) ((_Size) - 1))

#define Add2Ptr(P,I) ((PVOID)((PUCHAR)(P) + (I)))

//
//  These macros are used to control the flag bit in CACHE_UNINITIALIZE_EVENT
//  structures.  We need a way to flag that the component waiting in Mm without
//  changing the CACHE_UNINITIALIZE_EVENT structure size, therefore, we set the
//  low bit to denote this.
//

#define SetMmWaiterFlag(TYPE, PTR) (TYPE)((ULONG_PTR)(PTR) | 1)
#define ClearMmWaiterFlag(TYPE, PTR) (TYPE)((ULONG_PTR)(PTR) & -2)
#define TestMmWaiterFlag(PTR) ((ULONG_PTR)(PTR) & 1)


//
//  Define the Virtual Address Control Block, which controls all mapping
//  performed by the Cache Manager.
//

//
//  First some constants
//

#define PREALLOCATED_VACBS               (4)

//
//  Virtual Address Control Block
//

typedef struct _VACB {

    //
    //  Base Address for this control block.
    //

    PVOID BaseAddress;

    //
    //  Pointer to the Shared Cache Map using this Vacb.
    //

    struct _SHARED_CACHE_MAP *SharedCacheMap;

    //
    //  Overlay for remembering mapped offset within the Shared Cache Map,
    //  and the count of the number of times this Vacb is in use.
    //

    union {

        //
        //  File Offset within Shared Cache Map
        //

        LARGE_INTEGER FileOffset;

        //
        //  Count of number of times this Vacb is in use.  The size of this
        //  count is calculated to be adequate, while never large enough to
        //  overwrite nonzero bits of the FileOffset, which is a multiple
        //  of VACB_MAPPING_GRANULARITY.
        //

        USHORT ActiveCount;

    } Overlay;

    //
    //  Entry for the VACB reuse list
    //

    LIST_ENTRY LruList;

} VACB, *PVACB;

//
//  These define special flag values that are overloaded as PVACB.  They cause
//  certain special behavior, currently only in the case of multilevel structures.
//

#define VACB_SPECIAL_REFERENCE           ((PVACB) ~0)
#define VACB_SPECIAL_DEREFERENCE         ((PVACB) ~1)

#define VACB_SPECIAL_FIRST_VALID         VACB_SPECIAL_DEREFERENCE



#define PRIVATE_CACHE_MAP_READ_AHEAD_ACTIVE     0x10000
#define PRIVATE_CACHE_MAP_READ_AHEAD_ENABLED    0x20000

typedef struct _PRIVATE_CACHE_MAP_FLAGS {
    ULONG DontUse : 16;                     // Overlaid with NodeTypeCode

    //
    //  This flag says read ahead is currently active, which means either
    //  a file system call to CcReadAhead is still determining if the
    //  desired data is already resident, or else a request to do read ahead
    //  has been queued to a worker thread.
    //

    ULONG ReadAheadActive : 1;

    //
    //  Flag to say whether read ahead is currently enabled for this
    //  FileObject/PrivateCacheMap.  On read misses it is enabled on
    //  read ahead hits it will be disabled.  Initially disabled.
    //

    ULONG ReadAheadEnabled : 1;

    ULONG Available : 14;
} PRIVATE_CACHE_MAP_FLAGS;

#define CC_SET_PRIVATE_CACHE_MAP(PrivateCacheMap, Flags) \
    RtlInterlockedSetBitsDiscardReturn (&PrivateCacheMap->UlongFlags, Flags);

#define CC_CLEAR_PRIVATE_CACHE_MAP(PrivateCacheMap, Feature) \
    RtlInterlockedAndBitsDiscardReturn (&PrivateCacheMap->UlongFlags, (ULONG)~Feature);

//
//  The Private Cache Map is a structure pointed to by the File Object, whenever
//  a file is opened with caching enabled (default).
//

typedef struct _PRIVATE_CACHE_MAP {

    //
    //  Type and size of this record
    //

    union {
        CSHORT NodeTypeCode;
        PRIVATE_CACHE_MAP_FLAGS Flags;
        ULONG UlongFlags;
    };

    //
    //  Read Ahead mask formed from Read Ahead granularity - 1.
    //  Private Cache Map ReadAheadSpinLock controls access to this field.
    //

    ULONG ReadAheadMask;

    //
    //  Pointer to FileObject for this PrivateCacheMap.
    //

    PFILE_OBJECT FileObject;

    //
    //  READ AHEAD CONTROL
    //
    //  Read ahead history for determining when read ahead might be
    //  beneficial.
    //

    LARGE_INTEGER FileOffset1;
    LARGE_INTEGER BeyondLastByte1;

    LARGE_INTEGER FileOffset2;
    LARGE_INTEGER BeyondLastByte2;

    //
    //  Current read ahead requirements.
    //
    //  Array element 0 is optionally used for recording remaining bytes
    //  required for satisfying a large Mdl read.
    //
    //  Array element 1 is used for predicted read ahead.
    //

    LARGE_INTEGER ReadAheadOffset[2];
    ULONG ReadAheadLength[2];

    //
    //  SpinLock controlling access to following fields
    //

    KSPIN_LOCK ReadAheadSpinLock;

    //
    // Links for list of all PrivateCacheMaps linked to the same
    // SharedCacheMap.
    //

    LIST_ENTRY PrivateLinks;

} PRIVATE_CACHE_MAP;

typedef PRIVATE_CACHE_MAP *PPRIVATE_CACHE_MAP;


//
//  The Shared Cache Map is a per-file structure pointed to indirectly by
//  each File Object.  The File Object points to a pointer in a single
//  FS-private structure for the file (Fcb).  The SharedCacheMap maps the
//  first part of the file for common access by all callers.
//

#define CcAddOpenToLog( LOG, ACTION, REASON )

#define CcIncrementOpenCount( SCM, REASON ) {               \
    (SCM)->OpenCount += 1;                                  \
    if (REASON != 0) {                                      \
        CcAddOpenToLog( &(SCM)->OpenCountLog, REASON, 1 );  \
    }                                                       \
}

#define CcDecrementOpenCount( SCM, REASON ) {               \
    (SCM)->OpenCount -= 1;                                  \
    if (REASON != 0) {                                      \
        CcAddOpenToLog( &(SCM)->OpenCountLog, REASON, -1 ); \
    }                                                       \
}

typedef struct _SHARED_CACHE_MAP {

    //
    //  Type and size of this record
    //

    CSHORT NodeTypeCode;
    CSHORT NodeByteSize;

    //
    //  Number of times this file has been opened cached.
    //

    ULONG OpenCount;

    //
    //  Actual size of file, primarily for restricting Read Ahead.  Initialized
    //  on creation and maintained by extend and truncate operations.
    //
    //  NOTE:   This field may never be moved.  cache.h exports a macro
    //          which "knows" that FileSize is the second longword in the Cache Map!
    //

    LARGE_INTEGER FileSize;

    //
    //  Bcb Listhead.  The BcbList is ordered by descending
    //  FileOffsets, to optimize misses in the sequential I/O case.
    //  Synchronized by the BcbSpinLock.
    //

    LIST_ENTRY BcbList;

    //
    //  Size of section created.
    //

    LARGE_INTEGER SectionSize;

    //
    //  ValidDataLength for file, as currently stored by the file system.
    //  Synchronized by the BcbSpinLock or exclusive access by FileSystem.
    //

    LARGE_INTEGER ValidDataLength;

    //
    //  Goal for ValidDataLength, when current dirty data is written.
    //  Synchronized by the BcbSpinLock or exclusive access by FileSystem.
    //

    LARGE_INTEGER ValidDataGoal;

    //
    //  Pointer to a contiguous array of Vacb pointers which control mapping
    //  to this file, along with Vacbs (currently) for a 1MB file.
    //  Synchronized by CcVacbSpinLock.
    //

    PVACB InitialVacbs[PREALLOCATED_VACBS];
    PVACB * Vacbs;

    //
    //  Referenced pointer to original File Object on which the SharedCacheMap
    //  was created.
    //

    PFILE_OBJECT FileObject;

    //
    //  Describe Active Vacb and Page for copysup optimizations.
    //

    volatile PVACB ActiveVacb;

    //
    //  Virtual address needing zero to end of page
    //

    volatile PVOID NeedToZero;

    ULONG ActivePage;
    ULONG NeedToZeroPage;

    //
    //  Fields for synchronizing on active requests.
    //

    KSPIN_LOCK ActiveVacbSpinLock;
    ULONG VacbActiveCount;

    //
    //  Number of dirty pages in this SharedCacheMap.  Used to trigger
    //  write behind.  Synchronized by CcMasterSpinLock.
    //

    ULONG DirtyPages;

    //
    //  THE NEXT TWO FIELDS MUST BE ADJACENT, TO SUPPORT
    //  SHARED_CACHE_MAP_LIST_CURSOR!
    //
    //  Links for Global SharedCacheMap List
    //

    LIST_ENTRY SharedCacheMapLinks;

    //
    //  Shared Cache Map flags (defined below)
    //

    ULONG Flags;

    //
    //  Status variable set by creator of SharedCacheMap
    //

    NTSTATUS Status;

    //
    //  Mask Bcb for this SharedCacheMap, if there is one.
    //  Synchronized by the BcbSpinLock.
    //

    struct _MBCB *Mbcb;

    //
    //  Pointer to the common Section Object used by the file system.
    //

    PVOID Section;

    //
    //  This event pointer is used to handle creation collisions.
    //  If a second thread tries to call CcInitializeCacheMap for the
    //  same file, while BeingCreated (below) is TRUE, then that thread
    //  will allocate an event store it here (if not already allocated),
    //  and wait on it.  The first creator will set this event when it
    //  is done.  The event is not deleted until CcUninitializedCacheMap
    //  is called, to avoid possible race conditions.  (Note that normally
    //  the event never has to be allocated.
    //

    PKEVENT CreateEvent;

    //
    //  This points to an event used to wait for active count to go to zero
    //

    PKEVENT WaitOnActiveCount;

    //
    //  These two fields control the writing of large metadata
    //  streams.  The first field gives a target for the current
    //  flush interval, and the second field stores the end of
    //  the last flush that occurred on this file.
    //

    ULONG PagesToWrite;
    LONGLONG BeyondLastFlush;

    //
    //  Pointer to structure of routines used by the Lazy Writer to Acquire
    //  and Release the file for Lazy Write and Close, to avoid deadlocks,
    //  and the context to call them with.
    //

    PCACHE_MANAGER_CALLBACKS Callbacks;

    PVOID LazyWriteContext;

    //
    //  Listhead of all PrivateCacheMaps linked to this SharedCacheMap.
    //

    LIST_ENTRY PrivateList;

    //
    //  Log handle specified for this shared cache map, for support of routines
    //  in logsup.c
    //

    PVOID LogHandle;

    //
    //  Callback routine specified for flushing to Lsn.
    //

    PFLUSH_TO_LSN FlushToLsnRoutine;

    //
    //  Dirty Page Threshold for this stream
    //

    ULONG DirtyPageThreshold;

    //
    //  Lazy Writer pass count.  Used by the Lazy Writer for
    //  no modified write streams, which are not serviced on
    //  every pass in order to avoid contention with foreground
    //  activity.
    //

    ULONG LazyWritePassCount;

    //
    //  This event pointer is used to allow a file system to be notified when
    //  the deletion of a shared cache map.
    //
    //  This has to be provided here because the cache manager may decide to
    //  "Lazy Delete" the shared cache map, and some network file systems
    //  will want to know when the lazy delete completes.
    //

    PCACHE_UNINITIALIZE_EVENT UninitializeEvent;

    //
    //  This Vacb pointer is needed for keeping the NeedToZero virtual address
    //  valid.
    //

    PVACB NeedToZeroVacb;

    //
    //  Spinlock for synchronizing the Mbcb and Bcb lists - must be acquired
    //  before CcMasterSpinLock and before the VacbLock.  This spinlock also 
    //  synchronizes ValidDataGoal and ValidDataLength, as described above.
    //
    //  REMEMBER: Mapping and unmapping views for files with BcbListHeads and
    //    multilevel VACB representation must hold the BcbSpinLock while 
    //    adding/removing VACB levels since they will affect the BcbList as
    //    BcbListHeads are added/removed.
    //

    KSPIN_LOCK BcbSpinLock;

    PVOID Reserved;

    //
    //  This is an event which may be used for the WaitOnActiveCount event.  We
    //  avoid overhead by only "activating" it when it is needed.
    //

    KEVENT Event;

    EX_PUSH_LOCK VacbPushLock;
    
    //
    //  Preallocate one PrivateCacheMap to reduce pool allocations.
    //

    PRIVATE_CACHE_MAP PrivateCacheMap;

} SHARED_CACHE_MAP;

typedef SHARED_CACHE_MAP *PSHARED_CACHE_MAP;

//
//  Shared Cache Map Flags
//

//
//  Read ahead has been disabled on this file.
//

#define DISABLE_READ_AHEAD               0x0001

//
//  Write behind has been disabled on this file.
//

#define DISABLE_WRITE_BEHIND             0x0002

//
//  This flag indicates whether CcInitializeCacheMap was called with
//  PinAccess = TRUE.
//

#define PIN_ACCESS                       0x0004

//
//  This flag indicates that a truncate is required when OpenCount
//  goes to 0.
//

#define TRUNCATE_REQUIRED                0x0010

//
//  This flag indicates that a LazyWrite request is queued.
//

#define WRITE_QUEUED                     0x0020

//
//  This flag indicates that we have never seen anyone cache
//  the file except for with FO_SEQUENTIAL_ONLY, so we should
//  tell MM to quickly dump pages when we unmap.
//

#define ONLY_SEQUENTIAL_ONLY_SEEN        0x0040

//
//  Active Page is locked
//

#define ACTIVE_PAGE_IS_DIRTY             0x0080

//
//  Flag to say that a create is in progress.
//

#define BEING_CREATED                    0x0100

//
//  Flag to say that modified write was disabled on the section.
//

#define MODIFIED_WRITE_DISABLED          0x0200

//
//  Flag that indicates if a lazy write ever occurred on this file.
//

#define LAZY_WRITE_OCCURRED              0x0400

//
//  Flag that indicates this structure is only a cursor, only the
//  SharedCacheMapLinks and Flags are valid!
//

#define IS_CURSOR                        0x0800

//
//  Flag that indicates that we have seen someone cache this file
//  and specify FO_RANDOM_ACCESS.  This will deactivate our cache
//  working set trim assist.
//

#define RANDOM_ACCESS_SEEN               0x1000

//
//  Flag indicating that the stream is private write.  This disables
//  non-aware flush/purge.
//

#define PRIVATE_WRITE                    0x2000

//
//  This flag indicates that a LazyWrite request is queued.
//

#define READ_AHEAD_QUEUED                0x4000

//
//  This flag indicates that CcMapAndCopy() forced a remote write
//  to be write through while writes were throttled.  This tells
//  CcUninitializeCacheMap() to force a lazy close of the file
//  and CcWriteBehind() to force an update of the valid data
//  length.
//

#define FORCED_WRITE_THROUGH             0x8000

//
//  This flag indicates that Mm is waiting for the data section being used
//  by Cc at this time to go away so that the file can be opened as an image
//  section.  If this flag is set during CcWriteBehind, we will flush the
//  entire file and try to tear down the shared cache map.
//

#define WAITING_FOR_TEARDOWN             0x10000

//
//  This flag indicates that the caller intends to use the 
//  CcPreparePinWriteNoDirtyTracking API and will manage tracking the
//  dirty data for that pinning activity on the data stream.
//

#define CALLER_TRACKS_DIRTY_DATA         0x20000

FORCEINLINE
VOID
CcAcquireBcbSpinLockAndVacbLock (
    __in LOGICAL AcquireBcbSpinLock,
    __in_opt PSHARED_CACHE_MAP SharedCacheMap,
    __out PKLOCK_QUEUE_HANDLE LockHandle
    )

/*++

Routine Description:

    This routine acquires the appropriate locks based on AcquireBcbSpinLock.
    If AcquireBcbSpinLock is true, both the SharedCacheMap->BcbSpinLock and
    the VACB spin lock must be acquired.  This stream must be a file which
    has BCB list heads to manage.  Otherwise, acquiring only the VACB spin lock
    is sufficient for synchronization.

Arguments:

    AcquireBcbSpinLock - Flag telling us which locks to acquire.

    SharedCacheMap - The SharedCacheMap which has the BcbSpinLock to acquire.
        NULL if AcquireBcbSpinLock is FALSE.

    LockHandle - Supplies the lock handle to store the queued spin lock release
        information if the BcbSpinLock must be acquired.  Otherwise, stores
        the OldIrql from the Vacb spin lock acquisition.
    
Return Value:

    None.

--*/

{
    if (AcquireBcbSpinLock) {

        ASSERT( SharedCacheMap != NULL );

        KeAcquireInStackQueuedSpinLock( &SharedCacheMap->BcbSpinLock, LockHandle );
        CcAcquireVacbLockAtDpcLevel();
        
    } else {

        CcAcquireVacbLock( &LockHandle->OldIrql );
    }
}

FORCEINLINE
VOID
CcReleaseBcbSpinLockAndVacbLock (
    __in LOGICAL AcquiredBcbSpinLock,
    __out PKLOCK_QUEUE_HANDLE LockHandle
    )
/*++

Routine Description:

    This routine releases the locks acquired by CcAcquireBcbSpinLockAndVacbLock.

Arguments:

    AcquiredBcbSpinLock - Flag telling us which locks were acquired.

    LockHandle - Supplies the lock handle or OldIrql to restore.
    
Return Value:

    None.

--*/

{
    if (AcquiredBcbSpinLock) {

        CcReleaseVacbLockFromDpcLevel();
        KeReleaseInStackQueuedSpinLock( LockHandle );
            
    } else {

        CcReleaseVacbLock( LockHandle->OldIrql );
    }
}
    
//
//  Cursor structure for traversing the SharedCacheMap lists.  Anyone
//  scanning these lists must verify that the IS_CURSOR flag is clear
//  before looking at other SharedCacheMap fields.
//


typedef struct _SHARED_CACHE_MAP_LIST_CURSOR {

    //
    //  Links for Global SharedCacheMap List
    //

    LIST_ENTRY SharedCacheMapLinks;

    //
    //  Shared Cache Map flags, IS_CURSOR must be set.
    //

    ULONG Flags;

} SHARED_CACHE_MAP_LIST_CURSOR, *PSHARED_CACHE_MAP_LIST_CURSOR;

FORCEINLINE
BOOLEAN
CcForceWriteThrough (
    IN PFILE_OBJECT FileObject,
    IN ULONG WriteLength,
    IN OUT PSHARED_CACHE_MAP SharedCacheMap,
    IN BOOLEAN SetForceWriteThroughFlag
    )

/*++

Routine Description:

    This routine checks to see if we meet the conditions to force this
    cached write to be write through even though the file object was not
    opened for write through access.  We will force the operation to write
    through when the following conditions are met:

    1. The write originated from a remote user (i.e., the write is coming
    through SRV.SYS)
    
    2. This cached write is large enough that we would otherwise throttle
    the write because we have too much dirty data in the cache right now.

Arguments:

    FileObject - The file object for this cached write.

    WriteLength - The amount of data being written

    SharedCacheMap - SharedCacheMap for this file.

    SetForcedWriteThroughFlag - TRUE if the caller is going to convert the
        current write to write through based on the return value of this
        function.  If so, we will set the FORCE_WRITE_THROUGH flag in the
        shared cache map now.  FALSE if the caller just wants to know if we are
        under the conditions that would cause a write to be forced write through.

Return Value:

    Returns TRUE if the write should be forced to be write through, or FALSE
    if we can go ahead with a regular cached write.
    
--*/

{
    BOOLEAN ForcedWriteThrough = FALSE;
    KIRQL OldIrql;

    //
    //  If this file is from SRV, we don't want to throttle writes on this
    //  machine because these cached writes were already throttled on the client.
    //  But, we can't just allow SRVs cached writes to go unchecked because
    //  it can fill up all the memory in the machine.  So, if we would otherwise
    //  throttle this cached write, we will force the write to WRITE_THROUGH
    //  so that we don't end up generating more dirty data in the cache.
    //  
    //  It is very important to set the FORCED_WRITE_THROUGH flag on the
    //  shared cache map so that the lazy writer thread will still send the 
    //  VDL updates to the file system if these writes ended up extending VDL.
    //
    
    if (IoIsFileOriginRemote(FileObject) &&
        !CcCanIWrite( FileObject,
                      WriteLength,
                      FALSE,
                      MAXUCHAR - 2 )) {

        ForcedWriteThrough = TRUE;

        if (SetForceWriteThroughFlag &&
            !FlagOn(SharedCacheMap->Flags, FORCED_WRITE_THROUGH)) {

            CcAcquireMasterLock( &OldIrql );
            SetFlag(SharedCacheMap->Flags, FORCED_WRITE_THROUGH);
            CcReleaseMasterLock( OldIrql );
        }
    }

    return ForcedWriteThrough;
}


//
//  Bitmap Range structure.  For small files there is just one embedded in the
//  Mbcb.  For large files there may be many of these linked to the Mbcb.
//

typedef struct _BITMAP_RANGE {

    //
    //  Links for the list of bitmap ranges off the Mbcb.
    //

    LIST_ENTRY Links;

    //
    //  Base page (FileOffset / PAGE_SIZE) represented by this range.
    //  (Size is a fixed maximum.)
    //

    LONGLONG BasePage;

    //
    //  First and Last dirty pages relative to the BasePage.
    //

    ULONG FirstDirtyPage;
    ULONG LastDirtyPage;

    //
    //  Number of dirty pages in this range.
    //

    ULONG DirtyPages;

    //
    //  Pointer to the bitmap for this range.
    //

    PULONG Bitmap;

} BITMAP_RANGE, *PBITMAP_RANGE;

//
//  This structure is a "mask" Bcb.  For fast simple write operations,
//  a mask Bcb is used so that we basically only have to set bits to remember
//  where the dirty data is.
//

typedef struct _MBCB {

    //
    //  Type and size of this record
    //

    CSHORT NodeTypeCode;
    CSHORT NodeIsInZone;

    //
    //  This field is used as a scratch area for the Lazy Writer to
    //  guide how much he will write each time he wakes up.
    //

    ULONG PagesToWrite;

    //
    //  Number of dirty pages (set bits) in the bitmap below.
    //

    ULONG DirtyPages;

    //
    //  Reserved for alignment.
    //

    ULONG Reserved;

    //
    //  ListHead of Bitmap ranges.
    //

    LIST_ENTRY BitmapRanges;

    //
    //  This is a hint on where to resume writing, since we will not
    //  always write all of the dirty data at once.
    //

    LONGLONG ResumeWritePage;

    //
    //  Initial three embedded Bitmap ranges.  For a file up to 2MB, only the
    //  first range is used, and the rest of the Mbcb contains bits for 2MB of
    //  dirty pages.  For larger files, all three ranges may
    //  be used to describe external bitmaps.
    //

    BITMAP_RANGE BitmapRange1;
    BITMAP_RANGE BitmapRange2;
    BITMAP_RANGE BitmapRange3;

} MBCB;

typedef MBCB *PMBCB;



//
//  This is the Buffer Control Block structure for representing data which
//  is "pinned" in memory by one or more active requests and/or dirty.  This
//  structure is created the first time that a call to CcPinFileData specifies
//  a particular integral range of pages.  It is deallocated whenever the Pin
//  Count reaches 0 and the Bcb is not Dirty.
//
//  NOTE: The first four fields must be the same as the PUBLIC_BCB.
//

typedef struct _BCB {

    union {

        //
        // To ensure QuadAlign (sizeof (BCB)) >= QuadAlign (sizeof (MBCB))
        // so that they can share the same pool blocks.
        //

        MBCB Dummy;

        struct {

            //
            //  Type and size of this record
            //

            CSHORT NodeTypeCode;

            //
            //  Flags
            //

            BOOLEAN Dirty;
            BOOLEAN Reserved;

            //
            //  Byte FileOffset and and length of entire buffer
            //

            ULONG  ByteLength;
            LARGE_INTEGER FileOffset;

            //
            //  Links for BcbList in SharedCacheMap
            //

            LIST_ENTRY BcbLinks;

            //
            //  Byte FileOffset of last byte in buffer (used for searching)
            //

            LARGE_INTEGER BeyondLastByte;

            //
            //  Oldest Lsn (if specified) when this buffer was set dirty.
            //

            LARGE_INTEGER OldestLsn;

            //
            //  Most recent Lsn specified when this buffer was set dirty.
            //  The FlushToLsnRoutine is called with this Lsn.
            //

            LARGE_INTEGER NewestLsn;

            //
            //  Pointer to Vacb via which this Bcb is mapped.
            //

            PVACB Vacb;

            //
            //  Count of threads actively using this Bcb to process a request.
            //  This must be manipulated under protection of the BcbListSpinLock
            //  in the SharedCacheMap.
            //

            ULONG PinCount;

            //
            //  Resource to synchronize buffer access.  Pinning Readers and all Writers
            //  of the described buffer take out shared access (synchronization of
            //  buffer modifications is strictly up to the caller).  Note that pinning
            //  readers do not declare if they are going to modify the buffer or not.
            //  Anyone writing to disk takes out exclusive access, to prevent the buffer
            //  from changing while it is being written out.
            //

            ERESOURCE Resource;

            //
            //  Pointer to SharedCacheMap for this Bcb.
            //

            PSHARED_CACHE_MAP SharedCacheMap;

            //
            //  This is the Base Address at which the buffer can be seen in
            //  system space.  All access to buffer data should go through this
            //  address.
            //

            PVOID BaseAddress;
        };
    };

} BCB;

#define CcUnpinFileData( _Bcb, _ReadOnly, _UnmapAction ) \
    CcUnpinFileDataEx( (_Bcb), (_ReadOnly), (_UnmapAction ) )
#define CcUnpinFileDataReleaseFromFlush( _Bcb, _ReadOnly, _UnmapAction ) \
    CcUnpinFileDataEx( (_Bcb), (_ReadOnly), (_UnmapAction ) )

typedef BCB *PBCB;

//
//  This is the Overlap Buffer Control Block structure for representing data which
//  is "pinned" in memory and must be represented by multiple Bcbs due to overlaps.
//
//  NOTE: The first four fields must be the same as the PUBLIC_BCB.
//

typedef struct _OBCB {

    //
    //  Type and size of this record
    //

    CSHORT NodeTypeCode;
    CSHORT NodeByteSize;

    //
    //  Byte FileOffset and and length of entire buffer
    //

    ULONG  ByteLength;
    LARGE_INTEGER FileOffset;

    //
    //  Vector of Bcb pointers.
    //

    PBCB Bcbs[ANYSIZE_ARRAY];

} OBCB;

typedef OBCB *POBCB;


//
//  Struct for remembering deferred writes for later posting.
//

typedef struct _DEFERRED_WRITE {

    //
    //  Type and size of this record
    //

    CSHORT NodeTypeCode;
    CSHORT NodeByteSize;

    //
    //  The file to be written.
    //

    PFILE_OBJECT FileObject;

    //
    //  Number of bytes the caller intends to write
    //

    ULONG BytesToWrite;

    //
    //  Links for the deferred write queue.
    //

    LIST_ENTRY DeferredWriteLinks;

    //
    //  If this event pointer is not NULL, then this event will
    //  be signaled when the write is ok, rather than calling
    //  the PostRoutine below.
    //

    PKEVENT Event;

    //
    //  The posting routine and its parameters
    //

    PCC_POST_DEFERRED_WRITE PostRoutine;
    PVOID Context1;
    PVOID Context2;

    BOOLEAN LimitModifiedPages;

} DEFERRED_WRITE, *PDEFERRED_WRITE;


//
//  Struct controlling the Lazy Writer algorithms
//

typedef struct _LAZY_WRITER {

    //
    //  Work queue.
    //

    LIST_ENTRY WorkQueue;

    //
    //  Dpc and Timer Structures used for activating periodic scan when active.
    //

    KDPC ScanDpc;
    KTIMER ScanTimer;

    //
    //  Boolean to say whether Lazy Writer scan is active or not.
    //

    BOOLEAN ScanActive;

    //
    //  Boolean indicating if there is any other reason for Lazy Writer to
    //  wake up.
    //

    BOOLEAN OtherWork;

} LAZY_WRITER;


//
//  Work queue entry for the worker threads, with an enumerated
//  function code.
//

typedef enum _WORKER_FUNCTION {
    Noop = 0,
    ReadAhead,
    WriteBehind,
    LazyWriteScan,
    EventSet
} WORKER_FUNCTION;

typedef struct _WORK_QUEUE_ENTRY {

    //
    //  List entry for our work queues.
    //

    LIST_ENTRY WorkQueueLinks;

    //
    //  Define a union to contain function-specific parameters.
    //

    union {

        //
        //  Read parameters (for read ahead)
        //

        struct {
            PFILE_OBJECT FileObject;
        } Read;

        //
        //  Write parameters (for write behind)
        //

        struct {
            PSHARED_CACHE_MAP SharedCacheMap;
        } Write;

        //
        //  Set event parameters (for queue checks)
        //

        struct {
            PKEVENT Event;
        } Event;

    } Parameters;

    //
    //  Function code for this entry:
    //

    UCHAR Function;

} WORK_QUEUE_ENTRY, *PWORK_QUEUE_ENTRY;

//
//  This is a structure appended to the end of an MDL
//

typedef struct _MDL_WRITE {

    //
    //  This field is for the use of the Server to stash anything interesting
    //

    PVOID ServerContext;

    //
    //  This is the resource to release when the write is complete.
    //

    PERESOURCE Resource;

    //
    //  This is thread caller's thread, and the thread that must release
    //  the resource.
    //

    ERESOURCE_THREAD Thread;

    //
    //  This links all the pending MDLs through the shared cache map.
    //

    LIST_ENTRY MdlLinks;

} MDL_WRITE, *PMDL_WRITE;


//
//  Common Private routine definitions for the Cache Manager
//

VOID
CcGetActiveVacb (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    OUT PVACB *Vacb,
    OUT PULONG Page,
    OUT PULONG Dirty
    );

VOID
CcSetActiveVacb (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN OUT PVACB *Vacb,
    IN ULONG Page,
    IN ULONG Dirty
    );

//
//  We trim out the previous macro-forms of Get/Set (nondpc) so that we can page
//  more cache manager code that otherwise does not acquire spinlocks.
//

#define GetActiveVacb(SCM,IRQ,V,P,D)     CcGetActiveVacb((SCM),&(V),&(P),&(D))
#define SetActiveVacb(SCM,IRQ,V,P,D)     CcSetActiveVacb((SCM),&(V),(P),(D))

#define GetActiveVacbAtDpcLevel(SCM,V,P,D) {                            \
    ExAcquireSpinLockAtDpcLevel(&(SCM)->ActiveVacbSpinLock);            \
    (V) = (SCM)->ActiveVacb;                                            \
    if ((V) != NULL) {                                                  \
        (P) = (SCM)->ActivePage;                                        \
        (SCM)->ActiveVacb = NULL;                                       \
        (D) = (SCM)->Flags & ACTIVE_PAGE_IS_DIRTY;                      \
    }                                                                   \
    ExReleaseSpinLockFromDpcLevel(&(SCM)->ActiveVacbSpinLock);          \
}

//
//  Gather the common work of charging and deducting dirty page counts.  When
//  write hysteresis was being considered during Windows XP, this also helped
//  gather up the activation of that throttle.
//

#define CcDeductDirtyPages( S, P )                                      \
        CcTotalDirtyPages -= (P);                                       \
        (S)->DirtyPages -= (P);
        
#define CcChargeMaskDirtyPages( S, M, B, P )                            \
        CcTotalDirtyPages += (P);                                       \
        (M)->DirtyPages += (P);                                         \
        (B)->DirtyPages += (P);                                         \
        (S)->DirtyPages += (P);

#define CcChargePinDirtyPages( S, P )                                   \
        CcTotalDirtyPages += (P);                                       \
        (S)->DirtyPages += (P);

VOID
CcPostDeferredWrites (
    );

BOOLEAN
CcPinFileData (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN ReadOnly,
    IN BOOLEAN WriteOnly,
    IN ULONG Flags,
    OUT PBCB *Bcb,
    OUT PVOID *BaseAddress,
    OUT PLARGE_INTEGER BeyondLastByte
    );

typedef enum {
    UNPIN,
    UNREF,
    SET_CLEAN
} UNMAP_ACTIONS;

VOID
FASTCALL
CcUnpinFileDataEx (
    IN OUT PBCB Bcb,
    IN BOOLEAN ReadOnly,
    IN UNMAP_ACTIONS UnmapAction
    );

VOID
FASTCALL
CcDeallocateBcb (
    IN PBCB Bcb
    );

VOID
FASTCALL
CcPerformReadAhead (
    IN PFILE_OBJECT FileObject
    );

VOID
CcSetDirtyInMask (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length
    );

VOID
FASTCALL
CcWriteBehind (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN PIO_STATUS_BLOCK IoStatus
    );

#define ZERO_FIRST_PAGE                  1
#define ZERO_MIDDLE_PAGES                2
#define ZERO_LAST_PAGE                   4

BOOLEAN
CcMapAndRead(
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG ZeroFlags,
    IN BOOLEAN Wait,
    IN PVOID BaseAddress
    );

VOID
CcFreeActiveVacb (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN PVACB ActiveVacb OPTIONAL,
    IN ULONG ActivePage,
    IN ULONG PageIsDirty
    );

#define OPTIMIZE_FIRST_PAGE                  1
#define OPTIMIZE_MIDDLE_PAGES                2
#define OPTIMIZE_LAST_PAGE                   4

BOOLEAN
CcMapAndCopy(
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN PVOID UserBuffer,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG OptimizeFlags,
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER ValidDataLength,
    IN BOOLEAN Wait
    );

VOID
CcScanDpc (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
CcScheduleLazyWriteScan (
    IN BOOLEAN FastScan
    );

VOID
CcStartLazyWriter (
    IN PVOID NotUsed
    );

#define CcAllocateWorkQueueEntry() \
    (PWORK_QUEUE_ENTRY)ExAllocateFromPPLookasideList(LookasideTwilightList)

#define CcFreeWorkQueueEntry(_entry_)         \
    ExFreeToPPLookasideList(LookasideTwilightList, (_entry_))

VOID
FASTCALL
CcPostWorkQueue (
    IN PWORK_QUEUE_ENTRY WorkQueueEntry,
    IN PLIST_ENTRY WorkQueue
    );

VOID
CcWorkerThread (
    PVOID ExWorkQueueItem
    );

VOID
FASTCALL
CcDeleteSharedCacheMap (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN KIRQL ListIrql,
    IN ULONG ReleaseFile
    );

VOID
CcCancelMmWaitForUninitializeCacheMap (
    IN PSHARED_CACHE_MAP SharedCacheMap
    );

//
//  This exception filter handles STATUS_IN_PAGE_ERROR correctly
//

LONG
CcCopyReadExceptionFilter(
    IN PEXCEPTION_POINTERS ExceptionPointer,
    IN PNTSTATUS ExceptionCode
    );

//
//  Exception filter for Worker Threads in lazyrite.c
//

LONG
CcExceptionFilter (
    IN NTSTATUS ExceptionCode
    );

//
//  Vacb routines
//

VOID
CcInitializeVacbs(
    );

PVOID
CcGetVirtualAddressIfMapped (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN LONGLONG FileOffset,
    OUT PVACB *Vacb,
    OUT PULONG ReceivedLength
    );

PVOID
CcGetVirtualAddress (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN LARGE_INTEGER FileOffset,
    OUT PVACB *Vacb,
    OUT PULONG ReceivedLength
    );

VOID
FASTCALL
CcFreeVirtualAddress (
    IN PVACB Vacb
    );

VOID
CcReferenceFileOffset (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN LARGE_INTEGER FileOffset
    );

VOID
CcDereferenceFileOffset (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN LARGE_INTEGER FileOffset
    );

VOID
CcWaitOnActiveCount (
    IN PSHARED_CACHE_MAP SharedCacheMap
    );

NTSTATUS
FASTCALL
CcCreateVacbArray (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN LARGE_INTEGER NewSectionSize
    );

NTSTATUS
CcExtendVacbArray (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN LARGE_INTEGER NewSectionSize
    );

BOOLEAN
FASTCALL
CcUnmapVacbArray (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN PLARGE_INTEGER FileOffset OPTIONAL,
    IN ULONG Length,
    IN BOOLEAN UnmapBehind
    );

VOID
CcAdjustVacbLevelLockCount (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN LONGLONG FileOffset,
    IN LONG Adjustment
    );

PLIST_ENTRY
CcGetBcbListHead (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN LONGLONG FileOffset,
    IN BOOLEAN FailToSuccessor
    );

PLIST_ENTRY
CcGetBcbListHeadLargeOffset (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN LONGLONG FileOffset,
    IN BOOLEAN FailToSuccessor
    );

ULONG
CcPrefillVacbLevelZone (
    IN ULONG NumberNeeded,
    OUT PKLOCK_QUEUE_HANDLE LockHandle,
    IN ULONG NeedBcbListHeads,
    IN LOGICAL AcquireBcbSpinLock,
    IN PSHARED_CACHE_MAP SharedCacheMap OPTIONAL
    );

VOID
CcDrainVacbLevelZone (
    );

//
//  Define references to global data
//

extern ALIGNED_SPINLOCK CcBcbSpinLock;
extern LIST_ENTRY CcCleanSharedCacheMapList;
extern SHARED_CACHE_MAP_LIST_CURSOR CcDirtySharedCacheMapList;
extern SHARED_CACHE_MAP_LIST_CURSOR CcLazyWriterCursor;
extern GENERAL_LOOKASIDE CcTwilightLookasideList;
extern ULONG CcNumberWorkerThreads;
extern ULONG CcNumberActiveWorkerThreads;
extern LIST_ENTRY CcIdleWorkerThreadList;
extern LIST_ENTRY CcExpressWorkQueue;
extern LIST_ENTRY CcRegularWorkQueue;
extern LIST_ENTRY CcPostTickWorkQueue;
extern BOOLEAN CcQueueThrottle;
extern ULONG CcIdleDelayTick;
extern LARGE_INTEGER CcNoDelay;
extern LARGE_INTEGER CcFirstDelay;
extern LARGE_INTEGER CcIdleDelay;
extern LARGE_INTEGER CcCollisionDelay;
extern LARGE_INTEGER CcTargetCleanDelay;
extern LAZY_WRITER LazyWriter;
extern ULONG_PTR CcNumberVacbs;
extern PVACB CcVacbs;
extern PVACB CcBeyondVacbs;
extern LIST_ENTRY CcVacbLru;
extern LIST_ENTRY CcVacbFreeList;
extern ALIGNED_SPINLOCK CcDeferredWriteSpinLock;
extern LIST_ENTRY CcDeferredWrites;
extern ULONG CcDirtyPageThreshold;
extern ULONG CcDirtyPageTarget;
extern ULONG CcDirtyPagesLastScan;
extern ULONG CcPagesYetToWrite;
extern ULONG CcPagesWrittenLastTime;
extern ULONG CcThrottleLastTime;
extern ULONG CcDirtyPageHysteresisThreshold;
extern PSHARED_CACHE_MAP CcSingleDirtySourceDominant;
extern ULONG CcAvailablePagesThreshold;
extern ULONG CcTotalDirtyPages;
extern ULONG CcTune;
extern LONG CcAggressiveZeroCount;
extern LONG CcAggressiveZeroThreshold;
extern ULONG CcLazyWriteHotSpots;
extern MM_SYSTEMSIZE CcCapturedSystemSize;
extern ULONG CcMaxVacbLevelsSeen;
extern ULONG CcVacbLevelEntries;
extern PVACB *CcVacbLevelFreeList;
extern ULONG CcVacbLevelWithBcbsEntries;
extern PVACB *CcVacbLevelWithBcbsFreeList;

//
//  Macros for allocating and deallocating Vacb levels - CcVacbSpinLock must
//  be acquired.
//

_inline PVACB *CcAllocateVacbLevel (
    IN LOGICAL AllocatingBcbListHeads
    )

{
    PVACB *ReturnEntry;

    if (AllocatingBcbListHeads) {
        ReturnEntry = CcVacbLevelWithBcbsFreeList;
        CcVacbLevelWithBcbsFreeList = (PVACB *)*ReturnEntry;
        CcVacbLevelWithBcbsEntries -= 1;
    } else {
        ReturnEntry = CcVacbLevelFreeList;
        CcVacbLevelFreeList = (PVACB *)*ReturnEntry;
        CcVacbLevelEntries -= 1;
    }
    *ReturnEntry = NULL;
    ASSERT(RtlCompareMemory(ReturnEntry, ReturnEntry + 1, VACB_LEVEL_BLOCK_SIZE - sizeof(PVACB)) ==
                                                          (VACB_LEVEL_BLOCK_SIZE - sizeof(PVACB)));
    return ReturnEntry;
}

_inline VOID CcDeallocateVacbLevel (
    IN PVACB *Entry,
    IN LOGICAL DeallocatingBcbListHeads
    )

{
    if (DeallocatingBcbListHeads) {
        *Entry = (PVACB)CcVacbLevelWithBcbsFreeList;
        CcVacbLevelWithBcbsFreeList = Entry;
        CcVacbLevelWithBcbsEntries += 1;
    } else {
        *Entry = (PVACB)CcVacbLevelFreeList;
        CcVacbLevelFreeList = Entry;
        CcVacbLevelEntries += 1;
    }
}

//
//  Export the macros for inspecting the reference counts for
//  the multilevel Vacb array.
//

_inline
PVACB_LEVEL_REFERENCE
VacbLevelReference (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN PVACB *VacbArray,
    IN ULONG Level
    )
{
    return (PVACB_LEVEL_REFERENCE)
           ((PCHAR)VacbArray +
            VACB_LEVEL_BLOCK_SIZE +
            (Level != 0?
             0 : (FlagOn( SharedCacheMap->Flags, MODIFIED_WRITE_DISABLED )?
                  VACB_LEVEL_BLOCK_SIZE : 0)));
}

_inline
ULONG
IsVacbLevelReferenced (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN PVACB *VacbArray,
    IN ULONG Level
    )
{
    PVACB_LEVEL_REFERENCE VacbReference = VacbLevelReference( SharedCacheMap, VacbArray, Level );

    return VacbReference->Reference | VacbReference->SpecialReference;
}


//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
//      #define try_return(S)  { S; goto try_exit; }
//

#define try_return(S) { S; goto try_exit; }

#define DebugTrace(INDENT,LEVEL,X,Y) {NOTHING;}
#define DebugTrace2(INDENT,LEVEL,X,Y,Z) {NOTHING;}
#define DebugDump(STR,LEVEL,PTR) {NOTHING;}

//
//  Global list of pinned Bcbs which may be examined for debug purposes
//

#if DBG

extern ULONG CcBcbCount;
extern LIST_ENTRY CcBcbList;

#endif

FORCEINLINE
VOID
CcInsertIntoCleanSharedCacheMapList (
    IN PSHARED_CACHE_MAP SharedCacheMap
    )
{
    if (KdDebuggerEnabled && 
        (KdDebuggerNotPresent == FALSE) &&
        SharedCacheMap->OpenCount == 0 &&
        SharedCacheMap->DirtyPages == 0) {

        DbgPrint( "CC: SharedCacheMap->OpenCount == 0 && DirtyPages == 0 && going onto CleanList!\n" );
        DbgBreakPoint();
    }

    InsertTailList( &CcCleanSharedCacheMapList,
                    &SharedCacheMap->SharedCacheMapLinks );
}

#endif  //  _CCh_
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\cache\lazyrite.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    lazyrite.c

Abstract:

    This module implements the lazy writer for the Cache subsystem.

--*/

#include "cc.h"

//
//  The Bugcheck file id for this module
//

#define BugCheckFileId                   (CACHE_BUG_CHECK_LAZYRITE)

//
//  Define our debug constant
//

#define me 0x00000020

//
//  Local support routines
//

PWORK_QUEUE_ENTRY
CcReadWorkQueue (
    );

VOID
CcLazyWriteScan (
    );


VOID
CcScheduleLazyWriteScan (
    IN BOOLEAN FastScan
    )

/*++

Routine Description:

    This routine may be called to schedule the next lazy writer scan,
    during which lazy write and lazy close activity is posted to other
    worker threads.  Callers should acquire the lazy writer spin lock
    to see if the scan is currently active, and then call this routine
    still holding the spin lock if not.  One special call is used at
    the end of the lazy write scan to propagate lazy write active once
    we go active.  This call is "the" scan thread, and it can therefore
    safely schedule the next scan without taking out the spin lock.

Arguments:

    FastScan - if set, make the scan happen immediately

Return Value:

    None.

--*/

{
    //
    //  It is important to set the active flag TRUE first for the propagate
    //  case, because it is conceivable that once the timer is set, another
    //  thread could actually run and make the scan go idle before we then
    //  jam the flag TRUE.
    //
    //  When going from idle to active, we delay a little longer to let the
    //  app finish saving its file.
    //

    if (FastScan) {
        
        LazyWriter.ScanActive = TRUE;
        KeSetTimer( &LazyWriter.ScanTimer, CcNoDelay, &LazyWriter.ScanDpc );

    } else if (LazyWriter.ScanActive) {

        KeSetTimer( &LazyWriter.ScanTimer, CcIdleDelay, &LazyWriter.ScanDpc );
    
    } else {

        LazyWriter.ScanActive = TRUE;
        KeSetTimer( &LazyWriter.ScanTimer, CcFirstDelay, &LazyWriter.ScanDpc );
    }
}


VOID
CcScanDpc (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This is the Dpc routine which runs when the scan timer goes off.  It
    simply posts an element for an Ex Worker thread to do the scan.

Arguments:

    (All are ignored)

Return Value:

    None.

--*/

{
    PWORK_QUEUE_ENTRY WorkQueueEntry;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(DeferredContext);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

    WorkQueueEntry = CcAllocateWorkQueueEntry();

    //
    //  If we failed to allocate a WorkQueueEntry, things must
    //  be in pretty bad shape.  However, all we have to do is
    //  say we are not active, and wait for another event to
    //  wake things up again.
    //

    if (WorkQueueEntry == NULL) {

        LazyWriter.ScanActive = FALSE;

    } else {

        //
        //  Otherwise post a work queue entry to do the scan.
        //

        WorkQueueEntry->Function = (UCHAR)LazyWriteScan;

        CcPostWorkQueue( WorkQueueEntry, &CcRegularWorkQueue );
    }
}


NTSTATUS
CcWaitForCurrentLazyWriterActivity (
    )

/*++

Routine Description:

    This routine allows a thread to receive notification when the current tick
    of lazy writer work has completed.  It must not be called within a lazy
    writer workitem!  The caller must not be holding synchronization that could
    block a Cc workitem!

    In particular, this lets a caller ensure that all available lazy closes at
    the time of the call have completed.

Arguments:

    None.

Return Value:

    Final result of the wait.

--*/

{
    KIRQL OldIrql;
    KEVENT Event;
    PWORK_QUEUE_ENTRY WorkQueueEntry;

    WorkQueueEntry = CcAllocateWorkQueueEntry();

    if (WorkQueueEntry == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    WorkQueueEntry->Function = (UCHAR)EventSet;
    KeInitializeEvent( &Event, NotificationEvent, FALSE );
    WorkQueueEntry->Parameters.Event.Event = &Event;

    //
    //  Add this to the post-tick work queue and wake the lazy writer for it.
    //  The lazy writer will add this to the end of the next batch of work
    //  he issues.
    //

    CcAcquireMasterLock( &OldIrql );

    InsertTailList( &CcPostTickWorkQueue, &WorkQueueEntry->WorkQueueLinks );

    LazyWriter.OtherWork = TRUE;
    if (!LazyWriter.ScanActive) {
        CcScheduleLazyWriteScan( TRUE );
    }

    CcReleaseMasterLock( OldIrql );

    return KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, NULL );
}



VOID
CcLazyWriteScan (
    )

/*++

Routine Description:

    This routine implements the Lazy Writer scan for dirty data to flush
    or any other work to do (lazy close).  This routine is scheduled by
    calling CcScheduleLazyWriteScan.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG PagesToWrite, ForegroundRate, EstimatedDirtyNextInterval;
    PSHARED_CACHE_MAP SharedCacheMap, FirstVisited, NextSharedCacheMap;
    KIRQL OldIrql;
    ULONG LoopsWithLockHeld = 0;
    BOOLEAN AlreadyMoved = FALSE;
    BOOLEAN MoveBehindCursor = FALSE;

    LIST_ENTRY PostTickWorkQueue;

    //
    //  Top of Lazy Writer scan.
    //

    try {

        //
        //  If there is no work to do, then we will go inactive, and return.
        //

        CcAcquireMasterLock( &OldIrql );

        if ((CcTotalDirtyPages == 0) && !LazyWriter.OtherWork) {

            //
            //  Sleep if there are no deferred writes.  It is important to check
            //  proactively because writes may be blocked for reasons external
            //  to the cache manager.  The lazy writer must keep poking since it
            //  may have no bytes to write itself.
            //

#if DBG
            //
            //  In DBG builds, make sure that the CcDirtySharedCacheMapList
            //  is really empty (except for the cursor) if we are going to sleep
            //  because we think there is no more work to do.
            //
            
            {
                PLIST_ENTRY CurrentEntry = CcDirtySharedCacheMapList.SharedCacheMapLinks.Flink;
                PSHARED_CACHE_MAP CurrentScm;
                ULONG Count = 0;
                
                while( CurrentEntry != &CcDirtySharedCacheMapList.SharedCacheMapLinks ) {

                    CurrentScm = CONTAINING_RECORD( CurrentEntry,
                                                    SHARED_CACHE_MAP,
                                                    SharedCacheMapLinks );

                    if (FlagOn(CurrentScm->Flags, WAITING_FOR_TEARDOWN) &&
                        !FlagOn(CurrentScm->Flags, WRITE_QUEUED)) {
                        Count++;
                    }
                    CurrentEntry = CurrentEntry->Flink;
                }

                if (!IsListEmpty( &CcDeferredWrites )) {

                    Count = 0;
                }

                ASSERTMSG( "CcLazyWriteScan stopped scan while SCM with the flag WAITING_FOR_TEARDOWN are still in the dirty list!\n",
                           Count == 0 );
            }
#endif

            if (IsListEmpty(&CcDeferredWrites)) {

                LazyWriter.ScanActive = FALSE;
                CcReleaseMasterLock( OldIrql );

            } else {

                CcReleaseMasterLock( OldIrql );

                //
                //  Check for writes and schedule the next scan.
                //

                CcPostDeferredWrites();
                CcScheduleLazyWriteScan( FALSE );
            }

            return;
        }

        //
        //  Pull out the post tick workitems for this pass.  It is important that
        //  we are doing this at the top since more could be queued as we rummage
        //  for work to do.  Post tick workitems are guaranteed to occur after all
        //  work generated in a complete scan.
        //

        InitializeListHead( &PostTickWorkQueue );
        while (!IsListEmpty( &CcPostTickWorkQueue )) {

            PLIST_ENTRY Entry = RemoveHeadList( &CcPostTickWorkQueue );
            InsertTailList( &PostTickWorkQueue, Entry );
        }

        //
        //  Calculate the next sweep time stamp, then update all relevant fields for
        //  the next time around.  Also we can clear the OtherWork flag.
        //

        LazyWriter.OtherWork = FALSE;

        //
        //  Assume we will write our usual fraction of dirty pages.  Do not do the
        //  divide if there is not enough dirty pages, or else we will never write
        //  the last few pages.
        //

        PagesToWrite = CcTotalDirtyPages;
        if (PagesToWrite > LAZY_WRITER_MAX_AGE_TARGET) {
            PagesToWrite /= LAZY_WRITER_MAX_AGE_TARGET;
        }

        //
        //  Estimate the rate of dirty pages being produced in the foreground.
        //  This is the total number of dirty pages now plus the number of dirty
        //  pages we scheduled to write last time, minus the number of dirty
        //  pages we have now.  Throw out any cases which would not produce a
        //  positive rate.
        //

        ForegroundRate = 0;

        if ((CcTotalDirtyPages + CcPagesWrittenLastTime) > CcDirtyPagesLastScan) {
            ForegroundRate = (CcTotalDirtyPages + CcPagesWrittenLastTime) -
                             CcDirtyPagesLastScan;
        }

        //
        //  If we estimate that we will exceed our dirty page target by the end
        //  of this interval, then we must write more.  Try to arrive on target.
        //

        EstimatedDirtyNextInterval = CcTotalDirtyPages - PagesToWrite + ForegroundRate;

        if (EstimatedDirtyNextInterval > CcDirtyPageTarget) {

            PagesToWrite += EstimatedDirtyNextInterval - CcDirtyPageTarget;
        }

        //
        //  Now save away the number of dirty pages and the number of pages we
        //  just calculated to write.
        //

        CcDirtyPagesLastScan = CcTotalDirtyPages;
        CcPagesYetToWrite = CcPagesWrittenLastTime = PagesToWrite;

        //
        //  Loop to flush enough Shared Cache Maps to write the number of pages
        //  we just calculated.
        //

        SharedCacheMap = CONTAINING_RECORD( CcLazyWriterCursor.SharedCacheMapLinks.Flink,
                                            SHARED_CACHE_MAP,
                                            SharedCacheMapLinks );

        DebugTrace( 0, me, "Start of Lazy Writer Scan\n", 0 );

        //
        //  Normally we would just like to visit every Cache Map once on each scan,
        //  so the scan will terminate normally when we return to FirstVisited.  But
        //  in the off chance that FirstVisited gets deleted, we are guaranteed to stop
        //  when we get back to our own listhead.
        //

        FirstVisited = NULL;
        while ((SharedCacheMap != FirstVisited) &&
               (&SharedCacheMap->SharedCacheMapLinks != &CcLazyWriterCursor.SharedCacheMapLinks)) {

            if (FirstVisited == NULL) {
                FirstVisited = SharedCacheMap;
            }

            //
            //  Skip the SharedCacheMap if a write behind request is
            //  already queued, write behind has been disabled, or
            //  if there is no work to do (either dirty data to be written
            //  or a delete is required).
            //
            //  Note that for streams where modified writing is disabled, we
            //  need to take out Bcbs exclusive, which serializes with foreground
            //  activity.  Therefore we use a special counter in the SharedCacheMap
            //  to only service these once every n intervals.
            //
            //  Skip temporary files unless we currently could not write as many
            //  bytes as we might charge some hapless thread for throttling, unless
            //  it has been closed.  We assume that the "tick" of the lazy writer,
            //  delayed temporarily by the passcount check, will permit the common
            //  open/write/close/delete action on temporary files to sneak in and
            //  truncate the file before we really write the data, if the file was
            //  not opened delete-on-close to begin with.
            //
            //  Since we will write closed files with dirty pages as part of the
            //  regular pass (even temporary ones), only do lazy close on files
            //  with no dirty pages.
            //

            if (!FlagOn(SharedCacheMap->Flags, WRITE_QUEUED | IS_CURSOR)

                    &&

                (((SharedCacheMap->DirtyPages != 0) 
                           &&
                   (FlagOn(SharedCacheMap->Flags, WAITING_FOR_TEARDOWN)
                                ||
                    ((PagesToWrite != 0)
                                        && 
                     (((++SharedCacheMap->LazyWritePassCount & 0xF) == 0) ||
                      !FlagOn(SharedCacheMap->Flags, MODIFIED_WRITE_DISABLED) ||
                      (CcCapturedSystemSize == MmSmallSystem) ||
                      (SharedCacheMap->DirtyPages >= (4 * (MAX_WRITE_BEHIND / PAGE_SIZE))))
                                        &&
                     (!FlagOn(SharedCacheMap->FileObject->Flags, FO_TEMPORARY_FILE) ||
                      (SharedCacheMap->OpenCount == 0) ||
                      !CcCanIWrite(SharedCacheMap->FileObject, WRITE_CHARGE_THRESHOLD, FALSE, MAXUCHAR)))))

                    ||

                 ((SharedCacheMap->OpenCount == 0) &&
                  (SharedCacheMap->DirtyPages == 0) ||
                  (SharedCacheMap->FileSize.QuadPart == 0)))) {

                PWORK_QUEUE_ENTRY WorkQueueEntry;

                //
                //  If this is a metadata stream with at least 4 times
                //  the maximum write behind I/O size, then let's tell
                //  this guy to write 1/8 of his dirty data on this pass
                //  so it doesn't build up.
                //
                //  Else assume we can write everything (PagesToWrite only affects
                //  metadata streams - otherwise writing is controlled by the Mbcb -
                //  this throttle is engaged in CcWriteBehind).
                //

                SharedCacheMap->PagesToWrite = SharedCacheMap->DirtyPages;

                if (FlagOn(SharedCacheMap->Flags, MODIFIED_WRITE_DISABLED) &&
                    (SharedCacheMap->PagesToWrite >= (4 * (MAX_WRITE_BEHIND / PAGE_SIZE))) &&
                    (CcCapturedSystemSize != MmSmallSystem)) {

                    SharedCacheMap->PagesToWrite /= 8;
                }

                //
                //  If still searching for pages to write, adjust our targets.
                //

                if (!AlreadyMoved) {

                    //
                    //  See if he exhausts the number of pages to write.  (We
                    //  keep going in case there are any closes to do.)
                    //

                    if (SharedCacheMap->PagesToWrite >= PagesToWrite) {

                        //
                        //  Here is where we should move the cursor to.  Figure
                        //  out if we should resume on this stream or the next one.
                        //

                        //
                        //  For Metadata streams, set up to resume on the next stream on the
                        //  next scan.  Also force a push forward every n intervals if all of
                        //  the pages came from this stream, so we don't get preoccupied with
                        //  one stream at the expense of others (which may be waiting for a
                        //  lazy close).  Normally we would like to avoid seek overhead and
                        //  take the common case of a large sequential series of writes.
                        //
                        //  This is similar to hotspot detection.
                        //
                        //  Note, to ensure that we iterate through the entire
                        //  CcDirtySharedCacheMap list, we cannot move this shared
                        //  cache map behind the cursor now.  We will just 
                        //  remember that we want to move this to the end of the 
                        //  list and do the actual move when we are ready to read
                        //  the next entry.
                        //

                        if (FlagOn(SharedCacheMap->Flags, MODIFIED_WRITE_DISABLED) ||
                            ((FirstVisited == SharedCacheMap) &&
                             ((SharedCacheMap->LazyWritePassCount & 0xF) == 0))) {

                            MoveBehindCursor = TRUE;

                        //
                        //  For other streams, set up to resume on the same stream on the
                        //  next scan.
                        //

                        } else {

                            RemoveEntryList( &CcLazyWriterCursor.SharedCacheMapLinks );
                            InsertTailList( &SharedCacheMap->SharedCacheMapLinks, &CcLazyWriterCursor.SharedCacheMapLinks );
                        }

                        PagesToWrite = 0;
                        AlreadyMoved = TRUE;

                    } else {

                        PagesToWrite -= SharedCacheMap->PagesToWrite;
                    }
                }

                //
                //  Otherwise show we are actively writing, and keep it in the dirty
                //  list.
                //

                SetFlag(SharedCacheMap->Flags, WRITE_QUEUED);
                SharedCacheMap->DirtyPages += 1;

                CcReleaseMasterLock( OldIrql );

                //
                //  Queue the request to do the work to a worker thread.
                //

                WorkQueueEntry = CcAllocateWorkQueueEntry();

                //
                //  If we failed to allocate a WorkQueueEntry, things must
                //  be in pretty bad shape.  However, all we have to do is
                //  break out of our current loop, and try to go back and
                //  delay a while.  Even if the current guy should have gone
                //  away when we clear WRITE_QUEUED, we will find him again
                //  in the LW scan.
                //

                if (WorkQueueEntry == NULL) {

                    CcAcquireMasterLock( &OldIrql );
                    ClearFlag(SharedCacheMap->Flags, WRITE_QUEUED);
                    SharedCacheMap->DirtyPages -= 1;
                    break;
                }

                WorkQueueEntry->Function = (UCHAR)WriteBehind;
                WorkQueueEntry->Parameters.Write.SharedCacheMap = SharedCacheMap;

                //
                //  Post it to the regular work queue.
                //

                CcAcquireMasterLock( &OldIrql );
                SharedCacheMap->DirtyPages -= 1;

                if (FlagOn( SharedCacheMap->Flags, WAITING_FOR_TEARDOWN )) {

                    //
                    //  If we are waiting for this shared cache map to be torn
                    //  down, put it at the head of the express work queue so
                    //  that it gets processed right away.
                    //
                    
                    CcPostWorkQueue( WorkQueueEntry, &CcExpressWorkQueue );

                } else {

                    //
                    //  We aren't anxiously awaiting for this shared cached map
                    //  to go away, so just process this work item via the 
                    //  regular work queue.
                    //

                    CcPostWorkQueue( WorkQueueEntry, &CcRegularWorkQueue );
                }

                LoopsWithLockHeld = 0;

            //
            //  Make sure we occasionally drop the lock.  Set WRITE_QUEUED
            //  to keep the guy from going away.
            //

            } else if ((++LoopsWithLockHeld >= 20) &&
                       !FlagOn(SharedCacheMap->Flags, WRITE_QUEUED | IS_CURSOR)) {

                SetFlag(SharedCacheMap->Flags, WRITE_QUEUED);
                SharedCacheMap->DirtyPages += 1;
                CcReleaseMasterLock( OldIrql );
                LoopsWithLockHeld = 0;
                CcAcquireMasterLock( &OldIrql );
                ClearFlag(SharedCacheMap->Flags, WRITE_QUEUED);
                SharedCacheMap->DirtyPages -= 1;
            }

            //
            //  Now loop back.
            //
            //  If we want to put this shared cache map at the end of the 
            //  dirty list, we will do it AFTER we determine the next shared
            //  cache map to go to.  This ensures that we loop through the entire
            //  list during this scan tick.
            //

            NextSharedCacheMap =
                CONTAINING_RECORD( SharedCacheMap->SharedCacheMapLinks.Flink,
                                   SHARED_CACHE_MAP,
                                   SharedCacheMapLinks );

            if (MoveBehindCursor) {

                RemoveEntryList( &CcLazyWriterCursor.SharedCacheMapLinks );
                InsertHeadList( &SharedCacheMap->SharedCacheMapLinks, &CcLazyWriterCursor.SharedCacheMapLinks );
                MoveBehindCursor = FALSE;
            }

            SharedCacheMap = NextSharedCacheMap;
        }

        DebugTrace( 0, me, "End of Lazy Writer Scan\n", 0 );

        //
        //  Queue up our  post tick workitems for this pass.
        //

        while (!IsListEmpty( &PostTickWorkQueue )) {

            PLIST_ENTRY Entry = RemoveHeadList( &PostTickWorkQueue );
            CcPostWorkQueue( CONTAINING_RECORD( Entry, WORK_QUEUE_ENTRY, WorkQueueLinks ),
                             &CcRegularWorkQueue );
        }

        //
        //  Now we can release the global list and loop back, per chance to sleep.
        //

        CcReleaseMasterLock( OldIrql );

        //
        //  Once again we need to give the deferred writes a poke.  We can have all dirty
        //  pages on disable_write_behind files but also have an external condition that
        //  caused the cached IO to be deferred. If so, this serves as our only chance to
        //  issue it when the condition clears.
        //

        if (!IsListEmpty(&CcDeferredWrites)) {

            CcPostDeferredWrites();
        }

        //
        //  Now go ahead and schedule the next scan.
        //

        CcScheduleLazyWriteScan( FALSE );

    //
    //  Basically, the Lazy Writer thread should never get an exception,
    //  so we put a try-except around it that bugchecks one way or the other.
    //  Better we bugcheck here than worry about what happens if we let one
    //  get by.
    //

    } except( CcExceptionFilter( GetExceptionCode() )) {

        CcBugCheck( GetExceptionCode(), 0, 0 );
    }
}


//
//  Internal support routine
//

LONG
CcExceptionFilter (
    IN NTSTATUS ExceptionCode
    )

/*++

Routine Description:

    This is the standard exception filter for worker threads which simply
    calls an FsRtl routine to see if an expected status is being raised.
    If so, the exception is handled, else we bugcheck.

Arguments:

    ExceptionCode - the exception code which was raised.

Return Value:

    EXCEPTION_EXECUTE_HANDLER if expected, else a Bugcheck occurs.

--*/

{
    DebugTrace(0, 0, "CcExceptionFilter %08lx\n", ExceptionCode);

    if (FsRtlIsNtstatusExpected( ExceptionCode )) {

        return EXCEPTION_EXECUTE_HANDLER;

    } else {

        return EXCEPTION_CONTINUE_SEARCH;
    }
}



//
//  Internal support routine
//

VOID
FASTCALL
CcPostWorkQueue (
    IN PWORK_QUEUE_ENTRY WorkQueueEntry,
    IN PLIST_ENTRY WorkQueue
    )

/*++

Routine Description:

    This routine queues a WorkQueueEntry, which has been allocated and
    initialized by the caller, to the WorkQueue for FIFO processing by
    the work threads.

Arguments:

    WorkQueueEntry - supplies a pointer to the entry to queue

Return Value:

    None

--*/

{
    KIRQL OldIrql;
    PLIST_ENTRY WorkerThreadEntry = NULL;

    ASSERT(FIELD_OFFSET(WORK_QUEUE_ITEM, List) == 0);

    DebugTrace(+1, me, "CcPostWorkQueue:\n", 0 );
    DebugTrace( 0, me, "    WorkQueueEntry = %08lx\n", WorkQueueEntry );

    //
    //  Queue the entry to the respective work queue.
    //

    CcAcquireWorkQueueLock( &OldIrql );
    InsertTailList( WorkQueue, &WorkQueueEntry->WorkQueueLinks );

    //
    //  Now, if we aren't throttled and have any more idle threads we can
    //  use, activate one.
    //

    if (!CcQueueThrottle && !IsListEmpty(&CcIdleWorkerThreadList)) {
        WorkerThreadEntry = RemoveHeadList( &CcIdleWorkerThreadList );
        CcNumberActiveWorkerThreads += 1;
    }
    CcReleaseWorkQueueLock( OldIrql );

    if (WorkerThreadEntry != NULL) {

        //
        //  This routine is a noop if the Flink is not NULL.
        //

        ((PWORK_QUEUE_ITEM)WorkerThreadEntry)->List.Flink = NULL;
        ExQueueWorkItem( (PWORK_QUEUE_ITEM)WorkerThreadEntry, CriticalWorkQueue );
    }

    //
    //  And return to our caller
    //

    DebugTrace(-1, me, "CcPostWorkQueue -> VOID\n", 0 );

    return;
}


//
//  Internal support routine
//

VOID
CcWorkerThread (
    PVOID ExWorkQueueItem
    )

/*++

Routine Description:

    This is worker thread routine for processing cache manager work queue
    entries.

Arguments:

    ExWorkQueueItem - The work item used for this thread

Return Value:

    None

--*/

{
    KIRQL OldIrql;
    PLIST_ENTRY WorkQueue;
    PWORK_QUEUE_ENTRY WorkQueueEntry;
    BOOLEAN RescanOk = FALSE;
    BOOLEAN DropThrottle = FALSE;
    IO_STATUS_BLOCK IoStatus;

    IoStatus.Status = STATUS_SUCCESS;
    IoStatus.Information = 0;

    ASSERT(FIELD_OFFSET(WORK_QUEUE_ENTRY, WorkQueueLinks) == 0);

    while (TRUE) {

        CcAcquireWorkQueueLock( &OldIrql );

        //
        //  If we just processed a throttled operation, drop the flag.
        //

        if (DropThrottle) {

            DropThrottle = CcQueueThrottle = FALSE;
        }

        //
        //  On requeue, push at end of the source queue and clear hint.
        //

        if (IoStatus.Information == CC_REQUEUE) {

            InsertTailList( WorkQueue, &WorkQueueEntry->WorkQueueLinks );
            IoStatus.Information = 0;
        }

        //
        //  First see if there is something in the express queue.
        //

        if (!IsListEmpty(&CcExpressWorkQueue)) {
            WorkQueue = &CcExpressWorkQueue;

        //
        //  If there was nothing there, then try the regular queue.
        //

        } else if (!IsListEmpty(&CcRegularWorkQueue)) {
            WorkQueue = &CcRegularWorkQueue;

        //
        //  Else we can break and go idle.
        //

        } else {

            break;
        }

        WorkQueueEntry = CONTAINING_RECORD( WorkQueue->Flink, WORK_QUEUE_ENTRY, WorkQueueLinks );

        //
        //  If this is an EventSet, throttle down to a single thread to be sure
        //  that this event fires after all preceding workitems have completed.
        //

        if (WorkQueueEntry->Function == EventSet && CcNumberActiveWorkerThreads > 1) {

            CcQueueThrottle = TRUE;
            break;
        }

        //
        //  Pop the workitem off: we will execute it now.
        //

        RemoveHeadList( WorkQueue );

        CcReleaseWorkQueueLock( OldIrql );

        //
        //  Process the entry within a try-except clause, so that any errors
        //  will cause us to continue after the called routine has unwound.
        //

        try {

            switch (WorkQueueEntry->Function) {

            //
            //  Perform read ahead
            //

            case ReadAhead:

                DebugTrace( 0, me, "CcWorkerThread Read Ahead FileObject = %08lx\n",
                            WorkQueueEntry->Parameters.Read.FileObject );

                CcPerformReadAhead( WorkQueueEntry->Parameters.Read.FileObject );

                break;

            //
            //  Perform write behind
            //

            case WriteBehind:

                DebugTrace( 0, me, "CcWorkerThread WriteBehind SharedCacheMap = %08lx\n",
                            WorkQueueEntry->Parameters.Write.SharedCacheMap );

                //
                //  While CcWriteBehind is running, we mark this thread as a
                //  MemoryMaker so that Mm will allow pool allocations to 
                //  succeed when we are getting into low-resource situations.
                //  This helps avoid loss delayed write error in low-resource
                //  scenarios.
                //

                PsGetCurrentThread()->MemoryMaker = 1;

                CcWriteBehind( WorkQueueEntry->Parameters.Write.SharedCacheMap, &IoStatus );
                RescanOk = (BOOLEAN)NT_SUCCESS(IoStatus.Status);

                PsGetCurrentThread()->MemoryMaker = 0;
                break;


            //
            //  Perform set event
            //
        
            case EventSet:

                DebugTrace( 0, me, "CcWorkerThread SetEvent Event = %08lx\n",
                            WorkQueueEntry->Parameters.Event.Event );

                KeSetEvent( WorkQueueEntry->Parameters.Event.Event, 0, FALSE );
                DropThrottle = TRUE;
                break;

            //
            //  Perform Lazy Write Scan
            //

            case LazyWriteScan:

                DebugTrace( 0, me, "CcWorkerThread Lazy Write Scan\n", 0 );

                CcLazyWriteScan();
                break;
            }

        }
        except( CcExceptionFilter( GetExceptionCode() )) {

            //
            //  If we hit an exception in this thread, we need to make sure
            //  that if we had made this thread a memory maker that flag is
            //  cleared in the thread structure because this thread will be
            //  reused by arbitrary system worker threads that should not have
            //  this designation.
            //
            
            if (WorkQueueEntry->Function == WriteBehind) {
                
                PsGetCurrentThread()->MemoryMaker = 0;
            }
        }

        //
        //  If not a requeue request, free the workitem.
        //

        if (IoStatus.Information != CC_REQUEUE) {

            CcFreeWorkQueueEntry( WorkQueueEntry );
        }
    }

    //
    //  No more work.  Requeue our worker thread entry and get out.
    //

    InsertTailList( &CcIdleWorkerThreadList,
                    &((PWORK_QUEUE_ITEM)ExWorkQueueItem)->List );
    CcNumberActiveWorkerThreads -= 1;

    CcReleaseWorkQueueLock( OldIrql );

    if (!IsListEmpty(&CcDeferredWrites) && (CcTotalDirtyPages >= 20) && RescanOk) {
        CcLazyWriteScan();
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\cache\fssup.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    fssup.c

Abstract:

    This module implements the File System support routines for the
    Cache subsystem.

--*/

#include "cc.h"

//
//  The Bugcheck file id for this module
//

#define BugCheckFileId                   (CACHE_BUG_CHECK_FSSUP)

//
//  Define our debug constant
//

#define me 0x00000001

//
//  For your debugging pleasure, if the flag doesn't move!  (Currently not used)
//

#define IsSyscacheFile(FO) (((FO) != NULL) &&                                               \
                            (*(PUSHORT)(FO)->FsContext == 0X705) &&                         \
                            FlagOn(*(PULONG)((PCHAR)(FO)->FsContext + 0x48), 0x80000000))

extern POBJECT_TYPE IoFileObjectType;
extern ULONG MmLargeSystemCache;

VOID
CcUnmapAndPurge(
    IN PSHARED_CACHE_MAP SharedCacheMap
    );

VOID
CcDeleteMbcb(
    IN PSHARED_CACHE_MAP SharedCacheMap
    );

VOID
CcDeleteBcbs (
    IN PSHARED_CACHE_MAP SharedCacheMap
    );

VOID
CcPurgeAndClearCacheSection (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN PLARGE_INTEGER FileOffset
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,CcInitializeCacheManager)
#pragma alloc_text(PAGE,CcZeroData)
#endif


BOOLEAN
CcInitializeCacheManager (
    )

/*++

Routine Description:

    This routine must be called during system initialization before the
    first call to any file system, to allow the Cache Manager to initialize
    its global data structures.  This routine has no dependencies on other
    system components being initialized.

Arguments:

    None

Return Value:

    TRUE if initialization was successful

--*/

{
    CLONG i;
    ULONG Index;
    PGENERAL_LOOKASIDE Lookaside;
    USHORT NumberOfItems;
    PKPRCB Prcb;
    PWORK_QUEUE_ITEM WorkItem;

#if DBG
    CcBcbCount = 0;
    InitializeListHead( &CcBcbList );
#endif

    //
    //  Figure out the timeout clock tick for the lazy writer.
    //

    CcIdleDelayTick = LAZY_WRITER_IDLE_DELAY / KeQueryTimeIncrement();

    //
    //  Initialize shared cache map list structures
    //

    InitializeListHead( &CcCleanSharedCacheMapList );
    InitializeListHead( &CcDirtySharedCacheMapList.SharedCacheMapLinks );
    CcDirtySharedCacheMapList.Flags = IS_CURSOR;
    InsertTailList( &CcDirtySharedCacheMapList.SharedCacheMapLinks,
                    &CcLazyWriterCursor.SharedCacheMapLinks );
    CcLazyWriterCursor.Flags = IS_CURSOR;

    //
    //  Initialize worker thread structures
    //

    InitializeListHead( &CcIdleWorkerThreadList );
    InitializeListHead( &CcExpressWorkQueue );
    InitializeListHead( &CcRegularWorkQueue );
    InitializeListHead( &CcPostTickWorkQueue );

    //
    //  Set the number of worker threads based on the system size.
    //

    CcCapturedSystemSize = MmQuerySystemSize();
    if (CcNumberWorkerThreads == 0) {

        switch (CcCapturedSystemSize) {
        case MmSmallSystem:
            CcNumberWorkerThreads = ExCriticalWorkerThreads - 1;
            CcDirtyPageThreshold = MmNumberOfPhysicalPages / 8;
            CcAggressiveZeroThreshold = 1;
            break;

        case MmMediumSystem:
            CcNumberWorkerThreads = ExCriticalWorkerThreads - 1;
            CcDirtyPageThreshold = MmNumberOfPhysicalPages / 4;
            CcAggressiveZeroThreshold = 2;
            break;

        case MmLargeSystem:
            CcNumberWorkerThreads = ExCriticalWorkerThreads - 2;

            if (MmSystemCacheWs.MaximumWorkingSetSize > ((4*1024*1024)/PAGE_SIZE)) {

                CcDirtyPageThreshold = (ULONG)(MmSystemCacheWs.MaximumWorkingSetSize -
                                                        ((2*1024*1024)/PAGE_SIZE));

                if (CcDirtyPageThreshold > (MmNumberOfPhysicalPages / 2)) {

                    //
                    //  We don't want the system cache to ever generate more dirty data
                    //  than can be stored in half of the physical memory on the machine.
                    //  Otherwise, the machine gets too much dirty data to be
                    //  able to flush.
                    //

                    CcDirtyPageThreshold = MmNumberOfPhysicalPages / 2;
                }
            
            } else {
            
                CcDirtyPageThreshold = MmNumberOfPhysicalPages / 4 +
                                        MmNumberOfPhysicalPages / 8;
            }
            
            CcAggressiveZeroThreshold = 4;
            break;

        default:
            CcNumberWorkerThreads = 1;
            CcDirtyPageThreshold = MmNumberOfPhysicalPages / 8;
        }

        CcDirtyPageTarget = CcDirtyPageThreshold / 2 +
                            CcDirtyPageThreshold / 4;
    }

    CcAggressiveZeroCount = 0;

    //
    //  Now allocate and initialize the above number of worker thread
    //  items.
    //

    for (i = 0; i < CcNumberWorkerThreads; i++) {

        WorkItem = ExAllocatePoolWithTag( NonPagedPool, sizeof(WORK_QUEUE_ITEM), 'qWcC' );

        if (WorkItem == NULL) {

            CcBugCheck( 0, 0, 0 );
        }

        //
        //  Initialize the work queue item and insert in our queue
        //  of potential worker threads.
        //

        ExInitializeWorkItem( WorkItem, CcWorkerThread, WorkItem );
        InsertTailList( &CcIdleWorkerThreadList, &WorkItem->List );
    }

    //
    //  Initialize the Lazy Writer thread structure, and start him up.
    //

    RtlZeroMemory( &LazyWriter, sizeof(LAZY_WRITER) );

    InitializeListHead( &LazyWriter.WorkQueue );

    //
    //  Initialize the Scan Dpc and Timer.
    //

    KeInitializeDpc( &LazyWriter.ScanDpc, &CcScanDpc, NULL );
    KeInitializeTimer( &LazyWriter.ScanTimer );

    //
    //  Now initialize the lookaside list for allocating Work Queue entries.
    //

    switch ( CcCapturedSystemSize ) {

        //
        // ~512 bytes
        //

    case MmSmallSystem :
        NumberOfItems = 32;
        break;

        //
        // ~1k bytes
        //

    case MmMediumSystem :
        NumberOfItems = 64;
        break;

        //
        // ~2k bytes
        //

    case MmLargeSystem :
        NumberOfItems = 128;
        if (MmIsThisAnNtAsSystem()) {
            NumberOfItems += 128;
        }

        break;
    }

    ExInitializeSystemLookasideList( &CcTwilightLookasideList,
                                     NonPagedPool,
                                     sizeof( WORK_QUEUE_ENTRY ),
                                     'kWcC',
                                     NumberOfItems,
                                     &ExSystemLookasideListHead );

    //
    // Initialize the per processor nonpaged lookaside lists and descriptors.
    //

    for (Index = 0; Index < (ULONG)KeNumberProcessors; Index += 1) {
        Prcb = KiProcessorBlock[Index];

        //
        // Initialize the large IRP per processor lookaside pointers.
        //

        Prcb->PPLookasideList[LookasideTwilightList].L = &CcTwilightLookasideList;
        Lookaside = ExAllocatePoolWithTag( NonPagedPool,
                                           sizeof(GENERAL_LOOKASIDE),
                                           'KWcC');

        if (Lookaside != NULL) {
            ExInitializeSystemLookasideList( Lookaside,
                                             NonPagedPool,
                                             sizeof( WORK_QUEUE_ENTRY ),
                                             'KWcC',
                                             NumberOfItems,
                                             &ExSystemLookasideListHead );

        } else {
            Lookaside = &CcTwilightLookasideList;
        }

        Prcb->PPLookasideList[LookasideTwilightList].P = Lookaside;
    }

    //
    //  Initialize the Deferred Write List.
    //

    KeInitializeSpinLock( &CcDeferredWriteSpinLock );
    InitializeListHead( &CcDeferredWrites );

    //
    //  Initialize the Vacbs.
    //

    CcInitializeVacbs();

    return TRUE;
}


VOID
CcInitializeCacheMap (
    __in PFILE_OBJECT FileObject,
    __in PCC_FILE_SIZES FileSizes,
    __in BOOLEAN PinAccess,
    __in PCACHE_MANAGER_CALLBACKS Callbacks,
    __in PVOID LazyWriteContext
    )

/*++

Routine Description:

    This routine is intended to be called by File Systems only.  It
    initializes the cache maps for data caching.  It should be called
    every time a file is opened or created, and NO_INTERMEDIATE_BUFFERING
    was specified as FALSE.

Arguments:

    FileObject - A pointer to the newly-created file object.

    FileSizes - A pointer to AllocationSize, FileSize and ValidDataLength
                for the file.  ValidDataLength should contain MAXLONGLONG if
                valid data length tracking and callbacks are not desired.

    PinAccess - FALSE if file will be used exclusively for Copy and Mdl
                access, or TRUE if file will be used for Pin access.
                (Files for Pin access are not limited in size as the caller
                must access multiple areas of the file at once.)

    Callbacks - Structure of callbacks used by the Lazy Writer

    LazyWriteContext - Parameter to be passed in to above routine.

Return Value:

    None.  If an error occurs, this routine will Raise the status.

--*/

{
    KIRQL OldIrql;
    PSHARED_CACHE_MAP SharedCacheMap;
    PVOID CacheMapToFree = NULL;
    CC_FILE_SIZES LocalSizes;
    LOGICAL WeSetBeingCreated = FALSE;
    LOGICAL SharedListOwned = FALSE;
    LOGICAL MustUninitialize = FALSE;
    LOGICAL WeCreated = FALSE;
    PPRIVATE_CACHE_MAP PrivateCacheMap;
    NTSTATUS Status = STATUS_SUCCESS;

    DebugTrace(+1, me, "CcInitializeCacheMap:\n", 0 );
    DebugTrace( 0, me, "    FileObject = %08lx\n", FileObject );
    DebugTrace( 0, me, "    FileSizes = %08lx\n", FileSizes );

    //
    //  Make a local copy of the passed in file sizes before acquiring
    //  the spin lock.
    //

    LocalSizes = *FileSizes;

    //
    //  If no FileSize was given, set to one byte before maximizing below.
    //

    if (LocalSizes.AllocationSize.QuadPart == 0) {
        LocalSizes.AllocationSize.LowPart += 1;
    }

    //
    //  If caller has Write access or will allow write, then round
    //  size to next create modulo.  (***Temp*** there may be too many
    //  apps that end up allowing shared write, thanks to our Dos heritage,
    //  to keep that part of the check in.)
    //

    if (FileObject->WriteAccess /*|| FileObject->SharedWrite */) {

        LocalSizes.AllocationSize.QuadPart = LocalSizes.AllocationSize.QuadPart + (LONGLONG)(DEFAULT_CREATE_MODULO - 1);
        LocalSizes.AllocationSize.LowPart &= ~(DEFAULT_CREATE_MODULO - 1);

    } else {

        LocalSizes.AllocationSize.QuadPart = LocalSizes.AllocationSize.QuadPart + (LONGLONG)(VACB_MAPPING_GRANULARITY - 1);
        LocalSizes.AllocationSize.LowPart &= ~(VACB_MAPPING_GRANULARITY - 1);
    }

    //
    //  Do the allocate of the SharedCacheMap, based on an unsafe test,
    //  while not holding a spinlock.  If the allocation fails, it's ok
    //  to fail the request even though the test was unsafe.
    //

    if (FileObject->SectionObjectPointer->SharedCacheMap == NULL) {

restart:

        ASSERT (CacheMapToFree == NULL);

        SharedCacheMap = ExAllocatePoolWithTag( NonPagedPool, sizeof(SHARED_CACHE_MAP), 'cScC' );

        if (SharedCacheMap == NULL) {
            DebugTrace( 0, 0, "Failed to allocate SharedCacheMap\n", 0 );
            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }

        //
        //  Stash a copy of it so we can free it in the error path below.
        //

        CacheMapToFree = SharedCacheMap;

        //
        //  Zero the SharedCacheMap and fill in the nonzero portions later.
        //

        RtlZeroMemory( SharedCacheMap, sizeof(SHARED_CACHE_MAP) );

        //
        //  Now initialize the Shared Cache Map.
        //

        SharedCacheMap->NodeTypeCode = CACHE_NTC_SHARED_CACHE_MAP;
        SharedCacheMap->NodeByteSize = sizeof(SHARED_CACHE_MAP);
        SharedCacheMap->FileObject = FileObject;
        SharedCacheMap->FileSize = LocalSizes.FileSize;
        SharedCacheMap->ValidDataLength = LocalSizes.ValidDataLength;
        SharedCacheMap->ValidDataGoal = LocalSizes.ValidDataLength;
        //  SharedCacheMap->Section set below

        //
        //  Initialize the spin locks.
        //

        KeInitializeSpinLock( &SharedCacheMap->ActiveVacbSpinLock );
        KeInitializeSpinLock( &SharedCacheMap->BcbSpinLock );

        ExInitializePushLock( &SharedCacheMap->VacbPushLock );

        if (PinAccess) {
            SetFlag(SharedCacheMap->Flags, PIN_ACCESS);
        }

        //
        //  If this file has FO_SEQUENTIAL_ONLY set, then remember that
        //  in the SharedCacheMap.
        //

        if (FlagOn(FileObject->Flags, FO_SEQUENTIAL_ONLY)) {
            SetFlag(SharedCacheMap->Flags, ONLY_SEQUENTIAL_ONLY_SEEN);
        }

        //
        //  Do the round-robin allocation of the spinlock for the shared
        //  cache map.  Note the manipulation of the next
        //  counter is safe, since we have the CcMasterSpinLock
        //  exclusive.
        //

        InitializeListHead( &SharedCacheMap->BcbList );
        SharedCacheMap->Callbacks = Callbacks;
        SharedCacheMap->LazyWriteContext = LazyWriteContext;

        //
        //  Initialize listhead for all PrivateCacheMaps
        //

        InitializeListHead( &SharedCacheMap->PrivateList );
    }

    //
    //  Serialize Creation/Deletion of all Shared CacheMaps
    //

    SharedListOwned = TRUE;

    CcAcquireMasterLock( &OldIrql );

    //
    //  Check for second initialization of same file object
    //

    if (FileObject->PrivateCacheMap != NULL) {

        DebugTrace( 0, 0, "CacheMap already initialized\n", 0 );
        CcReleaseMasterLock( OldIrql );
        if (CacheMapToFree != NULL) {
            ExFreePool(CacheMapToFree);
        }
        DebugTrace(-1, me, "CcInitializeCacheMap -> VOID\n", 0 );
        return;
    }

    //
    //  Get current Shared Cache Map pointer indirectly off of the file object.
    //  (The actual pointer is typically in a file system data structure, such
    //  as an Fcb.)
    //

    SharedCacheMap = FileObject->SectionObjectPointer->SharedCacheMap;

    //
    //  If there is no SharedCacheMap, then we must create a section and
    //  the SharedCacheMap structure.
    //

    if (SharedCacheMap == NULL) {

        //
        //  Insert the new SharedCacheMap.
        //

        if (CacheMapToFree == NULL) {
            CcReleaseMasterLock( OldIrql );
            SharedListOwned = FALSE;
            goto restart;
        }

        SharedCacheMap = CacheMapToFree;
        CacheMapToFree = NULL;

        //
        //  Insert the new Shared Cache Map in the global list
        //

        //
        //  Note: We do NOT use the common CcInsertIntoCleanSharedCacheMapList
        //  routine here because this shared cache map does not meet the
        //  validation conditions we check for in that routine since it is 
        //  not finished being initialized.
        //

        InsertTailList( &CcCleanSharedCacheMapList,
                        &SharedCacheMap->SharedCacheMapLinks );

        WeCreated = TRUE;

        //
        //  Finally, store the pointer to the Shared Cache Map back
        //  via the indirect pointer in the File Object.
        //

        FileObject->SectionObjectPointer->SharedCacheMap = SharedCacheMap;

        //
        //  We must reference this file object so that it cannot go away
        //  until we do CcUninitializeCacheMap below.  Note we cannot
        //  find or rely on the FileObject that Memory Management has,
        //  although normally it will be this same one anyway.
        //

        ObReferenceObject ( FileObject );

    } else {

        //
        //  If this file has FO_SEQUENTIAL_ONLY clear, then remember that
        //  in the SharedCacheMap.
        //

        if (!FlagOn(FileObject->Flags, FO_SEQUENTIAL_ONLY)) {
            ClearFlag(SharedCacheMap->Flags, ONLY_SEQUENTIAL_ONLY_SEEN);
        }
    }

    //
    //  If this file is opened for random access, remember this in
    //  the SharedCacheMap.
    //

    if (FlagOn(FileObject->Flags, FO_RANDOM_ACCESS)) {
        SetFlag(SharedCacheMap->Flags, RANDOM_ACCESS_SEEN);
    }

    //
    //  Make sure that no one is trying to lazy delete it in the case
    //  that the Cache Map was already there.
    //

    ClearFlag(SharedCacheMap->Flags, TRUNCATE_REQUIRED);

    //
    //  In case there has been a CcUnmapAndPurge call, we check here if we
    //  if we need to recreate the section and map it.
    //

    if ((SharedCacheMap->Vacbs == NULL) &&
        !FlagOn(SharedCacheMap->Flags, BEING_CREATED)) {

        //
        //  Increment the OpenCount on the CacheMap.
        //

        CcIncrementOpenCount( SharedCacheMap, 'onnI' );

        //
        //  We still want anyone else to wait.
        //

        SetFlag(SharedCacheMap->Flags, BEING_CREATED);

        //
        //  If there is a create event, then this must be the path where we
        //  we were only unmapped.  We will just clear it here again in case
        //  someone needs to wait again this time too.
        //

        if (SharedCacheMap->CreateEvent != NULL) {

            KeInitializeEvent( SharedCacheMap->CreateEvent,
                               NotificationEvent,
                               FALSE );
        }

        //
        //  Release global resource
        //

        CcReleaseMasterLock( OldIrql );
        SharedListOwned = FALSE;

        //
        //  Signify we have incremented the open count.
        //

        MustUninitialize = TRUE;

        //
        //  Signify we have marked BEING_CREATED in the CacheMap flags.
        //

        WeSetBeingCreated = TRUE;

        //
        //  We have to test this, because the section may only be unmapped.
        //

        if (SharedCacheMap->Section == NULL) {

            //
            //  Call MM to create a section for this file, for the calculated
            //  section size.  Note that we have the choice in this service to
            //  pass in a FileHandle or a FileObject pointer, but not both.
            //  Use the pointer as it results in much faster performance.
            //

            DebugTrace( 0, mm, "MmCreateSection:\n", 0 );
            DebugTrace2(0, mm, "    MaximumSize = %08lx, %08lx\n",
                        LocalSizes.AllocationSize.LowPart,
                        LocalSizes.AllocationSize.HighPart );
            DebugTrace( 0, mm, "    FileObject = %08lx\n", FileObject );

            SharedCacheMap->Status = MmCreateSection( &SharedCacheMap->Section,
                                                      SECTION_MAP_READ
                                                        | SECTION_MAP_WRITE
                                                        | SECTION_QUERY,
                                                      NULL,
                                                      &LocalSizes.AllocationSize,
                                                      PAGE_READWRITE,
                                                      SEC_COMMIT,
                                                      NULL,
                                                      FileObject );

            DebugTrace( 0, mm, "    <Section = %08lx\n", SharedCacheMap->Section );

            if (!NT_SUCCESS( SharedCacheMap->Status )){
                DebugTrace( 0, 0, "Error from MmCreateSection = %08lx\n",
                            SharedCacheMap->Status );

                SharedCacheMap->Section = NULL;
                Status = FsRtlNormalizeNtstatus( SharedCacheMap->Status,
                                                 STATUS_UNEXPECTED_MM_CREATE_ERR );
                goto exitfinally;
            }

            ObDeleteCapturedInsertInfo(SharedCacheMap->Section);

            //
            //  If this is a stream file object, then no user can map it,
            //  and we should keep the modified page writer out of it.
            //

            if (!FlagOn(((PFSRTL_COMMON_FCB_HEADER)FileObject->FsContext)->Flags2,
                        FSRTL_FLAG2_DO_MODIFIED_WRITE) &&
                (FileObject->FsContext2 == NULL)) {

                MmDisableModifiedWriteOfSection( FileObject->SectionObjectPointer );
                CcAcquireMasterLock( &OldIrql );
                SetFlag(SharedCacheMap->Flags, MODIFIED_WRITE_DISABLED);
                CcReleaseMasterLock( OldIrql );
            }

            //
            //  Create the Vacb array.
            //

            Status = CcCreateVacbArray( SharedCacheMap, LocalSizes.AllocationSize );
            if (!NT_SUCCESS(Status)) {
                goto exitfinally;
            }
        }

        //
        //  If the section already exists, we still have to call MM to
        //  extend, in case it is not large enough.
        //

        else {

            if ( LocalSizes.AllocationSize.QuadPart > SharedCacheMap->SectionSize.QuadPart ) {

                DebugTrace( 0, mm, "MmExtendSection:\n", 0 );
                DebugTrace( 0, mm, "    Section = %08lx\n", SharedCacheMap->Section );
                DebugTrace2(0, mm, "    Size = %08lx, %08lx\n",
                            LocalSizes.AllocationSize.LowPart,
                            LocalSizes.AllocationSize.HighPart );

                Status = MmExtendSection( SharedCacheMap->Section,
                                          &LocalSizes.AllocationSize,
                                          TRUE );

                if (!NT_SUCCESS(Status)) {

                    DebugTrace( 0, 0, "Error from MmExtendSection, Status = %08lx\n",
                                Status );

                    Status = FsRtlNormalizeNtstatus( Status,
                                                     STATUS_UNEXPECTED_MM_EXTEND_ERR );
                    goto exitfinally;
                }
            }

            //
            //  Extend the Vacb array.
            //

            Status = CcExtendVacbArray( SharedCacheMap, LocalSizes.AllocationSize );
            if (!NT_SUCCESS(Status)) {
                goto exitfinally;
            }
        }

        //
        //  Now show that we are all done and resume any waiters.
        //

        CcAcquireMasterLock( &OldIrql );
        ClearFlag(SharedCacheMap->Flags, BEING_CREATED);
        if (SharedCacheMap->CreateEvent != NULL) {
            KeSetEvent( SharedCacheMap->CreateEvent, 0, FALSE );
        }
        CcReleaseMasterLock( OldIrql );
        WeSetBeingCreated = FALSE;
    }

    //
    //  Else if the section is already there, we make sure it is large
    //  enough by calling CcExtendCacheSection.
    //

    else {

        //
        //  If the SharedCacheMap is currently being created we have
        //  to optionally create and wait on an event for it.  Note that
        //  the only safe time to delete the event is in
        //  CcUninitializeCacheMap, because we otherwise have no way of
        //  knowing when everyone has reached the KeWaitForSingleObject.
        //

        if (FlagOn(SharedCacheMap->Flags, BEING_CREATED)) {

            if (SharedCacheMap->CreateEvent == NULL) {

                SharedCacheMap->CreateEvent = (PKEVENT)ExAllocatePoolWithTag( NonPagedPool,
                                                                              sizeof(KEVENT),
                                                                              'vEcC' );

                if (SharedCacheMap->CreateEvent == NULL) {
                    DebugTrace( 0, 0, "Failed to allocate CreateEvent\n", 0 );

                    CcReleaseMasterLock( OldIrql );
                    SharedListOwned = FALSE;

                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto exitfinally;
                }

                KeInitializeEvent( SharedCacheMap->CreateEvent,
                                   NotificationEvent,
                                   FALSE );
            }

            //
            //  Increment the OpenCount on the CacheMap.
            //

            CcIncrementOpenCount( SharedCacheMap, 'ecnI' );

            //
            //  Release global resource before waiting
            //

            CcReleaseMasterLock( OldIrql );
            SharedListOwned = FALSE;

            MustUninitialize = TRUE;

            DebugTrace( 0, 0, "Waiting on CreateEvent\n", 0 );

            KeWaitForSingleObject( SharedCacheMap->CreateEvent,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   (PLARGE_INTEGER)NULL);

            //
            //  If the real creator got an error, then we must bomb
            //  out too.
            //

            if (!NT_SUCCESS(SharedCacheMap->Status)) {
                Status = FsRtlNormalizeNtstatus( SharedCacheMap->Status,
                                                 STATUS_UNEXPECTED_MM_CREATE_ERR );
                goto exitfinally;
            }
        }
        else {

            //
            //  Increment the OpenCount on the CacheMap.
            //

            CcIncrementOpenCount( SharedCacheMap, 'esnI' );

            //
            //  Release global resource
            //

            CcReleaseMasterLock( OldIrql );
            SharedListOwned = FALSE;
            MustUninitialize = TRUE;
        }
    }

    if (CacheMapToFree != NULL) {
        ExFreePool( CacheMapToFree );
        CacheMapToFree = NULL;
    }

    //
    //  Now allocate (if local one already in use) and initialize
    //  the Private Cache Map.
    //

    PrivateCacheMap = &SharedCacheMap->PrivateCacheMap;

    //
    //  See if we should allocate a PrivateCacheMap while not holding
    //  a spinlock.
    //

    if (PrivateCacheMap->NodeTypeCode != 0) {

restart2:

        CacheMapToFree = ExAllocatePoolWithTag( NonPagedPool, sizeof(PRIVATE_CACHE_MAP), 'cPcC' );

        if (CacheMapToFree == NULL) {
            DebugTrace( 0, 0, "Failed to allocate PrivateCacheMap\n", 0 );

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto exitfinally;
        }

    }

    //
    //  Insert the new PrivateCacheMap in the list off the SharedCacheMap.
    //

    SharedListOwned = TRUE;
    CcAcquireMasterLock( &OldIrql );

    //
    //  Now make sure there is still no PrivateCacheMap, and if so just get out.
    //

    if (FileObject->PrivateCacheMap == NULL) {

        //
        //  Is the local one already in use?
        //

        if (PrivateCacheMap->NodeTypeCode != 0) {

            //
            //  Use the one allocated above, if there is one, else go to pool now.
            //

            if (CacheMapToFree == NULL) {
                CcReleaseMasterLock( OldIrql );
                SharedListOwned = FALSE;

                goto restart2;
            }

            PrivateCacheMap = CacheMapToFree;
            CacheMapToFree = NULL;
        }

        RtlZeroMemory( PrivateCacheMap, sizeof(PRIVATE_CACHE_MAP) );

        PrivateCacheMap->NodeTypeCode = CACHE_NTC_PRIVATE_CACHE_MAP;
        PrivateCacheMap->FileObject = FileObject;
        PrivateCacheMap->ReadAheadMask = PAGE_SIZE - 1;

        //
        //  Initialize the spin lock.
        //

        KeInitializeSpinLock( &PrivateCacheMap->ReadAheadSpinLock );

        InsertTailList( &SharedCacheMap->PrivateList, &PrivateCacheMap->PrivateLinks );

        FileObject->PrivateCacheMap = PrivateCacheMap;

    } else {

        //
        //  We raced with another initializer for the same fileobject and must
        //  drop our (to this point speculative) opencount.
        //

        ASSERT( SharedCacheMap->OpenCount > 1 );

        CcDecrementOpenCount( SharedCacheMap, 'rpnI' );
        SharedCacheMap = NULL;
    }

    MustUninitialize = FALSE;

exitfinally:

    //
    //  See if we got an error and must uninitialize the SharedCacheMap
    //

    if (MustUninitialize) {

        if (!SharedListOwned) {
            CcAcquireMasterLock( &OldIrql );
        }
        if (WeSetBeingCreated) {
            if (SharedCacheMap->CreateEvent != NULL) {
                KeSetEvent( SharedCacheMap->CreateEvent, 0, FALSE );
            }
            ClearFlag(SharedCacheMap->Flags, BEING_CREATED);
        }

        //
        //  Now release our open count.
        //

        CcDecrementOpenCount( SharedCacheMap, 'umnI' );

        if ((SharedCacheMap->OpenCount == 0) &&
            !FlagOn(SharedCacheMap->Flags, WRITE_QUEUED) &&
            (SharedCacheMap->DirtyPages == 0)) {

            //
            //  It is necessary to eliminate the structure now.  We should
            //  be guaranteed that our dereference will not result in close
            //  due to the caller's reference on the fileobject, unlike the
            //  comment in the original code, below, would indicate.
            //
            //  Not removing this structure can result in problems if the file
            //  is also mapped and the mapped page writer extends VDL. An FS
            //  will use CcSetFileSizes and cause us to issue a recursive flush
            //  of the same range, resulting in a self-colliding page flush and
            //  a deadlock.
            //
            //  We also think that file extension/truncation in the interim
            //  (if the section create failed) would result in an inconsistent
            //  "resurrected" cache map if we managed to use the one we have
            //  now.  Note CcSetFileSizes aborts if the section is NULL.
            //

            CcDeleteSharedCacheMap( SharedCacheMap, OldIrql, FALSE );

        } else {

            CcReleaseMasterLock( OldIrql );
        }

        SharedListOwned = FALSE;

    } else if (SharedCacheMap != NULL) {

        PCACHE_UNINITIALIZE_EVENT CUEvent, EventNext;

        //
        //  If we did not create this SharedCacheMap, then there is a
        //  possibility that it is in the dirty list.  Once we are sure
        //  we have the spinlock, just make sure it is in the clean list
        //  if there are no dirty bytes and the open count is nonzero.
        //  (The latter test is almost guaranteed, of course, but we check
        //  it to be safe.)
        //

        if (!SharedListOwned) {

            CcAcquireMasterLock( &OldIrql );
            SharedListOwned = TRUE;
        }

        if (!WeCreated                        &&
            (SharedCacheMap->DirtyPages == 0) &&
            (SharedCacheMap->OpenCount != 0)) {

            RemoveEntryList( &SharedCacheMap->SharedCacheMapLinks );
            CcInsertIntoCleanSharedCacheMapList( SharedCacheMap );
        }

        //
        //  If there is a process waiting on an uninitialize on this
        //  cache map to complete, let the thread that is waiting go,
        //  since the uninitialize is now complete.
        //
        
        CUEvent = SharedCacheMap->UninitializeEvent;

        while (CUEvent != NULL) {
            CUEvent = ClearMmWaiterFlag( PCACHE_UNINITIALIZE_EVENT, CUEvent );
            EventNext = CUEvent->Next;
            KeSetEvent(&CUEvent->Event, 0, FALSE);
            CUEvent = EventNext;
        }

        SharedCacheMap->UninitializeEvent = NULL;
        ClearFlag( SharedCacheMap->Flags, WAITING_FOR_TEARDOWN );
    }

    //
    //  Release global resource
    //

    if (SharedListOwned) {
        CcReleaseMasterLock( OldIrql );
    }

    if (CacheMapToFree != NULL) {
        ExFreePool(CacheMapToFree);
    }

    if (!NT_SUCCESS(Status)) {
        DebugTrace(-1, me, "CcInitializeCacheMap -> RAISING EXCEPTION\n", 0 );
        ExRaiseStatus(Status);
    }

    DebugTrace(-1, me, "CcInitializeCacheMap -> VOID\n", 0 );

    return;
}


BOOLEAN
CcUninitializeCacheMap (
    __in PFILE_OBJECT FileObject,
    __in_opt PLARGE_INTEGER TruncateSize,
    __in_opt PCACHE_UNINITIALIZE_EVENT UninitializeEvent
    )

/*++

Routine Description:

    This routine uninitializes the previously initialized Shared and Private
    Cache Maps.  This routine is only intended to be called by File Systems.
    It should be called when the File System receives a cleanup call on the
    File Object.

    A File System which supports data caching must always call this routine
    whenever it closes a file, whether the caller opened the file with
    NO_INTERMEDIATE_BUFFERING as FALSE or not.  This is because the final
    cleanup of a file related to truncation or deletion of the file, can
    only occur on the last close, whether the last closer cached the file
    or not.  When CcUnitializeCacheMap is called on a file object for which
    CcInitializeCacheMap was never called, the call has a benign effect
    iff no one has truncated or deleted the file; otherwise the necessary
    cleanup relating to the truncate or close is performed.

    In summary, CcUnitializeCacheMap does the following:

        If the caller had Write or Delete access, the cache is flushed.
        (This could change with lazy writing.)

        If a Cache Map was initialized on this File Object, it is
        unitialized (unmap any views, delete section, and delete
        Cache Map structures).

        On the last Cleanup, if the file has been deleted, the
        Section is forced closed.  If the file has been truncated, then
        the truncated pages are purged from the cache.

Arguments:

    FileObject - File Object which was previously supplied to
                 CcInitializeCacheMap.

    TruncateSize - If specified, the file was truncated to the specified
                   size, and the cache should be purged accordingly.

    UninitializeEvent - If specified, then the provided event will be set
                        to the signaled state when the actual flush is
                        completed.  This is only of interest to file systems
                        that require that they be notified when a cache flush
                        operation has completed.  Due to network protocol
                        restrictions, it is critical that network file
                        systems know exactly when a cache flush operation
                        completes, by specifying this event, they can be
                        notified when the cache section is finally purged
                        if the section is "lazy-deleted".

ReturnValue:

    FALSE if Section was not closed.
    TRUE if Section was closed.

--*/

{
    KIRQL OldIrql;
    PSHARED_CACHE_MAP SharedCacheMap;
    ULONG ActivePage;
    ULONG PageIsDirty;
    PVACB ActiveVacb = NULL;
    BOOLEAN SectionClosed = FALSE;
    PPRIVATE_CACHE_MAP PrivateCacheMap;

    DebugTrace(+1, me, "CcUninitializeCacheMap:\n", 0 );
    DebugTrace( 0, me, "    FileObject = %08lx\n", FileObject );
    DebugTrace( 0, me, "    &TruncateSize = %08lx\n", TruncateSize );

    //
    //  Serialize Creation/Deletion of all Shared CacheMaps
    //

    CcAcquireMasterLock( &OldIrql );

    //
    //  Get pointer to SharedCacheMap via File Object.
    //

    SharedCacheMap = FileObject->SectionObjectPointer->SharedCacheMap;
    PrivateCacheMap = FileObject->PrivateCacheMap;

    //
    //  Decrement Open Count on SharedCacheMap, if we did a cached open.
    //  Also unmap PrivateCacheMap if it is mapped and deallocate it.
    //

    if (PrivateCacheMap != NULL) {

        ASSERT( PrivateCacheMap->FileObject == FileObject );

        CcDecrementOpenCount( SharedCacheMap, 'ninU' );

        //
        //  Remove PrivateCacheMap from list in SharedCacheMap.
        //

        RemoveEntryList( &PrivateCacheMap->PrivateLinks );

        //
        //  Free local or allocated PrivateCacheMap
        //

        if (PrivateCacheMap == &SharedCacheMap->PrivateCacheMap) {
            PrivateCacheMap->NodeTypeCode = 0;
            PrivateCacheMap = NULL;
        }

        FileObject->PrivateCacheMap = (PPRIVATE_CACHE_MAP)NULL;
    }

    //
    //  Now if we have a SharedCacheMap whose Open Count went to 0, we
    //  have some additional cleanup.
    //

    if (SharedCacheMap != NULL) {

        //
        //  If a Truncate Size was specified, then remember that we want to
        //  truncate the FileSize and purge the unneeded pages when OpenCount
        //  goes to 0.
        //

        if (ARGUMENT_PRESENT(TruncateSize)) {

            if ( (TruncateSize->QuadPart == 0) && (SharedCacheMap->FileSize.QuadPart != 0) ) {

                SetFlag(SharedCacheMap->Flags, TRUNCATE_REQUIRED);

            } else if (IsListEmpty(&SharedCacheMap->PrivateList)) {

                //
                //  If this is the last guy, I can drop the file size down
                //  now.
                //

                SharedCacheMap->FileSize = *TruncateSize;
            }
        }

        //
        //  If other file objects are still using this SharedCacheMap,
        //  then we are done now.
        //

        if (SharedCacheMap->OpenCount != 0) {

            DebugTrace(-1, me, "SharedCacheMap OpenCount != 0\n", 0);

            //
            //  If the caller specified an event to be set when
            //  the cache uninitialize is completed, set the event
            //  now, because the uninitialize is complete for this file.
            //  (Note, we make him wait if he is the last guy.)
            //

            if (ARGUMENT_PRESENT(UninitializeEvent)) {

                if (!IsListEmpty(&SharedCacheMap->PrivateList)) {
                    KeSetEvent(&UninitializeEvent->Event, 0, FALSE);
                } else {
                    UninitializeEvent->Next = SharedCacheMap->UninitializeEvent;
                    SharedCacheMap->UninitializeEvent = UninitializeEvent;
                }
            }

            CcReleaseMasterLock( OldIrql );

            //
            //  Free PrivateCacheMap now that we no longer have the spinlock.
            //

            if (PrivateCacheMap != NULL) {
                ExFreePool( PrivateCacheMap );
            }

            DebugTrace(-1, me, "CcUnitializeCacheMap -> %02lx\n", FALSE );
            return FALSE;
        }

        //
        //  Remove the private write flag synchronously.  Even though a
        //  private writer is also opening the file exclusively, the
        //  shared cache map is not going away synchronously and we
        //  cannot let a non private writer re-reference the scm in
        //  this state. Their data will never be written!
        //

        if (FlagOn(SharedCacheMap->Flags, PRIVATE_WRITE)) {

            ClearFlag(SharedCacheMap->Flags, PRIVATE_WRITE | DISABLE_WRITE_BEHIND);
            MmEnableModifiedWriteOfSection( FileObject->SectionObjectPointer );
        }

        //
        //  The private cache map list better be empty!
        //

        ASSERT(IsListEmpty(&SharedCacheMap->PrivateList));

        //
        //  Set the "uninitialize complete" in the shared cache map
        //  so that CcDeleteSharedCacheMap will delete it.
        //

        if (ARGUMENT_PRESENT(UninitializeEvent)) {
            UninitializeEvent->Next = SharedCacheMap->UninitializeEvent;
            SharedCacheMap->UninitializeEvent = UninitializeEvent;
        }

        //
        //  We are in the process of deleting this cache map.  If the
        //  Lazy Writer is active or the Bcb list is not empty or the Lazy
        //  Writer will hit this SharedCacheMap because we are purging
        //  the file to 0, then get out and let the Lazy Writer clean
        //  up.  If a write through, was forced queue a lazy write to
        //  update the file sizes.
        //

        if ((!FlagOn(SharedCacheMap->Flags, PIN_ACCESS) &&
             !ARGUMENT_PRESENT(UninitializeEvent))

                ||

            FlagOn(SharedCacheMap->Flags, WRITE_QUEUED)

                ||

            (SharedCacheMap->DirtyPages != 0)

                ||

            FlagOn(SharedCacheMap->Flags, FORCED_WRITE_THROUGH)) {

            //
            //  Move it to the dirty list so the lazy write scan will
            //  see it.
            //

            if (!FlagOn(SharedCacheMap->Flags, WRITE_QUEUED)) {
                RemoveEntryList( &SharedCacheMap->SharedCacheMapLinks );
                InsertTailList( &CcDirtySharedCacheMapList.SharedCacheMapLinks,
                                &SharedCacheMap->SharedCacheMapLinks );
            }

            //
            //  Make sure the Lazy Writer will wake up, because we
            //  want him to delete this SharedCacheMap.
            //

            LazyWriter.OtherWork = TRUE;
            if (!LazyWriter.ScanActive) {
                CcScheduleLazyWriteScan( FALSE );
            }

            //
            //  Get the active Vacb if we are going to lazy delete, to
            //  free it for someone who can use it.
            //

            GetActiveVacbAtDpcLevel( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );

            DebugTrace(-1, me, "SharedCacheMap has Bcbs and not purging to 0\n", 0);

            CcReleaseMasterLock( OldIrql );
            ASSERT (SectionClosed == FALSE);
        }
        else {

            //
            //  Now we can delete the SharedCacheMap.  If there are any Bcbs,
            //  then we must be truncating to 0, and they will also be deleted.
            //  On return the Shared Cache Map List Spinlock will be released.
            //

            CcDeleteSharedCacheMap( SharedCacheMap, OldIrql, FALSE );

            SectionClosed = TRUE;
        }
    }

    //
    //  No Shared Cache Map.  To make the file go away, we still need to
    //  purge the section, if one exists.  (And we still need to release
    //  our global list first to avoid deadlocks.)
    //

    else {
        if (ARGUMENT_PRESENT(TruncateSize) &&
            ( TruncateSize->QuadPart == 0 ) &&
            (*(PCHAR *)FileObject->SectionObjectPointer != NULL)) {

            CcReleaseMasterLock( OldIrql );

            DebugTrace( 0, mm, "MmPurgeSection:\n", 0 );
            DebugTrace( 0, mm, "    SectionObjectPointer = %08lx\n",
                        FileObject->SectionObjectPointer );
            DebugTrace2(0, mm, "    Offset = %08lx\n",
                        TruncateSize->LowPart,
                        TruncateSize->HighPart );

            //
            //  0 Length means to purge from the TruncateSize on.
            //

            CcPurgeCacheSection( FileObject->SectionObjectPointer,
                                 TruncateSize,
                                 0,
                                 FALSE );
        }
        else {
            CcReleaseMasterLock( OldIrql );
        }

        //
        //  If the caller specified an event to be set when
        //  the cache uninitialize is completed, set the event
        //  now, because the uninitialize is complete for this file.
        //

        if (ARGUMENT_PRESENT(UninitializeEvent)) {
            KeSetEvent(&UninitializeEvent->Event, 0, FALSE);
        }
    }

    //
    //  Free the active vacb, if we found one.
    //

    if (ActiveVacb != NULL) {

        CcFreeActiveVacb( ActiveVacb->SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
    }

    //
    //  Free PrivateCacheMap now that we no longer have the spinlock.
    //

    if (PrivateCacheMap != NULL) {
        ExFreePool( PrivateCacheMap );
    }

    DebugTrace(-1, me, "CcUnitializeCacheMap -> %02lx\n", SectionClosed );

    return SectionClosed;
}

VOID
CcWaitForUninitializeCacheMap (
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine is called to wait for the uninitialization of this FileObject's
    SharedCacheMap to complete.  If we are in the process of tearing down the
    SharedCacheMap, this routine will wait for that work to complete.  If this
    SharedCacheMap is referenced by another file object initiating caching of
    this stream, the wait will end.

    This routine will wait for residual references to a data section
    caused by a SharedCacheMap to go away.  If this SharedCacheMap still needs
    to reference the data section, then the SharedCacheMap reference on the
    section will remain when this call returns.
    
Arguments:

    FileObject - The file of interest for which the caller wants to ensure any
        residual references on the sections backing this file due to the 
        Cache Manager are released.

Return Value:

    None.

--*/

{
    KIRQL OldIrql;
    PSHARED_CACHE_MAP SharedCacheMap;
    CACHE_UNINITIALIZE_EVENT UninitializeEvent;
    BOOLEAN ShouldWait = FALSE;
    LARGE_INTEGER Timeout;
    NTSTATUS Status;

    DebugTrace(+1, me, "CcWaitForUninitializeCacheMap:\n", 0 );
    DebugTrace( 0, me, "    FileObject = %08lx\n", FileObject );

    //
    //  First, do an unprotected check to see if a SharedCacheMap exists
    //  for this file.  If not, we've got no more work to do and avoid
    //  acquiring the master lock.
    //

    if (FileObject->SectionObjectPointer->SharedCacheMap == NULL) {

        return;
    }

    //
    //  Initialize event that we may have to wait on if we are in the process
    //  of uninitializing the SharedCacheMap.
    //
    
    KeInitializeEvent( &UninitializeEvent.Event,
                       NotificationEvent,
                       FALSE );

    //
    //  Serialize Creation/Deletion of all Shared CacheMaps
    //

    CcAcquireMasterLock( &OldIrql );

    //
    //  Get pointer to SharedCacheMap via File Object.
    //

    SharedCacheMap = FileObject->SectionObjectPointer->SharedCacheMap;

    //
    //  If we have a SharedCacheMap, we will check to OpenCount to see if 
    //  we are in the process of uninitializing the SharedCacheMap and 
    //  should therefore wait for that work to complete.
    //

    if (SharedCacheMap != NULL) {

        //
        //  If the OpenCount on the SharedCacheMap is zero or the list
        //  of private cache maps is empty, we are in the process of 
        //  uninitializing this SharedCacheMap.  Link our event into the 
        //  SharedCacheMap's UninitializeEvent list so that we will be signaled
        //  when the work is completed or the SharedCacheMap is referenced by
        //  another file before it is torn down.
        //

        if (SharedCacheMap->OpenCount == 0 ||
            IsListEmpty( &SharedCacheMap->PrivateList )) {

            DebugTrace(-1, me, "SharedCacheMap OpenCount == 0 or PrivateList is empty\n", 0);

            ShouldWait = TRUE; 
            SetFlag( SharedCacheMap->Flags, WAITING_FOR_TEARDOWN );

            UninitializeEvent.Next = SharedCacheMap->UninitializeEvent;
            SharedCacheMap->UninitializeEvent = SetMmWaiterFlag( PCACHE_UNINITIALIZE_EVENT, 
                                                                 &UninitializeEvent );

            //
            //  Give the lazy write scan a kick to get it to start doing its
            //  scan right now.
            //
            
            CcScheduleLazyWriteScan( TRUE );
        } 
    }

    //
    //  Release the lock because we are finished with the SharedCacheMap.
    //

    CcReleaseMasterLock( OldIrql );

    if (!ShouldWait) {

        //
        //  We shouldn't wait or try to force this teardown sooner, so just
        //  return now.
        
        goto exit;
    }

    //
    //  We will now wait for the event to get signaled.  We've given the lazy
    //  write scan a kick so it should process this right away ahead of any
    //  other outstanding work.  We should get signaled as soon as the flush
    //  has been completed.
    //

    Timeout.QuadPart = (LONGLONG)-(10 * 60 * NANO_FULL_SECOND);

    Status = KeWaitForSingleObject( &UninitializeEvent.Event, 
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    &Timeout );

    if (Status == STATUS_TIMEOUT) {

        PCACHE_UNINITIALIZE_EVENT CUEvent;

        //
        //  We weren't signaled, so grab the master spin lock and remove
        //  this event from the shared cache map if it is still around.
        //

        CcAcquireMasterLock( &OldIrql );

        SharedCacheMap = FileObject->SectionObjectPointer->SharedCacheMap;

        if (SharedCacheMap != NULL) {

            //
            //  We've got a shared cache map, so take our UninitializeEvent
            //  out of the list.  Since this is a singlely-linked list, we've
            //  got to search, but the list shouldn't be long.
            //               

            CUEvent = CONTAINING_RECORD( &SharedCacheMap->UninitializeEvent,
                                         CACHE_UNINITIALIZE_EVENT,
                                         Next );

            while (CUEvent->Next != NULL) {

                if (CUEvent->Next == SetMmWaiterFlag(PCACHE_UNINITIALIZE_EVENT, &UninitializeEvent)) {

                    CUEvent->Next = UninitializeEvent.Next;
                    break;
                }

                CUEvent = ClearMmWaiterFlag( PCACHE_UNINITIALIZE_EVENT, CUEvent->Next);
            }

            ClearFlag( SharedCacheMap->Flags, WAITING_FOR_TEARDOWN );
            
            //
            //  All done, so release the master lock.
            //
            
            CcReleaseMasterLock( OldIrql );

        } else {

            //
            //  Release the master lock and wait again on the event.  If the
            //  shared cache map is no longer around, another thread is
            //  in CcDeleteSharedCacheMap and will be walking the event list
            //  to signal this event very soon.  
            //
            
            CcReleaseMasterLock( OldIrql );

            KeWaitForSingleObject( &UninitializeEvent.Event, 
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL );
        }
    }
    
exit:
    
    DebugTrace(-1, me, "CcWaitForUninitializeCacheMap\n", 0 );
    return;
}


//
//  Internal support routine.
//

VOID
CcCancelMmWaitForUninitializeCacheMap (
    IN PSHARED_CACHE_MAP SharedCacheMap
    )

/*++

Routine Description:

    This routine is called to search the list of events waiting on this cache
    map being uninitialized and signal any waiters that are Mm.  We detect
    Mm by looking for the low bit in the address to be set.

    NOTE: Caller must be holding the master spin lock when making this call.
    
Arguments:

    SharedCacheMap - The shared cache map on which Mm's wait should be canceled.
    
Return Value:

    None.

--*/
{
    PCACHE_UNINITIALIZE_EVENT LastEvent, CUEvent;

    LastEvent = CONTAINING_RECORD( &SharedCacheMap->UninitializeEvent,
                                   CACHE_UNINITIALIZE_EVENT,
                                   Next );

    while (LastEvent->Next != NULL) {

        if (TestMmWaiterFlag(LastEvent->Next) != 0) {
            CUEvent = ClearMmWaiterFlag(PCACHE_UNINITIALIZE_EVENT, LastEvent->Next);
            LastEvent->Next = CUEvent->Next;
            KeSetEvent( &CUEvent->Event, 0, FALSE );
        } else {
            LastEvent = LastEvent->Next;
        }
    }

    ClearFlag( SharedCacheMap->Flags, WAITING_FOR_TEARDOWN );
}



VOID
CcDeleteBcbs (
    IN PSHARED_CACHE_MAP SharedCacheMap
    )

/*++

Routine Description:

    This routine may be called to delete all Bcbs for a stream.
    
    External synchronization must be acquired to guarantee no
    active pin on any bcb.

Arguments:

    SharedCacheMap - Pointer to SharedCacheMap.

Return Value:

    None.

--*/

{
    KIRQL OldIrql;
    PLIST_ENTRY NextEntry;
    PBCB Bcb;

    //
    //  If there are Bcbs, then empty the list. None of them can be pinned now!
    //  Either the file is being truncated, in which case synchronization with
    //  the lazy writer must have been externally acheived, or the file is being
    //  closed down and nothing should be able to get a fresh reference on this
    //  shared cache map.
    //

    NextEntry = SharedCacheMap->BcbList.Flink;
    while (NextEntry != &SharedCacheMap->BcbList) {

        Bcb = (PBCB)CONTAINING_RECORD( NextEntry,
                                       BCB,
                                       BcbLinks );
        NextEntry = Bcb->BcbLinks.Flink;

        //
        //  Skip over the pendaflex entries, only removing true Bcbs
        //  so that level teardown doesn't need to special case unhooking
        //  the pendaflex.  This has the side benefit of dramatically
        //  reducing write traffic to memory on teardown of large files.
        //

        if (Bcb->NodeTypeCode == CACHE_NTC_BCB) {

            ASSERT( Bcb->PinCount == 0 );

            RemoveEntryList( &Bcb->BcbLinks );

            //
            //  For large metadata streams we unlock the Vacb level when
            //  removing.  We do not need spinlocks since no other thread
            //  can be accessing this list when we are deleting the
            //  SharedCacheMap.
            //

            CcUnlockVacbLevel( SharedCacheMap, Bcb->FileOffset.QuadPart );

            //
            //  There is a small window where the data could still be mapped
            //  if (for example) the Lazy Writer collides with a CcCopyWrite
            //  in the foreground, and then someone calls CcUninitializeCacheMap
            //  while the Lazy Writer is active.  This is because the Lazy
            //  Writer biases the pin count.  Deal with that here.
            //

            if (Bcb->BaseAddress != NULL) {
                CcFreeVirtualAddress( Bcb->Vacb );
            }

            //
            //  If the Bcb is dirty, we have to synchronize with the Lazy Writer
            //  and reduce the total number of dirty.
            //

            CcAcquireMasterLock( &OldIrql );
            if (Bcb->Dirty) {
                CcDeductDirtyPages( SharedCacheMap,  Bcb->ByteLength >> PAGE_SHIFT );
            }
            CcReleaseMasterLock( OldIrql );

            CcDeallocateBcb( Bcb );
        }
    }
}


//
//  Internal support routine.
//

VOID
FASTCALL
CcDeleteSharedCacheMap (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN KIRQL ListIrql,
    IN ULONG ReleaseFile
    )

/*++

Routine Description:

    The specified SharedCacheMap is removed from the global list of
    SharedCacheMap's and deleted with all of its related structures.
    Other objects which were referenced in CcInitializeCacheMap are
    dereferenced here.

    NOTE:   The CcMasterSpinLock must already be acquired
            on entry.  It is released on return.

Arguments:

    SharedCacheMap - Pointer to Cache Map to delete

    ListIrql - priority to restore to when releasing shared cache map list

    ReleaseFile - Supplied as nonzero if file was acquired exclusive and
                  should be released.

ReturnValue:

    None.

--*/

{
    LIST_ENTRY LocalList;
    PFILE_OBJECT FileObject;
    PVACB ActiveVacb;
    ULONG ActivePage;
    ULONG PageIsDirty;

    DebugTrace(+1, me, "CcDeleteSharedCacheMap:\n", 0 );
    DebugTrace( 0, me, "    SharedCacheMap = %08lx\n", SharedCacheMap );

    //
    //  Remove it from the global list and clear the pointer to it via
    //  the File Object.
    //

    RemoveEntryList( &SharedCacheMap->SharedCacheMapLinks );

    //
    //  Zero pointer to SharedCacheMap.  Once we have cleared the pointer,
    //  we can/must release the global list to avoid deadlocks.
    //

    FileObject = SharedCacheMap->FileObject;

    FileObject->SectionObjectPointer->SharedCacheMap = (PSHARED_CACHE_MAP)NULL;
    SetFlag( SharedCacheMap->Flags, WRITE_QUEUED );

    //
    //  The OpenCount is 0, but we still need to flush out any dangling
    //  cache read or writes.
    //

    if ((SharedCacheMap->VacbActiveCount != 0) || (SharedCacheMap->NeedToZero != NULL)) {

        //
        //  We will put it in a local list and set a flag
        //  to keep the Lazy Writer away from it, so that we can rip it out
        //  below if someone manages to sneak in and set something dirty, etc.
        //  If the file system does not synchronize cleanup calls with an
        //  exclusive on the stream, then this case is possible.
        //

        InitializeListHead( &LocalList );
        InsertTailList( &LocalList, &SharedCacheMap->SharedCacheMapLinks );

        //
        //  If there is an active Vacb, then delete it now (before waiting).
        //

        GetActiveVacbAtDpcLevel( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );

        CcReleaseMasterLock( ListIrql );

        //
        //  No point in saying the page is dirty (which can cause an allocation
        //  failure), since we are deleting this SharedCacheMap anyway.
        //

        CcFreeActiveVacb( SharedCacheMap, ActiveVacb, ActivePage, FALSE );

        while (SharedCacheMap->VacbActiveCount != 0) {
            CcWaitOnActiveCount( SharedCacheMap );
        }

        //
        //  Now in case we hit the rare path where someone moved the
        //  SharedCacheMap again, do a remove again now.  It may be
        //  from our local list or it may be from the dirty list,
        //  but who cares?  The important thing is to remove it in
        //  the case it was the dirty list, since we will delete it
        //  below.
        //

        CcAcquireMasterLock( &ListIrql );
        RemoveEntryList( &SharedCacheMap->SharedCacheMapLinks );
    }

    CcReleaseMasterLock( ListIrql );

    //
    //  If there are Bcbs, then empty the list.
    //
    //  I really wonder how often we have Bcbs at teardown.  This is
    //  a lot of work that could be avoided otherwise.
    //

    if (!IsListEmpty( &SharedCacheMap->BcbList )) {
        CcDeleteBcbs( SharedCacheMap );
    }

    //
    //  Call local routine to unmap, and purge if necessary.
    //

    CcUnmapAndPurge( SharedCacheMap );

    //
    //  Now release the file now that the purge is done.
    //

    if (ReleaseFile) {
        FsRtlReleaseFile( SharedCacheMap->FileObject );
    }

    //
    //  Dereference our pointer to the Section and FileObject
    //  (We have to test the Section pointer since CcInitializeCacheMap
    //  calls this routine for error recovery.  Release our global
    //  resource before dereferencing the FileObject to avoid deadlocks.
    //

    if (SharedCacheMap->Section != NULL) {
        ObDereferenceObject( SharedCacheMap->Section );
    }
    ObDereferenceObject( FileObject );

    //
    //  If there is an Mbcb, deduct any dirty pages and deallocate.
    //

    if (SharedCacheMap->Mbcb != NULL) {
        CcDeleteMbcb( SharedCacheMap );
    }

    //
    //  If there was an uninitialize event specified for this shared cache
    //  map, then set it to the signaled state, indicating that we are
    //  removing the section and deleting the shared cache map.
    //

    if (SharedCacheMap->UninitializeEvent != NULL) {
        PCACHE_UNINITIALIZE_EVENT CUEvent, EventNext;

        CUEvent = SharedCacheMap->UninitializeEvent;
        while (CUEvent != NULL) {
            CUEvent = ClearMmWaiterFlag(PCACHE_UNINITIALIZE_EVENT, CUEvent);
            EventNext = CUEvent->Next;
            KeSetEvent(&CUEvent->Event, 0, FALSE);
            CUEvent = EventNext;
        }
    }

    //
    //  Now delete the Vacb vector.
    //

    if ((SharedCacheMap->Vacbs != &SharedCacheMap->InitialVacbs[0])

            &&

        (SharedCacheMap->Vacbs != NULL)) {

        //
        //  If there are Vacb levels, then the Vacb Array better be in an empty state.
        //

        ASSERT((SharedCacheMap->SectionSize.QuadPart <= VACB_SIZE_OF_FIRST_LEVEL) ||
               !IsVacbLevelReferenced( SharedCacheMap, SharedCacheMap->Vacbs, 1 ));

        ExFreePool( SharedCacheMap->Vacbs );
    }

    //
    //  If an event had to be allocated for this SharedCacheMap,
    //  deallocate it.
    //

    if ((SharedCacheMap->CreateEvent != NULL) && (SharedCacheMap->CreateEvent != &SharedCacheMap->Event)) {
        ExFreePool( SharedCacheMap->CreateEvent );
    }

    if ((SharedCacheMap->WaitOnActiveCount != NULL) && (SharedCacheMap->WaitOnActiveCount != &SharedCacheMap->Event)) {
        ExFreePool( SharedCacheMap->WaitOnActiveCount );
    }

    //
    //  Deallocate the storeage for the SharedCacheMap.
    //

    ExFreePool( SharedCacheMap );

    DebugTrace(-1, me, "CcDeleteSharedCacheMap -> VOID\n", 0 );

    return;

}


VOID
CcSetFileSizes (
    __in PFILE_OBJECT FileObject,
    __in PCC_FILE_SIZES FileSizes
    )

/*++

Routine Description:

    This routine must be called whenever a file has been extended to reflect
    this extension in the cache maps and underlying section.  Calling this
    routine has a benign effect if the current size of the section is
    already greater than or equal to the new AllocationSize.

    This routine must also be called whenever the FileSize for a file changes
    to reflect these changes in the Cache Manager.

    This routine seems rather large, but in the normal case it only acquires
    a spinlock, updates some fields, and exits.  Less often it will either
    extend the section, or truncate/purge the file, but it would be unexpected
    to do both.  On the other hand, the idea of this routine is that it does
    "everything" required when AllocationSize or FileSize change.

Arguments:

    FileObject - A file object for which CcInitializeCacheMap has been
                 previously called.

    FileSizes - A pointer to AllocationSize, FileSize and ValidDataLength
                for the file.  AllocationSize is ignored if it is not larger
                than the current section size (i.e., it is ignored unless it
                has grown).  ValidDataLength is not used.


Return Value:

    None

--*/

{
    LARGE_INTEGER NewSectionSize;
    LARGE_INTEGER NewFileSize;
    LARGE_INTEGER NewValidDataLength;
    IO_STATUS_BLOCK IoStatus;
    PSHARED_CACHE_MAP SharedCacheMap;
    NTSTATUS Status;
    KIRQL OldIrql;
    PVACB ActiveVacb;
    ULONG ActivePage;
    ULONG PageIsDirty;

    DebugTrace(+1, me, "CcSetFileSizes:\n", 0 );
    DebugTrace( 0, me, "    FileObject = %08lx\n", FileObject );
    DebugTrace( 0, me, "    FileSizes = %08lx\n", FileSizes );

    //
    //  Make a local copy of the new file size and section size.
    //

    NewSectionSize = FileSizes->AllocationSize;
    NewFileSize = FileSizes->FileSize;
    NewValidDataLength = FileSizes->ValidDataLength;

    //
    //  Serialize Creation/Deletion of all Shared CacheMaps
    //

    CcAcquireMasterLock( &OldIrql );

    //
    //  Get pointer to SharedCacheMap via File Object.
    //

    SharedCacheMap = FileObject->SectionObjectPointer->SharedCacheMap;

    //
    //  If the file is not cached, just get out.
    //

    if ((SharedCacheMap == NULL) || (SharedCacheMap->Section == NULL)) {

        CcReleaseMasterLock( OldIrql );

        //
        //  Let's try to purge the file incase this is a truncate.  In the
        //  vast majority of cases when there is no shared cache map, there
        //  is no data section either, so this call will eventually be
        //  nooped in Mm.
        //
        //  First flush the first page we are keeping, if it has data, before
        //  we throw it away.
        //

        if (NewFileSize.LowPart & (PAGE_SIZE - 1)) {

            MmFlushSection( FileObject->SectionObjectPointer, 
                            &NewFileSize, 
                            1, 
                            &IoStatus, 
                            0 );
            
            ASSERT( IoStatus.Status != STATUS_ENCOUNTERED_WRITE_IN_PROGRESS );
        }

        CcPurgeCacheSection( FileObject->SectionObjectPointer,
                             &NewFileSize,
                             0,
                             FALSE );

        DebugTrace(-1, me, "CcSetFileSizes -> VOID\n", 0 );

        return;
    }

    //
    //  Make call a Noop if file is not mapped, or section already big enough.
    //

    if ( NewSectionSize.QuadPart > SharedCacheMap->SectionSize.QuadPart ) {

        //
        //  Increment open count to make sure the SharedCacheMap stays around,
        //  then release the spinlock so that we can call Mm.
        //

        CcIncrementOpenCount( SharedCacheMap, '1fSS' );
        CcReleaseMasterLock( OldIrql );

        //
        //  Round new section size to pages.
        //

        NewSectionSize.QuadPart = NewSectionSize.QuadPart + (LONGLONG)(DEFAULT_EXTEND_MODULO - 1);
        NewSectionSize.LowPart &= ~(DEFAULT_EXTEND_MODULO - 1);

        //
        //  Call MM to extend the section.
        //

        DebugTrace( 0, mm, "MmExtendSection:\n", 0 );
        DebugTrace( 0, mm, "    Section = %08lx\n", SharedCacheMap->Section );
        DebugTrace2(0, mm, "    Size = %08lx, %08lx\n",
                    NewSectionSize.LowPart, NewSectionSize.HighPart );

        Status = MmExtendSection( SharedCacheMap->Section, &NewSectionSize, TRUE );

        if (NT_SUCCESS(Status)) {

            //
            //  Extend the Vacb array.
            //

            Status = CcExtendVacbArray( SharedCacheMap, NewSectionSize );
        }
        else {

            DebugTrace( 0, 0, "Error from MmExtendSection, Status = %08lx\n",
                        Status );

            Status = FsRtlNormalizeNtstatus( Status,
                                             STATUS_UNEXPECTED_MM_EXTEND_ERR );
        }

        //
        //  Serialize again to decrement the open count.
        //

        CcAcquireMasterLock( &OldIrql );

        CcDecrementOpenCount( SharedCacheMap, '1fSF' );

        if ((SharedCacheMap->OpenCount == 0) &&
            !FlagOn(SharedCacheMap->Flags, WRITE_QUEUED) &&
            (SharedCacheMap->DirtyPages == 0)) {

            //
            //  Move to the dirty list.
            //

            RemoveEntryList( &SharedCacheMap->SharedCacheMapLinks );
            InsertTailList( &CcDirtySharedCacheMapList.SharedCacheMapLinks,
                            &SharedCacheMap->SharedCacheMapLinks );

            //
            //  Make sure the Lazy Writer will wake up, because we
            //  want him to delete this SharedCacheMap.
            //

            LazyWriter.OtherWork = TRUE;
            if (!LazyWriter.ScanActive) {
                CcScheduleLazyWriteScan( FALSE );
            }
        }

        //
        //  If section or VACB extension failed, raise an
        //  exception to our caller.
        //

        if (!NT_SUCCESS(Status)) {
            CcReleaseMasterLock( OldIrql );
            ExRaiseStatus( Status );
        }

        //
        //  It is now very unlikely that we have any more work to do, but since
        //  the spinlock is already held, check again if we are cached.
        //

        //
        //  Get pointer to SharedCacheMap via File Object.
        //

        SharedCacheMap = FileObject->SectionObjectPointer->SharedCacheMap;

        //
        //  If the file is not cached, just get out.
        //

        if (SharedCacheMap == NULL) {

            CcReleaseMasterLock( OldIrql );

            DebugTrace(-1, me, "CcSetFileSizes -> VOID\n", 0 );

            return;
        }
    }

    //
    //  If we are shrinking either of these two sizes, then we must free the
    //  active page, since it may be locked.
    //

    CcIncrementOpenCount( SharedCacheMap, '2fSS' );

    if ( ( NewFileSize.QuadPart < SharedCacheMap->ValidDataGoal.QuadPart ) ||
         ( NewFileSize.QuadPart < SharedCacheMap->FileSize.QuadPart )) {

        GetActiveVacbAtDpcLevel( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );

        if ((ActiveVacb != NULL) || (SharedCacheMap->NeedToZero != NULL)) {

            CcReleaseMasterLock( OldIrql );

            CcFreeActiveVacb( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );

            //
            //  Serialize again to reduce ValidDataLength.  It cannot change
            //  because the caller must have the file exclusive.
            //

            CcAcquireMasterLock( &OldIrql );
        }
    }

    //
    //  If the section did not grow, see if the file system supports
    //  ValidDataLength, then update the valid data length in the file system.
    //

    if ( SharedCacheMap->ValidDataLength.QuadPart != MAXLONGLONG ) {

        if ( NewFileSize.QuadPart < SharedCacheMap->ValidDataLength.QuadPart ) {
            SharedCacheMap->ValidDataLength = NewFileSize;
        }

        //
        //  Update our notion of ValidDataGoal (how far the file has been
        //  written in the cache) with caller's ValidDataLength.  (Our
        //  ValidDataLength controls when we issue ValidDataLength callbacks.)
        //

        SharedCacheMap->ValidDataGoal = NewValidDataLength;
    }

    //
    //  On truncate, be nice guys and actually purge away user data from
    //  the cache.  However, the PinAccess check is important to avoid deadlocks
    //  in Ntfs.
    //
    //  It is also important to check the Vacb Active count.  The caller
    //  must have the file exclusive, therefore, no one else can be actively
    //  doing anything in the file.  Normally the Active count will be zero
    //  (like in a normal call from Set File Info), and we can go ahead and
    //  truncate.  However, if the active count is nonzero, chances are this
    //  very thread has something pinned or mapped, and we will deadlock if
    //  we try to purge and wait for the count to go zero.  A rare case of
    //  this which deadlocked DaveC on Christmas Day of 1992, is where Ntfs
    //  was trying to convert an attribute from resident to nonresident - which
    //  is a good example of a case where the purge was not needed.
    //

    if ( (NewFileSize.QuadPart < SharedCacheMap->FileSize.QuadPart ) &&
        !FlagOn(SharedCacheMap->Flags, PIN_ACCESS) &&
        (SharedCacheMap->VacbActiveCount == 0)) {

        //
        //  Release the spinlock so that we can call Mm.
        //

        CcReleaseMasterLock( OldIrql );

        //
        //  If we are actually truncating to zero (a size which has particular
        //  meaning to the Lazy Writer scan!) then we must reset the Mbcb/Bcbs,
        //  if there are any, so that we do not keep dirty pages around forever.
        //

        if (NewFileSize.QuadPart == 0) {
            if (SharedCacheMap->Mbcb != NULL) {
                CcDeleteMbcb( SharedCacheMap );
            }
            if (!IsListEmpty( &SharedCacheMap->BcbList )) {
                CcDeleteBcbs( SharedCacheMap );
            }
        }

        CcPurgeAndClearCacheSection( SharedCacheMap, &NewFileSize );

        //
        //  Serialize again to decrement the open count.
        //

        CcAcquireMasterLock( &OldIrql );
    }

    CcDecrementOpenCount( SharedCacheMap, '2fSF' );

    SharedCacheMap->FileSize = NewFileSize;

    if ((SharedCacheMap->OpenCount == 0) &&
        !FlagOn(SharedCacheMap->Flags, WRITE_QUEUED) &&
        (SharedCacheMap->DirtyPages == 0)) {

        //
        //  Move to the dirty list.
        //

        RemoveEntryList( &SharedCacheMap->SharedCacheMapLinks );
        InsertTailList( &CcDirtySharedCacheMapList.SharedCacheMapLinks,
                        &SharedCacheMap->SharedCacheMapLinks );

        //
        //  Make sure the Lazy Writer will wake up, because we
        //  want him to delete this SharedCacheMap.
        //

        LazyWriter.OtherWork = TRUE;
        if (!LazyWriter.ScanActive) {
            CcScheduleLazyWriteScan( FALSE );
        }
    }

    CcReleaseMasterLock( OldIrql );

    DebugTrace(-1, me, "CcSetFileSizes -> VOID\n", 0 );

    return;
}


VOID
CcPurgeAndClearCacheSection (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN PLARGE_INTEGER FileOffset
    )

/*++

Routine Description:

    This routine calls CcPurgeCacheSection after zeroing the end any
    partial page at the start of the range.  If the file is not cached
    it flushes this page before the purge.

Arguments:

    SectionObjectPointer - A pointer to the Section Object Pointers
                           structure in the nonpaged Fcb.

    FileOffset - Offset from which file should be purged - rounded down
               to page boundary.  If NULL, purge the entire file.

ReturnValue:

    FALSE - if the section was not successfully purged
    TRUE - if the section was successfully purged

--*/

{
    ULONG TempLength, Length;
    LARGE_INTEGER LocalFileOffset;
    IO_STATUS_BLOCK IoStatus;
    PVOID TempVa;
    PVACB Vacb;
    LOGICAL ZeroSucceeded = TRUE;

    //
    //  Awareness is indicated by the lowbit of the fileoffset pointer.
    //  Non-awareness of a private write stream results in a no-op.
    //

    if (FlagOn( SharedCacheMap->Flags, PRIVATE_WRITE )) {

        if (((ULONG_PTR)FileOffset & 1) == 0) {
            return;
        }

        FileOffset = (PLARGE_INTEGER)((ULONG_PTR)FileOffset ^ 1);
    }

    //
    //  If a range was specified, then we have to see if we need to
    //  save any user data before purging.
    //

    if ((FileOffset->LowPart & (PAGE_SIZE - 1)) != 0) {

        //
        //  Switch to LocalFileOffset.  We do it this way because we
        //  still pass it on as an optional parameter.
        //

        LocalFileOffset = *FileOffset;
        FileOffset = &LocalFileOffset;

        //
        //  If the file is cached, then we can actually zero the data to
        //  be purged in memory, and not purge those pages.  This is a huge
        //  savings, because sometimes the flushes in the other case cause
        //  us to kill lots of stack, time and I/O doing CcZeroData in especially
        //  large user-mapped files.
        //

        if ((SharedCacheMap->Section != NULL) &&
            (SharedCacheMap->Vacbs != NULL)) {

            //
            //  First zero the first page we are keeping, if it has data, and
            //  adjust FileOffset and Length to allow it to stay.
            //

            TempLength = PAGE_SIZE - (FileOffset->LowPart & (PAGE_SIZE - 1));

            TempVa = CcGetVirtualAddress( SharedCacheMap, *FileOffset, &Vacb, &Length );

            try {

                //
                //  Do not map and zero the page if we are not reducing our notion
                //  of Valid Data, because that does two bad things.  First
                //  CcSetDirtyInMask will arbitrarily smash up ValidDataGoal
                //  (causing a potential invalid CcSetValidData call).  Secondly,
                //  if the Lazy Writer writes the last page ahead of another flush
                //  through MM, then the file system will never see a write from
                //  MM, and will not include the last page in ValidDataLength on
                //  disk.
                //

                RtlZeroMemory( TempVa, TempLength );

            } except (EXCEPTION_EXECUTE_HANDLER) {

                //
                //  If we get an exception here, it means TempVa was not valid
                //  and we got an error trying to page that data in from the
                //  backing file.  If that is the case, then we don't need zero
                //  the end of this file because the file system will take
                //  care of that.  We will just swallow the exception here
                //  and continue.  If we couldn't zero this range, we don't
                //  want to mark that we made data dirty, so remember that
                //  this operation failed.
                //
                
                ZeroSucceeded = FALSE;
            }

            if (ZeroSucceeded) {
                
                if (FileOffset->QuadPart <= SharedCacheMap->ValidDataGoal.QuadPart) {

                    //
                    //  Make sure the Lazy Writer writes it.
                    //

                    CcSetDirtyInMask( SharedCacheMap, FileOffset, TempLength );

                //
                //  Otherwise, we are mapped, so make sure at least that Mm
                //  knows the page is dirty since we zeroed it.
                //

                } else {

                    MmSetAddressRangeModified( TempVa, 1 );
                }

                FileOffset->QuadPart += (LONGLONG)TempLength;
            }

            //
            //  If we get any kind of error, like failing to read the page from
            //  the network, just charge on.  Note that we only read it in order
            //  to zero it and avoid the flush below, so if we cannot read it
            //  there is really no stale data problem.
            //

            CcFreeVirtualAddress( Vacb );

        } else {

            //
            //  First flush the first page we are keeping, if it has data, before
            //  we throw it away.
            //

            MmFlushSection( SharedCacheMap->FileObject->SectionObjectPointer, 
                            FileOffset, 
                            1, 
                            &IoStatus, 
                            0 );
            
            ASSERT( IoStatus.Status != STATUS_ENCOUNTERED_WRITE_IN_PROGRESS );
        }
    }

    CcPurgeCacheSection( SharedCacheMap->FileObject->SectionObjectPointer,
                         FileOffset,
                         0,
                         FALSE );
}


BOOLEAN
CcPurgeCacheSection (
    __in PSECTION_OBJECT_POINTERS SectionObjectPointer,
    __in_opt PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in BOOLEAN UninitializeCacheMaps
    )

/*++

Routine Description:

    This routine may be called to force a purge of the cache section,
    even if it is cached.  Note, if a user has the file mapped, then the purge
    will *not* take effect, and this must be considered part of normal application
    interaction.  The purpose of purge is to throw away potentially nonzero
    data, so that it will be read in again and presumably zeroed.  This is
    not really a security issue, but rather an effort to not confuse the
    application when it sees nonzero data.  We cannot help the fact that
    a user-mapped view forces us to hang on to stale data.

    This routine is intended to be called whenever previously written
    data is being truncated from the file, and the file is not being
    deleted.

    The file must be acquired exclusive in order to call this routine.

Arguments:

    SectionObjectPointer - A pointer to the Section Object Pointers
                           structure in the nonpaged Fcb.

    FileOffset - Offset from which file should be purged - rounded down
               to page boundary.  If NULL, purge the entire file.

    Length - Defines the length of the byte range to purge, starting at
             FileOffset.  This parameter is ignored if FileOffset is
             specified as NULL.  If FileOffset is specified and Length
             is 0, then purge from FileOffset to the end of the file.

    UninitializeCacheMaps - If TRUE, we should uninitialize all the private
                            cache maps before purging the data.

ReturnValue:

    FALSE - if the section was not successfully purged
    TRUE - if the section was successfully purged

--*/

{
    KIRQL OldIrql;
    PSHARED_CACHE_MAP SharedCacheMap;
    PPRIVATE_CACHE_MAP PrivateCacheMap;
    ULONG ActivePage;
    ULONG PageIsDirty;
    BOOLEAN PurgeWorked = TRUE;
    PVACB Vacb = NULL;

    DebugTrace(+1, me, "CcPurgeCacheSection:\n", 0 );
    DebugTrace( 0, mm, "    SectionObjectPointer = %08lx\n", SectionObjectPointer );
    DebugTrace2(0, me, "    FileOffset = %08lx, %08lx\n",
                            ARGUMENT_PRESENT(FileOffset) ? FileOffset->LowPart
                                                         : 0,
                            ARGUMENT_PRESENT(FileOffset) ? FileOffset->HighPart
                                                         : 0 );
    DebugTrace( 0, me, "    Length = %08lx\n", Length );


    //
    //  If you want us to uninitialize cache maps, the RtlZeroMemory paths
    //  below depend on actually having to purge something after zeroing.
    //

    ASSERT(!UninitializeCacheMaps || (Length == 0) || (Length >= PAGE_SIZE * 2));

    //
    //  Serialize Creation/Deletion of all Shared CacheMaps
    //

    CcAcquireMasterLock( &OldIrql );

    //
    //  Get pointer to SharedCacheMap via File Object.
    //

    SharedCacheMap = SectionObjectPointer->SharedCacheMap;

    //
    //  Increment open count to make sure the SharedCacheMap stays around,
    //  then release the spinlock so that we can call Mm.
    //

    if (SharedCacheMap != NULL) {

        //
        //  Awareness is indicated by the lowbit of the fileoffset pointer.
        //  Non-awareness of a private write stream results in a no-op.
        //

        if (FlagOn( SharedCacheMap->Flags, PRIVATE_WRITE )) {

            if (((ULONG_PTR)FileOffset & 1) == 0) {

                CcReleaseMasterLock( OldIrql );
                return TRUE;
            }

            FileOffset = (PLARGE_INTEGER)((ULONG_PTR)FileOffset ^ 1);
        }

        CcIncrementOpenCount( SharedCacheMap, 'scPS' );

        //
        //  If there is an active Vacb, then delete it now (before waiting!).
        //

        GetActiveVacbAtDpcLevel( SharedCacheMap, Vacb, ActivePage, PageIsDirty );
    }

    CcReleaseMasterLock( OldIrql );

    if (Vacb != NULL) {

        CcFreeActiveVacb( SharedCacheMap, Vacb, ActivePage, PageIsDirty );
    }

    //
    //  Increment open count to make sure the SharedCacheMap stays around,
    //  then release the spinlock so that we can call Mm.
    //

    if (SharedCacheMap != NULL) {

        //
        // Now loop to make sure that no one is currently caching the file.
        //

        if (UninitializeCacheMaps) {

            while (!IsListEmpty( &SharedCacheMap->PrivateList )) {

                PrivateCacheMap = CONTAINING_RECORD( SharedCacheMap->PrivateList.Flink,
                                                     PRIVATE_CACHE_MAP,
                                                     PrivateLinks );

                CcUninitializeCacheMap( PrivateCacheMap->FileObject, NULL, NULL );
            }
        }

        //
        //  Now, let's unmap and purge here.
        //
        //  We still need to wait for any dangling cache read or writes.
        //
        //  In fact we have to loop and wait because the lazy writer can
        //  sneak in and do an CcGetVirtualAddressIfMapped, and we are not
        //  synchronized.
        //

        while ((SharedCacheMap->Vacbs != NULL) &&
               !CcUnmapVacbArray( SharedCacheMap, FileOffset, Length, FALSE )) {

            CcWaitOnActiveCount( SharedCacheMap );
        }
    }

    //
    //  Purge failures are extremely rare if there are no user mapped sections.
    //  However, it is possible that we will get one from our own mapping, if
    //  the file is being lazy deleted from a previous open.  For that case
    //  we wait here until the purge succeeds, so that we are not left with
    //  old user file data.  Although Length is actually invariant in this loop,
    //  we do need to keep checking that we are allowed to truncate in case a
    //  user maps the file during a delay.
    //

    while (!(PurgeWorked = MmPurgeSection(SectionObjectPointer,
                                          FileOffset,
                                          Length,
                                          (BOOLEAN)((SharedCacheMap !=NULL) &&
                                                    ARGUMENT_PRESENT(FileOffset)))) &&
           (Length == 0) &&
           MmCanFileBeTruncated(SectionObjectPointer, FileOffset)) {

        (VOID)KeDelayExecutionThread( KernelMode, FALSE, &CcCollisionDelay );
    }

    //
    //  Reduce the open count on the SharedCacheMap if there was one.
    //

    if (SharedCacheMap != NULL) {

        //
        //  Serialize again to decrement the open count.
        //

        CcAcquireMasterLock( &OldIrql );

        CcDecrementOpenCount( SharedCacheMap, 'scPF' );

        if ((SharedCacheMap->OpenCount == 0) &&
            !FlagOn(SharedCacheMap->Flags, WRITE_QUEUED) &&
            (SharedCacheMap->DirtyPages == 0)) {

            //
            //  Move to the dirty list.
            //

            RemoveEntryList( &SharedCacheMap->SharedCacheMapLinks );
            InsertTailList( &CcDirtySharedCacheMapList.SharedCacheMapLinks,
                            &SharedCacheMap->SharedCacheMapLinks );

            //
            //  Make sure the Lazy Writer will wake up, because we
            //  want him to delete this SharedCacheMap.
            //

            LazyWriter.OtherWork = TRUE;
            if (!LazyWriter.ScanActive) {
                CcScheduleLazyWriteScan( FALSE );
            }
        }

        CcReleaseMasterLock( OldIrql );
    }

    DebugTrace(-1, me, "CcPurgeCacheSection -> %02lx\n", PurgeWorked );

    return PurgeWorked;
}


//
//  Internal support routine.
//

VOID
CcUnmapAndPurge(
    IN PSHARED_CACHE_MAP SharedCacheMap
    )

/*++

Routine Description:

    This routine may be called to unmap and purge a section, causing Memory
    Management to throw the pages out and reset his notion of file size.

Arguments:

    SharedCacheMap - Pointer to SharedCacheMap of section to purge.

Return Value:

    None.

--*/

{
    PFILE_OBJECT FileObject;

    FileObject = SharedCacheMap->FileObject;

    //
    //  Unmap all Vacbs
    //

    if (SharedCacheMap->Vacbs != NULL) {
        (VOID)CcUnmapVacbArray( SharedCacheMap, NULL, 0, FALSE );
    }

    //
    //  Now that the file is unmapped, we can purge the truncated
    //  pages from memory, if TRUNCATE_REQUIRED.  Note that since the
    //  entire section is being purged (FileSize == NULL), the purge
    //  and subsequent delete  of the SharedCacheMap should drop
    //  all references on the section and file object clearing the
    //  way for the Close Call and actual file delete to occur
    //  immediately.
    //

    if (FlagOn(SharedCacheMap->Flags, TRUNCATE_REQUIRED)) {

        DebugTrace( 0, mm, "MmPurgeSection:\n", 0 );
        DebugTrace( 0, mm, "    SectionObjectPointer = %08lx\n",
                    FileObject->SectionObjectPointer );
        DebugTrace2(0, mm, "    Offset = %08lx\n",
                    SharedCacheMap->FileSize.LowPart,
                    SharedCacheMap->FileSize.HighPart );

        CcPurgeCacheSection( FileObject->SectionObjectPointer,
                             NULL,
                             0,
                             FALSE );
    }
}


VOID
CcDeleteMbcb(
    IN PSHARED_CACHE_MAP SharedCacheMap
    )

/*++

Routine Description:

    This routine may be called to reset the Mbcb for a stream to say
    there are no dirty pages, and free all auxiliary allocation.

Arguments:

    SharedCacheMap - Pointer to SharedCacheMap.

Return Value:

    None.

--*/

{
    PMBCB Mbcb;
    PBITMAP_RANGE BitmapRange;
    KLOCK_QUEUE_HANDLE LockHandle;
    ULONG DoDrain = FALSE;
    PLIST_ENTRY NextEntry;
    LIST_ENTRY BitmapRangesToFree;

    InitializeListHead( &BitmapRangesToFree );

    KeAcquireInStackQueuedSpinLock( &SharedCacheMap->BcbSpinLock, &LockHandle );

    Mbcb = SharedCacheMap->Mbcb;

    //
    //  Is there an Mbcb?
    //

    if (Mbcb != NULL) {

        //
        //  First deduct the dirty pages we are getting rid of.
        //

        CcAcquireMasterLockAtDpcLevel();
        CcDeductDirtyPages( SharedCacheMap, Mbcb->DirtyPages );
        CcReleaseMasterLockFromDpcLevel();

        //
        //  Now loop through all of the ranges.
        //

        while (!IsListEmpty(&Mbcb->BitmapRanges)) {

            //
            //  Get next range and remove it from the list.
            //

            BitmapRange = (PBITMAP_RANGE)CONTAINING_RECORD( Mbcb->BitmapRanges.Flink,
                                                            BITMAP_RANGE,
                                                            Links );

            RemoveEntryList( &BitmapRange->Links );

            //
            //  If there is a bitmap, and it is not the initial embedded one, then
            //  delete it.
            //

            if ((BitmapRange->Bitmap != NULL) &&
                (BitmapRange->Bitmap != (PULONG)&Mbcb->BitmapRange2)) {

                DoDrain = TRUE;

                //
                //  Usually the bitmap is all zeros at this point, but it may not be.
                //

                if (BitmapRange->DirtyPages != 0) {
                    RtlZeroMemory( BitmapRange->Bitmap, MBCB_BITMAP_BLOCK_SIZE );
                }
                CcAcquireVacbLockAtDpcLevel();
                CcDeallocateVacbLevel( (PVACB *)BitmapRange->Bitmap, FALSE );
                CcReleaseVacbLockFromDpcLevel();
            }

            //
            //  If the range is not one of the initial embedded ranges, then delete it.
            //

            if ((BitmapRange < (PBITMAP_RANGE)Mbcb) ||
                (BitmapRange >= (PBITMAP_RANGE)((PCHAR)Mbcb + sizeof(MBCB)))) {

                InsertTailList( &BitmapRangesToFree, &BitmapRange->Links );
            }
        }

        //
        //  Zero the pointer and get out.
        //

        SharedCacheMap->Mbcb = NULL;

        KeReleaseInStackQueuedSpinLock( &LockHandle );

        //
        // Free all the pool now that no locks are held.
        //

        while (!IsListEmpty(&BitmapRangesToFree)) {
            NextEntry = RemoveHeadList( &BitmapRangesToFree );

            BitmapRange = CONTAINING_RECORD ( NextEntry,
                                              BITMAP_RANGE,
                                              Links );

            ExFreePool( BitmapRange );
        }

        //
        //  Now delete the Mbcb.
        //

        CcDeallocateBcb( (PBCB)Mbcb );

    } else {

        KeReleaseInStackQueuedSpinLock( &LockHandle );
    }

    if (DoDrain) {
        CcDrainVacbLevelZone();
    }
}


VOID
CcSetDirtyPageThreshold (
    __in PFILE_OBJECT FileObject,
    __in ULONG DirtyPageThreshold
    )

/*++

Routine Description:

    This routine may be called to set a dirty page threshold for this
    stream.  The write throttling will kick in whenever the file system
    attempts to exceed the dirty page threshold for this file.

Arguments:

    FileObject - Supplies file object for the stream

    DirtyPageThreshold - Supplies the dirty page threshold for this stream,
                         or 0 for no threshold.

Return Value:

    None

Environment:

    The caller must guarantee exclusive access to the FsRtl header flags,
    for example, by calling this routine once during create of the structure
    containing the header.  Then it would call the routine again when actually
    caching the stream.

--*/

{
    PSHARED_CACHE_MAP SharedCacheMap = FileObject->SectionObjectPointer->SharedCacheMap;

    if (SharedCacheMap != NULL) {

        SharedCacheMap->DirtyPageThreshold = DirtyPageThreshold;
    }

    //
    //  Test the flag before setting, in case the caller is no longer properly
    //  synchronized.
    //

    if (!FlagOn(((PFSRTL_COMMON_FCB_HEADER)(FileObject->FsContext))->Flags,
                FSRTL_FLAG_LIMIT_MODIFIED_PAGES)) {

        SetFlag(((PFSRTL_COMMON_FCB_HEADER)(FileObject->FsContext))->Flags,
                FSRTL_FLAG_LIMIT_MODIFIED_PAGES);
    }
}


VOID
CcZeroEndOfLastPage (
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine is only called by Mm before mapping a user view to
    a section.  If there is an uninitialized page at the end of the
    file, we zero it by freeing that page.

Parameters:

    FileObject - File object for section to be mapped

Return Value:

    None
--*/

{
    PSHARED_CACHE_MAP SharedCacheMap;
    ULONG ActivePage;
    ULONG PageIsDirty;
    KIRQL OldIrql;
    PVOID NeedToZero = NULL;
    PVACB ActiveVacb = NULL;
    IO_STATUS_BLOCK Iosb;
    BOOLEAN PurgeResult;
    BOOLEAN ReferencedCacheMap = FALSE;
    
    //
    //  See if we have an active Vacb, that we need to free.
    //

    FsRtlAcquireFileExclusive( FileObject );
    CcAcquireMasterLock( &OldIrql );
    SharedCacheMap = FileObject->SectionObjectPointer->SharedCacheMap;

    if (SharedCacheMap != NULL) {

        //
        //  See if there is an active vacb.
        //

        if ((SharedCacheMap->ActiveVacb != NULL) || ((NeedToZero = SharedCacheMap->NeedToZero) != NULL)) {

            CcIncrementOpenCount( SharedCacheMap, 'peZS' );
            ReferencedCacheMap = TRUE;
            GetActiveVacbAtDpcLevel( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
        }
    }

    CcReleaseMasterLock( OldIrql );

    //
    //  Remember in FsRtl header there is a user section.
    //  If this is an advanced header then also acquire the mutex to access
    //  this field.
    //

    if (FlagOn( ((PFSRTL_COMMON_FCB_HEADER)FileObject->FsContext)->Flags,
                FSRTL_FLAG_ADVANCED_HEADER )) {

        ExAcquireFastMutex( ((PFSRTL_ADVANCED_FCB_HEADER)FileObject->FsContext)->FastMutex );

        SetFlag( ((PFSRTL_COMMON_FCB_HEADER)FileObject->FsContext)->Flags,
                 FSRTL_FLAG_USER_MAPPED_FILE );

        ExReleaseFastMutex( ((PFSRTL_ADVANCED_FCB_HEADER)FileObject->FsContext)->FastMutex );

    } else {

        SetFlag( ((PFSRTL_COMMON_FCB_HEADER)FileObject->FsContext)->Flags,
                 FSRTL_FLAG_USER_MAPPED_FILE );
    }

    //
    //  Free the active vacb now so we don't deadlock if we have to purge
    //


    if ((ActiveVacb != NULL) || (NeedToZero != NULL)) {
        CcFreeActiveVacb( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
    }


    if (FlagOn( ((PFSRTL_COMMON_FCB_HEADER)FileObject->FsContext)->Flags2, FSRTL_FLAG2_PURGE_WHEN_MAPPED )) {

        if (FileObject->SectionObjectPointer->SharedCacheMap) {
            ASSERT( ((PSHARED_CACHE_MAP)(FileObject->SectionObjectPointer->SharedCacheMap))->VacbActiveCount == 0 );
        }

        CcFlushCache( FileObject->SectionObjectPointer, NULL, 0, &Iosb );

        //
        //  Only purge if the flush was successful so we don't lose user data
        //  

        if (Iosb.Status == STATUS_SUCCESS) {
            PurgeResult = CcPurgeCacheSection( FileObject->SectionObjectPointer, NULL, 0, FALSE );
        }

        if (FileObject->SectionObjectPointer->SharedCacheMap) {
            ASSERT( ((PSHARED_CACHE_MAP)(FileObject->SectionObjectPointer->SharedCacheMap))->VacbActiveCount == 0 );
        }
    }


    FsRtlReleaseFile( FileObject );

    //
    //  If the file is cached and we have a Vacb to free, we need to
    //  use the lazy writer callback to synchronize so no one will be
    //  extending valid data.
    //

    if (ReferencedCacheMap) {

        //
        //  Serialize again to decrement the open count.
        //

        CcAcquireMasterLock( &OldIrql );

        CcDecrementOpenCount( SharedCacheMap, 'peZF' );

        if ((SharedCacheMap->OpenCount == 0) &&
            !FlagOn(SharedCacheMap->Flags, WRITE_QUEUED) &&
            (SharedCacheMap->DirtyPages == 0)) {

            //
            //  Move to the dirty list.
            //

            RemoveEntryList( &SharedCacheMap->SharedCacheMapLinks );
            InsertTailList( &CcDirtySharedCacheMapList.SharedCacheMapLinks,
                            &SharedCacheMap->SharedCacheMapLinks );

            //
            //  Make sure the Lazy Writer will wake up, because we
            //  want him to delete this SharedCacheMap.
            //

            LazyWriter.OtherWork = TRUE;
            if (!LazyWriter.ScanActive) {
                CcScheduleLazyWriteScan( FALSE );
            }
        }

        CcReleaseMasterLock( OldIrql );
    }
}


BOOLEAN
CcZeroData (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER StartOffset,
    __in PLARGE_INTEGER EndOffset,
    __in BOOLEAN Wait
    )

/*++

Routine Description:

    This routine attempts to zero the specified file data and deliver the
    correct I/O status.

    If the caller does not want to block (such as for disk I/O), then
    Wait should be supplied as FALSE.  If Wait was supplied as FALSE and
    it is currently impossible to zero all of the requested data without
    blocking, then this routine will return FALSE.  However, if the
    required space is immediately accessible in the cache and no blocking is
    required, this routine zeros the data and returns TRUE.

    If the caller supplies Wait as TRUE, then this routine is guaranteed
    to zero the data and return TRUE.  If the correct space is immediately
    accessible in the cache, then no blocking will occur.  Otherwise,
    the necessary work will be initiated to read and/or free cache data,
    and the caller will be blocked until the data can be received.

    File system Fsd's should typically supply Wait = TRUE if they are
    processing a synchronous I/O requests, or Wait = FALSE if they are
    processing an asynchronous request.

    File system threads should supply Wait = TRUE.

    IMPORTANT NOTE: File systems which call this routine must be prepared
    to handle a special form of a write call where the Mdl is already
    supplied.  Namely, if Irp->MdlAddress is supplied, the file system
    must check the low order bit of Irp->MdlAddress->ByteOffset.  If it
    is set, that means that the Irp was generated in this routine and
    the file system must do two things:

        Decrement Irp->MdlAddress->ByteOffset and Irp->UserBuffer

        Clear Irp->MdlAddress immediately prior to completing the
        request, as this routine expects to reuse the Mdl and
        ultimately deallocate the Mdl itself.

Arguments:

    FileObject - pointer to the FileObject for which a range of bytes
                 is to be zeroed.  This FileObject may either be for
                 a cached file or a noncached file.  If the file is
                 not cached, then WriteThrough must be TRUE and
                 StartOffset and EndOffset must be on sector boundaries.

    StartOffset - Start offset in file to be zeroed.

    EndOffset - End offset in file to be zeroed.

    Wait - FALSE if caller may not block, TRUE otherwise (see description
           above)

Return Value:

    FALSE - if Wait was supplied as FALSE and the data was not zeroed.

    TRUE - if the data has been zeroed.

Raises:

    STATUS_INSUFFICIENT_RESOURCES - If a pool allocation failure occurs.
        This can only occur if Wait was specified as TRUE.  (If Wait is
        specified as FALSE, and an allocation failure occurs, this
        routine simply returns FALSE.)

--*/

{
    PSHARED_CACHE_MAP SharedCacheMap;
    PVOID CacheBuffer;
    LARGE_INTEGER FOffset;
    LARGE_INTEGER ToGo;
    ULONG ZeroBytes, ZeroTransfer;
    ULONG SectorMask;
    ULONG i;
    BOOLEAN WriteThrough;
    BOOLEAN AggressiveZero = FALSE;
    ULONG SavedState = 0;
    ULONG MaxZerosInCache = MAX_ZEROS_IN_CACHE;
    ULONG NumberOfColors = 1;

    PBCB Bcb = NULL;
    PCHAR Zeros = NULL;
    PMDL ZeroMdl = NULL;
    ULONG MaxBytesMappedInMdl = 0;
    BOOLEAN Result = TRUE;

    PPFN_NUMBER Page;
    ULONG SavedByteCount;
    LARGE_INTEGER SizeLeft;

    DebugTrace(+1, me, "CcZeroData\n", 0 );

    WriteThrough = (BOOLEAN)(((FileObject->Flags & FO_WRITE_THROUGH) != 0) ||
                   (FileObject->PrivateCacheMap == NULL));

    //
    //  If the caller specified Wait, but the FileObject is WriteThrough,
    //  then we need to just get out.
    //

    if (WriteThrough && !Wait) {

        DebugTrace(-1, me, "CcZeroData->FALSE (WriteThrough && !Wait)\n", 0 );

        return FALSE;
    }

    SharedCacheMap = FileObject->SectionObjectPointer->SharedCacheMap;

    SectorMask = IoGetRelatedDeviceObject(FileObject)->SectorSize - 1;

    FOffset = *StartOffset;

    //
    //  Calculate how much to zero this time.
    //

    ToGo.QuadPart = EndOffset->QuadPart - FOffset.QuadPart;

    //
    //  This magic number is what the fastpaths throttle on, and they will present
    //  non-sector aligned zeroing requests. As long as we will always handle them
    //  on the cached path, we are OK.
    //
    //  If we will not make the cached path, the request must be aligned.
    //

    ASSERT( ToGo.QuadPart <= 0x2000 ||
            ((ToGo.LowPart & SectorMask) == 0  &&
             (FOffset.LowPart & SectorMask) == 0));

    //
    //  We will only do zeroing in the cache if the caller is using a
    //  cached file object, and did not specify WriteThrough.  We are
    //  willing to zero some data in the cache if our total is not too
    //  much, or there is sufficient available pages.
    //

    if (((ToGo.QuadPart <= 0x2000) ||
         (MmAvailablePages >= ((MAX_ZEROS_IN_CACHE / PAGE_SIZE) * 4))) && !WriteThrough) {

        try {

            while (MaxZerosInCache != 0) {

                ULONG ReceivedLength;
                LARGE_INTEGER BeyondLastByte;

                if ( ToGo.QuadPart > (LONGLONG)MaxZerosInCache ) {

                    //
                    //  If Wait == FALSE, then there is no point in getting started,
                    //  because we would have to start all over again zeroing with
                    //  Wait == TRUE, since we would fall out of this loop and
                    //  start synchronously writing pages to disk.
                    //

                    if (!Wait) {

                        DebugTrace(-1, me, "CcZeroData -> FALSE\n", 0 );

                        try_return( Result = FALSE );
                    }
                }
                else {
                    MaxZerosInCache = ToGo.LowPart;
                }

                //
                //  Call local routine to Map or Access the file data, then zero the data,
                //  then call another local routine to free the data.  If we cannot map
                //  the data because of a Wait condition, return FALSE.
                //
                //  Note that this call may result in an exception, however, if it
                //  does no Bcb is returned and this routine has absolutely no
                //  cleanup to perform.  Therefore, we do not have a try-finally
                //  and we allow the possibility that we will simply be unwound
                //  without notice.
                //

                if (!CcPinFileData( FileObject,
                                    &FOffset,
                                    MaxZerosInCache,
                                    FALSE,
                                    TRUE,
                                    Wait,
                                    &Bcb,
                                    &CacheBuffer,
                                    &BeyondLastByte )) {

                    DebugTrace(-1, me, "CcZeroData -> FALSE\n", 0 );

                    try_return( Result = FALSE );
                }

                //
                //  Calculate how much data is described by Bcb starting at our desired
                //  file offset.  If it is more than we need, we will zero the whole thing
                //  anyway.
                //

                ReceivedLength = (ULONG)(BeyondLastByte.QuadPart - FOffset.QuadPart );

                //
                //  Now attempt to allocate an Mdl to describe the mapped data.
                //

                ZeroMdl = IoAllocateMdl( CacheBuffer,
                                         ReceivedLength,
                                         FALSE,
                                         FALSE,
                                         NULL );

                if (ZeroMdl == NULL) {

                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }

                //
                //  It is necessary to probe and lock the pages, or else
                //  the pages may not still be in memory when we do the
                //  MmSetAddressRangeModified for the dirty Bcb.
                //

                MmDisablePageFaultClustering(&SavedState);
                MmProbeAndLockPages( ZeroMdl, KernelMode, IoReadAccess );
                MmEnablePageFaultClustering(SavedState);
                SavedState = 0;

                //
                //  Assume we did not get all the data we wanted, and set FOffset
                //  to the end of the returned data, and advance buffer pointer.
                //

                FOffset = BeyondLastByte;

                //
                //  Figure out how many bytes we are allowed to zero in the cache.
                //  Note it is possible we have zeroed a little more than our maximum,
                //  because we hit an existing Bcb that extended beyond the range.
                //

                if (MaxZerosInCache <= ReceivedLength) {
                    MaxZerosInCache = 0;
                }
                else {
                    MaxZerosInCache -= ReceivedLength;
                }

                //
                //  Now set the Bcb dirty.  We have to explicitly set the address
                //  range modified here, because that work otherwise gets deferred
                //  to the Lazy Writer.
                //

                MmSetAddressRangeModified( CacheBuffer, ReceivedLength );
                CcSetDirtyPinnedData( Bcb, NULL );

                //
                //  Unmap the data now
                //

                CcUnpinFileData( Bcb, FALSE, UNPIN );
                Bcb = NULL;

                //
                //  Unlock and free the Mdl (we only loop back if we crossed
                //  a 256KB boundary.
                //

                MmUnlockPages( ZeroMdl );
                IoFreeMdl( ZeroMdl );
                ZeroMdl = NULL;
            }

        try_exit: NOTHING;
        } finally {

            if (SavedState != 0) {
                MmEnablePageFaultClustering(SavedState);
            }

            //
            //  Clean up only necessary in abnormal termination.
            //

            if (Bcb != NULL) {

                CcUnpinFileData( Bcb, FALSE, UNPIN );
            }

            //
            //  Since the last thing in the above loop which can
            //  fail is the MmProbeAndLockPages, we only need to
            //  free the Mdl here.
            //

            if (ZeroMdl != NULL) {

                IoFreeMdl( ZeroMdl );
            }
        }

        //
        //  If hit a wait condition above, return it now.
        //

        if (!Result) {
            return FALSE;
        }

        //
        //  If we finished, get out nbow.
        //

        if ( FOffset.QuadPart >= EndOffset->QuadPart ) {
            return TRUE;
        }
    }

    //
    //  We either get here because we decided above not to zero anything in
    //  the cache directly, or else we zeroed up to our maximum and still
    //  have some left to zero direct to the file on disk.  In either case,
    //  we will now zero from FOffset to *EndOffset, and then flush this
    //  range in case the file is cached/mapped, and there are modified
    //  changes in memory.
    //

    //
    //  Round FOffset and EndOffset up to sector boundaries, since
    //  we will be doing disk I/O, and calculate size left.
    //

    ASSERT( (FOffset.LowPart & SectorMask) == 0 );

    FOffset.QuadPart += (LONGLONG)SectorMask;
    FOffset.LowPart &= ~SectorMask;
    SizeLeft.QuadPart = EndOffset->QuadPart + (LONGLONG)SectorMask;
    SizeLeft.LowPart &= ~SectorMask;
    SizeLeft.QuadPart -= FOffset.QuadPart;

    ASSERT( (FOffset.LowPart & SectorMask) == 0 );
    ASSERT( (SizeLeft.LowPart & SectorMask) == 0 );

    if (SizeLeft.QuadPart == 0) {
        return TRUE;
    }

    //
    //  try-finally to guarantee cleanup.
    //

    try {

        //
        //  Allocate a page to hold the zeros we will write, and
        //  zero it.
        //

        ZeroBytes = NumberOfColors * PAGE_SIZE;

        if (SizeLeft.HighPart == 0 && SizeLeft.LowPart < ZeroBytes) {
            ZeroBytes = SizeLeft.LowPart;
        }

        Zeros = (PCHAR)ExAllocatePoolWithTag( NonPagedPoolCacheAligned, ZeroBytes, 'eZcC' );

        if (Zeros != NULL) {

            //
            //  Allocate and initialize an Mdl to describe the zeros
            //  we need to transfer.  Allocate to cover the maximum
            //  size required, and we will use and reuse it in the
            //  loop below, initialized correctly.
            //

            if (SizeLeft.HighPart == 0 && SizeLeft.LowPart < MAX_ZERO_TRANSFER) {

                ZeroTransfer = SizeLeft.LowPart;

            } else {

                //
                //  See how aggressive we can afford to be.
                //

                if (InterlockedIncrement( &CcAggressiveZeroCount ) <= CcAggressiveZeroThreshold) {
                    AggressiveZero = TRUE;
                    ZeroTransfer = MAX_ZERO_TRANSFER;
                } else {
                    InterlockedDecrement( &CcAggressiveZeroCount );
                    ZeroTransfer = MIN_ZERO_TRANSFER;
                }
            }

            //
            //  Since the maximum zero may start at a very aggressive level, fall back
            //  until we really have to give up.  Since filter drivers, filesystems and
            //  even storage drivers may need to map this Mdl, we have to pre-map it
            //  into system space so that we know enough PTEs are available.  We also
            //  need to throttle our consumption of virtual addresses based on the size
            //  of the system and the number of parallel instances of this work outstanding.
            //  This may be a bit of overkill, but since running out of PTEs is a fatal
            //  event for the rest of the system, try to help out while still being fast.
            //

            while (TRUE) {

                //
                //  Spin down trying to get an MDL which can describe our operation.
                //
                
                while (TRUE) {

                    ZeroMdl = IoAllocateMdl( Zeros, ZeroTransfer, FALSE, FALSE, NULL );
                
                    //
                    //  Throttle ourselves to what we've physically allocated.  Note that
                    //  we could have started with an odd multiple of this number.  If we
                    //  tried for exactly that size and failed, we're toast.
                    //

                    if (ZeroMdl || ZeroTransfer == ZeroBytes) {

                        break;
                    }
                
                    Fall_Back:
                
                    //
                    //  Fallback by half and round down to a sector multiple.
                    //
                        
                    ZeroTransfer /= 2;
                    ZeroTransfer &= ~SectorMask;
                    if (ZeroTransfer < ZeroBytes) {
                        ZeroTransfer = ZeroBytes;
                    }

                    ASSERT( (ZeroTransfer & SectorMask) == 0 && ZeroTransfer != 0);
                }

                if (ZeroMdl == NULL) {

                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }

                //
                //  If we have throttled all the way down, stop and just build a
                //  simple MDL describing our previous allocation.
                //

                if (ZeroTransfer == ZeroBytes) {

                    MmBuildMdlForNonPagedPool( ZeroMdl );
                    break;
                }

                //
                //  Now we will temporarily lock the allocated pages
                //  only, and then replicate the page frame numbers through
                //  the entire Mdl to keep writing the same pages of zeros.
                //
                //  It would be nice if Mm exported a way for us to not have
                //  to pull the Mdl apart and rebuild it ourselves, but this
                //  is so bizarre a purpose as to be tolerable.
                //

                SavedByteCount = ZeroMdl->ByteCount;
                ZeroMdl->ByteCount = ZeroBytes;
                MmBuildMdlForNonPagedPool( ZeroMdl );

                ZeroMdl->MdlFlags &= ~MDL_SOURCE_IS_NONPAGED_POOL;
                ZeroMdl->MdlFlags |= MDL_PAGES_LOCKED;
                ZeroMdl->MappedSystemVa = NULL;
                ZeroMdl->ByteCount = SavedByteCount;
                Page = MmGetMdlPfnArray( ZeroMdl );
                for (i = NumberOfColors;
                     i < (ADDRESS_AND_SIZE_TO_SPAN_PAGES( 0, SavedByteCount ));
                     i++) {

                    *(Page + i) = *(Page + i - NumberOfColors);
                }

                if (MmGetSystemAddressForMdlSafe( ZeroMdl, LowPagePriority ) == NULL) {

                    //
                    //  Blow away this Mdl and trim for the retry.  Since it didn't
                    //  get mapped, there is nothing fancy to do.
                    //

                    IoFreeMdl( ZeroMdl );
                    goto Fall_Back;
                }

                break;
            }

        //
        //  We failed to allocate the space we wanted, so we will go to
        //  half of a page and limp along.
        //

        } else {

            //
            //  Of course, if we have a device which has large sectors, that defines
            //  the lower limit of our attempt.
            //

            if (IoGetRelatedDeviceObject(FileObject)->SectorSize < PAGE_SIZE / 2) {
                
                ZeroBytes = PAGE_SIZE / 2;
                Zeros = (PCHAR)ExAllocatePoolWithTag( NonPagedPoolCacheAligned, ZeroBytes, 'eZcC' );
            }

            //
            //  If we cannot get even that much, then let's write a sector at a time.
            //

            if (Zeros == NULL) {

                ZeroBytes = IoGetRelatedDeviceObject(FileObject)->SectorSize;
                Zeros = (PCHAR)ExAllocatePoolWithTag( NonPagedPoolCacheAligned, ZeroBytes, 'eZcC' );

                //
                //  If we cannot get even the minimum, we have to give up.
                //

                if (Zeros == NULL) {
                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }
            }

            //
            //  Allocate and initialize an Mdl to describe the zeros
            //  we need to transfer.  Allocate to cover the maximum
            //  size required, and we will use and reuse it in the
            //  loop below, initialized correctly.
            //

            ZeroTransfer = ZeroBytes;
            ZeroMdl = IoAllocateMdl( Zeros, ZeroBytes, FALSE, FALSE, NULL );

            ASSERT( (ZeroTransfer & SectorMask) == 0 );

            if (ZeroMdl == NULL) {
                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }

            //
            //  Now we will lock and map the allocated pages.
            //

            MmBuildMdlForNonPagedPool( ZeroMdl );

            ASSERT( ZeroMdl->MappedSystemVa == Zeros );
        }

        //
        //  Zero the buffer now.
        //

        RtlZeroMemory( Zeros, ZeroBytes );

        //
        //  We have a mapped and zeroed range back by an MDL to use.  Note the
        //  size we have for cleanup, since we will possibly wind this down
        //  over the operation.
        //

        ASSERT( MmGetSystemAddressForMdl(ZeroMdl) );
        MaxBytesMappedInMdl = ZeroMdl->ByteCount;

        //
        //  Now loop to write buffers full of zeros through to the file
        //  until we reach the starting Vbn for the transfer.
        //

        ASSERT( ZeroTransfer != 0 &&
                (ZeroTransfer & SectorMask) == 0 &&
                (SizeLeft.LowPart & SectorMask) == 0 );

        while ( SizeLeft.QuadPart != 0 ) {

            IO_STATUS_BLOCK IoStatus;
            NTSTATUS Status;
            KEVENT Event;

            //
            //  See if we really need to write that many zeros, and
            //  trim the size back if not.
            //

            if ( (LONGLONG)ZeroTransfer > SizeLeft.QuadPart ) {

                ZeroTransfer = SizeLeft.LowPart;
            }

            //
            //  (Re)initialize the kernel event to FALSE.
            //

            KeInitializeEvent( &Event, NotificationEvent, FALSE );

            //
            //  Initiate and wait for the synchronous transfer.
            //

            ZeroMdl->ByteCount = ZeroTransfer;

            Status = IoSynchronousPageWrite( FileObject,
                                             ZeroMdl,
                                             &FOffset,
                                             &Event,
                                             &IoStatus );

            //
            //  If pending is returned (which is a successful status),
            //  we must wait for the request to complete.
            //

            if (Status == STATUS_PENDING) {
                KeWaitForSingleObject( &Event,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       (PLARGE_INTEGER)NULL);
            }


            //
            //  If we got an error back in Status, then the Iosb
            //  was not written, so we will just copy the status
            //  there, then test the final status after that.
            //

            if (!NT_SUCCESS(Status)) {
                ExRaiseStatus( Status );
            }

            if (!NT_SUCCESS(IoStatus.Status)) {
                ExRaiseStatus( IoStatus.Status );
            }

            //
            //  If we succeeded, then update where we are at by how much
            //  we wrote, and loop back to see if there is more.
            //

            FOffset.QuadPart = FOffset.QuadPart + (LONGLONG)ZeroTransfer;
            SizeLeft.QuadPart = SizeLeft.QuadPart - (LONGLONG)ZeroTransfer;
        }
    }
    finally{

        //
        //  Clean up anything from zeroing pages on a noncached
        //  write.
        //

        if (ZeroMdl != NULL) {

            if ((MaxBytesMappedInMdl != 0) &&
                !FlagOn(ZeroMdl->MdlFlags, MDL_SOURCE_IS_NONPAGED_POOL)) {
                ZeroMdl->ByteCount = MaxBytesMappedInMdl;
                MmUnmapLockedPages (ZeroMdl->MappedSystemVa, ZeroMdl);
            }

            IoFreeMdl( ZeroMdl );
        }

        if (AggressiveZero) {
            InterlockedDecrement( &CcAggressiveZeroCount );
        }

        if (Zeros != NULL) {
            ExFreePool( Zeros );
        }

        DebugTrace(-1, me, "CcZeroData -> TRUE\n", 0 );
    }

    return TRUE;
}


PFILE_OBJECT
CcGetFileObjectFromSectionPtrs (
    __in PSECTION_OBJECT_POINTERS SectionObjectPointer
    )

/*++

This routine may be used to retrieve a pointer to the FileObject that the
Cache Manager is using for a given file from the Section Object Pointers
in the nonpaged File System structure Fcb.  The use of this function is
intended for exceptional use unrelated to the processing of user requests,
when the File System would otherwise not have a FileObject at its disposal.
An example is for mount verification.

Note that the File System is responsible for ensuring that the File
Object does not go away while in use.  It is impossible for the Cache
Manager to guarantee this.

Arguments:

    SectionObjectPointer - A pointer to the Section Object Pointers
                           structure in the nonpaged Fcb.

Return Value:

    Pointer to the File Object, or NULL if the file is not cached or no
    longer cached

--*/

{
    KIRQL OldIrql;
    PFILE_OBJECT FileObject = NULL;

    //
    //  Serialize with Creation/Deletion of all Shared CacheMaps
    //

    CcAcquireMasterLock( &OldIrql );

    if (SectionObjectPointer->SharedCacheMap != NULL) {

        FileObject = ((PSHARED_CACHE_MAP)SectionObjectPointer->SharedCacheMap)->FileObject;
    }

    CcReleaseMasterLock( OldIrql );

    return FileObject;
}


PFILE_OBJECT
CcGetFileObjectFromBcb (
    __in PVOID Bcb
    )

/*++

This routine may be used to retrieve a pointer to the FileObject that the
Cache Manager is using for a given file from a Bcb of that file.

Note that the File System is responsible for ensuring that the File
Object does not go away while in use.  It is impossible for the Cache
Manager to guarantee this.

Arguments:

    Bcb - A pointer to the pinned Bcb.

Return Value:

    Pointer to the File Object, or NULL if the file is not cached or no
    longer cached

--*/

{
    return ((PBCB)Bcb)->SharedCacheMap->FileObject;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\cache\cachedat.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cachedat.c

Abstract:

    This module implements the Memory Management based cache management
    routines for the common Cache subsystem.

--*/

#include "cc.h"

//
//  Global SharedCacheMap lists and resource to synchronize access to it.
//
//

// extern KSPIN_LOCK CcMasterSpinLock;
LIST_ENTRY CcCleanSharedCacheMapList;
SHARED_CACHE_MAP_LIST_CURSOR CcDirtySharedCacheMapList;
SHARED_CACHE_MAP_LIST_CURSOR CcLazyWriterCursor;

//
//  Worker thread structures:
//
//      A spinlock to synchronize all three lists.
//      A count of the number of worker threads Cc will use
//      A count of the number of worker threads Cc in use
//      A listhead for preinitialized executive work items for Cc use.
//      A listhead for an express queue of WORK_QUEUE_ENTRYs
//      A listhead for a regular queue of WORK_QUEUE_ENTRYs
//      A listhead for a post-tick queue of WORK_QUEUE_ENTRYs
//
//      A flag indicating if we are throttling the queue to a single thread
//

// extern KSPIN_LOCK CcWorkQueueSpinLock;
ULONG CcNumberWorkerThreads = 0;
ULONG CcNumberActiveWorkerThreads = 0;
LIST_ENTRY CcIdleWorkerThreadList;
LIST_ENTRY CcExpressWorkQueue;
LIST_ENTRY CcRegularWorkQueue;
LIST_ENTRY CcPostTickWorkQueue;

BOOLEAN CcQueueThrottle = FALSE;

//
//  Store the current idle delay and target time to clean all.  We must calculate
//  the idle delay in terms of clock ticks for the lazy writer timeout.
//

ULONG CcIdleDelayTick;
LARGE_INTEGER CcNoDelay;
LARGE_INTEGER CcFirstDelay = {(ULONG)-(3*LAZY_WRITER_IDLE_DELAY), -1};
LARGE_INTEGER CcIdleDelay = {(ULONG)-LAZY_WRITER_IDLE_DELAY, -1};
LARGE_INTEGER CcCollisionDelay = {(ULONG)-LAZY_WRITER_COLLISION_DELAY, -1};
LARGE_INTEGER CcTargetCleanDelay = {(ULONG)-(LONG)(LAZY_WRITER_IDLE_DELAY * (LAZY_WRITER_MAX_AGE_TARGET + 1)), -1};

//
//  Spinlock for controlling access to Vacb and related global structures,
//  and a counter indicating how many Vcbs are active.
//

// extern KSPIN_LOCK CcVacbSpinLock;
ULONG_PTR CcNumberVacbs;

//
//  Pointer to the global Vacb vector.
//

PVACB CcVacbs;
PVACB CcBeyondVacbs;
LIST_ENTRY CcVacbLru;
LIST_ENTRY CcVacbFreeList;
ULONG CcMaxVacbLevelsSeen = 1;
ULONG CcVacbLevelEntries = 0;
PVACB *CcVacbLevelFreeList = NULL;
ULONG CcVacbLevelWithBcbsEntries = 0;
PVACB *CcVacbLevelWithBcbsFreeList = NULL;

//
//  Deferred write list and respective Thresholds
//

extern ALIGNED_SPINLOCK CcDeferredWriteSpinLock;
LIST_ENTRY CcDeferredWrites;
ULONG CcDirtyPageThreshold;
ULONG CcDirtyPageTarget;
ULONG CcPagesYetToWrite;
ULONG CcPagesWrittenLastTime = 0;
ULONG CcDirtyPagesLastScan = 0;
ULONG CcAvailablePagesThreshold = 100;
ULONG CcTotalDirtyPages = 0;

//
//  Captured system size
//

MM_SYSTEMSIZE CcCapturedSystemSize;

//
//  Number of outstanding aggressive zeroers in the system.  Used
//  to throttle the activity.
//

LONG CcAggressiveZeroCount;
LONG CcAggressiveZeroThreshold;

//
//  Tuning options du Jour
//

ULONG CcTune = 0;

//
//  Global structure controlling lazy writer algorithms
//

LAZY_WRITER LazyWriter;

GENERAL_LOOKASIDE CcTwilightLookasideList;

//
//  Global list of pinned Bcbs which may be examined for debug purposes
//

#if DBG

ULONG CcBcbCount;
LIST_ENTRY CcBcbList;

#endif

//
//  Throw away miss counter.
//

ULONG CcThrowAway;

//
//  Performance Counters
//

ULONG CcFastReadNoWait;
ULONG CcFastReadWait;
ULONG CcFastReadResourceMiss;
ULONG CcFastReadNotPossible;

ULONG CcFastMdlReadNoWait;
ULONG CcFastMdlReadWait;
ULONG CcFastMdlReadResourceMiss;
ULONG CcFastMdlReadNotPossible;

ULONG CcMapDataNoWait;
ULONG CcMapDataWait;
ULONG CcMapDataNoWaitMiss;
ULONG CcMapDataWaitMiss;

ULONG CcPinMappedDataCount;

ULONG CcPinReadNoWait;
ULONG CcPinReadWait;
ULONG CcPinReadNoWaitMiss;
ULONG CcPinReadWaitMiss;

ULONG CcCopyReadNoWait;
ULONG CcCopyReadWait;
ULONG CcCopyReadNoWaitMiss;
ULONG CcCopyReadWaitMiss;

ULONG CcMdlReadNoWait;
ULONG CcMdlReadWait;
ULONG CcMdlReadNoWaitMiss;
ULONG CcMdlReadWaitMiss;

ULONG CcReadAheadIos;

ULONG CcLazyWriteHotSpots;
ULONG CcLazyWriteIos;
ULONG CcLazyWritePages;
ULONG CcDataFlushes;
ULONG CcDataPages;

ULONG CcLostDelayedWrites;

PULONG CcMissCounter = &CcThrowAway;
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\cache\cachesub.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cachesub.c

Abstract:

    This module implements the common subroutines for the Cache subsystem.

--*/

#include "cc.h"

//
//  The Bugcheck file id for this module
//

#define BugCheckFileId                   (CACHE_BUG_CHECK_CACHESUB)

//
//  Define our debug constant
//

#define me 0x00000002

//
//  Define those errors which should be retried
//
//  Note: We sometimes need to treat STATUS_ENCOUNTERED_WRITE_IN_PROGRESS
//    differently than the other retry-able errors, but we still need to
//    keep it in this test since we don't want LostDelayedWrite popups or
//    event log messages to be generated for this error.
//

#define RetryError(STS) (((STS) == STATUS_VERIFY_REQUIRED) || ((STS) == STATUS_FILE_LOCK_CONFLICT) || ((STS) == STATUS_ENCOUNTERED_WRITE_IN_PROGRESS))

ULONG CcMaxDirtyWrite = 0x10000;

//
//  Local support routines
//

BOOLEAN
CcFindBcb (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN PLARGE_INTEGER FileOffset,
    IN OUT PLARGE_INTEGER BeyondLastByte,
    OUT PBCB *Bcb
    );

PBCB
CcAllocateInitializeBcb (
    IN OUT PSHARED_CACHE_MAP SharedCacheMap OPTIONAL,
    IN OUT PBCB AfterBcb,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length
    );

NTSTATUS
CcSetValidData (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER ValidDataLength
    );

BOOLEAN
CcAcquireByteRangeForWrite (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN PLARGE_INTEGER TargetOffset OPTIONAL,
    IN ULONG TargetLength,
    OUT PLARGE_INTEGER FileOffset,
    OUT PULONG Length,
    OUT PBCB *FirstBcb
    );

VOID
CcReleaseByteRangeFromWrite (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN PBCB FirstBcb,
    IN BOOLEAN VerifyRequired
    );

PBITMAP_RANGE
CcFindBitmapRangeToDirty (
    IN PMBCB Mbcb,
    IN LONGLONG Page,
    IN PULONG *FreePageForSetting
    );

PBITMAP_RANGE
CcFindBitmapRangeToClean (
    IN PMBCB Mbcb,
    IN LONGLONG Page
    );

BOOLEAN
CcLogError(
    IN PFILE_OBJECT FileObject,
    IN PUNICODE_STRING FileName,
    IN NTSTATUS Error,
    IN NTSTATUS DeviceError,
    IN UCHAR IrpMajorCode
    );



//
//  Internal support routine
//

BOOLEAN
CcPinFileData (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN ReadOnly,
    IN BOOLEAN WriteOnly,
    IN ULONG Flags,
    OUT PBCB *Bcb,
    OUT PVOID *BaseAddress,
    OUT PLARGE_INTEGER BeyondLastByte
    )

/*++

Routine Description:

    This routine locks the specified range of file data into memory.

    Note that the data desired by the caller (or the first part of it)
    may be in one of three states:

        No Bcb exists which describes the data

        A Bcb exists describing the data, but it is not mapped
        (BcbOut->BaseAddress == NULL)

        A Bcb exists describing the data, and it is mapped

    Given the above three states, and given that the caller may call
    with either Wait == FALSE or Wait == TRUE, this routine has basically
    six cases.  What has to be done, and the order in which things must be
    done varies quite a bit with each of these six cases.  The most
    straight-forward implementation of this routine, with the least amount
    of branching, is achieved by determining which of the six cases applies,
    and dispatching fairly directly to that case.  The handling of the
    cases is summarized in the following table:

                Wait == TRUE                Wait == FALSE
                ------------                -------------

    no Bcb      Case 1:                     Case 2:

                CcAllocateInitializeBcb     CcMapAndRead (exit if FALSE)
                Acquire Bcb Exclusive       CcAllocateInitializeBcb
                Release BcbList SpinLock    Acquire Bcb Shared if not ReadOnly
                CcMapAndRead w/ Wait        Release BcbList SpinLock
                Convert/Release Bcb Resource

    Bcb not     Case 3:                     Case 4:
    mapped
                Increment PinCount          Acquire Bcb Exclusive (exit if FALSE)
                Release BcbList SpinLock    CcMapAndRead (exit if FALSE)
                Acquire Bcb Excl. w/ Wait   Increment PinCount
                if still not mapped         Convert/Release Bcb Resource
                    CcMapAndRead w/ Wait    Release BcbList SpinLock
                Convert/Release Bcb Resource

    Bcb mapped  Case 5:                     Case 6:

                Increment PinCount          if not ReadOnly
                Release BcbList SpinLock        Acquire Bcb shared (exit if FALSE)
                if not ReadOnly             Increment PinCount
                    Acquire Bcb Shared      Release BcbList SpinLock

    It is important to note that most changes to this routine will affect
    multiple cases from above.

Arguments:

    FileObject - Pointer to File Object for file

    FileOffset - Offset in file at which map should begin

    Length - Length of desired map in bytes

    ReadOnly - Supplies TRUE if caller will only read the mapped data (i.e.,
               TRUE for CcCopyRead, CcMapData and CcMdlRead and FALSE for
               everyone else)

    WriteOnly - The specified range of bytes will only be written.

    Flags - (PIN_WAIT, PIN_EXCLUSIVE, PIN_NO_READ, etc. as defined in cache.h)

    Bcb - Returns a pointer to the Bcb representing the pinned data.

    BaseAddress - Returns base address of desired data

    BeyondLastByte - Returns the File Offset of the first byte beyond the
                     last accessible byte.

Return Value:

    FALSE - if PIN_WAIT was set, and it was impossible to lock all
            of the data without blocking
    TRUE - if the desired data, is being returned

Raises:

    STATUS_INSUFFICIENT_RESOURCES - If a pool allocation failure occurs.
        This can only occur if Wait was specified as TRUE.  (If Wait is
        specified as FALSE, and an allocation failure occurs, this
        routine simply returns FALSE.)

--*/

{
    PSHARED_CACHE_MAP SharedCacheMap;
    LARGE_INTEGER TrialBound;
    KLOCK_QUEUE_HANDLE LockHandle;
    PBCB BcbOut = NULL;
    ULONG ZeroFlags = 0;
    LOGICAL SpinLockAcquired = FALSE;
    BOOLEAN Result = FALSE;

    ULONG ReceivedLength;
    ULONG ActivePage;
    ULONG PageIsDirty;
    PVACB Vacb = NULL;

    DebugTrace(+1, me, "CcPinFileData:\n", 0 );
    DebugTrace( 0, me, "    FileObject = %08lx\n", FileObject );
    DebugTrace2(0, me, "    FileOffset = %08lx, %08lx\n", FileOffset->LowPart,
                                                          FileOffset->HighPart );
    DebugTrace( 0, me, "    Length = %08lx\n", Length );
    DebugTrace( 0, me, "    Flags = %02lx\n", Flags );

    //
    //  Get pointer to SharedCacheMap via File Object.
    //

    SharedCacheMap = FileObject->SectionObjectPointer->SharedCacheMap;

    //
    //  See if we have an active Vacb, that we need to free.
    //

    GetActiveVacb( SharedCacheMap, OldIrql, Vacb, ActivePage, PageIsDirty );

    //
    //  If there is an end of a page to be zeroed, then free that page now,
    //  so it does not cause our data to get zeroed.  If there is an active
    //  page, free it so we have the correct ValidDataGoal.
    //

    if ((Vacb != NULL) || (SharedCacheMap->NeedToZero != NULL)) {

        CcFreeActiveVacb( SharedCacheMap, Vacb, ActivePage, PageIsDirty );
        Vacb = NULL;
    }

    //
    //  Make sure the calling file system is not asking to map beyond the
    //  end of the section, for example, that it did not forget to do
    //  CcExtendCacheSection.
    //

    ASSERT( ( FileOffset->QuadPart + (LONGLONG)Length ) <=
                     SharedCacheMap->SectionSize.QuadPart );

    //
    //  Initially clear output
    //

    *Bcb = NULL;
    *BaseAddress = NULL;

    if (!FlagOn(Flags, PIN_NO_READ)) {

        *BaseAddress = CcGetVirtualAddress( SharedCacheMap,
                                            *FileOffset,
                                            &Vacb,
                                            &ReceivedLength );

    } else {

        //
        //  In the PIN_NO_READ case, we simply need to make sure that the
        //  sparse structure containing the Bcb listheads is expanded in the
        //  region of the file we are interested in.
        //
        //  Fake a ReceivedLength that matches the remaining bytes in the view.
        //

        ReceivedLength = VACB_MAPPING_GRANULARITY -
                         (ULONG)(FileOffset->QuadPart & (VACB_MAPPING_GRANULARITY - 1));

        //
        //  Now simply cause a reference that will expand a multilevel Vacb.
        //

        CcReferenceFileOffset( SharedCacheMap, *FileOffset );
    }

    //
    //  Acquire Bcb List Exclusive to look for Bcb
    //

    KeAcquireInStackQueuedSpinLock( &SharedCacheMap->BcbSpinLock, &LockHandle );
    SpinLockAcquired = TRUE;

    //
    //  Use try to guarantee cleanup on the way out.
    //

    try {

        LOGICAL Found;
        LARGE_INTEGER FOffset;
        LARGE_INTEGER TLength;

        //
        //  Search for Bcb describing the largest matching "prefix" byte range,
        //  or where to insert it.
        //

        TrialBound.QuadPart = FileOffset->QuadPart + (LONGLONG)Length;
        Found = CcFindBcb( SharedCacheMap, FileOffset, &TrialBound, &BcbOut );


        //
        //  Cases 1 and 2 - Bcb was not found.
        //
        //  First calculate data to pin down.
        //

        if (!Found) {

            //
            //  Get out if the user specified PIN_IF_BCB.
            //

            if (FlagOn(Flags, PIN_IF_BCB)) {

                //
                //  We need to zap BcbOut since this is a hint to the cleanup code
                //  to remove the Bcb if we are returning FALSE.
                //

                BcbOut = NULL;
                try_return( Result = FALSE );
            }

            //
            //  Not found, calculate data to pin down.
            //
            //  Round local copy of FileOffset down to page boundary, and
            //  round copies of size and minimum size up.  Also make sure that
            //  we keep the length from crossing the end of the SharedCacheMap.
            //

            FOffset = *FileOffset;
            TLength.QuadPart = TrialBound.QuadPart - FOffset.QuadPart;

            TLength.LowPart += FOffset.LowPart & (PAGE_SIZE - 1);
            ReceivedLength += FOffset.LowPart & (PAGE_SIZE - 1);

            //
            //  At this point we can calculate the ReadOnly flag for
            //  the purposes of whether to use the Bcb resource, and
            //  we can calculate the ZeroFlags.
            //

            if ((!ReadOnly  && !FlagOn(SharedCacheMap->Flags, PIN_ACCESS)) || WriteOnly) {

                //
                //  We can always zero middle pages, if any.
                //

                ZeroFlags = ZERO_MIDDLE_PAGES;

                if (((FOffset.LowPart & (PAGE_SIZE - 1)) == 0) &&
                    (Length >= PAGE_SIZE)) {
                    ZeroFlags |= ZERO_FIRST_PAGE;
                }

                if ((TLength.LowPart & (PAGE_SIZE - 1)) == 0) {
                    ZeroFlags |= ZERO_LAST_PAGE;
                }
            }

            //
            //  We treat Bcbs as ReadOnly (do not acquire resource) if they
            //  are in sections for which we have not disabled modified writing.
            //

            if (!FlagOn(SharedCacheMap->Flags, MODIFIED_WRITE_DISABLED)) {
                ReadOnly = TRUE;
            }

            TLength.LowPart = (ULONG) ROUND_TO_PAGES( TLength.LowPart );

            //
            //  Round BaseAddress and FOffset down to the bottom of a page.
            //

            *BaseAddress = ((PCHAR)*BaseAddress - (FileOffset->LowPart & (PAGE_SIZE - 1)));
            FOffset.LowPart &= ~(PAGE_SIZE - 1);

            //
            //  We cannot use a zero page optimization beyond VDL because we
            //  cannot be guaranteed that the caller will track this page as
            //  being dirty.  If the zero-page optimization is used, the page 
            //  returned by Mm will be marked dirty (MmCheckCachedPageState).  
            //  If Cc does not properly track this page as being dirty, the
            //  dirty page may never be written since.  There are cases when 
            //  the file system will not allow the modified page writer to 
            //  write out dirty pages beyond VDL (e.g., NTFS for compressed 
            //  files).
            //

            //
            //  We will get into trouble if we try to read more than we
            //  can map by one Vacb.  So make sure that our lengths stay
            //  within a Vacb.
            //

            if (TLength.LowPart > ReceivedLength) {
                TLength.LowPart = ReceivedLength;
            }


            //
            //  Case 1 - Bcb was not found and Wait is TRUE.
            //
            //  Note that it is important to minimize the time that the Bcb
            //  List spin lock is held, as well as guarantee we do not take
            //  any faults while holding this lock.
            //
            //  If we can (and perhaps will) wait, then it is important to
            //  allocate the Bcb acquire it exclusive and free the Bcb List.
            //  We then proceed to read in the data, and anyone else finding
            //  our Bcb will have to wait shared to ensure that the data is
            //  in.
            //

            if (FlagOn(Flags, PIN_WAIT)) {

                BcbOut = CcAllocateInitializeBcb( SharedCacheMap,
                                                  BcbOut,
                                                  &FOffset,
                                                  &TLength );

                if (BcbOut == NULL) {
                    DebugTrace( 0, 0, "Bcb allocation failure\n", 0 );
                    KeReleaseInStackQueuedSpinLock( &LockHandle );
                    SpinLockAcquired = FALSE;
                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }

                //
                //  Now just acquire the newly-allocated Bcb shared, and
                //  release the spin lock.
                //

                if (!ReadOnly) {
                    if (FlagOn(Flags, PIN_EXCLUSIVE)) {
                        (VOID)ExAcquireResourceExclusiveLite( &BcbOut->Resource, TRUE );
                    } else {
                        (VOID)ExAcquireSharedStarveExclusive( &BcbOut->Resource, TRUE );
                    }
                }
                KeReleaseInStackQueuedSpinLock( &LockHandle );
                SpinLockAcquired = FALSE;

                //
                //  Now read in the data.
                //

                if (!FlagOn(Flags, PIN_NO_READ)) {

                    (VOID)CcMapAndRead( SharedCacheMap,
                                        &FOffset,
                                        TLength.LowPart,
                                        ZeroFlags,
                                        TRUE,
                                        *BaseAddress );

                    //
                    //  Now we have to reacquire the Bcb List spinlock to load
                    //  up the mapping if we are the first one, else we collided
                    //  with someone else who loaded the mapping first, and we
                    //  will just free our mapping.  It is guaranteed that the
                    //  data will be mapped to the same place.
                    //

                    KeAcquireInStackQueuedSpinLock( &SharedCacheMap->BcbSpinLock, &LockHandle );

                    if (BcbOut->BaseAddress == NULL) {

                        BcbOut->BaseAddress = *BaseAddress;
                        BcbOut->Vacb = Vacb;
                        Vacb = NULL;
                    }

                    KeReleaseInStackQueuedSpinLock( &LockHandle );

                    //
                    //  Calculate Base Address of the data we want.
                    //

                    *BaseAddress = (PCHAR)BcbOut->BaseAddress +
                                   (ULONG)( FileOffset->QuadPart - BcbOut->FileOffset.QuadPart );
                }

                //
                //  Success!
                //

                try_return( Result = TRUE );
            }


            //
            //  Case 2 - Bcb was not found and Wait is FALSE
            //
            //  If we cannot wait, then we go immediately see if the data is
            //  there (CcMapAndRead), and then only set up the Bcb and release
            //  the spin lock if the data is there.  Note here we call
            //  CcMapAndRead while holding the spin lock, because we know we
            //  will not fault and not block before returning.
            //

            else {

                //
                //  Now try to allocate and initialize the Bcb.  If we
                //  fail to allocate one, then return FALSE, since we know that
                //  Wait = FALSE.  The caller may get lucky if he calls
                //  us back with Wait = TRUE.
                //

                BcbOut = CcAllocateInitializeBcb( SharedCacheMap,
                                                  BcbOut,
                                                  &FOffset,
                                                  &TLength );

                if (BcbOut == NULL) {

                    try_return( Result = FALSE );
                }

                //
                //  If we are not ReadOnly, we must acquire the newly-allocated
                //  resource shared, and then we can free the spin lock.
                //

                if (!ReadOnly) {
                    ExAcquireSharedStarveExclusive( &BcbOut->Resource, TRUE );
                }
                KeReleaseInStackQueuedSpinLock( &LockHandle );
                SpinLockAcquired = FALSE;

                //
                //  Note that since this call has Wait = FALSE, it cannot
                //  get an exception (see procedure header).
                //

                ASSERT( !FlagOn(Flags, PIN_NO_READ) );
                if (!CcMapAndRead( SharedCacheMap,
                                   &FOffset,
                                   TLength.LowPart,
                                   ZeroFlags,
                                   FALSE,
                                   *BaseAddress )) {

                    try_return( Result = FALSE );
                }

                //
                //  Now we have to reacquire the Bcb List spinlock to load
                //  up the mapping if we are the first one, else we collided
                //  with someone else who loaded the mapping first, and we
                //  will just free our mapping.  It is guaranteed that the
                //  data will be mapped to the same place.
                //

                KeAcquireInStackQueuedSpinLock( &SharedCacheMap->BcbSpinLock, &LockHandle );

                if (BcbOut->BaseAddress == NULL) {

                    BcbOut->BaseAddress = *BaseAddress;
                    BcbOut->Vacb = Vacb;
                    Vacb = NULL;
                }

                KeReleaseInStackQueuedSpinLock( &LockHandle );

                //
                //  Calculate Base Address of the data we want.
                //

                *BaseAddress = (PCHAR)BcbOut->BaseAddress +
                               (ULONG)( FileOffset->QuadPart - BcbOut->FileOffset.QuadPart );

                //
                //  Success!
                //

                try_return( Result = TRUE );
            }

        } else {

            //
            //  We treat Bcbs as ReadOnly (do not acquire resource) if they
            //  are in sections for which we have not disabled modified writing.
            //

            if (!FlagOn(SharedCacheMap->Flags, MODIFIED_WRITE_DISABLED)) {
                ReadOnly = TRUE;
            }
        }


        //
        //  Cases 3 and 4 - Bcb is there but not mapped
        //

        if (BcbOut->BaseAddress == NULL) {

            //
            //  It is too complicated to attempt to calculate any ZeroFlags in this
            //  case, because we have to not only do the tests above, but also
            //  compare to the byte range in the Bcb since we will be passing
            //  those parameters to CcMapAndRead.  Also, the probability of hitting
            //  some window where zeroing is of any advantage is quite small.
            //

            //
            //  Set up to just reread the Bcb exactly as the data in it is
            //  described.
            //

            *BaseAddress = ((PCHAR)*BaseAddress - (FileOffset->LowPart - BcbOut->FileOffset.LowPart));
            FOffset = BcbOut->FileOffset;
            TLength.QuadPart = (LONGLONG)BcbOut->ByteLength;

            //
            //  Case 3 - Bcb is there but not mapped and Wait is TRUE
            //
            //  Increment the PinCount, and then release the BcbList
            //  SpinLock so that we can wait to acquire the Bcb exclusive.
            //  Once we have the Bcb exclusive, map and read it in if no
            //  one beats us to it.  Someone may have beat us to it since
            //  we had to release the SpinLock above.
            //

            if (FlagOn(Flags, PIN_WAIT)) {

                BcbOut->PinCount += 1;

                //
                //  Now we have to release the BcbList SpinLock in order to
                //  acquire the Bcb shared.
                //

                KeReleaseInStackQueuedSpinLock( &LockHandle );
                SpinLockAcquired = FALSE;
                if (!ReadOnly) {
                    if (FlagOn(Flags, PIN_EXCLUSIVE)) {
                        (VOID)ExAcquireResourceExclusiveLite( &BcbOut->Resource, TRUE );
                    } else {
                        (VOID)ExAcquireSharedStarveExclusive( &BcbOut->Resource, TRUE );
                    }
                }

                //
                //  Now proceed to map and read the data in.
                //
                //  Now read in the data.
                //

                if (!FlagOn(Flags, PIN_NO_READ)) {

                    (VOID)CcMapAndRead( SharedCacheMap,
                                        &FOffset,
                                        TLength.LowPart,
                                        ZeroFlags,
                                        TRUE,
                                        *BaseAddress );

                    //
                    //  Now we have to reacquire the Bcb List spinlock to load
                    //  up the mapping if we are the first one, else we collided
                    //  with someone else who loaded the mapping first, and we
                    //  will just free our mapping.  It is guaranteed that the
                    //  data will be mapped to the same place.
                    //

                    KeAcquireInStackQueuedSpinLock( &SharedCacheMap->BcbSpinLock, &LockHandle );

                    if (BcbOut->BaseAddress == NULL) {

                        BcbOut->BaseAddress = *BaseAddress;
                        BcbOut->Vacb = Vacb;
                        Vacb = NULL;
                    }

                    KeReleaseInStackQueuedSpinLock( &LockHandle );

                    //
                    //
                    //  Calculate Base Address of the data we want.
                    //

                    *BaseAddress = (PCHAR)BcbOut->BaseAddress +
                                   (ULONG)( FileOffset->QuadPart - BcbOut->FileOffset.QuadPart );
                }

                //
                //  Success!
                //

                try_return( Result = TRUE );
            }


            //
            //  Case 4 - Bcb is there but not mapped, and Wait is FALSE
            //
            //  Since we cannot wait, we go immediately see if the data is
            //  there (CcMapAndRead), and then only set up the Bcb and release
            //  the spin lock if the data is there.  Note here we call
            //  CcMapAndRead while holding the spin lock, because we know we
            //  will not fault and not block before returning.
            //

            else {

                if (!ReadOnly && !ExAcquireSharedStarveExclusive( &BcbOut->Resource, FALSE )) {

                    //
                    //  If we cannot get the resource and have not incremented PinCount, then
                    //  suppress the unpin on cleanup.
                    //

                    BcbOut = NULL;
                    try_return( Result = FALSE );
                }

                BcbOut->PinCount += 1;

                KeReleaseInStackQueuedSpinLock( &LockHandle );
                SpinLockAcquired = FALSE;

                //
                //  Note that since this call has Wait = FALSE, it cannot
                //  get an exception (see procedure header).
                //

                ASSERT( !FlagOn(Flags, PIN_NO_READ) );
                if (!CcMapAndRead( SharedCacheMap,
                                   &BcbOut->FileOffset,
                                   BcbOut->ByteLength,
                                   ZeroFlags,
                                   FALSE,
                                   *BaseAddress )) {

                    try_return( Result = FALSE );
                }

                //
                //  Now we have to reacquire the Bcb List spinlock to load
                //  up the mapping if we are the first one, else we collided
                //  with someone else who loaded the mapping first, and we
                //  will just free our mapping.  It is guaranteed that the
                //  data will be mapped to the same place.
                //

                KeAcquireInStackQueuedSpinLock( &SharedCacheMap->BcbSpinLock, &LockHandle );

                if (BcbOut->BaseAddress == NULL) {

                    BcbOut->BaseAddress = *BaseAddress;
                    BcbOut->Vacb = Vacb;
                    Vacb = NULL;
                }

                KeReleaseInStackQueuedSpinLock( &LockHandle );

                //
                //  Calculate Base Address of the data we want.
                //

                *BaseAddress = (PCHAR)BcbOut->BaseAddress +
                               (ULONG)( FileOffset->QuadPart - BcbOut->FileOffset.QuadPart );

                //
                //  Success!
                //

                try_return( Result = TRUE );
            }
        }


        //
        //  Cases 5 and 6 - Bcb is there and it is mapped
        //

        else {

            //
            //  Case 5 - Bcb is there and mapped, and Wait is TRUE
            //
            //  We can just increment the PinCount, release the SpinLock
            //  and then acquire the Bcb Shared if we are not ReadOnly.
            //

            if (FlagOn(Flags, PIN_WAIT)) {

                BcbOut->PinCount += 1;
                KeReleaseInStackQueuedSpinLock( &LockHandle );
                SpinLockAcquired = FALSE;

                //
                //  Acquire Bcb Resource shared to ensure that it is in memory.
                //

                if (!ReadOnly) {
                    if (FlagOn(Flags, PIN_EXCLUSIVE)) {
                        (VOID)ExAcquireResourceExclusiveLite( &BcbOut->Resource, TRUE );
                    } else {
                        (VOID)ExAcquireSharedStarveExclusive( &BcbOut->Resource, TRUE );
                    }
                }
            }

            //
            //  Case 6 - Bcb is there and mapped, and Wait is FALSE
            //
            //  If we are not ReadOnly, we have to first see if we can
            //  acquire the Bcb shared before incrementing the PinCount,
            //  since we will have to return FALSE if we cannot acquire the
            //  resource.
            //

            else {

                //
                //  Acquire Bcb Resource shared to ensure that it is in memory.
                //

                if (!ReadOnly && !ExAcquireSharedStarveExclusive( &BcbOut->Resource, FALSE )) {

                    //
                    //  If we cannot get the resource and have not incremented PinCount, then
                    //  suppress the unpin on cleanup.
                    //

                    BcbOut = NULL;
                    try_return( Result = FALSE );
                }

                BcbOut->PinCount += 1;
                KeReleaseInStackQueuedSpinLock( &LockHandle );
                SpinLockAcquired = FALSE;
            }

            //
            //  Calculate Base Address of the data we want.
            //

            *BaseAddress = (PCHAR)BcbOut->BaseAddress +
                           (ULONG)( FileOffset->QuadPart - BcbOut->FileOffset.QuadPart );

            //
            //  Success!
            //

            try_return( Result = TRUE );
        }


    try_exit: NOTHING;

        if (FlagOn(Flags, PIN_NO_READ) &&
            FlagOn(Flags, PIN_EXCLUSIVE) &&
            (BcbOut != NULL) &&
            (BcbOut->BaseAddress != NULL)) {

            //
            //  Unmap the Vacb and free the resource if the Bcb is still
            //  dirty.  We have to free the resource before dropping the
            //  spinlock, and we want to hold the resource until the
            //  virtual address is freed.
            //

            CcFreeVirtualAddress( BcbOut->Vacb );

            BcbOut->BaseAddress = NULL;
            BcbOut->Vacb = NULL;
        }

    } finally {

        //
        //  Release the spinlock if it is acquired.
        //

        if (SpinLockAcquired) {
            KeReleaseInStackQueuedSpinLock( &LockHandle );
        }

        //
        //  If the Vacb was not used for any reason (error or not needed), then free it here.
        //

        if (Vacb != NULL) {
            CcFreeVirtualAddress( Vacb );
        }

        //
        //  If we referenced a piece of a multilevel structure, release here.
        //

        if (FlagOn(Flags, PIN_NO_READ)) {

            CcDereferenceFileOffset( SharedCacheMap, *FileOffset );
        }

        if (Result) {

            *Bcb = BcbOut;
            *BeyondLastByte = BcbOut->BeyondLastByte;

        //
        //  An abnormal termination can occur on an allocation failure,
        //  or on a failure to map and read the buffer.
        //

        } else {

            *BaseAddress = NULL;
            if (BcbOut != NULL) {
                CcUnpinFileData( BcbOut, ReadOnly, UNPIN );
            }
        }

        DebugTrace( 0, me, "    <Bcb = %08lx\n", *Bcb );
        DebugTrace( 0, me, "    <BaseAddress = %08lx\n", *BaseAddress );
        DebugTrace(-1, me, "CcPinFileData -> %02lx\n", Result );
    }

    return Result;
}


//
//  Internal Support Routine
//

VOID
FASTCALL
CcUnpinFileDataEx (
    IN OUT PBCB Bcb,
    IN BOOLEAN ReadOnly,
    IN UNMAP_ACTIONS UnmapAction
    )

/*++

Routine Description:

    This routine umaps and unlocks the specified buffer, which was previously
    locked and mapped by calling CcPinFileData.

Arguments:

    Bcb - Pointer previously returned from CcPinFileData.  As may be
          seen above, this pointer may be either a Bcb or a Vacb.

    ReadOnly - must specify same value as when data was mapped

    UnmapAction - UNPIN or SET_CLEAN

Return Value:

    None

--*/

{
    KLOCK_QUEUE_HANDLE LockHandle;
    PSHARED_CACHE_MAP SharedCacheMap;

    DebugTrace(+1, me, "CcUnpinFileData >Bcb = %08lx\n", Bcb );

    //
    //  Note, since we have to allocate so many Vacbs, we do not use
    //  a node type code.  However, the Vacb starts with a BaseAddress,
    //  so we assume that the low byte of the Bcb node type code has
    //  some bits set, which a page-aligned Base Address cannot.
    //

    ASSERT( (CACHE_NTC_BCB & 0xFF) != 0 );

    if (Bcb->NodeTypeCode != CACHE_NTC_BCB) {

        ASSERT(((PVACB)Bcb >= CcVacbs) && ((PVACB)Bcb < CcBeyondVacbs));
        ASSERT(((PVACB)Bcb)->SharedCacheMap->NodeTypeCode == CACHE_NTC_SHARED_CACHE_MAP);

        CcFreeVirtualAddress( (PVACB)Bcb );

        DebugTrace(-1, me, "CcUnpinFileData -> VOID (simple release)\n", 0 );

        return;
    }

    SharedCacheMap = Bcb->SharedCacheMap;

    //
    //  We treat Bcbs as ReadOnly (do not acquire resource) if they
    //  are in sections for which we have not disabled modified writing, or
    //  in this special case if this action is a dereferencing of the BCB.
    //

    if (!FlagOn(SharedCacheMap->Flags, MODIFIED_WRITE_DISABLED) ||
        UnmapAction == UNREF) {
        ReadOnly = TRUE;
    }

    //
    //  Synchronize
    //

    KeAcquireInStackQueuedSpinLock( &SharedCacheMap->BcbSpinLock, &LockHandle );

    switch (UnmapAction) {

    case UNPIN:
    case UNREF:

        ASSERT( Bcb->PinCount > 0 );

        Bcb->PinCount -= 1;

        break;

    case SET_CLEAN:

        if (Bcb->Dirty) {

            ULONG Pages = Bcb->ByteLength >> PAGE_SHIFT;

            //
            //  Reverse the rest of the actions taken when the Bcb was set dirty.
            //

            Bcb->Dirty = FALSE;

            //
            //  Clear any Lsn that was assigned to this Bcb.
            //

            Bcb->OldestLsn.QuadPart = 0;
            Bcb->NewestLsn.QuadPart = 0;

            CcAcquireMasterLockAtDpcLevel();
            CcDeductDirtyPages( SharedCacheMap, Pages );
            
            //
            //  Normally we need to reduce CcPagesYetToWrite appropriately.
            //

            if (CcPagesYetToWrite > Pages) {
                CcPagesYetToWrite -= Pages;
            } else {
                CcPagesYetToWrite = 0;
            }

            //
            //  Remove SharedCacheMap from dirty list if nothing more dirty,
            //  and someone still has the cache map opened.
            //

            if ((SharedCacheMap->DirtyPages == 0) &&
                (SharedCacheMap->OpenCount != 0)) {

                RemoveEntryList( &SharedCacheMap->SharedCacheMapLinks );
                CcInsertIntoCleanSharedCacheMapList( SharedCacheMap );
            }

            CcReleaseMasterLockFromDpcLevel();
        }

        break;

    default:
        CcBugCheck( UnmapAction, 0, 0 );
    }

    //
    //  If we brought it to 0, then we have to kill it.
    //

    if (Bcb->PinCount == 0) {

        //
        //  If the Bcb is Dirty, we only release the resource and unmap now.
        //

        if (Bcb->Dirty) {

            if (Bcb->BaseAddress != NULL) {

                //
                //  Unmap the Vacb and free the resource if the Bcb is still
                //  dirty.  We have to free the resource before dropping the
                //  spinlock, and we want to hold the resource until the
                //  virtual address is freed.
                //

                CcFreeVirtualAddress( Bcb->Vacb );

                Bcb->BaseAddress = NULL;
                Bcb->Vacb = NULL;
            }

            if (!ReadOnly) {
                ExReleaseResourceLite( &Bcb->Resource );
            }

            KeReleaseInStackQueuedSpinLock( &LockHandle );
        }

        //
        //  Otherwise, we also delete the Bcb.
        //

        else {

            //
            //  Since CcCalculateVacbLockCount has to be able to walk
            //  the BcbList with only the VacbSpinLock, we take that one
            //  out to change the list and decrement the level.
            //

            CcAcquireVacbLockAtDpcLevel();
            RemoveEntryList( &Bcb->BcbLinks );

            //
            //  For large metadata streams we unlock the Vacb level.
            //

            CcUnlockVacbLevel( SharedCacheMap, Bcb->FileOffset.QuadPart );
            CcReleaseVacbLockFromDpcLevel();

            if (Bcb->BaseAddress != NULL) {

                CcFreeVirtualAddress( Bcb->Vacb );
            }
#if DBG
            if (!ReadOnly) {
                ExReleaseResourceLite( &Bcb->Resource );
            }

            //
            //  ASSERT that the resource is unowned.
            //

            ASSERT( Bcb->Resource.ActiveCount == 0 );
#endif
            KeReleaseInStackQueuedSpinLock( &LockHandle );
            CcDeallocateBcb( Bcb );
        }
    }

    //
    //  Else we just have to release our Shared access, if we are not
    //  readonly.  We don't need to do this above, since we deallocate
    //  the entire Bcb there.
    //

    else {

        if (!ReadOnly) {
            ExReleaseResourceLite( &Bcb->Resource );
        }

        KeReleaseInStackQueuedSpinLock( &LockHandle );
    }

    DebugTrace(-1, me, "CcUnpinFileData -> VOID\n", 0 );

    return;
}


VOID
CcSetReadAheadGranularity (
    __in PFILE_OBJECT FileObject,
    __in ULONG Granularity
    )

/*++

Routine Description:

    This routine may be called to set the read ahead granularity used by
    the Cache Manager.  The default is PAGE_SIZE.  The number is decremented
    and stored as a mask.

Arguments:

    FileObject - File Object for which granularity shall be set

    Granularity - new granularity, which must be an even power of 2 and
                  >= PAGE_SIZE

Return Value:

    None
--*/

{
    ((PPRIVATE_CACHE_MAP)FileObject->PrivateCacheMap)->ReadAheadMask = Granularity - 1;
}


VOID
CcScheduleReadAhead (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length
    )

/*++

Routine Description:

    This routine is called by Copy Read and Mdl Read file system routines to
    perform common Read Ahead processing.  The input parameters describe
    the current read which has just been completed, or perhaps only started
    in the case of Mdl Reads.  Based on these parameters, an
    assessment is made on how much data should be read ahead, and whether
    that data has already been read ahead.

    The processing is divided into two parts:

        CALCULATE READ AHEAD REQUIREMENTS   (CcScheduleReadAhead)

        PERFORM READ AHEAD                  (CcPerformReadAhead)

    File systems should always call CcReadAhead, which will conditionally
    call CcScheduleReadAhead (if the read is large enough).  If such a call
    determines that there is read ahead work to do, and no read ahead is
    currently active, then it will set ReadAheadActive and schedule read
    ahead to be performed by the Lazy Writer, who will call CcPeformReadAhead.

Arguments:

    FileObject - supplies pointer to FileObject on which readahead should be
                 considered.

    FileOffset - supplies the FileOffset at which the last read just occurred.

    Length - supplies the length of the last read.

Return Value:

    None
--*/

{
    LARGE_INTEGER NewOffset;
    LARGE_INTEGER NewBeyond;
    LARGE_INTEGER FileOffset1, FileOffset2;
    KIRQL OldIrql;
    PSHARED_CACHE_MAP SharedCacheMap;
    PPRIVATE_CACHE_MAP PrivateCacheMap;
    PWORK_QUEUE_ENTRY WorkQueueEntry;
    ULONG ReadAheadSize;
    LOGICAL Changed = FALSE;

    DebugTrace(+1, me, "CcScheduleReadAhead:\n", 0 );
    DebugTrace2(0, me, "    FileOffset = %08lx, %08lx\n", FileOffset->LowPart,
                                                          FileOffset->HighPart );
    DebugTrace( 0, me, "    Length = %08lx\n", Length );

    SharedCacheMap = FileObject->SectionObjectPointer->SharedCacheMap;
    PrivateCacheMap = FileObject->PrivateCacheMap;

    if ((PrivateCacheMap == NULL) ||
        (SharedCacheMap == NULL) ||
        FlagOn(SharedCacheMap->Flags, DISABLE_READ_AHEAD)) {

        DebugTrace(-1, me, "CcScheduleReadAhead -> VOID (Nooped)\n", 0 );

        return;
    }

    //
    //  Round boundaries of transfer up to some greater granularity, so that
    //  sequential reads will be recognized even if a few bytes are skipped
    //  between records.
    //

    NewOffset = *FileOffset;
    NewBeyond.QuadPart = FileOffset->QuadPart + (LONGLONG)Length;

    //
    //  Find the next read ahead boundary beyond the current read.
    //

    ReadAheadSize = (Length + PrivateCacheMap->ReadAheadMask) & ~PrivateCacheMap->ReadAheadMask;
    FileOffset2.QuadPart = NewBeyond.QuadPart + (LONGLONG)ReadAheadSize;
    FileOffset2.LowPart &= ~PrivateCacheMap->ReadAheadMask;

    //
    //  CALCULATE READ AHEAD REQUIREMENTS
    //

    //
    //  Take out the ReadAhead spinlock to synchronize our read ahead decision.
    //

    ExAcquireSpinLock( &PrivateCacheMap->ReadAheadSpinLock, &OldIrql );

    //
    //  Read Ahead Case 0.
    //
    //  Sequential-only hint in the file object.  For this case we will
    //  try and always keep two read ahead granularities read ahead from
    //  and including the end of the current transfer.  This case has the
    //  lowest overhead, and the code is completely immune to how the
    //  caller skips around.  Sequential files use ReadAheadOffset[1] in
    //  the PrivateCacheMap as their "high water mark".
    //

    if (FlagOn(FileObject->Flags, FO_SEQUENTIAL_ONLY)) {

        //
        //  If the next boundary is greater than or equal to the high-water mark,
        //  then read ahead.
        //

        if (FileOffset2.QuadPart >= PrivateCacheMap->ReadAheadOffset[1].QuadPart) {

            //
            //  On the first read if we are using a large read ahead granularity,
            //  and the read did not get it all, we will just get the rest of the
            //  first data we want.
            //

            if ((FileOffset->QuadPart == 0)

                    &&

                (PrivateCacheMap->ReadAheadMask > (PAGE_SIZE - 1))

                    &&

                ((Length + PAGE_SIZE - 1) <= PrivateCacheMap->ReadAheadMask)) {

                FileOffset1.QuadPart = (LONGLONG)( ROUND_TO_PAGES(Length) );
                PrivateCacheMap->ReadAheadLength[0] = ReadAheadSize - FileOffset1.LowPart;
                FileOffset2.QuadPart = (LONGLONG)ReadAheadSize;

            //
            //  Calculate the next read ahead boundary.
            //

            } else {

                FileOffset1.QuadPart = PrivateCacheMap->ReadAheadOffset[1].QuadPart +
                                       (LONGLONG)ReadAheadSize;

                //
                //  If the end of the current read is actually beyond where we would
                //  normally do our read ahead, then we have fallen behind, and we must
                //  advance to that spot.
                //

                if (FileOffset2.QuadPart > FileOffset1.QuadPart) {
                    FileOffset1 = FileOffset2;
                }
                PrivateCacheMap->ReadAheadLength[0] = ReadAheadSize;
                FileOffset2.QuadPart = FileOffset1.QuadPart + (LONGLONG)ReadAheadSize;
            }

            //
            //  Now issue the next two read aheads.
            //

            PrivateCacheMap->ReadAheadOffset[0] = FileOffset1;

            PrivateCacheMap->ReadAheadOffset[1] = FileOffset2;
            PrivateCacheMap->ReadAheadLength[1] = ReadAheadSize;

            Changed = TRUE;
        }

    //
    //  Read Ahead Case 1.
    //
    //  If this is the third of three sequential reads, then we will see if
    //  we can read ahead.  Note that if the first read to a file is to
    //  offset 0, it passes this test.
    //

    } else if ((NewOffset.HighPart == PrivateCacheMap->BeyondLastByte2.HighPart)

            &&

        ((NewOffset.LowPart & ~NOISE_BITS)
           == (PrivateCacheMap->BeyondLastByte2.LowPart & ~NOISE_BITS))

            &&

        (PrivateCacheMap->FileOffset2.HighPart
           == PrivateCacheMap->BeyondLastByte1.HighPart)

            &&

        ((PrivateCacheMap->FileOffset2.LowPart & ~NOISE_BITS)
           == (PrivateCacheMap->BeyondLastByte1.LowPart & ~NOISE_BITS))) {

        //
        //  On the first read if we are using a large read ahead granularity,
        //  and the read did not get it all, we will just get the rest of the
        //  first data we want.
        //

        if ((FileOffset->QuadPart == 0)

                &&

            (PrivateCacheMap->ReadAheadMask > (PAGE_SIZE - 1))

                &&

            ((Length + PAGE_SIZE - 1) <= PrivateCacheMap->ReadAheadMask)) {

            FileOffset2.QuadPart = (LONGLONG)( ROUND_TO_PAGES(Length) );
        }

        //
        //  Round read offset to next read ahead boundary.
        //

        else {
            FileOffset2.QuadPart = NewBeyond.QuadPart + (LONGLONG)ReadAheadSize;

            FileOffset2.LowPart &= ~PrivateCacheMap->ReadAheadMask;
        }

        //
        //  Set read ahead length to be the same as for the most recent read,
        //  up to our max.
        //

        if (FileOffset2.QuadPart != PrivateCacheMap->ReadAheadOffset[1].QuadPart) {

            ASSERT( FileOffset2.HighPart >= 0 );

            Changed = TRUE;
            PrivateCacheMap->ReadAheadOffset[1] = FileOffset2;
            PrivateCacheMap->ReadAheadLength[1] = ReadAheadSize;
        }
    }

    //
    //  Read Ahead Case 2.
    //
    //  If this is the third read following a particular stride, then we
    //  will see if we can read ahead.  One example of an application that
    //  might do this is a spreadsheet.  Note that this code even works
    //  for negative strides.
    //

    else if ( ( NewOffset.QuadPart -
                PrivateCacheMap->FileOffset2.QuadPart ) ==
              ( PrivateCacheMap->FileOffset2.QuadPart -
                PrivateCacheMap->FileOffset1.QuadPart )) {

        //
        //  According to the current stride, the next offset will be:
        //
        //      NewOffset + (NewOffset - FileOffset2)
        //
        //  which is the same as:
        //
        //      (NewOffset * 2) - FileOffset2
        //

        FileOffset2.QuadPart = ( NewOffset.QuadPart << 1 ) - PrivateCacheMap->FileOffset2.QuadPart;

        //
        //  If our stride is going backwards through the file, we
        //  have to detect the case where the next step would wrap.
        //

        if (FileOffset2.HighPart >= 0) {

            //
            //  The read ahead length must be extended by the same amount that
            //  we will round the PrivateCacheMap->ReadAheadOffset down.
            //

            Length += FileOffset2.LowPart & (PAGE_SIZE - 1);

            //
            //  Now round the PrivateCacheMap->ReadAheadOffset down.
            //

            FileOffset2.LowPart &= ~(PAGE_SIZE - 1);
            PrivateCacheMap->ReadAheadOffset[1] = FileOffset2;

            //
            //  Round to page boundary.
            //

            PrivateCacheMap->ReadAheadLength[1] = (ULONG) ROUND_TO_PAGES(Length);
            Changed = TRUE;
        }
    }

    //
    //  Get out if the ReadAhead requirements did not change.
    //

    if (!Changed || PrivateCacheMap->Flags.ReadAheadActive) {

        DebugTrace( 0, me, "Read ahead already in progress or no change\n", 0 );

        ExReleaseSpinLock( &PrivateCacheMap->ReadAheadSpinLock, OldIrql );
        return;
    }

    //
    //  Otherwise, we will proceed and try to schedule the read ahead
    //  ourselves.
    //

    CC_SET_PRIVATE_CACHE_MAP (PrivateCacheMap, PRIVATE_CACHE_MAP_READ_AHEAD_ACTIVE);

    //
    //  Release spin lock on way out
    //

    ExReleaseSpinLock( &PrivateCacheMap->ReadAheadSpinLock, OldIrql );

    //
    //  Queue the read ahead request to the Lazy Writer's work queue.
    //

    DebugTrace( 0, me, "Queueing read ahead to worker thread\n", 0 );

    WorkQueueEntry = CcAllocateWorkQueueEntry();

    //
    //  If we failed to allocate a work queue entry, then, we will
    //  quietly bag it.  Read ahead is only an optimization, and
    //  no one ever requires that it occur.
    //

    if (WorkQueueEntry != NULL) {

        //
        //  We must reference this file object so that it cannot go away
        //  until we finish Read Ahead processing in the Worker Thread.
        //

        ObReferenceObject ( FileObject );

        //
        //  Increment open count to make sure the SharedCacheMap stays around.
        //

        CcAcquireMasterLock( &OldIrql );
        CcIncrementOpenCount( SharedCacheMap, 'adRQ' );
        SetFlag(SharedCacheMap->Flags, READ_AHEAD_QUEUED);
        CcReleaseMasterLock( OldIrql );

        WorkQueueEntry->Function = (UCHAR)ReadAhead;
        WorkQueueEntry->Parameters.Read.FileObject = FileObject;

        CcPostWorkQueue( WorkQueueEntry, &CcExpressWorkQueue );
    }

    //
    //  If we failed to allocate a Work Queue Entry, or all of the pages
    //  are resident we must set the active flag false.
    //

    else {

        ExAcquireFastLock( &PrivateCacheMap->ReadAheadSpinLock, &OldIrql );
        CC_CLEAR_PRIVATE_CACHE_MAP (PrivateCacheMap, PRIVATE_CACHE_MAP_READ_AHEAD_ACTIVE);
        ExReleaseFastLock( &PrivateCacheMap->ReadAheadSpinLock, OldIrql );
    }

    DebugTrace(-1, me, "CcScheduleReadAhead -> VOID\n", 0 );

    return;
}


VOID
FASTCALL
CcPerformReadAhead (
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine is called by the Lazy Writer to perform read ahead which
    has been scheduled for this file by CcScheduleReadAhead.

Arguments:

    FileObject - supplies pointer to FileObject on which readahead should be
                 considered.

Return Value:

    None
--*/

{
    KIRQL OldIrql;
    PSHARED_CACHE_MAP SharedCacheMap;
    PPRIVATE_CACHE_MAP PrivateCacheMap;
    ULONG i;
    LARGE_INTEGER ReadAheadOffset[2];
    ULONG ReadAheadLength[2];
    PCACHE_MANAGER_CALLBACKS Callbacks;
    PVOID Context;
    ULONG SavedState;
    LOGICAL Done;
    LOGICAL HitEof = FALSE;
    LOGICAL ReadAheadPerformed = FALSE;
    ULONG FaultOccurred = 0;
    PETHREAD Thread = PsGetCurrentThread();
    PVACB Vacb = NULL;

    LOGICAL ResourceHeld = FALSE;

    DebugTrace(+1, me, "CcPerformReadAhead:\n", 0 );
    DebugTrace( 0, me, "    FileObject = %08lx\n", FileObject );

    MmSavePageFaultReadAhead( Thread, &SavedState );

    try {

        //
        //  Since we have the open count biased, we can safely access the
        //  SharedCacheMap.
        //

        SharedCacheMap = FileObject->SectionObjectPointer->SharedCacheMap;

        Callbacks = SharedCacheMap->Callbacks;
        Context = SharedCacheMap->LazyWriteContext;

        //
        //  After the first time, keep looping as long as there are new
        //  read ahead requirements.  (We will skip out below.)
        //

        while (TRUE) {

            //
            //  Get SharedCacheMap and PrivateCacheMap.  If either are now NULL, get
            //  out.
            //

            CcAcquireMasterLock( &OldIrql );

            PrivateCacheMap = FileObject->PrivateCacheMap;

            //
            //  Now capture the information that we need, so that we can drop the
            //  SharedList Resource.  This information is advisory only anyway, and
            //  the caller must guarantee that the FileObject is referenced.
            //

            if (PrivateCacheMap != NULL) {

                ExAcquireSpinLockAtDpcLevel( &PrivateCacheMap->ReadAheadSpinLock );

                //
                //  We are done when the lengths are 0
                //

                Done = ((PrivateCacheMap->ReadAheadLength[0] |
                         PrivateCacheMap->ReadAheadLength[1]) == 0);

                ReadAheadOffset[0] = PrivateCacheMap->ReadAheadOffset[0];
                ReadAheadOffset[1] = PrivateCacheMap->ReadAheadOffset[1];
                ReadAheadLength[0] = PrivateCacheMap->ReadAheadLength[0];
                ReadAheadLength[1] = PrivateCacheMap->ReadAheadLength[1];
                PrivateCacheMap->ReadAheadLength[0] = 0;
                PrivateCacheMap->ReadAheadLength[1] = 0;

                ExReleaseSpinLockFromDpcLevel( &PrivateCacheMap->ReadAheadSpinLock );
            }

            CcReleaseMasterLock( OldIrql );

            //
            //  Acquire the file shared.
            //

            ResourceHeld = (*Callbacks->AcquireForReadAhead)( Context, TRUE );

            if ((PrivateCacheMap == NULL) || Done || !ResourceHeld) {

                try_return( NOTHING );
            }

            //
            //  PERFORM READ AHEAD
            //
            //
            //  Now loop until everything is read in.  The Read ahead is accomplished
            //  by touching the pages with an appropriate ReadAhead parameter in MM.
            //

            i = 0;

            do {

                LARGE_INTEGER Offset, SavedOffset;
                ULONG Length, SavedLength;

                Offset = ReadAheadOffset[i];
                Length = ReadAheadLength[i];
                SavedOffset = Offset;
                SavedLength = Length;

                if ((Length != 0)

                        &&

                    ( Offset.QuadPart <= SharedCacheMap->FileSize.QuadPart )) {

                    ReadAheadPerformed = TRUE;

                    //
                    //  Keep length within file and MAX_READ_AHEAD
                    //

                    if ( ( Offset.QuadPart + (LONGLONG)Length ) >= SharedCacheMap->FileSize.QuadPart ) {

                        Length = (ULONG)( SharedCacheMap->FileSize.QuadPart - Offset.QuadPart );
                        HitEof = TRUE;

                    }
                    if (Length > MAX_READ_AHEAD) {
                        Length = MAX_READ_AHEAD;
                    }

                    //
                    //  Now loop to read all of the desired data in.  This loop
                    //  is more or less like the same loop to read data in
                    //  CcCopyRead, except that we do not copy anything, just
                    //  unmap as soon as it is in.
                    //

                    while (Length != 0) {

                        ULONG ReceivedLength;
                        PVOID CacheBuffer;
                        ULONG PagesToGo;

                        //
                        //  Call local routine to Map or Access the file data.
                        //  If we cannot map the data because of a Wait condition,
                        //  return FALSE.
                        //
                        //  Since this routine is intended to be called from
                        //  the finally handler from file system read modules,
                        //  it is imperative that it not raise any exceptions.
                        //  Therefore, if any expected exception is raised, we
                        //  will simply get out.
                        //

                        CacheBuffer = CcGetVirtualAddress( SharedCacheMap,
                                                           Offset,
                                                           &Vacb,
                                                           &ReceivedLength );

                        //
                        //  If we got more than we need, make sure to only transfer
                        //  the right amount.
                        //

                        if (ReceivedLength > Length) {
                            ReceivedLength = Length;
                        }

                        //
                        //  Now loop to touch all of the pages, calling MM to ensure
                        //  that if we fault, we take in exactly the number of pages
                        //  we need.
                        //

                        PagesToGo = ADDRESS_AND_SIZE_TO_SPAN_PAGES( CacheBuffer,
                                                           ReceivedLength );

                        CcMissCounter = &CcReadAheadIos;

                        while (PagesToGo) {

                            MmSetPageFaultReadAhead( Thread, (PagesToGo - 1) );
                            FaultOccurred |= !MmCheckCachedPageState(CacheBuffer, FALSE);

                            CacheBuffer = (PCHAR)CacheBuffer + PAGE_SIZE;
                            PagesToGo -= 1;
                        }
                        CcMissCounter = &CcThrowAway;

                        //
                        //  Calculate how much data we have left to go.
                        //

                        Length -= ReceivedLength;

                        //
                        //  Assume we did not get all the data we wanted, and set
                        //  Offset to the end of the returned data.
                        //

                        Offset.QuadPart = Offset.QuadPart + (LONGLONG)ReceivedLength;

                        //
                        //  It was only a page, so we can just leave this loop
                        //  After freeing the address.
                        //

                        CcFreeVirtualAddress( Vacb );
                        Vacb = NULL;
                    }
                }
                i += 1;
            } while (i <= 1);

            //
            //  Release the file
            //

            (*Callbacks->ReleaseFromReadAhead)( Context );
            ResourceHeld = FALSE;
        }

    try_exit: NOTHING;
    }
    finally {

        MmResetPageFaultReadAhead(Thread, SavedState);
        CcMissCounter = &CcThrowAway;

        //
        //  If we got an error faulting a single page in, release the Vacb
        //  here.  It is important to free any mapping before dropping the
        //  resource to prevent purge problems.
        //

        if (Vacb != NULL) {
            CcFreeVirtualAddress( Vacb );
        }

        //
        //  Release the file
        //

        if (ResourceHeld) {
            (*Callbacks->ReleaseFromReadAhead)( Context );
        }

        //
        //  To show we are done, we must make sure the PrivateCacheMap is
        //  still there.
        //

        CcAcquireMasterLock( &OldIrql );

        PrivateCacheMap = FileObject->PrivateCacheMap;

        //
        //  Show readahead is going inactive.
        //

        if (PrivateCacheMap != NULL) {

            ExAcquireSpinLockAtDpcLevel( &PrivateCacheMap->ReadAheadSpinLock );
            CC_CLEAR_PRIVATE_CACHE_MAP (PrivateCacheMap, PRIVATE_CACHE_MAP_READ_AHEAD_ACTIVE);

            //
            //  If he said sequential only and we smashed into Eof, then
            //  let's reset the highwater mark in case he wants to read the
            //  file sequentially again.
            //

            if (HitEof && FlagOn(FileObject->Flags, FO_SEQUENTIAL_ONLY)) {
                PrivateCacheMap->ReadAheadOffset[1].LowPart =
                PrivateCacheMap->ReadAheadOffset[1].HighPart = 0;
            }

            //
            //  If no faults occurred, turn read ahead off.
            //

            if (ReadAheadPerformed && !FaultOccurred) {
                CC_CLEAR_PRIVATE_CACHE_MAP (PrivateCacheMap, PRIVATE_CACHE_MAP_READ_AHEAD_ENABLED);
            }

            ExReleaseSpinLockFromDpcLevel( &PrivateCacheMap->ReadAheadSpinLock );
        }

        //
        //  Free SharedCacheMap list
        //

        CcReleaseMasterLock( OldIrql );

        ObDereferenceObject( FileObject );

        //
        //  Serialize again to decrement the open count.
        //

        CcAcquireMasterLock( &OldIrql );

        CcDecrementOpenCount( SharedCacheMap, 'adRP' );

        ClearFlag(SharedCacheMap->Flags, READ_AHEAD_QUEUED);

        if ((SharedCacheMap->OpenCount == 0) &&
            !FlagOn(SharedCacheMap->Flags, WRITE_QUEUED) &&
            (SharedCacheMap->DirtyPages == 0)) {

            //
            //  Move to the dirty list.
            //

            RemoveEntryList( &SharedCacheMap->SharedCacheMapLinks );
            InsertTailList( &CcDirtySharedCacheMapList.SharedCacheMapLinks,
                            &SharedCacheMap->SharedCacheMapLinks );

            //
            //  Make sure the Lazy Writer will wake up, because we
            //  want him to delete this SharedCacheMap.
            //

            LazyWriter.OtherWork = TRUE;
            if (!LazyWriter.ScanActive) {
                CcScheduleLazyWriteScan( FALSE );
            }
        }

        CcReleaseMasterLock( OldIrql );
    }

    DebugTrace(-1, me, "CcPerformReadAhead -> VOID\n", 0 );

    return;
}


PBITMAP_RANGE
CcFindBitmapRangeToDirty (
    IN PMBCB Mbcb,
    IN LONGLONG Page,
    IN PULONG *FreePageForSetting
    )

/*++

Routine Description:

    This routine looks for the bitmap range containing the specified page.
    If it is found it is returned so the caller can set some dirty bits.
    If it is not found, then an attempt is made to come up with a free range
    and set it up to describe the desired range.  To come up with a free range,
    first we attempt to recycle the lowest range that does not currently contain
    any dirty pages.  If there is no such range, then we allocate one.

Arguments:

    Mbcb - Supplies the Mbcb in which to find the range.

    Page - Supplies the page number for the first page to be set dirty.

    FreePageForSetting - Supplies a free bitmap page of zeros from the zone; the
                         caller's pointer is cleared on return if this page is used.

Return Value:

    The desired bitmap range, or NULL if one could not be allocated.

Environment:

    The BcbSpinLock must be held on entry.

--*/

{
    PBITMAP_RANGE BitmapRange, FreeRange;
    PLIST_ENTRY InsertPoint;
    LONGLONG BasePage;

    //
    //  Initialize FreeRange and InsertPoint for the case we have
    //  to initialize a range.
    //

    FreeRange = NULL;
    InsertPoint = &Mbcb->BitmapRanges;

    //
    //  Point to the first bitmap range.
    //

    BitmapRange = (PBITMAP_RANGE)InsertPoint->Flink;

    //
    //  Calculate the desired BasePage from the caller's page.
    //

    BasePage = (Page & ~(LONGLONG)((MBCB_BITMAP_BLOCK_SIZE * 8) - 1));

    //
    //  Loop through the list until we find the range or we have a free range
    //  and correct insertion point.
    //

    do {

        //
        //  If we get an exact match, then we must have hit a fully-initialized
        //  range which we can return.
        //

        if (BasePage == BitmapRange->BasePage) {
            return BitmapRange;

        //
        //  Otherwise, see if the range is free and we have not captured a
        //  free range yet.
        //

        } else if ((BitmapRange->DirtyPages == 0) && (FreeRange == NULL)) {
            FreeRange = BitmapRange;

        //
        //  If we did not capture a free range, see if we need to update our
        //  insertion point.
        //

        } else if (BasePage > BitmapRange->BasePage) {
            InsertPoint = &BitmapRange->Links;
        }

        //
        //  Advance to the next range (or possibly back to the listhead).
        //

        BitmapRange = (PBITMAP_RANGE)BitmapRange->Links.Flink;

    //
    //  Loop until we hit the end, or we know we are done updating both InsertPoint
    //  and FreeRange.
    //

    } while ((BitmapRange != (PBITMAP_RANGE)&Mbcb->BitmapRanges) &&
             ((BasePage >= BitmapRange->BasePage) ||
              (FreeRange == NULL)));

    //
    //  If we found a FreeRange we can use, then remove it from the list.
    //

    if (FreeRange != NULL) {
        RemoveEntryList( &FreeRange->Links );

    //
    //  Otherwise we have to allocate the small bitmap range structure.  We usually
    //  try to avoid calling the pool package while owning a spin lock, but note the
    //  following things which must be true if we hit this point:
    //
    //      The file is larger than 3 bitmap ranges (normally 384MB on Intel).
    //      Three ranges plus all previously allocated ranges are simultaneously dirty.
    //
    //  The second point is fairly unlikely, especially for a sequential writer.  It
    //  can occur for a random writer in a large file, but eventually we will allocate
    //  enough ranges to always describe how many ranges he can keep dirty at once!
    //

    } else {
        FreeRange = ExAllocatePoolWithTag( NonPagedPool, sizeof(BITMAP_RANGE), 'rBcC' );
        if (FreeRange == NULL) {
            return NULL;
        }
        RtlZeroMemory( FreeRange, sizeof(BITMAP_RANGE) );
    }

    //
    //  Insert and initialize.
    //

    InsertHeadList( InsertPoint, &FreeRange->Links );
    FreeRange->BasePage = BasePage;
    FreeRange->FirstDirtyPage = MAXULONG;
    FreeRange->LastDirtyPage = 0;

    //
    //  If the range does not have a bitmap yet, then consume the one we were passed
    //  in.
    //

    if (FreeRange->Bitmap == NULL) {
        ASSERT(*FreePageForSetting != NULL);
        FreeRange->Bitmap = *FreePageForSetting;
        *FreePageForSetting = NULL;
    }

    return FreeRange;
}


PBITMAP_RANGE
CcFindBitmapRangeToClean (
    IN PMBCB Mbcb,
    IN LONGLONG Page
    )

/*++

Routine Description:

    This routine starts from the specified page, and looks for a range with dirty
    pages.  The caller must guarantee that some range exists with dirty pages.  If
    the end of the ranges is hit before finding any dirty ranges, then this routine
    loops back to the start of the range list.

Arguments:

    Mbcb - Supplies the Mbcb in which to find the range.

    Page - Supplies the page number for the first page to scan from.

Return Value:

    The desired bitmap range with dirty pages.

Environment:

    The BcbSpinLock must be held on entry.

--*/

{
    PBITMAP_RANGE BitmapRange;

    //
    //  Point to the first bitmap range.
    //

    BitmapRange = (PBITMAP_RANGE)Mbcb->BitmapRanges.Flink;

    //
    //  Loop through the list until we find the range to return.
    //

    do {

        //
        //  If we hit the listhead, then wrap to find the first dirty range.
        //

        if (BitmapRange == (PBITMAP_RANGE)&Mbcb->BitmapRanges) {

            //
            //  If Page is already 0, we are in an infinite loop.
            //

            ASSERT(Page != 0);

            //
            //  Clear Page and fall through to advance to first range.
            //

            Page = 0;


        //
        //  Otherwise, if we are in range, return the first range
        //  with dirty pages.
        //

        } else if ((Page <= (BitmapRange->BasePage + BitmapRange->LastDirtyPage)) &&
            (BitmapRange->DirtyPages != 0)) {
            return BitmapRange;
        }

        //
        //  Advance to the next range (or possibly back to the listhead).
        //

        BitmapRange = (PBITMAP_RANGE)BitmapRange->Links.Flink;

    } while (TRUE);
}


VOID
CcSetDirtyInMask (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine may be called to set a range of pages dirty in a user data
    file, by just setting the corresponding bits in the mask bcb.

    IMPORTANT NOTE:

        If this routine fails to set any bits due to an allocation failure,
        it just returns quietly without informing the caller.  (Note that this
        routine is never called for no modified write sections.)  The reason
        for this behavior is that this routine is sometimes called as part of
        error recovery (CcFreeActiveVacb, CcMdlWriteComplete, etc.) when it is
        essential to just keep on moving.  Note that if an allocation failure does
        occur, this only means that MM will have to flush the modified page in
        time, since the Lazy Writer will not do it.

Arguments:

    SharedCacheMap - SharedCacheMap where the pages are to be set dirty.

    FileOffset - FileOffset of first page to set dirty

    Length - Used in conjunction with FileOffset to determine how many pages
             to set dirty.

Return Value:

    None

--*/

{
    KLOCK_QUEUE_HANDLE LockHandle;
    PMBCB Mbcb;
    PBITMAP_RANGE BitmapRange;
    LONGLONG FirstPage;
    LONGLONG LastPage;
    PULONG MaskPtr;
    ULONG Mask = 0;
    PULONG Bitmap = NULL;

    //
    //  We assume no caller can cross a bitmap range boundary (currently not even
    //  a view boundary!), so we do not want to loop through bitmap ranges.
    //

    ASSERT((FileOffset->QuadPart / MBCB_BITMAP_RANGE) ==
           ((FileOffset->QuadPart + Length - 1) / MBCB_BITMAP_RANGE));

    //
    //  Initialize our locals.
    //

    FirstPage = FileOffset->QuadPart >> PAGE_SHIFT;
    LastPage = ((FileOffset->QuadPart + Length - 1) >> PAGE_SHIFT);

    //
    //  PREfix correctly notes that Mbcb grande promotion test and the one
    //  that decides to preallocate the bitmap buffer ever disagree, we will
    //  be able to have a NULL Bitmap and die.  This will not happen since we
    //  guarantee that section size >= filesize.  Assert this case, and we will
    //  also assert that Bitmap is never NULL when needed - this should convince
    //  PREfix we're OK.
    //

    ASSERT( (SharedCacheMap->SectionSize.QuadPart / PAGE_SIZE) > LastPage );

    //
    //  If we have to convert to an Mbcb grande, we will loop back here to
    //  preallocate another buffer.
    //

    do {

        //
        //  For large streams, we need to preallocate a block we use for
        //  we use for bitmaps.  We allocate one, then loop back in the rare
        //  case where we will need another.  We free it at the bottom if we
        //  don't need one.
        //

        if (SharedCacheMap->SectionSize.QuadPart > (MBCB_BITMAP_INITIAL_SIZE * 8 * PAGE_SIZE)) {

            //
            //  If we could not preallocate, break out into common cleanup code and
            //  return quietly.
            //

            if (!CcPrefillVacbLevelZone( 1, &LockHandle, FALSE, FALSE, NULL )) {
                return;
            }

            Bitmap = (PULONG)CcAllocateVacbLevel( FALSE );
            CcReleaseVacbLock( LockHandle.OldIrql );
        }

        //
        //  Acquire the Mbcb spinlock.
        //

        KeAcquireInStackQueuedSpinLock( &SharedCacheMap->BcbSpinLock, &LockHandle );

        //
        //  If there is no Mbcb, we will have to allocate one.
        //

        Mbcb = SharedCacheMap->Mbcb;
        if (Mbcb == NULL) {

            //
            //  Since we use the Bcb zone, we must assume that Bcbs are big enough.
            //

            ASSERT(QuadAlign(sizeof(MBCB)) <= QuadAlign(sizeof(BCB)));

            //
            //  Allocate the Mbcb from the Bcb zone.
            //

            Mbcb = (PMBCB)CcAllocateInitializeBcb( NULL, NULL, NULL, NULL );

            //
            //  If we could not allocate an Mbcb, break out to clean up and return
            //

            if (Mbcb == NULL) {
                break;
            }

            //
            //  Set in the node type, and initialize the listhead of ranges.
            //

            Mbcb->NodeTypeCode = CACHE_NTC_MBCB;
            InitializeListHead( &Mbcb->BitmapRanges );

            //
            //  Insert and initialize the first range.
            //

            InsertTailList( &Mbcb->BitmapRanges, &Mbcb->BitmapRange1.Links );
            Mbcb->BitmapRange1.FirstDirtyPage = MAXULONG;

            //
            //  Use the rest of the Mbcb as the initial bitmap.
            //

            Mbcb->BitmapRange1.Bitmap = (PULONG)&Mbcb->BitmapRange2;

            //
            //  Now set to use our new Mbcb.
            //

            SharedCacheMap->Mbcb = Mbcb;
        }

        //
        //  Now see if we need to switch to the Mbcb grande format.
        //

        if ((LastPage >= (MBCB_BITMAP_INITIAL_SIZE * 8)) &&
            (Mbcb->NodeTypeCode != CACHE_NTC_MBCB_GRANDE)) {

            ASSERT( Bitmap != NULL );

            //
            //  If there are any dirty pages, copy the initial bitmap over, and zero
            //  out the original end of the Mbcb for reuse.
            //

            if (Mbcb->BitmapRange1.DirtyPages != 0) {
                RtlCopyMemory( Bitmap, Mbcb->BitmapRange1.Bitmap, MBCB_BITMAP_INITIAL_SIZE );
                RtlZeroMemory( Mbcb->BitmapRange1.Bitmap, MBCB_BITMAP_INITIAL_SIZE );
            }

            //
            //  Store the new bitmap pointer and show we have consumed this one.
            //

            Mbcb->BitmapRange1.Bitmap = Bitmap;
            Bitmap = NULL;

            //
            //  Insert and initialize the first range.
            //

            InsertTailList( &Mbcb->BitmapRanges, &Mbcb->BitmapRange2.Links );
            Mbcb->BitmapRange2.BasePage = MAXLONGLONG;
            Mbcb->BitmapRange2.FirstDirtyPage = MAXULONG;
            InsertTailList( &Mbcb->BitmapRanges, &Mbcb->BitmapRange3.Links );
            Mbcb->BitmapRange3.BasePage = MAXLONGLONG;
            Mbcb->BitmapRange3.FirstDirtyPage = MAXULONG;
            Mbcb->NodeTypeCode = CACHE_NTC_MBCB_GRANDE;

            //
            //  This is a one-time event - converting to the large Mbcb.  Continue back
            //  to preallocate another buffer for CcFindBitmapRangeToDirty.
            //

            KeReleaseInStackQueuedSpinLock( &LockHandle );
            continue;
        }

        //
        //  Now find the Bitmap range we are setting bits in.
        //

        BitmapRange = CcFindBitmapRangeToDirty( Mbcb, FirstPage, &Bitmap );

        //
        //  If we could not allocate this dinky structure, break out quietly.
        //

        if (BitmapRange == NULL) {
            break;
        }

        //
        //  Now update the first and last dirty page indices and the bitmap.
        //

        if (FirstPage < (BitmapRange->BasePage + BitmapRange->FirstDirtyPage)) {
            BitmapRange->FirstDirtyPage = (ULONG)(FirstPage - BitmapRange->BasePage);
        }

        if (LastPage > (BitmapRange->BasePage + BitmapRange->LastDirtyPage)) {
            BitmapRange->LastDirtyPage = (ULONG)(LastPage - BitmapRange->BasePage);
        }

        //
        //  We have to acquire the shared cache map list, because we
        //  may be changing lists.
        //

        CcAcquireMasterLockAtDpcLevel();

        //
        //  If this is the first dirty page for this cache map, there is some work
        //  to do.
        //

        if (SharedCacheMap->DirtyPages == 0) {

            //
            //  If the lazy write scan is not active, then start it.
            //

            if (!LazyWriter.ScanActive) {
                CcScheduleLazyWriteScan( FALSE );
            }

            //
            //  Move to the dirty list.
            //

            RemoveEntryList( &SharedCacheMap->SharedCacheMapLinks );
            InsertTailList( &CcDirtySharedCacheMapList.SharedCacheMapLinks,
                            &SharedCacheMap->SharedCacheMapLinks );

            Mbcb->ResumeWritePage = FirstPage;
        }

        MaskPtr = &BitmapRange->Bitmap[(ULONG)(FirstPage - BitmapRange->BasePage) / 32];
        Mask = 1 << ((ULONG)FirstPage % 32);

        //
        //  Loop to set all of the bits and adjust the DirtyPage totals.
        //

        for ( ; FirstPage <= LastPage; FirstPage++) {

            if ((*MaskPtr & Mask) == 0) {
                CcChargeMaskDirtyPages( SharedCacheMap, Mbcb, BitmapRange, 1 );
                *MaskPtr |= Mask;
            }

            Mask <<= 1;

            if (Mask == 0) {

                MaskPtr += 1;
                Mask = 1;
            }
        }

        //
        //  See if we need to advance our goal for ValidDataLength.
        //

        LastPage = FileOffset->QuadPart + Length;

        if (LastPage > SharedCacheMap->ValidDataGoal.QuadPart) {
            SharedCacheMap->ValidDataGoal.QuadPart = (LONGLONG)LastPage;
        }

        CcReleaseMasterLockFromDpcLevel();

    //
    //  Continue until we have actually set the bits (there is a continue
    //  which just wants to loop back and allocate another buffer).
    //

    } while (Mask == 0);

    //
    //  Now if we preallocated a bitmap buffer, free it on the way out.
    //

    if (Bitmap != NULL) {
        CcAcquireVacbLockAtDpcLevel();
        CcDeallocateVacbLevel( (PVACB *)Bitmap, FALSE );
        CcReleaseVacbLockFromDpcLevel();
    }
    KeReleaseInStackQueuedSpinLock( &LockHandle );
}


VOID
CcSetDirtyPinnedData (
    __in PVOID BcbVoid,
    __in_opt PLARGE_INTEGER Lsn
    )

/*++

Routine Description:

    This routine may be called to set a Bcb (returned by CcPinFileData)
    dirty, and a candidate for the Lazy Writer.  All Bcbs should be set
    dirty by calling this routine, even if they are to be flushed
    another way.

Arguments:

    Bcb - Supplies a pointer to a pinned (by CcPinFileData) Bcb, to
          be set dirty.

    Lsn - Lsn to be remembered with page.

Return Value:

    None

--*/

{
    PBCB Bcbs[2];
    PBCB *BcbPtrPtr;
    KLOCK_QUEUE_HANDLE LockHandle;
    PSHARED_CACHE_MAP SharedCacheMap;

    DebugTrace(+1, me, "CcSetDirtyPinnedData: Bcb = %08lx\n", BcbVoid );

    //
    //  Assume this is a normal Bcb, and set up for loop below.
    //

    Bcbs[0] = (PBCB)BcbVoid;
    Bcbs[1] = NULL;
    BcbPtrPtr = &Bcbs[0];

    //
    //  If it is an overlap Bcb, then point into the Bcb vector
    //  for the loop.
    //

    if (Bcbs[0]->NodeTypeCode == CACHE_NTC_OBCB) {
        BcbPtrPtr = &((POBCB)Bcbs[0])->Bcbs[0];
    }

    //
    //  Loop to set all Bcbs dirty
    //

    while (*BcbPtrPtr != NULL) {

        Bcbs[0] = *(BcbPtrPtr++);

        //
        //  Should be no ReadOnly Bcbs
        //

        ASSERT(((ULONG_PTR)Bcbs[0] & 1) != 1);

        SharedCacheMap = Bcbs[0]->SharedCacheMap;

        //
        //  We have to acquire the shared cache map list, because we
        //  may be changing lists.
        //

        KeAcquireInStackQueuedSpinLock( &SharedCacheMap->BcbSpinLock, &LockHandle );

        if (!Bcbs[0]->Dirty) {

            ULONG Pages = Bcbs[0]->ByteLength >> PAGE_SHIFT;

            //
            //  Set dirty to keep the Bcb from going away until
            //  it is set Undirty, and assign the next modification time stamp.
            //

            Bcbs[0]->Dirty = TRUE;

            //
            //  Initialize the OldestLsn field.
            //

            if (ARGUMENT_PRESENT(Lsn)) {
                Bcbs[0]->OldestLsn = *Lsn;
                Bcbs[0]->NewestLsn = *Lsn;
            }

            //
            //  Move it to the dirty list if these are the first dirty pages,
            //  and this is not disabled for write behind.
            //
            //  Increase the count of dirty bytes in the shared cache map.
            //

            CcAcquireMasterLockAtDpcLevel();
            if ((SharedCacheMap->DirtyPages == 0) &&
                !FlagOn(SharedCacheMap->Flags, DISABLE_WRITE_BEHIND)) {

                //
                //  If the lazy write scan is not active, then start it.
                //

                if (!LazyWriter.ScanActive) {
                    CcScheduleLazyWriteScan( FALSE );
                }

                RemoveEntryList( &SharedCacheMap->SharedCacheMapLinks );
                InsertTailList( &CcDirtySharedCacheMapList.SharedCacheMapLinks,
                                &SharedCacheMap->SharedCacheMapLinks );
            }
            
            CcChargePinDirtyPages( SharedCacheMap, Pages );
            CcReleaseMasterLockFromDpcLevel();
        }

        //
        //  If this Lsn happens to be older/newer than the ones we have stored, then
        //  change it.
        //

        if (ARGUMENT_PRESENT(Lsn)) {

            if ((Bcbs[0]->OldestLsn.QuadPart == 0) || (Lsn->QuadPart < Bcbs[0]->OldestLsn.QuadPart)) {
                Bcbs[0]->OldestLsn = *Lsn;
            }

            if (Lsn->QuadPart > Bcbs[0]->NewestLsn.QuadPart) {
                Bcbs[0]->NewestLsn = *Lsn;
            }
        }

        //
        //  See if we need to advance our goal for ValidDataLength.
        //

        if ( Bcbs[0]->BeyondLastByte.QuadPart > SharedCacheMap->ValidDataGoal.QuadPart ) {

            SharedCacheMap->ValidDataGoal = Bcbs[0]->BeyondLastByte;
        }

        KeReleaseInStackQueuedSpinLock( &LockHandle );
    }

    DebugTrace(-1, me, "CcSetDirtyPinnedData -> VOID\n", 0 );
}


NTSTATUS
CcSetValidData (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER ValidDataLength
    )

/*++

Routine Description:

    This routine is used to call the File System to update ValidDataLength
    for a file.

Arguments:

    FileObject - A pointer to a referenced file object describing which file
        the read should be performed from.

    ValidDataLength - Pointer to new ValidDataLength.

Return Value:

    Status of operation.

--*/

{
    PIO_STACK_LOCATION IrpSp;
    PDEVICE_OBJECT DeviceObject;
    NTSTATUS Status;
    FILE_END_OF_FILE_INFORMATION Buffer;
    IO_STATUS_BLOCK IoStatus;
    KEVENT Event;
    PIRP Irp;

    DebugTrace(+1, me, "CcSetValidData:\n", 0 );
    DebugTrace( 0, me, "    FileObject = %08lx\n", FileObject );
    DebugTrace2(0, me, "    ValidDataLength = %08lx, %08lx\n",
                ValidDataLength->LowPart, ValidDataLength->HighPart );

    //
    //  Copy ValidDataLength to our buffer.
    //

    Buffer.EndOfFile = *ValidDataLength;

    //
    //  Initialize the event.
    //

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    //
    //  Begin by getting a pointer to the device object that the file resides
    //  on.
    //

    DeviceObject = IoGetRelatedDeviceObject( FileObject );

    //
    //  Allocate an I/O Request Packet (IRP) for this in-page operation.
    //

    Irp = IoAllocateIrp( DeviceObject->StackSize, FALSE );
    if (Irp == NULL) {

        DebugTrace(-1, me, "CcSetValidData-> STATUS_INSUFFICIENT_RESOURCES\n", 0 );

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Get a pointer to the first stack location in the packet.  This location
    //  will be used to pass the function codes and parameters to the first
    //  driver.
    //

    IrpSp = IoGetNextIrpStackLocation( Irp );

    //
    //  Fill in the IRP according to this request, setting the flags to
    //  just cause IO to set the event and deallocate the Irp.
    //

    Irp->Flags = IRP_PAGING_IO | IRP_SYNCHRONOUS_PAGING_IO;
    Irp->RequestorMode = KernelMode;
    Irp->UserIosb = &IoStatus;
    Irp->UserEvent = &Event;
    Irp->Tail.Overlay.OriginalFileObject = FileObject;
    Irp->Tail.Overlay.Thread = PsGetCurrentThread();
    Irp->AssociatedIrp.SystemBuffer = &Buffer;

    //
    //  Fill in the normal read parameters.
    //

    IrpSp->MajorFunction = IRP_MJ_SET_INFORMATION;
    IrpSp->FileObject = FileObject;
    IrpSp->DeviceObject = DeviceObject;
    IrpSp->Parameters.SetFile.Length = sizeof(FILE_END_OF_FILE_INFORMATION);
    IrpSp->Parameters.SetFile.FileInformationClass = FileEndOfFileInformation;
    IrpSp->Parameters.SetFile.FileObject = NULL;
    IrpSp->Parameters.SetFile.AdvanceOnly = TRUE;

    //
    //  Queue the packet to the appropriate driver based on whether or not there
    //  is a VPB associated with the device.  This routine should not raise.
    //

    Status = IoCallDriver( DeviceObject, Irp );

    //
    //  If pending is returned (which is a successful status),
    //  we must wait for the request to complete.
    //

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject( &Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               (PLARGE_INTEGER)NULL);
    }

    //
    //  If we got an error back in Status, then the Iosb
    //  was not written, so we will just copy the status
    //  there, then test the final status after that.
    //

    if (!NT_SUCCESS(Status)) {
        IoStatus.Status = Status;
    }

    DebugTrace(-1, me, "CcSetValidData-> %08lx\n", IoStatus.Status );

    return IoStatus.Status;
}


//
//  Internal Support Routine
//

BOOLEAN
CcAcquireByteRangeForWrite (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN PLARGE_INTEGER TargetOffset OPTIONAL,
    IN ULONG TargetLength,
    OUT PLARGE_INTEGER FileOffset,
    OUT PULONG Length,
    OUT PBCB *FirstBcb
    )

/*++

Routine Description:

    This routine is called by the Lazy Writer to try to find a contiguous
    range of bytes from the specified SharedCacheMap that are dirty and
    should be flushed.  After flushing, these bytes should be released
    by calling CcReleaseByteRangeFromWrite.

    Dirty ranges are returned in strictly increasing order.

Arguments:

    SharedCacheMap - for the file for which the dirty byte range is sought

    TargetOffset - If specified, then only the specified range is
                   to be flushed.

    TargetLength - If target offset specified, this completes the range.
                   In any case, this field is zero for the Lazy Writer,
                   and nonzero for explicit flush calls.

    FileOffset - Returns the offset for the beginning of the dirty byte
                 range to flush

    Length - Returns the length of bytes in the range.

    FirstBcb - Returns the first Bcb in the list for the range, to be used
               when calling CcReleaseByteRangeFromWrite, or NULL if dirty
               pages were found in the mask Bcb.

Return Value:

    FALSE - if no dirty byte range could be found to match the necessary
            criteria.

    TRUE - if a dirty byte range is being returned.

--*/

{
    KLOCK_QUEUE_HANDLE LockHandle;
    PMBCB Mbcb;
    PBCB Bcb;
    LARGE_INTEGER LsnToFlushTo = {0, 0};

    LOGICAL BcbLookasideCheck = FALSE;

    PBITMAP_RANGE BitmapRange;
    PULONG EndPtr;
    PULONG MaskPtr;
    ULONG Mask;
    LONGLONG FirstDirtyPage;
    ULONG OriginalFirstDirtyPage;
    LONGLONG LastDirtyPage = MAXLONGLONG;

    DebugTrace(+1, me, "CcAcquireByteRangeForWrite:\n", 0);
    DebugTrace( 0, me, "    SharedCacheMap = %08lx\n", SharedCacheMap);

    //
    //  Initially clear outputs.
    //

    FileOffset->QuadPart = 0;
    *Length = 0;

    //
    //  We must acquire the SharedCacheMap->BcbSpinLock.
    //

    KeAcquireInStackQueuedSpinLock( &SharedCacheMap->BcbSpinLock, &LockHandle );

    //
    //  See if there is a simple Mask Bcb, and if there is anything dirty in
    //  it.  If so we will simply handle that case here by processing the bitmap.
    //

    Mbcb = SharedCacheMap->Mbcb;

    if ((Mbcb != NULL) &&
        (Mbcb->DirtyPages != 0) &&
        ((Mbcb->PagesToWrite != 0) || (TargetLength != 0))) {

        //
        //  If a target range was specified (outside call to CcFlush for a range),
        //  then calculate FirstPage and EndPtr based on these inputs.
        //

        if (ARGUMENT_PRESENT(TargetOffset)) {

            FirstDirtyPage = TargetOffset->QuadPart >> PAGE_SHIFT;
            LastDirtyPage = (TargetOffset->QuadPart + TargetLength - 1) >> PAGE_SHIFT;

            //
            //  Find the bitmap range containing the first dirty page.
            //

            BitmapRange = CcFindBitmapRangeToClean( Mbcb, FirstDirtyPage );

            //
            //  If the target range is not dirty, get out.  We may have even
            //  gotten back a nonoverlapping bitmap range.
            //

            if ((LastDirtyPage < (BitmapRange->BasePage + BitmapRange->FirstDirtyPage)) ||
                (FirstDirtyPage > (BitmapRange->BasePage + BitmapRange->LastDirtyPage))) {

                goto Scan_Bcbs;
            }

            if (LastDirtyPage < (BitmapRange->BasePage + BitmapRange->LastDirtyPage)) {
                EndPtr = &BitmapRange->Bitmap[(ULONG)(LastDirtyPage - BitmapRange->BasePage) / 32];
            } else {
                EndPtr = &BitmapRange->Bitmap[BitmapRange->LastDirtyPage / 32];
            }


        //
        //  Otherwise, for the Lazy Writer pick up where we left off.
        //

        } else {

            //
            //  If a length was specified, then it is an explicit flush, and
            //  we want to start with the first dirty page, else the Lazy Writer
            //  starts from the ResumeWritePage.
            //

            FirstDirtyPage = 0;
            if (TargetLength == 0) {
                FirstDirtyPage = Mbcb->ResumeWritePage;
            }

            //
            //  Now find the next (cyclic) dirty page from this point.
            //

            BitmapRange = CcFindBitmapRangeToClean( Mbcb, FirstDirtyPage );

            //
            //  If the page we thought we were looking for is beyond the last dirty page
            //  of this range, then CcFindBitmapRangeToClean must have wrapped back to
            //  the start of the file, and we should resume on the first dirty page of
            //  this range.
            //

            if (FirstDirtyPage > (BitmapRange->BasePage + BitmapRange->LastDirtyPage)) {
                FirstDirtyPage = BitmapRange->BasePage + BitmapRange->FirstDirtyPage;
            }

            EndPtr = &BitmapRange->Bitmap[BitmapRange->LastDirtyPage / 32];
        }

        //
        //  Now we can skip over any clean pages.
        //

        if (FirstDirtyPage < (BitmapRange->BasePage + BitmapRange->FirstDirtyPage)) {
            FirstDirtyPage = BitmapRange->BasePage + BitmapRange->FirstDirtyPage;
        }

        //
        //  Form a few other inputs for our dirty page scan.
        //

        MaskPtr = &BitmapRange->Bitmap[(ULONG)(FirstDirtyPage - BitmapRange->BasePage) / 32];
        Mask = (ULONG)(-1 << (FirstDirtyPage % 32));
        OriginalFirstDirtyPage = (ULONG)(FirstDirtyPage - BitmapRange->BasePage);

        //
        //  Because of the possibility of getting stuck on a "hot spot" which gets
        //  modified over and over, we want to be very careful to resume exactly
        //  at the recorded resume point.  If there is nothing there, then we
        //  fall into the loop below to scan for nozero long words in the bitmap,
        //  starting at the next longword.
        //

        if ((*MaskPtr & Mask) == 0) {

            //
            //  Before entering loop, set all mask bits and ensure we increment from
            //  an even Ulong boundary.
            //

            Mask = MAXULONG;
            FirstDirtyPage &= ~31;

            //
            //  To scan the bitmap faster, we scan for entire long words which are
            //  nonzero.
            //

            do {

                MaskPtr += 1;
                FirstDirtyPage += 32;

                //
                //  If we go beyond the end, then we must wrap back to the first
                //  dirty page.  We will just go back to the start of the first
                //  longword.
                //

                if (MaskPtr > EndPtr) {

                    //
                    //  We can backup the last dirty page hint to where we
                    //  started scanning, if we are the lazy writer.
                    //

                    if (TargetLength == 0) {
                        ASSERT(OriginalFirstDirtyPage >= BitmapRange->FirstDirtyPage);
                        BitmapRange->LastDirtyPage = OriginalFirstDirtyPage - 1;
                    }

                    //
                    //  We hit the end of our scan.  Let's assume we are supposed
                    //  to move on to the next range with dirty pages.
                    //

                    do {

                        //
                        //  Go to the next range.
                        //

                        BitmapRange = (PBITMAP_RANGE)BitmapRange->Links.Flink;

                        //
                        //  Did we hit the listhead?
                        //

                        if (BitmapRange == (PBITMAP_RANGE)&Mbcb->BitmapRanges) {

                            //
                            //  If this is an explicit flush, then it is time to
                            //  get out.
                            //

                            if (TargetLength != 0) {
                                goto Scan_Bcbs;
                            }

                            //
                            //  Otherwise, we must wrap back to the first range in the
                            //  Lazy Writer Scan.
                            //

                            BitmapRange = (PBITMAP_RANGE)BitmapRange->Links.Flink;
                        }

                    } while (BitmapRange->DirtyPages == 0);

                    //
                    //  Now we have a new range with dirty pages, but if this is
                    //  an explicit flush of a specified range, we may be done.
                    //

                    if ((LastDirtyPage < (BitmapRange->BasePage + BitmapRange->FirstDirtyPage)) ||
                        (FirstDirtyPage > (BitmapRange->BasePage + BitmapRange->LastDirtyPage))) {

                        goto Scan_Bcbs;
                    }

                    //
                    //  Otherwise, we need to set up our context to resume scanning in this
                    //  range.
                    //

                    MaskPtr = &BitmapRange->Bitmap[BitmapRange->FirstDirtyPage / 32];
                    EndPtr = &BitmapRange->Bitmap[BitmapRange->LastDirtyPage / 32];
                    FirstDirtyPage = BitmapRange->BasePage + (BitmapRange->FirstDirtyPage & ~31);
                    OriginalFirstDirtyPage = BitmapRange->FirstDirtyPage;
                }
            } while (*MaskPtr == 0);
        }

        //
        //  Calculate the first set bit in the mask that we hit on.
        //

        Mask = ~Mask + 1;

        //
        //  Now loop to find the first set bit.
        //

        while ((*MaskPtr & Mask) == 0) {

            Mask <<= 1;
            FirstDirtyPage += 1;
        }

        //
        //  If a TargetOffset was specified, then make sure we do not start
        //  beyond the specified range or a dirty Bcb in the range.
        //

        if (ARGUMENT_PRESENT(TargetOffset)) {

            if (FirstDirtyPage >= ((TargetOffset->QuadPart + TargetLength + PAGE_SIZE - 1) >> PAGE_SHIFT)) {

                goto Scan_Bcbs;
            }

            //
            //  If Bcbs are present on this file, we must go scan to see if they
            //  describe a range that must be written first.  If this is not the
            //  case, we'll hop back and continue building the range from the mask Bcb.
            //
            //  Note that this case will be very rare.  Bcbs are introduced into user
            //  files in limited situations (CcZero) and the reverse is never allowed
            //  to happen.
            //

            if (!IsListEmpty(&SharedCacheMap->BcbList)) {

                BcbLookasideCheck = TRUE;
                goto Scan_Bcbs;
            }
        }

Accept_Page:

        //
        //  Now loop to count the set bits at that point, clearing them as we
        //  go because we plan to write the corresponding pages.  Stop as soon
        //  as we find a clean page, or we reach our maximum write size.  Of
        //  course we want to ignore long word boundaries and keep trying to
        //  extend the write.  We do not check for wrapping around the end of
        //  the bitmap here, because we guarantee some zero bits at the end
        //  in CcSetDirtyInMask.
        //

        while (((*MaskPtr & Mask) != 0) && (*Length < (MAX_WRITE_BEHIND / PAGE_SIZE)) &&
               (!ARGUMENT_PRESENT(TargetOffset) || ((FirstDirtyPage + *Length) <
                                                    (ULONG)((TargetOffset->QuadPart + TargetLength + PAGE_SIZE - 1) >> PAGE_SHIFT)))) {

            ASSERT(MaskPtr <= (&BitmapRange->Bitmap[BitmapRange->LastDirtyPage / 32]));

            *MaskPtr -= Mask;
            *Length += 1;
            Mask <<= 1;

            if (Mask == 0) {

                MaskPtr += 1;
                Mask = 1;

                if (MaskPtr > EndPtr) {
                    break;
                }
            }
        }

        //
        //  Now reduce the count of pages we were supposed to write this time,
        //  possibly clearing this count.
        //

        if (*Length < Mbcb->PagesToWrite) {

            Mbcb->PagesToWrite -= *Length;

        } else {

            Mbcb->PagesToWrite = 0;
        }

        //
        //  Reduce the dirty page counts by the number of pages we just cleared.
        //

        ASSERT(Mbcb->DirtyPages >= *Length);
        Mbcb->DirtyPages -= *Length;
        BitmapRange->DirtyPages -= *Length;

        CcAcquireMasterLockAtDpcLevel();
        CcDeductDirtyPages( SharedCacheMap, *Length );

        //
        //  Normally we need to reduce CcPagesYetToWrite appropriately.
        //

        if (CcPagesYetToWrite > *Length) {
            CcPagesYetToWrite -= *Length;
        } else {
            CcPagesYetToWrite = 0;
        }

        //
        //  If we took out the last dirty page, then move the SharedCacheMap
        //  back to the clean list.
        //

        if (SharedCacheMap->DirtyPages == 0) {

            RemoveEntryList( &SharedCacheMap->SharedCacheMapLinks );
            CcInsertIntoCleanSharedCacheMapList( SharedCacheMap );
        }
        CcReleaseMasterLockFromDpcLevel();

        //
        //  If the number of dirty pages for the Mbcb went to zero, we can reset
        //  our hint fields now.
        //

        if (BitmapRange->DirtyPages == 0) {

            BitmapRange->FirstDirtyPage = MAXULONG;
            BitmapRange->LastDirtyPage = 0;

            //
            //  Assume this is a large file and that the resume point should
            //  be at the beginning of the next range.  In all cases if the resume
            //  point is set too high, the next resume will just wrap back to 0 anyway.
            //

            Mbcb->ResumeWritePage = BitmapRange->BasePage + (MBCB_BITMAP_BLOCK_SIZE * 8);

        //
        //  Otherwise we have to update the hint fields.
        //

        } else {

            //
            //  Advance the first dirty page hint if we can.
            //

            if (BitmapRange->FirstDirtyPage == OriginalFirstDirtyPage) {

                BitmapRange->FirstDirtyPage = (ULONG)(FirstDirtyPage - BitmapRange->BasePage) + *Length;
            }

            //
            //  Set to resume the next scan at the next bit for
            //  the Lazy Writer.
            //

            if (TargetLength == 0) {

                Mbcb->ResumeWritePage = FirstDirtyPage + *Length;
            }
        }

        //
        //  We can save a callback by letting our caller know when
        //  we have no more pages to write.
        //

        if (IsListEmpty(&SharedCacheMap->BcbList)) {
            SharedCacheMap->PagesToWrite = Mbcb->PagesToWrite;
        }

        KeReleaseInStackQueuedSpinLock( &LockHandle );

        //
        //  Now form all of our outputs.  We calculated *Length as a page count,
        //  but our caller wants it in bytes.
        //

        *Length <<= PAGE_SHIFT;
        FileOffset->QuadPart = (LONGLONG)FirstDirtyPage << PAGE_SHIFT;
        *FirstBcb = NULL;

        DebugTrace2(0, me, "    <FileOffset = %08lx, %08lx\n", FileOffset->LowPart,
                                                               FileOffset->HighPart );
        DebugTrace( 0, me, "    <Length = %08lx\n", *Length );
        DebugTrace(-1, me, "CcAcquireByteRangeForWrite -> TRUE\n", 0 );

        return TRUE;
    }

    //
    //  We get here if there is no Mbcb or no dirty pages in it.  Note that we
    //  wouldn't even be here if there were no dirty pages in this SharedCacheMap.
    //

    //
    //  Now point to last Bcb in List, and loop until we hit one of the
    //  breaks below or the beginning of the list.
    //

Scan_Bcbs:

    //
    //  Use while TRUE to handle case where the current target range wraps
    //  (escape is at the bottom).
    //

    while (TRUE) {

        Bcb = CONTAINING_RECORD( SharedCacheMap->BcbList.Blink, BCB, BcbLinks );

        //
        //  If we are to resume from a nonzero FileOffset, call CcFindBcb
        //  to get a quicker start.  This is only useful on files that make
        //  use of significant pinned access, of course.
        //

        if (FlagOn(SharedCacheMap->Flags, MODIFIED_WRITE_DISABLED)) {

            PLARGE_INTEGER StartingOffset;

            if (ARGUMENT_PRESENT(TargetOffset)) {
                StartingOffset = TargetOffset;
            } else {
                StartingOffset = (PLARGE_INTEGER)&SharedCacheMap->BeyondLastFlush;
            }

            if (StartingOffset->QuadPart != 0) {

                LARGE_INTEGER StartingOffsetBias;

                StartingOffsetBias.QuadPart = StartingOffset->QuadPart + PAGE_SIZE;

                //
                //  Position ourselves.  If we did not find a Bcb for the page, then
                //  a lower FileOffset was returned, so we want to move forward one.
                //

                if (!CcFindBcb( SharedCacheMap,
                                StartingOffset,
                                &StartingOffsetBias,
                                &Bcb )) {
                    Bcb = CONTAINING_RECORD( Bcb->BcbLinks.Blink, BCB, BcbLinks );
                }
            }
        }

        while (&Bcb->BcbLinks != &SharedCacheMap->BcbList) {

            //
            //  Skip over this item if it is a listhead.
            //

            if (Bcb->NodeTypeCode != CACHE_NTC_BCB) {

                Bcb = CONTAINING_RECORD( Bcb->BcbLinks.Blink, BCB, BcbLinks );
                continue;
            }

            //
            //  If we are doing a specified range, then get out if we hit a
            //  higher Bcb.
            //

            if (ARGUMENT_PRESENT(TargetOffset) &&
                ((TargetOffset->QuadPart + TargetLength) <= Bcb->FileOffset.QuadPart)) {

                break;
            }

            //
            //  If we have not started a run, then see if this Bcb is a candidate
            //  to start one.
            //

            if (*Length == 0) {

                //
                //  Else see if the Bcb is dirty, and is in our specified range, if
                //  there is one.
                //

                if (!Bcb->Dirty ||
                    (ARGUMENT_PRESENT(TargetOffset) && (TargetOffset->QuadPart >= Bcb->BeyondLastByte.QuadPart)) ||
                    (!ARGUMENT_PRESENT(TargetOffset) && (Bcb->FileOffset.QuadPart < SharedCacheMap->BeyondLastFlush))) {

                    Bcb = CONTAINING_RECORD( Bcb->BcbLinks.Blink, BCB, BcbLinks );
                    continue;

                }

                //
                //  If we have a candidate dirty page from the mask Bcb, see
                //  if it describes a prior range.  We must decide to return
                //  the first dirty range.
                //

                if (BcbLookasideCheck && FirstDirtyPage <= (ULONG)(Bcb->FileOffset.QuadPart >> PAGE_SHIFT)) {
                    goto Accept_Page;
                }
            }

            //
            //  Else, if we have started a run, then if this guy cannot be
            //  appended to the run, then break.  Note that we ignore the
            //  Bcb's modification time stamp here to simplify the test.
            //
            //  If the Bcb is currently pinned, then there is no sense in causing
            //  contention, so we will skip over this guy as well.
            //
            //  Finally, if the new Bcb is in the next Vacb level, we will skip it
            //  to avoid problems with Bcb listheads going away in the middle of
            //  CcReleaseByteRangeFromWrite.
            //

            else {
                if (!Bcb->Dirty || ( Bcb->FileOffset.QuadPart != ( FileOffset->QuadPart + (LONGLONG)*Length)) ||
                    (*Length + Bcb->ByteLength > MAX_WRITE_BEHIND) ||
                    (Bcb->PinCount != 0) ||
                    ((Bcb->FileOffset.QuadPart & (VACB_SIZE_OF_FIRST_LEVEL - 1)) == 0)) {

                    break;
                }
            }

            //
            //  Increment PinCount to prevent Bcb from going away once the
            //  SpinLock is released, or we set it clean for the case where
            //  modified write is allowed.
            //

            Bcb->PinCount += 1;

            //
            //  Release the SpinLock before waiting on the resource.
            //

            KeReleaseInStackQueuedSpinLock( &LockHandle );

            if (FlagOn(SharedCacheMap->Flags, MODIFIED_WRITE_DISABLED) &&
                !FlagOn(SharedCacheMap->Flags, DISABLE_WRITE_BEHIND)) {

                //
                //  Now acquire the Bcb exclusive, so that we know that nobody
                //  has it pinned and thus no one can be modifying the described
                //  buffer.  To acquire the first Bcb in a run, we can afford
                //  to wait, because we are not holding any resources.  However
                //  if we already have a Bcb, then we better not wait, because
                //  someone could have this Bcb pinned, and then wait for the
                //  Bcb we already have exclusive.
                //
                //  For streams for which we have not disabled modified page
                //  writing, we do not need to acquire this resource, and the
                //  foreground processing will not be acquiring the Bcb either.
                //

                if (!ExAcquireResourceExclusiveLite( &Bcb->Resource,
                                                 (BOOLEAN)(*Length == 0) )) {

                    DebugTrace( 0, me, "Could not acquire 2nd Bcb\n", 0 );

                    //
                    //  Release the Bcb count we took out above.  We say
                    //  ReadOnly = TRUE since we do not own the resource,
                    //  and SetClean = FALSE because we just want to decement
                    //  the count.
                    //

                    CcUnpinFileData( Bcb, TRUE, UNPIN );

                    //
                    //  When we leave the loop, we have to have the spin lock
                    //

                    KeAcquireInStackQueuedSpinLock( &SharedCacheMap->BcbSpinLock, &LockHandle );
                    break;
                }

                KeAcquireInStackQueuedSpinLock( &SharedCacheMap->BcbSpinLock, &LockHandle );

                //
                //  If someone has the file open WriteThrough, then the Bcb may no
                //  longer be dirty.  If so, call CcUnpinFileData to decrement the
                //  PinCount we incremented and free the resource.
                //

                if (!Bcb->Dirty) {

                    //
                    //  Release the spinlock so that we can call CcUnpinFileData
                    //

                    KeReleaseInStackQueuedSpinLock( &LockHandle );

                    CcUnpinFileData( Bcb, FALSE, UNPIN );

                    KeAcquireInStackQueuedSpinLock( &SharedCacheMap->BcbSpinLock, &LockHandle );

                    //
                    //  Now if we already have some data we can just break to return
                    //  it, otherwise we have to restart the scan, since our Bcb
                    //  may have gone away.
                    //

                    if (*Length != 0) {
                        break;
                    }
                    else {

                        Bcb = CONTAINING_RECORD( SharedCacheMap->BcbList.Blink, BCB, BcbLinks );
                        continue;
                    }
                }

            //
            //  If we are not in the disable modified write mode (normal user data)
            //  then we must set the buffer clean before doing the write, since we
            //  are unsynchronized with anyone producing dirty data.  That way if we,
            //  for example, are writing data out while it is actively being changed,
            //  at least the changer will mark the buffer dirty afterwards and cause
            //  us to write it again later.
            //

            } else {

                CcUnpinFileData( Bcb, TRUE, SET_CLEAN );

               KeAcquireInStackQueuedSpinLock( &SharedCacheMap->BcbSpinLock, &LockHandle );
            }

            DebugTrace( 0, me, "Adding Bcb = %08lx to run\n", Bcb );

            //
            //  No matter what, once we've reached this point we are returning
            //  a range from the Bcbs.
            //

            BcbLookasideCheck = FALSE;

            //
            //  Update all of our return values.  Note that FirstBcb refers to the
            //  FirstBcb in terms of how the Bcb list is ordered.  Since the Bcb list
            //  is ordered by descending file offsets, FirstBcb will actually return
            //  the Bcb with the highest FileOffset.
            //

            if (*Length == 0) {
                *FileOffset = Bcb->FileOffset;
            }

            *FirstBcb = Bcb;
            *Length += Bcb->ByteLength;

            //
            //  If there is a log file flush callback for this stream, then we must
            //  remember the largest Lsn we are about to flush.
            //

            if ((SharedCacheMap->FlushToLsnRoutine != NULL) &&
                (Bcb->NewestLsn.QuadPart > LsnToFlushTo.QuadPart)) {

                LsnToFlushTo = Bcb->NewestLsn;
            }

            Bcb = CONTAINING_RECORD( Bcb->BcbLinks.Blink, BCB, BcbLinks );
        }

        //
        //  If we have a candidate dirty page from the mask Bcb, accept it
        //  since no Bcb has been found.
        //

        if (BcbLookasideCheck) {

            ASSERT( *Length == 0 );
            goto Accept_Page;
        }

        //
        //  If we found something, update our last flush range and reduce
        //  PagesToWrite.
        //

        if (*Length != 0) {

            //
            //  If this is the Lazy Writer, then update BeyondLastFlush and
            //  the PagesToWrite target.
            //

            if (!ARGUMENT_PRESENT(TargetOffset)) {

                SharedCacheMap->BeyondLastFlush = FileOffset->QuadPart + *Length;

                if (SharedCacheMap->PagesToWrite > (*Length >> PAGE_SHIFT)) {
                    SharedCacheMap->PagesToWrite -= (*Length >> PAGE_SHIFT);
                } else {
                    SharedCacheMap->PagesToWrite = 0;
                }
            }

            break;

        //
        //  Else, if we scanned the entire file, get out - nothing to write now.
        //

        } else if ((SharedCacheMap->BeyondLastFlush == 0) || ARGUMENT_PRESENT(TargetOffset)) {
            break;
        }

        //
        //  Otherwise, we may have not found anything because there is nothing
        //  beyond the last flush.  In that case it is time to wrap back to 0
        //  and keep scanning.
        //

        SharedCacheMap->BeyondLastFlush = 0;
    }

    //
    //  Now release the spinlock file while we go off and do the I/O
    //

    KeReleaseInStackQueuedSpinLock( &LockHandle );

    //
    //  If we need to flush to some Lsn, this is the time to do it now
    //  that we have found the largest Lsn and freed the spin lock.
    //

    if (LsnToFlushTo.QuadPart != 0) {

        try {

            (*SharedCacheMap->FlushToLsnRoutine) ( SharedCacheMap->LogHandle,
                                                   LsnToFlushTo );
        } except( CcExceptionFilter( GetExceptionCode() )) {

            //
            //  If there was an error, it will be raised.  We cannot
            //  write anything until we successfully flush the log
            //  file, so we will release everything here and just
            //  return with 0 bytes.
            //

            LARGE_INTEGER LastOffset;
            PBCB NextBcb;

            //
            //  Now loop to free up all of the Bcbs.  Set the time
            //  stamps to 0, so that we are guaranteed to try to
            //  flush them again on the next sweep.
            //

            do {
                NextBcb = CONTAINING_RECORD( (*FirstBcb)->BcbLinks.Flink, BCB, BcbLinks );

                //
                //  Skip over any listheads.
                //

                if ((*FirstBcb)->NodeTypeCode == CACHE_NTC_BCB) {

                    LastOffset = (*FirstBcb)->FileOffset;

                    CcUnpinFileData( *FirstBcb,
                                     BooleanFlagOn(SharedCacheMap->Flags, DISABLE_WRITE_BEHIND),
                                     UNPIN );
                }

                *FirstBcb = NextBcb;
            } while (FileOffset->QuadPart != LastOffset.QuadPart);

            //
            //  Show we did not acquire anything.
            //

            *Length = 0;
        }
    }

    //
    //  If we got anything, return TRUE.
    //

    DebugTrace2(0, me, "    <FileOffset = %08lx, %08lx\n", FileOffset->LowPart,
                                                           FileOffset->HighPart );
    DebugTrace( 0, me, "    <Length = %08lx\n", *Length );
    DebugTrace(-1, me, "CcAcquireByteRangeForWrite -> %02lx\n", *Length != 0 );

    return ((BOOLEAN)(*Length != 0));
}


//
//  Internal Support Routine
//

VOID
CcReleaseByteRangeFromWrite (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN PBCB FirstBcb,
    IN BOOLEAN VerifyRequired
    )

/*++

Routine Description:

    This routine is called by the Lazy Writer to free a range of bytes and
    clear all dirty bits, for a byte range returned by CcAcquireByteRangeForWrite.

Arguments:

    SharedCacheMap - As supplied to CcAcquireByteRangeForWrite

    FileOffset - As returned from CcAcquireByteRangeForWrite

    Length - As returned from CcAcquirebyteRangeForWrite

    FirstBcb - As returned from CcAcquireByteRangeForWrite

    VerifyRequired - supplied as TRUE if a verify required error was received.
                     In this case we must mark/leave the data dirty so that
                     we will try to write it again.

Return Value:

    None

--*/

{
    LARGE_INTEGER LastOffset;
    PBCB NextBcb;

    DebugTrace(+1, me, "CcReleaseByteRangeFromWrite:\n", 0);
    DebugTrace2(0, me, "    FileOffset = %08lx, %08lx\n", FileOffset->LowPart,
                                                          FileOffset->HighPart );

    //
    //  If it is a mask Mbcb we are getting, then we only have to check
    //  for VerifyRequired.
    //

    if (FirstBcb == NULL) {

        ASSERT(Length != 0);

        if (VerifyRequired) {
            CcSetDirtyInMask( SharedCacheMap, FileOffset, Length );
        }

        DebugTrace(-1, me, "CcReleaseByteRangeFromWrite -> VOID\n", 0);

        return;
    }

    //
    //  PREfix correctly notes that if the caller gives us a listhead to start with,
    //  we will not have filled in LastOffset by the time we do our first loop test.
    //  For PREfix's benefit (and ours), assert we really are starting with a Bcb.
    //

    ASSERT( FirstBcb->NodeTypeCode == CACHE_NTC_BCB );

    //
    //  Now loop to free up all of the Bcbs.  If modified writing is disabled
    //  for each Bcb, then we are to set it clean here, since we are synchronized
    //  with callers who set the data dirty.  Otherwise we only have the Bcb pinned
    //  so it will not go away, and we only unpin it here.
    //

    do {
        NextBcb = CONTAINING_RECORD( FirstBcb->BcbLinks.Flink, BCB, BcbLinks );

        //
        //  Skip over any listheads.
        //

        if (FirstBcb->NodeTypeCode == CACHE_NTC_BCB) {

            LastOffset = FirstBcb->FileOffset;

            //
            //  If this is file system metadata (we disabled modified writing),
            //  then this is the time to mark the buffer clean, so long as we
            //  did not get verify required.
            //

            if (FlagOn(SharedCacheMap->Flags, MODIFIED_WRITE_DISABLED)) {

                CcUnpinFileData( FirstBcb,
                                 BooleanFlagOn(SharedCacheMap->Flags, DISABLE_WRITE_BEHIND),
                                 SET_CLEAN );
            }

            //
            //  If we got verify required, we have to mark the buffer dirty again
            //  so we will try again later.  Note we have to make this call again
            //  to make sure the right thing happens with time stamps.
            //

            if (VerifyRequired) {
                CcSetDirtyPinnedData( FirstBcb, NULL );
            }

            //
            //  Finally remove a pin count left over from CcAcquireByteRangeForWrite.
            //

            CcUnpinFileDataReleaseFromFlush( FirstBcb, TRUE, UNPIN );
        }

        FirstBcb = NextBcb;
    } while (FileOffset->QuadPart != LastOffset.QuadPart);

    DebugTrace(-1, me, "CcReleaseByteRangeFromWrite -> VOID\n", 0);
}


//
//  Internal Support Routine
//

VOID
FASTCALL
CcWriteBehind (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN PIO_STATUS_BLOCK IoStatus
    )

/*++

Routine Description:

    This routine may be called with Wait = FALSE to see if write behind
    is required, or with Wait = TRUE to perform write behind as required.

    The code is very similar to the the code that the Lazy Writer performs
    for each SharedCacheMap.  The main difference is in the call to
    CcAcquireByteRangeForWrite.  Write Behind does not care about time
    stamps (passing ULONG to accept all time stamps), but it will never
    dump the first (highest byte offset) buffer in the list if the last
    byte of that buffer is not yet written.  The Lazy Writer does exactly
    the opposite, in the sense that it is totally time-driven, and will
    even dump a partially modified buffer if it sits around long enough.

Arguments:

    SharedCacheMap - Pointer to SharedCacheMap to be written

Return Value:

    FALSE - if write behind is required, but the caller supplied
            Wait = FALSE

    TRUE - if write behind is complete or not required

--*/

{
    KLOCK_QUEUE_HANDLE LockHandle;
    ULONG ActivePage;
    ULONG PageIsDirty;
    PMBCB Mbcb;
    NTSTATUS Status;
    PVACB ActiveVacb = NULL;
    LOGICAL FlushFailed = FALSE;

    DebugTrace(+1, me, "CcWriteBehind\n", 0 );
    DebugTrace( 0, me, "    SharedCacheMap = %08lx\n", SharedCacheMap );

    //
    //  First we have to acquire the file for LazyWrite, to avoid
    //  deadlocking with writers to the file.  We do this via the
    //  CallBack procedure specified to CcInitializeCacheMap.
    //

    if (!(*SharedCacheMap->Callbacks->AcquireForLazyWrite)
                            ( SharedCacheMap->LazyWriteContext, TRUE )) {

        //
        //  The filesystem is hinting that it doesn't think that it can
        //  service the write without significant delay so we will defer
        //  and come back later.  Simply drop the queued flag ... note that
        //  we do not modify CcPagesYetToWrite, in the hope that we can make
        //  up the difference in some other cache map on this pass.
        //

        CcAcquireMasterLock( &LockHandle.OldIrql );
        ClearFlag(SharedCacheMap->Flags, WRITE_QUEUED);
        CcReleaseMasterLock( LockHandle.OldIrql );

        IoStatus->Status = STATUS_FILE_LOCK_CONFLICT;
        return;
    }

    //
    //  See if there is a previous active page to clean up, but only
    //  do so now if it is the last dirty page or no users have the
    //  file open.  We will free it below after dropping the spinlock.
    //

    KeAcquireInStackQueuedSpinLock( &SharedCacheMap->BcbSpinLock, &LockHandle );
    CcAcquireMasterLockAtDpcLevel();

    if ((SharedCacheMap->DirtyPages <= 1) || (SharedCacheMap->OpenCount == 0)) {
        GetActiveVacbAtDpcLevel( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
    }

    //
    //  Increment open count so that our caller's views stay available
    //  for CcGetVacbMiss.  We could be tying up all of the views, and
    //  still need to write file sizes.
    //

    CcIncrementOpenCount( SharedCacheMap, 'brWS' );

    //
    //  If there is a mask bcb, then we need to establish a target for
    //  it to flush.
    //

    if ((Mbcb = SharedCacheMap->Mbcb) != 0) {

        //
        //  Set a target of pages to write, assuming that any Active
        //  Vacb will increase the number.
        //

        Mbcb->PagesToWrite = Mbcb->DirtyPages + ((ActiveVacb != NULL) ? 1 : 0);

        if (Mbcb->PagesToWrite > CcPagesYetToWrite) {

            Mbcb->PagesToWrite = CcPagesYetToWrite;
        }
    }

    CcReleaseMasterLockFromDpcLevel();
    KeReleaseInStackQueuedSpinLock( &LockHandle );

    //
    //  Now free the active Vacb, if we found one.
    //

    if (ActiveVacb != NULL) {

        CcFreeActiveVacb( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
    }

    //
    //  Now perform the lazy writing for this file via a special call
    //  to CcFlushCache.  He recognizes us by the &CcNoDelay input to
    //  FileOffset, which signifies a Lazy Write, but is subsequently
    //  ignored.
    //

    CcFlushCache( SharedCacheMap->FileObject->SectionObjectPointer,
                  &CcNoDelay,
                  1,
                  IoStatus );

    //
    //  No need for the Lazy Write resource now.
    //

    (*SharedCacheMap->Callbacks->ReleaseFromLazyWrite)
                        ( SharedCacheMap->LazyWriteContext );

    //
    //  If we are supposed to do a fast lazy write on this shared cache map,
    //  we need to remember if the flush failed so that we can signal Mm when 
    //  we acquire the master lock below.  We will signal Mm if we failed for 
    //  any reason other than STATUS_VERIFY_REQUIRED, including 
    //  STATUS_FILE_LOCK_CONFLICT.
    //

    if (!NT_SUCCESS( IoStatus->Status ) && (IoStatus->Status != STATUS_VERIFY_REQUIRED)) {
        
        FlushFailed = TRUE;
    }

    //
    //  Check if we need to put up a popup.
    //

    if (!NT_SUCCESS(IoStatus->Status) && !RetryError(IoStatus->Status)) {

        //
        //  We lost writebehind data.  Bemoan our fate into the system event
        //  log and throw a popup with a meaningful name to the desktop.
        //

        POBJECT_NAME_INFORMATION FileNameInfo = NULL;
        NTSTATUS Status;

        //
        //  Increment the count of how many of these we've had.  This counter
        //  is useful in attempting to discriminate some corruption cases under
        //  test.
        //

        CcLostDelayedWrites += 1;
        
        Status = IoQueryFileDosDeviceName( SharedCacheMap->FileObject, &FileNameInfo );

        if ( Status == STATUS_SUCCESS ) {
            IoRaiseInformationalHardError( STATUS_LOST_WRITEBEHIND_DATA, &FileNameInfo->Name, NULL );

        } else {
            if ( SharedCacheMap->FileObject->FileName.Length &&
                 SharedCacheMap->FileObject->FileName.MaximumLength &&
                 SharedCacheMap->FileObject->FileName.Buffer ) {

                IoRaiseInformationalHardError( STATUS_LOST_WRITEBEHIND_DATA, &SharedCacheMap->FileObject->FileName, NULL );
            }
        }

        CcLogError( SharedCacheMap->FileObject,
                    ( Status == STATUS_SUCCESS ?
                      &FileNameInfo->Name :
                      &SharedCacheMap->FileObject->FileName ),
                    IO_LOST_DELAYED_WRITE,
                    IoStatus->Status,
                    IRP_MJ_WRITE );

        if (FileNameInfo) {
            ExFreePool(FileNameInfo);
        }

    //
    //  See if there is any deferred writes we can post.
    //

    } else if (!IsListEmpty(&CcDeferredWrites)) {
        CcPostDeferredWrites();
    }

    //
    //  Now acquire BcbSpinLock again to check for ValidData updates.
    //

    KeAcquireInStackQueuedSpinLock( &SharedCacheMap->BcbSpinLock, &LockHandle );

    //
    //  If the the current ValidDataGoal is greater (or equal) than ValidDataLength,
    //  then we must see if we have advanced beyond the current ValidDataLength.
    //
    //  If we have NEVER written anything out from this shared cache map, then
    //  there is no need to check anything associated with valid data length
    //  here.  We will come by here again when, and if, anybody actually
    //  modifies the file and we lazy write some data.
    //

    Status = STATUS_SUCCESS;
    if (FlagOn(SharedCacheMap->Flags, (LAZY_WRITE_OCCURRED | FORCED_WRITE_THROUGH)) &&
        (SharedCacheMap->ValidDataGoal.QuadPart >= SharedCacheMap->ValidDataLength.QuadPart) &&
        (SharedCacheMap->ValidDataLength.QuadPart != MAXLONGLONG) &&
        (SharedCacheMap->FileSize.QuadPart != 0)) {

        LARGE_INTEGER NewValidDataLength;

        NewValidDataLength = CcGetFlushedValidData( SharedCacheMap->FileObject->SectionObjectPointer,
                                                    TRUE );

        //
        //  If New ValidDataLength has been written, then we have to
        //  call the file system back to update it.  We must temporarily
        //  drop our global list while we do this, which is safe to do since
        //  we have not cleared WRITE_QUEUED.
        //
        //  Note we keep calling any time we wrote the last page of the file,
        //  to solve the "famous" AFS Server problem.  The file system will
        //  truncate our valid data call to whatever is currently valid.  But
        //  then if he writes a little more, we do not want to stop calling
        //  back.
        //

        if ( NewValidDataLength.QuadPart >= SharedCacheMap->ValidDataLength.QuadPart ) {

            KeReleaseInStackQueuedSpinLock( &LockHandle );

            //
            //  Call file system to set new valid data.  We have no
            //  one to tell if this doesn't work.
            //

            Status = CcSetValidData( SharedCacheMap->FileObject,
                                     &NewValidDataLength );

            KeAcquireInStackQueuedSpinLock( &SharedCacheMap->BcbSpinLock, &LockHandle );
            if (NT_SUCCESS(Status)) {
                SharedCacheMap->ValidDataLength = NewValidDataLength;
            }
        }
    }

    KeReleaseInStackQueuedSpinLock( &LockHandle );

    //
    //  Show we are done.
    //

    CcAcquireMasterLock( &LockHandle.OldIrql );
    CcDecrementOpenCount( SharedCacheMap, 'brWF' );

    //
    //  Check to see if this is a shared cache map Mm is waiting to be torn
    //  down and if this flush failed.  If so, we need to signal Mm because
    //  this cache map will not be able to be torn down quickly.
    //

    if (FlushFailed && FlagOn( SharedCacheMap->Flags, WAITING_FOR_TEARDOWN )) {

        CcCancelMmWaitForUninitializeCacheMap( SharedCacheMap );
    }

    //
    //  Make an approximate guess about whether we will call CcDeleteSharedCacheMap or not
    //  to truncate the file.
    //
    //  Also do not delete the SharedCacheMap if we got an error on the ValidDataLength
    //  callback.  If we get a resource allocation failure or a retryable error (due to
    //  log file full?), we have no one to tell, so we must just loop back and try again.
    //  Of course all I/O errors are just too bad.
    //

    if (SharedCacheMap->OpenCount == 0) {


        if (NT_SUCCESS(Status) || 
            ((Status != STATUS_INSUFFICIENT_RESOURCES) && !RetryError(Status))) {

            CcReleaseMasterLock( LockHandle.OldIrql );
            FsRtlAcquireFileExclusive( SharedCacheMap->FileObject );
            CcAcquireMasterLock( &LockHandle.OldIrql );

            //
            //  Now really see if we are to delete this SharedCacheMap. By having released
            //  first we avoid a deadlock with the file system when the FileObject is
            //  dereferenced.  Note that CcDeleteSharedCacheMap requires that the
            //  CcMasterSpinLock already be acquired, and it releases it.
            //
            //  Note that we must retest since we dropped and reacquired the master
            //  lock.
            //

            if ((SharedCacheMap->OpenCount == 0)

                    &&

                ( (SharedCacheMap->DirtyPages == 0) 
                    
                            || 
                            
                  ( (SharedCacheMap->FileSize.QuadPart == 0) && 
                    !FlagOn(SharedCacheMap->Flags, PIN_ACCESS) ) )
                ) {

                //
                //  Make sure to drop the requeue flag in case the write hit the timeout at
                //  the same time it finished everything up.
                //

                CcDeleteSharedCacheMap( SharedCacheMap, LockHandle.OldIrql, TRUE );
                IoStatus->Information = 0;
                SharedCacheMap = NULL;

            } else {

                CcReleaseMasterLock( LockHandle.OldIrql );
                FsRtlReleaseFile( SharedCacheMap->FileObject );
                CcAcquireMasterLock( &LockHandle.OldIrql );
            }
            
        } else {

            //
            //  We got an error where we should retry our operation.  Move this
            //  shared cache map back to the dirty list if it is not already
            //  there.
            //

            if (SharedCacheMap->DirtyPages == 0) {

                RemoveEntryList( &SharedCacheMap->SharedCacheMapLinks );
                InsertTailList( &CcDirtySharedCacheMapList.SharedCacheMapLinks,
                                &SharedCacheMap->SharedCacheMapLinks );

                //
                //  Make sure the Lazy Writer will wake up, because we
                //  want him to delete this SharedCacheMap.
                //

                LazyWriter.OtherWork = TRUE;
                if (!LazyWriter.ScanActive) {
                    CcScheduleLazyWriteScan( FALSE );
                }
            }
        }
    }

    //
    //  In the normal case, we just clear the flag on the way out if
    //  we will not requeue the workitem.
    //

    if (SharedCacheMap != NULL) {

        if (IoStatus->Information != CC_REQUEUE) {
            ClearFlag(SharedCacheMap->Flags, WRITE_QUEUED);
        }
        CcReleaseMasterLock( LockHandle.OldIrql );
    }

    DebugTrace(-1, me, "CcWriteBehind->VOID\n", 0 );

    return;
}


LARGE_INTEGER
CcGetFlushedValidData (
    __in PSECTION_OBJECT_POINTERS SectionObjectPointer,
    __in BOOLEAN CcInternalCaller
    )

/*++

Routine Description:

    This routine may be called by a file system to find out how far the Cache Manager
    has flushed in the stream.  More accurately, this routine returns either the FileOffset
    of the lowest dirty page currently in the file.

    NOTE that even though the routine takes SectionObjectPointer, the caller must ensure
    that the stream is cached and stays cached for the duration of this routine, much like
    for the copy routines, etc.

Arguments:

    SectionObjectPointer - A pointer to the Section Object Pointers
                           structure in the nonpaged Fcb.

    CcInternalCaller - must be TRUE if the caller is coming from Cc, FALSE otherwise.
        TRUE implies the need for self-synchronization.

Return Value:

    The derived number for flushed ValidData, or MAXLONGLONG in the quad part if
    the Section is not cached.  (Naturally the caller can guarantee that this case
    does not occur, and internal callers do.)

--*/

{
    PSHARED_CACHE_MAP SharedCacheMap;
    KLOCK_QUEUE_HANDLE LockHandle;
    LARGE_INTEGER NewValidDataLength;

    //
    //  External callers may be unsynchronized with this shared cache map
    //  perhaps going away underneath this call.
    //

    if (!CcInternalCaller) {

        CcAcquireMasterLock( &LockHandle.OldIrql );

        SharedCacheMap = SectionObjectPointer->SharedCacheMap;

        if (SharedCacheMap == NULL) {
            CcReleaseMasterLock( LockHandle.OldIrql );
            NewValidDataLength.QuadPart = MAXLONGLONG;
            return NewValidDataLength;
        }

        CcIncrementOpenCount( SharedCacheMap, 'dfGS' );
        CcReleaseMasterLock( LockHandle.OldIrql );
        KeAcquireInStackQueuedSpinLock( &SharedCacheMap->BcbSpinLock, &LockHandle );

    } else {

        SharedCacheMap = SectionObjectPointer->SharedCacheMap;
    }

    ASSERT( SharedCacheMap != NULL );

    //
    //  If the file is entirely clean, then we wish to return
    //  the new ValidDataLength as equal to ValidDataGoal.
    //

    NewValidDataLength = SharedCacheMap->ValidDataGoal;

    //
    //  If there may be dirty pages we will look at the last Bcb in the
    //  descending-order Bcb list, and see if it describes data beyond
    //  ValidDataGoal.
    //
    //  It is important to note that since we use DirtyPages as a faux
    //  reference count over some short windows (+1, -1) the simple
    //  fact it is nonzero does *not* mean the file is dirty.
    //
    //  (This test is logically too conservative.  For example, the last Bcb
    //  may not even be dirty (in which case we should look at its
    //  predecessor), or we may have earlier written valid data to this
    //  byte range (which also means if we knew this we could look at
    //  the predecessor).  This simply means that the Lazy Writer may not
    //  successfully get ValidDataLength updated in a file being randomly
    //  accessed until the level of file access dies down, or at the latest
    //  until the file is closed.  However, security will never be
    //  compromised.)
    //

    if (SharedCacheMap->DirtyPages) {

        PBITMAP_RANGE BitmapRange;
        PBCB LastBcb;
        PMBCB Mbcb = SharedCacheMap->Mbcb;

        if ((Mbcb != NULL) && (Mbcb->DirtyPages != 0)) {

            BitmapRange = CcFindBitmapRangeToClean( Mbcb, 0 );

            ASSERT(BitmapRange->FirstDirtyPage != MAXULONG);

            NewValidDataLength.QuadPart = (BitmapRange->BasePage + BitmapRange->FirstDirtyPage)
                                            << PAGE_SHIFT;
        }

        LastBcb = CONTAINING_RECORD( SharedCacheMap->BcbList.Flink,
                                     BCB,
                                     BcbLinks );

        while (&LastBcb->BcbLinks != &SharedCacheMap->BcbList) {

            if ((LastBcb->NodeTypeCode == CACHE_NTC_BCB) && LastBcb->Dirty) {
                break;
            }

            LastBcb = CONTAINING_RECORD( LastBcb->BcbLinks.Flink,
                                         BCB,
                                         BcbLinks );
        }

        //
        //  Check the Base of the last entry.
        //

        if ((&LastBcb->BcbLinks != &SharedCacheMap->BcbList) &&
            (LastBcb->FileOffset.QuadPart < NewValidDataLength.QuadPart )) {

            NewValidDataLength = LastBcb->FileOffset;
        }
    }

    if (!CcInternalCaller) {

        //
        //  Remove our reference.
        //

        CcAcquireMasterLockAtDpcLevel();
        CcDecrementOpenCount( SharedCacheMap, 'dfGF' );

        if ((SharedCacheMap->OpenCount == 0) &&
            !FlagOn(SharedCacheMap->Flags, WRITE_QUEUED) &&
            (SharedCacheMap->DirtyPages == 0)) {

            //
            //  Move to the dirty list.
            //

            RemoveEntryList( &SharedCacheMap->SharedCacheMapLinks );
            InsertTailList( &CcDirtySharedCacheMapList.SharedCacheMapLinks,
                        &SharedCacheMap->SharedCacheMapLinks );

            //
            //  Make sure the Lazy Writer will wake up, because we
            //  want him to delete this SharedCacheMap.
            //

            LazyWriter.OtherWork = TRUE;
            if (!LazyWriter.ScanActive) {
                CcScheduleLazyWriteScan( FALSE );
            }
        }

        KeReleaseInStackQueuedSpinLockFromDpcLevel( &LockHandle );
        CcReleaseMasterLock( LockHandle.OldIrql );
    }

    return NewValidDataLength;
}


VOID
CcFlushCache (
    __in PSECTION_OBJECT_POINTERS SectionObjectPointer,
    __in_opt PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __out_opt PIO_STATUS_BLOCK IoStatus
    )

/*++

Routine Description:

    This routine may be called to flush dirty data from the cache to the
    cached file on disk.  Any byte range within the file may be flushed,
    or the entire file may be flushed by omitting the FileOffset parameter.

    This routine does not take a Wait parameter; the caller should assume
    that it will always block.

Arguments:

    SectionObjectPointer - A pointer to the Section Object Pointers
                           structure in the nonpaged Fcb.

    FileOffset - If this parameter is supplied (not NULL), then only the
                 byte range specified by FileOffset and Length are flushed.
                 If &CcNoDelay is specified, then this signifies the call
                 from the Lazy Writer, and the lazy write scan should resume
                 as normal from the last spot where it left off in the file.

    Length - Defines the length of the byte range to flush, starting at
             FileOffset.  This parameter is ignored if FileOffset is
             specified as NULL.

    IoStatus - The I/O status resulting from the flush operation.

Return Value:

    None.

--*/

{
    LARGE_INTEGER NextFileOffset, TargetOffset;
    ULONG NextLength;
    PBCB FirstBcb;
    KIRQL OldIrql;
    PSHARED_CACHE_MAP SharedCacheMap;
    IO_STATUS_BLOCK TrashStatus;
    PVOID TempVa;
    ULONG RemainingLength, TempLength;
    NTSTATUS PopupStatus;
    LOGICAL HotSpot;
    ULONG BytesWritten = 0;
    LOGICAL PopupRequired = FALSE;
    LOGICAL VerifyRequired = FALSE;
    LOGICAL CollidedFlush;
    LOGICAL IsLazyWriter = FALSE;
    LOGICAL FastLazyWrite = FALSE;
    LOGICAL FreeActiveVacb = FALSE;
    PVACB ActiveVacb = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    LARGE_INTEGER EndTick, CurrentTick;
    ULONG MmFlushFlags = 0;

    DebugTrace(+1, me, "CcFlushCache:\n", 0 );
    DebugTrace( 0, mm, "    SectionObjectPointer = %08lx\n", SectionObjectPointer );
    DebugTrace2(0, me, "    FileOffset = %08lx, %08lx\n",
                            ARGUMENT_PRESENT(FileOffset) ? FileOffset->LowPart
                                                         : 0,
                            ARGUMENT_PRESENT(FileOffset) ? FileOffset->HighPart
                                                         : 0 );
    DebugTrace( 0, me, "    Length = %08lx\n", Length );

    //
    //  If IoStatus passed a Null pointer, set up to through status away.
    //

    if (!ARGUMENT_PRESENT(IoStatus)) {
        IoStatus = &TrashStatus;
    }
    IoStatus->Status = STATUS_SUCCESS;
    IoStatus->Information = 0;

    //
    //  See if this is the Lazy Writer.  Since he wants to use this common
    //  routine, which is also a public routine callable by file systems,
    //  the Lazy Writer shows his call by specifying CcNoDelay as the file offset!
    //
    //  Also, in case we do not write anything because we see only HotSpot(s),
    //  initialize the Status to indicate a retryable error, so CcWorkerThread
    //  knows we did not make any progress.  Of course any actual flush will
    //  overwrite this code.
    //

    if (FileOffset == &CcNoDelay) {
        IoStatus->Status = STATUS_VERIFY_REQUIRED;
        IsLazyWriter = TRUE;
        FileOffset = NULL;
        SetFlag( MmFlushFlags, MM_FLUSH_FAIL_COLLISIONS );
        
    } else {

        SetFlag( MmFlushFlags, MM_FLUSH_ACQUIRE_FILE );
    }

    CcAcquireMasterLock( &OldIrql );

    SharedCacheMap = SectionObjectPointer->SharedCacheMap;

    //
    //  Awareness is indicated by the lowbit of the FileOffset pointer.
    //  Non-awareness of a private write stream results in a no-op.
    //

    if (SharedCacheMap != NULL) {

        if (IsLazyWriter && FlagOn( SharedCacheMap->Flags, WAITING_FOR_TEARDOWN )) {

            //
            //  If the WAITING_FOR_TEARDOWN flag is set, Mm is waiting for Cc
            //  to flush this file and teardown the shared cache map so that
            //  the file can be remapped as a section image.  In this case,
            //  we want the lazy writer to flush all dirty data for this file
            //  to disk now, not just a fraction of the dirty pages to keep 
            //  within the lazy write threshold.
            //
            
            FastLazyWrite = TRUE;

            //
            //  If we are doing a fast lazy write, we don't want to fail because
            //  of a flush collision, so we will clear that MmFlushFlag now.
            //

            ClearFlag( MmFlushFlags, MM_FLUSH_FAIL_COLLISIONS );
        }

        if (FlagOn( SharedCacheMap->Flags, PRIVATE_WRITE )) {
            
            if (((ULONG_PTR)FileOffset & 1) == 0) {

                CcReleaseMasterLock( OldIrql );
                return;

            }

            FileOffset = (PLARGE_INTEGER)((ULONG_PTR)FileOffset ^ 1);
        }

        //
        //  If this file is targeted to a CD ROM device, we don't want to 
        //  deal back off when we collide with the mapped page writer because
        //  we could colliding in the window between the point where Mm has
        //  marked the pages "WriteInProgress" but is waiting to acquire the 
        //  file system locks.  Often, these file systems will fail the 
        //  AcquireForModWrite if the file does not have any user mapped views
        //  so that the flushes come in sequential order, which it is very 
        //  important for efficient writing on these devices.
        //

        if ((SharedCacheMap->FileObject->DeviceObject != NULL) &&
            (SharedCacheMap->FileObject->DeviceObject->DeviceType == FILE_DEVICE_CD_ROM)) {

            ClearFlag( MmFlushFlags, MM_FLUSH_FAIL_COLLISIONS );
        }
    }

    //
    //  If there is nothing to do, return here.
    //

    if (ARGUMENT_PRESENT(FileOffset) && (Length == 0)) {

        CcReleaseMasterLock( OldIrql );
        DebugTrace(-1, me, "CcFlushCache -> VOID\n", 0 );
        return;
    }

    //
    //  See if the file is cached.
    //

    if (SharedCacheMap != NULL) {

        //
        //  Increment the open count to keep it from going away.
        //

        CcIncrementOpenCount( SharedCacheMap, 'fcCS' );

        if ((SharedCacheMap->NeedToZero != NULL) || (SharedCacheMap->ActiveVacb != NULL)) {

            ULONG FirstPage = 0;
            ULONG LastPage = MAXULONG;

            if (ARGUMENT_PRESENT(FileOffset)) {

                FirstPage = (ULONG)(FileOffset->QuadPart >> PAGE_SHIFT);
                LastPage = (ULONG)((FileOffset->QuadPart + Length - 1) >> PAGE_SHIFT);
            }

            //
            //  Make sure we do not flush the active page without zeroing any
            //  uninitialized data.  Also, it is very important to free the active
            //  page if it is the one to be flushed, so that we get the dirty
            //  bit out to the Pfn.
            //

            if (((((LONGLONG)LastPage + 1) << PAGE_SHIFT) > SharedCacheMap->ValidDataGoal.QuadPart) ||

                ((SharedCacheMap->NeedToZero != NULL) &&
                 (FirstPage <= SharedCacheMap->NeedToZeroPage) &&
                 (LastPage >= SharedCacheMap->NeedToZeroPage)) ||

                ((SharedCacheMap->ActiveVacb != NULL) &&
                 (FirstPage <= SharedCacheMap->ActivePage) &&
                 (LastPage >= SharedCacheMap->ActivePage))) {

                GetActiveVacbAtDpcLevel( SharedCacheMap, ActiveVacb, RemainingLength, TempLength );
                FreeActiveVacb = TRUE;
            }
        }
    }

    CcReleaseMasterLock( OldIrql );

    if (FreeActiveVacb) {
        CcFreeActiveVacb( SharedCacheMap, ActiveVacb, RemainingLength, TempLength );
    }

    //
    //  If there is a user-mapped file, then we perform the "service" of
    //  flushing even data not written via the file system.  Note that this
    //  is pretty important for folks provoking the flush/purge of a coherency
    //  operation.
    //
    //  It is critical this happen before we examine our own hints.  In the course
    //  of this flush it is possible valid data length will be advanced by the
    //  underlying filesystem, with CcZero'ing behind - which will cause us to
    //  make some dirty zeroes in the cache.
    //
    //  If this stream allows mapping for overwrite, we also need to flush the
    //  full range now since there could be dirty data in this range that Cc 
    //  isn't tracking.
    //

    if (((SharedCacheMap == NULL)
            ||
         FlagOn(((PFSRTL_COMMON_FCB_HEADER)(SharedCacheMap->FileObject->FsContext))->Flags,
               FSRTL_FLAG_USER_MAPPED_FILE)
            ||
         FlagOn(SharedCacheMap->Flags, CALLER_TRACKS_DIRTY_DATA))
            && 
        !IsLazyWriter) {

        //
        //  Call MM to flush the section through our view.
        //

        DebugTrace( 0, mm, "MmFlushSection:\n", 0 );
        DebugTrace( 0, mm, "    SectionObjectPointer = %08lx\n", SectionObjectPointer );
        DebugTrace2(0, me, "    FileOffset = %08lx, %08lx\n",
                                ARGUMENT_PRESENT(FileOffset) ? FileOffset->LowPart
                                                             : 0,
                                ARGUMENT_PRESENT(FileOffset) ? FileOffset->HighPart
                                                             : 0 );
        DebugTrace( 0, mm, "    RegionSize = %08lx\n", Length );

        //
        //  In this case, we always want to acquire the file instead of using
        //  the flags we have setup MmFlushFlags.  To avoid cache coherency
        //  issues, we want to do our best to make sure this flush is completed 
        //  successfully before continuing.
        //

        Status = MmFlushSection( SectionObjectPointer,
                                 FileOffset,
                                 Length,
                                 IoStatus,
                                 MM_FLUSH_ACQUIRE_FILE );

        ASSERT( IoStatus->Status != STATUS_ENCOUNTERED_WRITE_IN_PROGRESS );

        if ((!NT_SUCCESS(IoStatus->Status)) && !RetryError(IoStatus->Status)) {

            PopupRequired = TRUE;
            PopupStatus = IoStatus->Status;
        }

        DebugTrace2(0, mm, "    <IoStatus = %08lx, %08lx\n",
                    IoStatus->Status, IoStatus->Information );
    }

    //
    //  Scan for dirty pages if there is a shared cache map.
    //

    if (SharedCacheMap != NULL) {

        //
        //  If FileOffset was not specified then set to flush entire region
        //  and set valid data length to the goal so that we will not get
        //  any more call backs.
        //
        //  NOTE: We could be flushing the entire file if this is
        //  a FastLazyWrite (if FastLazyWrite is TRUE, IsLazyWriter will also
        //  always be TRUE).  In this case we do NOT want to do this 
        //  optimization to move VDL to VDG *before* we've done the flush 
        //  because it is not safe to update the SharedCacheMap's VDL at this 
        //  time -- the lazy write path only has the file acquired shared, not 
        //  exclusive as is the case when the user has requested the file to 
        //  be flushed.

        if (!IsLazyWriter && !ARGUMENT_PRESENT(FileOffset)) {

            SharedCacheMap->ValidDataLength = SharedCacheMap->ValidDataGoal;
        }

        //
        //  If this is an explicit flush, initialize our offset to scan for.
        //

        if (ARGUMENT_PRESENT(FileOffset)) {
            TargetOffset = *FileOffset;
        }

        //
        //  Assume we want to pass the explicit flush flag in Length.
        //  But overwrite it if a length really was specified.  On
        //  subsequent loops, NextLength will have some nonzero value.
        //

        NextLength = 1;
        if (Length != 0) {
            NextLength = Length;
        }

        //
        //  Now calculate the tick that will signal the expiration of a
        //  lazy writer tick interval.
        //

        if (IsLazyWriter) {

            KeQueryTickCount( &EndTick );
            EndTick.QuadPart += CcIdleDelayTick;
        }

        //
        //  Loop as long as we find buffers to flush for this
        //  SharedCacheMap, and we are not trying to delete the guy.
        //

        while (((SharedCacheMap->PagesToWrite != 0) || !(IsLazyWriter && !FastLazyWrite))

                    &&
               ((SharedCacheMap->FileSize.QuadPart != 0) ||
                FlagOn(SharedCacheMap->Flags, PIN_ACCESS))

                    &&

               !VerifyRequired

                    &&

               CcAcquireByteRangeForWrite ( SharedCacheMap,
                                            (IsLazyWriter && !FastLazyWrite ) ? NULL : (ARGUMENT_PRESENT(FileOffset) ?
                                                                                       &TargetOffset : NULL),
                                            (IsLazyWriter && !FastLazyWrite ) ? 0: NextLength,
                                            &NextFileOffset,
                                            &NextLength,
                                            &FirstBcb )) {

            //
            //  Assume this range is not a hot spot or a collided flush.
            //

            HotSpot = FALSE;
            CollidedFlush = FALSE;

            //
            //  We defer calling Mm to set address range modified until here, to take
            //  overhead out of the main line path, and to reduce the number of TBIS
            //  on a multiprocessor.
            //

            RemainingLength = NextLength;

            do {

                //
                //  See if the next file offset is mapped.  (If not, the dirty bit
                //  was propagated on the unmap.)
                //

                if ((TempVa = CcGetVirtualAddressIfMapped( SharedCacheMap,
                                                           NextFileOffset.QuadPart + NextLength - RemainingLength,
                                                           &ActiveVacb,
                                                           &TempLength)) != NULL) {

                    //
                    //  Reduce TempLength to RemainingLength if necessary, and
                    //  call MM.
                    //

                    if (TempLength > RemainingLength) {
                        TempLength = RemainingLength;
                    }

                    //
                    //  Clear the Dirty bit (if set) in the PTE and set the
                    //  Pfn modified.  Assume if the Pte was dirty, that this may
                    //  be a hot spot.  Do not do hot spots for metadata, and unless
                    //  they are within ValidDataLength as reported to the file system
                    //  via CcSetValidData.
                    //

                    HotSpot = (BOOLEAN)(((MmSetAddressRangeModified(TempVa, TempLength) || HotSpot) &&
                                         ((NextFileOffset.QuadPart + NextLength) <
                                          (SharedCacheMap->ValidDataLength.QuadPart)) &&
                                         ((SharedCacheMap->LazyWritePassCount & 0xF) != 0) &&
                                         (IsLazyWriter && !FastLazyWrite)) &&
                                        !FlagOn(SharedCacheMap->Flags, MODIFIED_WRITE_DISABLED));

                    CcFreeVirtualAddress( ActiveVacb );

                } else {

                    //
                    //  Reduce TempLength to RemainingLength if necessary.
                    //

                    if (TempLength > RemainingLength) {
                        TempLength = RemainingLength;
                    }
                }

                //
                //  Reduce RemainingLength by what we processed.
                //

                RemainingLength -= TempLength;

            //
            //  Loop until done.
            //

            } while (RemainingLength != 0);

            CcLazyWriteHotSpots += HotSpot;

            //
            //  Now flush, now flush if we do not think it is a hot spot.
            //

            if (!HotSpot) {

                MmFlushSection( SharedCacheMap->FileObject->SectionObjectPointer,
                                &NextFileOffset,
                                NextLength,
                                IoStatus,
                                MmFlushFlags );

                if (NT_SUCCESS(IoStatus->Status)) {

                    if (!FlagOn(SharedCacheMap->Flags, LAZY_WRITE_OCCURRED)) {

                        CcAcquireMasterLock( &OldIrql );
                        SetFlag(SharedCacheMap->Flags, LAZY_WRITE_OCCURRED);
                        CcReleaseMasterLock( OldIrql );
                    }

                    //
                    //  Increment performance counters
                    //

                    if (IsLazyWriter) {

                        CcLazyWriteIos += 1;
                        CcLazyWritePages += (NextLength + PAGE_SIZE - 1) >> PAGE_SHIFT;
                    }

                } else {

                    LARGE_INTEGER Offset = NextFileOffset;
                    ULONG RetryLength = NextLength;

                    DebugTrace2( 0, 0, "I/O Error on Cache Flush: %08lx, %08lx\n",
                                 IoStatus->Status, IoStatus->Information );

                    //
                    //  If we collided with mapped page writer, we don't
                    //  want to terminate this flush loop yet.  We do want 
                    //  to track the collision so that we re-mark the pages 
                    //  dirty, but then we want to continue the loop and
                    //  try to flush the next range of dirty data since it 
                    //  is unlikely we will collide again.
                    //
                    
                    if (IoStatus->Status == STATUS_ENCOUNTERED_WRITE_IN_PROGRESS) {


                        CollidedFlush = TRUE;

                    //
                    //  If we get any other RetryError, we set VerifyRequired so
                    //  that we will re-mark the pages as dirty then terminate 
                    //  this flush loop.
                    //
                        
                    } else if (RetryError(IoStatus->Status)) {

                        VerifyRequired = TRUE;

                    //
                    //  Loop to write each page individually, starting with one
                    //  more try on the page that got the error, in case that page
                    //  or any page beyond it can be successfully written
                    //  individually.  Note that Offset and RetryLength are
                    //  guaranteed to be in integral pages, but the Information
                    //  field from the failed request is not.
                    //
                    //  We ignore errors now, and give it one last shot, before
                    //  setting the pages clean (see below).
                    //

                    } else {

                        do {

                            DebugTrace2( 0, 0, "Trying page at offset %08lx, %08lx\n",
                                         Offset.LowPart, Offset.HighPart );

                            MmFlushSection ( SharedCacheMap->FileObject->SectionObjectPointer,
                                             &Offset,
                                             PAGE_SIZE,
                                             IoStatus,
                                             MmFlushFlags );

                            DebugTrace2( 0, 0, "I/O status = %08lx, %08lx\n",
                                         IoStatus->Status, IoStatus->Information );

                            if (NT_SUCCESS(IoStatus->Status)) {
                                CcAcquireMasterLock( &OldIrql );
                                SetFlag(SharedCacheMap->Flags, LAZY_WRITE_OCCURRED);
                                CcReleaseMasterLock( OldIrql );
                            }

                            if ((!NT_SUCCESS(IoStatus->Status)) && !RetryError(IoStatus->Status)) {

                                PopupRequired = TRUE;
                                PopupStatus = IoStatus->Status;
                            }

                            VerifyRequired = VerifyRequired || RetryError(IoStatus->Status);

                            Offset.QuadPart = Offset.QuadPart + (LONGLONG)PAGE_SIZE;
                            RetryLength -= PAGE_SIZE;

                        } while(RetryLength > 0);
                    }
                }
            }

            //
            //  Now release the Bcb resources and set them clean.  Note we do not check
            //  here for errors, and just returned in the I/O status.  Errors on writes
            //  are rare to begin with.  Nonetheless, our strategy is to rely on
            //  one or more of the following (depending on the file system) to prevent
            //  errors from getting to us.
            //
            //      - Retries and/or other forms of error recovery in the disk driver
            //      - Mirroring driver
            //      - Hot fixing in the noncached path of the file system
            //
            //  In the unexpected case that a write error does get through, we
            //  *currently* just set the Bcbs clean anyway, rather than let
            //  Bcbs and pages accumulate which cannot be written.  Note we did
            //  a popup above to at least notify the guy.
            //
            //  Set the pages dirty again if we either saw a HotSpot or got
            //  verify required.
            //

            CcReleaseByteRangeFromWrite ( SharedCacheMap,
                                          &NextFileOffset,
                                          NextLength,
                                          FirstBcb,
                                          (BOOLEAN)(HotSpot || CollidedFlush || VerifyRequired) );

            //
            //  See if there is any deferred writes we should post.
            //

            BytesWritten += NextLength;
            if ((BytesWritten >= 0x40000) && !IsListEmpty(&CcDeferredWrites)) {
                CcPostDeferredWrites();
                BytesWritten = 0;
            }

            //
            //  If we're the lazy writer and have spent more than the active tick
            //  length in this loop, break out for a requeue so we share the
            //  file resources.
            //

            if (IsLazyWriter) {

                KeQueryTickCount( &CurrentTick );

                if (CurrentTick.QuadPart > EndTick.QuadPart) {
                    IoStatus->Information = CC_REQUEUE;
                    break;
                }
            }

            //
            //  Now for explicit flushes, we should advance our range.
            //

            if (ARGUMENT_PRESENT(FileOffset)) {

                NextFileOffset.QuadPart += NextLength;

                //
                //  Done yet?
                //

                if ((FileOffset->QuadPart + Length) <= NextFileOffset.QuadPart) {
                    break;
                }

                //
                //  Calculate new target range
                //

                NextLength = (ULONG)((FileOffset->QuadPart + Length) - NextFileOffset.QuadPart);
                TargetOffset = NextFileOffset;
            }
        }
    }

    //
    //  See if there are any deferred writes we should post if
    //  we escaped the loop without checking after a series of
    //  flushes.
    //

    if (BytesWritten != 0 && !IsListEmpty(&CcDeferredWrites)) {

        CcPostDeferredWrites();
    }

    //
    //  Now we can get rid of the open count, and clean up as required.
    //

    if (SharedCacheMap != NULL) {

        //
        //  Serialize again to decrement the open count.
        //

        CcAcquireMasterLock( &OldIrql );

        CcDecrementOpenCount( SharedCacheMap, 'fcCF' );

        if ((SharedCacheMap->OpenCount == 0) &&
            !FlagOn(SharedCacheMap->Flags, WRITE_QUEUED) &&
            (SharedCacheMap->DirtyPages == 0)) {

            //
            //  Move to the dirty list.
            //

            RemoveEntryList( &SharedCacheMap->SharedCacheMapLinks );
            InsertTailList( &CcDirtySharedCacheMapList.SharedCacheMapLinks,
                            &SharedCacheMap->SharedCacheMapLinks );

            //
            //  Make sure the Lazy Writer will wake up, because we
            //  want him to delete this SharedCacheMap.
            //

            LazyWriter.OtherWork = TRUE;
            if (!LazyWriter.ScanActive) {
                CcScheduleLazyWriteScan( FALSE );
            }
        }

        CcReleaseMasterLock( OldIrql );
    }

    //
    //  Make sure and return the first error to our caller.  In the
    //  case of the Lazy Writer, a popup will be issued.
    //

    if (PopupRequired) {
        IoStatus->Status = PopupStatus;
    }

    DebugTrace(-1, me, "CcFlushCache -> VOID\n", 0 );

    return;
}


PVOID
CcRemapBcb (
    __in PVOID Bcb
    )

/*++

Routine Description:

    This routine may be called by a file system to map a Bcb an additional
    time in order to preserve it through several calls that perform additional
    maps and unpins.


Arguments:

    Bcb - Supplies a pointer to a previously returned Bcb.

Return Value:

    Bcb with read-only indicator.

--*/

{
    KIRQL OldIrql;
    PVACB Vacb;

    //
    //  Remove read-only bit
    //

    Bcb = (PVOID) ((ULONG_PTR)Bcb & ~1);

    if (((PBCB)Bcb)->NodeTypeCode == CACHE_NTC_OBCB) {

        //
        //  If this is an overlapped BCB, use the first Vacb in the
        //  array
        //

        Vacb = ((POBCB)Bcb)->Bcbs[0]->Vacb;

    } else if (((PBCB)Bcb)->NodeTypeCode == CACHE_NTC_BCB) {

        //
        //  If this is a BCB, extract the Vcb from it
        //

        Vacb = ((PBCB)Bcb)->Vacb;

    } else {

        //
        //  Otherwise, there is no signature to match. Assume
        //  it is a Vacb.
        //

        Vacb = (PVACB) Bcb;
    }

    ASSERT((Vacb >= CcVacbs) && (Vacb < CcBeyondVacbs));

    //
    //  Safely bump the active count
    //

    CcAcquireVacbLock( &OldIrql );

    Vacb->Overlay.ActiveCount += 1;

    CcReleaseVacbLock( OldIrql );

    return (PVOID) ((ULONG_PTR)Vacb | 1);
}


VOID
CcRepinBcb (
    __in PVOID Bcb
    )

/*++

Routine Description:

    This routine may be called by a file system to pin a Bcb an additional
    time in order to reserve it for Write Through or error recovery.
    Typically the file system would do this the first time that it sets a
    pinned buffer dirty while processing a WriteThrough request, or any
    time that it determines that a buffer will be required for WriteThrough.

    The call to this routine must be followed by a call to CcUnpinRepinnedBcb.
    CcUnpinRepinnedBcb should normally be called during request completion
    after all other resources have been released.  CcUnpinRepinnedBcb
    synchronously writes the buffer (for WriteThrough requests) and performs
    the matching unpin for this call.

Arguments:

    Bcb - Supplies a pointer to a previously pinned Bcb

Return Value:

    None.

--*/

{
    KLOCK_QUEUE_HANDLE LockHandle;

    KeAcquireInStackQueuedSpinLock( &((PBCB)Bcb)->SharedCacheMap->BcbSpinLock, &LockHandle );

    ((PBCB)Bcb)->PinCount += 1;

    KeReleaseInStackQueuedSpinLock( &LockHandle );
}


VOID
CcUnpinRepinnedBcb (
    __in PVOID Bcb,
    __in BOOLEAN WriteThrough,
    __out PIO_STATUS_BLOCK IoStatus
    )

/*++

Routine Description:

    This routine may be called to Write a previously pinned buffer
    through to the file.  It must have been preceded by a call to
    CcRepinBcb.  As this routine must acquire the Bcb
    resource exclusive, the caller must be extremely careful to avoid
    deadlocks.  Ideally the caller owns no resources at all when it
    calls this routine, or else the caller should guarantee that it
    has nothing else pinned in this same file.  (The latter rule is
    the one used to avoid deadlocks in calls from CcCopyWrite and
    CcMdlWrite.)

Arguments:

    Bcb - Pointer to a Bcb which was previously specified in a call
          to CcRepinBcb.

    WriteThrough - TRUE if the Bcb should be written through.

    IoStatus - Returns the I/O status for the operation.

Return Value:

    None.

--*/

{
    PSHARED_CACHE_MAP SharedCacheMap = ((PBCB)Bcb)->SharedCacheMap;

    DebugTrace(+1, me, "CcUnpinRepinnedBcb\n", 0 );
    DebugTrace( 0, me, "    Bcb = %08lx\n", Bcb );
    DebugTrace( 0, me, "    WriteThrough = %02lx\n", WriteThrough );

    //
    //  Set status to success for non write through case.
    //

    IoStatus->Status = STATUS_SUCCESS;

    if (WriteThrough) {

        //
        //  Acquire Bcb exclusive to eliminate possible modifiers of the buffer,
        //  since we are about to write its buffer.
        //

        if (FlagOn(SharedCacheMap->Flags, MODIFIED_WRITE_DISABLED)) {
            ExAcquireResourceExclusiveLite( &((PBCB)Bcb)->Resource, TRUE );
        }

        //
        //  Now, there is a chance that the LazyWriter has already written
        //  it, since the resource was free.  We will only write it if it
        //  is still dirty.
        //

        if (((PBCB)Bcb)->Dirty) {

            //
            //  First we make sure that the dirty bit in the PFN database is set.
            //

            ASSERT( ((PBCB)Bcb)->BaseAddress != NULL );
            MmSetAddressRangeModified( ((PBCB)Bcb)->BaseAddress,
                                       ((PBCB)Bcb)->ByteLength );

            //
            //  Now release the Bcb resource and set it clean.  Note we do not check
            //  here for errors, and just return the I/O status.  Errors on writes
            //  are rare to begin with.  Nonetheless, our strategy is to rely on
            //  one or more of the following (depending on the file system) to prevent
            //  errors from getting to us.
            //
            //      - Retries and/or other forms of error recovery in the disk driver
            //      - Mirroring driver
            //      - Hot fixing in the noncached path of the file system
            //
            //  In the unexpected case that a write error does get through, we
            //  report it to our caller, but go ahead and set the Bcb clean.  There
            //  seems to be no point in letting Bcbs (and pages in physical memory)
            //  accumulate which can never go away because we get an unrecoverable I/O
            //  error.
            //

            //
            //  We specify TRUE here for ReadOnly so that we will keep the
            //  resource during the flush.
            //

            CcUnpinFileData( (PBCB)Bcb, TRUE, SET_CLEAN );

            //
            //  Write it out.
            //

            MmFlushSection( ((PBCB)Bcb)->SharedCacheMap->FileObject->SectionObjectPointer,
                            &((PBCB)Bcb)->FileOffset,
                            ((PBCB)Bcb)->ByteLength,
                            IoStatus,
                            MM_FLUSH_ACQUIRE_FILE );

            ASSERT( IoStatus->Status != STATUS_ENCOUNTERED_WRITE_IN_PROGRESS );

            //
            //  If we got verify required, we have to mark the buffer dirty again
            //  so we will try again later.
            //

            if (RetryError(IoStatus->Status)) {
                CcSetDirtyPinnedData( (PBCB)Bcb, NULL );
            }

            //
            //  Now remove the final pin count now that we have set it clean.
            //

            CcUnpinFileData( (PBCB)Bcb, FALSE, UNPIN );

            //
            //  See if there is any deferred writes we can post.
            //

            if (!IsListEmpty(&CcDeferredWrites)) {
                CcPostDeferredWrites();
            }
        }
        else {

            //
            //  Lazy Writer got there first, just free the resource and unpin.
            //

            CcUnpinFileData( (PBCB)Bcb, FALSE, UNPIN );

        }

        DebugTrace2(0, me, "    <IoStatus = %08lx, %08lx\n", IoStatus->Status,
                                                             IoStatus->Information );
    }

    //
    //  Non-WriteThrough case
    //

    else {

        CcUnpinFileData( (PBCB)Bcb, TRUE, UNPIN );

        //
        //  Set status to success for non write through case.
        //

        IoStatus->Status = STATUS_SUCCESS;
    }

    DebugTrace(-1, me, "CcUnpinRepinnedBcb -> VOID\n", 0 );
}


//
//  Internal Support Routine
//

BOOLEAN
CcFindBcb (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN PLARGE_INTEGER FileOffset,
    IN OUT PLARGE_INTEGER BeyondLastByte,
    OUT PBCB *Bcb
    )

/*++

Routine Description:

    This routine is called to find a Bcb describing the specified byte range
    of a file.  It returns TRUE if it could at least find a Bcb which describes
    the beginning of the specified byte range, or else FALSE if the first
    part of the byte range is not present.  In the latter case, the requested
    byte range (TrialLength) is truncated if there is currently a Bcb which
    describes bytes beyond the beginning of the byte range.

    The caller may see if the entire byte range is being returned by examining
    the Bcb, and the caller (or caller's caller) may then make subsequent
    calls if the data is not all returned.

    The BcbSpinLock must be currently acquired.

Arguments:

    SharedCacheMap - Supplies a pointer to the SharedCacheMap for the file
                     in which the byte range is desired.

    FileOffset - Supplies the file offset for the beginning of the desired
                 byte range.

    BeyondLastByte - Supplies the file offset of the ending of the desired
                  byte range + 1.  Note that this offset will be truncated
                  on return if the Bcb was not found, but bytes beyond the
                  beginning of the Bcb are contained in another Bcb.

    Bcb - returns a Bcb describing the beginning of the byte range if also
          returning TRUE, or else the point in the Bcb list to insert after.

Return Value:

    FALSE - if no Bcb describes the beginning of the desired byte range

    TRUE - if a Bcb is being returned describing at least an initial
           part of the byte range.

--*/

{
    PLIST_ENTRY BcbList;
    PBCB Bcbt;
    BOOLEAN Found = FALSE;

    DebugTrace(+1, me, "CcFindBcb:\n", 0 );
    DebugTrace( 0, me, "    SharedCacheMap = %08lx\n", SharedCacheMap );
    DebugTrace2(0, me, "    FileOffset = %08lx, %08lx\n", FileOffset->LowPart,
                                                          FileOffset->HighPart );
    DebugTrace2(0, me, "    TrialLength = %08lx, %08lx\n", TrialLength->LowPart,
                                                           TrialLength->HighPart );

    //
    //  We want to terminate scans by testing the NodeTypeCode field from the
    //  BcbLinks, so we want to see the SharedCacheMap signature from the same
    //  offset.
    //

    ASSERT(FIELD_OFFSET(SHARED_CACHE_MAP, BcbList) == FIELD_OFFSET(BCB, BcbLinks));

    //
    //  Similarly, when we hit one of the BcbListHeads in the array, small negative
    //  offsets are all structure pointers, so we are counting on the Bcb signature
    //  to have some non-Ulong address bits set.
    //

    ASSERT((CACHE_NTC_BCB & 3) != 0);

    //
    //  Get address of Bcb listhead that is *after* the Bcb we are looking for,
    //  for backwards scan.  It is important that we fail in the forward
    //  direction so that we are looking in the right segment of the Bcb list.
    //

    BcbList = CcGetBcbListHead( SharedCacheMap, 
                                FileOffset->QuadPart + SIZE_PER_BCB_LIST, 
                                TRUE );

    //
    //  Search for an entry that overlaps the specified range, or until we hit
    //  a listhead.
    //

    Bcbt = CONTAINING_RECORD(BcbList->Flink, BCB, BcbLinks);

    //
    //  First see if we really have to do Large arithmetic or not, and
    //  then use either a 32-bit loop or a 64-bit loop to search for
    //  the Bcb.
    //

    if (FileOffset->HighPart == 0 &&
        Bcbt->NodeTypeCode == CACHE_NTC_BCB &&
        Bcbt->BeyondLastByte.HighPart == 0) {

        //
        //  32-bit - loop until we get back to a listhead.
        //

        while (Bcbt->NodeTypeCode == CACHE_NTC_BCB) {

            //
            //  Since the Bcb list is in descending order, we first check
            //  if we are completely beyond the current entry, and if so
            //  get out.
            //

            if (FileOffset->LowPart >= Bcbt->BeyondLastByte.LowPart) {
                break;
            }

            //
            //  Next check if the first byte we are looking for is
            //  contained in the current Bcb.  If so, we either have
            //  a partial hit and must truncate to the exact amount
            //  we have found, or we may have a complete hit.  In
            //  either case we break with Found == TRUE.
            //

            if (FileOffset->LowPart >= Bcbt->FileOffset.LowPart) {
                Found = TRUE;
                break;
            }

            //
            //  Now we know we must loop back and keep looking, but we
            //  still must check for the case where the tail end of the
            //  bytes we are looking for are described by the current
            //  Bcb.  If so we must truncate what we are looking for,
            //  because this routine is only supposed to return bytes
            //  from the start of the desired range.
            //

            if (BeyondLastByte->LowPart >= Bcbt->FileOffset.LowPart) {
                BeyondLastByte->LowPart = Bcbt->FileOffset.LowPart;
            }

            //
            //  Advance to next entry in list (which is possibly back to
            //  the listhead) and loop back.
            //

            Bcbt = CONTAINING_RECORD( Bcbt->BcbLinks.Flink,
                                      BCB,
                                      BcbLinks );

        }

    } else {

        //
        //  64-bit - Loop until we get back to a listhead.
        //

        while (Bcbt->NodeTypeCode == CACHE_NTC_BCB) {

            //
            //  Since the Bcb list is in descending order, we first check
            //  if we are completely beyond the current entry, and if so
            //  get out.
            //

            if (FileOffset->QuadPart >= Bcbt->BeyondLastByte.QuadPart) {
                break;
            }

            //
            //  Next check if the first byte we are looking for is
            //  contained in the current Bcb.  If so, we either have
            //  a partial hit and must truncate to the exact amount
            //  we have found, or we may have a complete hit.  In
            //  either case we break with Found == TRUE.
            //

            if (FileOffset->QuadPart >= Bcbt->FileOffset.QuadPart) {
                Found = TRUE;
                break;
            }

            //
            //  Now we know we must loop back and keep looking, but we
            //  still must check for the case where the tail end of the
            //  bytes we are looking for are described by the current
            //  Bcb.  If so we must truncate what we are looking for,
            //  because this routine is only supposed to return bytes
            //  from the start of the desired range.
            //

            if (BeyondLastByte->QuadPart >= Bcbt->FileOffset.QuadPart) {
                BeyondLastByte->QuadPart = Bcbt->FileOffset.QuadPart;
            }

            //
            //  Advance to next entry in list (which is possibly back to
            //  the listhead) and loop back.
            //

            Bcbt = CONTAINING_RECORD( Bcbt->BcbLinks.Flink,
                                      BCB,
                                      BcbLinks );

        }
    }

    *Bcb = Bcbt;

    DebugTrace2(0, me, "    <TrialLength = %08lx, %08lx\n", TrialLength->LowPart,
                                                            TrialLength->HighPart );
    DebugTrace( 0, me, "    <Bcb = %08lx\n", *Bcb );
    DebugTrace(-1, me, "CcFindBcb -> %02lx\n", Found );

    return Found;
}


//
//  Internal Support Routine
//

PBCB
CcAllocateInitializeBcb (
    IN OUT PSHARED_CACHE_MAP SharedCacheMap OPTIONAL,
    IN OUT PBCB AfterBcb,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER TrialLength
    )

/*++

Routine Description:

    This routine allocates and initializes a Bcb to describe the specified
    byte range, and inserts it into the Bcb List of the specified Shared
    Cache Map.  The Bcb List spin lock must currently be acquired.

    BcbSpinLock must be acquired on entry.

Arguments:

    SharedCacheMap - Supplies the SharedCacheMap for the new Bcb.

    AfterBcb - Supplies where in the descending-order BcbList the new Bcb
               should be inserted: either the ListHead (masquerading as
               a Bcb) or a Bcb.

    FileOffset - Supplies File Offset for the desired data.

    TrialLength - Supplies length of desired data.

Return Value:

    Address of the allocated and initialized Bcb

--*/

{
    PBCB Bcb;
    ULONG RoundedBcbSize = (sizeof(BCB) + 7) & ~7;

    if ((Bcb = ExAllocatePoolWithTag( NonPagedPool, sizeof(BCB), 'cBcC')) == NULL) {
        
        return NULL;
    }

    //
    //  Initialize the newly allocated Bcb.  First zero it, then fill in
    //  nonzero fields.
    //

    RtlZeroMemory( Bcb, RoundedBcbSize );

    //
    //  For Mbcb's, SharedCacheMap is NULL, and the rest of this initialization
    //  is not desired.
    //

    if (SharedCacheMap != NULL) {

        Bcb->NodeTypeCode = CACHE_NTC_BCB;
        Bcb->FileOffset = *FileOffset;
        Bcb->ByteLength = TrialLength->LowPart;
        Bcb->BeyondLastByte.QuadPart = FileOffset->QuadPart + TrialLength->QuadPart;
        Bcb->PinCount += 1;
        ExInitializeResourceLite( &Bcb->Resource );
        Bcb->SharedCacheMap = SharedCacheMap;

        //
        //  Since CcCalculateVacbLockCount has to be able to walk
        //  the BcbList with only the VacbSpinLock, we take that one
        //  out to change the list and set the count.
        //

        CcAcquireVacbLockAtDpcLevel();
        InsertTailList( &AfterBcb->BcbLinks, &Bcb->BcbLinks );

        ASSERT( (SharedCacheMap->SectionSize.QuadPart < VACB_SIZE_OF_FIRST_LEVEL) ||
                (CcFindBcb(SharedCacheMap, FileOffset, &Bcb->BeyondLastByte, &AfterBcb) &&
                 (Bcb == AfterBcb)) );

        //
        //  Now for large metadata streams we lock the Vacb level.
        //

        CcLockVacbLevel( SharedCacheMap, FileOffset->QuadPart );
        CcReleaseVacbLockFromDpcLevel();

        //
        //  If this resource was no write behind, let Ex know that the
        //  resource will never be acquired exclusive.  Also disable boost.
        //

        if (SharedCacheMap &&
            FlagOn(SharedCacheMap->Flags, DISABLE_WRITE_BEHIND)) {
#if DBG
            SetFlag(Bcb->Resource.Flag, ResourceNeverExclusive);
#endif
            ExDisableResourceBoost( &Bcb->Resource );
        }
    }

    return Bcb;
}


//
//  Internal support routine
//

VOID
FASTCALL
CcDeallocateBcb (
    IN PBCB Bcb
    )

/*++

Routine Description:

    This routine deallocates a Bcb to the BcbZone.  It must
    already be removed from the BcbList.

Arguments:

    Bcb - the Bcb to deallocate

Return Value:

    None

--*/

{
    //
    //  Deallocate Resource structures
    //

    if (Bcb->NodeTypeCode == CACHE_NTC_BCB) {

        ExDeleteResourceLite( &Bcb->Resource );
    }

    ExFreePool(Bcb);
    return;
}


//
//  Internal Support Routine
//

BOOLEAN
CcMapAndRead(
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG ZeroFlags,
    IN BOOLEAN Wait,
    IN PVOID BaseAddress
    )

/*++

Routine Description:

    This routine may be called to ensure that the specified data is mapped,
    read into memory and locked.  If TRUE is returned, then the
    correct I/O status for the transfer is also returned, along with
    a system-space address for the data.

Arguments:

    SharedCacheMap - Supplies the address of the SharedCacheMap for the
                     data.

    FileOffset - Supplies the file offset of the desired data.

    Length - Supplies the total amount of data desired.

    ZeroFlags - Defines which pages may be zeroed if not resident.

    Wait - Supplies FALSE if the caller is not willing to block for the
           data, or TRUE if the caller is willing to block.

    BaseAddress - Supplies the system base address at which the data may
                  be accessed.

Return Value:

    FALSE - if the caller supplied Wait = FALSE and the data could not
            be returned without blocking.

    TRUE - if the data is being returned.

    Note: this routine may raise an exception due to a map or read failure,
          however, this can only happen if Wait was specified as TRUE, since
          mapping and reading will not be performed if the caller cannot wait.

--*/

{
    ULONG ZeroCase;
    ULONG SavedState;
    BOOLEAN Result = FALSE;
    PETHREAD Thread = PsGetCurrentThread();

    UNREFERENCED_PARAMETER (SharedCacheMap);
    UNREFERENCED_PARAMETER (FileOffset);

    MmSavePageFaultReadAhead( Thread, &SavedState );

    //
    //  try around everything for cleanup.
    //

    try {

        ULONG PagesToGo;

        //
        //  Now loop to touch all of the pages, calling MM to ensure
        //  that if we fault, we take in exactly the number of pages
        //  we need.
        //

        PagesToGo = ADDRESS_AND_SIZE_TO_SPAN_PAGES( BaseAddress, Length );

        //
        //  Loop to touch or zero the pages.
        //

        ZeroCase = ZERO_FIRST_PAGE;

        while (PagesToGo) {

            //
            //  If we cannot zero this page, or Mm failed to return
            //  a zeroed page, then just fault it in.
            //

            MmSetPageFaultReadAhead( Thread, (PagesToGo - 1) );

            if (!FlagOn(ZeroFlags, ZeroCase) ||
                !MmCheckCachedPageState(BaseAddress, TRUE)) {

                //
                //  If we get here, it is almost certainly due to the fact
                //  that we can not take a zero page.  MmCheckCachedPageState
                //  will so rarely return FALSE, that we will not worry
                //  about it.  We will only check if the page is there if
                //  Wait is FALSE, so that we can do the right thing.
                //

                if (!MmCheckCachedPageState(BaseAddress, FALSE) && !Wait) {
                    try_return( Result = FALSE );
                }
            }

            BaseAddress = (PCHAR)BaseAddress + PAGE_SIZE;
            PagesToGo -= 1;

            if (PagesToGo == 1) {
                ZeroCase = ZERO_LAST_PAGE;
            } else {
                ZeroCase = ZERO_MIDDLE_PAGES;
            }
        }

        try_return( Result = TRUE );

    try_exit: NOTHING;
    }

    //
    //  Cleanup on the way out.
    //

    finally {

        MmResetPageFaultReadAhead(Thread, SavedState);
    }

    return Result;
}


//
//  Internal Support Routine
//

VOID
CcFreeActiveVacb (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN PVACB ActiveVacb OPTIONAL,
    IN ULONG ActivePage,
    IN ULONG PageIsDirty
    )

/*++

Routine Description:

    This routine may be called to zero the end of a locked page or
    free the ActiveVacb for a Shared Cache Map, if there is one.
    Note that some callers are not synchronized with foreground
    activity, and may therefore not have an ActiveVacb.  Examples
    of unsynchronized callers are CcZeroEndOfLastPage (which is
    called by MM) and any flushing done by CcWriteBehind.

Arguments:

    SharedCacheMap - SharedCacheMap to examine for page to be zeroed.

    ActiveVacb - Vacb to free

    ActivePage - Page that was used

    PageIsDirty - ACTIVE_PAGE_IS_DIRTY if the active page is dirty

Return Value:

    None

--*/

{
    LARGE_INTEGER ActiveOffset;
    PVOID ActiveAddress;
    ULONG BytesLeftInPage;
    KIRQL OldIrql;

    //
    //  If the page was locked, then unlock it.
    //

    if (SharedCacheMap->NeedToZero != NULL) {

        PVACB NeedToZeroVacb;

        //
        //  Zero the rest of the page under spinlock control,
        //  and then clear the address field.  This field makes
        //  zero->nonzero transitions only when the file is exclusive,
        //  but it can make nonzero->zero transitions any time the
        //  spinlock is not held.
        //

        ExAcquireFastLock( &SharedCacheMap->ActiveVacbSpinLock, &OldIrql );

        //
        //  The address could already be gone.
        //

        ActiveAddress = SharedCacheMap->NeedToZero;
        if (ActiveAddress != NULL) {

            BytesLeftInPage = PAGE_SIZE - ((((ULONG)((ULONG_PTR)ActiveAddress) - 1) & (PAGE_SIZE - 1)) + 1);

            RtlZeroBytes( ActiveAddress, BytesLeftInPage );
            NeedToZeroVacb = SharedCacheMap->NeedToZeroVacb;
            ASSERT( NeedToZeroVacb != NULL );
            SharedCacheMap->NeedToZero = NULL;

        }
        ExReleaseFastLock( &SharedCacheMap->ActiveVacbSpinLock, OldIrql );

        //
        //  Now call MM to unlock the address.  Note we will never store the
        //  address at the start of the page, but we can sometimes store
        //  the start of the next page when we have exactly filled the page.
        //

        if (ActiveAddress != NULL) {
            MmUnlockCachedPage( (PVOID)((PCHAR)ActiveAddress - 1) );
            CcFreeVirtualAddress( NeedToZeroVacb );
        }
    }

    //
    //  See if caller actually has an ActiveVacb
    //

    if (ActiveVacb != NULL) {

        //
        //  See if the page is dirty
        //

        if (PageIsDirty) {

            ActiveOffset.QuadPart = (LONGLONG)ActivePage << PAGE_SHIFT;
            ActiveAddress = (PVOID)((PCHAR)ActiveVacb->BaseAddress +
                                    (ActiveOffset.LowPart  & (VACB_MAPPING_GRANULARITY - 1)));

            //
            //  Tell the Lazy Writer to write the page.
            //

            CcSetDirtyInMask( SharedCacheMap, &ActiveOffset, PAGE_SIZE );

            //
            //  Now we need to clear the flag and decrement some counts if there is
            //  no other active Vacb which snuck in.
            //

            CcAcquireMasterLock( &OldIrql );
            ExAcquireSpinLockAtDpcLevel( &SharedCacheMap->ActiveVacbSpinLock );
            if ((SharedCacheMap->ActiveVacb == NULL) &&
                FlagOn(SharedCacheMap->Flags, ACTIVE_PAGE_IS_DIRTY)) {

                ClearFlag(SharedCacheMap->Flags, ACTIVE_PAGE_IS_DIRTY);
                CcDeductDirtyPages( SharedCacheMap, 1);
            }
            ExReleaseSpinLockFromDpcLevel( &SharedCacheMap->ActiveVacbSpinLock );
            CcReleaseMasterLock( OldIrql );
        }

        //
        //  Now free the Vacb.
        //

        CcFreeVirtualAddress( ActiveVacb );
    }
}


//
//  Internal Support Routine
//

BOOLEAN
CcMapAndCopy(
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN PVOID UserBuffer,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG OptimizeFlags,
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER ValidDataLength,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    This routine may be called to copy the specified user data to the
    cache via a special Mm routine which copies the data to uninitialized
    pages and returns.

Arguments:

    SharedCacheMap - Supplies the address of the SharedCacheMap for the
                     data.

    UserBuffer - unsafe buffer supplying the user's data to be written

    FileOffset - Supplies the file offset to be modified

    Length - Supplies the total amount of data

    OptimizeFlags - Defines which pages can use the MmCopyToCachedPage
        optimization.

    FileObject - Supplies the file object being written to

    ValidDataLength - The file system's current record of this files valid
        data length.  This is used to know if we can use a zero page when
        using the MmCopyToCachedPage optimization.

    Wait - FALSE if caller may not block, TRUE otherwise

Return Value:

    FALSE - if the caller supplied Wait = FALSE and the data could not
            be returned without blocking.

    TRUE - if the data is being returned.

--*/

{
    ULONG ReceivedLength;
    ULONG OptimizeCase;
    PVOID CacheBuffer;
    PVOID SavedMappedBuffer;
    ULONG SavedMappedLength;
    ULONG ActivePage;
    KIRQL OldIrql;
    LARGE_INTEGER PFileOffset;
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS Status;
    ULONG SavedState;
    LOGICAL MorePages;
    BOOLEAN WriteThrough = BooleanFlagOn( FileObject->Flags, FO_WRITE_THROUGH );
    ULONG SavedTotalLength = Length;
    LARGE_INTEGER LocalOffset;
    ULONG PageOffset = FileOffset->LowPart & (PAGE_SIZE - 1);
    PVACB Vacb = NULL;
    PETHREAD Thread = PsGetCurrentThread();
    BOOLEAN Result = FALSE;

    //
    //  Initialize SavePage to TRUE to skip the finally clause on zero-length
    //  writes.
    //

    BOOLEAN SavePage = TRUE;

    //
    //  PREfix needs to see this explicitly, as opposed to a structure copy.
    //

    LocalOffset.QuadPart = FileOffset->QuadPart;

    DebugTrace(+1, me, "CcMapAndCopy:\n", 0 );
    DebugTrace( 0, me, "    SharedCacheMap = %08lx\n", SharedCacheMap );
    DebugTrace2(0, me, "    FileOffset = %08lx, %08lx\n", FileOffset->LowPart,
                                                          FileOffset->HighPart );
    DebugTrace( 0, me, "    Length = %08lx\n", Length );

    MmSavePageFaultReadAhead( Thread, &SavedState );

    //
    //  See if we need to force write through.  If the file object is of remote origin,
    //  it has been exempted from throttling.  As a result, it is possible that too
    //  many pages will get dirty.  In order to prevent this, we force write through
    //  on these file objects if we would have throttled them in the first place.
    //

    if (!WriteThrough) {

        WriteThrough = CcForceWriteThrough( FileObject, 
                                            Length,
                                            SharedCacheMap,
                                            TRUE );
    }

    //
    //  If this is a WriteThrough operation, return FALSE here if the caller 
    //  cannot block since the flushes necessary for WriteThrough will be 
    //  synchronous.  This will more accurately honor the Wait == FALSE request.
    //

    if (WriteThrough && !Wait) {

        return FALSE;
    }

    //
    //  try around everything for cleanup.
    //

    try {

        while (Length != 0) {

            SavedMappedLength = 0;
            CacheBuffer = CcGetVirtualAddress( SharedCacheMap,
                                               LocalOffset,
                                               &Vacb,
                                               &ReceivedLength );

            //
            //  PREfix wants to know this cannot be NULL, otherwise it
            //  will complain.
            //

            ASSERT( CacheBuffer != NULL );

            //
            //  If we got more than we need, make sure to only use
            //  the right amount.
            //

            if (ReceivedLength > Length) {
                ReceivedLength = Length;
            }
            SavedMappedBuffer = CacheBuffer;
            SavedMappedLength = ReceivedLength;
            Length -= ReceivedLength;

            //
            //  Now loop to touch all of the pages, calling MM to ensure
            //  that if we fault, we take in exactly the number of pages
            //  we need.
            //

            CacheBuffer = (PVOID)((PCHAR)CacheBuffer - PageOffset);
            ReceivedLength += PageOffset;

            //
            //  Loop to touch or zero the pages.
            //

            OptimizeCase = OPTIMIZE_FIRST_PAGE;

            //
            //  Set up offset to page for use below.
            //

            PFileOffset = LocalOffset;
            PFileOffset.LowPart -= PageOffset;

            while (TRUE) {

                //
                //  Calculate whether we wish to save an active page
                //  or not.
                //

                SavePage = (BOOLEAN) ((Length == 0) &&
                            (ReceivedLength < PAGE_SIZE) &&
                            (SavedTotalLength <= (PAGE_SIZE / 2)) &&
                            !WriteThrough);

                MorePages = (ReceivedLength > PAGE_SIZE);

                //
                //  Copy the data to the user buffer.
                //

                //
                //  It is possible that there is a locked page
                //  hanging around, and so we need to delete it here.
                //

                if (SharedCacheMap->NeedToZero != NULL) {
                    CcFreeActiveVacb( SharedCacheMap, NULL, 0, 0 );
                }

                Status = STATUS_SUCCESS;
                if (FlagOn(OptimizeFlags, OptimizeCase)) {

                    Status = MmCopyToCachedPage( CacheBuffer,
                                                 UserBuffer,
                                                 PageOffset,
                                                 MorePages ?
                                                   (PAGE_SIZE - PageOffset) :
                                                   (ReceivedLength - PageOffset),
                                                 (PFileOffset.QuadPart >= ValidDataLength->QuadPart) ?
                                                   TRUE :
                                                   FALSE );

                    if (!NT_SUCCESS (Status)) {

                        //
                        //  We got some error -- this indicates that
                        //  the user buffer was invalid, so we will raise 
                        //  here.
                        //

                        ExRaiseStatus( FsRtlNormalizeNtstatus( Status,
                                                               STATUS_INVALID_USER_BUFFER ));
                    }
                    
                //
                //  Otherwise, we have to actually copy the data ourselves after
                //  checking whether or not the page is resident.
                //

                } else {

                    MmSetPageFaultReadAhead( Thread,
                                             (MorePages && FlagOn(OptimizeFlags, OPTIMIZE_LAST_PAGE)) ? 1 : 0);

                    if (!MmCheckCachedPageState(CacheBuffer, FALSE) && !Wait) {

                        //
                        //  The page is not resident and the caller does not
                        //  want to wait, so we will just return here.
                        //
                        
                        try_return( Result = FALSE );

                    } else {

                        try {

                            RtlCopyBytes( (PVOID)((PCHAR)CacheBuffer + PageOffset),
                                          UserBuffer,
                                          MorePages ?
                                            (PAGE_SIZE - PageOffset) :
                                            (ReceivedLength - PageOffset) );

                        } except( CcCopyReadExceptionFilter( GetExceptionInformation(),
                                                             &Status ) ) {

                            //
                            //  If we got an access violation, then the user buffer went
                            //  away.  Otherwise we must have gotten an I/O error trying
                            //  to bring the data in.
                            //

                            if (Status == STATUS_ACCESS_VIOLATION) {
                                ExRaiseStatus( STATUS_INVALID_USER_BUFFER );
                            }
                            else {
                                ExRaiseStatus( FsRtlNormalizeNtstatus( Status,
                                                                       STATUS_UNEXPECTED_IO_ERROR ));
                            }
                        }
                    }

                    MmResetPageFaultReadAhead( Thread, SavedState );
                }

                //
                //  Now get out quickly if it is a small write and we want
                //  to save the page.
                //

                if (SavePage) {

                    ActivePage = (ULONG)( Vacb->Overlay.FileOffset.QuadPart >> PAGE_SHIFT ) +
                                 (ULONG)(((PCHAR)CacheBuffer - (PCHAR)Vacb->BaseAddress) >>
                                   PAGE_SHIFT);

                    PFileOffset.LowPart += ReceivedLength;

                    SetActiveVacb( SharedCacheMap,
                                   OldIrql,
                                   Vacb,
                                   ActivePage,
                                   ACTIVE_PAGE_IS_DIRTY );

                    //
                    //  Must set the VACB to NULL here because we do not want to
                    //  unmap it below.
                    //
                    
                    Vacb = NULL;

                    try_return( Result = TRUE );
                }

                //
                //  If it looks like we may save a page and exit on the next loop,
                //  then we must make sure to mark the current page dirty.  Note
                //  that Cc[Fast]CopyWrite will finish the last part of any page
                //  before allowing us to free the Active Vacb above, therefore
                //  this case only occurs for a small random write.
                //

                if ((SavedTotalLength <= (PAGE_SIZE / 2)) && !WriteThrough) {

                    CcSetDirtyInMask( SharedCacheMap, &PFileOffset, ReceivedLength );
                }

                UserBuffer = (PVOID)((PCHAR)UserBuffer + (PAGE_SIZE - PageOffset));
                PageOffset = 0;

                //
                //  If there is more than a page to go (including what we just
                //  copied), then adjust our buffer pointer and counts, and
                //  determine if we are to the last page yet.
                //

                if (MorePages) {

                    CacheBuffer = (PCHAR)CacheBuffer + PAGE_SIZE;
                    ReceivedLength -= PAGE_SIZE;

                    //
                    //  Update our offset to the page.  Note that 32-bit
                    //  add is ok since we cannot cross a Vacb boundary
                    //  and we reinitialize this offset before entering
                    //  this loop again.
                    //

                    PFileOffset.LowPart += PAGE_SIZE;

                    //
                    //  Update what region of the file we are currently working
                    //  on.
                    //

                    if (ReceivedLength > PAGE_SIZE) {
                        OptimizeCase = OPTIMIZE_MIDDLE_PAGES;
                    } else {
                        OptimizeCase = OPTIMIZE_LAST_PAGE;
                    }

                } else {

                    break;
                }
            }

            //
            //  If there is still more to write (ie. we are going to step
            //  onto the next vacb) AND we just dirtied more than 64K, then
            //  do a vicarious MmFlushSection here.  This prevents us from
            //  creating unlimited dirty pages while holding the file
            //  resource exclusive.  We also do not need to set the pages
            //  dirty in the mask in this case.
            //

            if (Length > CcMaxDirtyWrite) {

                MmSetAddressRangeModified( SavedMappedBuffer, SavedMappedLength );
                MmFlushSection( SharedCacheMap->FileObject->SectionObjectPointer,
                                &LocalOffset,
                                SavedMappedLength,
                                &IoStatus,
                                MM_FLUSH_ACQUIRE_FILE );

                ASSERT( IoStatus.Status != STATUS_ENCOUNTERED_WRITE_IN_PROGRESS );

                if (!NT_SUCCESS(IoStatus.Status)) {
                    ExRaiseStatus( FsRtlNormalizeNtstatus( IoStatus.Status,
                                                           STATUS_UNEXPECTED_IO_ERROR ));
                }

            //
            //  For write through files, call Mm to propagate the dirty bits
            //  here while we have the view mapped, so we know the flush will
            //  work below.  Again - do not set dirty in the mask.
            //

            } else if (WriteThrough) {

                MmSetAddressRangeModified( SavedMappedBuffer, SavedMappedLength );

            //
            //  For the normal case, just set the pages dirty for the Lazy Writer
            //  now.
            //

            } else {

                CcSetDirtyInMask( SharedCacheMap, &LocalOffset, SavedMappedLength );
            }

            CcFreeVirtualAddress( Vacb );
            Vacb = NULL;

            //
            //  If we have to loop back to get at least a page, it will be ok to
            //  try to optimize our write to the first page.  If we are not 
            //  getting at least a page, we must make sure we clear the 
            //  OptimizeFlags if we cannot optimize the last page.
            //

            if (Length >= PAGE_SIZE) {
                OptimizeFlags |= OPTIMIZE_FIRST_PAGE;
            } else if (!FlagOn( OptimizeFlags, OPTIMIZE_LAST_PAGE )) {
                OptimizeFlags = 0;
            }

            //
            //  Note that if ReceivedLength (and therefore SavedMappedLength)
            //  was truncated to the transfer size then the new LocalOffset
            //  computed below is not correct.  This is not an issue since
            //  in that case (Length == 0) and we would never get here.
            //

            LocalOffset.QuadPart = LocalOffset.QuadPart + (LONGLONG)SavedMappedLength;
        }

        try_return( Result = TRUE );
        
    try_exit: NOTHING;
    }

    //
    //  Cleanup on the way out.
    //

    finally {

        MmResetPageFaultReadAhead( Thread, SavedState );

        //
        //  Make sure that we do not leave the Vacb mapped if it is non-null.
        //

        if (Vacb != NULL) {

            CcFreeVirtualAddress( Vacb );
        }

        //
        //  We have no work to do if we have squirreled away the Vacb.
        //

        if (!SavePage || AbnormalTermination()) {

            //
            //  If this is write through, flush the whole range.
            //

            if (WriteThrough) {

                if (AbnormalTermination() && (0 != SavedMappedLength)) {

                    //
                    //  If we have hit an exception, we need to assume that all
                    //  the pages we were currently working on were modified.
                    //  Mark them as such so they will get flushed.
                    //

                    MmSetAddressRangeModified( SavedMappedBuffer, SavedMappedLength );
                }

                MmFlushSection ( SharedCacheMap->FileObject->SectionObjectPointer,
                                 FileOffset,
                                 SavedTotalLength,
                                 &IoStatus,
                                 MM_FLUSH_ACQUIRE_FILE );

                ASSERT( IoStatus.Status != STATUS_ENCOUNTERED_WRITE_IN_PROGRESS );

                //
                //  If we successfully flushed the file, move forward
                //  ValidDataGoal.  Otherwise, if we get an error we will
                //  raise the error only if we are not already handling an
                //  exception.  If we raised again, we would get into an endless
                //  recursive loop of executing this finally handler.
                //

                if (NT_SUCCESS( IoStatus.Status )) {

                    //
                    //  Advance ValidDataGoal if we successfully flushed.
                    //

                    LocalOffset.QuadPart = FileOffset->QuadPart + (LONGLONG)SavedTotalLength;
                    if (LocalOffset.QuadPart > SharedCacheMap->ValidDataGoal.QuadPart) {
                        SharedCacheMap->ValidDataGoal = LocalOffset;
                    }

                } else {
                    
                    if (!AbnormalTermination()) {

                        ExRaiseStatus( FsRtlNormalizeNtstatus( IoStatus.Status,
                                                               STATUS_UNEXPECTED_IO_ERROR ));
                    }
                }
            } 
            else if (AbnormalTermination() && (0 != SavedMappedLength)) {

                //
                //  If we have hit an exception, we need to mark the last
                //  range we were working on as dirty.  Any range we successfully
                //  copied will have already been marked dirty.
                //
                
                CcSetDirtyInMask( SharedCacheMap, &LocalOffset, SavedMappedLength );
            }
        }
    }

    DebugTrace(-1, me, "CcMapAndCopy -> %02lx\n", Result );

    return Result;
}


BOOLEAN
CcLogError(
    IN PFILE_OBJECT FileObject,
    IN PUNICODE_STRING FileName,
    IN NTSTATUS Error,
    IN NTSTATUS DeviceError,
    IN UCHAR IrpMajorCode
    )

/*++

Routine Description:

    This routine writes an eventlog entry to the eventlog.

Arguments:

    FileObject - The fileobject in whose context the error occured.

    FileName - The filename to use in logging the error (usually the DOS-side name)

    Error - The error to log in the eventlog record

    DeviceError - The actual error that occured in the device - will be logged
                  as user data

Return Value:

    True if successful, false if internal memory allocation failed

--*/

{
    UCHAR ErrorPacketLength;
    UCHAR BasePacketLength;
    ULONG StringLength;
    PIO_ERROR_LOG_PACKET ErrorLogEntry = NULL;
    BOOLEAN Result = FALSE;
    PWCHAR String;

    PAGED_CODE();

    //
    //  Get our error packet, holding the string and status code.  Note we log against the
    //  true filesystem if this is available.
    //
    //  The sizing of the packet is a bit slimy since the dumpdata is already grown by a
    //  ULONG onto the end of the packet.  Since NTSTATUS is ULONG, well, we just work in
    //  place.
    //

    BasePacketLength = sizeof(IO_ERROR_LOG_PACKET);
    if ((BasePacketLength + FileName->Length + sizeof(WCHAR)) <= ERROR_LOG_MAXIMUM_SIZE) {
        ErrorPacketLength = (UCHAR)(BasePacketLength + FileName->Length + sizeof(WCHAR));
    } else {
        ErrorPacketLength = ERROR_LOG_MAXIMUM_SIZE;
    }

    ErrorLogEntry = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry( (FileObject->Vpb ?
                                                                     FileObject->Vpb->DeviceObject :
                                                                     FileObject->DeviceObject),
                                                                    ErrorPacketLength );
    if (ErrorLogEntry) {

        //
        //  Fill in the nonzero members of the packet.
        //

        ErrorLogEntry->MajorFunctionCode = IrpMajorCode;
        ErrorLogEntry->ErrorCode = Error;
        ErrorLogEntry->FinalStatus = DeviceError;

        ErrorLogEntry->DumpDataSize = sizeof(NTSTATUS);
        RtlCopyMemory( &ErrorLogEntry->DumpData, &DeviceError, sizeof(NTSTATUS) );

        //
        //  The filename string is appended to the end of the error log entry. We may
        //  have to smash the middle to fit it in the limited space.
        //

        StringLength = ErrorPacketLength - BasePacketLength - sizeof(WCHAR);

        ASSERT(!(StringLength % sizeof(WCHAR)));

        String = (PWCHAR) ((PUCHAR)ErrorLogEntry + BasePacketLength);
        ErrorLogEntry->NumberOfStrings = 1;
        ErrorLogEntry->StringOffset = BasePacketLength;

        //
        //  If the name does not fit in the packet, divide the name equally to the
        //  prefix and suffix, with an ellipsis " .. " (4 wide characters) to indicate
        //  the loss.
        //

        if (StringLength < FileName->Length) {

            //
            //  Remember, prefix + " .. " + suffix is the length.  Calculate by figuring
            //  the prefix and then get the suffix by whacking the ellipsis and prefix off
            //  the total.
            //
            
            ULONG NamePrefixSegmentLength = ((StringLength/sizeof(WCHAR))/2 - 2)*sizeof(WCHAR);
            ULONG NameSuffixSegmentLength = StringLength - 4*sizeof(WCHAR) - NamePrefixSegmentLength;

            ASSERT(!(NamePrefixSegmentLength % sizeof(WCHAR)));
            ASSERT(!(NameSuffixSegmentLength % sizeof(WCHAR)));

            RtlCopyMemory( String,
                           FileName->Buffer,
                           NamePrefixSegmentLength );
            String = (PWCHAR)((PCHAR)String + NamePrefixSegmentLength);

            RtlCopyMemory( String,
                           L" .. ",
                           4*sizeof(WCHAR) );
            String += 4;

            RtlCopyMemory( String,
                           (PUCHAR)FileName->Buffer +
                           FileName->Length - NameSuffixSegmentLength,
                           NameSuffixSegmentLength );
            String = (PWCHAR)((PCHAR)String + NameSuffixSegmentLength);

        } else {
            
            RtlCopyMemory( String,
                           FileName->Buffer,
                           FileName->Length );
            String += FileName->Length/sizeof(WCHAR);
        }

        //
        //  Null terminate the string and send the packet.
        //

        *String = L'\0';

        IoWriteErrorLogEntry( ErrorLogEntry );
        Result = TRUE;
    }

    return Result;
}


LOGICAL
CcHasInactiveViews (
    VOID
    )

/*++

Routine Description:

    This routine is called by Memory Management only to query if the system
    cache has any inactive views.  If so, Memory Management may issue a
    subsequent call to CcUnmapInactiveViews to discard these views in an
    attempt to reclaim the prototype PTE pool (and other resources tied to
    the section).

Arguments:

    None.

Return Value:

    TRUE if Cc has any views it can discard, FALSE if not.

Environment:

    Arbitrary thread context, generally APC_LEVEL or DISPATCH_LEVEL.  Various
    mutexes and/or spinlocks may be held by the caller.

--*/

{
    return FALSE;
}


LOGICAL
CcUnmapInactiveViews (
    IN ULONG NumberOfViewsToUnmap
    )

/*++

Routine Description:

    This routine is called by Memory Management to request that the cache
    manager unmap a number of inactive views.  This call is generally made
    because the system is low on pool (paged or nonpaged).

    Discarding these views is done in an attempt to reclaim the prototype
    PTE pool (and other resources tied to the section).

Arguments:

    NumberOfViewsToUnmap - Supplies the desired number of views to unmap.

Return Value:

    TRUE if Cc discarded *ANY* views, FALSE if not.

Environment:

    Dereference segment thread context at PASSIVE_LEVEL.

--*/

{
    UNREFERENCED_PARAMETER (NumberOfViewsToUnmap);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\cache\copysup.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    copysup.c

Abstract:

    This module implements the copy support routines for the Cache subsystem.

--*/

#include "cc.h"

//
//  Define our debug constant
//

#define me 0x00000004

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CcCopyRead)
#pragma alloc_text(PAGE,CcFastCopyRead)
#endif


BOOLEAN
CcCopyRead (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in BOOLEAN Wait,
    __out_bcount(Length) PVOID Buffer,
    __out PIO_STATUS_BLOCK IoStatus
    )

/*++

Routine Description:

    This routine attempts to copy the specified file data from the cache
    into the output buffer, and deliver the correct I/O status.  It is *not*
    safe to call this routine from Dpc level.

    If the caller does not want to block (such as for disk I/O), then
    Wait should be supplied as FALSE.  If Wait was supplied as FALSE and
    it is currently impossible to supply all of the requested data without
    blocking, then this routine will return FALSE.  However, if the
    data is immediately accessible in the cache and no blocking is
    required, this routine copies the data and returns TRUE.

    If the caller supplies Wait as TRUE, then this routine is guaranteed
    to copy the data and return TRUE.  If the data is immediately
    accessible in the cache, then no blocking will occur.  Otherwise,
    the the data transfer from the file into the cache will be initiated,
    and the caller will be blocked until the data can be returned.

    File system Fsd's should typically supply Wait = TRUE if they are
    processing a synchronous I/O requests, or Wait = FALSE if they are
    processing an asynchronous request.

    File system or Server Fsp threads should supply Wait = TRUE.

Arguments:

    FileObject - Pointer to the file object for a file which was
                 opened with NO_INTERMEDIATE_BUFFERING clear, i.e., for
                 which CcInitializeCacheMap was called by the file system.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Wait - FALSE if caller may not block, TRUE otherwise (see description
           above)

    Buffer - Pointer to output buffer to which data should be copied.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.  (STATUS_SUCCESS guaranteed for cache
               hits, otherwise the actual I/O status is returned.)

               Note that even if FALSE is returned, the IoStatus.Information
               field will return the count of any bytes successfully
               transferred before a blocking condition occured.  The caller
               may either choose to ignore this information, or resume
               the copy later accounting for bytes transferred.

Return Value:

    FALSE - if Wait was supplied as FALSE and the data was not delivered

    TRUE - if the data is being delivered

--*/

{
    PSHARED_CACHE_MAP SharedCacheMap;
    PPRIVATE_CACHE_MAP PrivateCacheMap;
    PVOID CacheBuffer;
    LARGE_INTEGER FOffset;
    PVACB Vacb;
    PBCB Bcb;
    PVACB ActiveVacb;
    ULONG ActivePage;
    ULONG PageIsDirty;
    ULONG SavedState;
    ULONG PagesToGo;
    ULONG MoveLength;
    ULONG LengthToGo;
    NTSTATUS Status;
    ULONG OriginalLength = Length;
    PETHREAD Thread = PsGetCurrentThread();
    ULONG GotAMiss = 0;

    DebugTrace(+1, me, "CcCopyRead\n", 0 );

    MmSavePageFaultReadAhead( Thread, &SavedState );

    //
    //  Get pointer to shared and private cache maps
    //

    SharedCacheMap = FileObject->SectionObjectPointer->SharedCacheMap;
    PrivateCacheMap = FileObject->PrivateCacheMap;

    //
    //  Check for read past file size, the caller must filter this case out.
    //

    ASSERT( ( FileOffset->QuadPart + (LONGLONG)Length) <= SharedCacheMap->FileSize.QuadPart );

    //
    //  If read ahead is enabled, then do the read ahead here so it
    //  overlaps with the copy (otherwise we will do it below).
    //  Note that we are assuming that we will not get ahead of our
    //  current transfer - if read ahead is working it should either
    //  already be in memory or else underway.
    //

    if (PrivateCacheMap->Flags.ReadAheadEnabled && (PrivateCacheMap->ReadAheadLength[1] == 0)) {
        CcScheduleReadAhead( FileObject, FileOffset, Length );
    }

    FOffset = *FileOffset;

    //
    //  Increment performance counters
    //

    if (Wait) {
        HOT_STATISTIC(CcCopyReadWait) += 1;

        //
        //  This is not an exact solution, but when IoPageRead gets a miss,
        //  it cannot tell whether it was CcCopyRead or CcMdlRead, but since
        //  the miss should occur very soon, by loading the pointer here
        //  probably the right counter will get incremented, and in any case,
        //  we hope the errors average out!
        //

        CcMissCounter = &CcCopyReadWaitMiss;

    } else {
        HOT_STATISTIC(CcCopyReadNoWait) += 1;
    }

    //
    //  See if we have an active Vacb, that we can just copy to.
    //

    GetActiveVacb( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );

    if (ActiveVacb != NULL) {

        if ((ULONG)(FOffset.QuadPart >> VACB_OFFSET_SHIFT) == (ActivePage >> (VACB_OFFSET_SHIFT - PAGE_SHIFT))) {

            ULONG LengthToCopy = VACB_MAPPING_GRANULARITY - (FOffset.LowPart & (VACB_MAPPING_GRANULARITY - 1));

            if (SharedCacheMap->NeedToZero != NULL) {
                CcFreeActiveVacb( SharedCacheMap, NULL, 0, FALSE );
            }

            //
            //  Get the starting point in the view.
            //

            CacheBuffer = (PVOID)((PCHAR)ActiveVacb->BaseAddress +
                                          (FOffset.LowPart & (VACB_MAPPING_GRANULARITY - 1)));

            //
            //  Reduce LengthToCopy if it is greater than our caller's length.
            //

            if (LengthToCopy > Length) {
                LengthToCopy = Length;
            }

            //
            //  Like the logic for the normal case below, we want to spin around
            //  making sure Mm only reads the pages we will need.
            //
            
            PagesToGo = ADDRESS_AND_SIZE_TO_SPAN_PAGES( CacheBuffer,
                                               LengthToCopy ) - 1;

            //
            //  Copy the data to the user buffer.
            //

            try {

                if (PagesToGo != 0) {
    
                    LengthToGo = LengthToCopy;
    
                    while (LengthToGo != 0) {
    
                        MoveLength = (ULONG)((PCHAR)(ROUND_TO_PAGES(((PCHAR)CacheBuffer + 1))) -
                                     (PCHAR)CacheBuffer);
    
                        if (MoveLength > LengthToGo) {
                            MoveLength = LengthToGo;
                        }
    
                        //
                        //  Here's hoping that it is cheaper to call Mm to see if
                        //  the page is valid.  If not let Mm know how many pages
                        //  we are after before doing the move.
                        //
    
                        MmSetPageFaultReadAhead( Thread, PagesToGo );
                        GotAMiss |= !MmCheckCachedPageState( CacheBuffer, FALSE );
    
                        RtlCopyBytes( Buffer, CacheBuffer, MoveLength );
    
                        PagesToGo -= 1;
    
                        LengthToGo -= MoveLength;
                        Buffer = (PCHAR)Buffer + MoveLength;
                        CacheBuffer = (PCHAR)CacheBuffer + MoveLength;
                    }
    
                //
                //  Handle the read here that stays on a single page.
                //
    
                } else {
    
                    //
                    //  Here's hoping that it is cheaper to call Mm to see if
                    //  the page is valid.  If not let Mm know how many pages
                    //  we are after before doing the move.
                    //
    
                    MmSetPageFaultReadAhead( Thread, 0 );
                    GotAMiss |= !MmCheckCachedPageState( CacheBuffer, FALSE );
    
                    RtlCopyBytes( Buffer, CacheBuffer, LengthToCopy );
    
                    Buffer = (PCHAR)Buffer + LengthToCopy;
                }
                
            } except( CcCopyReadExceptionFilter( GetExceptionInformation(),
                                                 &Status ) ) {

                MmResetPageFaultReadAhead( Thread, SavedState );

                SetActiveVacb( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );

                //
                //  If we got an access violation, then the user buffer went
                //  away.  Otherwise we must have gotten an I/O error trying
                //  to bring the data in.
                //

                if (Status == STATUS_ACCESS_VIOLATION) {
                    ExRaiseStatus( STATUS_INVALID_USER_BUFFER );
                }
                else {
                    ExRaiseStatus( FsRtlNormalizeNtstatus( Status,
                                                           STATUS_UNEXPECTED_IO_ERROR ));
                }
            }

            //
            //  Now adjust FOffset and Length by what we copied.
            //

            FOffset.QuadPart = FOffset.QuadPart + (LONGLONG)LengthToCopy;
            Length -= LengthToCopy;

        }

        //
        //  If that was all the data, then remember the Vacb
        //

        if (Length == 0) {

            SetActiveVacb( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );

        //
        //  Otherwise we must free it because we will map other vacbs below.
        //

        } else {

            CcFreeActiveVacb( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
        }
    }

    //
    //  Not all of the transfer will come back at once, so we have to loop
    //  until the entire transfer is complete.
    //

    while (Length != 0) {

        ULONG ReceivedLength;
        LARGE_INTEGER BeyondLastByte;

        //
        //  Call local routine to Map or Access the file data, then move the data,
        //  then call another local routine to free the data.  If we cannot map
        //  the data because of a Wait condition, return FALSE.
        //
        //  Note that this call may result in an exception, however, if it
        //  does no Bcb is returned and this routine has absolutely no
        //  cleanup to perform.  Therefore, we do not have a try-finally
        //  and we allow the possibility that we will simply be unwound
        //  without notice.
        //

        if (Wait) {

            CacheBuffer = CcGetVirtualAddress( SharedCacheMap,
                                               FOffset,
                                               &Vacb,
                                               &ReceivedLength );

            BeyondLastByte.QuadPart = FOffset.QuadPart + (LONGLONG)ReceivedLength;

        } else if (!CcPinFileData( FileObject,
                                   &FOffset,
                                   Length,
                                   TRUE,
                                   FALSE,
                                   FALSE,
                                   &Bcb,
                                   &CacheBuffer,
                                   &BeyondLastByte )) {

            DebugTrace(-1, me, "CcCopyRead -> FALSE\n", 0 );

            HOT_STATISTIC(CcCopyReadNoWaitMiss) += 1;

            //
            //  Enable ReadAhead if we missed.
            //

            if (!FlagOn( FileObject->Flags, FO_RANDOM_ACCESS ) &&
                !PrivateCacheMap->Flags.ReadAheadEnabled) {
                
                CC_SET_PRIVATE_CACHE_MAP (PrivateCacheMap, PRIVATE_CACHE_MAP_READ_AHEAD_ENABLED);
            }

            return FALSE;

        } else {

            //
            //  Calculate how much data is described by Bcb starting at our desired
            //  file offset.
            //

            ReceivedLength = (ULONG)(BeyondLastByte.QuadPart - FOffset.QuadPart);
        }

        //
        //  If we got more than we need, make sure to only transfer
        //  the right amount.
        //

        if (ReceivedLength > Length) {
            ReceivedLength = Length;
        }

        //
        //  It is possible for the user buffer to become no longer accessible
        //  since it was last checked by the I/O system.  If we fail to access
        //  the buffer we must raise a status that the caller's exception
        //  filter considers as "expected".  Also we unmap the Bcb here, since
        //  we otherwise would have no other reason to put a try-finally around
        //  this loop.
        //

        try {

            PagesToGo = ADDRESS_AND_SIZE_TO_SPAN_PAGES( CacheBuffer,
                                               ReceivedLength ) - 1;

            //
            //  We know exactly how much we want to read here, and we do not
            //  want to read any more in case the caller is doing random access.
            //  Our read ahead logic takes care of detecting sequential reads,
            //  and tends to do large asynchronous read aheads.  So far we have
            //  only mapped the data and we have not forced any in.  What we
            //  do now is get into a loop where we copy a page at a time and
            //  just prior to each move, we tell MM how many additional pages
            //  we would like to have read in, in the event that we take a
            //  fault.  With this strategy, for cache hits we never make a single
            //  expensive call to MM to guarantee that the data is in, yet if we
            //  do take a fault, we are guaranteed to only take one fault because
            //  we will read all of the data in for the rest of the transfer.
            //
            //  We test first for the multiple page case, to keep the small
            //  reads faster.
            //

            if (PagesToGo != 0) {

                LengthToGo = ReceivedLength;

                while (LengthToGo != 0) {

                    MoveLength = (ULONG)((PCHAR)(ROUND_TO_PAGES(((PCHAR)CacheBuffer + 1))) -
                                 (PCHAR)CacheBuffer);

                    if (MoveLength > LengthToGo) {
                        MoveLength = LengthToGo;
                    }

                    //
                    //  Here's hoping that it is cheaper to call Mm to see if
                    //  the page is valid.  If not let Mm know how many pages
                    //  we are after before doing the move.
                    //

                    MmSetPageFaultReadAhead( Thread, PagesToGo );
                    GotAMiss |= !MmCheckCachedPageState( CacheBuffer, FALSE );

                    RtlCopyBytes( Buffer, CacheBuffer, MoveLength );

                    PagesToGo -= 1;

                    LengthToGo -= MoveLength;
                    Buffer = (PCHAR)Buffer + MoveLength;
                    CacheBuffer = (PCHAR)CacheBuffer + MoveLength;
                }

            //
            //  Handle the read here that stays on a single page.
            //

            } else {

                //
                //  Here's hoping that it is cheaper to call Mm to see if
                //  the page is valid.  If not let Mm know how many pages
                //  we are after before doing the move.
                //

                MmSetPageFaultReadAhead( Thread, 0 );
                GotAMiss |= !MmCheckCachedPageState( CacheBuffer, FALSE );

                RtlCopyBytes( Buffer, CacheBuffer, ReceivedLength );

                Buffer = (PCHAR)Buffer + ReceivedLength;
            }

        }
        except( CcCopyReadExceptionFilter( GetExceptionInformation(),
                                           &Status ) ) {

            CcMissCounter = &CcThrowAway;

            //
            //  If we get an exception, then we have to re-enable page fault
            //  clustering and unmap on the way out.
            //

            MmResetPageFaultReadAhead( Thread, SavedState );


            if (Wait) {
                CcFreeVirtualAddress( Vacb );
            } else {
                CcUnpinFileData( Bcb, TRUE, UNPIN );
            }

            //
            //  If we got an access violation, then the user buffer went
            //  away.  Otherwise we must have gotten an I/O error trying
            //  to bring the data in.
            //

            if (Status == STATUS_ACCESS_VIOLATION) {
                ExRaiseStatus( STATUS_INVALID_USER_BUFFER );
            }
            else {
                ExRaiseStatus( FsRtlNormalizeNtstatus( Status,
                                                       STATUS_UNEXPECTED_IO_ERROR ));
            }
        }

        //
        //  Update number of bytes transferred.
        //

        Length -= ReceivedLength;

        //
        //  Unmap the data now, and calculate length left to transfer.
        //

        if (Wait) {

            //
            //  If there is more to go, just free this vacb.
            //

            if (Length != 0) {

                CcFreeVirtualAddress( Vacb );

            //
            //  Otherwise save it for the next time through.
            //

            } else {

                SetActiveVacb( SharedCacheMap, OldIrql, Vacb, (ULONG)(FOffset.QuadPart >> PAGE_SHIFT), 0 );
                break;
            }

        } else {
            CcUnpinFileData( Bcb, TRUE, UNPIN );
        }

        //
        //  Assume we did not get all the data we wanted, and set FOffset
        //  to the end of the returned data.
        //

        FOffset = BeyondLastByte;
    }

    MmResetPageFaultReadAhead( Thread, SavedState );

    CcMissCounter = &CcThrowAway;

    //
    //  Now enable read ahead if it looks like we got any misses, and do
    //  the first one.
    //

    if (GotAMiss &&
        !FlagOn( FileObject->Flags, FO_RANDOM_ACCESS ) &&
        !PrivateCacheMap->Flags.ReadAheadEnabled) {

        CC_SET_PRIVATE_CACHE_MAP (PrivateCacheMap, PRIVATE_CACHE_MAP_READ_AHEAD_ENABLED);
        CcScheduleReadAhead( FileObject, FileOffset, OriginalLength );
    }

    //
    //  Now that we have described our desired read ahead, let's
    //  shift the read history down.
    //

    PrivateCacheMap->FileOffset1 = PrivateCacheMap->FileOffset2;
    PrivateCacheMap->BeyondLastByte1 = PrivateCacheMap->BeyondLastByte2;
    PrivateCacheMap->FileOffset2 = *FileOffset;
    PrivateCacheMap->BeyondLastByte2.QuadPart =
                                FileOffset->QuadPart + (LONGLONG)OriginalLength;

    IoStatus->Status = STATUS_SUCCESS;
    IoStatus->Information = OriginalLength;

    DebugTrace(-1, me, "CcCopyRead -> TRUE\n", 0 );

    return TRUE;
}


VOID
CcFastCopyRead (
    __in PFILE_OBJECT FileObject,
    __in ULONG FileOffset,
    __in ULONG Length,
    __in ULONG PageCount,
    __out_bcount(Length) PVOID Buffer,
    __out PIO_STATUS_BLOCK IoStatus
    )

/*++

Routine Description:

    This routine attempts to copy the specified file data from the cache
    into the output buffer, and deliver the correct I/O status.

    This is a faster version of CcCopyRead which only supports 32-bit file
    offsets and synchronicity (Wait = TRUE).

Arguments:

    FileObject - Pointer to the file object for a file which was
                 opened with NO_INTERMEDIATE_BUFFERING clear, i.e., for
                 which CcInitializeCacheMap was called by the file system.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    PageCount - Number of pages spanned by the read.

    Buffer - Pointer to output buffer to which data should be copied.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.  (STATUS_SUCCESS guaranteed for cache
               hits, otherwise the actual I/O status is returned.)

               Note that even if FALSE is returned, the IoStatus.Information
               field will return the count of any bytes successfully
               transferred before a blocking condition occured.  The caller
               may either choose to ignore this information, or resume
               the copy later accounting for bytes transferred.

Return Value:

    None

--*/

{
    PSHARED_CACHE_MAP SharedCacheMap;
    PPRIVATE_CACHE_MAP PrivateCacheMap;
    PVOID CacheBuffer;
    LARGE_INTEGER FOffset;
    PVACB Vacb;
    PVACB ActiveVacb;
    ULONG ActivePage;
    ULONG PageIsDirty;
    ULONG SavedState;
    ULONG PagesToGo;
    ULONG MoveLength;
    ULONG LengthToGo;
    NTSTATUS Status;
    LARGE_INTEGER OriginalOffset;
    ULONG OriginalLength = Length;
    PETHREAD Thread = PsGetCurrentThread();
    ULONG GotAMiss = 0;

    UNREFERENCED_PARAMETER (PageCount);

    DebugTrace(+1, me, "CcFastCopyRead\n", 0 );

    MmSavePageFaultReadAhead( Thread, &SavedState );

    //
    //  Get pointer to shared and private cache maps
    //

    SharedCacheMap = FileObject->SectionObjectPointer->SharedCacheMap;
    PrivateCacheMap = FileObject->PrivateCacheMap;

    //
    //  Check for read past file size, the caller must filter this case out.
    //

    ASSERT( (FileOffset + Length) <= SharedCacheMap->FileSize.LowPart );

    //
    //  If read ahead is enabled, then do the read ahead here so it
    //  overlaps with the copy (otherwise we will do it below).
    //  Note that we are assuming that we will not get ahead of our
    //  current transfer - if read ahead is working it should either
    //  already be in memory or else underway.
    //

    OriginalOffset.LowPart = FileOffset;
    OriginalOffset.HighPart = 0;

    if (PrivateCacheMap->Flags.ReadAheadEnabled && (PrivateCacheMap->ReadAheadLength[1] == 0)) {
        CcScheduleReadAhead( FileObject, &OriginalOffset, Length );
    }

    //
    //  This is not an exact solution, but when IoPageRead gets a miss,
    //  it cannot tell whether it was CcCopyRead or CcMdlRead, but since
    //  the miss should occur very soon, by loading the pointer here
    //  probably the right counter will get incremented, and in any case,
    //  we hope the errors average out!
    //

    CcMissCounter = &CcCopyReadWaitMiss;

    //
    //  Increment performance counters
    //

    HOT_STATISTIC(CcCopyReadWait) += 1;

    //
    //  See if we have an active Vacb, that we can just copy to.
    //

    GetActiveVacb( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );

    if (ActiveVacb != NULL) {

        if ((FileOffset >> VACB_OFFSET_SHIFT) == (ActivePage >> (VACB_OFFSET_SHIFT - PAGE_SHIFT))) {

            ULONG LengthToCopy = VACB_MAPPING_GRANULARITY - (FileOffset & (VACB_MAPPING_GRANULARITY - 1));

            if (SharedCacheMap->NeedToZero != NULL) {
                CcFreeActiveVacb( SharedCacheMap, NULL, 0, FALSE );
            }

            //
            //  Get the starting point in the view.
            //

            CacheBuffer = (PVOID)((PCHAR)ActiveVacb->BaseAddress +
                                          (FileOffset & (VACB_MAPPING_GRANULARITY - 1)));

            //
            //  Reduce LengthToCopy if it is greater than our caller's length.
            //

            if (LengthToCopy > Length) {
                LengthToCopy = Length;
            }

            //
            //  Like the logic for the normal case below, we want to spin around
            //  making sure Mm only reads the pages we will need.
            //
            
            PagesToGo = ADDRESS_AND_SIZE_TO_SPAN_PAGES( CacheBuffer,
                                               LengthToCopy ) - 1;

            //
            //  Copy the data to the user buffer.
            //

            try {

                if (PagesToGo != 0) {
    
                    LengthToGo = LengthToCopy;
    
                    while (LengthToGo != 0) {
    
                        MoveLength = (ULONG)((PCHAR)(ROUND_TO_PAGES(((PCHAR)CacheBuffer + 1))) -
                                     (PCHAR)CacheBuffer);
    
                        if (MoveLength > LengthToGo) {
                            MoveLength = LengthToGo;
                        }
    
                        //
                        //  Here's hoping that it is cheaper to call Mm to see if
                        //  the page is valid.  If not let Mm know how many pages
                        //  we are after before doing the move.
                        //
    
                        MmSetPageFaultReadAhead( Thread, PagesToGo );
                        GotAMiss |= !MmCheckCachedPageState( CacheBuffer, FALSE );
    
                        RtlCopyBytes( Buffer, CacheBuffer, MoveLength );
    
                        PagesToGo -= 1;
    
                        LengthToGo -= MoveLength;
                        Buffer = (PCHAR)Buffer + MoveLength;
                        CacheBuffer = (PCHAR)CacheBuffer + MoveLength;
                    }
    
                //
                //  Handle the read here that stays on a single page.
                //
    
                } else {
    
                    //
                    //  Here's hoping that it is cheaper to call Mm to see if
                    //  the page is valid.  If not let Mm know how many pages
                    //  we are after before doing the move.
                    //
    
                    MmSetPageFaultReadAhead( Thread, 0 );
                    GotAMiss |= !MmCheckCachedPageState( CacheBuffer, FALSE );
    
                    RtlCopyBytes( Buffer, CacheBuffer, LengthToCopy );
    
                    Buffer = (PCHAR)Buffer + LengthToCopy;
                }
                
            } except( CcCopyReadExceptionFilter( GetExceptionInformation(),
                                                 &Status ) ) {

                MmResetPageFaultReadAhead( Thread, SavedState );


                SetActiveVacb( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );

                //
                //  If we got an access violation, then the user buffer went
                //  away.  Otherwise we must have gotten an I/O error trying
                //  to bring the data in.
                //

                if (Status == STATUS_ACCESS_VIOLATION) {
                    ExRaiseStatus( STATUS_INVALID_USER_BUFFER );
                }
                else {
                    ExRaiseStatus( FsRtlNormalizeNtstatus( Status,
                                                           STATUS_UNEXPECTED_IO_ERROR ));
                }
            }

            //
            //  Now adjust FileOffset and Length by what we copied.
            //

            FileOffset += LengthToCopy;
            Length -= LengthToCopy;
        }

        //
        //  If that was all the data, then remember the Vacb
        //

        if (Length == 0) {

            SetActiveVacb( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );

        //
        //  Otherwise we must free it because we will map other vacbs below.
        //

        } else {

            CcFreeActiveVacb( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
        }
    }

    //
    //  Not all of the transfer will come back at once, so we have to loop
    //  until the entire transfer is complete.
    //

    FOffset.HighPart = 0;
    FOffset.LowPart = FileOffset;

    while (Length != 0) {

        ULONG ReceivedLength;
        ULONG BeyondLastByte;

        //
        //  Call local routine to Map or Access the file data, then move the data,
        //  then call another local routine to free the data.  If we cannot map
        //  the data because of a Wait condition, return FALSE.
        //
        //  Note that this call may result in an exception, however, if it
        //  does no Bcb is returned and this routine has absolutely no
        //  cleanup to perform.  Therefore, we do not have a try-finally
        //  and we allow the possibility that we will simply be unwound
        //  without notice.
        //

        CacheBuffer = CcGetVirtualAddress( SharedCacheMap,
                                           FOffset,
                                           &Vacb,
                                           &ReceivedLength );

        BeyondLastByte = FOffset.LowPart + ReceivedLength;

        //
        //  If we got more than we need, make sure to only transfer
        //  the right amount.
        //

        if (ReceivedLength > Length) {
            ReceivedLength = Length;
        }

        //
        //  It is possible for the user buffer to become no longer accessible
        //  since it was last checked by the I/O system.  If we fail to access
        //  the buffer we must raise a status that the caller's exception
        //  filter considers as "expected".  Also we unmap the Bcb here, since
        //  we otherwise would have no other reason to put a try-finally around
        //  this loop.
        //

        try {

            PagesToGo = ADDRESS_AND_SIZE_TO_SPAN_PAGES( CacheBuffer,
                                               ReceivedLength ) - 1;

            //
            //  We know exactly how much we want to read here, and we do not
            //  want to read any more in case the caller is doing random access.
            //  Our read ahead logic takes care of detecting sequential reads,
            //  and tends to do large asynchronous read aheads.  So far we have
            //  only mapped the data and we have not forced any in.  What we
            //  do now is get into a loop where we copy a page at a time and
            //  just prior to each move, we tell MM how many additional pages
            //  we would like to have read in, in the event that we take a
            //  fault.  With this strategy, for cache hits we never make a single
            //  expensive call to MM to guarantee that the data is in, yet if we
            //  do take a fault, we are guaranteed to only take one fault because
            //  we will read all of the data in for the rest of the transfer.
            //
            //  We test first for the multiple page case, to keep the small
            //  reads faster.
            //

            if (PagesToGo != 0) {

                LengthToGo = ReceivedLength;

                while (LengthToGo != 0) {

                    MoveLength = (ULONG)((PCHAR)(ROUND_TO_PAGES(((PCHAR)CacheBuffer + 1))) -
                                 (PCHAR)CacheBuffer);

                    if (MoveLength > LengthToGo) {
                        MoveLength = LengthToGo;
                    }

                    //
                    //  Here's hoping that it is cheaper to call Mm to see if
                    //  the page is valid.  If not let Mm know how many pages
                    //  we are after before doing the move.
                    //

                    MmSetPageFaultReadAhead( Thread, PagesToGo );
                    GotAMiss |= !MmCheckCachedPageState( CacheBuffer, FALSE );

                    RtlCopyBytes( Buffer, CacheBuffer, MoveLength );

                    PagesToGo -= 1;

                    LengthToGo -= MoveLength;
                    Buffer = (PCHAR)Buffer + MoveLength;
                    CacheBuffer = (PCHAR)CacheBuffer + MoveLength;
                }

            //
            //  Handle the read here that stays on a single page.
            //

            } else {

                //
                //  Here's hoping that it is cheaper to call Mm to see if
                //  the page is valid.  If not let Mm know how many pages
                //  we are after before doing the move.
                //

                MmSetPageFaultReadAhead( Thread, 0 );
                GotAMiss |= !MmCheckCachedPageState( CacheBuffer, FALSE );

                RtlCopyBytes( Buffer, CacheBuffer, ReceivedLength );

                Buffer = (PCHAR)Buffer + ReceivedLength;
            }
        }
        except( CcCopyReadExceptionFilter( GetExceptionInformation(),
                                           &Status ) ) {

            CcMissCounter = &CcThrowAway;

            //
            //  If we get an exception, then we have to re-enable page fault
            //  clustering and unmap on the way out.
            //

            MmResetPageFaultReadAhead( Thread, SavedState );


            CcFreeVirtualAddress( Vacb );

            //
            //  If we got an access violation, then the user buffer went
            //  away.  Otherwise we must have gotten an I/O error trying
            //  to bring the data in.
            //

            if (Status == STATUS_ACCESS_VIOLATION) {
                ExRaiseStatus( STATUS_INVALID_USER_BUFFER );
            }
            else {
                ExRaiseStatus( FsRtlNormalizeNtstatus( Status,
                                                       STATUS_UNEXPECTED_IO_ERROR ));
            }
        }

        //
        //  Update number of bytes transferred.
        //

        Length -= ReceivedLength;

        //
        //  Unmap the data now, and calculate length left to transfer.
        //

        if (Length != 0) {

            //
            //  If there is more to go, just free this vacb.
            //

            CcFreeVirtualAddress( Vacb );

        } else {

            //
            //  Otherwise save it for the next time through.
            //

            SetActiveVacb( SharedCacheMap, OldIrql, Vacb, (FOffset.LowPart >> PAGE_SHIFT), 0 );
            break;
        }

        //
        //  Assume we did not get all the data we wanted, and set FOffset
        //  to the end of the returned data.
        //

        FOffset.LowPart = BeyondLastByte;
    }

    MmResetPageFaultReadAhead( Thread, SavedState );

    CcMissCounter = &CcThrowAway;

    //
    //  Now enable read ahead if it looks like we got any misses, and do
    //  the first one.
    //

    if (GotAMiss &&
        !FlagOn( FileObject->Flags, FO_RANDOM_ACCESS ) &&
        !PrivateCacheMap->Flags.ReadAheadEnabled) {

        CC_SET_PRIVATE_CACHE_MAP (PrivateCacheMap, PRIVATE_CACHE_MAP_READ_AHEAD_ENABLED);
        CcScheduleReadAhead( FileObject, &OriginalOffset, OriginalLength );
    }

    //
    //  Now that we have described our desired read ahead, let's
    //  shift the read history down.
    //

    PrivateCacheMap->FileOffset1.LowPart = PrivateCacheMap->FileOffset2.LowPart;
    PrivateCacheMap->BeyondLastByte1.LowPart = PrivateCacheMap->BeyondLastByte2.LowPart;
    PrivateCacheMap->FileOffset2.LowPart = OriginalOffset.LowPart;
    PrivateCacheMap->BeyondLastByte2.LowPart = OriginalOffset.LowPart + OriginalLength;

    IoStatus->Status = STATUS_SUCCESS;
    IoStatus->Information = OriginalLength;

    DebugTrace(-1, me, "CcFastCopyRead -> VOID\n", 0 );
}


BOOLEAN
CcCopyWrite (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in BOOLEAN Wait,
    __in_bcount(Length) PVOID Buffer
    )

/*++

Routine Description:

    This routine attempts to copy the specified file data from the specified
    buffer into the Cache, and deliver the correct I/O status.  It is *not*
    safe to call this routine from Dpc level.

    If the caller does not want to block (such as for disk I/O), then
    Wait should be supplied as FALSE.  If Wait was supplied as FALSE and
    it is currently impossible to receive all of the requested data without
    blocking, then this routine will return FALSE.  However, if the
    correct space is immediately accessible in the cache and no blocking is
    required, this routine copies the data and returns TRUE.

    If the caller supplies Wait as TRUE, then this routine is guaranteed
    to copy the data and return TRUE.  If the correct space is immediately
    accessible in the cache, then no blocking will occur.  Otherwise,
    the necessary work will be initiated to read and/or free cache data,
    and the caller will be blocked until the data can be received.

    File system Fsd's should typically supply Wait = TRUE if they are
    processing a synchronous I/O requests, or Wait = FALSE if they are
    processing an asynchronous request.

    File system or Server Fsp threads should supply Wait = TRUE.

Arguments:

    FileObject - Pointer to the file object for a file which was
                 opened with NO_INTERMEDIATE_BUFFERING clear, i.e., for
                 which CcInitializeCacheMap was called by the file system.

    FileOffset - Byte offset in file to receive the data.

    Length - Length of data in bytes.

    Wait - FALSE if caller may not block, TRUE otherwise (see description
           above)

    Buffer - Pointer to input buffer from which data should be copied.

Return Value:

    FALSE - if Wait was supplied as FALSE and the data was not copied.

    TRUE - if the data has been copied.

Raises:

    STATUS_INSUFFICIENT_RESOURCES - If a pool allocation failure occurs.
        This can only occur if Wait was specified as TRUE.  (If Wait is
        specified as FALSE, and an allocation failure occurs, this
        routine simply returns FALSE.)

--*/

{
    PSHARED_CACHE_MAP SharedCacheMap;
    PFSRTL_ADVANCED_FCB_HEADER FcbHeader;
    PVACB ActiveVacb;
    ULONG ActivePage;
    PVOID ActiveAddress;
    ULONG PageIsDirty;
    KIRQL OldIrql;
    NTSTATUS Status;
    PVOID CacheBuffer;
    LARGE_INTEGER FOffset;
    PBCB Bcb;
    ULONG OptimizeFlags;
    LARGE_INTEGER Temp;
    LARGE_INTEGER ValidDataLength;
    BOOLEAN Result;

    DebugTrace(+1, me, "CcCopyWrite\n", 0 );

    //
    //  If the caller specified Wait == FALSE, but the FileObject is WriteThrough,
    //  then we need to just get out.
    //

    if ((FileObject->Flags & FO_WRITE_THROUGH) && !Wait) {

        DebugTrace(-1, me, "CcCopyWrite->FALSE (WriteThrough && !Wait)\n", 0 );

        return FALSE;
    }

    //
    //  Get pointer to shared cache map
    //

    SharedCacheMap = FileObject->SectionObjectPointer->SharedCacheMap;
    FOffset = *FileOffset;

    //
    //  See if we have an active Vacb, that we can just copy to.
    //

    GetActiveVacb( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );

    if (ActiveVacb != NULL) {

        //
        //  See if the request starts in the ActivePage.  WriteThrough requests must
        //  go the longer route through CcMapAndCopy, where WriteThrough flushes are
        //  implemented.
        //

        if (((ULONG)(FOffset.QuadPart >> PAGE_SHIFT) == ActivePage) && (Length != 0) &&
            !FlagOn( FileObject->Flags, FO_WRITE_THROUGH )) {

            ULONG LengthToCopy = PAGE_SIZE - (FOffset.LowPart & (PAGE_SIZE - 1));

            //
            //  Reduce LengthToCopy if it is greater than our caller's length.
            //

            if (LengthToCopy > Length) {
                LengthToCopy = Length;
            }

            //
            //  Copy the data to the user buffer.
            //

            try {

                //
                //  If we are copying to a page that is locked down, then
                //  we have to do it under our spinlock, and update the
                //  NeedToZero field.
                //

                OldIrql = 0xFF;

                CacheBuffer = (PVOID)((PCHAR)ActiveVacb->BaseAddress +
                                      (FOffset.LowPart & (VACB_MAPPING_GRANULARITY - 1)));

                if (SharedCacheMap->NeedToZero != NULL) {

                    //
                    //  The FastLock may not write our "flag".
                    //

                    OldIrql = 0;

                    ExAcquireFastLock( &SharedCacheMap->ActiveVacbSpinLock, &OldIrql );

                    //
                    //  Note that the NeedToZero could be cleared, since we
                    //  tested it without the spinlock.
                    //

                    ActiveAddress = SharedCacheMap->NeedToZero;
                    if ((ActiveAddress != NULL) &&
                        (ActiveVacb == SharedCacheMap->NeedToZeroVacb) &&
                        (((PCHAR)CacheBuffer + LengthToCopy) > (PCHAR)ActiveAddress)) {

                        //
                        //  If we are skipping some bytes in the page, then we need
                        //  to zero them.
                        //

                        if ((PCHAR)CacheBuffer > (PCHAR)ActiveAddress) {

                            RtlZeroMemory( ActiveAddress, (PCHAR)CacheBuffer - (PCHAR)ActiveAddress );
                        }
                        SharedCacheMap->NeedToZero = (PVOID)((PCHAR)CacheBuffer + LengthToCopy);
                    }

                    ExReleaseFastLock( &SharedCacheMap->ActiveVacbSpinLock, OldIrql );
                }

                RtlCopyBytes( CacheBuffer, Buffer, LengthToCopy );

            } except( CcCopyReadExceptionFilter( GetExceptionInformation(),
                                                 &Status ) ) {

                //
                //  If we failed to overwrite the uninitialized data,
                //  zero it now (we cannot safely restore NeedToZero).
                //

                if (OldIrql != 0xFF) {
                    RtlZeroBytes( CacheBuffer, LengthToCopy );
                }

                SetActiveVacb( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, ACTIVE_PAGE_IS_DIRTY );

                //
                //  If we got an access violation, then the user buffer went
                //  away.  Otherwise we must have gotten an I/O error trying
                //  to bring the data in.
                //

                if (Status == STATUS_ACCESS_VIOLATION) {
                    ExRaiseStatus( STATUS_INVALID_USER_BUFFER );
                }
                else {
                    ExRaiseStatus( FsRtlNormalizeNtstatus( Status,
                                                           STATUS_UNEXPECTED_IO_ERROR ));
                }
            }

            //
            //  Now adjust FOffset and Length by what we copied.
            //

            Buffer = (PVOID)((PCHAR)Buffer + LengthToCopy);
            FOffset.QuadPart = FOffset.QuadPart + (LONGLONG)LengthToCopy;
            Length -= LengthToCopy;

            //
            //  If that was all the data, then get outski...
            //

            if (Length == 0) {

                SetActiveVacb( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, ACTIVE_PAGE_IS_DIRTY );
                return TRUE;
            }

            //
            //  Remember that the page is dirty now.
            //

            PageIsDirty |= ACTIVE_PAGE_IS_DIRTY;
        }

        CcFreeActiveVacb( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );

    //
    //  Else someone else could have the active page, and may want to zero
    //  the range we plan to write!
    //

    } else if (SharedCacheMap->NeedToZero != NULL) {

        CcFreeActiveVacb( SharedCacheMap, NULL, 0, FALSE );
    }

    //
    //  At this point we can calculate the ZeroFlags.
    //

    //
    //  We can always zero middle pages, if any.
    //

    OptimizeFlags = OPTIMIZE_MIDDLE_PAGES;

    if (((FOffset.LowPart & (PAGE_SIZE - 1)) == 0) &&
        (Length >= PAGE_SIZE)) {
        OptimizeFlags |= OPTIMIZE_FIRST_PAGE;
    }

    if (((FOffset.LowPart + Length) & (PAGE_SIZE - 1)) == 0) {
        OptimizeFlags |= OPTIMIZE_LAST_PAGE;
    }

    Temp = FOffset;
    Temp.LowPart &= ~(PAGE_SIZE -1);

    //
    //  If there is an advanced header, then we can acquire the FastMutex to
    //  make capturing ValidDataLength atomic.  Currently our other file systems
    //  are either RO or do not really support 64-bits.
    //
    //  We will save the ValidDataLength read from the file system here so that
    //  we can pass it into CcMapAndCopy.
    //

    FcbHeader = (PFSRTL_ADVANCED_FCB_HEADER)FileObject->FsContext;
    if (FlagOn(FcbHeader->Flags, FSRTL_FLAG_ADVANCED_HEADER)) {
        ExAcquireFastMutex( FcbHeader->FastMutex );
        ValidDataLength.QuadPart = ((PFSRTL_COMMON_FCB_HEADER)FileObject->FsContext)->ValidDataLength.QuadPart;
        ExReleaseFastMutex( FcbHeader->FastMutex );
    } else {
        ValidDataLength.QuadPart = ((PFSRTL_COMMON_FCB_HEADER)FileObject->FsContext)->ValidDataLength.QuadPart;
    }

    Temp.QuadPart = ValidDataLength.QuadPart - Temp.QuadPart;

    if (Temp.QuadPart <= 0) {
        OptimizeFlags |= OPTIMIZE_FIRST_PAGE | OPTIMIZE_MIDDLE_PAGES | OPTIMIZE_LAST_PAGE;
    } else if ((Temp.HighPart == 0) && (Temp.LowPart <= PAGE_SIZE)) {
        OptimizeFlags |= OPTIMIZE_MIDDLE_PAGES | OPTIMIZE_LAST_PAGE;
    }

    //
    //  Call a routine to map and copy the data in Mm and get out.
    //

    Result = CcMapAndCopy( SharedCacheMap,
                           Buffer,
                           &FOffset,
                           Length,
                           OptimizeFlags,
                           FileObject,
                           &ValidDataLength,
                           Wait );

    DebugTrace(-1, me, "CcCopyWrite -> %02lx\n", Result );
        
    return Result;
}


VOID
CcFastCopyWrite (
    __in PFILE_OBJECT FileObject,
    __in ULONG FileOffset,
    __in ULONG Length,
    __in_bcount(Length) PVOID Buffer
    )

/*++

Routine Description:

    This routine attempts to copy the specified file data from the specified
    buffer into the Cache, and deliver the correct I/O status.

    This is a faster version of CcCopyWrite which only supports 32-bit file
    offsets and synchronicity (Wait = TRUE) and no Write Through.

Arguments:

    FileObject - Pointer to the file object for a file which was
                 opened with NO_INTERMEDIATE_BUFFERING clear, i.e., for
                 which CcInitializeCacheMap was called by the file system.

    FileOffset - Byte offset in file to receive the data.

    Length - Length of data in bytes.

    Buffer - Pointer to input buffer from which data should be copied.

Return Value:

    None

Raises:

    STATUS_INSUFFICIENT_RESOURCES - If a pool allocation failure occurs.
        This can only occur if Wait was specified as TRUE.  (If Wait is
        specified as FALSE, and an allocation failure occurs, this
        routine simply returns FALSE.)

--*/

{
    PSHARED_CACHE_MAP SharedCacheMap;
    PVOID CacheBuffer;
    PVACB ActiveVacb;
    ULONG ActivePage;
    PVOID ActiveAddress;
    ULONG PageIsDirty;
    KIRQL OldIrql;
    NTSTATUS Status;
    ULONG OptimizeFlags;
    LARGE_INTEGER ValidDataLength;
    LARGE_INTEGER FOffset;

    DebugTrace(+1, me, "CcFastCopyWrite\n", 0 );

    //
    //  Get pointer to shared cache map and a copy of valid data length
    //

    SharedCacheMap = FileObject->SectionObjectPointer->SharedCacheMap;

    //
    //  See if we have an active Vacb, that we can just copy to.
    //

    GetActiveVacb( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );

    if (ActiveVacb != NULL) {

        //
        //  See if the request starts in the ActivePage.  WriteThrough requests must
        //  go the longer route through CcMapAndCopy, where WriteThrough flushes are
        //  implemented.
        //

        if (((FileOffset >> PAGE_SHIFT) == ActivePage) && (Length != 0) &&
            !FlagOn( FileObject->Flags, FO_WRITE_THROUGH )) {

            ULONG LengthToCopy = PAGE_SIZE - (FileOffset & (PAGE_SIZE - 1));

            //
            //  Reduce LengthToCopy if it is greater than our caller's length.
            //

            if (LengthToCopy > Length) {
                LengthToCopy = Length;
            }

            //
            //  Copy the data to the user buffer.
            //

            try {

                //
                //  If we are copying to a page that is locked down, then
                //  we have to do it under our spinlock, and update the
                //  NeedToZero field.
                //

                OldIrql = 0xFF;

                CacheBuffer = (PVOID)((PCHAR)ActiveVacb->BaseAddress +
                                      (FileOffset & (VACB_MAPPING_GRANULARITY - 1)));

                if (SharedCacheMap->NeedToZero != NULL) {

                    //
                    //  The FastLock may not write our "flag".
                    //

                    OldIrql = 0;

                    ExAcquireFastLock( &SharedCacheMap->ActiveVacbSpinLock, &OldIrql );

                    //
                    //  Note that the NeedToZero could be cleared, since we
                    //  tested it without the spinlock.
                    //

                    ActiveAddress = SharedCacheMap->NeedToZero;
                    if ((ActiveAddress != NULL) &&
                        (ActiveVacb == SharedCacheMap->NeedToZeroVacb) &&
                        (((PCHAR)CacheBuffer + LengthToCopy) > (PCHAR)ActiveAddress)) {

                        //
                        //  If we are skipping some bytes in the page, then we need
                        //  to zero them.
                        //

                        if ((PCHAR)CacheBuffer > (PCHAR)ActiveAddress) {

                            RtlZeroMemory( ActiveAddress, (PCHAR)CacheBuffer - (PCHAR)ActiveAddress );
                        }
                        SharedCacheMap->NeedToZero = (PVOID)((PCHAR)CacheBuffer + LengthToCopy);
                    }

                    ExReleaseFastLock( &SharedCacheMap->ActiveVacbSpinLock, OldIrql );
                }

                RtlCopyBytes( CacheBuffer, Buffer, LengthToCopy );

            } except( CcCopyReadExceptionFilter( GetExceptionInformation(),
                                                 &Status ) ) {

                //
                //  If we failed to overwrite the uninitialized data,
                //  zero it now (we cannot safely restore NeedToZero).
                //

                if (OldIrql != 0xFF) {
                    RtlZeroBytes( CacheBuffer, LengthToCopy );
                }

                SetActiveVacb( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, ACTIVE_PAGE_IS_DIRTY );

                //
                //  If we got an access violation, then the user buffer went
                //  away.  Otherwise we must have gotten an I/O error trying
                //  to bring the data in.
                //

                if (Status == STATUS_ACCESS_VIOLATION) {
                    ExRaiseStatus( STATUS_INVALID_USER_BUFFER );
                }
                else {
                    ExRaiseStatus( FsRtlNormalizeNtstatus( Status,
                                                           STATUS_UNEXPECTED_IO_ERROR ));
                }
            }

            //
            //  Now adjust FileOffset and Length by what we copied.
            //

            Buffer = (PVOID)((PCHAR)Buffer + LengthToCopy);
            FileOffset += LengthToCopy;
            Length -= LengthToCopy;

            //
            //  If that was all the data, then get outski...
            //

            if (Length == 0) {

                SetActiveVacb( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, ACTIVE_PAGE_IS_DIRTY );
                return;
            }

            //
            //  Remember that the page is dirty now.
            //

            PageIsDirty |= ACTIVE_PAGE_IS_DIRTY;
        }

        CcFreeActiveVacb( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );

    //
    //  Else someone else could have the active page, and may want to zero
    //  the range we plan to write!
    //

    } else if (SharedCacheMap->NeedToZero != NULL) {

        CcFreeActiveVacb( SharedCacheMap, NULL, 0, FALSE );
    }

    //
    //  Set up for call to CcMapAndCopy
    //

    FOffset.LowPart = FileOffset;
    FOffset.HighPart = 0;

    ValidDataLength.LowPart = ((PFSRTL_COMMON_FCB_HEADER)FileObject->FsContext)->ValidDataLength.LowPart;
    ValidDataLength.HighPart = 0;

    ASSERT((ValidDataLength.LowPart == MAXULONG) ||
           (((PFSRTL_COMMON_FCB_HEADER)FileObject->FsContext)->ValidDataLength.HighPart == 0));

    //
    //  We now calculate if there are any regions of the write for which we
    //  can use the optimized path that will not require us to fault this data
    //  in from disk if the data is not currently resident in memory.
    //

    //
    //  We can always optimize middle pages, if any.
    //

    OptimizeFlags = OPTIMIZE_MIDDLE_PAGES;

    if (((FileOffset & (PAGE_SIZE - 1)) == 0) &&
        (Length >= PAGE_SIZE)) {
        OptimizeFlags |= OPTIMIZE_FIRST_PAGE;
    }

    if (((FileOffset + Length) & (PAGE_SIZE - 1)) == 0) {
        OptimizeFlags |= OPTIMIZE_LAST_PAGE;
    }

    if ((FileOffset & ~(PAGE_SIZE - 1)) >= ValidDataLength.LowPart) {
        OptimizeFlags |= OPTIMIZE_FIRST_PAGE | OPTIMIZE_MIDDLE_PAGES | OPTIMIZE_LAST_PAGE;
    } else if (((FileOffset & ~(PAGE_SIZE - 1)) + PAGE_SIZE) >= ValidDataLength.LowPart) {
        OptimizeFlags |= OPTIMIZE_MIDDLE_PAGES | OPTIMIZE_LAST_PAGE;
    }

    //
    //  Call a routine to map and copy the data in Mm and get out.
    //

    CcMapAndCopy( SharedCacheMap,
                  Buffer,
                  &FOffset,
                  Length,
                  OptimizeFlags,
                  FileObject,
                  &ValidDataLength,
                  TRUE );

    DebugTrace(-1, me, "CcFastCopyWrite -> VOID\n", 0 );
}


LONG
CcCopyReadExceptionFilter(
    IN PEXCEPTION_POINTERS ExceptionPointer,
    IN PNTSTATUS ExceptionCode
    )

/*++

Routine Description:

    This routine serves as a exception filter and has the special job of
    extracting the "real" I/O error when Mm raises STATUS_IN_PAGE_ERROR
    beneath us.

Arguments:

    ExceptionPointer - A pointer to the exception record that contains
                       the real Io Status.

    ExceptionCode - A pointer to an NTSTATUS that is to receive the real
                    status.

Return Value:

    EXCEPTION_EXECUTE_HANDLER

--*/

{
    *ExceptionCode = ExceptionPointer->ExceptionRecord->ExceptionCode;

    if ( (*ExceptionCode == STATUS_IN_PAGE_ERROR) &&
         (ExceptionPointer->ExceptionRecord->NumberParameters >= 3) ) {

        *ExceptionCode = (NTSTATUS) ExceptionPointer->ExceptionRecord->ExceptionInformation[2];
    }

    ASSERT( !NT_SUCCESS(*ExceptionCode) );

    return EXCEPTION_EXECUTE_HANDLER;
}


BOOLEAN
CcCanIWrite (
    __in PFILE_OBJECT FileObject,
    __in ULONG BytesToWrite,
    __in BOOLEAN Wait,
    __in UCHAR Retrying
    )

/*++

Routine Description:

    This routine tests whether it is ok to do a write to the cache
    or not, according to the Thresholds of dirty bytes and available
    pages.  The first time this routine is called for a request (Retrying
    FALSE), we automatically make the new request queue if there are other
    requests in the queue.

    Note that the ListEmpty test is important to prevent small requests from sneaking
    in and starving large requests.

Arguments:

    FileObject - for the file to be written

    BytesToWrite - Number of bytes caller wishes to write to the Cache.

    Wait - TRUE if the caller owns no resources, and can block inside this routine
           until it is ok to write.

    Retrying - Specified as FALSE when the request is first received, and
               otherwise specified as TRUE if this write has already entered
               the queue.  Special non-zero value of MAXUCHAR indicates that
               we were called within the cache manager with a MasterSpinLock held,
               so do not attempt to acquire it here.  MAXUCHAR - 1 means we
               were called within the Cache Manager with some other spinlock
               held.  MAXUCHAR - 2 means we want to enforce throttling, even if
               the file object is flagged as being of remote origin. We will not
               throttle files of remote origin if this value is any of our three
               special values. For either of the first two special values, we do
               not touch the FsRtl header.

Return Value:

    TRUE if it is ok to write.
    FALSE if the caller should defer the write via a call to CcDeferWrite.

--*/

{
    PSHARED_CACHE_MAP SharedCacheMap;
    KEVENT Event;
    KIRQL OldIrql;
    ULONG PagesToWrite;
    BOOLEAN ExceededPerFileThreshold;
    DEFERRED_WRITE DeferredWrite;
    PSECTION_OBJECT_POINTERS SectionObjectPointers;

    //
    //  If this file is writethrough or of remote origin, exempt it from throttling
    //  and let it write.  We do this under the assumption that it has been throttled
    //  at the remote location and we do not want to block it here.  If we were called
    //  with Retrying set to greater than or equal to MAXUCHAR - 2 (i.e., this is
    //  one of the CC's special values), enforce the throttle regardless of the file 
    //  object origin (see above).
    //

    if (BooleanFlagOn( FileObject->Flags, FO_WRITE_THROUGH) || 
        (IoIsFileOriginRemote(FileObject) && (Retrying < MAXUCHAR - 2))) {

        return TRUE;
    } 

    //
    //  Do a special test here for file objects that keep track of dirty
    //  pages on a per-file basis.  This is used mainly for slow links.
    //

    ExceededPerFileThreshold = FALSE;

    PagesToWrite = ((BytesToWrite < WRITE_CHARGE_THRESHOLD ?
                     BytesToWrite : WRITE_CHARGE_THRESHOLD) + (PAGE_SIZE - 1)) / PAGE_SIZE;

    //
    //  Don't dereference the FsContext field if we were called while holding
    //  a spinlock.
    //

    if ((Retrying >= MAXUCHAR - 1) ||

        FlagOn(((PFSRTL_COMMON_FCB_HEADER)(FileObject->FsContext))->Flags,
               FSRTL_FLAG_LIMIT_MODIFIED_PAGES)) {

        if (Retrying != MAXUCHAR) {
            CcAcquireMasterLock( &OldIrql );
        }

        if (((SectionObjectPointers = FileObject->SectionObjectPointer) != NULL) &&
            ((SharedCacheMap = SectionObjectPointers->SharedCacheMap) != NULL) &&
            (SharedCacheMap->DirtyPageThreshold != 0) &&
            (SharedCacheMap->DirtyPages != 0) &&
            ((PagesToWrite + SharedCacheMap->DirtyPages) >
              SharedCacheMap->DirtyPageThreshold)) {

            ExceededPerFileThreshold = TRUE;
        }

        if (Retrying != MAXUCHAR) {
            CcReleaseMasterLock( OldIrql );
        }
    }

    //
    //  See if it is ok to do the write right now
    //

    if ((Retrying || IsListEmpty(&CcDeferredWrites))

                &&

        (CcTotalDirtyPages + PagesToWrite < CcDirtyPageThreshold)

                &&

        MmEnoughMemoryForWrite()

                &&

        !ExceededPerFileThreshold) {

        return TRUE;
    }

    //
    //  Otherwise, if our caller is synchronous, we will just wait here.
    //

    if (Wait) {

        if (IsListEmpty(&CcDeferredWrites) ) {

            //
            // Get a write scan to occur NOW
            //

            CcAcquireMasterLock( &OldIrql );
            CcScheduleLazyWriteScan( TRUE );
            CcReleaseMasterLock( OldIrql );
        }
    
        KeInitializeEvent( &Event, NotificationEvent, FALSE );

        //
        //  Fill in the block.  Note that we can access the Fsrtl Common Header
        //  even if it's paged because Wait will be FALSE if called from
        //  within the cache.
        //

        DeferredWrite.NodeTypeCode = CACHE_NTC_DEFERRED_WRITE;
        DeferredWrite.NodeByteSize = sizeof(DEFERRED_WRITE);
        DeferredWrite.FileObject = FileObject;
        DeferredWrite.BytesToWrite = BytesToWrite;
        DeferredWrite.Event = &Event;
        DeferredWrite.LimitModifiedPages = BooleanFlagOn(((PFSRTL_COMMON_FCB_HEADER)(FileObject->FsContext))->Flags,
                                                         FSRTL_FLAG_LIMIT_MODIFIED_PAGES);

        //
        //  Now insert at the appropriate end of the list
        //

        if (Retrying) {
            ExInterlockedInsertHeadList( &CcDeferredWrites,
                                         &DeferredWrite.DeferredWriteLinks,
                                         &CcDeferredWriteSpinLock );
        } else {
            ExInterlockedInsertTailList( &CcDeferredWrites,
                                         &DeferredWrite.DeferredWriteLinks,
                                         &CcDeferredWriteSpinLock );
        }

        while (TRUE) {

            //
            //  Now since we really didn't synchronize anything but the insertion,
            //  we call the post routine to make sure that in some wierd case we
            //  do not leave anyone hanging with no dirty bytes for the Lazy Writer.
            //

            CcPostDeferredWrites();

            //
            //  Finally wait until the event is signaled and we can write
            //  and return to tell the guy he can write.
            //

            if (KeWaitForSingleObject( &Event,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       &CcIdleDelay ) == STATUS_SUCCESS) {


                return TRUE;
            }
        }

    } else {
        return FALSE;
    }
}


VOID
CcDeferWrite (
    __in PFILE_OBJECT FileObject,
    __in PCC_POST_DEFERRED_WRITE PostRoutine,
    __in PVOID Context1,
    __in PVOID Context2,
    __in ULONG BytesToWrite,
    __in BOOLEAN Retrying
    )

/*++

Routine Description:

    This routine may be called to have the Cache Manager defer posting
    of a write until the Lazy Writer makes some progress writing, or
    there are more available pages.  A file system would normally call
    this routine after receiving FALSE from CcCanIWrite, and preparing
    the request to be posted.

Arguments:

    FileObject - for the file to be written

    PostRoutine - Address of the PostRoutine that the Cache Manager can
                  call to post the request when conditions are right.  Note
                  that it is possible that this routine will be called
                  immediately from this routine.

    Context1 - First context parameter for the post routine.

    Context2 - Second parameter for the post routine.

    BytesToWrite - Number of bytes that the request is trying to write
                   to the cache.

    Retrying - Supplied as FALSE if the request is being posted for the
               first time, TRUE otherwise.

Return Value:

    None

--*/

{
    PDEFERRED_WRITE DeferredWrite;
    KIRQL OldIrql;

    //
    //  Attempt to allocate a deferred write block, and if we do not get
    //  one, just post it immediately rather than gobbling up must succeed
    //  pool.
    //

    DeferredWrite = ExAllocatePoolWithTag( NonPagedPool, sizeof(DEFERRED_WRITE), 'wDcC' );

    if (DeferredWrite == NULL) {
        (*PostRoutine)( Context1, Context2 );
        return;
    }

    //
    //  Fill in the block.
    //

    DeferredWrite->NodeTypeCode = CACHE_NTC_DEFERRED_WRITE;
    DeferredWrite->NodeByteSize = sizeof(DEFERRED_WRITE);
    DeferredWrite->FileObject = FileObject;
    DeferredWrite->BytesToWrite = BytesToWrite;
    DeferredWrite->Event = NULL;
    DeferredWrite->PostRoutine = PostRoutine;
    DeferredWrite->Context1 = Context1;
    DeferredWrite->Context2 = Context2;
    DeferredWrite->LimitModifiedPages = BooleanFlagOn(((PFSRTL_COMMON_FCB_HEADER)(FileObject->FsContext))->Flags,
                                                      FSRTL_FLAG_LIMIT_MODIFIED_PAGES);

    //
    //  Now insert at the appropriate end of the list
    //

    if (Retrying) {
        ExInterlockedInsertHeadList( &CcDeferredWrites,
                                     &DeferredWrite->DeferredWriteLinks,
                                     &CcDeferredWriteSpinLock );
    } else {
        ExInterlockedInsertTailList( &CcDeferredWrites,
                                     &DeferredWrite->DeferredWriteLinks,
                                     &CcDeferredWriteSpinLock );
    }

    //
    //  Now since we really didn't synchronize anything but the insertion,
    //  we call the post routine to make sure that in some wierd case we
    //  do not leave anyone hanging with no dirty bytes for the Lazy Writer.
    //

    CcPostDeferredWrites();

    //
    //  Schedule the lazy writer in case the reason we're blocking
    //  is that we're waiting for Mm (or some other external flag)
    //  to lower and let this write happen.  He will be the one to
    //  keep coming back and checking if this can proceed, even if
    //  there are no cache manager pages to write.
    //
            
    CcAcquireMasterLock( &OldIrql);
            
    if (!LazyWriter.ScanActive) {
        CcScheduleLazyWriteScan( FALSE );
    }

    CcReleaseMasterLock( OldIrql);
}


VOID
CcPostDeferredWrites (
    )

/*++

Routine Description:

    This routine may be called to see if any deferred writes should be posted
    now, and to post them.  It should be called any time the status of the
    queue may have changed, such as when a new entry has been added, or the
    Lazy Writer has finished writing out buffers and set them clean.

Arguments:

    None

Return Value:

    None

--*/

{
    PDEFERRED_WRITE DeferredWrite;
    ULONG TotalBytesLetLoose = 0;
    KIRQL OldIrql;

    do {

        //
        //  Initially clear the deferred write structure pointer
        //  and synchronize.
        //

        DeferredWrite = NULL;

        ExAcquireSpinLock( &CcDeferredWriteSpinLock, &OldIrql );

        //
        //  If the list is empty we are done.
        //

        if (!IsListEmpty(&CcDeferredWrites)) {

            PLIST_ENTRY Entry;

            Entry = CcDeferredWrites.Flink;

            while (Entry != &CcDeferredWrites) {

                DeferredWrite = CONTAINING_RECORD( Entry,
                                                   DEFERRED_WRITE,
                                                   DeferredWriteLinks );

                //
                //  Check for a paranoid case here that TotalBytesLetLoose
                //  wraps.  We stop processing the list at this time.
                //

                TotalBytesLetLoose += DeferredWrite->BytesToWrite;

                if (TotalBytesLetLoose < DeferredWrite->BytesToWrite) {

                    DeferredWrite = NULL;
                    break;
                }

                //
                //  If it is now ok to post this write, remove him from
                //  the list.
                //

                if (CcCanIWrite( DeferredWrite->FileObject,
                                 TotalBytesLetLoose,
                                 FALSE,
                                 MAXUCHAR - 1 )) {

                    RemoveEntryList( &DeferredWrite->DeferredWriteLinks );
                    break;

                //
                //  Otherwise, it is time to stop processing the list, so
                //  we clear the pointer again unless we throttled this item
                //  because of a private dirty page limit.
                //

                } else {

                    //
                    //  If this was a private throttle, skip over it and
                    //  remove its byte count from the running total.
                    //

                    if (DeferredWrite->LimitModifiedPages) {

                        Entry = Entry->Flink;
                        TotalBytesLetLoose -= DeferredWrite->BytesToWrite;
                        DeferredWrite = NULL;
                        continue;

                    } else {

                        DeferredWrite = NULL;

                        break;
                    }
                }
            }
        }

        ExReleaseSpinLock( &CcDeferredWriteSpinLock, OldIrql );

        //
        //  If we got something, set the event or call the post routine
        //  and deallocate the structure.
        //

        if (DeferredWrite != NULL) {

            if (DeferredWrite->Event != NULL) {

                KeSetEvent( DeferredWrite->Event, 0, FALSE );

            } else {

                (*DeferredWrite->PostRoutine)( DeferredWrite->Context1,
                                               DeferredWrite->Context2 );
                ExFreePool( DeferredWrite );
            }
        }

    //
    //  Loop until we find no more work to do.
    //

    } while (DeferredWrite != NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\cache\ccperf.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

   CcPerf.c

Abstract:

    This module contains the perf trace routines in Cc Component

--*/

#include "cc.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEWMI, CcPerfFileRunDown)
#endif //ALLOC_PRAGMA

VOID
CcPerfFileRunDown(
    PPERFINFO_ENTRY_TABLE HashTable
    )
/*++

Routine Description:

    This routine walks the following lists:

    1. CcDirtySharedCacheMapList
    2. CcCleanSharedCacheMapList
    
    and returns a pointer to a pool allocation
    containing the referenced file object pointers.

Arguments:
 
    None.
 
Return Value:
 
    Returns a pointer to a NULL terminated pool allocation 
    containing the file object pointers from the two lists, 
    NULL if the memory could not be allocated.
     
    It is also the responsibility of the caller to dereference each
    file object in the list and then free the returned pool.

Environment:

    PASSIVE_LEVEL, arbitrary thread context.
--*/
{
    KIRQL OldIrql;
    PSHARED_CACHE_MAP SharedCacheMap;

    ASSERT (KeGetCurrentIrql () == PASSIVE_LEVEL);

    CcAcquireMasterLock( &OldIrql );

    //
    // Walk through CcDirtySharedCacheMapList
    //
    
    SharedCacheMap = CONTAINING_RECORD( CcDirtySharedCacheMapList.SharedCacheMapLinks.Flink,
                                        SHARED_CACHE_MAP,
                                        SharedCacheMapLinks );
    
    while (&SharedCacheMap->SharedCacheMapLinks != &CcDirtySharedCacheMapList.SharedCacheMapLinks) {
        //
        //  Skip over cursors
        //
        if (!FlagOn(SharedCacheMap->Flags, IS_CURSOR)) {
            PerfInfoAddToFileHash(HashTable, SharedCacheMap->FileObject);
        }
        SharedCacheMap = CONTAINING_RECORD( SharedCacheMap->SharedCacheMapLinks.Flink,
                                            SHARED_CACHE_MAP,
                                            SharedCacheMapLinks );
    }                   

    //
    // CcCleanSharedCacheMapList
    //
    SharedCacheMap = CONTAINING_RECORD( CcCleanSharedCacheMapList.Flink,
                                        SHARED_CACHE_MAP,
                                        SharedCacheMapLinks );

    while (&SharedCacheMap->SharedCacheMapLinks != &CcCleanSharedCacheMapList) {
        PerfInfoAddToFileHash(HashTable, SharedCacheMap->FileObject);

        SharedCacheMap = CONTAINING_RECORD( SharedCacheMap->SharedCacheMapLinks.Flink,
                                            SHARED_CACHE_MAP,
                                            SharedCacheMapLinks );

    }

    CcReleaseMasterLock( OldIrql );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmalloc.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmalloc.c

Abstract:

    Provides routines for implementing the registry's own pool allocator.

--*/

#include "cmp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,CmpInitCmPrivateAlloc)
#pragma alloc_text(PAGE,CmpDestroyCmPrivateAlloc)
#pragma alloc_text(PAGE,CmpAllocateKeyControlBlock)
#pragma alloc_text(PAGE,CmpFreeKeyControlBlock)
#pragma alloc_text(INIT,CmpInitCmPrivateDelayAlloc)
#pragma alloc_text(PAGE,CmpDestroyCmPrivateDelayAlloc)
#pragma alloc_text(PAGE,CmpAllocateDelayItem)
#pragma alloc_text(PAGE,CmpFreeDelayItem)
#endif

typedef struct _CM_ALLOC_PAGE {
    ULONG       FreeCount;		// number of free kcbs
    ULONG       Reserved;		// alignment
    PVOID       AllocPage;      // crud allocations - this member is NOT USED
} CM_ALLOC_PAGE, *PCM_ALLOC_PAGE;

#define CM_KCB_ENTRY_SIZE   sizeof( CM_KEY_CONTROL_BLOCK )
#define CM_KCBS_PER_PAGE    ((PAGE_SIZE - FIELD_OFFSET(CM_ALLOC_PAGE,AllocPage)) / CM_KCB_ENTRY_SIZE)

#define KCB_TO_PAGE_ADDRESS( kcb ) (PVOID)(((ULONG_PTR)(kcb)) & ~(PAGE_SIZE - 1))
#define KCB_TO_ALLOC_PAGE( kcb ) ((PCM_ALLOC_PAGE)KCB_TO_PAGE_ADDRESS(kcb))

LIST_ENTRY          CmpFreeKCBListHead;   // list of free kcbs
BOOLEAN				CmpAllocInited = FALSE;

KGUARDED_MUTEX			CmpAllocBucketLock;                // used to protect the bucket

#define LOCK_ALLOC_BUCKET() KeAcquireGuardedMutex(&CmpAllocBucketLock)
#define UNLOCK_ALLOC_BUCKET() KeReleaseGuardedMutex(&CmpAllocBucketLock)

VOID
CmpInitCmPrivateAlloc( )

/*++

Routine Description:

    Initialize the CmPrivate pool allocation module

Arguments:


Return Value:


--*/

{
    if( CmpAllocInited ) {
        //
        // already initialized
        //
        return;
    }
    
    InitializeListHead(&(CmpFreeKCBListHead));   

    //
	// init the bucket lock
	//
	KeInitializeGuardedMutex(&CmpAllocBucketLock);
	
	CmpAllocInited = TRUE;
}

VOID
CmpDestroyCmPrivateAlloc( )

/*++

Routine Description:

    Frees memory used byt the CmPrivate pool allocation module

Arguments:


Return Value:


--*/

{
    PAGED_CODE();
    
    if( !CmpAllocInited ) {
        return;
    }
}


PCM_KEY_CONTROL_BLOCK
CmpAllocateKeyControlBlock( )

/*++

Routine Description:

    Allocates a kcb; first try from our own allocator.
    If it doesn't work (we have maxed out our number of allocs
    or private allocator is not initialized)
    try from paged pool

Arguments:


Return Value:

    The  new kcb

--*/

{
    USHORT                  j;
    PCM_KEY_CONTROL_BLOCK   kcb = NULL;
	PCM_ALLOC_PAGE			AllocPage;

    PAGED_CODE();
    
    if( !CmpAllocInited ) {
        //
        // not initialized
        //
        goto AllocFromPool;
    }
    
	LOCK_ALLOC_BUCKET();

SearchFreeKcb:
    //
    // try to find a free one
    //
    if( IsListEmpty(&CmpFreeKCBListHead) == FALSE ) {
        //
        // found one
        //
        kcb = (PCM_KEY_CONTROL_BLOCK)RemoveHeadList(&CmpFreeKCBListHead);
        kcb = CONTAINING_RECORD(kcb,
                                CM_KEY_CONTROL_BLOCK,
                                FreeListEntry);

		AllocPage = (PCM_ALLOC_PAGE)KCB_TO_ALLOC_PAGE( kcb );

        ASSERT( AllocPage->FreeCount != 0 );

        AllocPage->FreeCount--;
        
		//
		// set when page was allocated
		//
		ASSERT( kcb->PrivateAlloc == 1);

		UNLOCK_ALLOC_BUCKET();
        return kcb;
    }

    //
    // we need to allocate a new page as we ran out of free kcbs
    //
            
    //
    // allocate a new page and insert all kcbs in the freelist
    //
    AllocPage = (PCM_ALLOC_PAGE)ExAllocatePoolWithTag(PagedPool, PAGE_SIZE, CM_ALLOCATE_TAG|PROTECTED_POOL);
    if( AllocPage == NULL ) {
        //
        // we might be low on pool; maybe small pool chunks will work
        //
		UNLOCK_ALLOC_BUCKET();
        goto AllocFromPool;
    }

	//
	// set up the page
	//
    AllocPage->FreeCount = CM_KCBS_PER_PAGE;

    //
    // now the dirty job; insert all kcbs inside the page in the free list
    //
    for(j=0;j<CM_KCBS_PER_PAGE;j++) {
        kcb = (PCM_KEY_CONTROL_BLOCK)((PUCHAR)AllocPage + FIELD_OFFSET(CM_ALLOC_PAGE,AllocPage) + j*CM_KCB_ENTRY_SIZE);

		//
		// set it here; only once
		//
		kcb->PrivateAlloc = 1;
        kcb->DelayCloseEntry = NULL;
        
        InsertTailList(
            &CmpFreeKCBListHead,
            &(kcb->FreeListEntry)
            );
    }
            
    //
    // this time will find one for sure
    //
    goto SearchFreeKcb;

AllocFromPool:
    kcb = ExAllocatePoolWithTag(PagedPool,
                                sizeof(CM_KEY_CONTROL_BLOCK),
                                CM_KCB_TAG | PROTECTED_POOL);

    if( kcb != NULL ) {
        //
        // clear the private alloc flag
        //
        kcb->PrivateAlloc = 0;
        kcb->DelayCloseEntry = NULL;
    }

    return kcb;
}

#define LogKCBFree(kcb) //nothing

VOID
CmpFreeKeyControlBlock( PCM_KEY_CONTROL_BLOCK kcb )

/*++

Routine Description:

    Frees a kcb; if it's allocated from our own pool put it back in the free list.
    If it's allocated from general pool, just free it.

Arguments:

    kcb to free

Return Value:


--*/
{
    USHORT			j;
	PCM_ALLOC_PAGE	AllocPage;

    PAGED_CODE();

    ASSERT_KEYBODY_LIST_EMPTY(kcb);

#if defined(_WIN64)
    //
    // free cached name if any
    //
    if( (kcb->RealKeyName != NULL) && (kcb->RealKeyName != CMP_KCB_REAL_NAME_UPCASE) ) {
        ExFreePoolWithTag(kcb->RealKeyName, CM_NAME_TAG);
    }
#endif

    if( !kcb->PrivateAlloc ) {
        //
        // just free it and be done with it
        //
        ExFreePoolWithTag(kcb, CM_KCB_TAG | PROTECTED_POOL);
        return;
    }

	LOCK_ALLOC_BUCKET();

    ASSERT_HASH_ENTRY_LOCKED_EXCLUSIVE(kcb->ConvKey);
    LogKCBFree(kcb);

    //
    // add kcb to freelist
    //
    InsertTailList(
        &CmpFreeKCBListHead,
        &(kcb->FreeListEntry)
        );

	//
	// get the page
	//
	AllocPage = (PCM_ALLOC_PAGE)KCB_TO_ALLOC_PAGE( kcb );

    //
	// not all are free
	//
	ASSERT( AllocPage->FreeCount != CM_KCBS_PER_PAGE);

	AllocPage->FreeCount++;

    if( AllocPage->FreeCount == CM_KCBS_PER_PAGE ) {
        //
        // entire page is free; let it go
        //
        //
        // first; iterate through the free kcb list and remove all kcbs inside this page
        //
        for(j=0;j<CM_KCBS_PER_PAGE;j++) {
            kcb = (PCM_KEY_CONTROL_BLOCK)((PUCHAR)AllocPage + FIELD_OFFSET(CM_ALLOC_PAGE,AllocPage) + j*CM_KCB_ENTRY_SIZE);
        
            RemoveEntryList(&(kcb->FreeListEntry));
        }
        ExFreePoolWithTag(AllocPage, CM_ALLOCATE_TAG|PROTECTED_POOL);
    }

	UNLOCK_ALLOC_BUCKET();

}

//
// delay deref and delay close private allocator
//

LIST_ENTRY          CmpFreeDelayItemsListHead;   // list of free delay items

KGUARDED_MUTEX			CmpDelayAllocBucketLock;                // used to protect the bucket

#define LOCK_DELAY_ALLOC_BUCKET() KeAcquireGuardedMutex(&CmpDelayAllocBucketLock)
#define UNLOCK_DELAY_ALLOC_BUCKET() KeReleaseGuardedMutex(&CmpDelayAllocBucketLock)



#define CM_DELAY_ALLOC_ENTRY_SIZE   sizeof( CM_DELAY_ALLOC )
#define CM_DELAYS_PER_PAGE          ((PAGE_SIZE - FIELD_OFFSET(CM_ALLOC_PAGE,AllocPage)) / CM_DELAY_ALLOC_ENTRY_SIZE)

#define DELAY_ALLOC_TO_PAGE_ADDRESS( delay ) (PVOID)(((ULONG_PTR)(delay)) & ~(PAGE_SIZE - 1))
#define DELAY_ALLOC_TO_ALLOC_PAGE( delay )   ((PCM_ALLOC_PAGE)DELAY_ALLOC_TO_PAGE_ADDRESS(delay))


VOID
CmpInitCmPrivateDelayAlloc( )

/*++

Routine Description:

    Initialize the CmPrivate pool allocation module for delay related allocs

Arguments:


Return Value:


--*/

{
    InitializeListHead(&(CmpFreeDelayItemsListHead));   

    //
	// init the bucket lock
	//
	KeInitializeGuardedMutex(&CmpDelayAllocBucketLock);
}

VOID
CmpDestroyCmPrivateDelayAlloc( )

/*++

Routine Description:

    Frees memory used by the CmPrivate pool allocation module

Arguments:


Return Value:


--*/

{
    CM_PAGED_CODE();
}


PVOID
CmpAllocateDelayItem( )

/*++

Routine Description:

    Allocates a delay item from our own pool; 

Arguments:


Return Value:

    The  new item

--*/

{
    USHORT                  j;
    PCM_DELAY_ALLOC         DelayItem = NULL;
	PCM_ALLOC_PAGE			AllocPage;

    CM_PAGED_CODE();
    
    
	LOCK_DELAY_ALLOC_BUCKET();

SearchFreeItem:
    //
    // try to find a free one
    //
    if( CmpIsListEmpty(&CmpFreeDelayItemsListHead) == FALSE ) {
        //
        // found one
        //
        DelayItem = (PCM_DELAY_ALLOC)RemoveHeadList(&CmpFreeDelayItemsListHead);
        DelayItem = CONTAINING_RECORD(  DelayItem,
                                        CM_DELAY_ALLOC,
                                        ListEntry);

        CmpClearListEntry(&(DelayItem->ListEntry));

        AllocPage = (PCM_ALLOC_PAGE)DELAY_ALLOC_TO_ALLOC_PAGE( DelayItem );

        ASSERT( AllocPage->FreeCount != 0 );

        AllocPage->FreeCount--;
        
		UNLOCK_DELAY_ALLOC_BUCKET();
        return DelayItem;
    }

    //
    // we need to allocate a new page as we ran out of free items
    //
            
    //
    // allocate a new page and insert all kcbs in the freelist
    //
    AllocPage = (PCM_ALLOC_PAGE)ExAllocatePoolWithTag(PagedPool, PAGE_SIZE, CM_ALLOCATE_TAG|PROTECTED_POOL);
    if( AllocPage == NULL ) {
        //
        // bad luck
        //
		UNLOCK_DELAY_ALLOC_BUCKET();
        return NULL;
    }

	//
	// set up the page
	//
    AllocPage->FreeCount = CM_DELAYS_PER_PAGE;

    //
    // now the dirty job; insert all items inside the page in the free list
    //
    for(j=0;j<CM_DELAYS_PER_PAGE;j++) {
        DelayItem = (PCM_DELAY_ALLOC)((PUCHAR)AllocPage + FIELD_OFFSET(CM_ALLOC_PAGE,AllocPage) + j*CM_DELAY_ALLOC_ENTRY_SIZE);

        InsertTailList(
            &CmpFreeDelayItemsListHead,
            &(DelayItem->ListEntry)
            );
        DelayItem->Kcb = NULL;
    }
            
    //
    // this time will find one for sure
    //
    goto SearchFreeItem;
}

extern LIST_ENTRY      CmpDelayDerefKCBListHead;
extern LIST_ENTRY      CmpDelayedLRUListHead;

VOID
CmpFreeDelayItem( PVOID Item )

/*++

Routine Description:

    Frees a kcb; if it's allocated from our own pool put it back in the free list.
    If it's allocated from general pool, just free it.

Arguments:

    kcb to free

Return Value:


--*/
{
    USHORT			j;
	PCM_ALLOC_PAGE	AllocPage;
    PCM_DELAY_ALLOC DelayItem = (PCM_DELAY_ALLOC)Item;

    CM_PAGED_CODE();

	LOCK_DELAY_ALLOC_BUCKET();

    //
    // add kcb to freelist
    //
    InsertTailList(
        &CmpFreeDelayItemsListHead,
        &(DelayItem->ListEntry)
        );

	//
	// get the page
	//
    AllocPage = (PCM_ALLOC_PAGE)DELAY_ALLOC_TO_ALLOC_PAGE( DelayItem );

    //
	// not all are free
	//
	ASSERT( AllocPage->FreeCount != CM_DELAYS_PER_PAGE);

	AllocPage->FreeCount++;

    if( AllocPage->FreeCount == CM_DELAYS_PER_PAGE ) {
        //
        // entire page is free; let it go
        //
        //
        // first; iterate through the free item list and remove all items inside this page
        //
        for(j=0;j<CM_DELAYS_PER_PAGE;j++) {
            DelayItem = (PCM_DELAY_ALLOC)((PUCHAR)AllocPage + FIELD_OFFSET(CM_ALLOC_PAGE,AllocPage) + j*CM_DELAY_ALLOC_ENTRY_SIZE);
            CmpRemoveEntryList(&(DelayItem->ListEntry));
        }
        ExFreePoolWithTag(AllocPage, CM_ALLOCATE_TAG|PROTECTED_POOL);
    }

	UNLOCK_DELAY_ALLOC_BUCKET();
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\cache\mdlsup.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    mdlsup.c

Abstract:

    This module implements the Mdl support routines for the Cache subsystem.

--*/

#include "cc.h"

//
//  Debug Trace Level
//

#define me                               (0x00000010)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CcMdlRead)
#pragma alloc_text(PAGE,CcMdlReadComplete)
#pragma alloc_text(PAGE,CcMdlReadComplete2)
#pragma alloc_text(PAGE,CcMdlWriteComplete)
#endif


VOID
CcMdlRead (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __out PMDL *MdlChain,
    __out PIO_STATUS_BLOCK IoStatus
    )

/*++

Routine Description:

    This routine attempts to lock the specified file data in the cache
    and return a description of it in an Mdl along with the correct
    I/O status.  It is *not* safe to call this routine from Dpc level.

    This routine is synchronous, and raises on errors.

    As each call returns, the pages described by the Mdl are
    locked in memory, but not mapped in system space.  If the caller
    needs the pages mapped in system space, then it must map them.

    Note that each call is a "single shot" which should be followed by
    a call to CcMdlReadComplete.  To resume an Mdl-based transfer, the
    caller must form one or more subsequent calls to CcMdlRead with
    appropriately adjusted parameters.

Arguments:

    FileObject - Pointer to the file object for a file which was
                 opened with NO_INTERMEDIATE_BUFFERING clear, i.e., for
                 which CcInitializeCacheMap was called by the file system.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    MdlChain - On output it returns a pointer to an Mdl chain describing
               the desired data.  Note that even if FALSE is returned,
               one or more Mdls may have been allocated, as may be ascertained
               by the IoStatus.Information field (see below).

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.  (STATUS_SUCCESS guaranteed for cache
               hits, otherwise the actual I/O status is returned.)  The
               I/O Information Field indicates how many bytes have been
               successfully locked down in the Mdl Chain.

Return Value:

    None

Raises:

    STATUS_INSUFFICIENT_RESOURCES - If a pool allocation failure occurs.

--*/

{
    PSHARED_CACHE_MAP SharedCacheMap;
    PPRIVATE_CACHE_MAP PrivateCacheMap;
    PVOID CacheBuffer;
    LARGE_INTEGER FOffset;
    PMDL Mdl = NULL;
    PMDL MdlTemp;
    PETHREAD Thread = PsGetCurrentThread();
    ULONG SavedState = 0;
    ULONG OriginalLength = Length;
    ULONG Information = 0;
    PVACB Vacb = NULL;
    ULONG SavedMissCounter = 0;

    ULONG ActivePage;
    ULONG PageIsDirty;
    PVACB ActiveVacb = NULL;

    DebugTrace(+1, me, "CcMdlRead\n", 0 );
    DebugTrace( 0, me, "    FileObject = %08lx\n", FileObject );
    DebugTrace2(0, me, "    FileOffset = %08lx, %08lx\n", FileOffset->LowPart,
                                                          FileOffset->HighPart );
    DebugTrace( 0, me, "    Length = %08lx\n", Length );

    //
    //  Save the current readahead hints.
    //

    MmSavePageFaultReadAhead( Thread, &SavedState );

    //
    //  Get pointer to SharedCacheMap.
    //

    SharedCacheMap = FileObject->SectionObjectPointer->SharedCacheMap;
    PrivateCacheMap = FileObject->PrivateCacheMap;

    //
    //  See if we have an active Vacb, that we need to free.
    //

    GetActiveVacb( SharedCacheMap, OldIrql, ActiveVacb, ActivePage, PageIsDirty );

    //
    //  If there is an end of a page to be zeroed, then free that page now,
    //  so we don't send Greg the uninitialized data...
    //

    if ((ActiveVacb != NULL) || (SharedCacheMap->NeedToZero != NULL)) {

        CcFreeActiveVacb( SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
    }

    //
    //  If read ahead is enabled, then do the read ahead here so it
    //  overlaps with the copy (otherwise we will do it below).
    //  Note that we are assuming that we will not get ahead of our
    //  current transfer - if read ahead is working it should either
    //  already be in memory or else underway.
    //

    if (PrivateCacheMap->Flags.ReadAheadEnabled && (PrivateCacheMap->ReadAheadLength[1] == 0)) {
        CcScheduleReadAhead( FileObject, FileOffset, Length );
    }

    //
    //  Increment performance counters
    //

    CcMdlReadWait += 1;

    //
    //  This is not an exact solution, but when IoPageRead gets a miss,
    //  it cannot tell whether it was CcCopyRead or CcMdlRead, but since
    //  the miss should occur very soon, by loading the pointer here
    //  probably the right counter will get incremented, and in any case,
    //  we hope the errors average out!
    //

    CcMissCounter = &CcMdlReadWaitMiss;

    FOffset = *FileOffset;

    //
    //  Check for read past file size, the caller must filter this case out.
    //

    ASSERT( ( FOffset.QuadPart + (LONGLONG)Length ) <= SharedCacheMap->FileSize.QuadPart );

    //
    //  Put try-finally around the loop to deal with any exceptions
    //

    try {

        //
        //  Not all of the transfer will come back at once, so we have to loop
        //  until the entire transfer is complete.
        //

        while (Length != 0) {

            ULONG ReceivedLength;
            LARGE_INTEGER BeyondLastByte;

            //
            //  Map the data and read it in (if necessary) with the
            //  MmProbeAndLockPages call below.
            //

            CacheBuffer = CcGetVirtualAddress( SharedCacheMap,
                                               FOffset,
                                               &Vacb,
                                               &ReceivedLength );

            if (ReceivedLength > Length) {
                ReceivedLength = Length;
            }

            BeyondLastByte.QuadPart = FOffset.QuadPart + (LONGLONG)ReceivedLength;

            //
            //  Now attempt to allocate an Mdl to describe the mapped data.
            //

            DebugTrace( 0, mm, "IoAllocateMdl:\n", 0 );
            DebugTrace( 0, mm, "    BaseAddress = %08lx\n", CacheBuffer );
            DebugTrace( 0, mm, "    Length = %08lx\n", ReceivedLength );

            Mdl = IoAllocateMdl( CacheBuffer,
                                 ReceivedLength,
                                 FALSE,
                                 FALSE,
                                 NULL );

            DebugTrace( 0, mm, "    <Mdl = %08lx\n", Mdl );

            if (Mdl == NULL) {
                DebugTrace( 0, 0, "Failed to allocate Mdl\n", 0 );

                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }

            DebugTrace( 0, mm, "MmProbeAndLockPages:\n", 0 );
            DebugTrace( 0, mm, "    Mdl = %08lx\n", Mdl );

            //
            //  Set to see if the miss counter changes in order to
            //  detect when we should turn on read ahead.
            //

            SavedMissCounter += CcMdlReadWaitMiss;

            MmSetPageFaultReadAhead( Thread, ADDRESS_AND_SIZE_TO_SPAN_PAGES( CacheBuffer, ReceivedLength ) - 1);
            MmProbeAndLockPages( Mdl, KernelMode, IoReadAccess );

            SavedMissCounter -= CcMdlReadWaitMiss;

            //
            //  Unmap the data now, now that the pages are locked down.
            //

            CcFreeVirtualAddress( Vacb );
            Vacb = NULL;

            //
            //  Now link the Mdl into the caller's chain
            //

            if ( *MdlChain == NULL ) {
                *MdlChain = Mdl;
            } else {
                MdlTemp = CONTAINING_RECORD( *MdlChain, MDL, Next );
                while (MdlTemp->Next != NULL) {
                    MdlTemp = MdlTemp->Next;
                }
                MdlTemp->Next = Mdl;
            }
            Mdl = NULL;

            //
            //  Assume we did not get all the data we wanted, and set FOffset
            //  to the end of the returned data.
            //

            FOffset = BeyondLastByte;

            //
            //  Update number of bytes transferred.
            //

            Information += ReceivedLength;

            //
            //  Calculate length left to transfer.
            //

            Length -= ReceivedLength;
        }
    }
    finally {

        CcMissCounter = &CcThrowAway;

        //
        //  Restore the readahead hints.
        //

        MmResetPageFaultReadAhead( Thread, SavedState );

        if (AbnormalTermination()) {

            //
            //  We may have failed to allocate an Mdl while still having
            //  data mapped.
            //

            if (Vacb != NULL) {
                CcFreeVirtualAddress( Vacb );
            }

            if (Mdl != NULL) {
                IoFreeMdl( Mdl );
            }

            //
            //  Otherwise loop to deallocate the Mdls
            //

            while (*MdlChain != NULL) {
                MdlTemp = (*MdlChain)->Next;

                DebugTrace( 0, mm, "MmUnlockPages/IoFreeMdl:\n", 0 );
                DebugTrace( 0, mm, "    Mdl = %08lx\n", *MdlChain );

                MmUnlockPages( *MdlChain );
                IoFreeMdl( *MdlChain );

                *MdlChain = MdlTemp;
            }

            DebugTrace(-1, me, "CcMdlRead -> Unwinding\n", 0 );

        }
        else {

            //
            //  Now enable read ahead if it looks like we got any misses, and do
            //  the first one.
            //

            if (!FlagOn( FileObject->Flags, FO_RANDOM_ACCESS ) &&
                !PrivateCacheMap->Flags.ReadAheadEnabled &&
                (SavedMissCounter != 0)) {

                CC_SET_PRIVATE_CACHE_MAP (PrivateCacheMap, PRIVATE_CACHE_MAP_READ_AHEAD_ENABLED);
                CcScheduleReadAhead( FileObject, FileOffset, OriginalLength );
            }

            //
            //  Now that we have described our desired read ahead, let's
            //  shift the read history down.
            //

            PrivateCacheMap->FileOffset1 = PrivateCacheMap->FileOffset2;
            PrivateCacheMap->BeyondLastByte1 = PrivateCacheMap->BeyondLastByte2;
            PrivateCacheMap->FileOffset2 = *FileOffset;
            PrivateCacheMap->BeyondLastByte2.QuadPart =
                                FileOffset->QuadPart + (LONGLONG)OriginalLength;

            IoStatus->Status = STATUS_SUCCESS;
            IoStatus->Information = Information;
        }
    }


    DebugTrace( 0, me, "    <MdlChain = %08lx\n", *MdlChain );
    DebugTrace2(0, me, "    <IoStatus = %08lx, %08lx\n", IoStatus->Status,
                                                         IoStatus->Information );
    DebugTrace(-1, me, "CcMdlRead -> VOID\n", 0 );

    return;
}


//
//  First we have the old routine which checks for an entry in the FastIo vector.
//  This routine becomes obsolete for every component that compiles with the new
//  definition of FsRtlMdlReadComplete in fsrtl.h.
//

VOID
CcMdlReadComplete (
    __in PFILE_OBJECT FileObject,
    __in PMDL MdlChain
    )

{
    PDEVICE_OBJECT DeviceObject;
    PFAST_IO_DISPATCH FastIoDispatch;

    DeviceObject = IoGetRelatedDeviceObject( FileObject );
    FastIoDispatch = DeviceObject->DriverObject->FastIoDispatch;

    if ((FastIoDispatch != NULL) &&
        (FastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET(FAST_IO_DISPATCH, MdlWriteComplete)) &&
        (FastIoDispatch->MdlReadComplete != NULL) &&
        FastIoDispatch->MdlReadComplete( FileObject, MdlChain, DeviceObject )) {

        NOTHING;

    } else {
        CcMdlReadComplete2( FileObject, MdlChain );
    }
}

VOID
CcMdlReadComplete2 (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain
    )

/*++

Routine Description:

    This routine must be called at IPL0 after a call to CcMdlRead.  The
    caller must simply supply the address of the MdlChain returned in
    CcMdlRead.

    This call does the following:

        Deletes the MdlChain

Arguments:

    FileObject - Pointer to the file object for a file which was
                 opened with NO_INTERMEDIATE_BUFFERING clear, i.e., for
                 which CcInitializeCacheMap was called by the file system.

    MdlChain - same as returned from corresponding call to CcMdlRead.

Return Value:

    None.
--*/

{
    PMDL MdlNext;

    UNREFERENCED_PARAMETER (FileObject);

    DebugTrace(+1, me, "CcMdlReadComplete\n", 0 );
    DebugTrace( 0, me, "    FileObject = %08lx\n", FileObject );
    DebugTrace( 0, me, "    MdlChain = %08lx\n", MdlChain );

    //
    //  Deallocate the Mdls
    //

    while (MdlChain != NULL) {

        MdlNext = MdlChain->Next;

        DebugTrace( 0, mm, "MmUnlockPages/IoFreeMdl:\n", 0 );
        DebugTrace( 0, mm, "    Mdl = %08lx\n", MdlChain );

        MmUnlockPages( MdlChain );

        IoFreeMdl( MdlChain );

        MdlChain = MdlNext;
    }

    DebugTrace(-1, me, "CcMdlReadComplete -> VOID\n", 0 );
}


VOID
CcPrepareMdlWrite (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __out PMDL *MdlChain,
    __out PIO_STATUS_BLOCK IoStatus
    )

/*++

Routine Description:

    This routine attempts to lock the specified file data in the cache
    and return a description of it in an Mdl along with the correct
    I/O status.  Pages to be completely overwritten may be satisfied
    with emtpy pages.  It is *not* safe to call this routine from Dpc level.

    This call is synchronous and raises on error.

    When this call returns, the caller may immediately begin
    to transfer data into the buffers via the Mdl.

    When the call returns with TRUE, the pages described by the Mdl are
    locked in memory, but not mapped in system space.  If the caller
    needs the pages mapped in system space, then it must map them.
    On the subsequent call to CcMdlWriteComplete the pages will be
    unmapped if they were mapped, and in any case unlocked and the Mdl
    deallocated.

Arguments:

    FileObject - Pointer to the file object for a file which was
                 opened with NO_INTERMEDIATE_BUFFERING clear, i.e., for
                 which CcInitializeCacheMap was called by the file system.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    MdlChain - On output it returns a pointer to an Mdl chain describing
               the desired data.  Note that even if FALSE is returned,
               one or more Mdls may have been allocated, as may be ascertained
               by the IoStatus.Information field (see below).

    IoStatus - Pointer to standard I/O status block to receive the status
               for the in-transfer of the data.  (STATUS_SUCCESS guaranteed
               for cache hits, otherwise the actual I/O status is returned.)
               The I/O Information Field indicates how many bytes have been
               successfully locked down in the Mdl Chain.

Return Value:

    None

--*/

{
    PSHARED_CACHE_MAP SharedCacheMap;
    PVOID CacheBuffer;
    LARGE_INTEGER FOffset;
    PMDL Mdl = NULL;
    PMDL MdlTemp;
    LARGE_INTEGER Temp;
    ULONG SavedState = 0;
    ULONG ZeroFlags = 0;
    ULONG Information = 0;

    KLOCK_QUEUE_HANDLE LockHandle;
    ULONG ActivePage;
    ULONG PageIsDirty;
    PVACB Vacb = NULL;

    DebugTrace(+1, me, "CcPrepareMdlWrite\n", 0 );
    DebugTrace( 0, me, "    FileObject = %08lx\n", FileObject );
    DebugTrace2(0, me, "    FileOffset = %08lx, %08lx\n", FileOffset->LowPart,
                                                          FileOffset->HighPart );
    DebugTrace( 0, me, "    Length = %08lx\n", Length );

    //
    //  Get pointer to SharedCacheMap.
    //

    SharedCacheMap = FileObject->SectionObjectPointer->SharedCacheMap;

    if (!FlagOn(FileObject->Flags, FO_WRITE_THROUGH) &&
        CcForceWriteThrough( FileObject, Length, SharedCacheMap, FALSE )) {

        ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
    }

    //
    //  See if we have an active Vacb, that we need to free.
    //

    GetActiveVacb( SharedCacheMap, LockHandle.OldIrql, Vacb, ActivePage, PageIsDirty );

    //
    //  If there is an end of a page to be zeroed, then free that page now,
    //  so it does not cause our data to get zeroed.  If there is an active
    //  page, free it so we have the correct ValidDataGoal.
    //

    if ((Vacb != NULL) || (SharedCacheMap->NeedToZero != NULL)) {

        CcFreeActiveVacb( SharedCacheMap, Vacb, ActivePage, PageIsDirty );
        Vacb = NULL;
    }

    FOffset = *FileOffset;

    //
    //  Put try-finally around the loop to deal with exceptions
    //

    try {

        //
        //  Not all of the transfer will come back at once, so we have to loop
        //  until the entire transfer is complete.
        //

        while (Length != 0) {

            ULONG ReceivedLength;
            LARGE_INTEGER BeyondLastByte;

            //
            //  Map and see how much we could potentially access at this
            //  FileOffset, then cut it down if it is more than we need.
            //

            CacheBuffer = CcGetVirtualAddress( SharedCacheMap,
                                               FOffset,
                                               &Vacb,
                                               &ReceivedLength );

            if (ReceivedLength > Length) {
                ReceivedLength = Length;
            }

            BeyondLastByte.QuadPart = FOffset.QuadPart + (LONGLONG)ReceivedLength;

            //
            //  At this point we can calculate the ZeroFlags.
            //

            //
            //  We can always zero middle pages, if any.
            //

            ZeroFlags = ZERO_MIDDLE_PAGES;

            //
            //  See if we are completely overwriting the first or last page.
            //

            if (((FOffset.LowPart & (PAGE_SIZE - 1)) == 0) &&
                (ReceivedLength >= PAGE_SIZE)) {
                ZeroFlags |= ZERO_FIRST_PAGE;
            }

            if ((BeyondLastByte.LowPart & (PAGE_SIZE - 1)) == 0) {
                ZeroFlags |= ZERO_LAST_PAGE;
            }

            //
            //  See if the entire transfer is beyond valid data length,
            //  or at least starting from the second page.
            //

            Temp = FOffset;
            Temp.LowPart &= ~(PAGE_SIZE -1);
            KeAcquireInStackQueuedSpinLock( &SharedCacheMap->BcbSpinLock, &LockHandle );
            Temp.QuadPart = SharedCacheMap->ValidDataGoal.QuadPart - Temp.QuadPart;
            KeReleaseInStackQueuedSpinLock( &LockHandle );

            if (Temp.QuadPart <= 0) {
                ZeroFlags |= ZERO_FIRST_PAGE | ZERO_MIDDLE_PAGES | ZERO_LAST_PAGE;
            } else if ((Temp.HighPart == 0) && (Temp.LowPart <= PAGE_SIZE)) {
                ZeroFlags |= ZERO_MIDDLE_PAGES | ZERO_LAST_PAGE;
            }

            (VOID)CcMapAndRead( SharedCacheMap,
                                &FOffset,
                                ReceivedLength,
                                ZeroFlags,
                                TRUE,
                                CacheBuffer );

            //
            //  Now attempt to allocate an Mdl to describe the mapped data.
            //

            DebugTrace( 0, mm, "IoAllocateMdl:\n", 0 );
            DebugTrace( 0, mm, "    BaseAddress = %08lx\n", CacheBuffer );
            DebugTrace( 0, mm, "    Length = %08lx\n", ReceivedLength );

            Mdl = IoAllocateMdl( CacheBuffer,
                                 ReceivedLength,
                                 FALSE,
                                 FALSE,
                                 NULL );

            DebugTrace( 0, mm, "    <Mdl = %08lx\n", Mdl );

            if (Mdl == NULL) {
                DebugTrace( 0, 0, "Failed to allocate Mdl\n", 0 );

                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }

            DebugTrace( 0, mm, "MmProbeAndLockPages:\n", 0 );
            DebugTrace( 0, mm, "    Mdl = %08lx\n", Mdl );

            MmDisablePageFaultClustering(&SavedState);
            MmProbeAndLockPages( Mdl, KernelMode, IoWriteAccess );
            MmEnablePageFaultClustering(SavedState);
            SavedState = 0;

            //
            //  Now that some data (maybe zeros) is locked in memory and
            //  set dirty, it is safe, and necessary for us to advance
            //  valid data goal, so that we will not subsequently ask
            //  for a zero page.  Note if we are extending valid data,
            //  our caller has the file exclusive.
            //

            KeAcquireInStackQueuedSpinLock( &SharedCacheMap->BcbSpinLock, &LockHandle );
            if (BeyondLastByte.QuadPart > SharedCacheMap->ValidDataGoal.QuadPart) {
                SharedCacheMap->ValidDataGoal = BeyondLastByte;
            }
            KeReleaseInStackQueuedSpinLock( &LockHandle );

            //
            //  Unmap the data now, now that the pages are locked down.
            //

            CcFreeVirtualAddress( Vacb );
            Vacb = NULL;

            //
            //  Now link the Mdl into the caller's chain
            //

            if ( *MdlChain == NULL ) {
                *MdlChain = Mdl;
            } else {
                MdlTemp = CONTAINING_RECORD( *MdlChain, MDL, Next );
                while (MdlTemp->Next != NULL) {
                    MdlTemp = MdlTemp->Next;
                }
                MdlTemp->Next = Mdl;
            }
            Mdl = NULL;

            //
            //  Assume we did not get all the data we wanted, and set FOffset
            //  to the end of the returned data.
            //

            FOffset = BeyondLastByte;

            //
            //  Update number of bytes transferred.
            //

            Information += ReceivedLength;

            //
            //  Calculate length left to transfer.
            //

            Length -= ReceivedLength;
        }
    }
    finally {

        if (AbnormalTermination()) {

            if (SavedState != 0) {
                MmEnablePageFaultClustering(SavedState);
            }

            if (Vacb != NULL) {
                CcFreeVirtualAddress( Vacb );
            }

            if (Mdl != NULL) {
                IoFreeMdl( Mdl );
            }

            //
            //  Otherwise loop to deallocate the Mdls
            //

            FOffset = *FileOffset;
            while (*MdlChain != NULL) {
                MdlTemp = (*MdlChain)->Next;

                DebugTrace( 0, mm, "MmUnlockPages/IoFreeMdl:\n", 0 );
                DebugTrace( 0, mm, "    Mdl = %08lx\n", *MdlChain );

                MmUnlockPages( *MdlChain );

                //
                //  Extract the File Offset for this part of the transfer, and
                //  tell the lazy writer to write these pages, since we have
                //  marked them dirty.  Ignore the only exception (allocation
                //  error), and console ourselves for having tried.
                //

                CcSetDirtyInMask( SharedCacheMap, &FOffset, (*MdlChain)->ByteCount );

                FOffset.QuadPart = FOffset.QuadPart + (LONGLONG)((*MdlChain)->ByteCount);

                IoFreeMdl( *MdlChain );

                *MdlChain = MdlTemp;
            }

            DebugTrace(-1, me, "CcPrepareMdlWrite -> Unwinding\n", 0 );
        }
        else {

            IoStatus->Status = STATUS_SUCCESS;
            IoStatus->Information = Information;

            //
            //  Make sure the SharedCacheMap does not go away while
            //  the Mdl write is in progress.  We decrment below.
            //

            CcAcquireMasterLock( &LockHandle.OldIrql );
            CcIncrementOpenCount( SharedCacheMap, 'ldmP' );
            CcReleaseMasterLock( LockHandle.OldIrql );
        }
    }

    DebugTrace( 0, me, "    <MdlChain = %08lx\n", *MdlChain );
    DebugTrace(-1, me, "CcPrepareMdlWrite -> VOID\n", 0 );

    return;
}


//
//  First we have the old routine which checks for an entry in the FastIo vector.
//  This routine becomes obsolete for every component that compiles with the new
//  definition of FsRtlMdlWriteComplete in fsrtl.h.
//

VOID
CcMdlWriteComplete (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in PMDL MdlChain
    )

{
    PDEVICE_OBJECT DeviceObject;
    PFAST_IO_DISPATCH FastIoDispatch;

    DeviceObject = IoGetRelatedDeviceObject( FileObject );
    FastIoDispatch = DeviceObject->DriverObject->FastIoDispatch;

    if ((FastIoDispatch != NULL) &&
        (FastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET(FAST_IO_DISPATCH, MdlWriteComplete)) &&
        (FastIoDispatch->MdlWriteComplete != NULL) &&
        FastIoDispatch->MdlWriteComplete( FileObject, FileOffset, MdlChain, DeviceObject )) {

        NOTHING;

    } else {
        CcMdlWriteComplete2( FileObject, FileOffset, MdlChain );
    }
}

VOID
CcMdlWriteComplete2 (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain
    )

/*++

Routine Description:

    This routine must be called at IPL0 after a call to CcPrepareMdlWrite.
    The caller supplies the ActualLength of data that it actually wrote
    into the buffer, which may be less than or equal to the Length specified
    in CcPrepareMdlWrite.

    This call does the following:

        Makes sure the data up to ActualLength eventually gets written.
        If WriteThrough is FALSE, the data will not be written immediately.
        If WriteThrough is TRUE, then the data is written synchronously.

        Unmaps the pages (if mapped), unlocks them and deletes the MdlChain

Arguments:

    FileObject - Pointer to the file object for a file which was
                 opened with NO_INTERMEDIATE_BUFFERING clear, i.e., for
                 which CcInitializeCacheMap was called by the file system.

    FileOffset - Original file offset read above.

    MdlChain - same as returned from corresponding call to CcPrepareMdlWrite.

Return Value:

    None

--*/

{
    PMDL MdlNext;
    PMDL Mdl;
    PSHARED_CACHE_MAP SharedCacheMap;
    LARGE_INTEGER FOffset;
    IO_STATUS_BLOCK IoStatus;
    KIRQL OldIrql;
    NTSTATUS StatusToRaise = STATUS_SUCCESS;
    BOOLEAN First = FALSE;

    DebugTrace(+1, me, "CcMdlWriteComplete\n", 0 );
    DebugTrace( 0, me, "    FileObject = %08lx\n", FileObject );
    DebugTrace( 0, me, "    MdlChain = %08lx\n", MdlChain );

    SharedCacheMap = FileObject->SectionObjectPointer->SharedCacheMap;

    //
    //  Deallocate the Mdls
    //

    FOffset.QuadPart = *(LONGLONG UNALIGNED *)FileOffset;
    Mdl = MdlChain;

    //
    //  If the MDL is unlocked, this is a retry.
    //
    
    if (FlagOn( MdlChain->MdlFlags, MDL_PAGES_LOCKED )) {
        First = TRUE;
    }
    
    while (Mdl != NULL) {

        MdlNext = Mdl->Next;

        DebugTrace( 0, mm, "MmUnlockPages/IoFreeMdl:\n", 0 );
        DebugTrace( 0, mm, "    Mdl = %08lx\n", Mdl );

        //
        //  Now clear the dirty bits in the Pte and set them in the
        //  Pfn.  The Mdls will not be locked on repeated completion
        //  attempts.
        //

        if (First) {
            MmUnlockPages( Mdl );
        }

        //
        //  Extract the File Offset for this part of the transfer.
        //

        if (FlagOn(FileObject->Flags, FO_WRITE_THROUGH)) {

            MmFlushSection ( FileObject->SectionObjectPointer,
                             &FOffset,
                             Mdl->ByteCount,
                             &IoStatus,
                             MM_FLUSH_ACQUIRE_FILE );

            ASSERT( IoStatus.Status != STATUS_ENCOUNTERED_WRITE_IN_PROGRESS );

            //
            //  If we got an I/O error, remember it.
            //

            if (!NT_SUCCESS(IoStatus.Status)) {
                StatusToRaise = IoStatus.Status;
            }

        } else {

            //
            //  Ignore the only exception (allocation error), and console
            //  ourselves for having tried.
            //

            CcSetDirtyInMask( SharedCacheMap, &FOffset, Mdl->ByteCount );
        }

        FOffset.QuadPart = FOffset.QuadPart + (LONGLONG)(Mdl->ByteCount);

        Mdl = MdlNext;
    }

    //
    //  Remove our open count and check to see if this makes the shared cache
    //  map eligible for lazy close.
    //
    //  We do this now so, on failure, old filesystems which did not expect
    //  writethrough to raise continue to work.  They will be within exception
    //  handling with the Mdl still in the IRP.
    //
    //  Note that non-writethrough is the only one that needs the cache map,
    //  and it'll always work.  Removing the open count for writethrough
    //  could be a minor win.
    //
    
    if (First) {
        
        CcAcquireMasterLock( &OldIrql );

        CcDecrementOpenCount( SharedCacheMap, 'ldmC' );

        if ((SharedCacheMap->OpenCount == 0) &&
            !FlagOn(SharedCacheMap->Flags, WRITE_QUEUED) &&
            (SharedCacheMap->DirtyPages == 0)) {

            //
            //  Move to the dirty list.
            //

            RemoveEntryList( &SharedCacheMap->SharedCacheMapLinks );
            InsertTailList( &CcDirtySharedCacheMapList.SharedCacheMapLinks,
                            &SharedCacheMap->SharedCacheMapLinks );

            //
            //  Make sure the Lazy Writer will wake up, because we
            //  want him to delete this SharedCacheMap.
            //

            LazyWriter.OtherWork = TRUE;
            if (!LazyWriter.ScanActive) {
                CcScheduleLazyWriteScan( FALSE );
            }
        }

        CcReleaseMasterLock( OldIrql );
    }
    
    //
    //  If we got an I/O error, raise it now.  Note that we have not free'd the Mdl
    //  yet so the owning filesystem can retry the completion.
    //

    if (!NT_SUCCESS(StatusToRaise)) {
        ExRaiseStatus( FsRtlNormalizeNtstatus( StatusToRaise,
                                               STATUS_UNEXPECTED_IO_ERROR ));
    }

    //
    //  Otherwise, free the Mdl chain and clean everything up.
    //
    
    Mdl = MdlChain;
    while (Mdl != NULL) {

        MdlNext = Mdl->Next;
        IoFreeMdl( Mdl );
        Mdl = MdlNext;
    }

    DebugTrace(-1, me, "CcMdlWriteComplete -> TRUE\n", 0 );

    return;
}

VOID
CcMdlWriteAbort (
    __in PFILE_OBJECT FileObject,
    __in PMDL MdlChain
    )

/*++

Routine Description:

    This routine must be called at IPL0 after a call to CcPrepareMdlWrite.

    This call does the following:

        Unmaps the pages (if mapped), unlocks them and deletes the MdlChain
        unlike the CcMdlWriteComplete this is only used to do teardown in a non
        success case where we didn't actually write anything

Arguments:

    FileObject - Pointer to the file object for a file which was
                 opened with NO_INTERMEDIATE_BUFFERING clear, i.e., for
                 which CcInitializeCacheMap was called by the file system.

    MdlChain - same as returned from corresponding call to CcPrepareMdlWrite.

Return Value:

    None

--*/

{
    PMDL MdlNext;
    PSHARED_CACHE_MAP SharedCacheMap;
    KIRQL OldIrql;
    BOOLEAN First = FALSE;

    DebugTrace(+1, me, "CcMdlWriteAbort\n", 0 );
    DebugTrace( 0, me, "    FileObject = %08lx\n", FileObject );
    DebugTrace( 0, me, "    MdlChain = %08lx\n", MdlChain );

    SharedCacheMap = FileObject->SectionObjectPointer->SharedCacheMap;

    //
    //  If the MDL is unlocked, we went through completion.
    //
    
    if (FlagOn( MdlChain->MdlFlags, MDL_PAGES_LOCKED )) {
        First = TRUE;
    }
    
    //
    //  Deallocate the Mdls
    //

    while (MdlChain != NULL) {

        MdlNext = MdlChain->Next;

        DebugTrace( 0, mm, "MmUnlockPages/IoFreeMdl:\n", 0 );
        DebugTrace( 0, mm, "    Mdl = %08lx\n", MdlChain );

        if (First) {
            MmUnlockPages( MdlChain );
        }
        IoFreeMdl( MdlChain );
        MdlChain = MdlNext;
    }

    //
    //  Now release our open count.  If this already went through completion,
    //  the opencount is already dropped.
    //

    if (First) {
        
        CcAcquireMasterLock( &OldIrql );

        CcDecrementOpenCount( SharedCacheMap, 'AdmC' );

        //
        //  Check for a possible deletion, this Mdl write may have been the last
        //  reference.
        //

        if ((SharedCacheMap->OpenCount == 0) &&
            !FlagOn(SharedCacheMap->Flags, WRITE_QUEUED) &&
            (SharedCacheMap->DirtyPages == 0)) {

            //
            //  Move to the dirty list.
            //

            RemoveEntryList( &SharedCacheMap->SharedCacheMapLinks );
            InsertTailList( &CcDirtySharedCacheMapList.SharedCacheMapLinks,
                            &SharedCacheMap->SharedCacheMapLinks );

            //
            //  Make sure the Lazy Writer will wake up, because we
            //  want him to delete this SharedCacheMap.
            //

            LazyWriter.OtherWork = TRUE;
            if (!LazyWriter.ScanActive) {
                CcScheduleLazyWriteScan( FALSE );
            }
        }

        CcReleaseMasterLock( OldIrql );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\cache\vacbsup.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    vacbsup.c

Abstract:

    This module implements the support routines for the Virtual Address
    Control Block support for the Cache Manager.  These routines are used
    to manage a large number of relatively small address windows to map
    file data for all forms of cache access.

--*/

#include "cc.h"
#include "ex.h"

//
//  Define our debug constant
//

#define me 0x000000040

//
//  Internal Support Routines.
//

VOID
CcUnmapVacb (
    IN PVACB Vacb,
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN BOOLEAN UnmapBehind
    );

PVACB
CcGetVacbMiss (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN LARGE_INTEGER FileOffset,
    IN OUT PKLOCK_QUEUE_HANDLE LockHandle,
    IN LOGICAL HasBcbListHeads
    );

VOID
CcCalculateVacbLevelLockCount (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN PVACB *VacbArray,
    IN ULONG Level
    );

PVACB
CcGetVacbLargeOffset (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN LONGLONG FileOffset
    );

VOID
CcSetVacbLargeOffset (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN LONGLONG FileOffset,
    IN PVACB Vacb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, CcInitializeVacbs)
#endif

//
//  Define a few macros for manipulating the Vacb array.
//

#define GetVacb(SCM,OFF) (                                                                \
    ((SCM)->SectionSize.QuadPart > VACB_SIZE_OF_FIRST_LEVEL) ?                            \
    CcGetVacbLargeOffset((SCM),(OFF).QuadPart) :                                          \
    (SCM)->Vacbs[(OFF).LowPart >> VACB_OFFSET_SHIFT]                                      \
)

_inline
VOID
SetVacb (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN LARGE_INTEGER Offset,
    IN PVACB Vacb
    )
{
    if (SharedCacheMap->SectionSize.QuadPart > VACB_SIZE_OF_FIRST_LEVEL) {
        CcSetVacbLargeOffset(SharedCacheMap, Offset.QuadPart, Vacb);
    } else if (Vacb < VACB_SPECIAL_FIRST_VALID) {
        SharedCacheMap->Vacbs[Offset.LowPart >> VACB_OFFSET_SHIFT] = Vacb;
    }
}

//
//  Define the macro for referencing the multilevel Vacb array.
//

_inline
VOID
ReferenceVacbLevel (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN PVACB *VacbArray,
    IN ULONG Level,
    IN LONG Amount,
    IN LOGICAL Special
    )
{
    PVACB_LEVEL_REFERENCE VacbReference = VacbLevelReference( SharedCacheMap, VacbArray, Level );

    ASSERT( Amount > 0 ||
            (!Special && VacbReference->Reference >= (0 - Amount)) ||
            ( Special && VacbReference->SpecialReference >= (0 - Amount)));

    if (Special) {
        VacbReference->SpecialReference += Amount;
    } else {
        VacbReference->Reference += Amount;
    }
}

//
//  Define the macros for moving the VACBs on the LRU list
//

#define CcMoveVacbToReuseFree(V)        RemoveEntryList( &(V)->LruList );                 \
                                        InsertHeadList( &CcVacbFreeList, &(V)->LruList );

#define CcMoveVacbToReuseTail(V)        RemoveEntryList( &(V)->LruList );                 \
                                        InsertTailList( &CcVacbLru, &(V)->LruList );

//
//  If the HighPart is nonzero, then we will go to a multi-level structure anyway, which is
//  most easily triggered by returning MAXULONG.
//

#define SizeOfVacbArray(LSZ) (                                                            \
    ((LSZ).HighPart != 0) ? MAXULONG :                                                    \
    ((LSZ).LowPart > (PREALLOCATED_VACBS * VACB_MAPPING_GRANULARITY) ?                    \
     (((LSZ).LowPart >> VACB_OFFSET_SHIFT) * sizeof(PVACB)) :                             \
     (PREALLOCATED_VACBS * sizeof(PVACB)))                                                \
)

//
//  When the VACB array size is extended to make room for the BCB list heads,
//  we need to make sure that the space allocated for these list heads will be 
//  sizeof( LIST_ENTRY ) aligned, since BCB list heads are LIST_ENTRY 
//  structures.  The VACB array size should already be PVOID aligned, so at 
//  most, we will need to increase the size by sizeof( PVOID ).
//

#define GrowArrayForBcbListHeads(_VacbArraySize) {                                        \
    (_VacbArraySize) =                                                                    \
    (_VacbArraySize) + (ULONG)AlignedToSize( (_VacbArraySize) , sizeof(LIST_ENTRY) );     \
}

#define CheckedDec(N) {  \
    ASSERT((N) != 0);    \
    (N) -= 1;            \
}

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,CcInitializeVacbs)
#pragma alloc_text(PAGE,CcCreateVacbArray)
#pragma alloc_text(PAGE,CcUnmapVacb)
#endif


VOID
CcInitializeVacbs(
)

/*++

Routine Description:

    This routine must be called during Cache Manager initialization to
    initialize the Virtual Address Control Block structures.

Arguments:

    None.

Return Value:

    None.

--*/

{
    SIZE_T VacbBytes;
    PVACB NextVacb;

    CcNumberVacbs = (MmSizeOfSystemCacheInPages >> (VACB_OFFSET_SHIFT - PAGE_SHIFT)) - 2;
    VacbBytes = CcNumberVacbs * sizeof(VACB);

    CcVacbs = (PVACB) ExAllocatePoolWithTag( NonPagedPool, VacbBytes, 'aVcC' );

    if (CcVacbs != NULL) {
        CcBeyondVacbs = (PVACB)((PCHAR)CcVacbs + VacbBytes);
        RtlZeroMemory( CcVacbs, VacbBytes );

        InitializeListHead( &CcVacbLru );
        InitializeListHead( &CcVacbFreeList );

        for (NextVacb = CcVacbs; NextVacb < CcBeyondVacbs; NextVacb++) {

            InsertTailList( &CcVacbFreeList, &NextVacb->LruList );
        }
    }
}


PVOID
CcGetVirtualAddressIfMapped (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN LONGLONG FileOffset,
    OUT PVACB *Vacb,
    OUT PULONG ReceivedLength
    )

/*++

Routine Description:

    This routine returns a virtual address for the specified FileOffset,
    iff it is mapped.  Otherwise, it informs the caller that the specified
    virtual address was not mapped.  In the latter case, it still returns
    a ReceivedLength, which may be used to advance to the next view boundary.

Arguments:

    SharedCacheMap - Supplies a pointer to the Shared Cache Map for the file.

    FileOffset - Supplies the desired FileOffset within the file.

    Vach - Returns a Vacb pointer which must be supplied later to free
           this virtual address, or NULL if not mapped.

    ReceivedLength - Returns the number of bytes to the next view boundary,
                     whether the desired file offset is mapped or not.

Return Value:

    The virtual address at which the desired data is mapped, or NULL if it
    is not mapped.

--*/

{
    KIRQL OldIrql;
    ULONG VacbOffset = (ULONG)FileOffset & (VACB_MAPPING_GRANULARITY - 1);
    PVOID Value = NULL;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    //  Generate ReceivedLength return right away.
    //

    *ReceivedLength = VACB_MAPPING_GRANULARITY - VacbOffset;

    //
    //  The VacbPushLock in the SharedCacheMap was introduced to provide 
    //  mutually exclusive synchronization between threads testing to see if 
    //  views are mapped for this stream and threads unmapping views for this
    //  stream from the system cache.  We need to provide synchronization 
    //  across both Cc and Mm's data structure setup in these cases to avoid 
    //  the race described below.
    //
    //  VacbLock must be released during the call to CcUnmapVacb() because it
    //  contains a call to MmUnmapViewInSystemCache() (this routine cannot be 
    //  called with a spinlock held).  It is this MM call that is responsible 
    //  for copying the dirty bit from the PTEs back to the PFN.
    //
    //  During this time the worker thread may call CcFlushCache() on the
    //  Vacb being unmapped.  CcGetVirtualAddressIfMapped() is used to determine
    //  if the Vacb's memory is mapped and will correctly report that the address
    //  is not mapped.  If the address is not mapped, CcFlushCache() will not
    //  call MmSetAddressRangeModified() to propagate the dirty bit from the PTE
    //  to the PFN, but CcFlushCache() will proceed to call MmFlushSection().
    //
    //  This is where we have synchronization problems.  If MmUnmapViewInSystemCache()
    //  is not finished propagating the dirty PTE information back to the
    //  PFN when MmFlushSection() executes, the Mm doesn't think there is any
    //  dirty data to flush.  But, Cc has cleared its dirty hint and seen a 
    //  successful flush, so Cc thinks the data has been flushed.  We are left
    //  with dirty data sitting in memory until:
    //   * the mapped page writer comes along and writes the data,
    //   * the data is dirtied again via the system cache so Cc will try to
    //     flush it again,
    //   * or, the dirty data says in memory forever because the page has
    //     modified writing disabled (only Cc can flush it) and it never gets
    //     dirtied again through the system cache.
    //
    //  The solution to this problem is to introduce the 
    //  SharedCacheMap->VacbPushLock.  This allows for multiple threads to unmap
    //  views as needed, but we synchronize to ensure that no thread is 
    //  unmapping views for this stream (the CcGetVacbMiss() and 
    //  CcUnmapVacbArray() paths) while another thread is checking to see if
    //  that view is still mapped (the CcGetVirtualAddressIfMapped() path).
    //

    ExAcquirePushLockExclusive( &SharedCacheMap->VacbPushLock );

    //
    //  Acquire the Vacb lock to see if the desired offset is already mapped.
    //

    CcAcquireVacbLock( &OldIrql );

    ASSERT( FileOffset <= SharedCacheMap->SectionSize.QuadPart );

    if ((*Vacb = GetVacb( SharedCacheMap, *(PLARGE_INTEGER)&FileOffset )) != NULL) {

        if ((*Vacb)->Overlay.ActiveCount == 0) {
            SharedCacheMap->VacbActiveCount += 1;
        }

        (*Vacb)->Overlay.ActiveCount += 1;

        //
        //  Move this range away from the front to avoid wasting cycles
        //  looking at it for reuse.
        //

        CcMoveVacbToReuseTail( *Vacb );

        Value = (PVOID)((PCHAR)(*Vacb)->BaseAddress + VacbOffset);
    }

    CcReleaseVacbLock( OldIrql );
    
    ExReleasePushLockExclusive( &SharedCacheMap->VacbPushLock );
    
    return Value;
}


PVOID
CcGetVirtualAddress (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN LARGE_INTEGER FileOffset,
    OUT PVACB *Vacb,
    IN OUT PULONG ReceivedLength
    )

/*++

Routine Description:

    This is the main routine for Vacb management.  It may be called to acquire
    a virtual address for a given file offset.  If the desired file offset is
    already mapped, this routine does very little work before returning with
    the desired virtual address and Vacb pointer (which must be supplied to
    free the mapping).

    If the desired virtual address is not currently mapped, then this routine
    claims a Vacb from the tail of the Vacb LRU to reuse its mapping.  This Vacb
    is then unmapped if necessary (normally not required), and mapped to the
    desired address.

Arguments:

    SharedCacheMap - Supplies a pointer to the Shared Cache Map for the file.

    FileOffset - Supplies the desired FileOffset within the file.

    Vacb - Returns a Vacb pointer which must be supplied later to free
           this virtual address.

    ReceivedLength - Returns the number of bytes which are contiguously
                     mapped starting at the virtual address returned.

Return Value:

    The virtual address at which the desired data is mapped.

--*/

{
    KLOCK_QUEUE_HANDLE LockHandle;
    PVACB TempVacb;
    ULONG VacbOffset = FileOffset.LowPart & (VACB_MAPPING_GRANULARITY - 1);
    LOGICAL HasBcbListHeads = FALSE;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    //  Acquire the shared lock on the VacbArray because CcGetVacbMiss()
    //  might unmap a Vacb.  See CcGetVirtualAddressIfMapped() for more
    //  details.
    //
            
    ExAcquirePushLockShared( &SharedCacheMap->VacbPushLock );

    //
    //  If this file has modified writing disabled, it may be large enough to
    //  to use BCB list heads for BCB management.  If this file uses BCB list 
    //  heads for BCB management, mapping a new view may cause more BCB list 
    //  heads to be added to the BcbList.  In this case, we must acquire both 
    //  the SharedCacheMap->BcbSpinLock and the VacbLock to synchronize this 
    //  correctly.  Otherwise, the VACB lock is sufficient for synchronizing 
    //  the VACB lookup.
    //

    if (FlagOn( SharedCacheMap->Flags, MODIFIED_WRITE_DISABLED )) {
        
        HasBcbListHeads = TRUE;
    }

    CcAcquireBcbSpinLockAndVacbLock( HasBcbListHeads, SharedCacheMap, &LockHandle );
    
    ASSERT( FileOffset.QuadPart <= SharedCacheMap->SectionSize.QuadPart );

    if ((TempVacb = GetVacb( SharedCacheMap, FileOffset )) == NULL) {

        TempVacb = CcGetVacbMiss( SharedCacheMap, FileOffset, &LockHandle, HasBcbListHeads );

    } else {

        if (TempVacb->Overlay.ActiveCount == 0) {
            SharedCacheMap->VacbActiveCount += 1;
        }

        TempVacb->Overlay.ActiveCount += 1;
    }

    //
    //  Move this range away from the front to avoid wasting cycles
    //  looking at it for reuse.
    //

    CcMoveVacbToReuseTail( TempVacb );

    CcReleaseBcbSpinLockAndVacbLock( HasBcbListHeads, &LockHandle );

    ExReleasePushLockShared( &SharedCacheMap->VacbPushLock );
    
    //
    //  Now form all outputs.
    //

    *Vacb = TempVacb;
    *ReceivedLength = VACB_MAPPING_GRANULARITY - VacbOffset;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    //  PREfix wants to know this cannot be NULL, otherwise it will complain
    //  about users of this function.
    //

    ASSERT( TempVacb->BaseAddress != NULL );

    return (PVOID)((PCHAR)TempVacb->BaseAddress + VacbOffset);
}


PVACB
CcGetVacbMiss (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN LARGE_INTEGER FileOffset,
    IN OUT PKLOCK_QUEUE_HANDLE LockHandle,
    IN LOGICAL HasBcbListHeads
    )

/*++

Routine Description:

    This is the main routine for Vacb management.  It may be called to acquire
    a virtual address for a given file offset.  If the desired file offset is
    already mapped, this routine does very little work before returning with
    the desired virtual address and Vacb pointer (which must be supplied to
    free the mapping).

    If the desired virtual address is not currently mapped, then this routine
    claims a Vacb from the tail of the Vacb LRU to reuse its mapping.  This Vacb
    is then unmapped if necessary (normally not required), and mapped to the
    desired address.

Arguments:

    SharedCacheMap - Supplies a pointer to the Shared Cache Map for the file.

    FileOffset - Supplies the desired FileOffset within the file.

    LockHandle - Pointer to the LockHandle variable in the caller

    HasBcbListHeads - TRUE if the stream is large enough and of the type to use
        Bcb list head markers, FALSE otherwise.

Return Value:

    The Vacb.

--*/

{
    PSHARED_CACHE_MAP OldSharedCacheMap;
    PVACB Vacb, TempVacb;
    LARGE_INTEGER MappedLength;
    LARGE_INTEGER NormalOffset;
    NTSTATUS Status;
    ULONG ActivePage;
    ULONG PageIsDirty;
    PVACB ActiveVacb = NULL;
    ULONG VacbOffset = FileOffset.LowPart & (VACB_MAPPING_GRANULARITY - 1);

    NormalOffset = FileOffset;
    NormalOffset.LowPart -= VacbOffset;

    //
    //  For files that are not open for random access, we assume sequential
    //  access and periodically unmap unused views behind us as we go, to
    //  keep from hogging memory.
    //
    //  We used to only do this for pure FO_SEQUENTIAL_ONLY access.  The
    //  sequential flags still has an effect (to put the pages at the front
    //  of the standby lists) but we intend for the majority of the file
    //  cache to live on the standby and are willing to take transition
    //  faults to bring it back.  Granted, this exacerbates the problem that
    //  it is hard to figure out how big the filecache really is since even
    //  less of it is going to be mapped at any given time.  It may also
    //  promote the synchronization bottlenecks in view mapping (MmPfnLock)
    //  to the forefront when significant view thrashing occurs.
    //
    //  This isn't as bad as it seems.  When we see access take a view miss,
    //  it is really likely that it is a result of sequential access.  As long
    //  as the pages go onto the back of the standby, they'll live for a while.
    //  The problem we're dealing with here is that the cache can be filled at
    //  high speed, but the working set manager can't possibly trim it as fast,
    //  intelligently, while we have a pretty good guess where the candidate
    //  pages should come from.  We can't let the filecache size make large
    //  excursions, or we'll kick out a lot of valuable pages in the process.
    //

    if (!FlagOn(SharedCacheMap->Flags, RANDOM_ACCESS_SEEN) &&
        ((NormalOffset.LowPart & (SEQUENTIAL_MAP_LIMIT - 1)) == 0) &&
        (NormalOffset.QuadPart >= (SEQUENTIAL_MAP_LIMIT * 2))) {

        //
        //  Use MappedLength as a scratch variable to form the offset
        //  to start unmapping.  We are not synchronized with these past
        //  views, so it is possible that CcUnmapVacbArray will kick out
        //  early when it sees an active view.  That is why we go back
        //  twice the distance, and effectively try to unmap everything
        //  twice.  The second time should normally do it.  If the file
        //  is truly sequential only, then the only collision expected
        //  might be the previous view if we are being called from readahead,
        //  or there is a small chance that we can collide with the
        //  Lazy Writer during the small window where he briefly maps
        //  the file to push out the dirty bits.
        //

        CcReleaseBcbSpinLockAndVacbLock( HasBcbListHeads, LockHandle );
        ExReleasePushLockShared( &SharedCacheMap->VacbPushLock );
        
        MappedLength.QuadPart = NormalOffset.QuadPart - (SEQUENTIAL_MAP_LIMIT * 2);
        CcUnmapVacbArray( SharedCacheMap, &MappedLength, (SEQUENTIAL_MAP_LIMIT * 2), TRUE );

        ExAcquirePushLockShared( &SharedCacheMap->VacbPushLock );
        CcAcquireBcbSpinLockAndVacbLock( HasBcbListHeads, SharedCacheMap, LockHandle );
    }

    //
    //  If there is a free view, move it to the LRU and we're done.
    //

    if (!IsListEmpty(&CcVacbFreeList)) {
    
        Vacb = CONTAINING_RECORD( CcVacbFreeList.Flink, VACB, LruList );
        CcMoveVacbToReuseTail( Vacb );

    } else {

        //
        //  Scan from the front of the lru for the next victim Vacb
        //

        Vacb = CONTAINING_RECORD( CcVacbLru.Flink, VACB, LruList );

        while (TRUE) {

            //
            //  If this guy is not active, break out and use him.  Also, if
            //  it is an Active Vacb, delete it now, because the reader may be idle and we
            //  want to clean up.
            //

            OldSharedCacheMap = Vacb->SharedCacheMap;
            if ((Vacb->Overlay.ActiveCount == 0) ||
                ((ActiveVacb == NULL) &&
                 (OldSharedCacheMap != NULL) &&
                 (OldSharedCacheMap->ActiveVacb == Vacb))) {

                //
                //  The normal case is that the Vacb is no longer mapped
                //  and we can just get out and use it, however, here we
                //  handle the case where it is mapped.
                //

                if (Vacb->BaseAddress != NULL) {


                    //
                    //  If this Vacb is active, it must be the ActiveVacb.
                    //

                    if (Vacb->Overlay.ActiveCount != 0) {

                        //
                        //  Get the active Vacb.
                        //

                        GetActiveVacbAtDpcLevel( Vacb->SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );

                    //
                    //  Otherwise we will break out and use this Vacb.  If it
                    //  is still mapped we can now safely increment the open
                    //  count.
                    //

                    } else {

                        //
                        //  Note that if the SharedCacheMap is currently
                        //  being deleted, we need to skip over
                        //  it, otherwise we will become the second
                        //  deleter.  CcDeleteSharedCacheMap clears the
                        //  pointer in the SectionObjectPointer.
                        //

                        CcAcquireMasterLockAtDpcLevel();
                        if (Vacb->SharedCacheMap->FileObject->SectionObjectPointer->SharedCacheMap ==
                            Vacb->SharedCacheMap) {

                            CcIncrementOpenCount( Vacb->SharedCacheMap, 'mvGS' );
                            CcReleaseMasterLockFromDpcLevel();
                            break;
                        }
                        CcReleaseMasterLockFromDpcLevel();
                    }
                } else {
                    break;
                }
            }

            //
            //  Advance to the next guy if we haven't scanned
            //  the entire list.
            //

            if (Vacb->LruList.Flink != &CcVacbLru) {

                Vacb = CONTAINING_RECORD( Vacb->LruList.Flink, VACB, LruList );

            } else {

                CcReleaseBcbSpinLockAndVacbLock( HasBcbListHeads, LockHandle );

                //
                //  If we found an active vacb, then free it and go back and
                //  try again.  Else it's time to bail.
                //

                if (ActiveVacb != NULL) {
                    CcFreeActiveVacb( ActiveVacb->SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
                    ActiveVacb = NULL;

                    //
                    //  Reacquire spinlocks to loop back and position ourselves at the head
                    //  of the LRU for the next pass.
                    //

                    CcAcquireBcbSpinLockAndVacbLock( HasBcbListHeads,
                                                     SharedCacheMap,
                                                     LockHandle );

                    Vacb = CONTAINING_RECORD( CcVacbLru.Flink, VACB, LruList );

                } else {

                    ExReleasePushLockShared( &SharedCacheMap->VacbPushLock );

                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }
            }
        }
    }

    //
    //  Unlink it from the other SharedCacheMap, so the other
    //  guy will not try to use it when we free the spin lock.
    //

    if (Vacb->SharedCacheMap != NULL) {

        OldSharedCacheMap = Vacb->SharedCacheMap;
        SetVacb( OldSharedCacheMap, Vacb->Overlay.FileOffset, NULL );
        Vacb->SharedCacheMap = NULL;
    }

    //
    //  Mark it in use so no one else will muck with it after
    //  we release the spin lock.
    //

    Vacb->Overlay.ActiveCount = 1;
    SharedCacheMap->VacbActiveCount += 1;

    CcReleaseBcbSpinLockAndVacbLock( HasBcbListHeads, LockHandle );

    //
    //  If the Vacb is already mapped, then unmap it.
    //

    if (Vacb->BaseAddress != NULL) {

        //
        //  Check to see if we need to drain the zone.
        //

        CcDrainVacbLevelZone();

        CcUnmapVacb( Vacb, OldSharedCacheMap, FALSE );

        //
        //  Now we can decrement the open count as we normally
        //  do, possibly deleting the guy.
        //

        CcAcquireMasterLock( &LockHandle->OldIrql );

        //
        //  Now release our open count.
        //

        CcDecrementOpenCount( OldSharedCacheMap, 'mvGF' );

        if ((OldSharedCacheMap->OpenCount == 0) &&
            !FlagOn(OldSharedCacheMap->Flags, WRITE_QUEUED) &&
            (OldSharedCacheMap->DirtyPages == 0)) {

            //
            //  Move to the dirty list.
            //

            RemoveEntryList( &OldSharedCacheMap->SharedCacheMapLinks );
            InsertTailList( &CcDirtySharedCacheMapList.SharedCacheMapLinks,
                            &OldSharedCacheMap->SharedCacheMapLinks );

            //
            //  Make sure the Lazy Writer will wake up, because we
            //  want him to delete this SharedCacheMap.
            //

            LazyWriter.OtherWork = TRUE;
            if (!LazyWriter.ScanActive) {
                CcScheduleLazyWriteScan( FALSE );
            }
        }

        CcReleaseMasterLock( LockHandle->OldIrql );
    }

    //
    //  Assume we are mapping to the end of the section, but
    //  reduce to our normal mapping granularity if the section
    //  is too large.
    //

    MappedLength.QuadPart = SharedCacheMap->SectionSize.QuadPart - NormalOffset.QuadPart;

    if ((MappedLength.HighPart != 0) ||
        (MappedLength.LowPart > VACB_MAPPING_GRANULARITY)) {

        MappedLength.LowPart = VACB_MAPPING_GRANULARITY;
    }

    try {

        //
        //  Now map this one in the system cache.
        //

        DebugTrace( 0, mm, "MmMapViewInSystemCache:\n", 0 );
        DebugTrace( 0, mm, "    Section = %08lx\n", SharedCacheMap->Section );
        DebugTrace2(0, mm, "    Offset = %08lx, %08lx\n",
                                NormalOffset.LowPart,
                                NormalOffset.HighPart );
        DebugTrace( 0, mm, "    ViewSize = %08lx\n", MappedLength.LowPart );

        Status = MmMapViewInSystemCache (SharedCacheMap->Section,
                                         &Vacb->BaseAddress,
                                         &NormalOffset,
                                         &MappedLength.LowPart);
     
        //
        //  Take this opportunity to free the active vacb.
        //

        if (ActiveVacb != NULL) {

            CcFreeActiveVacb( ActiveVacb->SharedCacheMap, ActiveVacb, ActivePage, PageIsDirty );
        }

        if (!NT_SUCCESS (Status)) {
            
            DebugTrace (0, 0, "Error from Map, Status = %08lx\n", Status);

            //
            //  We should make sure this is NULL since the mapping failed.  Our
            //  Vacb->Overlay.ActiveCount == 1 ensures that we are the only
            //  folks accessing this Vacb right now as we set it up so we can
            //  make this assignment without the VacbLock held.
            //
            
            Vacb->BaseAddress = NULL;

            ExRaiseStatus (FsRtlNormalizeNtstatus (Status,
                                                   STATUS_UNEXPECTED_MM_MAP_ERROR));
        }

        DebugTrace( 0, mm, "    <BaseAddress = %p\n", Vacb->BaseAddress );
        DebugTrace( 0, mm, "    <ViewSize = %08lx\n", MappedLength.LowPart );

        //
        //  Make sure the zone contains the worst case number of entries.
        //

        if (SharedCacheMap->SectionSize.QuadPart > VACB_SIZE_OF_FIRST_LEVEL) {

            //
            //  Raise if we cannot preallocate enough buffers.
            //

            if (!CcPrefillVacbLevelZone( CcMaxVacbLevelsSeen - 1,
                                         LockHandle,
                                         FlagOn(SharedCacheMap->Flags, MODIFIED_WRITE_DISABLED),
                                         HasBcbListHeads,
                                         SharedCacheMap )) {

                //
                //  We can't setup the Vacb levels, so we will raise the error
                //  here and the finally clause will do the proper cleanup.
                //

                //
                //  Since the Vacb->BaseAddress is non-NULL we will do the 
                //  proper unmapping work in the finally.
                //

                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }

            //
            //  CcPrefillVacbLevelZone returns with the VacbLock acquired.
            //

        } else {

            CcAcquireBcbSpinLockAndVacbLock( HasBcbListHeads,
                                             SharedCacheMap,
                                             LockHandle );
        }

    } finally {

        if (AbnormalTermination()) {

            if (Vacb->BaseAddress != NULL) {

                CcUnmapVacb( Vacb, SharedCacheMap, FALSE );
            }

            ExReleasePushLockShared( &SharedCacheMap->VacbPushLock );

            //
            //  We just need the VacbLock to synchronize this bit of cleanup.
            //
            
            CcAcquireVacbLock( &LockHandle->OldIrql );
            
            CheckedDec(Vacb->Overlay.ActiveCount);
            CheckedDec(SharedCacheMap->VacbActiveCount);

            //
            //  If there is someone waiting for this count to go to zero,
            //  wake them here.
            //

            if (SharedCacheMap->WaitOnActiveCount != NULL) {
                KeSetEvent( SharedCacheMap->WaitOnActiveCount, 0, FALSE );
            }

            ASSERT( Vacb->SharedCacheMap == NULL );

            CcMoveVacbToReuseFree( Vacb );

            CcReleaseVacbLock( LockHandle->OldIrql );
        }
    }

    //
    //  Finish filling in the Vacb, and store its address in the array in
    //  the Shared Cache Map.  (We have to rewrite the ActiveCount
    //  since it is overlaid.)  To do this we must reacquire the
    //  spin lock one more time.  Note we have to check for the unusual
    //  case that someone beat us to mapping this view, since we had to
    //  drop the spin lock.
    //

    if ((TempVacb = GetVacb( SharedCacheMap, NormalOffset )) == NULL) {

        Vacb->SharedCacheMap = SharedCacheMap;
        Vacb->Overlay.FileOffset = NormalOffset;
        Vacb->Overlay.ActiveCount = 1;

        SetVacb( SharedCacheMap, NormalOffset, Vacb );

    //
    //  This is the unlucky case where we collided with someone else
    //  trying to map the same view.  He can get in because we dropped
    //  the spin lock above.  Rather than allocating events and making
    //  someone wait, considering this case is fairly unlikely, we just
    //  dump this one at the head of the LRU and use the one from the
    //  guy who beat us.
    //

    } else {

        //
        //  Now we have to increment all of the counts for the one that
        //  was already there, then ditch the one we had.
        //

        if (TempVacb->Overlay.ActiveCount == 0) {
            SharedCacheMap->VacbActiveCount += 1;
        }

        TempVacb->Overlay.ActiveCount += 1;

        //
        //  Now unmap the one we mapped and proceed with the other Vacb.
        //  On this path we have to release the spinlock to do the unmap,
        //  and then reacquire the spinlock before cleaning up.
        //

        CcReleaseBcbSpinLockAndVacbLock( HasBcbListHeads, LockHandle );

        CcUnmapVacb( Vacb, SharedCacheMap, FALSE );

        CcAcquireBcbSpinLockAndVacbLock( HasBcbListHeads,
                                         SharedCacheMap,
                                         LockHandle );

        CheckedDec(Vacb->Overlay.ActiveCount);
        CheckedDec(SharedCacheMap->VacbActiveCount);
        Vacb->SharedCacheMap = NULL;

        CcMoveVacbToReuseFree( Vacb );

        Vacb = TempVacb;
    }

    return Vacb;
}


VOID
FASTCALL
CcFreeVirtualAddress (
    IN PVACB Vacb
    )

/*++

Routine Description:

    This routine must be called once for each call to CcGetVirtualAddress
    to free that virtual address.

Arguments:

    Vacb - Supplies the Vacb which was returned from CcGetVirtualAddress.

Return Value:

    None.

--*/

{
    KIRQL OldIrql;
    PSHARED_CACHE_MAP SharedCacheMap = Vacb->SharedCacheMap;

    CcAcquireVacbLock( &OldIrql );

    CheckedDec(Vacb->Overlay.ActiveCount);

    //
    //  If the count goes to zero, then we want to decrement the global
    //  Active count.
    //

    if (Vacb->Overlay.ActiveCount == 0) {

        //
        //  If the SharedCacheMap address is not NULL, then this one is
        //  in use by a shared cache map, and we have to decrement his
        //  count and see if anyone is waiting.
        //

        if (SharedCacheMap != NULL) {

            CheckedDec(SharedCacheMap->VacbActiveCount);

            //
            //  If there is someone waiting for this count to go to zero,
            //  wake them here.
            //

            if (SharedCacheMap->WaitOnActiveCount != NULL) {
                KeSetEvent( SharedCacheMap->WaitOnActiveCount, 0, FALSE );
            }

            //
            //  Go to the back of the LRU to save this range for a bit
            //

            CcMoveVacbToReuseTail( Vacb );

        } else {

            //
            //  This range is no longer referenced, so make it available
            //

            ASSERT( Vacb->BaseAddress == NULL );

            CcMoveVacbToReuseFree( Vacb );
        }

    } else {

        //
        //  This range is still in use, so move it away from the front
        //  so that it doesn't consume cycles being checked.
        //

        CcMoveVacbToReuseTail( Vacb );
    }

    CcReleaseVacbLock( OldIrql );
}


VOID
CcReferenceFileOffset (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN LARGE_INTEGER FileOffset
    )

/*++

Routine Description:

    This is a special form of reference that ensures that the multi-level
    Vacb structures are expanded to cover a given file offset.

Arguments:

    SharedCacheMap - Supplies a pointer to the Shared Cache Map for the file.

    FileOffset - Supplies the desired FileOffset within the file.

Return Value:

    None

--*/

{
    KLOCK_QUEUE_HANDLE LockHandle;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    //  This operation only has meaning if the Vacbs are in the multilevel form.
    //

    if (SharedCacheMap->SectionSize.QuadPart > VACB_SIZE_OF_FIRST_LEVEL) {

        //
        //  Prefill the level zone so that we can expand the tree if required.
        //

        if (!CcPrefillVacbLevelZone( CcMaxVacbLevelsSeen - 1,
                                     &LockHandle,
                                     FlagOn(SharedCacheMap->Flags, MODIFIED_WRITE_DISABLED),
                                     TRUE,
                                     SharedCacheMap )) {

            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }

        ASSERT( FileOffset.QuadPart <= SharedCacheMap->SectionSize.QuadPart );

        SetVacb( SharedCacheMap, FileOffset, VACB_SPECIAL_REFERENCE );

        CcReleaseBcbSpinLockAndVacbLock( TRUE, &LockHandle );
    }

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    return;
}


VOID
CcDereferenceFileOffset (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN LARGE_INTEGER FileOffset
    )

/*++

Routine Description:

    This routine must be called once for each call to CcReferenceFileOffset
    to remove the reference.

Arguments:

    SharedCacheMap - Supplies a pointer to the Shared Cache Map for the file.

    FileOffset - Supplies the desired FileOffset within the file.

Return Value:

    None

--*/

{
    KLOCK_QUEUE_HANDLE LockHandle;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    //  This operation only has meaning if the Vacbs are in the multilevel form.
    //

    if (SharedCacheMap->SectionSize.QuadPart > VACB_SIZE_OF_FIRST_LEVEL) {

        //
        //  Acquire the BcbSpinLock and Vacb lock to synchronize the dereference.
        //

        CcAcquireBcbSpinLockAndVacbLock( TRUE, SharedCacheMap, &LockHandle );

        ASSERT( FileOffset.QuadPart <= SharedCacheMap->SectionSize.QuadPart );

        SetVacb( SharedCacheMap, FileOffset, VACB_SPECIAL_DEREFERENCE );

        CcReleaseBcbSpinLockAndVacbLock( TRUE, &LockHandle );
    }

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    return;
}


VOID
CcWaitOnActiveCount (
    IN PSHARED_CACHE_MAP SharedCacheMap
    )

/*++

Routine Description:

    This routine may be called to wait for outstanding mappings for
    a given SharedCacheMap to go inactive.  It is intended to be called
    from CcUninitializeCacheMap, which is called by the file systems
    during cleanup processing.  In that case this routine only has to
    wait if the user closed a handle without waiting for all I/Os on the
    handle to complete.

    This routine returns each time the active count is decremented.  The
    caller must recheck his wait conditions on return, either waiting for
    the ActiveCount to go to 0, or for specific views to go inactive
    (CcPurgeCacheSection case).

Arguments:

    SharedCacheMap - Supplies the Shared Cache Map on whose VacbActiveCount
                     we wish to wait.

Return Value:

    None.

--*/

{
    KIRQL OldIrql;
    PKEVENT Event;

    //
    //  In the unusual case that we get a cleanup while I/O is still going
    //  on, we can wait here.  The caller must test the count for nonzero
    //  before calling this routine.
    //
    //  Since we are being called from cleanup, we cannot afford to
    //  fail here.
    //

    CcAcquireVacbLock( &OldIrql );

    //
    //  It is possible that the count went to zero before we acquired the
    //  spinlock, so we must handle two cases here.
    //

    if (SharedCacheMap->VacbActiveCount != 0) {

        Event = SharedCacheMap->WaitOnActiveCount;

        if (Event == NULL) {

            //
            //  Take the event.  We avoid dispatcher lock overhead for
            //  every single zero transition by only picking up the event
            //  when we actually need it.
            //

            Event = &SharedCacheMap->Event;

            KeInitializeEvent( Event,
                               NotificationEvent,
                               FALSE );

            SharedCacheMap->WaitOnActiveCount = Event;
        }
        else {
            KeClearEvent( Event );
        }

        CcReleaseVacbLock( OldIrql );

        KeWaitForSingleObject( Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               (PLARGE_INTEGER)NULL);
    } else {

        CcReleaseVacbLock( OldIrql );
    }
}


//
//  Internal Support Routine.
//

VOID
CcUnmapVacb (
    IN PVACB Vacb,
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN BOOLEAN UnmapBehind
    )

/*++

Routine Description:

    This routine may be called to unmap a previously mapped Vacb, and
    clear its BaseAddress field.

Arguments:

    Vacb - Supplies the Vacb which was returned from CcGetVirtualAddress.

    UnmapBehind - If this is a result of our unmap behind logic (the
        only case in which we pay attention to sequential hints)

Return Value:

    None.

--*/

{
    //
    //  Make sure it is mapped.
    //

    ASSERT(SharedCacheMap != NULL);
    ASSERT(Vacb->BaseAddress != NULL);

    //
    //  Call MM to unmap it.
    //

    DebugTrace( 0, mm, "MmUnmapViewInSystemCache:\n", 0 );
    DebugTrace( 0, mm, "    BaseAddress = %08lx\n", Vacb->BaseAddress );

    MmUnmapViewInSystemCache( Vacb->BaseAddress,
                              SharedCacheMap->Section,
                              UnmapBehind &&
                              FlagOn(SharedCacheMap->Flags, ONLY_SEQUENTIAL_ONLY_SEEN) );

    Vacb->BaseAddress = NULL;
}


NTSTATUS
FASTCALL
CcCreateVacbArray (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN LARGE_INTEGER NewSectionSize
    )

/*++

Routine Description:

    This routine must be called when a SharedCacheMap is created to create
    and initialize the initial Vacb array.

Arguments:

    SharedCacheMap - Supplies the shared cache map for which the array is
                     to be created.

    NewSectionSize - Supplies the current size of the section which must be
                     covered by the Vacb array.

Return Value:

    NTSTATUS.

--*/

{
    PVACB *NewAddresses;
    ULONG NewSize, SizeToAllocate;
    PLIST_ENTRY BcbListHead;
    LOGICAL CreateBcbListHeads = FALSE, CreateReference = FALSE;

    NewSize = SizeToAllocate = SizeOfVacbArray(NewSectionSize);

    //
    //  The following limit is greater than the MM limit
    //  (i.e., MM actually only supports even smaller sections).
    //  We have to reject the sign bit, and testing the high byte
    //  for nonzero will surely only catch errors.
    //

    if (NewSectionSize.HighPart & ~(PAGE_SIZE - 1)) {
        return STATUS_SECTION_TOO_BIG;
    }

    //
    //  See if we can use the array inside the shared cache map.
    //

    if (NewSize == (PREALLOCATED_VACBS * sizeof(PVACB))) {

        NewAddresses = &SharedCacheMap->InitialVacbs[0];

    //
    //  Else allocate the array.
    //

    } else {

        //
        //  For large metadata streams, double the size to allocate
        //  an array of Bcb listheads.  Each two Vacb pointers also
        //  gets its own Bcb listhead, thus requiring double the size.
        //

        ASSERT(SIZE_PER_BCB_LIST == (VACB_MAPPING_GRANULARITY * 2));

        //
        //  If this stream is larger than the size for multi-level Vacbs,
        //  then fix the size to allocate the root.
        //

        if (NewSize > VACB_LEVEL_BLOCK_SIZE) {

            ULONG Level = 0;
            ULONG Shift = VACB_OFFSET_SHIFT + VACB_LEVEL_SHIFT;

            NewSize = SizeToAllocate = VACB_LEVEL_BLOCK_SIZE;
            SizeToAllocate += sizeof(VACB_LEVEL_REFERENCE);
            CreateReference = TRUE;

            //
            //  Loop to calculate how many levels we have and how much we have to
            //  shift to index into the first level.
            //

            do {

                Level += 1;
                Shift += VACB_LEVEL_SHIFT;

            } while ((NewSectionSize.QuadPart > ((LONGLONG)1 << Shift)) != 0);

            //
            //  Remember the maximum level ever seen (which is actually Level + 1).
            //

            if (Level >= CcMaxVacbLevelsSeen) {
                ASSERT(Level <= VACB_NUMBER_OF_LEVELS);
                CcMaxVacbLevelsSeen = Level + 1;
            }

        } else {

            //
            //  Does this stream get a Bcb Listhead array?
            //

            if (FlagOn(SharedCacheMap->Flags, MODIFIED_WRITE_DISABLED) &&
                (NewSectionSize.QuadPart > BEGIN_BCB_LIST_ARRAY)) {

                //
                //  Grow the size we need to allocation sufficiently that it
                //  can accommodate the BCB list heads.  This is basically 
                //  doubling the size of the array since we have a BCB list
                //  head (i.e., LIST_ENTRY) for every 2 VACB pointers.
                //

                GrowArrayForBcbListHeads( SizeToAllocate );

                CreateBcbListHeads = TRUE;
            }

            //
            //  Handle the boundary case by giving the proto-level a
            //  reference count.  This will allow us to simply push it
            //  in the expansion case.  In practice, due to pool granularity
            //  this will not change the amount of space allocated
            //

            if (NewSize == VACB_LEVEL_BLOCK_SIZE) {

                SizeToAllocate += sizeof(VACB_LEVEL_REFERENCE);
                CreateReference = TRUE;
            }
        }

        NewAddresses = ExAllocatePoolWithTag( NonPagedPool, SizeToAllocate, 'pVcC' );
        if (NewAddresses == NULL) {
            SharedCacheMap->Status = STATUS_INSUFFICIENT_RESOURCES;
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //
    //  Zero out the Vacb array and the trailing reference counts.
    //

    RtlZeroMemory( (PCHAR)NewAddresses, NewSize );

    if (CreateReference) {

        SizeToAllocate -= sizeof(VACB_LEVEL_REFERENCE);
        RtlZeroMemory( (PCHAR)NewAddresses + SizeToAllocate, sizeof(VACB_LEVEL_REFERENCE) );
    }

    //
    //  Loop to insert the Bcb listheads (if any) in the *descending* order
    //  Bcb list.
    //

    if (CreateBcbListHeads) {

        for (BcbListHead = (PLIST_ENTRY)((PCHAR)NewAddresses + NewSize);
             BcbListHead < (PLIST_ENTRY)((PCHAR)NewAddresses + SizeToAllocate);
             BcbListHead++) {

            InsertHeadList( &SharedCacheMap->BcbList, BcbListHead );
        }
    }

    SharedCacheMap->Vacbs = NewAddresses;
    SharedCacheMap->SectionSize = NewSectionSize;

    return STATUS_SUCCESS;
}


NTSTATUS
CcExtendVacbArray (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN LARGE_INTEGER NewSectionSize
    )

/*++

Routine Description:

    This routine must be called any time the section for a shared cache
    map is extended, in order to extend the Vacb array (if necessary).

Arguments:

    SharedCacheMap - Supplies the shared cache map for which the array is
                     to be created.

    NewSectionSize - Supplies the new size of the section which must be
                     covered by the Vacb array.

Return Value:

    NTSTATUS.

--*/

{
    KLOCK_QUEUE_HANDLE LockHandle;
    PVACB *OldAddresses;
    PVACB *NewAddresses;
    ULONG OldSize;
    ULONG NewSize, SizeToAllocate;
    LARGE_INTEGER NextLevelSize;
    LOGICAL GrowingBcbListHeads = FALSE, CreateReference = FALSE;

    //
    //  The following limit is greater than the MM limit
    //  (i.e., MM actually only supports even smaller sections).
    //  We have to reject the sign bit, and testing the high byte
    //  for nonzero will surely only catch errors.
    //

    if (NewSectionSize.HighPart & ~(PAGE_SIZE - 1)) {
        return STATUS_SECTION_TOO_BIG;
    }

    //
    //  See if we will be growing the Bcb ListHeads, so we can take out the
    //  BCB spin lock.
    //

    if (FlagOn(SharedCacheMap->Flags, MODIFIED_WRITE_DISABLED) &&
        (NewSectionSize.QuadPart > BEGIN_BCB_LIST_ARRAY)) {

        GrowingBcbListHeads = TRUE;
    }

    //
    //  Is there any work to do?
    //

    if (NewSectionSize.QuadPart > SharedCacheMap->SectionSize.QuadPart) {

        //
        //  Handle the growth of the first level here.
        //

        if (SharedCacheMap->SectionSize.QuadPart < VACB_SIZE_OF_FIRST_LEVEL) {

            NextLevelSize = NewSectionSize;

            //
            //  Limit the growth of this level
            //

            if (NextLevelSize.QuadPart >= VACB_SIZE_OF_FIRST_LEVEL) {
                NextLevelSize.QuadPart = VACB_SIZE_OF_FIRST_LEVEL;
                CreateReference = TRUE;
            }

            //
            //  N.B.: SizeOfVacbArray only calculates the size of the VACB
            //  pointer block.  We must adjust for Bcb listheads and the
            //  multilevel reference count.
            //

            NewSize = SizeToAllocate = SizeOfVacbArray(NextLevelSize);
            OldSize = SizeOfVacbArray(SharedCacheMap->SectionSize);

            //
            //  Only do something if the size is growing.
            //

            if (NewSize > OldSize) {

                //
                //  Does this stream get a Bcb Listhead array?
                //

                if (GrowingBcbListHeads) {
                    
                    //
                    //  Grow the size we need to allocation sufficiently that it
                    //  can accommodate the BCB list heads.  This is basically 
                    //  doubling the size of the array since we have a BCB list
                    //  head (i.e., LIST_ENTRY) for every 2 VACB pointers.
                    //

                    GrowArrayForBcbListHeads( SizeToAllocate );
                }

                //
                //  Do we need space for the reference count?
                //

                if (CreateReference) {
                    SizeToAllocate += sizeof(VACB_LEVEL_REFERENCE);
                }

                NewAddresses = ExAllocatePoolWithTag( NonPagedPool, SizeToAllocate, 'pVcC' );
                if (NewAddresses == NULL) {
                    return STATUS_INSUFFICIENT_RESOURCES;
                }

                //
                //  See if we will be growing the Bcb ListHeads, if so we need
                //  both the BcbSpinLock to sychronize adding the list heads
                //  to the BCB list and the VacbLock to synchronize with anyone
                //  who could be unmapping a view at this time.
                //

                CcAcquireBcbSpinLockAndVacbLock( GrowingBcbListHeads,
                                                 SharedCacheMap,
                                                 &LockHandle );

                OldAddresses = SharedCacheMap->Vacbs;
                if (OldAddresses != NULL) {
                    RtlCopyMemory( NewAddresses, OldAddresses, OldSize );
                } else {
                    OldSize = 0;
                }

                RtlZeroMemory( (PCHAR)NewAddresses + OldSize, NewSize - OldSize );

                if (CreateReference) {

                    SizeToAllocate -= sizeof(VACB_LEVEL_REFERENCE);
                    RtlZeroMemory( (PCHAR)NewAddresses + SizeToAllocate, sizeof(VACB_LEVEL_REFERENCE) );
                }

                //
                //  See if we have to initialize Bcb Listheads.
                //

                if (GrowingBcbListHeads) {

                    LARGE_INTEGER Offset;
                    PLIST_ENTRY BcbListHeadNew, TempEntry;

                    Offset.QuadPart = 0;
                    BcbListHeadNew = (PLIST_ENTRY)((PCHAR)NewAddresses + NewSize );

                    //
                    //  Handle case where the old array had Bcb Listheads.
                    //

                    if ((SharedCacheMap->SectionSize.QuadPart > BEGIN_BCB_LIST_ARRAY) &&
                        (OldAddresses != NULL)) {

                        PLIST_ENTRY BcbListHeadOld;

                        BcbListHeadOld = (PLIST_ENTRY)((PCHAR)OldAddresses + OldSize);

                        //
                        //  Loop to remove each old listhead and insert the new one
                        //  in its place.
                        //

                        do {
                            TempEntry = BcbListHeadOld->Flink;
                            RemoveEntryList( BcbListHeadOld );
                            InsertTailList( TempEntry, BcbListHeadNew );
                            Offset.QuadPart += SIZE_PER_BCB_LIST;
                            BcbListHeadOld += 1;
                            BcbListHeadNew += 1;
                        } while (Offset.QuadPart < SharedCacheMap->SectionSize.QuadPart);

                    //
                    //  Otherwise, handle the case where we are adding Bcb
                    //  Listheads.
                    //

                    } else {

                        TempEntry = SharedCacheMap->BcbList.Blink;

                        //
                        //  Loop through any/all Bcbs to insert the new listheads.
                        //

                        while (TempEntry != &SharedCacheMap->BcbList) {

                            //
                            //  Sit on this Bcb until we have inserted all listheads
                            //  that go before it.
                            //

                            while (Offset.QuadPart <= ((PBCB)CONTAINING_RECORD(TempEntry, BCB, BcbLinks))->FileOffset.QuadPart) {

                                InsertHeadList(TempEntry, BcbListHeadNew);
                                Offset.QuadPart += SIZE_PER_BCB_LIST;
                                BcbListHeadNew += 1;
                            }
                            TempEntry = TempEntry->Blink;
                        }
                    }

                    //
                    //  Now insert the rest of the new listhead entries that were
                    //  not finished in either loop above.
                    //

                    while (Offset.QuadPart < NextLevelSize.QuadPart) {

                        InsertHeadList(&SharedCacheMap->BcbList, BcbListHeadNew);
                        Offset.QuadPart += SIZE_PER_BCB_LIST;
                        BcbListHeadNew += 1;
                    }
                }

                //
                //  These two fields must be changed while still holding the spinlock.
                //

                SharedCacheMap->Vacbs = NewAddresses;
                SharedCacheMap->SectionSize = NextLevelSize;

                //
                //  Now we can free the spinlocks ahead of freeing pool.
                //

                CcReleaseBcbSpinLockAndVacbLock( GrowingBcbListHeads,
                                                 &LockHandle );

                if ((OldAddresses != &SharedCacheMap->InitialVacbs[0]) &&
                    (OldAddresses != NULL)) {
                    ExFreePool( OldAddresses );
                }
            }

            //
            //  Make sure SectionSize gets updated.  It is ok to fall through here
            //  without a spinlock, so long as either Vacbs was not changed, or it
            //  was changed together with SectionSize under the spinlock(s) above.
            //

            SharedCacheMap->SectionSize = NextLevelSize;
        }

        //
        //  Handle extends up to and within multi-level Vacb arrays here.  This is fairly simple.
        //  If no additional Vacb levels are required, then there is no work to do, otherwise
        //  we just have to push the root one or more levels linked through the first pointer
        //  in the new root(s).
        //

        if (NewSectionSize.QuadPart > SharedCacheMap->SectionSize.QuadPart) {

            PVACB *NextVacbArray;
            ULONG NewLevel;
            ULONG Level = 1;
            ULONG Shift = VACB_OFFSET_SHIFT + VACB_LEVEL_SHIFT;

            //
            //  Loop to calculate how many levels we currently have.
            //

            while (SharedCacheMap->SectionSize.QuadPart > ((LONGLONG)1 << Shift)) {

                Level += 1;
                Shift += VACB_LEVEL_SHIFT;
            }

            NewLevel = Level;

            //
            //  Loop to calculate how many levels we need.
            //

            while (((NewSectionSize.QuadPart - 1) >> Shift) != 0) {

                NewLevel += 1;
                Shift += VACB_LEVEL_SHIFT;
            }

            //
            //  Now see if we have any work to do.
            //

            if (NewLevel > Level) {

                //
                //  Remember the maximum level ever seen (which is actually NewLevel + 1).
                //

                if (NewLevel >= CcMaxVacbLevelsSeen) {
                    ASSERT(NewLevel <= VACB_NUMBER_OF_LEVELS);
                    CcMaxVacbLevelsSeen = NewLevel + 1;
                }

                //
                //  Raise if we cannot preallocate enough buffers.
                //

                if (!CcPrefillVacbLevelZone( NewLevel - Level, 
                                             &LockHandle, 
                                             FALSE,
                                             GrowingBcbListHeads,
                                             SharedCacheMap )) {

                    return STATUS_INSUFFICIENT_RESOURCES;
                }

                //
                //  Now if the current Level of the file is 1, we have not been maintaining
                //  a reference count, so we have to calculate it before pushing.  In the
                //  boundary case we have made sure that the reference space is available.
                //

                if (Level == 1) {

                    //
                    //  We know this is always a leaf-like level right now.
                    //

                    CcCalculateVacbLevelLockCount( SharedCacheMap, SharedCacheMap->Vacbs, 0 );
                }

                //
                //  Finally, if there are any active pointers in the first level, then we
                //  have to create new levels by adding a new root enough times to create
                //  additional levels.  On the other hand, if the pointer count in the top
                //  level is zero, then we must not do any pushes, because we never allow
                //  empty leaves!
                //

                if (IsVacbLevelReferenced( SharedCacheMap, SharedCacheMap->Vacbs, Level - 1 )) {

                    while (NewLevel > Level++) {

                        ASSERT(CcVacbLevelEntries != 0);
                        NextVacbArray = CcAllocateVacbLevel(FALSE);

                        NextVacbArray[0] = (PVACB)SharedCacheMap->Vacbs;
                        ReferenceVacbLevel( SharedCacheMap, NextVacbArray, Level, 1, FALSE );

                        SharedCacheMap->Vacbs = NextVacbArray;
                    }

                } else {

                    //
                    //  We are now possessed of the additional problem that this level has no
                    //  references but may have Bcb listheads due to the boundary case where
                    //  we have expanded up to the multilevel Vacbs above.  This level can't
                    //  remain at the root and needs to be destroyed.  What we need to do is
                    //  replace it with one of our prefilled (non Bcb) levels and unlink the
                    //  Bcb listheads in the old one.
                    //

                    if (Level == 1 && FlagOn(SharedCacheMap->Flags, MODIFIED_WRITE_DISABLED)) {

                        PLIST_ENTRY PredecessorListHead, SuccessorListHead;

                        NextVacbArray = SharedCacheMap->Vacbs;
                        SharedCacheMap->Vacbs = CcAllocateVacbLevel(FALSE);

                        PredecessorListHead = ((PLIST_ENTRY)((PCHAR)NextVacbArray + VACB_LEVEL_BLOCK_SIZE))->Flink;
                        SuccessorListHead = ((PLIST_ENTRY)((PCHAR)NextVacbArray + (VACB_LEVEL_BLOCK_SIZE * 2) - sizeof(LIST_ENTRY)))->Blink;
                        PredecessorListHead->Blink = SuccessorListHead;
                        SuccessorListHead->Flink = PredecessorListHead;

                        CcDeallocateVacbLevel( NextVacbArray, TRUE );
                    }
                }

                //
                //  These two fields (Vacbs and SectionSize) must be changed while still
                //  holding the spinlock.
                //

                SharedCacheMap->SectionSize = NewSectionSize;

                CcReleaseBcbSpinLockAndVacbLock( GrowingBcbListHeads, &LockHandle );
            }

            //
            //  Make sure SectionSize gets updated.  It is ok to fall through here
            //  without a spinlock, so long as either Vacbs was not changed, or it
            //  was changed together with SectionSize under the spinlock(s) above.
            //

            SharedCacheMap->SectionSize = NewSectionSize;
        }
    }
    return STATUS_SUCCESS;
}


BOOLEAN
FASTCALL
CcUnmapVacbArray (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN PLARGE_INTEGER FileOffset OPTIONAL,
    IN ULONG Length,
    IN BOOLEAN UnmapBehind
    )

/*++

Routine Description:

    This routine must be called to do any unmapping and associated
    cleanup for a shared cache map, just before it is deleted.

Arguments:

    SharedCacheMap - Supplies a pointer to the shared cache map
                     which is about to be deleted.

    FileOffset - If supplied, only unmap the specified offset and length

    Length - Completes range to unmap if FileOffset specified.  If FileOffset
             is specified, Length of 0 means unmap to the end of the section.

    UnmapBehind - If this is a result of our unmap behind logic

Return Value:

    FALSE -- if an the unmap was not done due to an active vacb
    TRUE -- if the unmap was done

--*/

{
    PVACB Vacb;
    KLOCK_QUEUE_HANDLE LockHandle;
    LARGE_INTEGER StartingFileOffset = {0,0};
    LARGE_INTEGER EndingFileOffset = SharedCacheMap->SectionSize;
    LOGICAL HasBcbListHeads = FALSE;

    //
    //  We could be just cleaning up for error recovery.
    //

    if (SharedCacheMap->Vacbs == NULL) {
        return TRUE;
    }

    //
    //  See if a range was specified. Align it to the VACB boundaries so it
    //  works in the loop below
    //

    if (ARGUMENT_PRESENT(FileOffset)) {
        StartingFileOffset.QuadPart = ((FileOffset->QuadPart) & (~((LONGLONG)VACB_MAPPING_GRANULARITY - 1)));
        if (Length != 0) {

            EndingFileOffset.QuadPart = FileOffset->QuadPart + Length;

        }
    }

    //
    //  If this file uses BCB list heads for BCB management, mapping a new view 
    //  may cause more BCB list heads to be added to the BcbList.  In this case,
    //  we must acquire both the SharedCacheMap->BcbSpinLock and the VacbLock 
    //  to synchronize this correctly.  Otherwise, the VACB lock is sufficient 
    //  for synchronizing the VACB manipulations.
    //

    if ((SharedCacheMap->SectionSize.QuadPart > BEGIN_BCB_LIST_ARRAY) && 
        FlagOn( SharedCacheMap->Flags, MODIFIED_WRITE_DISABLED )) {
        
        HasBcbListHeads = TRUE;
    }

    //
    //  Acquire the SCM's VacbPushLock to synchronize with threads checking for 
    //  views to be mapped (see large comment in CcGetVirtualAddressIfMapped).
    //  Acquire VACB spin lock to sychronizes our view management.
    //

    ExAcquirePushLockShared( &SharedCacheMap->VacbPushLock );

    //
    //  Acquire the appropriate spin locks to synchronize the VACB lookup and
    //  unmapping.
    //

    CcAcquireBcbSpinLockAndVacbLock( HasBcbListHeads, SharedCacheMap, &LockHandle );
    
    while (StartingFileOffset.QuadPart < EndingFileOffset.QuadPart) {

        //
        //  Note that the caller with an explicit range may be off the
        //  end of the section (example CcPurgeCacheSection for cache
        //  coherency).  That is the reason for the first part of the
        //  test below.
        //
        //  Check the next cell once without the spin lock, it probably will
        //  not change, but we will handle it if it does not.
        //

        if ((StartingFileOffset.QuadPart < SharedCacheMap->SectionSize.QuadPart) &&
            ((Vacb = GetVacb( SharedCacheMap, StartingFileOffset )) != NULL)) {

            //
            //  Return here if we are unlucky and see an active
            //  Vacb.  It could be Purge calling, and the Lazy Writer
            //  may have done a CcGetVirtualAddressIfMapped!
            //

            if (Vacb->Overlay.ActiveCount != 0) {

                CcReleaseBcbSpinLockAndVacbLock( HasBcbListHeads, &LockHandle );
                ExReleasePushLockShared( &SharedCacheMap->VacbPushLock );
                return FALSE;
            }

            //
            //  Unlink it from the other SharedCacheMap, so the other
            //  guy will not try to use it when we free the spin lock.
            //

            SetVacb( SharedCacheMap, StartingFileOffset, NULL );
            Vacb->SharedCacheMap = NULL;

            //
            //  Increment the open count so that no one else will
            //  try to unmap or reuse until we are done.
            //

            Vacb->Overlay.ActiveCount += 1;

            //
            //  Release the spin lock(s).
            //

            CcReleaseBcbSpinLockAndVacbLock( HasBcbListHeads, &LockHandle );

            //
            //  Unmap and free it if we really got it above.
            //

            CcUnmapVacb( Vacb, SharedCacheMap, UnmapBehind );

            //
            //  Reacquire the spin lock so that we can decrment the count.
            //

            CcAcquireBcbSpinLockAndVacbLock( HasBcbListHeads, 
                                             SharedCacheMap, 
                                             &LockHandle );

            Vacb->Overlay.ActiveCount -= 1;

            //
            //  Place this VACB at the head of the LRU
            //

            CcMoveVacbToReuseFree( Vacb );
        }

        StartingFileOffset.QuadPart = StartingFileOffset.QuadPart + VACB_MAPPING_GRANULARITY;
    }

    CcReleaseBcbSpinLockAndVacbLock( HasBcbListHeads, &LockHandle );
    ExReleasePushLockShared( &SharedCacheMap->VacbPushLock );

    CcDrainVacbLevelZone();

    return TRUE;
}


ULONG
CcPrefillVacbLevelZone (
    IN ULONG NumberNeeded,
    OUT PKLOCK_QUEUE_HANDLE LockHandle,
    IN ULONG NeedBcbListHeads,
    IN LOGICAL AcquireBcbSpinLock,
    IN PSHARED_CACHE_MAP SharedCacheMap OPTIONAL
    )

/*++

Routine Description:

    This routine may be called to prefill the VacbLevelZone with the number of
    entries required, and return with CcVacbSpinLock acquired.  This approach is
    taken so that the pool allocations and RtlZeroMemory calls can occur without
    holding any spinlock, yet the caller may proceed to perform a single indivisible
    operation without error handling, since there is a guaranteed minimum number of
    entries in the zone.

Arguments:

    NumberNeeded - Number of VacbLevel entries needed, not counting the possible
                   one with Bcb listheads.

    LockHandle - supplies a pointer to the lock handle which should be used to
                 acquire the BCB spin lock or store the OldIrql if only the VACB
                 lock is acquired.

    NeedBcbListHeads - Supplies true if a level is also needed which contains 
                       listheads.

    AcquireBcbSpinLock - True if the BCB spin lock must be acquired, 
        SharedCacheMap must not be NULL.  False if only the VACB spin lock 
        should be acquired.
        
    SharedCacheMap - SharedCacheMap with the BcbSpinLockToAcquire.

Return Value:

    FALSE if the buffers could not be preallocated, TRUE otherwise.

Environment:

    No spinlocks should be held upon entry.

--*/

{
    PVACB *NextVacbArray;

    CcAcquireBcbSpinLockAndVacbLock( AcquireBcbSpinLock,
                                     SharedCacheMap, 
                                     LockHandle );

    //
    //  Loop until there is enough entries, else return failure...
    //

    while ((NumberNeeded > CcVacbLevelEntries) ||
           (NeedBcbListHeads && (CcVacbLevelWithBcbsFreeList == NULL))) {


        //
        //  Else release the spinlock(s) so we can do the allocate/zero.
        //

        CcReleaseBcbSpinLockAndVacbLock( AcquireBcbSpinLock, LockHandle );

        //
        //  First handle the case where we need a VacbListHead with Bcb Listheads.
        //  The pointer test is unsafe but see below.
        //

        if (NeedBcbListHeads && (CcVacbLevelWithBcbsFreeList == NULL)) {

            //
            //  Allocate and initialize the Vacb block for this level, and store its pointer
            //  back into our parent.  We do not zero the listhead area.
            //

            NextVacbArray =
            (PVACB *)ExAllocatePoolWithTag( NonPagedPool, (VACB_LEVEL_BLOCK_SIZE * 2) + sizeof(VACB_LEVEL_REFERENCE), 'lVcC' );

            if (NextVacbArray == NULL) {
                return FALSE;
            }

            RtlZeroMemory( (PCHAR)NextVacbArray, VACB_LEVEL_BLOCK_SIZE );
            RtlZeroMemory( (PCHAR)NextVacbArray + (VACB_LEVEL_BLOCK_SIZE * 2), sizeof(VACB_LEVEL_REFERENCE) );

            CcAcquireBcbSpinLockAndVacbLock( AcquireBcbSpinLock,
                                             SharedCacheMap, 
                                             LockHandle );

            NextVacbArray[0] = (PVACB)CcVacbLevelWithBcbsFreeList;
            CcVacbLevelWithBcbsFreeList = NextVacbArray;
            CcVacbLevelWithBcbsEntries += 1;

        } else {

            //
            //  Allocate and initialize the Vacb block for this level, and store its pointer
            //  back into our parent.
            //

            NextVacbArray =
            (PVACB *)ExAllocatePoolWithTag( NonPagedPool, VACB_LEVEL_BLOCK_SIZE + sizeof(VACB_LEVEL_REFERENCE), 'lVcC' );

            if (NextVacbArray == NULL) {
                return FALSE;
            }

            RtlZeroMemory( (PCHAR)NextVacbArray, VACB_LEVEL_BLOCK_SIZE + sizeof(VACB_LEVEL_REFERENCE) );

            CcAcquireBcbSpinLockAndVacbLock( AcquireBcbSpinLock,
                                             SharedCacheMap, 
                                             LockHandle );

            NextVacbArray[0] = (PVACB)CcVacbLevelFreeList;
            CcVacbLevelFreeList = NextVacbArray;
            CcVacbLevelEntries += 1;
        }
    }

    return TRUE;
}


VOID
CcDrainVacbLevelZone (
    )

/*++

Routine Description:

    This routine should be called any time some entries have been deallocated to
    the VacbLevel zone, and we want to ensure the zone is returned to a normal level.

Arguments:

Return Value:

    None.

Environment:

    No spinlocks should be held upon entry.

--*/

{
    KIRQL OldIrql;
    PVACB *NextVacbArray;

    //
    //  This is an unsafe loop to see if it looks like there is stuff to
    //  clean up.
    //

    while ((CcVacbLevelEntries > (CcMaxVacbLevelsSeen * 4)) ||
           (CcVacbLevelWithBcbsEntries > 2)) {

        //
        //  Now go in and try to pick up one entry to free under a FastLock.
        //

        NextVacbArray = NULL;
        CcAcquireVacbLock( &OldIrql );
        if (CcVacbLevelEntries > (CcMaxVacbLevelsSeen * 4)) {
            NextVacbArray = CcVacbLevelFreeList;
            CcVacbLevelFreeList = (PVACB *)NextVacbArray[0];
            CcVacbLevelEntries -= 1;
        } else if (CcVacbLevelWithBcbsEntries > 2) {
            NextVacbArray = CcVacbLevelWithBcbsFreeList;
            CcVacbLevelWithBcbsFreeList = (PVACB *)NextVacbArray[0];
            CcVacbLevelWithBcbsEntries -= 1;
        }
        CcReleaseVacbLock( OldIrql );

        //
        //  Since the loop is unsafe, we may not have gotten anything.
        //

        if (NextVacbArray != NULL) {
            ExFreePool(NextVacbArray);
        }
    }
}


PLIST_ENTRY
CcGetBcbListHead (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN LONGLONG FileOffset,
    IN BOOLEAN FailToSuccessor
    )

/*++

Routine Description:

    This routine is called to return the Bcb listhead for the specified FileOffset,
    regardless of the size of the file.

Arguments:

    SharedCacheMap - Supplies the pointer to the SharedCacheMap for which the listhead
                     is desired.

    FileOffset - Supplies the fileOffset corresponding to the desired listhead.

    FailToSuccessor - Instructs whether not finding the exact listhead should cause us to
        return the predecessor or successor Bcb listhead.

Return Value:

    Returns the desired Listhead pointer.  If the desired listhead does not actually exist
    yet, then it returns the appropriate listhead.

Environment:

    The BcbSpinlock should be held on entry.

--*/

{
    PLIST_ENTRY BcbListHead;
    
    if ((SharedCacheMap->SectionSize.QuadPart > BEGIN_BCB_LIST_ARRAY) && 
        FlagOn( SharedCacheMap->Flags, MODIFIED_WRITE_DISABLED )) {

        //
        //  We've got BCB list head markers for this stream, so now do the work to
        //  find the appropriate list head for this offset.
        //

        if (SharedCacheMap->SectionSize.QuadPart > VACB_SIZE_OF_FIRST_LEVEL) {

            //
            //  We are using the multi-level VACB representation for this
            //  stream, so we need to walk the levels to find our BCB list head.
            //

            BcbListHead = CcGetBcbListHeadLargeOffset( SharedCacheMap, 
                                                       FileOffset, 
                                                       FailToSuccessor );
            
        } else {

            //
            //  We have a single array to represent the VACBs for this
            //  stream.  The BCB list heads are allocated contiguously *behind*
            //  the VACBs.
            //

            if (FileOffset >= SharedCacheMap->SectionSize.QuadPart) {

                // 
                //  This offset is beyond the section size, so always return
                //  the list head so we know to stop looking.
                //
                
                BcbListHead = &SharedCacheMap->BcbList;

            } else {

                //
                //  Now calculate the appropriate BCB list head to be returned.
                //  We first need to find where the BCB list head portion of the
                //  VacbArray begins, then index into that portion of the array
                //  to find the right BCB list head.
                //
                //  Each BCB list head represents SIZE_PER_BCB_LIST amount of
                //  data.  (Dividing by SIZE_PER_BCB_LIST is the same as shifting
                //  right by BCB_LIST_SHIFT.)
                //

                PLIST_ENTRY BcbListHeadArray;

                BcbListHeadArray = Add2Ptr( SharedCacheMap->Vacbs, 
                                            SizeOfVacbArray( SharedCacheMap->SectionSize ) );
                BcbListHead = &BcbListHeadArray[ FileOffset >> BCB_LIST_SHIFT ];
            }
        }
        
    } else {

        //
        //  We don't have BCB list heads for this stream, so just return the
        //  shared cache map's BCB list head and let the caller do a linear
        //  search.
        //

        BcbListHead = &SharedCacheMap->BcbList;

    }

    return BcbListHead;
}


PLIST_ENTRY
CcGetBcbListHeadLargeOffset (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN LONGLONG FileOffset,
    IN BOOLEAN FailToSuccessor
    )

/*++

Routine Description:

    This routine may be called to return the Bcb listhead for the specified FileOffset.
    It should only be called if the SectionSize is greater than VACB_SIZE_OF_FIRST_LEVEL.

Arguments:

    SharedCacheMap - Supplies the pointer to the SharedCacheMap for which the listhead
                     is desired.

    FileOffset - Supplies the fileOffset corresponding to the desired listhead.

    FailToSuccessor - Instructs whether not finding the exact listhead should cause us to
        return the predecessor or successor Bcb listhead.

Return Value:

    Returns the desired Listhead pointer.  If the desired listhead does not actually exist
    yet, then it returns the appropriate listhead.

Environment:

    The BcbSpinlock should be held on entry.

--*/

{
    ULONG Level, Shift;
    PVACB *VacbArray, *NextVacbArray;
    ULONG Index;
    ULONG SavedIndexes[VACB_NUMBER_OF_LEVELS];
    PVACB *SavedVacbArrays[VACB_NUMBER_OF_LEVELS];
    ULONG SavedLevels = 0;

    //
    //  Initialize variables controlling our descent into the hierarchy.
    //

    Level = 0;
    Shift = VACB_OFFSET_SHIFT + VACB_LEVEL_SHIFT;
    VacbArray = SharedCacheMap->Vacbs;

    //
    //  Caller must have verified that we have a hierarchy, otherwise this routine
    //  would fail.
    //

    ASSERT(SharedCacheMap->SectionSize.QuadPart > VACB_SIZE_OF_FIRST_LEVEL);

    //
    //  Loop to calculate how many levels we have and how much we have to
    //  shift to index into the first level.
    //

    do {

        Level += 1;
        Shift += VACB_LEVEL_SHIFT;

    } while (SharedCacheMap->SectionSize.QuadPart > ((LONGLONG)1 << Shift));

    //
    //  Our caller could be asking for an offset off the end of section size, so if he
    //  is actually off the size of the level, then return the main listhead.
    //

    if (FileOffset >= ((LONGLONG)1 << Shift)) {
        return &SharedCacheMap->BcbList;
    }

    //
    //  Now descend the tree to the bottom level to get the caller's Bcb ListHead.
    //

    Shift -= VACB_LEVEL_SHIFT;
    do {

        //
        //  Decrement back to the level that describes the size we are within.
        //

        Level -= 1;

        //
        //  Calculate the index into the Vacb block for this level.
        //

        Index = (ULONG)(FileOffset >> Shift);
        ASSERT(Index <= VACB_LAST_INDEX_FOR_LEVEL);

        //
        //  Get block address for next level.
        //

        NextVacbArray = (PVACB *)VacbArray[Index];

        //
        //  If it is NULL then we have to go find the highest Bcb or listhead which
        //  comes before the guy we are looking for, i.e., its predecessor.
        //

        if (NextVacbArray == NULL) {

            //
            //  Back up to look for the highest guy earlier in this tree, i.e., the
            //  predecessor listhead.
            //

            while (TRUE) {

                //
                //  Scan, if we can, in the current array for a non-null index.
                //

                if (FailToSuccessor) {

                    if (Index != VACB_LAST_INDEX_FOR_LEVEL) {

                        while ((Index != VACB_LAST_INDEX_FOR_LEVEL) && (VacbArray[++Index] == NULL)) {
                            continue;
                        }

                        //
                        //  If we found a non-null index, get out and try to return the
                        //  listhead.
                        //

                        if ((NextVacbArray = (PVACB *)VacbArray[Index]) != NULL) {
                            break;
                        }
                    }

                } else {

                    if (Index != 0) {

                        while ((Index != 0) && (VacbArray[--Index] == NULL)) {
                            continue;
                        }

                        //
                        //  If we found a non-null index, get out and try to return the
                        //  listhead.
                        //

                        if ((NextVacbArray = (PVACB *)VacbArray[Index]) != NULL) {
                            break;
                        }
                    }
                }

                //
                //  If there are no saved levels yet, then there is no predecessor or
                //  successor - it is the main listhead.
                //

                if (SavedLevels == 0) {
                    return &SharedCacheMap->BcbList;
                }

                //
                //  Otherwise, we can pop up a level in the tree and start scanning
                //  from that guy for a path to the right listhead.
                //

                Level += 1;
                Index = SavedIndexes[--SavedLevels];
                VacbArray = SavedVacbArrays[SavedLevels];
            }

            //
            //  We have backed up in the hierarchy, so now we are just looking for the
            //  highest/lowest guy in the level we want, i.e., the level-linking listhead.
            //  So smash FileOffset accordingly (we mask the high bits out anyway).
            //

            if (FailToSuccessor) {
                FileOffset = 0;
            } else {
                FileOffset = MAXLONGLONG;
            }
        }

        //
        //  We save Index and VacbArray at each level, for the case that we
        //  have to walk back up the tree to find a predecessor.
        //

        SavedIndexes[SavedLevels] = Index;
        SavedVacbArrays[SavedLevels] = VacbArray;
        SavedLevels += 1;

        //
        //  Now make this one our current pointer, and mask away the extraneous high-order
        //  FileOffset bits for this level.
        //

        VacbArray = NextVacbArray;
        FileOffset &= ((LONGLONG)1 << Shift) - 1;
        Shift -= VACB_LEVEL_SHIFT;

    //
    //  Loop until we hit the bottom level.
    //

    } while (Level != 0);

    //
    //  Now calculate the index for the bottom level and return the appropriate listhead.
    //  (The normal Vacb index indexes to a pointer to a Vacb for a .25MB view, so dropping
    //  the low bit gets you to the even-indexed Vacb pointer which is one block size below
    //  the two-pointer listhead for the Bcbs for that .5MB range...)
    //

    Index = (ULONG)(FileOffset >> Shift);
    return (PLIST_ENTRY)((PCHAR)&VacbArray[Index & ~1] + VACB_LEVEL_BLOCK_SIZE);
}


VOID
CcAdjustVacbLevelLockCount (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN LONGLONG FileOffset,
    IN LONG Adjustment
    )

/*++

Routine Description:

    This routine may be called to adjust the lock count of the bottom Vacb level when
    Bcbs are inserted or deleted.  If the count goes to zero, the level will be
    eliminated.  The bottom level must exist, or we crash!

Arguments:

    SharedCacheMap - Supplies the pointer to the SharedCacheMap for which the Vacb
                     is desired.

    FileOffset - Supplies the fileOffset corresponding to the desired Vacb.

    Adjustment - Generally -1 or +1.

Return Value:

    None.

Environment:

    CcVacbSpinLock should be held on entry.

--*/

{
    ULONG Level, Shift;
    PVACB *VacbArray;
    LONGLONG OriginalFileOffset = FileOffset;

    //
    //  Initialize variables controlling our descent into the hierarchy.
    //

    Level = 0;
    Shift = VACB_OFFSET_SHIFT + VACB_LEVEL_SHIFT;

    VacbArray = SharedCacheMap->Vacbs;

    //
    //  Caller must have verified that we have a hierarchy, otherwise this routine
    //  would fail.
    //

    ASSERT(SharedCacheMap->SectionSize.QuadPart > VACB_SIZE_OF_FIRST_LEVEL);

    //
    //  Loop to calculate how many levels we have and how much we have to
    //  shift to index into the first level.
    //

    do {

        Level += 1;
        Shift += VACB_LEVEL_SHIFT;

    } while (SharedCacheMap->SectionSize.QuadPart > ((LONGLONG)1 << Shift));

    //
    //  Now descend the tree to the bottom level to get the caller's Vacb.
    //

    Shift -= VACB_LEVEL_SHIFT;
    do {

        VacbArray = (PVACB *)VacbArray[(ULONG)(FileOffset >> Shift)];

        Level -= 1;

        FileOffset &= ((LONGLONG)1 << Shift) - 1;

        Shift -= VACB_LEVEL_SHIFT;

    } while (Level != 0);

    //
    //  Now we have reached the final level, do the adjustment.
    //

    ReferenceVacbLevel( SharedCacheMap, VacbArray, Level, Adjustment, FALSE );

    //
    //  Now, if we decremented the count to 0, then force the collapse to happen by
    //  upping count and resetting to NULL.  Then smash OriginalFileOffset to be
    //  the first entry so we do not recalculate!
    //

    if (!IsVacbLevelReferenced( SharedCacheMap, VacbArray, Level )) {
        ReferenceVacbLevel( SharedCacheMap, VacbArray, Level, 1, TRUE );
        OriginalFileOffset &= ~(VACB_SIZE_OF_FIRST_LEVEL - 1);
        CcSetVacbLargeOffset( SharedCacheMap, OriginalFileOffset, VACB_SPECIAL_DEREFERENCE );
    }
}


VOID
CcCalculateVacbLevelLockCount (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN PVACB *VacbArray,
    IN ULONG Level
    )

/*++

Routine Description:

    This routine may be called to calculate or recalculate the lock count on a
    given Vacb level array.  It is called, for example, when we are extending a
    section up to the point where we activate multilevel logic and want to start
    keeping the count.

Arguments:

    SharedCacheMap - Supplies the pointer to the SharedCacheMap for which the Vacb
                     is desired.

    VacbArray - The Vacb Level array to recalculate

    Level - Supplies 0 for the bottom level, nonzero otherwise.

Return Value:

    None.

Environment:

    CcVacbSpinLock should be held on entry.

--*/

{
    PBCB Bcb;
    ULONG Index;
    LONG Count = 0;
    PVACB *VacbTemp = VacbArray;
    PVACB_LEVEL_REFERENCE VacbReference;

    //
    //  First loop through to count how many Vacb pointers are in use.
    //

    for (Index = 0; Index <= VACB_LAST_INDEX_FOR_LEVEL; Index++) {
        if (*(VacbTemp++) != NULL) {
            Count += 1;
        }
    }

    //
    //  If this is a metadata stream, we also have to count the Bcbs in the
    //  corresponding listheads.
    //

    if (FlagOn(SharedCacheMap->Flags, MODIFIED_WRITE_DISABLED) && (Level == 0)) {

        //
        //  Pick up the Blink of the first listhead, casting it to a Bcb.
        //

        Bcb = (PBCB)CONTAINING_RECORD(((PLIST_ENTRY)VacbTemp)->Blink, BCB, BcbLinks);
        Index = 0;

        //
        //  Now loop through the list.  For each Bcb we see, increment the count,
        //  and for each listhead, increment Index.  We are done when we hit the
        //  last listhead, which is actually the next listhead past the ones in this
        //  block.
        //

        do {

            if (Bcb->NodeTypeCode == CACHE_NTC_BCB) {
                Count += 1;
            } else {
                Index += 1;
            }

            Bcb = (PBCB)CONTAINING_RECORD(Bcb->BcbLinks.Blink, BCB, BcbLinks);

        } while (Index <= (VACB_LAST_INDEX_FOR_LEVEL / 2));
    }

    //
    //  Store the count and get out... (by hand, don't touch the special count)
    //

    VacbReference = VacbLevelReference( SharedCacheMap, VacbArray, Level );
    VacbReference->Reference = Count;
}


PVACB
CcGetVacbLargeOffset (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN LONGLONG FileOffset
    )

/*++

Routine Description:

    This routine may be called to return the Vacb for the specified FileOffset.
    It should only be called if the SectionSize is greater than VACB_SIZE_OF_FIRST_LEVEL.

Arguments:

    SharedCacheMap - Supplies the pointer to the SharedCacheMap for which the Vacb
                     is desired.

    FileOffset - Supplies the fileOffset corresponding to the desired Vacb.

Return Value:

    Returns the desired Vacb pointer or NULL if there is none.

Environment:

    CcVacbSpinLock should be held on entry.

--*/

{
    ULONG Level, Shift;
    PVACB *VacbArray;
    PVACB Vacb;

    //
    //  Initialize variables controlling our descent into the hierarchy.
    //

    Level = 0;
    Shift = VACB_OFFSET_SHIFT + VACB_LEVEL_SHIFT;
    VacbArray = SharedCacheMap->Vacbs;

    //
    //  Caller must have verified that we have a hierarchy, otherwise this routine
    //  would fail.
    //

    ASSERT(SharedCacheMap->SectionSize.QuadPart > VACB_SIZE_OF_FIRST_LEVEL);

    //
    //  Loop to calculate how many levels we have and how much we have to
    //  shift to index into the first level.
    //

    do {

        Level += 1;
        Shift += VACB_LEVEL_SHIFT;

    } while (SharedCacheMap->SectionSize.QuadPart > ((LONGLONG)1 << Shift));

    //
    //  Now descend the tree to the bottom level to get the caller's Vacb.
    //

    Shift -= VACB_LEVEL_SHIFT;
    while (((Vacb = (PVACB)VacbArray[FileOffset >> Shift]) != NULL) && (Level != 0)) {

        Level -= 1;

        VacbArray = (PVACB *)Vacb;
        FileOffset &= ((LONGLONG)1 << Shift) - 1;

        Shift -= VACB_LEVEL_SHIFT;
    }

    //
    //  If the Vacb we exited with is not NULL, we want to make sure it looks OK.
    //

    ASSERT(Vacb == NULL || ((Vacb >= CcVacbs) && (Vacb < CcBeyondVacbs)));

    return Vacb;
}


VOID
CcSetVacbLargeOffset (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN LONGLONG FileOffset,
    IN PVACB Vacb
    )

/*++

Routine Description:

    This routine may be called to set the specified Vacb pointer for the specified FileOffset.
    It should only be called if the SectionSize is greater than VACB_SIZE_OF_FIRST_LEVEL.

    For non-null Vacb, intermediate Vacb levels will be added as necessary, and if the lowest
    level has Bcb listheads, these will also be added.  For this case the caller must acquire
    the spinlock by calling CcPrefillVacbLevelZone specifying the worst-case number of levels
    required.

    For a null Vacb pointer, the tree is pruned of all Vacb levels that go empty.  If the lowest
    level has Bcb listheads, then they are removed.  The caller should subsequently call
    CcDrainVacbLevelZone once the spinlock is release to actually free some of this zone to the
    pool.

Arguments:

    SharedCacheMap - Supplies the pointer to the SharedCacheMap for which the Vacb
                     is desired.

    FileOffset - Supplies the fileOffset corresponding to the desired Vacb.

Return Value:

    Returns the desired Vacb pointer or NULL if there is none.

Environment:

    CcVacbSpinLock should be held on entry.

--*/

{
    ULONG Level, Shift;
    PVACB *VacbArray, *NextVacbArray;
    ULONG Index;
    ULONG SavedIndexes[VACB_NUMBER_OF_LEVELS];
    PVACB *SavedVacbArrays[VACB_NUMBER_OF_LEVELS];
    PLIST_ENTRY PredecessorListHead, SuccessorListHead, CurrentListHead;
    LOGICAL AllocatingBcbListHeads, Special = FALSE;
    LONGLONG OriginalFileOffset = FileOffset;
    ULONG SavedLevels = 0;

    //
    //  Initialize variables controlling our descent into the hierarchy.
    //

    Level = 0;
    Shift = VACB_OFFSET_SHIFT + VACB_LEVEL_SHIFT;
    VacbArray = SharedCacheMap->Vacbs;

    //
    //  Caller must have verified that we have a hierarchy, otherwise this routine
    //  would fail.
    //

    ASSERT(SharedCacheMap->SectionSize.QuadPart > VACB_SIZE_OF_FIRST_LEVEL);

    //
    //  Loop to calculate how many levels we have and how much we have to
    //  shift to index into the first level.
    //

    do {

        Level += 1;
        Shift += VACB_LEVEL_SHIFT;

    } while (SharedCacheMap->SectionSize.QuadPart > ((LONGLONG)1 << Shift));

    //
    //  Now descend the tree to the bottom level to set the caller's Vacb.
    //

    Shift -= VACB_LEVEL_SHIFT;
    do {

        //
        //  Decrement back to the level that describes the size we are within.
        //

        Level -= 1;

        //
        //  Calculate the index into the Vacb block for this level.
        //

        Index = (ULONG)(FileOffset >> Shift);
        ASSERT(Index <= VACB_LAST_INDEX_FOR_LEVEL);

        //
        //  We save Index and VacbArray at each level, for the case that we
        //  are collapsing and deallocating blocks below.
        //

        SavedIndexes[SavedLevels] = Index;
        SavedVacbArrays[SavedLevels] = VacbArray;
        SavedLevels += 1;

        //
        //  Get block address for next level.
        //

        NextVacbArray = (PVACB *)VacbArray[Index];

        //
        //  If it is NULL then we have to allocate the next level to fill it in.
        //

        if (NextVacbArray == NULL) {

            //
            //  We better not be thinking we're dereferencing a level if the level
            //  doesn't currently exist.
            //

            ASSERT( Vacb != VACB_SPECIAL_DEREFERENCE );

            AllocatingBcbListHeads = FlagOn(SharedCacheMap->Flags, MODIFIED_WRITE_DISABLED) && (Level == 0);

            //
            //  This is only valid if we are setting a nonzero pointer!
            //

            ASSERT(Vacb != NULL);

            NextVacbArray = CcAllocateVacbLevel(AllocatingBcbListHeads);

            //
            //  If we allocated Bcb Listheads, we must link them in.
            //

            if (AllocatingBcbListHeads) {

                ULONG i;

                //
                //  Find our predecessor.
                //

                PredecessorListHead = CcGetBcbListHeadLargeOffset( SharedCacheMap, OriginalFileOffset, FALSE );

                //
                //  If he is followed by any Bcbs, they "belong" to him, and we have to
                //  skip over them.
                //

                while (((PBCB)CONTAINING_RECORD(PredecessorListHead->Blink, BCB, BcbLinks))->NodeTypeCode ==
                       CACHE_NTC_BCB) {
                    PredecessorListHead = (PLIST_ENTRY)PredecessorListHead->Blink;
                }

                //
                //  Point to the first newly allocated listhead.
                //

                CurrentListHead = (PLIST_ENTRY)((PCHAR)NextVacbArray + VACB_LEVEL_BLOCK_SIZE);

                //
                //  Link first new listhead to predecessor.
                //

                SuccessorListHead = PredecessorListHead->Blink;
                PredecessorListHead->Blink = CurrentListHead;
                CurrentListHead->Flink = PredecessorListHead;

                //
                //  Now loop to link all of the new listheads together.
                //

                for (i = 0; i < ((VACB_LEVEL_BLOCK_SIZE / sizeof(LIST_ENTRY) - 1)); i++) {

                    CurrentListHead->Blink = CurrentListHead + 1;
                    CurrentListHead += 1;
                    CurrentListHead->Flink = CurrentListHead - 1;
                }

                //
                //  Finally link the last new listhead to the successor.
                //

                CurrentListHead->Blink = SuccessorListHead;
                SuccessorListHead->Flink = CurrentListHead;
            }

            VacbArray[Index] = (PVACB)NextVacbArray;

            //
            //  Increment the reference count.  Note that Level right now properly indicates
            //  what level NextVacbArray is at, not VacbArray.
            //

            ReferenceVacbLevel( SharedCacheMap, VacbArray, Level + 1, 1, FALSE );
        }

        //
        //  Now make this one our current pointer, and mask away the extraneous high-order
        //  FileOffset bits for this level and reduce the shift count.
        //

        VacbArray = NextVacbArray;
        FileOffset &= ((LONGLONG)1 << Shift) - 1;
        Shift -= VACB_LEVEL_SHIFT;

    //
    //  Loop until we hit the bottom level.
    //

    } while (Level != 0);

    if (Vacb < VACB_SPECIAL_FIRST_VALID) {

        //
        //  Now calculate the index for the bottom level and store the caller's Vacb pointer.
        //

        Index = (ULONG)(FileOffset >> Shift);
        VacbArray[Index] = Vacb;

    //
    //  Handle the special actions.
    //

    } else {

        Special = TRUE;

        //
        //  Induce the dereference.
        //

        if (Vacb == VACB_SPECIAL_DEREFERENCE) {

            Vacb = NULL;
        }
    }

    //
    //  If he is storing a nonzero pointer, just reference the level.
    //

    if (Vacb != NULL) {

        ASSERT( !(Special && Level != 0) );

        ReferenceVacbLevel( SharedCacheMap, VacbArray, Level, 1, Special );

    //
    //  Otherwise we are storing a NULL pointer, and we have to see if we can collapse
    //  the tree by deallocating empty blocks of pointers.
    //

    } else {

        //
        //  Loop until doing all possible collapse except for the top level.
        //

        while (TRUE) {

            ReferenceVacbLevel( SharedCacheMap, VacbArray, Level, -1, Special );

            //
            //  If this was a special dereference, then recognize that this was
            //  the only one.  The rest, as we tear up the tree, are regular
            //  (calculable) references.
            //

            Special = FALSE;

            //
            //  Now, if we have an empty block (other than the top one), then we should free the
            //  block and keep looping.
            //

            if (!IsVacbLevelReferenced( SharedCacheMap, VacbArray, Level ) && (SavedLevels != 0)) {

                SavedLevels -= 1;

                //
                //  First see if we have Bcb Listheads to delete and if so, we have to unlink
                //  the whole block first.
                //

                AllocatingBcbListHeads = FALSE;
                if ((Level++ == 0) && FlagOn(SharedCacheMap->Flags, MODIFIED_WRITE_DISABLED)) {

                    AllocatingBcbListHeads = TRUE;
                    PredecessorListHead = ((PLIST_ENTRY)((PCHAR)VacbArray + VACB_LEVEL_BLOCK_SIZE))->Flink;
                    SuccessorListHead = ((PLIST_ENTRY)((PCHAR)VacbArray + (VACB_LEVEL_BLOCK_SIZE * 2) - sizeof(LIST_ENTRY)))->Blink;
                    PredecessorListHead->Blink = SuccessorListHead;
                    SuccessorListHead->Flink = PredecessorListHead;
                }

                //
                //  Free the unused block and then pick up the saved parent pointer array and
                //  index and erase the pointer to this block.
                //

                CcDeallocateVacbLevel( VacbArray, AllocatingBcbListHeads );
                Index = SavedIndexes[SavedLevels];
                VacbArray = SavedVacbArrays[SavedLevels];
                VacbArray[Index] = NULL;

            //
            //  No more collapsing if we hit a block that still has pointers, or we hit the root.
            //

            } else {
                break;
            }
        }
    }
}


VOID
CcGetActiveVacb (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    OUT PVACB *Vacb,
    OUT PULONG Page,
    OUT PULONG Dirty
    )

/*++

Routine Description:

    This routine retrieves and clears the active page hint from a shared cache map.

    Originally, this routine is a macro.  To reduce the nonpaged footprint of the
    system we want to page as much as possible, and it turns out this was the only
    reason a substantial part of the cache manager wasn't.

Arguments:

    SharedCacheMap - Supplies the pointer to the SharedCacheMap for which the active
                Vacb is desired.

    Vacb - Receives the active Vacb

    Page - Receives the active Page #

    Dirty - Receives ACTIVE_PAGE_IS_DIRTY if the page has dirty data

Return Value:

    None.

Environment:

    Passive.

--*/

{
    KIRQL Irql;

    ExAcquireFastLock(&SharedCacheMap->ActiveVacbSpinLock, &Irql);
    *Vacb = SharedCacheMap->ActiveVacb;
    if (*Vacb != NULL) {
        *Page = SharedCacheMap->ActivePage;
        SharedCacheMap->ActiveVacb = NULL;
        *Dirty = SharedCacheMap->Flags & ACTIVE_PAGE_IS_DIRTY;
    }
    ExReleaseFastLock(&SharedCacheMap->ActiveVacbSpinLock, Irql);
}


VOID
CcSetActiveVacb (
    IN PSHARED_CACHE_MAP SharedCacheMap,
    IN OUT PVACB *Vacb,
    IN ULONG Page,
    IN ULONG Dirty
    )

/*++

Routine Description:

    This routine sets the active page hint for a shared cache map.

    Originally, this routine is a macro.  To reduce the nonpaged footprint of the
    system we want to page as much as possible, and it turns out this was the only
    reason a substantial part of the cache manager wasn't.

Arguments:

    SharedCacheMap - Supplies the pointer to the SharedCacheMap for which the active
                Vacb is desired.

    Vacb - Supplies the new active Vacb

    Page - Supplies the new active Page #

    Dirty - Supplies ACTIVE_PAGE_IS_DIRTY if the page has dirty data

Return Value:

    None.

Environment:

    Passive.

--*/

{
    KIRQL Irql;

    //
    //  When setting dirty, when we set ACTIVE_PAGE_IS_DIRTY the first time,
    //  we increment the dirty counts, and they never get decremented until
    //  CcFreeActiveVacb.  If we are trying to set and there is already an
    //  active Vacb *or* we are trying to set a clean one and the flag above
    //  is set, we do not allow it, and we just free the vacb (we only want
    //  to handle the clean transition in one place).
    //
    //  MP & UP cases are separately defined, because I do not trust the compiler
    //  to otherwise generate the optimal UP code.
    //

    //
    //  In the MP case, we test if we are setting the page dirty, because then
    //  we must acquire CcMasterSpinLock to diddle CcDirtyPages.
    //

    //
    //  In the UP case, any FastLock will do, so we just use the ActiveVacb lock, and do not
    //  explicitly acquire CcMasterSpinLock.
    //

#if !defined(NT_UP)
    if (Dirty) {
        CcAcquireMasterLock(&Irql);
        ExAcquireSpinLockAtDpcLevel(&SharedCacheMap->ActiveVacbSpinLock);
    } else {
        ExAcquireSpinLock(&SharedCacheMap->ActiveVacbSpinLock, &Irql);
    }
#else
    ExAcquireFastLock(&SharedCacheMap->ActiveVacbSpinLock, &Irql);
#endif

    do {
        if (SharedCacheMap->ActiveVacb == NULL) {
            if ((SharedCacheMap->Flags & ACTIVE_PAGE_IS_DIRTY) != Dirty) {
                if (Dirty) {
                    SharedCacheMap->ActiveVacb = *Vacb;
                    SharedCacheMap->ActivePage = Page;
                    *Vacb = NULL;
                    SetFlag(SharedCacheMap->Flags, ACTIVE_PAGE_IS_DIRTY);
                    CcTotalDirtyPages += 1;
                    SharedCacheMap->DirtyPages += 1;
                    if (SharedCacheMap->DirtyPages == 1) {
                        PLIST_ENTRY Blink;
                        PLIST_ENTRY Entry;
                        PLIST_ENTRY Flink;
                        PLIST_ENTRY Head;
                        Entry = &SharedCacheMap->SharedCacheMapLinks;
                        Blink = Entry->Blink;
                        Flink = Entry->Flink;
                        Blink->Flink = Flink;
                        Flink->Blink = Blink;
                        Head = &CcDirtySharedCacheMapList.SharedCacheMapLinks;
                        Blink = Head->Blink;
                        Entry->Flink = Head;
                        Entry->Blink = Blink;
                        Blink->Flink = Entry;
                        Head->Blink = Entry;
                        if (!LazyWriter.ScanActive) {
                            LazyWriter.ScanActive = TRUE;
#if !defined(NT_UP)
                            ExReleaseSpinLockFromDpcLevel(&SharedCacheMap->ActiveVacbSpinLock);
                            CcReleaseMasterLock(Irql);
#else
                            ExReleaseFastLock(&SharedCacheMap->ActiveVacbSpinLock, Irql);
#endif
                            KeSetTimer( &LazyWriter.ScanTimer,
                                        CcFirstDelay,
                                        &LazyWriter.ScanDpc );
                            break;
                        }
                    }
                }
            } else {
                SharedCacheMap->ActiveVacb = *Vacb;
                SharedCacheMap->ActivePage = Page;
                *Vacb = NULL;
            }
        }
#if !defined(NT_UP)
        if (Dirty) {
            ExReleaseSpinLockFromDpcLevel(&SharedCacheMap->ActiveVacbSpinLock);
            CcReleaseMasterLock(Irql);
        } else {
            ExReleaseSpinLock(&SharedCacheMap->ActiveVacbSpinLock, Irql);
        }
#else
        ExReleaseFastLock(&SharedCacheMap->ActiveVacbSpinLock, Irql);
#endif
        if (*Vacb != NULL) {
            CcFreeActiveVacb( SharedCacheMap, *Vacb, Page, Dirty);
        }
    } while (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\cache\pinsup.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    pinsup.c

Abstract:

    This module implements the pointer-based Pin support routines for the
    Cache subsystem.

--*/

#include "cc.h"

//
//  Define our debug constant
//

#define me 0x00000008

//
//  Internal routines
//

BOOLEAN
CcMapDataCommon (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG Flags,
    OUT PVOID *Bcb,
    OUT PVOID *Buffer
    );

VOID
CcMapDataForOverwrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    OUT PVOID *Bcb,
    OUT PVOID *Buffer
    );

POBCB
CcAllocateObcb (
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN PBCB FirstBcb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CcPinMappedData)
#pragma alloc_text(PAGE,CcPinRead)
#pragma alloc_text(PAGE,CcPreparePinWrite)
#pragma alloc_text(PAGE,CcMapDataCommon)
#pragma alloc_text(PAGE,CcMapData)
#pragma alloc_text(PAGE,CcUnpinData)
#pragma alloc_text(PAGE,CcSetBcbOwnerPointer)
#pragma alloc_text(PAGE,CcUnpinDataForThread)
#pragma alloc_text(PAGE,CcAllocateObcb)
#endif



BOOLEAN
CcMapData (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in ULONG Flags,
    __out PVOID *Bcb,
    __deref_out_bcount(Length) PVOID *Buffer
    )

/*++

Routine Description:

    This routine attempts to map the specified file data in the cache.
    A pointer is returned to the desired data in the cache.

    If the caller does not want to block on this call, then
    Wait should be supplied as FALSE.  If Wait was supplied as FALSE and
    it is currently impossible to supply the requested data without
    blocking, then this routine will return FALSE.  However, if the
    data is immediately accessible in the cache and no blocking is
    required, this routine returns TRUE with a pointer to the data.

    Note that a call to this routine with Wait supplied as TRUE is
    considerably faster than a call with Wait supplies as FALSE, because
    in the Wait TRUE case we only have to make sure the data is mapped
    in order to return.

    It is illegal to modify data that is only mapped, and can in fact lead
    to serious problems.  It is impossible to check for this in all cases,
    however CcSetDirtyPinnedData may implement some Assertions to check for
    this.  If the caller wishes to modify data that it has only mapped, then
    it must *first* call CcPinMappedData.

    In any case, the caller MUST subsequently call CcUnpinData.
    Naturally if CcPinRead or CcPreparePinWrite were called multiple
    times for the same data, CcUnpinData must be called the same number
    of times.

    The returned Buffer pointer is valid until the data is unpinned, at
    which point it is invalid to use the pointer further.  This buffer pointer
    will remain valid if CcPinMappedData is called.

    Note that under some circumstances (like Wait supplied as FALSE or more
    than a page is requested), this routine may actually pin the data, however
    it is not necessary, and in fact not correct, for the caller to be concerned
    about this.

Arguments:

    FileObject - Pointer to the file object for a file which was
                 opened with NO_INTERMEDIATE_BUFFERING clear, i.e., for
                 which CcInitializeCacheMap was called by the file system.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Wait - FALSE if caller may not block, TRUE otherwise (see description
           above)

    Bcb - On the first call this returns a pointer to a Bcb
          parameter which must be supplied as input on all subsequent
          calls, for this buffer

    Buffer - Returns pointer to desired data, valid until the buffer is
             unpinned or freed.  This pointer will remain valid if CcPinMappedData
             is called.

Return Value:

    FALSE - if Wait was supplied as FALSE and the data was not delivered

    TRUE - if the data is being delivered

--*/

{
    ULONG SavedState;
    volatile UCHAR ch;
    PVOID TempBcb;
    PVOID BaseAddress;
    ULONG PageCount = ADDRESS_AND_SIZE_TO_SPAN_PAGES((ULongToPtr(FileOffset->LowPart)), Length);
    PETHREAD Thread = PsGetCurrentThread();
    BOOLEAN ReturnStatus;

    DebugTrace(+1, me, "CcMapData\n", 0 );

    MmSavePageFaultReadAhead( Thread, &SavedState );

    ReturnStatus = CcMapDataCommon( FileObject,
                                    FileOffset,
                                    Length,
                                    Flags,
                                    &TempBcb,
                                    Buffer );

    if (!ReturnStatus) {

        //
        //  No need to revert the CcMissCounter in this case because we can
        //  only get here if Wait was FALSE and the CcMissCounter isn't set
        //  by CcMapDataCommon if Wait is FALSE.
        //

        return FALSE;
    }
    
    //
    //  Caller specifically requested he doesn't want data to be faulted in.
    //

    if (!FlagOn( Flags, MAP_NO_READ )) {

        //
        //  Now let's just sit here and take the miss(es) like a man (and count them).
        //

        try {

            //
            //  Loop to touch each page
            //

            BaseAddress = *Buffer;

            while (PageCount != 0) {

                MmSetPageFaultReadAhead( Thread, PageCount - 1 );

                ch = *((volatile UCHAR *)(BaseAddress));

                BaseAddress = (PCHAR) BaseAddress + PAGE_SIZE;
                PageCount -= 1;
            }

        } finally {

            MmResetPageFaultReadAhead( Thread, SavedState );

            if (AbnormalTermination() && (TempBcb != NULL)) {
                CcUnpinFileData( (PBCB)TempBcb, TRUE, UNPIN );
            }
        }
    }

    //
    //  CcMapDataCommon set the appropriate miss counter, but we need to reset
    //  it at this point.
    //

    CcMissCounter = &CcThrowAway;

    //
    //  Increment the pointer as a reminder that it is read only, and
    //  return it.  We pend this until now to avoid raising with a valid
    //  Bcb into caller's contexts.
    //

    *(PCHAR *)&TempBcb += 1;
    *Bcb = TempBcb;

    DebugTrace(-1, me, "CcMapData -> TRUE\n", 0 );

    return TRUE;
}


BOOLEAN
CcMapDataCommon (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG Flags,
    OUT PVOID *Bcb,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

    This routine attempts to map the specified file data in the cache.
    A pointer is returned to the desired data in the cache.

    If the caller does not want to block on this call, then
    Wait should be supplied as FALSE.  If Wait was supplied as FALSE and
    it is currently impossible to supply the requested data without
    blocking, then this routine will return FALSE.  However, if the
    data is immediately accessible in the cache and no blocking is
    required, this routine returns TRUE with a pointer to the data.

    Note that a call to this routine with Wait supplied as TRUE is
    considerably faster than a call with Wait supplies as FALSE, because
    in the Wait TRUE case we only have to make sure the data is mapped
    in order to return.

    If data is only mapped, Cc does not setup the structures to track the
    pages as dirty.  If the caller plans to dirty the data, it must do one
    of the following:
    * Call CcPinMappedData - Cc will then setup the structures to track that
        the buffer is dirty.  Then the caller can dirty the buffer and call
        CcSetDirtyPinnedData to tell Cc about it.
    * Track the dirty data itself.  If the caller chooses to do this, he/she
        is responsible for setting the address range modified after it is
        written, but before trying to flush the data.
        
    In any case, the caller MUST subsequently call CcUnpinData.
    Naturally if CcPinRead or CcPreparePinWrite were called multiple
    times for the same data, CcUnpinData must be called the same number
    of times.

    The returned Buffer pointer is valid until the data is unpinned, at
    which point it is invalid to use the pointer further.  This buffer pointer
    will remain valid if CcPinMappedData is called.

    Note that under some circumstances (like Wait supplied as FALSE or more
    than a page is requested), this routine may actually pin the data, however
    it is not necessary, and in fact not correct, for the caller to be concerned
    about this.

Arguments:

    FileObject - Pointer to the file object for a file which was
                 opened with NO_INTERMEDIATE_BUFFERING clear, i.e., for
                 which CcInitializeCacheMap was called by the file system.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Wait - FALSE if caller may not block, TRUE otherwise (see description
           above)

    Bcb - On the first call this returns a pointer to a Bcb
          parameter which must be supplied as input on all subsequent
          calls, for this buffer

    Buffer - Returns pointer to desired data, valid until the buffer is
             unpinned or freed.  This pointer will remain valid if CcPinMappedData
             is called.

Return Value:

    FALSE - if Wait was supplied as FALSE and the data was not delivered

    TRUE - if the data is being delivered

--*/

{
    PSHARED_CACHE_MAP SharedCacheMap;
    LARGE_INTEGER BeyondLastByte;
    ULONG ReceivedLength;
    PVOID TempBcb;
    PETHREAD Thread = PsGetCurrentThread();

    DebugTrace(+1, me, "CcMapDataCommon\n", 0 );

    //
    //  Increment performance counters
    //

    if (FlagOn(Flags, MAP_WAIT)) {

        CcMapDataWait += 1;

        //
        //  Initialize the indirect pointer to our miss counter.
        //

        CcMissCounter = &CcMapDataWaitMiss;

    } else {
        CcMapDataNoWait += 1;
    }

    //
    //  Get pointer to SharedCacheMap.
    //

    SharedCacheMap = FileObject->SectionObjectPointer->SharedCacheMap;

    //
    //  Call local routine to Map or Access the file data.  If we cannot map
    //  the data because of a Wait condition, return FALSE.
    //

    if (FlagOn(Flags, MAP_WAIT)) {

        *Buffer = CcGetVirtualAddress( SharedCacheMap,
                                       *FileOffset,
                                       (PVACB *)&TempBcb,
                                       &ReceivedLength );

        ASSERT( ReceivedLength >= Length );

    } else if (!CcPinFileData( FileObject,
                               FileOffset,
                               Length,
                               TRUE,
                               FALSE,
                               Flags,
                               (PBCB *)&TempBcb,
                               Buffer,
                               &BeyondLastByte )) {

        DebugTrace(-1, me, "CcMapData -> FALSE\n", 0 );

        CcMapDataNoWaitMiss += 1;

        return FALSE;

    } else {

        ASSERT( (BeyondLastByte.QuadPart - FileOffset->QuadPart) >= Length );

    }

    //
    //  Even though this pointer is read-only, we will leave it to the 
    //  caller to mark it as such since the caller will need to do some
    //  addition operations on this pointer before returning to the request
    //  originator.
    //

    *Bcb = TempBcb;

    DebugTrace(-1, me, "CcMapDataCommon -> TRUE\n", 0 );

    return TRUE;
}


BOOLEAN
CcPinMappedData (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in ULONG Flags,
    __inout PVOID *Bcb
    )

/*++

Routine Description:

    This routine attempts to pin data that was previously only mapped.
    If the routine determines that in fact it was necessary to actually
    pin the data when CcMapData was called, then this routine does not
    have to do anything.

    If the caller does not want to block on this call, then
    Wait should be supplied as FALSE.  If Wait was supplied as FALSE and
    it is currently impossible to supply the requested data without
    blocking, then this routine will return FALSE.  However, if the
    data is immediately accessible in the cache and no blocking is
    required, this routine returns TRUE with a pointer to the data.

    If the data is not returned in the first call, the caller
    may request the data later with Wait = TRUE.  It is not required
    that the caller request the data later.

    If the caller subsequently modifies the data, it should call
    CcSetDirtyPinnedData.

    In any case, the caller MUST subsequently call CcUnpinData.
    Naturally if CcPinRead or CcPreparePinWrite were called multiple
    times for the same data, CcUnpinData must be called the same number
    of times.

    Note there are no performance counters in this routine, as the misses
    will almost always occur on the map above, and there will seldom be a
    miss on this conversion.

Arguments:

    FileObject - Pointer to the file object for a file which was
                 opened with NO_INTERMEDIATE_BUFFERING clear, i.e., for
                 which CcInitializeCacheMap was called by the file system.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Flags - (PIN_WAIT, PIN_EXCLUSIVE, PIN_NO_READ, etc. as defined in cache.h)
            If the caller specifies PIN_NO_READ and PIN_EXCLUSIVE, then he must
            guarantee that no one else will be attempting to map the view, if he
            wants to guarantee that the Bcb is not mapped (view may be purged).
            If the caller specifies PIN_NO_READ without PIN_EXCLUSIVE, the data
            may or may not be mapped in the return Bcb.

    Bcb - On the first call this returns a pointer to a Bcb
          parameter which must be supplied as input on all subsequent
          calls, for this buffer

Return Value:

    FALSE - if Wait was not set and the data was not delivered

    TRUE - if the data is being delivered

--*/

{
    PVOID Buffer;
    LARGE_INTEGER BeyondLastByte;
    PSHARED_CACHE_MAP SharedCacheMap;
    LARGE_INTEGER LocalFileOffset = *FileOffset;
    POBCB MyBcb = NULL;
    PBCB *CurrentBcbPtr = (PBCB *)&MyBcb;
    BOOLEAN Result = FALSE;

    DebugTrace(+1, me, "CcPinMappedData\n", 0 );

    //
    // If the Bcb is no longer ReadOnly, then just return.
    //

    if ((*(PULONG)Bcb & 1) == 0) {
        return TRUE;
    }

    //
    // Remove the Read Only flag
    //

    *(PCHAR *)Bcb -= 1;

    //
    //  Get pointer to SharedCacheMap.
    //

    SharedCacheMap = FileObject->SectionObjectPointer->SharedCacheMap;

    //
    //  We only count the calls to this routine, since they are almost guaranteed
    //  to be hits.
    //

    CcPinMappedDataCount += 1;

    //
    //  Guarantee we will put the flag back if required.
    //

    try {

        if (((PBCB)*Bcb)->NodeTypeCode != CACHE_NTC_BCB) {

            //
            //  Form loop to handle occasional overlapped Bcb case.
            //

            do {

                //
                //  If we have already been through the loop, then adjust
                //  our file offset and length from the last time.
                //

                if (MyBcb != NULL) {

                    //
                    //  If this is the second time through the loop, then it is time
                    //  to handle the overlap case and allocate an OBCB.
                    //

                    if (CurrentBcbPtr == (PBCB *)&MyBcb) {

                        MyBcb = CcAllocateObcb( FileOffset, Length, (PBCB)MyBcb );

                        //
                        //  Set CurrentBcbPtr to point at the first entry in
                        //  the vector (which is already filled in), before
                        //  advancing it below.
                        //

                        CurrentBcbPtr = &MyBcb->Bcbs[0];
                    }

                    Length -= (ULONG)(BeyondLastByte.QuadPart - LocalFileOffset.QuadPart);
                    LocalFileOffset.QuadPart = BeyondLastByte.QuadPart;
                    CurrentBcbPtr += 1;
                }

                //
                //  Call local routine to Map or Access the file data.  If we cannot map
                //  the data because of a Wait condition, return FALSE.
                //

                if (!CcPinFileData( FileObject,
                                    &LocalFileOffset,
                                    Length,
                                    (BOOLEAN)!FlagOn(SharedCacheMap->Flags, MODIFIED_WRITE_DISABLED),
                                    FALSE,
                                    Flags,
                                    CurrentBcbPtr,
                                    &Buffer,
                                    &BeyondLastByte )) {

                    try_return( Result = FALSE );
                }

            //
            //  Continue looping if we did not get everything.
            //

            } while((BeyondLastByte.QuadPart - LocalFileOffset.QuadPart) < Length);

            //
            //  Free the Vacb before going on.
            //

            CcFreeVirtualAddress( (PVACB)*Bcb );

            *Bcb = MyBcb;

            //
            //  Debug routines used to insert and remove Bcbs from the global list
            //

        }

        //
        //  If he really has a Bcb, all we have to do is acquire it shared since he is
        //  no longer ReadOnly.
        //

        else {

            if (!ExAcquireSharedStarveExclusive( &((PBCB)*Bcb)->Resource, BooleanFlagOn(Flags, PIN_WAIT))) {

                try_return( Result = FALSE );
            }
        }

        Result = TRUE;

    try_exit: NOTHING;
    }
    finally {

        if (!Result) {

            //
            //  Put the Read Only flag back
            //

            *(PCHAR *)Bcb += 1;

            //
            //  We may have gotten partway through
            //

            if (MyBcb != NULL) {
                CcUnpinData( MyBcb );
            }
        }

        DebugTrace(-1, me, "CcPinMappedData -> %02lx\n", Result );
    }
    return Result;
}


BOOLEAN
CcPinRead (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in ULONG Flags,
    __out PVOID *Bcb,
    __deref_out_bcount(Length) PVOID *Buffer
    )

/*++

Routine Description:

    This routine attempts to pin the specified file data in the cache.
    A pointer is returned to the desired data in the cache.  This routine
    is intended for File System support and is not intended to be called
    from Dpc level.

    If the caller does not want to block on this call, then
    Wait should be supplied as FALSE.  If Wait was supplied as FALSE and
    it is currently impossible to supply the requested data without
    blocking, then this routine will return FALSE.  However, if the
    data is immediately accessible in the cache and no blocking is
    required, this routine returns TRUE with a pointer to the data.

    If the data is not returned in the first call, the caller
    may request the data later with Wait = TRUE.  It is not required
    that the caller request the data later.

    If the caller subsequently modifies the data, it should call
    CcSetDirtyPinnedData.

    In any case, the caller MUST subsequently call CcUnpinData.
    Naturally if CcPinRead or CcPreparePinWrite were called multiple
    times for the same data, CcUnpinData must be called the same number
    of times.

    The returned Buffer pointer is valid until the data is unpinned, at
    which point it is invalid to use the pointer further.

Arguments:

    FileObject - Pointer to the file object for a file which was
                 opened with NO_INTERMEDIATE_BUFFERING clear, i.e., for
                 which CcInitializeCacheMap was called by the file system.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Flags - (PIN_WAIT, PIN_EXCLUSIVE, PIN_NO_READ, etc. as defined in cache.h)
            If the caller specifies PIN_NO_READ and PIN_EXCLUSIVE, then he must
            guarantee that no one else will be attempting to map the view, if he
            wants to guarantee that the Bcb is not mapped (view may be purged).
            If the caller specifies PIN_NO_READ without PIN_EXCLUSIVE, the data
            may or may not be mapped in the return Bcb.

    Bcb - On the first call this returns a pointer to a Bcb
          parameter which must be supplied as input on all subsequent
          calls, for this buffer

    Buffer - Returns pointer to desired data, valid until the buffer is
             unpinned or freed.

Return Value:

    FALSE - if Wait was not set and the data was not delivered

    TRUE - if the data is being delivered

--*/

{
    PSHARED_CACHE_MAP SharedCacheMap;
    PVOID LocalBuffer;
    LARGE_INTEGER BeyondLastByte;
    LARGE_INTEGER LocalFileOffset = *FileOffset;
    POBCB MyBcb = NULL;
    PBCB *CurrentBcbPtr = (PBCB *)&MyBcb;
    BOOLEAN Result = FALSE;

    DebugTrace(+1, me, "CcPinRead\n", 0 );

    //
    //  Increment performance counters
    //

    if (FlagOn(Flags, PIN_WAIT)) {

        CcPinReadWait += 1;

        //
        //  Initialize the indirect pointer to our miss counter.
        //

        CcMissCounter = &CcPinReadWaitMiss;

    } else {
        CcPinReadNoWait += 1;
    }

    //
    //  Get pointer to SharedCacheMap.
    //

    SharedCacheMap = FileObject->SectionObjectPointer->SharedCacheMap;

    try {

        //
        //  Form loop to handle occasional overlapped Bcb case.
        //

        do {

            //
            //  If we have already been through the loop, then adjust
            //  our file offset and length from the last time.
            //

            if (MyBcb != NULL) {

                //
                //  If this is the second time through the loop, then it is time
                //  to handle the overlap case and allocate an OBCB.
                //

                if (CurrentBcbPtr == (PBCB *)&MyBcb) {

                    MyBcb = CcAllocateObcb( FileOffset, Length, (PBCB)MyBcb );

                    //
                    //  Set CurrentBcbPtr to point at the first entry in
                    //  the vector (which is already filled in), before
                    //  advancing it below.
                    //

                    CurrentBcbPtr = &MyBcb->Bcbs[0];

                    //
                    //  Also on second time through, return starting Buffer
                    //

                    *Buffer = LocalBuffer;
                }

                Length -= (ULONG)(BeyondLastByte.QuadPart - LocalFileOffset.QuadPart);
                LocalFileOffset.QuadPart = BeyondLastByte.QuadPart;
                CurrentBcbPtr += 1;
            }

            //
            //  Call local routine to Map or Access the file data.  If we cannot map
            //  the data because of a Wait condition, return FALSE.
            //

            if (!CcPinFileData( FileObject,
                                &LocalFileOffset,
                                Length,
                                (BOOLEAN)!FlagOn(SharedCacheMap->Flags, MODIFIED_WRITE_DISABLED),
                                FALSE,
                                Flags,
                                CurrentBcbPtr,
                                &LocalBuffer,
                                &BeyondLastByte )) {

                CcPinReadNoWaitMiss += 1;

                try_return( Result = FALSE );
            }

        //
        //  Continue looping if we did not get everything.
        //

        } while((BeyondLastByte.QuadPart - LocalFileOffset.QuadPart) < Length);

        *Bcb = MyBcb;

        //
        //  Debug routines used to insert and remove Bcbs from the global list
        //

        //
        //  In the normal (nonoverlapping) case we return the
        //  correct buffer address here.
        //

        if (CurrentBcbPtr == (PBCB *)&MyBcb) {
            *Buffer = LocalBuffer;
        }

        Result = TRUE;

    try_exit: NOTHING;
    }
    finally {

        CcMissCounter = &CcThrowAway;

        if (!Result) {

            //
            //  We may have gotten partway through
            //

            if (MyBcb != NULL) {
                CcUnpinData( MyBcb );
            }
        }

        DebugTrace(-1, me, "CcPinRead -> %02lx\n", Result );
    }

    return Result;
}


BOOLEAN
CcPreparePinWrite (
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in BOOLEAN Zero,
    __in ULONG Flags,
    __out PVOID *Bcb,
    __deref_out_bcount(Length) PVOID *Buffer
    )

/*++

Routine Description:

    This routine attempts to lock the specified file data in the cache
    and return a pointer to it along with the correct
    I/O status.  Pages to be completely overwritten may be satisfied
    with emtpy pages.

    If not all of the pages can be prepared, and Wait was supplied as
    FALSE, then this routine will return FALSE, and its outputs will
    be meaningless.  The caller may request the data later with
    Wait = TRUE.  However, it is not required that the caller request
    the data later.

    If Wait is supplied as TRUE, and all of the pages can be prepared
    without blocking, this call will return TRUE immediately.  Otherwise,
    this call will block until all of the pages can be prepared, and
    then return TRUE.

    When this call returns with TRUE, the caller may immediately begin
    to transfer data into the buffers via the Buffer pointer.  The
    buffer will already be marked dirty.

    The caller MUST subsequently call CcUnpinData.
    Naturally if CcPinRead or CcPreparePinWrite were called multiple
    times for the same data, CcUnpinData must be called the same number
    of times.

    The returned Buffer pointer is valid until the data is unpinned, at
    which point it is invalid to use the pointer further.

Arguments:

    FileObject - Pointer to the file object for a file which was
                 opened with NO_INTERMEDIATE_BUFFERING clear, i.e., for
                 which CcInitializeCacheMap was called by the file system.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Zero - If supplied as TRUE, the buffer will be zeroed on return.  Ignored
           if PIN_CALLER_TRACKS_DIRTY_DATA is specified.

    Flags - (PIN_WAIT, PIN_EXCLUSIVE, PIN_NO_READ, etc. as defined in cache.h)
    
            If the caller specifies PIN_NO_READ and PIN_EXCLUSIVE, then he must
            guarantee that no one else will be attempting to map the view, if he
            wants to guarantee that the Bcb is not mapped (view may be purged).
            
            If the caller specifies PIN_NO_READ without PIN_EXCLUSIVE, the data
            may or may not be mapped in the return Bcb.

            If the caller specifies PIN_CALLER_TRACKS_DIRTY_DATA, all other flags
            are ignored.  The cache manager will not allocate its internal 
            structures for tracking dirty data (BCBs).  The caller is
            responsible for tracking dirty ranges, marking them dirty with
            MmSetAddressRangeModified then flushing them.  Ranges should only 
            be pinned via this manner only if the entire range will be written 
            or purged (one or the other must occur, otherwise dirty pages may
            remain in memory - see CcMapDataForOverwrite for details).

    Bcb - This returns a pointer to a Bcb parameter which must be
          supplied as input to CcPinWriteComplete.

    Buffer - Returns pointer to desired data, valid until the buffer is
             unpinned or freed.

Return Value:

    FALSE - if Wait was not set and the data was not delivered

    TRUE - if the pages are being delivered

--*/

{
    PSHARED_CACHE_MAP SharedCacheMap;
    PVOID LocalBuffer;
    LARGE_INTEGER BeyondLastByte;
    LARGE_INTEGER LocalFileOffset = *FileOffset;
    POBCB MyBcb = NULL;
    PBCB *CurrentBcbPtr = (PBCB *)&MyBcb;
    ULONG OriginalLength = Length;
    BOOLEAN Result = FALSE;

    DebugTrace(+1, me, "CcPreparePinWrite\n", 0 );

    //
    //  If PIN_CALLER_TRACKS_DIRTY_DATA is set, call CcMapDataForOverwrite to
    //  do the work because it is a special case which does not overlap with
    //  the other CcPreparePinWriteCases.
    //

    if (FlagOn( Flags, PIN_CALLER_TRACKS_DIRTY_DATA )) {

        CcMapDataForOverwrite( FileObject,
                               FileOffset, 
                               Length, 
                               Bcb,
                               Buffer );

        return TRUE;
    }

    //
    //  Get pointer to SharedCacheMap.
    //

    SharedCacheMap = FileObject->SectionObjectPointer->SharedCacheMap;

    try {

        //
        //  Form loop to handle occasional overlapped Bcb case.
        //

        do {

            //
            //  If we have already been through the loop, then adjust
            //  our file offset and length from the last time.
            //

            if (MyBcb != NULL) {

                //
                //  If this is the second time through the loop, then it is time
                //  to handle the overlap case and allocate an OBCB.
                //

                if (CurrentBcbPtr == (PBCB *)&MyBcb) {

                    MyBcb = CcAllocateObcb( FileOffset, Length, (PBCB)MyBcb );

                    //
                    //  Set CurrentBcbPtr to point at the first entry in
                    //  the vector (which is already filled in), before
                    //  advancing it below.
                    //

                    CurrentBcbPtr = &MyBcb->Bcbs[0];

                    //
                    //  Also on second time through, return starting Buffer
                    //

                    *Buffer = LocalBuffer;
                }

                Length -= (ULONG)(BeyondLastByte.QuadPart - LocalFileOffset.QuadPart);
                LocalFileOffset.QuadPart = BeyondLastByte.QuadPart;
                CurrentBcbPtr += 1;
            }

            //
            //  Call local routine to Map or Access the file data.  If we cannot map
            //  the data because of a Wait condition, return FALSE.
            //

            if (!CcPinFileData( FileObject,
                                &LocalFileOffset,
                                Length,
                                FALSE,
                                TRUE,
                                Flags,
                                CurrentBcbPtr,
                                &LocalBuffer,
                                &BeyondLastByte )) {

                try_return( Result = FALSE );
            }

        //
        //  Continue looping if we did not get everything.
        //

        } while((BeyondLastByte.QuadPart - LocalFileOffset.QuadPart) < Length);

        //
        //  Debug routines used to insert and remove Bcbs from the global list
        //

        //
        //  In the normal (nonoverlapping) case we return the
        //  correct buffer address here.
        //

        if (CurrentBcbPtr == (PBCB *)&MyBcb) {
            *Buffer = LocalBuffer;
        }

        if (Zero) {
            RtlZeroMemory( *Buffer, OriginalLength );
        }

        CcSetDirtyPinnedData( MyBcb, NULL );

        //
        //  Fill in the return argument.
        //

        *Bcb = MyBcb;
        
        Result = TRUE;

    try_exit: NOTHING;
    }
    finally {

        CcMissCounter = &CcThrowAway;

        if (!Result) {

            //
            //  We may have gotten partway through
            //

            if (MyBcb != NULL) {
                CcUnpinData( MyBcb );
            }
        }

        DebugTrace(-1, me, "CcPreparePinWrite -> %02lx\n", Result );
    }

    return Result;
}


VOID
CcMapDataForOverwrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    OUT PVOID *Bcb,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

    This routine returns the range of the file mapped for write-only access
    (if possible, we will avoid reading the data from disk to provide valid
    memory for use, so the buffer returned should not be read).

    The difference between this routine and CcPreparePinWrite is that Cc does
    not allocate the BCB structure to track the dirty ranges of the file.  This
    responsibility is left to the caller.  The intention is that this API is
    used for log-type metadata files, where the log owner needs to separately
    track dirty ranges itself, therefore the additional tracking overhead by
    Cc is not needed. (NTFS's LFS is a prime example of this.)

    Note that although this is accessed via CcPreparePinWrite, the actual
    operations Cc needs to take internally are much close to CcMapData, 
    therefore we use a common routine that is shared with CcMapData (called
    CcMapDataCommon) to prepare the state appropriately.
    
    When CcPreparePinWrite is called with PIN_CALLER_TRACKS_DIRTY_DATA,
    THE CALLER OF THIS ROUTINE IS RESPONSIBLE FOR TRACKING THE DIRTY RANGES!
    That includes marking the buffer ranges dirty by calling 
    MmSetAddressRangeModified when the buffers are dirty and the caller wants
    the data flushed to disk when CcFlushCache is called.

    Also note that if a page is currently not resident, we will 

    The caller MUST subsequently call CcUnpinData when finished with using the
    buffer.

    The returned Buffer pointer is valid until the data is unpinned, at
    which point it is invalid to use the pointer further.

Arguments:

    FileObject - Pointer to the file object for a file which was
                 opened with NO_INTERMEDIATE_BUFFERING clear, i.e., for
                 which CcInitializeCacheMap was called by the file system.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Bcb - On the first call this returns a pointer to a Bcb
          parameter which must be supplied as input on all subsequent
          calls, for this buffer

    Buffer - Returns pointer to desired data, valid until the buffer is
             unpinned or freed.  This pointer will remain valid if CcPinMappedData
             is called.

Return Value:

    None - this routine raises an exception if an error occurs.

--*/

{
    ULONG SavedState;
    PVOID TempBcb;
    PVOID BaseAddress;
    ULONG PageCount = ADDRESS_AND_SIZE_TO_SPAN_PAGES((ULongToPtr(FileOffset->LowPart)), Length);
    PETHREAD Thread = PsGetCurrentThread();
    PSHARED_CACHE_MAP SharedCacheMap;
    KIRQL OldIrql;
    BOOLEAN ReturnStatus;

    DebugTrace(+1, me, "CcMapDataForOverwrite\n", 0 );

    SharedCacheMap = FileObject->SectionObjectPointer->SharedCacheMap;

    //
    //  If this flag isn't already set for this stream, set it now so that
    //  we know to flush the entire range in CcFlushCache since we will not
    //  have dirty hints to follow.
    //
    
    if (!FlagOn( SharedCacheMap->Flags, CALLER_TRACKS_DIRTY_DATA )) {

        CcAcquireMasterLock( &OldIrql );
        SetFlag( SharedCacheMap->Flags, CALLER_TRACKS_DIRTY_DATA );
        CcReleaseMasterLock( OldIrql );
    }

    MmSavePageFaultReadAhead( Thread, &SavedState );

    ReturnStatus = CcMapDataCommon( FileObject,
                                    FileOffset,
                                    Length,
                                    MAP_WAIT,
                                    &TempBcb,
                                    Buffer );

    ASSERTMSG( "CcMapDataCommon should never fail for a blocking caller",
               ReturnStatus == TRUE );
    
    //
    //  Now fault the data in using the zero page optimization exposed by
    //  MmCheckCachedPageState.
    //

    try {

        //
        //  Loop to touch each page
        //

        BaseAddress = *Buffer;

        while (PageCount != 0) {

            MmSetPageFaultReadAhead( Thread, PageCount - 1 );

            if (!MmCheckCachedPageState( BaseAddress, TRUE )) {

                //
                //  We don't have enough memory to produce a zero page, so make
                //  the request again and allow the data to be faulted from
                //  disk.
                //  

                MmCheckCachedPageState( BaseAddress, FALSE );
            }

            BaseAddress = (PCHAR) BaseAddress + PAGE_SIZE;
            PageCount -= 1;
        }

    } finally {

        MmResetPageFaultReadAhead( Thread, SavedState );

        if (AbnormalTermination() && (TempBcb != NULL)) {
            CcUnpinFileData( (PBCB)TempBcb, FALSE, UNPIN );
        }
    }

    //
    //  CcMapDataCommon set the appropriate miss counter, but we need to reset
    //  it at this point.
    //

    CcMissCounter = &CcThrowAway;

    //
    //  Return the BCB.  We pend this until now to avoid raising with a valid
    //  Bcb into caller's contexts.
    //

    *Bcb = TempBcb;

    DebugTrace(-1, me, "CcMapDataForOverwrite -> VOID\n", 0 );

    return;
}


VOID
CcUnpinData (
    __in PVOID Bcb
    )

/*++

Routine Description:

    This routine must be called at IPL0, some time after calling CcPinRead
    or CcPreparePinWrite.  It performs any cleanup that is necessary.

Arguments:

    Bcb - Bcb parameter returned from the last call to CcPinRead.

Return Value:

    None.

--*/

{
    DebugTrace(+1, me, "CcUnpinData:\n", 0 );
    DebugTrace( 0, me, "    >Bcb = %08lx\n", Bcb );

    //
    //  Test for ReadOnly and unpin accordingly.
    //

    if (((ULONG_PTR)Bcb & 1) != 0) {

        //
        //  Remove the Read Only flag
        //

        Bcb = (PVOID) ((ULONG_PTR)Bcb & ~1);

        CcUnpinFileData( (PBCB)Bcb, TRUE, UNPIN );

    } else {

        //
        //  Handle the overlapped Bcb case.
        //

        if (((POBCB)Bcb)->NodeTypeCode == CACHE_NTC_OBCB) {

            PBCB *BcbPtrPtr = &((POBCB)Bcb)->Bcbs[0];

            //
            //  Loop to free all Bcbs with recursive calls
            //  (rather than dealing with RO for this uncommon case).
            //

            while (*BcbPtrPtr != NULL) {
                CcUnpinData(*(BcbPtrPtr++));
            }

            //
            //  Then free the pool for the Obcb
            //

            ExFreePool( Bcb );

        //
        //  Otherwise, it is a normal Bcb
        //

        } else {
            CcUnpinFileData( (PBCB)Bcb, FALSE, UNPIN );
        }
    }

    DebugTrace(-1, me, "CcUnPinData -> VOID\n", 0 );
}


VOID
CcSetBcbOwnerPointer (
    __in PVOID Bcb,
    __in PVOID OwnerPointer
    )

/*++

Routine Description:

    This routine may be called to set the resource owner for the Bcb resource,
    for cases where another thread will do the unpin *and* the current thread
    may exit.

Arguments:

    Bcb - Bcb parameter returned from the last call to CcPinRead.

    OwnerPointer - A valid resource owner pointer, which means a pointer to
                   an allocated system address, with the low-order two bits
                   set.  The address may not be deallocated until after the
                   unpin call.

Return Value:

    None.

--*/

{
    ASSERT(((ULONG_PTR)Bcb & 1) == 0);

    //
    //  Handle the overlapped Bcb case.
    //

    if (((POBCB)Bcb)->NodeTypeCode == CACHE_NTC_OBCB) {

        PBCB *BcbPtrPtr = &((POBCB)Bcb)->Bcbs[0];

        //
        //  Loop to set owner for all Bcbs.
        //

        while (*BcbPtrPtr != NULL) {
            ExSetResourceOwnerPointer( &(*BcbPtrPtr)->Resource, OwnerPointer );
            BcbPtrPtr++;
        }

    //
    //  Otherwise, it is a normal Bcb
    //

    } else {

        //
        //  Handle normal case.
        //

        ExSetResourceOwnerPointer( &((PBCB)Bcb)->Resource, OwnerPointer );
    }
}


VOID
CcUnpinDataForThread (
    __in PVOID Bcb,
    __in ERESOURCE_THREAD ResourceThreadId
    )

/*++

Routine Description:

    This routine must be called at IPL0, some time after calling CcPinRead
    or CcPreparePinWrite.  It performs any cleanup that is necessary,
    releasing the Bcb resource for the given thread.

Arguments:

    Bcb - Bcb parameter returned from the last call to CcPinRead.

Return Value:

    None.

--*/

{
    DebugTrace(+1, me, "CcUnpinDataForThread:\n", 0 );
    DebugTrace( 0, me, "    >Bcb = %08lx\n", Bcb );
    DebugTrace( 0, me, "    >ResoureceThreadId = %08lx\n", ResoureceThreadId );

    //
    //  Test for ReadOnly and unpin accordingly.
    //

    if (((ULONG_PTR)Bcb & 1) != 0) {

        //
        //  Remove the Read Only flag
        //

        Bcb = (PVOID) ((ULONG_PTR)Bcb & ~1);

        CcUnpinFileData( (PBCB)Bcb, TRUE, UNPIN );

    } else {

        //
        //  Handle the overlapped Bcb case.
        //

        if (((POBCB)Bcb)->NodeTypeCode == CACHE_NTC_OBCB) {

            PBCB *BcbPtrPtr = &((POBCB)Bcb)->Bcbs[0];

            //
            //  Loop to free all Bcbs with recursive calls
            //  (rather than dealing with RO for this uncommon case).
            //

            while (*BcbPtrPtr != NULL) {
                CcUnpinDataForThread( *(BcbPtrPtr++), ResourceThreadId );
            }

            //
            //  Then free the pool for the Obcb
            //

            ExFreePool( Bcb );

        //
        //  Otherwise, it is a normal Bcb
        //

        } else {

            //
            //  If not readonly, we can release the resource for the thread first,
            //  and then call CcUnpinFileData.  Release resource first in case
            //  Bcb gets deallocated.
            //

            ExReleaseResourceForThreadLite( &((PBCB)Bcb)->Resource, ResourceThreadId );
            CcUnpinFileData( (PBCB)Bcb, TRUE, UNPIN );
        }
    }
    DebugTrace(-1, me, "CcUnpinDataForThread -> VOID\n", 0 );
}


POBCB
CcAllocateObcb (
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN PBCB FirstBcb
    )

/*++

Routine Description:

    This routine is called by the various pinning routines to allocate and
    initialize an overlap Bcb.

Arguments:

    FileOffset - Starting file offset for the Obcb (An Obcb starts with a
                 public structure, which someone could use)

    Length - Length of the range covered by the Obcb

    FirstBcb - First Bcb already created, which only covers the start of
               the desired range (low order bit may be set to indicate ReadOnly)

Return Value:

    Pointer to the allocated Obcb

--*/

{
    ULONG LengthToAllocate;
    POBCB Obcb;
    PBCB Bcb = (PBCB)((ULONG_PTR)FirstBcb & ~1);

    //
    //  Allocate according to the worst case, assuming that we
    //  will need as many additional Bcbs as there are pages
    //  remaining. Also throw in one more pointer to guarantee
    //  users of the OBCB can always terminate on NULL.
    //
    //  We remove fron consideration the range described by the
    //  first Bcb (note that the range of the Obcb is not strictly
    //  starting at the first Bcb) and add in locations for the first
    //  bcb and the null.
    //

    LengthToAllocate = FIELD_OFFSET(OBCB, Bcbs) + (2 * sizeof(PBCB)) +
                       ((Length -
                         (Bcb->ByteLength -
                          (FileOffset->HighPart?
                           (ULONG)(FileOffset->QuadPart - Bcb->FileOffset.QuadPart) :
                           FileOffset->LowPart - Bcb->FileOffset.LowPart)) +
                         PAGE_SIZE - 1) / PAGE_SIZE) * sizeof(PBCB);

    Obcb = ExAllocatePoolWithTag( NonPagedPool, LengthToAllocate, 'bOcC' );
    if (Obcb == NULL) {
        ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
    }

    RtlZeroMemory( Obcb, LengthToAllocate );
    Obcb->NodeTypeCode = CACHE_NTC_OBCB;
    Obcb->NodeByteSize = (USHORT)LengthToAllocate;
    Obcb->ByteLength = Length;
    Obcb->FileOffset = *FileOffset;
    Obcb->Bcbs[0] = FirstBcb;

    return Obcb;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\cache\logsup.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    logsup.c

Abstract:

    This module implements the special cache manager support for logging
    file systems.

--*/

#include "cc.h"

//
//  Define our debug constant
//

#define me 0x0000040

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CcSetLogHandleForFile)
#endif


VOID
CcSetAdditionalCacheAttributes (
    __in PFILE_OBJECT FileObject,
    __in BOOLEAN DisableReadAhead,
    __in BOOLEAN DisableWriteBehind
    )

/*++

Routine Description:

    This routine supports the setting of disable read ahead or disable write
    behind flags to control Cache Manager operation.  This routine may be
    called any time after calling CcInitializeCacheMap.  Initially both
    read ahead and write behind are enabled.  Note that the state of both
    of these flags must be specified on each call to this routine.

Arguments:

    FileObject - File object for which the respective flags are to be set.

    DisableReadAhead - FALSE to enable read ahead, TRUE to disable it.

    DisableWriteBehind - FALSE to enable write behind, TRUE to disable it.

Return Value:

    None.

--*/

{
    PSHARED_CACHE_MAP SharedCacheMap;
    KIRQL OldIrql;

    //
    //  Get pointer to SharedCacheMap.
    //

    SharedCacheMap = FileObject->SectionObjectPointer->SharedCacheMap;

    //
    //  Now set the flags and return.
    //

    CcAcquireMasterLock( &OldIrql );
    if (DisableReadAhead) {
        SetFlag(SharedCacheMap->Flags, DISABLE_READ_AHEAD);
    } else {
        ClearFlag(SharedCacheMap->Flags, DISABLE_READ_AHEAD);
    }
    if (DisableWriteBehind) {
        SetFlag(SharedCacheMap->Flags, DISABLE_WRITE_BEHIND | MODIFIED_WRITE_DISABLED);
    } else {
        ClearFlag(SharedCacheMap->Flags, DISABLE_WRITE_BEHIND);
    }
    CcReleaseMasterLock( OldIrql );
}


NTKERNELAPI
BOOLEAN
CcSetPrivateWriteFile(
    PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine will instruct the cache manager to treat the file as
    a private-write stream, so that a caller can implement a private
    logging mechanism for it.  We will turn on both Mm's modify-no-write
    and our disable-write-behind, and disallow non-aware flush/purge for
    the file.

    Caching must already be initiated on the file.

    This routine is only exported to the kernel.

Arguments:

    FileObject - File to make private-write.

Return Value:

    None.

--*/

{
    PSHARED_CACHE_MAP SharedCacheMap;
    BOOLEAN Disabled;
    KIRQL OldIrql;
    PVACB Vacb;
    ULONG ActivePage;
    ULONG PageIsDirty;

    //
    //  Pick up the file exclusive to synchronize against readahead and
    //  other purge/map activity.
    //

    FsRtlAcquireFileExclusive( FileObject );

    //
    //  Get a pointer to the SharedCacheMap. Be sure to release the FileObject
    //  in case an error condition forces a premature exit.
    //
    
    if ((FileObject->SectionObjectPointer == NULL) ||
    	((SharedCacheMap = FileObject->SectionObjectPointer->SharedCacheMap) == NULL)){
    	 FsRtlReleaseFile( FileObject );
        return FALSE;
    }
    
    //
    //  Unmap all the views in preparation for making the disable mw call.
    //

    //
    //  We still need to wait for any dangling cache read or writes.
    //
    //  In fact we have to loop and wait because the lazy writer can
    //  sneak in and do an CcGetVirtualAddressIfMapped, and we are not
    //  synchronized.
    //
    //  This is the same bit of code that our purge will do.  We assume
    //  that a private writer has succesfully blocked out other activity.
    //

    //
    //  If there is an active Vacb, then delete it now (before waiting!).
    //

    CcAcquireMasterLock( &OldIrql );
    GetActiveVacbAtDpcLevel( SharedCacheMap, Vacb, ActivePage, PageIsDirty );
    CcReleaseMasterLock( OldIrql );
    
    if (Vacb != NULL) {

        CcFreeActiveVacb( SharedCacheMap, Vacb, ActivePage, PageIsDirty );
    }

    while ((SharedCacheMap->Vacbs != NULL) &&
           !CcUnmapVacbArray( SharedCacheMap, NULL, 0, FALSE )) {

        CcWaitOnActiveCount( SharedCacheMap );
    }

    //
    //  Knock the file down.
    // 

    CcFlushCache( FileObject->SectionObjectPointer, NULL, 0, NULL );

    //
    //  Now the file is clean and unmapped. We can still have a racing
    //  lazy writer, though.
    //
    //  We just wait for the lazy writer queue to drain before disabling
    //  modified write.  There may be a better way to do this by having
    //  an event for the WRITE_QUEUED flag. ?  This would also let us
    //  dispense with the pagingio pick/drop in the FS cache coherency
    //  paths, but there could be reasons why CcFlushCache shouldn't
    //  always do such a block.  Investigate this.
    //
    //  This wait takes on the order of ~.5s avg. case.
    //

    CcAcquireMasterLock( &OldIrql );
    
    if (FlagOn( SharedCacheMap->Flags, WRITE_QUEUED ) ||
        FlagOn( SharedCacheMap->Flags, READ_AHEAD_QUEUED )) {
        
        CcReleaseMasterLock( OldIrql );
        FsRtlReleaseFile( FileObject );
        CcWaitForCurrentLazyWriterActivity();
        FsRtlAcquireFileExclusive( FileObject );

    } else {

        CcReleaseMasterLock( OldIrql );
    }

    //
    //  Now set the flags and return.  We do not set our MODIFIED_WRITE_DISABLED
    //  since we don't want to fully promote this cache map.  Future?
    //

    Disabled = MmDisableModifiedWriteOfSection( FileObject->SectionObjectPointer );

    if (Disabled) {
        CcAcquireMasterLock( &OldIrql );
        SetFlag(SharedCacheMap->Flags, DISABLE_WRITE_BEHIND | PRIVATE_WRITE);
        CcReleaseMasterLock( OldIrql );
    }

    //
    //  Now release the file for regular operation.
    //

    FsRtlReleaseFile( FileObject );

    return Disabled;
}


VOID
CcSetLogHandleForFile (
    __in PFILE_OBJECT FileObject,
    __in PVOID LogHandle,
    __in PFLUSH_TO_LSN FlushToLsnRoutine
    )

/*++

Routine Description:

    This routine may be called to instruct the Cache Manager to store the
    specified log handle with the shared cache map for a file, to support
    subsequent calls to the other routines in this module which effectively
    perform an associative search for files by log handle.

Arguments:

    FileObject - File for which the log handle should be stored.

    LogHandle - Log Handle to store.

    FlushToLsnRoutine - A routine to call before flushing buffers for this
                        file, to ensure a log file is flushed to the most
                        recent Lsn for any Bcb being flushed.

Return Value:

    None.

--*/

{
    PSHARED_CACHE_MAP SharedCacheMap;

    //
    //  Get pointer to SharedCacheMap.
    //

    SharedCacheMap = FileObject->SectionObjectPointer->SharedCacheMap;

    //
    //  Now set the log file handle and flush routine
    //

    SharedCacheMap->LogHandle = LogHandle;
    SharedCacheMap->FlushToLsnRoutine = FlushToLsnRoutine;
}


LARGE_INTEGER
CcGetDirtyPages (
    __in PVOID LogHandle,
    __in PDIRTY_PAGE_ROUTINE DirtyPageRoutine,
    __in PVOID Context1,
    __in PVOID Context2
    )

/*++

Routine Description:

    This routine may be called to return all of the dirty pages in all files
    for a given log handle.  Each page is returned by an individual call to
    the Dirty Page Routine.  The Dirty Page Routine is defined by a prototype
    in ntos\inc\cache.h.

Arguments:

    LogHandle - Log Handle which must match the log handle previously stored
                for all files which are to be returned.

    DirtyPageRoutine -- The routine to call as each dirty page for this log
                        handle is found.

    Context1 - First context parameter to be passed to the Dirty Page Routine.

    Context2 - First context parameter to be passed to the Dirty Page Routine.

Return Value:

    LARGE_INTEGER - Oldest Lsn found of all the dirty pages, or 0 if no dirty pages

--*/

{
    PSHARED_CACHE_MAP SharedCacheMap;
    PBCB Bcb, BcbToUnpin = NULL;
    KLOCK_QUEUE_HANDLE LockHandle;
    LARGE_INTEGER SavedFileOffset, SavedOldestLsn, SavedNewestLsn;
    ULONG SavedByteLength;
    LARGE_INTEGER OldestLsn = {0,0};

    //
    //  Synchronize with changes to the SharedCacheMap list.
    //

    CcAcquireMasterLock( &LockHandle.OldIrql );

    SharedCacheMap = CONTAINING_RECORD( CcDirtySharedCacheMapList.SharedCacheMapLinks.Flink,
                                        SHARED_CACHE_MAP,
                                        SharedCacheMapLinks );

    //
    //  Use try/finally for cleanup.  The only spot where we can raise is out of the
    //  filesystem callback, but we have the exception handler out here so we aren't
    //  constantly setting/unsetting it.
    //

    try {

        while (&SharedCacheMap->SharedCacheMapLinks != &CcDirtySharedCacheMapList.SharedCacheMapLinks) {

            //
            //  Skip over cursors, SharedCacheMaps for other LogHandles, and ones with
            //  no dirty pages
            //

            if (!FlagOn(SharedCacheMap->Flags, IS_CURSOR) && (SharedCacheMap->LogHandle == LogHandle) &&
                (SharedCacheMap->DirtyPages != 0)) {

                //
                //  This SharedCacheMap should stick around for a while in the dirty list.
                //

                CcIncrementOpenCount( SharedCacheMap, 'pdGS' );
                SharedCacheMap->DirtyPages += 1;
                CcReleaseMasterLock( LockHandle.OldIrql );

                //
                //  Set our initial resume point and point to first Bcb in List.
                //

                KeAcquireInStackQueuedSpinLock( &SharedCacheMap->BcbSpinLock, &LockHandle );
                Bcb = CONTAINING_RECORD( SharedCacheMap->BcbList.Flink, BCB, BcbLinks );

                //
                //  Scan to the end of the Bcb list.
                //

                while (&Bcb->BcbLinks != &SharedCacheMap->BcbList) {

                    //
                    //  If the Bcb is dirty, then capture the inputs for the
                    //  callback routine so we can call without holding a spinlock.
                    //

                    if ((Bcb->NodeTypeCode == CACHE_NTC_BCB) && Bcb->Dirty) {

                        SavedFileOffset = Bcb->FileOffset;
                        SavedByteLength = Bcb->ByteLength;
                        SavedOldestLsn = Bcb->OldestLsn;
                        SavedNewestLsn = Bcb->NewestLsn;

                        //
                        //  Increment PinCount so the Bcb sticks around
                        //

                        Bcb->PinCount += 1;

                        KeReleaseInStackQueuedSpinLock( &LockHandle );

                        //
                        //  Any Bcb to unref from a previous loop?
                        //

                        if (BcbToUnpin != NULL) {
                            CcUnpinFileData( BcbToUnpin, TRUE, UNREF );
                            BcbToUnpin = NULL;
                        }

                        //
                        //  Call the file system.  This callback may raise status.
                        //

                        (*DirtyPageRoutine)( SharedCacheMap->FileObject,
                                             &SavedFileOffset,
                                             SavedByteLength,
                                             &SavedOldestLsn,
                                             &SavedNewestLsn,
                                             Context1,
                                             Context2 );

                        //
                        //  Possibly update OldestLsn
                        //

                        if ((SavedOldestLsn.QuadPart != 0) &&
                            ((OldestLsn.QuadPart == 0) || (SavedOldestLsn.QuadPart < OldestLsn.QuadPart ))) {
                            OldestLsn = SavedOldestLsn;
                        }

                        //
                        //  Now reacquire the spinlock and scan from the resume point
                        //  point to the next Bcb to return in the descending list.
                        //

                        KeAcquireInStackQueuedSpinLock( &SharedCacheMap->BcbSpinLock, &LockHandle );

                        //
                        //  Normally the Bcb can stay around a while, but if not,
                        //  we will just remember it for the next time we do not
                        //  have the spin lock.  We cannot unpin it now, because
                        //  we would lose our place in the list.
                        //
                        //  This is cheating, but it works and is sane since we're
                        //  already traversing the bcb list - dropping the bcb count
                        //  is OK, as long as we don't hit zero.  Zero requires a 
                        //  slight bit more attention that shouldn't be replicated.
                        //  (unmapping the view)
                        //

                        if (Bcb->PinCount > 1) {
                            Bcb->PinCount -= 1;
                        } else {
                            BcbToUnpin = Bcb;
                        }
                    }

                    Bcb = CONTAINING_RECORD( Bcb->BcbLinks.Flink, BCB, BcbLinks );
                }
                KeReleaseInStackQueuedSpinLock( &LockHandle );

                //
                //  We need to unref any Bcb we are holding before moving on to
                //  the next SharedCacheMap, or else CcDeleteSharedCacheMap will
                //  also delete this Bcb.
                //

                if (BcbToUnpin != NULL) {

                    CcUnpinFileData( BcbToUnpin, TRUE, UNREF );
                    BcbToUnpin = NULL;
                }

                CcAcquireMasterLock( &LockHandle.OldIrql );

                //
                //  Now release the SharedCacheMap, leaving it in the dirty list.
                //

                CcDecrementOpenCount( SharedCacheMap, 'pdGF' );
                SharedCacheMap->DirtyPages -= 1;
            }

            //
            //  Now loop back for the next cache map.
            //

            SharedCacheMap =
                CONTAINING_RECORD( SharedCacheMap->SharedCacheMapLinks.Flink,
                                   SHARED_CACHE_MAP,
                                   SharedCacheMapLinks );
        }

        CcReleaseMasterLock( LockHandle.OldIrql );

    } finally {

        //
        //  Drop the Bcb if we are being ejected.  We are guaranteed that the
        //  only raise is from the callback, at which point we have an incremented
        //  pincount.
        //

        if (AbnormalTermination()) {

            CcUnpinFileData( Bcb, TRUE, UNPIN );
        }
    }

    return OldestLsn;
}


BOOLEAN
CcIsThereDirtyData (
    __in PVPB Vpb
    )

/*++

Routine Description:

    This routine returns TRUE if the specified Vcb has any unwritten dirty
    data in the cache.

Arguments:

    Vpb - specifies Vpb to check for

Return Value:

    FALSE - if the Vpb has no dirty data
    TRUE - if the Vpb has dirty data

--*/

{
    PSHARED_CACHE_MAP SharedCacheMap;
    KIRQL OldIrql;
    ULONG LoopsWithLockHeld = 0;

    //
    //  Synchronize with changes to the SharedCacheMap list.
    //

    CcAcquireMasterLock( &OldIrql );

    SharedCacheMap = CONTAINING_RECORD( CcDirtySharedCacheMapList.SharedCacheMapLinks.Flink,
                                        SHARED_CACHE_MAP,
                                        SharedCacheMapLinks );

    while (&SharedCacheMap->SharedCacheMapLinks != &CcDirtySharedCacheMapList.SharedCacheMapLinks) {

        //
        //  Look at this one if the Vpb matches and if there is dirty data.
        //  For what it's worth, don't worry about dirty data in temporary files,
        //  as that should not concern the caller if it wants to dismount.
        //

        if (!FlagOn(SharedCacheMap->Flags, IS_CURSOR) &&
            (SharedCacheMap->FileObject->Vpb == Vpb) &&
            (SharedCacheMap->DirtyPages != 0) &&
            !FlagOn(SharedCacheMap->FileObject->Flags, FO_TEMPORARY_FILE)) {

            CcReleaseMasterLock( OldIrql );
            return TRUE;
        }

        //
        //  Make sure we occasionally drop the lock.  Set WRITE_QUEUED
        //  to keep the guy from going away, and increment DirtyPages to
        //  keep it in this list.
        //

        if ((++LoopsWithLockHeld >= 20) &&
            !FlagOn(SharedCacheMap->Flags, WRITE_QUEUED | IS_CURSOR)) {

            SetFlag( *((ULONG volatile *)&SharedCacheMap->Flags), WRITE_QUEUED);
            *((ULONG volatile *)&SharedCacheMap->DirtyPages) += 1;
            CcReleaseMasterLock( OldIrql );
            LoopsWithLockHeld = 0;
            CcAcquireMasterLock( &OldIrql );
            ClearFlag( *((ULONG volatile *)&SharedCacheMap->Flags), WRITE_QUEUED);
            *((ULONG volatile *)&SharedCacheMap->DirtyPages) -= 1;
        }

        //
        //  Now loop back for the next cache map.
        //

        SharedCacheMap =
            CONTAINING_RECORD( SharedCacheMap->SharedCacheMapLinks.Flink,
                               SHARED_CACHE_MAP,
                               SharedCacheMapLinks );
    }

    CcReleaseMasterLock( OldIrql );

    return FALSE;
}

LARGE_INTEGER
CcGetLsnForFileObject(
    __in PFILE_OBJECT FileObject,
    __out_opt PLARGE_INTEGER OldestLsn
    )

/*++

Routine Description:

    This routine returns the  oldest and newest LSNs for a file object.

Arguments:

    FileObject - File for which the log handle should be stored.

    OldestLsn - pointer to location to store oldest LSN for file object.

Return Value:

    The newest LSN for the file object.

--*/

{
    PBCB Bcb;
    KLOCK_QUEUE_HANDLE LockHandle;
    LARGE_INTEGER Oldest, Newest;
    PSHARED_CACHE_MAP SharedCacheMap = FileObject->SectionObjectPointer->SharedCacheMap;

    //
    // initialize lsn variables
    //

    Oldest.LowPart = 0;
    Oldest.HighPart = 0;
    Newest.LowPart = 0;
    Newest.HighPart = 0;

    if(SharedCacheMap == NULL) {
        return Oldest;
    }

    KeAcquireInStackQueuedSpinLock(&SharedCacheMap->BcbSpinLock, &LockHandle);

    //
    //  Now point to first Bcb in List, and loop through it.
    //

    Bcb = CONTAINING_RECORD( SharedCacheMap->BcbList.Flink, BCB, BcbLinks );

    while (&Bcb->BcbLinks != &SharedCacheMap->BcbList) {

        //
        //  If the Bcb is dirty then capture the oldest and newest lsn
        //


        if ((Bcb->NodeTypeCode == CACHE_NTC_BCB) && Bcb->Dirty) {

            LARGE_INTEGER BcbLsn, BcbNewest;

            BcbLsn = Bcb->OldestLsn;
            BcbNewest = Bcb->NewestLsn;

            if ((BcbLsn.QuadPart != 0) &&
                ((Oldest.QuadPart == 0) ||
                 (BcbLsn.QuadPart < Oldest.QuadPart))) {

                 Oldest = BcbLsn;
            }

            if ((BcbLsn.QuadPart != 0) && (BcbNewest.QuadPart > Newest.QuadPart)) {

                Newest = BcbNewest;
            }
        }


        Bcb = CONTAINING_RECORD( Bcb->BcbLinks.Flink, BCB, BcbLinks );
    }

    //
    //  Now release the spin lock for this Bcb list and generate a callback
    //  if we got something.
    //

    KeReleaseInStackQueuedSpinLock( &LockHandle );

    if (ARGUMENT_PRESENT(OldestLsn)) {

        *OldestLsn = Oldest;
    }

    return Newest;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmboot.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmboot.c

Abstract:

    This provides routines for determining driver load lists from the
    registry.  The relevant drivers are extracted from the registry,
    sorted by groups, and then dependencies are resolved.

    This module is used by IoInitSystem for determining
    the drivers to be loaded in Phase 1 Initialization
    (CmGetSystemDriverList)

--*/

#include "cmp.h"
#include <profiles.h>

#define LOAD_LAST 0xffffffff
#define LOAD_NEXT_TO_LAST (LOAD_LAST-1)

//
// Private function prototypes.
//
BOOLEAN
CmpAddDriverToList(
    IN PHHIVE Hive,
    IN HCELL_INDEX DriverCell,
    IN HCELL_INDEX GroupOrderCell,
    IN PUNICODE_STRING RegistryPath,
    IN PLIST_ENTRY BootDriverListHead
    );

BOOLEAN
CmpDoSort(
    IN PLIST_ENTRY DriverListHead,
    IN PUNICODE_STRING OrderList
    );

ULONG
CmpFindTagIndex(
    IN PHHIVE Hive,
    IN HCELL_INDEX TagCell,
    IN HCELL_INDEX GroupOrderCell,
    IN PUNICODE_STRING GroupName
    );

BOOLEAN
CmpIsLoadType(
    IN PHHIVE Hive,
    IN HCELL_INDEX Cell,
    IN SERVICE_LOAD_TYPE LoadType
    );

BOOLEAN
CmpOrderGroup(
    IN PBOOT_DRIVER_NODE GroupStart,
    IN PBOOT_DRIVER_NODE GroupEnd
    );

VOID
BlPrint(
    PCHAR cp,
    ...
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,CmpFindNLSData)
#pragma alloc_text(INIT,CmpFindDrivers)
#pragma alloc_text(INIT,CmpIsLoadType)
#pragma alloc_text(INIT,CmpAddDriverToList)
#pragma alloc_text(INIT,CmpSortDriverList)
#pragma alloc_text(INIT,CmpDoSort)
#pragma alloc_text(INIT,CmpResolveDriverDependencies)
#pragma alloc_text(INIT,CmpSetCurrentProfile)
#pragma alloc_text(INIT,CmpOrderGroup)
#pragma alloc_text(PAGE,CmpFindControlSet)
#pragma alloc_text(INIT,CmpFindTagIndex)
#pragma alloc_text(INIT,CmpFindProfileOption)
#pragma alloc_text(INIT,CmpValidateSelect)
#ifdef _WANT_MACHINE_IDENTIFICATION
#pragma alloc_text(INIT,CmpGetBiosDateFromRegistry)
#endif
#endif


BOOLEAN
CmpFindNLSData(
    IN PHHIVE Hive,
    IN HCELL_INDEX ControlSet,
    OUT PUNICODE_STRING AnsiFilename,
    OUT PUNICODE_STRING OemFilename,
    OUT PUNICODE_STRING CaseTableFilename,
    OUT PUNICODE_STRING OemHalFont
    )

/*++

Routine Description:

    Traverses a particular control set and determines the filenames for
    the NLS data files that need to be loaded.

Arguments:

    Hive - Supplies the hive control structure for the SYSTEM hive.

    ControlSet - Supplies the HCELL_INDEX of the root of the control set.

    AnsiFileName - Returns the name of the Ansi codepage file (c_1252.nls)

    OemFileName -  Returns the name of the OEM codepage file  (c_437.nls)

    CaseTableFileName - Returns the name of the Unicode upper/lowercase
            table for the language (l_intl.nls)

    OemHalfont - Returns the name of the font file to be used by the HAL.

Return Value:

    TRUE - filenames successfully determined

    FALSE - hive is corrupt

--*/

{
    UNICODE_STRING Name;
    HCELL_INDEX Control;
    HCELL_INDEX Nls;
    HCELL_INDEX CodePage;
    HCELL_INDEX Language;
    HCELL_INDEX ValueCell;
    PCM_KEY_VALUE Value;
    ULONG realsize;
    PCM_KEY_NODE Node;

    //
    // no mapped hives at this point. don't bother releasing cells
    //
    ASSERT( Hive->ReleaseCellRoutine == NULL );
    //
    // Find CONTROL node
    //
    Node = (PCM_KEY_NODE)HvGetCell(Hive,ControlSet);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    RtlInitUnicodeString(&Name, L"Control");
    Control = CmpFindSubKeyByName(Hive,
                                 Node,
                                 &Name);
    if (Control == HCELL_NIL) {
        return(FALSE);
    }

    //
    // Find NLS node
    //
    Node = (PCM_KEY_NODE)HvGetCell(Hive,Control);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    RtlInitUnicodeString(&Name, L"NLS");
    Nls = CmpFindSubKeyByName(Hive,
                             Node,
                             &Name);
    if (Nls == HCELL_NIL) {
        return(FALSE);
    }

    //
    // Find CodePage node
    //
    Node = (PCM_KEY_NODE)HvGetCell(Hive,Nls);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    RtlInitUnicodeString(&Name, L"CodePage");
    CodePage = CmpFindSubKeyByName(Hive,
                                  Node,
                                  &Name);
    if (CodePage == HCELL_NIL) {
        return(FALSE);
    }

    //
    // Find ACP value
    //
    Node = (PCM_KEY_NODE)HvGetCell(Hive,CodePage);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    RtlInitUnicodeString(&Name, L"ACP");
    ValueCell = CmpFindValueByName(Hive,
                                   Node,
                                   &Name);
    if (ValueCell == HCELL_NIL) {
        return(FALSE);
    }

    Value = (PCM_KEY_VALUE)HvGetCell(Hive, ValueCell);
    if( Value == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    Name.Buffer = (PWSTR)CmpValueToData(Hive,Value,&realsize);
    if( Name.Buffer == NULL ) {
        //
        // HvGetCell inside CmpValueToData failed; bail out safely
        //
        return FALSE;
    }
    Name.MaximumLength=(USHORT)realsize;
    Name.Length = 0;
    while ((Name.Length<Name.MaximumLength) &&
           (Name.Buffer[Name.Length/sizeof(WCHAR)] != UNICODE_NULL)) {
        Name.Length += sizeof(WCHAR);
    }

    //
    // Find ACP filename
    //
    Node = (PCM_KEY_NODE)HvGetCell(Hive,CodePage);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    ValueCell = CmpFindValueByName(Hive,
                                   Node,
                                   &Name);
    if (ValueCell == HCELL_NIL) {
        return(FALSE);
    }

    Value = (PCM_KEY_VALUE)HvGetCell(Hive, ValueCell);
    if( Value == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    AnsiFilename->Buffer = (PWSTR)CmpValueToData(Hive,Value,&realsize);
    if( AnsiFilename->Buffer == NULL ) {
        //
        // HvGetCell inside CmpValueToData failed; bail out safely
        //
        return FALSE;
    }
    AnsiFilename->Length = AnsiFilename->MaximumLength = (USHORT)realsize;

    //
    // Find OEMCP node
    //
    Node = (PCM_KEY_NODE)HvGetCell(Hive,CodePage);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    RtlInitUnicodeString(&Name, L"OEMCP");
    ValueCell = CmpFindValueByName(Hive,
                                   Node,
                                   &Name);
    if (ValueCell == HCELL_NIL) {
        return(FALSE);
    }

    Value = (PCM_KEY_VALUE)HvGetCell(Hive, ValueCell);
    if( Value == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    Name.Buffer = (PWSTR)CmpValueToData(Hive,Value,&realsize);
    if( Name.Buffer == NULL ) {
        //
        // HvGetCell inside CmpValueToData failed; bail out safely
        //
        return FALSE;
    }
    Name.MaximumLength = (USHORT)realsize;
    Name.Length = 0;
    while ((Name.Length<Name.MaximumLength) &&
           (Name.Buffer[Name.Length/sizeof(WCHAR)] != UNICODE_NULL)) {
        Name.Length += sizeof(WCHAR);
    }

    //
    // Find OEMCP filename
    //
    Node = (PCM_KEY_NODE)HvGetCell(Hive,CodePage);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    ValueCell = CmpFindValueByName(Hive,
                                   Node,
                                   &Name);
    if (ValueCell == HCELL_NIL) {
        return(FALSE);
    }

    Value = (PCM_KEY_VALUE)HvGetCell(Hive, ValueCell);
    if( Value == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    OemFilename->Buffer = (PWSTR)CmpValueToData(Hive, Value,&realsize);
    if( OemFilename->Buffer == NULL ) {
        //
        // HvGetCell inside CmpValueToData failed; bail out safely
        //
        return FALSE;
    }
    OemFilename->Length = OemFilename->MaximumLength = (USHORT)realsize;

    //
    // Find Language node
    //
    Node = (PCM_KEY_NODE)HvGetCell(Hive,Nls);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    RtlInitUnicodeString(&Name, L"Language");
    Language = CmpFindSubKeyByName(Hive,
                                   Node,
                                   &Name);
    if (Language == HCELL_NIL) {
        return(FALSE);
    }

    //
    // Find Default value
    //
    Node = (PCM_KEY_NODE)HvGetCell(Hive,Language);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    RtlInitUnicodeString(&Name, L"Default");
    ValueCell = CmpFindValueByName(Hive,
                                   Node,
                                   &Name);
    if (ValueCell == HCELL_NIL) {
            return(FALSE);
    }

    Value = (PCM_KEY_VALUE)HvGetCell(Hive, ValueCell);
    if( Value == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    Name.Buffer = (PWSTR)CmpValueToData(Hive, Value,&realsize);
    if( Name.Buffer == NULL ) {
        //
        // HvGetCell inside CmpValueToData failed; bail out safely
        //
        return FALSE;
    }
    Name.MaximumLength = (USHORT)realsize;
    Name.Length = 0;

    while ((Name.Length<Name.MaximumLength) &&
           (Name.Buffer[Name.Length/sizeof(WCHAR)] != UNICODE_NULL)) {
        Name.Length+=sizeof(WCHAR);
    }

    //
    // Find default filename
    //
    Node = (PCM_KEY_NODE)HvGetCell(Hive,Language);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    ValueCell = CmpFindValueByName(Hive,
                                   Node,
                                   &Name);
    if (ValueCell == HCELL_NIL) {
        return(FALSE);
    }

    Value = (PCM_KEY_VALUE)HvGetCell(Hive, ValueCell);
    if( Value == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    CaseTableFilename->Buffer = (PWSTR)CmpValueToData(Hive, Value,&realsize);
    if( CaseTableFilename->Buffer == NULL ) {
        //
        // HvGetCell inside CmpValueToData failed; bail out safely
        //
        return FALSE;
    }
    CaseTableFilename->Length = CaseTableFilename->MaximumLength = (USHORT)realsize;

    //
    // Find OEMHAL filename
    //
    Node = (PCM_KEY_NODE)HvGetCell(Hive,CodePage);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    RtlInitUnicodeString(&Name, L"OEMHAL");
    ValueCell = CmpFindValueByName(Hive,
                                   Node,
                                   &Name);
    if (ValueCell == HCELL_NIL) {
#ifdef i386
        OemHalFont->Buffer = NULL;
        OemHalFont->Length = 0;
        OemHalFont->MaximumLength = 0;
        return TRUE;
#else
        return(FALSE);
#endif
    }

    Value = (PCM_KEY_VALUE)HvGetCell(Hive, ValueCell);
    if( Value == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    OemHalFont->Buffer = (PWSTR)CmpValueToData(Hive,Value,&realsize);
    if( OemHalFont->Buffer == NULL ) {
        //
        // HvGetCell inside CmpValueToData failed; bail out safely
        //
        return FALSE;
    }
    OemHalFont->Length = (USHORT)realsize;
    OemHalFont->MaximumLength = (USHORT)realsize;

    return(TRUE);
}


BOOLEAN
CmpFindDrivers(
    IN PHHIVE Hive,
    IN HCELL_INDEX ControlSet,
    IN SERVICE_LOAD_TYPE LoadType,
    IN PWSTR BootFileSystem OPTIONAL,
    IN PLIST_ENTRY DriverListHead
    )

/*++

Routine Description:

    Traverses a particular control set and creates a list of boot drivers
    to be loaded.  This list is unordered, but complete.

Arguments:

    Hive - Supplies the hive control structure for the SYSTEM hive.

    ControlSet - Supplies the HCELL_INDEX of the root of the control set.

    LoadType - Supplies the type of drivers to be loaded (BootLoad,
            SystemLoad, AutoLoad, etc)

    BootFileSystem - If present, supplies the base name of the boot
        filesystem, which is explicitly added to the driver list.

    DriverListHead - Supplies a pointer to the head of the (empty) list
            of boot drivers to load.

Return Value:

    TRUE - List successfully created.

    FALSE - Hive is corrupt.

--*/

{
    HCELL_INDEX Services;
    HCELL_INDEX Control;
    HCELL_INDEX GroupOrder;
    HCELL_INDEX DriverCell;
    UNICODE_STRING Name;
    int i;
    UNICODE_STRING UnicodeString;
    UNICODE_STRING BasePath;
    WCHAR BaseBuffer[128];
    PBOOT_DRIVER_NODE BootFileSystemNode;
    PCM_KEY_NODE ControlNode;
    PCM_KEY_NODE ServicesNode;
    PCM_KEY_NODE Node;

    //
    // no mapped hives at this point. don't bother releasing cells
    //
    ASSERT( Hive->ReleaseCellRoutine == NULL );
    //
    // Find SERVICES node.
    //
    ControlNode = (PCM_KEY_NODE)HvGetCell(Hive,ControlSet);
    if( ControlNode == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    RtlInitUnicodeString(&Name, L"Services");
    Services = CmpFindSubKeyByName(Hive,
                                   ControlNode,
                                   &Name);
    if (Services == HCELL_NIL) {
        return(FALSE);
    }
    ServicesNode = (PCM_KEY_NODE)HvGetCell(Hive,Services);
    if( ServicesNode == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }

    //
    // Find CONTROL node.
    //
    RtlInitUnicodeString(&Name, L"Control");
    Control = CmpFindSubKeyByName(Hive,
                                  ControlNode,
                                  &Name);
    if (Control == HCELL_NIL) {
        return(FALSE);
    }

    //
    // Find GroupOrderList node.
    //
    RtlInitUnicodeString(&Name, L"GroupOrderList");
    Node = (PCM_KEY_NODE)HvGetCell(Hive,Control);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    GroupOrder = CmpFindSubKeyByName(Hive,
                                     Node,
                                     &Name);
    if (GroupOrder == HCELL_NIL) {
        return(FALSE);
    }

    BasePath.Length = 0;
    BasePath.MaximumLength = sizeof(BaseBuffer);
    BasePath.Buffer = BaseBuffer;
    RtlAppendUnicodeToString(&BasePath, L"\\Registry\\Machine\\System\\");
    RtlAppendUnicodeToString(&BasePath, L"CurrentControlSet\\Services\\");

    i=0;
    do {
        DriverCell = CmpFindSubKeyByNumber(Hive,ServicesNode,i++);
        if (DriverCell != HCELL_NIL) {
            if (CmpIsLoadType(Hive, DriverCell, LoadType)) {
                CmpAddDriverToList(Hive,
                                   DriverCell,
                                   GroupOrder,
                                   &BasePath,
                                   DriverListHead);

            }
        }
    } while ( DriverCell != HCELL_NIL );

    if (ARGUMENT_PRESENT(BootFileSystem)) {
        //
        // Add boot filesystem to boot driver list
        //

        RtlInitUnicodeString(&UnicodeString, BootFileSystem);
        DriverCell = CmpFindSubKeyByName(Hive,
                                         ServicesNode,
                                         &UnicodeString);
        if (DriverCell != HCELL_NIL) {
            CmpAddDriverToList(Hive,
                               DriverCell,
                               GroupOrder,
                               &BasePath,
                               DriverListHead);

            //
            // mark the Boot Filesystem critical
            //
            BootFileSystemNode = CONTAINING_RECORD(DriverListHead->Flink,
                                                   BOOT_DRIVER_NODE,
                                                   ListEntry.Link);
            BootFileSystemNode->ErrorControl = SERVICE_ERROR_CRITICAL;
        }
    }
    return(TRUE);

}


BOOLEAN
CmpIsLoadType(
    IN PHHIVE Hive,
    IN HCELL_INDEX Cell,
    IN SERVICE_LOAD_TYPE LoadType
    )

/*++

Routine Description:

    Determines if the driver is of a specified LoadType, based on its
    node values.

Arguments:

    Hive - Supplies a pointer to the hive control structure for the system
           hive.

    Cell - Supplies the cell index of the driver's node in the system hive.

    LoadType - Supplies the type of drivers to be loaded (BootLoad,
            SystemLoad, AutoLoad, etc)

Return Value:

    TRUE - Driver is the correct type and should be loaded.

    FALSE - Driver is not the correct type and should not be loaded.

--*/

{
    HCELL_INDEX ValueCell;
    PLONG Data;
    UNICODE_STRING Name;
    PCM_KEY_VALUE Value;
    ULONG realsize;
    PCM_KEY_NODE Node;

    //
    // no mapped hives at this point. don't bother releasing cells
    //
    ASSERT( Hive->ReleaseCellRoutine == NULL );
    //
    // Must have a Start=BootLoad value in order to be a boot driver, so
    // look for that first.
    //
    Node = (PCM_KEY_NODE)HvGetCell(Hive,Cell);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    RtlInitUnicodeString(&Name, L"Start");
    ValueCell = CmpFindValueByName(Hive,
                                   Node,
                                   &Name);
    if (ValueCell == HCELL_NIL) {
        return(FALSE);
    }

    Value = (PCM_KEY_VALUE)HvGetCell(Hive, ValueCell);
    if( Value == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }

    Data = (PLONG)CmpValueToData(Hive,Value,&realsize);
    if( Data == NULL ) {
        //
        // HvGetCell inside CmpValueToData failed; bail out safely
        //
        return FALSE;
    }

    if (*Data != LoadType) {
        return(FALSE);
    }

    return(TRUE);
}


BOOLEAN
CmpAddDriverToList(
    IN PHHIVE Hive,
    IN HCELL_INDEX DriverCell,
    IN HCELL_INDEX GroupOrderCell,
    IN PUNICODE_STRING RegistryPath,
    IN PLIST_ENTRY BootDriverListHead
    )

/*++

Routine Description:

    This routine allocates a list entry node for a particular driver.
    It initializes it with the registry path, filename, group name, and
    dependency list.  Finally, it inserts the new node into the boot
    driver list.

    Note that this routine allocates memory by calling the Hive's
    memory allocation procedure.

Arguments:

    Hive - Supplies a pointer to the hive control structure

    DriverCell - Supplies the HCELL_INDEX of the driver's node in the hive.

    GroupOrderCell - Supplies the HCELL_INDEX of the GroupOrderList key.
        ( \Registry\Machine\System\CurrentControlSet\Control\GroupOrderList )

    RegistryPath - Supplies the full registry path to the SERVICES node
            of the current control set.

    BootDriverListHead - Supplies the head of the boot driver list

Return Value:

    TRUE - Driver successfully added to boot driver list.

    FALSE - Could not add driver to boot driver list.

--*/

{
    PCM_KEY_NODE            Driver;
    USHORT                  DriverNameLength;
    PCM_KEY_VALUE           Value;
    PBOOT_DRIVER_NODE       DriverNode;
    PBOOT_DRIVER_LIST_ENTRY DriverEntry;
    HCELL_INDEX             ValueCell;
    HCELL_INDEX             Tag;
    UNICODE_STRING          UnicodeString;
    PUNICODE_STRING         FileName;
    ULONG                   Length;
    ULONG                   realsize;
    PULONG                  TempULong;
    PWSTR                   TempBuffer;

    //
    // no mapped hives at this point. don't bother releasing cells
    //
    ASSERT( Hive->ReleaseCellRoutine == NULL );

    Driver = (PCM_KEY_NODE)HvGetCell(Hive, DriverCell);
    if( Driver == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    DriverNode = (Hive->Allocate)(sizeof(BOOT_DRIVER_NODE),FALSE,CM_FIND_LEAK_TAG1);
    if (DriverNode == NULL) {
        return(FALSE);
    }
    DriverEntry = &DriverNode->ListEntry;

    DriverEntry->RegistryPath.Buffer = NULL;
    DriverEntry->FilePath.Buffer = NULL;

    if (Driver->Flags & KEY_COMP_NAME) {
        DriverNode->Name.Length = CmpCompressedNameSize(Driver->Name,Driver->NameLength);
        DriverNode->Name.Buffer = (Hive->Allocate)(DriverNode->Name.Length, FALSE,CM_FIND_LEAK_TAG2);
        if (DriverNode->Name.Buffer == NULL) {
            return(FALSE);
        }
        CmpCopyCompressedName(DriverNode->Name.Buffer,
                              DriverNode->Name.Length,
                              Driver->Name,
                              Driver->NameLength);

    } else {
        DriverNode->Name.Length = Driver->NameLength;
        DriverNode->Name.Buffer = (Hive->Allocate)(DriverNode->Name.Length, FALSE,CM_FIND_LEAK_TAG2);
        if (DriverNode->Name.Buffer == NULL) {
            return(FALSE);
        }
        RtlCopyMemory((PVOID)(DriverNode->Name.Buffer), (PVOID)(Driver->Name), Driver->NameLength);
    }
    DriverNode->Name.MaximumLength = DriverNode->Name.Length;
    DriverNameLength = DriverNode->Name.Length;

    //
    // Check for ImagePath value, which will override the default name
    // if it is present.
    //
    RtlInitUnicodeString(&UnicodeString, L"ImagePath");
    ValueCell = CmpFindValueByName(Hive,
                                   Driver,
                                   &UnicodeString);
    if (ValueCell == HCELL_NIL) {

        //
        // No ImagePath, so generate default filename.
        // Build up Unicode filename  ("system32\drivers\<nodename>.sys");
        //

        Length = sizeof(L"System32\\Drivers\\") +
                 DriverNameLength  +
                 sizeof(L".sys");

        FileName = &DriverEntry->FilePath;
        FileName->Length = 0;
        FileName->MaximumLength = (USHORT)Length;
        FileName->Buffer = (PWSTR)(Hive->Allocate)(Length, FALSE,CM_FIND_LEAK_TAG3);
        if (FileName->Buffer == NULL) {
            return(FALSE);
        }
        if (!NT_SUCCESS(RtlAppendUnicodeToString(FileName, L"System32\\"))) {
            return(FALSE);
        }
        if (!NT_SUCCESS(RtlAppendUnicodeToString(FileName, L"Drivers\\"))) {
            return(FALSE);
        }
        if (!NT_SUCCESS(
                RtlAppendUnicodeStringToString(FileName,
                                               &DriverNode->Name))) {
            return(FALSE);
        }
        if (!NT_SUCCESS(RtlAppendUnicodeToString(FileName, L".sys"))) {
            return(FALSE);
        }

    } else {
        Value = (PCM_KEY_VALUE)HvGetCell(Hive,ValueCell);
        if( Value == NULL ) {
            //
            // we couldn't map a view for the bin containing this cell
            //

            return FALSE;
        }
        FileName = &DriverEntry->FilePath;
        TempBuffer = (PWSTR)CmpValueToData(Hive,Value,&realsize);
        FileName->Buffer = (PWSTR)(Hive->Allocate)(realsize, FALSE,CM_FIND_LEAK_TAG3);
        if( (FileName->Buffer == NULL) || (TempBuffer == NULL) ) {
            //
            // HvGetCell inside CmpValueToData failed; bail out safely
            //
            return FALSE;
        }
        RtlCopyMemory((PVOID)(FileName->Buffer), (PVOID)(TempBuffer), realsize);
        FileName->MaximumLength = FileName->Length = (USHORT)realsize;
    }

    FileName = &DriverEntry->RegistryPath;
    FileName->Length = 0;
    FileName->MaximumLength = RegistryPath->Length + DriverNameLength;
    FileName->Buffer = (Hive->Allocate)(FileName->MaximumLength,FALSE,CM_FIND_LEAK_TAG4);
    if (FileName->Buffer == NULL) {
        return(FALSE);
    }
    RtlAppendUnicodeStringToString(FileName, RegistryPath);
    RtlAppendUnicodeStringToString(FileName, &DriverNode->Name);

    InsertHeadList(BootDriverListHead, &DriverEntry->Link);

    //
    // Find "ErrorControl" value
    //

    RtlInitUnicodeString(&UnicodeString, L"ErrorControl");
    ValueCell = CmpFindValueByName(Hive,
                                   Driver,
                                   &UnicodeString);
    if (ValueCell == HCELL_NIL) {
        DriverNode->ErrorControl = NormalError;
    } else {
        Value = (PCM_KEY_VALUE)HvGetCell(Hive, ValueCell);
        if( Value == NULL ) {
            //
            // we couldn't map a view for the bin containing this cell
            //

            return FALSE;
        }

        TempULong = (PULONG)CmpValueToData(Hive,Value,&realsize);
        if( TempULong == NULL ) {
            //
            // HvGetCell inside CmpValueToData failed; bail out safely
            //
            return FALSE;
        }
        DriverNode->ErrorControl = *TempULong;
    }

    //
    // Find "Group" value
    //
    RtlInitUnicodeString(&UnicodeString, L"group");
    ValueCell = CmpFindValueByName(Hive,
                                   Driver,
                                   &UnicodeString);
    if (ValueCell == HCELL_NIL) {
        DriverNode->Group.Length = 0;
        DriverNode->Group.MaximumLength = 0;
        DriverNode->Group.Buffer = NULL;
    } else {
        Value = (PCM_KEY_VALUE)HvGetCell(Hive, ValueCell);
        if( Value == NULL ) {
            //
            // we couldn't map a view for the bin containing this cell
            //

            return FALSE;
        }

        DriverNode->Group.Buffer = (PWSTR)CmpValueToData(Hive,Value,&realsize);
        if( DriverNode->Group.Buffer == NULL ) {
            //
            // HvGetCell inside CmpValueToData failed; bail out safely
            //
            return FALSE;
        }
        DriverNode->Group.Length = (USHORT)realsize - sizeof(WCHAR);
        DriverNode->Group.MaximumLength = (USHORT)DriverNode->Group.Length;
    }

    //
    // Calculate the tag value for the driver.  If the driver has no tag,
    // this defaults to 0xffffffff, so the driver is loaded last in the
    // group.
    //
    RtlInitUnicodeString(&UnicodeString, L"Tag");
    Tag = CmpFindValueByName(Hive,
                             Driver,
                             &UnicodeString);
    if (Tag == HCELL_NIL) {
        DriverNode->Tag = LOAD_LAST;
    } else {
        //
        // Now we have to find this tag in the tag list for the group.
        // If the tag is not in the tag list, then it defaults to 0xfffffffe,
        // so it is loaded after all the drivers in the tag list, but before
        // all the drivers without tags at all.
        //

        DriverNode->Tag = CmpFindTagIndex(Hive,
                                          Tag,
                                          GroupOrderCell,
                                          &DriverNode->Group);
    }

    return(TRUE);

}


BOOLEAN
CmpSortDriverList(
    IN PHHIVE Hive,
    IN HCELL_INDEX ControlSet,
    IN PLIST_ENTRY DriverListHead
    )

/*++

Routine Description:

    Sorts the list of boot drivers by their groups based on the group
    ordering in <control_set>\CONTROL\SERVICE_GROUP_ORDER:list

    Does NOT do dependency ordering.

Arguments:

    Hive - Supplies the hive control structure for the SYSTEM hive.

    ControlSet - Supplies the HCELL_INDEX of the root of the control set.

    DriverListHead - Supplies a pointer to the head of the list of
            boot drivers to be sorted.

Return Value:

    TRUE - List successfully sorted

    FALSE - List is inconsistent and could not be sorted.

--*/

{
    HCELL_INDEX Controls;
    HCELL_INDEX GroupOrder;
    HCELL_INDEX ListCell;
    UNICODE_STRING Name;
    UNICODE_STRING DependList;
    PCM_KEY_VALUE ListNode;
    ULONG realsize;
    PCM_KEY_NODE Node;

    //
    // no mapped hives at this point. don't bother releasing cells
    //
    ASSERT( Hive->ReleaseCellRoutine == NULL );
    //
    // Find "CONTROL" node.
    //
    Node = (PCM_KEY_NODE)HvGetCell(Hive,ControlSet);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    RtlInitUnicodeString(&Name, L"Control");
    Controls = CmpFindSubKeyByName(Hive,
                                   Node,
                                   &Name);
    if (Controls == HCELL_NIL) {
        return(FALSE);
    }

    //
    // Find "SERVICE_GROUP_ORDER" subkey
    //
    Node = (PCM_KEY_NODE)HvGetCell(Hive,Controls);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    RtlInitUnicodeString(&Name, L"ServiceGroupOrder");
    GroupOrder = CmpFindSubKeyByName(Hive,
                                     Node,
                                     &Name);
    if (GroupOrder == HCELL_NIL) {
        return(FALSE);
    }

    //
    // Find "list" value
    //
    Node = (PCM_KEY_NODE)HvGetCell(Hive,GroupOrder);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    RtlInitUnicodeString(&Name, L"list");
    ListCell = CmpFindValueByName(Hive,
                                  Node,
                                  &Name);
    if (ListCell == HCELL_NIL) {
        return(FALSE);
    }
    ListNode = (PCM_KEY_VALUE)HvGetCell(Hive, ListCell);
    if( ListNode == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    if (ListNode->Type != REG_MULTI_SZ) {
        return(FALSE);
    }

    DependList.Buffer = (PWSTR)CmpValueToData(Hive,ListNode,&realsize);
    if( DependList.Buffer == NULL ) {
        //
        // HvGetCell inside CmpValueToData failed; bail out safely
        //
        return FALSE;
    }
    DependList.Length = DependList.MaximumLength = (USHORT)realsize - sizeof(WCHAR);

    //
    // Dependency list is now pointed to by DependList->Buffer.  We need
    // to sort the driver entry list.
    //

    return (CmpDoSort(DriverListHead, &DependList));

}

BOOLEAN
CmpDoSort(
    IN PLIST_ENTRY DriverListHead,
    IN PUNICODE_STRING OrderList
    )

/*++

Routine Description:

    Sorts the boot driver list based on the order list

    Start with the last entry in the group order list and work towards
    the beginning.  For each group entry, move all driver entries that
    are members of the group to the front of the list.  Driver entries
    with no groups, or with a group that does not match any in the
    group list will be shoved to the end of the list.

Arguments:

    DriverListHead - Supplies a pointer to the head of the list of
            boot drivers to be sorted.

    OrderList - Supplies pointer to the order list

Return Value:

    TRUE - List successfully ordered

    FALSE - List is inconsistent and could not be ordered.

--*/

{
    PWSTR Current;
    PWSTR End = NULL;
    PLIST_ENTRY Next;
    PBOOT_DRIVER_NODE CurrentNode;
    UNICODE_STRING CurrentGroup;


    Current = (PWSTR) ((PUCHAR)(OrderList->Buffer)+OrderList->Length);

    while (Current > OrderList->Buffer) {
        do {
            if (*Current == UNICODE_NULL) {
                End = Current;
            }
            --Current;
        } while ((*(Current-1) != UNICODE_NULL) &&
                 ( Current != OrderList->Buffer));

        ASSERT (End != NULL);
        //
        // Current now points to the beginning of the NULL-terminated
        // Unicode string.
        // End now points to the end of the string
        //
        CurrentGroup.Length = (USHORT) ((PCHAR)End - (PCHAR)Current);
        CurrentGroup.MaximumLength = CurrentGroup.Length;
        CurrentGroup.Buffer = Current;
        Next = DriverListHead->Flink;
        while (Next != DriverListHead) {
            CurrentNode = CONTAINING_RECORD(Next,
                                            BOOT_DRIVER_NODE,
                                            ListEntry.Link);
            Next = CurrentNode->ListEntry.Link.Flink;
            if (CurrentNode->Group.Buffer != NULL) {
                if (RtlEqualUnicodeString(&CurrentGroup, &CurrentNode->Group,TRUE)) {
                    RemoveEntryList(&CurrentNode->ListEntry.Link);
                    InsertHeadList(DriverListHead,
                                   &CurrentNode->ListEntry.Link);
                }
            }
        }
        --Current;

    }

    return(TRUE);

}


BOOLEAN
CmpResolveDriverDependencies(
    IN PLIST_ENTRY DriverListHead
    )

/*++

Routine Description:

    This routine orders driver nodes in a group based on their dependencies
    on one another.  It removes any drivers that have circular dependencies
    from the list.

Arguments:

    DriverListHead - Supplies a pointer to the head of the list of
            boot drivers to be sorted.

Return Value:

    TRUE - Dependencies successfully resolved

    FALSE - Corrupt hive.

--*/

{
    PLIST_ENTRY CurrentEntry;
    PBOOT_DRIVER_NODE GroupStart;
    PBOOT_DRIVER_NODE GroupEnd;
    PBOOT_DRIVER_NODE CurrentNode;

    CurrentEntry = DriverListHead->Flink;

    while (CurrentEntry != DriverListHead) {
        //
        // The list is already ordered by groups.  Find the first and
        // last entry in each group, and order each of these sub-lists
        // based on their dependencies.
        //

        GroupStart = CONTAINING_RECORD(CurrentEntry,
                                       BOOT_DRIVER_NODE,
                                       ListEntry.Link);
        do {
            GroupEnd = CONTAINING_RECORD(CurrentEntry,
                                         BOOT_DRIVER_NODE,
                                         ListEntry.Link);

            CurrentEntry = CurrentEntry->Flink;
            CurrentNode = CONTAINING_RECORD(CurrentEntry,
                                            BOOT_DRIVER_NODE,
                                            ListEntry.Link);

            if (CurrentEntry == DriverListHead) {
                break;
            }

            if (!RtlEqualUnicodeString(&GroupStart->Group,
                                       &CurrentNode->Group,
                                       TRUE)) {
                break;
            }

        } while ( CurrentEntry != DriverListHead );

        //
        // GroupStart now points to the first driver node in the group,
        // and GroupEnd points to the last driver node in the group.
        //
        CmpOrderGroup(GroupStart, GroupEnd);

    }
    return(TRUE);
}


BOOLEAN
CmpOrderGroup(
    IN PBOOT_DRIVER_NODE GroupStart,
    IN PBOOT_DRIVER_NODE GroupEnd
    )

/*++

Routine Description:

    Reorders the nodes in a driver group based on their tag values.

Arguments:

    GroupStart - Supplies the first node in the group.

    GroupEnd - Supplies the last node in the group.

Return Value:

    TRUE - Group successfully reordered

    FALSE - Circular dependencies detected.

--*/

{
    PBOOT_DRIVER_NODE Current;
    PBOOT_DRIVER_NODE Previous;
    PLIST_ENTRY ListEntry;

    if (GroupStart == GroupEnd) {
        return(TRUE);
    }

    Current = GroupStart;

    do {
        //
        // If the driver before the current one has a lower tag, then
        // we do not need to move it.  If not, then remove the driver
        // from the list and scan backwards until we find a driver with
        // a tag that is <= the current tag, or we reach the beginning
        // of the list.
        //
        Previous = Current;
        ListEntry = Current->ListEntry.Link.Flink;
        Current = CONTAINING_RECORD(ListEntry,
                                    BOOT_DRIVER_NODE,
                                    ListEntry.Link);

        if (Previous->Tag > Current->Tag) {
            //
            // Remove the Current driver from the list, and search
            // backwards until we find a tag that is <= the current
            // driver's tag.  Reinsert the current driver there.
            //
            if (Current == GroupEnd) {
                ListEntry = Current->ListEntry.Link.Blink;
                GroupEnd = CONTAINING_RECORD(ListEntry,
                                             BOOT_DRIVER_NODE,
                                             ListEntry.Link);
            }
            RemoveEntryList(&Current->ListEntry.Link);
            while ( (Previous->Tag > Current->Tag) &&
                    (Previous != GroupStart) ) {
                ListEntry = Previous->ListEntry.Link.Blink;
                Previous = CONTAINING_RECORD(ListEntry,
                                             BOOT_DRIVER_NODE,
                                             ListEntry.Link);
            }
            InsertTailList(&Previous->ListEntry.Link,
                           &Current->ListEntry.Link);
            if (Previous == GroupStart) {
                GroupStart = Current;
            }
        }

    } while ( Current != GroupEnd );

    return(TRUE);
}

BOOLEAN
CmpValidateSelect(
     IN PHHIVE SystemHive,
     IN HCELL_INDEX RootCell
     )
/*++

Routine Description:

    This routines parses the SYSTEM hive and "Select" node
    and verifies the following values:

    Current
    Default
    Failed
    LastKnownGood


    If any of these is missing the the loader will put the corrupt
    system hive message

    This routine is to be called by the loader just after it loads the
    system hive. It's purpose is to ensure a uniform and consistent way
    to treat missing values in this area.

Arguments:

    SystemHive - Supplies the hive control structure for the SYSTEM hive.

    RootCell - Supplies the HCELL_INDEX of the root cell of the hive.


Return Value:

    TRUE - all the values are here
    FALSE - some of them are missing

--*/
{
    HCELL_INDEX     Select;
    PCM_KEY_NODE    Node;
    UNICODE_STRING  Name;

    //
    // no mapped hives at this point. don't bother releasing cells
    //
    ASSERT( SystemHive->ReleaseCellRoutine == NULL );

    //
    // Find \SYSTEM\SELECT node.
    //
    Node = (PCM_KEY_NODE)HvGetCell(SystemHive,RootCell);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    RtlInitUnicodeString(&Name, L"select");
    Select = CmpFindSubKeyByName(SystemHive,
                                Node,
                                &Name);
    if (Select == HCELL_NIL) {
        return FALSE;
    }

    //
    // Find AutoSelect value
    //
    Node = (PCM_KEY_NODE)HvGetCell(SystemHive,Select);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }

    // search for current
    RtlInitUnicodeString(&Name, L"current");
    Select = CmpFindValueByName(SystemHive,
                                Node,
                                &Name);
    if (Select == HCELL_NIL) {
        return FALSE;
    }

    // search for default
    RtlInitUnicodeString(&Name, L"default");
    Select = CmpFindValueByName(SystemHive,
                                Node,
                                &Name);
    if (Select == HCELL_NIL) {
        return FALSE;
    }

    // search for failed
    RtlInitUnicodeString(&Name, L"failed");
    Select = CmpFindValueByName(SystemHive,
                                Node,
                                &Name);
    if (Select == HCELL_NIL) {
        return FALSE;
    }

    // search for LKG
    RtlInitUnicodeString(&Name, L"LastKnownGood");
    Select = CmpFindValueByName(SystemHive,
                                Node,
                                &Name);
    if (Select == HCELL_NIL) {
        return FALSE;
    }

    return TRUE;
}

HCELL_INDEX
CmpFindControlSet(
     IN PHHIVE SystemHive,
     IN HCELL_INDEX RootCell,
     IN PUNICODE_STRING SelectName,
     OUT PBOOLEAN AutoSelect
     )

/*++

Routine Description:

    This routines parses the SYSTEM hive and "Select" node
    to locate the control set to be used for booting.

    Note that this routines also updates the value of Current to reflect
    the control set that was just found.  This is what we want to do
    when this is called during boot.  During I/O initialization, this
    is irrelevant, since we're just changing it to what it already is.

Arguments:

    SystemHive - Supplies the hive control structure for the SYSTEM hive.

    RootCell - Supplies the HCELL_INDEX of the root cell of the hive.

    SelectName - Supplies the name of the Select value to be used in
            determining the control set.  This should be one of "Current"
            "Default" or "LastKnownGood"

    AutoSelect - Returns the value of the AutoSelect value under
            the Select node.

Return Value:

    != HCELL_NIL - Cell Index of the control set to be used for booting.
    == HCELL_NIL - Indicates the hive is corrupt or inconsistent

--*/

{
    HCELL_INDEX     Select;
    HCELL_INDEX     ValueCell;
    HCELL_INDEX     ControlSet;
    HCELL_INDEX     AutoSelectCell;
    NTSTATUS        Status;
    UNICODE_STRING  Name;
    ANSI_STRING     AnsiString;
    PCM_KEY_VALUE   Value;
    PULONG          ControlSetIndex;
    PULONG          CurrentControl;
    CHAR            AsciiBuffer[128];
    WCHAR           UnicodeBuffer[128];
    ULONG           realsize;
    PCM_KEY_NODE    Node;
    PBOOLEAN        TempBoolean;

    //
    // no mapped hives at this point. don't bother releasing cells
    //
    ASSERT( SystemHive->ReleaseCellRoutine == NULL );
    //
    // Find \SYSTEM\SELECT node.
    //
    Node = (PCM_KEY_NODE)HvGetCell(SystemHive,RootCell);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return HCELL_NIL;
    }
    RtlInitUnicodeString(&Name, L"select");
    Select = CmpFindSubKeyByName(SystemHive,
                                Node,
                                &Name);
    if (Select == HCELL_NIL) {
        return(HCELL_NIL);
    }

    //
    // Find AutoSelect value
    //
    Node = (PCM_KEY_NODE)HvGetCell(SystemHive,Select);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return HCELL_NIL;
    }
    RtlInitUnicodeString(&Name, L"AutoSelect");
    AutoSelectCell = CmpFindValueByName(SystemHive,
                                        Node,
                                        &Name);
    if (AutoSelectCell == HCELL_NIL) {
        //
        // It's not there, we don't care.  Set autoselect to TRUE
        //
        *AutoSelect = TRUE;
    } else {
        Value = (PCM_KEY_VALUE)HvGetCell(SystemHive, AutoSelectCell);
        if( Value == NULL ) {
            //
            // we couldn't map a view for the bin containing this cell
            //

            return HCELL_NIL;
        }

        TempBoolean = (PBOOLEAN)(CmpValueToData(SystemHive,Value,&realsize));
        if( TempBoolean == NULL ) {
            //
            // HvGetCell inside CmpValueToData failed; bail out safely
            //
            return HCELL_NIL;
        }

        *AutoSelect = *TempBoolean;
    }

    Node = (PCM_KEY_NODE)HvGetCell(SystemHive,Select);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return HCELL_NIL;
    }
    ValueCell = CmpFindValueByName(SystemHive,
                                   Node,
                                   SelectName);
    if (ValueCell == HCELL_NIL) {
        return(HCELL_NIL);
    }
    Value = (PCM_KEY_VALUE)HvGetCell(SystemHive, ValueCell);
    if( Value == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return HCELL_NIL;
    }
    if (Value->Type != REG_DWORD) {
        return(HCELL_NIL);
    }

    ControlSetIndex = (PULONG)CmpValueToData(SystemHive, Value,&realsize);
    if( ControlSetIndex == NULL ) {
        //
        // HvGetCell inside CmpValueToData failed; bail out safely
        //
        return HCELL_NIL;
    }

    //
    // Find appropriate control set
    //

    sprintf(AsciiBuffer, "ControlSet%03d", *ControlSetIndex);
    AnsiString.Length = AnsiString.MaximumLength = (USHORT) strlen(&(AsciiBuffer[0]));
    AnsiString.Buffer = AsciiBuffer;
    Name.MaximumLength = 128*sizeof(WCHAR);
    Name.Buffer = UnicodeBuffer;
    Status = RtlAnsiStringToUnicodeString(&Name,
                                          &AnsiString,
                                          FALSE);
    if (!NT_SUCCESS(Status)) {
        return(HCELL_NIL);
    }

    Node = (PCM_KEY_NODE)HvGetCell(SystemHive,RootCell);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return HCELL_NIL;
    }
    ControlSet = CmpFindSubKeyByName(SystemHive,
                                     Node,
                                     &Name);
    if (ControlSet == HCELL_NIL) {
        return(HCELL_NIL);
    }

    //
    // Control set was successfully found, so update the value in "Current"
    // to reflect the control set we are going to use.
    //
    Node = (PCM_KEY_NODE)HvGetCell(SystemHive,Select);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return HCELL_NIL;
    }
    RtlInitUnicodeString(&Name, L"Current");
    ValueCell = CmpFindValueByName(SystemHive,
                                   Node,
                                   &Name);
    if (ValueCell != HCELL_NIL) {
        Value = (PCM_KEY_VALUE)HvGetCell(SystemHive, ValueCell);
        if( Value == NULL ) {
            //
            // we couldn't map a view for the bin containing this cell
            //

            return HCELL_NIL;
        }
        if (Value->Type == REG_DWORD) {
            CurrentControl = (PULONG)CmpValueToData(SystemHive, Value,&realsize);
            if( CurrentControl == NULL ) {
                //
                // HvGetCell inside CmpValueToData failed; bail out safely
                //
                return HCELL_NIL;
            }
            *CurrentControl = *ControlSetIndex;
        }
    }
    return(ControlSet);

}


VOID
CmpSetCurrentProfile(
    IN PHHIVE Hive,
    IN HCELL_INDEX ControlSet,
    IN PCM_HARDWARE_PROFILE Profile
    )

/*++

Routine Description:

    Edits the in-memory copy of the registry to reflect the hardware
    profile that the system is booting from.

Arguments:

    Hive - Supplies a pointer to the hive control structure

    ControlSet - Supplies the HCELL_INDEX of the current control set.

    Profile - Supplies a pointer to the selected hardware profile

Return Value:

    None.

--*/

{
    HCELL_INDEX IDConfigDB;
    PCM_KEY_NODE IDConfigNode;
    HCELL_INDEX CurrentConfigCell;
    PCM_KEY_VALUE CurrentConfigValue;
    UNICODE_STRING Name;
    PULONG CurrentConfig;
    ULONG realsize;

    //
    // no mapped hives at this point. don't bother releasing cells
    //
    ASSERT( Hive->ReleaseCellRoutine == NULL );

    IDConfigDB = CmpFindProfileOption(Hive,
                                      ControlSet,
                                      NULL,
                                      NULL,
                                      NULL);
    if (IDConfigDB != HCELL_NIL) {
        IDConfigNode = (PCM_KEY_NODE)HvGetCell(Hive, IDConfigDB);
        if( IDConfigNode == NULL ) {
            //
            // we couldn't map a view for the bin containing this cell
            //
            return;
        }

        RtlInitUnicodeString(&Name, L"CurrentConfig");
        CurrentConfigCell = CmpFindValueByName(Hive,
                                               IDConfigNode,
                                               &Name);
        if (CurrentConfigCell != HCELL_NIL) {
            CurrentConfigValue = (PCM_KEY_VALUE)HvGetCell(Hive, CurrentConfigCell);
            if( CurrentConfigValue == NULL ) {
                //
                // we couldn't map a view for the bin containing this cell
                //
                return;
            }
            if (CurrentConfigValue->Type == REG_DWORD) {
                CurrentConfig = (PULONG)CmpValueToData(Hive,
                                                       CurrentConfigValue,
                                                       &realsize);
                if( CurrentConfig == NULL ) {
                    //
                    // HvGetCell inside CmpValueToData failed; bail out safely
                    //
                    return;
                }
                *CurrentConfig = Profile->Id;
            }
        }
    }


}


HCELL_INDEX
CmpFindProfileOption(
     IN PHHIVE SystemHive,
     IN HCELL_INDEX ControlSet,
     OUT OPTIONAL PCM_HARDWARE_PROFILE_LIST *ReturnedProfileList,
     OUT OPTIONAL PCM_HARDWARE_PROFILE_ALIAS_LIST *ReturnedAliasList,
     OUT OPTIONAL PULONG ProfileTimeout
     )

/*++

Routine Description:

    This routines parses the SYSTEM hive and locates the
    "CurrentControlSet\Control\IDConfigDB" node to determine the
    hardware profile configuration settings.

Arguments:

    SystemHive - Supplies the hive control structure for the SYSTEM hive.

    ControlSet - Supplies the HCELL_INDEX of the root cell of the hive.

    ProfileList - Returns the list of available hardware profiles sorted
                  by preference. Will be allocated by this routine if
                  NULL is passed in, or a pointer to a CM_HARDWARE_PROFILE_LIST
                  structure that is too small is passed in.

    ProfileTimeout - Returns the timeout value for the config menu.

Return Value:

    != HCELL_NIL - Cell Index of the IDConfigDB node.
    == HCELL_NIL - Indicates IDConfigDB does not exist

--*/
{
    HCELL_INDEX                     ControlCell;
    HCELL_INDEX                     IDConfigDB;
    HCELL_INDEX                     TimeoutCell;
    HCELL_INDEX                     ProfileCell;
    HCELL_INDEX                     AliasCell;
    HCELL_INDEX                     HWCell;
    PCM_KEY_NODE                    HWNode;
    PCM_KEY_NODE                    ProfileNode;
    PCM_KEY_NODE                    AliasNode;
    PCM_KEY_NODE                    ConfigDBNode;
    PCM_KEY_NODE                    Control;
    PCM_KEY_VALUE                   TimeoutValue;
    UNICODE_STRING                  Name;
    ULONG                           realsize;
    PCM_HARDWARE_PROFILE_LIST       ProfileList;
    PCM_HARDWARE_PROFILE_ALIAS_LIST AliasList;
    ULONG                           ProfileCount;
    ULONG                           AliasCount;
    ULONG                           i,j;
    WCHAR                           NameBuf[20];
    PCM_KEY_NODE                    Node;
    PULONG                          TempULong;

    //
    // no mapped hives at this point. don't bother releasing cells
    //
    ASSERT( SystemHive->ReleaseCellRoutine == NULL );

    //
    // Find Control node
    //
    Node = (PCM_KEY_NODE)HvGetCell(SystemHive,ControlSet);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return HCELL_NIL;
    }
    RtlInitUnicodeString(&Name, L"Control");
    ControlCell = CmpFindSubKeyByName(SystemHive,
                                      Node,
                                      &Name);
    if (ControlCell == HCELL_NIL) {
        return(HCELL_NIL);
    }
    Control = (PCM_KEY_NODE)HvGetCell(SystemHive, ControlCell);
    if( Control == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return HCELL_NIL;
    }

    //
    // Find IDConfigDB node
    //
    RtlInitUnicodeString(&Name, L"IDConfigDB");
    IDConfigDB = CmpFindSubKeyByName(SystemHive,
                                     Control,
                                     &Name);
    if (IDConfigDB == HCELL_NIL) {
        return(HCELL_NIL);
    }
    ConfigDBNode = (PCM_KEY_NODE)HvGetCell(SystemHive, IDConfigDB);
    if( ConfigDBNode == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return HCELL_NIL;
    }

    if (ARGUMENT_PRESENT(ProfileTimeout)) {
        //
        // Find UserWaitInterval value. This is the timeout
        //
        RtlInitUnicodeString(&Name, L"UserWaitInterval");
        TimeoutCell = CmpFindValueByName(SystemHive,
                                         ConfigDBNode,
                                         &Name);
        if (TimeoutCell == HCELL_NIL) {
            *ProfileTimeout = 0;
        } else {
            TimeoutValue = (PCM_KEY_VALUE)HvGetCell(SystemHive, TimeoutCell);
            if( TimeoutValue == NULL ) {
                //
                // we couldn't map a view for the bin containing this cell
                //

                return HCELL_NIL;
            }
            if (TimeoutValue->Type != REG_DWORD) {
                *ProfileTimeout = 0;
            } else {
                TempULong = (PULONG)CmpValueToData(SystemHive, TimeoutValue, &realsize);
                if( TempULong == NULL ) {
                    //
                    // HvGetCell inside CmpValueToData failed; bail out safely
                    //
                    return HCELL_NIL;
                }
                *ProfileTimeout = *TempULong;
            }
        }
    }

    if (ARGUMENT_PRESENT(ReturnedProfileList)) {
        ProfileList = *ReturnedProfileList;
        //
        // Enumerate the keys under IDConfigDB\Hardware Profiles
        // and build the list of available hardware profiles.  The list
        // is built sorted by PreferenceOrder.  Therefore, when the
        // list is complete, the default hardware profile is at the
        // head of the list.
        //
        RtlInitUnicodeString(&Name, L"Hardware Profiles");
        ProfileCell = CmpFindSubKeyByName(SystemHive,
                                          ConfigDBNode,
                                          &Name);
        if (ProfileCell == HCELL_NIL) {
            ProfileCount = 0;
            if (ProfileList != NULL) {
                ProfileList->CurrentProfileCount = 0;
            }
        } else {
            ProfileNode = (PCM_KEY_NODE)HvGetCell(SystemHive, ProfileCell);
            if( ProfileNode == NULL ) {
                //
                // we couldn't map a view for the bin containing this cell
                //

                return HCELL_NIL;
            }
            ProfileCount = ProfileNode->SubKeyCounts[Stable];
            if ((ProfileList == NULL) || (ProfileList->MaxProfileCount < ProfileCount)) {
                //
                // Allocate a larger ProfileList
                //
                ProfileList = (SystemHive->Allocate)(sizeof(CM_HARDWARE_PROFILE_LIST)
                                                     + (ProfileCount-1) * sizeof(CM_HARDWARE_PROFILE),
                                                     FALSE
                                                     ,CM_FIND_LEAK_TAG5);
                if (ProfileList == NULL) {
                    return(HCELL_NIL);
                }
                ProfileList->MaxProfileCount = ProfileCount;
            }
            ProfileList->CurrentProfileCount = 0;

            //
            // Enumerate the keys and fill in the profile list.
            //
            for (i=0; i<ProfileCount; i++) {
                CM_HARDWARE_PROFILE TempProfile;
                HCELL_INDEX ValueCell;
                PCM_KEY_VALUE ValueNode;
                UNICODE_STRING KeyName;

                HWCell = CmpFindSubKeyByNumber(SystemHive, ProfileNode, i);
                if (HWCell == HCELL_NIL) {
                    //
                    // This should never happen.
                    //
                    ProfileList->CurrentProfileCount = i;
                    break;
                }
                HWNode = (PCM_KEY_NODE)HvGetCell(SystemHive, HWCell);
                if( HWNode == NULL ) {
                    //
                    // we couldn't map a view for the bin containing this cell
                    //

                    return HCELL_NIL;
                }
                if (HWNode->Flags & KEY_COMP_NAME) {
                    KeyName.Length = CmpCompressedNameSize(HWNode->Name,
                                                           HWNode->NameLength);
                    KeyName.MaximumLength = sizeof(NameBuf);
                    if (KeyName.MaximumLength < KeyName.Length) {
                        KeyName.Length = KeyName.MaximumLength;
                    }
                    KeyName.Buffer = NameBuf;
                    CmpCopyCompressedName(KeyName.Buffer,
                                          KeyName.Length,
                                          HWNode->Name,
                                          HWNode->NameLength);
                } else {
                    KeyName.Length = KeyName.MaximumLength = HWNode->NameLength;
                    KeyName.Buffer = HWNode->Name;
                }

                //
                // Fill in the temporary profile structure with this
                // profile's data.
                //
                RtlUnicodeStringToInteger(&KeyName, 0, &TempProfile.Id);
                RtlInitUnicodeString(&Name, CM_HARDWARE_PROFILE_STR_PREFERENCE_ORDER);
                ValueCell = CmpFindValueByName(SystemHive,
                                               HWNode,
                                               &Name);
                if (ValueCell == HCELL_NIL) {
                    TempProfile.PreferenceOrder = (ULONG)-1;
                } else {
                    ValueNode = (PCM_KEY_VALUE)HvGetCell(SystemHive, ValueCell);
                    if( ValueNode == NULL ) {
                        //
                        // we couldn't map a view for the bin containing this cell
                        //

                        return HCELL_NIL;
                    }

                    TempULong = (PULONG)CmpValueToData(SystemHive,
                                                      ValueNode,
                                                      &realsize);
                    if( TempULong == NULL ) {
                        //
                        // HvGetCell inside CmpValueToData failed; bail out safely
                        //
                        return HCELL_NIL;
                    }
                    TempProfile.PreferenceOrder = *TempULong;
                }
                RtlInitUnicodeString(&Name, CM_HARDWARE_PROFILE_STR_FRIENDLY_NAME);
                ValueCell = CmpFindValueByName(SystemHive,
                                               HWNode,
                                               &Name);
                if (ValueCell == HCELL_NIL) {
                    TempProfile.FriendlyName = L"-------";
                    TempProfile.NameLength = (ULONG)(wcslen(TempProfile.FriendlyName) * sizeof(WCHAR));
                } else {
                    ValueNode = (PCM_KEY_VALUE)HvGetCell(SystemHive, ValueCell);
                    if( ValueNode == NULL ) {
                        //
                        // we couldn't map a view for the bin containing this cell
                        //

                        return HCELL_NIL;
                    }
                    TempProfile.FriendlyName = (PWSTR)CmpValueToData(SystemHive,
                                                                     ValueNode,
                                                                     &realsize);
                    if( TempProfile.FriendlyName == NULL ) {
                        //
                        // HvGetCell inside CmpValueToData failed; bail out safely
                        //
                        return HCELL_NIL;
                    }
                    TempProfile.NameLength = realsize - sizeof(WCHAR);
                }

                TempProfile.Flags = 0;

                RtlInitUnicodeString(&Name, CM_HARDWARE_PROFILE_STR_ALIASABLE);
                ValueCell = CmpFindValueByName(SystemHive,
                                               HWNode,
                                               &Name);
                if (ValueCell == HCELL_NIL) {
                    TempProfile.Flags = CM_HP_FLAGS_ALIASABLE;
                } else {
                    ValueNode = (PCM_KEY_VALUE)HvGetCell(SystemHive, ValueCell);
                    if( ValueNode == NULL ) {
                        //
                        // we couldn't map a view for the bin containing this cell
                        //

                        return HCELL_NIL;
                    }

                    TempULong = (PULONG)CmpValueToData (SystemHive,ValueNode,&realsize);
                    if( TempULong == NULL ) {
                        //
                        // HvGetCell inside CmpValueToData failed; bail out safely
                        //
                        return HCELL_NIL;
                    }
                    if (*TempULong) {
                        TempProfile.Flags = CM_HP_FLAGS_ALIASABLE;
                        // NO other flags set.
                    }
                }

                RtlInitUnicodeString(&Name, CM_HARDWARE_PROFILE_STR_PRISTINE);
                ValueCell = CmpFindValueByName(SystemHive,
                                               HWNode,
                                               &Name);
                if (ValueCell != HCELL_NIL) {

                    ValueNode = (PCM_KEY_VALUE)HvGetCell(SystemHive, ValueCell);
                    if( ValueNode == NULL ) {
                        //
                        // we couldn't map a view for the bin containing this cell
                        //

                        return HCELL_NIL;
                    }

                    TempULong = (PULONG)CmpValueToData (SystemHive,ValueNode,&realsize);
                    if( TempULong == NULL ) {
                        //
                        // HvGetCell inside CmpValueToData failed; bail out safely
                        //
                        return HCELL_NIL;
                    }
                    if (*TempULong) {
                        TempProfile.Flags = CM_HP_FLAGS_PRISTINE;
                        // NO other flags set.
                    }
                }

                //
                // If we see a profile with the ID of zero (AKA an illegal)
                // ID for a hardware profile to possess, then we know that this
                // must be a pristine profile.
                //
                if (0 == TempProfile.Id) {
                    TempProfile.Flags = CM_HP_FLAGS_PRISTINE;
                    // NO other flags set.

                    TempProfile.PreferenceOrder = (ULONG)-1; // move to the end of the list.
                }


                //
                // Insert this new profile into the appropriate spot in the
                // profile array. Entries are sorted by preference order.
                //
                for (j=0; j<ProfileList->CurrentProfileCount; j++) {
                    if (ProfileList->Profile[j].PreferenceOrder >= TempProfile.PreferenceOrder) {
                        //
                        // Insert at position j.
                        //
                        RtlMoveMemory(&ProfileList->Profile[j+1],
                                      &ProfileList->Profile[j],
                                      sizeof(CM_HARDWARE_PROFILE)*(ProfileList->MaxProfileCount-j-1));
                        break;
                    }
                }
                ProfileList->Profile[j] = TempProfile;
                ++ProfileList->CurrentProfileCount;
            }
        }
        *ReturnedProfileList = ProfileList;
    }

    if (ARGUMENT_PRESENT(ReturnedAliasList)) {
        AliasList = *ReturnedAliasList;
        //
        // Enumerate the keys under IDConfigDB\Alias
        // and build the list of available hardware profiles aliases.
        // So that if we know our docking state we can find it in the alias
        // table.
        //
        RtlInitUnicodeString(&Name, L"Alias");
        AliasCell = CmpFindSubKeyByName(SystemHive,
                                        ConfigDBNode,
                                        &Name);
        if (AliasCell == HCELL_NIL) {
            AliasCount = 0;
            if (AliasList != NULL) {
                AliasList->CurrentAliasCount = 0;
            }
        } else {
            AliasNode = (PCM_KEY_NODE)HvGetCell(SystemHive, AliasCell);
            if( AliasNode == NULL ) {
                //
                // we couldn't map a view for the bin containing this cell
                //

                return HCELL_NIL;
            }
            AliasCount = AliasNode->SubKeyCounts[Stable];
            if ((AliasList == NULL) || (AliasList->MaxAliasCount < AliasCount)) {
                //
                // Allocate a larger AliasList
                //
                AliasList = (SystemHive->Allocate)(sizeof(CM_HARDWARE_PROFILE_LIST)
                                                   + (AliasCount-1) * sizeof(CM_HARDWARE_PROFILE),
                                                   FALSE
                                                   ,CM_FIND_LEAK_TAG6);
                if (AliasList == NULL) {
                    return(HCELL_NIL);
                }
                AliasList->MaxAliasCount = AliasCount;
            }
            AliasList->CurrentAliasCount = 0;

            //
            // Enumerate the keys and fill in the profile list.
            //
            for (i=0; i<AliasCount; i++) {
#define TempAlias AliasList->Alias[i]
                HCELL_INDEX ValueCell;
                PCM_KEY_VALUE ValueNode;
                UNICODE_STRING KeyName;

                HWCell = CmpFindSubKeyByNumber(SystemHive, AliasNode, i);
                if (HWCell == HCELL_NIL) {
                    //
                    // This should never happen.
                    //
                    AliasList->CurrentAliasCount = i;
                    break;
                }
                HWNode = (PCM_KEY_NODE)HvGetCell(SystemHive, HWCell);
                if( HWNode == NULL ) {
                    //
                    // we couldn't map a view for the bin containing this cell
                    //

                    return HCELL_NIL;
                }
                if (HWNode->Flags & KEY_COMP_NAME) {
                    KeyName.Length = CmpCompressedNameSize(HWNode->Name,
                                                           HWNode->NameLength);
                    KeyName.MaximumLength = sizeof(NameBuf);
                    if (KeyName.MaximumLength < KeyName.Length) {
                        KeyName.Length = KeyName.MaximumLength;
                    }
                    KeyName.Buffer = NameBuf;
                    CmpCopyCompressedName(KeyName.Buffer,
                                          KeyName.Length,
                                          HWNode->Name,
                                          HWNode->NameLength);
                } else {
                    KeyName.Length = KeyName.MaximumLength = HWNode->NameLength;
                    KeyName.Buffer = HWNode->Name;
                }

                //
                // Fill in the temporary profile structure with this
                // profile's data.
                //
                RtlInitUnicodeString(&Name, L"ProfileNumber");
                ValueCell = CmpFindValueByName(SystemHive,
                                               HWNode,
                                               &Name);
                if (ValueCell == HCELL_NIL) {
                    TempAlias.ProfileNumber = 0;
                } else {
                    ValueNode = (PCM_KEY_VALUE)HvGetCell(SystemHive, ValueCell);
                    if( ValueNode == NULL ) {
                        //
                        // we couldn't map a view for the bin containing this cell
                        //

                        return HCELL_NIL;
                    }

                    TempULong = (PULONG)CmpValueToData(SystemHive,ValueNode,&realsize);
                    if( TempULong == NULL ) {
                        //
                        // HvGetCell inside CmpValueToData failed; bail out safely
                        //
                        return HCELL_NIL;
                    }
                    TempAlias.ProfileNumber = *TempULong;
                }
                RtlInitUnicodeString(&Name, L"DockState");
                ValueCell = CmpFindValueByName(SystemHive,
                                               HWNode,
                                               &Name);
                if (ValueCell == HCELL_NIL) {
                    TempAlias.DockState = 0;
                } else {
                    ValueNode = (PCM_KEY_VALUE)HvGetCell(SystemHive, ValueCell);
                    if( ValueNode == NULL ) {
                        //
                        // we couldn't map a view for the bin containing this cell
                        //

                        return HCELL_NIL;
                    }

                    TempULong = (PULONG)CmpValueToData(SystemHive,ValueNode,&realsize);
                    if( TempULong == NULL ) {
                        //
                        // HvGetCell inside CmpValueToData failed; bail out safely
                        //
                        return HCELL_NIL;
                    }
                    TempAlias.DockState = *TempULong;
                }
                RtlInitUnicodeString(&Name, L"DockID");
                ValueCell = CmpFindValueByName(SystemHive,
                                               HWNode,
                                               &Name);
                if (ValueCell == HCELL_NIL) {
                    TempAlias.DockID = 0;
                } else {
                    ValueNode = (PCM_KEY_VALUE)HvGetCell(SystemHive, ValueCell);
                    if( ValueNode == NULL ) {
                        //
                        // we couldn't map a view for the bin containing this cell
                        //

                        return HCELL_NIL;
                    }

                    TempULong = (PULONG)CmpValueToData(SystemHive,ValueNode,&realsize);
                    if( TempULong == NULL ) {
                        //
                        // HvGetCell inside CmpValueToData failed; bail out safely
                        //
                        return HCELL_NIL;
                    }
                    TempAlias.DockID = *TempULong;
                }
                RtlInitUnicodeString(&Name, L"SerialNumber");
                ValueCell = CmpFindValueByName(SystemHive,
                                               HWNode,
                                               &Name);
                if (ValueCell == HCELL_NIL) {
                    TempAlias.SerialNumber = 0;
                } else {
                    ValueNode = (PCM_KEY_VALUE)HvGetCell(SystemHive, ValueCell);
                    if( ValueNode == NULL ) {
                        //
                        // we couldn't map a view for the bin containing this cell
                        //

                        return HCELL_NIL;
                    }

                    TempULong = (PULONG)CmpValueToData(SystemHive,ValueNode,&realsize);
                    if( TempULong == NULL ) {
                        //
                        // HvGetCell inside CmpValueToData failed; bail out safely
                        //
                        return HCELL_NIL;
                    }
                    TempAlias.SerialNumber = *TempULong;
                }

                ++AliasList->CurrentAliasCount;
            }
        }
        *ReturnedAliasList = AliasList;
    }

    return(IDConfigDB);
}


ULONG
CmpFindTagIndex(
    IN PHHIVE Hive,
    IN HCELL_INDEX TagCell,
    IN HCELL_INDEX GroupOrderCell,
    IN PUNICODE_STRING GroupName
    )

/*++

Routine Description:

    Calculates the tag index for a driver based on its tag value and
    the GroupOrderList entry for its group.

Arguments:

    Hive - Supplies the hive control structure for the driver.

    TagCell - Supplies the cell index of the driver's tag value cell.

    GroupOrderCell - Supplies the cell index for the control set's
            GroupOrderList:

            \Registry\Machine\System\CurrentControlSet\Control\GroupOrderList

    GroupName - Supplies the name of the group the driver belongs to.
            Note that if a driver's group does not have an entry under
            GroupOrderList, its tags will be ignored.  Also note that if
            a driver belongs to no group (GroupName is NULL) its tags will
            be ignored.

Return Value:

    The index that the driver should be sorted by.

--*/

{
    PCM_KEY_VALUE TagValue;
    PCM_KEY_VALUE DriverTagValue;
    HCELL_INDEX OrderCell;
    PULONG OrderVector;
    PULONG DriverTag;
    ULONG CurrentTag;
    ULONG realsize;
    PCM_KEY_NODE Node;
    BOOLEAN     BufferAllocated;

    //
    // no mapped hives at this point. don't bother releasing cells
    //
    ASSERT( Hive->ReleaseCellRoutine == NULL );

    DriverTagValue = (PCM_KEY_VALUE)HvGetCell(Hive, TagCell);
    if( DriverTagValue == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return LOAD_NEXT_TO_LAST;
    }

    DriverTag = (PULONG)CmpValueToData(Hive, DriverTagValue, &realsize);
    if( DriverTag == NULL ) {
        //
        // HvGetCell inside CmpValueToData failed; bail out safely
        //
        return LOAD_NEXT_TO_LAST;
    }

    Node = (PCM_KEY_NODE)HvGetCell(Hive,GroupOrderCell);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return LOAD_NEXT_TO_LAST;
    }
    OrderCell = CmpFindValueByName(Hive,
                                   Node,
                                   GroupName);
    if (OrderCell == HCELL_NIL) {
        return(LOAD_NEXT_TO_LAST);
    }

    TagValue = (PCM_KEY_VALUE)HvGetCell(Hive, OrderCell);
    if( TagValue == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return LOAD_NEXT_TO_LAST;
    }
    CmpGetValueData(Hive,TagValue,&realsize,&OrderVector,&BufferAllocated,&OrderCell);

    if( OrderVector == NULL ) {
        //
        // HvGetCell inside CmpValueToData failed; bail out safely
        //
        return LOAD_NEXT_TO_LAST;
    }

    for (CurrentTag=1; CurrentTag <= OrderVector[0]; CurrentTag++) {
        if (OrderVector[CurrentTag] == *DriverTag) {
            //
            // We have found a matching tag in the OrderVector, so return
            // its index.
            //
            if( BufferAllocated ) {
                ExFreePool( OrderVector );
            }
            return(CurrentTag);
        }
    }

    if( BufferAllocated ) {
        ExFreePool( OrderVector );
    }
    //
    // There was no matching tag in the OrderVector.
    //
    return(LOAD_NEXT_TO_LAST);

}

#ifdef _WANT_MACHINE_IDENTIFICATION

BOOLEAN
CmpGetBiosDateFromRegistry(
    IN PHHIVE Hive,
    IN HCELL_INDEX ControlSet,
    OUT PUNICODE_STRING Date
    )

/*++

Routine Description:

    Reads and returns the BIOS date from the registry.

Arguments:

    Hive - Supplies the hive control structure for the driver.

    ControlSet - Supplies the HCELL_INDEX of the root cell of the hive.

    Date - Receives the date string in the format "mm/dd/yy".

Return Value:

 	TRUE iff successful, else FALSE.
 	
--*/

{
    UNICODE_STRING  name;
    HCELL_INDEX     control;
    HCELL_INDEX     biosInfo;
    HCELL_INDEX     valueCell;
    PCM_KEY_VALUE   value;
    ULONG           realSize;
    PCM_KEY_NODE    Node;
    //
    // no mapped hives at this point. don't bother releasing cells
    //
    ASSERT( Hive->ReleaseCellRoutine == NULL );

    //
    // Find CONTROL node
    //
    Node = (PCM_KEY_NODE)HvGetCell(Hive, ControlSet);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    RtlInitUnicodeString(&name, L"Control");
    control = CmpFindSubKeyByName(  Hive,
                                    Node,
                                    &name);
    if (control == HCELL_NIL) {

        return(FALSE);
    }

    //
    // Find BIOSINFO node
    //
    Node = (PCM_KEY_NODE)HvGetCell(Hive, control);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    RtlInitUnicodeString(&name, L"BIOSINFO");
    biosInfo = CmpFindSubKeyByName( Hive,
                                    Node,
                                    &name);
    if (biosInfo == HCELL_NIL) {

        return(FALSE);
    }

    //
    // Find SystemBiosDate value
    //
    Node = (PCM_KEY_NODE)HvGetCell(Hive, biosInfo);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    RtlInitUnicodeString(&name, L"SystemBiosDate");
    valueCell = CmpFindValueByName( Hive,
                                    Node,
                                    &name);
    if (valueCell == HCELL_NIL) {

        return(FALSE);
    }

    value = (PCM_KEY_VALUE)HvGetCell(Hive, valueCell);
    if( value == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    Date->Buffer = (PWSTR)CmpValueToData(Hive, value, &realSize);
    if( Date->Buffer == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    Date->MaximumLength=(USHORT)realSize;
    Date->Length = 0;
    while ( (Date->Length < Date->MaximumLength) &&
            (Date->Buffer[Date->Length/sizeof(WCHAR)] != UNICODE_NULL)) {

        Date->Length += sizeof(WCHAR);
    }

    return (TRUE);
}

BOOLEAN
CmpGetBiosinfoFileNameFromRegistry(
    IN PHHIVE Hive,
    IN HCELL_INDEX ControlSet,
    OUT PUNICODE_STRING InfName
    )
{
    UNICODE_STRING  name;
    HCELL_INDEX     control;
    HCELL_INDEX     biosInfo;
    HCELL_INDEX     valueCell;
    PCM_KEY_VALUE   value;
    ULONG           realSize;
    PCM_KEY_NODE    Node;

    //
    // no mapped hives at this point. don't bother releasing cells
    //
    ASSERT( Hive->ReleaseCellRoutine == NULL );
    //
    // Find CONTROL node
    //
    Node = (PCM_KEY_NODE)HvGetCell(Hive, ControlSet);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    RtlInitUnicodeString(&name, L"Control");
    control = CmpFindSubKeyByName(  Hive,
                                    Node,
                                    &name);
    if (control == HCELL_NIL) {

        return(FALSE);
    }

    //
    // Find BIOSINFO node
    //
    Node = (PCM_KEY_NODE)HvGetCell(Hive, control);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    RtlInitUnicodeString(&name, L"BIOSINFO");
    biosInfo = CmpFindSubKeyByName( Hive,
                                    Node,
                                    &name);
    if (biosInfo == HCELL_NIL) {

        return(FALSE);
    }

    //
    // Find InfName value
    //
    Node = (PCM_KEY_NODE)HvGetCell(Hive, biosInfo);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    RtlInitUnicodeString(&name, L"InfName");
    valueCell = CmpFindValueByName( Hive,
                                    Node,
                                    &name);
    if (valueCell == HCELL_NIL) {

        return(FALSE);
    }

    value = (PCM_KEY_VALUE)HvGetCell(Hive, valueCell);
    if( value == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    InfName->Buffer = (PWSTR)CmpValueToData(Hive, value, &realSize);
    if( InfName->Buffer == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        return FALSE;
    }
    InfName->MaximumLength=(USHORT)realSize;
    InfName->Length = 0;
    while ( (InfName->Length < InfName->MaximumLength) &&
            (InfName->Buffer[InfName->Length/sizeof(WCHAR)] != UNICODE_NULL)) {

        InfName->Length += sizeof(WCHAR);
    }

    return (TRUE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\config\cmapi.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    cmapi.c

Abstract:

    This module contains CM level entry points for the registry.

--*/

#include "cmp.h"

extern  BOOLEAN     CmpNoWrite;

extern  BOOLEAN CmpProfileLoaded;
extern  BOOLEAN CmpWasSetupBoot;

extern  UNICODE_STRING CmSymbolicLinkValueName;

extern HIVE_LIST_ENTRY CmpMachineHiveList[];

VOID
CmpDereferenceNameControlBlockWithLock(
    PCM_NAME_CONTROL_BLOCK   Ncb
    );

//
// procedures private to this file
//
NTSTATUS
CmpSetValueKeyExisting(
    IN PHHIVE  Hive,
    IN HCELL_INDEX OldChild,
    IN PCM_KEY_VALUE Value,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize,
    IN ULONG StorageType,
    IN ULONG TempData
    );


NTSTATUS
CmpSetValueKeyNew(
    IN PHHIVE  Hive,
    IN PCM_KEY_NODE Parent,
    IN PUNICODE_STRING ValueName,
    IN ULONG Index,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize,
    IN ULONG StorageType,
    IN ULONG TempData
    );

VOID
CmpRemoveKeyHash(
    IN PCM_KEY_HASH KeyHash
    );

PCM_KEY_CONTROL_BLOCK
CmpInsertKeyHash(
    IN PCM_KEY_HASH KeyHash,
    IN BOOLEAN      FakeKey
    );

#if DBG
ULONG
CmpUnloadKeyWorker(
    PCM_KEY_CONTROL_BLOCK Current,
    PVOID                 Context1,
    PVOID                 Context2
    );
#endif

ULONG
CmpCompressKeyWorker(
    PCM_KEY_CONTROL_BLOCK Current,
    PVOID                 Context1,
    PVOID                 Context2
    );

NTSTATUS
CmpDuplicateKey(
    PHHIVE          Hive,
    HCELL_INDEX     OldKeyCell,
    PHCELL_INDEX    NewKeyCell
    );


VOID
CmpDestroyTemporaryHive(
    PCMHIVE CmHive
    );

VALUE_SEARCH_RETURN_TYPE
CmpCompareNewValueDataAgainstKCBCache(  PCM_KEY_CONTROL_BLOCK KeyControlBlock,
                                        PUNICODE_STRING ValueName,
                                        ULONG Type,
                                        PVOID Data,
                                        ULONG DataSize
                                        );

BOOLEAN
CmpIsHiveAlreadyLoaded( IN HANDLE KeyHandle,
                        IN POBJECT_ATTRIBUTES SourceFile,
                        OUT PCMHIVE *CmHive
                        );

BOOLEAN
CmpDoFlushNextHive(
    BOOLEAN     ForceFlush,
    PBOOLEAN    PostWarning,
    PULONG      DirtyCount
    );

BOOLEAN
CmpGetHiveName(
    PCMHIVE         CmHive,
    PUNICODE_STRING HiveName
    );

VOID
CmpDoQueueLateUnloadWorker(IN PCMHIVE CmHive);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CmDeleteValueKey)
#pragma alloc_text(PAGE,CmEnumerateKey)
#pragma alloc_text(PAGE,CmEnumerateValueKey)
#pragma alloc_text(PAGE,CmFlushKey)
#pragma alloc_text(PAGE,CmQueryKey)
#pragma alloc_text(PAGE,CmQueryValueKey)
#pragma alloc_text(PAGE,CmQueryMultipleValueKey)
#pragma alloc_text(PAGE,CmSetValueKey)
#pragma alloc_text(PAGE,CmpSetValueKeyExisting)
#pragma alloc_text(PAGE,CmpSetValueKeyNew)
#pragma alloc_text(PAGE,CmSetLastWriteTimeKey)
#pragma alloc_text(PAGE,CmSetKeyUserFlags)
#pragma alloc_text(PAGE,CmLoadKey)
#pragma alloc_text(PAGE,CmUnloadKey)
#pragma alloc_text(PAGE,CmUnloadKeyEx)
#pragma alloc_text(PAGE,CmpDoFlushAll)
#pragma alloc_text(PAGE,CmpDoFlushNextHive)
#pragma alloc_text(PAGE,CmReplaceKey)
#pragma alloc_text(PAGE,CmRenameKey)
#pragma alloc_text(PAGE,CmLockKcbForWrite)

#if DBG
#pragma alloc_text(PAGE,CmpUnloadKeyWorker)
#endif

#pragma alloc_text(PAGE,CmMoveKey)
#pragma alloc_text(PAGE,CmpDuplicateKey)
#pragma alloc_text(PAGE,CmCompressKey)
#pragma alloc_text(PAGE,CmpCompressKeyWorker)
#pragma alloc_text(PAGE,CmpCompareNewValueDataAgainstKCBCache)
#pragma alloc_text(PAGE,CmpIsHiveAlreadyLoaded)
#endif

NTSTATUS
CmDeleteValueKey(
    IN PCM_KEY_CONTROL_BLOCK    KeyControlBlock,
    IN UNICODE_STRING           ValueName         // RAW
    )
/*++

Routine Description:

    One of the value entries of a registry key may be removed with this call.

    The value entry with ValueName matching ValueName is removed from the key.
    If no such entry exists, an error is returned.

Arguments:

    KeyControlBlock - pointer to kcb for key to operate on

    ValueName - The name of the value to be deleted.  NULL is a legal name.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status;
    PCM_KEY_NODE    pcell = NULL;
    PCHILD_LIST     plist;
    PCM_KEY_VALUE   Value = NULL;
    ULONG           targetindex;
    HCELL_INDEX     ChildCell;
    PHHIVE          Hive;
    HCELL_INDEX     Cell;
    LARGE_INTEGER   systemtime;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_CM,"CmDeleteValueKey\n"));

    status = STATUS_OBJECT_NAME_NOT_FOUND;

    ChildCell = HCELL_NIL;

    CmpLockRegistry();
    //
    // serialize access to this key.
    //
    CmpLockKCBExclusive(KeyControlBlock);

    PERFINFO_REG_DELETE_VALUE(KeyControlBlock, &ValueName);

    //
    // no edits, not even this one, on keys marked for deletion
    //
    if (KeyControlBlock->Delete) {
        CmpUnlockKCB(KeyControlBlock);
        CmpUnlockRegistry();

        // Mark the hive as read only
        CmpMarkAllBinsReadOnly(Hive);

        return STATUS_KEY_DELETED;
    }

    Hive = KeyControlBlock->KeyHive;
    Cell = KeyControlBlock->KeyCell;

    // 
    // no flush from this point on
    //
    CmpLockHiveFlusherShared((PCMHIVE)Hive);
    try {

        pcell = (PCM_KEY_NODE)HvGetCell(Hive, Cell);
        if( pcell == NULL ) {
            //
            // we couldn't map a view for the bin containing this cell
            //
            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

        // Mark the hive as read only
        CmpMarkAllBinsReadOnly(Hive);

        plist = &(pcell->ValueList);

        if (plist->Count != 0) {

            //
            // The parent has at least one value, map in the list of
            // values and call CmpFindChildInList
            //

            //
            // plist -> the CHILD_LIST structure
            // pchild -> the child node structure being examined
            //

            if( CmpFindNameInList(Hive,
                                  plist,
                                  &ValueName,
                                  &targetindex,
                                  &ChildCell) == FALSE ) {
            
                    // Mark the hive as read only
                    CmpMarkAllBinsReadOnly(Hive);

                    status = STATUS_INSUFFICIENT_RESOURCES;
                    leave;
            }

            if (ChildCell != HCELL_NIL) {

                //
                // 1. the desired target was found
                // 2. ChildCell is it's HCELL_INDEX
                // 3. targetaddress points to it
                // 4. targetindex is it's index
                //

                //
                // attempt to mark all relevant cells dirty
                //
                if (!(HvMarkCellDirty(Hive, Cell, FALSE) &&
                      HvMarkCellDirty(Hive, pcell->ValueList.List, FALSE) &&
                      HvMarkCellDirty(Hive, ChildCell, FALSE)))

                {
                    // Mark the hive as read only
                    CmpMarkAllBinsReadOnly(Hive);

                    status = STATUS_NO_LOG_SPACE;
                    leave;
                }

                Value = (PCM_KEY_VALUE)HvGetCell(Hive,ChildCell);
                if( Value == NULL ) {
                    //
                    // could not map view inside
                    // this is impossible as we just dirtied the view
                    //
                    ASSERT( FALSE );
                    // Mark the hive as read only
                    CmpMarkAllBinsReadOnly(Hive);

                    status = STATUS_INSUFFICIENT_RESOURCES;
                    leave;
                }
                if( !CmpMarkValueDataDirty(Hive,Value) ) {
                    // Mark the hive as read only
                    CmpMarkAllBinsReadOnly(Hive);

                    status = STATUS_NO_LOG_SPACE;
                    leave;
                }

                // sanity
                ASSERT_CELL_DIRTY(Hive,pcell->ValueList.List);
                ASSERT_CELL_DIRTY(Hive,ChildCell);

                if( !NT_SUCCESS(CmpRemoveValueFromList(Hive,targetindex,plist)) ) {
                    //
                    // bail out !
                    //
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    leave;
                }
                if( CmpFreeValue(Hive, ChildCell) == FALSE ) {
                    //
                    // we couldn't map a view inside above call
                    //
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    leave;
                }

                KeQuerySystemTime(&systemtime);
                pcell->LastWriteTime = systemtime;
                // cache it in the kcb too.
                KeyControlBlock->KcbLastWriteTime = systemtime;
                
                // some sanity asserts
                ASSERT( pcell->MaxValueNameLen == KeyControlBlock->KcbMaxValueNameLen );
                ASSERT( pcell->MaxValueDataLen == KeyControlBlock->KcbMaxValueDataLen );
                ASSERT_CELL_DIRTY(Hive,Cell);

                if (pcell->ValueList.Count == 0) {
                    pcell->MaxValueNameLen = 0;
                    pcell->MaxValueDataLen = 0;
                    // update the kcb cache too
                    KeyControlBlock->KcbMaxValueNameLen = 0;
                    KeyControlBlock->KcbMaxValueDataLen = 0;
                }

                //
                // Invalidate and rebuild the cache
                //
                CmpCleanUpKcbValueCache(KeyControlBlock);
                CmpSetUpKcbValueCache(KeyControlBlock,plist->Count,plist->List);
    
                CmpReportNotify(
                        KeyControlBlock,
                        KeyControlBlock->KeyHive,
                        KeyControlBlock->KeyCell,
                        REG_NOTIFY_CHANGE_LAST_SET
                        );
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_OBJECT_NAME_NOT_FOUND;
            }
        }
    } finally {
        if(pcell != NULL){
            HvReleaseCell(Hive, Cell);
        }
        if(Value != NULL){
            ASSERT( ChildCell != HCELL_NIL );
            HvReleaseCell(Hive, ChildCell);
        }

        CmpUnlockHiveFlusher((PCMHIVE)Hive);
        CmpUnlockKCB(KeyControlBlock);
        CmpUnlockRegistry();
    }

    // Mark the hive as read only
    CmpMarkAllBinsReadOnly(Hive);

    return status;
}


NTSTATUS
CmEnumerateKey(
    IN PCM_KEY_CONTROL_BLOCK    KeyControlBlock,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    IN PVOID KeyInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    )
/*++

Routine Description:

    Enumerate sub keys, return data on Index'th entry.

    CmEnumerateKey returns the name of the Index'th sub key of the open
    key specified.  The value STATUS_NO_MORE_ENTRIES will be
    returned if value of Index is larger than the number of sub keys.

    Note that Index is simply a way to select among child keys.  Two calls
    to CmEnumerateKey with the same Index are NOT guaranteed to return
    the same results.

    If KeyInformation is not long enough to hold all requested data,
    STATUS_BUFFER_OVERFLOW will be returned, and ResultLength will be
    set to the number of bytes actually required.

Arguments:

    KeyControlBlock - pointer to the KCB that describes the key

    Index - Specifies the (0-based) number of the sub key to be returned.

    KeyInformationClass - Specifies the type of information returned in
        Buffer.  One of the following types:

        KeyBasicInformation - return last write time, title index, and name.
            (see KEY_BASIC_INFORMATION structure)

        KeyNodeInformation - return last write time, title index, name, class.
            (see KEY_NODE_INFORMATION structure)

    KeyInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyInformation in bytes.

    ResultLength - Number of bytes actually written into KeyInformation.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status;
    HCELL_INDEX     childcell;
    PHHIVE          Hive;
    HCELL_INDEX     Cell;
    PCM_KEY_NODE    Node;
    HV_TRACK_CELL_REF       CellRef = {0};

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_CM,"CmEnumerateKey\n"));


    CmpLockRegistry();
    // 
    // this should not be changed from under us
    //
    CmpLockKCBShared(KeyControlBlock);

    PERFINFO_REG_ENUM_KEY(KeyControlBlock, Index);

    if (KeyControlBlock->Delete) {
        CmpUnlockKCB(KeyControlBlock);
        CmpUnlockRegistry();
        return STATUS_KEY_DELETED;
    }

    Hive = KeyControlBlock->KeyHive;
    Cell = KeyControlBlock->KeyCell;

    // Mark the hive as read only
    CmpMarkAllBinsReadOnly(Hive);

    //
    // fetch the child of interest
    //

    Node = (PCM_KEY_NODE)HvGetCell(Hive, Cell);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //
        CmpUnlockKCB(KeyControlBlock);
        CmpUnlockRegistry();
        CmpMarkAllBinsReadOnly(Hive);
        return STATUS_INSUFFICIENT_RESOURCES;

    }
    childcell = CmpFindSubKeyByNumber(Hive, Node, Index);
    
    // release this cell here as we don't need this Node anymore
    HvReleaseCell(Hive, Cell);

    if (childcell == HCELL_NIL) {
        //
        // no such child, clean up and return error
        //
        // we cannot return STATUS_INSUFFICIENT_RESOURCES because of Iop 
        // subsystem which treats INSUFFICIENT RESOURCES as no fatal error
        //
        CmpUnlockKCB(KeyControlBlock);
        CmpUnlockRegistry();

        // Mark the hive as read only
        CmpMarkAllBinsReadOnly(Hive);

        return STATUS_NO_MORE_ENTRIES;
    }

    Node = (PCM_KEY_NODE)HvGetCell(Hive,childcell);
    if( (Node == NULL) || !HvTrackCellRef(&CellRef,Hive,childcell) ) {
        //
        // we couldn't map a view for the bin containing this cell
        //
        CmpMarkAllBinsReadOnly(Hive);
        CmpUnlockKCB(KeyControlBlock);
        CmpUnlockRegistry();
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    try {

        //
        // call a worker to perform data transfer
        //

        status = CmpQueryKeyData(Hive,
                                 Node,
                                 KeyInformationClass,
                                 KeyInformation,
                                 Length,
                                 ResultLength
                                 );

     } except (EXCEPTION_EXECUTE_HANDLER) {

        HvReleaseFreeCellRefArray(&CellRef);

        CmpUnlockKCB(KeyControlBlock);
        CmpUnlockRegistry();
        status = GetExceptionCode();

        // Mark the hive as read only
        CmpMarkAllBinsReadOnly(Hive);

        return status;
    }

    HvReleaseFreeCellRefArray(&CellRef);

    CmpUnlockKCB(KeyControlBlock);

    CmpUnlockRegistry();

    // Mark the hive as read only
    CmpMarkAllBinsReadOnly(Hive);

    return status;
}



NTSTATUS
CmEnumerateValueKey(
    IN PCM_KEY_CONTROL_BLOCK    KeyControlBlock,
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    IN PVOID KeyValueInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    )
/*++

Routine Description:

    The value entries of an open key may be enumerated.

    CmEnumerateValueKey returns the name of the Index'th value
    entry of the open key specified by KeyHandle.  The value
    STATUS_NO_MORE_ENTRIES will be returned if value of Index is
    larger than the number of sub keys.

    Note that Index is simply a way to select among value
    entries.  Two calls to NtEnumerateValueKey with the same Index
    are NOT guaranteed to return the same results.

    If KeyValueInformation is not long enough to hold all requested data,
    STATUS_BUFFER_OVERFLOW will be returned, and ResultLength will be
    set to the number of bytes actually required.

Arguments:

    KeyControlBlock - pointer to the KCB that describes the key

    Index - Specifies the (0-based) number of the sub key to be returned.

    KeyValueInformationClass - Specifies the type of information returned
    in Buffer. One of the following types:

        KeyValueBasicInformation - return time of last write,
            title index, and name.  (See KEY_VALUE_BASIC_INFORMATION)

        KeyValueFullInformation - return time of last write,
            title index, name, class.  (See KEY_VALUE_FULL_INFORMATION)

    KeyValueInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyValueInformation in bytes.

    ResultLength - Number of bytes actually written into KeyValueInformation.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PHHIVE              Hive;
    PCM_KEY_NODE        Node;
    PCELL_DATA          ChildList;
    PCM_KEY_VALUE       ValueData = NULL;
    BOOLEAN             IndexCached;
    BOOLEAN             ValueCached = FALSE;
    PPCM_CACHED_VALUE   ContainingList = NULL;
    HCELL_INDEX         ValueDataCellToRelease = HCELL_NIL;
    HCELL_INDEX         ValueListToRelease = HCELL_NIL;
    VALUE_SEARCH_RETURN_TYPE    SearchValue;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_CM,"CmEnumerateValueKey\n"));


    //
    // lock the parent cell
    //

    CmpLockRegistry();
    // 
    // try shared first; we only upgrade to exclusive when there is a symlink or we need to populate the cache
    //
    CmpLockKCBShared(KeyControlBlock); 

    PERFINFO_REG_ENUM_VALUE(KeyControlBlock, Index);

RetryExclusive:
    if (KeyControlBlock->Delete) {
        CmpUnlockKCB(KeyControlBlock);
        CmpUnlockRegistry();
        return STATUS_KEY_DELETED;
    }
    Hive = KeyControlBlock->KeyHive;
    Node = (PCM_KEY_NODE)HvGetCell(Hive, KeyControlBlock->KeyCell);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //
        CmpUnlockKCB(KeyControlBlock);
        CmpUnlockRegistry();
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // fetch the child of interest
    //
    //
    // Do it using the cache
    //
    if (Index >= KeyControlBlock->ValueCache.Count) {
        //
        // No such child, clean up and return error.
        //
        HvReleaseCell(Hive, KeyControlBlock->KeyCell);
        CmpUnlockKCB(KeyControlBlock);
        CmpUnlockRegistry();
        return(STATUS_NO_MORE_ENTRIES);
    }

    // Mark the hive as read only
    CmpMarkAllBinsReadOnly(Hive);

    if (KeyControlBlock->ExtFlags & CM_KCB_SYM_LINK_FOUND) {
        //
        // The value list is now set to the KCB for symbolic link,
        // Clean it up and set the value right before we do the query.
        //
        if( (CmpIsKCBLockedExclusive(KeyControlBlock) == FALSE) &&
            (CmpTryConvertKCBLockSharedToExclusive(KeyControlBlock) == FALSE) ) {
            //
            // need to upgrade lock to exclusive
            //
            HvReleaseCell(Hive, KeyControlBlock->KeyCell);
            CmpUpgradeKCBLockToExclusive(KeyControlBlock);
            goto RetryExclusive;
        }
        CmpCleanUpKcbValueCache(KeyControlBlock);
        CmpSetUpKcbValueCache(KeyControlBlock,Node->ValueList.Count,Node->ValueList.List);
    }

    SearchValue = CmpGetValueListFromCache(KeyControlBlock,&ChildList, &IndexCached, &ValueListToRelease);
    if( SearchValue == SearchNeedExclusiveLock ) {
        //
        // retry with exclusive lock, since we need to update the cache
        //
        ASSERT( ValueListToRelease == HCELL_NIL );    
        HvReleaseCell(Hive, KeyControlBlock->KeyCell);
        CmpUpgradeKCBLockToExclusive(KeyControlBlock);
        goto RetryExclusive;
    }

    if (SearchValue != SearchSuccess) {
        ASSERT( ChildList == NULL );

        if( ValueListToRelease != HCELL_NIL ) {
            HvReleaseCell(Hive,ValueListToRelease);
        }
        HvReleaseCell(Hive, KeyControlBlock->KeyCell);
        CmpUnlockKCB(KeyControlBlock);
        CmpUnlockRegistry();
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    SearchValue = CmpGetValueKeyFromCache(KeyControlBlock, ChildList, Index, &ContainingList, &ValueData, IndexCached, &ValueCached,&ValueDataCellToRelease);    
    if( SearchValue == SearchNeedExclusiveLock ) {
        //
        // retry with exclusive lock, since we need to update the cache
        //
        ASSERT( ValueDataCellToRelease == HCELL_NIL );    
    
        if( ValueListToRelease != HCELL_NIL ) {
            HvReleaseCell(Hive,ValueListToRelease);
            ValueListToRelease = HCELL_NIL;
        }
        HvReleaseCell(Hive, KeyControlBlock->KeyCell);

        CmpUpgradeKCBLockToExclusive(KeyControlBlock);
        goto RetryExclusive;
    }
    if (SearchValue != SearchSuccess) {
        ASSERT( ValueData == NULL );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

    try {
        //
        // call a worker to perform data transfer; we are touching user-mode address; do it in a try/except
        //
        SearchValue = CmpQueryKeyValueData(KeyControlBlock,
                                  ContainingList,
                                  ValueData,
                                  ValueCached,
                                  KeyValueInformationClass,
                                  KeyValueInformation,
                                  Length,
                                  ResultLength,
                                  &status);
        if( SearchValue == SearchNeedExclusiveLock ) {
            //
            // retry with exclusive lock, since we need to update the cache
            //
            if( ValueListToRelease != HCELL_NIL ) {
                HvReleaseCell(Hive,ValueListToRelease);
            }

            HvReleaseCell(Hive, KeyControlBlock->KeyCell);

            if( ValueDataCellToRelease != HCELL_NIL ) {
                HvReleaseCell(Hive,ValueDataCellToRelease);
            }
            CmpUpgradeKCBLockToExclusive(KeyControlBlock);
            goto RetryExclusive;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"CmEnumerateValueKey: code:%08lx\n", GetExceptionCode()));
        status = GetExceptionCode();
    }

Exit:
    if( ValueListToRelease != HCELL_NIL ) {
        HvReleaseCell(Hive,ValueListToRelease);
    }
    HvReleaseCell(Hive, KeyControlBlock->KeyCell);
    if( ValueDataCellToRelease != HCELL_NIL ) {
        HvReleaseCell(Hive,ValueDataCellToRelease);
    }

    CmpUnlockKCB(KeyControlBlock);
    CmpUnlockRegistry();
    return status;
}

NTSTATUS
CmFlushKey(
    IN PCM_KEY_CONTROL_BLOCK    Kcb,
    IN BOOLEAN                  RegistryLockOwnedExclusive
    )
/*++

Routine Description:

    Forces changes made to a key to disk.

    CmFlushKey will not return to its caller until any changed data
    associated with the key has been written out.

    WARNING: CmFlushKey will flush the entire registry tree, and thus will
    burn cycles and I/O.

Arguments:

    Hive - supplies a pointer to the hive control structure for the hive

    Cell - supplies index of node to whose sub keys are to be found

Return Value:

    NTSTATUS

--*/
{
    PCMHIVE     CmHive;
    NTSTATUS    status = STATUS_SUCCESS;
    PHHIVE      Hive;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_CM,"CmFlushKey\n"));


    //
    // If writes are not working, lie and say we succeeded, will
    // clean up in a short time.  Only early system init code
    // will ever know the difference.
    //
    if (CmpNoWrite) {
        return STATUS_SUCCESS;
    }

    Hive = Kcb->KeyHive;

    // Mark the hive as read only
    CmpMarkAllBinsReadOnly(Hive);

    CmHive = CONTAINING_RECORD(Hive, CMHIVE, Hive);

    //
    // Don't flush the master hive.  If somebody asks for a flushkey on
    // the master hive, do a CmpDoFlushAll instead.  CmpDoFlushAll flushes
    // every hive except the master hive, which is what they REALLY want.
    //
    if (CmHive == CmpMasterHive) {
        CmpDoFlushAll(FALSE);
    } else {
        DCmCheckRegistry(CONTAINING_RECORD(Hive, CMHIVE, Hive));

        //
        // no more writes to this hive while we are flushing it
        //
        CmpLockHiveFlusherExclusive(CmHive);
        CmLockHiveViews (CmHive);

        if( HvHiveWillShrink( &(CmHive->Hive) ) ) {
            //
            // we may end up here is when the hive shrinks and we need
            // exclusive access over the registry, as we are going to CcPurge !
            //
            CmUnlockHiveViews (CmHive);
            if( !RegistryLockOwnedExclusive ) {
                CmpUnlockHiveFlusher(CmHive);
                ASSERT_KCB_LOCKED(Kcb);
                CmpUnlockKCB(Kcb);
                CmpUnlockRegistry();
                CmpLockRegistryExclusive();
                CmpLockHiveFlusherExclusive(CmHive);
                CmpLockKCBShared(Kcb);
                if(Kcb->Delete) {
                    CmpUnlockHiveFlusher(CmHive);
                    return STATUS_KEY_DELETED;
                }

                if( CmHive->UseCount != 0) {
                    CmpFixHiveUsageCount(CmHive);
                    ASSERT( CmHive->UseCount == 0 );
                }
            } 
#if DBG
            else {
                ASSERT_CM_LOCK_OWNED_EXCLUSIVE_OR_HIVE_LOADING(CmHive);
            }
#endif
        } else {
            //
            // release the views
            //
            CmUnlockHiveViews(CmHive);
        }

        if (! HvSyncHive(Hive)) {

            status = STATUS_REGISTRY_IO_FAILED;

            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_BUGCHECK,"CmFlushKey: HvSyncHive failed\n"));
        }
        CmpUnlockHiveFlusher(CmHive);
    }

    // Mark the hive as read only
    CmpMarkAllBinsReadOnly(Hive);

    return  status;
}


NTSTATUS
CmQueryKey(
    IN PCM_KEY_CONTROL_BLOCK    KeyControlBlock,
    IN KEY_INFORMATION_CLASS    KeyInformationClass,
    IN PVOID                    KeyInformation,
    IN ULONG                    Length,
    IN PULONG                   ResultLength
    )
/*++

Routine Description:

    Data about the class of a key, and the numbers and sizes of its
    children and value entries may be queried with CmQueryKey.

    NOTE: The returned lengths are guaranteed to be at least as
          long as the described values, but may be longer in
          some circumstances.

Arguments:

    KeyControlBlock - pointer to the KCB that describes the key

    KeyInformationClass - Specifies the type of information
        returned in Buffer.  One of the following types:

        KeyBasicInformation - return last write time, title index, and name.
            (See KEY_BASIC_INFORMATION)

        KeyNodeInformation - return last write time, title index, name, class.
            (See KEY_NODE_INFORMATION)

        KeyFullInformation - return all data except for name and security.
            (See KEY_FULL_INFORMATION)

    KeyInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyInformation in bytes.

    ResultLength - Number of bytes actually written into KeyInformation.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status = STATUS_UNSUCCESSFUL;
    PCM_KEY_NODE    Node = NULL;
    PUNICODE_STRING Name = NULL;
    HV_TRACK_CELL_REF       CellRef = {0};

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_CM,"CmQueryKey\n"));

    CmpLockRegistry();
    // 
    // should not be changing from under us
    //
    CmpLockKCBShared(KeyControlBlock); 

    PERFINFO_REG_QUERY_KEY(KeyControlBlock);

    // Mark the hive as read only
    CmpMarkAllBinsReadOnly(KeyControlBlock->KeyHive);

    try {

        //
        // request for the FULL path of the key
        //
        if( KeyInformationClass == KeyNameInformation ) {
            if (KeyControlBlock->Delete ) {
                //
                // special case: return key deleted status, but still fill the full name of the key.
                //
                status = STATUS_KEY_DELETED;
            } else {
                status = STATUS_SUCCESS;
            }
            
            if( KeyControlBlock->NameBlock ) {
                
                Name = CmpConstructName(KeyControlBlock);
                if (Name == NULL) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    ULONG       requiredlength;
                    ULONG       minimumlength;
                    USHORT      NameLength;
                    LONG        leftlength;
                    PKEY_INFORMATION pbuffer = (PKEY_INFORMATION)KeyInformation;

                    NameLength = Name->Length;

                    requiredlength = FIELD_OFFSET(KEY_NAME_INFORMATION, Name) + NameLength;
                    
                    minimumlength = FIELD_OFFSET(KEY_NAME_INFORMATION, Name);

                    *ResultLength = requiredlength;
                    if (Length < minimumlength) {

                        status = STATUS_BUFFER_TOO_SMALL;

                    } else {
                        //
                        // Fill in the length of the name
                        //
                        pbuffer->KeyNameInformation.NameLength = NameLength;
                        
                        //
                        // Now copy the full name into the user buffer, if enough space
                        //
                        leftlength = Length - minimumlength;
                        requiredlength = NameLength;
                        if (leftlength < (LONG)requiredlength) {
                            requiredlength = leftlength;
                            status = STATUS_BUFFER_OVERFLOW;
                        }

                        //
                        // If not enough space, copy how much we can and return overflow
                        //
                        RtlCopyMemory(
                            &(pbuffer->KeyNameInformation.Name[0]),
                            Name->Buffer,
                            requiredlength
                            );
                    }
                }
            }
        } else if(KeyControlBlock->Delete ) {
            // 
            // key already deleted
            //
            status = STATUS_KEY_DELETED;
        } else if( KeyInformationClass == KeyFlagsInformation ) {
            //
            // we only want to get the user defined flags;
            //
            PKEY_INFORMATION    pbuffer = (PKEY_INFORMATION)KeyInformation;
            ULONG               requiredlength;

            requiredlength = sizeof(KEY_FLAGS_INFORMATION);

            *ResultLength = requiredlength;

            if (Length < requiredlength) {
                status = STATUS_BUFFER_TOO_SMALL;
            } else {
                pbuffer->KeyFlagsInformation.UserFlags = (ULONG)((USHORT)KeyControlBlock->Flags >> KEY_USER_FLAGS_SHIFT);
                status = STATUS_SUCCESS;
            }
        } else {
            //
            // call a worker to perform data transfer
            //

            if( KeyInformationClass == KeyCachedInformation ) {
                //
                // call the fast version
                //
                status = CmpQueryKeyDataFromCache(  KeyControlBlock,
                                                    KeyInformationClass,
                                                    KeyInformation,
                                                    Length,
                                                    ResultLength);
            } else {
                //
                // old'n plain slow version
                //
                Node = (PCM_KEY_NODE)HvGetCell(KeyControlBlock->KeyHive, KeyControlBlock->KeyCell);
                if( (Node == NULL) || !HvTrackCellRef(&CellRef,KeyControlBlock->KeyHive, KeyControlBlock->KeyCell) ) {
                    //
                    // we couldn't map a view for the bin containing this cell
                    //
                    status = STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    status = CmpQueryKeyData(KeyControlBlock->KeyHive,
                                             Node,
                                             KeyInformationClass,
                                             KeyInformation,
                                             Length,
                                             ResultLength
                                             );
                }
            }
        }

    } finally {
        HvReleaseFreeCellRefArray(&CellRef);

        if( Name != NULL ) {
            ExFreePoolWithTag(Name, CM_NAME_TAG | PROTECTED_POOL);
        }
        CmpUnlockKCB(KeyControlBlock); 
        CmpUnlockRegistry();
    }

    // Mark the hive as read only
    CmpMarkAllBinsReadOnly(KeyControlBlock->KeyHive);

    return status;
}


NTSTATUS
CmQueryValueKey(
    IN PCM_KEY_CONTROL_BLOCK    KeyControlBlock,
    IN UNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    IN PVOID KeyValueInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    )
/*++

Routine Description:

    The ValueName, TitleIndex, Type, and Data for any one of a key's
    value entries may be queried with CmQueryValueKey.

    If KeyValueInformation is not long enough to hold all requested data,
    STATUS_BUFFER_OVERFLOW will be returned, and ResultLength will be
    set to the number of bytes actually required.

Arguments:

    KeyControlBlock - pointer to the KCB that describes the key

    ValueName  - The name of the value entry to return data for.

    KeyValueInformationClass - Specifies the type of information
        returned in KeyValueInformation.  One of the following types:

        KeyValueBasicInformation - return time of last write, title
            index, and name.  (See KEY_VALUE_BASIC_INFORMATION)

        KeyValueFullInformation - return time of last write, title
            index, name, class.  (See KEY_VALUE_FULL_INFORMATION)

    KeyValueInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyValueInformation in bytes.

    ResultLength - Number of bytes actually written into KeyValueInformation.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    PCM_KEY_VALUE       ValueData = NULL;
    ULONG               Index;
    BOOLEAN             ValueCached = FALSE;
    PPCM_CACHED_VALUE   ContainingList = NULL;
    HCELL_INDEX         ValueDataCellToRelease = HCELL_NIL;
    VALUE_SEARCH_RETURN_TYPE SearchValue;
    
    CM_PAGED_CODE();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_CM,"CmQueryValueKey\n"));

    CmpLockRegistry();
    // 
    // try shared first, we'll only lock exclusive is symlink or cache not already set up
    //
    CmpLockKCBShared(KeyControlBlock); 
    PERFINFO_REG_QUERY_VALUE(KeyControlBlock, &ValueName);

RetryExclusive:

    if(KeyControlBlock->Delete) {
        CmpUnlockKCB(KeyControlBlock);
        CmpUnlockRegistry();
        return STATUS_KEY_DELETED;
    }

    if(KeyControlBlock->ExtFlags & CM_KCB_SYM_LINK_FOUND) {
        if( (CmpIsKCBLockedExclusive(KeyControlBlock) == FALSE) &&
            (CmpTryConvertKCBLockSharedToExclusive(KeyControlBlock) == FALSE) ) {
            //
            // need to upgrade lock to exclusive
            //
            CmpUpgradeKCBLockToExclusive(KeyControlBlock);
            goto RetryExclusive;
        }
        //
        // The value list is now set to the KCB for symbolic link,
        // Clean it up and set the value right before we do the query.
        //
        CmpCleanUpKcbValueCache(KeyControlBlock);

        {
            PCM_KEY_NODE Node = (PCM_KEY_NODE)HvGetCell(KeyControlBlock->KeyHive, KeyControlBlock->KeyCell);
            if( Node == NULL ) {
                //
                // we couldn't map a view for the bin containing this cell
                //
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto ExitNoRelease;
            }

            CmpSetUpKcbValueCache(KeyControlBlock,Node->ValueList.Count,Node->ValueList.List);

            HvReleaseCell(KeyControlBlock->KeyHive, KeyControlBlock->KeyCell);
        }
    }
    //
    // Find the data
    //

    SearchValue = CmpFindValueByNameFromCache(KeyControlBlock,
                                            &ValueName,
                                            &ContainingList,
                                            &Index,
                                            &ValueData,
                                            &ValueCached,
                                            &ValueDataCellToRelease
                                            );

    if( SearchValue == SearchNeedExclusiveLock ) {
        //
        // retry with exclusive lock, since we need to update the cache
        //
        ASSERT( ValueDataCellToRelease == HCELL_NIL );    
        ASSERT( ValueData == NULL );
        CmpUpgradeKCBLockToExclusive(KeyControlBlock);
        goto RetryExclusive;
    }

    if (SearchValue == SearchSuccess) {
        ASSERT( ValueData != NULL );

        try {
            //
            // call a worker to perform data transfer; we are touching user-mode address; do it in a try/except
            //
            SearchValue = CmpQueryKeyValueData(KeyControlBlock,
                                          ContainingList,
                                          ValueData,
                                          ValueCached,
                                          KeyValueInformationClass,
                                          KeyValueInformation,
                                          Length,
                                          ResultLength,
                                          &status);
            if( SearchValue == SearchNeedExclusiveLock ) {
                //
                // retry with exclusive lock, since we need to update the cache
                //
                if(ValueDataCellToRelease != HCELL_NIL) {
                    HvReleaseCell(KeyControlBlock->KeyHive,ValueDataCellToRelease);
                    ValueDataCellToRelease = HCELL_NIL;
                }
                CmpUpgradeKCBLockToExclusive(KeyControlBlock);
                goto RetryExclusive;
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"CmQueryValueKey: code:%08lx\n", GetExceptionCode()));
            status = GetExceptionCode();
        }
    } else {
        status = STATUS_OBJECT_NAME_NOT_FOUND;
    }


    if(ValueDataCellToRelease != HCELL_NIL) {
        HvReleaseCell(KeyControlBlock->KeyHive,ValueDataCellToRelease);
    }

ExitNoRelease:
    CmpUnlockKCB(KeyControlBlock);
    CmpUnlockRegistry();

    // Mark the hive as read only
    CmpMarkAllBinsReadOnly(KeyControlBlock->KeyHive);

    return status;
}


NTSTATUS
CmQueryMultipleValueKey(
    IN PCM_KEY_CONTROL_BLOCK KeyControlBlock,
    IN PKEY_VALUE_ENTRY ValueEntries,
    IN ULONG EntryCount,
    IN PVOID ValueBuffer,
    IN OUT PULONG BufferLength,
    IN OPTIONAL PULONG ResultLength
    )
/*++

Routine Description:

    Multiple values of any key may be queried atomically with
    this api.

Arguments:

    KeyControlBlock - Supplies the key to be queried.

    ValueEntries - Returns an array of KEY_VALUE_ENTRY structures, one for each value.

    EntryCount - Supplies the number of entries in the ValueNames and ValueEntries arrays

    ValueBuffer - Returns the value data for each value.

    BufferLength - Supplies the length of the ValueBuffer array in bytes.
                   Returns the length of the ValueBuffer array that was filled in.

    ResultLength - if present, Returns the length in bytes of the ValueBuffer
                    array required to return the requested values of this key.

Return Value:

    NTSTATUS

--*/

{
    PHHIVE          Hive;
    NTSTATUS        Status;
    ULONG           i;
    UNICODE_STRING  CurrentName;
    HCELL_INDEX     ValueCell = HCELL_NIL;
    PCM_KEY_VALUE   ValueNode;
    ULONG           RequiredLength = 0;
    ULONG           UsedLength = 0;
    ULONG           DataLength;
    BOOLEAN         BufferFull = FALSE;
    BOOLEAN         Small;
    KPROCESSOR_MODE PreviousMode;
    PCM_KEY_NODE    Node;

    PAGED_CODE();
    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_CM,"CmQueryMultipleValueKey\n"));


    CmpLockRegistry();
    CmpLockKCBShared(KeyControlBlock); 
    if (KeyControlBlock->Delete) {
        CmpUnlockKCB(KeyControlBlock);
        CmpUnlockRegistry();
        return STATUS_KEY_DELETED;
    }
    Hive = KeyControlBlock->KeyHive;
    Status = STATUS_SUCCESS;

    Node = (PCM_KEY_NODE)HvGetCell(Hive, KeyControlBlock->KeyCell);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //
        CmpUnlockKCB(KeyControlBlock);
        CmpUnlockRegistry();
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Mark the hive as read only
    CmpMarkAllBinsReadOnly(Hive);

    PreviousMode = KeGetPreviousMode();
    try {
        for (i=0; i < EntryCount; i++) {
            //
            // find the data
            //
            if (PreviousMode == UserMode) {
                ProbeAndReadUnicodeStringEx(&CurrentName,ValueEntries[i].ValueName);
                ProbeForRead(CurrentName.Buffer,CurrentName.Length,sizeof(WCHAR));
            } else {
                CurrentName = *(ValueEntries[i].ValueName);
            }

            PERFINFO_REG_QUERY_MULTIVALUE(KeyControlBlock, &CurrentName); 

            ValueCell = CmpFindValueByName(Hive,
                                           Node,
                                           &CurrentName);
            if (ValueCell != HCELL_NIL) {

                ValueNode = (PCM_KEY_VALUE)HvGetCell(Hive, ValueCell);
                if( ValueNode == NULL ) {
                    //
                    // we couldn't map a view for the bin containing this cell
                    //
                    ValueCell = HCELL_NIL;
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }
                Small = CmpIsHKeyValueSmall(DataLength, ValueNode->DataLength);

                //
                // Round up UsedLength and RequiredLength to a ULONG boundary
                //
                UsedLength = (UsedLength + sizeof(ULONG)-1) & ~(sizeof(ULONG)-1);
                RequiredLength = (RequiredLength + sizeof(ULONG)-1) & ~(sizeof(ULONG)-1);

                //
                // If there is enough room for this data value in the buffer,
                // fill it in now. Otherwise, mark the buffer as full. We must
                // keep iterating through the values in order to determine the
                // RequiredLength.
                //
                if ((UsedLength + DataLength <= *BufferLength) &&
                    (UsedLength + DataLength >= UsedLength) &&
                    (!BufferFull)) {
                    PCELL_DATA  Buffer;
                    BOOLEAN     BufferAllocated;
                    HCELL_INDEX CellToRelease;
                    //
                    // get the data from source, regardless of the size
                    //
                    if( CmpGetValueData(Hive,ValueNode,&DataLength,&Buffer,&BufferAllocated,&CellToRelease) == FALSE ) {
                        //
                        // insufficient resources; return NULL
                        //
                        ASSERT( BufferAllocated == FALSE );
                        ASSERT( Buffer == NULL );
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        break;
                    }

                    RtlCopyMemory((PUCHAR)ValueBuffer + UsedLength,
                                  Buffer,
                                  DataLength);
                    //
                    // cleanup the temporary buffer
                    //
                    if( BufferAllocated == TRUE ) {
                        ExFreePool( Buffer );
                    }
                    //
                    // release the buffer in case we are using hive storage
                    //
                    if( CellToRelease != HCELL_NIL ) {
                        HvReleaseCell(Hive,CellToRelease);
                    }

                    ValueEntries[i].Type = ValueNode->Type;
                    ValueEntries[i].DataLength = DataLength;
                    ValueEntries[i].DataOffset = UsedLength;
                    UsedLength += DataLength;
                } else {
                    BufferFull = TRUE;
                    Status = STATUS_BUFFER_OVERFLOW;
                }
                RequiredLength += DataLength;
                HvReleaseCell(Hive, ValueCell);
                ValueCell = HCELL_NIL;
            } else {
                Status = STATUS_OBJECT_NAME_NOT_FOUND;
                break;
            }
        }

        if (NT_SUCCESS(Status) ||
            (Status == STATUS_BUFFER_OVERFLOW)) {
            *BufferLength = UsedLength;
            if (ARGUMENT_PRESENT(ResultLength)) {
                *ResultLength = RequiredLength;
            }
        }

    } finally {
        if( ValueCell != HCELL_NIL) {
            HvReleaseCell(Hive, ValueCell);
        }
        HvReleaseCell(Hive, KeyControlBlock->KeyCell);
        
        CmpUnlockKCB(KeyControlBlock);
        CmpUnlockRegistry();
    }

    // Mark the hive as read only
    CmpMarkAllBinsReadOnly(Hive);

    return Status;
}

NTSTATUS
CmSetValueKey(
    IN PCM_KEY_CONTROL_BLOCK KeyControlBlock,
    IN PUNICODE_STRING ValueName,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    )
/*++

Routine Description:

    A value entry may be created or replaced with CmSetValueKey.

    If a value entry with a Value ID (i.e. name) matching the
    one specified by ValueName exists, it is deleted and replaced
    with the one specified.  If no such value entry exists, a new
    one is created.  NULL is a legal Value ID.  While Value IDs must
    be unique within any given key, the same Value ID may appear
    in many different keys.

Arguments:

    KeyControlBlock - pointer to kcb for the key to operate on

    ValueName - The unique (relative to the containing key) name
        of the value entry.  May be NULL.

    Type - The integer type number of the value entry.

    Data - Pointer to buffer with actual data for the value entry.

    DataSize - Size of Data buffer.


Return Value:

    NTSTATUS

--*/
{
    NTSTATUS        status;
    PCM_KEY_NODE    parent = NULL;
    HCELL_INDEX     oldchild = 0;
    ULONG           count;
    PHHIVE          Hive = NULL;
    HCELL_INDEX     Cell;
    ULONG           StorageType;
    ULONG           TempData;
    BOOLEAN         found;
    PCM_KEY_VALUE   Value = NULL;
    LARGE_INTEGER   systemtime;
    ULONG           mustChange=FALSE;
    ULONG           ChildIndex;
    HCELL_INDEX     ParentToRelease = HCELL_NIL;
    HCELL_INDEX     ChildToRelease = HCELL_NIL;
    BOOLEAN                 FlusherLocked = FALSE;
    VALUE_SEARCH_RETURN_TYPE    SearchType;

    PERFINFO_REG_SET_VALUE_DECL();

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_CM,"CmSetValueKey\n"));

    CmpLockRegistry();
    //
    // try shared first; we'll only lock exclusive if we're going to change the cache
    //
    CmpLockKCBShared(KeyControlBlock);

    ASSERT(sizeof(ULONG) == CM_KEY_VALUE_SMALL);

    PERFINFO_REG_SET_VALUE(KeyControlBlock);

    // Mark the hive as read only
    CmpMarkAllBinsReadOnly(KeyControlBlock->KeyHive);

    while (TRUE) {
TryAgain:
        //
        // Check that we are not being asked to add a value to a key
        // that has been deleted
        //
        if (KeyControlBlock->Delete == TRUE) {
            status = STATUS_KEY_DELETED;
            goto Exit;
        }

        ASSERT_KCB_LOCKED(KeyControlBlock);
        //
        // Check to see if this is a symbolic link node.  If so caller
        // is only allowed to create/change the SymbolicLinkValue
        // value name
        //

        if (KeyControlBlock->Flags & KEY_SYM_LINK &&
            (( (Type != REG_LINK) ) ||
             ValueName == NULL ||
             !RtlEqualUnicodeString(&CmSymbolicLinkValueName, ValueName, TRUE)))
        {
            //
            // Disallow attempts to manipulate any value names under a symbolic link
            // except for the "SymbolicLinkValue" value name or type other than REG_LINK
            //

            // Mark the hive as read only
            CmpMarkAllBinsReadOnly(KeyControlBlock->KeyHive);

            status = STATUS_ACCESS_DENIED;
            goto Exit;
        }

        if( mustChange == FALSE ) {
            //
            // first iteration; look inside the kcb cache
            //
            
            SearchType = CmpCompareNewValueDataAgainstKCBCache(KeyControlBlock,ValueName,Type,Data,DataSize);
            if( SearchType == SearchNeedExclusiveLock ) {
                CmpUpgradeKCBLockToExclusive(KeyControlBlock);
                goto TryAgain;
            } else if( SearchType == SearchSuccess) {
                //
                // the value is in the cache and is the same; make this call a noop
                //
                status = STATUS_SUCCESS;
                goto Exit;
            }

            //
            // To Get here, we must either be changing a value, or setting a new one
            // we need to upgrade kcb lock if not yet exclusive
            //
            if( (CmpIsKCBLockedExclusive(KeyControlBlock) == FALSE) &&
                (CmpTryConvertKCBLockSharedToExclusive(KeyControlBlock) == FALSE) ) {
                //
                // need to upgrade lock to exclusive
                //
                CmpUpgradeKCBLockToExclusive(KeyControlBlock);
            }
            mustChange=TRUE;
        } else {
            //
            // second iteration; look inside the hive
            //

            
            //
            // get reference to parent key,
            //
            Hive = KeyControlBlock->KeyHive;
            Cell = KeyControlBlock->KeyCell;
            if( ParentToRelease != HCELL_NIL ) {
                HvReleaseCell(Hive,ParentToRelease);
                ParentToRelease = HCELL_NIL;
            }
            parent = (PCM_KEY_NODE)HvGetCell(Hive, Cell);
            if( parent == NULL ) {
                //
                // we couldn't map a view for the bin containing this cell
                //
        
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto Exit;
            }
            ParentToRelease = Cell;
            //
            // try to find an existing value entry by the same name
            //
            count = parent->ValueList.Count;
            found = FALSE;

            if (count > 0) {
                if( CmpFindNameInList(Hive,
                                     &parent->ValueList,
                                     ValueName,
                                     &ChildIndex,
                                     &oldchild) == FALSE ) {
                    //
                    // we couldn't map a view for the bin containing this cell
                    //
        
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Exit;
                }

                if (oldchild != HCELL_NIL) {
                    if( ChildToRelease != HCELL_NIL ) {
                        HvReleaseCell(Hive,ChildToRelease);
                        ChildToRelease = HCELL_NIL;
                    }
                    Value = (PCM_KEY_VALUE)HvGetCell(Hive,oldchild);
                    if( Value == NULL ) {
                        //
                        // could no map view
                        //
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        goto Exit;
                    }
                    ChildToRelease = oldchild;
                    found = TRUE;
                }
            } else {
                //
                // empty list; add it first
                //
                ChildIndex = 0;
            }

            //
            // Performance Hack:
            // If a Set is asking us to set a key to the current value (IE does this a lot)
            // drop it (and, therefore, the last modified time) on the floor, but return success
            // this stops the page from being dirtied, and us having to flush the registry.
            //
            //
            break;
        }

        //
        // We're going through these gyrations so that if someone does come in and try and delete the
        // key we're setting we're safe. Once we know we have to change the key, take the
        // flusher lock and restart
        //
        //
        ASSERT( !FlusherLocked );
        CmpLockHiveFlusherShared((PCMHIVE)KeyControlBlock->KeyHive);
        FlusherLocked = TRUE;

    }// while

    ASSERT( mustChange == TRUE );

    ASSERT_KCB_LOCKED_EXCLUSIVE(KeyControlBlock);

    // It's a different or new value, mark it dirty, since we'll
    // at least set its time stamp

    if (! HvMarkCellDirty(Hive, Cell, FALSE)) {
        status = STATUS_NO_LOG_SPACE;
        goto Exit;
    }

    StorageType = HvGetCellType(Cell);

    //
    // stash small data if relevant
    //
    TempData = 0;
    if ((DataSize <= CM_KEY_VALUE_SMALL) &&
        (DataSize > 0))
    {
        try {
            RtlCopyMemory(          // yes, move memory, could be 1 byte
                &TempData,          // at the end of a page.
                Data,
                DataSize
                );
         } except (EXCEPTION_EXECUTE_HANDLER) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!CmSetValueKey: code:%08lx\n", GetExceptionCode()));
            status = GetExceptionCode();
            goto Exit;
        }
    }

    if (found) {

        //
        // ----- Existing Value Entry Path -----
        //

        //
        // An existing value entry of the specified name exists,
        // set our data into it.
        //
        status = CmpSetValueKeyExisting(Hive,
                                        oldchild,
                                        Value,
                                        Type,
                                        Data,
                                        DataSize,
                                        StorageType,
                                        TempData);

        PERFINFO_REG_SET_VALUE_EXIST();
    } else {

        //
        // ----- New Value Entry Path -----
        //

        //
        // Either there are no existing value entries, or the one
        // specified is not in the list.  In either case, create and
        // fill a new one, and add it to the list
        //
        status = CmpSetValueKeyNew(Hive,
                                   parent,
                                   ValueName,
                                   ChildIndex,
                                   Type,
                                   Data,
                                   DataSize,
                                   StorageType,
                                   TempData);
        PERFINFO_REG_SET_VALUE_NEW();
    }

    if (NT_SUCCESS(status)) {

        // sanity assert
        ASSERT( parent->MaxValueNameLen == KeyControlBlock->KcbMaxValueNameLen );
        if (parent->MaxValueNameLen < ValueName->Length) {
            parent->MaxValueNameLen = ValueName->Length;
            // update the kcb cache too
            KeyControlBlock->KcbMaxValueNameLen = ValueName->Length;
        }

        //sanity assert
        ASSERT( parent->MaxValueDataLen == KeyControlBlock->KcbMaxValueDataLen );
        if (parent->MaxValueDataLen < DataSize) {
            parent->MaxValueDataLen = DataSize;
            // update the kcb cache too
            KeyControlBlock->KcbMaxValueDataLen = parent->MaxValueDataLen;
        }

        KeQuerySystemTime(&systemtime);
        parent->LastWriteTime = systemtime;
        // update the kcb cache too.
        KeyControlBlock->KcbLastWriteTime = systemtime;
    
        if( found && (CMP_IS_CELL_CACHED(KeyControlBlock->ValueCache.ValueList)) ) {
            //
            // invalidate only the entry we changed.
            //
            PULONG_PTR CachedList = (PULONG_PTR) CMP_GET_CACHED_CELLDATA(KeyControlBlock->ValueCache.ValueList);
            if (CMP_IS_CELL_CACHED(CachedList[ChildIndex])) {

                ExFreePool((PVOID) CMP_GET_CACHED_ADDRESS(CachedList[ChildIndex]));
            }
            CachedList[ChildIndex] = oldchild;

        } else {
            //
            // rebuild ALL KCB cache
            // 
            CmpCleanUpKcbValueCache(KeyControlBlock);
            CmpSetUpKcbValueCache(KeyControlBlock,parent->ValueList.Count,parent->ValueList.List);
        }
        CmpReportNotify(KeyControlBlock,
                        KeyControlBlock->KeyHive,
                        KeyControlBlock->KeyCell,
                        REG_NOTIFY_CHANGE_LAST_SET);
    }

Exit:
    PERFINFO_REG_SET_VALUE_DONE(ValueName);

    if( ParentToRelease != HCELL_NIL && Hive != NULL) {
        HvReleaseCell(Hive,ParentToRelease);
    }
    if( ChildToRelease != HCELL_NIL && Hive != NULL) {
        HvReleaseCell(Hive,ChildToRelease);
    }

    if( FlusherLocked ) {
        CmpUnlockHiveFlusher((PCMHIVE)KeyControlBlock->KeyHive);    
    }

    CmpUnlockKCB(KeyControlBlock);
    CmpUnlockRegistry();
  
    // Mark the hive as read only
    CmpMarkAllBinsReadOnly(KeyControlBlock->KeyHive);

    return status;
}


NTSTATUS
CmpSetValueKeyExisting(
    IN PHHIVE  Hive,
    IN HCELL_INDEX OldChild,
    IN PCM_KEY_VALUE Value,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize,
    IN ULONG StorageType,
    IN ULONG TempData
    )
/*++

Routine Description:

    Helper for CmSetValueKey, implements the case where the value entry
    being set already exists.

Arguments:

    Hive - hive of interest

    OldChild - hcell_index of the value entry body to which we are to
                    set new data

    Type - The integer type number of the value entry.

    Data - Pointer to buffer with actual data for the value entry.

    DataSize - Size of Data buffer.

    StorageType - stable or volatile

    TempData - small values are passed here

Return Value:

    STATUS_SUCCESS if it worked, appropriate status code if it did not

Note: 
    
    For new hives format, we have the following cases:

    New Data                Old Data
    --------                --------

1.  small                   small
2.  small                   normal
3.  small                   bigdata
4.  normal                  small
5.  normal                  normal
6.  normal                  bigdata
7.  bigdata                 small
8.  bigdata                 normal
9.  bigdata                 bigdata  



--*/
{
    HCELL_INDEX     DataCell;
    HCELL_INDEX     OldDataCell;
    PCELL_DATA      pdata;
    HCELL_INDEX     NewCell;
    ULONG           OldRealSize;
    USHORT          OldSizeType;    // 0 - small
    USHORT          NewSizeType;    // 1 - normal
                                    // 2 - bigdata
    HANDLE          hSecure = 0;
    NTSTATUS        status = STATUS_SUCCESS;

    ASSERT_HIVE_FLUSHER_LOCKED((PCMHIVE)Hive);

    //
    // value entry by the specified name already exists
    // oldchild is hcell_index of its value entry body
    //  which we will always edit, so mark it dirty
    //
    if (! HvMarkCellDirty(Hive, OldChild, FALSE)) {
        return STATUS_NO_LOG_SPACE;
    }

    if(CmpIsHKeyValueSmall(OldRealSize, Value->DataLength) == TRUE ) {
        //
        // old data was small
        //
        OldSizeType = 0;
    } else if( CmpIsHKeyValueBig(Hive,OldRealSize) == TRUE ) {
        //
        // old data was big
        //
        OldSizeType = 2;
    } else {
        //
        // old data was normal
        //
        OldSizeType = 1;
    }

    if( DataSize <= CM_KEY_VALUE_SMALL ) {
        //
        // new data is small
        //
        NewSizeType = 0;
    } else if( CmpIsHKeyValueBig(Hive,DataSize) == TRUE ) {
        //
        // new data is big
        //
        NewSizeType = 2;
    } else {
        //
        // new data is normal
        //
        NewSizeType = 1;
    }


    //
    // this will handle all cases and will make sure data is marked dirty 
    //
    if( !CmpMarkValueDataDirty(Hive,Value) ) {
        return STATUS_NO_LOG_SPACE;
    }

    //
    // cases 1,2,3
    //
    if( NewSizeType == 0 ) {
        if( ((OldSizeType == 1) && (OldRealSize > 0) ) ||
            (OldSizeType == 2) 
            ) {
            CmpFreeValueData(Hive,Value->Data,OldRealSize);
        }
        
        //
        // write our new small data into value entry body
        //
        Value->DataLength = DataSize + CM_KEY_VALUE_SPECIAL_SIZE;
        Value->Data = TempData;
        Value->Type = Type;

        return STATUS_SUCCESS;
    }
    
    //
    // secure the user buffer so we don't get inconsistencies.
    // ONLY if we are called with a user mode buffer !!!
    //

    if ( (ULONG_PTR)Data <= (ULONG_PTR)MM_HIGHEST_USER_ADDRESS ) {
        hSecure = MmSecureVirtualMemory(Data,DataSize, PAGE_READONLY);
        if (hSecure == 0) {
            return STATUS_INVALID_PARAMETER;
        }
    }
    
    //
    // store it to be freed if the allocation succeeds
    //
    OldDataCell = Value->Data;

    //
    // cases 4,5,6
    //
    if( NewSizeType == 1 ){

        if( (OldSizeType == 1) && (OldRealSize > 0)) { 
            //
            // we already have a cell; see if we can reuse it !
            //
            DataCell = Value->Data;
            ASSERT(DataCell != HCELL_NIL);
            pdata = HvGetCell(Hive, DataCell);
            if( pdata == NULL ) {
                //
                // we couldn't map a view for the bin containing this cell
                //
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto Exit;
            }
            // release it right here, as the registry is locked exclusively, so we don't care
            HvReleaseCell(Hive, DataCell);

            ASSERT(HvGetCellSize(Hive, pdata) > 0);

            if (DataSize <= (ULONG)(HvGetCellSize(Hive, pdata))) {

                //
                // The existing data cell is big enough to hold the new data.  
                //

                //
                // we'll keep this cell
                //
                NewCell = DataCell;

            } else {
                //
                // grow the existing cell
                //
                NewCell = HvReallocateCell(Hive,DataCell,DataSize);
                if (NewCell == HCELL_NIL) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Exit;
                }
            }

        } else {
            //
            // allocate a new cell 
            //
            NewCell = HvAllocateCell(Hive, DataSize, StorageType,(HvGetCellType(OldChild)==StorageType)?OldChild:HCELL_NIL);

            if (NewCell == HCELL_NIL) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto Exit;
            }
        }
     
        //
        // now we have a cell that can accommodate the data
        //
        pdata = HvGetCell(Hive, NewCell);
        if( pdata == NULL ) {
            //
            // we couldn't map a view for the bin containing this cell
            //
            // this shouldn't happen as we just allocated/ reallocated/ marked dirty this cell
            //
            ASSERT( FALSE );
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit;
        }
        // release it right here, as the registry is locked exclusively, so we don't care
        HvReleaseCell(Hive, NewCell);

        //
        // copy the actual data
        //
        RtlCopyMemory(pdata,Data,DataSize);
        Value->Data = NewCell;
        Value->DataLength = DataSize;
        Value->Type = Type;
        
        // sanity
        ASSERT_CELL_DIRTY(Hive,NewCell);

        if( OldSizeType == 2 ) {
            //
            // old data was big; free it
            //
            ASSERT( OldDataCell != NewCell );
            CmpFreeValueData(Hive,OldDataCell,OldRealSize);
        }

        status = STATUS_SUCCESS;
        goto Exit;
    }
    
    //
    // cases 7,8,9
    //
    if( NewSizeType == 2 ) {

        if( OldSizeType == 2 ) { 
            //
            // data was previously big; grow it!
            //
            
            status =CmpSetValueDataExisting(Hive,Data,DataSize,StorageType,OldDataCell);
            if( !NT_SUCCESS(status) ) {
                goto Exit;
            }
            NewCell = OldDataCell;
            
        } else {
            //
            // data was small or normal. 
            // allocate and copy to a new big data cell; 
            // then free the old cell
            //
            status = CmpSetValueDataNew(Hive,Data,DataSize,StorageType,OldChild,&NewCell);
            if( !NT_SUCCESS(status) ) {
                //
                // We have bombed out loading user data, clean up and exit.
                //
                goto Exit;
            }
            
            if( (OldSizeType != 0) && (OldRealSize != 0) ) {
                //
                // there is something to free
                //
                HvFreeCell(Hive, Value->Data);
            }
        }

        Value->DataLength = DataSize;
        Value->Data = NewCell;
        Value->Type = Type;

        // sanity
        ASSERT_CELL_DIRTY(Hive,NewCell);

        status = STATUS_SUCCESS;
        goto Exit;

    }

    //
    // we shouldn't get here
    //
    ASSERT( FALSE );

Exit:
    if( hSecure) {
        MmUnsecureVirtualMemory(hSecure);
    }
    return status;
}

NTSTATUS
CmpSetValueKeyNew(
    IN PHHIVE  Hive,
    IN PCM_KEY_NODE Parent,
    IN PUNICODE_STRING ValueName,
    IN ULONG Index,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize,
    IN ULONG StorageType,
    IN ULONG TempData
    )
/*++

Routine Description:

    Helper for CmSetValueKey, implements the case where the value entry
    being set does not exist.  Will create new value entry and data,
    place in list (which may be created)

Arguments:

    Hive - hive of interest

    Parent - pointer to key node value entry is for

    ValueName - The unique (relative to the containing key) name
        of the value entry.  May be NULL.

    Index - where in the list should this value be inserted

    Type - The integer type number of the value entry.

    Data - Pointer to buffer with actual data for the value entry.

    DataSize - Size of Data buffer.

    StorageType - stable or volatile

    TempData - small data values passed here


Return Value:

    STATUS_SUCCESS if it worked, appropriate status code if it did not

--*/
{
    PCELL_DATA  pvalue;
    HCELL_INDEX ValueCell;
    NTSTATUS    Status;

    ASSERT_HIVE_FLUSHER_LOCKED((PCMHIVE)Hive);

    //
    // Either Count == 0 (no list) or our entry is simply not in
    // the list.  Create a new value entry body, and data.  Add to list.
    // (May create the list.)
    //
    if (Parent->ValueList.Count != 0) {
        ASSERT(Parent->ValueList.List != HCELL_NIL);
        if (! HvMarkCellDirty(Hive, Parent->ValueList.List, FALSE)) {
            return STATUS_NO_LOG_SPACE;
        }
    }

    //
    // allocate the body of the value entry, and the data
    //
    ValueCell = HvAllocateCell(
                    Hive,
                    CmpHKeyValueSize(Hive, ValueName),
                    StorageType,
                    HCELL_NIL
                    );

    if (ValueCell == HCELL_NIL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // map in the body, and fill in its fixed portion
    //
    pvalue = HvGetCell(Hive, ValueCell);
    if( pvalue == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        //
        // normally this shouldn't happen as we just allocated ValueCell
        // i.e. the bin containing ValueCell should be mapped in memory at this point.
        //
        ASSERT( FALSE );
        HvFreeCell(Hive, ValueCell);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    // release it right here, as the view is PINNED
    HvReleaseCell(Hive, ValueCell);

    // sanity
    ASSERT_CELL_DIRTY(Hive,ValueCell);

    pvalue->u.KeyValue.Signature = CM_KEY_VALUE_SIGNATURE;

    //
    // fill in the variable portions of the new value entry,  name and
    // and data are copied from caller space, could fault.
    //
    try {

        //
        // fill in the name
        //
        pvalue->u.KeyValue.NameLength = CmpCopyName(Hive,
                                                    pvalue->u.KeyValue.Name,
                                                    ValueName);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        CmKdPrintEx((DPFLTR_CONFIG_ID,CML_EXCEPTION,"!!CmSetValueKey: code:%08lx\n", GetExceptionCode()));

        //
        // We have bombed out loading user data, clean up and exit.
        //
        HvFreeCell(Hive, ValueCell);
        return GetExceptionCode();
    }

    if (pvalue->u.KeyValue.NameLength < ValueName->Length) {
        pvalue->u.KeyValue.Flags = VALUE_COMP_NAME;
    } else {
        pvalue->u.KeyValue.Flags = 0;
    }

    //
    // fill in the data
    //
    if (DataSize > CM_KEY_VALUE_SMALL) {
        Status = CmpSetValueDataNew(Hive,Data,DataSize,StorageType,ValueCell,&(pvalue->u.KeyValue.Data));
        if( !NT_SUCCESS(Status) ) {
            //
            // We have bombed out loading user data, clean up and exit.
            //
            HvFreeCell(Hive, ValueCell);
            return Status;
        }

        pvalue->u.KeyValue.DataLength = DataSize;
        // sanity
        ASSERT_CELL_DIRTY(Hive,pvalue->u.KeyValue.Data);

    } else {
        pvalue->u.KeyValue.DataLength = DataSize + CM_KEY_VALUE_SPECIAL_SIZE;
        pvalue->u.KeyValue.Data = TempData;
    }
    pvalue->u.KeyValue.Type = Type;

    if( !NT_SUCCESS(CmpAddValueToList(Hive,ValueCell,Index,StorageType,&(Parent->ValueList)) ) ) {
        // out of space, free all allocated stuff
        // this will free embedded cigdata cell info too (if any)
        CmpFreeValue(Hive,ValueCell);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
CmSetLastWriteTimeKey(
    IN PCM_KEY_CONTROL_BLOCK KeyControlBlock,
    IN PLARGE_INTEGER LastWriteTime
    )
/*++

Routine Description:

    The LastWriteTime associated with a key node can be set with
    CmSetLastWriteTimeKey

Arguments:

    KeyControlBlock - pointer to kcb for the key to operate on

    LastWriteTime - new time for key

Return Value:

    NTSTATUS

--*/
{
    PCM_KEY_NODE parent;
    PHHIVE      Hive;
    HCELL_INDEX Cell;
    NTSTATUS    status = STATUS_SUCCESS;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_CM,"CmSetLastWriteTimeKey\n"));

    CmpLockRegistry();
    //
    // serialize access to this key.
    //
    CmpLockKCBExclusive(KeyControlBlock);

    //
    // Check that we are not being asked to modify a key
    // that has been deleted
    //
    if (KeyControlBlock->Delete == TRUE) {
        status = STATUS_KEY_DELETED;
        goto Exit;
    }

    Hive = KeyControlBlock->KeyHive;
    Cell = KeyControlBlock->KeyCell;

    // 
    // no flush from this point on
    //
    CmpLockHiveFlusherShared((PCMHIVE)Hive);

    if (! HvMarkCellDirty(Hive, Cell,FALSE)) {
        status = STATUS_NO_LOG_SPACE;
        goto Exit2;
    }

    parent = (PCM_KEY_NODE)HvGetCell(Hive, Cell);
    if( parent == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit2;
    }

    parent->LastWriteTime = *LastWriteTime;
    // update the kcb cache too.
    KeyControlBlock->KcbLastWriteTime = *LastWriteTime;
    
    HvReleaseCell(Hive, Cell);
Exit2:
    CmpUnlockHiveFlusher((PCMHIVE)Hive);
Exit:
    CmpUnlockKCB(KeyControlBlock);
    CmpUnlockRegistry();
    return status;
}

NTSTATUS
CmSetKeyUserFlags(
    IN PCM_KEY_CONTROL_BLOCK    KeyControlBlock,
    IN ULONG                    UserFlags
    )
/*++

Routine Description:

    Sets the user defined flags for the key; At this point there are only 
    4 bits reserved for user defined flags. kcb and knode must be kept in 
    sync.

Arguments:

    KeyControlBlock - pointer to kcb for the key to operate on

    UserFlags - user defined flags to be set on this key.

Return Value:

    NTSTATUS

--*/
{
    PCM_KEY_NODE    Node;
    PHHIVE          Hive;
    HCELL_INDEX     Cell;
    LARGE_INTEGER   LastWriteTime;
    NTSTATUS        status = STATUS_SUCCESS;

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_CM,"CmSetKeyUserFlags\n"));

    CmpLockRegistry();
    //
    // serialize access to this key.
    //
    CmpLockKCBExclusive(KeyControlBlock);

    //
    // Check that we are not being asked to modify a key
    // that has been deleted
    //
    if (KeyControlBlock->Delete == TRUE) {
        status = STATUS_KEY_DELETED;
        goto Exit;
    }

    if( UserFlags & (~((ULONG)KEY_USER_FLAGS_VALID_MASK)) ) {
        //
        // number of user defined flags exceeded; punt
        //
        status = STATUS_INVALID_PARAMETER;
        goto Exit;

    }

    Hive = KeyControlBlock->KeyHive;
    Cell = KeyControlBlock->KeyCell;

    // 
    // no flush from this point on
    //
    CmpLockHiveFlusherShared((PCMHIVE)Hive);

    if (! HvMarkCellDirty(Hive, Cell,FALSE)) {
        status = STATUS_NO_LOG_SPACE;
        goto Exit2;
    }

    Node = (PCM_KEY_NODE)HvGetCell(Hive, Cell);
    if( Node == NULL ) {
        //
        // we couldn't map a view for the bin containing this cell
        //

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit2;
    }
    //
    // shift/(pack) the user defined flags and
    // update knode and kcb cache
    //
    // first, erase the old flags
    Node->Flags &= KEY_USER_FLAGS_CLEAR_MASK;
    Node->Flags |= (USHORT)(UserFlags<<KEY_USER_FLAGS_SHIFT);
    // update the kcb cache
    KeyControlBlock->Flags = Node->Flags;

    //
    // we need to update the LstWriteTime as well
    //
    KeQuerySystemTime(&LastWriteTime);
    Node->LastWriteTime = LastWriteTime;
    // update the kcb cache too.
    KeyControlBlock->KcbLastWriteTime = LastWriteTime;

    HvReleaseCell(Hive, Cell);
Exit2:
    CmpUnlockHiveFlusher((PCMHIVE)Hive);
Exit:
    CmpUnlockKCB(KeyControlBlock);
    CmpUnlockRegistry();
    return status;
}

BOOLEAN
CmpIsHiveAlreadyLoaded( IN HANDLE KeyHandle,
                        IN POBJECT_ATTRIBUTES SourceFile,
                        OUT PCMHIVE *CmHive
                        )
/*++

Routine Description:

    Checks if the SourceFile is already loaded in the same spot as KeyHandle.

Arguments:

    KeyHandle - should be the root of a hive. We'll query the name of the primary file
                and compare it against the name of SourceFile

    SourceFile - specifies a file.  while file could be remote,
                that is strongly discouraged.

Return Value:

    TRUE/FALSE
--*/
{
    NTSTATUS                    status;
    PCM_KEY_BODY                KeyBody;
    BOOLEAN                     Result = FALSE; // pessimistic
    
    CM_PAGED_CODE();

    ASSERT_CM_LOCK_OWNED_EXCLUSIVE();

    status = ObReferenceObjectByHandle(KeyHandle,
                                       0,
                                       CmpKeyObjectType,
                                       KernelMode,
                                       (PVOID *)(&KeyBody),
                                       NULL);
    if(!NT_SUCCESS(status)) {
        return FALSE;
    }

	if( KeyBody->KeyControlBlock->Delete ) {
		return FALSE;	
	}
    
    *CmHive = (PCMHIVE)CONTAINING_RECORD(KeyBody->KeyControlBlock->KeyHive, CMHIVE, Hive);

    //
    // should be the root of a hive
    // 
    if( !(KeyBody->KeyControlBlock->Flags & KEY_HIVE_ENTRY) || // not root of a hive
        ((*CmHive)->FileUserName.Buffer == NULL)// no name captured
        ) {
        goto ExitCleanup;
    }
    
    if( RtlCompareUnicodeString(&((*CmHive)->FileUserName),
                                SourceFile->ObjectName,
                                TRUE) == 0 ) {
        //
        // same file; same spot
        //
        Result = TRUE;
        //
        // unfreeze the hive;hive will become just a regular hive from now on
        // it is safe to do this because we hold an extra refcount on the root of the hive
        // as we have specifically opened the root to check if it's already loaded
        //
        if( IsHiveFrozen(*CmHive) ) {
            (*CmHive)->Frozen = FALSE;
            if( (*CmHive)->RootKcb ) {
                CmpDereferenceKeyControlBlockWithLock((*CmHive)->RootKcb,TRUE);
                (*CmHive)->RootKcb = NULL;
            }

        }

    }
    
ExitCleanup:
    ObDereferenceObject((PVOID)KeyBody);
    return Result;
}

#define LogHiveLoad(a,b) //nothing

NTSTATUS
CmLoadKey(
    IN POBJECT_ATTRIBUTES   TargetKey,
    IN POBJECT_ATTRIBUTES   SourceFile,
    IN ULONG                Flags,
    IN PCM_KEY_BODY         KeyBody
    )

/*++

Routine Description:

    A hive (file in the format created by NtSaveKey) may be linked
    into the active registry with this call.  UNLIKE NtRestoreKey,
    the file specified to NtLoadKey will become the actual backing
    store of part of the registry (that is, it will NOT be copied.)

    The file may have an associated .log file.

    If the hive file is marked as needing a .log file, and one is
    not present, the call will fail.

    The name specified by SourceFile must be such that ".log" can
    be appended to it to generate the name of the log file.  Thus,
    on FAT file systems, the hive file may not have an extension.

    This call is used by logon to make the user's profile available
    in the registry.  It is not intended for use doing backup,
    restore, etc.  Use NtRestoreKey for that.

    N.B.  This routine assumes that the object attributes for the file
          to be opened have been captured into kernel space so that
          they can safely be passed to the worker thread to open the file
          and do the actual I/O.

Arguments:

    TargetKey - specifies the path to a key to link the hive to.
                path must be of the form "\registry\user\<username>"

    SourceFile - specifies a file.  while file could be remote,
                that is strongly discouraged.

    Flags - specifies any flags that should be used for the load operation.
            The only valid flag is REG_NO_LAZY_FLUSH.

Return Value:

    NTSTATUS

--*/
{
    PCMHIVE                     NewHive = NULL;
    NTSTATUS                    Status;
    BOOLEAN                     Allocate;
    SECURITY_QUALITY_OF_SERVICE ServiceQos;
    SECURITY_CLIENT_CONTEXT     ClientSecurityContext;
    HANDLE                      KeyHandle;
    PCMHIVE                     OtherHive = NULL;
    CM_PARSE_CONTEXT            ParseContext;


    if( KeyBody != NULL ) {
        OtherHive = (PCMHIVE)CONTAINING_RECORD(KeyBody->KeyControlBlock->KeyHive, CMHIVE, Hive);
        if( ! (OtherHive->Flags & CM_CMHIVE_FLAG_UNTRUSTED) ) {
            //
            // deny attempts to join the TRUSTED class of trust
            //
            return STATUS_INVALID_PARAMETER;
        }
    }


    //
    // Obtain the security context here so we can use it
    // later to impersonate the user, which we will do
    // if we cannot access the file as SYSTEM.  This
    // usually occurs if the file is on a remote machine.
    //
    ServiceQos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    ServiceQos.ImpersonationLevel = SecurityImpersonation;
    ServiceQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    ServiceQos.EffectiveOnly = TRUE;
    Status = SeCreateClientSecurity(CONTAINING_RECORD(KeGetCurrentThread(),ETHREAD,Tcb),
                                    &ServiceQos,
                                    FALSE,
                                    &ClientSecurityContext);
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    RtlZeroMemory(&ParseContext,sizeof(CM_PARSE_CONTEXT));
    ParseContext.CreateOperation = FALSE;
    //
    // we open the root of the hive here. if it already exists,this will prevent it from going
    // away from under us while we are doing the "already loaded" check (due to delay unload logic)
    //
    Status = ObOpenObjectByName(TargetKey,
                                CmpKeyObjectType,
                                KernelMode,
                                NULL,
                                KEY_READ,
                                (PVOID)&ParseContext,
                                &KeyHandle);
    if(!NT_SUCCESS(Status)) {
        KeyHandle = NULL;
    }

    Allocate = TRUE;
    Status = CmpCmdHiveOpen(    SourceFile,             // FileAttributes
                                &ClientSecurityContext, // ImpersonationContext
                                &Allocate,              // Allocate
                                &NewHive,               // NewHive
								CM_CHECK_REGISTRY_CHECK_CLEAN // CheckFlags
                            );

    SeDeleteClientSecurity( &ClientSecurityContext );


    if (!NT_SUCCESS(Status)) {
        if( KeyHandle != NULL ) {
            PCMHIVE LoadedHive = NULL;
            
            CmpLockRegistryExclusive();

            //
            // check if the same file is loaded in the same spot
            //
            if( CmpIsHiveAlreadyLoaded(KeyHandle,SourceFile,&LoadedHive) ) {
                ASSERT( LoadedHive );
                if( OtherHive != NULL ) {
                    //
                    // unjoin the existing class (if any) and join the new one
                    //
                    CmpUnJoinClassOfTrust(LoadedHive);
                    CmpJoinClassOfTrust(LoadedHive,OtherHive);
                    LoadedHive->Flags |= CM_CMHIVE_FLAG_UNTRUSTED;
                }
                Status = STATUS_SUCCESS;
            }
            CmpUnlockRegistry();
        }
        
        if( KeyHandle != NULL ) {
            ZwClose(KeyHandle);
        }
        return(Status);
    } else {
        //
        // we only need shared
        //
        CmpLockRegistry();
    }

    //
    // only one hive loading at a time (I can imagine getting rid of that, if needed)
    //
    LOCK_HIVE_LOAD();
    //
    // only this thread is allowed to use this hive for now.
    //
    NewHive->Hive.HiveFlags |= HIVE_IS_UNLOADING;
    NewHive->CreatorOwner = KeGetCurrentThread();
    //
    // if this is a NO_LAZY_FLUSH hive, set the appropriate bit.
    //
    if (Flags & REG_NO_LAZY_FLUSH) {
        NewHive->Hive.HiveFlags |= HIVE_NOLAZYFLUSH;
    }
    //
    // mark the hive as untrusted
    //
    NewHive->Flags |= CM_CMHIVE_FLAG_UNTRUSTED;
    if( OtherHive != NULL ) {
        //
        // join the same class of trust with the otherhive
        //
        CmpJoinClassOfTrust(NewHive,OtherHive);
    }
    //
    // We now have a succesfully loaded and initialized CmHive, so we
    // just need to link that into the appropriate spot in the master hive.
    //
    Status = CmpLinkHiveToMaster(TargetKey->ObjectName,
                                 TargetKey->RootDirectory,
                                 NewHive,
                                 Allocate,
                                 TargetKey->SecurityDescriptor);

    if (NT_SUCCESS(Status)) {
        //
        // add new hive to hivelist
        //
        CmpAddToHiveFileList(NewHive);
        //
        // flush the hive right here if just created; this is to avoid situations where 
        // the lazy flusher doesn't get a chance to flush the hive, or it can't (because
        // the hive is a no_lazy_flush hive and it is never explicitly flushed)
        // 
        if( Allocate == TRUE ) {
            CmpLockHiveFlusherExclusive(NewHive);
            HvSyncHive(&(NewHive->Hive));
            CmpUnlockHiveFlusher(NewHive);
        }
        //
        // allow others to use this hive
        //
        NewHive->Hive.HiveFlags &= (~HIVE_IS_UNLOADING);
        NewHive->CreatorOwner = NULL;
        UNLOCK_HIVE_LOAD();

    } else {
        LogHiveLoad((PHHIVE)NewHive,Status);

        CmpLockHiveListExclusive();
        CmpRemoveEntryList(&(NewHive->HiveList));
        CmpUnlockHiveList();

        UNLOCK_HIVE_LOAD();
#if DBG
        NewHive->HiveIsLoading = TRUE;
#endif
        CmpDestroyHiveViewList(NewHive);
        CmpDestroySecurityCache (NewHive);
        CmpDropFileObjectForHive(NewHive);
        CmpUnJoinClassOfTrust(NewHive);

        HvFreeHive((PHHIVE)NewHive);

        //
        // Close the hive files
        //
        CmpCmdHiveClose(NewHive);

        //
        // free the cm level structure
        //
        CmpFreeMutex(NewHive->ViewLock);
#if DBG
        CmpFreeResource(NewHive->FlusherLock);
#endif
        CmpFree(NewHive, sizeof(CMHIVE));
    }

    //
    // We've given user chance to log on, so turn on quota
    //
    if ((CmpProfileLoaded == FALSE) &&
        (CmpWasSetupBoot == FALSE)) {
        CmpProfileLoaded = TRUE;
        CmpSetGlobalQuotaAllowed();
    }

    CmpUnlockRegistry();

    if( KeyHandle != NULL ) {
        ZwClose(KeyHandle);
    }
    return(Status);
}

#if DBG
ULONG
CmpUnloadKeyWorker(
    PCM_KEY_CONTROL_BLOCK Current,
    PVOID                 Context1,
    PVOID                 Context2
    )
{
    PUNICODE_STRING ConstructedName;

    UNREFERENCED_PARAMETER (Context2);

    if (Current->KeyHive == Context1) {
        ConstructedName = CmpConstructName(Current);

        if (ConstructedName) {
            CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"%wZ\n", ConstructedName));
            ExFreePoolWithTag(ConstructedName, CM_NAME_TAG | PROTECTED_POOL);
        }
    }
    return KCB_WORKER_CONTINUE;   // always keep searching
}
#endif

NTSTATUS
CmUnloadKey(
    IN PCM_KEY_CONTROL_BLOCK    Kcb,
    IN ULONG                    Flags,
    IN ULONG                    ControlFlags
    )

/*++

Routine Description:

    Unlinks a hive from its location in the registry, closes its file
    handles, and deallocates all its memory.

    There must be no key control blocks currently referencing the hive
    to be unloaded.

Arguments:

    Hive - Supplies a pointer to the hive control structure for the
           hive to be unloaded

    Kcb - Supplies the key control block

    Flags - REG_FORCE_UNLOAD will first mark open handles as invalid 
            and then unload the hive.

    KcbLocked  - tells if the kcb is locked ex on entry

Return Value:

    NTSTATUS

--*/

{
    PCMHIVE         CmHive;
    LOGICAL         Success;
    PHHIVE          Hive;
    HCELL_INDEX     Cell;
    UNICODE_STRING  EntryName = {0};
    BOOLEAN         Remove = FALSE;
    BOOLEAN         KcbLocked = (ControlFlags & CM_UNLOAD_KCB_LOCKED)?TRUE:FALSE;
    BOOLEAN         RegLockedEx = (ControlFlags & CM_UNLOAD_REG_LOCKED_EX)?TRUE:FALSE;
    

    CmKdPrintEx((DPFLTR_CONFIG_ID,CML_CM,"CmUnloadKey\n"));

    // sanity
    ASSERT( (KcbLocked && CmpIsKCBLockedExclusive(Kcb) && CmpIsKCBLockedExclusive(Kcb->ParentKcb)) || (CmpTestRegistryLockExclusive() == TRUE) );

    Hive = Kcb->KeyHive;
    Cell = Kcb->KeyCell;
    //
    // Make sure the cell passed in is the root cell of the hive.
    //
    if((Cell != Hive->BaseBlock->RootCell) || ((PCMHIVE)Hive == CmpMasterHive)) {
        return(STATUS_INVALID_PARAMETER);
    }

    CmHive = CONTAINING_RECORD(Hive, CMHIVE, Hive);

    if( InterlockedCompareExchangePointer(&(CmHive->UnloadWorkItem),(PVOID)1,NULL) != NULL ) {
        //
        // work item has already been queued
        //
        return STATUS_TOO_LATE;
    }
    //
    // mark the hive as HIVE_IS_UNLOADING so no new kcbs are created within this hive.
    //
    Hive->HiveFlags |= HIVE_IS_UNLOADING;

    //
    // Make sure there are no open references to key control blocks
    // for this hive.  If there are none, then we can unload the hive.
    //
    if(Kcb->RefCount != 1) {
        if( Flags == REG_FORCE_UNLOAD ) {
            //
            // This will mark open handles as invalid. However, it may fail, so we
            // account for that possibility here.
            //
            if (CmpSearchForOpenSubKeys(Kcb, SearchAndDeref, RegLockedEx, NULL)) {
                Hive->HiveFlags &= (~HIVE_IS_UNLOADING);
                InterlockedCompareExchangePointer(&(CmHive->UnloadWorkItem),NULL,(PVOID)1);
                return STATUS_CANNOT_DELETE;
            }
        } else {
            Success = (CmpSearchForOpenSubKeys(Kcb, SearchIfExist, RegLockedEx, NULL) == 0);
            Success = Success && (Kcb->RefCount == 1);
        
            if( Success == FALSE) {
#if DBG
                if( KcbLocked ) {
                    ASSERT( Kcb->ParentKcb != NULL );
                    CmpUnlockTwoHashEntries(Kcb->ConvKey,Kcb->ParentKcb->ConvKey);
                }
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"List of keys open against hive unload was attempted on:\n"));
                CmpSearchKeyControlBlockTree(
                    CmpUnloadKeyWorker,
                    Hive,
                    NULL
                    );
                if( KcbLocked ) {
                    ASSERT( Kcb->ParentKcb != NULL );
                    CmpLockTwoHashEntriesExclusive(Kcb->ConvKey,Kcb->ParentKcb->ConvKey);
                }
#endif
                Hive->HiveFlags &= (~HIVE_IS_UNLOADING);
                InterlockedCompareExchangePointer(&(CmHive->UnloadWorkItem),NULL,(PVOID)1);
                return STATUS_CANNOT_DELETE;
            }
            ASSERT( Kcb->RefCount == 1 );
        }
    }

#if DBG
    CmHive->HiveIsLoading = TRUE;
#endif
    //
    // Flush any dirty data to disk. If this fails, too bad.
    //
    CmFlushKey(Kcb,TRUE);

    //
    // get the hive name for later removal
    //
    if( CmpGetHiveName(CmHive, &EntryName) ) {
        Remove = TRUE;
    }
    //
    // Unlink from master hive, remove from list
    //
    Success = CmpDestroyHive(Hive, Cell);

    if (Success) {
        //
        // signal the user event (if any), then do the cleanup (i.e. deref the event
        // and the artificial refcount we set on the root kcb)
        //

        //
        // mark all key_bodies invalid
        //
        if( Flags == REG_FORCE_UNLOAD ) {
            CmpFlushNotifiesOnKeyBodyList(Kcb,TRUE);
        }
        Kcb->Delete = TRUE;
        //
        // If the parent has the subkey info or hint cached, free it.
        //
        CmpCleanUpSubKeyInfo(Kcb->ParentKcb);
        CmpRemoveKeyControlBlock(Kcb);

        //
        // no need to hold the lock anymore
        //

        if( KcbLocked ) {
            ASSERT( Kcb->ParentKcb != NULL );
            CmpUnlockTwoHashEntries(Kcb->ConvKey,Kcb->ParentKcb->ConvKey);
            UNLOCK_HIVE_LOAD();
        }
        CmpUnlockRegistry();

        if( Remove ) {
            //
            // Remove the hive from the HiveFileList
            //
            CmpRemoveFromHiveFileList(&EntryName);
        }
        if( CmHive->UnloadEvent != NULL ) {
            KeSetEvent(CmHive->UnloadEvent,0,FALSE);
            ObDereferenceObject(CmHive->UnloadEvent);
        }

        CmpDestroyHiveViewList(CmHive);
        CmpDestroySecurityCache (CmHive);
        CmpDropFileObjectForHive(CmHive);
        KeEnterCriticalRegion();
        CmpUnJoinClassOfTrust(CmHive);
        KeLeaveCriticalRegion();

        HvFreeHive(Hive);

        //
        // Close the hive files
        //
        CmpCmdHiveClose(CmHive);

        //
        // free the cm level structure
        //
        CmpFreeMutex(CmHive->ViewLock);
#if DBG
        CmpFreeResource(CmHive->FlusherLock);
#endif
        CmpFree(CmHive, sizeof(CMHIVE));

        RtlFreeUnicodeString(&EntryName);
        return(STATUS_SUCCESS);
    } else {
        Hive->HiveFlags &= (~HIVE_IS_UNLOADING);
        InterlockedCompareExchangePointer(&(CmHive->UnloadWorkItem),NULL,(PVOID)1);
#if DBG
        CmHive->HiveIsLoading = FALSE;
#endif
        RtlFreeUnicodeString(&EntryName);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

}

NTSTATUS
CmUnloadKeyEx(
    IN PCM_KEY_CONTROL_BLOCK kcb,
    IN PKEVENT UserEvent
    )

/*++

Routine Description:

    First tries to unlink the hive, by calling the sync version
    
    If the hive cannot be unloaded (there are open handles inside it),
    reference the root of the hive (i.e. kcb) and freeze the hive.

Arguments:

    