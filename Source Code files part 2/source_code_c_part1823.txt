DebugExitVOID(OSIInjectMouseEvent16);
}



//
// OSIInjectKeyboardEvent16()
//
void WINAPI OSIInjectKeyboardEvent16
(
    UINT    flags,
    WORD    vkCode,
    WORD    scanCode,
    DWORD   dwExtraInfo
)
{
    DebugEntry(OSIInjectKeyboardEvent16);

    //
    // First, fix up the flags
    //
    if (flags & KEYEVENTF_KEYUP)
    {
        // Put 0x80 in the HIBYTE of vkCode, this means a keyup
        vkCode = (WORD)(BYTE)vkCode | USERKEYEVENTF_KEYUP;
    }

    if (flags & KEYEVENTF_EXTENDEDKEY)
    {                         
        // Put 0x01 in the HIBYTE of scanCode, this means extended
        scanCode = (WORD)(BYTE)scanCode | USERKEYEVENTF_EXTENDEDKEY;
    }

    //
    // We disable interrupts, call the real keybd_event, reenable
    // interrupts.  That way our keybd_event patch is serialized.
    // And we can check the imfInject variable.
    //
    IMInject(TRUE);
    CallKeyboardEvent(vkCode, scanCode, LOWORD(dwExtraInfo), HIWORD(dwExtraInfo));
    IMInject(FALSE);

    DebugExitVOID(OSIInjectKeyboardEvent16);
}



//
// Win16lock pulse points when injecting mouse down/up sequences into 16-bit
// modal loop apps.
//


//
// IMCheckWin16LockPulse()
// This pulses the win16lock if we are in the middle of injecting a mouse
// down-up sequence to a 16-bit app shared on this machine.  We do this to
// prevent deadlock, caused by 16-bit dudes going into modal loops, not
// releasing the win16lock.  Our 32-bit thread would get stuck on the win16
// lock trying to play back the rest of the sequence.
//
void IMCheckWin16LockPulse(void)
{
    DebugEntry(IMCheckWin16LockPulse);

    if ((g_imMouseDowns > 0) &&
        (GetProcessDword(0, GPD_FLAGS) & GPF_WIN16_PROCESS))
    {
        TRACE_OUT(("Pulsing win16lock for 16-bit app; mouse down count %d", g_imMouseDowns));

        _LeaveWin16Lock();
        _EnterWin16Lock();

        TRACE_OUT(("Pulsed win16lock for 16-bit app; mouse down count %d", g_imMouseDowns));
    }

    DebugExitVOID(IMCheckWin16LockPulse);
}



int WINAPI DrvGetAsyncKeyState(int vk)
{
    int     retVal;

    DebugEntry(DrvGetAsyncKeyState);

    // Pulse BEFORE we call to USER
    IMCheckWin16LockPulse();

    EnableFnPatch(&g_imPatches[IM_GETASYNCKEYSTATE], PATCH_DISABLE);
    retVal = GetAsyncKeyState(vk);
    EnableFnPatch(&g_imPatches[IM_GETASYNCKEYSTATE], PATCH_ENABLE);

    DebugExitBOOL(DrvGetAsyncKeyState, retVal);
    return(retVal);
}



//
// DrvGetCursorPos()
//
BOOL WINAPI DrvGetCursorPos(LPPOINT lppt)
{
    BOOL    retVal;

    DebugEntry(DrvGetCursorPos);

    // Pulse BEFORE calling USER
    IMCheckWin16LockPulse();

    EnableFnPatch(&g_imPatches[IM_GETCURSORPOS], PATCH_DISABLE);
    retVal = RealGetCursorPos(lppt);
    EnableFnPatch(&g_imPatches[IM_GETCURSORPOS], PATCH_ENABLE);

    DebugExitBOOL(DrvGetCursorPos, retVal);
    return(retVal);
}


//
// DrvMouseEvent()
// mouse_event interrupt patch
//
void WINAPI DrvMouseEvent
(
    UINT    regAX,
    UINT    regBX,
    UINT    regCX,
    UINT    regDX,
    UINT    regSI,
    UINT    regDI
)
{
    BOOL    fAllow;

    //
    // If this is injected by us, just pass it through.
    //
    fAllow = TRUE;
    if (g_imWin95Data.imInjecting)
    {
        DC_QUIT;
    }

    //
    // NOTE:
    //      flags is in     AX
    //      x coord is in   BX
    //      y coord is in   CX
    //      mousedata is in DX
    //      dwExtraInfo is in DI, SI
    //

    if (g_imSharedData.imControlled && !g_imSharedData.imPaused)
    {
        //
        // If this is a button click, take control back
        //
        if (regAX &
            (MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_RIGHTDOWN | MOUSEEVENTF_MIDDLEDOWN))
        {
            if (!g_imSharedData.imUnattended)
            {
                PostMessage(g_asMainWindow, DCS_REVOKECONTROL_MSG, FALSE, 0);
            }
        }

        if (!g_imSharedData.imSuspended)
            fAllow = FALSE;
    }

DC_EXIT_POINT:
    if (fAllow)
    {
        EnableFnPatch(&g_imPatches[IM_MOUSEEVENT], PATCH_DISABLE);
        CallMouseEvent(regAX, regBX, regCX, regDX, regSI, regDI);
        EnableFnPatch(&g_imPatches[IM_MOUSEEVENT], PATCH_ENABLE);
    }
}


//
// DrvKeyboardEvent()
// keybd_event interrupt patch
//
void WINAPI DrvKeyboardEvent
(
    UINT    regAX,
    UINT    regBX,
    UINT    regSI,
    UINT    regDI
)
{
    BOOL    fAllow;

    //
    // If this is injected by us, pass it through.  Do the same for
    // critical errors, since everything is frozen and we can't play back
    // input if we wanted to.
    //
    // If the scan-code (in regBX) is 0 we assume that the input
    // is injected by an application (such as an IME) and we don't
    // want to block this or take control.
    //

    fAllow = TRUE;
    if (g_imWin95Data.imInjecting || !regBX)
    {
        DC_QUIT;
    }

    //
    // NOTE:
    //      vkCode is in    AX, LOBYTE is vkCode, HIBYTE is state
    //      scanCode is in  BX
    //      dwExtraInfo is in   DI, SI
    //

    if (g_imSharedData.imControlled && !g_imSharedData.imPaused)
    {
        if (!(regAX & USERKEYEVENTF_KEYUP))
        {
            //
            // This is a key down.  Take control back (except for ALT key),
            // and kill control allowability if it's the ESC key.
            //

            if (LOBYTE(regAX) == VK_ESCAPE)
            {
                PostMessage(g_asMainWindow, DCS_ALLOWCONTROL_MSG, FALSE, 0);
            }
            else if (LOBYTE(regAX != VK_MENU))
            {
                if (!g_imSharedData.imUnattended)
                {
                    PostMessage(g_asMainWindow, DCS_REVOKECONTROL_MSG, 0, 0);
                }
            }
        }

        //
        // Don't discard toggle keys.  The enabled/disabled function
        // is already set before we see the keystroke.  If we discard,
        // the lights are incorrect.
        //
        if (!IM_KEY_IS_TOGGLE(LOBYTE(regAX)) && !g_imSharedData.imSuspended)
        {
            fAllow = FALSE;
        }
    }

DC_EXIT_POINT:
    if (fAllow)
    {
        EnableFnPatch(&g_imPatches[IM_KEYBOARDEVENT], PATCH_DISABLE);
        CallKeyboardEvent(regAX, regBX, regSI, regDI);
        EnableFnPatch(&g_imPatches[IM_KEYBOARDEVENT], PATCH_ENABLE);
    }
}



//
// DrvSignalProc32()
// This patches USER's SignalProc32 export and watches for the FORCE_LOCK
// signals.  KERNEL32 calls them before/after putting up critical error and
// fault dialogs.  That's how we know when one is coming up, and can 
// temporarily suspend remote control of your machine so you can dismiss
// them.  Usually the thread they are on is boosted so high priority that
// nothing else can run, and so NM can't pump in input from the remote.
//
BOOL WINAPI DrvSignalProc32
(
    DWORD   dwSignal,
    DWORD   dwID,
    DWORD   dwFlags,
    WORD    hTask16
)
{
    BOOL    fRet;

    DebugEntry(DrvSignalProc32);

    if (dwSignal == SIG_PRE_FORCE_LOCK)
    {
        TRACE_OUT(("Disabling remote control before critical dialog, count %ld",
            g_imSharedData.imSuspended));
        ++g_imSharedData.imSuspended;
    }

    EnableFnPatch(&g_imPatches[IM_SIGNALPROC32], PATCH_DISABLE);
    fRet = SignalProc32(dwSignal, dwID, dwFlags, hTask16);
    EnableFnPatch(&g_imPatches[IM_SIGNALPROC32], PATCH_ENABLE);

    if (dwSignal == SIG_POST_FORCE_LOCK)
    {
        --g_imSharedData.imSuspended;
        TRACE_OUT(("Enabling remote control after critical dialog, count %ld",
            g_imSharedData.imSuspended));
    }

    DebugExitBOOL(DrvSignalProc32, fRet);
    return(fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\as16\oa.c ===
//
// OA.C
// Order Accumulator
//
// Copyright(c) Microsoft 1997-
//

#include <as16.h>


#ifdef DEBUG
//
// We use this to make sure our order heap list is committed in the order 
// the items were allocated in.
//
// NOTE:
// Can't make this CODESEG.  USER in Win95 has a bug, the validation layer
// for CopyRect() got the parameters reversed, and it won't continue
// if the SOURCE (it meant the DEST) rect isn't writeable.
//
static RECT g_oaEmptyRect = { 0x7FFF, 0x7FFF, 0, 0 };

#endif // DEBUG

//
// OA_DDProcessRequest()
// Handles OA escapes
//
BOOL OA_DDProcessRequest
(
    UINT                fnEscape,
    LPOSI_ESCAPE_HEADER pRequest,
    DWORD               cbRequest
)
{
    BOOL                rc = TRUE;

    DebugEntry(OA_DDProcessRequest);

    switch (fnEscape)
    {
        case OA_ESC_FLOW_CONTROL:
        {
            ASSERT(cbRequest == sizeof(OA_FLOW_CONTROL));

            // Save new throughput measurement
            g_oaFlow = ((LPOA_FLOW_CONTROL)pRequest)->oaFlow;
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognized OA escape"));
            rc = FALSE;
        }
        break;
    }

    DebugExitBOOL(OA_DDProcessRequest, rc);
    return(rc);
}



//
//
// OA_DDAddOrder(..)
//
// Adds an order to the queue for transmission.
//
// If the new order is completetly covered by the current SDA then
// it is spoilt.
//
// If the order is opaque and overlaps earlier orders it may clip
// or spoil them.
//
// Called by the GDI interception code.
//
//
void  OA_DDAddOrder(LPINT_ORDER pNewOrder, void FAR * pExtraInfo)
{
    RECT      SDARects[BA_NUM_RECTS*2];
    UINT      cBounds;
    UINT      spoilingBounds;
    UINT      totalBounds;
    UINT      i;
    RECT      SrcRect;
    RECT      tmpRect;
    BOOL      gotBounds = FALSE;
    int       dx;
    int       dy;
    RECT      IntersectedSrcRect;
    RECT      InvalidDstRect;
    LPINT_ORDER  pTmpOrder;
    LPEXTTEXTOUT_ORDER  pExtTextOut;
    LPOA_FAST_DATA  lpoaFast;
    LPOA_SHARED_DATA lpoaShared;

    DebugEntry(OA_DDAddOrder);

    lpoaShared = OA_SHM_START_WRITING;
    lpoaFast   = OA_FST_START_WRITING;

    //
    // Accumulate order accumulation rate.  We are interested in how
    // quickly orders are being added to the buffer, so that we can tell
    // DCS scheduling whether frequent sends are advisable
    //
    SHM_CheckPointer(lpoaFast);
    lpoaFast->ordersAccumulated++;

    //
    // If the order is a private one, then we just add it to the Order
    // List and return immediately.
    //
    // Private Orders are used to send bitmap cache information (bitmap
    // bits and color tables).
    //
    // Private Orders never spoil any others and must never be spoilt.
    //
    if (pNewOrder->OrderHeader.Common.fOrderFlags & OF_PRIVATE)
    {
        TRACE_OUT(("Add private order (%lx)", pNewOrder));
        OADDAppendToOrderList(lpoaShared, pNewOrder);
        DC_QUIT;
    }

    //
    // If this order is spoilable and its is completely enclosed by the
    // current screen data area, we can spoil it.  Unless...
    //
    // PM - Performance
    //
    // We have observed in usability testing that clipping orders always
    // degrades the end-user's perceived performance.  This is because the
    // orders flow much faster than the screendata and tend to relate to
    // text, which is what the user really wants to see.  For example, text
    // overwriting a bitmap will be delayed because we want to send the
    // bitmap as screendata.
    //
    // Also, word documents tend to contain sections of screendata due to
    // mismatched fonts, intelliquotes, spelling annotation, current line
    // memblit.  Nothing we can do about this, but if we page down two or
    // three times, or down and up again we get an accumulation of the
    // screendata on all the pages spoiling the orders and the end result
    // is that we have to wait longer than we would if we had not spoiled
    // the orders.
    //
    // So, what we can do instead is leave the text orders in and overwrite
    // them with screendata when it gets through.  However, to make this
    // really effective what we also do is convert any transparent text
    // (as WEB browsers tend to use) into opaque text on a default
    // background.
    //
    //
    if ((pNewOrder->OrderHeader.Common.fOrderFlags & OF_SPOILABLE) != 0)
    {
        //
        // Get the driver's current bounds.
        //
        BA_CopyBounds(SDARects, &cBounds, FALSE);
        gotBounds = TRUE;

        for (i = 0; i < cBounds; i++)
        {
            if ( OADDCompleteOverlapRect(&pNewOrder->OrderHeader.Common.rcsDst,
                                      &(SDARects[i])) )
            {
                //
                // The destination of the order is completely covered by
                // the SDA.  Check for a text order.
                //
                pExtTextOut = (LPEXTTEXTOUT_ORDER)pNewOrder->abOrderData;
                if (pExtTextOut->type == ORD_EXTTEXTOUT_TYPE)
                {
                    //
                    // The order is going to be completely overwritten so
                    // we can play around with it all we like.
                    // Just make it opaque so the user can read it while
                    // waiting for the screendata to follow on.
                    //
                    pExtTextOut->fuOptions |= ETO_OPAQUE;

                    //
                    // pExtTextOut->rectangle is a TSHR_RECT32
                    //
                    pExtTextOut->rectangle.left = pNewOrder->OrderHeader.Common.rcsDst.left;
                    pExtTextOut->rectangle.top = pNewOrder->OrderHeader.Common.rcsDst.top;
                    pExtTextOut->rectangle.right = pNewOrder->OrderHeader.Common.rcsDst.right;
                    pExtTextOut->rectangle.bottom = pNewOrder->OrderHeader.Common.rcsDst.bottom;

                    TRACE_OUT(("Converted text order to opaque"));
                    break;
                }
                else
                {
                    TRACE_OUT(("Spoiling order %08lx by SDA", pNewOrder));
                    OA_DDFreeOrderMem(pNewOrder);
                    DC_QUIT;
                }
            }
        }
    }

    //
    // Pass the order onto the Bitmap Cache Controller to try to cache the
    // src bitmap.
    //
    if (ORDER_IS_MEMBLT(pNewOrder) || ORDER_IS_MEM3BLT(pNewOrder))
    {
        ERROR_OUT(("MEMBLT orders not supported!"));
    }

    if (ORDER_IS_SCRBLT(pNewOrder))
    {
        //
        //
        // Handle Screen to Screen (SS) bitblts.
        //
        // The basic plan
        // --------------
        //
        // If the source of a screen to screen blt intersects with the
        // current SDA then we have to do some additional work because all
        // orders are always executed before the SDA is copied.  This means
        // that the data within the SDA will not be available at the time
        // we want to do the SS blt.
        //
        // In this situation we adjust the SS blt to remove all overlap
        // from the src rectangle.  The destination rectangle is adjusted
        // accordingly.  The area removed from the destination rectangle is
        // added into the SDA.
        //
        //
        TRACE_OUT(("Handle SS blt(%lx)", pNewOrder));

        //
        // Make the order non-spoilable because we don't want the adding
        // of screen data to delete the order.
        //
        pNewOrder->OrderHeader.Common.fOrderFlags &= ~OF_SPOILABLE;

        //
        // Calculate the src rect.
        //
        SrcRect.left = ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nXSrc;
        SrcRect.right = SrcRect.left +
                        ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nWidth - 1;
        SrcRect.top = ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nYSrc;
        SrcRect.bottom = SrcRect.top +
                       ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nHeight - 1;

        //
        //
        // ORIGINAL SCRBLT SCHEME
        // ----------------------
        //
        // If the source rectangle intersects the current Screen Data Area
        // (SDA) then the src rectangle is modified so that no there is no
        // intersection with the SDA, and the dst rectangle adjusted
        // accordingly (this is the theory - in practice the operation
        // remains the same and we just adjust the dst clip rectangle).
        // The destination area that is removed is added into the SDA.
        //
        // The code works, but can result in more screen data being sent
        // than is required.
        //
        // e.g.
        //
        // Operation:
        //
        //      SSSSSS      DDDDDD
        //      SSSSSS  ->  DDDDDD
        //      SSSSSS      DDDDDD
        //      SxSSSS      DDDDDD
        //
        //      S - src rect
        //      D - dst rect
        //      x - SDA overlap
        //
        // The bottom edge of the blt is trimmed off, and the corresponding
        // destination area added into the SDA.
        //
        //      SSSSSS      DDDDDD
        //      SSSSSS  ->  DDDDDD
        //      SSSSSS      DDDDDD
        //                  xxxxxx
        //
        //
        //
        // NEW SCRBLT SCHEME
        // ------------------
        //
        // The new scheme does not modify the blt rectangles, and just
        // maps the SDA overlap to the destination rect and adds that
        // area back into the SDA.
        //
        // e.g. (as above)
        //
        // Operation:
        //
        //      SSSSSS      DDDDDD
        //      SSSSSS  ->  DDDDDD
        //      SSSSSS      DDDDDD
        //      SxSSSS      DDDDDD
        //
        //      S - src rect
        //      D - dst rect
        //      x - SDA overlap
        //
        // The blt operation remains the same, but the overlap area is
        // mapped to the destination rectangle and added into the SDA.
        //
        //      SSSSSS      DDDDDD
        //      SSSSSS  ->  DDDDDD
        //      SSSSSS      DDDDDD
        //      SxSSSS      DxDDDD
        //
        //
        // This scheme results in a smaller SDA area. However, this scheme
        // does blt potentially invalid data to the destination - which
        // may briefly be visible at the remote machine (because orders
        // are replayed before Screen Data). This has not (yet) proved to
        // be a problem.
        //
        // The main benefit of the new scheme is when scrolling an area
        // that includes a small SDA.
        //
        //                                         new         old
        //                                        scheme      scheme
        //
        //     AAAAAAAA                          AAAAAAAA    AAAAAAAA
        //     AAAAAAAA                          AAAxAAAA    xxxxxxxx
        //     AAAAAAAA  scroll up 3 times ->    AAAxAAAA    xxxxxxxx
        //     AAAAAAAA                          AAAxAAAA    xxxxxxxx
        //     AAAxAAAA                          AAAxAAAA    xxxxxxxx
        //
        //
        //
        if (!gotBounds)
        {
            //
            // Get the driver's current bounds.
            //
            BA_CopyBounds(SDARects, &cBounds, FALSE);
        }

        //
        // Now get any bounds which the share core is currently processing.
        // We have to include these bounds when we are doing the above
        // processing to avoid a situation where the core grabs the screen
        // data from the source of a ScrBlt after the source has been
        // updated by another order.
        //
        // e.g.  If there is no driver SDA, but the core is processing the
        // area marked 'c'...
        //
        // If we ignore the core SDA, we queue a ScrBlt order which does
        // the following.
        //
        //      SSSSSS      DDDDDD
        //      SccccS  ->  DDDDDD
        //      SccccS      DDDDDD
        //      SSSSSS      DDDDDD
        //
        // However, if another order (marked 'N') is accumulated before
        // the core grabs the SDA, we end up with the shadow doing the
        // following
        //
        //      SSSSSS      DDDDDD
        //      ScNNcS  ->  DDNNDD
        //      ScNNcS      DDNNDD
        //      SSSSSS      DDDDDD
        //
        // i.e. the new order gets copied to the destination of the ScrBlt.
        // So, the ScrBlt order must be processed as
        //
        //      SSSSSS      DDDDDD
        //      SccccS  ->  DxxxxD
        //      SccccS      DxxxxD
        //      SSSSSS      DDDDDD
        //
        //
        BA_QuerySpoilingBounds(&SDARects[cBounds], &spoilingBounds);
        totalBounds = cBounds + spoilingBounds;

        //
        //
        // This is the new SCRBLT handler.
        //
        //
        for (i = 0; i < totalBounds ; i++)
        {
            if ( (SrcRect.left >= SDARects[i].left) &&
                 (SrcRect.right <= SDARects[i].right) &&
                 (SrcRect.top >= SDARects[i].top) &&
                 (SrcRect.bottom <= SDARects[i].bottom) )
            {
                //
                // The src of the SS blt is completely within the SDA.  We
                // must add in the whole destination rectangle into the SDA
                // and spoil the SS blt.
                //
                TRACE_OUT(("SS blt src within SDA - spoil it"));

                RECT_FROM_TSHR_RECT16(&tmpRect,
                                        pNewOrder->OrderHeader.Common.rcsDst);
                OA_DDFreeOrderMem(pNewOrder);
                BA_AddScreenData(&tmpRect);
                DC_QUIT;
            }

            //
            // Intersect the src rect with the SDA rect.
            //
            IntersectedSrcRect.left = max( SrcRect.left,
                                              SDARects[i].left );
            IntersectedSrcRect.right = min( SrcRect.right,
                                               SDARects[i].right );
            IntersectedSrcRect.top = max( SrcRect.top,
                                             SDARects[i].top );
            IntersectedSrcRect.bottom = min( SrcRect.bottom,
                                                SDARects[i].bottom );

            dx = ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nLeftRect -
                   ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nXSrc;
            dy = ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nTopRect -
                   ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nYSrc;

            InvalidDstRect.left   = IntersectedSrcRect.left + dx;
            InvalidDstRect.right  = IntersectedSrcRect.right + dx;
            InvalidDstRect.top    = IntersectedSrcRect.top + dy;
            InvalidDstRect.bottom = IntersectedSrcRect.bottom + dy;

            //
            // Intersect the invalid destination rectangle with the
            // destination clip rectangle.
            //
            InvalidDstRect.left = max(
                                InvalidDstRect.left,
                                pNewOrder->OrderHeader.Common.rcsDst.left );
            InvalidDstRect.right = min(
                                InvalidDstRect.right,
                                pNewOrder->OrderHeader.Common.rcsDst.right );
            InvalidDstRect.top = max(
                                InvalidDstRect.top,
                                pNewOrder->OrderHeader.Common.rcsDst.top );
            InvalidDstRect.bottom = min(
                                InvalidDstRect.bottom,
                                pNewOrder->OrderHeader.Common.rcsDst.bottom );

            if ( (InvalidDstRect.left <= InvalidDstRect.right) &&
                 (InvalidDstRect.top <= InvalidDstRect.bottom) )
            {
                //
                // Add the invalid area into the SDA.
                //
                TRACE_OUT(("Sending SDA {%d, %d, %d, %d}", InvalidDstRect.left,
                    InvalidDstRect.top, InvalidDstRect.right, InvalidDstRect.bottom));
                BA_AddScreenData(&InvalidDstRect);
            }

        } // for (i = 0; i < totalBounds ; i++)

        //
        // Make the order spoilable again (this assumes that all SS blts
        // are spoilable.
        //
        pNewOrder->OrderHeader.Common.fOrderFlags |= OF_SPOILABLE;

    } // if (ORDER_IS_SCRBLT(pNewOrder))

    else if ((pNewOrder->OrderHeader.Common.fOrderFlags & OF_DESTROP) != 0)
    {
        //
        // This is the case where the output of the order depends on the
        // existing contents of the target area (e.g.  an invert).
        //
        // What we have to do here is to add any parts of the destination
        // of this order which intersect the SDA which the share core is
        // processing to the driver SDA.  The reason for this is the same
        // as the SCRBLT case - the share core may grab the data from the
        // screen after we have applied this order (e.g.  after we have
        // inverted an area of the screen), then send the order as well
        // (re-inverting the area of the screen).
        //
        // Note that we only have to worry about the SDA which the share
        // core is processing - we can ignore the driver's SDA.
        //
        TRACE_OUT(("Handle dest ROP (%#.8lx)", pNewOrder));

        BA_QuerySpoilingBounds(SDARects, &spoilingBounds);
        for (i = 0; i < spoilingBounds ; i++)
        {
            //
            // Intersect the dest rect with the share core SDA rect.
            //
            InvalidDstRect.left = max(
                                SDARects[i].left,
                                pNewOrder->OrderHeader.Common.rcsDst.left );
            InvalidDstRect.right = min(
                                SDARects[i].right,
                                pNewOrder->OrderHeader.Common.rcsDst.right );
            InvalidDstRect.top = max(
                                SDARects[i].top,
                                pNewOrder->OrderHeader.Common.rcsDst.top );
            InvalidDstRect.bottom = min(
                                SDARects[i].bottom,
                                pNewOrder->OrderHeader.Common.rcsDst.bottom );

            if ( (InvalidDstRect.left <= InvalidDstRect.right) &&
                 (InvalidDstRect.top <= InvalidDstRect.bottom) )
            {
                //
                // Add the invalid area into the SDA.
                //
                TRACE_OUT(("Sending SDA {%d, %d, %d, %d}",
                             InvalidDstRect.left,
                             InvalidDstRect.top,
                             InvalidDstRect.right,
                             InvalidDstRect.bottom));
                BA_AddScreenData(&InvalidDstRect);
            }
        }
    }

    //
    // Add the new order to the end of the Order List.
    //
    OADDAppendToOrderList(lpoaShared, pNewOrder);
    TRACE_OUT(("Append order(%lx) to list", pNewOrder));

    //
    // Now see if this order spoils any existing orders
    //
    if (pNewOrder->OrderHeader.Common.fOrderFlags & OF_SPOILER)
    {
        //
        // Its a spoiler, so try to spoil with it.
        //
        // We have to pass in the bounding rectangle of the order, and the
        // first order to try to spoil to OADDSpoilFromOrder.  The first
        // order to try to spoil is the one before the new order.
        //
        RECT_FROM_TSHR_RECT16(&tmpRect,
                                pNewOrder->OrderHeader.Common.rcsDst);

        pTmpOrder = COM_BasedListPrev(&lpoaShared->orderListHead, pNewOrder,
            FIELD_OFFSET(INT_ORDER, OrderHeader.list));

        OADDSpoilFromOrder(lpoaShared, pTmpOrder, &tmpRect);
    }

    //
    // This is where the Win95 product would call DCS_TriggerEarlyTimer.
    //

DC_EXIT_POINT:
    OA_FST_STOP_WRITING;
    OA_SHM_STOP_WRITING;
    DebugExitVOID(OA_DDAddOrder);
}

//
//
// FUNCTION: OA_DDAllocOrderMem
//
// DESCRIPTION:
//
// Allocates memory for an internal order structure from our own private
// Order Heap.
//
// Allocates any Additional Order Memory from global memory.  A pointer to
// the Additional Order Memory is stored within the allocated order's
// header (pOrder->OrderHeader.pAdditionalOrderData).
//
//
// PARAMETERS:
//
// cbOrderDataLength - length in bytes of the order data to be allocated
// from the Order Heap.
//
// cbAdditionalOrderDataLength - length in bytes of additional order data
// to be allocated from Global Memory.  If this parameter is zero no
// additional order memory is allocated.
//
//
// RETURNS:
//
// A pointer to the allocated order memory.  NULL if the memory allocation
// failed.
//
//
//
LPINT_ORDER  OA_DDAllocOrderMem(UINT cbOrderDataLength, UINT cbAdditionalOrderDataLength)
{
    LPINT_ORDER  pOrder = NULL;
    LPINT_ORDER  pFirstOrder;
    LPINT_ORDER  pTailOrder;
    RECT        tferRect;
    LONG        targetSize;
    DWORD       moveOffset;
    DWORD       moveBytes;
    LPINT_ORDER  pColorTableOrder = NULL;
    LPBYTE     pNextOrderPos;
    LPOA_SHARED_DATA    lpoaShared;

    DebugEntry(OA_DDAllocOrderMem);

    lpoaShared = OA_SHM_START_WRITING;

    //
    // PM Performance
    //
    // Although turning order accumulation off does clear the pipe, ready
    // for us to get the screendata over the wire as soon as we can, it
    // actually hinders end-user responsiveness because they see a longer
    // interval when nothing is happening, rather than getting feedback
    // that we are busy and the whole thing taking longer!
    //
    // So, what we do when we fill up the order buffer is we discard half
    // the orders in the buffer, adding them to the screendata.  In this
    // way we will always keep between 50 and 100% of the orders for the
    // final updates to the window, which hopefully will be what the user
    // really wants to see.
    //
    // If the orders keep coming then we will keep on accumulating some,
    // sending them, discarding others until things quiet down, at which
    // point we will flush out our order buffer.
    //
    // When we come to flush the order buffer we also spoil the early ones
    // against screendata, so that we only have the final set of orders to
    // replay.  We control the size of this final non-spoiled set depending
    // on whether we are running over a high or low speed connection.
    // Also, if we did not encounter any back pressure during the session
    // then we do not purge any orders at all, preferring to send
    // everything we possibly can as orders.
    //
    // Note that this approach assumes that we do not spoil all orders
    // against screendata on the fly because that leads to us generally
    // sending out-of-data orders followed by up-to-date screendata, which
    // is exactly what we do not want to see.
    //
    //

    CheckOaHeap(lpoaShared);

    //
    // First check that we have not already exceeded our high water mark
    // recommended by flow control.  If we have then purge half the queue
    // so we have space to accumulate the later, more valuable, orders
    //
    // Note that this does not guarantee that we will have less orders
    // accumulated than the limit set by flow control.  However, if enough
    // orders are generated, we will come through this branch on each order
    // and finally reduce to below the imposed limit.
    //
    SHM_CheckPointer(&lpoaShared->totalOrderBytes);

    if (g_oaPurgeAllowed && (lpoaShared->totalOrderBytes >
        (DWORD)(g_oaFlow == OAFLOW_FAST ? OA_FAST_HEAP : OA_SLOW_HEAP)))
    {
        RECT        aRects[BA_NUM_RECTS];
        UINT        numRects;
        UINT        i;

        WARNING_OUT(("Purging orders; total 0x%08x is greater than heap 0x%08x",
            lpoaShared->totalOrderBytes,
            (DWORD)(g_oaFlow == OAFLOW_FAST ? OA_FAST_HEAP : OA_SLOW_HEAP)));

        //
        // If we need to make room for the new order then purge half the
        // current queue.  We do this so we end up with the most recent
        // orders on the queue, rather than the oldest.
        //
        targetSize = lpoaShared->totalOrderBytes / 2;
        TRACE_OUT(("Target size %ld", targetSize));

        //
        // Iterate through the list until we have found the first order
        // beyond the limit to be destroyed.  Once we have got this order,
        // we can shuffle the list over the useless orders.
        //
        pOrder = COM_BasedListFirst(&lpoaShared->orderListHead,
            FIELD_OFFSET(INT_ORDER, OrderHeader.list));

        pTailOrder = (LPINT_ORDER)COM_BasedPrevListField(&lpoaShared->orderListHead);

        //
        // If we hit this condition, we have to have at least one order
        // pending, so these both must be non NULL.
        //
        SHM_CheckPointer(pOrder);
        SHM_CheckPointer(pTailOrder);

        TRACE_OUT(("Order 0x%08lx, tail 0x%08lx", pOrder, pTailOrder));

        //
        // Disable spoiling of existing orders by screen data while we do
        // the purge otherwise we may try to spoil an order which we are
        // purging !
        //
        g_baSpoilByNewSDAEnabled = FALSE;

        while ((pOrder != NULL) && (targetSize > 0))
        {
            //
            // Can't check at end; COM_BasedListNext may return NULL and
            // SHM_CheckPointer doesn't like that.
            //
            SHM_CheckPointer(pOrder);

            //
            // Check to see if this is an internal color table order.  If
            // it is, the OF_INTERNAL flag will be set.
            //
            // MemBlt orders rely on being preceeded by a color table order
            // to set up the colors correctly.  If we purge all the color
            // table orders, the following Mem(3)Blts will get the wrong
            // colors.  So, we have to keep track of the last color table
            // order to be purged and then add it back into the order heap
            // later.
            //
            if ((pOrder->OrderHeader.Common.fOrderFlags & OF_INTERNAL) != 0)
            {
                TRACE_OUT(("Found color table order at %#.8lx", pOrder));
                pColorTableOrder = pOrder;
            }
            else
            {
                //
                // Add the order to the Screen Data Area
                //
                TRACE_OUT(("Purging orders. Add rect to SDA {%d, %d, %d, %d}",
                             pOrder->OrderHeader.Common.rcsDst.left,
                             pOrder->OrderHeader.Common.rcsDst.top,
                             pOrder->OrderHeader.Common.rcsDst.right,
                             pOrder->OrderHeader.Common.rcsDst.bottom));

                RECT_FROM_TSHR_RECT16(&tferRect,
                                        pOrder->OrderHeader.Common.rcsDst);
                BA_AddScreenData(&tferRect);
            }

            //
            // Keep track of how much data still needs removing.
            //
            targetSize                 -= INT_ORDER_SIZE(pOrder);

            lpoaShared->totalHeapOrderBytes -= INT_ORDER_SIZE(pOrder);
            TRACE_OUT(("Total heap order bytes: %ld",
                lpoaShared->totalHeapOrderBytes));

            lpoaShared->totalOrderBytes     -= MAX_ORDER_SIZE(pOrder);
            TRACE_OUT(("Total order bytes: %ld",
                lpoaShared->totalOrderBytes));

            //
            // If the order is a Mem(3)Blt, we have to tell SBC that we are
            // getting rid of it.
            //
            if (ORDER_IS_MEMBLT(pOrder) || ORDER_IS_MEM3BLT(pOrder))
            {
                ERROR_OUT(("MEMBLT orders not supported!"));
            }

            //
            // Get the next order to be removed.
            //
            pOrder = COM_BasedListNext(&lpoaShared->orderListHead,
                pOrder, FIELD_OFFSET(INT_ORDER, OrderHeader.list));
        }

        TRACE_OUT(("Stopped at order %#.8lx", pOrder));

        //
        // Orders have been transferred to SDA, so now we have to
        //   - move the last purged color table order (if there is one) to
        //     the start of the order heap
        //   - shuffle up the heap
        //   - reset the pointers.
        //
        // pOrder points to the first non-purged order.
        //
        if (pOrder != NULL)
        {
            pNextOrderPos = lpoaShared->orderHeap;

            //
            // If we purged (at least) one color table order, move the last
            // color table order to the start of the order heap.
            //
            if (pColorTableOrder != NULL)
            {
                TRACE_OUT(("Moving color table from %#.8lx to start",
                             pColorTableOrder));

                hmemcpy(pNextOrderPos, pColorTableOrder,
                              INT_ORDER_SIZE(pColorTableOrder));

                pColorTableOrder        = (LPINT_ORDER)pNextOrderPos;
                lpoaShared->totalHeapOrderBytes
                                       += INT_ORDER_SIZE(pColorTableOrder);
                TRACE_OUT(("Total heap order bytes: %ld",
                    lpoaShared->totalHeapOrderBytes));

                lpoaShared->totalOrderBytes += MAX_ORDER_SIZE(pColorTableOrder);
                TRACE_OUT(("Total order bytes: %ld",
                    lpoaShared->totalOrderBytes));

                pNextOrderPos          += INT_ORDER_SIZE(pColorTableOrder);

                //
                // Chain the order into the start of the order list.  Just
                // do the pointers to and from the list head for now, we
                // will do the rest later.
                //
                lpoaShared->orderListHead.next =
                   PTRBASE_TO_OFFSET(pColorTableOrder, &lpoaShared->orderListHead);

                pColorTableOrder->OrderHeader.list.prev =
                   PTRBASE_TO_OFFSET(&lpoaShared->orderListHead, pColorTableOrder);
            }

            //
            // Move the heap up to the top of the buffer.  The following
            // diagram illustrates how the order heap is split up at the
            // moment.
            //
            //              lpoaShared->nextOrder
            // |<>|
            //
            //         moveOffset          moveBytes
            //     |<>|<>|
            //
            // ͻ
            //                                                       
            //        purged           remaining          unused     
            //        orders           orders                        
            //                                                      
            // ͼ
            // ^  ^                 ^
            //                    
            //                    
            //                     pOrder
            //   
            //    pNextOrderPos
            //  
            //   color table order
            // 
            //  lpoaShared->orderHeap (pColorTableOrder)
            //
            // If there is no color table order, pNextOrderPos is equal to
            // lpoaShared->orderHeap.
            //
            // moveOffset is the number of bytes to move the remaining
            // orders by.
            //
            // moveBytes is the number of bytes to be moved.
            //
            //
            moveOffset = PTRBASE_TO_OFFSET(pOrder, pNextOrderPos);
            moveBytes  = lpoaShared->nextOrder
                       - moveOffset
                       - (pNextOrderPos - lpoaShared->orderHeap);

            TRACE_OUT(("Moving %ld bytes", moveBytes));

            hmemcpy(pNextOrderPos, pOrder, moveBytes);

            //
            // Update the head and tail pointers to reflect their new
            // positions.
            //
            pFirstOrder = (LPINT_ORDER)pNextOrderPos;
            pTailOrder  = (LPINT_ORDER)((DWORD)pTailOrder - moveOffset);
            SHM_CheckPointer(pFirstOrder);
            SHM_CheckPointer(pTailOrder);

            TRACE_OUT(("New first unpurged %#.8lx, tail %#.8lx",
                         pFirstOrder,
                         pTailOrder));

            //
            // Since the offsets are relative to the order pointer, we only
            // need to modify the start and end offsets.
            //
            // Unfortunately, the possibility of a color table order at the
            // start of the heap complicates the chaining of pFirstOrder.
            // If there is a color table order, we chain pFirstOrder to the
            // color table order, otherwise we chain it to the start of the
            // order list.
            //
            lpoaShared->orderListHead.prev =
                         PTRBASE_TO_OFFSET(pTailOrder, &lpoaShared->orderListHead);
            pTailOrder->OrderHeader.list.next =
                         PTRBASE_TO_OFFSET(&lpoaShared->orderListHead, pTailOrder);

            if (pColorTableOrder != NULL)
            {
                pColorTableOrder->OrderHeader.list.next =
                             PTRBASE_TO_OFFSET(pFirstOrder, pColorTableOrder);
                pFirstOrder->OrderHeader.list.prev =
                             PTRBASE_TO_OFFSET(pColorTableOrder, pFirstOrder);
            }
            else
            {
                lpoaShared->orderListHead.next =
                        PTRBASE_TO_OFFSET(pFirstOrder, &lpoaShared->orderListHead);
                pFirstOrder->OrderHeader.list.prev =
                        PTRBASE_TO_OFFSET(&lpoaShared->orderListHead, pFirstOrder);
            }

            //
            // Sort out where the next order to be allocated will go
            //
            lpoaShared->nextOrder -= moveOffset;
            TRACE_OUT(("Next order: %ld", lpoaShared->nextOrder));
        }
        else
        {
            //
            // No orders left - this happens if we've had lots of spoiling.
            // We have now cleared out all the valid orders so let's
            // re-initialise the heap for next time.
            //
            OA_DDResetOrderList();
        }

        //
        // Now re-enable the spoiling of orders by SDA.
        //
        g_baSpoilByNewSDAEnabled = TRUE;

        CheckOaHeap(lpoaShared);

        WARNING_OUT(("Purged orders, total is now 0x%08x", lpoaShared->totalOrderBytes));

        //
        // Lastly, spoil the remaining orders by the screen data.
        // If we've gotten this far, there's a lot of data being sent
        // and/or we're slow.  So nuke 'em.
        //
        BA_CopyBounds(aRects, &numRects, FALSE);

        for (i = 0; i < numRects; i++)
        {
            OA_DDSpoilOrdersByRect(aRects+i);
        }

        WARNING_OUT(("Spoiled remaining orders by SDA, total is now 0x%08x", lpoaShared->totalOrderBytes));

        TRACE_OUT(("Next 0x%08lx", lpoaShared->nextOrder));
        TRACE_OUT(("Head 0x%08lx", lpoaShared->orderListHead.next));
        TRACE_OUT(("Tail 0x%08lx", lpoaShared->orderListHead.prev));
        TRACE_OUT(("Total heap bytes 0x%08lx", lpoaShared->totalHeapOrderBytes));
        TRACE_OUT(("Total order bytes 0x%08lx", lpoaShared->totalOrderBytes));

        CheckOaHeap(lpoaShared);
    }

    pOrder = OADDAllocOrderMemInt(lpoaShared, cbOrderDataLength,
                                cbAdditionalOrderDataLength);
    if ( pOrder != NULL )
    {
        //
        // Update the count of total order data.
        //
        SHM_CheckPointer(&lpoaShared->totalHeapOrderBytes);
        lpoaShared->totalHeapOrderBytes       += sizeof(INT_ORDER_HEADER)
                                         +  cbOrderDataLength;
        TRACE_OUT(("Total heap order bytes: %ld", lpoaShared->totalHeapOrderBytes));

        SHM_CheckPointer(&lpoaShared->totalAdditionalOrderBytes);
        lpoaShared->totalAdditionalOrderBytes += cbAdditionalOrderDataLength;
        TRACE_OUT(("Total additional order bytes: %ld", lpoaShared->totalAdditionalOrderBytes));
    }
    TRACE_OUT(("Alloc order, addr %lx, size %u", pOrder,
                                                   cbOrderDataLength));

    CheckOaHeap(lpoaShared);

    OA_SHM_STOP_WRITING;
    DebugExitDWORD(OA_DDAllocOrderMem, (DWORD)pOrder);
    return(pOrder);
}

//
//
// FUNCTION: OA_DDFreeOrderMem
//
//
// DESCRIPTION:
//
// Frees order memory from our own private heap.
// Frees any Additional Order Memory associated with this order.
//
//
// PARAMETERS:
//
// pOrder - pointer to the order to be freed.
//
//
// RETURNS:
//
// Nothing.
//
//
void  OA_DDFreeOrderMem(LPINT_ORDER pOrder)
{
    LPOA_SHARED_DATA lpoaShared;

    DebugEntry(OA_DDFreeOrderMem);

    ASSERT(pOrder);

    lpoaShared = OA_SHM_START_WRITING;

    TRACE_OUT(("Free order %lx", pOrder));

    CheckOaHeap(lpoaShared);

    //
    // Update the data totals.
    //
    SHM_CheckPointer(&lpoaShared->totalHeapOrderBytes);
    lpoaShared->totalHeapOrderBytes -= (sizeof(INT_ORDER_HEADER)
                              + pOrder->OrderHeader.Common.cbOrderDataLength);
    TRACE_OUT(("Total heap order bytes: %ld", lpoaShared->totalHeapOrderBytes));

    SHM_CheckPointer(&lpoaShared->totalAdditionalOrderBytes);
    lpoaShared->totalAdditionalOrderBytes -=
                              pOrder->OrderHeader.cbAdditionalOrderDataLength;
    TRACE_OUT(("Total additional order bytes: %ld", lpoaShared->totalAdditionalOrderBytes));

    //
    // Do the work.
    //
    OADDFreeOrderMemInt(lpoaShared, pOrder);

    CheckOaHeap(lpoaShared);

    OA_SHM_STOP_WRITING;
    DebugExitVOID(OA_DDFreeOrderMem);
}


//
//
// FUNCTION: OA_DDResetOrderList
//
//
// DESCRIPTION:
//
// Frees all Orders and Additional Order Data in the Order List.
// Frees up the Order Heap memory.
//
//
// PARAMETERS:
//
// None.
//
//
// RETURNS:
//
// Nothing.
//
//
void  OA_DDResetOrderList(void)
{
    LPOA_SHARED_DATA    lpoaShared;

    DebugEntry(OA_DDResetOrderList);

    TRACE_OUT(("Resetting order list"));

    lpoaShared = OA_SHM_START_WRITING;

    CheckOaHeap(lpoaShared);

    //
    // First free all the orders on the list.
    //
    OADDFreeAllOrders(lpoaShared);

    //
    // Ensure that the list pointers are NULL.
    //
    SHM_CheckPointer(&lpoaShared->orderListHead);
    if ((lpoaShared->orderListHead.next != 0) || (lpoaShared->orderListHead.prev != 0))
    {
        ERROR_OUT(("Non-NULL list pointers (%lx)(%lx)",
                       lpoaShared->orderListHead.next,
                       lpoaShared->orderListHead.prev));

        SHM_CheckPointer(&lpoaShared->orderListHead);
        COM_BasedListInit(&lpoaShared->orderListHead);
    }

    CheckOaHeap(lpoaShared);

    OA_SHM_STOP_WRITING;
    DebugExitVOID(OA_DDResetOrderList);
}



//
// OA_DDSyncUpdatesNow
//
// Called when a sync operation is required.
//
// Discards all outstanding orders.
//
void  OA_DDSyncUpdatesNow(void)
{
    DebugEntry(OA_DDSyncUpdatesNow);

    TRACE_OUT(("Syncing OA updates now"));
    OADDFreeAllOrders(g_poaData[g_asSharedMemory->displayToCore.currentBuffer]);

    DebugExitVOID(OA_DDSyncUpdatesNow);
}


//
//
// OA_DDRemoveListOrder(..)
//
// Removes the specified order from the Order List by marking it as spoilt.
//
// Returns:
//   Pointer to the order following the removed order.
//
//
LPINT_ORDER  OA_DDRemoveListOrder(LPINT_ORDER pCondemnedOrder)
{
    LPOA_SHARED_DATA lpoaShared;
    LPINT_ORDER pSaveOrder;

    DebugEntry(OA_DDRemoveListOrder);

    TRACE_OUT(("Remove list order (%lx)", pCondemnedOrder));

    lpoaShared = OA_SHM_START_WRITING;

    SHM_CheckPointer(pCondemnedOrder);

    //
    // Check for a valid order.
    //
    if (pCondemnedOrder->OrderHeader.Common.fOrderFlags & OF_SPOILT)
    {
        ERROR_OUT(("Invalid order"));
        DC_QUIT;
    }

    //
    // Get the offset value of this order.
    //
    SHM_CheckPointer(&lpoaShared->orderHeap);

    //
    // Mark the order as spoilt.
    //
    pCondemnedOrder->OrderHeader.Common.fOrderFlags |= OF_SPOILT;

    //
    // Update the count of bytes currently in the Order List.
    //
    SHM_CheckPointer(&lpoaShared->totalOrderBytes);
    lpoaShared->totalOrderBytes -= MAX_ORDER_SIZE(pCondemnedOrder);
    TRACE_OUT(("Total order bytes: %ld", lpoaShared->totalOrderBytes));

    //
    // Save the order so we can remove it from the linked list after having
    // got the next element in the chain.
    //
    pSaveOrder = pCondemnedOrder;

    //
    // Return the next order in the list.
    //
    SHM_CheckPointer(&lpoaShared->orderListHead);
    pCondemnedOrder = COM_BasedListNext(&lpoaShared->orderListHead,
        pCondemnedOrder, FIELD_OFFSET(INT_ORDER, OrderHeader.list));

    if (pSaveOrder == pCondemnedOrder)
    {
        ERROR_OUT(("Order list has gone circular !"));
    }

    //
    // Delete the unwanted order from the linked list.
    //
    COM_BasedListRemove(&pSaveOrder->OrderHeader.list);

    //
    // Check that the list is still consistent with the total number of
    // order bytes.
    //
    if ( (lpoaShared->orderListHead.next != 0) &&
         (lpoaShared->orderListHead.prev != 0) &&
         (lpoaShared->totalOrderBytes    == 0) )
    {
        ERROR_OUT(("List head wrong: %ld %ld", lpoaShared->orderListHead.next,
                                                 lpoaShared->orderListHead.prev));
        COM_BasedListInit(&lpoaShared->orderListHead);
        pCondemnedOrder = NULL;
    }


DC_EXIT_POINT:
    CheckOaHeap(lpoaShared);
    OA_SHM_STOP_WRITING;

    DebugExitDWORD(OA_DDRemoveListOrder, (DWORD)pCondemnedOrder);
    return(pCondemnedOrder);
}



//
// OA_DDSpoilOrdersByRect - see oa.h
//
void  OA_DDSpoilOrdersByRect(LPRECT pRect)
{
    LPOA_SHARED_DATA lpoaShared;
    LPINT_ORDER  pOrder;

    DebugEntry(OA_DDSpoilOrdersByRect);

    lpoaShared = OA_SHM_START_WRITING;

    CheckOaHeap(lpoaShared);

    //
    // We want to start spoiling from the newest order i.e.  the one at the
    // end of the order list.
    //
    pOrder = COM_BasedListLast(&lpoaShared->orderListHead,
        FIELD_OFFSET(INT_ORDER, OrderHeader.list));
    if (pOrder != NULL)
    {
        OADDSpoilFromOrder(lpoaShared, pOrder, pRect);
    }

    CheckOaHeap(lpoaShared);

    OA_SHM_STOP_WRITING;
    
    DebugExitVOID(OA_DDSpoilOrdersByRect);
}



//
//
// OADDAppendToOrderList(..)
//
// Commits an allocated order to the end of the Order List.  The order must
// NOT be freed once it has been added.  The whole list must be invalidated
// to free the committed orders.
//
//
void  OADDAppendToOrderList(LPOA_SHARED_DATA lpoaShared, LPINT_ORDER pNewOrder)
{
    DebugEntry(OADDAppendToOrderList);

    //
    // Chain entry is already set up so all we do is keep track of
    // committed orders.
    //

    //
    // Store the total number of order bytes used.
    //
    SHM_CheckPointer(&lpoaShared->totalOrderBytes);
    lpoaShared->totalOrderBytes += MAX_ORDER_SIZE(pNewOrder);
    TRACE_OUT(("Total Order Bytes: %ld", lpoaShared->totalOrderBytes));

    DebugExitVOID(OADDAppendToOrderList);
}


//
//
// FUNCTION: OADDAllocOrderMemInt
//
// DESCRIPTION:
//
// Allocates memory for an internal order structure from our order heap.
//
//
// PARAMETERS:
//
// cbOrderDataLength - length in bytes of the order data to be allocated
// from the Order Heap.
//
// cbAdditionalOrderDataLength - length in bytes of additional order data
// to be allocated.  If this parameter is zero no additional order memory
// is allocated.
//
//
// RETURNS:           
//
// A pointer to the allocated order memory.  NULL if the memory allocation
// failed.
//
//
//
LPINT_ORDER  OADDAllocOrderMemInt
(
    LPOA_SHARED_DATA    lpoaShared,
    UINT                cbOrderDataLength,
    UINT                cbAdditionalOrderDataLength
)
{
    LPINT_ORDER   pOrder = NULL;
    UINT       cbOrderSize;

    DebugEntry(OADDAllocOrderMemInt);

    //
    // If the additional data will take us over our Additional Data Limit
    // then fail the memory allocation.
    //
    SHM_CheckPointer(&lpoaShared->totalAdditionalOrderBytes);
    if ((lpoaShared->totalAdditionalOrderBytes + cbAdditionalOrderDataLength) >
                                                    MAX_ADDITIONAL_DATA_BYTES)
    {
        TRACE_OUT(("Hit Additional Data Limit, current %lu addint %u",
                     lpoaShared->totalAdditionalOrderBytes,
                     cbAdditionalOrderDataLength));
        DC_QUIT;
    }

    //
    // Calculate the number of bytes we need to allocate (including the
    // order header).  Round up to the nearest 4 bytes to keep the 4 byte
    // alignment for the next order.
    //
    cbOrderSize = sizeof(INT_ORDER_HEADER) + cbOrderDataLength;
    cbOrderSize = (cbOrderSize + 3) & 0xFFFFFFFC;

    //
    // Make sure we don't overrun our heap limit
    //
    SHM_CheckPointer(&lpoaShared->nextOrder);
    if (lpoaShared->nextOrder + cbOrderSize > OA_HEAP_MAX)
    {
        WARNING_OUT(("Heap limit hit"));
        DC_QUIT;
    }

    //
    // Construct a far pointer to the allocated memory, and fill in the
    // length field in the Order Header.
    //
    SHM_CheckPointer(&lpoaShared->orderHeap);
    pOrder = (LPINT_ORDER)(lpoaShared->orderHeap + lpoaShared->nextOrder);
    pOrder->OrderHeader.Common.cbOrderDataLength = cbOrderDataLength;

    //
    // Update the order header to point to the next section of free heap.
    //
    SHM_CheckPointer(&lpoaShared->nextOrder);
    lpoaShared->nextOrder += cbOrderSize;

    //
    // Allocate any Additional Order Memory from Global Memory.
    //
    if (cbAdditionalOrderDataLength > 0)
    {
        //
        // Make sure we don't overrun our heap limit
        //
        SHM_CheckPointer(&lpoaShared->nextOrder);
        if (lpoaShared->nextOrder + cbAdditionalOrderDataLength > OA_HEAP_MAX)
        {
            WARNING_OUT(("Heap limit hit for additional data"));

            //
            // Clear the allocated order and quit.
            //
            SHM_CheckPointer(&lpoaShared->nextOrder);
            lpoaShared->nextOrder -= cbOrderSize;
            pOrder            = NULL;
            DC_QUIT;
        }

        //
        // Store the space for the additional data.
        //
        SHM_CheckPointer(&lpoaShared->nextOrder);
        pOrder->OrderHeader.additionalOrderData         = lpoaShared->nextOrder;
        pOrder->OrderHeader.cbAdditionalOrderDataLength =
                                                  cbAdditionalOrderDataLength;

        //
        // Update the next order pointer to point to the next 4-byte
        // boundary.
        //
        SHM_CheckPointer(&lpoaShared->nextOrder);
        lpoaShared->nextOrder += cbAdditionalOrderDataLength + 3;
        lpoaShared->nextOrder &= 0xFFFFFFFC;
    }
    else
    {
        pOrder->OrderHeader.additionalOrderData         = 0;
        pOrder->OrderHeader.cbAdditionalOrderDataLength = 0;
    }

    TRACE_OUT(("Next order: %ld", lpoaShared->nextOrder));

#ifdef DEBUG
    //
    // Initialize the bounds rect to something whacky, so we can detect if
    // our list ever gets out of order.  Orders MUST be committed in the 
    // sequence that they are allocated in.  Otherwise, spoilers will cause
    // us to mess up the linked list, since they walk backwards and assume
    // all previous orders are already committed.
    //
    CopyRect((LPRECT)&pOrder->OrderHeader.Common.rcsDst, &g_oaEmptyRect);
#endif // DEBUG

    //
    // Create the chain entry.
    //
    SHM_CheckPointer(&lpoaShared->orderListHead);
    COM_BasedListInsertBefore(&lpoaShared->orderListHead, &pOrder->OrderHeader.list);

DC_EXIT_POINT:
    DebugExitDWORD(OADDAllocOrderMemInit, (DWORD)pOrder);
    return(pOrder);
}


//
//
// FUNCTION: OADDFreeOrderMemInt
//
//
// DESCRIPTION:
//
// Frees order memory from our orders heap.  Frees any Additional Order
// Memory associated with this order.  This must NOT be used on an order
// that has been committed to the order list.
//
//
// PARAMETERS:
//
// pOrder - pointer to the order to be freed.
//
//
// RETURNS:
//
// Nothing.
//
//
void  OADDFreeOrderMemInt(LPOA_SHARED_DATA lpoaShared, LPINT_ORDER pOrder)
{
    LPINT_ORDER pOrderTail;

    DebugEntry(OADDFreeOrderMemInt);

    //
    // The order heap is real a misnomer.  We know that the memory is only
    // allocated in a purely sequential manner and deallocated as one large
    // lump of memory.
    //
    // So we do not need to implement a full memory heap allocation
    // mechanism.  Instead, we just need to keep track of where the
    // previous high water mark was before this order was freed.
    //

    //
    // Find the tail of the current chain.
    //
    pOrderTail = COM_BasedListLast(&lpoaShared->orderListHead, FIELD_OFFSET(INT_ORDER, OrderHeader.list));
    SHM_CheckPointer(pOrderTail);

    //
    // We wont necessarily be freeing the last item in the order heap.
    //
    if (pOrder == pOrderTail)
    {
        //
        // This is the last item in the heap, so we can set the pointer to
        // the next order to be used back to the start of the order being
        // freed.
        //
        SHM_CheckPointer(&lpoaShared->nextOrder);
        lpoaShared->nextOrder = (LONG)PTRBASE_TO_OFFSET(pOrder, lpoaShared->orderHeap);

        TRACE_OUT(("Next order: %ld", lpoaShared->nextOrder));
    }
    else
    {
        //
        // This is not the last item in the heap - we must not reset the
        // pointer to the next item to be used.
        //
        TRACE_OUT(("Not resetting next order (not last item in heap)"));
    }

    //
    // Delete the item from the chain.
    //
    COM_BasedListRemove(&pOrder->OrderHeader.list);

    DebugExitVOID(OADDFreeOrderMemInt);
}


//
// OADDFreeAllOrders
//
// Free the all the individual orders on the orders list, without
// discarding the list itself.
//
void  OADDFreeAllOrders(LPOA_SHARED_DATA lpoaShared)
{
    DebugEntry(OADDFreeAllOrders);

    TRACE_OUT(("Freeing all orders"));

    //
    // Simply clear the list head.
    //
    COM_BasedListInit(&lpoaShared->orderListHead);
    SHM_CheckPointer(&lpoaShared->orderListHead);

    lpoaShared->totalHeapOrderBytes       = 0;
    lpoaShared->totalOrderBytes           = 0;
    lpoaShared->totalAdditionalOrderBytes = 0;
    lpoaShared->nextOrder                 = 0;

    DebugExitVOID(OADDFreeAllOrders);
}

BOOL  OADDCompleteOverlapRect(LPTSHR_RECT16 prcsSrc, LPRECT prcsOverlap)
{
    //
    // Return TRUE if the source is completely enclosed by the overlap
    // rectangle.
    //
    return( (prcsSrc->left >= prcsOverlap->left) &&
            (prcsSrc->right <= prcsOverlap->right) &&
            (prcsSrc->top >= prcsOverlap->top) &&
            (prcsSrc->bottom <= prcsOverlap->bottom) );
}


//
// Name:      OADDSpoilFromOrder
//
// Purpose:   Remove any orders from the order heap which should be spoiled
//            by a given rectangle..
//
// Returns:   Nothing
//
// Params:    IN  pTargetOrder - Pointer to the first order to try to
//                               spoil.
//            IN  pRect        - Pointer to the spoiling rectangle.
//
// Operation: pTargetOrder may be spoiled by this function, so be careful
//            on return.
//
void  OADDSpoilFromOrder
(
    LPOA_SHARED_DATA    lpoaShared,
    LPINT_ORDER         pTargetOrder,
    LPRECT              pSpoilRect
)
{
    UINT      nonProductiveScanDepth = 0;
    UINT      scanExitDepth;
    BOOL      reachedBlocker = FALSE;

    DebugEntry(OADDSpoilFromOrder);

    TRACE_OUT(("Spoiling rect is {%d, %d, %d, %d}",
                 pSpoilRect->left,
                 pSpoilRect->top,
                 pSpoilRect->right,
                 pSpoilRect->bottom));

    //
    // Work out how deep we will scan if the spoiling is non-productive.
    // We go further for bigger orders over PSTN.  (ie Irrespective of the
    // bandwidth we do not want to do much work when the app is blasting
    // out a lot of single pel orders!)
    //
    if (((pSpoilRect->right - pSpoilRect->left) < FULL_SPOIL_WIDTH) &&
        ((pSpoilRect->bottom - pSpoilRect->top) < FULL_SPOIL_HEIGHT))
    {
        TRACE_OUT(("Small order so reducing spoil depth"));
        scanExitDepth = OA_FAST_SCAN_DEPTH;
    }
    else
    {
        //
        // Use the current default scan depth (this is based on the
        // current network throughput).
        //
        scanExitDepth = (g_oaFlow == OAFLOW_FAST) ?
            OA_FAST_SCAN_DEPTH : OA_SLOW_SCAN_DEPTH;
    }

    //
    // Loop backwards from the base order until we have one of the
    // following occurs.
    //   - We spoil all the preceeding orders.
    //   - We reach a blocker which we can't spoil.
    //   - We find scanExitDepth orders which we can't spoil.
    //
    while ((pTargetOrder != NULL)
             && !reachedBlocker
             && (nonProductiveScanDepth < scanExitDepth))
    {
        //
        // We do not exit immediately when we reach a blocker because it is
        // possible that we will spoil it.  If we do spoil it, then we can
        // quite happily try spoiling the orders which preceed it.
        //
        // So, just set a flag here which we will reset if we spoil the
        // order.
        //
        reachedBlocker =
           ((pTargetOrder->OrderHeader.Common.fOrderFlags & OF_BLOCKER) != 0);

        //
        // Only try to spoil spoilable orders.
        //
        if (pTargetOrder->OrderHeader.Common.fOrderFlags & OF_SPOILABLE)
        {
            //
            // Make sure this order is committed!
            //
            ASSERT(!EqualRect((LPRECT)&pTargetOrder->OrderHeader.Common.rcsDst, &g_oaEmptyRect));

            if (OADDCompleteOverlapRect(
                        &pTargetOrder->OrderHeader.Common.rcsDst, pSpoilRect))
            {
                //
                // The order can be spoilt.  If the order is a MemBlt or a
                // Mem3Blt, we have to notify SBC to allow it to free up
                // associated data.
                //
                if (ORDER_IS_MEMBLT(pTargetOrder) ||
                    ORDER_IS_MEM3BLT(pTargetOrder))
                {
                    ERROR_OUT(("MEMBLT orders not supported!"));
                }

                TRACE_OUT(("Spoil by order {%d, %d, %d, %d}",
                             pTargetOrder->OrderHeader.Common.rcsDst.left,
                             pTargetOrder->OrderHeader.Common.rcsDst.top,
                             pTargetOrder->OrderHeader.Common.rcsDst.right,
                             pTargetOrder->OrderHeader.Common.rcsDst.bottom));

                pTargetOrder = OA_DDRemoveListOrder(pTargetOrder);

                //
                // Reset the blocker flag - we spoiled the order, so if it
                // was a blocker we can now try to spoil earlier orders.
                //
                reachedBlocker = FALSE;
            }
            else
            {
                nonProductiveScanDepth++;
            }
        }
        else
        {
            nonProductiveScanDepth++;
        }

        //
        // Get the previous order in the list.  We have to be careful
        // because we may have just removed the last item in the list, in
        // which case pTargetOrder will be NULL.
        //
        if (pTargetOrder == NULL)
        {
            pTargetOrder = COM_BasedListLast(&lpoaShared->orderListHead,
                FIELD_OFFSET(INT_ORDER, OrderHeader.list));
        }
        else
        {
            pTargetOrder = COM_BasedListPrev(&lpoaShared->orderListHead,
                pTargetOrder, FIELD_OFFSET(INT_ORDER, OrderHeader.list));
        }
    }

    DebugExitVOID(OADDSpoilFromOrder);
}



#ifdef DEBUG

//
// This is a DEBUG-only function that walks a double-linked list and verifies
// that it is sane.
//
// We walk the list front to back, ensuring that the next item of the
// current order is the same as the previous item of the next order.
//
// Then we walk the list back to front, ensuring that the previous item of
// the current order is the same as the next item of the previous order.
//
// At the same time, we sum up the total order and total heap bytes.  They
// should equal what's in the structure header.
//

void CheckOaHeap(LPOA_SHARED_DATA lpoaHeap)
{
    PBASEDLIST         pList;
    LPINT_ORDER     pNextPrev;
    LPINT_ORDER     pCur;
    LPINT_ORDER     pNext;

    if (!(g_trcConfig & ZONE_OAHEAPCHECK))
        return;

    //
    // Walk front to back
    //
    pList           = &lpoaHeap->orderListHead;

    pCur = COM_BasedListFirst(pList, FIELD_OFFSET(INT_ORDER, OrderHeader.list));
    while (pCur != NULL)
    {
        //
        // Get the next item
        //
        pNext = COM_BasedListNext(pList, pCur, FIELD_OFFSET(INT_ORDER, OrderHeader.list));

        //
        // Is the previous dude of the next the same as us?
        //
        if (pNext != NULL)
        {
            pNextPrev = COM_BasedListPrev(pList, pNext, FIELD_OFFSET(INT_ORDER, OrderHeader.list));

            ASSERT(pNextPrev == pCur);
        }

        pCur = pNext;
    }


    //
    // Walk back to front
    //
    pCur = COM_BasedListLast(pList, FIELD_OFFSET(INT_ORDER, OrderHeader.list));

    while (pCur != NULL)
    {
        //
        // Get the previous item
        //
        pNextPrev = COM_BasedListPrev(pList, pCur, FIELD_OFFSET(INT_ORDER, OrderHeader.list));

        //
        // Is the next dude of the previous the same as us?
        //
        if (pNextPrev != NULL)
        {
            pNext = COM_BasedListNext(pList, pNextPrev, FIELD_OFFSET(INT_ORDER, OrderHeader.list));

            ASSERT(pNext == pCur);
        }

        pCur = pNextPrev;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\as16\oe.c ===
//
// OE.C
// Order Encoder
//
// Copyright(c) Microsoft 1997-
//

#include <as16.h>


//
// Define entries in the Font Alias table.  This table is used to convert
// non-existant fonts (used by certain widely used applications) into
// something we can use as a local font.
//
// The font names that we alias are:
//
// "Helv"
// This is used by Excel. It is mapped directly onto "MS Sans Serif".
//
// "MS Dialog"
// This is used by Word. It is the same as an 8pt bold MS Sans Serif.
// We actually map it to a "MS Sans Serif" font that is one pel narrower
// than the metrics specify (because all matching is done on non-bold
// fonts) - hence the 1 value in the charWidthAdjustment field.
//
// "MS Dialog Light"
// Added as part of the Win95 performance enhancements...Presumably for
// MS-Word...
//
//
#define NUM_ALIAS_FONTS     3

char CODESEG g_szMsSansSerif[]      = "MS Sans Serif";
char CODESEG g_szHelv[]             = "Helv";
char CODESEG g_szMsDialog[]         = "MS Dialog";
char CODESEG g_szMsDialogLight[]    = "MS Dialog Light";

FONT_ALIAS_TABLE CODESEG g_oeFontAliasTable[NUM_ALIAS_FONTS] =
{
    { g_szHelv,             g_szMsSansSerif,    0 },
    { g_szMsDialog,         g_szMsSansSerif,    1 },
    { g_szMsDialogLight,    g_szMsSansSerif,    0 }
};


//
// OE_DDProcessRequest()
// Handles OE escapes
//

BOOL OE_DDProcessRequest
(
    UINT   fnEscape,
    LPOSI_ESCAPE_HEADER pResult,
    DWORD   cbResult
)
{
    BOOL    rc = TRUE;

    DebugEntry(OE_DDProcessRequest);

    switch (fnEscape)
    {
        case OE_ESC_NEW_FONTS:
        {
            ASSERT(cbResult == sizeof(OE_NEW_FONTS));

            OEDDSetNewFonts((LPOE_NEW_FONTS)pResult);
        }
        break;

        case OE_ESC_NEW_CAPABILITIES:
        {
            ASSERT(cbResult == sizeof(OE_NEW_CAPABILITIES));

            OEDDSetNewCapabilities((LPOE_NEW_CAPABILITIES)pResult);
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognized OE escape"));
            rc = FALSE;
        }
        break;
    }

    DebugExitBOOL(OE_DDProcessRequest, rc);
    return(rc);
}


//
// OE_DDInit()
// This creates the patches we need.
// 
BOOL OE_DDInit(void)
{
    BOOL    rc = FALSE;
    HGLOBAL hMem;
    UINT    uSel;
    DDI_PATCH iPatch;

    DebugEntry(OE_DDInit);

    //
    // lstrcmp(), like strcmp(), works numerically for US/Eng code page.
    // But it's lexographic like Win32 lstrcmp() is all the time for non
    // US.
    //
    // So we use MyStrcmp()
    //
    ASSERT(MyStrcmp("Symbol", "SYmbol") > 0);

    //
    // Allocate a cached selector.  We use it when reading from swapped-out
    // DCs.  Therefore base it off of GDI's data segement, so it has the
    // same access rights and limit.
    //
    g_oeSelDst = AllocSelector((UINT)g_hInstGdi16);
    g_oeSelSrc = AllocSelector((UINT)g_hInstGdi16);
    if (!g_oeSelDst || !g_oeSelSrc)
    {
        ERROR_OUT(("Out of selectors"));
        DC_QUIT;
    }

    //
    // Allocate g_poeLocalFonts--it's too big for our DS.  We make it
    // a very small size since on new fonts, we will realloc it.
    //
    hMem = GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT | GMEM_SHARE,
        sizeof(LOCALFONT));
    if (!hMem)
    {
        ERROR_OUT(("OE_DDInit:  Couldn't allocate font matching array"));
        DC_QUIT;
    }
    g_poeLocalFonts = MAKELP(hMem, 0);


    //
    // Create two patches for ChangeDisplaySettings/Ex and ENABLE them right
    // away.  We don't want you to be able to change your display when
    // NetMeeting is running, regardless of whether you are in a share yet.
    //
    uSel = CreateFnPatch(ChangeDisplaySettings, DrvChangeDisplaySettings,
        &g_oeDisplaySettingsPatch, 0);
    if (!uSel)
    {
        ERROR_OUT(("CDS patch failed to create"));
        DC_QUIT;
    }

    EnableFnPatch(&g_oeDisplaySettingsPatch, PATCH_ACTIVATE);

    if (SELECTOROF(g_lpfnCDSEx))
    {
        if (!CreateFnPatch(g_lpfnCDSEx, DrvChangeDisplaySettingsEx,
                &g_oeDisplaySettingsExPatch, uSel))
        {
            ERROR_OUT(("CDSEx patch failed to create"));
            DC_QUIT;
        }

        EnableFnPatch(&g_oeDisplaySettingsExPatch, PATCH_ACTIVATE);
    }

    //
    // Create patches.
    // NOTE this code assumes that various groups of functions are in
    // the same segment.  CreateFnPatch has asserts to verify this.
    //
    // Rather than check each for failure (low on selectors), we try to
    // create all the patches, then loop through looking for any that
    // didn't succeed.
    //
    // Why do we do this?  Because allocating 50 different selectors is 
    // not so hot when 16-bit selectors are the most precious resource on
    // Win95 (most out-of-memory conditions that aren't blatant app errors
    // are caused by a lack of selectors, not logical memory).
    //

    // _ARCDDA
    uSel = CreateFnPatch(Arc, DrvArc, &g_oeDDPatches[DDI_ARC], 0);
    CreateFnPatch(Chord, DrvChord, &g_oeDDPatches[DDI_CHORD], uSel);
    CreateFnPatch(Ellipse, DrvEllipse, &g_oeDDPatches[DDI_ELLIPSE], uSel);
    CreateFnPatch(Pie, DrvPie, &g_oeDDPatches[DDI_PIE], uSel);
    CreateFnPatch(RoundRect, DrvRoundRect, &g_oeDDPatches[DDI_ROUNDRECT], uSel);

    // IGROUP
    uSel = CreateFnPatch(BitBlt, DrvBitBlt, &g_oeDDPatches[DDI_BITBLT], 0);
    CreateFnPatch(ExtTextOut, DrvExtTextOutA, &g_oeDDPatches[DDI_EXTTEXTOUTA], uSel);
    CreateFnPatch(InvertRgn, DrvInvertRgn, &g_oeDDPatches[DDI_INVERTRGN], uSel);
    CreateFnPatch(DeleteObject, DrvDeleteObject, &g_oeDDPatches[DDI_DELETEOBJECT], uSel);
    CreateFnPatch(Death, DrvDeath, &g_oeDDPatches[DDI_DEATH], uSel);
    CreateFnPatch(Resurrection, DrvResurrection, &g_oeDDPatches[DDI_RESURRECTION], uSel);


    //
    // Note:  PatBlt and IPatBlt (internal PatBlt) jump to RealPatBlt, which
    // is 3 bytes past PatBlt.  So patch RealPatBlt, or we'll (1) fault with
    // misaligned instructions and (2) miss many PatBlt calls.  But our
    // function needs to preserve CX since those two routines pass 0 for
    // internal calls (EMF) and -1 for external calls.
    //
    g_lpfnRealPatBlt = (REALPATBLTPROC)((LPBYTE)PatBlt+3);
    CreateFnPatch(g_lpfnRealPatBlt, DrvPatBlt, &g_oeDDPatches[DDI_PATBLT], uSel);
    CreateFnPatch(StretchBlt, DrvStretchBlt, &g_oeDDPatches[DDI_STRETCHBLT], uSel);
    CreateFnPatch(TextOut, DrvTextOutA, &g_oeDDPatches[DDI_TEXTOUTA], uSel);

    // _FLOODFILL
    uSel = CreateFnPatch(ExtFloodFill, DrvExtFloodFill, &g_oeDDPatches[DDI_EXTFLOODFILL], 0);
    CreateFnPatch(FloodFill, DrvFloodFill, &g_oeDDPatches[DDI_FLOODFILL], uSel);

    // _FONTLOAD
    uSel = CreateFnPatch(g_lpfnExtTextOutW, DrvExtTextOutW, &g_oeDDPatches[DDI_EXTTEXTOUTW], 0);
    CreateFnPatch(g_lpfnTextOutW, DrvTextOutW, &g_oeDDPatches[DDI_TEXTOUTW], uSel);

    // _PATH
    uSel = CreateFnPatch(FillPath, DrvFillPath, &g_oeDDPatches[DDI_FILLPATH], 0);
    CreateFnPatch(StrokeAndFillPath, DrvStrokeAndFillPath, &g_oeDDPatches[DDI_STROKEANDFILLPATH], uSel);
    CreateFnPatch(StrokePath, DrvStrokePath, &g_oeDDPatches[DDI_STROKEPATH], uSel);

    // _RGOUT
    uSel = CreateFnPatch(FillRgn, DrvFillRgn, &g_oeDDPatches[DDI_FILLRGN], 0);
    CreateFnPatch(FrameRgn, DrvFrameRgn, &g_oeDDPatches[DDI_FRAMERGN], uSel);
    CreateFnPatch(PaintRgn, DrvPaintRgn, &g_oeDDPatches[DDI_PAINTRGN], uSel);

    // _OUTMAN
    uSel = CreateFnPatch(LineTo, DrvLineTo, &g_oeDDPatches[DDI_LINETO], 0);
    CreateFnPatch(Polyline, DrvPolyline, &g_oeDDPatches[DDI_POLYLINE], uSel);
    CreateFnPatch(g_lpfnPolylineTo, DrvPolylineTo, &g_oeDDPatches[DDI_POLYLINETO], uSel);

    // EMF
    uSel = CreateFnPatch(PlayEnhMetaFileRecord, DrvPlayEnhMetaFileRecord, &g_oeDDPatches[DDI_PLAYENHMETAFILERECORD], 0);

    // METAPLAY
    uSel = CreateFnPatch(PlayMetaFile, DrvPlayMetaFile, &g_oeDDPatches[DDI_PLAYMETAFILE], 0);
    CreateFnPatch(PlayMetaFileRecord, DrvPlayMetaFileRecord, &g_oeDDPatches[DDI_PLAYMETAFILERECORD], uSel);

    // _POLYGON
    uSel = CreateFnPatch(Polygon, DrvPolygon, &g_oeDDPatches[DDI_POLYGON], 0);
    CreateFnPatch(PolyPolygon, DrvPolyPolygon, &g_oeDDPatches[DDI_POLYPOLYGON], uSel);

    // _BEZIER
    uSel = CreateFnPatch(PolyBezier, DrvPolyBezier, &g_oeDDPatches[DDI_POLYBEZIER], 0);
    CreateFnPatch(PolyBezierTo, DrvPolyBezierTo, &g_oeDDPatches[DDI_POLYBEZIERTO], uSel);

    // _WIN32
    uSel = CreateFnPatch(g_lpfnPolyPolyline, DrvPolyPolyline, &g_oeDDPatches[DDI_POLYPOLYLINE], 0);

    // _RECT
    uSel = CreateFnPatch(Rectangle, DrvRectangle, &g_oeDDPatches[DDI_RECTANGLE], 0);

    // _DIBITMAP
    uSel = CreateFnPatch(SetDIBitsToDevice, DrvSetDIBitsToDevice, &g_oeDDPatches[DDI_SETDIBITSTODEVICE], 0);
    CreateFnPatch(StretchDIBits, DrvStretchDIBits, &g_oeDDPatches[DDI_STRETCHDIBITS], uSel);

    // _DCSTUFF
    uSel = CreateFnPatch(CreateSpb, DrvCreateSpb, &g_oeDDPatches[DDI_CREATESPB], 0);

    // _PIXDDA
    uSel = CreateFnPatch(SetPixel, DrvSetPixel, &g_oeDDPatches[DDI_SETPIXEL], 0);

    // _PALETTE
    uSel = CreateFnPatch(UpdateColors, DrvUpdateColors, &g_oeDDPatches[DDI_UPDATECOLORS], 0);
    CreateFnPatch(GDIRealizePalette, DrvGDIRealizePalette, &g_oeDDPatches[DDI_GDIREALIZEPALETTE], uSel);
    CreateFnPatch(RealizeDefaultPalette, DrvRealizeDefaultPalette, &g_oeDDPatches[DDI_REALIZEDEFAULTPALETTE], uSel);

    // (User WINRARE)
    uSel = CreateFnPatch(WinOldAppHackoMatic, DrvWinOldAppHackoMatic, &g_oeDDPatches[DDI_WINOLDAPPHACKOMATIC], 0);

    //
    // Loop through our patches and check for failure
    //
    for (iPatch = DDI_FIRST; iPatch < DDI_MAX; iPatch++)
    {
        if (!SELECTOROF(g_oeDDPatches[iPatch].lpCodeAlias))
        {
            ERROR_OUT(("Patch %u failed to create", iPatch));
            DC_QUIT;
        }
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(OE_DDInit, rc);
    return(rc);
}



//
// OE_DDTerm()
// This destroys the patches we created.
//
void OE_DDTerm(void)
{
    DDI_PATCH   iPatch;

    DebugEntry(OE_DDTerm);

    //
    // Destroying patches will also disable any still active.
    //
    for (iPatch = DDI_FIRST; iPatch < DDI_MAX; iPatch++)
    {
        // destroy patches
        DestroyFnPatch(&g_oeDDPatches[iPatch]);
    }

    //
    // Destroy ChangeDisplaySettings patches
    //
    if (SELECTOROF(g_lpfnCDSEx))
        DestroyFnPatch(&g_oeDisplaySettingsExPatch);
    DestroyFnPatch(&g_oeDisplaySettingsPatch);

    //
    // Free font memory
    //
    if (SELECTOROF(g_poeLocalFonts))
    {
        GlobalFree((HGLOBAL)SELECTOROF(g_poeLocalFonts));
        g_poeLocalFonts = NULL;
    }

    //
    // Free cached selectors
    //
    if (g_oeSelSrc)
    {
        FreeSelector(g_oeSelSrc);
        g_oeSelSrc = 0;
    }

    if (g_oeSelDst)
    {
        FreeSelector(g_oeSelDst);
        g_oeSelDst = 0;
    }

    DebugExitVOID(OE_DDTerm);
}


//
// OE_DDViewing()
//
// Turns on/off patches for trapping graphic output.
//
void OE_DDViewing(BOOL fViewers)
{
    DDI_PATCH   patch;

    DebugEntry(OE_DDViewing);

    //
    // Clear font caches
    //
    g_oeFhLast.fontIndex = 0xFFFF;

    //
    // Enable or disable GDI patches
    //
    for (patch = DDI_FIRST; patch < DDI_MAX; patch++)
    {
        EnableFnPatch(&g_oeDDPatches[patch], (fViewers ? PATCH_ACTIVATE :
            PATCH_DEACTIVATE));
    }

    //
    // Do save bits & cursor patches too
    //
    SSI_DDViewing(fViewers);
    CM_DDViewing(fViewers);

    if (fViewers)
    {
        //
        // Our palette color array starts out as all black on each share.
        // So force PMUpdateSystemColors() to do something.
        //
        ASSERT(g_asSharedMemory);
        g_asSharedMemory->pmPaletteChanged = TRUE;
    }

    DebugExitVOID(OE_DDViewing);
}





//
// FUNCTION:    OEDDSetNewCapabilities
//
// DESCRIPTION:
//
// Set the new OE related capabilities
//
// RETURNS:
//
// NONE
//
// PARAMETERS:
//
// pDataIn  - pointer to the input buffer
//
//
void  OEDDSetNewCapabilities(LPOE_NEW_CAPABILITIES pCapabilities)
{
    LPBYTE  lpos16;

    DebugEntry(OEDDSetNewCapabilities);

    //
    // Copy the data from the Share Core.
    //
    g_oeBaselineTextEnabled = pCapabilities->baselineTextEnabled;

    g_oeSendOrders          = pCapabilities->sendOrders;

    g_oeTextEnabled         = pCapabilities->textEnabled;

    //
    // The share core has passed down a pointer to it's copy of the order
    // support array.  We take a copy for the kernel here.
    //
    lpos16 = MapLS(pCapabilities->orderSupported);
    if (SELECTOROF(lpos16))
    {
        hmemcpy(g_oeOrderSupported, lpos16, sizeof(g_oeOrderSupported));
        UnMapLS(lpos16);
    }
    else
    {
        UINT    i;

        ERROR_OUT(("OEDDSetNewCaps:  can't save new order array"));

        for (i = 0; i < sizeof(g_oeOrderSupported); i++)
            g_oeOrderSupported[i] = FALSE;
    }

    TRACE_OUT(( "OE caps: BLT %c Orders %c Text %c",
                 g_oeBaselineTextEnabled ? 'Y': 'N',
                 g_oeSendOrders ? 'Y': 'N',
                 g_oeTextEnabled ? 'Y': 'N'));
                    
    DebugExitVOID(OEDDSetNewCapabilities);
}



//
// FUNCTION:    OEDDSetNewFonts
//
// DESCRIPTION:
//
// Set the new font handling information to be used by the display driver.
//
// RETURNS:
//
// NONE
//
//
void  OEDDSetNewFonts(LPOE_NEW_FONTS pRequest)
{
    HGLOBAL hMem;
    UINT    cbNewSize;
    LPVOID  lpFontData;
    LPVOID  lpFontIndex;

    DebugEntry(OEDDSetNewFonts);

    TRACE_OUT(( "New fonts %d", pRequest->countFonts));

    //
    // Initialize new number of fonts to zero in case an error happens.
    // We don't want to use stale font info if so.  And clear the font
    // cache.
    //
    g_oeNumFonts = 0;
    g_oeFhLast.fontIndex = 0xFFFF;

    g_oeFontCaps = pRequest->fontCaps;

    //
    // Can we get 16:16 addresses for font info?
    //
    lpFontData = MapLS(pRequest->fontData);
    lpFontIndex = MapLS(pRequest->fontIndex);
    if (!lpFontData || !lpFontIndex)
    {
        ERROR_OUT(("OEDDSetNewFonts: couldn't map flat addresses to 16-bit"));
        DC_QUIT;
    }

    //
    // Realloc our current font block if we need to.  Always shrink it
    // too, this thing can get large!
    //
    ASSERT(pRequest->countFonts <= (0xFFFF / sizeof(LOCALFONT)));
    cbNewSize = pRequest->countFonts * sizeof(LOCALFONT);

    hMem = (HGLOBAL)SELECTOROF(g_poeLocalFonts);

    hMem = GlobalReAlloc(hMem, cbNewSize, GMEM_MOVEABLE | GMEM_SHARE);
    if (!hMem)
    {
        ERROR_OUT(("OEDDSetNewFonts: can't allocate space for font info"));
        DC_QUIT;
    }
    else
    {
        g_poeLocalFonts = MAKELP(hMem, 0);
    }

    //
    // We got here, so everything is OK.  Update the font info we have.
    //
    g_oeNumFonts = pRequest->countFonts;

    hmemcpy(g_poeLocalFonts, lpFontData, cbNewSize);

    hmemcpy(g_oeLocalFontIndex, lpFontIndex,
        sizeof(g_oeLocalFontIndex[0]) * FH_LOCAL_INDEX_SIZE);

DC_EXIT_POINT:
    if (lpFontData)
        UnMapLS(lpFontData);

    if (lpFontIndex)
        UnMapLS(lpFontIndex);

    DebugExitVOID(OEDDSetNewFonts);
}



//
// UTILITY ROUTINES
//


//
// OEGetPolarity()
// Gets the axes polarity signs.
//
// NOTE that we fill in the ptPolarity field of our OESTATE global, to
// save on stack.
//
void OEGetPolarity(void)
{
    SIZE    WindowExtent;
    SIZE    ViewportExtent;

    DebugEntry(OEGetPolarity);

    switch (GetMapMode(g_oeState.hdc))
    {
        case MM_ANISOTROPIC:
        case MM_ISOTROPIC:
            GetWindowExtEx(g_oeState.hdc, &WindowExtent);
            GetViewportExtEx(g_oeState.hdc, &ViewportExtent);

            if ((ViewportExtent.cx < 0) == (WindowExtent.cx < 0))
                g_oeState.ptPolarity.x = 1;
            else
                g_oeState.ptPolarity.x = -1;

            if ((ViewportExtent.cy < 0) == (WindowExtent.cy < 0))
                g_oeState.ptPolarity.y = 1;
            else
                g_oeState.ptPolarity.y = -1;
            break;

        case MM_HIENGLISH:
        case MM_HIMETRIC:
        case MM_LOENGLISH:
        case MM_LOMETRIC:
        case MM_TWIPS:
            g_oeState.ptPolarity.x = 1;
            g_oeState.ptPolarity.y = -1;
            break;

        default:
            g_oeState.ptPolarity.x = 1;
            g_oeState.ptPolarity.y = 1;
            break;
    }

    DebugExitVOID(OEGetPolarity);
}


//
// OEGetState()
// This sets up the fields in the g_oeState global, depending on what
// a particular DDI needs.  That is conveyed via the flags.
//
void OEGetState
(
    UINT    uFlags
)
{
    DWORD   dwOrg;

    DebugEntry(OEGetState);

    if (uFlags & OESTATE_COORDS)
    {
        dwOrg = GetDCOrg(g_oeState.hdc);
        g_oeState.ptDCOrg.x = LOWORD(dwOrg);
        g_oeState.ptDCOrg.y = HIWORD(dwOrg);

        OEGetPolarity();
    }

    if (uFlags & OESTATE_PEN)
    {
        // Try to get the pen data
        if (!GetObject(g_oeState.lpdc->hPen, sizeof(g_oeState.logPen),
                &g_oeState.logPen))
        {
            ERROR_OUT(("Couldn't get pen info"));
            g_oeState.logPen.lopnWidth.x = 1;
            g_oeState.logPen.lopnWidth.y = 1;
            g_oeState.logPen.lopnStyle   = PS_NULL;
            uFlags &= ~OESTATE_PEN;
        }
    }

    if (uFlags & OESTATE_BRUSH)
    {
        // Try to get the brush data
        if (!GetObject(g_oeState.lpdc->hBrush, sizeof(g_oeState.logBrush),
                &g_oeState.logBrush))
        {
            ERROR_OUT(("Couldn't get brush info"));
            g_oeState.logBrush.lbStyle = BS_NULL;
            uFlags &= ~OESTATE_BRUSH;
        }
    }

    if (uFlags & OESTATE_FONT)
    {
        // Try to get the logfont data
        if (!GetObject(g_oeState.lpdc->hFont, sizeof(g_oeState.logFont),
            &g_oeState.logFont))
        {
            ERROR_OUT(("Gouldn't get font info"));

            //
            // Fill in an empty face name
            //
            g_oeState.logFont.lfFaceName[0] = 0;
            uFlags &= ~OESTATE_FONT;
        }
        else
        {
            GetTextMetrics(g_oeState.hdc, &g_oeState.tmFont);
            g_oeState.tmAlign = GetTextAlign(g_oeState.hdc);
        }
    }

    if (uFlags & OESTATE_REGION)
    {
        DWORD   cbSize;

        cbSize = GetRegionData(g_oeState.lpdc->hRaoClip,
            sizeof(g_oeState.rgnData), (LPRGNDATA)&g_oeState.rgnData);
        if (cbSize > sizeof(g_oeState.rgnData))
        {
            WARNING_OUT(("Clip region %04x is too big, unclipped drawing may result"));
        }

        if (!cbSize || (cbSize > sizeof(g_oeState.rgnData)))
        {
            // Bound box is best we can do.
            RECT    rcBound;

            if (GetRgnBox(g_oeState.lpdc->hRaoClip, &rcBound) <= NULLREGION)
            {
                WARNING_OUT(("Couldn't even get bounding box of Clip region"));
                SetRectEmpty(&rcBound);
            }

            g_oeState.rgnData.rdh.iType = SIMPLEREGION;
            g_oeState.rgnData.rdh.nRgnSize = sizeof(RDH) + sizeof(RECTL);
            g_oeState.rgnData.rdh.nRectL = 1;
            RECT_TO_RECTL(&rcBound, &g_oeState.rgnData.rdh.arclBounds);
            RECT_TO_RECTL(&rcBound, g_oeState.rgnData.arclPieces);
        }
    }

    g_oeState.uFlags |= uFlags;

    DebugExitVOID(OEGetState);
}


//
// OEPolarityAdjust()
// This swaps the coordinates of a rectangle based on the sign polarity.
//
// NOTE:  We use the g_oeState polarity field.  So this function assumes
// polarity is setup already.
//
void OEPolarityAdjust
(
    LPRECT  aRects,
    UINT    cRects
)
{
    int     tmp;

    DebugEntry(OEPolarityAdjust);

    ASSERT(g_oeState.uFlags & OESTATE_COORDS);

    while (cRects > 0)
    {
        if (g_oeState.ptPolarity.x < 0)
        {
            // Swap left & right
            tmp = aRects->left;
            aRects->left = aRects->right;
            aRects->right = tmp;
        }

        if (g_oeState.ptPolarity.y < 0)
        {
            // Swap top & bottom
            tmp = aRects->top;
            aRects->top = aRects->bottom;
            aRects->bottom = tmp;
        }

        cRects--;
        aRects++;
    }

    DebugExitVOID(OEPolarityAdjust);
}


//
// OECheckOrder()
// This checks for the common stuff that all the DDIs do before deciding
// to send an order or accumulate screen data.
//
BOOL OECheckOrder
(
    DWORD   order,
    UINT    flags
)
{
    if (!OE_SendAsOrder(order))
        return(FALSE);

    if ((flags & OECHECK_PEN) && !OECheckPenIsSimple())
        return(FALSE);

    if ((flags & OECHECK_BRUSH) && !OECheckBrushIsSimple())
        return(FALSE);

    if ((flags & OECHECK_CLIPPING) && OEClippingIsComplex())
        return(FALSE);

    return(TRUE);
}


//
// OELPtoVirtual()
// Converts coords from logical to device (pixels).  This does map mode
// then translation offsets.
//
void OELPtoVirtual
(
    HDC     hdc,
    LPPOINT aPts,
    UINT    cPts
)
{
    LONG    l;
    int     s;

    DebugEntry(OELPtoVirtual);

    ASSERT(g_oeState.uFlags & OESTATE_COORDS);

    ASSERT(hdc == g_oeState.hdc);

    //
    // Convert to pixels
    //
    LPtoDP(hdc, aPts, cPts);

    //
    // Use the device origin, so we can convert from DC-relative to screen
    // coords.
    //

    while (cPts > 0)
    {
        //
        // Prevent overflow
        //
        l = (LONG)aPts->x + (LONG)g_oeState.ptDCOrg.x;
        s = (int)l;

        if (l == (LONG)s)
        {
            aPts->x = s;
        }
        else
        {
            //
            // HIWORD(l) will be 1 for positive overflow, 0xFFFF for
            // negative overflow.  Therefore we will get 0x7FFE or 0x8000
            // (+32766 or -32768).
            //
            aPts->x = 0x7FFF - HIWORD(l);
            TRACE_OUT(("adjusted X from %ld to %d", l, aPts->x));
        }

        //
        // Look for int overflow in the Y coordinate
        //
        l = (LONG)aPts->y + (LONG)g_oeState.ptDCOrg.y;
        s = (int)l;

        if (l == (LONG)s)
        {
            aPts->y = s;
        }
        else
        {
            //
            // HIWORD(l) will be 1 for positive overflow, 0xFFFF for
            // negative overflow.  Therefore we will get 0x7FFE or 0x8000
            // (+32766 or -32768).
            //
            aPts->y = 0x7FFF - HIWORD(l);
            TRACE_OUT(("adjusted Y from %ld to %d", l, aPts->y));
        }

        //
        // Move on to the next point
        //
        --cPts;
        ++aPts;
    }

    DebugExitVOID(OELPtoVirtual);
}



//
// OELRtoVirtual
//
// Adjusts RECT in window coordinates to virtual coordinates.  Clips the
// result to [+32766, -32768] which is near enough to [+32767, -32768]
//
// NB.  This function takes a Windows rectangle (Exclusive coords) and
//      returns a DC-Share rectangle (inclusive coords).
//      This means that any calling function can safely convert to inclusive
//      without having to worry above overflowing.
//
void OELRtoVirtual
(
    HDC     hdc,
    LPRECT  aRects,
    UINT    cRects
)
{
    int     temp;

    DebugEntry(OELRtoVirtual);

    //
    // Convert the points to screen coords, clipping to INT16s
    //
    OELPtoVirtual(hdc, (LPPOINT)aRects, 2 * cRects);

    //
    // Make each rectangle inclusive
    //
    while (cRects > 0)
    {
        //
        // LAURABU BOGUS!
        // Use OEPolarityAdjust() instead, this is safer.
        //

        //
        // If the rect is bad then flip the edges.  This will be the case
        // if the LP coordinate system is running in a different direction
        // than the device coordinate system.
        //
        if (aRects->left > aRects->right)
        {
            TRACE_OUT(("Flipping x coords"));

            temp = aRects->left;
            aRects->left = aRects->right;
            aRects->right = temp;
        }

        if (aRects->top > aRects->bottom)
        {
            TRACE_OUT(("Flipping y coords"));

            temp = aRects->top;
            aRects->top = aRects->bottom;
            aRects->bottom = temp;
        }

        aRects->right--;
        aRects->bottom--;

        //
        // Move on to the next rect
        //
        cRects--;
        aRects++;
    }

    DebugExitVOID(OELRtoVirtual);
}



//
// OE_SendAsOrder()
//
BOOL  OE_SendAsOrder(DWORD order)
{
    BOOL  rc = FALSE;

    DebugEntry(OE_SendAsOrder);

    //
    // Only check the order if we are allowed to send orders in the first
    // place!
    //
    if (g_oeSendOrders)
    {
        TRACE_OUT(("Orders enabled"));

        //
        // We are sending some orders, so check individual flags.
        //
        rc = (BOOL)g_oeOrderSupported[HIWORD(order)];
        TRACE_OUT(("Send order %lx HIWORD %u", order, HIWORD(order)));
    }

    DebugExitDWORD(OE_SendAsOrder, rc);
    return(rc);
}

//
// FUNCTION: OESendRop3AsOrder.
//
// DESCRIPTION:
//
// Checks to see if the rop uses the destination bits. If it does then
// returns FALSE unless the "send all rops" property flag is set.
//
// PARAMETERS: The rop3 to be checked (in protocol format ie a byte).
//
// RETURNS: TRUE if the rop3 should be sent as an order.
//
//
BOOL OESendRop3AsOrder(BYTE rop3)
{
    BOOL   rc = TRUE;

    DebugEntry(OESendRop3AsOrder);

    //
    // Rop 0x5F is used by MSDN to highlight search keywords.  This XORs
    // a pattern with the destination, producing markedly different (and
    // sometimes unreadable) shadow output.  We special-case no-encoding for
    // it.
    //
    if (rop3 == 0x5F)
    {
        WARNING_OUT(("Rop3 0x5F never encoded"));
        rc = FALSE;
    }

    DebugExitBOOL(OESendRop3AsOrder, rc);
    return(rc);
}


//
// OEPenWidthAdjust()
//
// Adjusts a rectangle to allow for the current pen width divided by
// the divisor, rounding up.
//
// NOTE:  This routine uses the logPen and ptPolarity fields of g_oeState.
//
void OEPenWidthAdjust
(
    LPRECT      lprc,
    UINT        divisor
)
{
    UINT        width;
    UINT        roundingFactor = divisor - 1;

    DebugEntry(OEPenWidthAdjust);

    width = max(g_oeState.logPen.lopnWidth.x, g_oeState.logPen.lopnWidth.y);

    InflateRect(lprc,
        ((g_oeState.ptPolarity.x * width) +
             (g_oeState.ptPolarity.x * roundingFactor)) / divisor,
        ((g_oeState.ptPolarity.y * width) +
             (g_oeState.ptPolarity.x * roundingFactor)) / divisor);

    DebugExitVOID(OEPenWidthAdjust);
}



//
// Function:    OEExpandColor
//
// Description: Converts a generic bitwise representation of an RGB color
//              index into an 8-bit color index as used by the line
//              protocol.
//
void  OEExpandColor
(
    LPBYTE  lpField,
    DWORD   srcColor,
    DWORD   mask
)
{
    DWORD   colorTmp;

    DebugEntry(OEExpandColor);

    //
    // Different example bit masks:
    //
    // Normal 24-bit:
    //      0x000000FF  (red)
    //      0x0000FF00  (green)
    //      0x00FF0000  (blue)
    //
    // True color 32-bits:
    //      0xFF000000  (red)
    //      0x00FF0000  (green)
    //      0x0000FF00  (blue)
    //
    // 5-5-5 16-bits
    //      0x0000001F  (red)
    //      0x000003E0  (green)
    //      0x00007C00  (blue)
    //
    // 5-6-5 16-bits
    //      0x0000001F  (red)
    //      0x000007E0  (green)
    //      0x0000F800  (blue)
    //
    //
    // Convert the color using the following algorithm.
    //
    // <new color> = <old color> * <new bpp mask> / <old bpp mask>
    //
    // where:
    //
    // new bpp mask = mask for all bits at new setting (0xFF for 8bpp)
    //
    // This way maximal (eg.  0x1F) and minimal (eg.  0x00) settings are
    // converted into the correct 8-bit maximum and minimum.
    //
    // Rearranging the above equation we get:
    //
    // <new color> = (<old color> & <old bpp mask>) * 0xFF / <old bpp mask>
    //
    // where:
    //
    // <old bpp mask> = mask for the color
    //

    //
    // LAURABU BOGUS:
    // We need to avoid overflow caused by the multiply.  NOTE:  in theory
    // we should use a double, but that's painfully slow.  So for now hack
    // it.  If the HIBYTE is set, just right shift 24 bits.
    //
    colorTmp = srcColor & mask;
    if (colorTmp & 0xFF000000)
        colorTmp >>= 24;
    else
        colorTmp = (colorTmp * 0xFF) / mask;
    *lpField = (BYTE)colorTmp;

    TRACE_OUT(( "0x%lX -> 0x%X", srcColor, (WORD)*lpField));

    DebugExitVOID(OEExpandColor);
}


//
// OEConvertColor()
// Converts a PHYSICAL color to a real RGB
//
void OEConvertColor
(
    DWORD           rgb,
    LPTSHR_COLOR    lptshrDst,
    BOOL            fAllowDither
)
{
    DWORD           rgbConverted;
    PALETTEENTRY    pe;
    int             pal;
    DWORD           numColors;

    DebugEntry(OEConvertColor);

    rgbConverted = rgb;

    //
    // Get the current palette size.
    //
    GetObject(g_oeState.lpdc->hPal, sizeof(pal), &pal);
    if (pal == 0)
    {
        //
        // GDI has a bug.  It allows a ResizePalette() call to set a new
        // size of zero for the palette.  If you subsequently make
        // certain palette manager calls on such a palette, GDI will fault.
        //
        // To avoid this problem, as seen in 3D Kitchen by Books that Work,
        // we check for this case and simply return the input color.
        //
        WARNING_OUT(("Zero-sized palette"));
        DC_QUIT;
    }

    if (g_oeState.lpdc->hPal == g_oeStockPalette)
    {
        //
        // Quattro Pro and others put junk in the high bits of their colors.
        // We need to mask it out.
        //
        if (rgb & 0xFC000000)
        {
            rgb &= 0x00FFFFFF;
        }
        else
        {
            if (rgb & PALETTERGB_FLAG)
            {
                //
                // Using PALETTERGB is just like using an RGB, turn it off.
                // The color will be dithered, if necessary, using the
                // default system colors.
                //
                rgb &= 0x01FFFFFF;

            }
        }
    }

    if (rgb & COLOR_FLAGS)
    {
        if (rgb & PALETTERGB_FLAG)
        {
            pal = GetNearestPaletteIndex(g_oeState.lpdc->hPal, rgb);
        }
        else
        {
            ASSERT(rgb & PALETTEINDEX_FLAG);
            pal = LOWORD(rgb);
        }

        //
        // Look up entry in palette.
        //
        if (!GetPaletteEntries(g_oeState.lpdc->hPal, pal, 1, &pe))
        {
            ERROR_OUT(("GetPaletteEntries failed for index %d", pal));
            *((LPDWORD)&pe) = 0L;
        }
        else if (pe.peFlags & PC_EXPLICIT)
        {
            //
            // If this is PC_EXPLICIT, it's an index into the system 
            // palette.
            //
            pal = LOWORD(*((LPDWORD)&pe));

            if (g_osiScreenBPP < 32)
            {
                numColors = 1L << g_osiScreenBPP;
            }
            else
            {
                numColors = 0xFFFFFFFF;
            }

            if (numColors > 256)
            {
                //
                // We are on a direct color device.  What does explicit 
                // mean in this case?  The answer is, use the VGA color
                // palette.
                //
                pe = g_osiVgaPalette[pal % 16];
            }
            else
            {
                pal %= numColors;

                GetSystemPaletteEntries(g_oeState.hdc, pal, 1, &pe);
            }
        }

        rgbConverted = *((LPDWORD)&pe);
    }

DC_EXIT_POINT:
    //
    // To get the correct results for any RGBs we send to true color systems,
    // we need to normalize the RGB to an exact palette match on the local
    // system.  This is because we aren't guaranteed that the RGB on the 
    // local will have an exact match to the current system palette.  If
    // not, then GDI will convert them locally, but the orders will send
    // to remotes will be displayed exactly, resulting in a mismatch.
    //
    if ((g_osiScreenBPP == 8)   &&
        !(rgb & COLOR_FLAGS)    &&
        (!fAllowDither || (g_oeState.lpdc->hPal != g_oeStockPalette)))
    {
        TSHR_RGBQUAD    rgq;

        rgbConverted &= 0x00FFFFFF;

        //
        // Common cases.
        //
        if ((rgbConverted == RGB(0, 0, 0)) ||
            (rgbConverted == RGB(0xFF, 0xFF, 0xFF)))
        {
            goto ReallyConverted;
        }

        //
        // g_osiScreenBMI.bmiHeader is already filled in.
        //

        //
        // NOTE:
        // We don't need or want to realize any palettes.  We want color
        // mapping based on the current screen palette contents.
        //
        // We disable SetPixel() patch, or our trap will trash the
        // variables for this call.
        //

        //
        // g_osiMemoryDC() always has our 1x1 color bitmap g_osiMemoryBMP
        // selected into it.
        //

        EnableFnPatch(&g_oeDDPatches[DDI_SETPIXEL], PATCH_DISABLE);
        SetPixel(g_osiMemoryDC, 0, 0, rgbConverted);
        EnableFnPatch(&g_oeDDPatches[DDI_SETPIXEL], PATCH_ENABLE);

        //
        // Get mapped color index
        //
        GetDIBits(g_osiMemoryDC, g_osiMemoryBMP, 0, 1, &pal,
            (LPBITMAPINFO)&g_osiScreenBMI, DIB_RGB_COLORS);

        rgq =  g_osiScreenBMI.bmiColors[LOBYTE(pal)];

        OTRACE(("Mapped color %08lx to %08lx", rgbConverted,
            RGB(rgq.rgbRed, rgq.rgbGreen, rgq.rgbBlue)));

        rgbConverted = RGB(rgq.rgbRed, rgq.rgbGreen, rgq.rgbBlue);
    }

ReallyConverted:
    lptshrDst->red  = GetRValue(rgbConverted);
    lptshrDst->green = GetGValue(rgbConverted);
    lptshrDst->blue = GetBValue(rgbConverted);

    DebugExitVOID(OEConvertColor);
}



//
// OEGetBrushInfo()
// Standard brush goop
//
void OEGetBrushInfo
(
    LPTSHR_COLOR    pBack,
    LPTSHR_COLOR    pFore,
    LPTSHR_UINT32   pStyle,
    LPTSHR_UINT32   pHatch,
    LPBYTE          pExtra
)
{
    int             iRow;

    DebugEntry(OEGetBrushInfo);

    OEConvertColor(g_oeState.lpdc->DrawMode.bkColorL, pBack, FALSE);

    *pStyle = g_oeState.logBrush.lbStyle;

    if (g_oeState.logBrush.lbStyle == BS_PATTERN)
    {
        //
        // We only track mono patterns, so the foreground color is the 
        // brush color.
        //
        OEConvertColor(g_oeState.lpdc->DrawMode.txColorL, pFore, FALSE);

        // For pattern brushes, the hatch stores the 1st pattern byte,
        // the Extra field the remaining 7 pattern bytes
        *pHatch = g_oeState.logBrushExtra[0];
        hmemcpy(pExtra, g_oeState.logBrushExtra+1, TRACKED_BRUSH_SIZE-1);
    }
    else
    {
        ASSERT(g_oeState.logBrush.lbStyle != BS_DIBPATTERN);

        OEConvertColor(g_oeState.logBrush.lbColor, pFore, TRUE);

        // The hatch is the hatch style
        *pHatch = g_oeState.logBrush.lbHatch;

        // Extra info is empty
        for (iRow = 0; iRow < TRACKED_BRUSH_SIZE-1; iRow++)
        {
            pExtra[iRow] = 0;
        }
    }

    DebugExitVOID(OEGetBrushInfo);
}



//
// OEClippingIsSimple()
//
BOOL OEClippingIsSimple(void)
{
    BOOL        fSimple;
    RECT        rc;

    DebugEntry(OEClippingIsSimple);

    ASSERT(g_oeState.uFlags & OESTATE_REGION);

    fSimple = (g_oeState.rgnData.rdh.nRectL <= 1);

    DebugExitBOOL(OEClippingIsSimple, fSimple);
    return(fSimple);
}

//
// OEClippingIsComplex()
//
BOOL OEClippingIsComplex(void)
{
    BOOL        fComplex;

    DebugEntry(OEClippingIsComplex);

    ASSERT(g_oeState.uFlags & OESTATE_REGION);

    fComplex = (g_oeState.rgnData.rdh.nRgnSize >=
        sizeof(RDH) + CRECTS_COMPLEX*sizeof(RECTL));

    DebugExitBOOL(OEClippingIsComplex, fComplex);
    return(fComplex);
}



//
// OECheckPenIsSimple()
//
BOOL OECheckPenIsSimple(void)
{
    POINT   ptArr[2];
    BOOL    fSimple;

    DebugEntry(OECheckPenIsSimple);

    if (g_oeState.uFlags & OESTATE_PEN)
    {
        ptArr[0].x = ptArr[0].y = 0;
        ptArr[1].x = g_oeState.logPen.lopnWidth.x;
        ptArr[1].y = 0;

        LPtoDP(g_oeState.hdc, ptArr, 2);

        fSimple = ((ptArr[1].x - ptArr[0].x) <= 1);
    }
    else
    {
        // The current pen in the DC is invalid
        WARNING_OUT(("Invalid pen selected into DC"));
        fSimple = FALSE;
    }

    DebugExitBOOL(OECheckPenIsSimple, fSimple);
    return(fSimple);
}


//
// OECheckBrushIsSimple()
//
BOOL OECheckBrushIsSimple(void)
{
    BOOL    fSimple;

    DebugEntry(OECheckBrushIsSimple);

    // Assume not simple
    fSimple = FALSE;

    if (g_oeState.uFlags & OESTATE_BRUSH)
    {
        //
        // If the brush is a pattern, it's OK if one of standard pattern 
        // brushes.  If it comes from a DIB, it's never OK.  All other 
        // brushes are OK.
        //
        if (g_oeState.logBrush.lbStyle == BS_PATTERN)
        {
            LPGDIHANDLE lpgh;
            LPBRUSH     lpBrush;
            LPBITMAP    lpPattern;

            //
            // For pattern brushes, the lbHatch field of the ilBrushOverhead
            // item in the GDI local BRUSH object is a global handle to
            // a memory block that is the BITMAP of the thing.
            //

            //
            // BOGUS LAURABU:
            // NM 2.0 Win95 went to a lot more work to check if a color bitmap
            // pattern brush had only 2 colors and therefore was orderable.  But 
            // I can't find a single that uses such a thing.  So for now, we just 
            // care if the pattern bitmap is monochrome and the pattern is between 8x8 and
            // 16x8.
            //

            // Get a pointer to the brush data
            lpgh = MAKELP(g_hInstGdi16, g_oeState.lpdc->hBrush);
            ASSERT(!IsBadReadPtr(lpgh, sizeof(DWORD)));
            ASSERT(!(lpgh->objFlags & OBJFLAGS_SWAPPEDOUT));

            lpBrush = MAKELP(g_hInstGdi16, lpgh->pGdiObj);
            ASSERT(!IsBadReadPtr(lpBrush, sizeof(BRUSH)));

            // Get the bitmapinfo handle -- it's the lbHatch field
            lpPattern = MAKELP(lpBrush->ilBrushOverhead.lbHatch, 0);

            //
            // Macromedia Director among others creates pattern brushes
            // with no pattern.  We therefore consider these objects to
            // be too complex to send in an order
            //

            //
            // Is this monochrome with a pattern between 8 and 16 pels?
            // We save the left 8 pixel grid if so.
            //
            if (!IsBadReadPtr(lpPattern, sizeof(BITMAP)) &&
                (lpPattern->bmWidth >= MIN_BRUSH_WIDTH) &&
                (lpPattern->bmWidth <= MAX_BRUSH_WIDTH) &&
                (lpPattern->bmHeight == TRACKED_BRUSH_HEIGHT) &&
                (lpPattern->bmPlanes == 1) && (lpPattern->bmBitsPixel == 1))
            {
                LPUINT  lpRow;
                int     iRow;

                // Save the pattern away in logBrushExtra
                lpRow = lpPattern->bmBits;
                ASSERT(!IsBadReadPtr(lpRow, TRACKED_BRUSH_HEIGHT*sizeof(UINT)));

                //
                // The pattern is always WORD aligned.  But only the
                // LOBYTE has meaning.  
                // 
                // NOTE:
                // We fill the pattern in DIB order, namely bottom to
                // top.
                //
                ASSERT(lpPattern->bmWidthBytes == 2);
                for (iRow = 0; iRow < TRACKED_BRUSH_HEIGHT; iRow++, lpRow++)
                {
                    g_oeState.logBrushExtra[TRACKED_BRUSH_HEIGHT - 1 - iRow] =
                        (BYTE)*lpRow;
                }

                fSimple = TRUE;
            }
        }
        else if (g_oeState.logBrush.lbStyle != BS_DIBPATTERN)
        {
            fSimple = TRUE;
        }
    }
    else
    {
        WARNING_OUT(("Invalid brush selected into DC"));
    }

    DebugExitBOOL(OECheckBrushIsSimple, fSimple);
    return(fSimple);
}




//
// OEAddLine()
// This calculates the bounds of a line output call, and either adds an
// order or gets set for screen data accum.
//
void OEAddLine
(
    POINT       ptStart,
    POINT       ptEnd
)
{
    LPINT_ORDER     pOrder;
    LPLINETO_ORDER  pLineTo;

    DebugEntry(OEAddLine);

    //
    // Get the bounds
    //
    g_oeState.rc.left = min(ptStart.x, ptEnd.x);
    g_oeState.rc.top  = min(ptStart.y, ptEnd.y);
    g_oeState.rc.right = max(ptStart.x, ptEnd.x);
    g_oeState.rc.bottom = max(ptStart.y, ptEnd.y);

    //
    // Adjust for axes polarity and pen dimensions
    //
    ASSERT(g_oeState.uFlags & OESTATE_COORDS);

    OEPolarityAdjust(&g_oeState.rc, 1);
    OEPenWidthAdjust(&g_oeState.rc, 1);

    //
    // OEPenWidthAdjust returns an inclusive rect.  But OELRtoVirtual
    // expects an exclusive.  After it returns, we need to add back
    // the extra subtraction.
    //
    // NOTE that OELRtoVirtual also adjusts for virtual desktop origin.
    //
    OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

    g_oeState.rc.right++;
    g_oeState.rc.bottom++;

    //
    // Now we have the true draw bounds.  Can we send this as an order?
    //
    pOrder = NULL;

    if (OECheckOrder(ORD_LINETO, OECHECK_PEN | OECHECK_CLIPPING))
    {
        //
        // We can send an order.
        //
        pOrder = OA_DDAllocOrderMem(sizeof(LINETO_ORDER), 0);
        if (!pOrder)
            DC_QUIT;

        pLineTo = (LPLINETO_ORDER)pOrder->abOrderData;

        pLineTo->type      = LOWORD(ORD_LINETO);

        //
        // Must do this first:  oords in the LINETO order are 32-bit
        //
        OELPtoVirtual(g_oeState.hdc, &ptStart, 1);
        OELPtoVirtual(g_oeState.hdc, &ptEnd, 1);

        pLineTo->nXStart   = ptStart.x;
        pLineTo->nYStart   = ptStart.y;
        pLineTo->nXEnd     = ptEnd.x;
        pLineTo->nYEnd     = ptEnd.y;

        //
        // This is a physical color
        //
        OEConvertColor(g_oeState.lpdc->DrawMode.bkColorL,
            &pLineTo->BackColor, FALSE);

        pLineTo->BackMode  = g_oeState.lpdc->DrawMode.bkMode;
        pLineTo->ROP2      = g_oeState.lpdc->DrawMode.Rop2;
        pLineTo->PenStyle  = g_oeState.logPen.lopnStyle;

        //
        // Currently only pen withs of 1 are supported.  Unfortunately
        // GDI left it up to the driver to decide on how to stroke the
        // line, so we can't predict what pixels will be on or off for
        // pen widths bigger.
        //
        pLineTo->PenWidth = 1;

        //
        // This is a logical color
        //
        OEConvertColor(g_oeState.logPen.lopnColor, &pLineTo->PenColor,
            FALSE);

        //
        // Store the general order data.
        //
        pOrder->OrderHeader.Common.fOrderFlags   = OF_SPOILABLE;

        //
        // This will add in OESTATE_SENTORDER if it succeeded.
        // Then OEDDPostStopAccum() will ignore screen data, or
        // will add our nicely calculated bounds above in instead.
        //
        OTRACE(("Line:  Start {%d, %d}, End {%d, %d}", ptStart.x, ptStart.y,
            ptEnd.x, ptEnd.y));
        OEClipAndAddOrder(pOrder, NULL);
    }

DC_EXIT_POINT:
    if (!pOrder)
    {
        OTRACE(("Line:  Sending as screen data {%d, %d, %d, %d}",
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom));
        OEClipAndAddScreenData(&g_oeState.rc);
    }

    DebugExitVOID(OEAddLine);
}




//
// OEValidateDC()
// This makes sure the thing passed in is a valid DC and gets a pointer to
// the DC data structure in GDI if so.  We need to handle the (rare) case
// of the DC being swapped out to GDI's extended flat memory space as well 
// as the HDC being prsent in GDI's 16-bit dataseg
//
// NOTE:
// It is NOT valid to hang on to a LPDC around a GDI call.  Something may
// be swapped out before the call, then get swapped in after the call.  
// In which case the original based32 ptr gets freed.  And vice-versa, the
// original GDI dc-16 localptr may get realloced small.
//
// In normal usage, this is very fast.  Only in low memory (or when 
// parameters are invalid) does doing this twice even matter.
//
LPDC OEValidateDC
(
    HDC     hdc,
    BOOL    fSrc
)
{
    LPDC        lpdc = NULL;
    LPGDIHANDLE lpgh;
    DWORD       dwBase;

    DebugEntry(OEDDValidateDC);

    if (IsGDIObject(hdc) != GDIOBJ_DC)
    {
        // 
        // This is a metafile HDC, an IC, or just a plain old bad param.
        //
        DC_QUIT;
    }

    //
    // OK. The HDC is a local handle to two words in GDI's DS:
    //      * 1st is actual ptr of DC (or local32 handle if swapped out)
    //      * 2nd is flags
    //
    // NOTE:
    // Gdi's data segment is already GlobalFixed().  So we don't have to
    // worry about it moving.
    //
    lpgh = MAKELP(g_hInstGdi16, hdc);
    if (lpgh->objFlags & OBJFLAGS_SWAPPEDOUT)
    {
        UINT    uSel;

        //
        // This is an error only so we can actually stop when we hit this
        // rare case and make sure our code is working!
        //
        WARNING_OUT(("DC is swapped out, getting at far heap info"));

        //
        // Need to make our cached selector  point at this thing.  NOTE that
        // in OEDDStopAccum, we need to reget lpdc since it will have been
        // swapped in during the output call.
        //

        dwBase = GetSelectorBase((UINT)g_hInstGdi16);
        ASSERT(dwBase);

        uSel = (fSrc ? g_oeSelSrc : g_oeSelDst);
        SetSelectorBase(uSel, dwBase + 0x10000);

        //
        // The pGdiObj is the local32 handle.  GDI:10000+pGdiObj has a DWORD
        // which is the based32 address, relative to GDI's dataseg, of the DC.
        // We've set the base of our selector 64K higher than GDI, so we can
        // use it as an offset directly.
        //
        ASSERT(!IsBadReadPtr(MAKELP(uSel, lpgh->pGdiObj), sizeof(DWORD)));
        dwBase = *(LPDWORD)MAKELP(uSel, lpgh->pGdiObj);
        
        //
        // The 16-bit base is the nearest 64K less than this 32-bit pointer,
        // above GDI's ds.
        //
        SetSelectorBase(uSel, GetSelectorBase((UINT)g_hInstGdi16) +
            (dwBase & 0xFFFF0000));

        //
        // Remainder is slop past 64K.
        //
        lpdc = MAKELP(uSel, LOWORD(dwBase));
    }
    else
    {
        lpdc = MAKELP(g_hInstGdi16, lpgh->pGdiObj);
    }

    ASSERT(!IsBadReadPtr(lpdc, sizeof(DC)));

DC_EXIT_POINT:
    DebugExitDWORD(OEDDValidateDC, (DWORD)lpdc);
    return(lpdc);
}


//
// OEBeforeDDI()
//
// This does all the common stuff at the start of an intercepted DDI call:
//      * Increment the reentrancy count
//      * Disable the patch
//      * Get a ptr to the DC structure (if valid)
//      * Get some attributes about the DC (if valid)
//      * Set up to get the drawing bounds calculated in GDI
//
BOOL OEBeforeDDI
(
    DDI_PATCH   ddiType,
    HDC         hdcDst,
    UINT        uFlags
)
{
    LPDC        lpdc;
    BOOL        fWeCare = FALSE;

    DebugEntry(OEBeforeDDI);

    EnableFnPatch(&g_oeDDPatches[ddiType], PATCH_DISABLE);
    if (++g_oeEnterCount > 1)
    {
        TRACE_OUT(("Skipping nested output call"));
        DC_QUIT;
    }

    //
    // Get a pointer to the destination DC.  Since we may have an output
    // call where both the source and dest are swapped out, we may need to
    // use both our cached selectors.  Thus, we must to tell OEValidateDC()
    // which DC this is to avoid collision.
    //
    lpdc = OEValidateDC(hdcDst, FALSE);
    if (!SELECTOROF(lpdc))
    {
        TRACE_OUT(("Bogus DC"));
        DC_QUIT;
    }

    //
    // Is this a screen DC w/o an active path?  When a path is active, the
    // output is being recorded into a path, which is like a region.  Then
    // stroking/filling the path can cause output.
    //
    if (!(lpdc->DCFlags & DC_IS_DISPLAY) ||
         (lpdc->fwPath & DCPATH_ACTIVE))
    {
        TRACE_OUT(("Not screen DC"));
        DC_QUIT;
    }

    //
    // Only if this is a screen DC do we care about where the output is 
    // going to happen.  For memory DCs,
    //
    // If this is a bitmap DC or a path is active, we want to dork with
    // the bitmap cache.
    if (lpdc->DCFlags & DC_IS_MEMORY)
    {
        //
        // No screen data or other goop accumulated for non-output calls
        // We just want to do stuff in OEAfterDDI.
        //
        uFlags &= ~OESTATE_DDISTUFF;
        goto WeCareWeReallyCare;
    }
    else
    {
        //
        // Is this a DC we care about?  Our algorithm is:
        //      * If sharing the desktop, yes.
        //      * If no window associated with DC or window is desktop, maybe.
        //      * If window is ancestor of shared window, yes.  Else no.
        //

        if (!g_hetDDDesktopIsShared)
        {
            ERROR_OUT(("g_hetDDDesktopIsShared is FALSE!"));
        }
    }

    //
    // Code from here to WeCareWeReallyCare() is only for screen DCs
    //

    //
    // For the *TextOut* apis, we want to accumulate DCBs if the font is too
    // complex.
    //
    if (uFlags & OESTATE_SDA_FONTCOMPLEX)
    {
        BOOL    fComplex;
        POINT   aptCheck[2];

        fComplex = TRUE;

        // Get the logfont info
        if (!GetObject(lpdc->hFont, sizeof(g_oeState.logFont), &g_oeState.logFont) ||
            (g_oeState.logFont.lfEscapement != 0))
            goto FontCheckDone;

        //
        // The font is too complex if it has escapement or the logical units
        // are bigger than pixels.
        //
        // NOTE that NM 2.0 had a bug--it used one point only for non
        // MM_TEXT mode.  They did this because they wouldn't get back
        // the same thing passed in, forgetting that LPtoDP takes into
        // account viewport and window origins in addition to scaling.
        //
        // So we do this the right way, using two points and looking at
        // the difference.
        //
        aptCheck[0].x = 0;
        aptCheck[0].y = 0;
        aptCheck[1].x = 1000;
        aptCheck[1].y = 1000;

        LPtoDP(hdcDst, aptCheck, 2);

        if ((aptCheck[1].x - aptCheck[0].x <= 1000) ||
            (aptCheck[1].y - aptCheck[0].y <= 1000))
        {
            fComplex = FALSE;
        }

FontCheckDone:
        if (fComplex)
        {
            TRACE_OUT(("Font too complex for text order"));
            uFlags |= OESTATE_SDA_DCB;
        }
    }

    //
    // Some DDIs calculate their own bound rects, which is faster than
    // GDI's BoundsRect() services.  But some don't because it's too 
    // complicated.  In that case, we do it for 'em.
    //
    if (uFlags & OESTATE_SDA_DCB)
    {
        //
        // We don't have to worry about the mapping mode when getting the 
        // bounds.  The only thing to note is that the return rect is 
        // relative to the window org of the DC, and visrgn/clipping occurs
        //
        g_oeState.uGetDCB = GetBoundsRect(hdcDst, &g_oeState.rcDCB, 0);
        g_oeState.uSetDCB = SetBoundsRect(hdcDst, NULL, DCB_ENABLE | DCB_RESET)
            & (DCB_ENABLE | DCB_DISABLE);

        // No curpos needed if going as screen data, not order
        uFlags &= ~OESTATE_CURPOS;
    }

    if (uFlags & OESTATE_CURPOS)
    {
        GetCurrentPositionEx(hdcDst, &g_oeState.ptCurPos);
    }

WeCareWeReallyCare:
    fWeCare = TRUE;
    g_oeState.uFlags = uFlags;
    g_oeState.hdc    = hdcDst;

DC_EXIT_POINT:
    DebugExitBOOL(OEBeforeDDI, fWeCare);
    return(fWeCare);
}


//
// OEAfterDDI()
// 
// This does all the common things right after a DDI call.  It returns TRUE
// if output happened into a screen DC that we care about.
//
BOOL OEAfterDDI
(
    DDI_PATCH   ddiType,
    BOOL        fWeCare,
    BOOL        fOutput
)
{
    DebugEntry(OEAfterDDI);

    //
    // Reenable patch
    //
    EnableFnPatch(&g_oeDDPatches[ddiType], PATCH_ENABLE);
    --g_oeEnterCount;

    if (!fWeCare)
    {
        // 
        // This was reentrant, we don't care about output into this
        // DC, or something went wrong, bail out.
        //
        DC_QUIT;
    }

    g_oeState.lpdc = OEValidateDC(g_oeState.hdc, FALSE);
    if (!SELECTOROF(g_oeState.lpdc))
    {
        ERROR_OUT(("Bogus DC"));
        DC_QUIT;
    }
    ASSERT(g_oeState.lpdc->DCFlags & DC_IS_DISPLAY);
    ASSERT(!(g_oeState.lpdc->fwPath & DCPATH_ACTIVE));

    //
    // If this output happened into a memory bitmap, see if it affects
    // SPBs or our sent bitmap cache
    //
    if (g_oeState.lpdc->DCFlags & DC_IS_MEMORY)
    {
        //
        // Don't set fOutput to FALSE for SPB operations, we want
        // BitBlt to look at it.
        //
        if (fOutput)
        {
            // If this is BitBlt, check for SPB creation
            if ((ddiType != DDI_BITBLT) ||
                (g_oeState.lpdc->hBitmap != g_ssiLastSpbBitmap))
            {
                fOutput = FALSE;
            }
        }
    }
    else
    {
        //
        // Drawing on the screen that isn't going to be handled in the DDI
        // call.
        //
        if (fOutput && (g_oeState.uFlags & OESTATE_SDA_MASK))
        {
            //
            // We do some common tasks that several DDIs would have to do
            //      * take the screen bounds and add as SD
            //      * take the draw bounds and add as SD
            //
            OEGetState(OESTATE_COORDS | OESTATE_REGION);

            if (g_oeState.uFlags & OESTATE_SDA_DCB)
            {
                //
                // Get the drawing bounds
                //
                int     mmMode;
                SIZE    ptWindowExt;
                SIZE    ptViewportExt;
                int     uBoundsNew;

                mmMode = GetMapMode(g_oeState.hdc);
                if (mmMode != MM_TEXT)
                {
                    //
                    // Changing the map mode whacks the window/view exts
                    // So save them so we can replace them when done.
                    //
                    GetWindowExtEx(g_oeState.hdc, &ptWindowExt);
                    GetViewportExtEx(g_oeState.hdc, &ptViewportExt);

                    SetMapMode(g_oeState.hdc,  MM_TEXT);
                }
                
                //
                // Get the drawing bounds and update them.
                //
                uBoundsNew = GetBoundsRect(g_oeState.hdc, &g_oeState.rc, DCB_RESET);

                //
                // If no drawing bounds updated, act like no output happened.
                //
                if ((uBoundsNew & DCB_SET) == DCB_RESET)
                {
                    fOutput = FALSE;
                }
                else
                {
                    OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);
                }

                if (mmMode != MM_TEXT)
                {
                    SetMapMode(g_oeState.hdc, mmMode);

                    // Put back the window, viewport exts; SetMapMode wipes them out
                    SetWindowExt(g_oeState.hdc, ptWindowExt.cx, ptWindowExt.cy);
                    SetViewportExt(g_oeState.hdc, ptViewportExt.cx, ptViewportExt.cy);
                }
            }
            else
            {
                ASSERT(g_oeState.uFlags & OESTATE_SDA_SCREEN);

                g_oeState.rc.left = g_osiScreenRect.left;
                g_oeState.rc.top  = g_osiScreenRect.top;
                g_oeState.rc.right = g_osiScreenRect.right - 1;
                g_oeState.rc.bottom = g_osiScreenRect.bottom - 1;
            }

            if (fOutput)
            {
                if (g_oeState.uFlags & OESTATE_OFFBYONEHACK)
                    g_oeState.rc.bottom++;

                OEClipAndAddScreenData(&g_oeState.rc);

                // This way caller won't do anything else.
                fOutput = FALSE;
            }

            //
            // Put back the draw bounds if we'd turned them on.
            //
            if (g_oeState.uFlags & OESTATE_SDA_DCB)
            {
                if (g_oeState.uGetDCB == DCB_SET)
                {
                    SetBoundsRect(g_oeState.hdc, &g_oeState.rcDCB,
                        g_oeState.uSetDCB | DCB_ACCUMULATE);
                }
                else
                {
                    SetBoundsRect(g_oeState.hdc, NULL,
                        g_oeState.uSetDCB | DCB_RESET);
                }
            }
        }
    }

DC_EXIT_POINT:
    DebugExitBOOL(OEAfterDDI, (fWeCare && fOutput));
    return(fWeCare && fOutput);

}



//
// OEClipAndAddScreenData()
//
void OEClipAndAddScreenData
(
    LPRECT      lprcAdd
)
{
    RECT            rcSDA;
    RECT            rcClipped;
    LPRECTL         pClip;
    UINT            iClip;

    DebugEntry(OEClipAndAddScreenData);

    ASSERT(g_oeState.uFlags & OESTATE_REGION);

    //
    // The rect passed is in virtual desktop inclusive coords.  Convert to
    // Windows screen coords
    //
    rcSDA.left      = lprcAdd->left;
    rcSDA.top       = lprcAdd->top;
    rcSDA.right     = lprcAdd->right + 1;
    rcSDA.bottom    = lprcAdd->bottom + 1;

    //
    // We've got our region data.  In the case of a region that has more
    // than 64 pieces, we just use the bound box (one piece), that's been
    // set up for us already.
    //

    //
    // Intersect each piece with the total bounds to product an SDA rect
    // clipped appropriately.
    //
    for (iClip = 0, pClip = g_oeState.rgnData.arclPieces;
         iClip < g_oeState.rgnData.rdh.nRectL; iClip++, pClip++)
    {
        RECTL_TO_RECT(pClip, &rcClipped);

        if (IntersectRect(&rcClipped, &rcClipped, &rcSDA))
        {
            //
            // Convert to virtual desktop inclusive coords
            //
            rcClipped.right -= 1;
            rcClipped.bottom -= 1;

            BA_AddScreenData(&rcClipped);
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(OEClipAndAddScreenData);
}



//
// FUNCTION: OEClipAndAddOrder
//
// DESCRIPTION:
//
// Clips the supplied order to the current clip region in the DC.  If this
// results in more than one clipped rectangle then the order is duplicated
// and multiple copies are added to the Order List (with the only
// difference between the orders being the destination rectangle).
//
// PARAMETERS: pOrder - a pointer to the order
//
// RETURNS: VOID
//
//
void OEClipAndAddOrder
(
    LPINT_ORDER pOrder,
    void FAR*   lpExtraInfo
)
{
    RECT        rcOrder;
    RECT        rcPiece;
    RECT        rcClipped;
    LPRECTL     pPiece;
    UINT        iClip;
    BOOL        fOrderClipped;
    LPINT_ORDER pNewOrder;
    LPINT_ORDER pLastOrder;

    DebugEntry(OEClipAndAddOrder);

    ASSERT(g_oeState.uFlags & OESTATE_REGION);

    //
    // If this fails somewhere, we accumulate screen data in the same place
    // to spoil the order(s).
    //

    //
    // NOTE:
    // There are some VERY important things about the way this function
    // works that you should be aware of:
    //
    // (1) Every time an order is allocated, it is added to the end of
    // the order heap linked list
    // (2) Appending an order commits it, that updates some total byte info.
    // If the order is a spoiler, the append code will walk backwards from
    // the order being appended and will wipe out orders whose bounds are
    // completely contained within the rect of the current one.
    //
    // THEREFORE, it is important to append orders in the order they are
    // allocated it.  When we come into this function, one order is already
    // allocated.  Its rcsDst bound rect is uninitialized.  When a second
    // intersection with the visrgn occurs, we must allocate a new order, 
    // but append the previously allocated block with the previous rect
    // info.  
    // 
    // Otherwise you will encounter the bug that took me a while to figure
    // out:
    //      * Laura allocates an order in say PatBlt with a spoiler ROP
    //      * Laura calls OEClipAndAddOrder and of course the rcsDst field
    //          hasn't been initialized yet.
    //      * The order intersects two pieces of the visrgn.  On the first
    //          intersection, we save that info away.
    //      * On the second, we allocate a new order block, fill in the NEW
    //          order's info by copying from the old, setting up the rect
    //          with the first intersection, and call OA_DDAddOrder.
    //      * This, as a spoiler, causes the OA_ code to walk backwards in
    //          the linked list looking for orders whose bounds are
    //          completely enclosed by this one.
    //      * It comes to the original order allocated, whose bounds are
    //          currently NOT initialized
    //      * It may find that these uninitialized values describe a rect
    //          contained within the new order's bounds
    //      * It frees this order but the order was not yet committed
    //      * The heap sizes and heap info no longer match, causing an
    //          error about the "List head wrong", the list to get reinited,
    //          and orders to be lost.
    //

    rcOrder.left    = g_oeState.rc.left;
    rcOrder.top     = g_oeState.rc.top;
    rcOrder.right   = g_oeState.rc.right + 1;
    rcOrder.bottom  = g_oeState.rc.bottom  + 1;

    pNewOrder       = pOrder;
    fOrderClipped   = FALSE;
    g_oaPurgeAllowed = FALSE;

    //
    // Intersect each piece rect with the draw bounds
    //
    for (iClip = 0, pPiece = g_oeState.rgnData.arclPieces;
            iClip < g_oeState.rgnData.rdh.nRectL; iClip++, pPiece++)
    {
        RECTL_TO_RECT(pPiece, &rcPiece);

        if (!IntersectRect(&rcPiece, &rcPiece, &rcOrder))
            continue;

        if (fOrderClipped)
        {
            //
            // This adds a clipped order for the LAST intersection, not
            // the current one.  We do this to avoid allocating an extra
            // order when only ONE intersection occurs.
            //

            //
            // The order has already been clipped once, so it actually
            // intersects more than one clip rect. We cope with this
            // by duplicating the order and clipping it again.
            //
            pNewOrder = OA_DDAllocOrderMem(
                pLastOrder->OrderHeader.Common.cbOrderDataLength, 0);
            if (pNewOrder == NULL)
            {
                WARNING_OUT(("OA alloc failed"));

                //
                // BOGUS LAURABU:
                // If some order in the middle fails to be
                // allocated, we need the previous order + the remaining
                // intersections to be added as screen data!
                //
                // NT's code is bogus, it will miss some output.
                //

                //
                // Allocation of memory for a duplicate order failed.  
                // Just add the original order as screen data, and free 
                // the original's memory.  Note that g_oeState.rc has
                // the proper bounds, so we can just call OEClipAndAddScreenData().
                //
                OA_DDFreeOrderMem(pLastOrder);
                OEClipAndAddScreenData(&g_oeState.rc);
                DC_QUIT;
            }

            //
            // Copy the header & data from the original order to this 
            // new one.  Don't overwrite the list info at the start.
            //
            hmemcpy((LPBYTE)pNewOrder + FIELD_SIZE(INT_ORDER, OrderHeader.list),
                    (LPBYTE)pLastOrder + FIELD_SIZE(INT_ORDER, OrderHeader.list),
                    pLastOrder->OrderHeader.Common.cbOrderDataLength +
                        sizeof(INT_ORDER_HEADER) -
                        FIELD_SIZE(INT_ORDER, OrderHeader.list));

            //
            // Set the clip rect.  NOTE:  This is the clipped rect from
            // LAST time.
            //
            pLastOrder->OrderHeader.Common.rcsDst.left =
                rcClipped.left;
            pLastOrder->OrderHeader.Common.rcsDst.top =
                rcClipped.top;
            pLastOrder->OrderHeader.Common.rcsDst.right =
                rcClipped.right - 1;
            pLastOrder->OrderHeader.Common.rcsDst.bottom =
                rcClipped.bottom - 1;

            OTRACE(("Duplicate clipped order %08lx at {%d, %d, %d, %d}",
                pLastOrder,
                pLastOrder->OrderHeader.Common.rcsDst.left,
                pLastOrder->OrderHeader.Common.rcsDst.top,
                pLastOrder->OrderHeader.Common.rcsDst.right,
                pLastOrder->OrderHeader.Common.rcsDst.bottom));

            OA_DDAddOrder(pLastOrder, lpExtraInfo);
        }

        //
        // Save the clipping rect for the NEXT dude.
        //
        CopyRect(&rcClipped, &rcPiece);
        fOrderClipped = TRUE;
        pLastOrder    = pNewOrder;
    }


    //
    // We're out of the loop now.
    //
    if (fOrderClipped)
    {
        pLastOrder->OrderHeader.Common.rcsDst.left =
            rcClipped.left;
        pLastOrder->OrderHeader.Common.rcsDst.top =
            rcClipped.top;
        pLastOrder->OrderHeader.Common.rcsDst.right =
            rcClipped.right - 1;
        pLastOrder->OrderHeader.Common.rcsDst.bottom =
            rcClipped.bottom - 1;

        OTRACE(("Clipped order %08lx at {%d, %d, %d, %d}",
            pLastOrder,
            pLastOrder->OrderHeader.Common.rcsDst.left,
            pLastOrder->OrderHeader.Common.rcsDst.top,
            pLastOrder->OrderHeader.Common.rcsDst.right,
            pLastOrder->OrderHeader.Common.rcsDst.bottom));

        OA_DDAddOrder(pLastOrder, lpExtraInfo);
    }
    else
    {
        OTRACE(("Order clipped completely"));
        OA_DDFreeOrderMem(pOrder);
    }

DC_EXIT_POINT:
    g_oaPurgeAllowed = TRUE;

    DebugExitVOID(OEClipAndAddOrder);
}






//
// DDI PATCHES
//

//
// DrvArc()
//
BOOL WINAPI DrvArc
(
    HDC     hdcDst,
    int     xLeft,
    int     yTop,
    int     xRight,
    int     yBottom,
    int     xStartArc,
    int     yStartArc,
    int     xEndArc,
    int     yEndArc
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    LPINT_ORDER pOrder;
    LPARC_ORDER pArc;
    POINT   ptStart;
    POINT   ptEnd;

    DebugEntry(DrvArc);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_ARC, hdcDst, 0);

    fOutput = Arc(hdcDst, xLeft, yTop, xRight, yBottom, xStartArc,
        yStartArc, xEndArc, yEndArc);

    if (OEAfterDDI(DDI_ARC, fWeCare, fOutput))
    {
        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_REGION);

        //
        // Get the bound rect
        //
        g_oeState.rc.left   =   xLeft;
        g_oeState.rc.top    =   yTop;
        g_oeState.rc.right  =   xRight;
        g_oeState.rc.bottom =   yBottom;

        OEPenWidthAdjust(&g_oeState.rc, 1);
        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

        //
        // Can we send an ARC order?
        //
        pOrder = NULL;

        if (OECheckOrder(ORD_ARC, OECHECK_PEN | OECHECK_CLIPPING))
        {
            pOrder = OA_DDAllocOrderMem(sizeof(ARC_ORDER), 0);
            if (!pOrder)
                goto NoArcOrder;

            pArc = (LPARC_ORDER)pOrder->abOrderData;
            pArc->type      = LOWORD(ORD_ARC);

            //
            // Note that order coordinates are 32-bits, but we're 16-bits.
            // So we need intermediate variables to do conversions on.
            //
            pArc->nLeftRect     = g_oeState.rc.left;
            pArc->nTopRect      = g_oeState.rc.top;
            pArc->nRightRect    = g_oeState.rc.right;
            pArc->nBottomRect   = g_oeState.rc.bottom;

            ptStart.x       = xStartArc;
            ptStart.y       = yStartArc;
            OELPtoVirtual(g_oeState.hdc, &ptStart, 1);
            pArc->nXStart   = ptStart.x;
            pArc->nYStart   = ptStart.y;

            ptEnd.x         = xEndArc;
            ptEnd.y         = yEndArc;
            OELPtoVirtual(g_oeState.hdc, &ptEnd, 1);
            pArc->nXEnd     = ptEnd.x;
            pArc->nYEnd     = ptEnd.y;

            OEConvertColor(g_oeState.lpdc->DrawMode.bkColorL,
                &pArc->BackColor, FALSE);
            pArc->BackMode      = g_oeState.lpdc->DrawMode.bkMode;
            pArc->ROP2          = g_oeState.lpdc->DrawMode.Rop2;

            pArc->PenStyle      = g_oeState.logPen.lopnStyle;
            pArc->PenWidth      = 1;
            OEConvertColor(g_oeState.logPen.lopnColor,
                &pArc->PenColor, FALSE);

            //
            // Get the arc direction (counter-clockwise or clockwise)
            //
            if (g_oeState.lpdc->fwPath & DCPATH_CLOCKWISE)
                pArc->ArcDirection = ORD_ARC_CLOCKWISE;
            else
                pArc->ArcDirection = ORD_ARC_COUNTERCLOCKWISE;

            pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILABLE;

            OTRACE(("Arc:  Order %08lx, Rect {%d, %d, %d, %d}, Start {%d, %d}, End {%d, %d}",
                pOrder,
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom, ptStart.x, ptStart.y, ptEnd.x, ptEnd.y));
            OEClipAndAddOrder(pOrder, NULL);
        }

NoArcOrder:
        if (!pOrder)
        {
            OTRACE(("Arc:  Sending as screen data {%d, %d, %d, %d}",
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
            OEClipAndAddScreenData(&g_oeState.rc);
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvArc, fOutput);
    return(fOutput);
}





//
// DrvChord()
//
BOOL WINAPI DrvChord
(
    HDC     hdcDst,
    int     xLeft,
    int     yTop,
    int     xRight,
    int     yBottom,
    int     xStartChord,
    int     yStartChord,
    int     xEndChord,
    int     yEndChord
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    LPINT_ORDER pOrder;
    LPCHORD_ORDER   pChord;
    POINT   ptStart;
    POINT   ptEnd;
    POINT   ptBrushOrg;

    DebugEntry(DrvChord);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_CHORD, hdcDst, 0);

    fOutput = Chord(hdcDst, xLeft, yTop, xRight, yBottom,
        xStartChord, yStartChord, xEndChord, yEndChord);

    if (OEAfterDDI(DDI_CHORD, fWeCare, fOutput))
    {
        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_BRUSH | OESTATE_REGION);

        //
        // Get the bound rect
        //
        g_oeState.rc.left   =   xLeft;
        g_oeState.rc.top    =   yTop;
        g_oeState.rc.right  =   xRight;
        g_oeState.rc.bottom =   yBottom;
        OEPenWidthAdjust(&g_oeState.rc, 1);
        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

        //
        // Can we send a CHORD order?
        //
        pOrder = NULL;

        if (OECheckOrder(ORD_CHORD, OECHECK_PEN | OECHECK_BRUSH | OECHECK_CLIPPING))
        {
            pOrder = OA_DDAllocOrderMem(sizeof(CHORD_ORDER), 0);
            if (!pOrder)
                goto NoChordOrder;

            pChord = (LPCHORD_ORDER)pOrder->abOrderData;
            pChord->type = LOWORD(ORD_CHORD);

            pChord->nLeftRect   = g_oeState.rc.left;
            pChord->nTopRect    = g_oeState.rc.top;
            pChord->nRightRect  = g_oeState.rc.right;
            pChord->nBottomRect = g_oeState.rc.bottom;

            ptStart.x           = xStartChord;
            ptStart.y           = yStartChord;
            OELPtoVirtual(g_oeState.hdc, &ptStart, 1);
            pChord->nXStart     = ptStart.x;
            pChord->nYStart     = ptStart.y;

            ptEnd.x             = xEndChord;
            ptEnd.y             = yEndChord;
            OELPtoVirtual(g_oeState.hdc, &ptEnd, 1);
            pChord->nXEnd       = ptEnd.x;
            pChord->nYEnd       = ptEnd.y;

            OEGetBrushInfo(&pChord->BackColor, &pChord->ForeColor,
                &pChord->BrushStyle, &pChord->BrushHatch, pChord->BrushExtra);

            GetBrushOrgEx(g_oeState.hdc, &ptBrushOrg);
            pChord->BrushOrgX = (BYTE)ptBrushOrg.x;
            pChord->BrushOrgY = (BYTE)ptBrushOrg.y;

            pChord->BackMode    = g_oeState.lpdc->DrawMode.bkMode;
            pChord->ROP2        = g_oeState.lpdc->DrawMode.Rop2;

            pChord->PenStyle    = g_oeState.logPen.lopnStyle;
            pChord->PenWidth    = 1;
            OEConvertColor(g_oeState.logPen.lopnColor,
                &pChord->PenColor, FALSE);

            if (g_oeState.lpdc->fwPath & DCPATH_CLOCKWISE)
                pChord->ArcDirection = ORD_ARC_CLOCKWISE;
            else
                pChord->ArcDirection = ORD_ARC_COUNTERCLOCKWISE;

            pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILABLE;

            OTRACE(("Chord:  Order %08lx, Rect {%d, %d, %d, %d}, Start {%d, %d}, End {%d, %d}",
                pOrder,
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom, ptStart.x, ptStart.y, ptEnd.x, ptEnd.y));
            OEClipAndAddOrder(pOrder, NULL);
        }

NoChordOrder:
        if (!pOrder)
        {
            OTRACE(("Chord:  Sending as screen data {%d, %d, %d, %d}",
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
            OEClipAndAddScreenData(&g_oeState.rc);
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvChord, fOutput);
    return(fOutput);
}





//
// DrvEllipse()
//
BOOL WINAPI DrvEllipse
(
    HDC     hdcDst,
    int     xLeft,
    int     yTop,
    int     xRight,
    int     yBottom
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    LPINT_ORDER pOrder;
    LPELLIPSE_ORDER pEllipse;
    POINT   ptBrushOrg;

    DebugEntry(DrvEllipse);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_ELLIPSE, hdcDst, 0);

    fOutput = Ellipse(hdcDst, xLeft, yTop, xRight, yBottom);

    if (OEAfterDDI(DDI_ELLIPSE, fWeCare, fOutput))
    {
        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_BRUSH | OESTATE_REGION);

        //
        // Calc bound rect
        //
        g_oeState.rc.left   = xLeft;
        g_oeState.rc.top    = yTop;
        g_oeState.rc.right  = xRight;
        g_oeState.rc.bottom = yBottom;
        OEPenWidthAdjust(&g_oeState.rc, 1);
        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

        //
        // Can we send ELLIPSE order?
        //
        pOrder = NULL;

        if (OECheckOrder(ORD_ELLIPSE, OECHECK_PEN | OECHECK_BRUSH | OECHECK_CLIPPING))
        {
            pOrder = OA_DDAllocOrderMem(sizeof(ELLIPSE_ORDER), 0);
            if (!pOrder)
                goto NoEllipseOrder;

            pEllipse = (LPELLIPSE_ORDER)pOrder->abOrderData;
            pEllipse->type = LOWORD(ORD_ELLIPSE);

            pEllipse->nLeftRect     = g_oeState.rc.left;
            pEllipse->nTopRect      = g_oeState.rc.top;
            pEllipse->nRightRect    = g_oeState.rc.right;
            pEllipse->nBottomRect   = g_oeState.rc.bottom;

            OEGetBrushInfo(&pEllipse->BackColor, &pEllipse->ForeColor,
                &pEllipse->BrushStyle, &pEllipse->BrushHatch,
                pEllipse->BrushExtra);

            GetBrushOrgEx(g_oeState.hdc, &ptBrushOrg);
            pEllipse->BrushOrgX = (BYTE)ptBrushOrg.x;
            pEllipse->BrushOrgY = (BYTE)ptBrushOrg.y;

            pEllipse->BackMode  = g_oeState.lpdc->DrawMode.bkMode;
            pEllipse->ROP2      = g_oeState.lpdc->DrawMode.Rop2;

            pEllipse->PenStyle  = g_oeState.logPen.lopnStyle;
            pEllipse->PenWidth  = 1;

            OEConvertColor(g_oeState.logPen.lopnColor, &pEllipse->PenColor,
                FALSE);

            pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILABLE;

            OTRACE(("Ellipse:  Order %08lx, Rect {%d, %d, %d, %d}",
                pOrder,
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
            OEClipAndAddOrder(pOrder, NULL);
        }

NoEllipseOrder:
        if (!pOrder)
        {
            OTRACE(("Ellipse:  Sending as screen data {%d, %d, %d, %d}",
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
            OEClipAndAddScreenData(&g_oeState.rc);
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvEllipse, fOutput);
    return(fOutput);
}




//
// DrvPie()
//
BOOL WINAPI DrvPie
(
    HDC     hdcDst,
    int     xLeft,
    int     yTop,
    int     xRight,
    int     yBottom,
    int     xStartArc,
    int     yStartArc,
    int     xEndArc,
    int     yEndArc
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    LPINT_ORDER pOrder;
    LPPIE_ORDER pPie;
    POINT   ptStart;
    POINT   ptEnd;
    POINT   ptBrushOrg;

    DebugEntry(DrvPie);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_PIE, hdcDst, 0);

    fOutput = Pie(hdcDst, xLeft, yTop, xRight, yBottom, xStartArc, yStartArc,
        xEndArc, yEndArc);

    if (OEAfterDDI(DDI_PIE, fWeCare, fOutput))
    {
        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_BRUSH | OESTATE_REGION);

        //
        // Get bound rect
        //
        g_oeState.rc.left       = xLeft;
        g_oeState.rc.top        = yTop;
        g_oeState.rc.right      = xRight;
        g_oeState.rc.bottom     = yBottom;
        OEPenWidthAdjust(&g_oeState.rc, 1);
        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

        //
        // Can we send PIE order?
        //
        pOrder = NULL;

        if (OECheckOrder(ORD_PIE, OECHECK_PEN | OECHECK_BRUSH | OECHECK_CLIPPING))
        {
            pOrder = OA_DDAllocOrderMem(sizeof(PIE_ORDER), 0);
            if (!pOrder)
                goto NoPieOrder;

            pPie = (LPPIE_ORDER)pOrder->abOrderData;
            pPie->type = LOWORD(ORD_PIE);

            pPie->nLeftRect   = g_oeState.rc.left;
            pPie->nTopRect    = g_oeState.rc.top;
            pPie->nRightRect  = g_oeState.rc.right;
            pPie->nBottomRect = g_oeState.rc.bottom;

            ptStart.x         = xStartArc;
            ptStart.y         = yStartArc;
            OELPtoVirtual(g_oeState.hdc, &ptStart, 1);
            pPie->nXStart     = ptStart.x;
            pPie->nYStart     = ptStart.y;

            ptEnd.x           = xEndArc;
            ptEnd.y           = yEndArc;
            OELPtoVirtual(g_oeState.hdc, &ptEnd, 1);
            pPie->nXEnd       = ptEnd.x;
            pPie->nYEnd       = ptEnd.y;

            OEGetBrushInfo(&pPie->BackColor, &pPie->ForeColor,
                &pPie->BrushStyle, &pPie->BrushHatch, pPie->BrushExtra);

            GetBrushOrgEx(g_oeState.hdc, &ptBrushOrg);
            pPie->BrushOrgX = (BYTE)ptBrushOrg.x;
            pPie->BrushOrgY = (BYTE)ptBrushOrg.y;

            pPie->BackMode    = g_oeState.lpdc->DrawMode.bkMode;
            pPie->ROP2        = g_oeState.lpdc->DrawMode.Rop2;

            pPie->PenStyle    = g_oeState.logPen.lopnStyle;
            pPie->PenWidth    = 1;
            OEConvertColor(g_oeState.logPen.lopnColor, &pPie->PenColor,
                FALSE);

            if (g_oeState.lpdc->fwPath & DCPATH_CLOCKWISE)
                pPie->ArcDirection = ORD_ARC_CLOCKWISE;
            else
                pPie->ArcDirection = ORD_ARC_COUNTERCLOCKWISE;

            pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILABLE;

            OTRACE(("Pie:  Order %08lx, Rect {%d, %d, %d, %d}, Start {%d, %d}, End {%d, %d}",
                pOrder,
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
            OEClipAndAddOrder(pOrder, NULL);
        }

NoPieOrder:
        if (!pOrder)
        {
            OTRACE(("PieOrder:  Sending as screen data {%d, %d, %d, %d}",
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
            OEClipAndAddScreenData(&g_oeState.rc);
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPie, fOutput);
    return(fOutput);
}



//
// DrvRoundRect()
//
BOOL WINAPI DrvRoundRect
(
    HDC     hdcDst,
    int     xLeft,
    int     yTop,
    int     xRight,
    int     yBottom,
    int     cxEllipse,
    int     cyEllipse
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    LPINT_ORDER pOrder;
    LPROUNDRECT_ORDER   pRoundRect;
    POINT   ptBrushOrg;

    DebugEntry(DrvRoundRect);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_ROUNDRECT, hdcDst, 0);

    fOutput = RoundRect(hdcDst, xLeft, yTop, xRight, yBottom, cxEllipse, cyEllipse);

    if (OEAfterDDI(DDI_ROUNDRECT, fWeCare, fOutput))
    {
        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_BRUSH | OESTATE_REGION);

        //
        // Get bound rect
        //
        g_oeState.rc.left   = xLeft;
        g_oeState.rc.top    = yTop;
        g_oeState.rc.right  = xRight;
        g_oeState.rc.bottom = yBottom;
        OEPenWidthAdjust(&g_oeState.rc, 1);
        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

        //
        // Can we send ROUNDRECT order?
        //
        pOrder = NULL;

        if (OECheckOrder(ORD_ROUNDRECT, OECHECK_PEN | OECHECK_BRUSH | OECHECK_CLIPPING) &&
            (GetMapMode(hdcDst) == MM_TEXT))
        {
            pOrder = OA_DDAllocOrderMem(sizeof(ROUNDRECT_ORDER), 0);
            if (!pOrder)
                goto NoRoundRectOrder;

            pRoundRect = (LPROUNDRECT_ORDER)pOrder->abOrderData;
            pRoundRect->type            = LOWORD(ORD_ROUNDRECT);

            pRoundRect->nLeftRect       = g_oeState.rc.left;
            pRoundRect->nTopRect        = g_oeState.rc.top;
            pRoundRect->nRightRect      = g_oeState.rc.right;
            pRoundRect->nBottomRect     = g_oeState.rc.bottom;

            //
            // It's too difficult to do the mapping of the ellipse 
            // dimensions when not MM_TEXT.  Therefore we don't.  If we
            // are here, we just pass the sizes straight through.
            //
            pRoundRect->nEllipseWidth   = cxEllipse;
            pRoundRect->nEllipseHeight  = cyEllipse;

            OEGetBrushInfo(&pRoundRect->BackColor, &pRoundRect->ForeColor,
                &pRoundRect->BrushStyle, &pRoundRect->BrushHatch,
                pRoundRect->BrushExtra);

            GetBrushOrgEx(g_oeState.hdc, &ptBrushOrg);
            pRoundRect->BrushOrgX = ptBrushOrg.x;
            pRoundRect->BrushOrgY = ptBrushOrg.y;

            pRoundRect->BackMode    = g_oeState.lpdc->DrawMode.bkMode;
            pRoundRect->ROP2        = g_oeState.lpdc->DrawMode.Rop2;

            pRoundRect->PenStyle    = g_oeState.logPen.lopnStyle;
            pRoundRect->PenWidth    = 1;
            OEConvertColor(g_oeState.logPen.lopnColor,
                &pRoundRect->PenColor, FALSE);

            pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILABLE;
            
            OTRACE(("RoundRect:  Order %08lx, Rect {%d, %d, %d, %d}, Curve {%d, %d}",
                pOrder,
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom, cxEllipse, cyEllipse));
            OEClipAndAddOrder(pOrder, NULL);
        }

NoRoundRectOrder:
        if (!pOrder)
        {
            OTRACE(("RoundRect:  Sending as screen data {%d, %d, %d, %d}",
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
            OEClipAndAddScreenData(&g_oeState.rc);
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvRoundRect, fOutput);
    return(fOutput);
}


//
// DrvBitBlt
//
BOOL WINAPI DrvBitBlt
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    int     cxDst,
    int     cyDst,
    HDC     hdcSrc,
    int     xSrc,
    int     ySrc,
    DWORD   dwRop
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    BYTE    bRop;
    LPDC    lpdcSrc;
    LPINT_ORDER  pOrder;
    LPSCRBLT_ORDER pScrBlt;
    POINT   ptT;
    RECT    rcT;

    DebugEntry(DrvBitBlt);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_BITBLT, hdcDst, 0);

    fOutput = BitBlt(hdcDst, xDst, yDst, cxDst, cyDst, hdcSrc, xSrc, ySrc, dwRop);

    if (OEAfterDDI(DDI_BITBLT, fWeCare, fOutput && cxDst && cyDst))
    {
        //
        // Is this really PatBlt?
        //
        bRop = LOBYTE(HIWORD(dwRop));

        if (((bRop & 0x33) << 2) == (bRop & 0xCC))
        {
            TRACE_OUT(("BitBlt used for PatBlt"));

            OEGetState(OESTATE_COORDS | OESTATE_BRUSH | OESTATE_REGION);

            //
            // Get bound rect
            //
            g_oeState.rc.left   = xDst;
            g_oeState.rc.top    = yDst;
            g_oeState.rc.right  = xDst + cxDst;
            g_oeState.rc.bottom = yDst + cyDst;

            OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

            OEAddBlt(dwRop);
            DC_QUIT;
        }

        //
        // SPB goop
        //
        if (g_oeState.lpdc->hBitmap == g_ssiLastSpbBitmap)
        {
            //
            // This is an SPB operation.  The source is in screen coords.
            //
            ASSERT(g_ssiLastSpbBitmap);
            ASSERT(g_oeState.lpdc->DCFlags & DC_IS_MEMORY);
            ASSERT(dwRop == SRCCOPY);

            g_oeState.rc.left = xSrc;
            g_oeState.rc.top  = ySrc;
            g_oeState.rc.right = xSrc + cxDst;
            g_oeState.rc.bottom = ySrc + cyDst;

            SSISaveBits(g_ssiLastSpbBitmap, &g_oeState.rc);
            g_ssiLastSpbBitmap = NULL;

            DC_QUIT;
        }

        ASSERT(!(g_oeState.lpdc->DCFlags & DC_IS_MEMORY));

        //
        // Is this a memory to screen blt for SPB restoration?
        //
        lpdcSrc = OEValidateDC(hdcSrc, TRUE);
        if (SELECTOROF(lpdcSrc)                     &&
            (lpdcSrc->DCFlags & DC_IS_DISPLAY)      &&
            (lpdcSrc->DCFlags & DC_IS_MEMORY)       &&
            (dwRop == SRCCOPY)                      &&
            SSIRestoreBits(lpdcSrc->hBitmap))
        {
            OTRACE(("BitBlt:  SPB restored"));
            DC_QUIT;
        }

        //
        // Now, we accumulate orders for screen-to-screen blts
        //
        OEGetState(OESTATE_COORDS | OESTATE_BRUSH | OESTATE_REGION);

        g_oeState.rc.left   = xDst;
        g_oeState.rc.top    = yDst;
        g_oeState.rc.right  = xDst + cxDst;
        g_oeState.rc.bottom = yDst + cyDst;

        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

        pOrder = NULL;

        if (hdcSrc == hdcDst)
        {
            if (!OECheckOrder(ORD_SCRBLT, OECHECK_CLIPPING) ||
                !OESendRop3AsOrder(bRop)                    ||
                !ROP3_NO_PATTERN(bRop))
            {
                goto NoBitBltOrder;
            }

            //
            // Get source coords
            //
            ptT.x = xSrc;
            ptT.y = ySrc;
            OELPtoVirtual(hdcSrc, &ptT, 1);

            //
            // If the clipping isn't simple and the source overlaps the dest,
            // send as screen data.  It's too complicated for an order.
            //
            if (!OEClippingIsSimple())
            {
                //
                // NOTE:
                // The NM 2.0 code was really messed up, the source rect
                // calcs were bogus.
                //
                rcT.left = max(g_oeState.rc.left, ptT.x);
                rcT.right = min(g_oeState.rc.right,
                    ptT.x + (g_oeState.rc.right - g_oeState.rc.left));

                rcT.top  = max(g_oeState.rc.top, ptT.y);
                rcT.bottom = min(g_oeState.rc.bottom,
                    ptT.y + (g_oeState.rc.bottom - g_oeState.rc.top));

                if ((rcT.left <= rcT.right) &&
                    (rcT.top  <= rcT.bottom))
                {
                    TRACE_OUT(("No SCRBLT order; non-rect clipping and Src/Dst intersect"));
                    goto NoBitBltOrder;
                }
            }

            pOrder = OA_DDAllocOrderMem(sizeof(SCRBLT_ORDER), 0);
            if (!pOrder)
                goto NoBitBltOrder;

            pScrBlt = (LPSCRBLT_ORDER)pOrder->abOrderData;
            pScrBlt->type = LOWORD(ORD_SCRBLT);

            pScrBlt->nLeftRect  = g_oeState.rc.left;
            pScrBlt->nTopRect   = g_oeState.rc.top;
            pScrBlt->nWidth     = g_oeState.rc.right - g_oeState.rc.left + 1;
            pScrBlt->nHeight    = g_oeState.rc.bottom - g_oeState.rc.top + 1;
            pScrBlt->bRop       = bRop;

            pScrBlt->nXSrc      = ptT.x;
            pScrBlt->nYSrc      = ptT.y;

            pOrder->OrderHeader.Common.fOrderFlags  = OF_BLOCKER | OF_SPOILABLE;

            OTRACE(("ScrBlt:  From {%d, %d}, To {%d, %d}, Size {%d, %d}",
                ptT.x, ptT.y, g_oeState.rc.left, g_oeState.rc.top,
                g_oeState.rc.right - g_oeState.rc.left + 1,
                g_oeState.rc.bottom - g_oeState.rc.top + 1));

            OEClipAndAddOrder(pOrder, NULL);
        }

NoBitBltOrder:
        if (!pOrder)
        {
            OTRACE(("BitBlt:  Sending as screen data {%d, %d, %d, %d}",
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
            OEClipAndAddScreenData(&g_oeState.rc);
        }
    }

DC_EXIT_POINT:
    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvBitBlt, fOutput);
    return(fOutput);
}



//
// DrvExtTextOutA()
//
BOOL WINAPI DrvExtTextOutA
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    UINT    uOptions,
    LPRECT  lprcClip,
    LPSTR  lpszText,
    UINT    cchText,
    LPINT   lpdxCharSpacing
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    UINT    uFlags;

    DebugEntry(DrvExtTextOutA);

    OE_SHM_START_WRITING;

    //
    // Is this really just opaquing?
    //
    if ((cchText == 0)          &&
        SELECTOROF(lprcClip)    &&
        !IsBadReadPtr(lprcClip, sizeof(RECT))   &&
        (uOptions & ETO_OPAQUE))
    {
        uFlags = 0;
    }
    else
    {
        uFlags = OESTATE_SDA_FONTCOMPLEX | OESTATE_CURPOS;
    }

    fWeCare = OEBeforeDDI(DDI_EXTTEXTOUTA, hdcDst, uFlags);

    fOutput = ExtTextOut(hdcDst, xDst, yDst, uOptions, lprcClip, lpszText, cchText, lpdxCharSpacing);

    if (OEAfterDDI(DDI_EXTTEXTOUTA, fWeCare, fOutput))
    {
        //
        // Is this a simple OPAQUE rect, or a textout call?
        // NOTE that OEAfterDDI() returns FALSE if fOutput is TRUE but 
        // we used DCBs to add it as screen data.
        //
        if (uFlags & OESTATE_SDA_FONTCOMPLEX)
        {
            if (cchText)
            {
                POINT   ptStart = {xDst, yDst};

                OEAddText(ptStart, uOptions, lprcClip, lpszText, cchText, lpdxCharSpacing);
            }
        }
        else
        {
            OEAddOpaqueRect(lprcClip);
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvExtTextOutA, fOutput);
    return(fOutput);
}



#pragma optimize("gle", off)
//
// DrvPatBlt()
//
BOOL WINAPI DrvPatBlt
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    int     cxDst,
    int     cyDst,
    DWORD   rop
)
{
    UINT    cxSave;
    BOOL    fWeCare;
    BOOL    fOutput;
    LPINT_ORDER pOrder;

    // Save CX
    _asm    mov cxSave, cx

    DebugEntry(DrvPatBlt);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_PATBLT, hdcDst, 0);

    // Restore CX for RealPatBlt
    _asm     mov cx, cxSave
    fOutput = g_lpfnRealPatBlt(hdcDst, xDst, yDst, cxDst, cyDst, rop);

    if (OEAfterDDI(DDI_PATBLT, fWeCare, fOutput && (cxSave != 0)))
    {
        OEGetState(OESTATE_COORDS | OESTATE_BRUSH | OESTATE_REGION);

        //
        // Get bound rect
        //
        g_oeState.rc.left   = xDst;
        g_oeState.rc.top    = yDst;
        g_oeState.rc.right  = xDst + cxDst;
        g_oeState.rc.bottom = yDst + cyDst;

        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

        OEAddBlt(rop);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPatBlt, fOutput);
    return(fOutput);
}
#pragma optimize("", on)



//
// OEAddBlt()
// Used for simple destination ROP blts
//
void OEAddBlt
(
    DWORD       dwRop
)
{
    LPINT_ORDER pOrder;
    DWORD       type;
    POINT       ptBrushOrg;
    BYTE        bRop;

    DebugEntry(OEAddBlt);

    pOrder = NULL;

    //
    // Is this a full PATBLT_ORDER or a simple DSTBLT_ORDER?  If the top
    // nibble of the ROP is equal to the bottom nibble, no pattern is
    // required.  WHITENESS for example.
    //
    bRop = LOBYTE(HIWORD(dwRop));
    if ((bRop >> 4) == (bRop & 0x0F))
    {
        type = ORD_DSTBLT;
    }
    else
    {
        type = ORD_PATBLT;

        if (!OECheckBrushIsSimple())
        {
            DC_QUIT;
        }

        if ((dwRop == PATCOPY) && (g_oeState.logBrush.lbStyle == BS_NULL))
        {
            // No output happens in this scenario at all, no screen data even
            goto NothingAtAll;
        }
    }

    if (OE_SendAsOrder(type)        &&
        OESendRop3AsOrder(bRop)     &&
        !OEClippingIsComplex())
    {
        if (type == ORD_PATBLT)
        {
            LPPATBLT_ORDER  pPatBlt;

            pOrder = OA_DDAllocOrderMem(sizeof(PATBLT_ORDER), 0);
            if (!pOrder)
                DC_QUIT;

            pPatBlt = (LPPATBLT_ORDER)pOrder->abOrderData;
            pPatBlt->type = LOWORD(ORD_PATBLT);

            pPatBlt->nLeftRect  =   g_oeState.rc.left;
            pPatBlt->nTopRect   =   g_oeState.rc.top;
            pPatBlt->nWidth     =   g_oeState.rc.right - g_oeState.rc.left + 1;
            pPatBlt->nHeight    =   g_oeState.rc.bottom - g_oeState.rc.top + 1;

            pPatBlt->bRop       =   bRop;

            OEGetBrushInfo(&pPatBlt->BackColor, &pPatBlt->ForeColor,
                &pPatBlt->BrushStyle, &pPatBlt->BrushHatch, pPatBlt->BrushExtra);

            GetBrushOrgEx(g_oeState.hdc, &ptBrushOrg);
            pPatBlt->BrushOrgX = (BYTE)ptBrushOrg.x;
            pPatBlt->BrushOrgY = (BYTE)ptBrushOrg.y;

            OTRACE(("PatBlt:  Order %08lx, Rect {%d, %d, %d, %d}",
                pOrder,
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.right));
        }
        else
        {
            LPDSTBLT_ORDER     pDstBlt;

            ASSERT(type == ORD_DSTBLT);

            pOrder = OA_DDAllocOrderMem(sizeof(DSTBLT_ORDER), 0);
            if (!pOrder)
                DC_QUIT;
           
            pDstBlt = (LPDSTBLT_ORDER)pOrder->abOrderData;
            pDstBlt->type = LOWORD(ORD_DSTBLT);

            pDstBlt->nLeftRect  = g_oeState.rc.left;
            pDstBlt->nTopRect   = g_oeState.rc.top;
            pDstBlt->nWidth     = g_oeState.rc.right - g_oeState.rc.left + 1;
            pDstBlt->nHeight    = g_oeState.rc.bottom - g_oeState.rc.top + 1;

            pDstBlt->bRop       = bRop;

            OTRACE(("DstBlt:  Order %08lx, Rect {%d, %d, %d, %d}",
                pOrder,
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
        }

        pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILABLE;
        if (ROP3_IS_OPAQUE(bRop))
            pOrder->OrderHeader.Common.fOrderFlags |= OF_SPOILER;

        OEClipAndAddOrder(pOrder, NULL);
    }

DC_EXIT_POINT:
    if (!pOrder)
    {
        OTRACE(("PatBlt:  Sending as screen data {%d, %d, %d, %d}",
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom));
        OEClipAndAddScreenData(&g_oeState.rc);
    }
    
NothingAtAll:
    DebugExitVOID(OEAddBlt);
}



//
// DrvStretchBlt()
//
BOOL WINAPI DrvStretchBlt
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    int     cxDst,
    int     cyDst,
    HDC     hdcSrc,
    int     xSrc,
    int     ySrc,
    int     cxSrc,
    int     cySrc,
    DWORD   rop
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvStretchBlt);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_STRETCHBLT, hdcDst, 0);

    fOutput = StretchBlt(hdcDst, xDst, yDst, cxDst, cyDst, hdcSrc, xSrc, ySrc, cxSrc, cySrc, rop);

    if (OEAfterDDI(DDI_STRETCHBLT, fWeCare, fOutput))
    {
        OEGetState(OESTATE_COORDS | OESTATE_REGION);

        g_oeState.rc.left   = xDst;
        g_oeState.rc.top    = yDst;
        g_oeState.rc.right  = xDst + cxDst;
        g_oeState.rc.bottom = yDst + cyDst;
        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

        OTRACE(("StretchBlt:  Sending as screen data {%d, %d, %d, %d}",
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom));

        OEClipAndAddScreenData(&g_oeState.rc);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvStretchBlt, fOutput);
    return(fOutput);
}



//
// TextOutA()
//
BOOL WINAPI DrvTextOutA
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    LPSTR  lpszText,
    int     cchText
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvTextOutA);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_TEXTOUTA, hdcDst, OESTATE_SDA_FONTCOMPLEX | OESTATE_CURPOS);

    fOutput = TextOut(hdcDst, xDst, yDst, lpszText, cchText);

    if (OEAfterDDI(DDI_TEXTOUTA, fWeCare, fOutput && cchText))
    {
        POINT   ptStart = {xDst, yDst};
        OEAddText(ptStart, 0, NULL, lpszText, cchText, NULL);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvTextOutA, fOutput);
    return(fOutput);
}



//
// DrvExtFloodFill()
//
// This just gets added as screen data.  Too darned complicated to
// calculate the result.
//
BOOL WINAPI DrvExtFloodFill
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    COLORREF    clrFill,
    UINT    uFillType
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvExtFloodFill);

    OE_SHM_START_WRITING;

    //
    // GDI's draw bounds has an off-by-one bug in ExtFloodFill and FloodFill
    //
    fWeCare = OEBeforeDDI(DDI_EXTFLOODFILL, hdcDst, OESTATE_SDA_DCB | 
        OESTATE_OFFBYONEHACK);

    fOutput = ExtFloodFill(hdcDst, xDst, yDst, clrFill, uFillType);

    OEAfterDDI(DDI_EXTFLOODFILL, fWeCare, fOutput);

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvExtFloodFill, fOutput);
    return(fOutput);
}



//
// DrvFloodFill()
//
BOOL WINAPI DrvFloodFill
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    COLORREF    clrFill
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvFloodFill);

    OE_SHM_START_WRITING;

    //
    // GDI's draw bounds has an off-by-one bug in ExtFloodFill and FloodFill
    //
    fWeCare = OEBeforeDDI(DDI_FLOODFILL, hdcDst, OESTATE_SDA_DCB |
        OESTATE_OFFBYONEHACK);

    fOutput = FloodFill(hdcDst, xDst, yDst, clrFill);

    OEAfterDDI(DDI_FLOODFILL, fWeCare, fOutput);

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvFloodFill, fOutput);
    return(fOutput);
}



//
// DrvExtTextOut()
//
BOOL WINAPI DrvExtTextOutW
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    UINT    uOptions,
    LPRECT  lprcClip,
    LPWSTR lpwszText,
    UINT    cchText,
    LPINT   lpdxCharSpacing
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    UINT    uFlags;

    //
    // NOTE:
    // ExtTextOutW and TextOutW are only called on 32-bit app threads.  So
    // chewing up stack space isn't a problem.
    //
    UINT    cchAnsi = 0;
    char    szAnsi[ORD_MAX_STRING_LEN_WITHOUT_DELTAS+1];

    DebugEntry(DrvExtTextOutW);

    OE_SHM_START_WRITING;

    if ((cchText == 0)                          &&
        SELECTOROF(lprcClip)                    &&
        !IsBadReadPtr(lprcClip, sizeof(RECT))   &&
        (uOptions & ETO_OPAQUE))
    {
        uFlags = 0;
    }
    else
    {
        //
        // Is this order-able?  It is if we can convert the unicode string
        // to ansi then back to unicode, and end up where we started.
        //
        uFlags = OESTATE_SDA_DCB;

        if (cchText &&
            (cchText <= ORD_MAX_STRING_LEN_WITHOUT_DELTAS) &&
            !IsBadReadPtr(lpwszText, cchText*sizeof(WCHAR)))
        {
            int cchUni;

            //
            // NOTE:
            // UniToAnsi() returns ONE LESS than the # of chars converted
            //
            cchAnsi = UniToAnsi(lpwszText, szAnsi, cchText) + 1;
            cchUni  = AnsiToUni(szAnsi, cchAnsi, g_oeTempString, ORD_MAX_STRING_LEN_WITHOUT_DELTAS);

            if (cchUni == cchText)
            {
                //
                // Verify these strings are the same
                //
                UINT ich;

                for (ich = 0; ich < cchText; ich++)
                {
                    if (lpwszText[ich] != g_oeTempString[ich])
                        break;
                }

                if (ich == cchText)
                {
                    //
                    // We made it to the end; everything matched.
                    //
                    uFlags = OESTATE_SDA_FONTCOMPLEX | OESTATE_CURPOS;
                }
            }

#ifdef DEBUG
            if (uFlags == OESTATE_SDA_DCB)
            {
                WARNING_OUT(("Can't encode ExtTextOutW"));
            }
#endif // DEBUG
        }
    }

    fWeCare = OEBeforeDDI(DDI_EXTTEXTOUTW, hdcDst, uFlags);

    fOutput = g_lpfnExtTextOutW(hdcDst, xDst, yDst, uOptions, lprcClip,
        lpwszText, cchText, lpdxCharSpacing);

    if (OEAfterDDI(DDI_EXTTEXTOUTW, fWeCare, fOutput))
    {
        //
        // Is this a simple OPAQUE rect, or a textout call we can order?
        // NOTE that OEAfterDDI() returns FALSE even if fOutput but we
        // used DCBs to add as screen data.
        //
        if (uFlags & OESTATE_SDA_FONTCOMPLEX)
        {
            POINT   ptStart = {xDst, yDst};

            ASSERT(cchAnsi);
            OEAddText(ptStart, uOptions, lprcClip, szAnsi, cchAnsi, lpdxCharSpacing);
        }
        else
        {
            OEAddOpaqueRect(lprcClip);
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvExtTextOutW, fOutput);
    return(fOutput);
}



//
// DrvTextOutW()
//
BOOL WINAPI DrvTextOutW
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    LPWSTR lpwszText,
    int     cchText
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    UINT    uFlags;

    //
    // NOTE:
    // ExtTextOutW and TextOutW are only called on 32-bit app threads.  So
    // chewing up stack space isn't a problem.
    //
    UINT    cchAnsi = 0;
    char    szAnsi[ORD_MAX_STRING_LEN_WITHOUT_DELTAS+1];

    DebugEntry(DrvTextOutW);

    OE_SHM_START_WRITING;

    //
    // Is this order-able?  It is if we can convert the unicode string to
    // ansi then back to unicode, and end up where we started.
    //
    uFlags = OESTATE_SDA_DCB;

    if (cchText &&
        (cchText <= ORD_MAX_STRING_LEN_WITHOUT_DELTAS)  &&
        !IsBadReadPtr(lpwszText, cchText*sizeof(WCHAR)))
    {
        int cchUni;

        //
        // NOTE:
        // UniToAnsi() returns one LESS than the # of chars converted
        //
        cchAnsi = UniToAnsi(lpwszText, szAnsi, cchText) + 1;
        cchUni  = AnsiToUni(szAnsi, cchAnsi, g_oeTempString, cchText);

        if (cchUni == cchText)
        {
            //
            // Verify these strings are the same
            //
            UINT ich;

            for (ich = 0; ich < cchText; ich++)
            {
                if (lpwszText[ich] != g_oeTempString[ich])
                    break;
            }

            if (ich == cchText)
            {
                //
                // We made it to the end; everything matched.
                //
                uFlags = OESTATE_SDA_FONTCOMPLEX | OESTATE_CURPOS;
            }

#ifdef DEBUG
            if (uFlags == OESTATE_SDA_DCB)
            {
                WARNING_OUT(("Can't encode TextOutW"));
            }
#endif // DEBUG

        }
    }

    fWeCare = OEBeforeDDI(DDI_TEXTOUTW, hdcDst, uFlags);

    fOutput = g_lpfnTextOutW(hdcDst, xDst, yDst, lpwszText, cchText);

    if (OEAfterDDI(DDI_TEXTOUTW, fWeCare, fOutput && cchText))
    {
        POINT ptStart = {xDst, yDst};
        OEAddText(ptStart, 0, NULL, szAnsi, cchAnsi, NULL);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvTextOutW, fOutput);
    return(fOutput);
}


//
// OEAddOpaqueRect()
// Adds a simple opaque rect order, used for "erasing" ExtTextOutA/W
// calls.  The most common examples are in Office.
//
void OEAddOpaqueRect(LPRECT lprcOpaque)
{
    LPINT_ORDER         pOrder;
    LPOPAQUERECT_ORDER  pOpaqueRect;

    DebugEntry(OEAddOpaqueRect);

    OEGetState(OESTATE_COORDS | OESTATE_REGION);

    g_oeState.rc = *lprcOpaque;
    OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

    pOrder = NULL;

    if (OECheckOrder(ORD_OPAQUERECT, OECHECK_CLIPPING))
    {
        pOrder = OA_DDAllocOrderMem(sizeof(OPAQUERECT_ORDER), 0);
        if (!pOrder)
            DC_QUIT;

        pOpaqueRect = (LPOPAQUERECT_ORDER)pOrder->abOrderData;
        pOpaqueRect->type = LOWORD(ORD_OPAQUERECT);

        pOpaqueRect->nLeftRect  = g_oeState.rc.left;
        pOpaqueRect->nTopRect   = g_oeState.rc.top;
        pOpaqueRect->nWidth     = g_oeState.rc.right - g_oeState.rc.left + 1;
        pOpaqueRect->nHeight    = g_oeState.rc.bottom - g_oeState.rc.top + 1;

        OEConvertColor(g_oeState.lpdc->DrawMode.bkColorL,
            &pOpaqueRect->Color, FALSE);

        pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILER | OF_SPOILABLE;

        OTRACE(("OpaqueRect:  Order %08lx, Rect {%d, %d, %d, %d}, Color %08lx",
            pOrder,
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom, pOpaqueRect->Color));

        OEClipAndAddOrder(pOrder, NULL);
    }

DC_EXIT_POINT:
    if (!pOrder)
    {
        OTRACE(("OpaqueRect:  Sending as screen data {%d, %d, %d, %d}",
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom));
        OEClipAndAddScreenData(&g_oeState.rc);
    }

    DebugExitVOID(OEAddOpaqueRect);
}


//
// OEAddText()
// Big monster routine that handles TextOutA/ExtTextOutA
//
// In general, we care about:
//      * Clip rect--if none, and no text, it's an OpaqueRect instead
//      * The font
//      * Whether it's too complicated to send as an order
//      * If it needs a deltaX array
//
void OEAddText
(
    POINT   ptStart,
    UINT    uOptions,
    LPRECT  lprcClip,
    LPSTR   lpszText,
    UINT    cchText,
    LPINT   lpdxCharSpacing
)
{
    RECT                rcT;
    int                 overhang;
    int                 width;
    UINT                fOrderFlags;
    int                 cchMax;
    DWORD               order;
    LPINT_ORDER         pOrder;
    LPEXTTEXTOUT_ORDER  pExtTextOut;
    LPTEXTOUT_ORDER     pTextOut;
    LPCOMMON_TEXTORDER  pCommon;
    UINT                fontHeight;
    UINT                fontWidth;
    UINT                fontWeight;
    UINT                fontFlags;
    UINT                fontIndex;
    BOOL                fSendDeltaX;
    POINT               ptT;
    
    DebugEntry(OEAddText);

    //
    // NOTE:
    // Do NOT convert ptStart.  It is needed in logical form for several
    // different things.
    //

    OEGetState(OESTATE_COORDS | OESTATE_FONT | OESTATE_REGION);

    //
    // We need to apply the same validation to the flags that GDI does.
    // This bit massaging is for various app compatibility things.
    //
    if (uOptions & ~(ETO_CLIPPED | ETO_OPAQUE | ETO_GLYPH_INDEX | ETO_RTLREADING))
    {
        uOptions &= (ETO_CLIPPED | ETO_OPAQUE);
    }
    if (!(uOptions & (ETO_CLIPPED | ETO_OPAQUE)))
    {
        // No opaquing/clipping, no clip rect
        lprcClip = NULL;
    }
    if (!SELECTOROF(lprcClip))
    {
        // No clip rect, no opaquing/clipping
        uOptions &= ~(ETO_CLIPPED | ETO_OPAQUE);
    }

    pOrder = NULL;

    fOrderFlags = OF_SPOILABLE;

    //
    // Calculate the real starting position of the text
    //
    if (g_oeState.tmAlign & TA_UPDATECP)
    {
        ASSERT(g_oeState.uFlags & OESTATE_CURPOS);
        ptStart = g_oeState.ptCurPos;
    }

    overhang = OEGetStringExtent(lpszText, cchText, lpdxCharSpacing, &rcT);

    width = rcT.right - overhang - rcT.left;
    switch (g_oeState.tmAlign & (TA_CENTER | TA_LEFT | TA_RIGHT))
    {
        case TA_CENTER:
            // The original x coord is the MIDPOINT
            TRACE_OUT(("TextOut HORZ center"));
            ptStart.x -= (width * g_oeState.ptPolarity.x / 2);
            break;

        case TA_RIGHT:
            // The original x coord is the RIGHT SIDE
            TRACE_OUT(("TextOut HORZ right"));
            ptStart.x -= (width * g_oeState.ptPolarity.x);
            break;

        case TA_LEFT:
            break;
    }

    switch (g_oeState.tmAlign & (TA_BASELINE | TA_BOTTOM | TA_TOP))
    {
        case TA_BASELINE:
            // The original y coord is the BASELINE
            TRACE_OUT(("TextOut VERT baseline"));
            ptStart.y -= (g_oeState.tmFont.tmAscent * g_oeState.ptPolarity.y);
            break;

        case TA_BOTTOM:
            // The original y coord is the BOTTOM SIDE
            TRACE_OUT(("TextOut VERT bottom"));
            ptStart.y -= ((rcT.bottom - rcT.top) * g_oeState.ptPolarity.y);
            break;

        case TA_TOP:
            break;
    }


    //
    // Calculate extent rect for order
    //
    if (uOptions & ETO_CLIPPED)
    {
        // Because of CopyRect() validation layer bug, do this directly
        g_oeState.rc = *lprcClip;

        if (uOptions & ETO_OPAQUE)
            fOrderFlags |= OF_SPOILER;
    }
    else
    {
        g_oeState.rc.left  = ptStart.x + (g_oeState.ptPolarity.x * rcT.left);
        g_oeState.rc.top   = ptStart.y + (g_oeState.ptPolarity.y * rcT.top);
        g_oeState.rc.right = ptStart.x + (g_oeState.ptPolarity.x * rcT.right);
        g_oeState.rc.bottom = ptStart.y + (g_oeState.ptPolarity.y * rcT.bottom);

        if (uOptions & ETO_OPAQUE)
        {
            //
            // Set the SPOILER flag in the order header.  However, if the 
            // text extends outside the opaque rect, then the order isn't
            // really opaque, and we have to clear this flag.
            //
 
            fOrderFlags |= OF_SPOILER;

            if (g_oeState.ptPolarity.x == 1)
            {
                if ((g_oeState.rc.left < lprcClip->left) ||
                    (g_oeState.rc.right > lprcClip->right))
                {
                    fOrderFlags &= ~OF_SPOILER;
                }

                g_oeState.rc.left = min(g_oeState.rc.left, lprcClip->left);
                g_oeState.rc.right = max(g_oeState.rc.right, lprcClip->right);
            }
            else
            {
                if ((g_oeState.rc.left > lprcClip->left) ||
                    (g_oeState.rc.right < lprcClip->right))
                {
                    fOrderFlags &= ~OF_SPOILER;
                }

                g_oeState.rc.left = max(g_oeState.rc.left, lprcClip->left);
                g_oeState.rc.right = min(g_oeState.rc.right, lprcClip->right);
            }

            if (g_oeState.ptPolarity.y == 1)
            {
                if ((g_oeState.rc.top < lprcClip->top) ||
                    (g_oeState.rc.bottom > lprcClip->bottom))
                {
                    fOrderFlags &= ~OF_SPOILER;
                }

                g_oeState.rc.top = min(g_oeState.rc.top, lprcClip->top);
                g_oeState.rc.bottom = max(g_oeState.rc.bottom, lprcClip->bottom);
            }
            else
            {
                if ((g_oeState.rc.top > lprcClip->top) ||
                    (g_oeState.rc.bottom < lprcClip->bottom))
                {
                    fOrderFlags &= ~OF_SPOILER;
                }

                g_oeState.rc.top = max(g_oeState.rc.top, lprcClip->top);
                g_oeState.rc.bottom = min(g_oeState.rc.bottom, lprcClip->bottom);
            }

            //
            // After all this, if the text is OPAQUE, then it is a spoiler
            //
            if (g_oeState.lpdc->DrawMode.bkMode == OPAQUE)
                fOrderFlags |= OF_SPOILER;
        }
    }

    OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

    //
    // Is the font supported?
    //
    if (!OECheckFontIsSupported(lpszText, cchText, &fontHeight,
            &fontWidth, &fontWeight, &fontFlags, &fontIndex, &fSendDeltaX))
        DC_QUIT;

    //
    // What type of order are we sending?  And therefore what is the max
    // # of chars we can encode?
    //
    if (fSendDeltaX || SELECTOROF(lpdxCharSpacing) || uOptions)
    {
        order = ORD_EXTTEXTOUT;
        cchMax = ORD_MAX_STRING_LEN_WITH_DELTAS;
    }
    else
    {
        order = ORD_TEXTOUT;
        cchMax = ORD_MAX_STRING_LEN_WITHOUT_DELTAS;
    }


    if (OECheckOrder(order, OECHECK_CLIPPING)   &&
        (cchText <= cchMax))
    {
        if (order == ORD_TEXTOUT)
        {
            pOrder = OA_DDAllocOrderMem((sizeof(TEXTOUT_ORDER)
                - ORD_MAX_STRING_LEN_WITHOUT_DELTAS
                + cchText),
                0);
            if (!pOrder)
                DC_QUIT;

            pTextOut = (LPTEXTOUT_ORDER)pOrder->abOrderData;
            pTextOut->type = LOWORD(order);

            pCommon = &pTextOut->common;
        }
        else
        {
            //
            // BOGUS LAURABU
            // This allocates space for a deltax array whether or not one is
            // needed.
            //
            pOrder = OA_DDAllocOrderMem((sizeof(EXTTEXTOUT_ORDER)
                - ORD_MAX_STRING_LEN_WITHOUT_DELTAS
                - (ORD_MAX_STRING_LEN_WITH_DELTAS * sizeof(TSHR_INT32))
                + cchText
                + (cchText * sizeof(TSHR_INT32))
                + 4), 0);       // 4 is for dword alignment padding
            if (!pOrder)
                DC_QUIT;

            pExtTextOut = (LPEXTTEXTOUT_ORDER)pOrder->abOrderData;
            pExtTextOut->type = LOWORD(order);

            pCommon = &pExtTextOut->common;
        }

        //
        // The order coords are TSHR_INT32s
        //
        ptT = ptStart;
        OELPtoVirtual(g_oeState.hdc, &ptT, 1);
        pCommon->nXStart   =   ptT.x;
        pCommon->nYStart   =   ptT.y;

        OEConvertColor(g_oeState.lpdc->DrawMode.bkColorL,
            &pCommon->BackColor, FALSE);
        OEConvertColor(g_oeState.lpdc->DrawMode.txColorL,
             &pCommon->ForeColor, FALSE);

        pCommon->BackMode = g_oeState.lpdc->DrawMode.bkMode;
        pCommon->CharExtra = g_oeState.lpdc->DrawMode.CharExtra;
        pCommon->BreakExtra = g_oeState.lpdc->DrawMode.TBreakExtra;
        pCommon->BreakCount = g_oeState.lpdc->DrawMode.BreakCount;

        //
        // Font details
        //
        pCommon->FontHeight = fontHeight;
        pCommon->FontWidth  = fontWidth;
        pCommon->FontWeight = fontWeight;
        pCommon->FontFlags  = fontFlags;
        pCommon->FontIndex  = fontIndex;

        if (order == ORD_TEXTOUT)
        {
            //
            // Copy the string
            //
            pTextOut->variableString.len = cchText;
            hmemcpy(pTextOut->variableString.string, lpszText, cchText);
        }
        else
        {
            pExtTextOut->fuOptions  = uOptions & (ETO_OPAQUE | ETO_CLIPPED);

            //
            // If there is a clipping rect, set it up.  Otherwise use the
            // last ETO's clip rect.  This makes OE2 encoding more efficient.
            //
            // NOTE that this is not the same as the drawing bounds--the
            // text may extend outside the clip area.
            //
            if (SELECTOROF(lprcClip))
            {
                ASSERT(uOptions & (ETO_OPAQUE | ETO_CLIPPED));

                rcT = *lprcClip;
                OELRtoVirtual(g_oeState.hdc, &rcT, 1);


                //
                // This is a TSHR_RECT32, so we can't just copy
                //
                pExtTextOut->rectangle.left     = rcT.left;
                pExtTextOut->rectangle.top      = rcT.top;
                pExtTextOut->rectangle.right    = rcT.right;
                pExtTextOut->rectangle.bottom   = rcT.bottom;

                g_oeLastETORect = pExtTextOut->rectangle;
            }
            else
            {
                pExtTextOut->rectangle = g_oeLastETORect;
            }

            //
            // Copy the string
            //
            pExtTextOut->variableString.len = cchText;
            hmemcpy(pExtTextOut->variableString.string, lpszText, cchText);

            //
            // Copy the deltax array
            // 
            // Although we have a defined fixed length structure for
            // storing ExtTextOut orders, we don't send the full structure
            // over the network as the text will only be, say, 10 chars while 
            // the structure contains room for 127.
            //
            // Hence we pack the structure now to remove all the blank data
            // BUT we must maintain the natural alignment of the variables.
            //
            // So we know the length of the string which we can use to
            // start the new delta structure at the next 4-byte boundary.
            //
            if (!OEAddDeltaX(pExtTextOut, lpszText, cchText, lpdxCharSpacing, fSendDeltaX, ptStart))
            {
                WARNING_OUT(("Couldn't add delta-x array to EXTTEXTOUT order"));
                OA_DDFreeOrderMem(pOrder);
                pOrder = NULL;
            }
        }
    }


DC_EXIT_POINT:
    if (pOrder)
    {
        //
        // Call OEMaybeSimulateDeltaX to add a deltax array to the order
        // if needed to correctly position the text.  This happens when
        // the font in use doesn't exist on other machines.
        //
        pOrder->OrderHeader.Common.fOrderFlags = fOrderFlags;

        OTRACE(("TextOut:  Type %08lx, Order %08lx, Rect {%d, %d, %d, %d}, Length %d",
            pOrder, order, 
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom, cchText));
          
        OEClipAndAddOrder(pOrder, NULL);
    }
    else
    {
        OTRACE(("OEAddText:  Sending as screen data {%d, %d, %d, %d}",
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom));
        OEClipAndAddScreenData(&g_oeState.rc);
    }
    DebugExitVOID(OEAddText);
}



//
// OECheckFontIsSupported()
//
// We check if we can send this font.  If we haven't received the negotiated
// packet caps yet, forget it.  
//
// It returns:
//      font height in points
//      font ascender in points
//      average font width in points
//      font weight
//      font style flags
//      font handle
//      do we need to send delta x
//

BOOL OECheckFontIsSupported
(
    LPSTR       lpszText,
    UINT        cchText,
    LPUINT      pFontHeight,
    LPUINT      pFontWidth,
    LPUINT      pFontWeight,
    LPUINT      pFontFlags,
    LPUINT      pFontIndex,
    LPBOOL      pSendDeltaX
)
{
    BOOL        fFontSupported;
    UINT        codePage;
    UINT        i;
    UINT        iLocal;
    TSHR_UINT32 matchQuality;
    UINT        charWidthAdjustment;
    int         fontNameLen;
    int         compareResult;
    POINT       xformSize[2];

    DebugEntry(OECheckFontIsSupported);

    ASSERT(g_oeState.uFlags & OESTATE_FONT);

    //
    // Set up defaults
    //
    fFontSupported = FALSE;
    *pSendDeltaX = FALSE;

    //
    // Do we have our list yet?
    //
    if (!g_oeTextEnabled)
        DC_QUIT;

    //
    // Get the font facename
    //
    GetTextFace(g_oeState.hdc, LF_FACESIZE, g_oeState.logFont.lfFaceName);
    
    //
    // Search our Font Alias Table for the font name.  If we find it,
    // replace it with the aliased name.
    //
    charWidthAdjustment = 0;
    for (i = 0; i < NUM_ALIAS_FONTS; i++)
    {
        if (!lstrcmp(g_oeState.logFont.lfFaceName,
                     g_oeFontAliasTable[i].pszOriginalFontName))
        {
            TRACE_OUT(("Alias name: %s -> %s", g_oeState.logFont.lfFaceName,
                    g_oeFontAliasTable[i].pszAliasFontName));
            lstrcpy(g_oeState.logFont.lfFaceName,
                    g_oeFontAliasTable[i].pszAliasFontName);
            charWidthAdjustment = g_oeFontAliasTable[i].charWidthAdjustment;
            break;
        }
    }

    //
    // Get the current font code page
    //
    switch (g_oeState.tmFont.tmCharSet)
    {
        case ANSI_CHARSET:
            codePage = NF_CP_WIN_ANSI;
            break;

        case OEM_CHARSET:
            codePage = NF_CP_WIN_OEM;
            break;

        //
        // LAURABU BUGBUG
        // This wasn't in NM 2.0 -- does this cause problems in int'l?
        //
        case SYMBOL_CHARSET:
            codePage = NF_CP_WIN_SYMBOL;
            break;

        default:
            codePage = NF_CP_UNKNOWN;
            break;
    }


    //
    // We have a font name to match with those we know to be available
    // remotely.  Try to jump straight to the first entry in the local font
    // table starting with the same char as this font.  If this index slot
    // is empty (has 0xFFFF in it), then bail out immediately.
    //
    for (iLocal = g_oeLocalFontIndex[(BYTE)g_oeState.logFont.lfFaceName[0]];
         iLocal < g_oeNumFonts;
         iLocal++)
    {
        //
        // If this font isn't supported remotely, skip it.
        //
        matchQuality = g_poeLocalFonts[iLocal].SupportCode;
        if (matchQuality == FH_SC_NO_MATCH)
        {
            continue;
        }

        //
        // If this facename is different than ours, skip it.  WE MUST
        // CALL STRCMP(), because lstrcmp and strcmp() do different things
        // for case.  lstrcmp is lexi, and strcmp is alphi.
        //
        compareResult = MyStrcmp(g_poeLocalFonts[iLocal].Details.nfFaceName,
            g_oeState.logFont.lfFaceName);

        //
        // If this font is alphabetically before the one we're searching for,
        // skip it and continue looking.
        //
        if (compareResult < 0)
        {
            continue;
        }

        //
        // If this font is alphabetically after the one we're searching for,
        // then an entry for ours doesn't exist since the table is sorted
        // alphabetically.  Bail out.
        //
        if (compareResult > 0)
        {
            break;
        }

        //
        // This looks promising, a font with the right name is supported on
        // the remote system.  Let's look at the metrics.
        //
        *pFontFlags  = 0;
        *pFontIndex  = iLocal;
        *pFontWeight = g_oeState.tmFont.tmWeight;

        //
        // Check for a fixed pitch font (NOT present means fixed)
        //
        if (!(g_oeState.tmFont.tmPitchAndFamily & FIXED_PITCH))
        {
            *pFontFlags |= NF_FIXED_PITCH;
        }

        //
        // Check for a truetype font
        //
        if (g_oeState.tmFont.tmPitchAndFamily & TMPF_TRUETYPE)
        {
            *pFontFlags |= NF_TRUE_TYPE;
        }

        //
        // Convert the font dimensions into pixel values.  We use the 
        // average font width and the character height
        //
        xformSize[0].x = 0;
        xformSize[0].y = 0;
        xformSize[1].x = g_oeState.tmFont.tmAveCharWidth;
        xformSize[1].y = g_oeState.tmFont.tmHeight -
            g_oeState.tmFont.tmInternalLeading;

        //
        // For non-truetype simulated bold/italic fonts only:
        //
        // If the font is bold, the overhang field indicates the extra
        // space a char takes up.  Since our internal table contains the
        // size of normal (non-bold) chars for simulated bold, we adjust
        // for that here.
        // 
        // If the font is italic, the overhang field indicates the number
        // of pixels the char is skewed.  We don't want to make adjustments
        // in this case.
        //
        if (!(g_oeState.tmFont.tmPitchAndFamily & TMPF_TRUETYPE) &&
            !g_oeState.tmFont.tmItalic)
        {
            xformSize[1].x -= g_oeState.tmFont.tmOverhang;
        }

        //
        // LAURABU BOGUS
        // For baseline text orders
        //
        // xformSize[2].x = 0;
        // xformSize[2].y = g_oeState.tmFont.tmAscent;
        //

        LPtoDP(g_oeState.hdc, xformSize, 2);

        //
        // Calculate the font width & height
        //
        *pFontHeight = abs(xformSize[1].y - xformSize[0].y);
        *pFontWidth  = abs(xformSize[1].x - xformSize[0].x)
            - charWidthAdjustment;

        //
        // LAURABU BOGUS
        // For baseline text orders
        //
        // Get the offset to the start of the text cell
        //
        // *pFontAscender = abs(xformSize[2].y - xformSize[0].y);
        //


        //
        // Check that we have a matching pair -- where we require that the
        // fonts (i.e., the one being used by the app and the one we've
        // matched with the remot system) are the same pitch and use the
        // same technology.
        //
        if ((g_poeLocalFonts[iLocal].Details.nfFontFlags & NF_FIXED_PITCH) !=
            (*pFontFlags & NF_FIXED_PITCH))
        {
            OTRACE(("Fixed pitch mismatch"));
            continue;
        }
        if ((g_poeLocalFonts[iLocal].Details.nfFontFlags & NF_TRUE_TYPE) !=
            (*pFontFlags & NF_TRUE_TYPE))
        {
            OTRACE(("True type mismatch"));
            continue;
        }

        //
        // We have a pair of fonts with the same attributes, both fixed or
        // variable pitch, and using the same font technology.
        //
        // If the font is fixed pitch, then we need to check that the size
        // matches also.
        //
        // If not, assume it's always matchable.
        //
        if (g_poeLocalFonts[iLocal].Details.nfFontFlags & NF_FIXED_SIZE)
        {
            //
            // The font is fixed size, so we must check that this
            // particular size is matchable.
            //
            if ( (*pFontHeight != g_poeLocalFonts[iLocal].Details.nfAveHeight) ||
                 (*pFontWidth  != g_poeLocalFonts[iLocal].Details.nfAveWidth)  )
            {
                //
                // The sizes differ, so we must fail this match.
                //
                TRACE_OUT(("Font size mismatch:  want {%d, %d}, found {%d, %d}",
                    *pFontHeight, *pFontWidth, g_poeLocalFonts[iLocal].Details.nfAveHeight,
                    g_poeLocalFonts[iLocal].Details.nfAveWidth));
                continue;
            }
        }

        //
        // Finally, we've got a matched pair.
        //
        fFontSupported = TRUE;
        break;
    }


    if (!fFontSupported)
    {
        TRACE_OUT(("Couldn't find matching font for %s in table",
            g_oeState.logFont.lfFaceName));
        DC_QUIT;
    }

    //
    // Build up the rest of the font flags.  We've got pitch already.
    //
    if (g_oeState.tmFont.tmItalic)
    {
        *pFontFlags |= NF_ITALIC;
    }
    if (g_oeState.tmFont.tmUnderlined)
    {
        *pFontFlags |= NF_UNDERLINE;
    }
    if (g_oeState.tmFont.tmStruckOut)
    {
        *pFontFlags |= NF_STRIKEOUT;
    }

    //
    // LAURABU BOGUS
    // On NT, here's where simulated bold fonts are handled.  Note that we, 
    // like NM 2.0, handle it above with the overhang.
    //
#if 0
    //
    // It is possible to have a font made bold by Windows, i.e.  the
    // standard font definition is not bold, but windows manipulates the
    // font data to create a bold effect.  This is marked by the
    // FO_SIM_BOLD flag.
    //
    // In this case we need to ensure that the font flags are marked as
    // bold according to the weight.
    //
    if ( ((pfo->flFontType & FO_SIM_BOLD) != 0)       &&
         ( pFontMetrics->usWinWeight      <  FW_BOLD) )
    {
        TRACE_OUT(( "Upgrading weight for a bold font"));
        *pFontWeight = FW_BOLD;
    }
#endif

    //
    // Should we check the chars in the string itself?  Use matchQuality
    // to decide.
    //
    // If the font is an exact match, or if it's an approx match for its
    // entire range (0x00 to 0xFF), then send it happily.  If not, only 
    // send chars within the range 0x20-0x7F (real ASCII)
    //
    if (codePage != g_poeLocalFonts[iLocal].Details.nfCodePage)
    {
        TRACE_OUT(( "Using different CP: downgrade to APPROX_ASC"));
        matchQuality = FH_SC_APPROX_ASCII_MATCH;
    }

    //
    // If we don't have an exact match, check the individual characters.
    //
    if ( (matchQuality != FH_SC_EXACT_MATCH ) &&
         (matchQuality != FH_SC_APPROX_MATCH) )
    {
        //
        // LAURABU BOGUS!
        // NT does approximate matching only if the font supports the
        // ANSI charset.  NM 2.0 never did this, so we won't either.
        //

        //
        // This font is not a good match across its entire range.  Check
        // that all chars are within the desired range.
        //
        for (i = 0; i < cchText; i++)
        {
            if ( (lpszText[i] == 0) ||
                 ( (lpszText[i] >= NF_ASCII_FIRST) &&
                   (lpszText[i] <= NF_ASCII_LAST)  )  )
            {
                continue;
            }

            //
            // Can only get here by finding a char outside our acceptable
            // range.
            //
            OTRACE(("Found non ASCII char %c", lpszText[i]));
            fFontSupported = FALSE;
            DC_QUIT;
        }

        if (fFontSupported)
        {
            //
            // We still have to check that this is ANSI text.  Consider a
            // string written in symbol font where all the chars in
            // the string are in the range 0x20-0x7F, but none of them 
            // are ASCII.
            //
            OemToAnsiBuff(lpszText, g_oeAnsiString, cchText);

            //
            // BOGUS LAURABU
            // This is our own inline MEMCMP to avoid pulling in the CRT.
            // If any other place needs it, we should make this a function
            //
            for (i = 0; i < cchText; i++)
            {
                if (lpszText[i] != g_oeAnsiString[i])
                {
                    OTRACE(("Found non ANSI char %c", lpszText[i]));
                    fFontSupported = FALSE;
                    DC_QUIT;
                }
            }
        }
    }


    //
    // We have a valid font.  Now sort out deltaX issues
    //
    if (!(g_oeFontCaps & CAPS_FONT_NEED_X_ALWAYS))
    {
        if (!(g_oeFontCaps & CAPS_FONT_NEED_X_SOMETIMES))
        {
            //
            // CAPS_FONT_NEED_X_SOMETIMES and CAPS_FONT_NEED_X_ALWAYS are
            // both not set so we can exit now.  (We do not need a delta X
            // array).
            //
            TRACE_OUT(( "Capabilities eliminated delta X"));
            DC_QUIT;
        }

        //
        // CAPS_FONT_NEED_X_SOMETIMES is set and CAPS_FONT_NEED_X_ALWAYS is
        // not set.  In this case whether we need a delta X is determined
        // by whether the font is an exact match or an approximate match
        // (because of either approximation of name, signature, or aspect
        // ratio).  We can only find this out after we have extracted the
        // font handle from the existing order.
        //
    }

    //
    // If the string is a single character (or less) then we can just
    // return.
    //
    if (cchText <= 1)
    {
        TRACE_OUT(( "String only %u long", cchText));
        DC_QUIT;
    }

    //
    // Capabilities allow us to ignore delta X position if we have an exact
    // match.
    //
    if (matchQuality & FH_SC_EXACT)
    {
        //
        // Exit immediately, providing that there is no override to always
        // send increments.
        //
        if (!(g_oeFontCaps & CAPS_FONT_NEED_X_ALWAYS))
        {
            TRACE_OUT(( "Font has exact match"));
            DC_QUIT;
        }
    }

    //
    // We must send a deltaX array
    //
    *pSendDeltaX = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(OECheckFontIsSupported, fFontSupported);
    return(fFontSupported);
}



//
// OEAddDeltaX()
//
// This fills in the allocated deltaX array if one is needed, either because
// the app passed one in ExtTextOut, or we need to simulate a font that
// isn't available remotely.
//
BOOL OEAddDeltaX
(
    LPEXTTEXTOUT_ORDER  pExtTextOut,
    LPSTR               lpszText,
    UINT                cchText,
    LPINT               lpdxCharSpacing,
    BOOL                fDeltaX,
    POINT               ptStart
)
{
    BOOL                fSuccess;
    LPBYTE              lpVariable;
    LPVARIABLE_DELTAX   lpDeltaPos;
    UINT                i;
    int                 charWidth;
    int                 xLastLP;
    int                 xLastDP;

    DebugEntry(OEAddDeltaX);

    lpVariable = ((LPBYTE)&pExtTextOut->variableString) +
        sizeof(pExtTextOut->variableString.len) + cchText;
    lpDeltaPos = (LPVARIABLE_DELTAX)DC_ROUND_UP_4((DWORD)lpVariable);

    fSuccess = FALSE;

    if (SELECTOROF(lpdxCharSpacing))
    {
        //
        // We must translate the LPDX increments into device units.  
        // We have to do this a single point at a time to preserve
        // accuracy and because the order field isn't the same size.
        //
        // We preserve accuracy by calculating the position of the
        // point in the current coords, and converting this before
        // subtracting the original point to get the delta.  
        // Otherwise, we'd hit rounding errors very often.  4 chars
        // is the limit in TWIPs e.g.
        //

        lpDeltaPos->len = cchText * sizeof(TSHR_INT32);

        xLastLP = ptStart.x;
        ptStart.y = 0;
        LPtoDP(g_oeState.hdc, &ptStart, 1);
        xLastDP = ptStart.x;

        for (i = 0; i < cchText; i++)
        {
            xLastLP += lpdxCharSpacing[i];

            ptStart.x = xLastLP;
            ptStart.y = 0;
            LPtoDP(g_oeState.hdc, &ptStart, 1);

            lpDeltaPos->deltaX[i] = ptStart.x - xLastDP;
            xLastDP = ptStart.x;
        }

        //
        // Remember we have a deltax array
        //
        pExtTextOut->fuOptions |= ETO_LPDX;
        fSuccess = TRUE;
    }
    else if (fDeltaX)
    {
        //
        // Simulate deltax.
        //
        lpDeltaPos->len = cchText * sizeof(TSHR_INT32);

        //
        // Is this the same font as last time?  If so, we have the 
        // generated character width table cached.
        //
        // NOTE that when the capabilities chage, we clear the cache to
        // avoid matching a font based on a stale index.  And when starting
        // to share.
        //
        if ((g_oeFhLast.fontIndex     != pExtTextOut->common.FontIndex) ||
            (g_oeFhLast.fontHeight    != pExtTextOut->common.FontHeight) ||
            (g_oeFhLast.fontWidth     != pExtTextOut->common.FontWidth) ||
            (g_oeFhLast.fontWeight    != pExtTextOut->common.FontWeight) ||
            (g_oeFhLast.fontFlags     != pExtTextOut->common.FontFlags))
        {
            LPLOCALFONT lpFont;
            HFONT       hFontSim;
            HFONT       hFontOld;
            TEXTMETRIC  tmNew;
            int         width;
            ABC         abc;
            BYTE        italic;
            BYTE        underline;
            BYTE        strikeout;
            BYTE        pitch;
            BYTE        charset;
            BYTE        precis;
            TSHR_UINT32 FontFlags;

            //
            // Generate a new table and cache the info
            //
            // We can not use the ACTUAL font selected in.  We must
            // create a new logical font from our table info.
            //

            ASSERT(g_poeLocalFonts);
            lpFont = g_poeLocalFonts + pExtTextOut->common.FontIndex;
            FontFlags = pExtTextOut->common.FontFlags;

            //
            // What are the logical attributes of this desired font?
            //

            italic      = (BYTE)(FontFlags & NF_ITALIC);
            underline   = (BYTE)(FontFlags & NF_UNDERLINE);
            strikeout   = (BYTE)(FontFlags & NF_STRIKEOUT);

            if (FontFlags & NF_FIXED_PITCH)
            {
                pitch = FF_DONTCARE | FIXED_PITCH;
            }
            else
            {
                pitch = FF_DONTCARE | VARIABLE_PITCH;
            }

            //
            // Is this a TrueType font?  The windows Font Mapper biases
            // towards non-TrueType fonts.
            //
            if (FontFlags & NF_TRUE_TYPE)
            {
                pitch |= TMPF_TRUETYPE;
                precis = OUT_TT_ONLY_PRECIS;
            }
            else
            {
                precis = OUT_RASTER_PRECIS;
            }

            //
            // The given height is the char height, not the cell height.
            // So pass it as a negative value below...
            //

            //
            // Use the codepage (misleadingly named) to figure out the
            // charset to ask for.
            //
            if (lpFont->Details.nfCodePage == NF_CP_WIN_ANSI)
            {
                charset = ANSI_CHARSET;
            }
            else if (lpFont->Details.nfCodePage == NF_CP_WIN_OEM)
            {
                charset = OEM_CHARSET;
            }
            else if (lpFont->Details.nfCodePage == NF_CP_WIN_SYMBOL)
            {
                charset = SYMBOL_CHARSET;
            }
            else
            {
                charset = DEFAULT_CHARSET;
            }

            hFontSim = CreateFont(-(int)pExtTextOut->common.FontHeight,
                (int)pExtTextOut->common.FontWidth, 0, 0,
                (int)pExtTextOut->common.FontWeight, italic, underline,
                strikeout, charset, precis, CLIP_DEFAULT_PRECIS,
                DEFAULT_QUALITY, pitch, (LPSTR)lpFont->Details.nfFaceName);
            if (!hFontSim)
            {
                ERROR_OUT(("Couldn't create simulated font for metrics"));
                DC_QUIT;
            }
            
            hFontOld = SelectFont(g_osiScreenDC, hFontSim);
            if (!hFontOld)
            {
                ERROR_OUT(("Couldn't select simulated font for metrics"));
                DeleteFont(hFontSim);
                DC_QUIT;
            }

            //
            // Get the character dimensions
            //
            GetTextMetrics(g_osiScreenDC, &tmNew);

            for (i = 0; i < 256; i++)
            {
                if (tmNew.tmPitchAndFamily & TMPF_TRUETYPE)
                {
                    //
                    // Use ABC spacing for truetype
                    //
                    GetCharABCWidths(g_osiScreenDC, i, i, &abc);
    
                    width = abc.abcA + abc.abcB + abc.abcC;
                }
                else if (!(tmNew.tmPitchAndFamily & FIXED_PITCH))
                {
                    //
                    // Note that the name of FIXED_PITCH is not what you'd
                    // expect, its ABSENCE means it's fixed.
                    //
                    // In any case, for fixed pitch fonts, each char is the 
                    // same size.
                    //
                    width = tmNew.tmAveCharWidth - tmNew.tmOverhang; 
                }
                else
                {
                    //
                    // Query the width of the char
                    //
                    GetCharWidth(g_osiScreenDC, i, i, &width);
                    width -= tmNew.tmOverhang;
                }

                g_oeFhLast.charWidths[i] = width;
            }

            //
            // We've successfully generated the width info for this font,
            // update our cache.
            //
            g_oeFhLast.fontIndex  = pExtTextOut->common.FontIndex;
            g_oeFhLast.fontHeight = pExtTextOut->common.FontHeight;
            g_oeFhLast.fontWidth  = pExtTextOut->common.FontWidth;  
            g_oeFhLast.fontWeight = pExtTextOut->common.FontWeight;
            g_oeFhLast.fontFlags  = pExtTextOut->common.FontFlags;

            //
            // Select back in old font and delete new one
            //
            SelectFont(g_osiScreenDC, hFontOld);
            DeleteFont(hFontSim);
        }

        //
        // Now calculate the width of each character in the string.  
        // This includes the last char because it is needed to correctly 
        // define the extent of the string.
        //
        for (i = 0; i < cchText; i++)
        {
            //
            // The width is that in the width table for the current char. 
            //
            lpDeltaPos->deltaX[i] = g_oeFhLast.charWidths[lpszText[i]];
        }

        //
        // Remember we have a deltax array
        //
        pExtTextOut->fuOptions |= ETO_LPDX;
        fSuccess = TRUE;
    }
    else
    {
        //
        // No deltax array
        //
        lpDeltaPos->len = 0;
        fSuccess = TRUE;
    }

DC_EXIT_POINT:
    DebugExitBOOL(OEAddDeltaX, fSuccess);
    return(fSuccess);
}



//
// OEGetStringExtent()
//
int OEGetStringExtent
(
    LPSTR   lpszText,
    UINT    cchText,
    LPINT   lpdxCharSpacing,
    LPRECT  lprcExtent
)
{
    DWORD   textExtent;
    UINT    i;
    int     thisX;
    int     minX;
    int     maxX;
    ABC     abcSpace;
    int     overhang = 0;

    DebugEntry(OEGetStringExtent);

    ASSERT(g_oeState.uFlags & OESTATE_FONT);
    ASSERT(g_oeState.uFlags & OESTATE_COORDS);

    //
    // With no characters, return a NULL rect
    //
    if (cchText == 0)
    {
        lprcExtent->left    = 1;
        lprcExtent->top     = 0;
        lprcExtent->right   = 0;
        lprcExtent->bottom  = 0;
    }
    else if (!SELECTOROF(lpdxCharSpacing))
    {
        //
        // Get the simple text extent from GDI
        //
        textExtent = GetTextExtent(g_oeState.hdc, lpszText, cchText);

        lprcExtent->left    = 0;
        lprcExtent->top     = 0;
        lprcExtent->right   = LOWORD(textExtent);
        lprcExtent->bottom  = HIWORD(textExtent);

        //
        // We now have the the advance distance for the string.  However,
        // some fonts like TrueType with C widths, or Italic, may extend
        // beyond this.  Add in extra space here if necessary
        //
        if (g_oeState.tmFont.tmPitchAndFamily & TMPF_TRUETYPE)
        {
            //
            // Get the A-B-C widths of the last character
            //
            GetCharABCWidths(g_oeState.hdc, lpszText[cchText-1],
                lpszText[cchText-1], &abcSpace);

            //
            // Add on the C width (the right side extra) of the last char
            //
            overhang = abcSpace.abcC;
        }
        else
        {
            //
            // Use global overhang, this is an old font (like simulated Italic)
            //
            overhang = g_oeState.tmFont.tmOverhang;
        }

        lprcExtent->right += overhang;
    }
    else
    {
        //
        // Delta positions were given.  In this case, the text extent is 
        // the sum of the delta values + the width of the last char
        //

        // Get the dimensions of the chars one by one, starting with 1st char
        textExtent = GetTextExtent(g_oeState.hdc, lpszText, 1);

        thisX = 0;
        minX  = 0;
        maxX  = LOWORD(textExtent);

        for (i = 1; i < cchText; i++)
        {
            thisX   += g_oeState.ptPolarity.x * lpdxCharSpacing[i-1];
            textExtent = GetTextExtent(g_oeState.hdc, lpszText+i, 1);

            minX = min(minX, thisX);
            maxX = max(maxX, thisX + (int)LOWORD(textExtent));
        }

        thisX += g_oeState.ptPolarity.x * lpdxCharSpacing[cchText-1];
        maxX   = max(maxX, thisX);

        lprcExtent->left    = minX;
        lprcExtent->top     = 0;
        lprcExtent->right   = maxX;
        lprcExtent->bottom  = HIWORD(textExtent);
    }

    DebugExitDWORD(OEGetStringExtent, (DWORD)(LONG)overhang);
    return(overhang);
}



//
// DrvFillPath()
//
BOOL WINAPI DrvFillPath
(
    HDC     hdcDst
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvFillPath);

    OE_SHM_START_WRITING;

    //
    // The Path() apis don't set the drawing bounds.  We assume the whole
    // screen (device coords) instead.
    //
    // NOTE that NM 2.0 had a bug--it didn't account for the virtual
    // screen origin when setting up the rect to accum as screen data.
    // It just passed (0, 0, 32765, 32765) in.
    //
    fWeCare = OEBeforeDDI(DDI_FILLPATH, hdcDst, OESTATE_SDA_SCREEN);

    fOutput = FillPath(hdcDst);

    OEAfterDDI(DDI_FILLPATH, fWeCare, fOutput);

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvFillPath, fOutput);
    return(fOutput);
}


//
// DrvStrokeAndFillPath()
//
BOOL WINAPI DrvStrokeAndFillPath
(
    HDC     hdcDst
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvStrokeAndFillPath);

    OE_SHM_START_WRITING;

    //
    // The Path() apis don't set the drawing bounds.  We assume the whole
    // screen (device coords) instead.
    //
    // NOTE that NM 2.0 had a bug--it didn't account for the virtual
    // screen origin when setting up the rect to accum as screen data.
    // It just passed (0, 0, 32765, 32765) in.
    //

    fWeCare = OEBeforeDDI(DDI_STROKEANDFILLPATH, hdcDst, OESTATE_SDA_SCREEN);

    fOutput = StrokeAndFillPath(hdcDst);

    OEAfterDDI(DDI_STROKEANDFILLPATH, fWeCare, fOutput);

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvStrokeAndFillPath, fOutput);
    return(fOutput);
}


//
// DrvStrokePath()
//
BOOL WINAPI DrvStrokePath
(
    HDC     hdcDst
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvStrokePath);

    OE_SHM_START_WRITING;

    //
    // The Path() apis don't set the drawing bounds.  We assume the whole
    // screen (device coords) instead.
    //
    // NOTE that NM 2.0 had a bug--it didn't account for the virtual
    // screen origin when setting up the rect to accum as screen data.
    // It just passed (0, 0, 32765, 32765) in.
    //
    fWeCare = OEBeforeDDI(DDI_STROKEPATH, hdcDst, OESTATE_SDA_SCREEN);

    fOutput = StrokePath(hdcDst);

    OEAfterDDI(DDI_STROKEPATH, fWeCare, fOutput);

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvStrokePath, fOutput);
    return(fOutput);
}



//
// DrvFillRgn()
//
BOOL WINAPI DrvFillRgn
(
    HDC     hdcDst,
    HRGN    hrgnFill,
    HBRUSH  hbrFill
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvFillRgn);

    OE_SHM_START_WRITING;

    //
    // We can't use Rgn apis if the map mode isn't MM_TEXT.  So we use DCBs
    // instead.
    //
    fWeCare = OEBeforeDDI(DDI_FILLRGN, hdcDst, 0);

    fOutput = FillRgn(hdcDst, hrgnFill, hbrFill);

    if (OEAfterDDI(DDI_FILLRGN, fWeCare, fOutput))
    {
        //
        // NOTE that OEAfterDDI() returns FALSE even if fOutput if we used
        // DCBs to send as screen data.  In other words, OEAfterDDI() returns
        // TRUE IFF output happened into a DC we care about and it needs 
        // processing still.
        //
        OEAddRgnPaint(hrgnFill, hbrFill, g_oeState.lpdc->DrawMode.Rop2);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvFillRgn, fOutput);
    return(fOutput);
}


//
// OETwoWayRopToThree()
// Gets the 3-way ROP equivalent of a 2-way ROP.
//
BOOL OETwoWayRopToThree
(
    int     rop2,
    LPDWORD lpdwRop3
)
{
    BOOL    fConverted = TRUE;

    DebugEntry(OETwoWayRopToThree);

    switch (rop2)
    {
        case R2_BLACK:
            *lpdwRop3 = BLACKNESS;
            break;

        case R2_NOT:
            *lpdwRop3 = DSTINVERT;
            break;

        case R2_XORPEN:
            *lpdwRop3 = PATINVERT;
            break;

        case R2_COPYPEN:
            *lpdwRop3 = PATCOPY;
            break;

        case R2_WHITE:
            *lpdwRop3 = WHITENESS;
            break;

        default:
            fConverted = FALSE;
            break;
    }

    DebugExitBOOL(OETwoWayRopToThree, fConverted);
    return(fConverted);
}

//
// OEAddRgnPaint()
// This will set up a modified region (vis intersect param) and brush, and
// if possible will fake a PatBlt.  If not, screen data.
//
// NOTE:
// (1) hrgnPaint is in DC coords
// (2) GetClipRgn() returns a region in screen coords
// (3) SelectClipRgn() takes a region in DC coords
//
void OEAddRgnPaint
(
    HRGN    hrgnPaint,
    HBRUSH  hbrPaint,
    UINT    rop2
)
{
    BOOL    fScreenData = TRUE;
    HRGN    hrgnClip;
    HRGN    hrgnNewClip;
    HRGN    hrgnOldClip;
    POINT   ptXlation;
    DWORD   dwRop3;

    DebugEntry(OEAddRgnPaint);

    //
    // Get the original visrgn.
    //
    OEGetState(OESTATE_COORDS | OESTATE_REGION);

    //
    // Get the bounding box and convert the bounding box to our coords.
    //
    if (GetRgnBox(hrgnPaint, &g_oeState.rc) <= NULLREGION)
    {
        // Nothing to do.
        TRACE_OUT(("OEAddRgnPaint:  empty region"));
        goto DC_EMPTY_REGION;
    }
    OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

    //
    // We can't continue if we aren't MM_TEXT--clip rgn APIs only work 
    // in that mode.  So send as screen data instead.
    //
    if (GetMapMode(g_oeState.hdc) != MM_TEXT)
    {
        TRACE_OUT(("OEAddRgnPaint: map mode not MM_TEXT, send as screen data"));
        DC_QUIT;
    }

    //
    // Save a copy of the current cliprgn
    //
    hrgnNewClip = CreateRectRgn(0, 0, 0, 0);
    if (!hrgnNewClip)
        DC_QUIT;

    //
    // Get app LP xlation factor; SelectClipRgn() expects DP units
    //
    ptXlation.x = 0;
    ptXlation.y = 0;
    DPtoLP(g_oeState.hdc, &ptXlation, 1);

    hrgnOldClip = NULL;
    if (hrgnClip = GetClipRgn(g_oeState.hdc))
    {
        hrgnOldClip = CreateRectRgn(0, 0, 0, 0);
        if (!hrgnOldClip)
        {
            DeleteRgn(hrgnNewClip);
            DC_QUIT;
        }

        //
        // This is in screen coords.  Convert to DC coords
        //      * Subtract the DC origin
        //      * Get the DP-LP xlation and subtract
        //
        CopyRgn(hrgnOldClip, hrgnClip);
        OffsetRgn(hrgnOldClip,
            -g_oeState.ptDCOrg.x + ptXlation.x,
            -g_oeState.ptDCOrg.y + ptXlation.y);

        //
        // Intersect the current clip with the paint region (already in
        // DC coords)
        //
        IntersectRgn(hrgnNewClip, hrgnOldClip, hrgnPaint);

        //
        // Convert the old LP region back to DP units to select back in
        // when done.
        //
        OffsetRgn(hrgnOldClip, -ptXlation.x, -ptXlation.y);
    }
    else
    {
        CopyRgn(hrgnNewClip, hrgnPaint);
    }

    //
    // Convert LP paint region to DP clip region
    //
    OffsetRgn(hrgnNewClip, -ptXlation.x, -ptXlation.y);

    //
    // Select in new clip region (expected to be in device coords).
    //
    SelectClipRgn(g_oeState.hdc, hrgnNewClip);
    DeleteRgn(hrgnNewClip);

    //
    // Reget the RAO (intersect of vis/clip)
    //
    OEGetState(OESTATE_REGION);

    //
    // Get brush info
    //
    if (hbrPaint)
    {
        if (GetObject(hbrPaint, sizeof(g_oeState.logBrush), &g_oeState.logBrush))
        {
            g_oeState.uFlags |= OESTATE_BRUSH;
        }
        else
        {
            g_oeState.logBrush.lbStyle = BS_NULL;
        }
    }

    //
    // Fake a patblt
    //
    if (OETwoWayRopToThree(rop2, &dwRop3))
    {
        fScreenData = FALSE;
        OEAddBlt(dwRop3);
    }

    //
    // Select back in the previous clip rgn
    //
    SelectClipRgn(g_oeState.hdc, hrgnOldClip);
    if (hrgnOldClip)
        DeleteRgn(hrgnOldClip);


DC_EXIT_POINT:
    if (fScreenData)
    {
        OTRACE(("OEAddRgnPaint:  Sending as screen data {%d, %d, %d, %d}",
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom));
        OEClipAndAddScreenData(&g_oeState.rc);
    }

DC_EMPTY_REGION:
    DebugExitVOID(OEAddRgnPaint);
}



//
// DrvFrameRgn()
//
BOOL WINAPI DrvFrameRgn
(
    HDC     hdcDst,
    HRGN    hrgnFrameArea,
    HBRUSH  hbrFramePattern,
    int     cxFrame,
    int     cyFrame
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvFrameRgn);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_FRAMERGN, hdcDst, 0);

    fOutput = FrameRgn(hdcDst, hrgnFrameArea, hbrFramePattern,
        cxFrame, cyFrame);

    if (OEAfterDDI(DDI_FRAMERGN, fWeCare, fOutput))
    {
        OEGetState(OESTATE_COORDS | OESTATE_REGION);

        if (GetRgnBox(hrgnFrameArea, &g_oeState.rc) > NULLREGION)
        {
            InflateRect(&g_oeState.rc,
                g_oeState.ptPolarity.x * cxFrame,
                g_oeState.ptPolarity.y * cyFrame);
            OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

            OTRACE(("FrameRgn:  Sending as screen data {%d, %d, %d, %d}",
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
            OEClipAndAddScreenData(&g_oeState.rc);
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvFrameRgn, fOutput);
    return(fOutput);
}



//
// DrvInvertRgn()
//
BOOL WINAPI DrvInvertRgn
(
    HDC     hdcDst,
    HRGN    hrgnInvert
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvInvertRgn);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_INVERTRGN, hdcDst, 0);

    fOutput = InvertRgn(hdcDst, hrgnInvert);

    if (OEAfterDDI(DDI_INVERTRGN, fWeCare, fOutput))
    {
        OEAddRgnPaint(hrgnInvert, NULL, R2_NOT);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvInvertRgn, fOutput);
    return(fOutput);
}



//
// DrvPaintRgn()
//
BOOL WINAPI DrvPaintRgn
(
    HDC     hdcDst,
    HRGN    hrgnPaint
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvPaintRgn);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_PAINTRGN, hdcDst, 0);

    fOutput = PaintRgn(hdcDst, hrgnPaint);

    if (OEAfterDDI(DDI_PAINTRGN, fWeCare, fOutput))
    {
        OEAddRgnPaint(hrgnPaint, g_oeState.lpdc->hBrush, g_oeState.lpdc->DrawMode.Rop2);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPaintRgn, fOutput);
    return(fOutput);
}



//
// DrvLineTo()
//
BOOL WINAPI DrvLineTo
(
    HDC     hdcDst,
    int     xTo,
    int     yTo
)
{
    POINT   ptEnd;
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvLineTo);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_LINETO, hdcDst, OESTATE_CURPOS);

    fOutput = LineTo(hdcDst, xTo, yTo);

    //
    // OEAfterDDI returns TRUE if the DC is a screen DC and output happened
    // and we aren't skipping due to reentrancy.
    //
    if (OEAfterDDI(DDI_LINETO, fWeCare, fOutput))
    {
        //
        // OEAddLine() will calculate extents, and if an order can't be sent,
        // OEDoneDDI will add the bounds as screen data.
        //
        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_REGION);
                                  
        ptEnd.x = xTo;
        ptEnd.y = yTo;

        ASSERT(g_oeState.uFlags & OESTATE_CURPOS);
        OEAddLine(g_oeState.ptCurPos, ptEnd);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvLineTo, fOutput);
    return(fOutput);
}



//
// DrvPolyline()
//
// NOTE:
// The differences between Polyline() and PolylineTo() are
//      (1) PolylineTo moves the current position to the end coords of the
//          last point; Polyline preserves the current position
//      (2) Polyline uses the first point in the array as the starting coord
//          of the first point; PolylineTo() uses the current position.
//
BOOL WINAPI DrvPolyline
(
    HDC     hdcDst,
    LPPOINT    aPoints,
    int     cPoints
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvPolyline);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_POLYLINE, hdcDst, 0);

    fOutput = Polyline(hdcDst, aPoints, cPoints);

    if (OEAfterDDI(DDI_POLYLINE, fWeCare, fOutput && cPoints > 1))
    {
        //
        // GDI should NEVER return success if the aPoints parameter is
        // bogus.
        //
        // NOTE LAURABU:
        // This implementation is better than NM 2.0.  That one would turn
        // this GDI call actually into separate MoveTo/LineTo calls, which 
        // whacks out metafiles etc.  Instead, we call through to the org
        // Polyline, then add LineTo orders.
        //
        ASSERT(!IsBadReadPtr(aPoints, cPoints*sizeof(POINT)));

        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_REGION);

        OEAddPolyline(aPoints[0], aPoints+1, cPoints-1);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPolyline, fOutput);
    return(fOutput);
}



//
// DrvPolylineTo()
//
BOOL WINAPI DrvPolylineTo
(
    HDC     hdcDst,
    LPPOINT    aPoints,
    int     cPoints
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvPolylineTo);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_POLYLINETO, hdcDst, OESTATE_CURPOS);

    fOutput = g_lpfnPolylineTo(hdcDst, aPoints, cPoints);

    if (OEAfterDDI(DDI_POLYLINETO, fWeCare, fOutput && cPoints))
    {
        //
        // GDI should NEVER return success if the aPoints parameter is
        // bogus.
        //
        // NOTE LAURABU:
        // This implementation is better than NM 2.0.  That one would turn
        // this GDI call actually into separate LineTo calls, which whacks
        // out metafiles etc.  Instead, we call through to the original
        // PolylineTo, then add LineTo orders.
        //
        ASSERT(!IsBadReadPtr(aPoints, cPoints*sizeof(POINT)));

        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_REGION);
        ASSERT(g_oeState.uFlags & OESTATE_CURPOS);

        OEAddPolyline(g_oeState.ptCurPos, aPoints, cPoints);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPolylineTo, fOutput);
    return(fOutput);
}



//
// OEAddPolyline
// Used by Polyline(), PolylineTo(), and PolyPolyline()
//
void OEAddPolyline
(
    POINT   ptStart,
    LPPOINT aPoints,
    UINT    cPoints
)
{
    DebugEntry(OEAddPolyline);

    ASSERT(g_oeState.uFlags & OESTATE_COORDS);
    ASSERT(g_oeState.uFlags & OESTATE_REGION);

    while (cPoints-- > 0)
    {
        OEAddLine(ptStart, *aPoints);

        //
        // The start point of the next line is the end point of the
        // current one.
        //
        ptStart = *aPoints;

        aPoints++;
    }

    DebugExitVOID(OEAddPolyline);
}



//
// DrvPlayEnhMetaFileRecord()
//
BOOL WINAPI DrvPlayEnhMetaFileRecord
(
    HDC     hdcDst,
    LPHANDLETABLE   lpEMFHandles,
    LPENHMETARECORD lpEMFRecord,
    DWORD   cEMFHandles
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvPlayEnhMetaFileRecord);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_PLAYENHMETAFILERECORD, hdcDst, OESTATE_SDA_DCB);

    fOutput = PlayEnhMetaFileRecord(hdcDst, lpEMFHandles, lpEMFRecord, cEMFHandles);

    OEAfterDDI(DDI_PLAYENHMETAFILERECORD, fWeCare, fOutput);

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPlayEnhMetaFileRecord, fOutput);
    return(fOutput);
}



//
// DrvPlayMetaFile()
//
BOOL WINAPI DrvPlayMetaFile
(
    HDC     hdcDst,
    HMETAFILE   hmf
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvPlayMetaFile);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_PLAYMETAFILE, hdcDst, OESTATE_SDA_DCB);
    
    fOutput = PlayMetaFile(hdcDst, hmf);

    OEAfterDDI(DDI_PLAYMETAFILE, fWeCare, fOutput);

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPlayMetaFile, fOutput);
    return(fOutput);
}



//
// DrvPlayMetaFileRecord()
//
void WINAPI DrvPlayMetaFileRecord
(
    HDC     hdcDst,
    LPHANDLETABLE   lpMFHandles,
    LPMETARECORD    lpMFRecord,
    UINT    cMFHandles
)
{
    BOOL    fWeCare;

    DebugEntry(DrvPlayMetaFileRecord);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_PLAYMETAFILERECORD, hdcDst, OESTATE_SDA_DCB);

    PlayMetaFileRecord(hdcDst, lpMFHandles, lpMFRecord, cMFHandles);

    OEAfterDDI(DDI_PLAYMETAFILERECORD, fWeCare, TRUE);

    OE_SHM_STOP_WRITING;

    DebugExitVOID(DrvPlayMetaFileRecord);
}



//
// DrvPolyBezier()
//
BOOL WINAPI DrvPolyBezier
(
    HDC     hdcDst,
    LPPOINT    aPoints,
    UINT    cPoints
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvPolyBezier);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_POLYBEZIER, hdcDst, 0);

    fOutput = PolyBezier(hdcDst, aPoints, cPoints);

    if (OEAfterDDI(DDI_POLYBEZIER, fWeCare, fOutput && (cPoints > 1)))
    {
        ASSERT(!IsBadReadPtr(aPoints, cPoints*sizeof(POINT)));

        OEAddPolyBezier(aPoints[0], aPoints+1, cPoints-1); 
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPolyBezier, fOutput);
    return(fOutput);
}



//
// DrvPolyBezierTo()
//
BOOL WINAPI DrvPolyBezierTo
(
    HDC     hdcDst,
    LPPOINT    aPoints,
    UINT    cPoints
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvPolyBezierTo);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_POLYBEZIERTO, hdcDst, OESTATE_CURPOS);

    fOutput = PolyBezierTo(hdcDst, aPoints, cPoints);

    if (OEAfterDDI(DDI_POLYBEZIERTO, fWeCare, fOutput && cPoints))
    {
        ASSERT(!IsBadReadPtr(aPoints, cPoints*sizeof(POINT)));
        ASSERT(g_oeState.uFlags & OESTATE_CURPOS);

        OEAddPolyBezier(g_oeState.ptCurPos, aPoints, cPoints);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPolyBezierTo, fOutput);
    return(fOutput);
}



//
// OEAddPolyBezier()
//
// Adds poly bezier order for both PolyBezier() and PolyBezierTo().
//
void OEAddPolyBezier
(
    POINT   ptStart,
    LPPOINT aPoints,
    UINT    cPoints
)
{
    UINT    iPoint;
    LPINT_ORDER pOrder;
    LPPOLYBEZIER_ORDER   pPolyBezier;

    DebugEntry(OEAddPolyBezier);

    OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_REGION);

    //
    // Calculate the bounds
    //
    g_oeState.rc.left = ptStart.x;
    g_oeState.rc.top  = ptStart.y;
    g_oeState.rc.right = ptStart.x;
    g_oeState.rc.bottom = ptStart.y;

    for (iPoint = 0; iPoint < cPoints; iPoint++)
    {
        g_oeState.rc.left = min(g_oeState.rc.left, aPoints[iPoint].x);
        g_oeState.rc.right = max(g_oeState.rc.right, aPoints[iPoint].x);
        g_oeState.rc.top = min(g_oeState.rc.top, aPoints[iPoint].y);
        g_oeState.rc.bottom = max(g_oeState.rc.bottom, aPoints[iPoint].y);
    }

    OEPolarityAdjust(&g_oeState.rc, 1);
    OEPenWidthAdjust(&g_oeState.rc, 1);
    OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

    //
    // OELRtoVirtual takes an exclusive rect and returns an inclusive one.
    // But we passed it an inclusive already rect, so we need to account
    // for that.
    //
    g_oeState.rc.right++;
    g_oeState.rc.bottom++;

    pOrder = NULL;

    // Account for starting point also
    if (OECheckOrder(ORD_POLYBEZIER, OECHECK_PEN | OECHECK_CLIPPING)    &&
        (cPoints < ORD_MAX_POLYBEZIER_POINTS))
    {
        pOrder = OA_DDAllocOrderMem(sizeof(POLYBEZIER_ORDER) -
            ((ORD_MAX_POLYBEZIER_POINTS - cPoints - 1) *
            sizeof(pPolyBezier->variablePoints.aPoints[0])), 0);
        if (!pOrder)
            DC_QUIT;

        pPolyBezier = (LPPOLYBEZIER_ORDER)pOrder->abOrderData;
        pPolyBezier->type = LOWORD(ORD_POLYBEZIER);

        //
        // Copy them into the order array
        //
        pPolyBezier->variablePoints.len =
            ((cPoints+1) * sizeof(pPolyBezier->variablePoints.aPoints[0]));

        pPolyBezier->variablePoints.aPoints[0].x = ptStart.x;
        pPolyBezier->variablePoints.aPoints[0].y = ptStart.y;
        hmemcpy(pPolyBezier->variablePoints.aPoints+1, aPoints,
                cPoints*sizeof(pPolyBezier->variablePoints.aPoints[0]));

        //
        // Convert points to virtual
        //
        // NOTE that this works because aPoints[] holds TSHR_POINT16s, which
        // are natively the same size as POINT structures.
        //
        OELPtoVirtual(g_oeState.hdc, (LPPOINT)pPolyBezier->variablePoints.aPoints,
            cPoints+1);

        OEConvertColor(g_oeState.lpdc->DrawMode.bkColorL,
            &pPolyBezier->BackColor, FALSE);
        OEConvertColor(g_oeState.lpdc->DrawMode.txColorL,
            &pPolyBezier->ForeColor, FALSE);
                
        pPolyBezier->BackMode   = g_oeState.lpdc->DrawMode.bkMode;
        pPolyBezier->ROP2       = g_oeState.lpdc->DrawMode.Rop2;

        pPolyBezier->PenStyle   = g_oeState.logPen.lopnStyle;
        pPolyBezier->PenWidth   = 1;
        OEConvertColor(g_oeState.logPen.lopnColor, &pPolyBezier->PenColor,
            FALSE);

        pOrder->OrderHeader.Common.fOrderFlags  = OF_SPOILABLE;

        OTRACE(("PolyBezier:  Order %08lx, Rect {%d, %d, %d, %d} with %d points",
            pOrder, g_oeState.rc.left, g_oeState.rc.top,
            g_oeState.rc.right, g_oeState.rc.bottom, cPoints+1));
        OEClipAndAddOrder(pOrder, NULL);
    }

DC_EXIT_POINT:
    if (!pOrder)
    {
        OTRACE(("PolyBezier:  Sending as screen data {%d, %d, %d, %d}",
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom));
        OEClipAndAddScreenData(&g_oeState.rc);
    }

    DebugExitVOID(OEAddPolyBezier);
}



//
// DrvPolygon()
//
BOOL WINAPI DrvPolygon
(
    HDC     hdcDst,
    LPPOINT    aPoints,
    int     cPoints
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    LPINT_ORDER pOrder;
    LPPOLYGON_ORDER pPolygon;
    int     iPoint;
    POINT   ptBrushOrg;

    DebugEntry(DrvPolygon);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_POLYGON, hdcDst, 0);

    fOutput = Polygon(hdcDst, aPoints, cPoints);

    if (OEAfterDDI(DDI_POLYGON, fWeCare, fOutput && (cPoints > 1)))
    {
        ASSERT(!IsBadReadPtr(aPoints, cPoints*sizeof(POINT)));

        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_BRUSH | OESTATE_REGION);

        //
        // Compute the bounds
        //
        g_oeState.rc.left = aPoints[0].x;
        g_oeState.rc.top = aPoints[0].y;
        g_oeState.rc.right = aPoints[0].x;
        g_oeState.rc.bottom = aPoints[0].y;

        for (iPoint = 1; iPoint < cPoints; iPoint++)
        {
            g_oeState.rc.left = min(g_oeState.rc.left, aPoints[iPoint].x);
            g_oeState.rc.top = min(g_oeState.rc.top, aPoints[iPoint].y);
            g_oeState.rc.right = max(g_oeState.rc.right, aPoints[iPoint].x);
            g_oeState.rc.bottom = max(g_oeState.rc.bottom, aPoints[iPoint].y);
        }

        OEPolarityAdjust(&g_oeState.rc, 1);
        OEPenWidthAdjust(&g_oeState.rc, 1);

        //
        // The rect is in inclusive coords already, OELRtoVirtual thinks
        // it's exclusive.  So we need to add one back on to the right
        // and bottom to end up with the real inclusive rect.
        //
        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);
        g_oeState.rc.right++;
        g_oeState.rc.bottom++;

        pOrder = NULL;

        if (OECheckOrder(ORD_POLYGON, OECHECK_PEN | OECHECK_BRUSH | OECHECK_CLIPPING) &&
            (cPoints <= ORD_MAX_POLYGON_POINTS))
        {
            pOrder = OA_DDAllocOrderMem(sizeof(POLYGON_ORDER) -
                ((ORD_MAX_POLYGON_POINTS - cPoints) *
                sizeof(pPolygon->variablePoints.aPoints[0])), 0);
            if (!pOrder)
                goto NoPolygonOrder;

            pPolygon = (LPPOLYGON_ORDER)pOrder->abOrderData;
            pPolygon->type = LOWORD(ORD_POLYGON);

            pPolygon->variablePoints.len =
                cPoints * sizeof(pPolygon->variablePoints.aPoints[0]);
            hmemcpy(pPolygon->variablePoints.aPoints, aPoints,
                pPolygon->variablePoints.len);

            //
            // Convert all the points to virtual
            //
            // NOTE that this works because aPoints[] hols TSHR_POINT16s,
            // which are natively the same size as POINT structures.
            //
            OELPtoVirtual(g_oeState.hdc, (LPPOINT)pPolygon->variablePoints.aPoints,
                cPoints);

            OEGetBrushInfo(&pPolygon->BackColor, &pPolygon->ForeColor,
                &pPolygon->BrushStyle, &pPolygon->BrushHatch,
                pPolygon->BrushExtra);

            GetBrushOrgEx(g_oeState.hdc, &ptBrushOrg);
            pPolygon->BrushOrgX = (BYTE)ptBrushOrg.x;
            pPolygon->BrushOrgY = (BYTE)ptBrushOrg.y;

            pPolygon->BackMode = g_oeState.lpdc->DrawMode.bkMode;
            pPolygon->ROP2 = g_oeState.lpdc->DrawMode.Rop2;

            //
            // Pen info
            //
            pPolygon->PenStyle = g_oeState.logPen.lopnStyle;
            pPolygon->PenWidth = 1;
            OEConvertColor(g_oeState.logPen.lopnColor, &pPolygon->PenColor,
                FALSE);
            pPolygon->FillMode = GetPolyFillMode(g_oeState.hdc);

            pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILABLE;
            
            OTRACE(("Polygon:  Order %08lx, Rect {%d, %d, %d, %d} with %d points",
                pOrder, g_oeState.rc.left, g_oeState.rc.top,
                g_oeState.rc.right, g_oeState.rc.bottom, cPoints));
            OEClipAndAddOrder(pOrder, NULL);

        }

NoPolygonOrder:
        if (!pOrder)
        {
            OTRACE(("Polygon:  Sending %d points as screen data {%d, %d, %d, %d}",
                cPoints, g_oeState.rc.left, g_oeState.rc.top,
                g_oeState.rc.right, g_oeState.rc.bottom));
            OEClipAndAddScreenData(&g_oeState.rc);
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPolygon, fOutput);
    return(fOutput);
}



//
// DrvPolyPolygon()
//
BOOL WINAPI DrvPolyPolygon
(
    HDC     hdcDst,
    LPPOINT    aPoints,
    LPINT   aPolygonPoints,
    int     cPolygons
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    int     iPolygon;
    int     iPoint;

    DebugEntry(DrvPolyPolygon);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_POLYPOLYGON, hdcDst, 0);

    fOutput = PolyPolygon(hdcDst, aPoints, aPolygonPoints, cPolygons);

    if (OEAfterDDI(DDI_POLYPOLYGON, fWeCare, fOutput && cPolygons))
    {
        ASSERT(!IsBadReadPtr(aPolygonPoints, cPolygons*sizeof(int)));

#ifdef DEBUG
        //
        // How many points total are there?
        //
        iPoint = 0;
        for (iPolygon = 0; iPolygon < cPolygons; iPolygon++)
        {
            iPoint += aPolygonPoints[iPolygon];
        }

        ASSERT(!IsBadReadPtr(aPoints, iPoint*sizeof(POINT)));
#endif

        //
        // Like LineTo, we need to juggle the coords for polarity.
        //
        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_REGION);

        for (iPolygon = 0; iPolygon < cPolygons; iPolygon++, aPolygonPoints++)
        {
            // 
            // No points for this polygon, nothing to do.
            //
            if (*aPolygonPoints < 2)
            {
                aPoints += *aPolygonPoints;
                continue;
            }

            g_oeState.rc.left = aPoints[0].x;
            g_oeState.rc.top  = aPoints[0].y;
            g_oeState.rc.right = aPoints[0].x;
            g_oeState.rc.bottom = aPoints[0].y;

            aPoints++;

            for (iPoint = 1; iPoint < *aPolygonPoints; iPoint++, aPoints++)
            {
                g_oeState.rc.left = min(g_oeState.rc.left, aPoints[0].x);
                g_oeState.rc.top = min(g_oeState.rc.top, aPoints[0].y);
                g_oeState.rc.right = max(g_oeState.rc.right, aPoints[0].x);
                g_oeState.rc.bottom = max(g_oeState.rc.bottom, aPoints[0].y);
            }

            OEPolarityAdjust(&g_oeState.rc, 1);
            OEPenWidthAdjust(&g_oeState.rc, 1);

            //
            // Our rectangle is already inclusive, and OELRtoVirtual() will
            // treat it like it's exclusive.  So after we return add one back
            // to the right & bottom to end up with the real inclusive
            // rectangle.
            //
            OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);
            g_oeState.rc.right++;
            g_oeState.rc.bottom++;

            OTRACE(("PolyPolygon:  Sending piece %d as screen data {%d, %d, %d, %d}",
                iPolygon, g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
            OEClipAndAddScreenData(&g_oeState.rc);
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPolyPolygon, fOutput);
    return(fOutput);
}



//
// PolyPolyline()
//
BOOL WINAPI DrvPolyPolyline
(
    DWORD   cPtTotal,
    HDC     hdcDst,
    LPPOINT    aPoints,
    LPINT   acPolylinePoints,
    int     cPolylines
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    UINT    cPoints;

    DebugEntry(DrvPolyPolyline);

    OE_SHM_START_WRITING;

    //
    // LAURABU NOTE:
    // This code is better than 2.0.  2.0 would simulate the actual GDI
    // call by repeated Polyline calls.  We accumulate orders the same way
    // that would have happened, but let GDI do the drawing, which is much
    // more metafile friendly, among other things.
    //
    fWeCare = OEBeforeDDI(DDI_POLYPOLYLINE, hdcDst, 0);

    fOutput = g_lpfnPolyPolyline(cPtTotal, hdcDst, aPoints, acPolylinePoints,
        cPolylines);

    if (OEAfterDDI(DDI_POLYPOLYLINE, fWeCare, fOutput && cPolylines))
    {
        ASSERT(!IsBadReadPtr(acPolylinePoints, cPolylines*sizeof(int)));
        ASSERT(!IsBadReadPtr(aPoints, (UINT)cPtTotal*sizeof(POINT)));

        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_REGION);

        while (cPolylines-- > 0)
        {
            cPoints = *(acPolylinePoints++);

            if (cPoints > 1)
            {
                OEAddPolyline(aPoints[0], aPoints+1, cPoints-1);
            }

            aPoints += cPoints;
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPolyPolyline, fOutput);
    return(fOutput);
}



//
// DrvRectangle()
//
BOOL WINAPI DrvRectangle
(
    HDC     hdcDst,
    int     xLeft,
    int     yTop,
    int     xRight,
    int     yBottom
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    RECT    rcAdjusted;
    LPINT_ORDER pOrder;
    LPRECTANGLE_ORDER   pRectangle;
    POINT   ptBrushOrg;
    LPRECT  pRect;
    int     sideWidth;

    DebugEntry(DrvRectangle);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_RECTANGLE, hdcDst, 0);

    fOutput = Rectangle(hdcDst, xLeft, yTop, xRight, yBottom);

    if (OEAfterDDI(DDI_RECTANGLE, fWeCare, fOutput && (xLeft != xRight) && (yTop != yBottom)))
    {
        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_BRUSH | OESTATE_REGION);

        g_oeState.rc.left   = xLeft;
        g_oeState.rc.top    = yTop;
        g_oeState.rc.right  = xRight;
        g_oeState.rc.bottom = yBottom;

        CopyRect(&rcAdjusted, &g_oeState.rc);

        if ((g_oeState.logPen.lopnStyle == PS_SOLID)    ||
            (g_oeState.logPen.lopnStyle == PS_INSIDEFRAME))
        {
            OEPenWidthAdjust(&rcAdjusted, 2);
        }

        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);
        OELRtoVirtual(g_oeState.hdc, &rcAdjusted, 1);

        rcAdjusted.right--;
        rcAdjusted.bottom--;

        pOrder = NULL;

        if (OECheckOrder(ORD_RECTANGLE, OECHECK_PEN | OECHECK_BRUSH | OECHECK_CLIPPING))
        {
            pOrder = OA_DDAllocOrderMem(sizeof(RECTANGLE_ORDER), 0);
            if (!pOrder)
                goto NoRectOrder;

            pRectangle = (LPRECTANGLE_ORDER)pOrder->abOrderData;
            pRectangle->type = LOWORD(ORD_RECTANGLE);

            pRectangle->nLeftRect   = g_oeState.rc.left;
            pRectangle->nTopRect    = g_oeState.rc.top;
            pRectangle->nRightRect  = g_oeState.rc.right;
            pRectangle->nBottomRect = g_oeState.rc.bottom;

            OEGetBrushInfo(&pRectangle->BackColor, &pRectangle->ForeColor,
                &pRectangle->BrushStyle, &pRectangle->BrushHatch,
                pRectangle->BrushExtra);

            GetBrushOrgEx(g_oeState.hdc, &ptBrushOrg);
            pRectangle->BrushOrgX   = (BYTE)ptBrushOrg.x;
            pRectangle->BrushOrgY   = (BYTE)ptBrushOrg.y;

            pRectangle->BackMode    = g_oeState.lpdc->DrawMode.bkMode;
            pRectangle->ROP2        = g_oeState.lpdc->DrawMode.Rop2;

            pRectangle->PenStyle    = g_oeState.logPen.lopnStyle;
            pRectangle->PenWidth    = 1;

            OEConvertColor(g_oeState.logPen.lopnColor, &pRectangle->PenColor,
                FALSE);

            pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILABLE;
            if ((g_oeState.logBrush.lbStyle == BS_SOLID) ||
                ((pRectangle->BackMode == OPAQUE) &&
                    (g_oeState.logBrush.lbStyle != BS_NULL)))
            {
                pOrder->OrderHeader.Common.fOrderFlags |= OF_SPOILER;
            }

            //
            // Since we only encode orders of width 1, the bounding rect
            // stuff is simple.
            //
            OTRACE(("Rectangle:  Order %08lx, pOrder, Rect {%d, %d, %d, %d}",
                pOrder, g_oeState.rc.left,
                g_oeState.rc.top, g_oeState.rc.right, g_oeState.rc.bottom));
            
            OEClipAndAddOrder(pOrder, NULL);
        }
NoRectOrder:
        if (!pOrder)
        {
            //
            // This is more complicated.  We accumulate screen data for
            // pens of different sizes.
            //

            //
            // If the interior is drawn, then we need to send all the screen
            // area enclosed by the rect.  Otherwise, we can just send the
            // four rectangles describing the border.
            //
            if (g_oeState.logBrush.lbStyle == BS_NULL)
            {
                pRect = NULL;

                //
                // Use the pen width to determine the width of each rect
                // to add as screen data
                //
                switch (g_oeState.logPen.lopnStyle)
                {
                    case PS_NULL:
                        // Nothing to do.
                        break;

                    case PS_SOLID:
                        //
                        // The difference between the adjusted and normal
                        // rects is half the pen width, so double this up
                        // to get the width of each piece to send.
                        //
                        pRect = &rcAdjusted;
                        sideWidth = 2*(g_oeState.rc.left - rcAdjusted.left)
                            - 1;
                        break;

                    case PS_INSIDEFRAME:
                        //
                        // The pen is contained entirely within the corner
                        // pts passed to this function.
                        //
                        pRect = &g_oeState.rc;
                        sideWidth = 2*(g_oeState.rc.left - rcAdjusted.left)
                            - 1;
                        break;

                    default:
                        //
                        // All other pens have width of 1 and are inside the
                        // frame.
                        //
                        pRect = &g_oeState.rc;
                        sideWidth = 0;
                        break;
                }

                if (pRect)
                {
                    RECT    rcT;

                    //
                    // Left
                    //
                    CopyRect(&rcT, pRect);
                    rcT.right = rcT.left + sideWidth;
                    rcT.bottom -= sideWidth + 1;

                    OTRACE(("Rectangle left:  Sending screen data {%d, %d, %d, %d}",
                        rcT.left, rcT.top, rcT.right, rcT.bottom));
                    OEClipAndAddScreenData(&rcT);

                    //
                    // Top
                    //
                    CopyRect(&rcT, pRect);
                    rcT.left += sideWidth + 1;
                    rcT.bottom = rcT.top + sideWidth;

                    OTRACE(("Rectangle top:  Sending screen data {%d, %d, %d, %d}",
                        rcT.left, rcT.top, rcT.right, rcT.bottom));
                    OEClipAndAddScreenData(&rcT);

                    //
                    // Right
                    //
                    CopyRect(&rcT, pRect);
                    rcT.left = rcT.right - sideWidth;
                    rcT.top  += sideWidth + 1;

                    OTRACE(("Rectangle right:  Sending screen data {%d, %d, %d, %d}",
                        rcT.left, rcT.top, rcT.right, rcT.bottom));
                    OEClipAndAddScreenData(&rcT);

                    //
                    // Bottom
                    //
                    CopyRect(&rcT, pRect);
                    rcT.right -= sideWidth + 1;
                    rcT.top = rcT.bottom - sideWidth;

                    OTRACE(("Rectangle bottom:  Sending screen data {%d, %d, %d, %d}",
                        rcT.left, rcT.top, rcT.right, rcT.bottom));
                    OEClipAndAddScreenData(&rcT);
                }
            }
            else
            {
                if (g_oeState.logPen.lopnStyle == PS_SOLID)
                    pRect = &rcAdjusted;
                else
                    pRect = &g_oeState.rc;

                OTRACE(("Rectangle:  Sending as screen data {%d, %d, %d, %d}",
                    pRect->left, pRect->top, pRect->right, pRect->bottom));
                OEClipAndAddScreenData(pRect);
            }
        }

    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvRectangle, fOutput);
    return(fOutput);
}



//
// DrvSetDIBitsToDevice()
//
int WINAPI DrvSetDIBitsToDevice
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    int     cxDst,
    int     cyDst,
    int     xSrc,
    int     ySrc,
    UINT    uStartScan,
    UINT    cScanLines,
    LPVOID  lpvBits,
    LPBITMAPINFO    lpbmi,
    UINT    fuColorUse
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvSetDIBitsToDevice);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_SETDIBITSTODEVICE, hdcDst, 0);

    fOutput = SetDIBitsToDevice(hdcDst, xDst, yDst, cxDst, cyDst,
        xSrc, ySrc, uStartScan, cScanLines, lpvBits, lpbmi, fuColorUse);

    if (OEAfterDDI(DDI_SETDIBITSTODEVICE, fWeCare, fOutput))
    {
        OEGetState(OESTATE_COORDS | OESTATE_REGION);

        g_oeState.rc.left   = xDst;
        g_oeState.rc.top    = yDst;
        OELPtoVirtual(g_oeState.hdc, (LPPOINT)&g_oeState.rc.left, 1);
        g_oeState.rc.right  = g_oeState.rc.left + cxDst;
        g_oeState.rc.bottom = g_oeState.rc.top  + cyDst;

        OTRACE(("SetDIBitsToDevice:  Sending as screen data {%d, %d, %d, %d}",
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom));
        OEClipAndAddScreenData(&g_oeState.rc);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvSetDIBitsToDevice, fOutput);
    return(fOutput);
}



//
// DrvSetPixel()
//
COLORREF WINAPI DrvSetPixel
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    COLORREF crPixel
)
{
    BOOL    fWeCare;
    COLORREF    rgbOld;

    DebugEntry(DrvSetPixel);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_SETPIXEL, hdcDst, 0);

    rgbOld = SetPixel(hdcDst, xDst, yDst, crPixel);
    
    if (OEAfterDDI(DDI_SETPIXEL, fWeCare, (rgbOld != (COLORREF)-1)))
    {
        OEGetState(OESTATE_COORDS | OESTATE_REGION);

        g_oeState.rc.left   = xDst;
        g_oeState.rc.top    = yDst;
        g_oeState.rc.right  = xDst;
        g_oeState.rc.bottom = yDst;
        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

        g_oeState.rc.right++;
        g_oeState.rc.bottom++;

        OTRACE(("SetPixel:  Sending as screen data {%d, %d, %d, %d}",
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom));
        OEClipAndAddScreenData(&g_oeState.rc);
    }

    OE_SHM_STOP_WRITING;

    DebugExitDWORD(DrvSetPxel, rgbOld);
    return(rgbOld);
}



//
// DrvStretchDIBits()
//
int WINAPI DrvStretchDIBits
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    int     cxDst,
    int     cyDst,
    int     xSrc,
    int     ySrc,
    int     cxSrc,
    int     cySrc,
    LPVOID  lpvBits,
    LPBITMAPINFO lpbmi,
    UINT    fuColorUse,
    DWORD   dwRop
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    BYTE    bRop;

    DebugEntry(DrvStretchDIBits);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_STRETCHDIBITS, hdcDst, 0);

    fOutput = StretchDIBits(hdcDst, xDst, yDst, cxDst, cyDst,
        xSrc, ySrc, cxSrc, cySrc, lpvBits, lpbmi, fuColorUse, dwRop);

    if (OEAfterDDI(DDI_STRETCHDIBITS, fWeCare, fOutput && cxDst && cyDst))
    {
        OEGetState(OESTATE_COORDS | OESTATE_BRUSH | OESTATE_REGION);

        g_oeState.rc.left   = xDst;
        g_oeState.rc.top    = yDst;
        g_oeState.rc.right  = xDst + cxDst;
        g_oeState.rc.bottom = yDst + cyDst;

        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

        //
        // If this is a PatBlt really, do that instead.
        //
        bRop = LOBYTE(HIWORD(dwRop));
        if (((bRop & 0x33) << 2) == (bRop & 0xCC))
        {
            OEAddBlt(dwRop);
            DC_QUIT;
        }

        //
        // Do tile bitblt order stuff...
        //

        OTRACE(("StretchDIBits:  Sending as screen data {%d, %d, %d, %d}",
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom));
        OEClipAndAddScreenData(&g_oeState.rc);
    }

DC_EXIT_POINT:
    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvStretchDIBits, fOutput);
    return(fOutput);
}



//
// DrvUpdateColors()
//
int WINAPI DrvUpdateColors
(
    HDC hdcDst
)
{
    BOOL    fWeCare;
    int     ret;

    DebugEntry(DrvUpdateColors);

    OE_SHM_START_WRITING;

    //
    // This doesn't reset the drawing bounds.  So we just assume the whole
    // DC changed.  And the return value is meaningless.  We can't assume
    // that zero means failure.
    //
    fWeCare = OEBeforeDDI(DDI_UPDATECOLORS, hdcDst, OESTATE_SDA_SCREEN);

    ret = UpdateColors(hdcDst);

    OEAfterDDI(DDI_UPDATECOLORS, fWeCare, TRUE);

    OE_SHM_STOP_WRITING;

    DebugExitDWORD(DrvUpdateColors, (DWORD)(UINT)ret);
    return(ret);
}



//
// SETTINGS/MODE FUNCTIONS
// For full screen dos boxes, resolution/color depth changes
//


//
// DrvGDIRealizePalette()
//
// The WM_PALETTE* messages in Win95 are unreliable.  So, like NM 2.0, we
// patch two GDI APIs instead and update a shared variable
//
DWORD WINAPI DrvGDIRealizePalette(HDC hdc)
{
    DWORD   dwRet;

    DebugEntry(DrvGDIRealizePalette);

    EnableFnPatch(&g_oeDDPatches[DDI_GDIREALIZEPALETTE], PATCH_DISABLE);
    dwRet = GDIRealizePalette(hdc);
    EnableFnPatch(&g_oeDDPatches[DDI_GDIREALIZEPALETTE], PATCH_ENABLE);

    ASSERT(g_asSharedMemory);
    g_asSharedMemory->pmPaletteChanged = TRUE;

    DebugExitDWORD(DrvGDIRealizePalette, dwRet);
    return(dwRet);
}



//
// DrvRealizeDefaultPalette()
//
// The WM_PALETTE* messages in Win95 are unreliable.  So, like NM 2.0, we
// patch two GDI APIs instead and update a shared variable
//
void WINAPI DrvRealizeDefaultPalette(HDC hdc)
{
    DebugEntry(DrvRealizeDefaultPalette);

    EnableFnPatch(&g_oeDDPatches[DDI_REALIZEDEFAULTPALETTE], PATCH_DISABLE);
    RealizeDefaultPalette(hdc);
    EnableFnPatch(&g_oeDDPatches[DDI_REALIZEDEFAULTPALETTE], PATCH_ENABLE);

    ASSERT(g_asSharedMemory);
    g_asSharedMemory->pmPaletteChanged = TRUE;

    DebugExitVOID(DrvRealizeDefaultPalette);
}


//
// This is called when a blue screen fault is coming up, or an app calls
// Disable() in USER.
//
UINT WINAPI DrvDeath
(
    HDC     hdc
)
{
    UINT    uResult;

    g_asSharedMemory->fullScreen = TRUE;

    EnableFnPatch(&g_oeDDPatches[DDI_DEATH], PATCH_DISABLE);
    uResult = Death(hdc);
    EnableFnPatch(&g_oeDDPatches[DDI_DEATH], PATCH_ENABLE);

    return(uResult);
}


//
// This is called when a blue screen fault is going away, or an app calls
// Enable() in USER.
//
UINT WINAPI DrvResurrection
(
    HDC     hdc,
    DWORD   dwParam1,
    DWORD   dwParam2,
    DWORD   dwParam3
)
{
    UINT    uResult;

    g_asSharedMemory->fullScreen = FALSE;

    EnableFnPatch(&g_oeDDPatches[DDI_RESURRECTION], PATCH_DISABLE);
    uResult = Resurrection(hdc, dwParam1, dwParam2, dwParam3);
    EnableFnPatch(&g_oeDDPatches[DDI_RESURRECTION], PATCH_ENABLE);

    return(uResult);
}


//
// This is called by a dosbox when going to or coming out of full screen
// mode.  DirectX calls it also.
//
LONG WINAPI DrvWinOldAppHackoMatic
(
    LONG    lFlags
)
{
    LONG    lResult;

    if (lFlags == WOAHACK_LOSINGDISPLAYFOCUS)
    {
        //
        // DOS box is going to full screen from windowed
        //
        g_asSharedMemory->fullScreen = TRUE;
    }
    else if (lFlags == WOAHACK_GAININGDISPLAYFOCUS)
    {
        //
        // DOS box is going from windowed to full screen
        //
        g_asSharedMemory->fullScreen = FALSE;
    }

    EnableFnPatch(&g_oeDDPatches[DDI_WINOLDAPPHACKOMATIC], PATCH_DISABLE);
    lResult = WinOldAppHackoMatic(lFlags);
    EnableFnPatch(&g_oeDDPatches[DDI_WINOLDAPPHACKOMATIC], PATCH_ENABLE);

    return(lResult);
}


//
// ChangeDisplaySettings()          WIN95
// ChangeDisplaySettingsEx()        MEMPHIS
//
// This is called in 3 circumstances:
//      * By the control to change your screen
//      * By the shell when warm-docking
//      * By 3rd party games to change the settings silently.
//
// Easiest thing to do is just to fail this completely.
//

LONG WINAPI DrvChangeDisplaySettings
(
    LPDEVMODE   lpDevMode,
    DWORD       flags
)
{
    return(DISP_CHANGE_FAILED);
}


LONG WINAPI DrvChangeDisplaySettingsEx
(
    LPCSTR      lpszDeviceName,
    LPDEVMODE   lpDevMode,
    HWND        hwnd,
    DWORD       flags,
    LPVOID      lParam
)
{
    return(DISP_CHANGE_FAILED);
}


//
// OBJECT FUNCTIONS
// For bitmaps (SPBs and cache) and brushes
//


//
// DrvCreateSpb()
//
// This watches for SPB bitmaps being created.
//
UINT WINAPI DrvCreateSpb
(
    HDC     hdcCompat,
    int     cxWidth,
    int     cyHeight
)
{
    HBITMAP hbmpRet;

    DebugEntry(DrvCreateSpb);

    EnableFnPatch(&g_oeDDPatches[DDI_CREATESPB], PATCH_DISABLE);
    hbmpRet = (HBITMAP)CreateSpb(hdcCompat, cxWidth, cyHeight);
    EnableFnPatch(&g_oeDDPatches[DDI_CREATESPB], PATCH_ENABLE);

    if (hbmpRet)
    {
        // 
        // Save in our "next SPB" bitmap list
        //
        g_ssiLastSpbBitmap = hbmpRet;
    }

    DebugExitDWORD(DrvCreateSpb, (DWORD)(UINT)hbmpRet);
    return((UINT)hbmpRet);
}



//
// DrvDeleteObject()
//
// This and DrvSysDeleteObject() watch for bitmaps being destroyed.
//
BOOL WINAPI DrvDeleteObject
(
    HGDIOBJ hobj
)
{
    BOOL    fReturn;
    int     gdiType;

    DebugEntry(DrvDeleteObject);

    gdiType = IsGDIObject(hobj);
    if (gdiType == GDIOBJ_BITMAP)
    {
        OE_SHM_START_WRITING;

        //
        // If SPB, toss it.  Else if cached bitmap, kill cache entry.
        //
        if ((HBITMAP)hobj == g_ssiLastSpbBitmap)
        {
            g_ssiLastSpbBitmap = NULL;
        }
        else if (!SSIDiscardBits((HBITMAP)hobj))
        {
        }

        OE_SHM_STOP_WRITING;
    }

    EnableFnPatch(&g_oeDDPatches[DDI_DELETEOBJECT], PATCH_DISABLE);
    fReturn = DeleteObject(hobj);
    EnableFnPatch(&g_oeDDPatches[DDI_DELETEOBJECT], PATCH_ENABLE);

    DebugExitBOOL(DrvDeleteObject, fReturn);
    return(fReturn);
}




//
// OE_RectIntersectsSDA()
// 
// Used by SSI and BLT orders
//
BOOL  OE_RectIntersectsSDA(LPRECT pRect)
{
    RECT  rectVD;
    BOOL  fIntersection = FALSE;
    UINT  i;

    DebugEntry(OE_RectIntersectsSDA);

    //
    // Copy the supplied rectangle, converting to inclusive Virtual
    // Desktop coords.
    //
    rectVD.left   = pRect->left;
    rectVD.top    = pRect->top;
    rectVD.right  = pRect->right - 1;
    rectVD.bottom = pRect->bottom - 1;

    //
    // Loop through each of the bounding rectangles checking for
    // an intersection with the supplied rectangle.
    //
    for (i = 0; i <= BA_NUM_RECTS; i++)
    {
        if ( (g_baBounds[i].InUse) &&
             (g_baBounds[i].Coord.left <= rectVD.right) &&
             (g_baBounds[i].Coord.top <= rectVD.bottom) &&
             (g_baBounds[i].Coord.right >= rectVD.left) &&
             (g_baBounds[i].Coord.bottom >= rectVD.top) )
        {
            OTRACE(("Rect {%d, %d, %d, %d} intersects SDA {%d, %d, %d, %d}",
                rectVD.left, rectVD.top, rectVD.right, rectVD.bottom,
                g_baBounds[i].Coord.left, g_baBounds[i].Coord.top,
                g_baBounds[i].Coord.right, g_baBounds[i].Coord.bottom));
            fIntersection = TRUE;
            break;
        }
    }

    DebugExitBOOL(OE_RectIntersectsSDA, fIntersection);
    return(fIntersection);
}



//
// MyStrcmp()
// Real strcmp() algorithm.
//
int MyStrcmp(LPCSTR lp1, LPCSTR lp2)
{
    ASSERT(lp1);
    ASSERT(lp2);

    while (*lp1 == *lp2)
    {
        //
        // The two strings are identical
        //
        if (!*lp1)
            return(0);

        lp1++;
        lp2++;
    }

    //
    // String1 is numerically > String2, or < 
    //
    return((*lp1 > *lp2) ? 1 : -1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\as16\shm.c ===
//
// SHM.C
// Shared Memory Manager
//
// Copyright(c) Microsoft 1997-
//

#include <as16.h>




//
// SHM_StartAccess
//
LPVOID  SHM_StartAccess(int block)
{
    LPBUFFER_CONTROL    pControl;
    LPVOID              pMemBlock;

    DebugEntry(SHM_StartAccess);

    //
    // Test for shared memory present
    //
    ASSERT(g_asSharedMemory != NULL);

    //
    // Determine which data block we are handling...
    //
    switch (block)
    {
        case SHM_OA_DATA:
            pControl = &g_asSharedMemory->displayToCore;
            break;

        case SHM_OA_FAST:
        case SHM_BA_FAST:
        case SHM_CM_FAST:
            pControl = &g_asSharedMemory->fastPath;
            break;

        default:
            ERROR_OUT(("Unknown type %d", block));
            break;
    }

    //
    // Mark the double-buffer as busy.
    //
    pControl->busyFlag = TRUE;

    //
    // Set up the current buffer pointer if this is the first access to the
    // shared memory.
    //
    pControl->indexCount++;
    if (pControl->indexCount == 1)
    {
        //
        // Set up the 'in use' buffer pointer
        //
        pControl->currentBuffer = pControl->newBuffer;

        //
        // Mark the buffer as busy so that the Share Core knows where we
        // are.
        //
        pControl->bufferBusy[pControl->currentBuffer] = 1;
    }

    //
    // Get the pointer to the block to return
    //
    switch (block)
    {
        case SHM_OA_DATA:
            pMemBlock = g_poaData[pControl->currentBuffer];
            break;

        case SHM_OA_FAST:
            pMemBlock = &(g_asSharedMemory->oaFast[pControl->currentBuffer]);
            break;

        case SHM_BA_FAST:
            pMemBlock = &(g_asSharedMemory->baFast[pControl->currentBuffer]);
            break;

        case SHM_CM_FAST:
            pMemBlock = &(g_asSharedMemory->cmFast[pControl->currentBuffer]);
            break;

        default:
            ERROR_OUT(("Unknown type %d", block));
            break;
    }

    DebugExitDWORD(SHM_StartAccess, (DWORD)pMemBlock);
    return(pMemBlock);
}


//
// SHM_StopAccess
//
void  SHM_StopAccess(int block)
{
    LPBUFFER_CONTROL pControl;

    DebugEntry(SHM_StopAccess);

    ASSERT(g_asSharedMemory != NULL);

    //
    // Determine which data block we are handling...
    //
    switch (block)
    {
        case SHM_OA_DATA:
            pControl = &g_asSharedMemory->displayToCore;
            break;

        case SHM_OA_FAST:
        case SHM_BA_FAST:
        case SHM_CM_FAST:
            pControl = &g_asSharedMemory->fastPath;
            break;

        default:
            ERROR_OUT(("Unknown type %d", block));
            break;
    }

    //
    // Decrement usage count - if we have finally finished with the memory,
    // clear the busy flags so that the Share Core knows it won't tread on
    // the display driver's toes.
    //
    pControl->indexCount--;
    if (pControl->indexCount == 0)
    {
        BOOL    fPulseLock;

        //
        // If this is the order heap, and it is more than half full, 
        // strobe the win16lock so the core has a chance to run and pick up
        // the pending orders.  This will NOT cause interthread sends to
        // get received on this guy.
        //
        fPulseLock = FALSE;
        if (block == SHM_OA_DATA)
        {
            LPOA_SHARED_DATA pMemBlock = g_poaData[pControl->currentBuffer];

            ASSERT(pMemBlock);

            if (pMemBlock->totalOrderBytes >=
                ((g_oaFlow == OAFLOW_FAST ? OA_FAST_HEAP : OA_SLOW_HEAP) / 2))
            {
                fPulseLock = TRUE;
                TRACE_OUT(("Pulsing Win16lock since order heap size %08ld is getting full",
                    pMemBlock->totalOrderBytes));
            }
        }

        pControl->bufferBusy[pControl->currentBuffer] = 0;

        pControl->busyFlag = 0;

        if (fPulseLock)
        {
            _LeaveWin16Lock();
            _EnterWin16Lock();
            
            TRACE_OUT(("Done pulsing Win16lock to flush order heap"));
        }
    }

    DebugExitVOID(SHM_StopAccess);
}


#ifdef _DEBUG
//
// SHM_CheckPointer - see shm.h
//
void  SHM_CheckPointer(LPVOID ptr)
{
    DebugEntry(SHMCheckPointer);

    //
    // Is it even accessible?
    //
    ASSERT(!IsBadWritePtr(ptr, 4));

    //
    // Is it in the proper range?  NOTE--our shared memory is not one
    // contiguous block.  Therefore we need to determine which chunk it
    // is in.  Since each chunk already has a limit built in, we just
    // need to make sure the selector is cool.
    //

    ASSERT(g_asSharedMemory);
    ASSERT(g_poaData[0]);
    ASSERT(g_poaData[1]);

    if ((SELECTOROF(ptr) != SELECTOROF(g_asSharedMemory)) &&
        (SELECTOROF(ptr) != SELECTOROF(g_poaData[0])) &&
        (SELECTOROF(ptr) != SELECTOROF(g_poaData[1])))
    {
        ERROR_OUT(("Pointer not in any shared memory block"));
    }

    DebugExitVOID(SHM_CheckPointer);
}
#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\as16\makefile.inc ===
#############################################################################
#
#   MAKEFILE.INC
#
#   Common rules for the Win95-16 groupware binaries (mnm*.*)
#
#############################################################################

.SUFFIXES : .asm .thk .rc .c .cpp .lib .exp .typ


C_TOTAL = $(C_FLAGS) -I$(INCLUDES:;= -I)
MASM_TOTAL = $(MASM_FLAGS) -I$(INCLUDES:;= -I)


{}.c{$(_OBJ_DIR)\$(TARGET_DIRECTORY)\}.obj:
    @type <<$(ECHO_RSP)
$(C_NAME) $(MAKEDIR)\$(<F)
$(C_TOTAL)
<<NOKEEP
    @$(C_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(<F)
$(C_TOTAL: =
)
<<NOKEEP



{}.asm{$(_OBJ_DIR)\$(TARGET_DIRECTORY)\}.obj:
    @type <<$(ECHO_RSP)
$(MASM_NAME) $(MAKEDIR)\$(<F)
$(MASM_TOTAL)
<<NOKEEP
    @$(MASM_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(<F)
$(MASM_TOTAL: =
)
<<NOKEEP


# This is kind of whacky
{$(AS_ROOT)\thk\}.thk{}.asm:
    $(THUNK_NAME) -t thk -o $(O)\$@ $?


RC_TOTAL = -r $(RC_FLAGS) -I$(RC_INCLUDES:;= -I)

$(_OBJ_DIR)\$(TARGET_DIRECTORY)\$(TARGETNAME).res : $(TARGETNAME).rc
    $(RC_NAME) $(RC_TOTAL) -fo $@ $(TARGETNAME).rc


$(DYNLINK_LIB) $(DYNLINK_LIB:.lib=.exp): $(DLLDEF) $(LIBRARY_OBJS)
    $(IMPLIB_NAME) $(IMPLIB_FLAGS) $(DYNLINK_LIB) $(DLLDEF)
    $(LIBEXTRA_CMD)


!if "$(TARGETTYPE)" != "DYNLINK" || "$(MAKEDLL)" != ""

$(TARGET): $(OBJECTS) $(LINKLIBS) $(CRTLIBS) $(MACHINE_TARGETLIBS)
    @type <<$(ECHO_RSP)
$(LINK_NAME)
$(LINK_FLAGS)
$(OBJECTS: =
)
$(LINKLIBS: =
)
$(TARGETLIBS: =
)
<<NOKEEP
    @$(LINK_NAME) @<<$(CL_RSP)
$(LINK_FLAGS) +
$(OBJECTS: =+^
),
$(TARGET),
$(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).map,
$(LINKLIBS) +
$(TARGETLIBS: =+^
),
$(DLLDEF)
<<NOKEEP
    $(RC_NAME) $(RES_FLAGS) $(_OBJ_DIR)\$(TARGET_DIRECTORY)\$(TARGETNAME).res $(TARGET)
    $(SPLITSYM_CMD)
    $(TARGETCOPY_CMD)
    $(MAPSYM_CMD)
    $(MAPCOPY_CMD)
    $(SYMCOPY_CMD)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\as16\ssi.c ===
//
// SSI.C
// Save Screenbits Interceptor
//
// Copyright(c) Microsoft 1997-
//

#include <as16.h>


//
// GENERAL COMMENTS
//
// We patch the display driver's onboard bitmap DDI call if it exists.  This
// doesn't exist on newer displays, but we need to fail it on older ones.
// We won't see drawing that happens via calls to it otherwise.
//
// NM 2.0 used to grovel in USER's dataseg to find the variable address of
// the onboard bitmap routine and fill in its own, whether there was one or
// not.  Then it used to return TRUE always for saves.  Since USER '95 checked
// for a non-zero address to decide if onboard capabilities were present,
// this sort of worked.  Except of course that NM 2.0 needed special case
// code for all the flavors of Win95.
//
// With multiple monitor support, there is no single savebits proc address
// anymore.  Plus, we're tired of having to alter our code with every
// change in the OS.  Our new scheme works based off blts to/from a memory
// bitmap owned by USER.  Since we already spy on bitmaps for the SBC
// it doesn't really add overhead to do it this way.
//
// When USER is saving bits
//      (1) It creates the SPB bitmap via CreateSpb() (GDI calls it
//          CreateUserDiscardableBitmap()),
//          the only time it calls this routine.  If the bits get discarded,
//          the BitBlt back from this bitmap will fail, in which case USER
//          will repaint the affected area.
//      (2) It does a BitBlt from the screen into this bitmap, after making
//          it owned by g_hModUser16.  This bitmap is byte-pixel-aligned
//          horizontally, so it may be a bit wider than the window about to
//          be shown there.
//      (3) This happens just before a CS_SAVEBITS window is shown in that
//          area.  The window gets a private WS_HASSPB style bit set on it.
//      (4) After creating the SPB bitmap, USER walks through the windows
//          behind where the window is going to be in the z-order and subtracts
//          pending updage regions from the "OK" region of the SPB.  This
//          may result in discarding the SPB right away.
//          
// When USER is discarding saved bits
//      (1) It deletes the bitmap it created when saving
//
// When USER is restoring saved bits
//      (1) It may decide to discard if there's not much saved by restoring
//      (2) It will temporarily select in a visrgn for the screen that is 
//          only the valid part of the SPB
//      (3) It will blt from a memory DC with the SPB bitmap selected in
//          to the screen, again byte-aligned pixelwise horizontally.
//      (4) It will return a region to be invalidated and repainted via
//          normal methods (the complement of the valid blt visrgn)
//
// We have to be able to support nested savebits.  We do this via a 
// stack-like bitmap cache.  New save requests get put at the front.
//  



//
// SSI_DDProcessRequest()
// Handles SSI escapes
//
BOOL    SSI_DDProcessRequest
(
    UINT                fnEscape,
    LPOSI_ESCAPE_HEADER pRequest,
    DWORD               cbRequest
)
{
    BOOL                rc;

    DebugEntry(SSI_DDProcessRequest);

    switch (fnEscape)
    {
        case SSI_ESC_RESET_LEVEL:
        {
            ASSERT(cbRequest == sizeof(OSI_ESCAPE_HEADER));

            SSIResetSaveScreenBitmap();
            rc = TRUE;
        }
        break;

        case SSI_ESC_NEW_CAPABILITIES:
        {
            ASSERT(cbRequest == sizeof(SSI_NEW_CAPABILITIES));

            SSISetNewCapabilities((LPSSI_NEW_CAPABILITIES)pRequest);
            rc = TRUE;
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognized SSI_ escape"));
            rc = FALSE;
        }
        break;
    }

    DebugExitBOOL(SSI_DDProcessRequest, rc);
    return(rc);
}


//
// SSI_DDInit()
//
BOOL SSI_DDInit(void)
{
    BOOL    rc = TRUE;

    DebugEntry(SSI_DDInit);

    //
    // Patch the display driver's onboard SaveBits routine, if there is one
    //
    if (SELECTOROF(g_lpfnSaveBits))
    {
        if (!CreateFnPatch(g_lpfnSaveBits, DrvSaveBits, &g_ssiSaveBitsPatch, 0))
        {
            ERROR_OUT(("Unable to patch savebits routine"));
            rc = FALSE;
        }
    }

    DebugExitBOOL(SSI_DDInit, rc);
    return(rc);
}



//
// SSI_DDTerm()
//
void SSI_DDTerm(void)
{
    DebugEntry(SSI_DDTerm);

    if (SELECTOROF(g_lpfnSaveBits))
    {
        DestroyFnPatch(&g_ssiSaveBitsPatch);
    }

    DebugExitVOID(SSI_DDTerm);
}



//
// SSI_DDViewing()
//
void SSI_DDViewing(BOOL fViewers)
{
    DebugEntry(SSI_DDViewing);

    //
    // Activate our SaveBits patch if we have one
    //
    if (SELECTOROF(g_lpfnSaveBits))
    {
        EnableFnPatch(&g_ssiSaveBitsPatch, (fViewers ? PATCH_ACTIVATE :
            PATCH_DEACTIVATE));
    }

    //
    // Reset our SSI stack
    //
    SSIResetSaveScreenBitmap();

    DebugExitVOID(SSI_DDViewing);
}



//
// DrvSaveBits()
//
// Since we have to have code to spy on USER spb bitmaps, it doesn't make
// sense to have twice the code.  So we simply return FALSE here.  This 
// also avoids the "enable the patch after a bitmap was saved via a call
// to the driver so on the restore we're confused" problem.  The worst that
// will happen now is that USER will blt from a bitmap we've never seen
// to the screen, we'll catch the drawing, and send it over the wire as
// screen update (not cached!).  The next full save/restore will use an
// order instead.
//
BOOL WINAPI DrvSaveBits
(
    LPRECT  lpRect,
    UINT    uCmd
)
{
    return(FALSE);
}


//
// NOTE:
// ssiSBSaveLevel is the index of the NEXT FREE SPB SLOT
//


//
// FUNCTION: SSIResetSaveScreenBitmap.
//
// DESCRIPTION:
//
// Resets the SaveScreenBitmap state.
//
// PARAMETERS: None.
//
// RETURNS: Nothing.
//
//
void SSIResetSaveScreenBitmap(void)
{
    DebugEntry(SSIResetSaveScreenBitmap);

    //
    // Discard all currently saved bits
    //
    g_ssiLocalSSBState.saveLevel = 0;

    //
    // Reset the # of pels saved
    //
    g_ssiRemoteSSBState.pelsSaved = 0;

    DebugExitVOID(SSIResetSaveScreenBitmap);
}



//
// FUNCTION: SSISendSaveBitmapOrder
//
// DESCRIPTION:
//
// Attempts to send a SaveBitmap order matching the supplied parameters.
//
//
// PARAMETERS:
//
// lpRect - pointer to the rectangle coords (EXCLUSIVE screen coords)
//
// wCommand - SaveScreenBitmap command (ONBOARD_SAVE, ONBOARD_RESTORE,
// SSB_DISCARDBITS)
//
//
// RETURNS:
//
// TRUE if order successfully sent FALSE if order not sent
//
//
BOOL SSISendSaveBitmapOrder
(
    LPRECT  lpRect,
    UINT    wCommand
)
{
    DWORD               cRemotePelsRequired;
    LPSAVEBITMAP_ORDER  pSaveBitmapOrder;
    LPINT_ORDER         pOrder;
    BOOL                rc = FALSE;

    DebugEntry(SSISendSaveBitmapOrder);

    //
    // If the SaveBitmap order is not supported then return FALSE
    // immediately.
    //
    if (!OE_SendAsOrder(ORD_SAVEBITMAP))
    {
        TRACE_OUT(( "SaveBmp not supported"));
        DC_QUIT;
    }

    switch (wCommand)
    {
        case ONBOARD_DISCARD:
            //
            // We don't transmit DISCARD orders, there's no need since
            // saves/restores are paired.
            //
            g_ssiRemoteSSBState.pelsSaved -=
                CURRENT_LOCAL_SSB_STATE.remotePelsRequired;
            rc = TRUE;
            DC_QUIT;

        case ONBOARD_SAVE:
            //
            // Calculate the number of pels required in the remote Save
            // Bitmap to handle this rectangle.
            //
            cRemotePelsRequired = SSIRemotePelsRequired(lpRect);

            //
            // If there aren't enough pels in the remote Save Bitmap to
            // handle this rectangle then return immediately.
            //
            if ((g_ssiRemoteSSBState.pelsSaved + cRemotePelsRequired) >
                                                            g_ssiSaveBitmapSize)
            {
                TRACE_OUT(( "no space for %lu pels", cRemotePelsRequired));
                DC_QUIT;
            }

            //
            // Allocate memory for the order.
            //
            pOrder = OA_DDAllocOrderMem(sizeof(SAVEBITMAP_ORDER), 0);
            if (!pOrder)
                DC_QUIT;

            //
            // Store the drawing order data.
            //
            pSaveBitmapOrder = (LPSAVEBITMAP_ORDER)pOrder->abOrderData;

            pSaveBitmapOrder->type = LOWORD(ORD_SAVEBITMAP);
            pSaveBitmapOrder->Operation = SV_SAVEBITS;

            //
            // SAVEBITS is a BLOCKER order i.e. it prevents any earlier
            // orders from being spoilt by subsequent orders or Screen
            // Data.
            //
            pOrder->OrderHeader.Common.fOrderFlags = OF_BLOCKER;

            //
            // Copy the rect, converting to inclusive Virtual Desktop
            // coords.
            //
            pSaveBitmapOrder->nLeftRect = lpRect->left;
            pSaveBitmapOrder->nTopRect  = lpRect->top;
            pSaveBitmapOrder->nRightRect = lpRect->right - 1;
            pSaveBitmapOrder->nBottomRect = lpRect->bottom - 1;

            pSaveBitmapOrder->SavedBitmapPosition = g_ssiRemoteSSBState.pelsSaved;

            //
            // Store the relevant details in the current entry of the
            // local SSB structure.
            //
            CURRENT_LOCAL_SSB_STATE.remoteSavedPosition =
                                        pSaveBitmapOrder->SavedBitmapPosition;

            CURRENT_LOCAL_SSB_STATE.remotePelsRequired = cRemotePelsRequired;

            //
            // Update the count of remote pels saved.
            //
            g_ssiRemoteSSBState.pelsSaved += cRemotePelsRequired;

            //
            // The operation rectangle is NULL.
            //
            pOrder->OrderHeader.Common.rcsDst.left   = 1;
            pOrder->OrderHeader.Common.rcsDst.right  = 0;
            pOrder->OrderHeader.Common.rcsDst.top    = 1;
            pOrder->OrderHeader.Common.rcsDst.bottom = 0;

            break;

        case ONBOARD_RESTORE:
            //
            // Update the remote pel count first. Even if we fail to send
            // the order we want to free up the remote pels.
            //
            g_ssiRemoteSSBState.pelsSaved -=
                                   CURRENT_LOCAL_SSB_STATE.remotePelsRequired;

            //
            // Allocate memory for the order.
            //
            pOrder = OA_DDAllocOrderMem(sizeof(SAVEBITMAP_ORDER), 0);
            if (!pOrder)
                DC_QUIT;

            //
            // Store the drawing order data.
            //
            pSaveBitmapOrder = (LPSAVEBITMAP_ORDER)pOrder->abOrderData;

            pSaveBitmapOrder->type = LOWORD(ORD_SAVEBITMAP);
            pSaveBitmapOrder->Operation = SV_RESTOREBITS;

            //
            // The order can spoil others (it is opaque).
            // It is not SPOILABLE because we want to keep the remote
            // save level in a consistent state.
            //
            pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILER;

            //
            // Copy the rect, converting to inclusive Virtual Desktop
            // coords.
            //
            pSaveBitmapOrder->nLeftRect = lpRect->left;
            pSaveBitmapOrder->nTopRect  = lpRect->top;
            pSaveBitmapOrder->nRightRect = lpRect->right - 1;
            pSaveBitmapOrder->nBottomRect = lpRect->bottom - 1;

            pSaveBitmapOrder->SavedBitmapPosition =
                          CURRENT_LOCAL_SSB_STATE.remoteSavedPosition;


            //
            // The operation rectangle is also the bounding rectangle of
            // the order.
            //
            pOrder->OrderHeader.Common.rcsDst.left =
                                       pSaveBitmapOrder->nLeftRect;
            pOrder->OrderHeader.Common.rcsDst.right =
                                       pSaveBitmapOrder->nRightRect;
            pOrder->OrderHeader.Common.rcsDst.top =
                                       pSaveBitmapOrder->nTopRect;
            pOrder->OrderHeader.Common.rcsDst.bottom =
                                       pSaveBitmapOrder->nBottomRect;
            break;

        default:
            ERROR_OUT(( "Unexpected wCommand(%d)", wCommand));
            break;
    }

    OTRACE(( "SaveBitmap op %d pos %ld rect {%d %d %d %d}",
        pSaveBitmapOrder->Operation, pSaveBitmapOrder->SavedBitmapPosition,
        pSaveBitmapOrder->nLeftRect, pSaveBitmapOrder->nTopRect,
        pSaveBitmapOrder->nRightRect, pSaveBitmapOrder->nBottomRect ));

    //
    // Add the order to the order list.
    // IT IS NEVER CLIPPED.
    //
    OA_DDAddOrder(pOrder, NULL);
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SSISendSaveBitmapOrder, rc);
    return(rc);
}



//
// SSISaveBits()
//
// This attemps to save the SPB into our stack.  If we have no more room,
// no big deal.  We won't find it on a bitblt back to the screen, and that
// info will go as screen data.
//
// The rectangle is EXCLUSIVE screen coords.
//
void SSISaveBits
(
    HBITMAP hbmpSpb,
    LPRECT  lpRect
)
{
    DebugEntry(SSISaveBits);

    //
    // We should never have unbalanced save/restore operations
    //
    ASSERT(g_ssiLocalSSBState.saveLevel >= 0);

    //
    // Are we out of space?
    //
    if (g_ssiLocalSSBState.saveLevel >= SSB_MAX_SAVE_LEVEL)
    {
        TRACE_OUT(("SaveLevel(%d) exceeds maximum", g_ssiLocalSSBState.saveLevel));
        DC_QUIT;
    }

    //
    // If the rectangle to be saved intersects the current SDA, then we will
    // have to force a repaint on the restore.  This is because orders are
    // always sent before Screen Data.
    //
    // Otherwise mark the bits as saved.
    //
    if (OE_RectIntersectsSDA(lpRect))
    {
        CURRENT_LOCAL_SSB_STATE.saveType = ST_FAILED_TO_SAVE;
    }
    else
    {
        CURRENT_LOCAL_SSB_STATE.saveType = ST_SAVED_BY_BMP_SIMULATION;
    }

    //
    // Store the bitmap and associated screen rectangle
    //
    CURRENT_LOCAL_SSB_STATE.hbmpSave = hbmpSpb;
    CopyRect(&CURRENT_LOCAL_SSB_STATE.rect, lpRect);

    //
    // If successfully saved, try to accumulate a SaveBits order
    //
    if (CURRENT_LOCAL_SSB_STATE.saveType != ST_FAILED_TO_SAVE)
    {
        CURRENT_LOCAL_SSB_STATE.fSavedRemotely =
            SSISendSaveBitmapOrder(lpRect, ONBOARD_SAVE);
    }
    else
    {
        //
        // We didn't manage to save it.  No point in trying to save the
        // bitmap remotely.
        //
        TRACE_OUT(( "Keep track of failed save for restore later"));
        CURRENT_LOCAL_SSB_STATE.fSavedRemotely = FALSE;
    }

    //
    // Update the save level
    // NOTE this now points to the NEXT free slot
    //
    g_ssiLocalSSBState.saveLevel++;

DC_EXIT_POINT:
    DebugExitVOID(SSISaveBits);
}



//
// SSIFindSlotAndDiscardAbove()
//
// This starts at the topmost valid entry on the SPB stack and works
// backwards.  NOTE that saveLevel is the NEXT valid entry.
//
BOOL SSIFindSlotAndDiscardAbove(HBITMAP hbmpSpb)
{
    int   i;
    int   iNewSaveLevel;
    BOOL  rc = FALSE;

    DebugEntry(SSIFindSlotAndDiscardAbove);

    //
    // Look for this SPB.  If we find it, then discard the entries after
    // it in our stack.
    //
    iNewSaveLevel = g_ssiLocalSSBState.saveLevel;

    for (i = 0; i < g_ssiLocalSSBState.saveLevel; i++)
    {
        if (rc)
        {
            //
            // We found this SPB, so we are discarding all entries after
            // it in the stack.  Subtract the saved pixels count for this
            // dude.
            //
            g_ssiRemoteSSBState.pelsSaved -=
                g_ssiLocalSSBState.saveState[i].remotePelsRequired;
        }
        else if (g_ssiLocalSSBState.saveState[i].hbmpSave == hbmpSpb)
        {
            //
            // Found the one we were looking for
            //
            OTRACE(( "Found SPB %04x at slot %d", hbmpSpb, i));

            iNewSaveLevel = i;
            rc = TRUE;
        }
    }

    g_ssiLocalSSBState.saveLevel = iNewSaveLevel;

    DebugExitBOOL(SSIFindSlotAndDiscardAbove, rc);
    return(rc);
}



//
// SSIRestoreBits()
//
// Called when a BitBlt happens to screen from memory.  We try to find the
// memory bitmap in our SPB stack.  If we can't, we return FALSE, and the OE
// code will save away a screen painting order.
//
// If we find it, we save a small SPB restore order instead.
//
BOOL SSIRestoreBits
(
    HBITMAP hbmpSpb
)
{
    BOOL    rc = FALSE;

    DebugEntry(SSIRestoreBits);

    ASSERT(g_ssiLocalSSBState.saveLevel >= 0);

    //
    // Can we find the SPB?
    //
    if (SSIFindSlotAndDiscardAbove(hbmpSpb))
    {
        //
        // saveLevel is the index of our SPB.
        //
        if (CURRENT_LOCAL_SSB_STATE.fSavedRemotely)
        {
            //
            // The bits were saved remotely, so send and order.
            //
            rc = SSISendSaveBitmapOrder(&CURRENT_LOCAL_SSB_STATE.rect,
                ONBOARD_RESTORE);
        }
        else
        {
            //
            // We failed to save the bitmap remotely originally, so now
            // we need to return FALSE so that BitBlt() will accumulate
            // screen data in the area.
            //
            TRACE_OUT(( "No remote save, force repaint"));
        }

        if (g_ssiLocalSSBState.saveLevel == 0)
        {
            g_ssiRemoteSSBState.pelsSaved = 0;
        }
    }

    DebugExitBOOL(SSIRestoreBits, rc);
    return(rc);
}



//
// SSIDiscardBits()
//
// This discards the saved SPB if we have it in our stack.
// NOTE that SSIRestoreBits() also discards the bitmap.
//
// We return TRUE if we found the bitmap.
//
BOOL SSIDiscardBits(HBITMAP hbmpSpb)
{
    BOOL    rc;

    DebugEntry(SSIDiscardBits);

    //
    // Search for the corresponding save order on our stack.
    //
    if (rc = SSIFindSlotAndDiscardAbove(hbmpSpb))
    {
        //
        // The save level is now the index to this entry.  Since we are
        // about to free it, this will be the place the next SAVE goes 
        // into.
        //

        //
        // If the bits were saved remotely, then send a DISCARD order
        //
        if (CURRENT_LOCAL_SSB_STATE.fSavedRemotely)
        {
            //
            // NOTE that SSISendSaveBitmapOrder() for DISCARD doesn't have
            // a side effect, we can just pass in the address of the rect
            // of the SPB we stored.
            //
            if (!SSISendSaveBitmapOrder(&CURRENT_LOCAL_SSB_STATE.rect, ONBOARD_DISCARD))
            {
                TRACE_OUT(("Failed to send DISCARDBITS"));
            }
        }

        if (g_ssiLocalSSBState.saveLevel == 0)
        {
            g_ssiRemoteSSBState.pelsSaved = 0;
        }
    }

    DebugExitBOOL(SSIDiscardBits, rc);
    return(rc);
}



//
// FUNCTION: SSIRemotePelsRequired
//
// DESCRIPTION:
//
// Returns the number of remote pels required to store the supplied
// rectangle, taking account of the Save Bitmap granularity.
//
// PARAMETERS:
//
// lpRect - pointer to rectangle position in EXCLUSIVE screen coordinates.
//
// RETURNS: Number of remote pels required.
//
//
DWORD SSIRemotePelsRequired(LPRECT lpRect)
{
    UINT    rectWidth;
    UINT    rectHeight;
    UINT    xGranularity;
    UINT    yGranularity;
    DWORD   rc;

    DebugEntry(SSIRemotePelsRequired);

    ASSERT(lpRect);

    //
    // Calculate the supplied rectangle size (it is in EXCLUSIVE coords).
    //
    rectWidth  = (DWORD)(lpRect->right  - lpRect->left);
    rectHeight = (DWORD)(lpRect->bottom - lpRect->top);

    xGranularity = g_ssiLocalSSBState.xGranularity;
    yGranularity = g_ssiLocalSSBState.yGranularity;

    rc = (DWORD)((rectWidth + (xGranularity-1))/xGranularity * xGranularity) *
         (DWORD)((rectHeight + (yGranularity-1))/yGranularity * yGranularity);

    //
    // Return the pels required in the remote SaveBits bitmap to handle
    // this rectangle, taking account of its granularity.
    //
    DebugExitDWORD(SSIRemotePelsRequired, rc);
    return(rc);
}



//
// FUNCTION:    SSISetNewCapabilities
//
// DESCRIPTION:
//
// Set the new SSI related capabilities
//
// RETURNS:
//
// NONE
//
// PARAMETERS:
//
// pDataIn  - pointer to the input buffer
//
//
void SSISetNewCapabilities(LPSSI_NEW_CAPABILITIES pCapabilities)
{
    DebugEntry(SSISetNewCapabilities);

    //
    // Copy the data from the Share Core.
    //
    g_ssiSaveBitmapSize             = pCapabilities->sendSaveBitmapSize;

    g_ssiLocalSSBState.xGranularity = pCapabilities->xGranularity;

    g_ssiLocalSSBState.yGranularity = pCapabilities->yGranularity;

    TRACE_OUT(( "SSI caps: Size %ld X gran %hd Y gran %hd",
                 g_ssiSaveBitmapSize,
                 g_ssiLocalSSBState.xGranularity,
                 g_ssiLocalSSBState.yGranularity));

    DebugExitVOID(SSISetNewCapabilities);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\as16\sbc.c ===
//
// SBC.C
// Sent Bitmap Cache
//
// Copyright(c) Microsoft 1997-
//

#include <as16.h>



//
// SBC_DDProcessRequest()
// Handle SBC escapes
//
BOOL SBC_DDProcessRequest
(
    UINT        fnEscape,
    LPOSI_ESCAPE_HEADER pResult,
    DWORD       cbResult
)
{
    BOOL        rc;

    DebugEntry(SBC_DDProcessRequest);

    switch (fnEscape)
    {
        case SBC_ESC_NEW_CAPABILITIES:
        {
            TRACE_OUT(("SBC_ESC_NEW_CAPABILITIES"));

            ASSERT(cbResult == sizeof(SBC_NEW_CAPABILITIES));

#if 0
            SBCDDSetNewCapabilities((LPSBC_NEW_CAPABILITIES)pResult);
#endif

            rc = TRUE;
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognized SBC_ escape"));
            rc = FALSE;
        }
        break;
    }

    DebugExitBOOL(SBC_DDProcessRequest, rc);
    return(rc);
}



#if 0
//
// FUNCTION:    SBCDDSetNewCapabilities
//
// DESCRIPTION:
//
// Set the new SBC related capabilities
//
// RETURNS:
//
// NONE
//
// PARAMETERS:
//
// pDataIn  - pointer to the input buffer
//
//
void SBCDDSetNewCapabilities(LPSBC_NEW_CAPABILITIES pCapabilities)
{
    DebugEntry(SBCSetNewCapabilities);

    //
    // Copy the data from the Share Core.
    //
    g_sbcSendingBPP     = pCapabilities->sendingBpp;

    hmemcpy(&g_sbcCacheInfo, pCapabilities->cacheInfo, sizeof(g_sbcCacheInfo));


    DebugExitVOID(SBCSetNewCapabilities);
}
#endif




//
// SBC_DDInit()
//
BOOL SBC_DDInit
(
    HDC     hdcScreen,
    LPDWORD ppShuntBuffers,
    LPDWORD pBitmasks
)
{
    UINT    i;
    BOOL    rc = FALSE;

    DebugEntry(SBC_DDInit);

#if 0
    for (i = 0; i < SBC_NUM_TILE_SIZES; i++)
    {
        ASSERT(!g_sbcWorkInfo[i].pShuntBuffer);
        ASSERT(!g_sbcWorkInfo[i].mruIndex);
        ASSERT(!g_sbcWorkInfo[i].workBitmap);

        if (i == SBC_SMALL_TILE_INDEX)
        {
            g_sbcWorkInfo[SBC_SMALL_TILE_INDEX].tileWidth = SBC_SMALL_TILE_WIDTH;
            g_sbcWorkInfo[SBC_SMALL_TILE_INDEX].tileHeight = SBC_SMALL_TILE_HEIGHT;
        }
        else
        {
            ASSERT(i == SBC_LARGE_TILE_INDEX);

            g_sbcWorkInfo[SBC_LARGE_TILE_INDEX].tileWidth = SBC_LARGE_TILE_WIDTH;
            g_sbcWorkInfo[SBC_LARGE_TILE_INDEX].tileHeight = SBC_LARGE_TILE_HEIGHT;
        }

        g_sbcWorkInfo[i].workBitmap = CreateCompatibleBitmap(hdcScreen,
            g_sbcWorkInfo[i].tileWidth, g_sbcWorkInfo[i].tileHeight);

        if (! g_sbcWorkInfo[i].workBitmap)
        {
            ERROR_OUT(("Failed to create work bitmap %d", i));
            DC_QUIT;
        }

        SetObjectOwner(g_sbcWorkInfo[i].workBitmap, g_hInstAs16);
        MakeObjectPrivate(g_sbcWorkInfo[i].workBitmap, TRUE);
    }

    //
    // Initialize the shunt buffers
    //
    if (! SBCDDCreateShuntBuffers())
        DC_QUIT;

    //
    // We've created our SBC cache.  Fill in the details
    //
    for (i = 0; i < SBC_NUM_TILE_SIZES; i++)
    {
        ppShuntBuffers[i] = (DWORD)MapSL(g_sbcWorkInfo[i].pShuntBuffer);
        ASSERT(ppShuntBuffers[i]);
    }

    pBitmasks[0] = g_osiScreenRedMask;
    pBitmasks[1] = g_osiScreenGreenMask;
    pBitmasks[2] = g_osiScreenBlueMask;

    g_sbcPaletteChanged = TRUE;

    rc = TRUE;

DC_EXIT_POINT:

#endif

    DebugExitBOOL(SBC_DDInit, rc);
    return(rc);
}



//
// SBC_DDTerm()
//
void SBC_DDTerm(void)
{
    UINT    i;

    DebugEntry(SBC_DDTerm);

#if 0
    //
    // Clear out our array and free the shunt buffer memory.
    //
    for (i = 0 ; i < SBC_NUM_TILE_SIZES ; i++)
    {
        // Kill the bitmap if we there
        if (g_sbcWorkInfo[i].workBitmap)
        {
            SysDeleteObject(g_sbcWorkInfo[i].workBitmap);
            g_sbcWorkInfo[i].workBitmap = NULL;
        }

        if (g_sbcWorkInfo[i].pShuntBuffer)
        {
            GlobalFree((HGLOBAL)SELECTOROF(g_sbcWorkInfo[i].pShuntBuffer));
            g_sbcWorkInfo[i].pShuntBuffer = NULL;
        }

        g_sbcWorkInfo[i].mruIndex        = 0;
    }
#endif

    DebugExitVOID(SBC_DDTerm);
}



#if 0

//
// SBC_DDTossFromCache()
// This throws away a bitmap if we'd cached it, which happens when the
// contents change.
//
void SBC_DDTossFromCache
(
    HBITMAP hbmp
)
{
    DebugEntry(SBC_DDTossFromCache);

    DebugExitVOID(SBC_DDTossFromCache);
}



//
//
// SBC_DDIsMemScreenBltCachable() - see sbc.h
//
//
BOOL SBC_DDIsMemScreenBltCachable
(
    UINT        type,
    HDC         hdcSrc,
    HBITMAP     hbmpSrc,
    UINT        cxSubWidth,
    UINT        cySubHeight,
    HDC         hdcDst,
    LPBITMAPINFO    lpbmi
)
{
    BOOL        rc = FALSE;
    UINT        srcBpp;
    UINT        tileWidth;
    UINT        tileHeight;
    BITMAP      bmpDetails;
    int         bmpWidth;
    int         bmpHeight;

    DebugEntry(SBC_DDIsMemScreenBltCachable);


    ASSERT((type == LOWORD(ORD_MEMBLT)) || (type == LOWORD(ORD_MEM3BLT)));

    if (g_sbcSendingBPP > 8)
    {
        TRACE_OUT(( "Unsupported sending bpp %d", g_sbcSendingBPP));
        DC_QUIT;
    }

    //
    // If this is a thrasher then don't cache it
    //
    if (!SBCBitmapCacheAllowed(hbmp))
    {
        TRACE_OUT(( "Its a thrasher"));
        DC_QUIT;
    }

    //
    // Ensure we're not in full screen mode.
    //
    if (g_asShared->fullScreen)
    {
        TRACE_OUT(("Not caching SBC; full screen active"));
        DC_QUIT;
    }

    if (hdcSrc && (GetMapMode(hdcSrc) != MM_TEXT))
    {
        TRACE_OUT(("Not caching SBC; source map mode not MM_TEXT"));
        DC_QUIT;
    }

    if (!hbmp)
    {
        //
        // We don't cache compressed DIB and DIB section bitmaps
        //
        if (lpbi->bmiHeader.biCompression != BI_RGB)
            DC_QUIT;

        bmpWidth = lpbi->bmiHeader.biWidth;
        bmpHeight = lpbi->bmiHeader.biHeight;
        srcBpp = lpbi->bmiHeader.biPlanes * lpbi->bmiHeader.biBitCount;
    }
    else
    {
        if (!GetObject(hbmp, sizeof(bmpDetails), &bmpDetails))
        {
            ERROR_OUT(("Can't get source info"));
            DC_QUIT;
        }

        srcBpp = bmpDetails.bmBitsPixel * bmpDetails.bmPlanes;
        bmpWidth = bmpDetails.bmWidth;
        bmpHeight = bmpDetails.bmHeight;
    }

    //
    // Oprah394
    //
    // This function is much too ready to take on work, even when it would
    // mean bogging down the host with unnecessary caching work.  We
    // have no way to determine when an app is doing animation save to
    // reject cache requests when the rate looks to be too high.
    //
    // This function is called for complete source bitmaps before tiling
    // so we do not need to worry about confusing tiling with animation.
    // The CacheRequests count is decayed in SBC_Periodic
    //
    //
    // MNM0063 - Oprah 394 revisited
    //
    // If we decide here that we are doing animation, we set the
    // sbcAnimating flag for the benefit of other parts of the code.  In
    // particular, we use this to suppress the comparison of before and
    // after states of the screen during a BitBlt operation
    //
    //
    if ((cxSubBitmapWidth  != bmpWidth) ||
        (cySubBitmapHeight != bmpHeight))
    {
        TRACE_OUT(("Partial blit - check for slideshow effects"));
        g_sbcBltRate++;
        if (g_sbcBltRate > SBC_CACHE_DISABLE_RATE)
        {
            TRACE_OUT(("Excessive cache rate %d - disabled", g_sbcBltRate));
            g_sbcAnimating = TRUE;
            DC_QUIT;
        }
    }
    //
    // MNM63: if we get here, we will assume we're not animating
    //
    g_sbcAnimating = FALSE;

    //
    // If the bitmap is 1bpp and the colors are not default then we don't
    // cache it (all bitmaps are cached in glorious technicolor!)
    //
    if ( (srcBpp == 1) &&
         ( (g_oeState.lpdc->DrawMode.bkColorL != DEFAULT_BG_COLOR) ||
           (g_oeState.lpdc->DrawMode.txColorL != DEFAULT_FG_COLOR) ||
           (type == LOWORD(ORD_MEM3BLT))) )
    {
        TRACE_OUT(("Didn't cache mono bitmap with non-default colors"));
        DC_QUIT;
    }

    //
    // Check that the cache will accept tiles
    //
    if (!SBC_DDQueryBitmapTileSize(bmpWidth,
                                 bmpHeight,
                                 &tileWidth,
                                 &tileHeight))
    {
        TRACE()"Cache does not support tiling"));
        DC_QUIT;
    }

    //
    // We are ready to go ahead with the caching!
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SBC_DDIsMemScreenBltCachable, rc);
    return(rc);
}


//
//
// SBC_DDCacheMemScreenBlt() - see sbc.h
//
//
BOOL SBC_DDCacheMemScreenBlt
(
    LPINT_ORDER                 pOrder,
    LPMEMBLT_ORDER_EXTRA_INFO   lpMemBltInfo,
    HDC                         hdcDst
)
{
    BOOL                rc = FALSE;
    LPMEMBLT_ORDER      pMemBltOrder = (LPMEMBLT_ORDER)&(pOrder->abOrderData);
    LPMEM3BLT_ORDER     pMem3BltOrder = (LPMEM3BLT_ORDER)pMemBltOrder;
    HBITMAP             hBitmap;
    HDC                 hdcSrc;
    UINT                iCache;
    UINT                iCacheEntry;
    UINT                iColorTable;
    UINT                type;
    LPINT               pXSrc;
    LPINT               pYSrc;
    UINT                srcBpp;
    BITMAP              bmpDetails;
    UINT                bmpWidth;
    UINT                bmpHeight;
    UINT                tileWidth;
    UINT                tileHeight;
    POINT               tileOrg;
    UINT                cxSubBitmapWidth;
    UINT                cySubBitmapHeight;
    LPBYTE              pWorkBits;
    RECT                destRect;
    POINT               sourcePt;
    int                 tileSize;
    LPSBC_TILE_DATA     pTileData = NULL;

    DebugEntry(SBC_DDCacheMemScreenBlt);

    //
    // Do a first pass on the cacheability of the Blt
    //
    if (!SBC_DDIsMemScreenBltCachable(lpMemBltInfo))
    {
        TRACE_OUT(( "This MemBlt Order is not cachable"));
        DC_QUIT;
    }

    //
    // Get the width and height of the source bitmap
    //
    pSourceSurf = pMemBltInfo->pSource;
    bmpWidth    = pSourceSurf->sizlBitmap.cx;
    bmpHeight   = pSourceSurf->sizlBitmap.cy;

    //
    // Calculate the tile size for this blit
    //
    if (!SBC_DDQueryBitmapTileSize(bmpWidth,
                                   bmpHeight,
                                   &tileWidth,
                                   &tileHeight))
    {
        TRACE_OUT(( "Cache does not support tiling"));
        DC_QUIT;
    }

    //
    // Set up pointers to the source coordinates in the order.
    //
    type = pMemBltOrder->type;
    if (type == ORD_MEMBLT_TYPE)
    {
        sourcePt.x = pMemBltOrder->nXSrc;
        sourcePt.y = pMemBltOrder->nYSrc;
        TRACE_OUT((
              "Request to cache MemBlt (%d, %d), %d x %d -> (%d, %d), src %x",
                 sourcePt.x,
                 sourcePt.y,
                 pMemBltOrder->nWidth,
                 pMemBltOrder->nHeight,
                 pMemBltOrder->nLeftRect,
                 pMemBltOrder->nTopRect,
                 pSourceSurf->hsurf));
    }
    else
    {
        sourcePt.x = pMem3BltOrder->nXSrc;
        sourcePt.y = pMem3BltOrder->nYSrc;
        TRACE_OUT((
             "Request to cache Mem3Blt (%d, %d), %d x %d -> (%d, %d), src %x",
                 sourcePt.x,
                 sourcePt.y,
                 pMem3BltOrder->nWidth,
                 pMem3BltOrder->nHeight,
                 pMem3BltOrder->nLeftRect,
                 pMem3BltOrder->nTopRect,
                 pSourceSurf->hsurf));
    }

    //
    // Calculate the tile origin and size of remaining bitmap.  Origin is
    // rounded down to the nearest tile.  Actual size of bitmap to cache
    // may be smaller than tile size if the tile runs off the right/bottom
    // of the bitmap
    //
    tileOrg.x = sourcePt.x - (sourcePt.x % tileWidth);
    tileOrg.y = sourcePt.y - (sourcePt.y % tileHeight);

    //
    // Actual size of bitmap to cache may be smaller than tile size if the
    // tile runs off the right/bottom of the bitmap. To see why this
    // calculation is correct, realize that (bmpWidth - tileOrg.x) is the
    // remaining width of the bitmap after the start of this tile.
    //
    cxSubBitmapWidth  = min(tileWidth, bmpWidth - tileOrg.x);
    cySubBitmapHeight = min(tileHeight, bmpHeight - tileOrg.y);

    //
    // We know how large a tile we have - we now have to Blt it into one of
    // our work bitmaps and pass it up to the share core.  First, work out
    // which of our work bitmaps we should use and set up some variables
    // based on this.
    //
    for (tileSize=0 ; tileSize<SBC_NUM_TILE_SIZES ; tileSize++)
    {
        if ((cxSubBitmapWidth <= g_sbcWorkInfo[tileSize].tileWidth) &&
            (cySubBitmapHeight <= g_sbcWorkInfo[tileSize].tileHeight))
        {
            break;
        }
    }

    if (tileSize == SBC_NUM_TILE_SIZES)
    {
        ERROR_OUT(( "%d x %d tile doesn't fit into work bmp",
                     cxSubBitmapWidth,
                     cySubBitmapHeight));
        DC_QUIT;
    }

    //
    // Before doing any more work, get the next free entry in the shunt
    // buffer.  Note that this fills in the tileId element of the returned
    // structure.
    //
    // It is perfectly valid for this call to fail.  The shunt buffer may
    // just be full if we are sending lots of bitmap data up to the share
    // core.
    //
    if (!SBCDDGetNextFreeTile(tileSize, &pTileData))
    {
        TRACE_OUT(( "Unable to get a free tile in shunt buffer"));
        DC_QUIT;
    }

    //
    // Lock the work bitmap to get a surface to pass to EngBitBlt
    //
    pWorkSurf = EngLockSurface((HSURF)g_sbcWorkInfo[tileSize].workBitmap);
    if (pWorkSurf == NULL)
    {
        ERROR_OUT(( "Failed to lock work surface"));
        DC_QUIT;
    }
    TRACE_OUT(( "Locked surface"));

    //
    // Do the Blt to our work bitmap to get the bits at native bpp, and
    // using the color table which we sent to the share core.
    //
    destRectl.top    = 0;
    destRectl.left   = 0;
    destRectl.right  = cxSubBitmapWidth;
    destRectl.bottom = cySubBitmapHeight;

    sourcePt = tileOrg;

    if (!EngBitBlt(pWorkSurf,
                   pSourceSurf,
                   NULL,                    // mask surface
                   NULL,                    // clip object
                   pMemBltInfo->pXlateObj,
                   &destRectl,
                   &sourcePt,
                   NULL,                    // mask origin
                   NULL,                    // brush
                   NULL,                    // brush origin
                   0xcccc))                 // SRCCPY
    {
        ERROR_OUT(( "Failed to Blt to work bitmap"));
        DC_QUIT;
    }
    TRACE_OUT(( "Completed BitBlt"));

    //
    // The Blt succeeded, so pass the bits to the share core by copying
    // them into the correct shunt buffer.
    //
    // bytesUsed is set to the number of bytes required for
    // cySubBitmapHeight number of full scanlines in the shunt buffer tile
    // (NOT the number of bytes available in the tile, or the number of
    // bytes of data which was actually Blted)
    //
    // major/minorCacheInfo are set to details from the source surface.
    // hdev does not change on consecutive Blts from the same surface, but
    // iUniq may.
    //
    pDestSurf            = pMemBltInfo->pDest;
    pDestDev             = (LPOSI_PDEV)pDestSurf->dhpdev;
    pTileData->bytesUsed = BYTES_IN_BITMAP(g_sbcWorkInfo[tileSize].tileWidth,
                                           cySubBitmapHeight,
                                           pDestDev->cBitsPerPel);
    pTileData->srcX           = (TSHR_UINT16)sourcePt.x;
    pTileData->srcY           = (TSHR_UINT16)sourcePt.y;
    pTileData->width          = cxSubBitmapWidth;
    pTileData->height         = cySubBitmapHeight;
    pTileData->tilingWidth    = tileWidth;
    pTileData->tilingHeight   = tileHeight;
    pTileData->majorCacheInfo = (UINT)pSourceSurf->hsurf;
    pTileData->minorCacheInfo = (UINT)pSourceSurf->iUniq;
    pTileData->majorPalette   = (UINT)pMemBltInfo->pXlateObj;
    pTileData->minorPalette   = (UINT)(pMemBltInfo->pXlateObj != NULL ?
                                           pMemBltInfo->pXlateObj->iUniq : 0);

    //
    // If the source surface has the BMF_DONTCACHE flag set then it is a
    // DIB Section.  This means that an app can change the bits in the
    // surface without calling GDI, and hence without the iUniq value being
    // updated.
    //
    // We rely on iUniq changing for the fast path to work, so we must
    // exclude these bitmaps from the fast path.  Do this by resetting the
    // majorCacheInfo field (we use this rather than minorCacheInfo because
    // we can't tell what an invalid iUniq value is).
    //
    if ( (pSourceSurf->iType == STYPE_BITMAP) &&
         ((pSourceSurf->fjBitmap & BMF_DONTCACHE) != 0) )
    {
        TRACE_OUT(( "Source hsurf %#.8lx has BMF_DONTCACHE set",
                     pTileData->majorCacheInfo));
        pTileData->majorCacheInfo = SBC_DONT_FASTPATH;
    }

    //
    // Note that this only works correctly because we create our work
    // bitmaps to be "top down" rather than the default of "bottom up".
    // i.e.  the data for the top scanline is first in memory, so we can
    // start copying from the start of the bit data.  Bottom up would mean
    // working out an offset into the work bitmap to start copying from.
    //
    memcpy(pTileData->bitData, pWorkSurf->pvBits, pTileData->bytesUsed);

    //
    // We've done the copy.  Reset the work bitmap bits for next time we
    // use this work bitmap - this helps with compression later on.
    //
    memset(pWorkSurf->pvBits, 0, pWorkSurf->cjBits);

    //
    // Fill in the required info in the Mem(3)Blt order.
    //
    if (type == ORD_MEMBLT_TYPE)
    {
        pMemBltOrder->cacheId = pTileData->tileId;
    }
    else
    {
        pMem3BltOrder->cacheId = pTileData->tileId;
    }

    //
    // We've filled in all the data in the shunt buffer entry, so mark it
    // as in use so that the share core can access it.
    //
    pTileData->inUse = TRUE;

    //
    // Must have completed successfully to get to here
    //
    TRACE_OUT(( "Queued tile (%d, %d), %d x %d, tile %d x %d, Id %hx",
                 sourcePt.x,
                 sourcePt.y,
                 cxSubBitmapWidth,
                 cySubBitmapHeight,
                 g_sbcWorkInfo[tileSize].tileWidth,
                 g_sbcWorkInfo[tileSize].tileHeight,
                 pTileData->tileId));
    rc = TRUE;

DC_EXIT_POINT:

    //
    // Unlock the work surface (if required)
    //
    if (pWorkSurf != NULL)
    {
        EngUnlockSurface(pWorkSurf);
        TRACE_OUT(( "Unlocked surface"));
    }

    DebugExitDWORD(SBC_DDCacheMemScreenBlt, rc);
    return(rc);

    //
    // If the data flow rate is high enough then we don't bother with
    // any bitmap caching.  This allows the host to run at its maximum
    // speed at all times, which gives us the maximum amount of spoiling
    // and responsiveness.
    //
    if (!usrCacheBitmaps)
    {
        DC_QUIT;
    }

    //
    // Bitmap caching is only supported for 4bpp and 8bpp protocols.  If we
    // switch the sending bpp during a share it does not matter because we
    // are controlling the remote bitmap caches.
    //
    if ((usrSendingbpp != 4) &&
        (usrSendingbpp != 8))
    {
        DC_QUIT;
    }

    //
    // Extract the src DC handle from the Order Header.
    //
    hdcSrc = pOrder->OrderHeader.memBltInfo.hdcSrc;

    //
    // If the mapping mode of the src DC is anything other that MM_TEXT
    // (the default) then we don't cache the bitmap.
    // We are aiming to cache icons and buttons and these will normally
    // be drawn using MM_TEXT mapping mode. Therefore if the mode is
    // anything other than MM_TEXT we can assume something more complex
    // is going on and we probably don't want to cache it anyway.
    //
    if ((hdcSrc != NULL) && (GetMapMode(hdcSrc) != MM_TEXT))
    {
        TRACE()"Didn't cache blt using complex mapping mode"));
        DC_QUIT;
    }

    //
    // Extract the src bitmap handle from the Order.
    //
    type = ((LPMEMBLT_ORDER)&pOrder->abOrderData)->type;
    if (type == LOWORD(ORD_MEMBLT))
    {
        hBitmap = (HBITMAP)((LPMEMBLT_ORDER)&pOrder->abOrderData)->hBitmap;
    }
    else
    {
        hBitmap = (HBITMAP)((LPMEM3BLT_ORDER)&pOrder->abOrderData)->hBitmap;
    }
    TRACE_DBG()"hBitmap %x", hBitmap));

    //
    // If this is a thrasher then don't cache it
    //
    if (!SBCBitmapCacheAllowed(hBitmap))
    {
        TRACE()"Its a thrasher!"));
        DC_QUIT;
    }

    //
    // Fetch the bitmap details.  If the bitmap is 1bpp and the colors are
    // not default then we don't cache it (all bitmaps are cached in
    // glorious technicolor!)
    //
    if (hBitmap == NULL)
    {
        bmpWidth  = (TSHR_INT16)pOrder->OrderHeader.memBltInfo.lpbmi->
                                                            bmiHeader.biWidth;
        bmpHeight = (TSHR_INT)pOrder->OrderHeader.memBltInfo.lpbmi->
                                                           bmiHeader.biHeight;
        srcBpp = pOrder->OrderHeader.memBltInfo.lpbmi->bmiHeader.biPlanes *
                 pOrder->OrderHeader.memBltInfo.lpbmi->bmiHeader.biBitCount;
    }
    else
    {
        if (GetObject(hBitmap, sizeof(BITMAP), &bmpDetails))
        {
            srcBpp = bmpDetails.bmBitsPixel * bmpDetails.bmPlanes;
            bmpWidth = bmpDetails.bmWidth;
            bmpHeight = bmpDetails.bmHeight;
        }
        else
        {
            TRACE_ERR()"Failed to get bmp details (%x)", (TSHR_UINT16)hBitmap));
            DC_QUIT;
        }
    }

    if ( (srcBpp == 1) &&
         ( (GetBkColor(hdcDst) != DEFAULT_BG_COLOR) ||
           (GetTextColor(hdcDst) != DEFAULT_FG_COLOR) ||
           (type == LOWORD(ORD_MEM3BLT))) )
    {
        TRACE()"Didn't cache mono bitmap with non-default colors"));
        DC_QUIT;
    }

    //
    // Set up pointers to the source coordinates in the order.
    //
    if ( type == LOWORD(ORD_MEMBLT) )
    {
        pXSrc = &((LPMEMBLT_ORDER)&(pOrder->abOrderData))->nXSrc;
        pYSrc = &((LPMEMBLT_ORDER)&(pOrder->abOrderData))->nYSrc;
    }
    else
    {
        pXSrc = &((LPMEM3BLT_ORDER)&(pOrder->abOrderData))->nXSrc;
        pYSrc = &((LPMEM3BLT_ORDER)&(pOrder->abOrderData))->nYSrc;
    }

    //
    // Calculate the tile size for this blit
    //
    if (!SBC_QueryBitmapTileSize(bmpWidth,
                                 bmpHeight,
                                 &tileWidth,
                                 &tileHeight))
    {
        TRACE()"Cache does not support tiling"));
        DC_QUIT;
    }

    //
    // Calculate the tile origin and size of remaining bitmap.  Origin is
    // rounded down to the nearest tile.  Actual size of bitmap to cache
    // may be smaller than tile size if the tile runs off the right/bottom
    // of the bitmap
    //
    tileOrg.x = *pXSrc - (*pXSrc % tileWidth);
    tileOrg.y = *pYSrc - (*pYSrc % tileHeight);

    //
    // Actual size of bitmap to cache may be smaller than tile size if the
    // tile runs off the right/bottom of the bitmap. To see why this
    // calculation is correct, realize that (bmpWidth - tileOrg.x) is the
    // remaining width of the bitmap after the start of this tile.
    //
    cxSubBitmapWidth  = MIN((TSHR_INT16)tileWidth, bmpWidth - tileOrg.x);
    cySubBitmapHeight = MIN((TSHR_INT16)tileHeight, bmpHeight - tileOrg.y);

    //
    // Add the bitmap to the cache.
    //
    // If the sub-bitmap is already in the cache then this function will
    // locate it and return the cache index.
    //
    // If the sub-bitmap is not in the cache, this function will cache
    // it, adding the sub-bitmap data to the order queue.
    //
    if (!SBCCacheSubBitmap(&iCache,
                           hBitmap,
                           hdcSrc,
                           hdcDst,
                           tileOrg.x,
                           tileOrg.y,
                           bmpWidth,
                           bmpHeight,
                           cxSubBitmapWidth,
                           cySubBitmapHeight,
                           srcBpp,
                           &iCacheEntry,
                           &iColorTable,
                           pOrder->OrderHeader.memBltInfo.pBits,
                           pOrder->OrderHeader.memBltInfo.lpbmi,
                           pOrder->OrderHeader.memBltInfo.fuColorUse,
                           pOrder->OrderHeader.memBltInfo.hPalDest))
    {
        //
        // The sub-bitmap could not be cached - return FALSE.
        // The caller will add the destination of the blt into the SDA and
        // discard the order.
        //
        TRACE()"Failed to cache bitmap %04x", hBitmap));
        DC_QUIT;
    }

    //
    // Set up the source co-ordinates. For R1 protocols, the x-coordinate
    // includes the offset which is required to get the right cell within
    // the receive bitmap cache. For R2, we set up the cache entry in a
    // separate field.
    //
    if (!sbcMultiPoint)
    {
        *pXSrc = (iCacheEntry * sbcBmpCaches[iCache].cCellSize) +
                             *pXSrc % tileWidth;
    }
    else
    {
        *pXSrc = *pXSrc % tileWidth;
    }
    *pYSrc = *pYSrc % tileHeight;

    //
    // The sub-bitmap and color table are in the cache.  Store a cache
    // handle and color handle (which the receiver will turn back into an
    // HBITMAP).  Also store the cache index for R2 protocols (see above).
    //
    if (type == LOWORD(ORD_MEMBLT))
    {
        ((LPMEMBLT_ORDER)&pOrder->abOrderData)->hBitmap =
                             MEMBLT_COMBINEHANDLES(iColorTable,iCache);
        if (sbcMultiPoint)
        {
            ((LPMEMBLT_R2_ORDER)&pOrder->abOrderData)->type =
                                                       LOWORD(ORD_MEMBLT_R2);
            ((LPMEMBLT_R2_ORDER)&pOrder->abOrderData)->cacheIndex =
                                                                  iCacheEntry;
        }
        TRACE()"MEMBLT color %d bitmap %d:%d",iColorTable,iCache,iCacheEntry));
    }
    else
    {
        ((LPMEM3BLT_ORDER)&pOrder->abOrderData)->hBitmap =
                             MEMBLT_COMBINEHANDLES(iColorTable,iCache);
        if (sbcMultiPoint)
        {
            ((LPMEM3BLT_R2_ORDER)&pOrder->abOrderData)->type =
                                                       LOWORD(ORD_MEM3BLT_R2);
            ((LPMEM3BLT_R2_ORDER)&pOrder->abOrderData)->cacheIndex =
                                                                  iCacheEntry;
        }
        TRACE()"MEM3BLT color %d bitmap %d:%d",iColorTable,iCache,iCacheEntry));

    }

    TRACE_DBG()"iCacheEntry=%u, tileWidth=%hu, xSrc=%hd, ySrc=%hd",
        iCacheEntry, tileWidth, *pXSrc, *pYSrc));

    rc = TRUE;

    DC_EXIT(rc);
}

//
//
// SBC_DDQueryBitmapTileSize - see sbc.h
//
//
BOOL SBC_DDQueryBitmapTileSize
(
    UINT   bmpWidth,
    UINT   bmpHeight,
    LPUINT  pTileWidth,
    LPUINT  pTileHeight
)
{
    BOOL    rc = FALSE;
    UINT    i;
    UINT    maxSide;

    DebugEntry(SBC_DDQueryBitmapTileSize);

    //
    // The tile cell sizes are a local only decision, with the proviso that
    // the largest uncompressed tile must fit into the largest cache slot.
    // What this means is that for R1.1 we must define cell dimensions that
    // have a good fit in the square cache cells.  For R2.0 we can just
    // select tile sizes that seem appropriate.  Taking widths that are not
    // a multiple of 16 is wasteful.  The height should generally be less
    // than the width, simply on the grounds that bitmaps tend to be wider
    // than they are high.
    //
    if (g_sbcCacheInfo[ID_LARGE_BMP_CACHE].cCellSize <
           (g_sbcWorkInfo[SBC_SMALL_TILE_INDEX].tileWidth *
            g_sbcWorkInfo[SBC_SMALL_TILE_INDEX].tileHeight))
    {
        ERROR_OUT(( "No space for any cells"));
        DC_QUIT;
    }

    rc = TRUE;

    //
    // If large cell size is adequate then allow 64*63 cells for
    // wide bitmaps
    //
    if (g_sbcCacheInfo[ID_LARGE_BMP_CACHE].cCellSize >=
        (MP_LARGE_TILE_WIDTH * MP_LARGE_TILE_HEIGHT))
    {
        if ((bmpWidth > MP_SMALL_TILE_WIDTH) ||
            (bmpHeight > MP_SMALL_TILE_HEIGHT))
        {
            *pTileWidth  = MP_LARGE_TILE_WIDTH;
            *pTileHeight = MP_LARGE_TILE_HEIGHT;
            DC_QUIT;
        }
    }

    //
    // Otherwise we just use 32*31 cells
    //
    *pTileWidth  = MP_SMALL_TILE_WIDTH;
    *pTileHeight = MP_SMALL_TILE_HEIGHT;

DC_EXIT_POINT:
    DebugExitBOOL(SBC_DDQueryBitmapTileSize, rc);
    return(rc);
}


//
//
// SBC_DDSyncUpdatesNow() - see sbc.h
//
//
void SBC_DDSyncUpdatesNow(void)
{
    LPSBC_TILE_DATA  pTileData;
    UINT          i;
    UINT          j;

    DebugEntry(SBC_DDSyncUpdatesNow);

    TRACE_OUT(( "Marking all shunt buffer entries as not in use"));

    //
    // We have to mark all entries in the shunt buffers as being free.
    //
    for (i = 0 ; i < SBC_NUM_TILE_SIZES; i++)
    {
        for (j = 0 ; j < g_sbcWorkInfo[i].pShuntBuffer->numEntries; j++)
        {
            pTileData = SBCTilePtrFromIndex(g_sbcWorkInfo[i].pShuntBuffer, j);
            pTileData->inUse = FALSE;
        }

        //
        // Reset the MRU counter for this shunt buffer
        //
        g_sbcWorkInfo[i].mruIndex = 0;
    }

    //
    // If we are a palette device (i.e.  we are running at 8 bpp or less),
    // set the paletteChanged flag so we will send up a color table before
    // our next Mem(3)Blt.  We do this because the color table order for
    // the current device palette may have been discarded during the OA
    // sync.
    //
    g_sbcPaletteChanged = (g_osiScreenBPP <= 8);

    DebugExitVOID(SBC_DDSyncUpdatesNow);
}


//
//
// SBC_DDOrderSpoiltNotification() - see sbc.h
//
//
void SBC_DDOrderSpoiltNotification(LPINT_ORDER pOrder)
{
    LPMEMBLT_ORDER      pMemBltOrder  = (LPMEMBLT_ORDER)&(pOrder->abOrderData);
    LPMEM3BLT_ORDER     pMem3BltOrder = (LPMEM3BLT_ORDER)pMemBltOrder;
    UINT                tileId;
    LPSBC_TILE_DATA     pTileData;
    UINT                tileType;
    UINT                i;

    DebugEntry(SBC_DDOrderSpoiltNotification);

    //
    // pOrder has been removed from the order heap before being processed.
    // We have to free up the entry which it references in one of the shunt
    // buffers.  First get the tile Id.
    //
    if (pMemBltOrder->type = ORD_MEMBLT_TYPE)
    {
        tileId = pMemBltOrder->cacheId;
    }
    else
    {
        tileId = pMem3BltOrder->cacheId;
    }
    TRACE_OUT(( "Order referencing tile %hx has been spoiled", tileId));

    //
    // Find out which of the shunt buffers the entry should be in based on
    // the tileId
    //
    tileType = SBC_TILE_TYPE(tileId);

    //
    // We implement the shunt buffers as circular FIFO queues, so we will
    // start looking from the last order which we marked as being in use,
    // and work BACKWARDS.  This is because, in general, the entries after
    // the last one we accessed will not be in use (unless the whole shunt
    // buffer is in use).
    //
    // So, get the index of the last tile we accessed.
    //
    i = g_sbcWorkInfo[tileType].mruIndex;

    //
    // Loop through the circular buffer until we get a match, or have
    // circled back to the beginning.
    //
    // Note that this has been coded as a "do while" loop, rather than just
    // a "while" loop so that we don't miss mruIndex.  mruIndex is set up
    // to point to the NEXT entry to be used, rather than the last entry to
    // be used, so decrementing i before doing any work first time round
    // the loop is actually what we want to do.
    //
    do
    {
        //
        // On to the next tile
        //
        i = (i == 0)
          ? g_sbcWorkInfo[tileType].pShuntBuffer->numEntries - 1
          : i - 1;

        pTileData = SBCTilePtrFromIndex(g_sbcWorkInfo[tileType].pShuntBuffer, i);

        if (pTileData->inUse && (pTileData->tileId == tileId))
        {
            //
            // We've got a match, so mark the tile as being free.
            //
            // We don't want to update the shunt buffer mruIndex - this
            // should remain indicating the next tile to be used when
            // adding an entry to the shunt buffer.
            //
            TRACE_OUT(( "Marked tile Id %hx at index %d as free",
                         tileId,
                         i));
            pTileData->inUse = FALSE;
            break;
        }
    }
    while (i != g_sbcWorkInfo[tileType].mruIndex);

    DebugExitVOID(SBC_DDOrderSpoiltNotification);
}


//
//
// SBC_DDMaybeQueueColorTable() - see sbc.h
//
//
BOOL SBC_DDMaybeQueueColorTable(void)
{
    BOOL                      queuedOK = FALSE;
    int                       orderSize;
    LPINT_ORDER               pOrder;
    LPINT_COLORTABLE_ORDER_1BPP  pColorTableOrder;
    UINT                      numColors;
    UINT                      i;

    DebugEntry(SBC_DDMaybeQueueColorTable);

    //
    // If we're running at > 8 bpp, then we don't have a palette, so just
    // quit out.
    //
    if (g_osiScreenBPP > 8)
    {
        queuedOK = TRUE;
        DC_QUIT;
    }

    //
    // Check the boolean in our PDEV to see if the palette has changed
    // since the last time we sent a color table order.  Note that if we
    // have a non palette device, the boolean will never be set.
    //
    if (!g_sbcPaletteChanged)
    {
        queuedOK = TRUE;
        DC_QUIT;
    }

    //
    // The palette has changed, so allocate order memory to queue a color
    // table order.  The order size depends on the bpp of our device.  Note
    // that the allocation can fail if the order buffer is full.
    //
    switch (g_osiScreenBPP)
    {
        case 1:
        {
            orderSize = sizeof(INT_COLORTABLE_ORDER_1BPP);
        }
        break;

        case 4:
        {
            orderSize = sizeof(INT_COLORTABLE_ORDER_4BPP);
        }
        break;

        case 8:
        {
            orderSize = sizeof(INT_COLORTABLE_ORDER_8BPP);
        }
        break;

        default:
        {
            ERROR_OUT(("Invalid bpp (%d) for palette device", g_osiScreenBPP));
            DC_QUIT;
        }
        break;
    }

    pOrder = OA_DDAllocOrderMem(orderSize, 0);
    if (pOrder == NULL)
    {
        TRACE_OUT(( "Failed to allocate %d bytes for order", orderSize));
        DC_QUIT;
    }
    TRACE_OUT(( "Allocate %d bytes for color table order", orderSize));

    //
    // We've successfully allocated the order, so fill in the details.  We
    // mark the order as internal so that the Update Packager will spot it
    // up in the share core and prevent it being sent over the wire.
    //
    pOrder->OrderHeader.Common.fOrderFlags = OF_INTERNAL;

    pColorTableOrder = (LPINT_COLORTABLE_ORDER_1BPP)&(pOrder->abOrderData);
    pColorTableOrder->header.type = INTORD_COLORTABLE_TYPE;
    pColorTableOrder->header.bpp  = g_osiScreenBPP;

    //
    // Get the current system palette and save it.
    //
    numColors = COLORS_FOR_BPP(g_osiScreenBPP);
    for (i = 0 ; i < numColors; i++)
    {
        pColorTableOrder->colorData[i].rgbRed   = ppDev->pPal[i].peRed;
        pColorTableOrder->colorData[i].rgbGreen = ppDev->pPal[i].peGreen;
        pColorTableOrder->colorData[i].rgbBlue  = ppDev->pPal[i].peBlue;
    }

    //
    // Add the order
    //
    OA_DDAddOrder(pOrder, NULL);
    TRACE_OUT(( "Added internal color table order, size %d", orderSize));

    //
    // Reset the flag which indicates that the palette needs to be sent
    //
    g_sbcPaletteChanged = FALSE;

    //
    // Must be OK to get to here
    //
    queuedOK = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SBC_DDMaybeQueueColorTable, queuedOK);
    return(queuedOK);
}




//
// Name:      SBCDDCreateShuntBuffers
//
// Purpose:   Allocate memory for, and initialize the two shunt buffers
//            used to pass data from the driver to the share core.
//
// Returns:   TRUE if the buffers were allocated OK, FALSE otherwise.
//
// Operation: If this function succeeds, the following global variables
//            are initialized.
//
//               g_sbcWorkInfo[x].pShuntBuffer
//               g_sbcWorkInfo[x].mruIndex
//               g_sbcNextTileId
//
//            If the function fails, some of these variables may be
//            initialized.
//
BOOL SBCDDCreateShuntBuffers(void)
{
    int     i;
    UINT    memPerTile[SBC_NUM_TILE_SIZES];
    UINT    numEntries[SBC_NUM_TILE_SIZES];
    DWORD   memRequired;
    DWORD   minRequired;
    HGLOBAL hBuffer;
    LPBYTE  pBuffer;
    BOOL    rc;

    DebugEntry(SBCDDCreateShuntBuffers);

    rc = FALSE;

    //
    // We should already have a pointer to the shared memory we can use for
    // our shunt buffers, and the number of bytes available.  What we have
    // to do is to partition this shared memory into SBC_NUM_TILE_SIZE
    // shunt buffers.  i.e. one shunt buffer per tile size.
    //
    //
    // <--- buffer 0 ---><------------------ buffer 1 -------------------->
    //
    //Ŀ
    //    :  :  :  :             :        :         :         :        
    //    :  :  :  :       tile  :  tile  :  tile   :  tile   :  tile  
    //    :  :  :  :             :        :         :         :        
    //
    //^ ^                  ^
    //                   
    //  header[0]      header[1]
    //
    // psbcSharedMemory
    //
    //
    // We try to use the number of entries given in the pEntries array, but
    // if we do not have enough shared memory for this, we reduce the
    // number of entries in each shunt buffer, preserving the ratio between
    // the number of entries in each of the shunt buffers.
    //

    for (i = 0; i < SBC_NUM_TILE_SIZES ; i++)
    {
        numEntries[i] = SBC_TILE_ENTRIES;

        //
        // Calculate how much memory we need per tile, and for the whole
        // shunt buffer.
        //
        memPerTile[i]   = SBC_BYTES_PER_TILE(g_sbcWorkInfo[i].tileWidth,
                                             g_sbcWorkInfo[i].tileHeight,
                                             g_osiScreenBPP);

        memRequired  = SBCShuntBufferSize(memPerTile[i], numEntries[i]);

        if (i == SBC_SMALL_TILE_INDEX)
            minRequired = SBCShuntBufferSize(memPerTile[i], SBC_SMALL_TILE_MIN_ENTRIES);
        else
            minRequired = SBCShuntBufferSize(memPerTile[i], SBC_LARGE_TILE_MIN_ENTRIES); 

        TRACE_OUT(( "[%d]: Requested %d entries, %ld bytes, %ld bytes min",
                     i, numEntries[i], memRequired, minRequired));

        //
        // If memRequired or minRequired are greater than 64K, bail out.
        //
        if (memRequired > 0x10000)
        {
            if (minRequired > 0x10000)
            {
                WARNING_OUT(("Not enough memory for SBC"));
                DC_QUIT;
            }

            //
            // We have enough shared memory for the minimum # of entries,
            // but not enough for the default.  Figure out how many will fit.
            // in 64K.  We do this in a tricky way to avoid DWORD divides
            //
            // Basically, the result is 
            //      (64K - fixed shunt buffer goop) / memPerTile
            //
            numEntries[i] = (0xFFFF -
                (sizeof(SBC_SHUNT_BUFFER) - sizeof(SBC_TILE_DATA)) + 1) /
                memPerTile[i];
        }

        //
        // Try to allocate memory block.
        //
        hBuffer = GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT | GMEM_SHARE,
            SBCShuntBufferSize(memPerTile[i], numEntries[i]));

        if (!hBuffer)
        {
            WARNING_OUT(("Not enough memory for SBC"));
            DC_QUIT;
        }

        g_sbcWorkInfo[i].pShuntBuffer = (LPSBC_SHUNT_BUFFER)MAKELP(hBuffer, 0);
    }

    //
    // There are currently only two tile sizes and therefore two shunt
    // buffers.  If we run out of memory on the second one, yeah, we'll
    // exit this function with one 64K block still allocated for the small
    // tile size cache.  It will get freed when SBC_DDTerm() is called.
    //
    // If this happens, freeing the block isn't going to make much of a 
    // difference, Windows is almost on its knees anyway.  So no point in
    // getting fancy and freeing it now.
    //

    //
    // OK, we're home free.
    //
    for (i = 0; i < SBC_NUM_TILE_SIZES ; i++)
    {
        ASSERT(g_sbcWorkInfo[i].pShuntBuffer);

        g_sbcWorkInfo[i].pShuntBuffer->numEntries    = numEntries[i];
        g_sbcWorkInfo[i].pShuntBuffer->numBytes      = memPerTile[i]
                                                   - sizeof(SBC_TILE_DATA);
        g_sbcWorkInfo[i].pShuntBuffer->structureSize = memPerTile[i];

        //
        // Fill in the mruIndex for this shunt buffer
        //
        g_sbcWorkInfo[i].mruIndex = 0;
    }

    //
    // Initialize the global variables associated with the shunt buffers
    //
    g_sbcNextTileId = 0;

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SBCDDCreateShuntBuffers, rc);
    return(rc);
}




//
// Name:      SBCDDGetNextFreeTile
//
// Purpose:   Return the next free tile of the correct size from one of the
//            shunt buffers.
//
// Returns:   TRUE if a tile is returned, FALSE otherwise
//
// Params:    IN  workTileSize - The tile size.  One of
//                     SBC_SMALL_TILE
//                     SBC_LARGE_TILE
//            OUT ppTileData   - A pointer to the tile.
//
// Operation: The tileId field of the tile is filled in on return from
//            this function.
//
//*PROC-********************************************************************
BOOL SBCDDGetNextFreeTile(int tileSize, LPSBC_TILE_DATA FAR * ppTileData)
{
    BOOL              foundFreeTile = FALSE;
    LPSBC_TILE_DATA      pTileData;

    DebugEntry(SBCDDGetNextFreeTile);

    ASSERT(tileSize < SBC_NUM_TILE_SIZES);

    //
    // Get a pointer to the next entry to be used in the shunt buffer
    // containing tiles of the given size.
    //
    pTileData = SBCTilePtrFromIndex(g_sbcWorkInfo[tileSize].pShuntBuffer,
                                        g_sbcWorkInfo[tileSize].mruIndex);

    //
    // If the entry is still in use (the share core has not yet processed
    // the order which references this tile) we have to quit - the shunt
    // buffer is full.
    //
    if (pTileData->inUse)
    {
        TRACE_OUT(( "Target entry (%d, %d) is still in use",
                     tileSize,
                     g_sbcWorkInfo[tileSize].mruIndex));
        DC_QUIT;
    }

    //
    // The entry is not in use - we can re-use it.  Fill in the Id field,
    // and the pointer to the entry which we return to the caller.
    //
    // We always set the top bit of the tile Id for large tiles, and clear
    // it for small tiles.
    //
    *ppTileData       = pTileData;
    pTileData->tileId = g_sbcNextTileId;
    if (tileSize == SBC_SMALL_TILE_INDEX)
    {
        pTileData->tileId &= ~0x8000;
    }
    else
    {
        pTileData->tileId |= 0x8000;
    }
    TRACE_OUT(( "Returning entry (%d, %d), Id %hx",
                 tileSize,
                 g_sbcWorkInfo[tileSize].mruIndex,
                 pTileData->tileId));

    //
    // Update the index of the next free entry in this shunt buffer, and
    // also the Id which we should assign next time.  Remember to wrap the
    // shunt buffer index to the number of entries in the shunt buffer.
    //
    g_sbcWorkInfo[tileSize].mruIndex = (g_sbcWorkInfo[tileSize].mruIndex + 1) %
            g_sbcWorkInfo[tileSize].pShuntBuffer->numEntries;


    g_sbcNextTileId++;
    g_sbcNextTileId &= ~0x8000;

    //
    // Completed successfully !
    //
    foundFreeTile = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SBCDDGetNextFreeTile, foundFreeTile);
    return(foundFreeTile);
}


//
// Name:      SBCDDIsBitmapThrasher
//
// Purpose:   Check to see if the given bitmap (surface object) is one
//            which would cause cache thrashing.
//
// Returns:   TRUE if the bitmap is a thrasher, FALSE otherwise.
//
// Params:    IN  pSurfObj - Pointer to the bitmap
//
BOOL SBCDDIsBitmapThrasher(HDC hdc)
{
    UINT      i;
    BOOL      rc = FALSE;
    BOOL      bitmapInList = FALSE;
    BOOL      updateEntry  = FALSE;
    UINT      updateIndex;
    UINT    nextTickCount;
    UINT      evictIndex;
    UINT    evictTickCount;

    DebugEntry(SBCDDIsBitmapThrasher);

    //
    // Here's an overview of how our bitmap cache thrash detection works...
    //
    // We hold an array of information about the last SBC_NUM_THRASHERS
    // bitmaps which we have tried to cache.  This information is
    //  - A value to identify the bitmap.  This is the hsurf field from the
    //    bitmap surface object, and is different for every bitmap.
    //  - A value to identify the "version" of the bitmap.  This is the
    //    iUniq field from the bitmap surface object, and is updated by GDI
    //    each time the bitmap is drawn to.
    //  - A timestamp for the last time which we saw iUniq change for this
    //    bitmap (or when we added the bitmap to the array).
    //
    // Each time this function is called, we scan this array looking for an
    // entry for the bitmap.
    //
    // If we find an entry, we check whether the bitmap has changed (has
    // the iUniq field changed).  If it has not changed, the bitmap is not
    // a thrasher.  If the bitmap has changed, we check the interval from
    // the timestamp value to the current time.  If the interval is less
    // than the SBC_THRASH_INTERVAL, the bitmap has changed too quickly, so
    // it is a thrasher.  If the interval is OK, the bitmap is not a
    // thrasher.  In either case, we update the stored iUniq field and the
    // timestamp to record the time / version at which we spotted that the
    // bitmap changed.
    //
    // If we do not find an entry for the bitmap, we add an entry for it.
    // If the array is fully populated, we evict the entry with the oldest
    // timestamp, and replace it with the new entry.
    //

    //
    // Scan the thrasher list looking for a match
    //
    for (i=0 ; i < SBC_NUM_THRASHERS ; i++)
    {
        //
        // If we find a match then we are only worried if it has been
        // modified since the last time we read it.
        //
        if (sbcThrashers[i].hsurf == lpdce->hbmp)
        {
            bitmapInList = TRUE;

            if (sbcThrashers[i].iUniq != pSurfObj->iUniq)
            {
                TRACE_OUT(( "Matching surface %x, index %u,"
                             "tick count %u has been modified",
                             pSurfObj->hsurf,
                             i,
                             sbcThrashers[i].tickCount));
                updateEntry = TRUE;
                updateIndex = i;

                //
                // Now we need to determine if this is a thrasher.  It is a
                // thrasher if the time we last read it is less than our
                // thrash interval.  (We only update the time when we read
                // a modified bitmap)
                //
                nextTickCount = SBCDDGetTickCount();
                if ((nextTickCount - sbcThrashers[i].tickCount) <
                                                          SBC_THRASH_INTERVAL)
                {
                    TRACE_OUT((
                             "Rejected cache attempt of thrashy bitmap %x",
                             pSurfObj->hsurf));
                    rc = TRUE;
                }
                sbcThrashers[i].tickCount = nextTickCount;
                sbcThrashers[i].iUniq     = pSurfObj->iUniq;
            }

            //
            // We've found a match - we can break out of the loop
            //
            break;
        }
    }

    if (!bitmapInList)
    {
        //
        // The bitmap isn't already in the thrasher list, so add it now.
        // Find the entry with the smallest (earliest) tick count - we will
        // evict this entry from the array to make room for the new entry.
        //
        evictIndex     = 0;
        evictTickCount = 0xffffffff;

        for (i = 0; i < SBC_NUM_THRASHERS; i++)
        {
            if (evictTickCount > sbcThrashers[i].tickCount)
            {
                evictTickCount = sbcThrashers[i].tickCount;
                evictIndex     = i;
            }
        }
        TRACE_OUT(( "Evicting entry %d, surface %x",
                     evictIndex,
                     sbcThrashers[i].hsurf));

        nextTickCount = SBCDDGetTickCount();

        TRACE_OUT(( "Adding surface %x to thrash list, tick %d",
                     pSurfObj->hsurf,
                     nextTickCount));
        updateEntry = TRUE;
        updateIndex = evictIndex;
    }

    if (updateEntry)
    {
        //
        // We have to update the entry at index updateIndex.  We optimise
        // things slightly by always putting the most recent bitmap in
        // position 0 of the array, so copy entry 0 to the eviction index,
        // and put the new entry in position 0.
        //
        sbcThrashers[updateIndex] = sbcThrashers[0];

        sbcThrashers[0].hsurf     = lpdce->hbmp;
        sbcThrashers[0].iUniq     = pSurfObj->iUniq;
        sbcThrashers[0].tickCount = nextTickCount;
    }

    DebugExitBOOL(SBCDDIsBitmapThrasher, rc);
    return(rc);
}


//
// Name:      SBCDDGetTickCount
//
// Purpose:   Get a system tick count
//
// Returns:   The number of centi-seconds since the system was started.
//            This number will wrap after approximately 497 days!
//
// Params:    None
//
DWORD SBCDDGetTickCount(void)
{
    DWORD   tickCount;

    DebugEntry(SBCDDGetTickCount);

    tickCount = GetTickCount() / 10;

    DebugExitDWORD(SBCDDGetTickCount, tickCount);
    return(tickCount);
}


#endif // #if 0





#if 0

//
// SBC_BitmapHasChanged(..)
//
// See asbcapi.h for description.
//
DCVOID DCAPI SBC_BitmapHasChanged(HBITMAP hChangedBitmap)
{
    TSHR_UINT nextIndex;
    TSHR_INT  nextTickCount;
    TSHR_INT  tickDelta;
    TSHR_INT  tickWork;
    UINT      i;

    TRACE_FN("SBC_BitmapHasChanged");

    //
    // We maintain a list of bitmaps that are the target for a drawing
    // operation and we prevent these bitmaps from being cached unless
    // the update frequency is below a target value.
    //
    // All we need to do at this stage is to make sure that the bitmap
    // handle is in the thrash list and is marked as modified since the
    // last read.  That means that the next read will be "productive"
    // and so we will check/update the timer at that stage.  If the
    // "productive" read occurs within a certain interval from the last
    // read then this bitmap has become a thrasher.
    //
    if (sbcThrashers[0].hBitmap == hChangedBitmap)
    {
        TRACE()"Repeat bitmap %x modified",(UINT)hChangedBitmap));
        sbcThrashers[0].modified = TRUE;
    }
    else
    {
        nextIndex     = 0;
        nextTickCount = (int)(CO_GET_TICK_COUNT()/32);
        tickDelta     = abs(nextTickCount - sbcThrashers[0].tickCount);

        for (i=1; i<SBC_NUM_THRASHERS; i++)
        {
            if (sbcThrashers[i].hBitmap == hChangedBitmap)
            {
                sbcThrashers[i].modified = TRUE;
                break;
            }

            tickWork = abs(nextTickCount - sbcThrashers[i].tickCount);
            if (tickWork > tickDelta)
            {
                tickDelta = tickWork;
                nextIndex = i;
            }

        }

        //
        // If not found in the list then add to the list.  Always add to
        // the top of the list so we find repeated bitmaps as the first
        // entry
        //
        if (i == SBC_NUM_THRASHERS)
        {
            TRACE()"Relegating bitmap %x at list pos %u",
                          (UINT)sbcThrashers[nextIndex].hBitmap,nextIndex));
            if (nextIndex != 0)
            {
                sbcThrashers[nextIndex].hBitmap   = sbcThrashers[0].hBitmap;
                sbcThrashers[nextIndex].tickCount = sbcThrashers[0].tickCount;
                sbcThrashers[nextIndex].modified  = sbcThrashers[0].modified;
            }
            sbcThrashers[0].hBitmap   = hChangedBitmap;
            sbcThrashers[0].tickCount = nextTickCount - BMC_THRASH_INTERVAL;
            sbcThrashers[0].modified  = TRUE;
            TRACE()"Adding bitmap %x to thrash list tick %u",
                                       (TSHR_UINT16)hChangedBitmap, nextTickCount));
        }
    }

    //
    // We also maintain a list of "fast path" bitmaps, which is those tiles
    // that have not been modified since we cached them and can therefore
    // be interpreted from the handle alone.  This must be an exhaustive
    // search for each bitmap update and so we cannot offord the CPU of
    // processing a very long list, but we can afford to cache enough to
    // handle most animations.  Also it is not worth the CPU to try and
    // save individual tiles here.  We just evict the complete bitmap.
    //
    for (i=0; i<SBC_NUM_FASTPATH; i++)
    {
        if (sbcFastPath[i].hBitmap == hChangedBitmap)
        {
            TRACE()"Bitmap %x no longer fastpathed",(UINT)hChangedBitmap));
            sbcFastPath[i].hBitmap = 0;
        }
    }

    return;
}

//
// SBC_BitmapDeleted()
//
// See asbcapi.h for description.
//
DCVOID DCAPI SBC_BitmapDeleted(HBITMAP hDeletedBitmap)
{
    UINT i;

    TRACE_FN("SBC_BitmapDeleted");

    //
    // Remove the bitmap from the thrashy list.
    //
    for (i=0; i<SBC_NUM_THRASHERS; i++)
    {
        if (sbcThrashers[i].hBitmap == hDeletedBitmap)
        {
            TRACE_DBG()"Bitmap %x no longer thrashing",hDeletedBitmap));
            sbcThrashers[i].hBitmap   = 0;
            sbcThrashers[i].tickCount = 0;
            break;
        }
    }

    //
    // We also maintain a list of "fast path" bitmaps, which is those tiles
    // that have not been modified since we cached them and can therefore
    // be interpreted from the handle alone.  This must be an exhaustive
    // search for each bitmap update and so we cannot offord the CPU of
    // processing a very long list, but we can afford to cache enough to
    // handle most animations.  Also it is not worth the CPU to try and
    // save individual tiles here.  We just evict the complete bitmap.
    //
    for (i=0; i<SBC_NUM_FASTPATH; i++)
    {
        if (sbcFastPath[i].hBitmap == hDeletedBitmap)
        {
            TRACE()"Bitmap %x no longer fastpathed",(UINT)hDeletedBitmap));
            sbcFastPath[i].hBitmap   = 0;
            sbcFastPath[i].tickCount = 0;
        }
    }

    return;
}

//
// SBC_ColorsChanged()
//
// Called whenever the system palette changes (presumably as a result of
// a new logical palette being realized to the screen).
//
//
DCVOID DCAPI SBC_ColorsChanged(DCVOID)
{
    TRACE_FN("SBC_ColorsChanged");
    //
    // Just clear out all the fast path cache because we can no longer
    // trust the cached bits to accurately reflect the color table we
    // have cached.  (Note that this does not mean we will not use the
    // bits without resending, merely that we will force a retest of
    // the bits with the latest color info selected.
    //
    TRACE()"Fastpath table reset"));
    memset(sbcFastPath, 0, sizeof(sbcFastPath));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\as16\osi.c ===
//
// OSI.C
// Operating System Independent DLL
//      * Graphical Output tracking (DDI hook/display driver)
//      * Window/Task tracking (Window hook)
//
// Copyright(c) Microsoft 1997-
//

#include <as16.h>

#include <version.h>
#include <ndcgver.h>



PALETTEENTRY CODESEG g_osiVgaPalette[16] =
{
    {0x00, 0x00, 0x00, 0x00},             // Black          0x00
    {0x80, 0x00, 0x00, 0x00},             // Dk Red         0x01
    {0x00, 0x80, 0x00, 0x00},             // Dk Green       0x02
    {0x80, 0x80, 0x00, 0x00},             // Dk Yellow      0x03
    {0x00, 0x00, 0x80, 0x00},             // Dk Blue        0x04
    {0x80, 0x00, 0x80, 0x00},             // Dk Purple      0x05
    {0x00, 0x80, 0x80, 0x00},             // Dk Teal        0x06
    {0xC0, 0xC0, 0xC0, 0x00},             //    Gray        0x07
    {0x80, 0x80, 0x80, 0x00},             // Dk Gray        0x08 or 0xF8
    {0xFF, 0x00, 0x00, 0x00},             //    Red         0x09 or 0xF9
    {0x00, 0xFF, 0x00, 0x00},             //    Green       0x0A or 0xFA
    {0xFF, 0xFF, 0x00, 0x00},             //    Yellow      0x0B or 0xFB
    {0x00, 0x00, 0xFF, 0x00},             //    Blue        0x0C or 0xFC
    {0xFF, 0x00, 0xFF, 0x00},             //    Purple      0x0D or 0xFD
    {0x00, 0xFF, 0xFF, 0x00},             //    Teal        0x0E or 0xFE
    {0xFF, 0xFF, 0xFF, 0x00}              //    White       0x0F or 0xFF
};



// --------------------------------------------------------------------------
//
//  DllEntryPoint
//
// --------------------------------------------------------------------------
BOOL WINAPI DllEntryPoint(DWORD dwReason, WORD hInst, WORD wDS,
    WORD wHeapSize, DWORD dwReserved1, WORD  wReserved2)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            // First app pulled us in
            if (g_cProcesses++ == 0)
            {
                g_hInstAs16 = (HINSTANCE)hInst;
            }
            break;

        case DLL_PROCESS_DETACH:
            // Last app went away
            if (--g_cProcesses == 0)
            {
                // Clean up anything that got left around
                OSITerm16(TRUE);
            }
            break;
    }

    return(TRUE);
}



//
// OSILoad16
// Called on process attach of mnmcpi32.dll, to establish the flat thunks
// and return back our instance handle
//
void WINAPI OSILoad16
(
    LPDWORD     lpdwInstance
)
{
    DebugEntry(OSI_Load16);

    *lpdwInstance = (DWORD)(UINT)g_hInstAs16;

    DebugExitVOID(OSI_Load16);
}




// --------------------------------------------------------------------------
//
//  OSIInit16
//
//  Inits binary patcher, gdi + user patching, windows hooks, etc.
//
// --------------------------------------------------------------------------
BOOL WINAPI OSIInit16
(
    DWORD       version,
    HWND        hwndCore,
    LPDWORD     ppSharedMem,
    LPDWORD     ppoaSharedMem,
    LPDWORD     ppimSharedMem,
    LPDWORD     lpsbcEnabled,
    LPDWORD     ppShuntBuffers,
    LPDWORD     pBitmasks
)
{
    BOOL    rc = FALSE;
    HGLOBAL hMem;
    HMODULE hModDisplay;

    DebugEntry(OSIInit16);

    //
    // Fill in our instance handle.  We always return this so the 32-bit
    // code can free our library after having loaded it.
    //
    *lpsbcEnabled = FALSE;

#ifdef DEBUG
    g_imSharedData.cbSize = sizeof(g_imSharedData);
#endif

    *ppimSharedMem = (DWORD)MapSL(&g_imSharedData);
    ASSERT(*ppimSharedMem);

    if (version != DCS_MAKE_VERSION())
    {
        ERROR_OUT(("OSIInit16: failing, version mismatch 0x%lx (core) 0x%lx (dd)",
            version, DCS_MAKE_VERSION()));
        DC_QUIT;
    }

    // ONLY ALLOW ONE CLIENT TO INITIALIZE
    if (g_asMainWindow != NULL)
    {
        WARNING_OUT(("OSIInit16: mnmas16.dll was left around last time"));

        // If this task is no longer valid, then cleanup for it
        if (IsWindow(g_asMainWindow))
        {
            //
            // Uh oh.  Somehow a previous version of NM is still around.  
            // Do the safest thing--refuse to share.
            //
            ERROR_OUT(("OSIInit16: Another version of NetMeeting is still running!"));
            DC_QUIT;
        }

        // Cleanup (this is similar to the NT dd code)
        OSITerm16(TRUE);
        ASSERT(!g_asMainWindow);
    }

    //
    // Clear out shared IM memory.
    //
    g_imSharedData.imSuspended  = FALSE;
    g_imSharedData.imControlled = FALSE;
    g_imSharedData.imPaused     = FALSE;
    g_imSharedData.imUnattended = FALSE;

    g_asMainWindow = hwndCore;
    ASSERT(g_asMainWindow);
    g_hCoreTask = GetCurrentTask();

    g_osiDesktopWindow = GetDesktopWindow();
    ASSERT(g_osiDesktopWindow);

    //
    // DISPLAY DRIVER STUFF
    //
    hModDisplay = GetModuleHandle("DISPLAY");
    g_lpfnSetCursor = (SETCURSORPROC)GetProcAddress(hModDisplay,
            MAKEINTRESOURCE(ORD_OEMSETCURSOR));
    if (!hModDisplay || !g_lpfnSetCursor)
    {
        ERROR_OUT(("Couldn't find cursor entry points"));
        DC_QUIT;
    }

    // This doesn't always exist
    g_lpfnSaveBits = (SAVEBITSPROC)GetProcAddress(hModDisplay,
            MAKEINTRESOURCE(ORD_OEMSAVEBITS));

    //
    // KERNEL16 AND KERNEL32 STUFF
    //

    //
    // Get KRNL16's instance/module handle
    //
    g_hInstKrnl16 = LoadLibrary("KRNL386.EXE");
    ASSERT(g_hInstKrnl16);
    FreeLibrary(g_hInstKrnl16);

    g_hModKrnl16 = GetExePtr(g_hInstKrnl16);
    ASSERT(g_hModKrnl16);

    //
    // Get KERNEL32's instance/module handle
    //
    g_hInstKrnl32 = GetModuleHandle32("KERNEL32.DLL");
    ASSERT(g_hInstKrnl32);

    //
    // Get mapped 16-bit equivalent of KERNEL32's instance handle
    //
    g_hInstKrnl32MappedTo16 = MapInstance32(g_hInstKrnl32);
    ASSERT(g_hInstKrnl32MappedTo16);

    //
    // Get hold of MultiByteToWideChar() routine
    //
    g_lpfnAnsiToUni = (ANSITOUNIPROC)GetProcAddress32(g_hInstKrnl32,
        "MultiByteToWideChar");
    ASSERT(g_lpfnAnsiToUni);


    //
    // GDI16 AND GDI32 STUFF
    //

    //
    // Get GDI16's instance/module handle
    //
    g_hInstGdi16 = LoadLibrary("GDI.EXE");
    ASSERT(g_hInstGdi16);
    FreeLibrary(g_hInstGdi16);

    g_hModGdi16 = GetExePtr(g_hInstGdi16);
    ASSERT(g_hModGdi16);

    //
    // Get GDI32's instance/module handle
    //
    g_hInstGdi32 = GetModuleHandle32("GDI32.DLL");
    ASSERT(g_hInstGdi32);

    //
    // Get hold of GDI16 functions not exported but which are the target of 
    // public GDI32 functions via flat thunks
    //
    if (!GetGdi32OnlyExport("ExtTextOutW", 0, (FARPROC FAR*)&g_lpfnExtTextOutW)  ||
        !GetGdi32OnlyExport("TextOutW", 0, (FARPROC FAR*)&g_lpfnTextOutW) ||
        !GetGdi32OnlyExport("PolylineTo", 0, (FARPROC FAR*)&g_lpfnPolylineTo) ||
        !GetGdi32OnlyExport("PolyPolyline", 18, (FARPROC FAR*)&g_lpfnPolyPolyline))
    {
        ERROR_OUT(("Couldn't get hold of GDI32 routines"));
        DC_QUIT;
    }

    ASSERT(g_lpfnExtTextOutW);
    ASSERT(g_lpfnTextOutW);
    ASSERT(g_lpfnPolylineTo);
    ASSERT(g_lpfnPolyPolyline);


    //
    // USER16 and USER32 STUFF
    //

    //
    // Get USER16's instance/module handle
    //
    g_hInstUser16 = LoadLibrary("USER.EXE");
    ASSERT(g_hInstUser16);
    FreeLibrary(g_hInstUser16);

    g_hModUser16 = GetExePtr(g_hInstUser16);
    ASSERT(g_hModUser16);

    //
    // Get hold of USER32's instance handle. It has functions we
    // want to call which USER16 doesn't export.
    //
    g_hInstUser32 = GetModuleHandle32("USER32.DLL");
    ASSERT(g_hInstUser32);


    //
    // Get hold of USER16 functions not exported but which are the target of
    // public USER32 functions via flat thunks
    //
    if (!GetUser32OnlyExport("GetWindowThreadProcessId", (FARPROC FAR*)&g_lpfnGetWindowThreadProcessId))
    {
        ERROR_OUT(("Couldn't get hold of USER32 routines"));
        DC_QUIT;
    }

    ASSERT(g_lpfnGetWindowThreadProcessId);

    // 
    // This exists in Memphis but not Win95
    //
    g_lpfnCDSEx = (CDSEXPROC)GetProcAddress(g_hModUser16, "ChangeDisplaySettingsEx");


    //
    // Allocate the shared memory we use to communicate with the 32-bit
    // share core.
    //
    ASSERT(!g_asSharedMemory);
    ASSERT(!g_poaData[0]);
    ASSERT(!g_poaData[1]);

    //
    // Allocate our blocks GMEM_SHARE so we aren't bound by the vagaries
    // of process ownership.  We want our DLL to control them.  Note that
    // we do the same thing with GDI objects we create--our module owns the.
    //
    // We use GMEM_FIXED since we map these to flat addresses for mnmcpi32.dll,
    // and we don't want the linear address of these memory blocks to move
    // afterwards.
    //
    hMem = GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT | GMEM_SHARE, sizeof(SHM_SHARED_MEMORY));
    g_asSharedMemory = MAKELP(hMem, 0);

    hMem = GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT | GMEM_SHARE, sizeof(OA_SHARED_DATA));
    g_poaData[0] = MAKELP(hMem, 0);

    hMem =  GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT | GMEM_SHARE, sizeof(OA_SHARED_DATA));
    g_poaData[1] = MAKELP(hMem, 0);

    if (!g_asSharedMemory  ||
        !g_poaData[0] ||
        !g_poaData[1])
    {
        ERROR_OUT(("OSIInit16: couldn't allocate shared memory blocks"));
        DC_QUIT;
    }

    //
    // Get current screen attributes
    //

    g_oeStockPalette = GetStockObject(DEFAULT_PALETTE);

    g_osiScreenRect.left    = 0;
    g_osiScreenRect.top     = 0;
    g_osiScreenRect.right   = GetSystemMetrics(SM_CXSCREEN);
    g_osiScreenRect.bottom  = GetSystemMetrics(SM_CYSCREEN);

    g_osiScreenDC   = CreateDC("DISPLAY", 0L, 0L, 0L);
    g_osiMemoryDC   = CreateCompatibleDC(g_osiScreenDC);
    g_osiMemoryBMP  = CreateCompatibleBitmap(g_osiScreenDC, 1, 1);

    if (!g_osiScreenDC || !g_osiMemoryDC || !g_osiMemoryBMP)
    {
        ERROR_OUT(("Couldn't get screen dc"));
        DC_QUIT;
    }

    SetObjectOwner(g_osiScreenDC, g_hInstAs16);

    SetObjectOwner(g_osiMemoryDC, g_hInstAs16);

    SetObjectOwner(g_osiMemoryBMP, g_hInstAs16);
    MakeObjectPrivate(g_osiMemoryBMP, TRUE);

    g_osiScreenBitsPlane    = GetDeviceCaps(g_osiScreenDC, BITSPIXEL);
    g_osiScreenPlanes       = GetDeviceCaps(g_osiScreenDC, PLANES);
    g_osiScreenBPP          = (g_osiScreenBitsPlane * g_osiScreenPlanes);


    //
    // Get the color masks
    //

    g_osiScreenRedMask      = 0x000000FF;
    g_osiScreenGreenMask    = 0x0000FF00;
    g_osiScreenBlueMask     = 0x00FF0000;

    //
    // Only displays with more than 8bpp (palettized) might have color
    // masks.  Use our 1 pixel scratch bitmap to get them.
    //
    if (g_osiScreenBPP > 8)
    {
        DIB4    dib4T;

        //
        // Get the header
        //
        dib4T.bi.biSize = sizeof(BITMAPINFOHEADER);
        dib4T.bi.biBitCount = 0;
        GetDIBits(g_osiScreenDC, g_osiMemoryBMP, 0, 1, NULL, (LPBITMAPINFO)&dib4T.bi,
            DIB_RGB_COLORS);

        //
        // Get the mask
        //
        GetDIBits(g_osiScreenDC, g_osiMemoryBMP, 0, 1, NULL, (LPBITMAPINFO)&dib4T.bi,
            DIB_RGB_COLORS);

        if (dib4T.bi.biCompression == BI_BITFIELDS)
        {
            g_osiScreenRedMask = dib4T.ct[0];
            g_osiScreenGreenMask = dib4T.ct[1];
            g_osiScreenBlueMask = dib4T.ct[2];
        }
    }

    g_osiMemoryOld = SelectBitmap(g_osiMemoryDC, g_osiMemoryBMP);

    //
    // Initialize the bmiHeader so OEConvertColor() doesn't have to do it
    // over and over, when the header isn't touched by GDI.
    //
    g_osiScreenBMI.bmiHeader.biSize     = sizeof(BITMAPINFOHEADER);
    g_osiScreenBMI.bmiHeader.biPlanes   = 1;
    g_osiScreenBMI.bmiHeader.biBitCount = g_osiScreenBPP;
    g_osiScreenBMI.bmiHeader.biCompression  = BI_RGB;
    g_osiScreenBMI.bmiHeader.biSizeImage    = 0;
    g_osiScreenBMI.bmiHeader.biXPelsPerMeter = 1000;
    g_osiScreenBMI.bmiHeader.biYPelsPerMeter = 1000;
    g_osiScreenBMI.bmiHeader.biClrUsed  = 0;
    g_osiScreenBMI.bmiHeader.biClrImportant = 0;
    g_osiScreenBMI.bmiHeader.biWidth    = 1;
    g_osiScreenBMI.bmiHeader.biHeight   = 1;


    //
    // Init the various display driver components
    //
    BA_DDInit();

    if (!CM_DDInit(g_osiScreenDC))
    {
        ERROR_OUT(("CM failed to init"));
        DC_QUIT;
    }

    if (!SSI_DDInit())
    {
        ERROR_OUT(("SSI failed to init"));
        DC_QUIT;
    }

    if (!OE_DDInit())
    {
        ERROR_OUT(("OE failed to init"));
        DC_QUIT;
    }

    if (!IM_DDInit())
    {
        ERROR_OUT(("IM failed to init"));
        DC_QUIT;
    }

    if (!HET_DDInit())
    {
        ERROR_OUT(("HET failed to init"));
        DC_QUIT;
    }

    //
    // If we're here, all succeeded initializing
    //
    //
    // Map ptrs to flat addresses so they can be used in 32-bit code.  This
    // can't fail unless kernel is so messed up Windows is about to keel
    // over and die.
    //
    ASSERT(ppSharedMem);
    *ppSharedMem  = (DWORD)MapSL(g_asSharedMemory);
    ASSERT(*ppSharedMem);
    
    ASSERT(ppoaSharedMem);
    ppoaSharedMem[0] = (DWORD)MapSL(g_poaData[0]);
    ASSERT(ppoaSharedMem[0]);

    ppoaSharedMem[1] = (DWORD)MapSL(g_poaData[1]);
    ASSERT(ppoaSharedMem[1]);

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(OSIInit16, rc);
    return(rc);
}


// --------------------------------------------------------------------------
//
//  OSITerm16
//  Cleans up binary patcher, gdi + user patching, windows hooks, etc.
//
//  We do this on normal OSI stop, and on catastrophic failure.
//
// --------------------------------------------------------------------------
void WINAPI OSITerm16(BOOL fUnloading)
{
    DebugEntry(OSITerm16);

    if (!g_hCoreTask)
    {
        // Nothing to cleanup.
        DC_QUIT;
    }

    //
    // Is the task that actually caused us to allocate our resources?  In
    // other words, we don't want to clean up if
    //      App A loads mnmas16.dll, and gets it inited
    //      App B somehow starts up, loads mnmas16.dll, but mnmas16.dll
    //          doesn't init for sharing because cProcesses is > 1
    //      App B shuts down
    //      App B calls OSITerm16
    //
    // So in the 'dll is really about to go away case', we always cleanup.
    // But in normal term of sharing, we cleanup if the current task is the
    // current one.
    //
    if (fUnloading || (g_hCoreTask == GetCurrentTask()))
    {
        //
        // Term other pieces that depend on layout of shared memory
        //
        HET_DDTerm();

        IM_DDTerm();

        OE_DDTerm();

        SSI_DDTerm();

        CM_DDTerm();

        //
        // Free memory blocks
        //

        if (g_poaData[1])
        {
            GlobalFree((HGLOBAL)SELECTOROF(g_poaData[1]));
            g_poaData[1] = NULL;
        }

        if (g_poaData[0])
        {
            GlobalFree((HGLOBAL)SELECTOROF(g_poaData[0]));
            g_poaData[0] = NULL;
        }

        if (g_asSharedMemory)
        {
            GlobalFree((HGLOBAL)SELECTOROF(g_asSharedMemory));
            g_asSharedMemory = NULL;
        }

        if (g_osiMemoryOld)
        {
            SelectBitmap(g_osiMemoryDC, g_osiMemoryOld);
            g_osiMemoryOld = NULL;
        }

        if (g_osiMemoryBMP)
        {
            SysDeleteObject(g_osiMemoryBMP);
            g_osiMemoryBMP = NULL;
        }

        if (g_osiMemoryDC)
        {
            DeleteDC(g_osiMemoryDC);
            g_osiMemoryDC = NULL;
        }

        if (g_osiScreenDC)
        {
            DeleteDC(g_osiScreenDC);
            g_osiScreenDC = NULL;
        }

        g_asMainWindow = NULL;
        g_hCoreTask = NULL;
    }

DC_EXIT_POINT:
    DebugExitVOID(OSITerm16);
}



// --------------------------------------------------------------------------
//
//  OSIFunctionRequest16
//
//  Communication function with 32-bit MNMCPI32.DLL
//
// --------------------------------------------------------------------------
BOOL WINAPI OSIFunctionRequest16(DWORD fnEscape, LPOSI_ESCAPE_HEADER lpOsiEsc,
    DWORD   cbEscInfo)
{

    BOOL    rc = FALSE;

    DebugEntry(OSIFunctionRequest16);

    //
    // Check the data is long enough to store our standard escape header.
    // If it is not big enough this must be an escape request for another
    // driver.
    //
    if (cbEscInfo < sizeof(OSI_ESCAPE_HEADER))
    {
        ERROR_OUT(("Escape block not big enough"));
        DC_QUIT;
    }

    //
    // Check for our escape ID.  If it is not our escape ID this must be an
    // escape request for another driver.
    //
    if (lpOsiEsc->identifier != OSI_ESCAPE_IDENTIFIER)
    {
        ERROR_OUT(("Bogus Escape header ID"));
        DC_QUIT;
    }
    else if (lpOsiEsc->version != DCS_MAKE_VERSION())
    {
        ERROR_OUT(("Mismatched display driver and NetMeeting"));
        DC_QUIT;
    }


    if ((fnEscape >= OSI_ESC_FIRST) && (fnEscape <= OSI_ESC_LAST))
    {
        rc = OSI_DDProcessRequest((UINT)fnEscape, lpOsiEsc, cbEscInfo);
    }
    else if ((fnEscape >= OSI_OE_ESC_FIRST) && (fnEscape <= OSI_OE_ESC_LAST))
    {
        rc = OE_DDProcessRequest((UINT)fnEscape, lpOsiEsc, cbEscInfo);
    }
    else if ((fnEscape >= OSI_HET_ESC_FIRST) && (fnEscape <= OSI_HET_ESC_LAST))
    {
        rc = HET_DDProcessRequest((UINT)fnEscape, lpOsiEsc, cbEscInfo);
    }
    else if ((fnEscape >= OSI_SBC_ESC_FIRST) && (fnEscape <= OSI_SBC_ESC_LAST))
    {
        // Do nothing
    }
    else if ((fnEscape >= OSI_SSI_ESC_FIRST) && (fnEscape <= OSI_SSI_ESC_LAST))
    {
        rc = SSI_DDProcessRequest((UINT)fnEscape, lpOsiEsc, cbEscInfo);
    }
    else if ((fnEscape >= OSI_CM_ESC_FIRST) && (fnEscape <= OSI_CM_ESC_LAST))
    {
        rc = CM_DDProcessRequest((UINT)fnEscape, lpOsiEsc, cbEscInfo);
    }
    else if ((fnEscape >= OSI_OA_ESC_FIRST) && (fnEscape <= OSI_OA_ESC_LAST))
    {
        rc = OA_DDProcessRequest((UINT)fnEscape, lpOsiEsc, cbEscInfo);
    }
    else if ((fnEscape >= OSI_BA_ESC_FIRST) && (fnEscape <= OSI_BA_ESC_LAST))
    {
        rc = BA_DDProcessRequest((UINT)fnEscape, lpOsiEsc, cbEscInfo);
    }
    else if ((fnEscape >= OSI_HET_WO_ESC_FIRST) && (fnEscape <= OSI_HET_WO_ESC_LAST))
    {
        rc = HET_DDProcessRequest((UINT)fnEscape, lpOsiEsc, cbEscInfo);
    }
    else
    {
        ERROR_OUT(("Unknown function request"));
    }

DC_EXIT_POINT:
    DebugExitBOOL(OSIFunctionRequest16, rc);
    return(rc);
}



//
// OSI_DDProcessRequest()
// Handles OSI generic escapes
//
BOOL OSI_DDProcessRequest
(
    UINT    fnEscape,
    LPOSI_ESCAPE_HEADER pResult,
    DWORD   cbResult
)
{
    BOOL    rc;

    DebugEntry(OSI_DDProcessRequest);

    switch (fnEscape)
    {
        case OSI_ESC_SYNC_NOW:
        {
            ASSERT(cbResult == sizeof(OSI_ESCAPE_HEADER));

            //
            // Resync with the 32-bit ring 3 core.  This happens when
            // somebody joins or leaves a share.
            //
            BA_ResetBounds();
            OA_DDSyncUpdatesNow();
            rc = TRUE;

        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognized OSI escape"));
            rc = FALSE;
        }
        break;
    }

    DebugExitBOOL(OSI_DDProcessRequest, rc);
    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\as16\trc.c ===
//
// TRC.C
// Debug tracing utilities
//
// Copyright(c) Microsoft 1997-
//

#include <as16.h>



#ifdef _DEBUG

// Set g_trcConfig to ZONE_FUNCTION in the debugger to get fn tracing on

//
// DbgZPrintFn()
// DbgZPrintFnExitDWORD()
//
// This prints out strings for function tracing
//

void DbgZPrintFn(LPSTR szFn)
{
    if (g_trcConfig & ZONE_FUNCTION)
    {
        WARNING_OUT(("%s", szFn));
    }
}



void DbgZPrintFnExitDWORD(LPSTR szFn, DWORD dwResult)
{
    if (g_trcConfig & ZONE_FUNCTION)
    {
        WARNING_OUT(("%s, RETURN %08lx", szFn, dwResult));
    }
}




#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\as16\winddi.h ===
// --------------------------------------------------------------------------
//
//  WINDDI.H
//
//  Win16 DDI header
//
// --------------------------------------------------------------------------

#ifndef _WINDDI_
#define _WINDDI_


//
// Display Driver ordinals
//
#define ORD_OEMINQUIRECURSOR    101
#define ORD_OEMSETCURSOR        102
#define ORD_OEMMOVECURSOR       103
#define ORD_OEMCHECKCURSOR      104
#define ORD_OEMSAVEBITS          92


//
// DDI patches
//

#define DDI_FIRST       0
typedef enum
{
    //
    // Screen Output routines
    //
    DDI_ARC = DDI_FIRST,
    DDI_BITBLT,
    DDI_CHORD,
    DDI_ELLIPSE,
    DDI_EXTFLOODFILL,
    DDI_EXTTEXTOUTA,
    DDI_EXTTEXTOUTW,
    DDI_FILLPATH,
    DDI_FILLRGN,
    DDI_FLOODFILL,
    DDI_FRAMERGN,
    DDI_INVERTRGN,
    DDI_LINETO,
    DDI_PAINTRGN,
    DDI_PATBLT,
    DDI_PIE,
    DDI_PLAYENHMETAFILERECORD,
    DDI_PLAYMETAFILE,
    DDI_PLAYMETAFILERECORD,
    DDI_POLYGON,
    DDI_POLYBEZIER,
    DDI_POLYBEZIERTO,
    DDI_POLYLINE,
    DDI_POLYLINETO,
    DDI_POLYPOLYLINE,
    DDI_POLYPOLYGON,
    DDI_RECTANGLE,
    DDI_ROUNDRECT,
    DDI_SETDIBITSTODEVICE,
    DDI_SETPIXEL,
    DDI_STRETCHBLT,
    DDI_STRETCHDIBITS,
    DDI_STROKEANDFILLPATH,
    DDI_STROKEPATH,
    DDI_TEXTOUTA,
    DDI_TEXTOUTW,
    DDI_UPDATECOLORS,

    //
    // SPB stuff
    //
    DDI_CREATESPB,
    DDI_DELETEOBJECT,
    // DDI_SETOBJECTOWNER for Memphis

    //
    // Display mode, dosbox stuff
    //
    DDI_DEATH,
    DDI_RESURRECTION,
    DDI_WINOLDAPPHACKOMATIC,
    DDI_GDIREALIZEPALETTE,
    DDI_REALIZEDEFAULTPALETTE,

    //
    // If we implement an SBC, 
    // DDI_SETBITMAPBITS,
    // DDI_SETDIBCOLORTABLE,
    // DDI_SETDIBITS,
    // DDI_SYSDELETEOBJECT,
    //

    DDI_MAX
} DDI_PATCH;


//
// IM Patches
// We patch these DDIs when you are sharing and your machine is being
// controlled by a remote.  If a 16-bit shared app goes into a modal loop
// on mouse/key down, we pulse the win16lock so our 32-bit thread can
// play back the mouse/key moves and ups.
//
#define IM_FIRST        0
typedef enum
{
    //
    // Low level input processing
    //
    IM_MOUSEEVENT   = IM_FIRST,
    IM_KEYBOARDEVENT,
    IM_SIGNALPROC32,

    //
    // Win16lock pulsing for 16-bit apps that do modal loops on mouse input
    //
    IM_GETASYNCKEYSTATE,
    IM_GETCURSORPOS,
    
    IM_MAX
} IM_PATCH;


//
// DDI Routines
//
BOOL    WINAPI DrvArc(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI DrvBitBlt(HDC, int, int, int, int, HDC, int, int, DWORD);
BOOL    WINAPI DrvChord(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI DrvEllipse(HDC, int, int, int, int);
BOOL    WINAPI DrvExtFloodFill(HDC, int, int, COLORREF, UINT);
BOOL    WINAPI DrvExtTextOutA(HDC, int, int, UINT, LPRECT, LPSTR, UINT, LPINT);
BOOL    WINAPI DrvExtTextOutW(HDC, int, int, UINT, LPRECT, LPWSTR, UINT, LPINT);
BOOL    WINAPI DrvFillPath(HDC);
BOOL    WINAPI DrvFillRgn(HDC, HRGN, HBRUSH);
BOOL    WINAPI DrvFloodFill(HDC, int, int, COLORREF);
BOOL    WINAPI DrvFrameRgn(HDC, HRGN, HBRUSH, int, int);
BOOL    WINAPI DrvInvertRgn(HDC, HRGN);
BOOL    WINAPI DrvLineTo(HDC, int, int);
BOOL    WINAPI DrvPaintRgn(HDC, HRGN);
BOOL    WINAPI DrvPatBlt(HDC, int, int, int, int, DWORD);
BOOL    WINAPI DrvPie(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI DrvPlayEnhMetaFileRecord(HDC, LPHANDLETABLE, LPENHMETARECORD, DWORD);
BOOL    WINAPI DrvPlayMetaFile(HDC, HMETAFILE);
void    WINAPI DrvPlayMetaFileRecord(HDC, LPHANDLETABLE, METARECORD FAR*, UINT);
BOOL    WINAPI DrvPolyBezier(HDC, LPPOINT, UINT);
BOOL    WINAPI DrvPolyBezierTo(HDC, LPPOINT, UINT);
BOOL    WINAPI DrvPolygon(HDC, LPPOINT, int);
BOOL    WINAPI DrvPolyline(HDC, LPPOINT, int);
BOOL    WINAPI DrvPolylineTo(HDC, LPPOINT, int);
BOOL    WINAPI DrvPolyPolygon(HDC, LPPOINT, LPINT, int);
BOOL    WINAPI DrvPolyPolyline(DWORD, HDC, LPPOINT, LPINT, int);
BOOL    WINAPI DrvRectangle(HDC, int, int, int, int);
BOOL    WINAPI DrvRoundRect(HDC, int, int, int, int, int, int);
int     WINAPI DrvSetDIBitsToDevice(HDC, int, int, int, int, int, int, UINT, UINT,
                    LPVOID, LPBITMAPINFO, UINT);
COLORREF WINAPI DrvSetPixel(HDC, int, int, COLORREF);
BOOL    WINAPI DrvStretchBlt(HDC, int, int, int, int, HDC, int, int, int, int, DWORD);
int     WINAPI DrvStretchDIBits(HDC, int, int, int, int, int,
                        int, int, int, const void FAR*, LPBITMAPINFO, UINT, DWORD);
BOOL    WINAPI DrvStrokeAndFillPath(HDC);
BOOL    WINAPI DrvStrokePath(HDC);
BOOL    WINAPI DrvTextOutA(HDC, int, int, LPSTR, int);
BOOL    WINAPI DrvTextOutW(HDC, int, int, LPWSTR, int);
int     WINAPI DrvUpdateColors(HDC);

void    WINAPI DrvRealizeDefaultPalette(HDC);
DWORD   WINAPI DrvGDIRealizePalette(HDC);

UINT    WINAPI DrvCreateSpb(HDC, int, int);
BOOL    WINAPI DrvDeleteObject(HGDIOBJ);
LONG    WINAPI DrvSetBitmapBits(HBITMAP, DWORD, const void FAR*);
UINT    WINAPI DrvSetDIBColorTable(HDC, UINT, UINT, const RGBQUAD FAR*);
int     WINAPI DrvSetDIBits(HDC, HBITMAP, UINT, UINT, const void FAR*, BITMAPINFO FAR*, UINT);
BOOL    WINAPI DrvSysDeleteObject(HGDIOBJ);


BOOL    WINAPI DrvSetPointerShape(LPCURSORSHAPE lpcur);
BOOL    WINAPI DrvSaveBits(LPRECT lprc, UINT wSave);

UINT    WINAPI DrvDeath(HDC);
UINT    WINAPI DrvResurrection(HDC, DWORD, DWORD, DWORD);
LONG    WINAPI DrvWinOldAppHackoMatic(LONG flags);

LONG    WINAPI DrvChangeDisplaySettings(LPDEVMODE, DWORD);
LONG    WINAPI DrvChangeDisplaySettingsEx(LPCSTR, LPDEVMODE, HWND, DWORD, LPVOID);
BOOL    WINAPI DrvSignalProc32(DWORD, DWORD, DWORD, WORD);

void    WINAPI DrvMouseEvent(UINT regAX, UINT regBX, UINT regCX, UINT regDX,
                UINT regSI, UINT regDI);
void    WINAPI DrvKeyboardEvent(UINT regAX, UINT regBX, UINT regSI, UINT regDI);

//
// GetAsyncKeyState
// GetCursorPos
//
int     WINAPI DrvGetAsyncKeyState(int);
BOOL    WINAPI DrvGetCursorPos(LPPOINT);


//
// GDI STRUCTURES
//


typedef struct tagGDIHANDLE
{
    PBYTE       pGdiObj;        // If not swapped out, in GDI ds
                                // If swapped out, local32handle
    BYTE        objFlags;
} GDIHANDLE, FAR* LPGDIHANDLE;

#define OBJFLAGS_SWAPPEDOUT     0x40
#define OBJFLAGS_INVALID        0xFF



//
// More useful definition of RGNDATA
//

#define CRECTS_COMPLEX      32
#define CRECTS_MAX          ((0x4000 - sizeof(RDH)) / sizeof(RECTL))

//
// Keep RGNDATA <= 8K.  WE can get a larger region then combine areas if
// needed.
//
typedef struct tagRDH
{
    DWORD   dwSize;
    DWORD   iType;
    DWORD   nRectL;                 // Number of rect pieces
    DWORD   nRgnSize;
    RECTL   arclBounds;
}
RDH, FAR* LPRDH;


typedef struct tagREAL_RGNDATA
{
    RDH     rdh;
    RECTL   arclPieces[CRECTS_MAX];
}
REAL_RGNDATA, FAR* LPREAL_RGNDATA;



//
// DRAWMODE
//

typedef struct tagDRAWMODE
{
    int         Rop2;               // 16-bit encoded logical op
    int         bkMode;             // Background mode (for text only)
    DWORD       bkColorP;           // Physical background color
    DWORD       txColorP;           // Physical foreground (text) color
    int         TBreakExtra;        // Total pixels to stuff into a line
    int         BreakExtra;         // div(TBreakExtra, BreakCount)
    int         BreakErr;           // Running error term
    int         BreakRem;           // mod(TBreakExtra, BreakCount)
    int         BreakCount;         // Number of breaks in the line
    int         CharExtra;          // Extra pixels to stuff after each char
    DWORD       bkColorL;           // Logical background color
    DWORD       txColorL;           // Logical foreground color
    DWORD       ICMCXform;          // Transform for DIC image color matching
    int         StretchBltMode;     // Stretch blt mode
    DWORD       eMiterLimit;        // Miter limit (single precision IEEE float)
} DRAWMODE;
typedef DRAWMODE FAR * LPDRAWMODE;


typedef struct tagGDIOBJ_HEAD
{
    LOCALHANDLE ilhphOBJ;
    UINT        ilObjType;
    DWORD       ilObjCount;
    UINT        ilObjMetaList;
    UINT        ilObjSelCount;
    UINT        ilObjTask;
} GDIOBJ_HEAD;
typedef GDIOBJ_HEAD FAR* LPGDIOBJ_HEAD;



typedef struct tagDC
{
    GDIOBJ_HEAD     MrDCHead;
    BYTE            DCFlags;
    BYTE            DCFlags2;
    HMETAFILE       hMetaFile;
    HRGN            hClipRgn;
    HRGN            hMetaRgn;
    GLOBALHANDLE    hPDevice;   // Physical device handle

    HPEN            hPen;       // Current logical pen
    HBRUSH          hBrush;     // Current logical brush
    HFONT           hFont;      // Current logical font
    HBITMAP         hBitmap;    // Current logical bitmap
    HPALETTE        hPal;       // Current logical palette

    LOCALHANDLE     hLDevice;   // Logical device handle
    HRGN            hRaoClip;   // Intersection of clip regions
    LOCALHANDLE     hPDeviceBlock;    // DC phys instance data inc. GDIINFO
    LOCALHANDLE     hPPen;      // Current physical pen
    LOCALHANDLE     hPBrush;    // Current physical brush
    LOCALHANDLE     hPFontTrans;    // Current physical font transform
    LOCALHANDLE     hPFont;     // Current physical font

    LPBYTE          lpPDevice;  // Ptr to physical device or bitmap
    PBYTE           pLDeviceBlock;   // Near ptr to logical device block
    PBYTE           hBitBits;   // Handle of selected bitmap bits
    PBYTE           pPDeviceBlock;   // Near ptr to physical device block
    LPBYTE          lpPPen;     // Ptr to OEM pen data
    LPBYTE          lpPBrush;   // Ptr to OEM brush data
    PBYTE           pPFontTrans;    // Near ptr to text transform
    LPBYTE          lpPFont;        // Ptr to physical font
    UINT            nPFTIndex;  // PFT index for font/DEVICE_FONT

    POINT           Translate;
    DRAWMODE        DrawMode;

    HGLOBAL         hPath;
    UINT            fwPath;
    // ...
} DC;
typedef DC FAR* LPDC;


// 
// Values for DCFlags
//

#define DC_IS_MEMORY        0x01
#define DC_IS_DISPLAY       0x02
#define DC_HAS_DIRTYVISRGN  0x04
#define DC_IS_PARTIAL       0x80
#define DC_HAS_DIRTYFONT    0x40
#define DC_HAS_DIRTYPEN     0x20
#define DC_HAS_DIRTYCLIP    0x10

//
// Values for DCFlags2
//
#define DRAFTFLAG           0x01
#define ChkDispPal          0x02
#define dfFont              0x04
#define SimVectFont         0x08
#define deFont              0x10
#define TT_NO_DX_MOD        0x40    // DC is for Micrografx's metafile recorder
#define DC_DIB              0x80    // memory DC is now a DIB DC.

//
// Values for fwPath
//
#define DCPATH_ACTIVE       0x0001
#define DCPATH_SAVE         0x0002
#define DCPATH_CLOCKWISE    0x0004


//
// BRUSH structure
//
typedef struct tagBRUSH
{
    GDIOBJ_HEAD     ilObjHead;
    LOGBRUSH        ilBrushOverhead;        // lbHatch is the HGLOBAL of the bitmap
    HBITMAP         ilBrushBitmapOrg;
} BRUSH;
typedef BRUSH FAR* LPBRUSH;




#endif  // !_WINDDI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\awc.cpp ===
#include "precomp.h"


//
// AWC.CPP
// Active Window Coordinator
//
// Copyright(c) Microsoft 1997-
//
#define MLZ_FILE_ZONE  ZONE_CORE




//
// AWC_ReceivedPacket()
//
void  ASShare::AWC_ReceivedPacket
(
    ASPerson *      pasPerson,
    PS20DATAPACKET  pPacket
)
{
    PAWCPACKET      pAWCPacket;
    UINT            activateWhat;
    HWND            hwnd;

    DebugEntry(ASShare::AWC_ReceivedPacket);

    ValidatePerson(pasPerson);

    pAWCPacket = (PAWCPACKET)pPacket;

    //
    // We trace the person ID out here so we don't bother to do it
    // elsewhere in this function on TRACE lines.
    //
    TRACE_OUT(("AWC_ReceivedPacket from [%d] - msg %x token %u data 0x%08x",
                 pasPerson->mcsID,
                 pAWCPacket->msg,
                 pAWCPacket->token,
                 pAWCPacket->data1));

    switch (pAWCPacket->msg)
    {
        case AWC_MSG_SAS:
        {
            //
            // Cause Ctrl+Alt+Del to be injected if we're in a service app,
            // we're hosting, and we're controlled by the sender.
            //
            if ((g_asOptions & AS_SERVICE) && (pasPerson->m_caInControlOf == m_pasLocal))
            {
                ASSERT(m_pHost);
                OSI_InjectCtrlAltDel();
            }
            break;
        }
    }

    DebugExitVOID(ASShare::AWC_ReceivedPacket);
}




//
// FUNCTION: AWC_SendMsg
//
// DESCRIPTION:
//
// Sends a AWC message to remote system
//      * Requests to activate are just to one host
//      * Notifications of activation are to everyone
//
// RETURNS: TRUE or FALSE - success or failure
//
//
BOOL  ASShare::AWC_SendMsg
(
    UINT            nodeID,
    UINT            msg,
    UINT            data1,
    UINT            data2
)
{

    PAWCPACKET      pAWCPacket;
    BOOL            rc = FALSE;
#ifdef _DEBUG
    UINT            sentSize;
#endif

    DebugEntry(ASShare::AWC_SendMsg);

    //
    // Allocate correct sized packet.
    //
    pAWCPacket = (PAWCPACKET)SC_AllocPkt(PROT_STR_UPDATES, nodeID, sizeof(AWCPACKET));
    if (!pAWCPacket)
    {
        WARNING_OUT(("Failed to alloc AWC packet"));
        DC_QUIT;
    }

    //
    // Set up the data header for an AWC message.
    //
    pAWCPacket->header.data.dataType = DT_AWC;

    //
    // Now set up the AWC fields.  By passing AWC_SYNC_MSG_TOKEN in the
    // token field, we ensure that back-level remotes will never drop our
    // packets.
    //
    pAWCPacket->msg     = (TSHR_UINT16)msg;
    pAWCPacket->data1   = data1;
    pAWCPacket->data2   = data2;
    pAWCPacket->token   = 0;

    //
    // Send the packet.
    //
    if (m_scfViewSelf)
        AWC_ReceivedPacket(m_pasLocal, &(pAWCPacket->header));

#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    DCS_CompressAndSendPacket(PROT_STR_UPDATES, nodeID,
        &(pAWCPacket->header), sizeof(*pAWCPacket));

    TRACE_OUT(("AWC packet size: %08d, sent: %08d", sizeof(*pAWCPacket), sentSize));

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(ASShare::AWC_SendMsg, rc);
    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\ba.cpp ===
#include "precomp.h"


//
// BA.CPP
// Bounds Accumulator
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE



//
// BA_SyncOutgoing()
// Reset rect count
//
void ASHost::BA_SyncOutgoing(void)
{
    DebugEntry(ASHost::BA_SyncOutgoing);

    m_baNumRects = 0;

    DebugExitVOID(ASHost::BA_SyncOutgoing);
}



//
// BA_AddRect()
//
void  ASHost::BA_AddRect(LPRECT pRect)
{
    DebugEntry(ASHost::BA_AddRect);

    //
    // Make sure that we don't have too many rects
    //
    if (m_baNumRects >= BA_NUM_RECTS)
    {
        ERROR_OUT(( "Too many rectangles"));
        DC_QUIT;
    }

    //
    // Check that the caller has passed a valid rectangle.  If not, do a
    // trace alert, and then return immediately (as an invalid rectangle
    // shouldn't contribute to the accumulated bounds) - but report an OK
    // return code, so we keep running.
    //
    if ((pRect->right < pRect->left) ||
        (pRect->bottom < pRect->top))
    {
        WARNING_OUT(("BA_AddRect: empty rect {%04d, %04d, %04d, %04d}",
                   pRect->left,
                   pRect->top,
                   pRect->right,
                   pRect->bottom ));
        DC_QUIT;
    }

    //
    // Add the rect to the bounds.
    //
    m_abaRects[m_baNumRects++] = *pRect;

DC_EXIT_POINT:
    DebugExitVOID(ASHost::BA_AddRect);
}



//
// BA_QueryAccumulation()
//
UINT  ASHost::BA_QueryAccumulation(void)
{
    UINT totalSDA;
    LPBA_FAST_DATA lpbaFast;

    DebugEntry(ASHost::BA_QueryAccumulation);

    lpbaFast = BA_FST_START_WRITING;

    //
    // Get the current setting and clear the previous one.
    //
    totalSDA = lpbaFast->totalSDA;
    lpbaFast->totalSDA = 0;

    BA_FST_STOP_WRITING;

    DebugExitDWORD(ASHost::BA_QueryAccumulation, totalSDA);
    return(totalSDA);
}



//
//
// BA_FetchBounds()
//
//
void  ASHost::BA_FetchBounds(void)
{
    BA_BOUNDS_INFO  boundsInfo;
    UINT          i;

    DebugEntry(ASHost::BA_FetchBounds);

    //
    // Clear our copy of the bounds
    //
    m_baNumRects = 0;


    //
    // Get the driver's latest bounds rects
    //
    OSI_FunctionRequest(BA_ESC_GET_BOUNDS,
                        (LPOSI_ESCAPE_HEADER)&boundsInfo,
                        sizeof(boundsInfo));

    //
    // Add the driver's bounds into our array
    //
    TRACE_OUT(( "Retreived %d rects from driver", boundsInfo.numRects));

    for (i = 0; i < boundsInfo.numRects; i++)
    {
        TRACE_OUT(( "Rect %d, (%d, %d) (%d, %d)",
                     i,
                     boundsInfo.rects[i].left,
                     boundsInfo.rects[i].top,
                     boundsInfo.rects[i].right,
                     boundsInfo.rects[i].bottom));
        BA_AddRect((LPRECT)&boundsInfo.rects[i]);
    }

    DebugExitVOID(ASHost::BA_FetchBounds);
}


//
// BA_ReturnBounds()
//
void  ASHost::BA_ReturnBounds(void)
{
    BA_BOUNDS_INFO  boundsInfo;

    DebugEntry(ASHost::BA_ReturnBounds);

    //
    // Copy the share core's bounds into the structure which we pass to the
    // driver.  This will also clear the share core's copy of the bounds.
    //
    BA_CopyBounds((LPRECT)boundsInfo.rects, (LPUINT)&boundsInfo.numRects, TRUE);

    //
    // Now set up for, and then call into the driver to fetch the driver's
    // bounds.
    //
    TRACE_OUT(( "Passing %d rects to driver", boundsInfo.numRects));
    OSI_FunctionRequest(BA_ESC_RETURN_BOUNDS,
                        (LPOSI_ESCAPE_HEADER)&boundsInfo,
                        sizeof(boundsInfo));

    DebugExitVOID(ASHost::BA_ReturnBounds);
}




//
// BA_CopyBounds()
//
void  ASHost::BA_CopyBounds(LPRECT pRects, LPUINT pNumRects, BOOL fReset)
{
    DebugEntry(ASHost::BA_CopyBounds);

    if (*pNumRects = m_baNumRects)
    {
        TRACE_OUT(( "num rects : %d", m_baNumRects));

        memcpy(pRects, m_abaRects, m_baNumRects * sizeof(RECT));

        if (fReset)
        {
            m_baNumRects = 0;
        }
    }

    DebugExitVOID(ASHost::BA_CopyBounds);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\asmaster.cpp ===
#include "precomp.h"

#include <RegEntry.h>
#include <asmaster.h>

#define MLZ_FILE_ZONE  ZONE_CORE


ASMaster *g_pMaster = NULL;



HRESULT WINAPI CreateASObject
(
    IAppSharingNotify * pNotify,
    UINT                flags,
    IAppSharing**       ppAS
)
{
    HRESULT             hr  = E_OUTOFMEMORY;
    ASMaster *          pMaster = NULL;

    DebugEntry(CreateASObject);

    ASSERT(ppAS);

    if (g_pMaster != NULL)
    {
        ERROR_OUT(("CreateASObject:  IAppSharing * alreadycreated; only one allowed at a time"));
        hr = E_UNEXPECTED;
        DC_QUIT;
    }

    ASSERT(!g_asMainThreadId);
    ASSERT(!g_putAS);


    pMaster = new ASMaster(flags, pNotify);
    if (pMaster != NULL)
    {
        //
        // Register as the groupware primary, with an event proc but no exit proc
        //
        if (!UT_InitTask(UTTASK_UI, &g_putUI))
        {
            ERROR_OUT(("Failed to register UI task"));
            DC_QUIT;
        }

        UT_RegisterEvent(g_putUI, eventProc, g_putUI, UT_PRIORITY_NORMAL);

        // Start groupware thread.
        if (!DCS_StartThread(WorkThreadEntryPoint))
        {
            ERROR_OUT(("Couldn't start groupware thread"));
            DC_QUIT;
        }

        // Make sure the work thread initialization is ok
        if (! g_asMainThreadId)
        {
            ERROR_OUT(("Init failed in the work thread"));
            DC_QUIT;
        }

        //
        // Success!
        //
    }

    hr = S_OK;

DC_EXIT_POINT:
    if (!SUCCEEDED(hr))
    {
        if (pMaster)
        {
            ERROR_OUT(("CreateASObject:  Init of ASMaster failed"));
            pMaster->Release();
            pMaster = NULL;
        }
    }

    *ppAS = pMaster;
    DebugExitHRESULT(CreateASObject, hr);
    return hr;
}


ASMaster::ASMaster(UINT flags, IAppSharingNotify * pNotify) :
    m_cRefs              (1),
    m_pNotify            (pNotify)
{
    DebugEntry(ASMaster::ASMaster);

    if (m_pNotify)
    {
        m_pNotify->AddRef();
    }

    ASSERT(!g_pMaster);
    g_pMaster = this;

    //
    // Set up global flags:
    //      * service
    //      * unattended
    //
    g_asOptions = flags;

    DebugExitVOID(ASMaster::ASMaster);
}


ASMaster::~ASMaster()
{
    DebugEntry(ASMaster::~ASMaster);

    //
    // Kill any share that's current or pending in the queue
    // This will do nothing if no share is extant at the time the
    // message is received.
    //
    if (g_asMainWindow)
    {
        PostMessage(g_asMainWindow, DCS_KILLSHARE_MSG, 0, 0);
    }

    //
    // Kill off the worker thread
    //
    if (g_asMainThreadId)
    {
        PostThreadMessage(g_asMainThreadId, WM_QUIT, 0, 0);
    }

    //
    // Clean up the UI
    //
    if (g_putUI)
    {
        UT_TermTask(&g_putUI);
    }

    // global variables cleanup
    if (m_pNotify)
    {
        m_pNotify->Release();
        m_pNotify = NULL;
    }

    if (g_pMaster == this)
    {
        g_pMaster = NULL;
    }

    DebugExitVOID(ASMaster::~ASMaster);
}



STDMETHODIMP ASMaster::QueryInterface(REFIID iid, void ** pv)
{
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) ASMaster::AddRef()
{
    InterlockedIncrement(&m_cRefs);
    return m_cRefs;
}

STDMETHODIMP_(ULONG) ASMaster::Release()
{
    ASSERT(m_cRefs > 0);
    if (::InterlockedDecrement(&m_cRefs) == 0)
    {
        delete this;
        return 0;
    }

    return m_cRefs;
}




//
// WorkThreadEntryPoint()
//
// This is the groupware code--obman, taskloader, and app sharing
//

DWORD WINAPI WorkThreadEntryPoint(LPVOID hEventWait)
{
    BOOL            result = FALSE;
    BOOL            fCMGCleanup = FALSE;
    BOOL            fDCSCleanup = FALSE;
    MSG             msg;
    HWND            hwndTop;

    DebugEntry(WorkThreadEntryPoint);

    //
    // Get the current thread ID.  This is used in the stop code to know
    // if the previous thread is still exiting.  In the run-when-windows
    // starts mode, our init code is called when Conf brings up UI and our
    // term code is called when Conf brings it down.  We have a race condition
    // because this thread is created on each init.  If we create a new
    // one while the old one is exiting, we will stomp over each other and
    // GP-fault.
    //
    g_asMainThreadId = GetCurrentThreadId();

    //
    // Get our policies
    //


    // Register the call primary code, for T.120 GCC
    if (!CMP_Init(&fCMGCleanup))
    {
        ERROR_OUT(("CMP_Init failed"));
        DC_QUIT;
    }

    //
    // Do DCS fast init; slow font enum will happen later off a posted
    // message.  We can still share & participate in sharing without a
    // full font list...
    //
    fDCSCleanup = TRUE;
    if (!DCS_Init())
    {
        ERROR_OUT(("AS did not initialize"));
        DC_QUIT;
    }

    //
    // We've successfully initialised - let the thread which created this
    // one continue
    //
    SetEvent((HANDLE)hEventWait);


    //
    // Enter the main message processing loop:
    //

    while (GetMessage(&msg, NULL, 0, 0))
    {
        //
        // For dialogs, it's OK to do normal message processing.
        //
        if (hwndTop = IsForDialog(msg.hwnd))
        {
            if (!IsDialogMessage(hwndTop, &msg))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
        else
        {
            //
            // Note that this message dispatch loop DOES NOT include a call to
            // Translate Message.  This is because we do not want it to call
            // ToAscii and affect the state maintained internally by ToAscii.
            // We will call ToAscii ourselves in the IM when the user is typing
            // in a view and calling it more than once for a keystroke
            // will cause it to return wrong results (eg for dead keys).
            //
            // The consequence of this is that any windows which are driven by
            // this dispatch loop will NOT receive WM_CHAR or WM_SYSCHAR
            // messages.  This is not a problem for dialog windows belonging to
            // a task using this message loop as the dialog will run its own
            // dispatch loop.
            //
            // If it becomes necessary for windows driven by this dispatch loop
            // to get their messages translated then we could add logic to
            // determine whether the message is destined for a view
            // before deciding whether to translate it.
            //

            //
            // Because we don't have a translate message in our message loop we
            // need to do the following to ensure the keyboard LEDs follow what
            // the user does when their input is going to this message loop.
            //
            if (((msg.message == WM_KEYDOWN) ||
                 (msg.message == WM_SYSKEYDOWN) ||
                 (msg.message == WM_KEYUP) ||
                 (msg.message == WM_SYSKEYUP)) &&
                IM_KEY_IS_TOGGLE(msg.wParam))
            {
                BYTE        kbState[256];

                //
                // There is a chance the LEDs state has changed so..
                //
                GetKeyboardState(kbState);
                SetKeyboardState(kbState);
            }

            DispatchMessage(&msg);
        }
   }

   result = (int)msg.wParam;

   //
   // We emerge from the processing loop when someone posts us a WM_QUIT.
   // We do ObMan specific termination then call UT_TermTask (which will
   // call any exit procedures we have registered).
   //

DC_EXIT_POINT:

    if (fDCSCleanup)
        DCS_Term();

    if (fCMGCleanup)
        CMP_Term();

    g_asMainThreadId = 0;

    DebugExitDWORD(WorkThreadEntryPoint, result);
    return(result);
}



//
// IsForDialog()
// Returns if the message is intended for a window in a dialog.  AppSharing
// has the host UI dialog, incoming request dialogs, and possibly
// notification message box dialogs.
//
HWND IsForDialog(HWND hwnd)
{
    BOOL    rc = FALSE;
    HWND    hwndParent;

    DebugEntry(IsForDialog);

    if (!hwnd)
        DC_QUIT;

    while (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
    {
        hwndParent = GetParent(hwnd);
        if (hwndParent == GetDesktopWindow())
            break;

        hwnd = hwndParent;
    }

    if (GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_DLGMODALFRAME)
    {
        // This is a dialog
    }
    else
    {
        hwnd = NULL;
    }

DC_EXIT_POINT:
    DebugExitPTR(IsForDialog, hwnd);
    return(hwnd);
}


//
// ASMaster member functions
//
//



//
//
// ASMaster::OnEvent
//
// Parameters: event    event type
//             param1   other parameter
//             param2   other parameter
//
//



BOOL CALLBACK eventProc
(
    LPVOID  cpiHandle_,
    UINT    event,
    UINT_PTR param1,
    UINT_PTR param2
)
{
    BOOL    rc;

    if (g_pMaster)
    {
        rc = g_pMaster->OnEvent(event, param1, param2);
    }
    else
    {
        WARNING_OUT(("Received ASMaster event %d but no g_pMaster", event));
        rc = FALSE;
    }

    return rc;
}



BOOL ASMaster::OnEvent
(
    UINT    event,
    UINT_PTR param1,
    UINT_PTR param2
)
{
    BOOL    rc = TRUE;

    DebugEntry(ASMaster::OnEvent);

    if (!m_pNotify)
    {
        // Nothing to do
        rc = FALSE;
        DC_QUIT;
    }

    switch (event)
    {
        case SH_EVT_APPSHARE_READY:
            m_pNotify->OnReadyToShare(param1 != 0);
            break;

        case SH_EVT_SHARE_STARTED:
            m_pNotify->OnShareStarted();
            break;

        case SH_EVT_SHARING_STARTED:
            m_pNotify->OnSharingStarted();
            break;

        case SH_EVT_SHARE_ENDED:
            m_pNotify->OnShareEnded();
            break;

        case SH_EVT_PERSON_JOINED:
            m_pNotify->OnPersonJoined((IAS_GCC_ID)param1);
            break;

        case SH_EVT_PERSON_LEFT:
            m_pNotify->OnPersonLeft((IAS_GCC_ID)param1);
            break;

        case SH_EVT_STARTINCONTROL:
            m_pNotify->OnStartInControl((IAS_GCC_ID)param1);
            break;

        case SH_EVT_STOPINCONTROL:
            m_pNotify->OnStopInControl((IAS_GCC_ID)param1);
            break;

        case SH_EVT_CONTROLLABLE:
            m_pNotify->OnControllable(param1 != 0);
            break;

        case SH_EVT_STARTCONTROLLED:
            m_pNotify->OnStartControlled((IAS_GCC_ID)param1);
            break;

        case SH_EVT_STOPCONTROLLED:
            m_pNotify->OnStopControlled((IAS_GCC_ID)param1);
            break;

        default:
            // Unrecognized, unhandled event
            rc = FALSE;
            break;
    }

DC_EXIT_POINT:
    DebugExitBOOL(ASMaster::OnEvent, rc);
    return(rc);
}


//
// ASMaster::IsSharingAvailable()
//
STDMETHODIMP_(BOOL) ASMaster::IsSharingAvailable()
{
    return(g_asCanHost);
}



//
// ASMaster::CanShareNow()
//
STDMETHODIMP_(BOOL) ASMaster::CanShareNow()
{
    BOOL    rc = FALSE;

    UT_Lock(UTLOCK_AS);

    //
    // We can share if
    //      * We can capture graphic output on this OS
    //      * We're in a call
    //
    if (g_asCanHost    &&
        g_asSession.callID         &&
        (g_s20State >= S20_NO_SHARE))
    {
        rc = TRUE;
    }

    UT_Unlock(UTLOCK_AS);

    return(rc);
}


//
// ASMaster::InInShare()
//
STDMETHODIMP_(BOOL) ASMaster::IsInShare()
{
    return(g_asSession.pShare != NULL);
}


//
// ASMaster::IsSharing()
//
STDMETHODIMP_(BOOL) ASMaster::IsSharing()
{
    IAS_PERSON_STATUS personStatus;

    ::ZeroMemory(&personStatus, sizeof(personStatus));
    personStatus.cbSize = sizeof(personStatus);
    GetPersonStatus(0, &personStatus);

    return(personStatus.AreSharing != 0);
}


//
// CanAllowControl()
// We can allow control if we're sharing and it's not prevented by policy
//
STDMETHODIMP_(BOOL) ASMaster::CanAllowControl(void)
{
    return(IsSharing());
}


//
// IsControllable()
// We are controllable if our state isn't detached.
//
STDMETHODIMP_(BOOL) ASMaster::IsControllable(void)
{
    IAS_PERSON_STATUS personStatus;

    ::ZeroMemory(&personStatus, sizeof(personStatus));
    personStatus.cbSize = sizeof(personStatus);
    GetPersonStatus(0, &personStatus);

    return(personStatus.Controllable != 0);
}



//
// GetPersonStatus()
//
STDMETHODIMP ASMaster::GetPersonStatus(IAS_GCC_ID Person, IAS_PERSON_STATUS * pStatus)
{
    return(::SHP_GetPersonStatus(Person, pStatus));
}




//
//
// ASMaster::ShareDesktop
//
//
STDMETHODIMP ASMaster::ShareDesktop(void)
{
    HRESULT     hr;

    DebugEntry(ASMaster::ShareDesktop);

    hr = E_FAIL;

    if (!CanShareNow())
    {
        WARNING_OUT(("Share failing; can't share now"));
        DC_QUIT;
    }

    if (SHP_ShareDesktop())
    {
        hr = S_OK;
    }

DC_EXIT_POINT:
    DebugExitHRESULT(ASMaster::ShareDesktop, hr);
    return hr;
}


//
//
// ASMaster::UnshareDesktop
//
// Parameters: HWND of the window to unshare
//
//
STDMETHODIMP ASMaster::UnshareDesktop(void)
{
    return(::SHP_UnshareDesktop());
}



//
// TakeControl()
//
// From viewer to host, asking to take control of host.
//
STDMETHODIMP ASMaster::TakeControl(IAS_GCC_ID PersonOf)
{
    return(SHP_TakeControl(PersonOf));
}



//
// CancelTakeControl()
//
// From viewer to host, to cancel pending TakeControl request.
//
STDMETHODIMP ASMaster::CancelTakeControl(IAS_GCC_ID PersonOf)
{
    return(SHP_CancelTakeControl(PersonOf));
}


//
// ReleaseControl()
//
// From viewer to host, telling host that viewer is not in control of host
// anymore.
//
STDMETHODIMP ASMaster::ReleaseControl(IAS_GCC_ID PersonOf)
{
    return(SHP_ReleaseControl(PersonOf));
}


//
// PassControl()
//
// From viewer to host, when viewer is in control of host, asking to pass
// control of host to a different viewer.
STDMETHODIMP ASMaster::PassControl(IAS_GCC_ID PersonOf, IAS_GCC_ID PersonTo)
{
    return(SHP_PassControl(PersonOf, PersonTo));
}


//
// AllowControl()
//
// On host side, to allow/stop allowing control at all of shared apps/desktop.
// When one starts to host, allowing control always starts as off.  So
// turning on allowing control, stopping sharing, then sharing something
// else will not leave host vulnerable.
//
// When turning it off, if a viewer was in control of the host, kill control
// from the host to the viewer will occur first.
//
// The "ESC" key is an accelerator to stop allowing control, when pressed
// by the user on the host who is currently controlled.
//
STDMETHODIMP ASMaster::AllowControl(BOOL fAllow)
{
    return(::SHP_AllowControl(fAllow));
}



//
// GiveControl()
//
// From host to viewer, inviting the viewer to take control of the host.
// It's the inverse of TakeControl.
//
STDMETHODIMP ASMaster::GiveControl(IAS_GCC_ID PersonTo)
{
    return(SHP_GiveControl(PersonTo));
}



//
// CancelGiveControl()
//
// From host to viewer, to cancel pending GiveControl request
//
STDMETHODIMP ASMaster::CancelGiveControl(IAS_GCC_ID PersonTo)
{
    return(SHP_CancelGiveControl(PersonTo));
}


//
// RevokeControl()
//
// From host to viewer, when host wishes to stop viewer from controlling him.
// AllowControl is still on, for another to possibly take control of the host.
//
// Mouse clicks and key presses other than "ESC" by the user on the controlled
// host host areaccelerators to kill control.
//
STDMETHODIMP ASMaster::RevokeControl(IAS_GCC_ID PersonTo)
{
    return(SHP_RevokeControl(PersonTo));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\as16\ut.asm ===
;
; UT.ASM
; Tracing goop, debug only
; Mouse/Keyboard event interrupt junk, all flavors
;


.386
option oldstructs
option readonly
option segment:use16
.model large,pascal

ifdef DEBUG
externDef   _wsprintf:far16
externDef   OutputDebugString:far16
externDef   DebugBreak:far16
endif ; DEBUG

externDef   DrvMouseEvent:far16
externDef   DrvKeyboardEvent:far16
externDef   mouse_event:far16
externDef   keybd_event:far16
externDef   MaphinstLS:far16

.data

ifdef DEBUG
externDef   g_szDbgBuf:word
externDef   g_szNewline:word
externDef   g_dbgRet:word
externDef   g_trcConfig:word
endif ; DEBUG

if 0
; DOS key redirection
externDef   g_imDOSShellVDDEntry:dword
externDef   g_imDOSVKDEntry:dword
endif

.code _TEXT


ifdef DEBUG

;
; We come in here with _cdecl var args.  We use DebugOutput() to spit out
; the message.  Then we do the debugbreak ourself.
;
_DbgZPrintWarning   proc    near
    ; Save IP of caller.  What's left on stack is var args
    pop     [g_dbgRet]   ; Save IP of output caller

    ; Push g_szDbgBuf to put result into.
    push    ds
    push    offset g_szDbgBuf

    ; We now have _cdecl args to wsprintf
    call    _wsprintf

    ;
    ; The same args are left on the stack, since wsprintf is _cdecl.  The
    ; first is g_szDbgBuf.  So we can convienently pass this to OutputDebugString().
    ; That routine is NOT _cdecl, so when it returns, we have exactly the
    ; same args that were passed in to us.
    ;
    call    OutputDebugString

    ; Now output a new line
    push    ds
    push    offset g_szNewline
    call    OutputDebugString

    ; Now we just need to do a near RET to the caller
    push    [g_dbgRet]
    ret
_DbgZPrintWarning   endp


;
; We come in here with _cdecl var args
;
_DbgZPrintTrace     proc    near
    ; Is tracing on?
    test    [g_trcConfig],  0001h
    jnz     _DbgZPrintWarning
    ret
_DbgZPrintTrace     endp



_DbgZPrintError     proc    near
    ; Save IP of caller.  What's left on stack is var args
    pop     [g_dbgRet]   ; Save IP of output caller

    ; Push g_szDbgBuf to put result into.
    push    ds
    push    offset g_szDbgBuf

    ; We now have _cdecl args to wsprintf
    call    _wsprintf

    ;
    ; The same args are left on the stack, since wsprintf is _cdecl.  The
    ; first is g_szDbgBuf.  So we can convienently pass this to OutputDebugString().
    ; That routine is NOT _cdecl, so when it returns, we have exactly the
    ; same args that were passed in to us.
    ;
    call    OutputDebugString

    ; Now output a new line
    push    ds
    push    offset g_szNewline
    call    OutputDebugString


    ; Break into the debugger
    call    DebugBreak

    ; Now we just need to do a near RET to the caller
    push    [g_dbgRet]
    ret
_DbgZprintError     endp

endif



;
; ASMMouseEvent()
; This passes the registers as parameters to a C function, DrvMouseEvent.
; It is basically the inverse of CallMouseEvent().
;
; NOTE:
; To be on the safe side, we preserve all registers just like keybd_event().
; USER trashes some registers, but it would not come as a surprise to find
; mouse drivers that expect incorrectly a register or two to not be
; altered.
;
ASMMouseEvent   proc    far

    ; Save registers that C code doesn't preserve
    push    eax
    push    ebx
    push    ecx
    push    edx

    ; Save original flags for turning ints off/on
    pushf

    ; Push AX for DrvMouseEvent() call
    push    ax

    ; Do we need to turn interrupts off?  We don't if they are already
    pushf
    pop     ax
    test    ax, 0200h
    jz      SkipCli
    cli
SkipCli:

    ; AX has already been pushed; push the rest of the parameters
    push    bx
    push    cx
    push    dx
    push    si
    push    di
    cld
    call    DrvMouseEvent

    ; If interrupts were not disabled before, enable them now.
    pop     cx      ; saved flags
    pushf
    pop     ax      ; current flags

    ; Find out what is different
    xor     ax, cx
    test    ax, 0200h
    jz      InterruptsOk

    ; The interrupt flag needs to be changed, do it
    test    cx, 0200h
    jnz     EnableInterrupts
    cli
    jmp     InterruptsOk

EnableInterrupts:
    sti

InterruptsOk:
    ; Does the direction flag need to be changed?
    test    ax, 0400h
    jz      DirectionOk

    ; The direction flag needs to be changed, do it
    test    cx, 0400h
    jnz     SetDirectionFlag
    cld
    jmp     DirectionOk

SetDirectionFlag:
    std

DirectionOk:
    ; Restore registers
    pop     edx
    pop     ecx
    pop     ebx
    pop     eax

    retf
ASMMouseEvent   endp



;
; CallMouseEvent()
; This puts the parameters into registers and calls the original mouse_event.
;
; There are two ways we can call this function:
;   (1) Injection code is piping mouse events through USER.  It is 
; responsible for disabling/enabling interrupts before calling us.
;   (2) mouse_event patch is calling through to USER.
;
CallMouseEvent      proc    near
    ;
    ; This is the stack, BP relative:
    ;       WORD    bpSave
    ;       WORD    near_ret
    ;       WORD    regDI
    ;       WORD    regSI
    ;       WORD    regDX
    ;       WORD    regCX
    ;       WORD    regBX
    ;       WORD    regAX
    ;
    ; We must preserve SI and DI
    ;
    push    bp
    mov     bp, sp
    push    si
    push    di

    mov     di, word ptr ss:[bp+4]
    mov     si, word ptr ss:[bp+6]
    mov     dx, word ptr ss:[bp+8]
    mov     cx, word ptr ss:[bp+10]
    mov     bx, word ptr ss:[bp+12]
    mov     ax, word ptr ss:[bp+14]

    call    mouse_event

    pop     di
    pop     si
    mov     sp, bp
    pop     bp
    ret     6*2
CallMouseEvent      endp


;
; ASMKeyboardEvent()
; This passes the registers as parameters to a C function, DrvKeyboardEvent.
; It is basically the inverse of CallKeyboardEvent().
;
; NOTE:
; keybd_event() MUST preserve all registers, unlike mouse_event().
;
ASMKeyboardEvent    proc    far

    ; Save flags and registers that aren't preserved in C code
    push    eax
    push    ebx
    push    ecx
    push    edx
    pushf

    ; Push AX for DrvKeyboardEvent() call
    push    ax

    ; Check if interrupts off, w/o trashing CX permanently
    pushf
    pop     ax
    test    ax, 0200h
    jz      SkipCli
    cli
SkipCli:

    ; AX has already been pushed; push the rest of the parameters
    push    bx
    push    si
    push    di
    cld
    call    DrvKeyboardEvent

    ;
    ; Restore the interrupt and string move direction flags to what they
    ; were before.
    ;
    pop     cx      ; Original flags
    pushf
    pop     ax      ; Current flags

    ; What has changed?
    xor     ax, cx

    ; Has the interrupt state been altered?
    test    ax, 0200h
    jz      InterruptsOk

    ; Interrupts need to be turned on/off
    test    cx, 0200h
    jnz     EnableInterrupts
    cli
    jmp     InterruptsOk

EnableInterrupts:
    sti

InterruptsOk:
    ; Has the direction flag been altered?
    test    ax, 0400h
    jz      DirectionOk

    ; Direction flag needs to be set/cleared
    test    cx, 0400h
    jnz     SetDirection
    cld
    jmp     DirectionOk

SetDirection:
    std

DirectionOk:
    ; Restore registers
    pop     edx
    pop     ecx
    pop     ebx
    pop     eax

    retf
ASMKeyboardEvent    endp



;
; CallKeyboardEvent()
; This puts the parameters in registers and calls USER's keybd_event.
;
; There are two ways we can call this function:
;   (1) Injection code is piping keybd events through USER.  It is 
; responsible for disabling/enabling interrupts before calling us.
;   (2) keybd_event patch is calling through to USER.
;
CallKeyboardEvent   proc    near
    ;
    ; This is the stack, BP relative:
    ;       WORD    bpSave
    ;       WORD    near_ret
    ;       WORD    regDI
    ;       WORD    regSI
    ;       WORD    regBX
    ;       WORD    regAX
    ;
    ; We must preserve SI and DI
    ;
    push    bp
    mov     bp, sp
    push    si
    push    di

    mov     di, word ptr ss:[bp+4]
    mov     si, word ptr ss:[bp+6]
    mov     bx, word ptr ss:[bp+8]
    mov     ax, word ptr ss:[bp+10]

    call    keybd_event

    pop     di
    pop     si
    mov     sp, bp
    pop     bp
    ret     4*2
CallKeyboardEvent   endp


;
; This is our wrapper around krnl386's MaphinstLS() routine, which expects
; the 32-bit instance handle in EAX
;
MapInstance32   proc    far
    ; Pop far return, pop 32-bit instance into eax, and replace far return
    pop     edx
    pop     eax
    push    edx

    ; Call krnl386 -- when MaphinstLS returns, it will return to our caller
    jmp     MaphinstLS
MapInstance32   endp



if 0
;
; DOS box key injection gunk.  We use the shell vdd service.
;

IMGetDOSShellVDDEntry   proc    near
    ; Save DI, int2f will trash it
    push    di

    ; int2f 0x1684, vdd 0x0017 (shell) gets the service entry point
    ; It is returned in es:di
    mov     ax, 1684h
    mov     bx, 017h
    int     2F

    ; Save the address (even if null)
    mov     word ptr ds:[g_imDOSShellVDDEntry], di
    mov     word ptr ds:[g_imDOSShellVDDEntry+2], es

    pop     di
    ret
IMGetDOSShellVDDEntry   endp


IMGetDOSVKDEntry        proc    near
    ; Save DI, int2f will trash it
    push    di

    ; int2f 0x1684, vkd 0x000d (vkd) gets the service entry point
    ; It is returned in es:di
    mov     ax, 1684h
    mov     bx, 00dh
    int     2Fh

    mov     word ptr ds:[g_imDOSVKDEntry], di
    mov     word ptr ds:[g_imDOSVKDEntry+1], es

    pop     di
    ret
IMGetDOSVKDEntry    endp



IMForceDOSKey           proc    near
    ; ss:[sp]   is  near ret
    ; ss:[sp+2] is  scanCode
    ; ss:[sp+4] is  keyState

    push    bp
    mov     bp, sp

    ; Preserve extended registers
    push    ebx
    push    ecx
    push    edx

    ; Setup for VKD call
    mov     eax, 1                      ; Service 1, stuff key
    xor     ebx, ebx                    ; VM 0, current VM
    movzx   ecx, word ptr ss:[bp+4]     
    shl     ecx, 8                      ; Scan code in high byte
    or      ecx, 1                      ; Repeat count in low byte
    movzx   edx, word ptr ss:[bp+6]     ; Shift state

    call    dword ptr ds:[g_imDOSVKDEntry]
    mov     ax, 0
    
    ; Failure?
    jc      DoneForceKey
    
    ; Success!
    inc     ax

DoneForceKey:
    pop     edx
    pop     ecx
    pop     ebx

    mov     sp, bp
    pop     bp

    ret     2+2
IMForceDOSKey       endp

endif ; if 0 for DOS key redirection

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\bcd.cpp ===
#include "precomp.h"


//
// BCD.CPP
// Bitmap Compression-Decompression
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_ORDER

//
// Introduction
//
// These functions take a bitmap and encode it according to the codes
// defined in bcd.h.  Although there are some complexities in the
// encoding (particularly with the "sliding palette" encoding for
// compressing 8 bit down to 4 bit) the encodings should be self
// explanatory.  bcd describes some nuances of the encoding scheme.
//
// The important thing to note is that, when used in conjunction with a
// dictionary based compression scheme the objective of this function is
// not to minimize the output but to "prime" it such that the GDC can
// perform faster and more effectively on the data.
//
// Specifically we must NOT encode short runs in the data, even though we
// know that they reduce the output from this stage, as they will
// invariably reduce the efficiency of the GDC compression by a greater
// factor!  The break even point seems to be about a 5/6 byte run.  To
// illustrate this, consider the following run
// xxxxyyyyyxxxyyyxxxxxyyyyyyxxxyyyxxxxyyy We would encode this as
// 4x5y3x3y5x5y3x3y4x3y The compression factor is only *2 and yet the
// output data is now much more random - the tokenized look of the input
// has been lost.
//
// Encodings that are not context independent are particularly bad.  A FG
// run in one position may become a SET+FG run in another position, thus
// "randomizing" the data.
//
// Bottom line is that all of the apparently arbitrary numbers below have
// been carefully tuned to prep the data for input to GDC.  Screwing them
// down does increase the compression of this stage in some cases by as
// much as 20%, but loses about 20% post GDC.  Frustrating!  Be warned.
//
//



//
// BCD_ShareStarting()
// Creates resources needed for bitmap compression/decompression
//
BOOL  ASShare::BCD_ShareStarting(void)
{
    BOOL    rc = FALSE;

    DebugEntry(ASShare::BCD_ShareStarting);

    // Allocate BCD scratch buffers
    m_abNormal = new BYTE[BCD_NORMALSIZE];
    if (!m_abNormal)
    {
        ERROR_OUT(("BCD_ShareStarting: failed to alloc m_abNormal"));
        DC_QUIT;
    }

    m_abXor = new BYTE[BCD_XORSIZE];
    if (!m_abXor)
    {
        ERROR_OUT(("BCD_ShareStarting: failed to alloc m_abXor"));
        DC_QUIT;
    }

    m_amatch = new MATCH[BCD_MATCHCOUNT];
    if (!m_amatch)
    {
        ERROR_OUT(("BCD_ShareStarting: failed to alloc m_amatch"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::BCD_ShareStarting, rc);
    return(rc);
}


//
// BCD_ShareEnded()
//
void ASShare::BCD_ShareEnded(void)
{
    DebugEntry(ASShare::BCD_ShareEnded);

    //
    // Free the BCD scratch buffers
    //
    if (m_amatch)
    {
        delete[] m_amatch;
        m_amatch = NULL;
    }

    if (m_abXor)
    {
        delete[] m_abXor;
        m_abXor = NULL;
    }

    if (m_abNormal)
    {
        delete[] m_abNormal;
        m_abNormal = NULL;
    }

    DebugExitVOID(ASShare::BCD_ShareEnded);
}


//
// BC_CompressBitmap(..)
//
BOOL  ASShare::BC_CompressBitmap
(
    LPBYTE      pSrcBitmap,
    LPBYTE      pDstBuffer,
    LPUINT      pDstBufferSize,
    UINT        bitmapWidth,
    UINT        bitmapHeight,
    UINT        cBpp,
    LPBOOL      pLossy
)
{
    BOOL        fCompressedData = FALSE;
    UINT        cbScanWidth;
    PCD_HEADER  pCompDataHeader;
    LPBYTE      pCompData;
    UINT        cbUncompressedDataSize;
    UINT        cbFreeDstBytes;
    UINT        cbCompFirstRowSize;
    UINT        cbCompMainBodySize;

    DebugEntry(ASShare::BC_CompressBitmap);

    //
    // We support 4 and 8 bpp only
    //
    if ((cBpp != 4) && (cBpp != 8))
    {
        TRACE_OUT(("BC_CompressBitmap:  No compression at %d bpp", cBpp));
        DC_QUIT;
    }

    //
    // If we don't have scratch buffers, can't do it either
    // But for now, we just won't enter into a share if we can't allocate
    // themm.
    //
    ASSERT(m_abNormal);
    ASSERT(m_abXor);
    ASSERT(m_amatch);

    cbScanWidth = BYTES_IN_SCANLINE(bitmapWidth, cBpp);

    //
    // Take a local copy of the destination buffer size.
    //
    cbFreeDstBytes = *pDstBufferSize;

    //
    // Calculate the size of the uncompressed src data.
    //
    cbUncompressedDataSize = cbScanWidth * bitmapHeight;

    //
    // Check that the size of the uncompressed data is less than our max.
    //
    ASSERT(cbUncompressedDataSize < TSHR_MAX_SEND_PKT);

    //
    // We write a compressed data header at the start of the dst buffer.
    // Reserve space for it now, and fill in the size of the uncompressed
    // data.
    //
    if (sizeof(CD_HEADER) >= cbFreeDstBytes)
    {
        WARNING_OUT(("BC_CompressBitmap: Dest buffer too small: %d", cbFreeDstBytes));
        DC_QUIT;
    }

    pCompDataHeader = (PCD_HEADER)pDstBuffer;
    pCompDataHeader->cbUncompressedSize = (TSHR_UINT16)cbUncompressedDataSize;
    pCompData = ((LPBYTE)pCompDataHeader) + sizeof(CD_HEADER);
    cbFreeDstBytes -= sizeof(CD_HEADER);

    //
    // Compress the bitmap data.
    // We just pass the complete image into the compression function.
    // The header size in the packet is set to 0 and the whole thing
    // flows as the main body
    //

    cbCompFirstRowSize = 0; // lonchanc: a must for V2
    cbCompMainBodySize = CompressV2Int(pSrcBitmap, pCompData,
            bitmapWidth*bitmapHeight, cBpp, cbScanWidth, cbFreeDstBytes,
            pLossy, m_abNormal, m_abXor, m_amatch);

    if (cbCompMainBodySize == 0)
    {
        WARNING_OUT(("BC_CompressBitmap: Compression failed"));
        DC_QUIT;
    }

    //
    // Fill in the compressed data header.
    //
    pCompDataHeader->cbCompFirstRowSize = (TSHR_UINT16)cbCompFirstRowSize;
    pCompDataHeader->cbCompMainBodySize = (TSHR_UINT16)cbCompMainBodySize;
    pCompDataHeader->cbScanWidth = (TSHR_UINT16)cbScanWidth;

    ASSERT(IsV2CompressedDataHeader(pCompDataHeader));

    //
    // Write back the new (compressed) packet size.
    //
    *pDstBufferSize = sizeof(CD_HEADER) + cbCompFirstRowSize + cbCompMainBodySize;

    TRACE_OUT(("Bitmap Compressed %u bytes to %u",
        cbUncompressedDataSize, *pDstBufferSize));

    fCompressedData = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::BC_CompressBitmap, fCompressedData);
    return(fCompressedData);
}




//
// BD_DecompressBitmap(..)
//
BOOL  ASShare::BD_DecompressBitmap
(
    LPBYTE      pCompressedData,
    LPBYTE      pDstBitmap,
    UINT        cbSrcData,
    UINT        bitmapWidth,
    UINT        bitmapHeight,
    UINT        cBpp
)
{
    BOOL        fDecompressedData = FALSE;
    PCD_HEADER  pCompDataHeader;
    LPBYTE      pCompDataFirstRow;
    LPBYTE      pCompDataMainBody;
    UINT        decompSize;


    DebugEntry(ASShare::BD_DecompressBitmap);

    //
    // We currently support 4 and 8 bpp bitmaps only
    //
    if ((cBpp != 4) && (cBpp != 8))
    {
        ERROR_OUT(("BD_DecompressBitmap: Unsupported bpp %d", cBpp));
        DC_QUIT;
    }


    //
    // Work out the location in the source data of each component.
    //
    pCompDataHeader = (PCD_HEADER)pCompressedData;

    pCompDataFirstRow = (LPBYTE)pCompDataHeader + sizeof(CD_HEADER);
    pCompDataMainBody = pCompDataFirstRow +
                                         pCompDataHeader->cbCompFirstRowSize;
    ASSERT(IsV2CompressedDataHeader(pCompDataHeader));


    TRACE_OUT(( "FirstRowSize(%u) MainBodySize(%u) ScanWidth(%u)",
                                         pCompDataHeader->cbCompFirstRowSize,
                                         pCompDataHeader->cbCompMainBodySize,
                                         pCompDataHeader->cbScanWidth ));

    //
    // Check that the supplied data size matches our expectations.
    //
    if (cbSrcData != sizeof(CD_HEADER) +
                     pCompDataHeader->cbCompFirstRowSize +
                     pCompDataHeader->cbCompMainBodySize )
    {
        ERROR_OUT(("BD_DecompressBitmap: Supplied packet size %u does not match bitmap header",
            cbSrcData));
        DC_QUIT;
    }

    //
    // As with compression, the V2 decompression function just takes
    // the whole image for decompression.
    // THE ABSENCE OF A FIRST LINE COUNT DOES, IN FACT, INDICATE TO US
    // THAT THIS IS A V2 COMPRESSED BITMAP.
    //
    if (pCompDataHeader->cbCompFirstRowSize != 0)
    {
        ERROR_OUT(("BD_DecompressBitmap: Bogus header data"));
    }
    else
    {
        ASSERT(m_abXor);

        decompSize = DecompressV2Int(pCompDataFirstRow, pDstBitmap,
            pCompDataHeader->cbCompMainBodySize, cBpp,
            pCompDataHeader->cbScanWidth, m_abXor);

        TRACE_OUT(("Bitmap Exploded %u bytes from %u", decompSize, cbSrcData));

        fDecompressedData = TRUE;
    }

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::BD_DecompressBitmap, fDecompressedData);
    return(fDecompressedData);
}



//
//
// Create a second copy of the source, which consists of all lines XORed,
// if there is a rowDelta specified
//
// Scan both the non-xored and the xored buffers for matches
//
// A best matches are built up in an array which contains an index to the
// match type, together with the match type.  Non repetetive sequences are
// stored in this array as color image strings.
//
//

//
// The following constant controls the threshold at which we decide that
// a lossy compress is a pointless overhead.  For low bandwidth connections
// DC-Share will always initially request a lossy compress to get some
// data out quickly.  If we find that the percentage of COLOR_IMAGE data
// is below this threshold then we turn off lossy compression for this
// bitmap, redo the analysis, perform non-lossy compression and return
// an indication to the caller that the compression was non-lossy.
//
#define LOSSY_THRESHOLD   75

//
// The following functions have been carefully coded to ensure that the
// 16 bit compiler can minimize its switching of segment registers.
// However, this will not impair its performance on 32 bit systems.
//

//
// Utility macros for encoding orders
//

//
// Encode a combined order and set fg color
//
#define ENCODE_SET_ORDER_MEGA(buffer,                                        \
                              order_code,                                    \
                              length,                                        \
                              mega_order_code,                               \
                              DEF_LENGTH_ORDER,                              \
                              DEF_LENGTH_LONG_ORDER)                         \
        if (length <= DEF_LENGTH_ORDER)                                      \
        {                                                                    \
            *buffer++ = (BYTE)((BYTE)order_code | (BYTE)length);    \
        }                                                                    \
        else                                                                 \
        {                                                                    \
            if (length <= DEF_LENGTH_LONG_ORDER)                             \
            {                                                                \
                *buffer++ = (BYTE)order_code;                             \
                *buffer++ = (BYTE)(length-DEF_LENGTH_ORDER-1);            \
            }                                                                \
            else                                                             \
            {                                                                \
                *buffer++ = (BYTE)mega_order_code;                        \
                INSERT_TSHR_UINT16_UA( buffer, (TSHR_UINT16)length);         \
                buffer += 2;                                                 \
            }                                                                \
        }                                                                    \
        *buffer++ = fgChar;

//
// Encode a combined order and set fg color for a special FGBG image
//
#define ENCODE_SET_ORDER_MEGA_FGBG(buffer,                                   \
                                   order_code,                               \
                                   length,                                   \
                                   mega_order_code,                          \
                                   DEF_LENGTH_ORDER,                         \
                                   DEF_LENGTH_LONG_ORDER)                    \
        if (((length & 0x0007) == 0) &&                                      \
            (length <= DEF_LENGTH_ORDER))                                    \
        {                                                                    \
            *buffer++ = (BYTE)((BYTE)order_code | (BYTE)(length/8));\
        }                                                                    \
        else                                                                 \
        {                                                                    \
            if (length <= DEF_LENGTH_LONG_ORDER)                             \
            {                                                                \
                *buffer++ = (BYTE)order_code;                             \
                *buffer++ = (BYTE)(length-1);                             \
            }                                                                \
            else                                                             \
            {                                                                \
                *buffer++ = (BYTE)mega_order_code;                        \
                INSERT_TSHR_UINT16_UA( buffer, (TSHR_UINT16)length);         \
                buffer += 2;                                                 \
            }                                                                \
        }                                                                    \
        *buffer++ = fgChar;


//
// Encode an order for a standard run
//
#define ENCODE_ORDER_MEGA(buffer,                                            \
                          order_code,                                        \
                          length,                                            \
                          mega_order_code,                                   \
                          DEF_LENGTH_ORDER,                                  \
                          DEF_LENGTH_LONG_ORDER)                             \
        if (length <= DEF_LENGTH_ORDER)                                      \
        {                                                                    \
            *buffer++ = (BYTE)((BYTE)order_code | (BYTE)length);    \
        }                                                                    \
        else                                                                 \
        {                                                                    \
            if (length <= DEF_LENGTH_LONG_ORDER)                             \
            {                                                                \
                *buffer++ = (BYTE)order_code;                             \
                *buffer++ = (BYTE)(length-DEF_LENGTH_ORDER-1);            \
            }                                                                \
            else                                                             \
            {                                                                \
                *buffer++ = (BYTE)mega_order_code;                        \
                INSERT_TSHR_UINT16_UA( buffer, (TSHR_UINT16)length);         \
                buffer += 2;                                                 \
            }                                                                \
        }

//
// Encode a special FGBG image
//
#define ENCODE_ORDER_MEGA_FGBG(buffer,                                       \
                          order_code,                                        \
                          length,                                            \
                          mega_order_code,                                   \
                          DEF_LENGTH_ORDER,                                  \
                          DEF_LENGTH_LONG_ORDER)                             \
        if (((length & 0x0007) == 0) &&                                      \
            (length <= DEF_LENGTH_ORDER))                                    \
        {                                                                    \
            *buffer++ = (BYTE)((BYTE)order_code | (BYTE)(length/8));\
        }                                                                    \
        else                                                                 \
        {                                                                    \
            if (length <= DEF_LENGTH_LONG_ORDER)                             \
            {                                                                \
                *buffer++ = (BYTE)order_code;                             \
                *buffer++ = (BYTE)(length-1);                             \
            }                                                                \
            else                                                             \
            {                                                                \
                *buffer++ = (BYTE)mega_order_code;                        \
                INSERT_TSHR_UINT16_UA( buffer, (TSHR_UINT16)length);         \
                buffer += 2;                                                 \
            }                                                                \
        }

//
// Macros to extract the length from order codes
//
#define EXTRACT_LENGTH(buffer, length)                                       \
        length = *buffer++ & MAX_LENGTH_ORDER;                               \
        if (length == 0)                                                     \
        {                                                                    \
            length = *buffer++ + MAX_LENGTH_ORDER + 1;                       \
        }

#define EXTRACT_LENGTH_LITE(buffer, length)                                  \
        length = *buffer++ & MAX_LENGTH_ORDER_LITE;                          \
        if (length == 0)                                                     \
        {                                                                    \
            length = *buffer++ + MAX_LENGTH_ORDER_LITE + 1;                  \
        }

#define EXTRACT_LENGTH_FGBG(buffer, length)                                  \
        length = *buffer++ & MAX_LENGTH_ORDER;                               \
        if (length == 0)                                                     \
        {                                                                    \
            length = *buffer++ + 1;                                          \
        }                                                                    \
        else                                                                 \
        {                                                                    \
            length = length << 3;                                            \
        }

#define EXTRACT_LENGTH_FGBG_LITE(buffer, length)                             \
        length = *buffer++ & MAX_LENGTH_ORDER_LITE;                          \
        if (length == 0)                                                     \
        {                                                                    \
            length = *buffer++ + 1;                                          \
        }                                                                    \
        else                                                                 \
        {                                                                    \
            length = length << 3;                                            \
        }

//
// RunSingle
//
// Determine the length of the current run
//
// RunSingle may only be called if the buffer has at least four
// consecutive identical bytes from the start position
//
// For 16 bit processing there are two versions of this macro.  For 32
// bit the nulling of NEAR/FAR will make them the same.
//
#define RUNSINGLE_XOR(buffer, length, result)                                \
     {                                                                       \
         BYTE NEAR *buf    = buffer+4;                                    \
         BYTE NEAR *endbuf = buffer+length-4;                             \
         while ((buf < endbuf) &&                                            \
                (EXTRACT_TSHR_UINT32_UA(buf) == EXTRACT_TSHR_UINT32_UA(buf-4)))  \
         {                                                                   \
             buf += 4;                                                       \
         }                                                                   \
         endbuf += 4;                                                        \
         while(buf < endbuf && (*buf == *(buf-1)))                           \
         {                                                                   \
             buf++;                                                          \
         }                                                                   \
         result = (DWORD)(buf - (buffer));                                            \
     }

#define RUNSINGLE_NRM(buffer, length, result)                                \
     {                                                                       \
         BYTE FAR *buf    = buffer+4;                                     \
         BYTE FAR *endbuf = buffer+length-4;                              \
         while ((buf < endbuf) &&                                            \
                (EXTRACT_TSHR_UINT32_UA(buf) == EXTRACT_TSHR_UINT32_UA(buf-4)))  \
         {                                                                   \
             buf += 4;                                                       \
         }                                                                   \
         endbuf += 4;                                                        \
         while(buf < endbuf && (*buf == *(buf-1)))                           \
         {                                                                   \
             buf++;                                                          \
         }                                                                   \
         result = (DWORD)(buf - (buffer));                                            \
     }


//
// RunDouble
//
// Determine the length of the current run of paired bytes
//
#define RunDouble(buffer, length, result)                                    \
    {                                                                        \
        int   len  = ((int)length);                                      \
        BYTE FAR *buf = buffer;                                           \
        BYTE testchar1 = *buf;                                            \
        BYTE testchar2 = *(buf+1);                                        \
        result = 0;                                                          \
        while(len > 1)                                                       \
        {                                                                    \
            if (*buf++ != testchar1)                                         \
            {                                                                \
                break;                                                       \
            }                                                                \
            if (*buf++ != testchar2)                                         \
            {                                                                \
                break;                                                       \
            }                                                                \
            result += 2;                                                     \
            len    -= 2;                                                     \
        }                                                                    \
    }


//
// RUNFGBG
//
// Determine the length of the run of bytes that consist
// only of black or a single FG color
// We exit the loop when
// - the next character is not a fg or bg color
// - we hit a run of 24 of the FG or BG color
// 24 may seem excessive, but note the following sample compression:
//                12     16     20     24     28
// Pre GDC       3845   3756   3712   3794   3822
// Post GDC      2401   2313   2286   2189   2209
//
//
#define RUNFGBG(buffer, length, result, work)                                \
    {                                                                        \
        BYTE NEAR *buf = buffer;                                          \
        BYTE NEAR *endbuf = buffer + length;                              \
        result = 0;                                                          \
        work = *buf;                                                         \
        while (TRUE)                                                         \
        {                                                                    \
            buf++;                                                           \
            result++;                                                        \
            if (buf >= endbuf)                                               \
            {                                                                \
                break;                                                       \
            }                                                                \
                                                                             \
            if ((*buf != work) && (*buf != 0))                               \
            {                                                                \
                break;                                                       \
            }                                                                \
                                                                             \
            if ((result & 0x0007) == 0)                                      \
            {                                                                \
                if ((*buf == *(buf+1)) &&                                    \
                    (EXTRACT_TSHR_UINT16_UA(buf) ==                            \
                                            EXTRACT_TSHR_UINT16_UA(buf+ 2)) && \
                    (EXTRACT_TSHR_UINT32_UA(buf) ==                            \
                                            EXTRACT_TSHR_UINT32_UA(buf+ 4)) && \
                    (EXTRACT_TSHR_UINT32_UA(buf) ==                            \
                                            EXTRACT_TSHR_UINT32_UA(buf+ 8)) && \
                    (EXTRACT_TSHR_UINT32_UA(buf) ==                            \
                                            EXTRACT_TSHR_UINT32_UA(buf+12)) && \
                    (EXTRACT_TSHR_UINT32_UA(buf) ==                            \
                                            EXTRACT_TSHR_UINT32_UA(buf+16)) && \
                    (EXTRACT_TSHR_UINT32_UA(buf) ==                            \
                                            EXTRACT_TSHR_UINT32_UA(buf+20)) )  \
                {                                                            \
                    break;                                                   \
                }                                                            \
            }                                                                \
        }                                                                    \
    }

//
// Determine whether a run is better than any previous run
// For efficiency we take any run of 32 pels or more without looking
// further.
//
#define CHECK_BEST_RUN(run_type, run_length, bestrun_length, bestrun_type)   \
        if (run_length > bestrun_length)                                     \
        {                                                                    \
            bestrun_length = run_length;                                     \
            bestrun_type = run_type;                                         \
            if (bestrun_length >= 32)                                        \
            {                                                                \
                break;                                                       \
            }                                                                \
        }

//
// SETFGCHAR
//
// Set up a new value in fgChar and recalculate the shift
//
#define CHECK_WORK(workchar)

#define SETFGCHAR(newchar, curchar, curshift)                                \
     curchar    = newchar;                                                   \
     {                                                                       \
         BYTE workchar = curchar;                                         \
         curshift = 0;                                                       \
         CHECK_WORK(workchar);                                               \
         while ((workchar & 0x01) == 0)                                      \
         {                                                                   \
             curshift++;                                                     \
             workchar = (BYTE)(workchar>>1);                              \
         }                                                                   \
     }


//
// Macro to store an FGBG image
//
#define STORE_FGBG(xorbyte, fgbgChar, fgChar, bits)                          \
      {                                                                      \
        UINT   numbits = bits;                                             \
        if (fgbgChar & 0x01)                                                 \
        {                                                                    \
            *destbuf++ = (BYTE)(xorbyte ^ fgChar);                        \
        }                                                                    \
        else                                                                 \
        {                                                                    \
            *destbuf++ = xorbyte;                                            \
        }                                                                    \
        if (--numbits > 0)                                                   \
        {                                                                    \
          if (fgbgChar & 0x02)                                               \
          {                                                                  \
              *destbuf++ = (BYTE)(xorbyte ^ fgChar);                      \
          }                                                                  \
          else                                                               \
          {                                                                  \
              *destbuf++ = xorbyte;                                          \
          }                                                                  \
          if (--numbits > 0)                                                 \
          {                                                                  \
            if (fgbgChar & 0x04)                                             \
            {                                                                \
                *destbuf++ = (BYTE)(xorbyte ^ fgChar);                    \
            }                                                                \
            else                                                             \
            {                                                                \
                *destbuf++ = xorbyte;                                        \
            }                                                                \
            if (--numbits > 0)                                               \
            {                                                                \
              if (fgbgChar & 0x08)                                           \
              {                                                              \
                  *destbuf++ = (BYTE)(xorbyte ^ fgChar);                  \
              }                                                              \
              else                                                           \
              {                                                              \
                  *destbuf++ = xorbyte;                                      \
              }                                                              \
              if (--numbits > 0)                                             \
              {                                                              \
                if (fgbgChar & 0x10)                                         \
                {                                                            \
                    *destbuf++ = (BYTE)(xorbyte ^ fgChar);                \
                }                                                            \
                else                                                         \
                {                                                            \
                    *destbuf++ = xorbyte;                                    \
                }                                                            \
                if (--numbits > 0)                                           \
                {                                                            \
                  if (fgbgChar & 0x20)                                       \
                  {                                                          \
                      *destbuf++ = (BYTE)(xorbyte ^ fgChar);              \
                  }                                                          \
                  else                                                       \
                  {                                                          \
                      *destbuf++ = xorbyte;                                  \
                  }                                                          \
                  if (--numbits > 0)                                         \
                  {                                                          \
                    if (fgbgChar & 0x40)                                     \
                    {                                                        \
                        *destbuf++ = (BYTE)(xorbyte ^ fgChar);            \
                    }                                                        \
                    else                                                     \
                    {                                                        \
                        *destbuf++ = xorbyte;                                \
                    }                                                        \
                    if (--numbits > 0)                                       \
                    {                                                        \
                      if (fgbgChar & 0x80)                                   \
                      {                                                      \
                          *destbuf++ = (BYTE)(xorbyte ^ fgChar);          \
                      }                                                      \
                      else                                                   \
                      {                                                      \
                          *destbuf++ = xorbyte;                              \
                      }                                                      \
                    }                                                        \
                  }                                                          \
                }                                                            \
              }                                                              \
            }                                                                \
          }                                                                  \
        }                                                                    \
      }


//
// ENCODEFGBG
//
// Encode 8 bytes of FG and black into a one byte bitmap representation
//
// The FgChar will always be non-zero, and therefore must have at least one
// bit set.
//
// We arrange that all bytes have this bit in their lowest position
//
// The zero pels will still have a 0 in the lowest bit.
//
// Getting the result is a 4 stage process
//
//  1) Get the wanted bits into bit 0 of each byte
//
//  <***************work1*****************>
//  31 0
//  0000 000d 0000 000c 0000 000b 0000 000a
//          ^ ^ ^ ^
//  <***************work2*****************>
//  31 0
//  0000 000h 0000 000g 0000 000f 0000 000e
//          ^ ^ ^ ^
//
// a..h = bits that we want to output
//
// We just need to collect the indicated bits and squash them into a single
// byte.
//
//  2) Compress down to 32 bits
//
//  <***************work1*****************>
//  31 0
//  000h 000d 000g 000c 000f 000b 000e 000a
//     ^ ^ ^ ^ ^ ^ ^ ^
//
//  3) Compress down to 16 bits
//
//  <******work*******>
//  15 0
//  0h0f 0d0b 0g0e 0c0a
//     ^ ^ ^ ^
//
//  4) Compress down to 8 bits
//
//  hgfedcba
//
#define ENCODEFGBG(result)                                                   \
{                                                                            \
    UINT work1;                                                          \
    UINT work2;                                                          \
    UINT   work;                                                           \
                                                                             \
    work1 = (((UINT)(xorbuf[srcOffset])        ) |                       \
             ((UINT)(xorbuf[srcOffset+1]) <<  8) |                       \
             ((UINT)(xorbuf[srcOffset+2]) << 16) |                       \
             ((UINT)(xorbuf[srcOffset+3]) << 24));                       \
    work2 = (((UINT)(xorbuf[srcOffset+4])      ) |                       \
             ((UINT)(xorbuf[srcOffset+5]) <<  8) |                       \
             ((UINT)(xorbuf[srcOffset+6]) << 16) |                       \
             ((UINT)(xorbuf[srcOffset+7]) << 24));                       \
                                                                             \
    work1 = (work1 >> fgShift) & 0x01010101;                                 \
    work2 = (work2 >> fgShift) & 0x01010101;                                 \
                                                                             \
    work1 = (work2 << 4) | work1;                                            \
                                                                             \
    work = work1 | (work1 >> 14);                                            \
                                                                             \
    result = ((BYTE)(((BYTE)(work>>7)) | ((BYTE)work)));            \
}


//
// Unpack4bpp
//
// Convert a 4bpp bitmap into an 8bpp one
//
void  Unpack4bpp(LPBYTE destbuf,
                                     LPBYTE srcbuf,
                                     UINT   srclen)
{
    do
    {
        *destbuf++ = (BYTE)((*srcbuf) >> 4);
        *destbuf++ = (BYTE)((*srcbuf) & 0x0F);
        srcbuf++;
    } while (--srclen > 0);
}

//
// Pack4bpp
//
// Convert an 8bpp bitmap back to 4bpp
//
void  Pack4bpp(LPBYTE destbuf,
                                   LPBYTE srcbuf,
                                   UINT   srclen)
{
    BYTE work1, work2;

    DebugEntry(Pack4bpp);

    while (srclen > 1)
    {
        work1  = (BYTE)(*srcbuf++ << 4);
        work2  = (BYTE)(*srcbuf++ & 0x0F);
        *destbuf++ = (BYTE)(work1 | work2);
        srclen -= 2;
    }
    if (srclen > 0)
    {
        *destbuf++ = (BYTE)(*srcbuf++ << 4);
    }

    DebugExitVOID(Pack4bpp);
}

//
// XORBuffer
//
// Create an XOR image of the input bitmap
//
// Note: This function assumes that rowDelta is always a multiple of 4, and
// that destbuf and srcbuf start on a 4 byte boundary.  It does not deal
// with unaligned accesses if this is not true.
//
void  XORBuffer(BYTE  NEAR *destbuf,
                                    BYTE  FAR  *srcbuf,
                                    UINT   srclen,
                                    int    rowDelta)
{
    UINT NEAR *dwdest = (UINT NEAR *)destbuf;

    DebugEntry(XORBuffer);


    ASSERT((rowDelta % 4 == 0));
    ASSERT((((UINT_PTR)destbuf) % 4 == 0));
    ASSERT((((UINT_PTR)srcbuf) % 4 == 0));

    while (srclen > 8)
    {
        *dwdest++ = *((LPUINT)srcbuf) ^ *((LPUINT)(srcbuf+rowDelta));
        srclen -= 4;
        srcbuf += 4;
        *dwdest++ = *((LPUINT)srcbuf) ^ *((LPUINT)(srcbuf+rowDelta));
        srclen -= 4;
        srcbuf += 4;
    }
    if (srclen)
    {
        destbuf = (BYTE NEAR *)dwdest;
        while(srclen)
        {
            *destbuf++ = (BYTE)(*srcbuf++ ^  *(srcbuf+rowDelta));
            srclen--;
        }
    }

    DebugExitVOID(XORBuffer);
}

//
// CompressV2Int
//
// Internal compresssion function
//
// The work buffer addresses are moved onto the stack, thus eliminating any
// need to use DS to address the default data segment.  This allows the
// compiler to perform more general optimizations.
//
UINT    CompressV2Int(LPBYTE pSrc,
                                          LPBYTE pDst,
                                          UINT   numPels,
                                          UINT   bpp,
                                          UINT   rowDelta,
                                          UINT   dstBufferSize,
                                          LPBOOL  pLossy,
                                          LPBYTE  nrmbuf,
                                          LPBYTE  xorbuf,
                                          MATCH    FAR  *match)
{

    int     i;
    UINT    srcOffset;
    UINT    matchindex;
    UINT    bestRunLength;
    UINT    nextRunLength;
    UINT    runLength;
    UINT    bestFGRunLength;
    UINT    checkFGBGLength;
    UINT    scanCount;
    BOOL    firstLine;
    UINT    saveNumPels;
    BOOL    saveLossy;
    BOOL    lossy;
    BYTE   bestRunType      = 0;
    LPBYTE  destbuf          = pDst;
    BYTE   fgChar           = 0xFF;
    BYTE   fgCharWork       = 0xFF;
    BYTE   fgShift          = 0;
    BOOL    lossyStarted     = FALSE;
    BOOL    inColorRun       = FALSE;
    UINT    compressedLength = 0;

    DebugEntry(CompressV2Int);

    //
    // Validate the line length
    //
    if ((numPels < rowDelta) ||
        (rowDelta & 0x0003) ||
        (numPels & 0x0003))
    {
        WARNING_OUT(( "Lines must be a multiple of 4 pels"));
        DC_QUIT;
    }

    //
    // First create the character and XOR buffers
    //
    if (bpp == 4)
    {
        Unpack4bpp(nrmbuf, pSrc, numPels/2);

    }
    else
    {
        nrmbuf = pSrc;
    }

    //
    // Set up the first portion of the XORBUF to contain the source buffer
    //
    memcpy(xorbuf, nrmbuf, rowDelta);

    //
    // Calculate the rest of the XOR buffer
    //
    XORBuffer( xorbuf+rowDelta,
               nrmbuf+rowDelta,
               numPels-rowDelta,
               -(int)rowDelta);

    //
    // Loop processing the input
    // We perform the loop twice, the first time for the non-xor portion
    // of the buffer and the second for the XOR portion
    // Note that we start the run at a match index of 2 to avoid having
    // to special case the startup condition in some of the match
    // merging code
    // The first time through is always a non-lossy pass.  If we find
    // enough incompressible data then we redo the compression in lossy
    // mode.  To achieve this we set saveLossy = FALSE here and reset it
    // following the first scan.
    //
    saveLossy     = FALSE;

RESTART_COMPRESSION_IN_LOSSY_MODE:
    srcOffset     = 0;
    firstLine     = TRUE;
    match[0].type = 0;
    match[1].type = 0;
    matchindex    = 2;
    saveNumPels   = numPels;

    //
    // Until we enter XOR mode we do not allow lossy compression on a
    // non-XOR request so set up to process just the first line.
    // Also, if the user is requesting a lossy compression then we
    // perform an initial full non-lossy pass to see if the request is
    // worthwhile.
    //
    lossy   = FALSE;
    numPels = rowDelta;

    for (scanCount = 0; scanCount < 2; scanCount++)
    {

        while (srcOffset < numPels)
        {
            //
            // Give up if we are nearing the end of the match array
            //
            if (matchindex >= BCD_MATCHCOUNT)
            {
                DC_QUIT;
            }

            //
            // Start a while loop to allow a more structured break when we
            // hit the first run type we want to encode (We can't afford
            // the overheads of a function call to provide the scope here.)
            //
            while (TRUE)
            {
                bestRunLength      = 0;
                bestFGRunLength    = 0;

                //
                // If we are hitting the end of the buffer then just take
                // color characters now - take them one at a time so that
                // lossy encoding still works.  We will only hit this
                // condition if we break out of a run just before the end
                // of the buffer, so this should not be too common a
                // situation, which is good given that we are encoding the
                // final 6 bytes uncompressed.
                //
                if (srcOffset+6 >= numPels)
                {
                    bestRunType = IMAGE_COLOR;
                    bestRunLength = 1;
                    break;
                }

                //
                // First do the scans on the XOR buffer.  Look for a
                // character run or a BG run.  Note that if there is no row
                // delta then xorbuf actually points to the normal buffer.
                // We must do the test independent of how long the run
                // might be because even for a 1 pel BG run our later logic
                // requires that we detect it seperately.  This code is
                // absolute main path so fastpath as much as possible.  In
                // particular detect short bg runs early and allow
                // RunSingle to presuppose at least 4 matching bytes
                //
                if (xorbuf[srcOffset] == 0x00)
                {
                    if (((srcOffset+1) >= numPels) ||
                        (xorbuf[srcOffset+1] != 0x00))
                    {
                        bestRunType = RUN_BG;
                        bestRunLength = 1;
                        if (!inColorRun)
                        {
                            break;
                        }
                    }
                    else
                    {
                        if (((srcOffset+2) >= numPels) ||
                            (xorbuf[srcOffset+2] != 0x00))
                        {
                            bestRunType = RUN_BG;
                            bestRunLength = 2;
                            if (!inColorRun)
                            {
                                break;
                            }
                        }
                        else
                        {
                            if (((srcOffset+3) >= numPels) ||
                                (xorbuf[srcOffset+3] != 0x00))
                            {
                                bestRunType = RUN_BG;
                                bestRunLength = 3;
                                if (!inColorRun)
                                {
                                    break;
                                }
                            }
                            else
                            {
                                RUNSINGLE_XOR(xorbuf+srcOffset,
                                             numPels-srcOffset,
                                             bestFGRunLength);
                                CHECK_BEST_RUN(RUN_BG,
                                               bestFGRunLength,
                                               bestRunLength,
                                               bestRunType);
                                if (!inColorRun)
                                {
                                     break;
                                }
                            }
                        }
                    }
                }
                else
                {
                    //
                    // No point in starting if FG run less than 4 bytes so
                    // check the first dword as quickly as possible Note
                    // that we don't need to check for an end-buffer
                    // condition here because our XOR buffer always has
                    // some free space at the end and the RUNSINGLE_XOR
                    // will break at the correct place
                    //
                    if ( (xorbuf[srcOffset] == xorbuf[srcOffset+1]) &&
                         (xorbuf[srcOffset] == xorbuf[srcOffset+2]) &&
                         (xorbuf[srcOffset] == xorbuf[srcOffset+3]) )
                    {
                        RUNSINGLE_XOR(xorbuf+srcOffset,
                                     numPels-srcOffset,
                                     bestFGRunLength);
                        //
                        // Don't permit a short FG run to prevent a FGBG
                        // image from starting up.  Only take if >= 5
                        //
                        if (bestFGRunLength > 5)
                        {
                            CHECK_BEST_RUN(RUN_FG,
                                           bestFGRunLength,
                                           bestRunLength,
                                           bestRunType);
                        }
                    }
                }


                //
                // Look for sequences in the non XOR buffer In this case we
                // insist upon a run of at least 6 pels
                //
                if ( (nrmbuf[srcOffset]     == nrmbuf[srcOffset + 2]) &&
                     (nrmbuf[srcOffset]     == nrmbuf[srcOffset + 4]) &&
                     (nrmbuf[srcOffset + 1] == nrmbuf[srcOffset + 3]) &&
                     (nrmbuf[srcOffset + 1] == nrmbuf[srcOffset + 5]) )
                {
                    //
                    // Now do the scan on the normal buffer for a character
                    // run Don't bother if first line because we will have
                    // found it already in the XOR buffer, since we just
                    // copy nrmbuf to xorbuf for the first line
                    //
                    if (*(nrmbuf+srcOffset) == *(nrmbuf+srcOffset+1))
                    {
                        if (!firstLine)
                        {
                            RUNSINGLE_NRM(nrmbuf+srcOffset,
                                         numPels-srcOffset,
                                         nextRunLength);
                            if (nextRunLength > 5)
                            {
                                CHECK_BEST_RUN(RUN_COLOR,
                                               nextRunLength,
                                               bestRunLength,
                                               bestRunType);
                            }
                        }
                    }
                    else
                    {
                        //
                        // Look for a dither on the nrm buffer Dithers are
                        // not very efficient for short runs so only take
                        // if 8 or longer
                        //
                        RunDouble(nrmbuf+srcOffset,
                                  numPels-srcOffset,
                                  nextRunLength);
                        if (nextRunLength > 9)
                        {
                            CHECK_BEST_RUN(RUN_DITHER,
                                           nextRunLength,
                                           bestRunLength,
                                           bestRunType);
                        }
                    }
                }

                //
                // If nothing so far then look for a FGBG run (The 6 is
                // carefully tuned!)
                //
                if (bestRunLength < 6)
                {
                    //
                    // But first look for a single fg bit breaking up a BG
                    // run.  If so then encode a BG run.  Careful of the
                    // enforced BG run break across the first line
                    // non-XOR/XOR boundary.
                    //
                    if ((EXTRACT_TSHR_UINT32_UA(xorbuf+srcOffset+1) == 0) &&
                        (*(xorbuf+srcOffset) == fgChar) &&
                        (match[matchindex-1].type == RUN_BG) &&
                        (srcOffset != (TSHR_UINT16)rowDelta))
                    {
                        RUNSINGLE_XOR(xorbuf+srcOffset+1,
                                     numPels-srcOffset-1,
                                     nextRunLength);
                        nextRunLength++;
                        CHECK_BEST_RUN(RUN_BG_PEL,
                                       nextRunLength,
                                       bestRunLength,
                                       bestRunType);
                    }
                    else
                    {
                        //
                        // If we have not found a run then look for a FG/BG
                        // image.  The disruptive effect of a short FGBG
                        // run on GDC is such that it is worth preventing
                        // one unless we are certain of the benefits.
                        // However, if the alternative is a color run then
                        // allow a lower value.
                        //
                        RUNFGBG( xorbuf+srcOffset,
                                 numPels-srcOffset,
                                 nextRunLength,
                                 fgCharWork );

                        checkFGBGLength = 48;
                        if (fgCharWork == fgChar)
                        {
                            checkFGBGLength -= 16;
                        }
                        if ((nextRunLength & 0x0007) == 0)
                        {
                            checkFGBGLength -= 8;
                        }
                        if (nextRunLength >= checkFGBGLength)
                        {
                            CHECK_BEST_RUN(IMAGE_FGBG,
                                           nextRunLength,
                                           bestRunLength,
                                           bestRunType);
                        }
                    }
                }

                //
                // If nothing useful so far then allow a short run, if any
                // Don't do this if we are accumulating a color run because
                // it will really screw up GDC compression if we allow lots
                // of little runs.  Also require that it is a regular short
                // run, rather than one that disturbs the fgChar
                //
                if (!inColorRun)
                {
                    if (bestRunLength < 6)
                    {
                        if ((bestFGRunLength > 4) &&
                            (xorbuf[srcOffset] == fgChar))
                        {
                            if (match[matchindex-1].type == RUN_FG)
                            {
                                match[matchindex-1].length += (WORD)bestFGRunLength;
                                srcOffset += bestFGRunLength;
                                continue;
                            }
                            else
                            {
                                bestRunLength = bestFGRunLength;
                                bestRunType   = RUN_FG;
                            }

                        }
                        else
                        {
                            //
                            // If we decided to take a run earlier then
                            // allow it now.  (May be a short BG run, for
                            // example) If nothing so far then take color
                            // image)
                            //
                            if (bestRunLength == 0)
                            {
                                bestRunType = IMAGE_COLOR;
                                bestRunLength = 1;
                            }

                        }
                    }
                }
                else
                {
                    //
                    // May seem restrictive, but it is important for our
                    // lossy compression that a color run is rather
                    // "sticky", in particular not broken by random FGBG
                    // runs which do appear from time to time.
                    //
                    if (lossy)
                    {
                        if ((bestRunLength < 8) ||
                            ((bestRunType == IMAGE_FGBG) &&
                             (bestRunLength < 16)))

                        {
                            bestRunType = IMAGE_COLOR;
                            bestRunLength = 1;
                        }
                    }
                    else
                    {
                        if ((bestRunLength < 6) ||
                            ((bestRunType != RUN_BG) && (bestRunLength < 8)))
                        {
                            bestRunType = IMAGE_COLOR;
                            bestRunLength = 1;
                        }
                    }
                }

                break;
            }

            //
            // When we get here we have found the best run.  Now check for
            // various amalamation conditions with the previous run type.
            // Note that we may already have done amalgamation of short
            // runs, but we had to do multiple samples for the longer runs
            // so we repeat the checks here
            //

            //
            // If we are encoding a color run then
            //     - process it for lossy compression
            //     - combine it with an existing run if possible
            //
            if (bestRunType == IMAGE_COLOR)
            {
                //
                // Flag that we are within a color run
                //
                inColorRun = TRUE;

                //
                // If we are doing a lossy compression then process
                // even/odd lines differently
                //
                if (lossy)
                {
                    //
                    // For even lines duplicate every other character,
                    // discarding the original value
                    //
                    if (((srcOffset/rowDelta)%2) == 0)
                    {
                        if ((match[matchindex-1].type == IMAGE_COLOR) &&
                            (match[matchindex-1].length%2 == 1))
                        {
                            nrmbuf[srcOffset] = nrmbuf[srcOffset-1];
                            //
                            // If we are not on the final line of the
                            // bitmap then propagate the update down to the
                            // next XORed line
                            //
                            if (numPels-srcOffset > rowDelta)
                            {
                                xorbuf[srcOffset+rowDelta] =
                                        (BYTE)(nrmbuf[srcOffset+rowDelta] ^
                                                  nrmbuf[srcOffset]);
                            }
                        }
                    }
                    else
                    {
                        //
                        // For odd lines we will just encode nulls which
                        // will replicate the previous line.  However, if
                        // the last run was a BG run then we will
                        // inadvertently insert a pel, so if we hit this
                        // situation then leave a single color char
                        //
                        bestRunType = IMAGE_LOSSY_ODD;

                        //
                        // No need to adjust the buffers for this, except
                        // to update the next XOR line to reflect the fact
                        // that the decoder will be operating on a
                        // replicated line.  Therefore we replace the
                        // character in the next line of the XOR buffer
                        // with the value it would have if the current line
                        // was identical with the previous line
                        //
                        if (numPels-srcOffset > (TSHR_UINT16)rowDelta)
                        {
                            xorbuf[srcOffset+rowDelta] =
                                     (BYTE)(nrmbuf[srcOffset+rowDelta] ^
                                               nrmbuf[srcOffset-rowDelta]);
                        }
                    }
                }

                //
                // Merge the color run immediately, if possible
                //
                if (match[matchindex-1].type == bestRunType)
                {
                    match[matchindex-1].length += (WORD)bestRunLength;
                    srcOffset += bestRunLength;
                    continue;
                }
            }
            else
            {
                //
                // We are no longer encoding a COLOR_IMAGE of any kind
                //
                inColorRun = FALSE;

                //
                // Keep track of the fg Color The macro that searches for
                // FGBG runs leaves the character in fgCharWork.
                //
                if (bestRunType == RUN_FG)
                {
                    fgChar = xorbuf[srcOffset];
                }
                else
                {
                    if (bestRunType == IMAGE_FGBG)
                    {
                        fgChar = fgCharWork;
                    }
                }
            }

            //
            // If we can amalgamate the entry then do so without creating a
            // new array entry.  We must amalgamate a lossy ODD with a
            // RUN_BG because otherwise the lossy would trigger a pel
            // insertion.  Our search for FGBG runs is dependent upon that
            // type of run being amalgamated because we break every 64
            // characters so that our mode switch detection works OK.
            //
            // Take care not to merge across the non-xor/xor boundary
            //
            if (srcOffset == (TSHR_UINT16)rowDelta)
            {
                //
                // Just bump the source offset
                //
                srcOffset += bestRunLength;
            }
            else
            {
                //
                // Bump srcOffset and try a merge
                //
                srcOffset += bestRunLength;

                //
                // The simpler merges are where the types are identical
                //
                if (bestRunType == match[matchindex-1].type)
                {
                    //
                    // COLOR IMAGES and BG images are trivial
                    //
                    if ((bestRunType == IMAGE_LOSSY_ODD)    ||
                        (bestRunType == RUN_BG))
                    {
                        match[matchindex-1].length += (WORD)bestRunLength;
                        continue;
                    }

                    //
                    // FG runs and FGBG images merge if fgChars match
                    //
                    if (((bestRunType == RUN_FG) ||
                         (bestRunType == IMAGE_FGBG)) &&
                        (fgChar  == match[matchindex-1].fgChar))
                    {
                        match[matchindex-1].length += (WORD)bestRunLength;
                        TRACE_OUT(( "Merged %u with preceding, giving %u",
                                 match[matchindex-1].type,
                                 match[matchindex-1].length));
                        continue;
                    }
                }

                //
                // BG RUNs merge with LOSSY odd lines It is important that
                // we do this merging because otherwise we will get
                // inadvertent pel insertion due to the broken BG runs.
                //
                if (((bestRunType == RUN_BG) ||
                     (bestRunType == IMAGE_LOSSY_ODD)) &&
                    ((match[matchindex-1].type == RUN_BG) ||
                     (match[matchindex-1].type == IMAGE_LOSSY_ODD) ||
                     (match[matchindex-1].type == RUN_BG_PEL)))
                {
                    match[matchindex-1].length += (WORD)bestRunLength;
                    continue;
                }

                //
                // If it is a normal FGBG run which follows a short BG run
                // then it is better to merge them.
                //
                if ((bestRunType == IMAGE_FGBG) &&
                    (match[matchindex-1].type == RUN_BG) &&
                    (match[matchindex-1].length < 8))
                {
                    match[matchindex-1].type   = IMAGE_FGBG;
                    match[matchindex-1].length += (WORD)bestRunLength;
                    match[matchindex-1].fgChar = fgChar;
                    TRACE_OUT(( "Merged FGBG with preceding BG run -> %u",
                             match[matchindex-1].length));
                    continue;

                }

                //
                // If it is a BG run following a FGBG run then merge in the
                // pels to make the FGBG a multiple of 8 bits.  The if the
                // remaining BG run is < 16 merge it in also otherwise just
                // write the shortened BG run
                //
                if (((bestRunType == RUN_BG) ||
                     (bestRunType == RUN_BG_PEL)) &&
                    (match[matchindex-1].type == IMAGE_FGBG) &&
                    (match[matchindex-1].length & 0x0007))
                {
                    UINT mergelen = 8 -
                                        (match[matchindex-1].length & 0x0007);
                    if (mergelen > bestRunLength)
                    {
                        mergelen = bestRunLength;
                    }
                    match[matchindex-1].length += (WORD)mergelen;
                    bestRunLength -= mergelen;
                    TRACE_OUT(( "Added %u pels to FGBG giving %u leaving %u",
                       mergelen, match[matchindex-1].length,bestRunLength));

                    if (bestRunLength < 9)
                    {
                        match[matchindex-1].length += (WORD)bestRunLength;
                        TRACE_OUT(( "Merged BG with preceding FGBG gives %u",
                             match[matchindex-1].length));
                        continue;
                    }
                }

                //
                // Finally, if it is a color run spanning any kind of
                // single pel entity then merge that last two entries.
                //
                if ((bestRunType == IMAGE_COLOR) &&
                    (match[matchindex-2].type == IMAGE_COLOR) &&
                    (match[matchindex-1].length == 1))
                {
                    match[matchindex-2].length += bestRunLength + 1;
                    matchindex--;
                    TRACE_OUT(( "Merged color with preceding color gives %u",
                         match[matchindex-1].length));
                    continue;
                }
            }

            //
            // Handle runs that will not amalgamate by adding a new array
            // entry
            //
            match[matchindex].type   = bestRunType;
            match[matchindex].length = (WORD)bestRunLength;
            match[matchindex].fgChar = fgChar;

            TRACE_OUT(( "Best run of type %u (index %u) has length %u",
                                     match[matchindex-1].type,
                                     matchindex-1,
                                     match[matchindex-1].length));
            TRACE_OUT(( "Trying run of type %u (index %u) length %u",
                                     match[matchindex].type,
                                     matchindex,
                                     match[matchindex].length));

            matchindex++;

        }

        //
        // If we have just done our scan of the first line then now do the
        // rest of the buffer.  Reset our saved pel count.
        //
        numPels   = saveNumPels;
        lossy     = saveLossy;
        firstLine = FALSE;
    }
    //
    // END OF INITIAL TWO PASS SCAN OF THE INPUT
    //


    //
    // We have parsed the buffer so now we can go ahead and encode it.
    // First we should check to see whether we want to redo the encoding
    // in lossy mode.  We only do this if requested and worthwhile.
    //
    if (!saveLossy && (pLossy != NULL) && *pLossy)
    {
        UINT    lossyCharCount = 0;
        UINT    divisor;
        for (i = 2; i < (int)matchindex; i++)
        {
            if ((match[i].type == IMAGE_COLOR) ||
                (match[i].type == IMAGE_LOSSY_ODD))
            {
                lossyCharCount += match[i].length;
            }
        }
        divisor = max(numPels/100, 1);
        if (lossyCharCount/divisor > LOSSY_THRESHOLD)
        {
            saveLossy  = TRUE;
            goto RESTART_COMPRESSION_IN_LOSSY_MODE;
        }
        else
        {
            *pLossy    = FALSE;
        }
    }

    //
    // Now do the encoding
    //
    srcOffset = 0;
    firstLine = TRUE;
    lossy     = FALSE;
    fgChar    = 0xFF;

    for (i = 2; i < (int)matchindex; i++)
    {
        //
        // First check for our approaching the end of the destination
        // buffer and get out if this is the case.  We allow for the
        // largest general run order (a mega-mega set run = 4 bytes).
        // Orders which may be larger are checked within the case arm
        //
        if ((UINT)(destbuf - pDst + 4) > dstBufferSize)
        {
            //
            // We are about to blow it so just get out
            //
            DC_QUIT;
        }

        //
        // While we are encoding the first line keep checking for the end
        // of line to switch encoding states
        //
        if (firstLine)
        {
            if (srcOffset >= rowDelta)
            {
                firstLine = FALSE;
                lossy     = saveLossy;
            }
        }

        switch (match[i].type)
        {
                //
                // BG_RUN, FG_RUN, COLOR, PACKED COLOR and FGBG are normal
                // precision codes
                //
            case RUN_BG:
            case RUN_BG_PEL:
                ENCODE_ORDER_MEGA(destbuf,
                                  CODE_BG_RUN,
                                  match[i].length,
                                  CODE_MEGA_MEGA_BG_RUN,
                                  MAX_LENGTH_ORDER,
                                  MAX_LENGTH_LONG_ORDER);
                TRACE_OUT(( "BG RUN %u",match[i].length));
                srcOffset += match[i].length;
                break;

            case IMAGE_LOSSY_ODD:
                //
                // For a lossy odd line we encode a background run
                // Note that we do not need to encode a start lossy
                // because the decode does not need to distinguish this
                // from a regular bg run
                //
                ENCODE_ORDER_MEGA(destbuf,
                                  CODE_BG_RUN,
                                  match[i].length,
                                  CODE_MEGA_MEGA_BG_RUN,
                                  MAX_LENGTH_ORDER,
                                  MAX_LENGTH_LONG_ORDER);
                TRACE_OUT(( "BG RUN %u",match[i].length));
                srcOffset += match[i].length;
                break;

            case RUN_FG:
                //
                // If the fg char is not yet set then encode a set+run code
                //
                if (fgChar != match[i].fgChar)
                {
                    SETFGCHAR(match[i].fgChar, fgChar, fgShift);
                    //
                    // Encode the order
                    //
                    ENCODE_SET_ORDER_MEGA(destbuf,
                                          CODE_SET_FG_FG_RUN,
                                          match[i].length,
                                          CODE_MEGA_MEGA_SET_FG_RUN,
                                          MAX_LENGTH_ORDER_LITE,
                                          MAX_LENGTH_LONG_ORDER_LITE);
                    TRACE_OUT(( "SET_FG_FG_RUN %u",match[i].length));
                    srcOffset += match[i].length;
                }
                else
                {
                    ENCODE_ORDER_MEGA(destbuf,
                                      CODE_FG_RUN,
                                      match[i].length,
                                      CODE_MEGA_MEGA_FG_RUN,
                                      MAX_LENGTH_ORDER,
                                      MAX_LENGTH_LONG_ORDER);
                    TRACE_OUT(( "FG_RUN %u",match[i].length));
                    srcOffset += match[i].length;
                }
                break;

            case IMAGE_FGBG:
                //
                // IMAGE_FGBG
                //
                runLength = match[i].length;

                //
                // First check for our approaching the end of the
                // destination buffer and get out if this is the case.
                //
                if ((destbuf-pDst+(runLength+7)/8+4) > dstBufferSize)
                {
                    //
                    // We are about to blow it so just get out
                    //
                    DC_QUIT;
                }

                //
                // We need to convert FGBG runs into the pixel form
                //
                if (fgChar != match[i].fgChar)
                {
                    SETFGCHAR(match[i].fgChar, fgChar, fgShift);

                    ENCODE_SET_ORDER_MEGA_FGBG(destbuf,
                                               CODE_SET_FG_FG_BG,
                                               runLength,
                                               CODE_MEGA_MEGA_SET_FGBG,
                                               MAX_LENGTH_FGBG_ORDER_LITE,
                                               MAX_LENGTH_LONG_FGBG_ORDER);
                    TRACE_OUT(( "SET_FG_FG_BG %u",match[i].length));
                    while (runLength >= 8)
                    {
                        ENCODEFGBG(*destbuf);
                        destbuf++;
                        srcOffset += 8;
                        runLength -= 8;
                    }
                    if (runLength)
                    {
                        ENCODEFGBG(*destbuf);
                        //
                        // Keep the final partial byte clean to help GDC
                        // packing
                        //
                        *destbuf &= ((0x01 << runLength) - 1);
                        destbuf++;
                        srcOffset += runLength;
                    }
                }
                else
                {

                    if  (runLength == 8)
                    {
                        BYTE fgbgChar;
                        //
                        // See if it is one of the high probability bytes
                        //
                        ENCODEFGBG(fgbgChar);

                        //
                        // Check for single byte encoding of FGBG images
                        //
                        switch (fgbgChar)
                        {
                            case SPECIAL_FGBG_CODE_1:
                                *destbuf++ = CODE_SPECIAL_FGBG_1;
                                break;
                            case SPECIAL_FGBG_CODE_2:
                                *destbuf++ = CODE_SPECIAL_FGBG_2;
                                break;
                            default:

                                ENCODE_ORDER_MEGA_FGBG(destbuf,
                                                  CODE_FG_BG_IMAGE,
                                                  runLength,
                                                  CODE_MEGA_MEGA_FGBG,
                                                  MAX_LENGTH_FGBG_ORDER,
                                                  MAX_LENGTH_LONG_FGBG_ORDER);
                                *destbuf++ = fgbgChar;
                                break;
                        }
                        srcOffset += 8;
                    }
                    else
                    {
                        //
                        // Encode as standard FGBG
                        //
                        ENCODE_ORDER_MEGA_FGBG(destbuf,
                                               CODE_FG_BG_IMAGE,
                                               runLength,
                                               CODE_MEGA_MEGA_FGBG,
                                               MAX_LENGTH_FGBG_ORDER,
                                               MAX_LENGTH_LONG_FGBG_ORDER);
                        TRACE_OUT(( "FG_BG %u",match[i].length));
                        while (runLength >= 8)
                        {
                            ENCODEFGBG(*destbuf);
                            destbuf++;
                            srcOffset += 8;
                            runLength -= 8;
                        }
                        if (runLength)
                        {
                            ENCODEFGBG(*destbuf);
                            *destbuf &= ((0x01 << runLength) - 1);
                            destbuf++;
                            srcOffset += runLength;
                        }
                    }
                }
                break;


            case RUN_COLOR:
                //
                // COLOR RUN
                //
                ENCODE_ORDER_MEGA(destbuf,
                                  CODE_COLOR_RUN,
                                  match[i].length,
                                  CODE_MEGA_MEGA_COLOR_RUN,
                                  MAX_LENGTH_ORDER,
                                  MAX_LENGTH_LONG_ORDER);
                TRACE_OUT(( "COLOR_RUN %u",match[i].length));
                *destbuf++ = nrmbuf[srcOffset];
                srcOffset += match[i].length;
                break;

            case RUN_DITHER:
                //
                // DITHERED RUN
                //
                {
                    UINT   ditherlen = match[i].length/2;
                    ENCODE_ORDER_MEGA(destbuf,
                                      CODE_DITHERED_RUN,
                                      ditherlen,
                                      CODE_MEGA_MEGA_DITHER,
                                      MAX_LENGTH_ORDER_LITE,
                                      MAX_LENGTH_LONG_ORDER_LITE);
                    TRACE_OUT(( "DITHERED_RUN %u",match[i].length));
                    //
                    // First check for our approaching the end of the
                    // destination buffer and get out if this is the case.
                    //
                    if ((UINT)(destbuf - pDst + 2) > dstBufferSize)
                    {
                        //
                        // We are about to blow it so just get out
                        //
                        DC_QUIT;
                    }
                    *destbuf++ = nrmbuf[srcOffset];
                    *destbuf++ = nrmbuf[srcOffset+1];
                    srcOffset += match[i].length;
                }
                break;

            case IMAGE_COLOR:
                //
                // IMAGE_COLOR
                //
                //
                // A length of 1 can possibly be encoded as a single
                // "BLACK"
                //
                if (match[i].length == 1)
                {
                    if (nrmbuf[srcOffset] == 0x00)
                    {
                        *destbuf++ = CODE_BLACK;
                        srcOffset++;
                        break;
                    }
                    if (nrmbuf[srcOffset] == 0xFF)
                    {
                        *destbuf++ = CODE_WHITE;
                        srcOffset++;
                        break;
                    }
                }

                //
                // If lossy compression is requested then indicate it
                // immediately we get a color image to encode here
                //
                if (lossy & !lossyStarted)
                {
                    lossyStarted = TRUE;
                    *destbuf++   = CODE_START_LOSSY;
                }

                //
                // For 4bpp data pack color runs into nibbles
                //
                if (bpp == 4)
                {
                    //
                    // Store the data in packed format
                    //
                    ENCODE_ORDER_MEGA(destbuf,
                                      CODE_PACKED_COLOR_IMAGE,
                                      match[i].length,
                                      CODE_MEGA_MEGA_PACKED_CLR,
                                      MAX_LENGTH_ORDER,
                                      MAX_LENGTH_LONG_ORDER);
                    TRACE_OUT(( "PACKED COLOR %u",match[i].length));

                    //
                    // If we are not doing lossy compress then just copy
                    // the data over, packing two to a byte
                    //
                    if (!lossy)
                    {
                        //
                        // First check for our approaching the end of the
                        // destination buffer and get out if this is the
                        // case.
                        //
                        if ((destbuf - pDst + (UINT)(match[i].length + 1) / 2) >
                            dstBufferSize)
                        {
                            //
                            // We are about to blow it so just get out
                            //
                            DC_QUIT;
                        }

                        Pack4bpp(destbuf, nrmbuf+srcOffset, match[i].length);
                        destbuf   += (match[i].length+1)/2;
                        srcOffset += match[i].length;
                    }
                    else
                    {
                        //
                        // First check for our approaching the end of the
                        // destination buffer and get out if this is the
                        // case.
                        //
                        if ((destbuf - pDst + (UINT)(match[i].length + 3) / 4) >
                            dstBufferSize)
                        {
                            //
                            // We are about to blow it so just get out
                            //
                            DC_QUIT;
                        }

                        //
                        // For a lossy compress we need to discard every
                        // even byte
                        //
                        while (match[i].length > 2)
                        {
                            *destbuf++ =
                                   (BYTE)((*(nrmbuf+srcOffset)<<4) |
                                             (*(nrmbuf+srcOffset+2) & 0x0F));
                            if (match[i].length > 3)
                            {
                                srcOffset       += 4;
                                match[i].length -= 4;
                            }
                            else
                            {
                                srcOffset       += 3;
                                match[i].length -= 3;
                            }
                        }
                        if (match[i].length > 0)
                        {
                            *destbuf++ = (BYTE)(*(nrmbuf+srcOffset)<<4);
                            srcOffset  += match[i].length;
                        }
                    }
                }
                else
                {
                    //
                    // For 8bpp we don't bother trying to detect packed
                    // data.  Doing so disturbs GDC.
                    //
                    if (!lossy)
                    {
                        //
                        // Store the data in non-compressed form
                        //
                        ENCODE_ORDER_MEGA(destbuf,
                                          CODE_COLOR_IMAGE,
                                          match[i].length,
                                          CODE_MEGA_MEGA_CLR_IMG,
                                          MAX_LENGTH_ORDER,
                                          MAX_LENGTH_LONG_ORDER);
                        TRACE_OUT(( "COLOR_IMAGE %u",match[i].length));

                        //
                        // First check for our approaching the end of the
                        // destination buffer and get out if this is the
                        // case.
                        //
                        if ((destbuf - pDst + (UINT)match[i].length) > dstBufferSize)
                        {
                            //
                            // We are about to blow it so just get out
                            //
                            DC_QUIT;
                        }

                        //
                        // Now just copy the data over
                        //
                        memcpy(destbuf, nrmbuf+srcOffset, match[i].length);
                        destbuf   += match[i].length;
                        srcOffset += match[i].length;
                    }
                    else
                    {
                        //
                        // Lossy compression - store the data with
                        // discarding
                        //
                        ENCODE_ORDER_MEGA(destbuf,
                                          CODE_COLOR_IMAGE,
                                          match[i].length,
                                          CODE_MEGA_MEGA_CLR_IMG,
                                          MAX_LENGTH_ORDER,
                                          MAX_LENGTH_LONG_ORDER);
                        TRACE_OUT(( "COLOR_IMAGE %u",match[i].length));

                        //
                        // First check for our approaching the end of the
                        // destination buffer and get out if this is the
                        // case.
                        //
                        if ((destbuf - pDst + (UINT)(match[i].length + 1) / 2) >
                            dstBufferSize)
                        {
                            //
                            // We are about to blow it so just get out
                            //
                            DC_QUIT;
                        }

                        //
                        // For a lossy compress we need to discard every
                        // even byte
                        //
                        while (match[i].length > 1)
                        {
                            *destbuf++ = *(nrmbuf+srcOffset);
                            srcOffset += 2;
                            match[i].length -= 2;
                        }
                        if (match[i].length == 1)
                        {
                            *destbuf++ = *(nrmbuf+srcOffset);
                            srcOffset++;
                        }
                    }
                }
                break;

            default:
                ERROR_OUT(( "Invalid run type %u",match[i].type));
        }
    }

    //
    // return the size of the compressed buffer
    //
    compressedLength = (UINT)(destbuf-pDst);

DC_EXIT_POINT:
    DebugExitDWORD(CompressV2Int, compressedLength);
    return(compressedLength);
}

//
// DecompressV2Int
//
UINT    DecompressV2Int(LPBYTE pSrc,
                                            LPBYTE pDst,
                                            UINT   bytes,
                                            UINT   bpp,
                                            UINT   rowDelta,
                                            LPBYTE nrmbuf)
{
    UINT    codeLength;
    BYTE   codeByte;
    BYTE   codeByte2;
    BYTE   decode;
    BYTE   decodeLite;
    BYTE   decodeMega;
    BYTE   fgChar             = 0xFF;
    BYTE NEAR *destbuf        = nrmbuf;
    LPBYTE  endSrc             = pSrc + bytes;
    BOOL    backgroundNeedsPel = FALSE;
    BOOL    lossyStarted       = FALSE;
    UINT    resultSize         = 0;
    BOOL    firstLine          = TRUE;

    DebugEntry(DecompressV2Int);

    //
    // Loop processing the input
    //
    while(pSrc < endSrc)
    {

        //
        // While we are processing the first line we should keep a look out
        // for the end of the line
        //
        if (firstLine)
        {
            if ((UINT)(destbuf - nrmbuf) >= rowDelta)
            {
                firstLine = FALSE;
                backgroundNeedsPel = FALSE;
            }
        }

        //
        // Trace out the source data for debugging
        //
        TRACE_OUT(( "Next code is %2.2x%2.2x%2.2x%2.2x",
                *pSrc,
                *(pSrc+1),
                *(pSrc+2),
                *(pSrc+3)));

        //
        // Get the decode
        //
        decode     = (BYTE)(*pSrc & CODE_MASK);
        decodeLite = (BYTE)(*pSrc & CODE_MASK_LITE);
        decodeMega = (BYTE)(*pSrc);

        //
        // BG RUN
        //
        if ((decode == CODE_BG_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_BG_RUN))
        {
            if (decode == CODE_BG_RUN)
            {
                EXTRACT_LENGTH(pSrc, codeLength);
            }
            else
            {
                codeLength = EXTRACT_TSHR_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            TRACE_OUT(( "Background run %u",codeLength));

            if (!firstLine)
            {
                if (backgroundNeedsPel)
                {
                    *destbuf++ = (BYTE)(*(destbuf - rowDelta) ^ fgChar);
                    codeLength--;
                }
                while (codeLength-- > 0)
                {
                    *destbuf++ = *(destbuf - rowDelta);
                }
            }
            else
            {
                if (backgroundNeedsPel)
                {
                    *destbuf++ = fgChar;
                    codeLength--;
                }
                while (codeLength-- > 0)
                {
                    *destbuf++ = 0x00;
                }
            }
            //
            // A follow on BG run will need a pel inserted
            //
            backgroundNeedsPel = TRUE;
            continue;
        }

        //
        // For any of the other runtypes a follow on BG run does not need
        // a FG pel inserted
        //
        backgroundNeedsPel = FALSE;

        //
        // FGBG IMAGE
        //
        if ((decode == CODE_FG_BG_IMAGE)      ||
            (decodeLite == CODE_SET_FG_FG_BG) ||
            (decodeMega == CODE_MEGA_MEGA_FGBG)    ||
            (decodeMega == CODE_MEGA_MEGA_SET_FGBG))
        {
            if ((decodeMega == CODE_MEGA_MEGA_FGBG) ||
                (decodeMega == CODE_MEGA_MEGA_SET_FGBG))
            {
                codeLength = EXTRACT_TSHR_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                if (decode == CODE_FG_BG_IMAGE)
                {
                    EXTRACT_LENGTH_FGBG(pSrc, codeLength);
                }
                else
                {
                    EXTRACT_LENGTH_FGBG_LITE(pSrc, codeLength);
                }
            }

            if ((decodeLite == CODE_SET_FG_FG_BG) ||
                (decodeMega == CODE_MEGA_MEGA_SET_FGBG))
            {
                fgChar    = *pSrc++;
                TRACE_OUT(( "Set FGBG image %u",codeLength));
            }
            else
            {
                TRACE_OUT(( "FGBG image     %u",codeLength));
            }

            while (codeLength > 8)
            {
                codeByte  = *pSrc++;
                if (firstLine)
                {
                    STORE_FGBG(0x00, codeByte, fgChar, 8);
                }
                else
                {
                    STORE_FGBG(*(destbuf - rowDelta), codeByte, fgChar, 8);
                }
                codeLength -= 8;
            }
            if (codeLength > 0)
            {
                codeByte  = *pSrc++;
                if (firstLine)
                {
                    STORE_FGBG(0x00, codeByte, fgChar, codeLength);
                }
                else
                {
                   STORE_FGBG(*(destbuf - rowDelta),
                              codeByte,
                              fgChar,
                              codeLength);
                }
            }
            continue;
        }

        //
        // FG RUN
        //
        if ((decode == CODE_FG_RUN) ||
            (decodeLite == CODE_SET_FG_FG_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_FG_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_SET_FG_RUN))
        {

            if ((decodeMega == CODE_MEGA_MEGA_FG_RUN) ||
                (decodeMega == CODE_MEGA_MEGA_SET_FG_RUN))
            {
                codeLength = EXTRACT_TSHR_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                if (decode == CODE_FG_RUN)
                {
                    EXTRACT_LENGTH(pSrc, codeLength);
                }
                else
                {
                    EXTRACT_LENGTH_LITE(pSrc, codeLength);
                }
            }

            //
            // Push the old fgChar down to the ALT position
            //
            if ((decodeLite == CODE_SET_FG_FG_RUN) ||
                (decodeMega  == CODE_MEGA_MEGA_SET_FG_RUN))
            {
                TRACE_OUT(( "Set FG run     %u",codeLength));
                fgChar    = *pSrc++;
            }
            else
            {
                TRACE_OUT(( "FG run         %u",codeLength));
            }

            while (codeLength-- > 0)
            {
                if (!firstLine)
                {
                    *destbuf++ = (BYTE)(*(destbuf - rowDelta) ^ fgChar);
                }
                else
                {
                    *destbuf++ = fgChar;
                }
            }
            continue;
        }

        //
        // DITHERED RUN
        //
        if ((decodeLite == CODE_DITHERED_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_DITHER))
        {
            if (decodeMega == CODE_MEGA_MEGA_DITHER)
            {
                codeLength = EXTRACT_TSHR_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH_LITE(pSrc, codeLength);
            }
            TRACE_OUT(( "Dithered run   %u",codeLength));

            codeByte  = *pSrc++;
            codeByte2 = *pSrc++;
            while (codeLength-- > 0)
            {
                *destbuf++ = codeByte;
                *destbuf++ = codeByte2;
            }
            continue;
        }

        //
        // COLOR IMAGE
        //
        if ((decode == CODE_COLOR_IMAGE) ||
            (decodeMega == CODE_MEGA_MEGA_CLR_IMG))
        {
            if (decodeMega == CODE_MEGA_MEGA_CLR_IMG)
            {
                codeLength = EXTRACT_TSHR_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH(pSrc, codeLength);
            }
            TRACE_OUT(( "Color image    %u",codeLength));

            //
            // If not doing lossy compression then just copy the bytes
            //
            if (!lossyStarted)
            {
                while (codeLength-- > 0)
                {
                    //
                    // Update the target with the character
                    //
                    *destbuf++ = *pSrc++;
                }
            }
            else
            {
                //
                // For lossy compression we must duplicate all the bytes,
                // bar the final odd byte
                //
                while (codeLength > 3)
                {
                    //
                    // Dither the bytes unless they are black in which
                    // case a non-dither is preferable
                    //
                    *destbuf++ = *pSrc;
                    if (*pSrc == 0)
                    {
                        *destbuf++ = *(pSrc);
                        *destbuf++ = *(pSrc+1);
                        *destbuf++ = *(pSrc+1);
                        pSrc += 2;
                    }
                    else
                    {
                        *destbuf++ = *(pSrc+1);
                        *destbuf++ = *pSrc++;
                        *destbuf++ = *pSrc++;
                    }
                    codeLength -= 4;
                }
                if (codeLength == 3)
                {
                    *destbuf++ = *pSrc;
                    *destbuf++ = *(pSrc+1);
                    *destbuf++ = *pSrc;
                    pSrc += 2;
                }
                else
                {
                    if (codeLength == 2)
                    {
                        *destbuf++ = *pSrc;
                        *destbuf++ = *pSrc++;
                    }
                    else
                    {
                        if (codeLength == 1)
                        {
                            *destbuf++ = *pSrc++;
                        }
                    }
                }
            }
            continue;
        }

        //
        // PACKED COLOR IMAGE
        //
        if ((decode == CODE_PACKED_COLOR_IMAGE) ||
            (decodeMega == CODE_MEGA_MEGA_PACKED_CLR))
        {
            if (decodeMega == CODE_MEGA_MEGA_PACKED_CLR)
            {
                codeLength = EXTRACT_TSHR_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH(pSrc, codeLength);
            }
            TRACE_OUT(( "Packed color   %u",codeLength));

            //
            // If not doing lossy compression then we just unpack the 4bpp
            // data two pels per byte
            //
            if (!lossyStarted)
            {
                if (bpp == 4)
                {
                    UINT   worklen = (codeLength)/2;
                    BYTE  workchar;
                    while (worklen--)
                    {
                        workchar   = *pSrc++;
                        *destbuf++ = (BYTE)(workchar>>4);
                        *destbuf++ = (BYTE)(workchar & 0x0F);
                    }
                    if (codeLength & 0x0001)
                    {
                        *destbuf++ = (BYTE)(*pSrc++>>4);
                    }
                }
                else
                {
                    ERROR_OUT(( "Don't support packed color for 8bpp"));
                }
            }
            else
            {
                //
                // For lossy compression we must duplicate all the bytes,
                // bar the final odd byte, again unpacking as we go
                //
                while (codeLength > 3)
                {
                    *destbuf++ = (BYTE)((*pSrc) >> 4);
                    *destbuf++ = (BYTE)((*pSrc) >> 4);
                    *destbuf++ = (BYTE)((*pSrc) & 0x0F);
                    *destbuf++ = (BYTE)((*pSrc) & 0x0F);
                    pSrc++;
                    codeLength -= 4;
                }

                if (codeLength > 0)
                {
                    if (codeLength-- > 0)
                    {
                        *destbuf++ = (BYTE)((*pSrc) >> 4);
                    }
                    if (codeLength-- > 0)
                    {
                        *destbuf++ = (BYTE)((*pSrc) >> 4);
                    }
                    if (codeLength-- > 0)
                    {
                        *destbuf++ = (BYTE)((*pSrc) & 0x0F);
                    }
                    if (codeLength-- > 0)
                    {
                        *destbuf++ = (BYTE)((*pSrc) & 0x0F);
                    }
                    pSrc++;
                }
            }

            continue;
        }

        //
        // COLOR RUN
        //
        if ((decode == CODE_COLOR_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_COLOR_RUN))
        {

            if (decodeMega == CODE_MEGA_MEGA_COLOR_RUN)
            {
                codeLength = EXTRACT_TSHR_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH(pSrc, codeLength);
            }
            TRACE_OUT(( "Color run      %u",codeLength));

            codeByte  = *pSrc++;
            while (codeLength-- > 0)
            {
                *destbuf++ = codeByte;
            }
            continue;
        }


        //
        // If we get here then the code must be a special one
        //
        TRACE_OUT(( "Special code   %x",decodeMega));
        switch (decodeMega)
        {
            case CODE_BLACK:
                *destbuf++ = 0x00;
                break;

            case CODE_WHITE:
                *destbuf++ = 0xFF;
                break;

            //
            // Ignore the unreachable code warnings that follow
            // Simply because we use the STORE_FGBG macro with a constant
            // value
            //
            case CODE_SPECIAL_FGBG_1:
                if (firstLine)
                {
                    STORE_FGBG(0x00, SPECIAL_FGBG_CODE_1, fgChar, 8);
                }
                else
                {
                    STORE_FGBG(*(destbuf - rowDelta),
                               SPECIAL_FGBG_CODE_1,
                               fgChar,
                               8);
                }
                break;

            case CODE_SPECIAL_FGBG_2:
                if (firstLine)
                {
                    STORE_FGBG(0x00,
                               SPECIAL_FGBG_CODE_2,
                               fgChar,
                               8);
                }
                else
                {
                    STORE_FGBG(*(destbuf - rowDelta),
                               SPECIAL_FGBG_CODE_2,
                               fgChar,
                               8);
                }
                break;


            case CODE_START_LOSSY:
                lossyStarted = TRUE;
                break;

            default:
                ERROR_OUT(( "Invalid compression data %x",decodeMega));
                break;
        }
        pSrc++;

    }

    //
    // Our final task is to copy the decoded image into the target buffer
    // compacting if we are generating a 4bpp image
    //
    resultSize = (UINT)(destbuf-nrmbuf);
    if (bpp == 4)
    {
        //
        // Zero the final byte to eliminate single byte packing problems
        //
        *destbuf = 0x00;

        Pack4bpp(pDst, nrmbuf, resultSize);
    }
    else
    {
        memcpy(pDst, nrmbuf, resultSize);
    }
    TRACE_OUT(( "Returning %u bytes",resultSize));

    //
    // Return the number of pixels decoded
    //
    DebugExitDWORD(DecompressV2Int, resultSize);
    return(resultSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\ch.cpp ===
#include "precomp.h"


//
// CH.CPP
// Cache Handler
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE

//
// CACHE HANDLER
//
// The Cache Handler is a generic cache manager that handles blocks of
// memory supplied by the calling component.
//
// Once a cache of a particular size has been created, blocks of memory can
// be added to it (CH_CacheData).  The cache can then be searched
// (CH_SearchCache) to try and match the contents of a given block of
// memory with the blocks in the cache.
//
// When a block is added to the cache and the cache is full, one of the
// blocks currently in the cache is discarded on a Least-Recently Used
// (LRU) basis.
//
// The component that creates the cache specifies a callback function which
// is called every time a block is removed from the cache.  This allows the
// caller to free up memory blocks when they are no longer in use.
//



//
// FUNCTION: CH_CreateCache
//
BOOL  ASHost::CH_CreateCache
(
    PCHCACHE *          ppCache,
    UINT                cCacheEntries,
    UINT                cNumEvictionCategories,
    UINT                cbNotHashed,
    PFNCACHEDEL         pfnCacheDel
)
{
    UINT                cbCacheSize;
    UINT                i;
    PCHCACHE            pCache;

    DebugEntry(ASHost::CH_CreateCache);


    //
    // Initialize return value
    //
    pCache = NULL;

    //
    // Do a few parameter validation checks.
    //
    ASSERT((cCacheEntries > 0));
    ASSERT((cCacheEntries < CH_MAX_CACHE_ENTRIES));
    ASSERT(cNumEvictionCategories > 0);
    ASSERT(cNumEvictionCategories <= CH_NUM_EVICTION_CATEGORIES);


    //
    // Calculate the amount of memory required.
    // NOTE that the CHCACHE definition includes one cache entry
    //
    cbCacheSize = sizeof(CHCACHE) + ((cCacheEntries-1) * sizeof(CHENTRY));

    //
    // Allocate memory for the cache.
    //
    pCache = (PCHCACHE)new BYTE[cbCacheSize];
    if (pCache == NULL)
    {
        ERROR_OUT(("Failed to alloc cache"));
        DC_QUIT;
    }

    SET_STAMP(pCache, CHCACHE);

    pCache->pRoot = NULL;
    pCache->pFirst = NULL;
    pCache->pLast= NULL;
    pCache->free = 0;

    pCache->cEntries = cCacheEntries;
    pCache->cNumEvictionCategories = cNumEvictionCategories;
    pCache->cbNotHashed = cbNotHashed;
    pCache->pfnCacheDel = pfnCacheDel;

    //
    // Initialize the cache entries
    //
    for (i = 0; i < cCacheEntries; i++)
    {
        CHInitEntry(&pCache->Entry[i]);
        pCache->Entry[i].free = (WORD)(i+1);
    }
    pCache->Entry[cCacheEntries-1].free = CH_MAX_CACHE_ENTRIES;

    //
    // Set up the default eviction category limits. Default is to balance
    // at 75% to the high category, 75% of the remainder to the next lower
    // and so on
    //
    for (i = cNumEvictionCategories; i > 0; i--)
    {
        pCache->iMRUHead[i-1] = CH_MAX_CACHE_ENTRIES;
        pCache->iMRUTail[i-1] = CH_MAX_CACHE_ENTRIES;
        pCache->cEvictThreshold[i-1] = (WORD)((cCacheEntries*3)/4);
    }

DC_EXIT_POINT:
    *ppCache = pCache;
    DebugExitBOOL(ASHost::CH_CreateCache, (pCache != NULL));
    return(pCache != NULL);
}


//
// CH_DestroyCache
// Destroys a created cache, if it is valid.
//
void ASHost::CH_DestroyCache(PCHCACHE pCache)
{
    DebugEntry(ASHost::CH_DestroyCache);

    ASSERT(IsValidCache(pCache));

    //
    // Clear the entries in the cache
    //
    CH_ClearCache(pCache);

    //
    // Free the memory
    //
    delete pCache;

    DebugExitVOID(ASHost::CH_DestroyCache);
}


//
// FUNCTION: CH_SearchCache
//
BOOL  ASHost::CH_SearchCache
(
    PCHCACHE    pCache,
    LPBYTE      pData,
    UINT        cbDataSize,
    UINT        evictionCategory,
    UINT *      piCacheEntry
)
{
    BOOL        rc = FALSE;
    UINT        checkSum;

    DebugEntry(ASHost::CH_SearchCache);

    ASSERT(IsValidCache(pCache));

    checkSum = CHCheckSum(pData + pCache->cbNotHashed,
        cbDataSize - pCache->cbNotHashed);

    *piCacheEntry = CHTreeSearch(pCache, checkSum, cbDataSize, pData);
    if ( *piCacheEntry != CH_MAX_CACHE_ENTRIES )
    {
        //
        // Found a match
        //
        CHUpdateMRUList(pCache, *piCacheEntry, evictionCategory);
        rc = TRUE;
    }

    DebugExitBOOL(ASHost::CH_SearchCache, rc);
    return(rc);
}

//
// FUNCTION: CH_CacheData
//
UINT  ASHost::CH_CacheData
(
    PCHCACHE    pCache,
    LPBYTE      pData,
    UINT        cbDataSize,
    UINT        evictionCategory
)
{
    UINT        evictionCount;
    UINT        iEntry = CH_MAX_CACHE_ENTRIES;
    PCHENTRY    pEntry;

    DebugEntry(ASHost::CH_CacheData);

    ASSERT(IsValidCache(pCache));
    ASSERT((evictionCategory < pCache->cNumEvictionCategories));

    if (!CHFindFreeCacheEntry(pCache, &iEntry, &evictionCount))
    {
        iEntry = CHEvictLRUCacheEntry(pCache, evictionCategory, evictionCount);

        //
        // MNM1422: Ideally we would now call CHFindFreeCacheEntry again to
        // get the entry freed up by the eviction process - but since we
        // have just been returned that entry, we may as well use it to
        // improve performance.
        //
        // However, the processing has left pTreeCacheData->tree.free
        // pointing to the entry we have just evicted - which we are about
        // to use.  So we need to perform the same processing on the free
        // list as CHFindFreeCacheEntry would have done, or next time
        // through, the first 'free' entry will really be in use, and the
        // insert code will assert!
        //
        ASSERT(pCache->free == iEntry);
        pCache->free = pCache->Entry[iEntry].free;
    }

    pEntry = &pCache->Entry[iEntry];
    pEntry->pData = pData;
    pEntry->cbData = cbDataSize;
    pEntry->checkSum = CHCheckSum(pData + pCache->cbNotHashed,
                                 cbDataSize - pCache->cbNotHashed);
    pEntry->evictionCategory = (WORD)evictionCategory;
    CHAvlInsert(pCache, pEntry);

    TRACE_OUT(( "Cache 0x%08x entry %d checksum 0x%08x data 0x%08x",
        pCache, iEntry, pEntry->checkSum, pEntry->pData));

    CHUpdateMRUList(pCache, iEntry, evictionCategory);

    DebugExitDWORD(ASHost::CH_CacheData, iEntry);
    return(iEntry);
}


//
// FUNCTION: CH_SearchAndCacheData
//
BOOL  ASHost::CH_SearchAndCacheData
(
    PCHCACHE    pCache,
    LPBYTE      pData,
    UINT        cbDataSize,
    UINT        evictionCategory,
    UINT *      piCacheEntry
)
{
    UINT        checkSum;
    UINT        i;
    BOOL        preExisting;
    UINT        iEntry        = CH_MAX_CACHE_ENTRIES;
    UINT        evictionCount = 0;
    PCHENTRY    pEntry;

    DebugEntry(ASHost::CH_SearchAndCacheData);

    ASSERT(IsValidCache(pCache));
    ASSERT(evictionCategory < pCache->cNumEvictionCategories);

    //
    // Does this entry exist?
    //
    checkSum = CHCheckSum(pData + pCache->cbNotHashed,
                          cbDataSize - pCache->cbNotHashed);

    iEntry = CHTreeSearch(pCache, checkSum, cbDataSize, pData);
    if ( iEntry == CH_MAX_CACHE_ENTRIES)
    {
        preExisting = FALSE;
        //
        // We didn't find the entry--can we add it?
        //
        TRACE_OUT(("CACHE: entry not found in cache 0x%08x csum 0x%08x",
            pCache, checkSum));

        if (!CHFindFreeCacheEntry(pCache, &iEntry, &evictionCount))
        {
            //
            // Nope.  Evict an entry
            //
            iEntry = CHEvictLRUCacheEntry(pCache, evictionCategory, evictionCount);

            ASSERT(iEntry != CH_MAX_CACHE_ENTRIES);

            TRACE_OUT(("CACHE: no free entries so evicted cache 0x%08x entry %d",
                pCache, iEntry));

            //
            // Ideally we would now call CHFindFreeCacheEntry again to
            // get the entry freed up via the eviction process, but since
            // we just returned that entry use to to improve perf.
            //
            // However, the processing has left pCache->free pointing
            // to the entry we just evicted and are about to use.  So
            // we need to fix it up.
            //
            ASSERT(pCache->free == iEntry);
            pCache->free = pCache->Entry[iEntry].free;
        }


        //
        // Fill in this entry's data
        //
        pEntry = &pCache->Entry[iEntry];
        pEntry->pData = pData;
        pEntry->cbData = cbDataSize;
        pEntry->checkSum = checkSum;
        pEntry->evictionCategory = (WORD)evictionCategory;

        CHAvlInsert(pCache, pEntry);
        TRACE_OUT(( "CACHE: NEW ENTRY cache 0x%08x entry %d csum 0x%08x pdata 0x%08x",
            pCache, iEntry, checkSum,  pEntry->pData));
    }
    else
    {
        //
        // We found the entry
        //
        preExisting = TRUE;

        TRACE_OUT(( "CACHE: entry found in cache 0x%08x entry %d csum 0x%08x",
                pCache, iEntry, checkSum));
    }

    CHUpdateMRUList(pCache, iEntry, evictionCategory);
    *piCacheEntry = iEntry;

    DebugExitBOOL(ASHost::CH_SearchAndCacheData, preExisting);
    return(preExisting);
}


//
// FUNCTION: CH_RemoveCacheEntry
//
void  ASHost::CH_RemoveCacheEntry
(
    PCHCACHE    pCache,
    UINT        iCacheEntry
)
{
    DebugEntry(ASHost::CH_RemoveCacheEntry);

    ASSERT(IsValidCache(pCache));
    ASSERT(IsValidCacheIndex(pCache, iCacheEntry));

    CHEvictCacheEntry(pCache, iCacheEntry, pCache->Entry[iCacheEntry].evictionCategory);

    DebugExitVOID(ASHost::CH_RemoveCacheEntry);
}

//
// FUNCTION: CH_ClearCache
//
void  ASHost::CH_ClearCache
(
    PCHCACHE pCache
)
{
    UINT    i;

    DebugEntry(ASHost::CH_ClearCache);

    ASSERT(IsValidCache(pCache));

    //
    // Remove the cache entries
    //
    for (i = 0; i < pCache->cEntries; i++)
    {
        if (pCache->Entry[i].pData != NULL)
        {
            CHRemoveEntry(pCache, i);
        }
    }

    DebugExitVOID(ASHost::CH_ClearCache);
}



//
// CH_TouchCacheEntry() - see ch.h
//
void ASHost::CH_TouchCacheEntry
(
    PCHCACHE    pCache,
    UINT        iCacheEntry
)
{
    DebugEntry(ASHost::CH_TouchCacheEntry);

    ASSERT(IsValidCache(pCache));
    ASSERT(IsValidCacheIndex(pCache, iCacheEntry));

    TRACE_OUT(( "Touching cache entry 0x%08x %d", pCache, iCacheEntry));

    CHUpdateMRUList(pCache, iCacheEntry, 0);

    DebugExitVOID(ASHost::CH_TouchCacheEntry);
}



//
// CHInitEntry
// Initializes a cache entry
//
//
void ASHost::CHInitEntry(PCHENTRY pEntry)
{
    pEntry->pParent     = NULL;
    pEntry->pLeft       = NULL;
    pEntry->pRight      = NULL;
    pEntry->pData       = NULL;
    pEntry->checkSum    = 0;
    pEntry->lHeight     = 0xFFFF;
    pEntry->rHeight     = 0xFFFF;
    pEntry->chain.next  = CH_MAX_CACHE_ENTRIES;
    pEntry->chain.prev  = CH_MAX_CACHE_ENTRIES;
    pEntry->cbData      = 0;
}



//
// FUNCTION: CHUpdateMRUList
//
void  ASHost::CHUpdateMRUList
(
    PCHCACHE    pCache,
    UINT        iEntry,
    UINT        evictionCategory
)
{
    WORD        inext;
    WORD        iprev;

    DebugEntry(ASHost::CHUpdateMRUList);

    //
    // Move the given entry to the head of the MRU if isn't there already
    //

    if (pCache->iMRUHead[evictionCategory] != iEntry)
    {
        //
        // Remove the supplied entry from the MRU list, if it is currently
        // chained.  Since we never do this if the entry is already in the
        // front, an iprev of CH_MAX_CACHE_ENTRIES indicates that we are
        // updated an unchained entry.
        //
        iprev = pCache->Entry[iEntry].chain.prev;
        inext = pCache->Entry[iEntry].chain.next;
        TRACE_OUT(("Add/promote entry %u which was chained off %hu to %hu",
                    iEntry,iprev,inext));

        if (iprev != CH_MAX_CACHE_ENTRIES)
        {
            pCache->Entry[iprev].chain.next = inext;
            if (inext != CH_MAX_CACHE_ENTRIES)
            {
                pCache->Entry[inext].chain.prev = iprev;
            }
            else
            {
                TRACE_OUT(("Removing final entry(%u) from MRU chain leaving %hu at tail",
                            iEntry, iprev));
                pCache->iMRUTail[evictionCategory] = iprev;
            }
        }

        //
        // Now add this entry to the head of the MRU list
        //
        inext = pCache->iMRUHead[evictionCategory];
        pCache->Entry[iEntry].chain.next = inext;
        pCache->Entry[iEntry].chain.prev = CH_MAX_CACHE_ENTRIES;
        pCache->iMRUHead[evictionCategory] = (WORD)iEntry;

        if (inext != CH_MAX_CACHE_ENTRIES)
        {
            pCache->Entry[inext].chain.prev = (WORD)iEntry;
        }
        else
        {
            //
            // If the MRU chain is currently empty, then we must first add
            // the entry to the tail of the chain.
            //
            pCache->iMRUTail[evictionCategory] = (WORD)iEntry;
            TRACE_OUT(("Cache 0x%08x entry %u is first so add to MRU %u tail",
                          pCache, iEntry, evictionCategory));
        }

        TRACE_OUT(( "Cache 0x%08x entry %u to head of MRU category %u",
                pCache, iEntry, evictionCategory));

    }
    else
    {
        TRACE_OUT(("Cache 0x%08x entry %u already at head of eviction category %u",
            pCache, iEntry, evictionCategory));
    }

    DebugExitVOID(ASHost::CHUpateMRUList);
}


//
// FUNCTION: CHFindFreeCacheEntry
//
BOOL  ASHost::CHFindFreeCacheEntry
(
    PCHCACHE    pCache,
    UINT*       piEntry,
    UINT*       pEvictionCount
)
{
    UINT        iEntry;
    BOOL        rc = FALSE;

    DebugEntry(ASHost::CHFindFreeCacheEntry);

    ASSERT(IsValidCache(pCache));

    iEntry = pCache->free;
    if (iEntry == CH_MAX_CACHE_ENTRIES)
    {
        TRACE_OUT(( "Cache 0x%08x is full", pCache));

        *pEvictionCount = pCache->cEntries;
        rc = FALSE;
    }
    else
    {
        TRACE_OUT(( "Free entry at %u",iEntry));

        *piEntry = iEntry;
        pCache->free = pCache->Entry[iEntry].free;

        *pEvictionCount = 0;
        rc = TRUE;
    }

    DebugExitBOOL(ASHost::CHFindFreeCacheEntry, rc);
    return(rc);
}

//
// FUNCTION: CHEvictCacheEntry
//
UINT  ASHost::CHEvictCacheEntry
(
    PCHCACHE    pCache,
    UINT        iEntry,
    UINT        evictionCategory
)
{
    WORD        inext;
    WORD        iprev;

    DebugEntry(ASHost::CHEvictCacheEntry);

    //
    // Evict the specified entry by removing it from the MRU chain, and
    // then resetting it.  If it is in the cache, it must be in an MRU
    // cache.
    //

    inext = pCache->Entry[iEntry].chain.next;
    iprev = pCache->Entry[iEntry].chain.prev;
    TRACE_OUT(( "Evicting entry %u which was chained off %hu to %hu",
        iEntry, iprev, inext));

    if (iprev < CH_MAX_CACHE_ENTRIES)
    {
        pCache->Entry[iprev].chain.next = inext;
    }
    else
    {
        TRACE_OUT(("Removing head entry(%u) from MRU chain leaving %hu at head",
            iEntry, inext));
        pCache->iMRUHead[evictionCategory] = inext;
    }

    if (inext < CH_MAX_CACHE_ENTRIES)
    {
        pCache->Entry[inext].chain.prev = iprev;
    }
    else
    {
        TRACE_OUT(("Removing tail entry(%u) from MRU chain leaving %hu at tail",
            iEntry, iprev));
        pCache->iMRUTail[evictionCategory] = iprev;
    }

    CHRemoveEntry(pCache, iEntry);

    DebugExitDWORD(ASHost::CHEvictCacheEntry, iEntry);
    return(iEntry);
}


//
// FUNCTION: CHEvictLRUCacheEntry
//
UINT  ASHost::CHEvictLRUCacheEntry
(
    PCHCACHE    pCache,
    UINT        evictionCategory,
    UINT        evictionCount
)
{
    UINT        iEntry;
    UINT        i;

    DebugEntry(ASHost::CHEvictLRUCacheEntry);

    TRACE_OUT(("0x%08x LRU eviction requested, category %u, count %u",
           pCache, evictionCategory, evictionCount));

    //
    // Evict from the same eviction category provided the number cached
    // is above the threshold.  Otherwise, take from the category one above.
    // This will allow the system to eventually stabilize at the correct
    // thresholds as all cache entries get used up.
    //
    if (evictionCount < pCache->cEvictThreshold[evictionCategory])
    {
        for (i = 0; i < pCache->cNumEvictionCategories; i++)
        {
            evictionCategory = (evictionCategory + 1) %
                               pCache->cNumEvictionCategories;
            if (pCache->iMRUTail[evictionCategory] != CH_MAX_CACHE_ENTRIES)
                break;
        }

        WARNING_OUT(( "Threshold %u, count %u so set eviction category to %u",
                pCache->cEvictThreshold[evictionCategory],
                evictionCount,
                evictionCategory));
    }

    //
    // Evict the lasat entry in the MRU chain
    //
    iEntry = pCache->iMRUTail[evictionCategory];
    TRACE_OUT(( "Selected %u for eviction",iEntry));
    ASSERT((iEntry != CH_MAX_CACHE_ENTRIES));

    CHEvictCacheEntry(pCache, iEntry, evictionCategory);

    DebugExitDWORD(ASHost::CHEvictLRUCacheEntry, iEntry);
    return(iEntry);
}



//
// FUNCTION: CHRemoveEntry
//
void  ASHost::CHRemoveEntry
(
    PCHCACHE    pCache,
    UINT        iCacheEntry
)
{
    DebugEntry(ASHost::CHRemoveEntry);

    ASSERT(IsValidCache(pCache));
    ASSERT(IsValidCacheIndex(pCache, iCacheEntry));

    if (pCache->Entry[iCacheEntry].pData != NULL)
    {
        if (pCache->pfnCacheDel)
        {
            (pCache->pfnCacheDel)(this, pCache, iCacheEntry,
                pCache->Entry[iCacheEntry].pData);
        }
        else
        {
            // Simple deletion -- just free memory
            delete[] pCache->Entry[iCacheEntry].pData;
        }
    }

    CHAvlDelete(pCache, &pCache->Entry[iCacheEntry], iCacheEntry);

    DebugExitVOID(ASHost::CHRemoveEntry);
}

//
// FUNCTION: CHCheckSum
//
// For processing speed we calculate the checksum based on whole multiples
// of 4 bytes followed by a final addition of the last few bytes
//
UINT  ASHost::CHCheckSum
(
    LPBYTE  pData,
    UINT    cbDataSize
)
{
    UINT    cSum = 0;
    UINT *  pCh;
    UINT *  pEnd;
    LPBYTE  pCh8;

    DebugEntry(ASHost::CHCheckSum);

    ASSERT(cbDataSize > 3);

    pCh  = (UINT *)pData;
    pEnd = (UINT *)(pData + cbDataSize - 4);

    //
    // Get the DWORD-aligned checksum
    //
    while (pCh <= pEnd)
    {
        cSum = (cSum << 1) + *pCh++ + ((cSum & 0x80000000) != 0);
    }

    //
    // Get the rest past the last DWORD boundaray
    //
    pEnd = (UINT *)(pData + cbDataSize);
    for (pCh8 = (LPBYTE)pCh; pCh8 < (LPBYTE)pEnd; pCh8++)
    {
        cSum = cSum + *pCh8;
    }

    DebugExitDWORD(ASHost::CHCheckSum, cSum);
    return(cSum);
}

//
// FUNCTION: CHTreeSearch
//
// Finds a node in the cache tree which matches size, checksum and data.
//
UINT  ASHost::CHTreeSearch
(
    PCHCACHE    pCache,
    UINT        checkSum,
    UINT        cbDataSize,
    LPBYTE      pData
)
{
    PCHENTRY    pEntry;
    UINT        iCacheEntry = CH_MAX_CACHE_ENTRIES;

    DebugEntry(ASHost::CHTreeSearch);

    pEntry = CHAvlFind(pCache, checkSum, cbDataSize);
    while (pEntry != NULL)
    {
        ASSERT(IsValidCacheEntry(pEntry));

        //
        // Found a match based on the checksum.  Now see if the data
        // also matches.
        //
        if (!memcmp(pEntry->pData + pCache->cbNotHashed,
                            pData + pCache->cbNotHashed,
                            cbDataSize - pCache->cbNotHashed))
        {
            //
            // Data also matches.  Get an index into the memory block
            // of the cache.
            //
            iCacheEntry = pEntry - pCache->Entry;
            TRACE_OUT(( "Cache 0x%08x entry %d match-csum 0x%08x",
                    pCache, iCacheEntry, checkSum));
            break;
        }
        else
        {
            TRACE_OUT(( "Checksum 0x%08x size %u matched, data didn't",
                         checkSum, cbDataSize));

            pEntry = CHAvlFindEqual(pCache, pEntry);
        }
    }

    DebugExitDWORD(ASHost::CHTreeSearch, iCacheEntry);
    return(iCacheEntry);
}


//
// Name:      CHAvlInsert
//
// Purpose:   Insert the supplied node into the specified AVL tree
//
// Returns:   Nothing
//
// Params:    IN    pTree              - a pointer to the AVL tree
//            IN    pEntry              - a pointer to the node to insert
//
// Operation: Scan down the tree looking for the insert point, going left
//            if the insert key is less than or equal to the key in the tree
//            and right if it is greater. When the insert point is found
//            insert the new node and rebalance the tree if necessary.
//
//
void  ASHost::CHAvlInsert
(
    PCHCACHE    pCache,
    PCHENTRY    pEntry
)
{
    PCHENTRY    pParentEntry;
    int         result;

    DebugEntry(ASHost::CHAvlInsert);

    ASSERT(IsValidCacheEntry(pEntry));
    ASSERT(!IsCacheEntryInTree(pEntry));

    pEntry->rHeight = 0;
    pEntry->lHeight = 0;

    if (pCache->pRoot == NULL)
    {
        //
        // tree is empty, so insert at root
        //
        TRACE_OUT(( "tree is empty, so insert at root" ));
        pCache->pRoot = pEntry;
        pCache->pFirst = pEntry;
        pCache->pLast = pEntry;
        DC_QUIT;
    }

    //
    // scan down the tree looking for the appropriate insert point
    //
    TRACE_OUT(( "scan for insert point" ));
    pParentEntry = pCache->pRoot;
    while (pParentEntry != NULL)
    {
        //
        // go left or right, depending on comparison
        //
        result = CHCompare(pEntry->checkSum, pEntry->cbData, pParentEntry);

        if (result > 0)
        {
            //
            // new key is greater than this node's key, so move down right
            // subtree
            //
            TRACE_OUT(( "move down right subtree" ));
            if (pParentEntry->pRight == NULL)
            {
                //
                // right subtree is empty, so insert here
                //
                TRACE_OUT(( "right subtree empty, insert here" ));

                pEntry->pParent = pParentEntry;
                ASSERT((pParentEntry != pEntry));

                pParentEntry->pRight = pEntry;
                pParentEntry->rHeight = 1;
                if (pParentEntry == pCache->pLast)
                {
                    //
                    // parent was the right-most node in the tree, so new
                    // node is now right-most
                    //
                    TRACE_OUT(( "new last node" ));
                    pCache->pLast = pEntry;
                }
                break;
            }
            else
            {
                //
                // right subtree is not empty
                //
                TRACE_OUT(( "right subtree not empty" ));
                pParentEntry = pParentEntry->pRight;
            }
        }
        else
        {
            //
            // New key is less than or equal to this node's key, so move
            // down left subtree.  The new node could be inserted before
            // the current node when equal, but this happens so rarely
            // that it's not worth special casing.
            //
            TRACE_OUT(( "move down left subtree" ));
            if (pParentEntry->pLeft == NULL)
            {
                //
                // left subtree is empty, so insert here
                //
                TRACE_OUT(( "left subtree empty, insert here" ));
                pEntry->pParent = pParentEntry;
                ASSERT((pParentEntry != pEntry));

                pParentEntry->pLeft = pEntry;
                pParentEntry->lHeight = 1;
                if (pParentEntry == pCache->pFirst)
                {
                    //
                    // parent was the left-most node in the tree, so new
                    // node is now left-most
                    //
                    TRACE_OUT(( "new first node" ));
                    pCache->pFirst = pEntry;
                }
                break;
            }
            else
            {
                //
                // left subtree is not empty
                //
                TRACE_OUT(( "left subtree not empty" ));
                pParentEntry = pParentEntry->pLeft;
            }
        }
    }

    //
    // now rebalance the tree if necessary
    //
    CHAvlBalanceTree(pCache, pParentEntry);

DC_EXIT_POINT:
    DebugExitVOID(ASHost::CHAvlInsert);
}



//
// Name:      CHAvlDelete
//
// Purpose:   Delete the specified node from the specified AVL tree
//
// Returns:   Nothing
//
// Params:    IN    pCache              - a pointer to the AVL tree
//            IN    pEntry              - a pointer to the node to delete
//
//
void  ASHost::CHAvlDelete
(
    PCHCACHE    pCache,
    PCHENTRY    pEntry,
    UINT        iCacheEntry
)
{
    PCHENTRY    pReplaceEntry;
    PCHENTRY    pParentEntry;
    WORD        newHeight;

    DebugEntry(ASHost::CHAvlDelete);

    ASSERT(IsValidCacheEntry(pEntry));
    ASSERT(IsCacheEntryInTree(pEntry));


    if ((pEntry->pLeft == NULL) && (pEntry->pRight == NULL))
    {
        //
        // Barren node (no children).  Update all references to it with
        // our parent.
        //
        TRACE_OUT(( "delete barren node" ));
        pReplaceEntry = NULL;

        if (pCache->pFirst == pEntry)
        {
            //
            // We are the first in the b-tree
            //
            TRACE_OUT(( "replace first node in tree" ));
            pCache->pFirst = pEntry->pParent;
        }

        if (pCache->pLast == pEntry)
        {
            //
            // We are the last in the b-tree
            //
            TRACE_OUT(( "replace last node in tree" ));
            pCache->pLast = pEntry->pParent;
        }
    }
    else if (pEntry->pLeft == NULL)
    {
        //
        // This node has no left child,  so update references to it with
        // pointer to right child.
        //
        TRACE_OUT(( "node has no left child, replace with right child" ));
        pReplaceEntry = pEntry->pRight;

        if (pCache->pFirst == pEntry)
        {
            //
            // We are the first in the b-tree
            //
            TRACE_OUT(( "replace first node in tree" ));
            pCache->pFirst = pReplaceEntry;
        }

        // WE CAN'T BE THE LAST IN THE B-TREE SINCE WE HAVE A RIGHT CHILD
        ASSERT(pCache->pLast != pEntry);
    }
    else if (pEntry->pRight == NULL)
    {
        //
        // This node has no right child, so update references to it with
        // pointer to left child.
        //
        TRACE_OUT(( "node has no right son, replace with left son" ));
        pReplaceEntry = pEntry->pLeft;

        // WE CAN'T BE THE FIRST IN THE B-TREE SINCE WE HAVE A LEFT CHILD
        ASSERT(pCache->pFirst != pEntry);

        if (pCache->pLast == pEntry)
        {
            //
            // We are the last in the b-tree
            //
            TRACE_OUT(( "replace last node in tree" ));
            pCache->pLast = pReplaceEntry;
        }
    }
    else
    {
        //
        // HARDEST CASE.  WE HAVE LEFT AND RIGHT CHILDREN
        TRACE_OUT(( "node has two sons" ));
        if (pEntry->rHeight > pEntry->lHeight)
        {
            //
            // Right subtree is bigger than left subtree
            //
            TRACE_OUT(( "right subtree is higher" ));
            if (pEntry->pRight->pLeft == NULL)
            {
                //
                // Replace references to entry with right child since it
                // has no left child (left grandchild of us)
                //
                TRACE_OUT(( "replace node with right son" ));
                pReplaceEntry = pEntry->pRight;
                pReplaceEntry->pLeft = pEntry->pLeft;
                pReplaceEntry->pLeft->pParent = pReplaceEntry;
                pReplaceEntry->lHeight = pEntry->lHeight;
            }
            else
            {
                //
                // Swap with leftmost descendent of the right subtree
                //
                TRACE_OUT(( "swap with left-most right descendent" ));
                CHAvlSwapLeftmost(pCache, pEntry->pRight, pEntry);
                pReplaceEntry = pEntry->pRight;
            }
        }
        else
        {
            //
            // Left subtree is bigger than or equal to right subtree
            //
            TRACE_OUT(( "left subtree is higher" ));
            TRACE_OUT(( "(or both subtrees are of equal height)" ));
            if (pEntry->pLeft->pRight == NULL)
            {
                //
                // Replace references to entry with left child since it
                // no right child (right grandchild of us)
                //
                TRACE_OUT(( "replace node with left son" ));
                pReplaceEntry = pEntry->pLeft;
                pReplaceEntry->pRight = pEntry->pRight;
                pReplaceEntry->pRight->pParent = pReplaceEntry;
                pReplaceEntry->rHeight = pEntry->rHeight;
            }
            else
            {
                //
                // Swap with rightmost descendent of the left subtree
                //
                TRACE_OUT(( "swap with right-most left descendent" ));
                CHAvlSwapRightmost(pCache, pEntry->pLeft, pEntry);
                pReplaceEntry = pEntry->pLeft;
            }
        }
    }

    //
    // NOTE:  We can not save parent entry above because some code might
    // swap the tree around.  In which case, our parenty entry will change
    // out from underneath us.
    //
    pParentEntry = pEntry->pParent;

    //
    // Clear out the about-to-be-deleted cache entry
    //
    TRACE_OUT(( "reset deleted node" ));
    CHInitEntry(pEntry);

    if (pReplaceEntry != NULL)
    {
        //
        // Fix up parent pointers, and calculate new heights of subtree
        //
        TRACE_OUT(( "fixup parent pointer of replacement node" ));
        pReplaceEntry->pParent = pParentEntry;
        newHeight = (WORD)(1 + max(pReplaceEntry->lHeight, pReplaceEntry->rHeight));
    }
    else
    {
        newHeight = 0;
    }
    TRACE_OUT(( "new height of parent is %d", newHeight ));

    if (pParentEntry != NULL)
    {
        //
        // Fixup parent entry pointers
        //
        TRACE_OUT(( "fix-up parent node" ));
        if (pParentEntry->pRight == pEntry)
        {
            //
            //  Entry is right child of parent
            //
            TRACE_OUT(( "replacement node is right son" ));
            pParentEntry->pRight = pReplaceEntry;
            pParentEntry->rHeight = newHeight;
        }
        else
        {
            //
            // Entry is left child of parent
            //
            TRACE_OUT(( "replacement node is left son" ));
            pParentEntry->pLeft = pReplaceEntry;
            pParentEntry->lHeight = newHeight;
        }

        //
        // Now rebalance the tree if necessary
        //
        CHAvlBalanceTree(pCache, pParentEntry);
    }
    else
    {
        //
        // Replacement is now root of tree
        //
        TRACE_OUT(( "replacement node is now root of tree" ));
        pCache->pRoot = pReplaceEntry;
    }


    //
    // Put entry back into free list.
    //
    pEntry->free = pCache->free;
    pCache->free = (WORD)iCacheEntry;

    DebugExitVOID(ASHost::CHAvlDelete);
}


//
// Name:      CHAvlNext
//
// Purpose:   Find next node in the AVL tree
//
// Returns:   A pointer to the next node's data
//
// Params:    IN     pEntry             - a pointer to the current node in
//                                       the tree
//
// Operation: If the specified node has a right-son then return the left-
//            most son of this. Otherwise search back up until we find a
//            node of which we are in the left sub-tree and return that.
//
//
LPBYTE ASHost::CHAvlNext
(
    PCHENTRY pEntry
)
{
    //
    // find next node in tree
    //
    DebugEntry(ASHost::CHAvlNext);

    ASSERT(IsValidCacheEntry(pEntry));
    ASSERT(IsCacheEntryInTree(pEntry));

    if (pEntry->pRight != NULL)
    {
        //
        // Next entry is the left-most in the right-subtree
        //
        TRACE_OUT(( "next node is left-most right descendent" ));
        pEntry = pEntry->pRight;
        ASSERT(IsValidCacheEntry(pEntry));

        while (pEntry->pLeft != NULL)
        {
            ASSERT(IsValidCacheEntry(pEntry->pLeft));
            pEntry = pEntry->pLeft;
        }
    }
    else
    {
        //
        // No right child.  So find an entry for which we are in its left
        // subtree.
        //
        TRACE_OUT(( "find node which this is in left subtree of" ));

        while (pEntry != NULL)
        {
            ASSERT(IsValidCacheEntry(pEntry));

            if ((pEntry->pParent == NULL) ||
                (pEntry->pParent->pLeft == pEntry))
            {
                pEntry = pEntry->pParent;
                break;
            }
            pEntry = pEntry->pParent;
        }
    }

    DebugExitVOID(ASHost::CHAvlNext);
    return((pEntry != NULL) ? pEntry->pData : NULL);
}



//
// Name:      CHAvlPrev
//
// Purpose:   Find previous node in the AVL tree
//
// Returns:   A pointer to the previous node's data in the tree
//
// Params:    IN     PNode             - a pointer to the current node in
//                                       the tree
//
// Operation: If we have a left-son then the previous node is the right-most
//            son of this. Otherwise, look for a node of whom we are in the
//            left subtree and return that.
//
//
LPBYTE  ASHost::CHAvlPrev(PCHENTRY pEntry)
{
    //
    // find previous node in tree
    //
    DebugEntry(ASHost::CHAvlPrev);

    ASSERT(IsValidCacheEntry(pEntry));
    ASSERT(IsCacheEntryInTree(pEntry));

    if (pEntry->pLeft != NULL)
    {
        //
        // Previous entry is right-most in left-subtree
        //
        TRACE_OUT(( "previous node is right-most left descendent" ));

        pEntry = pEntry->pLeft;
        ASSERT(IsValidCacheEntry(pEntry));

        while (pEntry->pRight != NULL)
        {
            ASSERT(IsValidCacheEntry(pEntry->pRight));
            pEntry = pEntry->pRight;
        }
    }
    else
    {
        //
        // No left child.  So find an entry for which we are in the right
        // subtree.
        //
        TRACE_OUT(( "find node which this is in right subtree of"));
        while (pEntry != NULL)
        {
            ASSERT(IsValidCacheEntry(pEntry));

            if ((pEntry->pParent == NULL) ||
                (pEntry->pParent->pRight == pEntry))
            {
                pEntry = pEntry->pParent;
                break;
            }

            pEntry = pEntry->pParent;
        }
    }

    DebugExitVOID(ASHost::CHAvlPrev);
    return((pEntry != NULL) ? pEntry->pData : NULL);
}



//
// Name:      CHAvlFindEqual
//
// Purpose:   Find the node in the AVL tree with the same key and size as
//            the supplied node
//
// Returns:   A pointer to the node
//            NULL if no node is found with the specified key and size
//
// Params:    IN     pCache              - a pointer to the AVL tree
//            IN     pEntry              - a pointer to the node to test
//
// Operation: Check if the left node has the same key and size, returning
//            a pointer to its data if it does.
//
//
PCHENTRY  ASHost::CHAvlFindEqual
(
    PCHCACHE    pCache,
    PCHENTRY    pEntry
)
{
    int         result;
    PCHENTRY    pReturn = NULL;

    DebugEntry(ASHost::CHAvlFindEqual);

    ASSERT(IsValidCacheEntry(pEntry));

    if (pEntry->pLeft)
    {
        ASSERT(IsValidCacheEntry(pEntry->pLeft));

        result = CHCompare(pEntry->pLeft->checkSum, pEntry->cbData, pEntry);

        if (result < 0)
        {
            //
            // specified key is less than key of this node - this is what
            // will normally occur
            //
            TRACE_OUT(( "left node size %u csum 0x%08x",
                     pEntry->pLeft->cbData,
                     pEntry->pLeft->checkSum));
        }
        else if (result == 0)
        {
            //
            // Found a match on size and key.
            //
            TRACE_OUT(( "left node dups size and key" ));
            pReturn = pEntry->pLeft;
        }
        else
        {
            //
            // This is an error (left node should never be greater)
            //
            ERROR_OUT(( "left node csum %#lx, supplied %#lx",
                     pEntry->pLeft->checkSum,
                     pEntry->checkSum));
        }
    }

    DebugExitPVOID(ASHost::CHAvlFindEqual, pReturn);
    return(pReturn);
}





//
// Name:      CHAvlFind
//
// Purpose:   Find the node in the AVL tree with the supplied key and size
//
// Returns:   A pointer to the node
//            NULL if no node is found with the specified key and size
//
// Params:    IN     pCache              - a pointer to the AVL tree
//            IN     checkSum           - a pointer to the key
//            IN     cbSize             - number of node data bytes
//
// Operation: Search down the tree going left if the search key is less than
//            the node in the tree and right if the search key is greater.
//            When we run out of tree to search through either we've found
//            it or the node is not in the tree.
//
//
PCHENTRY  ASHost::CHAvlFind
(
    PCHCACHE    pCache,
    UINT        checkSum,
    UINT        cbSize
)
{
    PCHENTRY    pEntry;
    int         result;

    DebugEntry(ASHost::CHAvlFind);

    pEntry = pCache->pRoot;

    while (pEntry != NULL)
    {
        ASSERT(IsValidCacheEntry(pEntry));

        //
        // Compare the supplied key (checksum) with that of the current node
        //
        result = CHCompare(checkSum, cbSize, pEntry);

        if (result > 0)
        {
            //
            // Supplied key is greater than that of this entry, so look in
            // the right subtree
            //
            pEntry = pEntry->pRight;
            TRACE_OUT(( "move down right subtree to node 0x%08x", pEntry));
        }
        else if (result < 0)
        {
            //
            // Supplied key is lesser than that of this entry, so look in
            // the left subtree
            //
            pEntry = pEntry->pLeft;
            TRACE_OUT(( "move down left subtree to node 0x%08x", pEntry));
        }
        else
        {
            //
            // We found the FIRST entry with an identical key (checksum).
            //
            TRACE_OUT(( "found requested node" ));
            break;
        }
    }

    DebugExitPVOID(ASHost::CHAvlFind, pEntry);
    return(pEntry);
}




//
// Name:      CHAvlBalanceTree
//
// Purpose:   Reblance the tree starting at the supplied node and ending at
//            the root of the tree
//
// Returns:   Nothing
//
// Params:    IN     pCache             - a pointer to the AVL tree
//            IN     pEntry             - a pointer to the node to start
//                                       balancing from
//
//
void  ASHost::CHAvlBalanceTree
(
    PCHCACHE pCache,
    PCHENTRY pEntry
)
{
    //
    // Balance the tree starting at the given entry, ending with the root
    // of the tree
    //
    DebugEntry(ASHost::CHAvlBalanceTree);

    ASSERT(IsValidCacheEntry(pEntry));

    while (pEntry->pParent != NULL)
    {
        ASSERT(IsValidCacheEntry(pEntry->pParent));

        //
        // node has uneven balance, so may need to rebalance it
        //
        TRACE_OUT(( "check node balance" ));
        TRACE_OUT(( "  rHeight = %hd", pEntry->rHeight ));
        TRACE_OUT(( "  lHeight = %hd", pEntry->lHeight ));

        if (pEntry->pParent->pRight == pEntry)
        {
            //
            // node is right-son of its parent
            //
            TRACE_OUT(( "node is right-son" ));
            pEntry = pEntry->pParent;
            CHAvlRebalance(&pEntry->pRight);

            //
            // now update the right height of the parent
            //
            pEntry->rHeight = (WORD)
                 (1 + max(pEntry->pRight->rHeight, pEntry->pRight->lHeight));
            TRACE_OUT(( "new rHeight = %d", pEntry->rHeight ));
        }
        else
        {
            //
            // node is left-son of its parent
            //
            TRACE_OUT(( "node is left-son" ));
            pEntry = pEntry->pParent;
            CHAvlRebalance(&pEntry->pLeft);

            //
            // now update the left height of the parent
            //
            pEntry->lHeight = (WORD)
                   (1 + max(pEntry->pLeft->rHeight, pEntry->pLeft->lHeight));
            TRACE_OUT(( "new lHeight = %d", pEntry->lHeight ));
        }

        ASSERT(IsValidCacheEntry(pEntry));
    }

    if (pEntry->lHeight != pEntry->rHeight)
    {
        //
        // rebalance root node
        //
        TRACE_OUT(( "rebalance root node"));
        CHAvlRebalance(&pCache->pRoot);
    }

    DebugExitVOID(ASHost::CHAvlBalanceTree);
}

//
// Name:      CHAvlRebalance
//
// Purpose:   Reblance a subtree of the AVL tree (if necessary)
//
// Returns:   Nothing
//
// Params:    IN/OUT ppSubtree         - a pointer to the subtree to
//                                       rebalance
//
//
void  ASHost::CHAvlRebalance
(
    PCHENTRY *  ppSubtree
)
{
    int         moment;

    DebugEntry(ASHost::CHAvlRebalance);

    ASSERT(IsValidCacheEntry(*ppSubtree));

    TRACE_OUT(( "rebalance subtree" ));
    TRACE_OUT(( "  rHeight = %hd", (*ppSubtree)->rHeight ));
    TRACE_OUT(( "  lHeight = %hd", (*ppSubtree)->lHeight ));

    //
    // How unbalanced - don't want to recalculate
    //
    moment = (*ppSubtree)->rHeight - (*ppSubtree)->lHeight;

    if (moment > 1)
    {
        //
        // subtree is heavy on the right side
        //
        TRACE_OUT(( "subtree is heavy on right side" ));
        TRACE_OUT(( "right subtree" ));
        TRACE_OUT(( "  rHeight = %d", (*ppSubtree)->pRight->rHeight ));
        TRACE_OUT(( "  lHeight = %d", (*ppSubtree)->pRight->lHeight ));
        if ((*ppSubtree)->pRight->lHeight > (*ppSubtree)->pRight->rHeight)
        {
            //
            // right subtree is heavier on left side, so must perform right
            // rotation on this subtree to make it heavier on the right
            // side
            //
            TRACE_OUT(( "right subtree is heavier on left side ..." ));
            TRACE_OUT(( "... so rotate it right" ));
            CHAvlRotateRight(&(*ppSubtree)->pRight);
            TRACE_OUT(( "right subtree" ));
            TRACE_OUT(( "  rHeight = %d", (*ppSubtree)->pRight->rHeight ));
            TRACE_OUT(( "  lHeight = %d", (*ppSubtree)->pRight->lHeight ));
        }

        //
        // now rotate the subtree left
        //
        TRACE_OUT(( "rotate subtree left" ));
        CHAvlRotateLeft(ppSubtree);
    }
    else if (moment < -1)
    {
        //
        // subtree is heavy on the left side
        //
        TRACE_OUT(( "subtree is heavy on left side" ));
        TRACE_OUT(( "left subtree" ));
        TRACE_OUT(( "  rHeight = %d", (*ppSubtree)->pLeft->rHeight ));
        TRACE_OUT(( "  lHeight = %d", (*ppSubtree)->pLeft->lHeight ));
        if ((*ppSubtree)->pLeft->rHeight > (*ppSubtree)->pLeft->lHeight)
        {
            //
            // left subtree is heavier on right side, so must perform left
            // rotation on this subtree to make it heavier on the left side
            //
            TRACE_OUT(( "left subtree is heavier on right side ..." ));
            TRACE_OUT(( "... so rotate it left" ));
            CHAvlRotateLeft(&(*ppSubtree)->pLeft);
            TRACE_OUT(( "left subtree" ));
            TRACE_OUT(( "  rHeight = %d", (*ppSubtree)->pLeft->rHeight ));
            TRACE_OUT(( "  lHeight = %d", (*ppSubtree)->pLeft->lHeight ));
        }

        //
        // now rotate the subtree right
        //
        TRACE_OUT(( "rotate subtree right" ));
        CHAvlRotateRight(ppSubtree);
    }

    TRACE_OUT(( "balanced subtree" ));
    TRACE_OUT(( "  rHeight = %d", (*ppSubtree)->rHeight ));
    TRACE_OUT(( "  lHeight = %d", (*ppSubtree)->lHeight ));

    DebugExitVOID(ASHost::CHAvlRebalance);
}

//
// Name:      CHAvlRotateRight
//
// Purpose:   Rotate a subtree of the AVL tree right
//
// Returns:   Nothing
//
// Params:    IN/OUT ppSubtree         - a pointer to the subtree to rotate
//
//
void  ASHost::CHAvlRotateRight
(
    PCHENTRY * ppSubtree
)
{
    PCHENTRY pLeftSon;

    DebugEntry(ASHost::CHAvlRotateRight);

    ASSERT(IsValidCacheEntry(*ppSubtree));
    pLeftSon = (*ppSubtree)->pLeft;
    ASSERT(IsValidCacheEntry(pLeftSon));

    (*ppSubtree)->pLeft = pLeftSon->pRight;
    if ((*ppSubtree)->pLeft != NULL)
    {
        (*ppSubtree)->pLeft->pParent = (*ppSubtree);
    }
    (*ppSubtree)->lHeight = pLeftSon->rHeight;

    pLeftSon->pParent = (*ppSubtree)->pParent;

    pLeftSon->pRight = *ppSubtree;
    pLeftSon->pRight->pParent = pLeftSon;
    pLeftSon->rHeight = (WORD)
                   (1 + max((*ppSubtree)->rHeight, (*ppSubtree)->lHeight));

    *ppSubtree = pLeftSon;

    DebugExitVOID(ASHost::CHAvlRotateRight);
}

//
// Name:      CHAvlRotateLeft
//
// Purpose:   Rotate a subtree of the AVL tree left
//
// Returns:   Nothing
//
// Params:    IN/OUT ppSubtree        - a pointer to the subtree to rotate
//
//
void  ASHost::CHAvlRotateLeft
(
    PCHENTRY *  ppSubtree
)
{
    PCHENTRY    pRightSon;

    DebugEntry(ASHost::CHAvlRotateLeft);

    ASSERT(IsValidCacheEntry(*ppSubtree));
    pRightSon = (*ppSubtree)->pRight;
    ASSERT(IsValidCacheEntry(pRightSon));

    (*ppSubtree)->pRight = pRightSon->pLeft;
    if ((*ppSubtree)->pRight != NULL)
    {
        (*ppSubtree)->pRight->pParent = (*ppSubtree);
    }
    (*ppSubtree)->rHeight = pRightSon->lHeight;

    pRightSon->pParent = (*ppSubtree)->pParent;

    pRightSon->pLeft = *ppSubtree;
    pRightSon->pLeft->pParent = pRightSon;
    pRightSon->lHeight = (WORD)
                   (1 + max((*ppSubtree)->rHeight, (*ppSubtree)->lHeight));

    *ppSubtree = pRightSon;

    DebugExitVOID(ASHost::CHAvlRotateLeft);
}


//
// Name:      CHAvlSwapRightmost
//
// Purpose:   Swap node with right-most descendent of subtree
//
// Returns:   Nothing
//
// Params:    IN     pCache             - a pointer to the tree
//            IN     pSubtree          - a pointer to the subtree
//            IN     pEntry             - a pointer to the node to swap
//
//
void  ASHost::CHAvlSwapRightmost
(
    PCHCACHE    pCache,
    PCHENTRY    pSubtree,
    PCHENTRY    pEntry
)
{
    PCHENTRY    pSwapEntry;
    PCHENTRY    pSwapParent;
    PCHENTRY    pSwapLeft;

    DebugEntry(ASHost::CHAvlSwapRightmost);

    ASSERT(IsValidCacheEntry(pEntry));
    ASSERT((pEntry->pRight != NULL));
    ASSERT((pEntry->pLeft != NULL));

    //
    // find right-most descendent of subtree
    //
    ASSERT(IsValidCacheEntry(pSubtree));
    pSwapEntry = pSubtree;
    while (pSwapEntry->pRight != NULL)
    {
        pSwapEntry = pSwapEntry->pRight;
        ASSERT(IsValidCacheEntry(pSwapEntry));
    }

    ASSERT((pSwapEntry->rHeight == 0));
    ASSERT((pSwapEntry->lHeight <= 1));

    //
    // save parent and left-son of right-most descendent
    //
    pSwapParent = pSwapEntry->pParent;
    pSwapLeft = pSwapEntry->pLeft;

    //
    // move swap node to its new position
    //
    pSwapEntry->pParent = pEntry->pParent;
    pSwapEntry->pRight = pEntry->pRight;
    pSwapEntry->pLeft = pEntry->pLeft;
    pSwapEntry->rHeight = pEntry->rHeight;
    pSwapEntry->lHeight = pEntry->lHeight;
    pSwapEntry->pRight->pParent = pSwapEntry;
    pSwapEntry->pLeft->pParent = pSwapEntry;
    if (pEntry->pParent == NULL)
    {
        //
        // node is at root of tree
        //
        pCache->pRoot = pSwapEntry;
    }
    else if (pEntry->pParent->pRight == pEntry)
    {
        //
        // node is right-son of parent
        //
        pSwapEntry->pParent->pRight = pSwapEntry;
    }
    else
    {
        //
        // node is left-son of parent
        //
        pSwapEntry->pParent->pLeft = pSwapEntry;
    }

    //
    // move node to its new position
    //
    pEntry->pParent = pSwapParent;
    pEntry->pRight = NULL;
    pEntry->pLeft = pSwapLeft;
    if (pEntry->pLeft != NULL)
    {
        pEntry->pLeft->pParent = pEntry;
        pEntry->lHeight = 1;
    }
    else
    {
        pEntry->lHeight = 0;
    }
    pEntry->rHeight = 0;
    pEntry->pParent->pRight = pEntry;

    DebugExitVOID(ASHost::CHAvlSwapRightmost);
}

//
// Name:      CHAvlSwapLeftmost
//
// Purpose:   Swap node with left-most descendent of subtree
//
// Returns:   Nothing
//
// Params:    IN     pCache             - a pointer to the tree
//            IN     pSubtree          - a pointer to the subtree
//            IN     pEntry             - a pointer to the node to swap
//
//
void  ASHost::CHAvlSwapLeftmost
(
    PCHCACHE    pCache,
    PCHENTRY    pSubtree,
    PCHENTRY    pEntry
)
{
    PCHENTRY    pSwapEntry;
    PCHENTRY    pSwapParent;
    PCHENTRY    pSwapRight;

    DebugEntry(ASHost::CHAvlSwapLeftmost);

    ASSERT(IsValidCacheEntry(pEntry));
    ASSERT((pEntry->pRight != NULL));
    ASSERT((pEntry->pLeft != NULL));

    //
    // find left-most descendent of pSubtree
    //
    ASSERT(IsValidCacheEntry(pSubtree));
    pSwapEntry = pSubtree;
    while (pSwapEntry->pLeft != NULL)
    {
        pSwapEntry = pSwapEntry->pLeft;
        ASSERT(IsValidCacheEntry(pSwapEntry));
    }

    ASSERT((pSwapEntry->lHeight == 0));
    ASSERT((pSwapEntry->rHeight <= 1));

    //
    // save parent and right-son of left-most descendent
    //
    pSwapParent = pSwapEntry->pParent;
    pSwapRight = pSwapEntry->pRight;

    //
    // move swap node to its new position
    //
    pSwapEntry->pParent = pEntry->pParent;
    pSwapEntry->pRight = pEntry->pRight;
    pSwapEntry->pLeft = pEntry->pLeft;
    pSwapEntry->rHeight = pEntry->rHeight;
    pSwapEntry->lHeight = pEntry->lHeight;
    pSwapEntry->pRight->pParent = pSwapEntry;
    pSwapEntry->pLeft->pParent = pSwapEntry;
    if (pEntry->pParent == NULL)
    {
        //
        // node is at root of tree
        //
        pCache->pRoot = pSwapEntry;
    }
    else if (pEntry->pParent->pRight == pEntry)
    {
        //
        // node is right-son of parent
        //
        pSwapEntry->pParent->pRight = pSwapEntry;
    }
    else
    {
        //
        // node is left-son of parent
        //
        pSwapEntry->pParent->pLeft = pSwapEntry;
    }

    //
    // move node to its new position
    //
    pEntry->pParent = pSwapParent;
    pEntry->pRight = pSwapRight;
    pEntry->pLeft = NULL;
    if (pEntry->pRight != NULL)
    {
        pEntry->pRight->pParent = pEntry;
        pEntry->rHeight = 1;
    }
    else
    {
        pEntry->rHeight = 0;
    }
    pEntry->lHeight = 0;
    pEntry->pParent->pLeft = pEntry;

    DebugExitVOID(ASHost::CHAvlSwapLeftmost);
}


//
// Name:      CHCompare
//
// Purpose:   Standard function for comparing UINTs
//
// Returns:   -1 if key < pEntry->checksum
//            -1 if key = pEntry->checksum AND sizes do not match
//             0 if key = pEntry->checksum AND sizes match
//             1 if key > pEntry->checksum
//
// Params:    IN  key           - a pointer to the comparison key
//            IN  cbSize        - number of comparison data bytes
//            IN  pEntry         - a pointer to the node to compare
//
//
int  ASHost::CHCompare
(
    UINT        key,
    UINT        cbSize,
    PCHENTRY    pEntry
)
{
    int         ret_val;

    DebugEntry(ASHost::CHCompare);

    ASSERT(IsValidCacheEntry(pEntry));

    if (key < pEntry->checkSum)
    {
        ret_val = -1;
        TRACE_OUT(( "Key is less (-1)"));
    }
    else if (key > pEntry->checkSum)
    {
        ret_val = 1;
        TRACE_OUT(( "Key is more (+1)"));
    }
    else
    {
        if (cbSize == pEntry->cbData)
        {
            ret_val = 0;
            TRACE_OUT(( "Key and size match"));
        }
        else
        {
            ret_val = -1;
            TRACE_OUT(( "Key match, size mismatch (-1)"));
        }
    }

    DebugExitDWORD(ASHost::CHCompare, ret_val);
    return(ret_val);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\cpc.cpp ===
#include "precomp.h"


//
// CPC.CPP
// Capabilities Coordinator
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE




//
// CPC_PartyJoiningShare()
//
BOOL  ASShare::CPC_PartyJoiningShare
(
    ASPerson *  pasPerson,
    UINT        cbCaps,
    LPVOID      pCapsData
)
{
    PPROTCOMBINEDCAPS   pCombinedCaps;
    LPBYTE      pCapsSrc;
    PPROTCAPS   pCapsDst;
    UINT        sizeSrc;
    UINT        sizeDst;
    BOOL        rc = FALSE;
    int         i;
    PPROTCAPS   pCapCheck;

    DebugEntry(ASShare::CPC_PartyJoiningShare);

    //
    // Set up caps
    //
    if (pasPerson == m_pasLocal)
    {
        // Copy the global variable caps
        memcpy(&pasPerson->cpcCaps, pCapsData, cbCaps);
        pasPerson->cpcCaps.share.gccID = g_asSession.gccID;
    }
    else
    {
        // When the person is created, it is zeroed out, so cpcCaps is too
        pCombinedCaps = (PPROTCOMBINEDCAPS)pCapsData;

        memcpy(&(pasPerson->cpcCaps.header), &(pCombinedCaps->header),
            sizeof(pCombinedCaps->header));

        //
        // Save the caps we care about in a simple easy structure
        //
        pCapsSrc = (LPBYTE)pCombinedCaps->capabilities;

        for (i = 0; i < pCombinedCaps->header.numCapabilities; i++)
        {
            sizeSrc = (UINT)(((PPROTCAPS)pCapsSrc)->header.capSize);

            switch (((PPROTCAPS)pCapsSrc)->header.capID)
            {
                case CAPS_ID_GENERAL:
                    pCapsDst = (PPROTCAPS)&(pasPerson->cpcCaps.general);
                    sizeDst = sizeof(PROTCAPS_GENERAL);
                    break;

                case CAPS_ID_SCREEN:
                    pCapsDst = (PPROTCAPS)&(pasPerson->cpcCaps.screen);
                    sizeDst = sizeof(PROTCAPS_SCREEN);
                    break;

                case CAPS_ID_ORDERS:
                    pCapsDst = (PPROTCAPS)&(pasPerson->cpcCaps.orders);
                    sizeDst = sizeof(PROTCAPS_ORDERS);
                    break;

                case CAPS_ID_BITMAPCACHE:
                    pCapsDst = (PPROTCAPS)&(pasPerson->cpcCaps.bitmaps);
                    sizeDst = sizeof(PROTCAPS_BITMAPCACHE);
                    break;

                case CAPS_ID_CM:
                    pCapsDst = (PPROTCAPS)&(pasPerson->cpcCaps.cursor);
                    sizeDst = sizeof(PROTCAPS_CM);
                    break;

                case CAPS_ID_PM:
                    pCapsDst = (PPROTCAPS)&(pasPerson->cpcCaps.palette);
                    sizeDst = sizeof(PROTCAPS_PM);
                    break;

                case CAPS_ID_SC:
                    pCapsDst = (PPROTCAPS)&(pasPerson->cpcCaps.share);
                    sizeDst = sizeof(PROTCAPS_SC);
                    break;

                default:
                    // Skip caps we don't recognize
                    WARNING_OUT(("Ignoring unrecognized cap ID %d, size %d from person [%d]",
                        ((PPROTCAPS)pCapsSrc)->header.capID, sizeSrc,
                        pasPerson->mcsID));
                    pCapsDst = NULL;
                    break;
            }

            if (pCapsDst)
            {
                //
                // Only copy the amount given, but keep the size of the
                // structure in the header the right one.
                //
                CopyMemory(pCapsDst, pCapsSrc, min(sizeSrc, sizeDst));
                pCapsDst->header.capSize = (TSHR_UINT16)sizeDst;
            }

            pCapsSrc += sizeSrc;
        }
    }


    //
    // Check that we have the basic 7 caps
    //
    if (!pasPerson->cpcCaps.general.header.capID)
    {
        ERROR_OUT(("Bogus GENERAL caps for person [%d]", pasPerson->mcsID));
        DC_QUIT;
    }
    if (!pasPerson->cpcCaps.screen.header.capID)
    {
        ERROR_OUT(("Bogus SCREEN caps for person [%d]", pasPerson->mcsID));
        DC_QUIT;
    }
    if (!pasPerson->cpcCaps.orders.header.capID)
    {
        ERROR_OUT(("Bogus ORDERS caps for person [%d]", pasPerson->mcsID));
        DC_QUIT;
    }
    if (!pasPerson->cpcCaps.bitmaps.header.capID)
    {
        ERROR_OUT(("Bogus BITMAPS caps for person [%d]", pasPerson->mcsID));
        DC_QUIT;
    }
    if (!pasPerson->cpcCaps.cursor.header.capID)
    {
        ERROR_OUT(("Bogus CURSOR caps for person [%d]", pasPerson->mcsID));
        DC_QUIT;
    }
    if (!pasPerson->cpcCaps.palette.header.capID)
    {
        ERROR_OUT(("Bogus PALETTE caps for person [%d]", pasPerson->mcsID));
        DC_QUIT;
    }
    if (!pasPerson->cpcCaps.share.header.capID)
    {
        ERROR_OUT(("Bogus SHARE caps for person [%d]", pasPerson->mcsID));
        DC_QUIT;
    }

    // SUCCESS!

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::CPC_PartyJoiningShare, rc);
    return(rc);
}



//
// CPC_UpdatedCaps()
//
void ASShare::CPC_UpdatedCaps(PPROTCAPS pCaps)
{
    ASPerson *      pasT;
    PCPCPACKET      pCPCPacket;
    UINT            packetSize;
#ifdef _DEBUG
    UINT            sentSize;
#endif

    DebugEntry(ASShare::CPC_UpdatedCaps);

    //
    // Only allow screen size change!
    //
    ASSERT(pCaps->header.capID == CAPS_ID_SCREEN);

    //
    // Allocate a DT_CPC packet and send it to the remote site
    //
    packetSize = sizeof(CPCPACKET) + pCaps->header.capSize - sizeof(PROTCAPS);
    pCPCPacket = (PCPCPACKET)SC_AllocPkt(PROT_STR_MISC, g_s20BroadcastID, packetSize);
    if (!pCPCPacket)
    {
        WARNING_OUT(("Failed to alloc CPC packet, size %u", packetSize));
        DC_QUIT;
    }

    //
    // Fill in the capabilities that have changed
    //
    pCPCPacket->header.data.dataType = DT_CPC;

    memcpy(&pCPCPacket->caps, pCaps, pCaps->header.capSize);

    //
    // Compress and send the packet
    //
#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    DCS_CompressAndSendPacket(PROT_STR_MISC, g_s20BroadcastID,
        &(pCPCPacket->header), packetSize);

    TRACE_OUT(("CPC packet size: %08d, sent %08d", packetSize, sentSize));

    // Handle change
    CPCCapabilitiesChange(m_pasLocal, pCaps);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CPC_UpdatedCaps);
}



//
// CPC_ReceivedPacket()
//
void  ASShare::CPC_ReceivedPacket
(
    ASPerson *      pasPerson,
    PS20DATAPACKET  pPacket
)
{
    PCPCPACKET  pCPCPacket;

    DebugEntry(ASShare::CPC_ReceivedPacket);

    ValidatePerson(pasPerson);

    pCPCPacket = (PCPCPACKET)pPacket;

    //
    // Capabilities have changed - update the local copy and inform all
    // components
    //
    TRACE_OUT(( "Capabilities changing for person [%d]", pasPerson->mcsID));

    TRACE_OUT(("Size of new capabilities 0x%08x", pCPCPacket->caps.header.capSize));
    CPCCapabilitiesChange(pasPerson, &(pCPCPacket->caps));

    DebugExitVOID(ASShare::CPC_ReceivedPacket);
}



//
// CPCCapabilitiesChange()
//
BOOL  ASShare::CPCCapabilitiesChange
(
    ASPerson *          pasPerson,
    PPROTCAPS           pCaps
)
{
    BOOL                changed;

    DebugEntry(ASShare::CPCCapabilitiesChange);

    ValidatePerson(pasPerson);

    //
    // Get pointer to the caps we're changing (SHOULD ONLY BE SCREEN!)
    //
    if (pCaps->header.capID != CAPS_ID_SCREEN)
    {
        ERROR_OUT(("Received caps change from [%d] for cap ID %d we can't handle",
            pasPerson->mcsID, pCaps->header.capID));
        changed = FALSE;
    }
    else
    {
        CopyMemory(&(pasPerson->cpcCaps.screen), pCaps,
            min(sizeof(PROTCAPS_SCREEN), pCaps->header.capSize));
        pasPerson->cpcCaps.screen.header.capSize = sizeof(PROTCAPS_SCREEN);

        USR_ScreenChanged(pasPerson);

        changed = TRUE;
    }

    DebugExitBOOL(ASShare::CPCCapabilitiesChange, changed);
    return(changed);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\cpi32dll.cpp ===
#include "precomp.h"


//
// CPI32DLL.CPP
// CPI32 dll entry point
//
// Copyright(c) Microsoft 1997-
//

#define INIT_DBG_ZONE_DATA
#include "dbgzones.h"


BOOL APIENTRY DllMain (HINSTANCE hInstance, DWORD reason, LPVOID plReserved)
{
    BOOL    rc = TRUE;

    switch (reason)
    {
        case DLL_PROCESS_ATTACH:
        {
#ifdef _DEBUG
            MLZ_DbgInit((PSTR *) &c_apszDbgZones[0],
                        (sizeof(c_apszDbgZones) / sizeof(c_apszDbgZones[0])) - 1);
#endif // _DEBUG

            DBG_INIT_MEMORY_TRACKING(hInstance);

            //
            // Utility stuff
            //
            if (!UT_HandleProcessStart(hInstance))
            {
                rc = FALSE;
                break;
            }

            //
            // Call platform specific init code
            //
            OSI_Load();

            //
            // Do common stuff
            //

            //
            // Init Persistent PKZIP -- this just calculates some values 
            // which are effectively constants, the tables are just too 
            // unwieldy to declare as such.
            //
            GDC_Init();

            break;
        }

        case DLL_PROCESS_DETACH:
        {
            //
            // Call platform specific cleanup code
            //
            OSI_Unload();


            //
            // Utility stuff
            //
            UT_HandleProcessEnd();

            DBG_CHECK_MEMORY_TRACKING(hInstance);

#ifdef _DEBUG
            MLZ_DbgDeInit();
#endif // _DEBUG

            break;
        }

        case DLL_THREAD_DETACH:
            UT_HandleThreadEnd();
            break;

        default:
            break;
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\cmg.cpp ===
#include "precomp.h"
#include <it120app.h>

//
// CMG.C
// Call Management
//
// Copyright(c) Microsoft 1997-
//


#define MLZ_FILE_ZONE  ZONE_NET

//
// CMP_Init()                                              
//
BOOL CMP_Init(BOOL * pfCleanup)
{
    BOOL                rc = FALSE;
    GCCError            gcc_rc;

    DebugEntry(CMP_Init);

    UT_Lock(UTLOCK_T120);

    if (g_putCMG || g_pcmPrimary)
    {
        *pfCleanup = FALSE;
        ERROR_OUT(("Can't start CMP primary task; already running"));
        DC_QUIT;
    }
    else
    {
        *pfCleanup = TRUE;
    }

    //
    // Register CMG task
    //
    if (!UT_InitTask(UTTASK_CMG, &g_putCMG))
    {
        ERROR_OUT(("Failed to start CMG task"));
        DC_QUIT;
    }

    //
    // Allocate a Call Manager handle, ref counted
    //
    g_pcmPrimary = (PCM_PRIMARY)UT_MallocRefCount(sizeof(CM_PRIMARY), TRUE);
    if (!g_pcmPrimary)
    {
        ERROR_OUT(("CMP_Init failed to allocate CM_PRIMARY data"));
        DC_QUIT;
    }

    SET_STAMP(g_pcmPrimary, CMPRIMARY);
    g_pcmPrimary->putTask       = g_putCMG;

    //
    // Init the people list
    //
    COM_BasedListInit(&(g_pcmPrimary->people));

    //
    // Register event and exit procedures
    //
    UT_RegisterExit(g_putCMG, CMPExitProc, g_pcmPrimary);
    g_pcmPrimary->exitProcRegistered = TRUE;

    //                                                                    
    // - GCCCreateSap, which is the interesting one.                       
    //
    gcc_rc = GCC_CreateAppSap((IGCCAppSap **) &(g_pcmPrimary->pIAppSap),
                              g_pcmPrimary,
                              CMPGCCCallback);
    if (GCC_NO_ERROR != gcc_rc || NULL == g_pcmPrimary->pIAppSap)
    {
        ERROR_OUT(( "Error from GCCCreateSap"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_T120);

    DebugExitBOOL(CMP_Init, rc);
    return(rc);
}



//
// CMP_Term()                                               
//
void CMP_Term(void)
{
    DebugEntry(CMP_Term);

    UT_Lock(UTLOCK_T120);

    if (g_pcmPrimary)
    {
        ValidateCMP(g_pcmPrimary);

        ValidateUTClient(g_putCMG);

        //
        // Unregister our GCC SAP.                                             
        //
        if (NULL != g_pcmPrimary->pIAppSap)
        {
            g_pcmPrimary->pIAppSap->ReleaseInterface();
            g_pcmPrimary->pIAppSap = NULL;
        }

        //
        // Call the exit procedure to do all our termination                   
        //
        CMPExitProc(g_pcmPrimary);
    }

    UT_TermTask(&g_putCMG);

    UT_Unlock(UTLOCK_T120);

    DebugExitVOID(CMP_Term);
}




//
// CMPExitProc()                                     
//
void CALLBACK CMPExitProc(LPVOID data)
{
    PCM_PRIMARY pcmPrimary = (PCM_PRIMARY)data;

    DebugEntry(CMPExitProc);

    UT_Lock(UTLOCK_T120);

    //
    // Check parameters                                                    
    //
    ValidateCMP(pcmPrimary);
    ASSERT(pcmPrimary == g_pcmPrimary);

    //
    // Deregister the exit procedure.
    //
    if (pcmPrimary->exitProcRegistered)
    {
        UT_DeregisterExit(pcmPrimary->putTask,
                          CMPExitProc,
                          pcmPrimary);
        pcmPrimary->exitProcRegistered = FALSE;
    }

    CMPCallEnded(pcmPrimary);

    //
    // Free the CMP data
    //
    UT_FreeRefCount((void**)&g_pcmPrimary, TRUE);

    UT_Unlock(UTLOCK_T120);

    DebugExitVOID(CMPExitProc);

}

//
// CMPCallEnded()                                            
//
void CMPCallEnded
(
    PCM_PRIMARY pcmPrimary
)
{
    PCM_PERSON  pPerson;
    PCM_PERSON  pPersonT;
    int         cmTask;

    DebugEntry(CMPCallEnded);

    ValidateCMP(pcmPrimary);

    if (!(pcmPrimary->currentCall))
    {
        TRACE_OUT(("CMCallEnded: not in call"));
        DC_QUIT;
    }

    //
    // Issue CMS_PERSON_LEFT events for all people still in the call.  
    // Do this back to front.
    //
    pPerson = (PCM_PERSON)COM_BasedListLast(&(pcmPrimary->people), FIELD_OFFSET(CM_PERSON, chain));
    while (pPerson != NULL)
    {
        ASSERT(pcmPrimary->peopleCount > 0);

        TRACE_OUT(("Person [%d] LEAVING call", pPerson->netID));

        //
        // Get the previous person
        //
        pPersonT = (PCM_PERSON)COM_BasedListPrev(&(pcmPrimary->people), pPerson,
                                     FIELD_OFFSET(CM_PERSON, chain));

        //
        // Remove this guy from the list
        //
        COM_BasedListRemove(&(pPerson->chain));
        pcmPrimary->peopleCount--;

        //
        // Notify people of his leaving
        //
        CMPBroadcast(pcmPrimary,
                    CMS_PERSON_LEFT,
                    pcmPrimary->peopleCount,
                    pPerson->netID);

        //
        // Free the memory for the item
        //
        delete pPerson;

        //
        // Move the previous person in the list
        pPerson = pPersonT;
    }

    //
    // Inform all registered secondary tasks of call ending (call          
    // CMbroadcast() with CMS_END_CALL)                                    
    //
    CMPBroadcast(pcmPrimary,
                CMS_END_CALL,
                0,
                pcmPrimary->callID);

    //
    // Reset the current call vars
    //
    pcmPrimary->currentCall  = FALSE;
    pcmPrimary->fTopProvider    = FALSE;
    pcmPrimary->callID          = 0;
    pcmPrimary->gccUserID       = 0;
    pcmPrimary->gccTopProviderID    = 0;

    //
    // Discard outstanding channel/token requests
    //
    for (cmTask = CMTASK_FIRST; cmTask < CMTASK_MAX; cmTask++)
    {
        if (pcmPrimary->tasks[cmTask])
        {
            pcmPrimary->tasks[cmTask]->channelKey = 0;
            pcmPrimary->tasks[cmTask]->tokenKey = 0;
        }
    }

DC_EXIT_POINT:
    //
    // Nobody should be in the call anymore
    //
    ASSERT(pcmPrimary->peopleCount == 0);

    DebugExitVOID(CMCallEnded);
}




//                                                                         
// CMPGCCCallback                                            
//
void CALLBACK CMPGCCCallback(GCCAppSapMsg * gccMessage)
{
    PCM_PRIMARY                         pcmPrimary;
    GCCConferenceID                     confID;
    GCCApplicationRoster FAR * FAR *    pRosterList;
    UINT                                roster;
    LPOSTR                              pOctetString;
    GCCObjectKey FAR *                  pObjectKey;
    UINT                              checkLen;

    DebugEntry(CMPGCCCallback);

    UT_Lock(UTLOCK_T120);

    //
    // The userDefined parameter is the Primary's PCM_CLIENT.               
    //
    pcmPrimary = (PCM_PRIMARY)gccMessage->pAppData;

    if (pcmPrimary != g_pcmPrimary)
    {
        ASSERT(NULL == g_pcmPrimary);
        return;
    }

    ValidateCMP(pcmPrimary);

    switch (gccMessage->eMsgType)
    {
        case GCC_PERMIT_TO_ENROLL_INDICATION:
        {
            //
            // This indicates a conference has started:                    
            //
            CMPProcessPermitToEnroll(pcmPrimary,
                        &gccMessage->AppPermissionToEnrollInd);
        }
        break;

        case GCC_ENROLL_CONFIRM:
        {
            //
            // This contains the result of a GCCApplicationEnrollRequest.  
            //
            CMPProcessEnrollConfirm(pcmPrimary,
                        &gccMessage->AppEnrollConfirm);
        }
        break;

        case GCC_REGISTER_CHANNEL_CONFIRM:
        {
            //
            // This contains the result of a GCCRegisterChannelRequest.    
            //
            CMPProcessRegistryConfirm(
                        pcmPrimary,
                        gccMessage->eMsgType,
                        &gccMessage->RegistryConfirm);
        }
        break;

        case GCC_ASSIGN_TOKEN_CONFIRM:
        {
            //
            // This contains the result of a GCCRegistryAssignTokenRequest.
            //
            CMPProcessRegistryConfirm(
                        pcmPrimary,
                        gccMessage->eMsgType,
                        &gccMessage->RegistryConfirm);
        }
        break;

        case GCC_APP_ROSTER_REPORT_INDICATION:
        {
            //
            // This indicates that the application roster has changed.     
            //
            confID = gccMessage->AppRosterReportInd.nConfID;
            pRosterList = gccMessage->AppRosterReportInd.apAppRosters;

            for (roster = 0;
                 roster < gccMessage->AppRosterReportInd.cRosters;
                 roster++)
            {

                //
                // Check this app roster to see if it relates to the       
                // Groupware session (the first check is because we always 
                // use a NON_STANDARD application key).                    
                //
                pObjectKey = &(pRosterList[roster]->
                               session_key.application_protocol_key);

                //
                // We only ever use a non standard key.                    
                //
                if (pObjectKey->key_type != GCC_H221_NONSTANDARD_KEY)
                {
                    TRACE_OUT(("Standard key, so not a roster we are interested in..."));
                    continue;
                }

                pOctetString = &pObjectKey->h221_non_standard_id;

                //
                // Now check the octet string.  It should be the same      
                // length as our hardcoded GROUPWARE- string (including    
                // NULL term) and should match byte for byte:              
                //
                checkLen = sizeof(GROUPWARE_GCC_APPLICATION_KEY);
                if ((pOctetString->length != checkLen)
                    ||
                    (memcmp(pOctetString->value,
                            GROUPWARE_GCC_APPLICATION_KEY,
                            checkLen) != 0))
                {
                    //
                    // This roster is not for our session - go to the next 
                    // one.                                                
                    //
                    TRACE_OUT(("Roster not for Groupware session - ignore"));
                    continue;
                }

                //
                // Process the application roster.                         
                //
                CMPProcessAppRoster(pcmPrimary,
                                       confID,
                                       pRosterList[roster]);
            }
        }
        break;
    }

    UT_Unlock(UTLOCK_T120);

    DebugExitVOID(CMPGCCCallback);
}


//
//                                                                        
// CMPBuildGCCRegistryKey(...)                                              
//
//
void CMPBuildGCCRegistryKey
(
    UINT                    dcgKeyNum,
    GCCRegistryKey FAR *    pGCCKey,
    LPSTR                   dcgKeyStr
)
{
    DebugEntry(CMPBuildGCCRegistryKey);

    //
    // Build up a string of the form "Groupware-XX" where XX is a string   
    // representation (in decimal) of the <dcgKey> parameter passed in.    
    //
    memcpy(dcgKeyStr, GROUPWARE_GCC_APPLICATION_KEY, sizeof(GROUPWARE_GCC_APPLICATION_KEY)-1);

    wsprintf(dcgKeyStr+sizeof(GROUPWARE_GCC_APPLICATION_KEY)-1, "%d",
        dcgKeyNum);

    //
    // Now build the GCCRegistryKey.  This involves putting a pointer to   
    // our static <dcgKeyStr> deep inside the GCC structure.  We also store
    // the length, which is lstrlen+1, because we want to include the    
    // NULLTERM explicitly (since GCC treats the octet_string as an        
    // arbitrary array of bytes).                                          
    //

    pGCCKey->session_key.application_protocol_key.
        key_type = GCC_H221_NONSTANDARD_KEY;

    pGCCKey->session_key.application_protocol_key.h221_non_standard_id.
        length = sizeof(GROUPWARE_GCC_APPLICATION_KEY);

    pGCCKey->session_key.application_protocol_key.h221_non_standard_id.
        value = (LPBYTE) GROUPWARE_GCC_APPLICATION_KEY;

    pGCCKey->session_key.session_id          = 0;

    pGCCKey->resource_id.length =
              (sizeof(GROUPWARE_GCC_APPLICATION_KEY) +
              lstrlen(&dcgKeyStr[sizeof(GROUPWARE_GCC_APPLICATION_KEY)-1]));

    pGCCKey->resource_id.value               = (LPBYTE) dcgKeyStr;


    DebugExitVOID(CMPBuildGCCRegistryKey);
}



//                                                                        
// CMPProcessPermitToEnroll(...)                                            
//
void CMPProcessPermitToEnroll
(
    PCM_PRIMARY                         pcmPrimary,
    GCCAppPermissionToEnrollInd *       pMsg
)
{
    DebugEntry(CMPProcessPermitToEnroll);

    ValidateCMP(pcmPrimary);

    //
    // We will send CMS_PERSON_JOINED events when we receive a         
    // GCC_APP_ROSTER_REPORT_INDICATION.                                   
    //

    if (pMsg->fPermissionGranted)
    {
        // CALL STARTED

        //
        // If we haven't had a NCS yet then we store the conference ID.    
        // Otherwise ignore it.                                            
        //
        ASSERT(!pcmPrimary->currentCall);

        //
        // Initially, we do not consider ourselves to be in the call - we will 
        // add an entry when we get the ENROLL_CONFIRM:                        
        //
        ASSERT(pcmPrimary->peopleCount == 0);

        pcmPrimary->currentCall = TRUE;
        pcmPrimary->callID      = pMsg->nConfID;
        pcmPrimary->fTopProvider =
            pcmPrimary->pIAppSap->IsThisNodeTopProvider(pMsg->nConfID);

        //
        // Tell GCC whether we're interested:                              
        //
        if (!CMPGCCEnroll(pcmPrimary, pMsg->nConfID, TRUE))
        {
            //
            // We are only interested in an error if it is a Groupware conf.   
            // All we can really do is pretend the conference has ended due
            // to a network error.                                         
            //
            WARNING_OUT(("Error from CMPGCCEnroll"));
            CMPCallEnded(pcmPrimary);
        }

        //
        // The reply will arrive on a GCC_ENROLL_CONFIRM event.            
        //
    }
    else
    {
        // CALL ENDED
        if (g_pcmPrimary->currentCall)
        {
            //
            // Inform Primary task and all secondary tasks that the call has ended 
            //

            CMPCallEnded(g_pcmPrimary);

            //
            // Un-enroll from the GCC Application Roster.                          
            //
            if (g_pcmPrimary->bGCCEnrolled)
            {
                CMPGCCEnroll(g_pcmPrimary, g_pcmPrimary->callID, FALSE);
                g_pcmPrimary->bGCCEnrolled = FALSE;
            }
        }
    }

    DebugExitVOID(CMPProcessPermitToEnroll);
}



//
//                                                                        
// CMPProcessEnrollConfirm(...)                                             
//
//
void CMPProcessEnrollConfirm
(
    PCM_PRIMARY             pcmPrimary,
    GCCAppEnrollConfirm *   pMsg
)
{
    DebugEntry(CMPProcessEnrollConfirm);

    ValidateCMP(pcmPrimary);

    ASSERT(pcmPrimary->currentCall);
    ASSERT(pMsg->nConfID == pcmPrimary->callID);

    //
    // This event contains the GCC node ID (i.e.  the MCS user ID of the   
    // GCC node controller at this node).  Store it for later reference    
    // against the roster report:                                          
    //
    TRACE_OUT(( "GCC user_id: %u", pMsg->nidMyself));

    pcmPrimary->gccUserID           = pMsg->nidMyself;
    pcmPrimary->gccTopProviderID    = pcmPrimary->pIAppSap->GetTopProvider(pcmPrimary->callID);
    ASSERT(pcmPrimary->gccTopProviderID);

    if (pMsg->nResult != GCC_RESULT_SUCCESSFUL)
    {
        WARNING_OUT(( "Attempt to enroll failed (reason: %u", pMsg->nResult));
        //
        // All we can really do is pretend the conference has ended due to 
        // a network error.                                                
        //
        CMPCallEnded(pcmPrimary);
    }

    DebugExitVOID(CMProcessEnrollConfirm);
}



//                                                                        
// CMPProcessRegistryConfirm(...)                                           
//
void CMPProcessRegistryConfirm
(
    PCM_PRIMARY         pcmPrimary,
    GCCMessageType      messageType,
    GCCRegistryConfirm *pConfirm
)
{
    UINT                event =     0;
    BOOL                succeeded;
    LPSTR               pGCCKeyStr;    // extracted from the GCC registry key  
    UINT                dcgKeyNum;     // the value originally passed in as key
    UINT                itemID;        // can be channel or token ID
    int                 cmTask;
    PUT_CLIENT          secondaryHandle = NULL;

    DebugEntry(CMPProcessRegistryConfirm);

    ValidateCMP(pcmPrimary);

    //
    // Check this is for the Groupware conference:                         
    //
    if (!pcmPrimary->currentCall ||
        (pConfirm->nConfID != pcmPrimary->callID))
    {
        WARNING_OUT(( "Got REGISTRY_XXX_CONFIRM for unknown conference %lu",
            pConfirm->nConfID));
        DC_QUIT;
    }

    //
    // Embedded deep down inside the message from GCC is a pointer to an   
    // octet string which is of the form "Groupware-XX", where XX is a     
    // string representation of the numeric key the original Call Manager  
    // secondary used when registering the item.  Extract it now:          
    //
    pGCCKeyStr = (LPSTR)pConfirm->pRegKey->resource_id.value;

    dcgKeyNum = DecimalStringToUINT(&pGCCKeyStr[sizeof(GROUPWARE_GCC_APPLICATION_KEY)-1]);

    if (dcgKeyNum == 0)
    {
        WARNING_OUT(( "Received ASSIGN/REGISTER_CONFIRM with unknown key: %s",
            pGCCKeyStr));
        DC_QUIT;
    }

    TRACE_OUT(( "Conf ID %u, DCG Key %u, result %u",
        pConfirm->nConfID, dcgKeyNum, pConfirm->nResult));

    //
    // This is either a REGISTER_CHANNEL_CONFIRM or a ASSIGN_TOKEN_CONFIRM.
    // Check, and set up the relevant pointers:                            
    //
    switch (messageType)
    {
        case GCC_REGISTER_CHANNEL_CONFIRM:
        {
            event = CMS_CHANNEL_REGISTER_CONFIRM;
            itemID = pConfirm->pRegItem->channel_id;

            // Look for task that registered this channel
            for (cmTask = CMTASK_FIRST; cmTask < CMTASK_MAX; cmTask++)
            {
                if (pcmPrimary->tasks[cmTask] &&
                    (pcmPrimary->tasks[cmTask]->channelKey == dcgKeyNum))
                {
                    pcmPrimary->tasks[cmTask]->channelKey = 0;
                    secondaryHandle = pcmPrimary->tasks[cmTask]->putTask;
                }
            }
        }
        break;

        case GCC_ASSIGN_TOKEN_CONFIRM:
        {
            event = CMS_TOKEN_ASSIGN_CONFIRM;
            itemID = pConfirm->pRegItem->token_id;

            // Look for task that assigned this token
            for (cmTask = CMTASK_FIRST; cmTask < CMTASK_MAX; cmTask++)
            {
                if (pcmPrimary->tasks[cmTask] &&
                    (pcmPrimary->tasks[cmTask]->tokenKey == dcgKeyNum))
                {
                    pcmPrimary->tasks[cmTask]->tokenKey = 0;
                    secondaryHandle = pcmPrimary->tasks[cmTask]->putTask;
                }
            }
        }
        break;

        default:
        {
            ERROR_OUT(( "Unexpected registry event %u", messageType));
            DC_QUIT;
        }
    }

    switch (pConfirm->nResult)
    {
        case GCC_RESULT_SUCCESSFUL:
        {
            //
            // We were the first to register an item against this key.     
            //
            TRACE_OUT(("We were first to register using key %u (itemID: %u)",
                     dcgKeyNum, itemID));
            succeeded = TRUE;
        }
        break;

        case GCC_RESULT_ENTRY_ALREADY_EXISTS:
        {
            //
            // Someone beat us to it: they have registered a channel       
            // against the key we specified.  This value is in the GCC     
            // message:                                                    
            //
            TRACE_OUT(("Another node registered using key %u (itemID: %u)",
                      dcgKeyNum, itemID));
            succeeded = TRUE;
        }
        break;

        default:
        {
            ERROR_OUT(("Error %#hx registering/assigning item against key %u",
                     pConfirm->nResult, dcgKeyNum));
            succeeded = FALSE;
        }
        break;
    }

    //
    // Tell the secondary about the result.                                
    //
    if (secondaryHandle)
    {
        UT_PostEvent(pcmPrimary->putTask,
                 secondaryHandle,
                 0,
                 event,
                 succeeded,
                 MAKELONG(itemID, dcgKeyNum));
    }

DC_EXIT_POINT:
    DebugExitVOID(CMProcessRegistryConfirm);
}



//                                                                        
// CMPProcessAppRoster(...)                                               
//
void CMPProcessAppRoster
(
    PCM_PRIMARY             pcmPrimary,
    GCCConferenceID         confID,
    GCCApplicationRoster*   pAppRoster
)
{
    UINT                    newList;
    UserID                  oldNode;
    UserID                  newNode;
    PCM_PERSON              pPerson;
    PCM_PERSON              pPersonT;
    BOOL                    found;
    int                     task;
    BOOL                    notInOldRoster = TRUE;
    BOOL                    inNewRoster    = FALSE;

    DebugEntry(CMPProcessAppRoster);

    ValidateCMP(pcmPrimary);

    //
    // If we are not in a call ignore this.                                
    //
    if (!pcmPrimary->currentCall ||
        (confID != pcmPrimary->callID))
    {
        WARNING_OUT(("Report not for active Groupware conference - ignore"));
        DC_QUIT;
    }

    //
    // At this point, pAppRoster points to the bit of the roster which     
    // relates to Groupware.  Trace out some info:                         
    //
    TRACE_OUT(( "Number of records %u;", pAppRoster->number_of_records));
    TRACE_OUT(( "Nodes added: %s, removed: %s",
        (pAppRoster->nodes_were_added   ? "YES" : "NO"),
        (pAppRoster->nodes_were_removed ? "YES" : "NO")));

    //
    // We store the GCC user IDs in shared memory as TSHR_PERSONIDs.
    // Compare this list of people we know to be in the call, and 
    //      * Remove people no longer around
    //      * See if we are new to the roster
    //      * Add people who are new
    //

    pPerson = (PCM_PERSON)COM_BasedListFirst(&(pcmPrimary->people), FIELD_OFFSET(CM_PERSON, chain));

    while (pPerson != NULL)
    {
        ASSERT(pcmPrimary->peopleCount > 0);

        oldNode = (UserID)pPerson->netID;

        //
        // Get the next guy in the list in case we remove this one.
        //
        pPersonT = (PCM_PERSON)COM_BasedListNext(&(pcmPrimary->people), pPerson,
                                     FIELD_OFFSET(CM_PERSON, chain));

        //
        // Check to see if our node is currently in the roster             
        // 
        if (oldNode == pcmPrimary->gccUserID)
        {
            TRACE_OUT(( "We are currently in the app roster"));
            notInOldRoster = FALSE;
        }

        //
        // ...check if they're in the new list...                          
        //
        found = FALSE;
        for (newList = 0; newList < pAppRoster->number_of_records; newList++)
        {
            if (oldNode == pAppRoster->application_record_list[newList]->node_id)
            {
                found = TRUE;
                break;
            }
        }

        if (!found)
        {
            //
            // This node is no longer present, so remove him.
            //
            TRACE_OUT(("Person %u left", oldNode));

            COM_BasedListRemove(&(pPerson->chain));
            pcmPrimary->peopleCount--;

            CMPBroadcast(pcmPrimary,
                        CMS_PERSON_LEFT,
                        pcmPrimary->peopleCount,
                        oldNode);

            //
            // Free the memory for the person item
            //
            delete pPerson;
        }

        pPerson = pPersonT;
    }

    //
    // Now see if we are new to the roster
    //
    for (newList = 0; newList < pAppRoster->number_of_records; newList++)
    {
        if (pAppRoster->application_record_list[newList]->node_id ==
                                                   pcmPrimary->gccUserID)
        {
            TRACE_OUT(( "We are in the new app roster"));
            inNewRoster = TRUE;
            break;
        }
    }

    if (notInOldRoster && inNewRoster)
    {
        //
        // We are new to the roster so we can now do all the processing we 
        // were previously doing in the enroll confirm handler.  GCC spec  
        // requires that we do not do this until we get the roster         
        // notification back.                                              
        //                                                                
        // Flag we are enrolled and start registering channels etc.        
        //
        pcmPrimary->bGCCEnrolled = TRUE;

        //
        // Post a CMS_NEW_CALL events to all secondary tasks               
        //
        TRACE_OUT(( "Broadcasting CMS_NEW_CALL with call handle 0x%08lx",
                                        pcmPrimary->callID));

        //
        // If we are not the caller then delay the broadcast a little      
        //
        CMPBroadcast(pcmPrimary, CMS_NEW_CALL,
            pcmPrimary->fTopProvider, pcmPrimary->callID);

#ifdef _DEBUG
        //
        // Process any outstanding channel register and assign token       
        // requests.                                                       
        //
        for (task = CMTASK_FIRST; task < CMTASK_MAX; task++)
        {
            if (pcmPrimary->tasks[task] != NULL)
            {
                ASSERT(pcmPrimary->tasks[task]->channelKey == 0);
                ASSERT(pcmPrimary->tasks[task]->tokenKey == 0);
            }
        }
#endif // _DEBUG
    }

    //
    // If we are not yet enrolled in the conference then do not start      
    // sending PERSON_JOINED notifications.                                
    //
    if (!pcmPrimary->bGCCEnrolled)
    {
        DC_QUIT;
    }

    //
    // Add the new people (this will include us).  At this point, we know 
    // that everyone in the people list is currently in the roster, since
    // we would have removed 'em above.
    //
    // We need to walk the existing list over and over.
    // But at least we can skip the people we add.  So we save the current
    // front of the list.
    //
    pPersonT = (PCM_PERSON)COM_BasedListFirst(&(pcmPrimary->people), FIELD_OFFSET(CM_PERSON, chain));

    for (newList = 0; newList < pAppRoster->number_of_records; newList++)
    {
        newNode = pAppRoster->application_record_list[newList]->node_id;

        found = FALSE;

        pPerson  = pPersonT;

        while (pPerson != NULL)
        {
            if (newNode == pPerson->netID)
            {
                //
                // This person already existed - don't need to do anything 
                //
                found = TRUE;
                break;          // out of inner for loop                   
            }

            pPerson = (PCM_PERSON)COM_BasedListNext(&(pcmPrimary->people), pPerson,
                FIELD_OFFSET(CM_PERSON, chain));
        }

        if (!found)
        {
            //
            // This dude is new; add him to our people list.
            //
            TRACE_OUT(("Person with GCC user_id %u joined", newNode));

            pPerson = new CM_PERSON;
            if (!pPerson)
            {
                //
                // Uh oh; can't add him.
                //
                ERROR_OUT(("Can't add person GCC user_id %u; out of memory",
                    newNode));
                break;
            }

            ZeroMemory(pPerson, sizeof(*pPerson));
            pPerson->netID = newNode;

            //
            // LONCHANC: We should collapse all these events into a single one
            // that summarize all added and removed nodes,
            // instead of posting the events one by one.
            //

            //
            // Stick him in at the beginning.  At least that way we don't
            // have to look at his record anymore.
            //
            COM_BasedListInsertAfter(&(pcmPrimary->people), &pPerson->chain);
            pcmPrimary->peopleCount++;

            CMPBroadcast(pcmPrimary, 
                CMS_PERSON_JOINED,
                pcmPrimary->peopleCount,
                newNode);
        }
    }

    TRACE_OUT(( "Num people now in call %u", pcmPrimary->peopleCount));

DC_EXIT_POINT:
    DebugExitVOID(CMPProcessAppRoster);
}



//
// CMPBroadcast()                                            
//
void CMPBroadcast
(
    PCM_PRIMARY pcmPrimary,
    UINT        event,
    UINT        param1,
    UINT        param2
)
{
    int         task;

    DebugEntry(CMPBroadcast);

    ValidateCMP(pcmPrimary);

    //
    // for every secondary task                                            
    //
    for (task = CMTASK_FIRST; task < CMTASK_MAX; task++)
    {
        if (pcmPrimary->tasks[task] != NULL)
        {
            UT_PostEvent(pcmPrimary->putTask,
                         pcmPrimary->tasks[task]->putTask,
                         NO_DELAY,
                         event,
                         param1,
                         param2);

        }
    }

    DebugExitVOID(CMPBroadcast);
}


//                                                                        
// CMPGCCEnroll(...)                                                        
//                                                                        
BOOL CMPGCCEnroll
(
    PCM_PRIMARY         pcmPrimary,
    GCCConferenceID     conferenceID,
    BOOL                fEnroll
)
{
    GCCError                    rcGCC =         GCC_NO_ERROR;
    GCCSessionKey               gccSessionKey;
    GCCObjectKey FAR *          pGCCObjectKey;
    BOOL                        succeeded = TRUE;
    GCCEnrollRequest            er;
    GCCRequestTag               nReqTag;

    DebugEntry(CMPGCCEnroll);

    ValidateCMP(pcmPrimary);

    //
    // Do some error checking.                                             
    //
    if (fEnroll && pcmPrimary->bGCCEnrolled)
    {
        WARNING_OUT(("Already enrolled"));
        DC_QUIT;
    }

    TRACE_OUT(("CMGCCEnroll for CM_hnd 0x%08x, confID 0x%08x, in/out %d",
                           pcmPrimary, conferenceID, fEnroll));

    //
    // Set up the session key which identifies us uniquely in the GCC      
    // AppRoster.  We use a non-standard key (because we're not part of the
    // T.120 standards series)                                             
    //                                                                    
    // Octet strings aren't null terminated, but we want ours to include   
    // the NULL at the end of the C string, so specify lstrlen+1 for the 
    // length.                                                             
    //
    pGCCObjectKey = &(gccSessionKey.application_protocol_key);

    pGCCObjectKey->key_type = GCC_H221_NONSTANDARD_KEY;

    pGCCObjectKey->h221_non_standard_id.value =
        (LPBYTE) GROUPWARE_GCC_APPLICATION_KEY;
    pGCCObjectKey->h221_non_standard_id.length =
                       sizeof(GROUPWARE_GCC_APPLICATION_KEY);

    gccSessionKey.session_id = 0;

    //
    // Try to enroll/unenroll with GCC.  This may fail because we have not 
    // yet received a GCC_PERMIT_TO_ENROLL_INDICATION.                     

    //
    // Fill in the enroll request structure
    //
    ZeroMemory(&er, sizeof(er));
    er.pSessionKey = &gccSessionKey;
    // er.fEnrollActively = FALSE;
    // er.nUserID = 0; // no user ID
    // er.fConductingCapable = FALSE;
    er.nStartupChannelType = MCS_STATIC_CHANNEL;
    // er.cNonCollapsedCaps = 0;
    // er.apNonCollapsedCaps = NULL;
    // er.cCollapsedCaps = 0;
    // er.apCollapsedCaps = NULL;
    er.fEnroll = fEnroll;

    rcGCC = pcmPrimary->pIAppSap->AppEnroll(
                                   conferenceID,
                                   &er,
                                   &nReqTag);
    if (GCC_NO_ERROR != rcGCC)
    {
        //
        // Leave the decision about any error processing to the caller.    
        //
        TRACE_OUT(("Error 0x%08x from GCCApplicationEnrollRequest conf ID %lu enroll=%s",
              rcGCC, conferenceID, fEnroll ? "YES": "NO"));
        succeeded = FALSE;
    }
    else
    {
        //
        // Whether we have asked to enroll or un-enroll, we act as if we   
        // are no longer enrolled at once.  We are only really enrolled    
        // when we receive an enroll confirm event.                        
        //
        pcmPrimary->bGCCEnrolled = FALSE;
        ASSERT(succeeded);
        TRACE_OUT(( "%s with conference %d", fEnroll ? 
                         "Enroll Outstanding" : "Unenrolled",
               conferenceID));
    }


DC_EXIT_POINT:
    DebugExitBOOL(CMPGCCEnroll, succeeded);
    return(succeeded);
}



//
// CMS_Register()                                           
//
BOOL CMS_Register
(
    PUT_CLIENT      putTask,
    CMTASK          taskType,
    PCM_CLIENT*     ppcmClient
)
{
    BOOL            fRegistered = FALSE;
    PCM_CLIENT      pcmClient = NULL;

    DebugEntry(CMS_Register);

    UT_Lock(UTLOCK_T120);

    if (!g_pcmPrimary)
    {
        ERROR_OUT(("CMS_Register failed; primary doesn't exist"));
        DC_QUIT;
    }

    ValidateUTClient(putTask);

    ASSERT(taskType >= CMTASK_FIRST);
    ASSERT(taskType < CMTASK_MAX);

    *ppcmClient = NULL;

    //
    // Is this task already present?  If so, share it
    //
    if (g_pcmPrimary->tasks[taskType] != NULL)
    {
        TRACE_OUT(("Sharing CMS task 0x%08x", g_pcmPrimary->tasks[taskType]));

        *ppcmClient = g_pcmPrimary->tasks[taskType];
        ValidateCMS(*ppcmClient);

        (*ppcmClient)->useCount++;

        // Return -- we exist.
        fRegistered = TRUE;
        DC_QUIT;
    }

    //
    // If we got here the task is not a Call Manager Secondary yet, so go  
    // ahead with the registration.                                        
    //

    //
    // Allocate memory for the client
    //
    pcmClient = new CM_CLIENT;
    if (! pcmClient)
    {
        ERROR_OUT(("Could not allocate CM handle"));
        DC_QUIT;
    }
    ZeroMemory(pcmClient, sizeof(*pcmClient));
    *ppcmClient = pcmClient;

    //
    // Fill in information                                                 
    //
    SET_STAMP(pcmClient, CMCLIENT);
    pcmClient->putTask      = putTask;
    pcmClient->taskType     = taskType;
    pcmClient->useCount     = 1;

    UT_BumpUpRefCount(g_pcmPrimary);
    g_pcmPrimary->tasks[taskType] = pcmClient;

    //
    // Register an exit procedure
    //
    UT_RegisterExit(putTask, CMSExitProc, pcmClient);
    pcmClient->exitProcRegistered = TRUE;

    fRegistered = TRUE;

DC_EXIT_POINT:

    UT_Unlock(UTLOCK_T120);

    DebugExitBOOL(CMS_Register, fRegistered);
    return(fRegistered);
}



//
// CMS_Deregister()                                         
//
void CMS_Deregister(PCM_CLIENT * ppcmClient)
{
    PCM_CLIENT      pcmClient = *ppcmClient;

    DebugEntry(CMS_Deregister);

    //
    // Check the parameters are valid                                      
    //
    UT_Lock(UTLOCK_T120);

    ValidateCMS(pcmClient);

    //
    // Only actually deregister the client if the registration count has   
    // reached zero.                                                       
    //
    pcmClient->useCount--;
    if (pcmClient->useCount != 0)
    {
        DC_QUIT;
    }

    //
    // Call the exit procedure to do our local cleanup                     
    //
    CMSExitProc(pcmClient);

DC_EXIT_POINT:
    *ppcmClient = NULL;

    UT_Unlock(UTLOCK_T120);

    DebugExitVOID(CMS_Deregister);
}




//
// CMS_ChannelRegister()                                    
//
BOOL CMS_ChannelRegister
(
    PCM_CLIENT      pcmClient,
    UINT            channelKey,
    UINT            channelID
)
{
    BOOL                fRegistered = FALSE;
    GCCRegistryKey      gccRegistryKey;
    GCCError            rcGCC;
    char                dcgKeyStr[sizeof(GROUPWARE_GCC_APPLICATION_KEY)+MAX_ITOA_LENGTH];

    DebugEntry(CMS_ChannelRegister);

    UT_Lock(UTLOCK_T120);

    //
    // Check the CMG task
    //
    ValidateUTClient(g_putCMG);

    //
    // Check the parameters are valid
    //
    ValidateCMP(g_pcmPrimary);
    ValidateCMS(pcmClient);

    //
    // If we are not in a call it is an error.                             
    //
    if (!g_pcmPrimary->currentCall)
    {
        WARNING_OUT(("CMS_ChannelRegister failed; not in call"));
        DC_QUIT;
    }
    if (!g_pcmPrimary->bGCCEnrolled)
    {
        WARNING_OUT(("CMS_ChannelRegister failed; not enrolled in call"));
        DC_QUIT;
    }

    // Make sure we don't have one pending already
    ASSERT(pcmClient->channelKey == 0);
   
    TRACE_OUT(("Channel ID %u Key %u", channelID, channelKey));

    //
    // Build a GCCRegistryKey based on our channelKey:                 
    //
    CMPBuildGCCRegistryKey(channelKey, &gccRegistryKey, dcgKeyStr);

    //
    // Now call through to GCC.  GCC will invoke our callback when it  
    // has processed the request.                                      
    //
    rcGCC = g_pcmPrimary->pIAppSap->RegisterChannel(
                                          g_pcmPrimary->callID,
                                          &gccRegistryKey,
                                          (ChannelID)channelID);
    if (rcGCC)
    {
        //
        // Tell the secondary client that the request failed.          
        //
        WARNING_OUT(( "Error %#lx from GCCRegisterChannel (key: %u)",
            rcGCC, channelKey));
    }
    else
    {
        // Remember so we can post confirm event back to proper task
        pcmClient->channelKey = channelKey;

        fRegistered = TRUE;
    }

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_T120);

    DebugExitBOOL(CMS_ChannelRegister, fRegistered);
    return(fRegistered);
}



//
// CMS_AssignTokenId()                                      
//
BOOL CMS_AssignTokenId
(
    PCM_CLIENT  pcmClient,
    UINT        tokenKey
)
{
    GCCRegistryKey  gccRegistryKey;
    GCCError        rcGCC;
    char            dcgKeyStr[sizeof(GROUPWARE_GCC_APPLICATION_KEY)+MAX_ITOA_LENGTH];
    BOOL            fAssigned = FALSE;

    DebugEntry(CMS_AssignTokenId);

    UT_Lock(UTLOCK_T120);

    //
    // Check the parameters are valid
    //
    ValidateCMP(g_pcmPrimary);
    ValidateCMS(pcmClient);

    ValidateUTClient(g_putCMG);

    if (!g_pcmPrimary->currentCall)
    {
        WARNING_OUT(("CMS_AssignTokenId failing; not in call"));
        DC_QUIT;
    }
    if (!g_pcmPrimary->bGCCEnrolled)
    {
        WARNING_OUT(("CMS_AssignTokenId failing; not enrolled in call"));
        DC_QUIT;
    }

    // Make sure we don't have one already
    ASSERT(pcmClient->tokenKey == 0);

    //
    // Build a GCCRegistryKey based on our tokenKey:                   
    //
    CMPBuildGCCRegistryKey(tokenKey, &gccRegistryKey, dcgKeyStr);

    //
    // Now call through to GCC.  GCC will invoke our callback when it  
    // has processed the request.                                      
    //
    rcGCC = g_pcmPrimary->pIAppSap->RegistryAssignToken(
        g_pcmPrimary->callID, &gccRegistryKey);
    if (rcGCC)
    {
        //
        // Tell the secondary client that the request failed.          
        //
        WARNING_OUT(( "Error %x from GCCAssignToken (key: %u)",
            rcGCC, tokenKey));
    }
    else
    {
        // Remember so we can post confirm to proper task
        pcmClient->tokenKey = tokenKey;
        fAssigned = TRUE;
    }

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_T120);

    DebugExitBOOL(CMS_AssignTokenId, fAssigned);
    return(fAssigned);
}


//
// CMSExitProc()                                    
//
void CALLBACK CMSExitProc(LPVOID data)
{
    PCM_CLIENT pcmClient = (PCM_CLIENT)data;

    DebugEntry(CMSExitProc);

    UT_Lock(UTLOCK_T120);

    //
    // Check parameters                                                    
    //
    ValidateCMS(pcmClient);

    //
    // Deregister exit procedure
    //
    if (pcmClient->exitProcRegistered)
    {
        UT_DeregisterExit(pcmClient->putTask,
                          CMSExitProc,
                          pcmClient);
        pcmClient->exitProcRegistered = FALSE;
    }

    //
    // Remove the task entry from the primary's list
    //
    g_pcmPrimary->tasks[pcmClient->taskType] = NULL;
    UT_FreeRefCount((void**)&g_pcmPrimary, TRUE);

    //
    // Free the client data
    //
    delete pcmClient;

    UT_Unlock(UTLOCK_T120);

    DebugExitVOID(CMSExitProc);
}


BOOL WINAPI CMS_GetStatus(PCM_STATUS pcmStatus)
{
    BOOL    inCall;

    DebugEntry(CMS_GetStatus);

    UT_Lock(UTLOCK_T120);

    ASSERT(!IsBadWritePtr(pcmStatus, sizeof(CM_STATUS)));
    ZeroMemory(pcmStatus, sizeof(CM_STATUS));

    ValidateCMP(g_pcmPrimary);

    T120_GetNodeName(pcmStatus->localName, CCHMAX(pcmStatus->localName));

    pcmStatus->localHandle      = g_pcmPrimary->gccUserID;
    pcmStatus->peopleCount      = g_pcmPrimary->peopleCount;
    pcmStatus->fTopProvider     = g_pcmPrimary->fTopProvider;
    pcmStatus->topProviderID    = g_pcmPrimary->gccTopProviderID;

    //
    // Fill in information about other primary                             
    //
    pcmStatus->callID    = g_pcmPrimary->callID;
    inCall = (g_pcmPrimary->currentCall != FALSE);

    UT_Unlock(UTLOCK_T120);

    DebugExitBOOL(CMS_GetStatus, inCall);
    return(inCall);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\dcs.cpp ===
#include "precomp.h"


//
// DCS.CPP
// Sharing main (init/term plus communication to/from ASMaster)
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE





//
// DCS_Init()
//
BOOL  DCS_Init(void)
{
    WNDCLASS    wc;
    BOOL        rc = FALSE;
    HDC         hdc;

    DebugEntry(DCS_Init);

    if (g_asOptions & AS_SERVICE)
    {
        WARNING_OUT(("AS is running as SERVICE"));
    }

    //
    // Register with the DC-Groupware Utility Services
    //
    if (!UT_InitTask(UTTASK_DCS, &g_putAS))
    {
        ERROR_OUT(( "Failed to init DCS task"));
        DC_QUIT;
    }
    UT_RegisterEvent(g_putAS, S20_UTEventProc, NULL, UT_PRIORITY_APPSHARING);


    //
    // Create the window
    //

    //
    // Register the main window class.
    //
    wc.style = 0;
    wc.lpfnWndProc = DCSMainWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = g_asInstance;
    wc.hIcon   = NULL;
    wc.hCursor = NULL;
    wc.hbrBackground = NULL;
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = DCS_MAIN_WINDOW_CLASS;

    if (!RegisterClass(&wc))
    {
        ERROR_OUT(("DCS_Init: couldn't register main window class"));
        DC_QUIT;
    }

    //
    // Create the main window.
    //
    // We make the window topmost so that it is sent the WM_QUERYENDSESSION
    // message before any other (non-topmost) windows.  This lets us
    // prevent the session from closing down if we are still in a share.
    //
    g_asMainWindow = CreateWindowEx(
           WS_EX_TOPMOST,                // Make the window topmost
           DCS_MAIN_WINDOW_CLASS,        // See RegisterClass() call.
           NULL,                         // Text for window title bar.
           0,                            // Invisible.
           0,                            // Default horizontal position.
           0,                            // Default vertical position.
           200,                          // Default width.
           100,                          // Default height.
           NULL,                         // Overlapped windows have no parent.
           NULL,                         // Use the window class menu.
           g_asInstance,
           NULL                          // Pointer not needed.
           );

    if (!g_asMainWindow)
    {
        ERROR_OUT(("DCS_Init: couldn't create main window"));
        DC_QUIT;
    }

    //
    // Check that display driver is loaded (if it isn't we can't host)
    //
    hdc = GetDC(NULL);
    g_usrScreenBPP = GetDeviceCaps(hdc, BITSPIXEL) *
        GetDeviceCaps(hdc, PLANES);
    g_usrPalettized = ((GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) != 0);
    ReleaseDC(NULL, hdc);

    g_usrCaptureBPP = g_usrScreenBPP;

    ASSERT(!g_asCanHost);
    ASSERT(!g_osiInitialized);
    ASSERT(!g_asSharedMemory);
    ASSERT(!g_poaData[0]);
    ASSERT(!g_poaData[1]);
    ASSERT(!g_lpimSharedData);
    ASSERT(!g_sbcEnabled);
    ASSERT(!g_asbcBitMasks[0]);
    ASSERT(!g_asbcBitMasks[1]);
    ASSERT(!g_asbcBitMasks[2]);

    OSI_Init();


    //
    // If we can't get hold of a pointer to shared IM vars, we are hosed.
    //
    if (!g_lpimSharedData)
    {
        ERROR_OUT(("Failed to get shared IM data"));
        DC_QUIT;
    }

    ASSERT(g_lpimSharedData->cbSize == sizeof(IM_SHARED_DATA));

    if (g_asOptions & AS_UNATTENDED)
    {
        // Let the input pieces (Win9x or NT) know we're in unattended mode
        g_lpimSharedData->imUnattended = TRUE;
    }

    //
    // Scheduler
    //
    if (!SCH_Init())
    {
        ERROR_OUT(("SCH Init failed"));
        DC_QUIT;
    }

    //
    // Hosting
    //
    if (!HET_Init())
    {
        ERROR_OUT(("HET Init failed"));
        DC_QUIT;
    }

    //
    // Viewing
    //
    if (!VIEW_Init())
    {
        ERROR_OUT(("VIEW Init failed"));
        DC_QUIT;
    }

    //
    // T.120 & T.128 Net
    //

    //
    // Initialize the network layer last of all.  This prevents us from
    // getting requests before we've fully initialized our components.
    //
    if (!S20_Init())
    {
        ERROR_OUT(("S20 Init failed"));
        DC_QUIT;

    }
    if (!SC_Init())
    {
        ERROR_OUT(("SC Init failed"));
        DC_QUIT;
    }

    //
    // We are now initialized.  Post a deferred message to get fonts.
    //
    PostMessage(g_asMainWindow, DCS_FINISH_INIT_MSG, 0, 0);

    // All modules have successfully initialised. Return success.
    // We are now ready to participate in sharing.
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(DCS_Init, rc);
    return(rc);
}


//
// DCS_Term()
//
void  DCS_Term(void)
{
    DebugEntry(DCS_Term);

    //
    // Kill window.  Do this FIRST so that any attempts to send us requests
    // or notifications will fail.
    //
    if (g_asMainWindow)
    {
        DestroyWindow(g_asMainWindow);
        g_asMainWindow = NULL;
    }

    UnregisterClass(DCS_MAIN_WINDOW_CLASS, g_asInstance);


    //
    // Network layer - terminate this early because it will handle
    // termination in a call by generating approriate events.
    //
    S20_Term();
    SC_Term();

    //
    // Scheduler.
    //
    SCH_Term();

    //
    // Viewing
    //
    VIEW_Term();

    //
    // Hosting
    //
    HET_Term();

    //
    // Fonts
    //
    FH_Term();

    //
    // Terminate OSI
    //
    OSI_Term();

    //
    // Deregister from the Groupware Utility Services
    //
    if (g_putAS)
    {
        UT_TermTask(&g_putAS);
    }

    DebugExitVOID(DCS_Term);
}


//
// DCS_FinishInit()
//
// This does slow font enumeration, and then tries to join a call if one
// has started up.  Even if font enum fails, we can share/view shared, we
// just won't send text orders
//
void DCS_FinishInit(void)
{
    DebugEntry(DCS_FinishInit);

    //
    // Determine what fonts we have locally.
    // Done after the r11 caps field is filled in, since if we dont support
    // some of the r11 caps, then we can reduce the amount of work we do
    // when we get the font metrics etc.
    //
    g_cpcLocalCaps.orders.capsNumFonts = (TSHR_UINT16)FH_Init();

    DebugExitVOID(DCS_FinishInit);
}



//
// FUNCTION: DCS_PartyJoiningShare
//
BOOL ASShare::DCS_PartyJoiningShare(ASPerson * pasPerson)
{
    BOOL            rc = FALSE;
    UINT            iDict;

    DebugEntry(ASShare::DCS_PartyJoiningShare);

    ValidatePerson(pasPerson);

    //
    // Allocate dictionaries for GDC Persistent dictionary compression if
    // this person supports it.  We'll use them to decompress data
    // received from this person.  NOTE:  Win95 2.0 does not support
    // persistent pkzip.
    //
    TRACE_OUT(( "Allocating receive dictionary set for [%d]", pasPerson->mcsID));

    pasPerson->adcsDict = new GDC_DICTIONARY[GDC_DICT_COUNT];
    if (!pasPerson->adcsDict)
    {
        ERROR_OUT(("Failed to allocate persistent dictionaries for [%d]", pasPerson->mcsID));
        DC_QUIT;
    }
    else
    {
        //
        // Initialize cbUsed to zero
        //
        for (iDict = 0; iDict < GDC_DICT_COUNT; iDict++)
        {
            pasPerson->adcsDict[iDict].cbUsed = 0;
        }
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::DCS_PartyJoiningShare, rc);
    return(rc);
}



//
// FUNCTION: DCS_PartyLeftShare
//
void  ASShare::DCS_PartyLeftShare(ASPerson * pasPerson)
{
    DebugEntry(ASShare::DCS_PartyLeftShare);

    ValidatePerson(pasPerson);

    //
    // Free any dictionaries we allocated
    //
    if (pasPerson->adcsDict)
    {
        delete[] pasPerson->adcsDict;
        pasPerson->adcsDict = NULL;
    }

    DebugExitVOID(ASShare::DCS_PartyLeftShare);
}



//
// DCS_RecalcCaps()
//
// Called when someone joins or leaves share.
//
void  ASShare::DCS_RecalcCaps(BOOL fJoiner)
{
    ASPerson * pasT;

    DebugEntry(ASShare::DCS_RecalcCaps);

    //
    // The combined compression support is initialised to the local support
    //
    ValidatePerson(m_pasLocal);

    DebugExitVOID(ASShare::DCS_RecalcCaps);
}


//
// SC_Periodic()
//
// The Scheduler runs a separate thread which is responsible for posting
// messages to our main thread, for which SC_Periodic() is the handler.
// Posted messages have the highest priority in GetMessage(), above input,
// paints, and timers.
//
// The Scheduler is in one of three states:
// asleep, normal or turbo.  When it is asleep, this function is not
// called.  When it is in normal mode, this function is called at least
// once, but the scheduler is a lazy guy, so will fall asleep again unless
// you keep prodding him.  In turbo mode this function is called repeatedly
// and rapidly, but only for a relatively short time, after which the
// scheduler falls back into normal mode, and from there falls asleep.
//
void  ASShare::SC_Periodic(void)
{
    UINT    currentTime;

    DebugEntry(ASShare::SC_Periodic);

    //
    // We must get the time accurately.
    //
    currentTime = GetTickCount();

    //
    // Dont do a lot of work if this is an immediate reschedule due to
    // multiple queued entries.  Most processors will achieve this in
    // less than 5 mS.
    //
    if ((currentTime - m_dcsLastScheduleTime) < 5)
    {
        WARNING_OUT(("Quit early"));
        DC_QUIT;
    }

    m_dcsLastScheduleTime = currentTime;

    //
    // Call the input manager event playback function frequently so that
    // we keep the input queue empty.  (Note that we do not want to just
    // dump the input queue into USER because we would lose all the
    // repeat keystroke packets we have so carefully sent across)
    // To trigger input we just use a 0 personid and NULL packet.
    //
    if ((currentTime - m_dcsLastIMTime) > DCS_IM_PERIOD)
    {
        m_dcsLastIMTime = currentTime;
        IM_ReceivedPacket(NULL, NULL);
    }

    //
    // There are calls which are made periodically but don't have any
    // dependencies.  First call the ones we want to be called fairly
    // frequently.
    //
    if ((currentTime - m_dcsLastFastMiscTime) > DCS_FAST_MISC_PERIOD )
    {
        m_dcsLastFastMiscTime = currentTime;

        OE_Periodic();
        HET_Periodic();
        CA_Periodic();
        IM_Periodic();
    }

    //
    // Only send updates if we're hosting, and have managed to tell everyone
    // we're hosting.
    //
    if (m_pHost && !m_hetRetrySendState)
    {
        BOOL    fetchedBounds = FALSE;

        m_pHost->CA_Periodic();

        //
        // See if we need to swap the buffers over.  Only swap if we have
        // sent all the data from the current orders.
        //
        if (m_pHost->OA_GetFirstListOrder() == NULL)
        {
            //
            // Get the current bounds from the driver.  This will fill in
            // the share core's copy of the bounds.
            //
            m_pHost->BA_FetchBounds();
            fetchedBounds = TRUE;

            //
            // Set up the new order list buffer
            //
            m_pHost->OA_ResetOrderList();

            //
            // Bounds data should be reset to a usable state by SDG once it
            // has finished with them, so we just need to swap the buffers
            // at this point.
            //
            SHM_SwitchReadBuffer();
        }

        //
        // In this high frequency code path we only send SWP info if it
        // is flagged as needed by the CBT hooks or if SWL determines a
        // send is required.  Only SWL knows if a send is required so
        // pass the CBT indication into SWL and let it do the
        // determination.
        //
        // The SWL window scan performs preemptable operations and we
        // must detect the occurrence of preemption otherwise we find
        // ourselves sending updates against an invalid window
        // structure.  Therefore we query OA and BA to see if any
        // updates have been accumulated in the interim.  We can tight
        // loop trying to get a good SWL list because we really don't
        // want to yield at this point - it is just that we cannot
        // prevent it sometimes.  (Sweeping through menus is a good way
        // to exercise this code.)
        //

        //
        // Synchronize the fast path data
        //
        SHM_SwitchFastBuffer();

        m_pHost->SWL_Periodic();
        m_pHost->UP_Periodic(currentTime);
        m_pHost->CM_Periodic();

        //
        // If we got the bounds from the driver, we have to let the driver know
        // how much of the bounds remain to be sent.
        //
        if (fetchedBounds)
        {
            m_pHost->BA_ReturnBounds();
        }
    }

DC_EXIT_POINT:
    SCH_ContinueScheduling(SCH_MODE_NORMAL);

    DebugExitVOID(ASShare::SC_Periodic);
}



//
// DCS_CompressAndSendPacket()
//
#ifdef _DEBUG
UINT ASShare::DCS_CompressAndSendPacket
#else
void ASShare::DCS_CompressAndSendPacket
#endif // _DEBUG
(
    UINT            streamID,
    UINT            nodeID,
    PS20DATAPACKET  pPacket,
    UINT            packetLength
)
{
    UINT            cbSrcDataSize;
    UINT            cbDstDataSize;
    UINT            compression;
    BOOL            compressed;
    UINT            dictionary;

    DebugEntry(ASShare::DCS_CompressAndSendPacket);

    ASSERT(streamID >= SC_STREAM_LOW);
    ASSERT(streamID <= SC_STREAM_HIGH);

    ASSERT(!m_ascSynced[streamID-1]);
    ASSERT(!m_scfInSync);

    ASSERT(packetLength < TSHR_MAX_SEND_PKT);

    //
    // Decide which (if any) compression algorithm we are going to use to
    // try and compress this packet.
    //
    compression     = 0;
    cbSrcDataSize   = packetLength - sizeof(S20DATAPACKET);

    //
    // Is the data a compressable size?
    //
    if ((cbSrcDataSize >= DCS_MIN_COMPRESSABLE_PACKET) &&
        (!m_dcsLargePacketCompressionOnly ||
            (cbSrcDataSize >= DCS_MIN_FAST_COMPRESSABLE_PACKET)))
    {
        if (cbSrcDataSize <= DCS_MAX_PDC_COMPRESSABLE_PACKET)
        {
            //
            // Use PERSIST_PKZIP compression
            //
            compression = GCT_PERSIST_PKZIP;
        }
        else
        {
            //
            // Use PKZIP compression
            //
            compression = GCT_PKZIP;
        }
    }


    //
    // Compress the packet
    //
    compressed = FALSE;
    if (compression != 0)
    {
        PGDC_DICTIONARY pgdcSrc = NULL;

        //
        // We compress only the data and not the header of course
        //
        cbDstDataSize     = cbSrcDataSize;

        ASSERT(m_ascTmpBuffer != NULL);

        //
        // Compress the data following the packet header.
        //
        if (compression == GCT_PERSIST_PKZIP)
        {
            //
            // Figure out what dictionary to use for the stream priority
            //
            switch (streamID)
            {
                case PROT_STR_UPDATES:
                    dictionary = GDC_DICT_UPDATES;
                    break;

                case PROT_STR_MISC:
                    dictionary = GDC_DICT_MISC;
                    break;

                case PROT_STR_INPUT:
                    dictionary = GDC_DICT_INPUT;
                    break;
            }

            pgdcSrc = &m_pasLocal->adcsDict[dictionary];
        }

        compressed = GDC_Compress(pgdcSrc,  GDCCO_MAXCOMPRESSION,
            m_agdcWorkBuf, (LPBYTE)(pPacket + 1),
            cbSrcDataSize, m_ascTmpBuffer, &cbDstDataSize);

        if (compressed)
        {
            //
            // The data was successfully compressed, copy it back
            //
            ASSERT(cbDstDataSize <= cbSrcDataSize);
            memcpy((pPacket+1), m_ascTmpBuffer, cbDstDataSize);

            //
            // The data length include the data header
            //
            pPacket->dataLength = (TSHR_UINT16)(cbDstDataSize + sizeof(DATAPACKETHEADER));
            pPacket->data.compressedLength = pPacket->dataLength;

            packetLength = cbDstDataSize + sizeof(S20DATAPACKET);
        }
    }

    //
    // Update the packet header.
    //
    if (!compressed)
    {
        pPacket->data.compressionType = 0;
    }
    else
    {
        pPacket->data.compressionType = (BYTE)compression;
    }

    //
    // Send the packet.
    //
    S20_SendDataPkt(streamID, nodeID, pPacket);

#ifdef _DEBUG
    DebugExitDWORD(ASShare::DCS_CompressAndSendPacket, packetLength);
    return(packetLength);
#else
    DebugExitVOID(ASShare::DCS_CompressAndSendPacket);
#endif // _DEBUG
}


//
// DCS_FlowControl()
//
// This is called back from our flow control code.  The parameter passed
// is the new bytes/second rate that data is flowing at.  We turn small
// packet compression off when the rate is large, it means we're on a
// fast link so there's no need to bog down the CPU compressing small
// packets.
//
void  ASShare::DCS_FlowControl
(
    UINT    DataBytesPerSecond
)
{
    DebugEntry(ASShare::DCS_FlowControl);

    if (DataBytesPerSecond < DCS_FAST_THRESHOLD)
    {
        //
        // Throughput is slow
        //
        if (m_dcsLargePacketCompressionOnly)
        {
            m_dcsLargePacketCompressionOnly = FALSE;
            TRACE_OUT(("DCS_FlowControl:  SLOW; compress small packets"));
        }
    }
    else
    {
        //
        // Throughput is fast
        //
        if (!m_dcsLargePacketCompressionOnly)
        {
            m_dcsLargePacketCompressionOnly = TRUE;
            TRACE_OUT(("DCS_FlowControl:  FAST; don't compress small packets"));
        }
    }

    DebugExitVOID(ASShare::DCS_FlowControl);
}



//
// DCS_SyncOutgoing() - see dcs.h
//
void ASShare::DCS_SyncOutgoing(void)
{
    DebugEntry(ASShare::DCS_SyncOutgoing);

    //
    // Reset the send compression dictionaries
    //
    {
        UINT    i;

        ASSERT(m_pasLocal->adcsDict);

        for (i = 0; i < GDC_DICT_COUNT; i++)
        {
            //
            // Somebody has joined or left.  We need to start over
            // and wipe out any saved data.
            //
            m_pasLocal->adcsDict[i].cbUsed = 0;
        }
    }

    DebugExitVOID(ASShare::DCS_SyncOutgoing);
}




//
// DCS_NotifyUI()
//
void DCS_NotifyUI
(
    UINT        eventID,
    UINT        parm1,
    UINT        parm2
)
{
    DebugEntry(DCS_NotifyUI);

    //
    // Post event to Front End
    //
    UT_PostEvent(g_putAS, g_putUI, 0, eventID, parm1, parm2);

    DebugExitVOID(DCS_NotifyUI);
}



//
// DCSLocalDesktopSizeChanged
//
// Routine called whenever the desktop size changes.
//
// Updates local desktop size stored in capabilities and informs all other
// machine in a share of the new size
//
void  DCSLocalDesktopSizeChanged(UINT width, UINT height)
{
    DebugEntry(DCSLocalDesktopSizeChanged);

    //
    // Check that the desktop has actually changed size
    //
    if ((g_cpcLocalCaps.screen.capsScreenHeight == height) &&
        (g_cpcLocalCaps.screen.capsScreenWidth == width))
    {
        TRACE_OUT(( "Desktop size has not changed!"));
        DC_QUIT;
    }

    //
    // Update the desktop size
    //
    g_cpcLocalCaps.screen.capsScreenWidth = (TSHR_UINT16)width;
    g_cpcLocalCaps.screen.capsScreenHeight = (TSHR_UINT16)height;

    if (g_asSession.pShare)
    {
        g_asSession.pShare->CPC_UpdatedCaps((PPROTCAPS)&g_cpcLocalCaps.screen);
    }

DC_EXIT_POINT:
    DebugExitVOID(DCSLocalDesktopSizeChanged);
}




//
// Main window message procedure.
//
LRESULT CALLBACK DCSMainWndProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    LRESULT     rc = 0;

    DebugEntry(DCSMainWndProc);

    switch (message)
    {
        case DCS_FINISH_INIT_MSG:
        {
            DCS_FinishInit();
            break;
        }

        case DCS_PERIODIC_SCHEDULE_MSG:
        {
            if (g_asSession.pShare)
            {
                //
                // Call our periodic processing function if there's at least
                // another person in the share with us.
                //
                g_asSession.pShare->ValidatePerson(g_asSession.pShare->m_pasLocal);

                //
                // NOTE:
                // If we add record/playback capabilities, get rid of this
                // or change the check.  This prevents us from allocating,
                // composing, and sending packets to nowhere when we are
                // the only person in the share.
                //
                if (g_asSession.pShare->m_pasLocal->pasNext || g_asSession.pShare->m_scfViewSelf)
                {
                    g_asSession.pShare->SC_Periodic();
                }
            }

            //
            // Notify the Scheduler that we have processed the scheduling
            // message, which signals that another one can be sent (only
            // one is outstanding at a time).
            //
            SCH_SchedulingMessageProcessed();
        }
        break;

        case WM_ENDSESSION:
        {
            //
            // The wParam specifies whether the session is about to end.
            //
            if (wParam && !(g_asOptions & AS_SERVICE))
            {
                //
                // Windows is about to terminate (abruptly!).  Call our
                // termination functions now - before Windows shuts down
                // the hardware device drivers.
                //
                // We don't leave this job to the WEP because by the time
                // it gets called the hardware device drivers have been
                // shut down and some of the calls we make then fail (e.g.
                // timeEndPeriod requires TIMER.DRV).
                //
                DCS_Term();
            }
        }
        break;

        case WM_CLOSE:
        {
            ERROR_OUT(("DCS window received WM_CLOSE, this should never happen"));
        }
        break;

        case WM_PALETTECHANGED:
        case WM_PALETTEISCHANGING:
        {
            //
            // Win95 patches the Palette DDIs which are more accurate,
            // so only key off this message for NT.
            //
            if (!g_asWin95 && g_asSharedMemory)
            {
                g_asSharedMemory->pmPaletteChanged = TRUE;
            }
        }
        break;

        case WM_DISPLAYCHANGE:
        {
            //
            // The desktop size is changing - we are passed the new size.
            //
            DCSLocalDesktopSizeChanged(LOWORD(lParam),
                                       HIWORD(lParam));
        }
        break;

        case WM_SETTINGCHANGE:
        case WM_USERCHANGED:
            if (g_asSession.pShare && g_asSession.pShare->m_pHost)
            {
                WARNING_OUT(("AS: Reset effects on %s", (message == WM_SETTINGCHANGE)
                    ? "SETTINGCHANGE" : "USERCHANGE"));
                HET_SetGUIEffects(FALSE, &g_asSession.pShare->m_pHost->m_hetEffects);
            }
            break;

        //
        // Private app sharing messages
        //
        case DCS_KILLSHARE_MSG:
            SC_EndShare();
            break;

        case DCS_SHAREDESKTOP_MSG:
            DCS_ShareDesktop();
            break;

        case DCS_UNSHAREDESKTOP_MSG:
            DCS_UnshareDesktop();
            break;

        case DCS_ALLOWCONTROL_MSG:
            if (g_asSession.pShare)
            {
                g_asSession.pShare->CA_AllowControl((BOOL)wParam);
            }
            break;

        case DCS_TAKECONTROL_MSG:
            if (g_asSession.pShare)
            {
                g_asSession.pShare->DCS_TakeControl((UINT)wParam);
            }
            break;

        case DCS_CANCELTAKECONTROL_MSG:
            if (g_asSession.pShare)
            {
                g_asSession.pShare->DCS_CancelTakeControl((UINT)wParam);
            }
            break;

        case DCS_RELEASECONTROL_MSG:
            if (g_asSession.pShare)
            {
                g_asSession.pShare->DCS_ReleaseControl((UINT)wParam);
            }
            break;

        case DCS_PASSCONTROL_MSG:
            if (g_asSession.pShare)
            {
                g_asSession.pShare->DCS_PassControl((UINT)wParam, (UINT)lParam);
            }
            break;

        case DCS_GIVECONTROL_MSG:
            if (g_asSession.pShare)
            {
                g_asSession.pShare->DCS_GiveControl((UINT)wParam);
            }
            break;

        case DCS_CANCELGIVECONTROL_MSG:
            if (g_asSession.pShare)
            {
                g_asSession.pShare->DCS_CancelGiveControl((UINT)wParam);
            }
            break;

        case DCS_REVOKECONTROL_MSG:
            if (g_asSession.pShare)
            {
                g_asSession.pShare->DCS_RevokeControl((UINT)wParam);
            }
            break;

        default:
            rc = DefWindowProc(hwnd, message, wParam, lParam);
            break;
    }

    DebugExitDWORD(DCSMainWndProc, rc);
    return(rc);
}


//
// DCS_ShareDesktop()
//
void DCS_ShareDesktop(void)
{
    DWORD   dwAppID;

    DebugEntry(DCS_ShareDesktop);

    if (!g_asSession.pShare)
    {
        //
        // Create one.
        //
        if (!SC_CreateShare(S20_CREATE))
        {
            WARNING_OUT(("Failing share request; in wrong state"));
            DC_QUIT;
        }
    }

    ASSERT(g_asSession.pShare);

    g_asSession.pShare->HET_ShareDesktop();

DC_EXIT_POINT:
    DebugExitVOID(DCS_Share);
}



//
// DCS_UnshareDesktop()
//
void DCS_UnshareDesktop(void)
{
    DebugEntry(DCS_UnshareDesktop);

    if (!g_asSession.pShare || !g_asSession.pShare->m_pHost)
    {
        WARNING_OUT(("Failing unshare, nothing is shared by us"));
        DC_QUIT;
    }

    g_asSession.pShare->HET_UnshareAll();

DC_EXIT_POINT:
    DebugExitVOID(DCS_Unshare);
}


//
// DCSGetPerson()
//
// Validates GCC ID passed in, returns non-null ASPerson * if all is cool.
//
ASPerson * ASShare::DCSGetPerson(UINT gccID, BOOL fNull)
{
    ASPerson * pasPerson = NULL;

    //
    // Special value?
    //
    if (!gccID)
    {
        if (fNull)
        {
            pasPerson = m_pasLocal->m_caInControlOf;
        }
    }
    else
    {
        pasPerson = SC_PersonFromGccID(gccID);
    }

    if (!pasPerson)
    {
        WARNING_OUT(("Person [%d] not in share", gccID));
    }
    else if (pasPerson == m_pasLocal)
    {
        ERROR_OUT(("Local person [%d] was passed in", gccID));
        pasPerson = NULL;
    }

    return(pasPerson);
}

//
// DCS_TakeControl()
//
void ASShare::DCS_TakeControl(UINT gccOf)
{
    ASPerson * pasHost;

    DebugEntry(ASShare::DCS_TakeControl);

    pasHost = DCSGetPerson(gccOf, FALSE);
    if (!pasHost)
    {
        WARNING_OUT(("DCS_TakeControl: ignoring, host [%d] not valid", gccOf));
        DC_QUIT;
    }

    CA_TakeControl(pasHost);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::DCS_TakeControl);
}



//
// DCS_CancelTakeControl()
//
void ASShare::DCS_CancelTakeControl(UINT gccOf)
{
    ASPerson * pasHost;

    DebugEntry(ASShare::DCS_CancelTakeControl);

    if (!gccOf)
    {
        pasHost = m_caWaitingForReplyFrom;
    }
    else
    {
        pasHost = DCSGetPerson(gccOf, FALSE);
    }

    if (!pasHost)
    {
        WARNING_OUT(("DCS_CancelTakeControl: Ignoring, host [%d] not valid", gccOf));
        DC_QUIT;
    }

    CA_CancelTakeControl(pasHost, TRUE);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::DCS_CancelTakeControl);
}


//
// DCS_ReleaseControl()
//
void ASShare::DCS_ReleaseControl(UINT gccOf)
{
    ASPerson * pasHost;

    DebugEntry(ASShare::DCS_ReleaseControl);

    //
    // Validate host
    //
    pasHost = DCSGetPerson(gccOf, TRUE);
    if (!pasHost)
    {
        WARNING_OUT(("DCS_ReleaseControl: ignoring, host [%d] not valid", gccOf));
        DC_QUIT;
    }

    CA_ReleaseControl(pasHost, TRUE);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::DCS_ReleaseControl);
}



//
// DCS_PassControl()
//
void ASShare::DCS_PassControl(UINT gccOf, UINT gccTo)
{
    ASPerson *  pasHost;
    ASPerson *  pasControllerNew;

    DebugEntry(ASShare::DCS_PassControl);

    //
    // Validate host
    //
    pasHost = DCSGetPerson(gccOf, TRUE);
    if (!pasHost)
    {
        WARNING_OUT(("DCS_PassControl: ignoring, host [%d] not valid", gccTo));
        DC_QUIT;
    }

    //
    // Validate new controller
    //
    pasControllerNew = DCSGetPerson(gccTo, FALSE);
    if (!pasControllerNew)
    {
        WARNING_OUT(("DCS_PassControl: ignoring, viewer [%d] not valid", gccTo));
        DC_QUIT;
    }

    if (pasControllerNew == pasHost)
    {
        ERROR_OUT(("DCS_PassControl: ignoring, pass of == pass to [%d]", pasControllerNew->mcsID));
        DC_QUIT;
    }

    CA_PassControl(pasHost, pasControllerNew);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::DCS_PassControl);
}



//
// DCS_GiveControl()
//
void ASShare::DCS_GiveControl(UINT gccTo)
{
    ASPerson * pasViewer;

    DebugEntry(ASShare::DCS_GiveControl);

    //
    // Validate viewer
    //
    pasViewer = DCSGetPerson(gccTo, FALSE);
    if (!pasViewer)
    {
        WARNING_OUT(("DCS_GiveControl: ignoring, viewer [%d] not valid", gccTo));
        DC_QUIT;
    }

    CA_GiveControl(pasViewer);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::DCS_GiveControl);
}



//
// DCS_CancelGiveControl()
//
void ASShare::DCS_CancelGiveControl(UINT gccTo)
{
    ASPerson * pasTo;

    DebugEntry(ASShare::DCS_CancelGiveControl);

    if (!gccTo)
    {
        pasTo = m_caWaitingForReplyFrom;
    }
    else
    {
        pasTo = DCSGetPerson(gccTo, FALSE);
    }

    if (!pasTo)
    {
        WARNING_OUT(("DCS_CancelGiveControl: Ignoring, person [%d] not valid", gccTo));
        DC_QUIT;
    }

    CA_CancelGiveControl(pasTo, TRUE);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::DCS_CancelGiveControl);
}



//
// DCS_RevokeControl()
//
void ASShare::DCS_RevokeControl(UINT gccController)
{
    ASPerson * pasController;

    DebugEntry(ASShare::DCS_RevokeControl);

    if (!gccController)
    {
        // Special value:  match whomever is controlling us
        pasController = m_pasLocal->m_caControlledBy;
    }
    else
    {
        pasController = DCSGetPerson(gccController, FALSE);
    }

    if (!pasController)
    {
        WARNING_OUT(("DCS_RevokeControl: ignoring, controller [%d] not valid", gccController));
        DC_QUIT;
    }

    CA_RevokeControl(pasController, TRUE);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::DCS_RevokeControl);
}





//
// SHP_ShareDesktop
//
BOOL  SHP_ShareDesktop(void)
{
    BOOL        rc = FALSE;

    DebugEntry(SHP_ShareDesktop);

    if (g_asCanHost)
    {
        rc = PostMessage(g_asMainWindow, DCS_SHAREDESKTOP_MSG, 0, 0);
    }
    else
    {
        ERROR_OUT(("SHP_ShareDesktop: not able to share"));
    }

    DebugExitBOOL(SHP_ShareDesktop, rc);
    return(rc);
}



//
// SHP_UnshareDesktop()
//
// For unsharing, we use a window.  The window has all the information
// we need to stop sharing already set in its host prop.
//
HRESULT SHP_UnshareDesktop(void)
{
    HRESULT     hr = E_FAIL;

    DebugEntry(SHP_UnshareDesktop);

    if (g_asCanHost)
    {
        if (PostMessage(g_asMainWindow, DCS_UNSHAREDESKTOP_MSG, 0, 0))
        {
            hr = S_OK;
        }
    }
    else
    {
        ERROR_OUT(("SHP_Unshare: not able to share"));
    }

    DebugExitHRESULT(SHP_UnshareDesktop, hr);
    return(hr);
}



//
// SHP_TakeControl()
// Request to take control of a remote host.
//      PersonOf is the GCC id of the remote.
//
HRESULT  SHP_TakeControl(IAS_GCC_ID PersonOf)
{
    HRESULT hr = E_FAIL;

    DebugEntry(SHP_TakeControl);

    if (g_asMainWindow &&
        PostMessage(g_asMainWindow, DCS_TAKECONTROL_MSG, PersonOf, 0))
    {
        hr = S_OK;
    }

    DebugExitHRESULT(SHP_TakeControl, hr);
    return(hr);
}



//
// SHP_CancelTakeControl()
// Cancel request to take control of a remote host.
//      PersonOf is the GCC id of the remote.
//
HRESULT  SHP_CancelTakeControl(IAS_GCC_ID PersonOf)
{
    HRESULT hr = E_FAIL;

    DebugEntry(SHP_CancelTakeControl);

    if (g_asMainWindow &&
        PostMessage(g_asMainWindow, DCS_CANCELTAKECONTROL_MSG, PersonOf, 0))
    {
        hr = S_OK;
    }

    DebugExitHRESULT(SHP_CancelTakeControl, hr);
    return(hr);
}



//
// SHP_ReleaseControl()
// Release control of a remote host.
//      PersonOf is the GCC id of the remote we are currently controlling
//          and wish to stop.  Zero means "whomever" we are in control of
//          at the time.
//
HRESULT SHP_ReleaseControl(IAS_GCC_ID PersonOf)
{
    HRESULT hr = E_FAIL;

    DebugEntry(SHP_ReleaseControl);

    if (g_asMainWindow &&
        PostMessage(g_asMainWindow, DCS_RELEASECONTROL_MSG, PersonOf, 0))
    {
        hr = S_OK;
    }

    DebugExitHRESULT(SHP_ReleaseControl, hr);
    return(hr);
}



//
// SHP_PassControl()
// Pass control of a remote to another prerson.
//      PersonOf is the GCC id of the remote we are currently controlling
//      PersonTo is the GCC id of the remote we wish to pass control to
//
HRESULT SHP_PassControl(IAS_GCC_ID PersonOf, IAS_GCC_ID PersonTo)
{
    HRESULT hr = E_FAIL;

    DebugEntry(SHP_PassControl);

    if (g_asMainWindow &&
        PostMessage(g_asMainWindow, DCS_PASSCONTROL_MSG, PersonOf, PersonTo))
    {
        hr = S_OK;
    }

    DebugExitHRESULT(SHP_PassControl, hr);
    return(hr);
}


//
// SHP_AllowControl()
// Toggle the ability for remotes to control us (when we are sharing stuff)
//
HRESULT SHP_AllowControl(BOOL fAllowed)
{
    HRESULT hr = E_FAIL;

    DebugEntry(SHP_AllowControl);

    if (!g_asCanHost)
    {
        ERROR_OUT(("SHP_AllowControl failing, can't host"));
        DC_QUIT;
    }

    if (PostMessage(g_asMainWindow, DCS_ALLOWCONTROL_MSG, fAllowed, 0))
    {
        hr = S_OK;
    }

DC_EXIT_POINT:
    DebugExitHRESULT(SHP_AllowControl, hr);
    return(hr);
}



//
// SHP_GiveControl()
//
// Give control of our shared stuff to a remote.
//
HRESULT SHP_GiveControl(IAS_GCC_ID PersonTo)
{
    HRESULT hr = E_FAIL;

    DebugEntry(SHP_GiveControl);

    if (g_asMainWindow &&
        PostMessage(g_asMainWindow, DCS_GIVECONTROL_MSG, PersonTo, 0))
    {
        hr = S_OK;
    }

    DebugExitHRESULT(SHP_GiveControl, hr);
    return(hr);
}



//
// SHP_CancelGiveControl()
//
// Cancel giving control of our shared stuff to a remote.
//
HRESULT SHP_CancelGiveControl(IAS_GCC_ID PersonTo)
{
    HRESULT hr = E_FAIL;

    DebugEntry(SHP_CancelGiveControl);

    if (g_asMainWindow &&
        PostMessage(g_asMainWindow, DCS_CANCELGIVECONTROL_MSG, PersonTo, 0))
    {
        hr = S_OK;
    }

    DebugExitHRESULT(SHP_CancelGiveControl, hr);
    return(hr);
}





//
// SHP_RevokeControl()
// Take control away from a remote who is in control of us.
//
// NOTE:
// SHP_AllowControl(FALSE) will of course revoke control if someone is
// in control of us at the time.
//
HRESULT SHP_RevokeControl(IAS_GCC_ID PersonTo)
{
    HRESULT hr = E_FAIL;

    DebugEntry(SHP_RevokeControl);

    if (g_asMainWindow &&
        PostMessage(g_asMainWindow, DCS_REVOKECONTROL_MSG, PersonTo, 0))
    {
        hr = S_OK;
    }

    DebugExitHRESULT(SHP_RevokeControl, hr);
    return(hr);
}



//
// SHP_GetPersonStatus()
//
HRESULT  SHP_GetPersonStatus(IAS_GCC_ID Person, IAS_PERSON_STATUS * pStatus)
{
    HRESULT     hr = E_FAIL;
    UINT        cbSize;

    DebugEntry(SHP_GetPersonStatus);

    UT_Lock(UTLOCK_AS);

    if (IsBadWritePtr(pStatus, sizeof(*pStatus)))
    {
        ERROR_OUT(("SHP_GetPersonStatus failing; IAS_PERSON_STATUS pointer is bogus"));
        DC_QUIT;
    }

    //
    // Check that size field is filled in properly
    //
    cbSize = pStatus->cbSize;
    if (cbSize != sizeof(*pStatus))
    {
        ERROR_OUT(("SHP_GetPersonStatus failing; cbSize field not right"));
        DC_QUIT;
    }

    //
    // First, clear the structure
    //
    ::ZeroMemory(pStatus, cbSize);
    pStatus->cbSize = cbSize;

    //
    // Is AS present?
    //
    if (!g_asMainWindow)
    {
        ERROR_OUT(("SHP_GetPersonStatus failing; AS not present"));
        DC_QUIT;
    }

    //
    // Are we in a share?
    //
    if (g_asSession.pShare)
    {
        ASPerson * pasT;

        //
        // Find this person
        //
        if (!Person)
        {
            Person = g_asSession.gccID;
        }

        for (pasT = g_asSession.pShare->m_pasLocal; pasT != NULL; pasT = pasT->pasNext)
        {
            if (pasT->cpcCaps.share.gccID == Person)
            {
                ASPerson * pTemp;

                //
                // Found it
                //
                pStatus->InShare = TRUE;

                switch (pasT->cpcCaps.general.version)
                {
                    case CAPS_VERSION_10:
                        pStatus->Version = IAS_VERSION_10;
                        break;

                    default:
                        ERROR_OUT(("Unknown version %d", pasT->cpcCaps.general.version));
                        break;
                }

                if (pasT->hetCount == HET_DESKTOPSHARED)
                    pStatus->AreSharing = IAS_SHARING_DESKTOP;
                else
                    pStatus->AreSharing = IAS_SHARING_NOTHING;

                pStatus->Controllable = pasT->m_caAllowControl;

                //
                // We MUST assign to avoid faults.
                //
                pTemp = pasT->m_caInControlOf;
                if (pTemp)
                {
                    pStatus->InControlOf = pTemp->cpcCaps.share.gccID;
                }
                else
                {
                    pTemp = pasT->m_caControlledBy;
                    if (pTemp)
                    {
                        pStatus->ControlledBy = pTemp->cpcCaps.share.gccID;
                    }
                }

                //
                // We MUST assign to avoid faults.
                //
                pTemp = g_asSession.pShare->m_caWaitingForReplyFrom;
                if (pTemp)
                {
                    if (pasT == g_asSession.pShare->m_pasLocal)
                    {
                        //
                        // We have an outstanding request to this dude.
                        //
                        switch (g_asSession.pShare->m_caWaitingForReplyMsg)
                        {
                            case CA_REPLY_REQUEST_TAKECONTROL:
                                pStatus->InControlOfPending = pTemp->cpcCaps.share.gccID;
                                break;

                            case CA_REPLY_REQUEST_GIVECONTROL:
                                pStatus->ControlledByPending = pTemp->cpcCaps.share.gccID;
                                break;
                        }
                    }
                    else if (pasT == pTemp)
                    {
                        //
                        // This dude has an outstanding request from us.
                        //
                        switch (g_asSession.pShare->m_caWaitingForReplyMsg)
                        {
                            case CA_REPLY_REQUEST_TAKECONTROL:
                                pStatus->ControlledByPending = g_asSession.pShare->m_pasLocal->cpcCaps.share.gccID;
                                break;

                            case CA_REPLY_REQUEST_GIVECONTROL:
                                pStatus->InControlOfPending = g_asSession.pShare->m_pasLocal->cpcCaps.share.gccID;
                                break;
                        }
                    }
                }

                break;
            }
        }
    }

    hr = S_OK;

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_AS);
    DebugExitHRESULT(SHP_GetPersonStatus, hr);
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\fh.cpp ===
#include "precomp.h"


//
// FH.CPP
// Font Handling
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE



//
// FH_Init()
//
// This routine allocates a structure for the local font list, then fills
// it in.  It returns the number of local fonts in the list, or zero if
// something went wrong
//
UINT FH_Init(void)
{
    UINT    cFonts = 0;

    DebugEntry(FH_Init);

    //
    // Create the font array and the font index array
    //
    g_fhFonts = new FHLOCALFONTS;
    if (!g_fhFonts)
    {
        ERROR_OUT(("FH_Init: couldn't allocate g_fhFonts local list"));
        DC_QUIT;
    }

    ZeroMemory(g_fhFonts, sizeof(FHLOCALFONTS));
    SET_STAMP(g_fhFonts, FHLOCALFONTS);

    //
    // Now we consider the fonts individually, and store all acceptable
    // ones in the local font list.
    //
    FHConsiderAllLocalFonts();

    cFonts = g_fhFonts->fhNumFonts;
    if (cFonts)
    {
        FHSortAndIndexLocalFonts();
    }
    else
    {
        WARNING_OUT(( "No fonts found - this seems unlikely"));
    }

DC_EXIT_POINT:
    DebugExitDWORD(FH_Init, cFonts);
    return(cFonts);
}


//
// FH_Term()
//
void FH_Term(void)
{
    DebugEntry(FH_Term);

    if (g_fhFonts)
    {
        delete g_fhFonts;
        g_fhFonts = NULL;
    }

    DebugExitVOID(FH_Term);
}


//
// FH_ReceivedPacket - see fh.h
//
void  ASShare::FH_ReceivedPacket
(
    ASPerson *      pasPerson,
    PS20DATAPACKET  pPacket
)
{
    PFHPACKET       pFontsPacket;
    UINT            iLocal;
    UINT            iRemote;
    LPNETWORKFONT   pRemoteFont;
    POEREMOTEFONT   pLocalFont;
    UINT            cbSize;

    DebugEntry(ASShare::FH_ReceivedPacket);

    ValidatePerson(pasPerson);

    pFontsPacket = (PFHPACKET)pPacket;

    //
    // If the number we received isn't the same as before, we need to
    // possibly free the previous font block, and then allocate a new one.
    //
    // Once we're in a share with this person, every new joiner will cause
    // existing members to resend their local fonts, usually the same size.
    // So we can optimize and not realloc in that case.
    //
    if (pFontsPacket->cFonts != pasPerson->oecFonts)
    {
        if (pasPerson->poeFontInfo)
        {
            delete[] pasPerson->poeFontInfo;
            pasPerson->poeFontInfo = NULL;
            pasPerson->oecFonts = 0;
        }
        else
        {
            ASSERT(!pasPerson->oecFonts);
        }

        //
        // Allocate a new block
        //
        pasPerson->poeFontInfo = new OEREMOTEFONT[pFontsPacket->cFonts];
        if (!pasPerson->poeFontInfo)
        {
            ERROR_OUT(("Couldn't allocate %d fonts for FH packet from [%d]",
                pasPerson->mcsID));
            DC_QUIT;
        }

        ZeroMemory(pasPerson->poeFontInfo, pFontsPacket->cFonts * sizeof(OEREMOTEFONT));
        pasPerson->oecFonts = pFontsPacket->cFonts;
    }


    TRACE_OUT(("Received %d remote fonts in packet from person [%d]",
        pasPerson->oecFonts, pasPerson->mcsID));

    //
    // Consider each remote font. The multibyte fields of the NETWORKFONT
    // structure are flipped as they are read; otherwise we would have to
    // duplicate the logic about which fields are present in which version.
    //

    //
    // The size of each font is in the packet.
    //
    cbSize      = pFontsPacket->cbFontSize;
    pRemoteFont = pFontsPacket->aFonts;
    pLocalFont  = pasPerson->poeFontInfo;

    for (iRemote = 0; iRemote < pasPerson->oecFonts; iRemote++, pLocalFont++)
    {
        //
        // Copy the fields we store directly.
        //
        pLocalFont->rfFontFlags     = pRemoteFont->nfFontFlags;
        pLocalFont->rfAveWidth      = pRemoteFont->nfAveWidth;
        pLocalFont->rfAveHeight     = pRemoteFont->nfAveHeight;
        pLocalFont->rfAspectX       = pRemoteFont->nfAspectX;
        pLocalFont->rfAspectY       = pRemoteFont->nfAspectY;

        //
        // And the R2.0 field(s)...
        //
        if (m_oeCombinedOrderCaps.capsfFonts & CAPS_FONT_CODEPAGE)
        {
            pLocalFont->rfCodePage = pRemoteFont->nfCodePage;
        }
        //
        // And the other R2.0 field(s)...
        //
        if (m_oeCombinedOrderCaps.capsfFonts & CAPS_FONT_R20_SIGNATURE)
        {
            pLocalFont->rfSigFats    = pRemoteFont->nfSigFats;
            pLocalFont->rfSigThins   = pRemoteFont->nfSigThins;
            pLocalFont->rfSigSymbol  = pRemoteFont->nfSigSymbol;
        }
        if (m_oeCombinedOrderCaps.capsfFonts & CAPS_FONT_EM_HEIGHT)
        {
            pLocalFont->rfMaxAscent  = pRemoteFont->nfMaxAscent;
            TRACE_OUT(( "maxAscent %hd", pLocalFont->rfMaxAscent));
        }

        //
        // Set up an initial remote to local handle mapping, by scanning
        // for the first local font with the remote font's facename.
        //
        // We first set a default match value, in case we dont find a true
        // match - this value should never be referenced since we never get
        // sent fonts that we can't match (because we sent details of our
        // fonts to remote systems, and they should be using the same, or a
        // compatible, font matching algorithm.
        //
        // The mapping we obtain here is to the first local font that has
        // the remote font's facename, which is probably not the correct
        // font (ie there are probably multiple fonts with the same
        // facename).  This initial mapping will be updated when we do the
        // full matching for all remote fonts.  (See FHConsiderRemoteFonts
        // for details), but is sufficient, as all we will use it for until
        // then, is to obtain the facename.
        //
        // This approach means that we do not have to store the remote
        // facename, which is a useful saving on remote font details space.
        //
        // SFR5279: cannot default to zero because that means we give a
        // name to fonts that do not in fact match at all, causing us to
        // always waste effort in FHConsiderRemoteFonts and sometimes to
        // wrongly match two fonts that do not really match at all.
        //
        pLocalFont->rfLocalHandle= NO_FONT_MATCH;

        for (iLocal = 0; iLocal < g_fhFonts->fhNumFonts; iLocal++)
        {
            if (!lstrcmp(g_fhFonts->afhFonts[iLocal].Details.nfFaceName,
                          pRemoteFont->nfFaceName))
            {
                pLocalFont->rfLocalHandle = (TSHR_UINT16)iLocal;
                break;
            }
        }

        //
        // Advance to the next remote font.
        //
        pRemoteFont = (LPNETWORKFONT)((LPBYTE)pRemoteFont + cbSize);
    }

DC_EXIT_POINT:
    //
    // We have a new set of fonts, so determine the common list.
    //
    FH_DetermineFontSupport();

    DebugExitVOID(ASShare::FH_ReceivedPacket);
}

//
// FH_SendLocalFontInfo()
//
void ASShare::FH_SendLocalFontInfo(void)
{
    PFHPACKET       pFontPacket = NULL;
    LPBYTE          pNetworkFonts;
    UINT            pktSize;
    UINT            iFont;
    BOOL            fSendFont;
    UINT            cDummyFonts = 0;
#ifdef _DEBUG
    UINT            sentSize;
#endif // _DEBUG

    DebugEntry(ASShare::FH_SendLocalFontInfo);

    ASSERT(!m_fhLocalInfoSent);

    //
    //
    // Look at the combined capability flags to see whether the remote(s)
    // can cope with our preferred font structure (R20) or a slightly
    // older one (R11) or only the original flavor (pre R11).
    //
    //
    if (!(m_oeCombinedOrderCaps.capsfFonts & CAPS_FONT_R20_TEST_FLAGS))
    {
        WARNING_OUT(("Remotes in share don't support CAPS_FONT_R20"));
        m_fhLocalInfoSent = TRUE;
        DC_QUIT;
    }

    pktSize = sizeof(FHPACKET) + (g_fhFonts->fhNumFonts - 1) * sizeof(NETWORKFONT);
    pFontPacket = (PFHPACKET)SC_AllocPkt(PROT_STR_MISC, g_s20BroadcastID, pktSize);
    if (!pFontPacket)
    {
        WARNING_OUT(("Failed to alloc FH packet, size %u", pktSize));
        DC_QUIT;
    }

    //
    // Packet successfully allocated.  Fill in the data and send it.
    //
    pFontPacket->header.data.dataType = DT_FH;

    pFontPacket->cbFontSize = sizeof(NETWORKFONT);

    //
    // Copy the fonts we want to send into the network packet.
    //
    pNetworkFonts = (LPBYTE)pFontPacket->aFonts;
    cDummyFonts = 0;
    for (iFont = 0 ; iFont < g_fhFonts->fhNumFonts ; iFont++)
    {
        //
        // Assume we will send this font.
        //
        fSendFont = TRUE;

        //
        // Check whether font is ANSI charset or font CodePage capability
        // is supported.  If neither, skip on to next local font.
        //
        TRACE_OUT(( "TEST CP set OK: font[%u] CodePage[%hu]", iFont,
                                g_fhFonts->afhFonts[iFont].Details.nfCodePage));

        if ((g_fhFonts->afhFonts[iFont].Details.nfCodePage != ANSI_CHARSET) &&
            (!(m_oeCombinedOrderCaps.capsfFonts & CAPS_FONT_CODEPAGE))   )
        {
            TRACE_OUT(( "Dont send font[%u] CodePage[%hu]", iFont,
                                g_fhFonts->afhFonts[iFont].Details.nfCodePage));
            fSendFont = FALSE;
        }

        if (fSendFont)
        {
            //
            // We want to send this entry so copy across as much of the
            // stored details as the protocol level requires.
            // We then mask the flags and advance to the next location in
            // the packet.
            //
            memcpy(pNetworkFonts,
                      &g_fhFonts->afhFonts[iFont].Details,
                      sizeof(NETWORKFONT));

            ((LPNETWORKFONT)pNetworkFonts)->nfFontFlags &= ~NF_LOCAL;
        }
        else
        {
            //
            // If we determine that we do not want to send the current
            // font then we fill the corresponding entry in the network
            // packet with zeros. This ensures that an index into our
            // local font table is also an index into the network packet,
            // so no conversion is required. Setting the whole entry to
            // zero gives the font a NULL facename and zero size, which
            // will never match a real font.
            //
            ZeroMemory(pNetworkFonts, sizeof(NETWORKFONT));
            cDummyFonts++;
        }

        //
        // Move to the next entry in the font packet.
        //
        pNetworkFonts += sizeof(NETWORKFONT);
    }

    //
    // Note that at the end of this loop, we may not have sent any fonts,
    // eg where the remote system does not support the font CodePage
    // capability and we do not have any true ANSI fonts.  We send the
    // packet anyway, so the remote system sees that we have no fonts to
    // match.
    //

    //
    // Only now do we know the number of fonts we actually put in the
    // packet.
    //
    pFontPacket->cFonts = (TSHR_UINT16)g_fhFonts->fhNumFonts;

    //
    // Send the fonts packet on the MISC stream.  It has no dependency on
    // any updates and we want it to get across quickly.
    //
    if (m_scfViewSelf)
        FH_ReceivedPacket(m_pasLocal, &(pFontPacket->header));

#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    DCS_CompressAndSendPacket(PROT_STR_MISC, g_s20BroadcastID,
        &(pFontPacket->header), pktSize);

    TRACE_OUT(("FH packet size: %08d, sent %08d", pktSize, sentSize));
    TRACE_OUT(( "Sent font packet with %u fonts (inc %u dummies)",
                 g_fhFonts->fhNumFonts,
                 cDummyFonts));

    //
    // Set the flag that indicates that we have successfully sent the
    // font info.
    //
    m_fhLocalInfoSent = TRUE;

    //
    // The font info has been sent, so this may mean we can enable text
    // orders.
    //
    FHMaybeEnableText();

DC_EXIT_POINT:
    DebugExitVOID(ASShare::FH_SendLocalFontInfo);
}


//
// FUNCTION: FH_GetMaxHeightFromLocalHandle
//
// DESCRIPTION:
//
// Given an FH font handle (ie a handle originating from the locally
// supported font structure which was sent to the remote machine at the
// start of the call) this function returns the MaxBaseLineExt value stored
// with the LOCALFONT details
//
// PARAMETERS:
//
// fontHandle - font handle being queried.
//
// RETURNS: max font height
//
//
UINT  FH_GetMaxHeightFromLocalHandle(UINT  fontHandle)
{
    UINT rc;

    DebugEntry(FH_GetMaxHeightFromLocalHandle);

    //
    // First check that the font handle is valid.
    //
    if (fontHandle >= g_fhFonts->fhNumFonts)
    {
        ERROR_OUT(( "Invalid font handle %u", fontHandle));
        fontHandle = 0;
    }

    //
    // Return the max font height
    //
    rc = g_fhFonts->afhFonts[fontHandle].lMaxBaselineExt;

    DebugExitDWORD(FH_GetMaxHeightFromLocalHandle, rc);
    return(rc);
}


//
// FUNCTION: FH_GetFontFlagsFromLocalHandle
//
// DESCRIPTION:
//
// Given an FH font handle (ie a handle originating from the locally
// supported font structure which was sent to the remote machine at the
// start of the call) this function returns the FontFlags value stored with
// the LOCALFONT details
//
// PARAMETERS:
//
// fontHandle - font handle being queried.
//
// RETURNS: font flags
//
//
UINT  FH_GetFontFlagsFromLocalHandle(UINT  fontHandle)
{
    UINT rc;

    DebugEntry(FH_GetFontFlagsFromLocalHandle);

    //
    // First check that the font handle is valid.
    //
    if (fontHandle >= g_fhFonts->fhNumFonts)
    {
        ERROR_OUT(( "Invalid font handle %u", fontHandle));
        fontHandle = 0;
    }

    //
    // Return the font flags.
    //
    rc = g_fhFonts->afhFonts[fontHandle].Details.nfFontFlags;

    DebugExitDWORD(FH_GetFontFlagsFromLocalHandle, rc);
    return(rc);
}

//
// FUNCTION: FH_GetCodePageFromLocalHandle
//
// DESCRIPTION:
//
// Given an FH font handle (ie a handle originating from the locally
// supported font structure which was sent to the remote machine at the
// start of the call) this function returns the CodePage value stored with
// the LOCALFONT details
//
// PARAMETERS:
//
// fontHandle - font handle being queried.
//
// RETURNS: char set
//
//
UINT  FH_GetCodePageFromLocalHandle(UINT  fontHandle)
{
    UINT rc = 0;

    DebugEntry(FH_GetCodePageFromLocalHandle);

    //
    // First check that the font handle is valid.
    //
    if (fontHandle >= g_fhFonts->fhNumFonts)
    {
        ERROR_OUT(( "Invalid font handle %u", fontHandle));
        fontHandle = 0;
    }

    //
    // Return the char set.
    //
    rc = g_fhFonts->afhFonts[fontHandle].Details.nfCodePage;

    DebugExitDWORD(FH_GetCodePageFromLocalHandle, rc);
    return(rc);
}



//
// FH_ConvertAnyFontIDToLocal()
//
// DESCRIPTION:
// Converts any font name ID fields in the passed order from remote font
// face name IDs to local font facename IDs.
//
void  ASShare::FH_ConvertAnyFontIDToLocal
(
    LPCOM_ORDER pOrder,
    ASPerson *  pasPerson
)
{
    LPCOMMON_TEXTORDER   pCommon = NULL;

    DebugEntry(ASShare::FH_ConvertAnyFontIDToLocal);

    ValidatePerson(pasPerson);

    //
    // Get a pointer to the structure which is common to both TextOut and
    // ExtTextOut
    //
    if (TEXTFIELD(pOrder)->type == LOWORD(ORD_TEXTOUT))
    {
        pCommon = &TEXTFIELD(pOrder)->common;
    }
    else if (EXTTEXTFIELD(pOrder)->type == LOWORD(ORD_EXTTEXTOUT))
    {
        pCommon = &EXTTEXTFIELD(pOrder)->common;
    }
    else
    {
        ERROR_OUT(( "Order type not TextOut or ExtTextOut."));
        DC_QUIT;
    }

    TRACE_OUT(( "fonthandle IN %lu", pCommon->FontIndex));
    pCommon->FontIndex = FHGetLocalFontHandle(pCommon->FontIndex, pasPerson);
    TRACE_OUT(( "fonthandle OUT %lu", pCommon->FontIndex));

DC_EXIT_POINT:
    DebugExitVOID(ASShare::FH_ConvertAnyFontIDToLocal);
}

//
// FH_GetFaceNameFromLocalHandle - see fh.h
//
LPSTR  FH_GetFaceNameFromLocalHandle(UINT fontHandle, LPUINT pFaceNameLength)
{
    LPSTR pFontName = NULL;

    DebugEntry(FH_GetFaceNameFromLocalHandle);

    //
    // First check that the font handle is valid.
    //
    if (fontHandle >= g_fhFonts->fhNumFonts)
    {
        ERROR_OUT(( "Invalid font handle %u", fontHandle));
        fontHandle = 0;
    }

    //
    // Now get the facename
    //
    *pFaceNameLength = lstrlen(g_fhFonts->afhFonts[fontHandle].RealName);
    pFontName = g_fhFonts->afhFonts[fontHandle].RealName;

    DebugExitVOID(FH_GetFaceNameFromLocalHandle);
    return(pFontName);
}


//
// FH_DetermineFontSupport()
//
void  ASShare::FH_DetermineFontSupport(void)
{
    UINT            cCommonFonts;
    UINT            iLocal;
    ASPerson *      pasPerson;

    DebugEntry(ASShare::FH_DetermineFontSupport);

    //
    // First mark all local fonts as supported.
    //
    cCommonFonts = g_fhFonts->fhNumFonts;
    for (iLocal = 0; iLocal < g_fhFonts->fhNumFonts; iLocal++)
    {
        g_fhFonts->afhFonts[iLocal].SupportCode = FH_SC_EXACT_MATCH;
    }

    //
    // Work through all remote people (but not us)
    //
    ValidatePerson(m_pasLocal);

    for (pasPerson = m_pasLocal->pasNext;
        (cCommonFonts > 0) && (pasPerson != NULL);
        pasPerson = pasPerson->pasNext)
    {
        ValidatePerson(pasPerson);

        if (pasPerson->oecFonts)
        {
            cCommonFonts = FHConsiderRemoteFonts(cCommonFonts, pasPerson);
        }
        else
        {
            //
            // We do not have valid fonts for this person, so must not
            // send any text orders at all.
            //
            TRACE_OUT(( "Pending FONT INFO from person [%d]", pasPerson->mcsID));
            cCommonFonts = 0;
        }
    }

    //
    // We have determined the common supported fonts, and may be able to
    // enable text orders now.
    //
    FHMaybeEnableText();

    DebugExitVOID(ASShare::FH_DetermineFontSupport);
}



//
// FH_CreateAndSelectFont()
//
BOOL  FH_CreateAndSelectFont(HDC    surface,
                                                 HFONT*       pHNewFont,
                                                 HFONT*       pHOldFont,
                                                 LPSTR        fontName,
                                                 UINT         codepage,
                                                 UINT         fontMaxHeight,
                                                 UINT         fontHeight,
                                                 UINT         fontWidth,
                                                 UINT         fontWeight,
                                                 UINT         fontFlags)
{
    BOOL      rc;
    BYTE        italic;
    BYTE        underline;
    BYTE        strikeout;
    BYTE        pitch;
    BYTE        charset;
    BYTE        precis;

    DebugEntry(FH_CreateAndSelectFont);


    //
    // Set the return code to indicate failure (FALSE). We will change this
    // later if we successfully create the font.
    //
    rc = FALSE;

    //
    // Massage the data passed which describes the font into the correct
    // arrangement to pass on a create font call.  Then create a font.
    //

    //
    // If a facename passed is the null string then we are supposed to use
    // the system font.
    //
    if (fontName[0] == 0)
    {
        WARNING_OUT(( "Using system font"));
        *pHNewFont = GetStockFont(SYSTEM_FONT);
    }
    else
    {
        //
        // Determine the italic, underline, strikeout and pitch values from
        // the packed flags.
        //
        italic    = (BYTE)(fontFlags & NF_ITALIC);
        underline = (BYTE)(fontFlags & NF_UNDERLINE);
        strikeout = (BYTE)(fontFlags & NF_STRIKEOUT);

        if (fontFlags & NF_FIXED_PITCH)
        {
            pitch = FF_DONTCARE | FIXED_PITCH;
        }
        else
        {
            pitch = FF_DONTCARE | VARIABLE_PITCH;
        }

        //
        // Check whether this is a TrueType font.  This is important, as
        // the Windows Font mapper is biased towards non-TrueType, and it
        // is easy to do the subsequent decoding with a non-TrueType font.
        //
        // Note that the Windows headers do not define a name for the
        // required value (which is 0x04 in the manuals), so we use the
        // value used in the TextMetrics (which has the same value).
        //
        if (fontFlags & NF_TRUE_TYPE)
        {
            pitch |= TMPF_TRUETYPE;
            precis = OUT_TT_ONLY_PRECIS;
        }
        else
        {
            precis = OUT_RASTER_PRECIS;
        }

        //
        // The height we are passed is the character height, not the cell
        // height.  To indicate this to Windows we need to pass it in as a
        // negative value.
        //
        TRACE_OUT(( "CreateFont cx(%u) cy(%u) wt(%u) pitch(%u) name:%s",
                                                                 fontWidth,
                                                                 fontHeight,
                                                                 fontWeight,
                                                                 pitch,
                                                                 fontName ));

        //
        // Use the misleadingly named codepage value to calculate what
        // charset to ask Windows for.
        //
        if (codepage == NF_CP_WIN_ANSI)
        {
            charset = ANSI_CHARSET;
        }
        else if (codepage == NF_CP_WIN_OEM)
        {
            charset = OEM_CHARSET;
        }
        else if (codepage == NF_CP_WIN_SYMBOL)
        {
            charset = SYMBOL_CHARSET;
        }
        else
        {
            //
            // We have to trust our luck to Windows by specifying default
            // (meaning don't care).
            //
            charset = DEFAULT_CHARSET;
        }

        *pHNewFont = CreateFont(-(int)fontHeight,
                             fontWidth,
                             0,    // escapement
                             0,    // orientation
                             fontWeight,
                             italic,
                             underline,
                             strikeout,
                             charset,
                             precis,
                             CLIP_DEFAULT_PRECIS,
                             DEFAULT_QUALITY,
                             pitch,
                             fontName);
        if (*pHNewFont == NULL)
        {
            WARNING_OUT(( "Failed to create font %s", fontName));
            DC_QUIT;
        }
    }

    //
    // Now we have created the font we need to select it into the HDC
    // which was passed to us.
    //
    *pHOldFont = SelectFont(surface, *pHNewFont);
    if (*pHOldFont == NULL)
    {
        ERROR_OUT(( "Failed to select font %s", fontName));
        DeleteFont(*pHNewFont);
        *pHNewFont = NULL;
        DC_QUIT;
    }
    TRACE_OUT(( "Select new font: %p Old font: %", *pHNewFont,
                                               *pHOldFont));

    //
    // We have successfully created and selected the font.
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(FH_CreateAndSelectFont, rc);
    return(rc);
}


//
// FHAddFontToLocalTable
//
// Adds the given font into the local font table, along with any renaming
// and approximate matches.
//
//
void  FHAddFontToLocalTable( LPSTR  faceName,
                                                 TSHR_UINT16 fontFlags,
                                                 TSHR_UINT16 codePage,
                                                 TSHR_UINT16 maxHeight,
                                                 TSHR_UINT16 aveHeight,
                                                 TSHR_UINT16 aveWidth,
                                                 TSHR_UINT16 aspectX,
                                                 TSHR_UINT16 aspectY,
                                                 TSHR_UINT16 maxAscent)
{
    TSHR_INT16       fatSig;
    TSHR_INT16       thinSig;
    TSHR_INT16       symbolSig;
    FHWIDTHTABLE  wTable;
    TSHR_UINT16      height;
    TSHR_UINT16      width;
    TSHR_UINT16      weight;
    LOCALFONT     thisFont;
    TSHR_UINT16      fIndex;

    //
    // SFRFONT: place marker.
    // Here would be the best place to adjust codepage; for example suppose
    // we find that CodePage 950 (Chinese) is so different on all platforms
    // that we just should not send text orders in this codepage, we can
    // set codePage=NF_CP_UNKNOWN and it will be discarded.
    //

    //
    // SFRFONT: no point hanging on to details of fonts with unknown
    // code pages; we cannot risk matching them.
    //
    if (codePage == NF_CP_UNKNOWN)
    {
        TRACE_OUT(( "unknown CP: discard"));
        DC_QUIT;
    }

    //
    // Check we still have room for more fonts.
    //
    if (g_fhFonts->fhNumFonts >= FH_MAX_FONTS)
    {
        //
        // We are already at our maximum number of fonts.
        //
        DC_QUIT;
    }

    //
    // Zero the fields where we store facenames to allow bytewise matches.
    //
    ZeroMemory(thisFont.Details.nfFaceName, FH_FACESIZE);
    ZeroMemory(thisFont.RealName, FH_FACESIZE);

    //
    // Store the easy bits!
    //
    thisFont.Details.nfFontFlags = fontFlags;
    thisFont.Details.nfAveWidth  = aveWidth;
    thisFont.Details.nfAveHeight = aveHeight;
    thisFont.Details.nfAspectX   = aspectX;
    thisFont.Details.nfAspectY   = aspectY;
    thisFont.Details.nfCodePage  = codePage;

    thisFont.lMaxBaselineExt     = maxHeight;

    //
    // Store the real name, for use when we want to create an instance of
    // this font.
    //
    lstrcpy (thisFont.RealName, faceName);

    //
    // Fill in the wire-format facename.
    //
    // NB - This has a machine-specific prefix, but for NT the prefix is an
    // empty string, so we can just use a strcpy without worrying about the
    // issues of adding a prefix.
    //
    lstrcpy (thisFont.Details.nfFaceName, faceName);

    //
    // Make sure the signatures are zero for now.
    //
    thisFont.Details.nfSigFats       = 0;
    thisFont.Details.nfSigThins      = 0;
    thisFont.Details.nfSigSymbol     = 0;

    //
    // Now calculate the signature and maxAscent for this font
    //
    weight = 0;                             // use default weight

    if ((fontFlags & NF_FIXED_SIZE) != 0)
    {
        //
        // Fixed size font: use actual font size for signatures/maxAscent
        //
        height = thisFont.lMaxBaselineExt;
        width  = thisFont.Details.nfAveWidth;

        thisFont.Details.nfMaxAscent = maxAscent;
    }
    else
    {
        //
        // Scalable font: use default height/width for signatures/maxAscent
        //
        height = NF_METRICS_HEIGHT;
        width  = NF_METRICS_WIDTH;

        thisFont.Details.nfMaxAscent = NF_METRICS_HEIGHT;
    }

    //
    // Initialise signature fields to zero (== NF_NO_SIGNATURE).  They will
    // be overwritten assuming we get a font width table OK.
    //
    fatSig    = 0;
    thinSig   = 0;
    symbolSig = 0;

    //
    // FHGenerateFontWidthTable also gives us a proper maxAscent value for
    // scalable fonts (i.e. based on its own rendition of the font)
    //
    if (FHGenerateFontWidthTable(&wTable,
                                 &thisFont,
                                  height,
                                  width,
                                  weight,
                                  thisFont.Details.nfFontFlags,
                                 &maxAscent))
    {
        //
        // If this is a scalable font, use the updated maxAscent value that
        // FHGenerateFontWidthTable has given us.
        //
        if (0 == (thisFont.Details.nfFontFlags & NF_FIXED_SIZE))
        {
            thisFont.Details.nfMaxAscent = maxAscent;
            TRACE_OUT(( "Set maxAscent = %d", thisFont.Details.nfMaxAscent));
        }

        //
        // We have all the raw data we need.  Calculate the signatures.
        //
        FHCalculateSignatures(&wTable, &fatSig, &thinSig, &symbolSig);
    }

    //
    // Store the signatures.  If the call to FHGenerateFontWidthTable
    // fails, the signatures are zero.
    //
    thisFont.Details.nfSigFats     =  (BYTE)fatSig;
    thisFont.Details.nfSigThins    =  (BYTE)thinSig;
    thisFont.Details.nfSigSymbol   = (TSHR_UINT16)symbolSig;

    TRACE_OUT(( "Font %hu signatures: (x%.4hx%.2hx%.2hx)",
             g_fhFonts->fhNumFonts,
             thisFont.Details.nfSigSymbol,
             (TSHR_UINT16)(thisFont.Details.nfSigThins),
             (TSHR_UINT16)(thisFont.Details.nfSigFats)));

    //
    // We can now copy the details to the end of the local table.
    //
    memcpy((void *)&g_fhFonts->afhFonts[g_fhFonts->fhNumFonts],
              (void *)&thisFont,
              sizeof(LOCALFONT));

    //
    // Count this font.
    //
    TRACE_OUT(( "Added record %s",
                                g_fhFonts->afhFonts[g_fhFonts->fhNumFonts].Details.nfFaceName));
    g_fhFonts->fhNumFonts++;

    TRACE_OUT(( "g_fhFonts->fhNumFonts now %u", g_fhFonts->fhNumFonts));

DC_EXIT_POINT:
    DebugExitVOID(FHAddFontToLocalTable);
}

//
// FHConsiderRemoteFonts
//
// Considers the remote fonts for a single remote person.
//
// Takes the existing number of supported fonts, and returns the number
// that are still common after considering this person.
//
UINT  ASShare::FHConsiderRemoteFonts
(
    UINT        cCanSend,
    ASPerson *  pasPerson
)
{
    UINT  iLocal;
    UINT  iRemote;
    UINT  cCanReceive=0;
    BOOL  fCanReceive, fOnlyAscii;
    UINT  sendSupportCode;
    UINT  bestSupportSoFar;

    DebugEntry(ASShare::FHConsiderRemoteFonts);

    ValidatePerson(pasPerson);
    //
    // Consider each of the still valid local fonts, and see if the remote
    // person also supports them.
    //

    //
    // SFR5396: LOOP ONE
    //
    // Look through all the LOCAL fonts, for ones where we find a match in
    // the remote font table.  These are fonts we can SEND, and for which
    // we must set g_fhFonts->afhFonts[].Supported.
    //
    // We also set the rfLocalHandle for remote fonts that we can receive
    // if we encounter them in this search.  We complete the search for
    // remote fonts that we can receive in LOOP TWO.
    //
    // Things we check in this loop: - we may already know there is no
    // match for this local name
    //      so drop out quickly.  - otherwise check through EVERY REMOTE
    // font looking for the
    //      best possible match.  (If we find an EXACT match, leave the
    //      inner loop early)
    //
    //
    for (iLocal=0;
         (cCanSend > 0) && (iLocal < g_fhFonts->fhNumFonts);
         iLocal++)
    {
        if (g_fhFonts->afhFonts[iLocal].SupportCode != FH_SC_NO_MATCH)
        {
            //
            //
            // This font is still valid so check it with all the remote
            // fonts for this person.
            //
            // Things we check in this loop:
            // -    do the face names match? if no - try next remote font.
            // -    the pitch: if one is FIXED pitch and one isn't try next
            // -    the codepages: are the local/remote the same?  This
            //          determines whether we send only ASCII chars.
            // -    scalability: possible combinations are:
            //       local fixed/remote scalable       (can send/not rcv)
            //       local scalable/remote scalable    (can send and rcv)
            //       local fixed/remote fixed, sizes match (send & rcv)
            //       local scalable/remote fixed      (cannot send/can rcv)
            //          for this last case, keep trying the remote fonts.
            //
            // In "back level" calls to Pre-R11 boxes we stop here but
            // force the matches to be approximate.  Otherwise check
            //
            // -    aspect ratios (if present): must match or try the
            //       next remote font.
            // -    signatures: these are used to finally decide whether
            //       the fonts are exact matches; good enough to treat as
            //       approximate matches or such poor matches that the
            //       font is not supported (cannot be sent).
            //
            //

//
// Handy SHORTHAND macroes.
//
#define REMOTEFONT pasPerson->poeFontInfo[iRemote]
#define LOCALFT  g_fhFonts->afhFonts[iLocal]
#define LOCALDETS  LOCALFT.Details

            //
            // Initially assume that the fonts do not match, but that
            // if they do they will match across the whole codepage
            // (not just the ascii set).
            //
            sendSupportCode  = FH_SC_NO_MATCH;
            bestSupportSoFar = FH_SC_NO_MATCH;
            fOnlyAscii       = FALSE;

            //
            //
            // Loop through all the remote fonts looking to see which, if
            // any, offers the best possible match.  Initially,
            // sendSupportCode is set to NO_MATCH; as we go through each
            // iteration we see if we can improve on the current setting
            // of sendSupportCode.  We leave the loop as soon as we find
            // an EXACT_MATCH ('cos we are not going to do any better than
            // that!) or when we run out of remote fonts.  The best match
            // found so far is kept in bestSupportSoFar.
            //
            //
            for (iRemote = 0;
                 (iRemote < pasPerson->oecFonts)
                                   && (sendSupportCode != FH_SC_EXACT_MATCH);
                 iRemote++)
            {
                //
                // If the remote font is already flagged as having no
                // possible match then skip out now. (We set this field
                // during the initial processing of the remote font).
                //
                if (REMOTEFONT.rfLocalHandle==NO_FONT_MATCH)
                {
                    continue;                                    // SFR5279
                }

                //
                // Check the face names...
                //
                if (lstrcmp(LOCALDETS.nfFaceName,
                    g_fhFonts->afhFonts[REMOTEFONT.rfLocalHandle].Details.nfFaceName))
                {
                    continue;
                }
                TRACE_OUT(( "Matched Remote Face Name %s",
                       g_fhFonts->afhFonts[REMOTEFONT.rfLocalHandle]
                                                .Details.nfFaceName));

                //
                // Check the pitch...
                //
                if( (LOCALDETS.nfFontFlags & NF_FIXED_PITCH)!=
                                   (REMOTEFONT.rfFontFlags & NF_FIXED_PITCH) )
                {
                    TRACE_OUT(( "Different Pitch %x %x",
                                LOCALDETS.nfFontFlags,
                                REMOTEFONT.rfFontFlags));
                    continue;
                }

                //
                //
                // If both systems support the font CodePage capability
                // (indicated by the remote capability flags - which are
                // the union of remote and local by now), check that the
                // CodePages and CodePage flags match, and if not,
                // restrict ourselves to sending the ASCII subset.
                //
                // If we support the font CodePage capability but  remote
                // system does not, then restrict ourselves to sending the
                // ASCII subset.
                //
                // If we do not support the font CodePage capability, then
                // we assume that the remote is only sending ANSI CodePage,
                // either because it doesn't know about the font CodePage
                // capability or because it can see that we don't support
                // it.  Therefore, we do not need to check the CodePage.
                // BUT: restrict ourselves to ASCII only.
                //
                //
                if (!(m_pasLocal->cpcCaps.orders.capsfFonts & CAPS_FONT_CODEPAGE))
                {
                    //
                    // We do not support codepage checking.
                    //
                    TRACE_OUT(( "not checking CP"));
                    fOnlyAscii = TRUE;
                }

                if ((m_oeCombinedOrderCaps.capsfFonts & CAPS_FONT_CODEPAGE)
                    && (LOCALDETS.nfCodePage != REMOTEFONT.rfCodePage)  )
                {
                    TRACE_OUT(( "Different CPs %hu %hu",
                                LOCALDETS.nfCodePage,
                                REMOTEFONT.rfCodePage));
                    //
                    //
                    // Assume that all codepages include ASCII.
                    //
                    //
                    fOnlyAscii = TRUE;
                }

                //
                //
                // If we support codepage, but the remote does not then
                // the remote will only be sending us ANSI chars. Make sure
                // that we send only ASCII subset.
                //
                //
                if ((m_pasLocal->cpcCaps.orders.capsfFonts & CAPS_FONT_CODEPAGE)  &&
                    !(m_oeCombinedOrderCaps.capsfFonts & CAPS_FONT_CODEPAGE))
                {
                    TRACE_OUT(( "Only ASCII"));
                    fOnlyAscii = TRUE;
                }

                //
                //
                // The face names and CodePages match and the fonts are of
                // the same type of pitch (ie both are fixed pitch or both
                // are variable pitch).
                //
                //
                if ((REMOTEFONT.rfFontFlags & NF_FIXED_SIZE) == 0)
                {
                    //
                    //
                    // The remote font is scalable, so we can send any font
                    // (with this facename) to the remote system, even if
                    // the local font is fixed sized. Set sendSupportCode
                    // to FH_SC_EXACT_MATCH now - we will change this to
                    // FH_SC_APPROX_MATCH later if other fields differ.
                    //
                    //
                    TRACE_OUT((
                  "Person [%d] Can SEND: remote SCALABLE %s (remote)%u to (local)%u",
                           pasPerson->mcsID,
                           LOCALDETS.nfFaceName,
                           iRemote, iLocal));
                    sendSupportCode = FH_SC_EXACT_MATCH;

                    //
                    //
                    // SFR5396: it is true that we can SEND this font
                    // because the remote version of the font is scalable.
                    // That does not mean that we can necessarily receive
                    // the font... unless ours is scalable too.
                    //
                    //
                    if ((LOCALDETS.nfFontFlags & NF_FIXED_SIZE)==0)
                    {
                        TRACE_OUT((
                               "Person [%d] Can RECEIVE remote font %u as local %u",
                               pasPerson->mcsID, iRemote, iLocal));
                        REMOTEFONT.rfLocalHandle = (TSHR_UINT16)iLocal;
                    }
                }
                else if (LOCALDETS.nfFontFlags & NF_FIXED_SIZE)
                {
                    //
                    //
                    // The remote font is fixed size and so is the local
                    // one, so check if the sizes match exactly.
                    //
                    //
                    if ((LOCALDETS.nfAveWidth == REMOTEFONT.rfAveWidth) &&
                        (LOCALDETS.nfAveHeight == REMOTEFONT.rfAveHeight))
                    {
                        //
                        //
                        // Our fixed size local font is the same as the
                        // fixed size font at the remote.  We set
                        // sendSupportCode to FH_SC_EXACT_MATCH now - we
                        // will change this to FH_SC_APPROX_MATCH later if
                        // other fields differ.
                        //
                        //
                        TRACE_OUT(("Person [%d] Matched remote fixed font %s %u to %u",
                               pasPerson->mcsID,
                               LOCALDETS.nfFaceName,
                               iRemote, iLocal));
                        sendSupportCode = FH_SC_EXACT_MATCH;
                        REMOTEFONT.rfLocalHandle = (TSHR_UINT16)iLocal;
                    }
                    else
                    {
                        TRACE_OUT(( "rejected %s ave width/heights "
                                      "local/remote width %d/%d height %d/%d",
                                   LOCALDETS.nfFaceName,
                                   LOCALDETS.nfAveWidth,
                                                  REMOTEFONT.rfAveWidth,
                                   LOCALDETS.nfAveHeight,
                                                  REMOTEFONT.rfAveHeight));
                    }
                }
                else
                {
                    TRACE_OUT((
                   "Can only RECEIVE %s %u Remote is fixed, but local %u not",
                             LOCALDETS.nfFaceName,
                             iRemote,
                             iLocal));
                    //
                    //
                    // SFR5396: while we cannot SEND this font because our
                    // local version is scalable, but the remote's is
                    // fixed - we can still receive the font in an order.
                    //
                    //
                    REMOTEFONT.rfLocalHandle = (TSHR_UINT16)iLocal;
                }

                //
                //
                // If we have have set the send support code to indicate
                // that we have matched we now consider any R1.1 info if it
                // is present.  As a result of this we may adjust the send
                // support code (from indicating an exact match) to
                // indicate either an approximate match or no match at all.
                //
                //
                if (!pasPerson->oecFonts)
                {
                    //
                    //
                    // The remote system did not send us any R11 font
                    // info. In this case we assume all font matches are
                    // approximate and restrict ourselves to the ascii
                    // subset.
                    //
                    //
                    if (sendSupportCode != FH_SC_NO_MATCH)
                    {
                        TRACE_OUT(( "No R11 so approx match only"));
                        sendSupportCode = FH_SC_APPROX_ASCII_MATCH;
                    }
                }
                else if (sendSupportCode != FH_SC_NO_MATCH)
                {
                    //
                    //
                    // The remote system did send us R11 font info and
                    // the font is flagged as matching.
                    //
                    //

                    if ((m_oeCombinedOrderCaps.capsfFonts
                                            & CAPS_FONT_R20_SIGNATURE)!=0)
                    {
                        //
                        //
                        // Check the signatures.
                        //
                        //
                        TRACE_OUT((
 "Person [%d] local %d (remote %d) signatures (x%.4hx%.2hx%.2hx v x%.4hx%.2hx%.2hx)",
                               pasPerson->mcsID,
                               iLocal,
                               iRemote,
                               LOCALDETS.nfSigSymbol,
                               (TSHR_UINT16)(LOCALDETS.nfSigThins),
                               (TSHR_UINT16)(LOCALDETS.nfSigFats),
                               REMOTEFONT.rfSigSymbol,
                               (TSHR_UINT16)(REMOTEFONT.rfSigThins),
                               (TSHR_UINT16)(REMOTEFONT.rfSigFats)));

                        if ((LOCALDETS.nfSigFats != REMOTEFONT.rfSigFats) ||
                            (LOCALDETS.nfSigThins != REMOTEFONT.rfSigThins) ||
                            (LOCALDETS.nfSigSymbol != REMOTEFONT.rfSigSymbol) ||
                            (REMOTEFONT.rfSigSymbol == NF_NO_SIGNATURE))
                        {
                            //
                            // Decide what to do from the signatures.
                            //
                            if (REMOTEFONT.rfSigSymbol == NF_NO_SIGNATURE)
                            {
                                TRACE_OUT(("NO match: remote no signature"));
                                sendSupportCode = FH_SC_APPROX_ASCII_MATCH;
                            }
                            else if ((LOCALDETS.nfSigFats == REMOTEFONT.rfSigFats)
                                  && (LOCALDETS.nfSigThins == REMOTEFONT.rfSigThins))
                            {
                                TRACE_OUT(( "our ASCII sigs match"));
                                sendSupportCode = FH_SC_EXACT_ASCII_MATCH;
                            }
                            else
                            {
                                //
                                // NOTE:
                                // We could use the "closeness" of the fat
                                // and thin signatures to help us decide
                                // whether to use approximate matching or
                                // not.  But currently we don't.
                                //
                                TRACE_OUT(( "Sig mismatch: APPROX_ASC"));
                                sendSupportCode = FH_SC_APPROX_ASCII_MATCH;
                            }
                        }
                        else
                        {
                            //
                            //
                            // All signatures match exactly.
                            // Leave SendSupportCode as FH_SC_EXACT_MATCH
                            //
                            //
                            TRACE_OUT(("EXACT MATCH: Signatures match exactly"));
                        }
                    }
                    else
                    {
                        //
                        // Not using signatures.  Do we care?
                        //
                        sendSupportCode = FH_SC_APPROX_MATCH;
                        TRACE_OUT(( "APPROX MATCH: no sigs"));
                    }

                    //
                    //
                    // Check the aspect ratio - but only if we do not
                    // already know that this font does not match.
                    //
                    //
                    if ( (sendSupportCode!=FH_SC_NO_MATCH) &&
                         ( (!(m_oeCombinedOrderCaps.capsfFonts
                                                          & CAPS_FONT_ASPECT))
                           || (LOCALDETS.nfAspectX != REMOTEFONT.rfAspectX)
                           || (LOCALDETS.nfAspectY != REMOTEFONT.rfAspectY) ))
                    {
                        //
                        //
                        // Either no aspect ratio was supplied or the
                        // aspect ratio differed.
                        //
                        //
                        if (sendSupportCode == FH_SC_EXACT_MATCH)
                        {
                            //
                            // Force delta-X text orders for mismatched
                            // aspect ratio.  Note we tested above to
                            // see whether supportCode == EXACT because if
                            // we have already "downgraded" support then
                            // we do not need to change it here
                            //
                            sendSupportCode = FH_SC_APPROX_MATCH;
                            TRACE_OUT(( "AR mismatch: APPROX_MATCH"));
                        }
                        else if (sendSupportCode == FH_SC_EXACT_ASCII_MATCH)
                        {
                            //
                            // Same again but for ASCII only.
                            //
                            sendSupportCode = FH_SC_APPROX_ASCII_MATCH;
                            TRACE_OUT(( "AR mismatch: APPROX_ASCII_MATCH"));
                        }
                    }
                }

                if (sendSupportCode != FH_SC_NO_MATCH)
                {
                    //
                    //
                    // Is this a better match than any we have seen
                    // before?
                    //
                    //
                    switch (sendSupportCode)
                    {
                        case FH_SC_EXACT_MATCH:
                        case FH_SC_APPROX_MATCH:
                            //
                            //
                            // Note that we do not have to worry about
                            // overwriting a bestSupportSoFar of EXACT
                            // with APPROX because we leave the loop when
                            // we get an exact match.
                            //
                            //
                            bestSupportSoFar = sendSupportCode;
                            break;

                        case FH_SC_EXACT_ASCII_MATCH:
                            //
                            //
                            // An approximate match over the whole 255
                            // code points is better than an exact one
                            // over just the ascii-s.  Debatable, but that
                            // is what I have decided.
                            //
                            //
                            if (bestSupportSoFar != FH_SC_APPROX_MATCH)
                            {
                                bestSupportSoFar = FH_SC_EXACT_ASCII_MATCH;
                            }
                            break;

                        case FH_SC_APPROX_ASCII_MATCH:
                            //
                            //
                            // An approximate match over just the ascii-s
                            // is better than nothing at all!
                            //
                            //
                            if (bestSupportSoFar == FH_SC_NO_MATCH)
                            {
                                bestSupportSoFar = FH_SC_APPROX_ASCII_MATCH;
                            }
                            break;

                        default:
                            ERROR_OUT(("invalid support code"));
                            break;

                    }
                }
            }

            sendSupportCode = bestSupportSoFar;

            //
            // If we matched the remote font, we have already updated
            // its local handle to
            // the matched local font.  While the local handle was already
            // set up, it was only set up to the first local font with the
            // same facename, rather than the correct font.
            //
            // If we did not match the remote font, mark it as not
            // supported, and decrement the common font count.
            //
            if (sendSupportCode != FH_SC_NO_MATCH)
            {
                TRACE_OUT(( "Local font %d/%s can be SENT (code=%u)",
                            iLocal,
                            LOCALDETS.nfFaceName,
                            sendSupportCode));
                if (fOnlyAscii)
                {
                    if (sendSupportCode == FH_SC_EXACT_MATCH)
                    {
                        sendSupportCode = FH_SC_EXACT_ASCII_MATCH;
                        TRACE_OUT(( "Adjust %d/%s to EXACT_ASC (code=%u)",
                                    iLocal,
                                    LOCALDETS.nfFaceName,
                                    sendSupportCode));
                    }
                    else
                    {
                        TRACE_OUT(( "Adjust %d/%s to APPROX_ASC (code=%u)",
                                    iLocal,
                                    LOCALDETS.nfFaceName,
                                    sendSupportCode));
                        sendSupportCode = FH_SC_APPROX_ASCII_MATCH;
                    }
                }
            }
            else
            {
                TRACE_OUT(( "Local font %d/%s cannot be SENT",
                            iLocal,LOCALDETS.nfFaceName));
                cCanSend--;
            }

            LOCALFT.SupportCode &= sendSupportCode;
        }
        else
        {
            TRACE_OUT(( "Cannot SEND %d/%s",iLocal,LOCALDETS.nfFaceName));
        }
    }

    //
    //
    // SFR5396: LOOP TWO
    //
    // Loop through all the remote fonts, looking for ones where we have
    // a locally matching font.  These are fonts that we can RECEIVE in
    // orders, and for which we need to map the remote font handle to the
    // local font handle.  This means setting REMOTEFONT.rfLocalHandle.
    //
    // By the time we reach here, REMOTEFONT.rfLocalHandle is already set
    // to:
    // -    NO_FONT_MATCH (in FH_ProcessRemoteFonts)
    // or   the index in the local table of a definite match found in LOOP1
    // or   the index of the first entry in the local table with the
    //      same face name as the remote font (set in FH_ProcessRemoteFonts)
    //
    // so - we can begin our search in the local table from
    // REMOTEFONT.rfLocalHandle.
    //
    //
    for (iRemote = 0;
         (iRemote < pasPerson->oecFonts);
         iRemote++)
    {
        iLocal = REMOTEFONT.rfLocalHandle;
        if (iLocal == NO_FONT_MATCH)
        {
            //
            // We have no fonts whatsoever that match this font name
            // Go round again... try the next REMOTE font.
            //
            continue;
        }

        TRACE_OUT(( "Can we receive %s?",
             g_fhFonts->afhFonts[REMOTEFONT.rfLocalHandle].Details.nfFaceName));
        for (fCanReceive = FALSE;
             (iLocal < g_fhFonts->fhNumFonts) && (!fCanReceive);
             iLocal++)
        {
            //
            // Check the face names...
            //
            if (lstrcmp(LOCALDETS.nfFaceName,
                g_fhFonts->afhFonts[REMOTEFONT.rfLocalHandle].Details.nfFaceName))
            {
                //
                // Try the next LOCAL font.
                //
                continue;
            }

            //
            // Check the pitch...
            //
            if((LOCALDETS.nfFontFlags & NF_FIXED_PITCH)!=
                                (REMOTEFONT.rfFontFlags & NF_FIXED_PITCH))
            {
                //
                // Different pitches, try the next local font.
                //
                TRACE_OUT(( "Pitch mismatch"));
                continue;
            }

            //
            //
            // The face names match and the fonts are of
            // the same type of pitch (ie both are fixed pitch or both
            // are variable pitch).
            //
            //
            if ((REMOTEFONT.rfFontFlags & NF_FIXED_SIZE) == 0)
            {
                if ((LOCALDETS.nfFontFlags & NF_FIXED_SIZE)==0)
                {
                    //
                    //
                    // The remote font is scalable.  Ours is also
                    // scalable then we can receive the font.
                    //
                    // We do not need to look at any more LOCAL fonts.
                    //
                    //
                    fCanReceive              = TRUE;
                }
            }
            else if (LOCALDETS.nfFontFlags & NF_FIXED_SIZE)
            {
                //
                //
                // The remote font is fixed size and so is the local
                // one, so check if the sizes match exactly.
                //
                //
                if ((LOCALDETS.nfAveWidth == REMOTEFONT.rfAveWidth) &&
                    (LOCALDETS.nfAveHeight == REMOTEFONT.rfAveHeight))
                {
                    //
                    //
                    // Our fixed size local font is the same as the
                    // fixed size font at the remote.
                    //
                    // We do not need to look at any more LOCAL fonts.
                    //
                    //
                    fCanReceive              = TRUE;
                }
                else
                {
                    TRACE_OUT(( "different fixed sizes"));
                }
            }
            else
            {
                //
                //
                // The remote is FIXED but the LOCAL is scalable.  We
                // can receive orders for text of this type (but not send)
                //
                // We do not need to look at any more LOCAL fonts.
                //
                //
                fCanReceive              = TRUE;
            }

            if (fCanReceive)
            {
               TRACE_OUT(("Person [%d] Can RECEIVE remote font %s %u as %u",
                      pasPerson->mcsID,
                      LOCALDETS.nfFaceName,
                      iRemote, iLocal));
                REMOTEFONT.rfLocalHandle = (TSHR_UINT16)iLocal;
                cCanReceive++;
            }
        }

    }

    TRACE_OUT(("Person [%d] Can SEND %d fonts", pasPerson->mcsID, cCanSend));
    TRACE_OUT(("Person [%d] Can RECEIVE %d fonts", pasPerson->mcsID, cCanReceive));

    DebugExitDWORD(ASShare::FHConsiderRemoteFonts, cCanSend);
    return(cCanSend);
}

//
// FHMaybeEnableText
//
// Enables or disables sending of text orders
//
void  ASShare::FHMaybeEnableText(void)
{
    BOOL            fEnableText = FALSE;
    ASPerson *      pasPerson;

    DebugEntry(ASShare::FHMaybeEnableText);

    //
    // To enable sending text orders we must have sent out our own packet
    // of fonts, and there must be no outstanding remote packets required.
    //
    if (m_fhLocalInfoSent)
    {
        //
        // Assume we can enable text orders.
        //
        fEnableText = TRUE;

        //
        // The local info was sent, so check remote dudes (not us)
        //
        ValidatePerson(m_pasLocal);
        for (pasPerson = m_pasLocal->pasNext; pasPerson != NULL; pasPerson = pasPerson->pasNext)
        {
            ValidatePerson(pasPerson);

            if (!pasPerson->oecFonts)
            {
                //
                // We have found a font packet that we have not yet
                // received, so must disable sending text, and can break
                // out of the search.
                //
                TRACE_OUT(( "No font packet yet from person [%d]", pasPerson->mcsID));
                fEnableText = FALSE;
                break;
            }
        }
    }
    else
    {
        TRACE_OUT(( "Local font info not yet sent"));
    }

    OE_EnableText(fEnableText);

    if (g_asCanHost)
    {
        //
        // Pass on new font data to the other tasks.
        //
        if (fEnableText)
        {
            OE_NEW_FONTS newFontData;

            //
            // Copy the data from the Share Core.
            //
            newFontData.fontCaps    = m_oeCombinedOrderCaps.capsfFonts;
            newFontData.countFonts  = (WORD)g_fhFonts->fhNumFonts;
            newFontData.fontData    = g_fhFonts->afhFonts;
            newFontData.fontIndex   = g_fhFonts->afhFontIndex;

            TRACE_OUT(( "Sending %d Fonts", g_fhFonts->fhNumFonts));

            //
            // Notify display driver of new fonts
            //
            OSI_FunctionRequest(OE_ESC_NEW_FONTS,
                                (LPOSI_ESCAPE_HEADER)&newFontData,
                                sizeof(newFontData));
        }
    }

    DebugExitVOID(ASShare::FHMaybeEnableText);
}

//
// FHGetLocalFontHandle
//
// Translate a remote font handle/local ID pair to a local font handle.
//
UINT  ASShare::FHGetLocalFontHandle
(
    UINT        remotefont,
    ASPerson *  pasPerson
)
{
    DebugEntry(ASShare::FHGetLocalFontHandle);

    ValidatePerson(pasPerson);

    if (!pasPerson->oecFonts)
    {
        WARNING_OUT(("Order packet from [%d] but no fonts", pasPerson->mcsID));
    }

    if (remotefont == DUMMY_FONT_ID)
    {
        //
        // The dummy font ID has been supplied for the remote font Id.
        // Substitute the first valid local font Id.
        //
        for (remotefont = 0;
             remotefont < pasPerson->oecFonts;
             remotefont++)
        {
            if (pasPerson->poeFontInfo[remotefont].rfLocalHandle !=
                                                                NO_FONT_MATCH)
            {
                break;
            }
        }
    }

    if (remotefont >= pasPerson->oecFonts)
    {
        //
        // The remote font is invalid.
        // There is no error value, we simply return the valid but
        // incorrect value 0.
        //
        TRACE_OUT(("Person [%d] Invalid font handle %u",
                 pasPerson->mcsID, remotefont));
        return(0);
    }

    DebugExitVOID(ASShare::FHGetLocalFontHandle);
    return(pasPerson->poeFontInfo[remotefont].rfLocalHandle);
}


//
//
// FUNCTION: FHCalculateSignatures
//
// DESCRIPTION:
//
// Given a width table, calculates the three font signatures that are
// included in the R2.0 NETWORKFONT structure.
//
// PARAMETERS:
//
//  pTable - pointer to width table
//  pSigFats, pSigThins, pSigSymbol - return the three signatures
//
// RETURNS:
//
//  None
//
//
void  FHCalculateSignatures(PFHWIDTHTABLE  pTable,
                                                LPTSHR_INT16       pSigFats,
                                                LPTSHR_INT16       pSigThins,
                                                LPTSHR_INT16       pSigSymbol)
{
    UINT    charI      = 0;
    UINT  fatSig     = 0;
    UINT  thinSig    = 0;
    UINT  symbolSig  = 0;

    DebugEntry(FHCalculateSignatures);

    ASSERT((pTable != NULL));
    ASSERT((pSigFats != NULL));
    ASSERT((pSigThins != NULL));
    ASSERT((pSigSymbol != NULL));

    //
    //  nfSigFats   the sum of the widths (in pels) of the chars
    //              0-9,@-Z,$,%,&. divided by two: the fat chars
    //  nfSigThins  the sum of the widths (in pels) of the chars
    //              0x20->0x7F EXCLUDING those summed in nfSigFats.
    //              Again - divided by two.  The thin chars.
    //  nfSigSymbol The sum of the widths (in pels) of the chars
    //              x80->xFF.
    //

    //
    // Loop for 0-9, some punctuation, A-Z. Then add $,% and &. i.e. mainly
    // fat characters.
    //
    for (charI= NF_ASCII_ZERO; charI<NF_ASCII_Z ; charI++ )
    {
        fatSig += pTable->charWidths[charI];
    }
    fatSig += pTable->charWidths[NF_ASCII_DOLLAR] +
        pTable->charWidths[NF_ASCII_PERCENT] +
        pTable->charWidths[NF_ASCII_AMPERSAND];

    //
    // thin sig covers the rest of the "ascii" characters (x20->7F) not
    // already included in fatSig.
    //
    for (charI= NF_ASCII_FIRST; charI<NF_ASCII_LAST ; charI++ )
    {
        thinSig += pTable->charWidths[charI];
    }
    thinSig -= fatSig;

    //
    // symbolSig covers the "non-ascii" characters (x0->1F, 80->FF)
    //
    for (charI= 0x00; charI<(NF_ASCII_FIRST-1) ; charI++ )
    {
        symbolSig += pTable->charWidths[charI];
    }
    for (charI= NF_ASCII_LAST+1; charI<0xFF ; charI++ )
    {
        symbolSig += pTable->charWidths[charI];
    }
    TRACE_OUT(( "Signatures: symbol %#lx thin %#lx fat %#lx",
             symbolSig, thinSig, fatSig));

    //
    // Halve the fat and thin sigs so that they fit into one byte each.
    //
    fatSig    /= 2;
    thinSig   /= 2;
    if ( (((TSHR_UINT16)symbolSig)==0)
         && (((BYTE)fatSig)==0) && (((BYTE)thinSig)==0))
    {
        //
        // Worry about the faint possibility that all three sums could add
        // up to a value of zero when truncated.
        //
        symbolSig=1;
    }

    //
    // Fill in return pointers.
    //
    *pSigFats   = (TSHR_INT16)fatSig;
    *pSigThins  = (TSHR_INT16)thinSig;
    *pSigSymbol = (TSHR_INT16)symbolSig;

    DebugExitVOID(FHCalculateSignatures);
}



//
// FHEachFontFamily
//
// This callback is called for each font family. We use it to build up a
// list of all the family names.
//
//
// Although wingdi.h defines the first two parameters for an ENUMFONTPROC
// as LOGFONT and TEXTMETRIC (thereby disagreeing with MSDN), tests show
// that the structures are actually as defined in MSDN (i.e.  we get valid
// information when accessing the extended fields)
//
int CALLBACK  FHEachFontFamily
(
    const ENUMLOGFONT   FAR * enumlogFont,
    const NEWTEXTMETRIC FAR * TextMetric,
    int                       FontType,
    LPARAM                    lParam
)
{
    LPFHFAMILIES                  lpFamilies = (LPFHFAMILIES)lParam;

    DebugEntry(FHEachFontFamily);

    ASSERT(!IsBadWritePtr(lpFamilies, sizeof(*lpFamilies)));

    if (lpFamilies->fhcFamilies == FH_MAX_FONTS)
    {
        //
        // We cannot support any more font families so stop enumerating.
        //
        WARNING_OUT(( "Can only handle %u families", FH_MAX_FONTS));
        return(FALSE); // Stop the enumeration
    }

    TRACE_OUT(("FHEachFontFamily:  %s", enumlogFont->elfLogFont.lfFaceName));

    ASSERT(lstrlen(enumlogFont->elfLogFont.lfFaceName) < FH_FACESIZE);
    lstrcpy(lpFamilies->afhFamilies[lpFamilies->fhcFamilies].szFontName,
              enumlogFont->elfLogFont.lfFaceName);

    lpFamilies->fhcFamilies++;

    DebugExitBOOL(FHEachFontFamily, TRUE);
    return(TRUE); // Continue enumerating
}

//
// FHEachFont
//
// This callback is called for each font.  It gathers and stores the font
// details.
//
//
//
// Although wingdi.h defines the first two parameters for an ENUMFONTPROC
// as LOGFONT and TEXTMETRIC (thereby disagreeing with MSDN), tests show
// that the structures are actually as defined in MSDN (i.e.  we get valid
// information when accessing the extended fields)
//
int CALLBACK  FHEachFont(const ENUMLOGFONT   FAR * enumlogFont,
                                      const NEWTEXTMETRIC FAR * TextMetric,
                                      int                       FontType,
                                      LPARAM                    lParam)
{
    HDC             hdc       = (HDC)lParam;
    TSHR_UINT16        fontflags = 0;
    TSHR_UINT16        CodePage  = 0;
    HFONT           hfont;
    HFONT           holdfont  = NULL;
    TEXTMETRIC      tm;
    BOOL            fAcceptFont;
    int             rc;

    DebugEntry(FHEachFont);

    TRACE_OUT(( "Family name: %s", enumlogFont->elfLogFont.lfFaceName));
    TRACE_OUT(( "Full name: %s", enumlogFont->elfFullName));

    if (g_fhFonts->fhNumFonts >= FH_MAX_FONTS)
    {
        //
        // We cannot support any more fonts so stop enumerating.
        //
        WARNING_OUT(( "Can only handle %u fonts", FH_MAX_FONTS));
        rc = 0;
        DC_QUIT; // Stop the enumeration
    }

    //
    // We want to continue...
    //
    rc = 1;

    //
    // Don't bother with this if it's a bold/italic variant.
    //
    // NOTE:
    // The elfFullName field is only valid for TrueType fonts on Win95.  For
    // non TrueType fonts, assume that the full name and face name are the
    // same.
    //
    if (!g_asWin95 || (FontType & TRUETYPE_FONTTYPE))
    {
        if (lstrcmp(enumlogFont->elfLogFont.lfFaceName, (LPCSTR)enumlogFont->elfFullName))
        {
            TRACE_OUT(( "Discarding variant: %s", enumlogFont->elfFullName));
            DC_QUIT;                   // Jump out, but don't stop enumerating!
        }
    }

    //
    // We now accumulate information on all local fonts in all CodePages.
    // This relies on the subsequent sending of local fonts and matching of
    // remote fonts taking into account the CodePage capabilities of the
    // systems.
    //

    //
    // On this pass we copy the details into our structure.
    //
    if (FontType & TRUETYPE_FONTTYPE)
    {
        //
        // This is a truetype font, which we simply accept without double
        // checking its metrics.  (Metric double checking to exclude
        // duplicates is of most relevance to fixed size fonts, which are
        // explicitly optimised for one screen size)
        //
        fAcceptFont = TRUE;

        //
        // Indicate TrueType (this will go in the NETWORKFONT structure
        // (i.e.  over the wire)
        //
        fontflags |= NF_TRUE_TYPE;

        //
        // Signal that we did not call CreateFont for this font.
        //
        hfont = NULL;
    }
    else
    {
        //
        // We create a font from the logical description, and select it so
        // that we can query its metrics.
        //
        // The point of this is that it allows us to identify fonts where
        // the logical font description is not a unique description of this
        // font, and hence if we cannot get to this font via a logical font
        // description, we cannot get to it at all.
        //
        // If we cannot get to it, then we cannot claim to support it.
        //
        // This selection operation is SLOW - of the order of a couple of
        // seconds in some extreme cases (for example where the font is
        // stored on a network drive, and pageing has to take place) and
        // when you can have hundreds of fonts this can add up to a
        // considerable time.
        //
        // Hence we only do the selection for non truetype fonts because
        // these are the fonts where it is easy to get multiple fonts of
        // the same logical description, though designed for different
        // display drivers.
        //

        //
        // Create a font from the logical font, so we can see what font
        // Windows actually choses.
        //
        hfont    = CreateFontIndirect(&enumlogFont->elfLogFont);
        holdfont = SelectFont(hdc, hfont);

        //
        // Find the metrics of the font that Windows has actually selected.
        //
        GetTextMetrics(hdc, &tm);

        //
        // Double check the aspect ratios - enumerate returns all fonts,
        // but it is possible to have fonts that are never matched by
        // Windows due to duplications.
        //
        fAcceptFont = ((tm.tmDigitizedAspectX == TextMetric->tmDigitizedAspectX)
                   &&  (tm.tmDigitizedAspectY == TextMetric->tmDigitizedAspectY));
    }

    //
    // Trace out the full text metrics for debugging.
    //

    if (fAcceptFont)
    {
        //
        // This font is accepted.
        //
        //
        // Determine the font flags settings.
        //
        if ((TextMetric->tmPitchAndFamily & TMPF_FIXED_PITCH) == 0)
        {
            //
            // Setting the TMPF_FIXED_PITCH bit in the text metrics is used
            // to indicate that the font is NOT fixed pitch.  What a
            // wonderfully named bit (see Microsoft CD for explanation).
            //
            fontflags |= NF_FIXED_PITCH;
        }

        if ((FontType & RASTER_FONTTYPE)         ||
            (FontType & TRUETYPE_FONTTYPE) == 0)
        {
            //
            // This is a raster font, but not a truetype font so it must be
            // of fixed size.
            //
            fontflags |= NF_FIXED_SIZE;
        }

        //
        // Get the font CodePage.  SFRFONT: must map from CharSet to
        // Codepage.  For now we only support ANSI and OEM charsets.  This
        // will need to change to support e.g BiDi/Arabic
        //
        CodePage = TextMetric->tmCharSet;
        if (CodePage == ANSI_CHARSET)
        {
            TRACE_OUT(( "ANSI codepage"));
            CodePage = NF_CP_WIN_ANSI;
        }
        else if (CodePage == OEM_CHARSET)
        {
            TRACE_OUT(( "OEM codepage"));
            CodePage = NF_CP_WIN_OEM;
        }
        else if (CodePage == SYMBOL_CHARSET)
        {
            TRACE_OUT(("Symbol codepage"));
            CodePage = NF_CP_WIN_SYMBOL;
        }
        else
        {
            TRACE_OUT(( "Charset %hu, unknown codepage", CodePage));
            CodePage = NF_CP_UNKNOWN;
        }


        //
        //
        // SFRFONT: We have replaced the "old" checksum which was based on
        // the actual bits making up the font to one based on the widths of
        // characters in the font.  The intention is that we use this to
        // ensure that the actual characters in the local font and in the
        // remote font which matches it are all the same width as each
        // other.
        //
        // We calculate this sum for all fonts (not just non-truetype as
        // before) because in cross platform calls with approximate font
        // matching it applies to fonts of all types.
        //
        //

        //
        //
        // There is considerable confusion caused by the terminology for
        // fonts characteristics.  The protocol uses two values MAXHEIGHT
        // and AVEHEIGHT.  In fact neither of these names is accurate
        // (MAXHEIGHT is not the maximum height of a char; and AVEHEIGHT is
        // not the average height of all chars).
        //
        // SFRFONT: we have added maxAscent to the protocol.  This is the
        // height of a capital letter (such as eM!) PLUS any internal
        // leading.  This value allows remote boxes to find the baseline -
        // the point at which the bottommost pel of a letter with no
        // descenders (e.g.  capital M) is to be drawn.  This is needed
        // because not all boxes in the call follow the windows convention
        // of specifying the start of text as being the top-left corner of
        // the first character cell.  maxAscent == tmAscent in the
        // TextMetric.
        //
        //
        FHAddFontToLocalTable((LPSTR)enumlogFont->elfLogFont.lfFaceName,
                              (TSHR_UINT16)fontflags,
                              (TSHR_UINT16)CodePage,
                              (TSHR_UINT16)TextMetric->tmHeight,
                              (TSHR_UINT16)(TextMetric->tmHeight -
                                           TextMetric->tmInternalLeading),
                              (TSHR_UINT16)TextMetric->tmAveCharWidth,
                              (TSHR_UINT16)TextMetric->tmDigitizedAspectX,
                              (TSHR_UINT16)TextMetric->tmDigitizedAspectY,
                              (TSHR_UINT16)TextMetric->tmAscent);
    }
    else
    {
        //
        // Windows returns a different font when we use this logical font
        // description - presumably because of duplicate fonts.  We
        // therfore must not claim to support this particular font.
        //
        TRACE_OUT(( "Discarding hidden font %s",
                 enumlogFont->elfLogFont.lfFaceName));
    }

    if (hfont)
    {
        //
        // We called CreateFont in processing this font, so now delete it
        // to clean up.
        //
        SelectFont(hdc, holdfont);

        //
        // We have finished with the font so delete it.
        //
        DeleteFont(hfont);
    }

DC_EXIT_POINT:
    DebugExitDWORD(FHEachFont, rc);
    return(rc);
}


//
// FHConsiderAllLocalFonts
//
// Considers the details of each of the fonts on the local system, and if
// acceptable adds them to the local font list.
//
//
void  FHConsiderAllLocalFonts(void)
{
    HDC             hdcDesktop;
    UINT            i;
    LPFONTNAME      newFontList;
    LPFHFAMILIES    lpFamilies = NULL;

    DebugEntry(FHConsiderAllLocalFonts);

    g_fhFonts->fhNumFonts       = 0;

    //
    // We can't enumerate all the fonts directly; we have to enumerate the
    // family names, then the fonts within each family.
    //
    // This alloc assumes the worst case memory-wise (i.e.  each
    // family contains a single font) and therefore we will usually
    // allocate more memory than we need.  We use LocalReAlloc later to fix
    // this.
    //
    lpFamilies = new FHFAMILIES;
    if (!lpFamilies)
    {
        ERROR_OUT(("Failed to alloc FHFAMILIES"));
        DC_QUIT;
    }

    SET_STAMP(lpFamilies, FHFAMILIES);

    hdcDesktop = GetWindowDC(HWND_DESKTOP);

    //
    // Find all the font family names.
    //
    lpFamilies->fhcFamilies = 0;
    EnumFontFamilies(hdcDesktop, NULL,(FONTENUMPROC)FHEachFontFamily,
                           (LPARAM)lpFamilies);

    TRACE_OUT(("Found %d font families ", lpFamilies->fhcFamilies));

    //
    // Now enumerate each font for each family
    //
    for (i = 0; i < lpFamilies->fhcFamilies; i++)
    {
        EnumFontFamilies(hdcDesktop, lpFamilies->afhFamilies[i].szFontName,
                               (FONTENUMPROC)FHEachFont,
                               (LPARAM)hdcDesktop);
    }

    ReleaseDC(HWND_DESKTOP, hdcDesktop);

DC_EXIT_POINT:
    //
    // Having considered all the fonts, we can now free the list of family
    // names.
    //
    if (lpFamilies)
    {
        delete lpFamilies;
    }

    DebugExitVOID(FHConsiderAllLocalFonts);
}

//
// FHGenerateFontWidthTable
//
BOOL  FHGenerateFontWidthTable(PFHWIDTHTABLE pTable,
                                                   LPLOCALFONT    pFontInfo,
                                                   UINT        fontHeight,
                                                   UINT        fontWidth,
                                                   UINT        fontWeight,
                                                   UINT        fontFlags,
                                                   LPTSHR_UINT16     pMaxAscent)

{
    HFONT     hNewFont;
    HFONT     hOldFont;
    BOOL        gdiRC;
    UINT        i;
    HDC         cachedDC;
    BOOL        localRC;
    BOOL        functionRC;
    TEXTMETRIC  textmetrics;
    int         width;
    UINT        aFontSizes[256];

    DebugEntry(FHGenerateFontWidthTable);

    //
    // Set the return value to FALSE (unsuccessful).  We will set it to
    // TRUE later if the function succeeds.
    //
    functionRC = FALSE;

    //
    // Set the old font handle to NULL.  If this is not NULL at the exit
    // point of this function then we will select it back into the cachedDC
    // device context.
    //
    hOldFont = NULL;

    //
    // Set the new font handle to NULL.  If this is not NULL at the exit
    // point of this function then the new font will be deleted.
    //
    hNewFont = NULL;

    //
    // Get a cached DC with which to do the query.
    //
    cachedDC = GetDC(HWND_DESKTOP);
    if (cachedDC == NULL)
    {
        WARNING_OUT(( "Failed to get DC"));
        DC_QUIT;
    }

    //
    // Get all the info we need from the local font table.
    //

    localRC = FH_CreateAndSelectFont(cachedDC,
                                    &hNewFont,
                                    &hOldFont,
                                    pFontInfo->RealName,
                                    pFontInfo->Details.nfCodePage,
                                    pFontInfo->lMaxBaselineExt,
                                    fontHeight,
                                    fontWidth,
                                    fontWeight,
                                    fontFlags);

    if (localRC == FALSE)
    {
        ERROR_OUT(( "Failed to create/select font %s, %u, %u",
                   pFontInfo->RealName,
                   fontHeight,
                   fontWidth));
        DC_QUIT;
    }

    //
    // Determine if the current font is a truetype font.
    //
    GetTextMetrics(cachedDC, &textmetrics);

    if (textmetrics.tmPitchAndFamily & TMPF_TRUETYPE)
    {
        //
        // Truetype fonts are ABC spaced.
        //
        ABC     abc[256];

        TRACE_OUT(("TrueType font %s, first char %d last char %d",
            pFontInfo->RealName, (UINT)(WORD)textmetrics.tmFirstChar,
            (UINT)(WORD)textmetrics.tmLastChar));

        //
        // Get all widths in one call - faster than getting them separately
        //
        GetCharABCWidths(cachedDC, 0, 255, abc);

        for (i = 0; i < 256; i++)
        {
            width = abc[i].abcA + abc[i].abcB + abc[i].abcC;

            if ((width < 0) || (width > 255))
            {
                //
                // Width is outside the range we can cope with, so quit.
                //
                TRACE_OUT(( "Width %d is outside range", width));
                DC_QUIT;
            }
            pTable->charWidths[i] = (BYTE)width;
        }

    }
    else
    {
        TRACE_OUT(( "Non-truetype font"));

        //
        // Check if the font is fixed or variable pitch - note that a clear
        // bit indicates FIXED, not the reverse which you might expect!
        //
        if ((textmetrics.tmPitchAndFamily & TMPF_FIXED_PITCH) == 0)
        {
            //
            // No need to call GetCharWidth for a fixed width font (and
            // more to the point it can return us bad values if we do)
            //
            for (i = 0; i < 256; i++)
            {
                aFontSizes[i] = textmetrics.tmAveCharWidth;
            }
        }
        else
        {
            //
            // Query the width of each character in the font.
            //
            ZeroMemory(aFontSizes, sizeof(aFontSizes));
            gdiRC = GetCharWidth(cachedDC,
                                 0,
                                 255,
                                 (LPINT)aFontSizes);
            if (gdiRC == FALSE)
            {
                ERROR_OUT(( "Failed to get char widths for %s, %u, %u",
                            pFontInfo->RealName,
                            fontHeight,
                            fontWidth));
                DC_QUIT;
            }
        }

        //
        // Now copy the widths into the width table.
        // We must adjust the widths to take account of any overhang
        // between characters.
        //
        for (i = 0; i < 256; i++)
        {
            width = aFontSizes[i] - textmetrics.tmOverhang;
            if ((width < 0) || (width > 255))
            {
                TRACE_OUT(( "Width %d is outside range", width));
                DC_QUIT;
            }
            pTable->charWidths[i] = (BYTE)width;
        }
    }

    //
    // The font table has been successfully generated.
    //
    functionRC = TRUE;

    TRACE_OUT(( "Generated font table for: %s", pFontInfo->RealName));

    //
    // Return the maxAscent value, as we have easy access to it here.  This
    // saves us having to create the font again later to find it.
    //
    TRACE_OUT(( "Updating maxAscent %hu -> %hu",
                 *pMaxAscent,
                 (TSHR_UINT16)textmetrics.tmAscent));
    *pMaxAscent = (TSHR_UINT16)textmetrics.tmAscent;

DC_EXIT_POINT:

    if (hOldFont != NULL)
    {
        SelectFont(cachedDC, hOldFont);
    }

    if (hNewFont != NULL)
    {
        DeleteFont(hNewFont);
    }

    if (cachedDC != NULL)
    {
        ReleaseDC(HWND_DESKTOP, cachedDC);
    }

    DebugExitDWORD(FHGenerateFontWidthTable, functionRC);
    return(functionRC);
}

//
// Define a macro to simplify the following code.  This returns the first
// character in the name of the font at position i in the local table.
//

//
// nfFaceName is an array of CHARs, which are SIGNED.  We need to treat them
// as UNSIGNED values, they are indeces from 0 to 255 into the font hash
// table.
//
#define LF_FIRSTCHAR(i)  (BYTE)g_fhFonts->afhFonts[i].Details.nfFaceName[0]

//
// Name:    FHSortAndIndexLocalFonts
//
// Purpose: Sorts local font table by font name and generates an index for
//          quicker searching in the display driver.
//
// Returns: None.
//
// Params:  None.
//
//
void FHSortAndIndexLocalFonts(void)
{
    TSHR_UINT16    thisIndexEntry;
    TSHR_UINT16    fontTablePos;

    DebugEntry(FHSortAndIndexLocalFonts);

    //
    // Check there are actually some fonts to sort/index
    //
    if (0 == g_fhFonts->fhNumFonts)
    {
        WARNING_OUT(( "No fonts to sort/index"));
        DC_QUIT;
    }

    //
    // Use qsort to do the sort.  We sort on the font name, ascending.
    // Therefore we must use STRCMP and not lstrcmp.  The latter sorts
    // by 'word' method, where upper case sorts before lower case.  But
    // our NT driver has no access to a similar routine.  And this code +
    // driver code must be in ssync for the driver to successfully search
    // the sorted font table.
    //

    FH_qsort(g_fhFonts->afhFonts, g_fhFonts->fhNumFonts, sizeof(LOCALFONT));
    TRACE_OUT(( "Sorted local font list"));

    //
    // Now generate the index.  Each element i in the g_fhFonts->afhFontIndex
    // array must indicate the first entry in the local font table
    // beginning with character i.  If there are no fonts beginning with
    // character i, then the element is set to USHRT_MAX (i.e.  a large
    // value).
    //

    //
    // First clear the index table to unused entries.
    //
    for (thisIndexEntry = 0;
         thisIndexEntry < FH_LOCAL_INDEX_SIZE;
         thisIndexEntry++)
    {
        g_fhFonts->afhFontIndex[thisIndexEntry] = USHRT_MAX;
    }

    //
    // Now fill in the useful information.
    //
    // This for loop steps through the index array, using the first
    // character of the first font in the local table as its start point.
    // Since the font table is alphabetically sorted, this will correspond
    // to the first index entry that needs filling in.
    //
    // The terminating condition for this loop may seem a little odd, but
    // works because fontTablePos will always reach a value of g_fhFonts->fhNumFonts
    // before thisIndexEntry gets to the last index element.
    //
    fontTablePos = 0;

    for (thisIndexEntry = LF_FIRSTCHAR(0);
         fontTablePos < g_fhFonts->fhNumFonts;
         thisIndexEntry++)
    {
        //
        // Don't do anything until we get to the index element
        // corresponding to the first character in the font pointed to by
        // fontTablePos.  (We'll be there straight away on the first pass)
        //
        if (thisIndexEntry == LF_FIRSTCHAR(fontTablePos))
        {
            //
            // We've found the first font table entry starting with
            // character thisIndexEntry, so enter it in the index.
            //
            g_fhFonts->afhFontIndex[thisIndexEntry] = fontTablePos;

            //
            // Now zip past the rest of the local font table entries that
            // start with this character, also checking that we haven't got
            // to the end of the font table.
            //
            // If the latter happens, it means we've finished and the check
            // in the for statement will ensure that we exit the loop.
            //
            while ((LF_FIRSTCHAR(fontTablePos) == thisIndexEntry) &&
                   (fontTablePos < g_fhFonts->fhNumFonts))
            {
                fontTablePos++;
            }
        }
    }

    TRACE_OUT(( "Built local font table index"));

DC_EXIT_POINT:
    DebugExitVOID(FHSortAndIndexLocalFonts);
}




//
// FHComp()
// This is a wrapper around strcmp(), which becomes an inline function in
// retail.  It also handles the casting of the LPVOIDs.
//
//
// Compare item 1, item 2
//
int FHComp
(
    LPVOID lpFont1,
    LPVOID lpFont2
)
{
    return(strcmp(((LPLOCALFONT)lpFont1)->Details.nfFaceName,
                   ((LPLOCALFONT)lpFont2)->Details.nfFaceName));
}


//
// FH_qsort(base, num, wid) - quicksort function for sorting arrays
//
// Purpose:
//       quicksort the array of elements
//       side effects:  sorts in place
//
// Entry:
//      char *base = pointer to base of array
//      unsigned num  = number of elements in the array
//      unsigned width = width in bytes of each array element
//
// Exit:
//       returns void
//
// Exceptions:
//




// sort the array between lo and hi (inclusive)

void FH_qsort
(
    LPVOID      base,
    UINT        num,
    UINT        width
)
{
    LPSTR       lo;
    LPSTR       hi;
    LPSTR       mid;
    LPSTR       loguy;
    LPSTR       higuy;
    UINT        size;
    char *lostk[30], *histk[30];
    int stkptr;                 // stack for saving sub-array to be processed

    // Note: the number of stack entries required is no more than
    // 1 + log2(size), so 30 is sufficient for any array

    ASSERT(width);
    if (num < 2)
        return;                 // nothing to do

    stkptr = 0;                 // initialize stack

    lo = (LPSTR)base;
    hi = (LPSTR)base + width * (num-1);        // initialize limits

    // this entry point is for pseudo-recursion calling: setting
    // lo and hi and jumping to here is like recursion, but stkptr is
    // prserved, locals aren't, so we preserve stuff on the stack
recurse:

    size = (UINT)(hi - lo) / width + 1;        // number of el's to sort

    // below a certain size, it is faster to use a O(n^2) sorting method
    if (size <= CUTOFF)
    {
         shortsort(lo, hi, width);
    }
    else
    {
        // First we pick a partititioning element.  The efficiency of the
        // algorithm demands that we find one that is approximately the
        // median of the values, but also that we select one fast.  Using
        // the first one produces bad performace if the array is already
        // sorted, so we use the middle one, which would require a very
        // weirdly arranged array for worst case performance.  Testing shows
        // that a median-of-three algorithm does not, in general, increase
        // performance.

        mid = lo + (size / 2) * width;      // find middle element
        swap(mid, lo, width);               // swap it to beginning of array

        // We now wish to partition the array into three pieces, one
        // consisiting of elements <= partition element, one of elements
        // equal to the parition element, and one of element >= to it.  This
        // is done below; comments indicate conditions established at every
        // step.

        loguy = lo;
        higuy = hi + width;

        // Note that higuy decreases and loguy increases on every iteration,
        // so loop must terminate.
        for (;;) {
            // lo <= loguy < hi, lo < higuy <= hi + 1,
            // A[i] <= A[lo] for lo <= i <= loguy,
            // A[i] >= A[lo] for higuy <= i <= hi

            do
            {
                loguy += width;
            }
            while ((loguy <= hi) && (FHComp(loguy, lo) <= 0));

            // lo < loguy <= hi+1, A[i] <= A[lo] for lo <= i < loguy,
            // either loguy > hi or A[loguy] > A[lo]

            do
            {
                higuy -= width;
            }
            while ((higuy > lo) && (FHComp(higuy, lo) >= 0));

            // lo-1 <= higuy <= hi, A[i] >= A[lo] for higuy < i <= hi,
            // either higuy <= lo or A[higuy] < A[lo]

            if (higuy < loguy)
                break;

            // if loguy > hi or higuy <= lo, then we would have exited, so
            // A[loguy] > A[lo], A[higuy] < A[lo],
            // loguy < hi, highy > lo

            swap(loguy, higuy, width);

            // A[loguy] < A[lo], A[higuy] > A[lo]; so condition at top
            // of loop is re-established
        }

        //     A[i] >= A[lo] for higuy < i <= hi,
        //     A[i] <= A[lo] for lo <= i < loguy,
        //     higuy < loguy, lo <= higuy <= hi
        // implying:
        //     A[i] >= A[lo] for loguy <= i <= hi,
        //     A[i] <= A[lo] for lo <= i <= higuy,
        //     A[i] = A[lo] for higuy < i < loguy

        swap(lo, higuy, width);     // put partition element in place

        // OK, now we have the following:
        //    A[i] >= A[higuy] for loguy <= i <= hi,
        //    A[i] <= A[higuy] for lo <= i < higuy
        //    A[i] = A[lo] for higuy <= i < loguy

        // We've finished the partition, now we want to sort the subarrays
        // [lo, higuy-1] and [loguy, hi].
        // We do the smaller one first to minimize stack usage.
        // We only sort arrays of length 2 or more.

        if ( higuy - 1 - lo >= hi - loguy ) {
            if (lo + width < higuy) {
                lostk[stkptr] = lo;
                histk[stkptr] = higuy - width;
                ++stkptr;
            }                           // save big recursion for later

            if (loguy < hi) {
                lo = loguy;
                goto recurse;           // do small recursion
            }
        }
        else {
            if (loguy < hi) {
                lostk[stkptr] = loguy;
                histk[stkptr] = hi;
                ++stkptr;               // save big recursion for later
            }

            if (lo + width < higuy) {
                hi = higuy - width;
                goto recurse;           // do small recursion
            }
        }
    }

    // We have sorted the array, except for any pending sorts on the stack.
    // Check if there are any, and do them.

    --stkptr;
    if (stkptr >= 0) {
        lo = lostk[stkptr];
        hi = histk[stkptr];
        goto recurse;           // pop subarray from stack
    }
    else
        return;                 // all subarrays done
}


//
// shortsort(hi, lo, width) - insertion sort for sorting short arrays
//
// Purpose:
//       sorts the sub-array of elements between lo and hi (inclusive)
//       side effects:  sorts in place
//       assumes that lo < hi
//
// Entry:
//      char *lo = pointer to low element to sort
//      char *hi = pointer to high element to sort
//      unsigned width = width in bytes of each array element
//
// Exit:
//       returns void
//
// Exceptions:
//

void shortsort
(
    char *lo,
    char *hi,
    unsigned int width
)
{
    char *p, *max;

    // Note: in assertions below, i and j are alway inside original bound of
    // array to sort.

    while (hi > lo) {
        // A[i] <= A[j] for i <= j, j > hi
        max = lo;
        for (p = lo+width; p <= hi; p += width) {
            // A[i] <= A[max] for lo <= i < p
            if (FHComp(p, max) > 0)
            {
                max = p;
            }
            // A[i] <= A[max] for lo <= i <= p
        }

        // A[i] <= A[max] for lo <= i <= hi

        swap(max, hi, width);

        // A[i] <= A[hi] for i <= hi, so A[i] <= A[j] for i <= j, j >= hi

        hi -= width;

        // A[i] <= A[j] for i <= j, j > hi, loop top condition established
    }
    // A[i] <= A[j] for i <= j, j > lo, which implies A[i] <= A[j] for i < j,
    // so array is sorted
}


//
// swap(a, b, width) - swap two elements
//
// Purpose:
//     swaps the two array elements of size width
//
// Entry:
//       char *a, *b = pointer to two elements to swap
//       unsigned width = width in bytes of each array element
//
// Exit:
//       returns void
//
// Exceptions:
//

 void swap (
    char *a,
    char *b,
    unsigned int width
    )
{
    char tmp;

    if ( a != b )
        // Do the swap one character at a time to avoid potential alignment
        // problems.
        while ( width-- ) {
            tmp = *a;
            *a++ = *b;
            *b++ = tmp;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\cm.cpp ===
#include "precomp.h"


//
// CM.CPP
// Cursor Manager
//
// Copyright(c) Microsoft 1997-
//
#define MLZ_FILE_ZONE  ZONE_CORE




//
// CM_ShareStarting()
// Creates resources used by the share
//
BOOL ASShare::CM_ShareStarting(void)
{
    BOOL        rc = FALSE;
    HBITMAP     hbmpT;
    ICONINFO    cursorInfo;
    char        szTmp[MAX_CURSOR_TAG_FONT_NAME_LENGTH];

    DebugEntry(ASShare::CM_ShareStarting);

    //
    // Create the hatching brush we will use to make shadow cursors
    // distinguishable from real cursors.
    //
    hbmpT = LoadBitmap(g_asInstance, MAKEINTRESOURCE(IDB_HATCH32X32) );
    m_cmHatchBrush = CreatePatternBrush(hbmpT);
    DeleteBitmap(hbmpT);

    if (!m_cmHatchBrush)
    {
        ERROR_OUT(("CM_ShareStarting: Failed to created hatched brush"));
        DC_QUIT;
    }

    m_cmArrowCursor = LoadCursor(NULL, IDC_ARROW);
    if (!m_cmArrowCursor)
    {
        ERROR_OUT(("CM_ShareStarting: Failed to load cursors"));
        DC_QUIT;
    }

    // Get the arrow hotspot
    GetIconInfo(m_cmArrowCursor, &cursorInfo);
    m_cmArrowCursorHotSpot.x = cursorInfo.xHotspot;
    m_cmArrowCursorHotSpot.y = cursorInfo.yHotspot;

    DeleteBitmap(cursorInfo.hbmMask);
    if (cursorInfo.hbmColor)
        DeleteBitmap(cursorInfo.hbmColor);

    //
    // Get the size of the cursor on this system. (Cursor bitmaps are word
    // padded 1bpp).
    //
    m_cmCursorWidth  = GetSystemMetrics(SM_CXCURSOR);
    m_cmCursorHeight = GetSystemMetrics(SM_CYCURSOR);

    //
    // Load the name of the font which will be used for creating cursor
    // tags.  It makes sense to have this in a resource, so it can be
    // localized.
    //
    LoadString(g_asInstance, IDS_FONT_CURSORTAG, szTmp, sizeof(szTmp));
    m_cmCursorTagFont = CreateFont(CURSOR_TAG_FONT_HEIGHT, 0, 0, 0, FW_NORMAL,
                             FALSE, FALSE, FALSE, DEFAULT_CHARSET,
                             OUT_TT_PRECIS, CLIP_DEFAULT_PRECIS,
                             DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE,
                             szTmp);
    if (!m_cmCursorTagFont)
    {
        ERROR_OUT(("CM_ShareStarting: couldn't create cursor tag font"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::CM_ShareStarting, rc);
    return(rc);
}



//
// CM_ShareEnded()
// Frees resources used by the share
//
void ASShare::CM_ShareEnded(void)
{
    DebugEntry(ASShare::CM_ShareEnded);

    //
    // Free cursor tag font
    //
    if (m_cmCursorTagFont != NULL)
    {
        DeleteFont(m_cmCursorTagFont);
        m_cmCursorTagFont = NULL;
    }

    //
    // Free shadow cursor dither brush
    //
    if (m_cmHatchBrush != NULL)
    {
        DeleteBrush(m_cmHatchBrush);
        m_cmHatchBrush = NULL;
    }

    DebugExitVOID(ASShare::CM_ShareEnded);
}


//
// CM_PartyJoiningShare()
//
BOOL ASShare::CM_PartyJoiningShare(ASPerson * pasPerson)
{
    BOOL          rc = FALSE;

    DebugEntry(ASShare::CM_PartyJoiningShare);

    ValidatePerson(pasPerson);

    pasPerson->cmhRemoteCursor  = m_cmArrowCursor;
    pasPerson->cmHotSpot        = m_cmArrowCursorHotSpot;

    ASSERT(pasPerson->cmPos.x == 0);
    ASSERT(pasPerson->cmPos.y == 0);

    rc = TRUE;

    DebugExitBOOL(ASShare::CM_PartyJoiningShare, rc);
    return(rc);

}


//
// CM_PartyLeftShare()
//
// See cm.h for description.
//
void ASShare::CM_PartyLeftShare(ASPerson * pasPerson)
{
    DebugEntry(ASShare::CM_PartyLeftShare);

    ValidatePerson(pasPerson);

    ASSERT(!pasPerson->ccmRxCache);
    ASSERT(!pasPerson->acmRxCache);

    DebugExitVOID(ASShare::CM_PartyLeftShare);
}


//
// CM_HostStarting()
//
// Called when we start to host.  Creates the outgoing cursor cache
//
BOOL ASHost::CM_HostStarting(void)
{
    BOOL    rc = FALSE;

    DebugEntry(ASHost::CM_HostStarting);

    //
    // Calculate actual size of cache we will use -- if 3.0 share, it's
    // what we advertise in our caps, but if 2.x share, it's <= to that
    // amount, being the min of everybody in the share.
    //
    // We however create the cache the size we want, knowing that in a 2.x
    // share we'll use some subset of it.  That's cool.
    //
    m_pShare->CM_RecalcCaps(TRUE);

    if (!CH_CreateCache(&m_cmTxCacheHandle, TSHR_CM_CACHE_ENTRIES,
            1, 0, NULL))
    {
        ERROR_OUT(("Could not create CM cache"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::CM_HostStarting, rc);
    return(rc);
}


//
// CM_HostEnded()
//
// Called when we stop hosting, so we can free cursor data
//
void ASHost::CM_HostEnded(void)
{
    DebugEntry(ASHost::CM_HostEnded);

    //
    // Destroy the outgoing cursor cache
    //
    if (m_cmTxCacheHandle)
    {
        CH_DestroyCache(m_cmTxCacheHandle);
        m_cmTxCacheHandle = 0;
        m_cmNumTxCacheEntries = 0;
    }

    DebugExitVOID(ASHost::CM_HostEnded);
}



//
// CM_ViewStarting()
//
// Called when somebody we're viewing starts to host.  We create
// the incoming cursor cache (well, we create it if they are 3.0; 2.x
// nodes populated it even when not hosting).
//
BOOL ASShare::CM_ViewStarting(ASPerson * pasPerson)
{
    BOOL    rc = FALSE;

    DebugEntry(ASShare::CM_ViewStarting);

    ValidatePerson(pasPerson);

    if (!CMCreateIncoming(pasPerson))
    {
        ERROR_OUT(("CM_ViewStarting:  can't create cursor cache for [%d]",
                pasPerson->mcsID));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::CM_ViewStarting, rc);
    return(rc);
}



//
// CM_ViewEnded()
//
// Called when somebody we are viewing has stopped hosting.  We free up
// cursor data needed to handle what they send us (well, for 3.0 dudes we
// do; for 2.x dudes we keep it as long as they are in a share).
//
void ASShare::CM_ViewEnded(ASPerson * pasPerson)
{
    DebugEntry(ASShare::CM_ViewEnded);

    ValidatePerson(pasPerson);

    // Free cursor cache
    CMFreeIncoming(pasPerson);

    DebugExitVOID(ASShare::CM_ViewEnded);
}



//
// CMCreateIncoming()
// Creates cursor cache for person.
// If 3.0 node, we create it when they start to host
// If 2.x node, we create it when they join the share
//
BOOL ASShare::CMCreateIncoming(ASPerson * pasPerson)
{
    BOOL rc = FALSE;

    DebugEntry(ASShare::CMCreateIncoming);

    if (!pasPerson->cpcCaps.cursor.capsCursorCacheSize)
    {
        //
        // This person has no cursor cache; don't create one.
        //
        WARNING_OUT(("CMCreateIncoming: person [%d] has no cursor cache size", pasPerson->mcsID));
        rc = TRUE;
        DC_QUIT;
    }

    pasPerson->ccmRxCache = pasPerson->cpcCaps.cursor.capsCursorCacheSize;
    pasPerson->acmRxCache = new CACHEDCURSOR[pasPerson->ccmRxCache];
    if (!pasPerson->acmRxCache)
    {
        ERROR_OUT(("CMCreateIncoming: can't create cursor cache for node [%d]", pasPerson->mcsID));
        DC_QUIT;
    }

    ZeroMemory(pasPerson->acmRxCache, sizeof(CACHEDCURSOR) * pasPerson->ccmRxCache);

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::CMCreateIncoming, rc);
    return(rc);
}



//
// CMFreeIncoming()
// Frees cursor cache for person.
// If 3.0 node, we free it when they stop hosting
// If 2.x node, we free it when they leave the share
//
void ASShare::CMFreeIncoming(ASPerson * pasPerson)
{
    UINT            irx;
    POINT           cursorPos;
    HWND            hwnd;
    HCURSOR         hCurCursor;

    DebugEntry(ASShare::CMFreeIncoming);

    hCurCursor = ::GetCursor();

    if (pasPerson->acmRxCache)
    {
        for (irx = 0; irx < pasPerson->ccmRxCache; irx++)
        {
            if (pasPerson->acmRxCache[irx].hCursor != NULL)
            {
                if (pasPerson->acmRxCache[irx].hCursor == hCurCursor)
                {
                    //
                    // We're about to destroy the current cursor.  Reset it.
                    // Note that this can only happen when there's an active
                    // frame for this host.  And that frame must be about
                    // to go away, in which case USER will jiggle the cursor
                    // anyway.  So we don't need to do more than this.
                    //
                    ::SetCursor(m_cmArrowCursor);
                }

                if (pasPerson->acmRxCache[irx].hCursor == pasPerson->cmhRemoteCursor)
                {
                    pasPerson->cmhRemoteCursor = NULL;
                }

                ::DestroyCursor(pasPerson->acmRxCache[irx].hCursor);
                pasPerson->acmRxCache[irx].hCursor = NULL;
            }
        }

        pasPerson->ccmRxCache = 0;

        delete[] pasPerson->acmRxCache;
        pasPerson->acmRxCache = NULL;

    }

    DebugExitVOID(ASShare::CMFreeIncoming);
}



//
// CM_Periodic()
//
void  ASHost::CM_Periodic(void)
{
    HWND    hwnd;

    DebugEntry(ASHost::CM_Periodic);

    CM_MaybeSendCursorMovedPacket();

    //
    // Find out which window is currently controlling the cursor
    // appearance.
    //
    hwnd = CMGetControllingWindow();
    if (hwnd)
    {
        UINT    cursorType;
        CURSORDESCRIPTION desiredCursor;
        UINT    idDelta;

        //
        // Send a cursor shape update for the controlling window if necessary
        //
        if (m_pShare->HET_WindowIsHosted(hwnd))
            cursorType = CM_CT_DISPLAYEDCURSOR;
        else
            cursorType = CM_CT_DEFAULTCURSOR;

        switch (cursorType)
        {
            case CM_CT_DEFAULTCURSOR:
                if ((m_cmLastCursorShape.type == CM_CD_SYSTEMCURSOR) &&
                    (m_cmLastCursorShape.id == CM_IDC_ARROW) )
                {
                    //
                    // No change.
                    //
                    DC_QUIT;
                }
                desiredCursor.type = CM_CD_SYSTEMCURSOR;
                desiredCursor.id = CM_IDC_ARROW;
                break;

            case CM_CT_DISPLAYEDCURSOR:
                CMGetCurrentCursor(&desiredCursor);

                if (desiredCursor.type == m_cmLastCursorShape.type)
                {
                    switch (desiredCursor.type)
                    {
                        case CM_CD_SYSTEMCURSOR:
                            if (desiredCursor.id == m_cmLastCursorShape.id)
                            {
                                //
                                // Same cursor as last time.
                                //
                                DC_QUIT;
                            }
                            break;

                        case CM_CD_BITMAPCURSOR:
                            //
                            // If the cursor has already been used, ignore it.
                            // Check if stamp is less than or equal to the last
                            // one - assume any sufficiently large difference
                            // is due to overflow.
                            //
                            idDelta = (UINT)
                                (desiredCursor.id - m_cmLastCursorShape.id);

                            if (((idDelta == 0) || (idDelta > 0x10000000)) &&
                                ((g_asSharedMemory->cmCursorHidden != FALSE) == (m_cmfCursorHidden != FALSE)))
                            {
                                TRACE_OUT(( "No change in cursor"));
                                DC_QUIT;
                            }
                            break;

                        default:
                            ERROR_OUT(("Invalid cursor definition"));
                            break;
                   }
                }
                break;

            default:
                ERROR_OUT(("cursorType invalid"));
                DC_QUIT;
        }

        if (desiredCursor.type == CM_CD_SYSTEMCURSOR)
        {
            if (!CMSendSystemCursor(desiredCursor.id))
            {
                //
                // We failed to send the system cursor, so we just exit without
                // updating m_cmLastCursorShape.  We will attempt to send it again
                // on the next call to CM_Periodic.
                //
                DC_QUIT;
            }

            m_cmLastCursorShape.type = desiredCursor.type;
            m_cmLastCursorShape.id = desiredCursor.id;
        }
        else
        {
            //
            // Save the 'hidden' state.
            //
            m_cmfCursorHidden = (g_asSharedMemory->cmCursorHidden != FALSE);

            if (!CMSendBitmapCursor())
            {
                //
                // We failed to send the bitmap cursor, so we just exit without
                // updating m_cmLastCursorShape.  We will attempt to send it again
                // on the next call to CM_Periodic.
                //
                DC_QUIT;
            }

            m_cmLastCursorShape.type = desiredCursor.type;
            m_cmLastCursorShape.id = desiredCursor.id;
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASHost::CM_Periodic);
}



//
// CM_SyncOutgoing()
// Forces a send of the current cursor shape/pos when we start to host or
// somebody new joins the conference
//
void ASHost::CM_SyncOutgoing(void)
{
    DebugEntry(ASHost::CM_SyncOutgoing);

    //
    // Mark the last cursor as unknown.  On next timer tick we'll send the
    // current one.
    //
    m_cmLastCursorShape.type = CM_CD_UNKNOWN;
    m_cmLastCursorPos.x = -1;
    m_cmLastCursorPos.y = -1;

    //
    // Clear the cursor cache.
    //
    if (m_cmTxCacheHandle != 0)
    {
        CH_ClearCache(m_cmTxCacheHandle);
    }

    DebugExitVOID(ASHost::CM_SyncOutgoing);
}





//
// CM_DrawShadowCursor(..)
//
void  ASShare::CM_DrawShadowCursor(ASPerson * pasHost, HDC hdc)
{
    HBRUSH      hbrOld;
    HDC         hdcMem;
    HBITMAP     hbmp;
    HBITMAP     hbmpOld;
    HPALETTE    hpalScreen = NULL;
    HPALETTE    hpalOldDIB = NULL;
    POINT       ptFrame;

    DebugEntry(ASShare::CM_DrawShadowCursor);

    ValidateView(pasHost);

    //
    // Draw the shadow cursor if there is one.
    //
    if (pasHost->cmShadowOff || !pasHost->cmhRemoteCursor)
    {
        TRACE_OUT(("CM_DrawShadowCursor: no cursor to draw"));
        DC_QUIT;
    }

    //
    // The cursor position is always kept in the host's screen coordinates.
    // When we paint our view frame, we adjust the DC so that painting
    // in host coordinates works right, even though the view frame may
    // be scrolled over.
    //
    ptFrame.x = pasHost->cmPos.x - pasHost->cmHotSpot.x - pasHost->m_pView->m_viewPos.x;
    ptFrame.y = pasHost->cmPos.y - pasHost->cmHotSpot.y - pasHost->m_pView->m_viewPos.y;

    //
    // We draw a greyed cursor using the following steps.
    // - copy the destination window rectangle to a memory bitmap.
    // - draw the cursor into the memory bitmap
    //
    // [the memory bitmap now contains the window background + a non-greyed
    // cursor]
    //
    // - blt the window bitmap back to the memory using a 3-way ROP and a
    //   hatched pattern bitmap.  The ROP is chosen such that the 0s and 1s
    //   in the pattern bitmap select either a bitmap pel or a destination
    //   pel for the final result.  The pattern bitmap is such that most
    //   of the bitmap pels are copied, but a few destination pels are
    //   left unchanged, giving a greying effect.
    //
    // - copy the resulting bitmap back into the window.
    //
    // The last two steps are done so that the cursor does not appear to
    // change shape as it is moved.  If the 3 way blt is done back to the
    // screen at stage 3, the pattern stays relative to the screen coords
    // and hence as the cursor moves, it will lose different pels each
    // time and appear to deform.
    //
    // The ROP is calculated to copy the source pel where the pattern is 1
    // and to leave the destination pel unchanged where the pattern is 0:
    //
    //   P  S  D     R
    //
    //   0  0  0     0
    //   0  0  1     1
    //   0  1  0     0
    //   0  1  1     1
    //   1  0  0     0
    //   1  0  1     0
    //   1  1  0     1
    //   1  1  1     1
    //
    //               ^
    //               Read upwards -> 0xCA
    //
    // From the table in the SDK, this gives a full ROP value of 0x00CA0749
    //
    //
    #define GREY_ROP 0x00CA0749

    if (NULL == (hdcMem = CreateCompatibleDC(hdc)))
    {
        WARNING_OUT(( "Failed to create memory DC"));
        DC_QUIT;
    }

    if (NULL == (hbmp = CreateCompatibleBitmap(hdc, CM_MAX_CURSOR_WIDTH, CM_MAX_CURSOR_HEIGHT)))
    {
        WARNING_OUT(( "Failed to create bitmap"));
        DeleteDC(hdcMem);
        DC_QUIT;
    }

    if (NULL == (hbmpOld = SelectBitmap(hdcMem, hbmp)))
    {
        WARNING_OUT(( "Failed to select bitmap"));
        DeleteBitmap(hbmp);
        DeleteDC(hdcMem);
        DC_QUIT;
    }

    hbrOld = SelectBrush(hdcMem, m_cmHatchBrush);

    //
    //
    // We need to make sure that we have the same logical palette selected
    // into both DCs otherwise we will corrupt the background color info
    // when we do the blitting.
    //
    //
    hpalScreen = SelectPalette(hdc,
        (HPALETTE)GetStockObject(DEFAULT_PALETTE),
                               FALSE );
    SelectPalette( hdc, hpalScreen, FALSE );
    hpalOldDIB = SelectPalette( hdcMem, hpalScreen, FALSE );
    RealizePalette(hdcMem);

    BitBlt( hdcMem,
            0,
            0,
            CM_MAX_CURSOR_WIDTH,
            CM_MAX_CURSOR_HEIGHT,
            hdc,
            ptFrame.x,
            ptFrame.y,
            SRCCOPY );

    DrawIcon(hdcMem, 0, 0, pasHost->cmhRemoteCursor);
    CMDrawCursorTag(pasHost, hdcMem);

    BitBlt( hdcMem,
            0,
            0,
            CM_MAX_CURSOR_WIDTH,
            CM_MAX_CURSOR_HEIGHT,
            hdc,
            ptFrame.x,
            ptFrame.y,
            GREY_ROP );

    BitBlt( hdc,
            ptFrame.x,
            ptFrame.y,
            CM_MAX_CURSOR_WIDTH,
            CM_MAX_CURSOR_HEIGHT,
            hdcMem,
            0,
            0,
            SRCCOPY );

    SelectBrush(hdcMem, hbrOld);

    SelectBitmap(hdcMem, hbmpOld);
    DeleteBitmap(hbmp);

    if (hpalOldDIB != NULL)
    {
        SelectPalette(hdcMem, hpalOldDIB, FALSE);
    }

    DeleteDC(hdcMem);


DC_EXIT_POINT:
    DebugExitVOID(ASShare::CM_DrawShadowCursor);
}



//
// CM_ReceivedPacket(..)
//
void  ASShare::CM_ReceivedPacket
(
    ASPerson *      pasPerson,
    PS20DATAPACKET  pPacket
)
{
    PCMPACKETHEADER pCMPacket;

    DebugEntry(ASShare::CM_ReceivedPacket);

    ValidatePerson(pasPerson);

    pCMPacket = (PCMPACKETHEADER)pPacket;

    //
    // Switch on the packet type
    //
    switch (pCMPacket->type)
    {
        case CM_CURSOR_ID:
        case CM_CURSOR_MONO_BITMAP:
        case CM_CURSOR_COLOR_BITMAP:
        case CM_CURSOR_COLOR_CACHE:
            CMReceivedCursorShapePacket(pasPerson, pCMPacket);
            break;

        case CM_CURSOR_MOVE:
            CMReceivedCursorMovedPacket(pasPerson, pCMPacket);
            break;

        default:
            ERROR_OUT(("Invalid CM data packet from [%d] of type %d",
                pasPerson->mcsID, pCMPacket->type));
            break;
    }

    DebugExitVOID(ASShare::CM_ReceivedPacket);
}



//
// CM_ApplicationMovedCursor(..)
//
void  ASHost::CM_ApplicationMovedCursor(void)
{
    DebugEntry(ASHost::CM_ApplicationMovedCursor);

    WARNING_OUT(("CM host:  cursor moved by app, tell viewers"));
    m_cmfSyncPos = TRUE;
    CM_MaybeSendCursorMovedPacket();

    DebugExitVOID(ASHost::CM_ApplicationMovedCursor);
}



//
// CM_RecalcCaps()
//
// This calculates the CM hosting caps when
//      * we start to host
//      * we're hosting and somebody joins the share
//      * we're hosting and somebody leaves the share
//
// This can GO AWAY WHEN 2.x COMPAT IS GONE -- no more min() of cache size
//
void ASShare::CM_RecalcCaps(BOOL fJoiner)
{
    ASPerson * pasT;

    DebugEntry(ASShare::CM_RecalcCaps);

    if (!m_pHost || !fJoiner)
    {
        //
        // Nothing to do if we're not hosting.  And also, if somebody has
        // left, no recalculation -- 2.x didn't.
        //
        DC_QUIT;
    }

    ValidatePerson(m_pasLocal);

    m_pHost->m_cmNumTxCacheEntries        = m_pasLocal->cpcCaps.cursor.capsCursorCacheSize;
    m_pHost->m_cmfUseColorCursorProtocol  =
        (m_pasLocal->cpcCaps.cursor.capsSupportsColorCursors == CAPS_SUPPORTED);


DC_EXIT_POINT:
    DebugExitVOID(ASShare::CM_RecalcCaps);
}



//
// FUNCTION: CMReceivedCursorShapePacket
//
// DESCRIPTION:
//
// Processes a received cursor shape packet.
//
// PARAMETERS:
//
// personID - ID of the packet sender
//
// pCMPacket - pointer to the received cursor shape packet
//
// RETURNS: Nothing
//
//
void  ASShare::CMReceivedCursorShapePacket
(
    ASPerson *      pasPerson,
    PCMPACKETHEADER pCMPacket
)
{
    BOOL        fSetCursorToNULL = FALSE;
    HCURSOR     hNewCursor;
    HCURSOR     hOldCursor = NULL;
    POINT       newHotSpot;
    UINT        cacheID;

    DebugEntry(ASShare::CMReceivedCursorShapePacket);

    ValidatePerson(pasPerson);

    //
    // Now create or load the new cursor.
    //
    switch (pCMPacket->type)
    {
        case CM_CURSOR_ID:
            CMProcessCursorIDPacket((PCMPACKETID)pCMPacket,
                &hNewCursor, &newHotSpot);
            break;

        case CM_CURSOR_MONO_BITMAP:
        case CM_CURSOR_COLOR_BITMAP:
            if (pCMPacket->type == CM_CURSOR_MONO_BITMAP)
            {
                cacheID = CMProcessMonoCursorPacket((PCMPACKETMONOBITMAP)pCMPacket,
                    &hNewCursor, &newHotSpot);
            }
            else
            {
                cacheID = CMProcessColorCursorPacket((PCMPACKETCOLORBITMAP)pCMPacket,
                    &hNewCursor, &newHotSpot );
            }

            ASSERT(pasPerson->acmRxCache);
            ASSERT(cacheID < pasPerson->ccmRxCache);

            hOldCursor = pasPerson->acmRxCache[cacheID].hCursor;

            if (hNewCursor != NULL)
            {

                TRACE_OUT(("Cursor using cache %u", cacheID));
                pasPerson->acmRxCache[cacheID].hCursor = hNewCursor;
                pasPerson->acmRxCache[cacheID].hotSpot = newHotSpot;
            }
            else
            {
                //
                // use default cursor.
                //
                TRACE_OUT(( "color cursor failed so use arrow"));

                pasPerson->acmRxCache[cacheID].hCursor = NULL;
                pasPerson->acmRxCache[cacheID].hotSpot.x = 0;
                pasPerson->acmRxCache[cacheID].hotSpot.y = 0;

                hNewCursor = m_cmArrowCursor;
                newHotSpot = m_cmArrowCursorHotSpot;
            }
            break;

        case CM_CURSOR_COLOR_CACHE:
            cacheID = ((PCMPACKETCOLORCACHE)pCMPacket)->cacheIndex;

            ASSERT(pasPerson->acmRxCache);
            ASSERT(cacheID < pasPerson->ccmRxCache);

            //
            // If the caching failed last time then use the default arrow
            // cursor.
            //
            if (pasPerson->acmRxCache[cacheID].hCursor == NULL)
            {
                TRACE_OUT(( "cache empty so use arrow"));
                hNewCursor = m_cmArrowCursor;
                newHotSpot = m_cmArrowCursorHotSpot;
            }
            else
            {
                hNewCursor = pasPerson->acmRxCache[cacheID].hCursor;
                newHotSpot = pasPerson->acmRxCache[cacheID].hotSpot;
            }
            break;

        default:
            WARNING_OUT(( "Unknown cursor type: %u", pCMPacket->type));
            DC_QUIT;
    }

    //
    // Destroy the old cursor.  Note that for bitmap cursor packets,
    // we will set the cursor to the new image twice.
    //
    if (hOldCursor)
    {
        if (hOldCursor == ::GetCursor())
        {
            ::SetCursor(hNewCursor);
        }

        ::DestroyCursor(hOldCursor);
    }

    pasPerson->cmhRemoteCursor = hNewCursor;

    //
    // Decide what to do with the new cursor...
    //
    if (!pasPerson->cmShadowOff)
    {
        //
        // The shadow cursor is enabled so update it.  It won't change state
        // or move, it will just repaint with the new image and/or hotspot.
        //
        TRACE_OUT(("Update shadow cursor"));

        CM_UpdateShadowCursor(pasPerson, pasPerson->cmShadowOff,
            pasPerson->cmPos.x, pasPerson->cmPos.y,
            newHotSpot.x, newHotSpot.y);
    }
    else
    {
        HWND    hwnd;

        // Update the hotspot.
        pasPerson->cmHotSpot = newHotSpot;

        // Refresh if no old cursor
        ASSERT(pasPerson->m_pView);

        hwnd = CMGetControllingWindow();
        if (hwnd == pasPerson->m_pView->m_viewClient)
        {
            SendMessage(hwnd, WM_SETCURSOR, (WPARAM)hwnd, MAKELONG(HTCLIENT, 0));
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CMReceivedCursorShapePacket);
}


//
// FUNCTION: CMProcessMonoCursorPacket
//
// DESCRIPTION:
//
// Processes a received mono cursor packet.
//
// PARAMETERS:
//
// pCMPacket - pointer to the received cursor ID packet
//
// phNewCursor - pointer to a HCURSOR variable that receives the handle
// of a cursor that corresponds to the received packet
//
// pNewHotSpot - pointer to a POINT variable that receives the hot-spot
// of the new cursor
//
// RETURNS: Nothing
//
//
UINT  ASShare::CMProcessMonoCursorPacket
(
    PCMPACKETMONOBITMAP     pCMPacket,
    HCURSOR*                phNewCursor,
    LPPOINT                 pNewHotSpot
)
{
    UINT        cbReceivedMaskBytes;
    LPBYTE      pANDMask;
    LPBYTE      pXORMask;

    DebugEntry(ASShare::CMProcessMonoCursorPacket);

    //
    // Work out the size (in bytes) of the two bitmap masks we have just
    // received.  (Cursor bitmaps are 1bpp and word padded).
    //
    cbReceivedMaskBytes = pCMPacket->height * CM_BYTES_FROM_WIDTH(pCMPacket->width);

    //
    // NOTE:  Compressed cursors are an R.11 remnant.  NM 1.0 and 2.0 never
    // sent them specially compressed.  Therefore the code to handle
    // decompression should be unnecessary.  Let's find out!
    //
    ASSERT(pCMPacket->header.type == CM_CURSOR_MONO_BITMAP);

    //
    // Get the XOR and AND masks
    //
    pXORMask = pCMPacket->aBits;
    pANDMask = pXORMask + cbReceivedMaskBytes;

    //
    // Create a cursor from the definition supplied in the packet.
    //
    *phNewCursor = CMCreateMonoCursor(pCMPacket->xHotSpot,
        pCMPacket->yHotSpot, pCMPacket->width, pCMPacket->height,
        pANDMask, pXORMask);
    if (*phNewCursor == NULL)
    {
        WARNING_OUT(( "Failed to create hRemoteCursor"));
        DC_QUIT;
    }

    //
    // Return the hot spot.
    //
    pNewHotSpot->x = pCMPacket->xHotSpot;
    pNewHotSpot->y = pCMPacket->yHotSpot;

DC_EXIT_POINT:
    DebugExitDWORD(ASShare::CMProcessMonoCursorPacket, 0);
    return(0);
}


//
// FUNCTION: CMProcessColorCursorPacket
//
// DESCRIPTION:
//
// Processes a received color cursor packet.
//
// PARAMETERS:
//
// pCMPacket - pointer to the received cursor ID packet
//
// phNewCursor - pointer to a HCURSOR variable that receives the handle
// of a cursor that corresponds to the received packet
//
// pNewHotSpot - pointer to a POINT variable that receives the hot-spot
// of the new cursor
//
// RETURNS: Nothing
//
//
UINT  ASShare::CMProcessColorCursorPacket
(
    PCMPACKETCOLORBITMAP    pCMPacket,
    HCURSOR*                phNewCursor,
    LPPOINT                 pNewHotSpot
)
{
    LPBYTE          pXORBitmap;
    LPBYTE          pANDMask;

    DebugEntry(ASShare::CMProcessColorCursorPacket);

    //
    // Calculate the pointers to the XOR bitmap and the AND mask within the
    // color cursor data.
    //
    pXORBitmap = pCMPacket->aBits;
    pANDMask = pXORBitmap + pCMPacket->cbXORBitmap;

    //
    // Create a cursor from the definition supplied in the packet.
    //
    *phNewCursor = CMCreateColorCursor(pCMPacket->xHotSpot, pCMPacket->yHotSpot,
        pCMPacket->cxWidth, pCMPacket->cyHeight, pANDMask, pXORBitmap,
        pCMPacket->cbANDMask, pCMPacket->cbXORBitmap);

    if (*phNewCursor == NULL)
    {
        WARNING_OUT(( "Failed to create color cursor"));
        DC_QUIT;
    }

    //
    // Return the hot spot.
    //
    pNewHotSpot->x = pCMPacket->xHotSpot;
    pNewHotSpot->y = pCMPacket->yHotSpot;

DC_EXIT_POINT:
    DebugExitDWORD(ASShare::CMProcessColorCursorPacket, pCMPacket->cacheIndex);
    return(pCMPacket->cacheIndex);
}


//
// FUNCTION: CMReceivedCursorMovedPacket
//
// DESCRIPTION:
//
// Processes a received cursor movement packet.
//
// PARAMETERS:
//
// personID - ID of the sender of this packet
//
// pCMPacket - pointer to the received cursor movement packet
//
// RETURNS: Nothing
//
//
void  ASShare::CMReceivedCursorMovedPacket
(
    ASPerson *      pasFrom,
    PCMPACKETHEADER pCMHeader
)
{
    ASPerson *      pasControlling;
    PCMPACKETMOVE   pCMPacket = (PCMPACKETMOVE)pCMHeader;

    DebugEntry(ASShare::CMReceivedCursorMovedPacket);

    //
    // Handle an incoming cursor moved packet.
    //
    ValidatePerson(pasFrom);

    TRACE_OUT(("Received cursor move packet from [%d] to pos (%d,%d)",
        pasFrom->mcsID, pCMPacket->xPos, pCMPacket->yPos));

    CM_UpdateShadowCursor(pasFrom, pasFrom->cmShadowOff,
        pCMPacket->xPos, pCMPacket->yPos,
        pasFrom->cmHotSpot.x, pasFrom->cmHotSpot.y);

    //
    // If we're in control of this person and it's a sync, we need to
    // move our cursor too, to reflect where the app really stuck it.
    //
    if ((pasFrom->m_caControlledBy == m_pasLocal)   &&
        (pCMPacket->header.flags & CM_SYNC_CURSORPOS))
    {
        //
        // If our mouse is over this host's client area,
        // autoscroll to pos or move our cursor
        //
        WARNING_OUT(("CM SYNC pos to {%04d, %04d}", pCMPacket->xPos,
            pCMPacket->yPos));
        VIEW_SyncCursorPos(pasFrom, pCMPacket->xPos, pCMPacket->yPos);
    }

    DebugExitVOID(ASShare::CMReceivedCursorMovedPacket);
}



//
// CM_UpdateShadowCursor()
//
// This repaints the host's shadow cursor in the view frame we have for him.
// It is used when
//      * the cursor image has changed
//      * the cursor tag has changed (due to control changes)
//      * the cursor hotspot has changed
//      * the cursor state is changing between on and off
//      * the cursor has moved
//
void  ASShare::CM_UpdateShadowCursor
(
    ASPerson *  pasPerson,
    BOOL        cmShadowOff,
    int         xNewPos,
    int         yNewPos,
    int         xNewHot,
    int         yNewHot
)
{
    RECT        rcInval;

    DebugEntry(ASShare::CM_UpdateShadowCursor);

    //
    // Is the remote cursor currently on?
    //
    if (!pasPerson->cmShadowOff)
    {
        if (pasPerson->m_pView)
        {
            //
            // We need to invalidate the old rectangle where the cursor
            // was.  We need to adjust for the hotspot.  Also, adjust for
            // any scrolling we may have done in the view frame.
            //
            rcInval.left   = pasPerson->cmPos.x - pasPerson->cmHotSpot.x;
            rcInval.top    = pasPerson->cmPos.y - pasPerson->cmHotSpot.y;
            rcInval.right  = rcInval.left + m_cmCursorWidth;
            rcInval.bottom = rcInval.top + m_cmCursorHeight;

            VIEW_InvalidateRect(pasPerson, &rcInval);
        }
    }

    // Update the state, position, and hotspot
    pasPerson->cmShadowOff  = cmShadowOff;
    pasPerson->cmPos.x      = xNewPos;
    pasPerson->cmPos.y      = yNewPos;
    pasPerson->cmHotSpot.x  = xNewHot;
    pasPerson->cmHotSpot.y  = yNewHot;

    if (!pasPerson->cmShadowOff)
    {
        if (pasPerson->m_pView)
        {
            //
            // We need to invalidate the new rectangle where the cursor is
            // moving to.  Again, we need to adjust for the hotspot, and any
            // scrolling done in the view frame.
            //
            rcInval.left = pasPerson->cmPos.x - pasPerson->cmHotSpot.x;
            rcInval.top  = pasPerson->cmPos.y - pasPerson->cmHotSpot.y;
            rcInval.right = rcInval.left + m_cmCursorWidth;
            rcInval.bottom = rcInval.top + m_cmCursorHeight;

            VIEW_InvalidateRect(pasPerson, &rcInval);
        }
    }

    DebugExitVOID(ASShare::CM_UpdateShadowCursor);
}


void  ASHost::CM_MaybeSendCursorMovedPacket(void)
{

    PCMPACKETMOVE   pCMPacket;
    POINT           cursorPos;
#ifdef _DEBUG
    UINT            sentSize;
#endif

    DebugEntry(ASHost::CM_MaybeSendCursorMovedPacket);

    //
    // Get the cursor position.
    //
    GetCursorPos(&cursorPos);

    //
    // Has it changed?
    //
    if (m_cmfSyncPos ||
        (cursorPos.x != m_cmLastCursorPos.x) ||
        (cursorPos.y != m_cmLastCursorPos.y))
    {
        //
        // Try to allocate a packet.
        //
        pCMPacket = (PCMPACKETMOVE)m_pShare->SC_AllocPkt(PROT_STR_MISC, g_s20BroadcastID,
            sizeof(*pCMPacket));
        if (!pCMPacket)
        {
            WARNING_OUT(("Failed to alloc CM move packet"));
            DC_QUIT;
        }

        TRACE_OUT(("Sending cursor moved packet to pos (%d, %d)",
            cursorPos.x, cursorPos.y));

        //
        // Fill in the fields
        //
        pCMPacket->header.header.data.dataType = DT_CM;

        pCMPacket->header.type = CM_CURSOR_MOVE;
        pCMPacket->header.flags = 0;
        if (m_cmfSyncPos)
        {
            pCMPacket->header.flags |= CM_SYNC_CURSORPOS;
        }
        pCMPacket->xPos = (TSHR_UINT16)cursorPos.x;
        pCMPacket->yPos = (TSHR_UINT16)cursorPos.y;

        //
        // Compress and send the packet.
        //
        if (m_pShare->m_scfViewSelf)
            m_pShare->CM_ReceivedPacket(m_pShare->m_pasLocal, &(pCMPacket->header.header));

#ifdef _DEBUG
        sentSize =
#endif // _DEBUG
        m_pShare->DCS_CompressAndSendPacket(PROT_STR_MISC, g_s20BroadcastID,
            &(pCMPacket->header.header), sizeof(*pCMPacket));

        TRACE_OUT(("CM MOVE packet size: %08d, sent %08d", sizeof(*pCMPacket), sentSize));

        m_cmfSyncPos = FALSE;
        m_cmLastCursorPos = cursorPos;
    }

DC_EXIT_POINT:
    DebugExitVOID(ASHost::CM_MaybeSendCursorMovedPacket);
}



//
// FUNCTION: CMSendCursorShape
//
// DESCRIPTION:
//
// Sends a packet containing the given cursor shape (bitmap). If the
// same shape is located in the cache then a cached cursor packet is sent.
//
// PARAMETERS:
//
// pCursorShape - pointer to the cursor shape
//
// cbCursorDataSize - pointer to the cursor data size
//
// RETURNS: TRUE if successful, FALSE otherwise.
//
//
BOOL  ASHost::CMSendCursorShape
(
    LPCM_SHAPE      pCursorShape,
    UINT            cbCursorDataSize
)
{
    BOOL            rc = FALSE;
    BOOL            fInCache;
    LPCM_SHAPE      pCacheData;
    UINT            iCacheEntry;

    DebugEntry(ASHost::CMSendCursorShape);

    fInCache = CH_SearchCache(m_cmTxCacheHandle,
                               (LPBYTE)pCursorShape,
                               cbCursorDataSize,
                               0,
                               &iCacheEntry );
    if (!fInCache)
    {
        pCacheData = (LPCM_SHAPE)new BYTE[cbCursorDataSize];
        if (pCacheData == NULL)
        {
            WARNING_OUT(("Failed to alloc CM_SHAPE data"));
            DC_QUIT;
        }

        memcpy(pCacheData, pCursorShape, cbCursorDataSize);

        iCacheEntry = CH_CacheData(m_cmTxCacheHandle,
                                    (LPBYTE)pCacheData,
                                    cbCursorDataSize,
                                    0);

        TRACE_OUT(( "Cache new cursor: pShape 0x%p, iEntry %u",
                                        pCursorShape, iCacheEntry));

        if (!CMSendColorBitmapCursor(pCacheData, iCacheEntry ))
        {
            CH_RemoveCacheEntry(m_cmTxCacheHandle, iCacheEntry);
            DC_QUIT;
        }
    }
    else
    {
        TRACE_OUT(("Cursor in cache: pShape 0x%p, iEntry %u",
                                        pCursorShape, iCacheEntry));

        if (!CMSendCachedCursor(iCacheEntry))
        {
            DC_QUIT;
        }
    }

    //
    // Return success.
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(ASHost::CMSendCursorShape, rc);
    return(rc);
}



//
// FUNCTION: CMCopy1bppTo1bpp
//
// DESCRIPTION:
//
// Color conversion utility function to copy 1bpp cursor data to 1bpp (no
// conversion required).
//
// Data is assumed to be padded to word boundaries, and that the
// destination buffer is big enough to receive the 1bpp cursor data.
//
// PARAMETERS:
//
// pSrc - pointer to source data
//
// pDst - pointer to destination buffer
//
// cx - width of cursor in pixels
//
// cy - height of cursor in pixels
//
// RETURNS: Nothing
//
//
void  CMCopy1bppTo1bpp( LPBYTE pSrc,
                                            LPBYTE pDst,
                                            UINT   cx,
                                            UINT   cy )
{
    UINT cbRowWidth;

    DebugEntry(CMCopy1bppTo1bpp);

    cbRowWidth = ((cx + 15)/16) * 2;

    memcpy(pDst, pSrc, (cbRowWidth * cy));

    DebugExitVOID(CMCopy1bppTo1bpp);
}


//
// FUNCTION: CMCopy4bppTo1bpp
//
// DESCRIPTION:
//
// Color conversion utility function to copy 4bpp cursor data to 1bpp.
//
// Data is assumed to be padded to word boundaries, and that the
// destination buffer is big enough to receive the 1bpp cursor data.
//
// PARAMETERS:
//
// pSrc - pointer to source data
//
// pDst - pointer to destination buffer
//
// cx - width of cursor in pixels
//
// cy - height of cursor in pixels
//
// RETURNS: Nothing
//
//
void  CMCopy4bppTo1bpp( LPBYTE pSrc,
                                            LPBYTE pDst,
                                            UINT   cx,
                                            UINT   cy )
{
    UINT  x;
    UINT  y;
    UINT  cbDstRowWidth;
    UINT  cbSrcRowWidth;
    UINT  cbUnpaddedDstRowWidth;
    BOOL  fPadByteNeeded;
    BYTE Mask;

    DebugEntry(CMCopy4bppTo1bpp);

    cbDstRowWidth = ((cx + 15)/16) * 2;
    cbUnpaddedDstRowWidth = (cx + 7) / 8;
    cbSrcRowWidth = (cx + 1) / 2;
    fPadByteNeeded = ((cbDstRowWidth - cbUnpaddedDstRowWidth) > 0);

    for (y = 0; y < cy; y++)
    {
        *pDst = 0;
        Mask = 0x80;
        for (x = 0; x < cbSrcRowWidth; x++)
        {
            if (Mask == 0)
            {
                Mask = 0x80;
                pDst++;
                *pDst = 0;
            }

            if ((*pSrc & 0xF0) != 0)
            {
                *pDst |= Mask;
            }

            if ((*pSrc & 0x0F) != 0)
            {
                *pDst |= (Mask >> 1);
            }

            Mask >>= 2;

            pSrc++;
        }

        if (fPadByteNeeded)
        {
            pDst++;
            *pDst = 0;
        }

        pDst++;
    }

    DebugExitVOID(CMCopy4bppTo1bpp);
}

//
// FUNCTION: CMCopy8bppTo1bpp
//
// DESCRIPTION:
//
// Color conversion utility function to copy 8bpp cursor data to 1bpp.
//
// Data is assumed to be padded to word boundaries, and that the
// destination buffer is big enough to receive the 1bpp cursor data.
//
// PARAMETERS:
//
// pSrc - pointer to source data
//
// pDst - pointer to destination buffer
//
// cx - width of cursor in pixels
//
// cy - height of cursor in pixels
//
// RETURNS: Nothing
//
//
void  CMCopy8bppTo1bpp( LPBYTE pSrc,
                                            LPBYTE pDst,
                                            UINT   cx,
                                            UINT   cy )
{
    UINT  x;
    UINT  y;
    UINT  cbDstRowWidth;
    UINT  cbSrcRowWidth;
    UINT  cbUnpaddedDstRowWidth;
    BOOL  fPadByteNeeded;
    BYTE Mask;

    DebugEntry(CMCopy8bppTo1bpp);

    cbDstRowWidth = ((cx + 15)/16) * 2;
    cbUnpaddedDstRowWidth = (cx + 7) / 8;
    cbSrcRowWidth = cx;
    fPadByteNeeded = ((cbDstRowWidth - cbUnpaddedDstRowWidth) > 0);

    for (y = 0; y < cy; y++)
    {
        *pDst = 0;
        Mask = 0x80;
        for (x = 0; x < cbSrcRowWidth; x++)
        {
            if (Mask == 0x00)
            {
                Mask = 0x80;
                pDst++;
                *pDst = 0;
            }

            if (*pSrc != 0)
            {
                *pDst |= Mask;
            }

            Mask >>= 1;

            pSrc++;
        }

        if (fPadByteNeeded)
        {
            pDst++;
            *pDst = 0;
        }

        pDst++;
    }

    DebugExitVOID(CMCopy8bppTo1bpp);
}

//
// FUNCTION: CMCopy16bppTo1bpp
//
// DESCRIPTION:
//
// Color conversion utility function to copy 16bpp cursor data to 1bpp.
//
// Data is assumed to be padded to word boundaries, and that the
// destination buffer is big enough to receive the 1bpp cursor data.
//
// PARAMETERS:
//
// pSrc - pointer to source data
//
// pDst - pointer to destination buffer
//
// cx - width of cursor in pixels
//
// cy - height of cursor in pixels
//
// RETURNS: Nothing
//
//
void  CMCopy16bppTo1bpp( LPBYTE pSrc,
                                             LPBYTE pDst,
                                             UINT   cx,
                                             UINT   cy )
{
    UINT  x;
    UINT  y;
    UINT  cbDstRowWidth;
    UINT  cbUnpaddedDstRowWidth;
    BOOL  fPadByteNeeded;
    BYTE Mask;

    DebugEntry(CMCopy16bppTo1bpp);

    cbDstRowWidth = ((cx + 15)/16) * 2;
    cbUnpaddedDstRowWidth = (cx + 7) / 8;
    fPadByteNeeded = ((cbDstRowWidth - cbUnpaddedDstRowWidth) > 0);

    for (y = 0; y < cy; y++)
    {
        *pDst = 0;
        Mask = 0x80;
        for (x = 0; x < cx; x++)
        {
            if (Mask == 0)
            {
                Mask = 0x80;
                pDst++;
                *pDst = 0;
            }

            if (*(LPTSHR_UINT16)pSrc != 0)
            {
                *pDst |= Mask;
            }

            Mask >>= 1;

            pSrc += 2;
        }

        if (fPadByteNeeded)
        {
            pDst++;
            *pDst = 0;
        }

        pDst++;
    }

    DebugExitVOID(CMCopy16bppTo1bpp);
}


//
// FUNCTION: CMCopy24bppTo1bpp
//
// DESCRIPTION:
//
// Color conversion utility function to copy 24bpp cursor data to 1bpp.
//
// Data is assumed to be padded to word boundaries, and that the
// destination buffer is big enough to receive the 1bpp cursor data.
//
// PARAMETERS:
//
// pSrc - pointer to source data
//
// pDst - pointer to destination buffer
//
// cx - width of cursor in pixels
//
// cy - height of cursor in pixels
//
// RETURNS: Nothing
//
//
void  CMCopy24bppTo1bpp( LPBYTE pSrc,
                                             LPBYTE pDst,
                                             UINT   cx,
                                             UINT   cy )
{
    UINT  x;
    UINT  y;
    UINT  cbDstRowWidth;
    UINT  cbUnpaddedDstRowWidth;
    BOOL  fPadByteNeeded;
    BYTE Mask;
    UINT intensity;

    DebugEntry(CMCopy24bppTo1bpp);

    cbDstRowWidth = ((cx + 15)/16) * 2;
    cbUnpaddedDstRowWidth = (cx + 7) / 8;
    fPadByteNeeded = ((cbDstRowWidth - cbUnpaddedDstRowWidth) > 0);

    for (y = 0; y < cy; y++)
    {
        *pDst = 0;
        Mask = 0x80;
        for (x = 0; x < cx; x++)
        {
            if (Mask == 0)
            {
                Mask = 0x80;
                pDst++;
                *pDst = 0;
            }

            //
            // Work out the intensity of the RGB value.  There are three
            // possible results
            // 1) intensity <=CM_BLACK_THRESHOLD
            //    -- we leave the dest as blck
            // 2) intensity > CM_WHITE_THRESHOLD
            //    -- we definitely map to white
            // 3) otherwise
            //    -- we map to white in a grid hatching fashion
            //
            intensity = ((UINT)pSrc[0]*(UINT)pSrc[0]) +
                        ((UINT)pSrc[1]*(UINT)pSrc[1]) +
                        ((UINT)pSrc[2]*(UINT)pSrc[2]);

            if ( (intensity > CM_WHITE_THRESHOLD) ||
                ((intensity > CM_BLACK_THRESHOLD) && (((x ^ y) & 1) == 1)))
            {
                *pDst |= Mask;
            }

            Mask >>= 1;

            pSrc += 3;
        }

        if (fPadByteNeeded)
        {
            pDst++;
            *pDst = 0;
        }

        pDst++;
    }

    DebugExitVOID(CMCopy24bppTo1bpp);
}




//
// FUNCTION: CMSendCachedCursor
//
// DESCRIPTION:
//
// Sends a packet containing the given cache entry id.
//
// PARAMETERS:
//
// iCacheEntry - cache index
//
// RETURNS: TRUE if packet sent, FALSE otherwise.
//
//
BOOL  ASHost::CMSendCachedCursor(UINT iCacheEntry)
{
    BOOL                    rc = FALSE;
    PCMPACKETCOLORCACHE     pCMPacket;
#ifdef _DEBUG
    UINT                    sentSize;
#endif // _DEBUG

    DebugEntry(ASHost::CMSendCachedCursor);

    TRACE_OUT(( "Send cached cursor(%u)", iCacheEntry));

    pCMPacket = (PCMPACKETCOLORCACHE)m_pShare->SC_AllocPkt(PROT_STR_MISC, g_s20BroadcastID,
        sizeof(*pCMPacket));
    if (!pCMPacket)
    {
        WARNING_OUT(("Failed to alloc CM cached image packet"));
        DC_QUIT;
    }

    //
    // Fill in the packet.
    //
    pCMPacket->header.header.data.dataType = DT_CM;
    pCMPacket->header.type = CM_CURSOR_COLOR_CACHE;
    pCMPacket->cacheIndex = (TSHR_UINT16)iCacheEntry;

    //
    // Send it
    //
    if (m_pShare->m_scfViewSelf)
        m_pShare->CM_ReceivedPacket(m_pShare->m_pasLocal, &(pCMPacket->header.header));

#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    m_pShare->DCS_CompressAndSendPacket(PROT_STR_MISC, g_s20BroadcastID,
        &(pCMPacket->header.header), sizeof(*pCMPacket));

    TRACE_OUT(("CM COLOR CACHE packet size: %08d, sent %08d", sizeof(*pCMPacket),
        sentSize));

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::CMSendCachedCursor, rc);
    return(rc);
}



//
// FUNCTION: CMGetControllingWindow
//
// DESCRIPTION:
//
// Determines the window that is controlling the cursor's current shape.
//
// PARAMETERS: None
//
// RETURNS: the window that is controlling the cursor's current shape.
//
//
HWND  CMGetControllingWindow(void)
{
    POINT   cursorPos;
    HWND    hwnd;

    DebugEntry(CMGetControllingWindow);

    //
    // If a SysErrPopup Window (which is always System Modal) is present
    // then WindowFromPoint enters a infinite recursion loop, trashing the
    // stack and crashing the whole system.
    // If there is a SysModal window Window ensure WindowFromPoint is not
    // executed.
    //
    // The window controlling the cursor appearance is:
    //
    // - the local window that has the mouse capture (if any)
    // - the window that is under the current mouse position
    //
    //
    hwnd = GetCapture();
    if (!hwnd)
    {
        //
        // Get the current mouse position.
        //
        GetCursorPos(&cursorPos);
        hwnd = WindowFromPoint(cursorPos);
    }

    DebugExitDWORD(CMGetControllingWindow, HandleToUlong(hwnd));
    return(hwnd);
}




//
// FUNCTION: CMGetCurrentCursor
//
// DESCRIPTION:
//
// Returns a description of the current cursor
//
// PARAMETERS:
//
// pCursor - pointer to a CURSORDESCRIPTION variable that receives details
// of the current cursor
//
// RETURNS: Nothing
//
//
void  CMGetCurrentCursor(LPCURSORDESCRIPTION pCursor)
{
    LPCM_FAST_DATA lpcmShared;

    DebugEntry(CMGetCurrentCursor);

    lpcmShared = CM_SHM_START_READING;

    pCursor->type = CM_CD_BITMAPCURSOR;
    pCursor->id = lpcmShared->cmCursorStamp;

    CM_SHM_STOP_READING;

    DebugExitVOID(CMGetCurrentCursor);
}


//
// FUNCTION: CMSendSystemCursor
//
// DESCRIPTION:
//
// Sends a packet containing the given system cursor IDC.
//
// PARAMETERS:
//
// cursorIDC - the IDC of the system cursor to send
//
// RETURNS: TRUE if successful, FALSE otherwise.
//
//
BOOL  ASHost::CMSendSystemCursor(UINT cursorIDC)
{
    BOOL            rc = FALSE;
    PCMPACKETID     pCMPacket;
#ifdef _DEBUG
    UINT            sentSize;
#endif // _DEBUG

    DebugEntry(ASHost::CMSendSystemCursor);

    ASSERT((cursorIDC == CM_IDC_NULL) || (cursorIDC == CM_IDC_ARROW));

    //
    // The cursor is one of the system cursors - create a PROTCURSOR packet
    //
    pCMPacket = (PCMPACKETID)m_pShare->SC_AllocPkt(PROT_STR_MISC, g_s20BroadcastID,
        sizeof(*pCMPacket));
    if (!pCMPacket)
    {
        WARNING_OUT(("Failed to alloc CM system image packet"));
        DC_QUIT;
    }

    //
    // Fill in the packet.
    //
    pCMPacket->header.header.data.dataType = DT_CM;
    pCMPacket->header.type = CM_CURSOR_ID;
    pCMPacket->idc = cursorIDC;

    TRACE_OUT(( "Send CMCURSORID %ld", cursorIDC));

    //
    // Send it
    //
    if (m_pShare->m_scfViewSelf)
        m_pShare->CM_ReceivedPacket(m_pShare->m_pasLocal, &(pCMPacket->header.header));

#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    m_pShare->DCS_CompressAndSendPacket(PROT_STR_MISC, g_s20BroadcastID,
        &(pCMPacket->header.header), sizeof(*pCMPacket));

    TRACE_OUT(("CM ID packet size: %08d, sent %08d", sizeof(*pCMPacket),
        sentSize));

    //
    // Indicate that we successfully sent a packet.
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::CMSendSystemCursor, rc);
    return(rc);
}



//
// FUNCTION: CMSendBitmapCursor
//
// DESCRIPTION:
//
// Sends the current cursor as a bitmap.
//
// PARAMETERS: None
//
// RETURNS: TRUE if successful, FALSE otherwise.
//
//
BOOL  ASHost::CMSendBitmapCursor(void)
{
    BOOL            rc = FALSE;
    LPCM_SHAPE      pCursor;
    UINT            cbCursorDataSize;

    DebugEntry(ASHost::CMSendBitmapCursor);

    //
    // If cursor is hidden, send Null cursor
    //
    if (m_cmfCursorHidden)
    {
        TRACE_OUT(( "Send Null cursor (cursor hidden)"));
        CMSendSystemCursor(CM_IDC_NULL);
        DC_QUIT;
    }

    //
    // Get a pointer to the current cursor shape.
    //
    if (!CMGetCursorShape(&pCursor, &cbCursorDataSize))
    {
        DC_QUIT;
    }

    //
    // If this is a Null pointer, send the relevant packet.
    //
    if (CM_CURSOR_IS_NULL(pCursor))
    {
        TRACE_OUT(( "Send Null cursor"));
        CMSendSystemCursor(CM_IDC_NULL);
        DC_QUIT;
    }

    //
    // If all of the parties in the call support the color cursor protocol
    // then we try to send the cursor using that protocol, otherwise we
    // send a mono cursor.
    //
    if (m_cmfUseColorCursorProtocol)
    {
        if (!CMSendCursorShape(pCursor, cbCursorDataSize))
        {
            DC_QUIT;
        }
    }
    else
    {
        //
        // We cannot send cursors that are not 32x32 using the mono
        // protocol.
        //
        if ((pCursor->hdr.cx != 32) || (pCursor->hdr.cy != 32))
        {
            //
            // Maybe copy and alter the cursor definition so that it is
            // 32x32 ?
            //
            WARNING_OUT(( "Non-standard cursor (%d x %d)", pCursor->hdr.cx,
                                                         pCursor->hdr.cy ));
            DC_QUIT;
        }

        if (!CMSendMonoBitmapCursor(pCursor))
        {
            DC_QUIT;
        }
    }

    //
    // Return success.
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(ASHost::CMSendBitmapCursor, rc);
    return(rc);
}


//
// FUNCTION: CMCalculateColorCursorSize
//
// DESCRIPTION:
//
// Calculates the size in bytes of a given color cursor.
//
// PARAMETERS:
//
// pCursor - pointer to the cursor shape
//
// pcbANDMaskSize - pointer to a UINT variable that receives the AND mask
// size in bytes
//
// pcbXORBitmapSize - pointer to a UINT variable that receives the XOR
// bitmap size in bytes
//
// RETURNS: Nothing
//
//
void  CMCalculateColorCursorSize( LPCM_SHAPE pCursor,
                                             LPUINT        pcbANDMaskSize,
                                             LPUINT        pcbXORBitmapSize)
{
    DebugEntry(CMCalculcateColorCursorSize);

    *pcbANDMaskSize = CURSOR_AND_MASK_SIZE(pCursor);

    *pcbXORBitmapSize = CURSOR_DIB_BITS_SIZE( pCursor->hdr.cx,
                                              pCursor->hdr.cy,
                                              24 );

    DebugExitVOID(CMCalculateColorCursorSize);
}


//
// FUNCTION: CMSendColorBitmapCursor
//
// DESCRIPTION:
//
// Sends a given cursor as a color bitmap.
//
// PARAMETERS:
//
// pCursor - pointer to the cursor shape
//
// iCacheEntry - cache index to store in the transmitted packet
//
// RETURNS: TRUE if packet sent, FALSE otherwise
//
//
BOOL  ASHost::CMSendColorBitmapCursor(LPCM_SHAPE pCursor, UINT iCacheEntry)
{
    UINT        cbPacketSize;
    PCMPACKETCOLORBITMAP  pCMPacket;
    BOOL      rc = FALSE;
    UINT      cbANDMaskSize;
    UINT      cbXORBitmapSize;
    UINT      cbColorCursorSize;
#ifdef _DEBUG
    UINT      sentSize;
#endif // _DEBUG

    DebugEntry(ASHost::CMSendColorBitmapCursor);


    CMCalculateColorCursorSize(pCursor, &cbANDMaskSize, &cbXORBitmapSize );

    cbColorCursorSize = cbANDMaskSize + cbXORBitmapSize;

    //
    // Allocate a packet.
    //
    cbPacketSize = sizeof(CMPACKETCOLORBITMAP) + (cbColorCursorSize - 1);
    pCMPacket = (PCMPACKETCOLORBITMAP)m_pShare->SC_AllocPkt(PROT_STR_MISC,
        g_s20BroadcastID, cbPacketSize);
    if (!pCMPacket)
    {
        WARNING_OUT(("Failed to alloc CM color image packet, size %u", cbPacketSize));
        DC_QUIT;
    }

    //
    // Fill in the packet.
    //
    pCMPacket->header.header.data.dataType = DT_CM;

    //
    // Fill in fields.
    //
    pCMPacket->header.type = CM_CURSOR_COLOR_BITMAP;
    pCMPacket->cacheIndex = (TSHR_UINT16)iCacheEntry;

    if (!CMGetColorCursorDetails(pCursor,
        &(pCMPacket->cxWidth), &(pCMPacket->cyHeight),
        &(pCMPacket->xHotSpot), &(pCMPacket->yHotSpot),
        pCMPacket->aBits + cbXORBitmapSize,
        &(pCMPacket->cbANDMask),
        pCMPacket->aBits,
        &(pCMPacket->cbXORBitmap )))
    {
        //
        // Failed to get a cursor details.  Must free up SNI packet
        //
        S20_FreeDataPkt(&(pCMPacket->header.header));
        DC_QUIT;
    }

    ASSERT((pCMPacket->cbANDMask == cbANDMaskSize));

    ASSERT((pCMPacket->cbXORBitmap == cbXORBitmapSize));

    //
    // Send it
    //
    if (m_pShare->m_scfViewSelf)
        m_pShare->CM_ReceivedPacket(m_pShare->m_pasLocal, &(pCMPacket->header.header));

#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    m_pShare->DCS_CompressAndSendPacket(PROT_STR_MISC, g_s20BroadcastID,
        &(pCMPacket->header.header), sizeof(*pCMPacket));

    TRACE_OUT(("CM COLOR BITMAP packet size: %08d, sent %08d", sizeof(*pCMPacket),
        sentSize));

    //
    // Indicate that we successfully sent a packet.
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::CMSendColorBitmapCursor, rc);
    return(rc);
}


//
// FUNCTION: CMSendMonoBitmapCursor
//
// DESCRIPTION:
//
// Sends a given cursor as a mono bitmap
//
// PARAMETERS:
//
// pCursor - pointer to the cursor shape
//
// RETURNS: TRUE if packet sent, FALSE otherwise
//
//
BOOL  ASHost::CMSendMonoBitmapCursor(LPCM_SHAPE pCursor)
{
    UINT                cbPacketSize;
    PCMPACKETMONOBITMAP pCMPacket;
    BOOL                rc = FALSE;
    TSHR_UINT16         cbANDMaskSize;
    TSHR_UINT16         cbXORBitmapSize;
#ifdef _DEBUG
    UINT                sentSize;
#endif // _DEBUG

    DebugEntry(AShare::CMSendMonoBitmapCursor);

    //
    // Calculate the sizes of the converted (1bpp) AND and XOR bitmaps.
    //
    cbANDMaskSize = (TSHR_UINT16)CURSOR_AND_MASK_SIZE(pCursor);
    cbXORBitmapSize = cbANDMaskSize;

    //
    // Allocate a packet.
    //
    cbPacketSize = sizeof(CMPACKETMONOBITMAP) +
                   (cbANDMaskSize + cbXORBitmapSize - 1);
    pCMPacket = (PCMPACKETMONOBITMAP)m_pShare->SC_AllocPkt(PROT_STR_MISC,
        g_s20BroadcastID, cbPacketSize);
    if (!pCMPacket)
    {
        WARNING_OUT(("Failed to alloc CM mono image packet, size %u", cbPacketSize));
        DC_QUIT;
    }

    //
    // Fill FF in to initialize the XOR and AND bits
    //
    FillMemory((LPBYTE)(pCMPacket+1)-1, cbANDMaskSize + cbXORBitmapSize, 0xFF);

    //
    // Fill in the packet.
    //
    pCMPacket->header.header.data.dataType = DT_CM;

    //
    // Fill in fields.
    //
    pCMPacket->header.type = CM_CURSOR_MONO_BITMAP;

    CMGetMonoCursorDetails(pCursor,
                            &(pCMPacket->width),
                            &(pCMPacket->height),
                            &(pCMPacket->xHotSpot),
                            &(pCMPacket->yHotSpot),
                            pCMPacket->aBits + cbXORBitmapSize,
                            &cbANDMaskSize,
                            pCMPacket->aBits,
                            &cbXORBitmapSize );

    pCMPacket->cbBits = (TSHR_UINT16) (cbANDMaskSize + cbXORBitmapSize);

    TRACE_OUT(( "Mono cursor cx:%u cy:%u xhs:%u yhs:%u cbAND:%u cbXOR:%u",
        pCMPacket->width, pCMPacket->height,
        pCMPacket->xHotSpot, pCMPacket->yHotSpot,
        cbANDMaskSize, cbXORBitmapSize));

    //
    // Send it
    //
    if (m_pShare->m_scfViewSelf)
        m_pShare->CM_ReceivedPacket(m_pShare->m_pasLocal, &(pCMPacket->header.header));

#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    m_pShare->DCS_CompressAndSendPacket(PROT_STR_MISC, g_s20BroadcastID,
        &(pCMPacket->header.header), sizeof(*pCMPacket));

    TRACE_OUT(("CM MONO BITMAP packet size: %08d, sent %08d", sizeof(*pCMPacket),
        sentSize));

    //
    // Indicate that we successfully sent a packet.
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(ASHost::CMSendMonoBitmapCursor, rc);
    return(rc);
}





//
// FUNCTION: CMCreateMonoCursor
//
// DESCRIPTION: Creates a mono cursor
//
// PARAMETERS:
//
// xHotSpot - x position of the hotspot
//
// yHotSpot - y position of the hotspot
//
// cxWidth - width of the cursor
//
// cyHeight - height of the cursor
//
// pANDMask - pointer to a 1bpp, word-padded AND mask
//
// pXORBitmap - pointer to a 1bpp, word-padded XOR bitmap
//
// RETURNS: a valid cursor id, or NULL if the function fails
//
//
HCURSOR  ASShare::CMCreateMonoCursor(UINT     xHotSpot,
                                                 UINT     yHotSpot,
                                                 UINT     cxWidth,
                                                 UINT     cyHeight,
                                                 LPBYTE   pANDMask,
                                                 LPBYTE   pXORBitmap)
{
    HCURSOR  rc;

    DebugEntry(ASShare::CMCreateMonoCursor);

    //
    // Attempt to create the mono cursor.
    //
    rc = CreateCursor(g_asInstance, xHotSpot, yHotSpot, cxWidth, cyHeight,
            pANDMask, pXORBitmap);

    //
    // Check that the cursor handle is not null.
    //
    if (NULL == rc)
    {
        //
        // Substitute the default arrow cursor.
        //
        rc = m_cmArrowCursor;

        WARNING_OUT(( "Could not create cursor - substituting default arrow"));
    }

    //
    // Return the cursor
    //
    DebugExitDWORD(ASShare::CMCreateMonoCursor, HandleToUlong(rc));
    return(rc);
}



//
// FUNCTION: CMCreateColorCursor
//
// DESCRIPTION:
//
// Creates a color cursor.
//
// PARAMETERS:
//
// xHotSpot - x position of the hotspot
//
// yHotSpot - y position of the hotspot
//
// cxWidth - width of the cursor
//
// cyHeight - height of the cursor
//
// pANDMask - pointer to a 1bpp, word-padded AND mask
//
// pXORBitmap - pointer to a 24bpp, word-padded XOR bitmap
//
// cbANDMask - the size in bytes of the AND mask
//
// cbXORBitmap - the size in bytes of the XOR bitmap
//
// RETURNS: a valid cursor id, or NULL if the function fails
//
//
HCURSOR  ASShare::CMCreateColorCursor
(
    UINT     xHotSpot,
    UINT     yHotSpot,
    UINT     cxWidth,
    UINT     cyHeight,
    LPBYTE   pANDMask,
    LPBYTE   pXORBitmap,
    UINT     cbANDMask,
    UINT     cbXORBitmap
)
{
    HCURSOR         rc = 0;
    UINT             cbAllocSize;
    LPBITMAPINFO       pbmi = NULL;
    HDC                hdc = NULL;
    ICONINFO           iconInfo;
    HBITMAP            hbmXORBitmap = NULL;
    HBITMAP            hbmANDMask = NULL;
    HWND               hwndDesktop = NULL;

    DebugEntry(ASShare::CMCreateColorCursor);

    TRACE_OUT(("xhs(%u) yhs(%u) cx(%u) cy(%u) cbXOR(%u) cbAND(%u)",
                                                             xHotSpot,
                                                             yHotSpot,
                                                             cxWidth,
                                                             cyHeight,
                                                             cbXORBitmap,
                                                             cbANDMask ));


    //
    // We need a BITMAPINFO structure plus one additional RGBQUAD (there is
    // one included within the BITMAPINFO).  We use this to pass the 24bpp
    // XOR bitmap (which has no color table) and the 1bpp AND mask (which
    // requires 2 colors).
    //
    cbAllocSize = sizeof(*pbmi) + sizeof(RGBQUAD);

    pbmi = (LPBITMAPINFO)new BYTE[cbAllocSize];
    if (pbmi == NULL)
    {
        WARNING_OUT(( "Failed to alloc bmi(%x)", cbAllocSize));
        DC_QUIT;
    }

    //
    // Get a screen DC that we can pass to CreateDIBitmap.  We do not use
    // CreateCompatibleDC(NULL) here because that results in Windows
    // creating a mono bitmap.
    //
    hwndDesktop = GetDesktopWindow();
    hdc = GetWindowDC(hwndDesktop);
    if (hdc == NULL)
    {
        WARNING_OUT(( "Failed to create DC"));
        DC_QUIT;
    }

    pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth  = cxWidth;
    pbmi->bmiHeader.biHeight = cyHeight;
    pbmi->bmiHeader.biPlanes = 1;
    pbmi->bmiHeader.biBitCount = 24;
    pbmi->bmiHeader.biCompression = 0;
    pbmi->bmiHeader.biSizeImage = cbXORBitmap;
    pbmi->bmiHeader.biXPelsPerMeter = 0;
    pbmi->bmiHeader.biYPelsPerMeter = 0;
    pbmi->bmiHeader.biClrUsed = 0;
    pbmi->bmiHeader.biClrImportant = 0;

    hbmXORBitmap = CreateDIBitmap( hdc,
                                   (LPBITMAPINFOHEADER)pbmi,
                                   CBM_INIT,
                                   pXORBitmap,
                                   pbmi,
                                   DIB_RGB_COLORS );

    ReleaseDC(hwndDesktop, hdc);

    if (hbmXORBitmap == NULL)
    {
        WARNING_OUT(( "Failed to create XOR bitmap"));
        DC_QUIT;
    }

    //
    // Create MONOCHROME mask bitmap.  This works on both Win95 and NT.
    // COLOR masks don't work on Win95, just NT.
    //
    hdc = CreateCompatibleDC(NULL);
    if (!hdc)
    {
        WARNING_OUT(("Failed to get screen dc"));
        DC_QUIT;
    }

    pbmi->bmiHeader.biBitCount = 1;
    pbmi->bmiHeader.biCompression = 0;
    pbmi->bmiHeader.biSizeImage = cbANDMask;

    // Black
    pbmi->bmiColors[0].rgbRed      = 0x00;
    pbmi->bmiColors[0].rgbGreen    = 0x00;
    pbmi->bmiColors[0].rgbBlue     = 0x00;
    pbmi->bmiColors[0].rgbReserved = 0x00;

    // White
    pbmi->bmiColors[1].rgbRed      = 0xFF;
    pbmi->bmiColors[1].rgbGreen    = 0xFF;
    pbmi->bmiColors[1].rgbBlue     = 0xFF;
    pbmi->bmiColors[1].rgbReserved = 0x00;

    hbmANDMask = CreateDIBitmap( hdc,
                                 (LPBITMAPINFOHEADER)pbmi,
                                 CBM_INIT,
                                 pANDMask,
                                 pbmi,
                                 DIB_RGB_COLORS );

    DeleteDC(hdc);

    if (hbmANDMask == NULL)
    {
        WARNING_OUT(( "Failed to create AND mask"));
        DC_QUIT;
    }

#ifdef _DEBUG
    //
    // Make sure the AND mask is monochrome
    //
    {
        BITMAP  bmp;

        GetObject(hbmANDMask, sizeof(BITMAP), &bmp);
        ASSERT(bmp.bmPlanes == 1);
        ASSERT(bmp.bmBitsPixel == 1);
    }
#endif

    iconInfo.fIcon = FALSE;
    iconInfo.xHotspot = xHotSpot;
    iconInfo.yHotspot = yHotSpot;
    iconInfo.hbmMask  = hbmANDMask;
    iconInfo.hbmColor = hbmXORBitmap;

    rc = CreateIconIndirect(&iconInfo);

    TRACE_OUT(( "CreateCursor(%x) cx(%u)cy(%u)", rc, cxWidth, cyHeight));

DC_EXIT_POINT:

    if (hbmXORBitmap != NULL)
    {
        DeleteBitmap(hbmXORBitmap);
    }

    if (hbmANDMask != NULL)
    {
        DeleteBitmap(hbmANDMask);
    }

    if (pbmi != NULL)
    {
        delete[] pbmi;
    }

    //
    // Check that we have successfully managed to create the cursor.  If
    // not then substitute the default cursor.
    //
    if (rc == 0)
    {
        //
        // Substitute the default arrow cursor.
        //
        rc = m_cmArrowCursor;

        WARNING_OUT(( "Could not create cursor - substituting default arrow"));
    }

    DebugExitDWORD(ASShare::CMCreateColorCursor, HandleToUlong(rc));
    return(rc);
}



//
// FUNCTION: CMCreateAbbreviatedName
//
// DESCRIPTION:
//
// This function attempts to take a name, and create an abbreviation from
// the first characters of the first and last name.
//
// PARAMETERS:
//
// szTagName    - a pointer to a string containing the name to abbreviate.
// szBuf        - a pointer to a buffer into which the abbreviation will
//                be created.
// cbBuf        - size of buffer pointed to by szBuf.
//
// RETURNS:
//
// TRUE:        Success.  szBuf filled in.
// FALSE:       Failure.  szBuf is not filled in.
//
//
BOOL CMCreateAbbreviatedName(LPCSTR szTagName, LPSTR szBuf,
                               UINT cbBuf)
{
    BOOL  rc = FALSE;
    LPSTR p;
    LPSTR q;

    DebugEntry(CMCreateAbbreviatedName);

    //
    // This function isn't DBCS safe, so we don't abbreviate in DBCS
    // character sets.
    //
    if (TRUE == GetSystemMetrics(SM_DBCSENABLED))
    {
        DC_QUIT;
    }

    //
    // Try to create initials.  If that doesn't work, fail the call.
    //
    if ((NULL != (p = (LPSTR)_StrChr(szTagName, ' '))) && ('\0' != *(p+1)))
    {
        //
        // Is there enough room for initials?
        //
        if (cbBuf < NTRUNCLETTERS)
        {
            DC_QUIT;
        }

        q = szBuf;

        *q++ = *szTagName;
        *q++ = '.';
        *q++ = *(p+1);
        *q++ = '.';
        *q = '\0';

        AnsiUpper(szBuf);

        rc = TRUE;
    }

DC_EXIT_POINT:
    DebugExitBOOL(CMCreateAbbreviatedName, rc);
    return rc;
}

//
// FUNCTION: CMDrawCursorTag
//
// DESCRIPTION:
//
// PARAMETERS:
//
// hdcWindow - DC handle of the window to be drawn to
//
// cursorID - handle of cursor to drawn
//
// RETURNS: Nothing.
//
//
void  ASShare::CMDrawCursorTag
(
    ASPerson *  pasHost,
    HDC         hdc
)
{
    ASPerson *  pasPerson;
    char        ShortName[TSHR_MAX_PERSON_NAME_LEN];
    HFONT       hOldFont = NULL;
    RECT        rect;
    UINT        cCharsFit;
    LPSTR       p;

    DebugEntry(ASShare::CMDrawCursorTag);

    pasPerson = pasHost->m_caControlledBy;
    if (!pasPerson)
    {
        // Nothing to do
        DC_QUIT;
    }

    ValidatePerson(pasPerson);

    //
    // Try to abbreviate the person's name, so it will fit into the tag.
    // If the abbreviation fails, just copy the entire name for now.
    //
    if (!(CMCreateAbbreviatedName(pasPerson->scName, ShortName, sizeof(ShortName))))
    {
        lstrcpyn(ShortName, pasPerson->scName, sizeof(ShortName));
    }

    //
    // Select the cursor tag font into the DC.
    //
    hOldFont = SelectFont(hdc, m_cmCursorTagFont);

    if (hOldFont == NULL)
    {
        WARNING_OUT(("CMDrawCursorTag failed"));
        DC_QUIT;
    }

    //
    // Create the tag background...
    //
    PatBlt(hdc, TAGXOFF, TAGYOFF, TAGXSIZ, TAGYSIZ, WHITENESS);

    //
    // See how many characters of the name or abbreviation we can fit into
    // the tag.  First assume the whole thing fits.
    //
    cCharsFit = lstrlen(ShortName);

    //
    // Determine how many characters actually fit.
    //
    rect.left = rect.top = rect.right = rect.bottom = 0;

    for (p = AnsiNext(ShortName); ; p = AnsiNext(p))
    {
        if (DrawText(hdc, ShortName, p - ShortName, &rect,
                     DT_CALCRECT | DT_SINGLELINE | DT_NOPREFIX))
        {
            if (rect.right > TAGXSIZ)
            {
                //
                // This number of characters does not fit into the tag. Try
                // the next smaller number.
                //
                cCharsFit = AnsiPrev(ShortName, p) - ShortName;
                break;
            }
        }

        if ( '\0' == *p)
            break;
    }

    //
    // Now draw the text.  Note that DrawText does not return a documented
    // error code, so we don't check.
    //
    rect.left = TAGXOFF;
    rect.top = TAGYOFF;
    rect.right = TAGXOFF + TAGXSIZ;
    rect.bottom = TAGYOFF + TAGYSIZ;

    DrawText(hdc, ShortName, cCharsFit, &rect,
             DT_CENTER | DT_SINGLELINE | DT_NOPREFIX);

DC_EXIT_POINT:
    //
    // Perform necessary cleanup.
    //
    if (hOldFont)
    {
        SelectFont(hdc, hOldFont);
    }

    DebugExitVOID(ASShare::CMDrawCursorTag);
}





//
// FUNCTION: CMGetCursorShape
//
// DESCRIPTION:
//
// Returns a pointer to a DCCURSORSHAPE structure that defines the bit
// definition of the currently displayed cursor.
//
// A DCCURSORSHAPE structure is OS-specific.  The higher level code does
// not look at any individual fields in this structure - it just compares
// the whole data block with others in the cursor cache.  If two
// DCCURSORSHAPE structures contain the same the data, then the
// corresponding cursors are assumed to be the same.
//
// The LPCM_SHAPE returned here is passed back into
// CMGetColorCursorDetails or CMGetMonoCursorDetails to retrieve the
// specific details.
//
// PARAMETERS:
//
// ppCursorShape - pointer to a LPCM_SHAPE variable that receives the
// pointer to the DCCURSORSHAPE structure
//
// pcbCursorDataSize - pointer to a UINT variable that receives the size
// in bytes of the DCCURSORSHAPE structure
//
// RETURNS: Success TRUE/FALSE
//
//
BOOL  CMGetCursorShape(LPCM_SHAPE * ppCursorShape,
                                     LPUINT       pcbCursorDataSize )
{
    LPCM_FAST_DATA  lpcmShared;
    BOOL            rc = FALSE;

    DebugEntry(CMGetCursorShape);

    lpcmShared = CM_SHM_START_READING;

    //
    // Check that a cursor has been written to shared memory - may happen
    // on start-up before the display driver has written a cursor - or if
    // the display driver is not working.
    //
    if (lpcmShared->cmCursorShapeData.hdr.cBitsPerPel == 0)
    {
        TRACE_OUT(( "No cursor in shared memory"));
        DC_QUIT;
    }

    *ppCursorShape = (LPCM_SHAPE)&lpcmShared->cmCursorShapeData;
    *pcbCursorDataSize = CURSORSHAPE_SIZE(&lpcmShared->cmCursorShapeData);

    rc = TRUE;

DC_EXIT_POINT:
    CM_SHM_STOP_READING;

    DebugExitDWORD(CMGetCursorShape, rc);
    return(rc);
}



//
// FUNCTION: CMGetColorCursorDetails
//
// DESCRIPTION:
//
// Returns details of a cursor at 24bpp, given a DCCURSORSHAPE structure.
//
// PARAMETERS:
//
// pCursor - pointer to a DCCURSORSHAPE structure from which this function
// extracts the details
//
// pcxWidth - pointer to a TSHR_UINT16 variable that receives the cursor width
// in pixels
//
// pcyHeight - pointer to a TSHR_UINT16 variable that receives the cursor
// height in pixels
//
// pxHotSpot - pointer to a TSHR_UINT16 variable that receives the cursor
// hotspot x coordinate
//
// pyHotSpot - pointer to a TSHR_UINT16 variable that receives the cursor
// hotspot y coordinate
//
// pANDMask - pointer to a buffer that receives the cursor AND mask
//
// pcbANDMask - pointer to a TSHR_UINT16 variable that receives the size in
// bytes of the cursor AND mask
//
// pXORBitmap - pointer to a buffer that receives the cursor XOR bitmap at
// 24bpp
//
// pcbXORBitmap - pointer to a TSHR_UINT16 variable that receives the size in
// bytes of the cursor XOR bitmap
//
//
BOOL  ASHost::CMGetColorCursorDetails
(
    LPCM_SHAPE          pCursor,
    LPTSHR_UINT16       pcxWidth,
    LPTSHR_UINT16       pcyHeight,
    LPTSHR_UINT16       pxHotSpot,
    LPTSHR_UINT16       pyHotSpot,
    LPBYTE              pANDMask,
    LPTSHR_UINT16       pcbANDMask,
    LPBYTE              pXORBitmap,
    LPTSHR_UINT16       pcbXORBitmap
)
{
    BOOL             rc = FALSE;
    LPCM_SHAPE_HEADER  pCursorHdr;
    HDC                hdcScreen = NULL;
    HBITMAP            hbmp = NULL;
    UINT             cbANDMaskSize;
    UINT             cbXORBitmapSize;
    HDC                hdcTmp = NULL;
    UINT             cbANDMaskRowWidth;
    UINT             cbSrcRowOffset;
    UINT             cbDstRowOffset;
    UINT             y;
    LPUINT          pDestBitmasks;
    BITMAPINFO_ours    bmi;
    BITMAPINFO_ours    srcbmi;
    HBITMAP            oldBitmap;
    void *            pBmBits = NULL;
    int              numColors;
    int              ii;
    LPCM_FAST_DATA  lpcmShared;

    DebugEntry(ASHost::CMGetColorCursorDetails);

    if (pCursor == NULL)
    {
        DC_QUIT;
    }
    pCursorHdr = &(pCursor->hdr);

    //
    // Copy the cursor size and hotspot coords.
    //
    *pcxWidth  = pCursorHdr->cx;
    *pcyHeight = pCursorHdr->cy;
    *pxHotSpot = (TSHR_UINT16)pCursorHdr->ptHotSpot.x;
    *pyHotSpot = (TSHR_UINT16)pCursorHdr->ptHotSpot.y;
    TRACE_OUT(( "cx(%u) cy(%u) cbWidth %d planes(%u) bpp(%u)",
                                                   pCursorHdr->cx,
                                                   pCursorHdr->cy,
                                                   pCursorHdr->cbRowWidth,
                                                   pCursorHdr->cPlanes,
                                                   pCursorHdr->cBitsPerPel ));

    cbANDMaskSize = CURSOR_AND_MASK_SIZE(pCursor);
    cbXORBitmapSize = CURSOR_XOR_BITMAP_SIZE(pCursor);

    //
    // Copy the AND mask - this is always mono.
    //
    // The AND mask is currently in top-down format (the top row of the
    // bitmap comes first).
    //
    // The protocol sends bitmaps in Device Independent format, which is
    // bottom-up.  We therefore have to flip the rows as we copy the mask.
    //
    cbANDMaskRowWidth = pCursorHdr->cbRowWidth;
    cbSrcRowOffset = 0;
    cbDstRowOffset = cbANDMaskRowWidth * (pCursorHdr->cy-1);

    for (y = 0; y < pCursorHdr->cy; y++)
    {
        memcpy( pANDMask + cbDstRowOffset,
                pCursor->Masks + cbSrcRowOffset,
                cbANDMaskRowWidth );
        cbSrcRowOffset += cbANDMaskRowWidth;
        cbDstRowOffset -= cbANDMaskRowWidth;
    }

    //
    // The XOR mask is color and is in DIB format - at 1bpp for mono
    // cursors, or the display driver bpp.
    //
    // We create a bitmap of the same size, set the bits into it and then
    // get the bits out in 24bpp DIB format.
    //
    hdcTmp = CreateCompatibleDC(NULL);
    if (hdcTmp == NULL)
    {
        ERROR_OUT(( "failed to create DC"));
        DC_QUIT;
    }

    //
    // Setup source bitmap information.
    //
    m_pShare->USR_InitDIBitmapHeader((BITMAPINFOHEADER *)&srcbmi, pCursorHdr->cBitsPerPel);
    srcbmi.bmiHeader.biWidth  = pCursorHdr->cx;
    srcbmi.bmiHeader.biHeight = pCursorHdr->cy;

    numColors = COLORS_FOR_BPP(pCursorHdr->cBitsPerPel);

    //
    // Setup source palette info.
    //
    if (pCursorHdr->cBitsPerPel > 8)
    {
        //
        // If the device bpp is > 8, we have to set up the DIB section to
        // use the same bitmasks as the device.  This means setting the
        // compression type to BI_BITFIELDS and setting the first 3 DWORDS
        // of the bitmap info color table to be the bitmasks for R, G and B
        // respectively.
        // But not for 24bpp.  No bitmask or palette are used - it is
        // always 8,8,8 RGB.
        //
        if (pCursorHdr->cBitsPerPel != 24)
        {
            TRACE_OUT(( "Copy bitfields"));
            srcbmi.bmiHeader.biCompression = BI_BITFIELDS;

            lpcmShared = CM_SHM_START_READING;

            pDestBitmasks    = (LPUINT)(srcbmi.bmiColors);
            pDestBitmasks[0] = lpcmShared->bitmasks[0];
            pDestBitmasks[1] = lpcmShared->bitmasks[1];
            pDestBitmasks[2] = lpcmShared->bitmasks[2];

            CM_SHM_STOP_READING;
        }
        else
        {
            TRACE_OUT(( "24bpp cursor: no bitmasks"));
        }
    }
    else
    {
        TRACE_OUT(( "Get palette %d", numColors));

        lpcmShared = CM_SHM_START_READING;

        //
        // Flip the palette - its RGB in the kernel, and needs to be BGR
        // here.
        //
        for (ii = 0; ii < numColors; ii++)
        {
            srcbmi.bmiColors[ii].rgbRed   = lpcmShared->colorTable[ii].peRed;
            srcbmi.bmiColors[ii].rgbGreen = lpcmShared->colorTable[ii].peGreen;
            srcbmi.bmiColors[ii].rgbBlue  = lpcmShared->colorTable[ii].peBlue;
        }

        CM_SHM_STOP_READING;
    }

    //
    // Create source bitmap and write in the bitmap bits.
    //
    hbmp = CreateDIBSection(hdcTmp,
                            (BITMAPINFO *)&srcbmi,
                            DIB_RGB_COLORS,
                            &pBmBits,
                            NULL,
                            0);
    if (hbmp == NULL)
    {
        ERROR_OUT(( "Failed to create bitmap"));
        DC_QUIT;
    }

    TRACE_OUT(( "Copy %d bytes of data into bitmap 0x%08x",
                  cbXORBitmapSize, pBmBits));
    memcpy(pBmBits, pCursor->Masks + cbANDMaskSize, cbXORBitmapSize);


    //
    // Set up the structure required by GetDIBits - 24bpp.  Set the height
    // -ve to allow for top-down ordering of the bitmap.
    //
    m_pShare->USR_InitDIBitmapHeader((BITMAPINFOHEADER *)&bmi, 24);
    bmi.bmiHeader.biWidth  = pCursorHdr->cx;
    bmi.bmiHeader.biHeight = -pCursorHdr->cy;

    if (GetDIBits(hdcTmp,
                  hbmp,
                  0,
                  pCursorHdr->cy,
                  pXORBitmap,
                  (LPBITMAPINFO)&bmi,
                  DIB_RGB_COLORS) == 0)
    {
        ERROR_OUT(( "GetDIBits failed hdc(%x) hbmp(%x) cy(%d)",
                     (TSHR_UINT16)hdcTmp,
                     (TSHR_UINT16)hbmp,
                     pCursorHdr->cy ));
        DC_QUIT;
    }

    *pcbANDMask   = (TSHR_UINT16) CURSOR_AND_MASK_SIZE(pCursor);
    *pcbXORBitmap = (TSHR_UINT16) CURSOR_DIB_BITS_SIZE(pCursor->hdr.cx,
                                                    pCursor->hdr.cy,
                                                    24);

    //
    // Return success.
    //
    rc = TRUE;

DC_EXIT_POINT:
    //
    // Clean up before exit.
    //
    if (hdcTmp)
    {
        DeleteDC(hdcTmp);
    }

    if (hbmp != NULL)
    {
        DeleteBitmap(hbmp);
    }

    DebugExitBOOL(ASHost::CMGetColorCursorDetails, rc);
    return(rc);
}

//
// FUNCTION: CMGetMonoCursorDetails
//
// DESCRIPTION:
//
// Returns details of a cursor at 1bpp, given a DCCURSORSHAPE structure.
//
// PARAMETERS:
//
// pCursor - pointer to a DCCURSORSHAPE structure from which this function
// extracts the details
//
// pcxWidth - pointer to a TSHR_UINT16 variable that receives the cursor width
// in pixels
//
// pcyHeight - pointer to a TSHR_UINT16 variable that receives the cursor
// height in pixels
//
// pxHotSpot - pointer to a TSHR_UINT16 variable that receives the cursor
// hotspot x coordinate
//
// pyHotSpot - pointer to a TSHR_UINT16 variable that receives the cursor
// hotspot y coordinate
//
// pANDMask - pointer to a buffer that receives the cursor AND mask
//
// pcbANDMask - pointer to a TSHR_UINT16 variable that receives the size in
// bytes of the cursor AND mask
//
// pXORBitmap - pointer to a buffer that receives the cursor XOR bitmap at
// 1bpp
//
// pcbXORBitmap - pointer to a TSHR_UINT16 variable that receives the size in
// bytes of the cursor XOR bitmap
//
//
BOOL  CMGetMonoCursorDetails(LPCM_SHAPE pCursor,
                                                 LPTSHR_UINT16      pcxWidth,
                                                 LPTSHR_UINT16      pcyHeight,
                                                 LPTSHR_UINT16      pxHotSpot,
                                                 LPTSHR_UINT16      pyHotSpot,
                                                 LPBYTE       pANDMask,
                                                 LPTSHR_UINT16      pcbANDMask,
                                                 LPBYTE       pXORBitmap,
                                                 LPTSHR_UINT16      pcbXORBitmap)
{
    BOOL            rc = FALSE;
    LPCM_SHAPE_HEADER pCursorHdr;
    UINT            x;
    UINT            y;
    LPBYTE          pSrcRow;
    UINT          cbDstRowWidth;
    LPBYTE          pDstData;
    UINT          cbSrcANDMaskSize;
    LPBYTE          pSrcXORMask;
    PFNCMCOPYTOMONO   pfnCopyToMono;

    DebugEntry(CMGetMonoCursor);

    pCursorHdr = &(pCursor->hdr);

    TRACE_OUT(( "cx(%u) cy(%u) cbWidth %d planes(%u) bpp(%u)",
                                                   pCursorHdr->cx,
                                                   pCursorHdr->cy,
                                                   pCursorHdr->cbRowWidth,
                                                   pCursorHdr->cPlanes,
                                                   pCursorHdr->cBitsPerPel ));

    //
    // Copy the cursor size and hotspot coords.
    //
    *pcxWidth  = pCursorHdr->cx;
    *pcyHeight = pCursorHdr->cy;
    *pxHotSpot = (TSHR_UINT16)pCursorHdr->ptHotSpot.x;
    *pyHotSpot = (TSHR_UINT16)pCursorHdr->ptHotSpot.y;

    //
    // Copy the AND mask - this is always mono...
    // The rows are padded to word (16-bit) boundaries.
    //
    pDstData = pANDMask;
    pSrcRow = pCursor->Masks;
    cbDstRowWidth = ((pCursorHdr->cx + 15)/16) * 2;

    for (y = 0; y < pCursorHdr->cy; y++)
    {
        for (x = 0; x < cbDstRowWidth; x++)
        {
            if (x < pCursorHdr->cbRowWidth)
            {
                //
                // Copy data from the cursor definition.
                //
                *pDstData++ = pSrcRow[x];
            }
            else
            {
                //
                // Padding required.
                //
                *pDstData++ = 0xFF;
            }
        }
        pSrcRow += pCursorHdr->cbRowWidth;
    }

    //
    // Copy the XOR mask - this may be color.  We convert to mono by:
    //
    //   - turning all zero values into a binary 0
    //   - turning all non-zero value into a binary 1
    //
    //
    switch (pCursorHdr->cBitsPerPel)
    {
        case 1:
            TRACE_OUT(( "1bpp"));
            pfnCopyToMono = CMCopy1bppTo1bpp;
            break;

        case 4:
            TRACE_OUT(( "4bpp"));
            pfnCopyToMono = CMCopy4bppTo1bpp;
            break;

        case 8:
            TRACE_OUT(( "8bpp"));
            pfnCopyToMono = CMCopy8bppTo1bpp;
            break;

        case 16:
            TRACE_OUT(( "16bpp"));
            pfnCopyToMono = CMCopy16bppTo1bpp;
            break;

        case 24:
            TRACE_OUT(( "24bpp"));
            pfnCopyToMono = CMCopy24bppTo1bpp;
            break;

        default:
            ERROR_OUT(( "Unexpected bpp: %d", pCursorHdr->cBitsPerPel));
            DC_QUIT;
    }

    cbSrcANDMaskSize = pCursorHdr->cbRowWidth * pCursorHdr->cy;
    pSrcXORMask = pCursor->Masks + cbSrcANDMaskSize;

    (*pfnCopyToMono)( pSrcXORMask,
                              pXORBitmap,
                              pCursorHdr->cx,
                              pCursorHdr->cy );

    *pcbANDMask   = (TSHR_UINT16) (cbDstRowWidth * pCursorHdr->cy);
    *pcbXORBitmap = (TSHR_UINT16) *pcbANDMask;

    //
    // Return success.
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(CMGetMonoCursor, rc);
    return(rc);
}



//
// FUNCTION: CMSetCursorTransform
//
// DESCRIPTION:
//
// This function is responsible for setting cursor transforms.
//
// PARAMETERS:
//
// cWidth        - the width in pels of the AND mask and the XOR DIB
// cHeight       - the height in pels of the AND mask and the XOR DIB
// pOrigANDMask  - a pointer to the bits of a WORD padded AND mask (the
//                 bits are top-down)
// pOrigXORDIB   - a pointer to a DIB of the size given by cWidth and
//                 cHeight.
//
//
BOOL ASHost::CMSetCursorTransform
(
    LPBYTE          pOrigANDMask,
    LPBITMAPINFO    pOrigXORDIB
)
{
    BOOL        rc = FALSE;
    LPBYTE      pBits = NULL;
    UINT        cbSize;
    CM_DRV_XFORM_INFO drvXformInfo;
    UINT        srcRowLength;

    DebugEntry(ASHost::CMSetCursorTransform);

    //
    // The transform should be monochrome
    //
    ASSERT(pOrigXORDIB->bmiHeader.biBitCount == 1);

    //
    // For mono tags, create a single 1bpp DIB with AND followed by XOR
    // data.  Since both the AND mask and the XOR bitmap are word
    // aligned we need to know the word aligned row length for
    // allocating memory.
    //

    //
    // Calculate the source and destination row lengths (in bytes).
    //
    srcRowLength = ((m_pShare->m_cmCursorWidth + 15)/16) * 2;
    cbSize = srcRowLength * m_pShare->m_cmCursorHeight;

    pBits = new BYTE[cbSize * 2];
    if (!pBits)
    {
        ERROR_OUT(( "Alloc %lu bytes failed", cbSize * 2));
        DC_QUIT;
    }

    //
    // Copy the packed 1bpp AND and XOR bits to the buffer
    //
    TRACE_OUT(( "Copy %d bytes from 0x%08x", cbSize, pOrigANDMask));

    //
    // Copy the AND and XOR 1bpp masks.
    //
    memcpy(pBits, pOrigANDMask, cbSize);
    memcpy(pBits + cbSize, POINTER_TO_DIB_BITS(pOrigXORDIB), cbSize);

    //
    // Call the display driver to set the pointer transform.
    //
    drvXformInfo.width      = m_pShare->m_cmCursorWidth;
    drvXformInfo.height     = m_pShare->m_cmCursorHeight;
    drvXformInfo.pANDMask   = pBits;
    drvXformInfo.result     = FALSE;

    if (!OSI_FunctionRequest(CM_ESC_XFORM, (LPOSI_ESCAPE_HEADER)&drvXformInfo,
            sizeof(drvXformInfo)) ||
        !drvXformInfo.result)
    {
        ERROR_OUT(("CM_ESC_XFORM failed"));
        DC_QUIT;
    }

    //
    // Set flag inidicating that transform is applied.
    //
    m_cmfCursorTransformApplied = TRUE;
    rc = TRUE;

DC_EXIT_POINT:
    //
    // Release allocated memory, bitmaps, DCs.
    //
    if (pBits)
    {
        delete[] pBits;
    }

    DebugExitBOOL(ASHost::CMSetCursorTransform, rc);
    return(rc);
}


//
// FUNCTION: CMRemoveCursorTransform
//
// DESCRIPTION:
// This function is responsible for removing cursor transforms.
//
// PARAMETERS: None.
//
void ASHost::CMRemoveCursorTransform(void)
{
    DebugEntry(ASHost::CMRemoveCursorTransform);

    //
    // Check to see if there is currently a transform applied.
    //
    if (m_cmfCursorTransformApplied)
    {
        CM_DRV_XFORM_INFO drvXformInfo;

        //
        // Call down to the display driver to remove the pointer tag.
        //
        drvXformInfo.pANDMask = NULL;
        drvXformInfo.result = FALSE;

        OSI_FunctionRequest(CM_ESC_XFORM, (LPOSI_ESCAPE_HEADER)&drvXformInfo,
            sizeof(drvXformInfo));

        m_cmfCursorTransformApplied = FALSE;
    }

    DebugExitVOID(ASHost::CMRemoveCursorTransform);
}



//
// FUNCTION: CMProcessCursorIDPacket
//
// DESCRIPTION:
//
// Processes a received cursor ID packet.
//
// PARAMETERS:
//
// pCMPacket - pointer to the received cursor ID packet
//
// phNewCursor - pointer to a HCURSOR variable that receives the handle
// of a cursor that corresponds to the received packet
//
// pNewHotSpot - pointer to a POINT variable that receives the hot-spot
// of the new cursor
//
// RETURNS: Nothing
//
//
void  ASShare::CMProcessCursorIDPacket
(
    PCMPACKETID     pCMPacket,
    HCURSOR*        phNewCursor,
    LPPOINT         pNewHotSpot
)
{
    DebugEntry(ASShare::CMProcessCursorIDPacket);

    //
    // We only support NULL and ARROW
    //

    //
    // If the IDC is not NULL then load the cursor.
    //
    if (pCMPacket->idc != CM_IDC_NULL)
    {
        if (pCMPacket->idc != CM_IDC_ARROW)
        {
            WARNING_OUT(("ProcessCursorIDPacket:  unrecognized ID, using arrow"));
        }

        *phNewCursor = m_cmArrowCursor;
        *pNewHotSpot = m_cmArrowCursorHotSpot;
    }
    else
    {
        // NULL is used for hidden cursors
        *phNewCursor = NULL;
        pNewHotSpot->x = 0;
        pNewHotSpot->y = 0;
    }

    DebugExitVOID(ASShare::CMProcessCursorIDPacket);
}




//
// CM_Controlled()
//
// Called when we start/stop being controlled.
//
extern              CURTAGINFO g_cti;

void ASHost::CM_Controlled(ASPerson * pasController)
{
    char  szAbbreviatedName[128];

    DebugEntry(ASHost::CM_Controlled);

    //
    // If we are not being controlled, turn off the cursor tag.  Note that
    // being detached means we aren't controlled.
    //
    if (!pasController)
    {
        // We're not being controlled by a remote.  No cursor xform
        CMRemoveCursorTransform();
    }
    else
    {
        BOOL fAbbreviated = CMCreateAbbreviatedName(pasController->scName,
            szAbbreviatedName, sizeof(szAbbreviatedName));

        if ( !fAbbreviated )
        {
            lstrcpyn(szAbbreviatedName, pasController->scName,
                    ARRAY_ELEMENTS(szAbbreviatedName));
        }

        if (!CMGetCursorTagInfo(szAbbreviatedName))
        {
            ERROR_OUT(("GetCurTagInfo failed, not setting cursor tag"));
        }
        else
        {
            CMSetCursorTransform(&g_cti.aAndBits[0], &g_cti.bmInfo);
        }
    }

    DebugExitVOID(ASHost::CM_Controlled);
}



// This initializes our single, volatile data for
// creating cursor tags.

CURTAGINFO g_cti = {
    32,    // height of masks
    32,    // width of masks

    // bits describing the AND mask, this is a 12x24 rectangle in lower right
    // if the tag size is changed, the mask will have to be edited, the
    // following helps draw attention to this
    #if ( TAGXOFF != 8 || TAGYOFF != 20 || TAGXSIZ != 24 || TAGYSIZ != 12 )
    #error "Bitmap mask may be incorrect"
    #endif

    {    0xff, 0xff, 0xff, 0xff,        // line 1
        0xff, 0xff, 0xff, 0xff,        // line 2
        0xff, 0xff, 0xff, 0xff,        // line 3
        0xff, 0xff, 0xff, 0xff,        // line 4
        0xff, 0xff, 0xff, 0xff,        // line 5
        0xff, 0xff, 0xff, 0xff,        // line 6
        0xff, 0xff, 0xff, 0xff,        // line 7
        0xff, 0xff, 0xff, 0xff,        // line 8
        0xff, 0xff, 0xff, 0xff,        // line 9
        0xff, 0xff, 0xff, 0xff,        // line 10
        0xff, 0xff, 0xff, 0xff,        // line 11
        0xff, 0xff, 0xff, 0xff,        // line 12
        0xff, 0xff, 0xff, 0xff,        // line 13
        0xff, 0xff, 0xff, 0xff,        // line 14
        0xff, 0xff, 0xff, 0xff,        // line 15
        0xff, 0xff, 0xff, 0xff,        // line 16
        0xff, 0xff, 0xff, 0xff,        // line 17
        0xff, 0xff, 0xff, 0xff,        // line 18
        0xff, 0xff, 0xff, 0xff,        // line 19
        0xff, 0xff, 0xff, 0xff,        // line 20
        0xff, 0x00, 0x00, 0x00,        // line 21
        0xff, 0x00, 0x00, 0x00,        // line 22
        0xff, 0x00, 0x00, 0x00,        // line 23
        0xff, 0x00, 0x00, 0x00,        // line 24
        0xff, 0x00, 0x00, 0x00,        // line 25
        0xff, 0x00, 0x00, 0x00,        // line 26
        0xff, 0x00, 0x00, 0x00,        // line 27
        0xff, 0x00, 0x00, 0x00,        // line 28
        0xff, 0x00, 0x00, 0x00,        // line 29
        0xff, 0x00, 0x00, 0x00,        // line 30
        0xff, 0x00, 0x00, 0x00,        // line 31
        0xff, 0x00, 0x00, 0x00        // line 32
    },
    // Initialize the BITMAPINFO structure:
    {
        // Initialize the BITMAPINFOHEADER structure:
        {
            sizeof(BITMAPINFOHEADER),
            32, // width
            -32, // height (top down bitmap)
            1, // planes
            1, // bits per pixel
            BI_RGB, // compression format (none)
            0, // not used for uncompressed bitmaps
            0, // xpels per meter, not set
            0, // ypels per meter, not set
            0, // biClrsUsed, indicates 2 color entries follow this struct
            0 // biClrsImportant (all)
        },

        // Initialize the foreground color (part of BITMAPINFO struct)
        // This is BLACK
        { 0x0, 0x0, 0x0, 0x0 },
    },

    // Initialize the background color (part of single RGBQUAD struct following
    // BITMAPINFO STRUCTURE
    { 0xff, 0xff, 0xff, 0x00 },

    // Because this is a packed bitmap, the bitmap bits follow:
    // These will be written into dynamically to create the tag

    { 0, }
};



//
// This function isn't DBCS safe, so we don't abbreviate in
// DBCS character sets
//

BOOL ASShare::CMCreateAbbreviatedName
(
    LPCSTR  szTagName,
    LPSTR   szBuf,
    UINT    cbBuf
)
{
    BOOL    rc = FALSE;

    DebugEntry(ASShare::CMCreateAbbreviatedName);

    if (GetSystemMetrics(SM_DBCSENABLED))
    {
        TRACE_OUT(("Do not attempt to abbreviate on DBCS system"));
        DC_QUIT;
    }

    // We will try to create initials first

    LPSTR p;
    if ( NULL != (p = (LPSTR) _StrChr ( szTagName, ' ' )))
    {
        // Enough room for initials?
        if (cbBuf < NTRUNCLETTERS)
        {
            TRACE_OUT(("CMCreateAbbreviatedName: not enough room for initials"));
            DC_QUIT;
        }

        char * q = szBuf;

        *q++ = *szTagName;
        *q++ = '.';
        *q++ = *(p+1);
        *q++ = '.';
        *q = '\0';

        CharUpper ( q );

        rc = TRUE;
    }

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::CMCreateAbbreviatedName, rc);
    return(rc);
}


// This function will create the appropriate data in the
// volatile global and return a pointer to it.

BOOL ASHost::CMGetCursorTagInfo(LPCSTR szTagName)
{
    HDC hdc = NULL;
    HDC hdcScratch = NULL;
    HBITMAP hBmpOld = NULL;
    HBITMAP hBitmap = NULL;
    PCURTAGINFO pctiRet = NULL;
    RECT    rect;
    HFONT hOldFont;
    BOOL    rc = FALSE;

    DebugEntry(ASHost::CMGetCursorTagInfo);

    hdcScratch = CreateCompatibleDC(NULL);
    if (!hdcScratch)
    {
        ERROR_OUT(("CMGetCursorTagInfo: couldn't get scratch DC"));
        DC_QUIT;
    }

    hBitmap = CreateDIBitmap(hdcScratch,
                &(g_cti.bmInfo.bmiHeader),
                0, // don't initialize bits
                NULL, // don't initialize bits
                &(g_cti.bmInfo),
                DIB_RGB_COLORS );

    if (!hBitmap)
    {
        ERROR_OUT(("CMGetCursorTagInfo: failed to create bitmap"));
        DC_QUIT;
    }

    hBmpOld = SelectBitmap(hdcScratch, hBitmap);
    hOldFont = SelectFont(hdcScratch, m_pShare->m_cmCursorTagFont);

    // Create the tag background...

    PatBlt ( hdcScratch, 0, 0, 32, 32, BLACKNESS );
    PatBlt ( hdcScratch, TAGXOFF, TAGYOFF, TAGXSIZ, TAGYSIZ, WHITENESS );

    // Now see how many characters of the name or abbreviation
    // we can fit into the tag

    int cCharsFit;
    SIZE size;
    LPSTR p;

    // First assume the whole thing fits
    cCharsFit = lstrlen(szTagName);

    // Now try to find out how big a part actually fits

    rect.left = rect.top = rect.right = rect.bottom = 0;

    for ( p = CharNext(szTagName); ; p = CharNext(p) )
    {
        if ( DrawText(hdcScratch, szTagName, (int)(p - szTagName), &rect,
                    DT_CALCRECT | DT_SINGLELINE | DT_NOPREFIX ) )
        {
            if ( rect.right > TAGXSIZ )
            {
                // This number of characters no longer fits into the
                // tag. Take the next smaller number and leave the loop
                cCharsFit = (int)(CharPrev(szTagName, p) - szTagName);
                break;
            }
        }

        if ( NULL == *p )
            break;
    }

    TRACE_OUT(("Tag: [%s], showing %d chars", szTagName, cCharsFit ));

    // Now draw the text...
    // DrawText doesn't return a documented error...

    rect.top = TAGYOFF;
    rect.left = TAGXOFF;
    rect.bottom = TAGYOFF + TAGYSIZ;
    rect.right = TAGXOFF + TAGXSIZ;

    DrawText ( hdcScratch, szTagName, cCharsFit, &rect,
            DT_CENTER | DT_SINGLELINE | DT_NOPREFIX );

    SelectFont (hdcScratch, hOldFont);

    // Now get the bitmap bits into the global volatile data area
    // Make sure the number of scan lines requested is returned

    if ( 32 != GetDIBits ( hdcScratch,
                hBitmap,
                0,
                32,
                g_cti.aXorBits,
                &(g_cti.bmInfo),
                DIB_RGB_COLORS ))
    {
        ERROR_OUT(("CMGetCursorTagInfo: GetDIBits failed"));
        DC_QUIT;
    }

    // Reset the foreground and background colors to black
    // and white respectively no matter what GetDIBits has filled in.
    // REVIEW: how do we get GetDIBits to fill in the expected (B&W) color
    // table?

    g_cti.bmInfo.bmiColors[0].rgbBlue = 0x0;
    g_cti.bmInfo.bmiColors[0].rgbGreen = 0x0;
    g_cti.bmInfo.bmiColors[0].rgbRed = 0x0;
    g_cti.bmInfo.bmiColors[0].rgbReserved = 0;

    g_cti.rgbBackground[0].rgbBlue = 0xff;
    g_cti.rgbBackground[0].rgbGreen = 0xff;
    g_cti.rgbBackground[0].rgbRed = 0xff;
    g_cti.rgbBackground[0].rgbReserved = 0;

    // Finally, we are happy
    rc = TRUE;

DC_EXIT_POINT:

    // Perform necessary cleanup
    if (hBmpOld)
        SelectBitmap ( hdcScratch, hBmpOld);

    if ( hBitmap )
        DeleteBitmap ( hBitmap );

    if ( hdcScratch )
        DeleteDC ( hdcScratch );

    DebugExitBOOL(ASHost::CMGetCursorTagInfo, rc);
    return(rc);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\control.cpp ===
#include "precomp.h"


//
// CONTROL.CPP
// Control by us, control of us
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE




//
// CA_ReceivedPacket()
//
void  ASShare::CA_ReceivedPacket
(
    ASPerson *      pasFrom,
    PS20DATAPACKET  pPacket
)
{
    PCAPACKET       pCAPacket;

    DebugEntry(ASShare::CA_ReceivedPacket);

    ValidatePerson(pasFrom);

    pCAPacket = (PCAPACKET)pPacket;

    switch (pCAPacket->msg)
    {
        case CA_MSG_NOTIFY_STATE:
            CAHandleNewState(pasFrom, (PCANOTPACKET)pPacket);
            break;

        default:
            // Ignore for now -- old 2.x messages
            break;
    }

    DebugExitVOID(ASShare::CA_ReceivedPacket);
}



//
// CA30_ReceivedPacket()
//
void ASShare::CA30_ReceivedPacket
(
    ASPerson *      pasFrom,
    PS20DATAPACKET  pPacket
)
{
    LPBYTE          pCAPacket;

    DebugEntry(ASShare::CA30_ReceivedPacket);

    pCAPacket = (LPBYTE)pPacket + sizeof(CA30PACKETHEADER);

    switch (((PCA30PACKETHEADER)pPacket)->msg)
    {
        // From VIEWER (remote) to HOST (us)
        case CA_REQUEST_TAKECONTROL:
        {
            CAHandleRequestTakeControl(pasFrom, (PCA_RTC_PACKET)pCAPacket);
            break;
        }

        // From HOST (remote) to VIEWER (us)
        case CA_REPLY_REQUEST_TAKECONTROL:
        {
            CAHandleReplyRequestTakeControl(pasFrom, (PCA_REPLY_RTC_PACKET)pCAPacket);
            break;
        }

        // From HOST (remote) to VIEWER (us)
        case CA_REQUEST_GIVECONTROL:
        {
            CAHandleRequestGiveControl(pasFrom, (PCA_RGC_PACKET)pCAPacket);
            break;
        }

        // From VIEWER (remote) to HOST (us)
        case CA_REPLY_REQUEST_GIVECONTROL:
        {
            CAHandleReplyRequestGiveControl(pasFrom, (PCA_REPLY_RGC_PACKET)pCAPacket);
            break;
        }

        // From CONTROLLER (remote) to HOST (us)
        case CA_PREFER_PASSCONTROL:
        {
            CAHandlePreferPassControl(pasFrom, (PCA_PPC_PACKET)pCAPacket);
            break;
        }



        // From CONTROLLER (remote) to HOST (us)
        case CA_INFORM_RELEASEDCONTROL:
        {
            CAHandleInformReleasedControl(pasFrom, (PCA_INFORM_PACKET)pCAPacket);
            break;
        }

        // From HOST (remote) to CONTROLLER (us)
        case CA_INFORM_REVOKEDCONTROL:
        {
            CAHandleInformRevokedControl(pasFrom, (PCA_INFORM_PACKET)pCAPacket);
            break;
        }

        default:
        {
            WARNING_OUT(("CA30_ReceivedPacket: unrecognized message %d",
                ((PCA30PACKETHEADER)pPacket)->msg));
            break;
        }
    }

    DebugExitVOID(ASShare::CA30_ReceivedPacket);
}



//
// CANewRequestID()
//
// Returns a new token.  It uses the current value, fills in the new one, and
// also returns the new one.  We wrap around if necessary.  ZERO is never
// valid.  Note that this is a unique identifier only to us.
//
// It is a stamp for the control operation.  Since you can't be controlling
// and controlled at the same time, we have one stamp for all ops.
//
UINT ASShare::CANewRequestID(void)
{
    DebugEntry(ASShare::CANewRequestID);

    ++(m_pasLocal->m_caControlID);
    if (m_pasLocal->m_caControlID == 0)
    {
        ++(m_pasLocal->m_caControlID);
    }

    DebugExitDWORD(ASShare::CANewRequestID, m_pasLocal->m_caControlID);
    return(m_pasLocal->m_caControlID);
}



//
// CA_ViewStarting()
// Called when a REMOTE starts hosting
//
// We only do anything if it's a 2.x node since they could be cooperating
// but not hosting.
//
BOOL ASShare::CA_ViewStarting(ASPerson * pasPerson)
{
    DebugEntry(ASShare::CA_ViewStarting);

    DebugExitBOOL(ASShare::CA_ViewStarting, TRUE);
    return(TRUE);
}


//
// CA_ViewEnded()
// Called when a REMOTE stopped hosting
//
void ASShare::CA_ViewEnded(ASPerson * pasPerson)
{
    PCAREQUEST  pRequest;
    PCAREQUEST  pNext;

    DebugEntry(ASShare::CA_ViewEnded);

    //
    // Clear any control stuff we are a part of where they are the host
    //
    CA_ClearLocalState(CACLEAR_VIEW, pasPerson, FALSE);

    //
    // Clear any control stuff involving remotes
    //
    if (pasPerson->m_caControlledBy)
    {
        ASSERT(pasPerson->m_caControlledBy != m_pasLocal);

        CAClearHostState(pasPerson, NULL);
        ASSERT(!pasPerson->m_caControlledBy);
    }

    pasPerson->m_caAllowControl = FALSE;

    //
    // Clean up outstanding control packets to this person
    //
    pRequest = (PCAREQUEST)COM_BasedListFirst(&m_caQueuedMsgs, FIELD_OFFSET(CAREQUEST, chain));
    while (pRequest)
    {
        pNext = (PCAREQUEST)COM_BasedListNext(&m_caQueuedMsgs, pRequest,
            FIELD_OFFSET(CAREQUEST, chain));

        if (pRequest->destID == pasPerson->mcsID)
        {
            //
            // Delete messages sent by us to this person who is hosting
            //
            switch (pRequest->msg)
            {
                case CA_REQUEST_TAKECONTROL:
                case CA_PREFER_PASSCONTROL:
                case CA_REPLY_REQUEST_GIVECONTROL:
                    WARNING_OUT(("Deleting viewer control message %d, person [%d] stopped hosting",
                            pRequest->msg, pasPerson->mcsID));
                    COM_BasedListRemove(&pRequest->chain);
                    delete pRequest;
                    break;
            }
        }

        pRequest = pNext;
    }

    DebugExitVOID(ASView::CA_ViewEnded);
}

//
// CA_PartyLeftShare()
//
void ASShare::CA_PartyLeftShare(ASPerson * pasPerson)
{
    DebugEntry(ASShare::CA_PartyLeftShare);

    ValidatePerson(pasPerson);

    //
    // We must have cleaned up hosting info for this person already.
    // So it can't be controlled or controllable.
    //
    ASSERT(!pasPerson->m_caAllowControl);
    ASSERT(!pasPerson->m_caControlledBy);

    if (pasPerson != m_pasLocal)
    {
        PCAREQUEST  pRequest;
        PCAREQUEST  pNext;

        //
        // Clear any control stuff we are a part of where they are the
        // viewer.
        //
        CA_ClearLocalState(CACLEAR_HOST, pasPerson, FALSE);

        //
        // Clear any control stuff involving remotes
        //
        if (pasPerson->m_caInControlOf)
        {
            ASSERT(pasPerson->m_caInControlOf != m_pasLocal);
            CAClearHostState(pasPerson->m_caInControlOf, NULL);
        }

        //
        // Clean up outgoing packets meant for this person.
        //
        pRequest = (PCAREQUEST)COM_BasedListFirst(&m_caQueuedMsgs, FIELD_OFFSET(CAREQUEST, chain));
        while (pRequest)
        {
            pNext = (PCAREQUEST)COM_BasedListNext(&m_caQueuedMsgs, pRequest,
                FIELD_OFFSET(CAREQUEST, chain));

            //
            // This doesn't need to know if it's a 2.x or 3.0 request,
            // simply remove queued packets intended for somebody leaving.
            //
            // Only GRANTED_CONTROL requests will have non-zero destIDs of
            // the 2.x packets.
            //
            if (pRequest->destID == pasPerson->mcsID)
            {
                WARNING_OUT(("Freeing outgoing RESPONSE to node [%d]", pasPerson->mcsID));

                COM_BasedListRemove(&(pRequest->chain));
                delete pRequest;
            }

            pRequest = pNext;
        }

        ASSERT(m_caWaitingForReplyFrom != pasPerson);
    }
    else
    {
        //
        // When our waiting for/controlled dude stopped sharing, we should
        // have cleaned this goop up.
        //
        ASSERT(!pasPerson->m_caInControlOf);
        ASSERT(!pasPerson->m_caControlledBy);
        ASSERT(!m_caWaitingForReplyFrom);
        ASSERT(!m_caWaitingForReplyMsg);

        //
        // There should be NO outgoing control requests
        //
        ASSERT(COM_BasedListIsEmpty(&(m_caQueuedMsgs)));
    }

    DebugExitVOID(ASShare::CA_PartyLeftShare);
}



//
// CA_Periodic() -> SHARE STUFF
//
void  ASShare::CA_Periodic(void)
{
    DebugEntry(ASShare::CA_Periodic);

    //
    // Flush as many queued outgoing messages as we can
    //
    CAFlushOutgoingPackets();

    DebugExitVOID(ASShare::CA_Periodic);
}



//
// CA_SyncAlreadyHosting()
//
void ASHost::CA_SyncAlreadyHosting(void)
{
    DebugEntry(ASHost::CA_SyncAlreadyHosting);

    m_caRetrySendState          = TRUE;

    DebugExitVOID(ASHost::CA_SyncAlreadyHosting);
}


//
// CA_Periodic() -> HOSTING STUFF
//
void ASHost::CA_Periodic(void)
{
    DebugEntry(ASHost::CA_Periodic);

    if (m_caRetrySendState)
    {
        PCANOTPACKET  pPacket;
#ifdef _DEBUG
        UINT            sentSize;
#endif // _DEBUG

        pPacket = (PCANOTPACKET)m_pShare->SC_AllocPkt(PROT_STR_MISC, g_s20BroadcastID,
            sizeof(*pPacket));
        if (!pPacket)
        {
            WARNING_OUT(("CA_Periodic: couldn't broadcast new state"));
        }
        else
        {
            pPacket->header.data.dataType   = DT_CA;
            pPacket->msg                    = CA_MSG_NOTIFY_STATE;

            pPacket->state                  = 0;
            if (m_pShare->m_pasLocal->m_caAllowControl)
                pPacket->state              |= CASTATE_ALLOWCONTROL;

            if (m_pShare->m_pasLocal->m_caControlledBy)
                pPacket->controllerID       = m_pShare->m_pasLocal->m_caControlledBy->mcsID;
            else
                pPacket->controllerID       = 0;

#ifdef _DEBUG
            sentSize =
#endif // _DEBUG
            m_pShare->DCS_CompressAndSendPacket(PROT_STR_MISC, g_s20BroadcastID,
                &(pPacket->header), sizeof(*pPacket));

            m_caRetrySendState = FALSE;
        }
    }

    DebugExitVOID(ASHost::CA_Periodic);
}



//
// CAFlushOutgoingPackets()
//
// This tries to send private packets (not broadcast notifications) that
// we have accumulated.  It returns TRUE if the outgoing queue is empty.
//
BOOL ASShare::CAFlushOutgoingPackets(void)
{
    BOOL            fEmpty = TRUE;
    PCAREQUEST      pRequest;

    //
    // If we're hosting and haven't yet flushed the HET or CA state,
    // force queueing.
    //
    if (m_hetRetrySendState || (m_pHost && m_pHost->m_caRetrySendState))
    {
        TRACE_OUT(("CAFlushOutgoingPackets:  force queuing, pending HET/CA state broadcast"));
        fEmpty = FALSE;
        DC_QUIT;
    }

    while (pRequest = (PCAREQUEST)COM_BasedListFirst(&m_caQueuedMsgs,
        FIELD_OFFSET(CAREQUEST, chain)))
    {
        //
        // Allocate/send packet
        //
        if (!CASendPacket(pRequest->destID, pRequest->msg,
            &pRequest->req30.packet))
        {
            WARNING_OUT(("CAFlushOutgoingPackets: couldn't send request"));
            fEmpty = FALSE;
            break;
        }

        //
        // Do we do state transitions here or when things are added to queue?
        // requestID, results are calculated when put on queue.  Results can
        // change though based on a future action.
        //

        COM_BasedListRemove(&(pRequest->chain));
        delete pRequest;
    }

DC_EXIT_POINT:
    DebugExitBOOL(CAFlushOutgoingPackets, fEmpty);
    return(fEmpty);
}


//
// CASendPacket()
// This sends a private message (request or response) to the destination.
// If there are queued private messages in front of this one, or we can't
// send it, we add it to the pending queue.
//
// This TRUE if sent.
//
// It's up to the caller to change state info appropriately.
//
BOOL  ASShare::CASendPacket
(
    UINT            destID,
    UINT            msg,
    PCA30P          pData
)
{
    BOOL                fSent = FALSE;
    PCA30PACKETHEADER   pPacket;
#ifdef _DEBUG
    UINT                sentSize;
#endif // _DEBUG

    DebugEntry(ASShare::CASendPacket);

    //
    // Note that CA30P does not include size of header.
    //
    pPacket = (PCA30PACKETHEADER)SC_AllocPkt(PROT_STR_INPUT, destID,
        sizeof(CA30PACKETHEADER) + sizeof(*pData));
    if (!pPacket)
    {
        WARNING_OUT(("CASendPacket: no memory to send %d packet to [%d]",
            msg, destID));
        DC_QUIT;
    }

    pPacket->header.data.dataType   = DT_CA30;
    pPacket->msg                    = msg;
    memcpy(pPacket+1, pData, sizeof(*pData));

#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    DCS_CompressAndSendPacket(PROT_STR_INPUT, destID,
            &(pPacket->header), sizeof(*pPacket));
    TRACE_OUT(("CA30 request packet size: %08d, sent %08d", sizeof(*pPacket), sentSize));

    fSent = TRUE;

DC_EXIT_POINT:

    DebugExitBOOL(ASShare::CASendPacket, fSent);
    return(fSent);
}




//
// CAQueueSendPacket()
// This flushes pending queued requests if there are any, then tries to
// send this one.  If it can't, we add it to the queue.  If there's not any
// memory even for that, we return an error about it.
//
BOOL ASShare::CAQueueSendPacket
(
    UINT            destID,
    UINT            msg,
    PCA30P          pPacketSend
)
{
    BOOL            rc = TRUE;
    PCAREQUEST      pCARequest;

    DebugEntry(ASShare::CAQueueSendPacket);

    //
    // These must go out in order.  So if any queued messages are still
    // present, those must be sent first.
    //
    if (!CAFlushOutgoingPackets() ||
        !CASendPacket(destID, msg, pPacketSend))
    {
        //
        // We must queue this.
        //
        TRACE_OUT(("CAQueueSendPacket: queuing request for send later"));

        pCARequest = new CAREQUEST;
        if (!pCARequest)
        {
            ERROR_OUT(("CAQueueSendPacket: can't even allocate memory to queue request; must fail"));
            rc = FALSE;
        }
        else
        {
            SET_STAMP(pCARequest, CAREQUEST);

            pCARequest->destID                  = destID;
            pCARequest->msg                     = msg;
            pCARequest->req30.packet        = *pPacketSend;

            //
            // Stick this at the end of the queue
            //
            COM_BasedListInsertBefore(&(m_caQueuedMsgs), &(pCARequest->chain));
        }
    }

    DebugExitBOOL(ASShare::CAQueueSendPacket, rc);
    return(rc);
}



//
// CALangToggle()
//
// This temporarily turns off the keyboard language toggle key, so that a
// remote controlling us doesn't inadvertently change it.  When we stop being
// controlled, we put it back.
//
void  ASShare::CALangToggle(BOOL fBackOn)
{
    //
    // Local Variables
    //
    LONG        rc;
    HKEY        hkeyToggle;
    BYTE        regValue[2];
    DWORD       cbRegValue;
    DWORD       dwType;
    LPCSTR      szValue;

    DebugEntry(ASShare::CALangToggle);

    szValue = (g_asWin95) ? NULL : LANGUAGE_TOGGLE_KEY_VAL;

    if (fBackOn)
    {
        //
        // We are gaining control of our local keyboard again - we restore the
        // language togging functionality.
        //
        // We must directly access the registry to accomplish this.
        //
        if (m_caToggle != LANGUAGE_TOGGLE_NOT_PRESENT)
        {
            rc = RegOpenKey(HKEY_CURRENT_USER, LANGUAGE_TOGGLE_KEY,
                        &hkeyToggle);

            if (rc == ERROR_SUCCESS)
            {
                //
                // Clear the value for this key.
                //
                regValue[0] = m_caToggle;
                regValue[1] = '\0';                  // ensure NUL termination

                //
                // Restore the value.
                //
                RegSetValueEx(hkeyToggle, szValue, 0, REG_SZ,
                    regValue, sizeof(regValue));

                //
                // We need to inform the system about this change.  We do not
                // tell any other apps about this (ie do not set any of the
                // notification flags as the last parm)
                //
                SystemParametersInfo(SPI_SETLANGTOGGLE, 0, 0, 0);
            }

            RegCloseKey(hkeyToggle);
        }
    }
    else
    {
        //
        // We are losing control of our keyboard - ensure that remote key
        // events will not change our local keyboard settings by disabling the
        // keyboard language toggle.
        //
        // We must directly access the registry to accomplish this.
        //
        rc = RegOpenKey(HKEY_CURRENT_USER, LANGUAGE_TOGGLE_KEY,
                    &hkeyToggle);

        if (rc == ERROR_SUCCESS)
        {
            cbRegValue = sizeof(regValue);

            rc = RegQueryValueEx(hkeyToggle, szValue, NULL,
                &dwType, regValue, &cbRegValue);

            if (rc == ERROR_SUCCESS)
            {
                m_caToggle = regValue[0];

                //
                // Clear the value for this key.
                //
                regValue[0] = '3';
                regValue[1] = '\0';                  // ensure NUL termination

                //
                // Clear the value.
                //
                RegSetValueEx(hkeyToggle, szValue, 0, REG_SZ,
                    regValue, sizeof(regValue));

                //
                // We need to inform the system about this change.  We do not
                // tell any other apps about this (ie do not set any of the
                // notification flags as the last parm)
                //
                SystemParametersInfo(SPI_SETLANGTOGGLE, 0, 0, 0);
            }
            else
            {
                m_caToggle = LANGUAGE_TOGGLE_NOT_PRESENT;
            }

            RegCloseKey(hkeyToggle);
        }
    }

    DebugExitVOID(ASShare::CALangToggle);
}



//
// CAStartControlled()
//
void ASShare::CAStartControlled
(
    ASPerson *  pasInControl,
    UINT        controlID
)
{
    DebugEntry(ASShare::CAStartControlled);

    ValidatePerson(pasInControl);

    //
    // Undo last known state of remote
    //
    CAClearRemoteState(pasInControl);

    //
    // Get any VIEW frame UI out of the way
    //
    VIEWStartControlled(TRUE);

    ASSERT(!m_pasLocal->m_caControlledBy);
    m_pasLocal->m_caControlledBy = pasInControl;

    ASSERT(!pasInControl->m_caInControlOf);
    pasInControl->m_caInControlOf = m_pasLocal;

    ASSERT(!pasInControl->m_caControlID);
    ASSERT(controlID);
    pasInControl->m_caControlID = controlID;

    //
    // Notify IM.
    //
    IM_Controlled(pasInControl);

    //
    // Disable language toggling.
    //
    CALangToggle(FALSE);

    ASSERT(m_pHost);
    m_pHost->CM_Controlled(pasInControl);

    //
    // Notify the UI.  Pass GCCID of controller
    //
    DCS_NotifyUI(SH_EVT_STARTCONTROLLED, pasInControl->cpcCaps.share.gccID, 0);

    //
    // Broadcast new state
    //
    m_pHost->m_caRetrySendState = TRUE;
    m_pHost->CA_Periodic();

    DebugExitVOID(ASShare::CAStartControlled);
}



//
// CAStopControlled()
//
void ASShare::CAStopControlled(void)
{
    ASPerson *  pasControlledBy;

    DebugEntry(ASShare::CAStopControlled);

    pasControlledBy = m_pasLocal->m_caControlledBy;
    ValidatePerson(pasControlledBy);

    m_pasLocal->m_caControlledBy        = NULL;

    ASSERT(pasControlledBy->m_caInControlOf == m_pasLocal);
    pasControlledBy->m_caInControlOf    = NULL;

    ASSERT(pasControlledBy->m_caControlID);
    pasControlledBy->m_caControlID      = 0;

    //
    // Notify IM.
    //
    IM_Controlled(NULL);

    //
    // Restore language toggling functionality.
    //
    CALangToggle(TRUE);

    ASSERT(m_pHost);
    m_pHost->CM_Controlled(NULL);

    VIEWStartControlled(FALSE);


    //
    // Notify the UI
    //
    DCS_NotifyUI(SH_EVT_STOPCONTROLLED, pasControlledBy->cpcCaps.share.gccID, 0);

    //
    // Broadcast the new state
    //
    m_pHost->m_caRetrySendState = TRUE;
    m_pHost->CA_Periodic();

    DebugExitVOID(ASShare::CAStopControlled);
}


//
// CAStartInControl()
//
void ASShare::CAStartInControl
(
    ASPerson *  pasControlled,
    UINT        controlID
)
{
    DebugEntry(ASShare::CAStartInControl);

    ValidatePerson(pasControlled);

    //
    // Undo last known state of host
    //
    CAClearRemoteState(pasControlled);

    ASSERT(!m_pasLocal->m_caInControlOf);
    m_pasLocal->m_caInControlOf = pasControlled;

    ASSERT(!pasControlled->m_caControlledBy);
    pasControlled->m_caControlledBy = m_pasLocal;

    ASSERT(!pasControlled->m_caControlID);
    ASSERT(controlID);
    pasControlled->m_caControlID = controlID;

    ASSERT(!g_lpimSharedData->imControlled);
    IM_InControl(pasControlled);

    VIEW_InControl(pasControlled, TRUE);

    //
    // Pass GCC ID of node we're controlling
    //
    DCS_NotifyUI(SH_EVT_STARTINCONTROL, pasControlled->cpcCaps.share.gccID, 0);

    DebugExitVOID(ASShare::CAStartInControl);
}


//
// CAStopInControl()
//
void ASShare::CAStopInControl(void)
{
    ASPerson *  pasInControlOf;

    DebugEntry(ASShare::CAStopInControl);

    pasInControlOf = m_pasLocal->m_caInControlOf;
    ValidatePerson(pasInControlOf);

    m_pasLocal->m_caInControlOf         = NULL;

    ASSERT(pasInControlOf->m_caControlledBy == m_pasLocal);
    pasInControlOf->m_caControlledBy    = NULL;

    ASSERT(pasInControlOf->m_caControlID);
    pasInControlOf->m_caControlID       = 0;

    ASSERT(!g_lpimSharedData->imControlled);
    IM_InControl(NULL);

    VIEW_InControl(pasInControlOf, FALSE);

    DCS_NotifyUI(SH_EVT_STOPINCONTROL, pasInControlOf->cpcCaps.share.gccID, 0);

    DebugExitVOID(ASShare::CAStopInControl);
}


//
// CA_AllowControl()
// Allows/disallows remotes from controlling us.
//
void ASShare::CA_AllowControl(BOOL fAllow)
{
    DebugEntry(ASShare::CA_AllowControl);

    if (!m_pHost)
    {
        WARNING_OUT(("CA_AllowControl: ignoring, we aren't hosting"));
        DC_QUIT;
    }

    if (fAllow != m_pasLocal->m_caAllowControl)
    {
        if (!fAllow)
        {
            // Undo pending control/control queries/being controlled stuff
            CA_ClearLocalState(CACLEAR_HOST, NULL, TRUE);
        }

        m_pasLocal->m_caAllowControl = fAllow;

        DCS_NotifyUI(SH_EVT_CONTROLLABLE, fAllow, 0);

        m_pHost->m_caRetrySendState = TRUE;
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA_AllowControl);
}





//
// CA_HostEnded()
//
// When we stop hosting, we do not need to flush queued control
// responses.  But we need to delete them!
//
void ASHost::CA_HostEnded(void)
{
    PCAREQUEST  pCARequest;
    PCAREQUEST  pCANext;

    DebugEntry(ASHost::CA_HostEnded);

    m_pShare->CA_ClearLocalState(CACLEAR_HOST, NULL, FALSE);

    //
    // Delete now obsolete messages originating from us as host.
    //
    pCARequest = (PCAREQUEST)COM_BasedListFirst(&m_pShare->m_caQueuedMsgs,
        FIELD_OFFSET(CAREQUEST, chain));
    while (pCARequest)
    {
        pCANext = (PCAREQUEST)COM_BasedListNext(&m_pShare->m_caQueuedMsgs, pCARequest,
            FIELD_OFFSET(CAREQUEST, chain));

        switch (pCARequest->msg)
        {
            //
            // Delete messages sent by us when we are hosting.
            //
            case CA_INFORM_PAUSEDCONTROL:
            case CA_INFORM_UNPAUSEDCONTROL:
            case CA_REPLY_REQUEST_TAKECONTROL:
            case CA_REQUEST_GIVECONTROL:
                WARNING_OUT(("Deleting host control message %d, we stopped hosting",
                    pCARequest->msg));
                COM_BasedListRemove(&pCARequest->chain);
                delete pCARequest;
                break;
        }

        pCARequest = pCANext;
    }

    if (m_pShare->m_pasLocal->m_caAllowControl)
    {
        m_pShare->m_pasLocal->m_caAllowControl = FALSE;

        DCS_NotifyUI(SH_EVT_CONTROLLABLE, FALSE, 0);
    }

    DebugExitVOID(ASHost::CA_HostEnded);
}



//
// CA_TakeControl()
//
// Called by viewer to ask to take control of host.  Note parallels to
// CA_GiveControl(), which is called by host to get same result.
//
void ASShare::CA_TakeControl(ASPerson *  pasHost)
{
    DebugEntry(ASShare::CA_TakeControl);

    ValidatePerson(pasHost);
    ASSERT(pasHost != m_pasLocal);

    //
    // If this person isn't hosting or controllable, fail.
    //
    if (!pasHost->m_pView)
    {
        WARNING_OUT(("CA_TakeControl: failing, person [%d] not hosting",
            pasHost->mcsID));
        DC_QUIT;
    }

    if (!pasHost->m_caAllowControl)
    {
        WARNING_OUT(("CA_TakeControl: failing, host [%d] not controllable",
            pasHost->mcsID));
        DC_QUIT;
    }

    //
    // Undo current state.
    //
    CA_ClearLocalState(CACLEAR_ALL, NULL, TRUE);

    //
    // Now take control.
    //
    {
        //
        // 3.0 host
        //
        CA30P   packetSend;

        ZeroMemory(&packetSend, sizeof(packetSend));
        packetSend.rtc.viewerControlID = CANewRequestID();

        if (CAQueueSendPacket(pasHost->mcsID, CA_REQUEST_TAKECONTROL, &packetSend))
        {
            //
            // Now we're in waiting state.
            //
            CAStartWaiting(pasHost, CA_REPLY_REQUEST_TAKECONTROL);
            VIEW_UpdateStatus(pasHost, IDS_STATUS_WAITINGFORCONTROL);
        }
        else
        {
            WARNING_OUT(("CA_TakeControl of [%d]: failing, out of memory", pasHost->mcsID));
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA_TakeControl);
}



//
// CA_CancelTakeControl()
//
void ASShare::CA_CancelTakeControl
(
    ASPerson *  pasHost,
    BOOL        fPacket
)
{
    DebugEntry(ASShare::CA_CancelTakeControl);

    ValidatePerson(pasHost);
    ASSERT(pasHost != m_pasLocal);

    if ((m_caWaitingForReplyFrom        != pasHost) ||
        (m_caWaitingForReplyMsg         != CA_REPLY_REQUEST_TAKECONTROL))
    {
        // We're not waiting for control of this host.
        WARNING_OUT(("CA_CancelTakeControl failing; not waiting to take control of [%d]",
            pasHost->mcsID));
        DC_QUIT;
    }

    ASSERT(pasHost->m_caControlID == 0);

    if (fPacket)
    {
        CA30P   packetSend;

        ZeroMemory(&packetSend, sizeof(packetSend));
        packetSend.inform.viewerControlID   = m_pasLocal->m_caControlID;
        packetSend.inform.hostControlID     = pasHost->m_caControlID;

        if (!CAQueueSendPacket(pasHost->mcsID, CA_INFORM_RELEASEDCONTROL,
            &packetSend))
        {
            WARNING_OUT(("Couldn't tell node [%d] we're no longer waiting for control",
                pasHost->mcsID));
        }
    }

    m_caWaitingForReplyFrom     = NULL;
    m_caWaitingForReplyMsg      = 0;

    VIEW_UpdateStatus(pasHost, IDS_STATUS_NONE);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA_CancelTakeControl);
}



//
// CA_ReleaseControl()
//
void ASShare::CA_ReleaseControl
(
    ASPerson *  pasHost,
    BOOL        fPacket
)
{
    DebugEntry(ASShare::CA_ReleaseControl);

    ValidatePerson(pasHost);
    ASSERT(pasHost != m_pasLocal);

    if (pasHost->m_caControlledBy != m_pasLocal)
    {
        // We're not in control of this dude, nothing to do.
        WARNING_OUT(("CA_ReleaseControl failing; not in control of [%d]",
            pasHost->mcsID));
        DC_QUIT;
    }

    ASSERT(!m_caWaitingForReplyFrom);
    ASSERT(!m_caWaitingForReplyMsg);

    if (fPacket)
    {
        CA30P   packetSend;

        ZeroMemory(&packetSend, sizeof(packetSend));
        packetSend.inform.viewerControlID   = m_pasLocal->m_caControlID;
        packetSend.inform.hostControlID     = pasHost->m_caControlID;

        if (!CAQueueSendPacket(pasHost->mcsID, CA_INFORM_RELEASEDCONTROL,
            &packetSend))
        {
            WARNING_OUT(("Couldn't tell node [%d] they're no longer controlled",
                   pasHost->mcsID));
        }
    }

    CAStopInControl();

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA_ReleaseControl);
}



//
// CA_PassControl()
//
void ASShare::CA_PassControl(ASPerson *  pasHost, ASPerson *  pasViewer)
{
    CA30P       packetSend;

    DebugEntry(ASShare::CA_PassControl);

    ValidatePerson(pasHost);
    ValidatePerson(pasViewer);
    ASSERT(pasHost != pasViewer);
    ASSERT(pasHost != m_pasLocal);
    ASSERT(pasViewer != m_pasLocal);

    if (pasHost->m_caControlledBy != m_pasLocal)
    {
        WARNING_OUT(("CA_PassControl: failing, we're not in control of [%d]",
            pasHost->mcsID));
        DC_QUIT;
    }

    ASSERT(!m_caWaitingForReplyFrom);
    ASSERT(!m_caWaitingForReplyMsg);

    ZeroMemory(&packetSend, sizeof(packetSend));
    packetSend.ppc.viewerControlID  = m_pasLocal->m_caControlID;
    packetSend.ppc.hostControlID    = pasHost->m_caControlID;
    packetSend.ppc.mcsPassTo        = pasViewer->mcsID;

    if (CAQueueSendPacket(pasHost->mcsID, CA_PREFER_PASSCONTROL, &packetSend))
    {
        CAStopInControl();
    }
    else
    {
        WARNING_OUT(("Couldn't tell node [%d] we want them to pass control to [%d]",
            pasHost->mcsID, pasViewer->mcsID));
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA_PassControl);
}




//
// CA_GiveControl()
//
// Called by host to ask to grant control to viewer.  Note parallels to
// CA_TakeControl(), which is called by viewer to get same result.
//
void ASShare::CA_GiveControl(ASPerson * pasTo)
{
    CA30P       packetSend;

    DebugEntry(ASShare::CA_GiveControl);

    ValidatePerson(pasTo);
    ASSERT(pasTo != m_pasLocal);

    //
    // If we aren't hosting or controllable, fail.
    //
    if (!m_pHost)
    {
        WARNING_OUT(("CA_GiveControl: failing, we're not hosting"));
        DC_QUIT;
    }

    if (!m_pasLocal->m_caAllowControl)
    {
        WARNING_OUT(("CA_GiveControl: failing, we're not controllable"));
        DC_QUIT;
    }

    //
    // Undo our control state.
    //
    CA_ClearLocalState(CACLEAR_ALL, NULL, TRUE);

    //
    // Now invite control.
    //
    ZeroMemory(&packetSend, sizeof(packetSend));
    packetSend.rgc.hostControlID    = CANewRequestID();
    packetSend.rgc.mcsPassFrom      = 0;

    if (CAQueueSendPacket(pasTo->mcsID, CA_REQUEST_GIVECONTROL, &packetSend))
    {
        //
        // Now we're in waiting state.
        //
        CAStartWaiting(pasTo, CA_REPLY_REQUEST_GIVECONTROL);
    }
    else
    {
        WARNING_OUT(("CA_GiveControl of [%d]: failing, out of memory", pasTo->mcsID));
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA_GiveControl);
}



//
// CA_CancelGiveControl()
// Cancels an invite TAKE or PASS request.
//
void ASShare::CA_CancelGiveControl
(
    ASPerson *  pasTo,
    BOOL        fPacket
)
{
    DebugEntry(ASShare::CA_CancelGiveControl);

    ValidatePerson(pasTo);
    ASSERT(pasTo != m_pasLocal);

    //
    // Have we invited this person, and are we now waiting for a response?
    //
    if ((m_caWaitingForReplyFrom        != pasTo)   ||
        (m_caWaitingForReplyMsg         != CA_REPLY_REQUEST_GIVECONTROL))
    {
        // We're not waiting to be controlled by this viewer.
        WARNING_OUT(("CA_CancelGiveControl failing; not waiting to give control to [%d]",
            pasTo->mcsID));
        DC_QUIT;
    }

    ASSERT(!pasTo->m_caControlID);

    if (fPacket)
    {
        CA30P   packetSend;

        ZeroMemory(&packetSend, sizeof(packetSend));
        packetSend.inform.viewerControlID   = pasTo->m_caControlID;
        packetSend.inform.hostControlID     = m_pasLocal->m_caControlID;

        if (!CAQueueSendPacket(pasTo->mcsID, CA_INFORM_REVOKEDCONTROL,
            &packetSend))
        {
            WARNING_OUT(("Couldn't tell node [%d] they're no longer invited to control us",
               pasTo->mcsID));
        }
    }

    m_caWaitingForReplyFrom     = NULL;
    m_caWaitingForReplyMsg      = 0;

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA_CancelGiveControl);
}




//
// CA_RevokeControl()
// Takes control back.  If we're cleaning up (we've stopped hosting or
//
//
void ASShare::CA_RevokeControl
(
    ASPerson *  pasInControl,
    BOOL        fPacket
)
{
    CA30P       packetSend;
    PCAREQUEST  pRequest;

    DebugEntry(ASShare::CA_RevokeControl);

    //
    // If the response to pasController is still queued, simply delete it.
    // There should NOT be any CARESULT_CONFIRMED responses left.
    //
    // Otherwise, if it wasn't found, we must send a packet.
    //
    ValidatePerson(pasInControl);
    ASSERT(pasInControl != m_pasLocal);

    if (pasInControl != m_pasLocal->m_caControlledBy)
    {
        WARNING_OUT(("CA_RevokeControl: node [%d] not in control of us",
            pasInControl->mcsID));
        DC_QUIT;
    }

    //
    // Take control back if we're being controlled
    //
    if (fPacket)
    {
        //
        // Regardless of whether we can queue or not, we get control back!
        // Note that we use the controller's request ID, so he knows if
        // this is still applicable.
        //
        ZeroMemory(&packetSend, sizeof(packetSend));
        packetSend.inform.viewerControlID  = pasInControl->m_caControlID;
        packetSend.inform.hostControlID    = m_pasLocal->m_caControlID;

        if (!CAQueueSendPacket(pasInControl->mcsID, CA_INFORM_REVOKEDCONTROL,
            &packetSend))

        {
            WARNING_OUT(("Couldn't tell node [%d] they're no longer in control",
                pasInControl->mcsID));
        }
    }

    CAStopControlled();

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA_RevokeControl);
}




//
// CAHandleRequestTakeControl()
//      WE are HOST, REMOTE is VIEWER
// Handles incoming take control request.  If our state is good, we accept.
//
void ASShare::CAHandleRequestTakeControl
(
    ASPerson *      pasViewer,
    PCA_RTC_PACKET  pPacketRecv
)
{
    UINT            result = CARESULT_CONFIRMED;

    DebugEntry(ASShare::CAHandleRequestTakeControl);

    ValidatePerson(pasViewer);

    //
    // If we aren't hosting, or haven't turned allow control on, we're
    // not controllable.
    //
    if (!m_pHost || !m_pasLocal->m_caAllowControl)
    {
        result = CARESULT_DENIED_WRONGSTATE;
        goto RESPOND_PACKET;
    }

    //
    // Are we doing something else right now?  Waiting to hear back about
    // something?
    //

    if (m_caWaitingForReplyFrom)
    {
        result = CARESULT_DENIED_BUSY;
        goto RESPOND_PACKET;
    }

    if (m_caQueryDlg)
    {
        result = CARESULT_DENIED_BUSY;
        goto RESPOND_PACKET;
    }

    //
    // LAURABU TEMPORARY:
    // In a bit, if we're controlled when a new control request comes in,
    // pause control then allow host to handle it.
    //
    if (m_pasLocal->m_caControlledBy)
    {
        result = CARESULT_DENIED_BUSY;
        goto RESPOND_PACKET;
    }


    //
    // Try to put up query dialog
    //
    if (!CAStartQuery(pasViewer, CA_REQUEST_TAKECONTROL, (PCA30P)pPacketRecv))
    {
        result = CARESULT_DENIED;
    }

RESPOND_PACKET:
    if (result != CARESULT_CONFIRMED)
    {
        // Instant failure.
        CACompleteRequestTakeControl(pasViewer, pPacketRecv, result);
    }
    else
    {
        //
        // We're in a waiting state.  CACompleteRequestTakeControl() will
        // complete later or the request will just go away.
        //
    }

    DebugExitVOID(ASShare::CAHandleRequestTakeControl);
}



//
// CACompleteRequestTakeControl()
//      WE are HOST, REMOTE is VIEWER
// Completes the take control request.
//
void ASShare::CACompleteRequestTakeControl
(
    ASPerson *      pasFrom,
    PCA_RTC_PACKET  pPacketRecv,
    UINT            result
)
{
    CA30P           packetSend;

    DebugEntry(ASShare::CACompleteRequestTakeControl);

    ValidatePerson(pasFrom);

    ZeroMemory(&packetSend, sizeof(packetSend));
    packetSend.rrtc.viewerControlID     = pPacketRecv->viewerControlID;
    packetSend.rrtc.result              = result;

    if (result == CARESULT_CONFIRMED)
    {
        packetSend.rrtc.hostControlID   = CANewRequestID();
    }

    if (CAQueueSendPacket(pasFrom->mcsID, CA_REPLY_REQUEST_TAKECONTROL, &packetSend))
    {
        if (result == CARESULT_CONFIRMED)
        {
            // Clear current state, whatever that is.
            CA_ClearLocalState(CACLEAR_ALL, NULL, TRUE);

            // We are now controlled by the sender.
            CAStartControlled(pasFrom, pPacketRecv->viewerControlID);
        }
        else
        {
            WARNING_OUT(("Denying REQUEST TAKE CONTROL from [%d] with reason %d",
                pasFrom->mcsID, result));
        }
    }
    else
    {
        WARNING_OUT(("Reply to REQUEST TAKE CONTROL from [%d] failing, out of memory",
            pasFrom->mcsID));
    }

    DebugExitVOID(ASShare::CACompleteRequestTakeControl);
}



//
// CAHandleReplyRequestTakeControl()
//      WE are VIEWER, REMOTE is HOST
// Handles reply to previous take control request.
//
void ASShare::CAHandleReplyRequestTakeControl
(
    ASPerson *              pasHost,
    PCA_REPLY_RTC_PACKET    pPacketRecv
)
{
    DebugEntry(ASShare::CAHandleReplyRequestTakeControl);

    ValidatePerson(pasHost);

    if (pPacketRecv->result == CARESULT_CONFIRMED)
    {
        // On success, should have valid op ID.
        ASSERT(pPacketRecv->hostControlID);
    }
    else
    {
        // On failure, should have invalid op ID.
        ASSERT(!pPacketRecv->hostControlID);
    }

    //
    // Is this response for the current control op?
    //
    if ((m_caWaitingForReplyFrom        != pasHost) ||
        (m_caWaitingForReplyMsg         != CA_REPLY_REQUEST_TAKECONTROL))
    {
        WARNING_OUT(("Ignoring TAKE CONTROL REPLY from [%d], not waiting for one",
            pasHost->mcsID));
        DC_QUIT;
    }

    if (pPacketRecv->viewerControlID    != m_pasLocal->m_caControlID)
    {
        WARNING_OUT(("Ignoring TAKE CONTROL REPLY from [%d], request %d is out of date",
            pasHost->mcsID, pPacketRecv->viewerControlID));
        DC_QUIT;

    }

    ASSERT(!m_caQueryDlg);

    //
    // Cleanup waiting state (for both failure & success)
    //
    CA_CancelTakeControl(pasHost, FALSE);
    ASSERT(!m_caWaitingForReplyFrom);
    ASSERT(!m_caWaitingForReplyMsg);

    if (pPacketRecv->result == CARESULT_CONFIRMED)
    {
        // Success!  We're now in control of the host.

        // Make sure our own state is OK
        ASSERT(!m_pasLocal->m_caControlledBy);
        ASSERT(!m_pasLocal->m_caInControlOf);

        CAStartInControl(pasHost, pPacketRecv->hostControlID);
    }
    else
    {
        UINT        ids;

        WARNING_OUT(("TAKE CONTROL REPLY from host [%d] is failure %d", pasHost->mcsID,
            pPacketRecv->result));

        ids = IDS_ERR_TAKECONTROL_MIN + pPacketRecv->result;
        if ((ids < IDS_ERR_TAKECONTROL_FIRST) || (ids > IDS_ERR_TAKECONTROL_LAST))
            ids = IDS_ERR_TAKECONTROL_LAST;

        VIEW_Message(pasHost, ids);
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CAHandleReplyRequestTakeControl);
}




//
// CAHandleRequestGiveControl()
//      WE are VIEWER, REMOTE is HOST
// Handles incoming take control invite.  If our state is good, we accept.
//
// NOTE how similar this routine is to CAHandleRequestTakeControl().  They
// are inverses of each other.  With RequestTake/Reply sequence, viewer
// initiates, host finishes.  With RequestGive/Reply sequence, host initiates,
// viewer finishes.  Both end up with viewer in control of host when
// completed successfully.
//
void ASShare::CAHandleRequestGiveControl
(
    ASPerson *      pasHost,
    PCA_RGC_PACKET  pPacketRecv
)
{
    UINT            result = CARESULT_CONFIRMED;

    DebugEntry(ASShare::CAHandleRequestGiveControl);

    ValidatePerson(pasHost);

    //
    // Is this node hosting as far as we know.  If not, or has not turned
    // on allow control, we can't do it.
    //
    if (!pasHost->m_pView)
    {
        WARNING_OUT(("GIVE CONTROL went ahead of HOSTING, that's bad"));
        result = CARESULT_DENIED_WRONGSTATE;
        goto RESPOND_PACKET;
    }

    if (!pasHost->m_caAllowControl)
    {
        //
        // We haven't got an AllowControl notification yet, this info is
        // more up to-date.  Make use of it.
        //
        WARNING_OUT(("GIVE CONTROL went ahead of ALLOW CONTROL, that's kind of bad"));
        result = CARESULT_DENIED_WRONGSTATE;
        goto RESPOND_PACKET;
    }


    //
    // Are we doing something else right now?  Waiting to hear back about
    // something?
    //
    if (m_caWaitingForReplyFrom)
    {
        result = CARESULT_DENIED_BUSY;
        goto RESPOND_PACKET;
    }

    if (m_caQueryDlg)
    {
        result = CARESULT_DENIED_BUSY;
        goto RESPOND_PACKET;
    }

    //
    // LAURABU TEMPORARY:
    // In a bit, if we're controlled when a new control request comes in,
    // pause control then allow host to handle it.
    //
    if (m_pasLocal->m_caControlledBy)
    {
        result = CARESULT_DENIED_BUSY;
        goto RESPOND_PACKET;
    }

    //
    // Try to put up query dialog
    //
    if (!CAStartQuery(pasHost, CA_REQUEST_GIVECONTROL, (PCA30P)pPacketRecv))
    {
        result = CARESULT_DENIED;
    }

RESPOND_PACKET:
    if (result != CARESULT_CONFIRMED)
    {
        // Instant failure.
        CACompleteRequestGiveControl(pasHost, pPacketRecv, result);
    }
    else
    {
        //
        // We're in a waiting state.  CACompleteRequestGiveControl() will
        // complete later or the request will just go away.
        //
    }

    DebugExitVOID(ASShare::CAHandleRequestGiveControl);
}



//
// CACompleteRequestGiveControl()
//      WE are VIEWER, REMOTE is HOST
// Completes the invite control request.
//
void ASShare::CACompleteRequestGiveControl
(
    ASPerson *      pasFrom,
    PCA_RGC_PACKET  pPacketRecv,
    UINT            result
)
{
    CA30P           packetSend;

    DebugEntry(ASShare::CACompleteRequestGiveControl);

    ValidatePerson(pasFrom);

    ZeroMemory(&packetSend, sizeof(packetSend));
    packetSend.rrgc.hostControlID       = pPacketRecv->hostControlID;
    packetSend.rrgc.result              = result;

    if (result == CARESULT_CONFIRMED)
    {
        packetSend.rrgc.viewerControlID     = CANewRequestID();
    }

    if (CAQueueSendPacket(pasFrom->mcsID, CA_REPLY_REQUEST_GIVECONTROL, &packetSend))
    {
        //
        // If this is successful, change our state.  We're now in control.
        //
        if (result == CARESULT_CONFIRMED)
        {
            // Clear current state, whatever that is.
            CA_ClearLocalState(CACLEAR_ALL, NULL, TRUE);

            CAStartInControl(pasFrom, pPacketRecv->hostControlID);
        }
        else
        {
            WARNING_OUT(("Denying GIVE CONTROL from [%d] with reason %d",
                pasFrom->mcsID, result));
        }
    }
    else
    {
        WARNING_OUT(("Reply to GIVE CONTROL from [%d] failing, out of memory",
            pasFrom->mcsID));
    }

    DebugExitVOID(ASShare::CACompleteRequestGiveControl);
}




//
// CAHandleReplyRequestGiveControl()
//      WE are HOST, REMOTE is VIEWER
// Handles reply to previous take control invite.
//
void ASShare::CAHandleReplyRequestGiveControl
(
    ASPerson *              pasViewer,
    PCA_REPLY_RGC_PACKET    pPacketRecv
)
{
    DebugEntry(ASShare::CAHandleReplyRequestGiveControl);

    ValidatePerson(pasViewer);

    if (pPacketRecv->result == CARESULT_CONFIRMED)
    {
        // On success, should have valid op ID.
        ASSERT(pPacketRecv->viewerControlID);
    }
    else
    {
        // On failure, should have invalid op ID.
        ASSERT(!pPacketRecv->viewerControlID);
    }

    //
    // Is this response for the latest control op?
    //
    if ((m_caWaitingForReplyFrom        != pasViewer) ||
        (m_caWaitingForReplyMsg         != CA_REPLY_REQUEST_GIVECONTROL))
    {
        WARNING_OUT(("Ignoring GIVE CONTROL REPLY from [%d], not waiting for one",
            pasViewer->mcsID));
        DC_QUIT;
    }

    if (pPacketRecv->hostControlID     != m_pasLocal->m_caControlID)
    {
        WARNING_OUT(("Ignoring GIVE CONTROL REPLY from [%d], request %d is out of date",
            pasViewer->mcsID, pPacketRecv->hostControlID));
        DC_QUIT;
    }

    ASSERT(!m_caQueryDlg);
    ASSERT(m_pHost);
    ASSERT(m_pasLocal->m_caAllowControl);

    //
    // Cleanup waiting state (for both failure & success)
    //
    CA_CancelGiveControl(pasViewer, FALSE);
    ASSERT(!m_caWaitingForReplyFrom);
    ASSERT(!m_caWaitingForReplyMsg);

    if (pPacketRecv->result == CARESULT_CONFIRMED)
    {
        // Success!  We are now controlled by the viewer

        // Make sure our own state is OK
        ASSERT(!m_pasLocal->m_caControlledBy);
        ASSERT(!m_pasLocal->m_caInControlOf);

        CAStartControlled(pasViewer, pPacketRecv->viewerControlID);
    }
    else
    {
        WARNING_OUT(("GIVE CONTROL to viewer [%d] was denied", pasViewer->mcsID));
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CAHandleReplyRequestGiveControl);
}




//
// CAHandlePreferPassControl()
//      WE are HOST, REMOTE is CONTROLLER
// Handles incoming pass control request.  If we are controlled by the
// remote, and end user is cool with it, accept.
//
void ASShare::CAHandlePreferPassControl
(
    ASPerson *      pasController,
    PCA_PPC_PACKET  pPacketRecv
)
{
    ASPerson *      pasNewController;

    DebugEntry(ASShare::CAHandlePreferPassControl);

    ValidatePerson(pasController);

    //
    // If we're not controlled by the requester, ignore it.
    //
    if (m_pasLocal->m_caControlledBy    != pasController)
    {
        WARNING_OUT(("Ignoring PASS CONTROL from [%d], not controlled by him",
            pasController->mcsID));
        DC_QUIT;
    }

    if ((pPacketRecv->viewerControlID   != pasController->m_caControlID) ||
        (pPacketRecv->hostControlID     != m_pasLocal->m_caControlID))
    {
        WARNING_OUT(("Ignoring PASS CONTROL from [%d], request %d %d out of date",
            pasController->mcsID, pPacketRecv->viewerControlID, pPacketRecv->hostControlID));
        DC_QUIT;
    }

    ASSERT(!m_caQueryDlg);
    ASSERT(!m_caWaitingForReplyFrom);
    ASSERT(!m_caWaitingForReplyMsg);

    //
    // OK, the sender is not in control of us anymore.
    //
    CA_RevokeControl(pasController, FALSE);

    // Is the pass to person specified valid?
    pasNewController = SC_PersonFromNetID(pPacketRecv->mcsPassTo);
    if (!pasNewController                       ||
        (pasNewController == pasController)     ||
        (pasNewController == m_pasLocal))
    {
        WARNING_OUT(("PASS CONTROL to [%d] failing, not valid person to pass to",
            pPacketRecv->mcsPassTo));
        DC_QUIT;
    }

    //
    // Try to put up query dialog
    //
    if (!CAStartQuery(pasController, CA_PREFER_PASSCONTROL, (PCA30P)pPacketRecv))
    {
        // Instant failure.  In this case, no packet.
        WARNING_OUT(("Denying PREFER PASS CONTROL from [%d], out of memory",
            pasController->mcsID));
    }
    else
    {
        //
        // We're in a waiting state.  CACompletePreferPassControl() will
        // complete later or the request will just go away.
        //
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CAHandlePreferPassControl);
}



//
// CACompletePreferPassControl()
//      WE are HOST, REMOTE is new potential CONTROLLER
// Completes the prefer pass control request.
//
void ASShare::CACompletePreferPassControl
(
    ASPerson *      pasTo,
    UINT            mcsOrg,
    PCA_PPC_PACKET  pPacketRecv,
    UINT            result
)
{
    CA30P           packetSend;

    DebugEntry(ASShare::CACompletePreferPassControl);

    ValidatePerson(pasTo);

    if (result == CARESULT_CONFIRMED)
    {
        ZeroMemory(&packetSend, sizeof(packetSend));
        packetSend.rgc.hostControlID = CANewRequestID();
        packetSend.rgc.mcsPassFrom   = mcsOrg;

        if (CAQueueSendPacket(pasTo->mcsID, CA_REQUEST_GIVECONTROL,
                &packetSend))
        {
            CA_ClearLocalState(CACLEAR_HOST, NULL, TRUE);

            CAStartWaiting(pasTo, CA_REPLY_REQUEST_GIVECONTROL);
        }
        else
        {
            WARNING_OUT(("Reply to PREFER PASS CONTROL from [%d] to [%d] failing, out of memory",
                mcsOrg, pasTo->mcsID));
        }
    }
    else
    {
        WARNING_OUT(("Denying PREFER PASS CONTROL from [%d] to [%d] with reason %d",
            mcsOrg, pasTo->mcsID, result));
    }

    DebugExitVOID(ASShare::CACompletePreferPassControl);
}




//
// CAHandleInformReleasedControl()
//      WE are HOST, REMOTE is CONTROLLER
//
void ASShare::CAHandleInformReleasedControl
(
    ASPerson *              pasController,
    PCA_INFORM_PACKET       pPacketRecv
)
{
    DebugEntry(ASShare::CAHandleInformReleasedControl);

    ValidatePerson(pasController);

    //
    // Do we currently have a TakeControl dialog up for this request?  If so,
    // take it down but don't send a packet.
    //
    if (m_caQueryDlg                            &&
        (m_caQuery.pasReplyTo    == pasController)   &&
        (m_caQuery.msg      == CA_REQUEST_TAKECONTROL)  &&
        (m_caQuery.request.rtc.viewerControlID  == pPacketRecv->viewerControlID))
    {
        ASSERT(!pPacketRecv->hostControlID);
        CACancelQuery(pasController, FALSE);
        DC_QUIT;
    }

    //
    // If this person isn't in control of us or the control op referred to
    // isn't the current one, ignore.  NULL hostControlID means the person
    // cancelled a request before they heard back from us.
    //

    if (pasController->m_caInControlOf  != m_pasLocal)
    {
        WARNING_OUT(("Ignoring RELEASE CONTROL from [%d], we're not controlled by them",
            pasController->mcsID));
        DC_QUIT;
    }

    if (pPacketRecv->viewerControlID    != pasController->m_caControlID)
    {
        WARNING_OUT(("Ignoring RELEASE CONTROL from [%d], viewer ID out of date",
            pasController->mcsID, pPacketRecv->viewerControlID));
        DC_QUIT;
    }

    if (pPacketRecv->hostControlID && (pPacketRecv->hostControlID != m_pasLocal->m_caControlID))
    {
        WARNING_OUT(("Ignoring RELEASE CONTROL from [%d], host ID out of date",
            pasController->mcsID, pPacketRecv->hostControlID));
        DC_QUIT;
    }


    // Undo control, but no packet gets sent, we're just cleaning up.
    CA_RevokeControl(pasController, FALSE);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CAHandleInformReleasedControl);
}




//
// CAHandleInformRevokedControl()
//      WE are CONTROLLER, REMOTE is HOST
//
void ASShare::CAHandleInformRevokedControl
(
    ASPerson *              pasHost,
    PCA_INFORM_PACKET       pPacketRecv
)
{
    DebugEntry(ASShare::CAHandleInformRevokedControl);

    ValidatePerson(pasHost);

    //
    // Do we currently have a GiveControl dialog up for this request?  If so,
    // take it down but don't send a packet.
    //

    if (m_caQueryDlg                            &&
        (m_caQuery.pasReplyTo        == pasHost)     &&
        (m_caQuery.msg          == CA_REQUEST_GIVECONTROL)   &&
        (m_caQuery.request.rgc.hostControlID == pPacketRecv->hostControlID))
    {
        ASSERT(!pPacketRecv->viewerControlID);
        CACancelQuery(pasHost, FALSE);
        DC_QUIT;
    }

    //
    // If this person isn't controlled by us or the control op referred to
    // isn't the current one, ignore.
    //
    if (pasHost->m_caControlledBy       != m_pasLocal)
    {
        WARNING_OUT(("Ignoring REVOKE CONTROL from [%d], not in control of them",
            pasHost->mcsID));
        DC_QUIT;
    }

    if (pPacketRecv->hostControlID     != pasHost->m_caControlID)
    {
        WARNING_OUT(("Ignoring REVOKE CONTROL from [%d], host ID out of date",
            pasHost->mcsID, pPacketRecv->hostControlID));
        DC_QUIT;
    }

    if (pPacketRecv->viewerControlID && (pPacketRecv->viewerControlID != m_pasLocal->m_caControlID))
    {
        WARNING_OUT(("Ignoring REVOKE CONTROL from [%d], viewer ID out of date",
            pasHost->mcsID, pPacketRecv->viewerControlID));
        DC_QUIT;
    }


    // Undo control, but no packet gets sent, we're just cleaning up.
    CA_ReleaseControl(pasHost, FALSE);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CAHandleInformRevokedControl);
}






void ASShare::CAHandleNewState
(
    ASPerson *      pasHost,
    PCANOTPACKET    pPacket
)
{
    BOOL            caOldAllowControl;
    BOOL            caNewAllowControl;
    ASPerson *      pasController;

    DebugEntry(ASShare::CAHandleNewState);

    //
    // If this node isn't hosting, ignore this.
    //
    ValidatePerson(pasHost);
    ASSERT(pasHost->hetCount);

    //
    // Update controllable state FIRST, so view window changes will
    // reflect it.
    //
    caOldAllowControl           = pasHost->m_caAllowControl;
    caNewAllowControl           = ((pPacket->state & CASTATE_ALLOWCONTROL) != 0);

    if (!caNewAllowControl && (pasHost->m_caControlledBy == m_pasLocal))
    {
        //
        // Fix up bogus notification
        //
        ERROR_OUT(("CA_STATE notification error!  We're in control of [%d] but he says he's not controllable.",
            pasHost->mcsID));
        CA_ReleaseControl(pasHost, FALSE);
    }

    pasHost->m_caAllowControl   = caNewAllowControl;


    // Update/clear controller
    if (!pPacket->controllerID)
    {
        pasController = NULL;
    }
    else
    {
        pasController = SC_PersonFromNetID(pPacket->controllerID);
        if (pasController == pasHost)
        {
            ERROR_OUT(("Bogus controller, same as host [%d]", pPacket->controllerID));
            pasController = NULL;
        }
    }

    if (!CAClearHostState(pasHost, pasController))
    {
        // This failed.  Put back old controllable state.
        pasHost->m_caAllowControl = caOldAllowControl;
    }

    // Force a state change if the allow state has altered
    if (caOldAllowControl != pasHost->m_caAllowControl)
    {
        VIEW_HostStateChange(pasHost);
    }

    DebugExitVOID(ASShare::CAHandleNewState);
}



//
// CAStartWaiting()
// Sets up vars for waiting state.
//
void ASShare::CAStartWaiting
(
    ASPerson *  pasWaitForReplyFrom,
    UINT        msgWaitForReplyFrom
)
{
    DebugEntry(ASShare::CAStartWaiting);

    ValidatePerson(pasWaitForReplyFrom);
    ASSERT(msgWaitForReplyFrom);

    ASSERT(!m_caWaitingForReplyFrom);
    ASSERT(!m_caWaitingForReplyMsg);

    m_caWaitingForReplyFrom    = pasWaitForReplyFrom;
    m_caWaitingForReplyMsg     = msgWaitForReplyFrom;

    DebugExitVOID(ASShare::CAStartWaiting);
}


//
// CA_ClearLocalState()
//
// Called to reset control state for LOCAL dude.
//
void ASShare::CA_ClearLocalState
(
    UINT        flags,
    ASPerson *  pasRemote,
    BOOL        fPacket
)
{
    DebugEntry(ASShare::CA_ClearLocalState);

    //
    // Clear HOST stuff
    //
    if (flags & CACLEAR_HOST)
    {
        if (m_caWaitingForReplyMsg == CA_REPLY_REQUEST_GIVECONTROL)
        {
            if (!pasRemote || (pasRemote == m_caWaitingForReplyFrom))
            {
                // Kill the outstanding invitation to the remote
                CA_CancelGiveControl(m_caWaitingForReplyFrom, fPacket);
            }
        }

        if (m_caQueryDlg &&
            ((m_caQuery.msg == CA_REQUEST_TAKECONTROL) ||
             (m_caQuery.msg == CA_PREFER_PASSCONTROL)))
        {
            if (!pasRemote || (pasRemote == m_caQuery.pasReplyTo))
            {
                // Kill the user query dialog that's up
                CACancelQuery(m_caQuery.pasReplyTo, fPacket);
            }
        }

        if (m_pasLocal->m_caControlledBy)
        {
            if (!pasRemote || (pasRemote == m_pasLocal->m_caControlledBy))
            {
                CA_RevokeControl(m_pasLocal->m_caControlledBy, fPacket);
                ASSERT(!m_pasLocal->m_caControlledBy);
            }
        }
    }

    //
    // Clear VIEW stuff
    //
    if (flags & CACLEAR_VIEW)
    {
        if (m_caWaitingForReplyMsg == CA_REPLY_REQUEST_TAKECONTROL)
        {
            if (!pasRemote || (pasRemote == m_caWaitingForReplyFrom))
            {
                CA_CancelTakeControl(m_caWaitingForReplyFrom, fPacket);
            }
        }

        if (m_caQueryDlg && (m_caQuery.msg == CA_REQUEST_GIVECONTROL))
        {
            if (!pasRemote || (pasRemote == m_caQuery.pasReplyTo))
            {
                // Kill the user query dialog that's up
                CACancelQuery(m_caQuery.pasReplyTo, fPacket);
            }
        }

        if (m_pasLocal->m_caInControlOf)
        {
            if (!pasRemote || (pasRemote == m_pasLocal->m_caInControlOf))
            {
                CA_ReleaseControl(m_pasLocal->m_caInControlOf, fPacket);
                ASSERT(!m_pasLocal->m_caInControlOf);
            }
        }
    }

    DebugExitVOID(ASShare::CA_ClearLocalState);
}


//
// CAClearRemoteState()
//
// Called to reset all control state for a REMOTE node
//
void ASShare::CAClearRemoteState(ASPerson * pasClear)
{
    DebugEntry(ASShare::CAClearRemoteState);

    if (pasClear->m_caInControlOf)
    {
        CAClearHostState(pasClear->m_caInControlOf, NULL);
        ASSERT(!pasClear->m_caInControlOf);
        ASSERT(!pasClear->m_caControlledBy);
    }
    else if (pasClear->m_caControlledBy)
    {
        CAClearHostState(pasClear, NULL);
        ASSERT(!pasClear->m_caControlledBy);
        ASSERT(!pasClear->m_caInControlOf);
    }

    DebugExitVOID(ASShare:CAClearRemoteState);
}


//
// CAClearHostState()
//
// Called to clean up the mutual pointers when undoing a node's host state.
// We need to undo the previous states:
//      * Clear the previous controller of the host
//      * Clear the previous controller of the controller
//      * Clear the previous controllee of the controller
//
// This may be recursive.
//
// It returns TRUE if the change takes effect, FALSE if it's ignored because
// it involves us and we have more recent information.
//
BOOL ASShare::CAClearHostState
(
    ASPerson *  pasHost,
    ASPerson *  pasController
)
{
    BOOL        rc = FALSE;
    UINT        gccID;

    DebugEntry(ASShare::CAClearHostState);

    ValidatePerson(pasHost);

    //
    // If nothing is changing, do nothing
    //
    if (pasHost->m_caControlledBy == pasController)
    {
        TRACE_OUT(("Ignoring control change; nothing's changing"));
        rc = TRUE;
        DC_QUIT;
    }

    //
    // If the host is us, ignore.
    // Also, if the host isn't hosting yet we got an in control change,
    // ignore it too.
    //
    if ((pasHost == m_pasLocal) ||
        (pasController && !pasHost->hetCount))
    {
        WARNING_OUT(("Ignoring control change; host is us or not sharing"));
        DC_QUIT;
    }

    //
    // UNDO any old state of the controller
    //
    if (pasController)
    {
        if (pasController == m_pasLocal)
        {
            TRACE_OUT(("Ignoring control with us as controller"));
            DC_QUIT;
        }
        else if (pasController->m_caInControlOf)
        {
            ASSERT(!pasController->m_caControlledBy);
            ASSERT(pasController->m_caInControlOf->m_caControlledBy == pasController);
            rc = CAClearHostState(pasController->m_caInControlOf, NULL);
            if (!rc)
            {
                DC_QUIT;
            }
            ASSERT(!pasController->m_caInControlOf);
        }
        else if (pasController->m_caControlledBy)
        {
            ASSERT(!pasController->m_caInControlOf);
            ASSERT(pasController->m_caControlledBy->m_caInControlOf == pasController);
            rc = CAClearHostState(pasController, NULL);
            if (!rc)
            {
                DC_QUIT;
            }
            ASSERT(!pasController->m_caControlledBy);
        }
    }

    //
    // UNDO any old IN CONTROL state of the host
    //
    if (pasHost->m_caInControlOf)
    {
        ASSERT(!pasHost->m_caControlledBy);
        ASSERT(pasHost->m_caInControlOf->m_caControlledBy == pasHost);
        rc = CAClearHostState(pasHost->m_caInControlOf, NULL);
        if (!rc)
        {
            DC_QUIT;
        }
        ASSERT(!pasHost->m_caInControlOf);
    }

    //
    // FINALLY!  Update CONTROLLED BY state of the host
    //

    // Clear OLD ControlledBy
    if (pasHost->m_caControlledBy)
    {
        ASSERT(pasHost->m_caControlledBy->m_caInControlOf == pasHost);
        pasHost->m_caControlledBy->m_caInControlOf = NULL;
    }

    // Set NEW ControlledBy
    pasHost->m_caControlledBy = pasController;
    if (pasController)
    {
        pasController->m_caInControlOf = pasHost;
        gccID = pasController->cpcCaps.share.gccID;
    }
    else
    {
        gccID = 0;
    }

    VIEW_HostStateChange(pasHost);

    //
    // The hosts' controller has changed.  Repaint the shadow cursor with/wo
    // the new initials.
    //
    CM_UpdateShadowCursor(pasHost, pasHost->cmShadowOff, pasHost->cmPos.x,
        pasHost->cmPos.y, pasHost->cmHotSpot.x, pasHost->cmHotSpot.y);

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::CAClearHostState, rc);
    return(rc);
}




//
// CAStartQuery()
//
// This puts up the modeless dialog to query the user about a control
// request.  It will timeout if not handled.
//
BOOL ASShare::CAStartQuery
(
    ASPerson *  pasFrom,
    UINT        msg,
    PCA30P      pReq
)
{
    BOOL        rc = FALSE;

    DebugEntry(ASShare::CAStartQuery);

    ValidatePerson(pasFrom);

    //
    // We have no stacked queries.  If another comes in while the current
    // one is up, it gets an immediate failure busy.
    //
    ASSERT(!m_caQueryDlg);
    ASSERT(!m_caQuery.pasReplyTo);
    ASSERT(!m_caQuery.msg);

    //
    // Setup for new query
    //
    if (msg == CA_PREFER_PASSCONTROL)
    {
        //
        // With forwarding, the person we're going to send a packet to
        // if accepted is not the person who sent us the request.  It's the
        // person we're forwarding to.
        //
        m_caQuery.pasReplyTo = SC_PersonFromNetID(pReq->ppc.mcsPassTo);
        ValidatePerson(m_caQuery.pasReplyTo);
    }
    else
    {
        m_caQuery.pasReplyTo = pasFrom;
    }
    m_caQuery.mcsOrg    = pasFrom->mcsID;
    m_caQuery.msg       = msg;
    m_caQuery.request   = *pReq;

    //
    // If we are unattended, or the requester is unattended, instantly
    // confirm.  That's why we show the window after creating the dialog.
    //
    if ((m_pasLocal->cpcCaps.general.typeFlags & AS_UNATTENDED) ||
        (pasFrom->cpcCaps.general.typeFlags & AS_UNATTENDED))
    {
        CAFinishQuery(CARESULT_CONFIRMED);
        rc = TRUE;
    }
    else
    {
        //
        // If this is a request to us && we're hosting, check auto-accept/
        // auto-reject settings.
        //
        if (m_pHost &&
            ((msg == CA_REQUEST_TAKECONTROL) || (msg == CA_PREFER_PASSCONTROL)))
        {
            if (m_pHost->m_caTempRejectRequests)
            {
                CAFinishQuery(CARESULT_DENIED_BUSY);
                rc = TRUE;
                DC_QUIT;
            }
            else if (m_pHost->m_caAutoAcceptRequests)
            {
                CAFinishQuery(CARESULT_CONFIRMED);
                rc = TRUE;
                DC_QUIT;
            }
        }

        m_caQueryDlg    = CreateDialogParam(g_asInstance,
            MAKEINTRESOURCE(IDD_QUERY), NULL, CAQueryDlgProc, 0);
        if (!m_caQueryDlg)
        {
            ERROR_OUT(("Failed to create query message box from [%d]",
                pasFrom->mcsID));

            m_caQuery.pasReplyTo     = NULL;
            m_caQuery.mcsOrg    = 0;
            m_caQuery.msg       = 0;
        }
        else
        {
            // Success
            rc = TRUE;
        }
    }

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::CAStartQuery, rc);
    return(rc);
}



//
// CAFinishQuery()
//
// Called to finish the query we started, either because of UI or because
// we or the remote are unattended.
//
void ASShare::CAFinishQuery(UINT result)
{
    CA30PENDING     request;

    DebugEntry(ASShare::CAFinishQuery);

    ValidatePerson(m_caQuery.pasReplyTo);

    // Make a copy of our request
    request         = m_caQuery;

    //
    // If we have a dialog up, destroy it NOW.  Completing the request
    // may cause us to be controlled or whatever.  So get the dialog
    // out of the way immediately.
    //
    // Note that destroying ourself will clear the request vars, hence the
    // copy above.
    //
    if (m_caQueryDlg)
    {
        DestroyWindow(m_caQueryDlg);
    }
    else
    {
        m_caQuery.pasReplyTo     = NULL;
        m_caQuery.mcsOrg    = 0;
        m_caQuery.msg       = 0;
    }

    switch (request.msg)
    {
        case CA_REQUEST_TAKECONTROL:
        {
            CACompleteRequestTakeControl(request.pasReplyTo,
                &request.request.rtc, result);
            break;
        }

        case CA_REQUEST_GIVECONTROL:
        {
            CACompleteRequestGiveControl(request.pasReplyTo,
                &request.request.rgc, result);
            break;
        }

        case CA_PREFER_PASSCONTROL:
        {
            CACompletePreferPassControl(request.pasReplyTo,
                request.mcsOrg, &request.request.ppc, result);
            break;
        }

        default:
        {
            ERROR_OUT(("Unrecognized query msg %d", request.msg));
            break;
        }
    }

    DebugExitVOID(ASShare::CAFinishQuery);
}



//
// CA_QueryDlgProc()
//
// Handles querying user dialog
//
INT_PTR CALLBACK CAQueryDlgProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    return(g_asSession.pShare->CA_QueryDlgProc(hwnd, message, wParam, lParam));
}



BOOL ASShare::CA_QueryDlgProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    BOOL        rc = TRUE;

    DebugEntry(CA_QueryDlgProc);

    switch (message)
    {
        case WM_INITDIALOG:
        {
            char    szT[256];
            char    szRes[512];
            char    szShared[64];
            UINT    idsTitle;
            ASPerson *  pasT;
            HDC     hdc;
            HFONT   hfn;
            RECT    rc;
            RECT    rcOwner;

            ValidatePerson(m_caQuery.pasReplyTo);

            pasT = NULL;

            // Set title.
            ASSERT(m_caQuery.msg);
            switch (m_caQuery.msg)
            {
                case CA_REQUEST_TAKECONTROL:
                {
                    idsTitle    = IDS_TITLE_QUERY_TAKECONTROL;

                    if (m_pasLocal->hetCount == HET_DESKTOPSHARED)
                        LoadString(g_asInstance, IDS_DESKTOP_LOWER, szShared, sizeof(szShared));
                    else
                        LoadString(g_asInstance, IDS_PROGRAMS_LOWER, szShared, sizeof(szShared));

                    LoadString(g_asInstance, IDS_MSG_QUERY_TAKECONTROL, szT, sizeof(szT));

                    wsprintf(szRes, szT, m_caQuery.pasReplyTo->scName, szShared);
                    break;
                }

                case CA_REQUEST_GIVECONTROL:
                {
                    if (m_caQuery.pasReplyTo->hetCount == HET_DESKTOPSHARED)
                        LoadString(g_asInstance, IDS_DESKTOP_LOWER, szShared, sizeof(szShared));
                    else
                        LoadString(g_asInstance, IDS_PROGRAMS_LOWER, szShared, sizeof(szShared));

                    if (m_caQuery.request.rgc.mcsPassFrom)
                    {
                        pasT = SC_PersonFromNetID(m_caQuery.request.rgc.mcsPassFrom);
                    }

                    if (pasT)
                    {
                        idsTitle    = IDS_TITLE_QUERY_YIELDCONTROL;

                        LoadString(g_asInstance, IDS_MSG_QUERY_YIELDCONTROL,
                            szT, sizeof(szT));

                        wsprintf(szRes, szT, pasT->scName, m_caQuery.pasReplyTo->scName, szShared);
                    }
                    else
                    {
                        idsTitle    = IDS_TITLE_QUERY_GIVECONTROL;

                        LoadString(g_asInstance, IDS_MSG_QUERY_GIVECONTROL,
                            szT, sizeof(szT));

                        wsprintf(szRes, szT, m_caQuery.pasReplyTo->scName, szShared);
                    }

                    break;
                }

                case CA_PREFER_PASSCONTROL:
                {
                    pasT = SC_PersonFromNetID(m_caQuery.mcsOrg);
                    ValidatePerson(pasT);

                    idsTitle    = IDS_TITLE_QUERY_FORWARDCONTROL;

                    if (m_pasLocal->hetCount == HET_DESKTOPSHARED)
                        LoadString(g_asInstance, IDS_DESKTOP_LOWER, szShared, sizeof(szShared));
                    else
                        LoadString(g_asInstance, IDS_PROGRAMS_LOWER, szShared, sizeof(szShared));

                    LoadString(g_asInstance, IDS_MSG_QUERY_FORWARDCONTROL, szT, sizeof(szT));

                    wsprintf(szRes, szT, pasT->scName, szShared, m_caQuery.pasReplyTo->scName);

                    break;
                }

                default:
                {
                    ERROR_OUT(("Bogus m_caQuery.msg %d", m_caQuery.msg));
                    break;
                }
            }

            LoadString(g_asInstance, idsTitle, szT, sizeof(szT));
            SetWindowText(hwnd, szT);

            // Set message.
            SetDlgItemText(hwnd, CTRL_QUERY, szRes);

            // Center the message vertically
            GetWindowRect(GetDlgItem(hwnd, CTRL_QUERY), &rcOwner);
            MapWindowPoints(NULL, hwnd, (LPPOINT)&rcOwner, 2);

            rc = rcOwner;

            hdc = GetDC(hwnd);
            hfn = (HFONT)SendDlgItemMessage(hwnd, CTRL_QUERY, WM_GETFONT, 0, 0);
            hfn = SelectFont(hdc, hfn);

            DrawText(hdc, szRes, -1, &rc, DT_NOCLIP | DT_EXPANDTABS |
                DT_NOPREFIX | DT_WORDBREAK | DT_CALCRECT);

            SelectFont(hdc, hfn);
            ReleaseDC(hwnd, hdc);

            ASSERT((rc.bottom - rc.top) <= (rcOwner.bottom - rcOwner.top));

            SetWindowPos(GetDlgItem(hwnd, CTRL_QUERY), NULL,
                rcOwner.left,
                ((rcOwner.top + rcOwner.bottom) - (rc.bottom - rc.top)) / 2,
                (rcOwner.right - rcOwner.left),
                rc.bottom - rc.top,
                SWP_NOACTIVATE | SWP_NOZORDER);

            SetTimer(hwnd, IDT_CAQUERY, PERIOD_CAQUERY, 0);

            //
            // Show window, the user will handle
            //
            ShowWindow(hwnd, SW_SHOWNORMAL);
            SetForegroundWindow(hwnd);
            UpdateWindow(hwnd);

            break;
        }

        case WM_COMMAND:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                {
                    CAFinishQuery(CARESULT_CONFIRMED);
                    break;
                }

                case IDCANCEL:
                {
                    CAFinishQuery(CARESULT_DENIED_USER);
                    break;
                }
            }
            break;
        }

        case WM_TIMER:
        {
            if (wParam != IDT_CAQUERY)
            {
                rc = FALSE;
            }
            else
            {
                KillTimer(hwnd, IDT_CAQUERY);

                // Timed out failure.
                CAFinishQuery(CARESULT_DENIED_TIMEDOUT);
            }
            break;
        }

        case WM_DESTROY:
        {
            //
            // Clear pending info
            //
            m_caQueryDlg        = NULL;
            m_caQuery.pasReplyTo     = NULL;
            m_caQuery.mcsOrg    = 0;
            m_caQuery.msg       = 0;
            break;
        }

        default:
        {
            rc = FALSE;
            break;
        }
    }

    DebugExitBOOL(CA_QueryDlgProc, rc);
    return(rc);
}



//
// CACancelQuery()
//
// If a dialog is up for a take control request, it hasn't been handled yet,
// and we get a cancel notification from the viewer, we need to take the
// dialog down WITHOUT generating a response packet.
//
void ASShare::CACancelQuery
(
    ASPerson *  pasFrom,
    BOOL        fPacket
)
{
    DebugEntry(ASShare::CACancelQuery);

    ASSERT(m_caQueryDlg);
    ASSERT(m_caQuery.pasReplyTo == pasFrom);

    if (fPacket)
    {
        // This will send a packet then destroy the dialog
        CAFinishQuery(CARESULT_DENIED);
    }
    else
    {
        // Destroy the dialog
        DestroyWindow(m_caQueryDlg);
    }

    ASSERT(!m_caQueryDlg);
    ASSERT(!m_caQuery.pasReplyTo);
    ASSERT(!m_caQuery.msg);

    DebugExitVOID(ASShare::CACancelQuery);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\globals.cpp ===
#include "precomp.h"


//
// This file generates the storage for our global variables
//
#include <datainit.h>
#include <globals.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\host.cpp ===
#include "precomp.h"


//
// HOST.CPP
// Hosting, local and remote
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE



//
// HET_Init()
//
// Initialization for hosting
//      * window tracking
//      * capabilities
//      * host UI
//
BOOL HET_Init(void)
{
    BOOL        rc = FALSE;
    int         property;
    UINT        i;
    LOGFONT     lf;

    DebugEntry(HET_Init);

    //
    // Initialize T.128 capabilities, whether we can host or not.
    //

    ZeroMemory(&g_cpcLocalCaps, sizeof(g_cpcLocalCaps));
    g_cpcLocalCaps.header.numCapabilities = PROTCAPS_COUNT;


    // PROTCAPS_GENERAL
    // Check for compression setting (useful to debug protocol)
    // You can set CT_PKZIP (1) or none (0) instead of persistent PKZIP,
    // which is the default.
    //
    g_cpcLocalCaps.general.header.capID             = CAPS_ID_GENERAL;
    g_cpcLocalCaps.general.header.capSize           = sizeof(g_cpcLocalCaps.general);

    COM_ReadProfInt(DBG_INI_SECTION_NAME, GDC_INI_COMPRESSION,
            GCT_DEFAULT, &property);
    g_cpcLocalCaps.general.OS                       = CAPS_WINDOWS;
    g_cpcLocalCaps.general.OSVersion                = (g_asWin95 ? CAPS_WINDOWS_95 : CAPS_WINDOWS_NT);

    g_cpcLocalCaps.general.typeFlags                = 0;
    if (g_asOptions & AS_SERVICE)
    {
        g_cpcLocalCaps.general.typeFlags            |= AS_SERVICE;
    }
    if (g_asOptions & AS_UNATTENDED)
    {
        g_cpcLocalCaps.general.typeFlags            |= AS_UNATTENDED;
    }

    g_cpcLocalCaps.general.version                  = CAPS_VERSION_CURRENT;


    //
    // PROTCAPS_SCREEN
    //
    g_cpcLocalCaps.screen.header.capID              = CAPS_ID_SCREEN;
    g_cpcLocalCaps.screen.header.capSize            = sizeof(g_cpcLocalCaps.screen);
    g_cpcLocalCaps.screen.capsSupports1BPP          = CAPS_UNSUPPORTED;
    g_cpcLocalCaps.screen.capsSupports4BPP          = CAPS_SUPPORTED;
    g_cpcLocalCaps.screen.capsSupports8BPP          = CAPS_SUPPORTED;
    g_cpcLocalCaps.screen.capsSupports24BPP         = CAPS_SUPPORTED;
    g_cpcLocalCaps.screen.capsScreenWidth           = (TSHR_UINT16)GetSystemMetrics(SM_CXSCREEN);
    g_cpcLocalCaps.screen.capsScreenHeight          = (TSHR_UINT16)GetSystemMetrics(SM_CYSCREEN);
    g_cpcLocalCaps.screen.capsSupportsDesktopResize = CAPS_SUPPORTED;
    //
    // Set up the V1 and/or V2 Bitmap Compression capabilities.  For the
    // V2.0 protocol, both are supported by default (supporting V1
    // compression allows for negotiation down to V1 protocol systems), but
    // can be overidden in the INI file.
    //
    g_cpcLocalCaps.screen.capsBPP                   = (TSHR_UINT16)g_usrScreenBPP;

    // PROTCAPS_SC
    g_cpcLocalCaps.share.header.capID               = CAPS_ID_SC;
    g_cpcLocalCaps.share.header.capSize             = sizeof(g_cpcLocalCaps.share);
    g_cpcLocalCaps.share.gccID                = 0;


    // PROTCAPS_CM
    g_cpcLocalCaps.cursor.header.capID              = CAPS_ID_CM;
    g_cpcLocalCaps.cursor.header.capSize            = sizeof(g_cpcLocalCaps.cursor);
    g_cpcLocalCaps.cursor.capsSupportsColorCursors  = CAPS_SUPPORTED;
    g_cpcLocalCaps.cursor.capsCursorCacheSize       = TSHR_CM_CACHE_ENTRIES;

    // PROTCAPS_PM
    g_cpcLocalCaps.palette.header.capID             = CAPS_ID_PM;
    g_cpcLocalCaps.palette.header.capSize           = sizeof(g_cpcLocalCaps.palette);
    g_cpcLocalCaps.palette.capsColorTableCacheSize  = TSHR_PM_CACHE_ENTRIES;


    //
    // PROTCAPS_BITMAPCACHE
    //

    g_cpcLocalCaps.bitmaps.header.capID = CAPS_ID_BITMAPCACHE;
    g_cpcLocalCaps.bitmaps.header.capSize = sizeof(g_cpcLocalCaps.bitmaps);

    //
    // SEND BITMAP CACHE
    //
    // The cache is now more in line with what the display driver is doing.
    // The memory size for medium/large is the same.  But large bitmaps are
    // 4x bigger, so there are 1/4 as many.  The # of small bitmaps is the
    // same as the # of medium bitmaps.  Since small bitmaps are 1/4 the
    // size, only 1/4 as much memory is used.
    //

    if (g_sbcEnabled)
    {
        UINT    maxSendBPP;

        ASSERT(g_asbcShuntBuffers[SBC_MEDIUM_TILE_INDEX]);
        ASSERT(g_asbcShuntBuffers[SBC_LARGE_TILE_INDEX]);

        g_cpcLocalCaps.bitmaps.sender.capsSmallCacheNumEntries =
            (TSHR_UINT16)g_asbcShuntBuffers[SBC_MEDIUM_TILE_INDEX]->numEntries;

        g_cpcLocalCaps.bitmaps.sender.capsMediumCacheNumEntries =
            (TSHR_UINT16)g_asbcShuntBuffers[SBC_MEDIUM_TILE_INDEX]->numEntries;

        g_cpcLocalCaps.bitmaps.sender.capsLargeCacheNumEntries =
            (TSHR_UINT16)g_asbcShuntBuffers[SBC_LARGE_TILE_INDEX]->numEntries;

        if (g_usrScreenBPP >= 24)
        {
            maxSendBPP = 24;
        }
        else
        {
            maxSendBPP = 8;
        }

        g_cpcLocalCaps.bitmaps.sender.capsSmallCacheCellSize =
            MP_CACHE_CELLSIZE(MP_SMALL_TILE_WIDTH, MP_SMALL_TILE_WIDTH,
                maxSendBPP);

        g_cpcLocalCaps.bitmaps.sender.capsMediumCacheCellSize =
            MP_CACHE_CELLSIZE(MP_MEDIUM_TILE_WIDTH, MP_MEDIUM_TILE_HEIGHT,
                maxSendBPP);

        g_cpcLocalCaps.bitmaps.sender.capsLargeCacheCellSize =
            MP_CACHE_CELLSIZE(MP_LARGE_TILE_WIDTH, MP_LARGE_TILE_HEIGHT,
                maxSendBPP);
    }
    else
    {
        //
        // We can't use sizes of zero, 2.x nodes will fail if we do.  But
        // we can use a tiny number so they don't allocate huge hunks of
        // memory for no reason.  And 3.0 will treat '1' like '0'.
        //
        g_cpcLocalCaps.bitmaps.sender.capsSmallCacheNumEntries      = 1;
        g_cpcLocalCaps.bitmaps.sender.capsSmallCacheCellSize        = 1;
        g_cpcLocalCaps.bitmaps.sender.capsMediumCacheNumEntries     = 1;
        g_cpcLocalCaps.bitmaps.sender.capsMediumCacheCellSize       = 1;
        g_cpcLocalCaps.bitmaps.sender.capsLargeCacheNumEntries      = 1;
        g_cpcLocalCaps.bitmaps.sender.capsLargeCacheCellSize        = 1;
    }

    TRACE_OUT(("SBC small cache:  %d entries, size %d",
        g_cpcLocalCaps.bitmaps.sender.capsSmallCacheNumEntries,
        g_cpcLocalCaps.bitmaps.sender.capsSmallCacheCellSize));

    TRACE_OUT(("SBC medium cache:  %d entries, size %d",
        g_cpcLocalCaps.bitmaps.sender.capsMediumCacheNumEntries,
        g_cpcLocalCaps.bitmaps.sender.capsMediumCacheCellSize));

    TRACE_OUT(("SBC large cache:  %d entries, size %d",
        g_cpcLocalCaps.bitmaps.sender.capsLargeCacheNumEntries,
        g_cpcLocalCaps.bitmaps.sender.capsLargeCacheCellSize));

    //
    // PROTCAPS_ORDERS
    //
    g_cpcLocalCaps.orders.header.capID      = CAPS_ID_ORDERS;
    g_cpcLocalCaps.orders.header.capSize    = sizeof(g_cpcLocalCaps.orders);

    //
    // Fill in the SaveBitmap capabilities.
    //
    g_cpcLocalCaps.orders.capsSaveBitmapSize         = TSHR_SSI_BITMAP_SIZE;
    g_cpcLocalCaps.orders.capsSaveBitmapXGranularity = TSHR_SSI_BITMAP_X_GRANULARITY;
    g_cpcLocalCaps.orders.capsSaveBitmapYGranularity = TSHR_SSI_BITMAP_Y_GRANULARITY;

    //
    // We support
    //      * R20 Signatures (cell heights, better matching)
    //      * Aspect matching
    //      * Charset/code page matching
    //      * Baseline text orders
    //      * Em Heights
    //      * DeltaX arrays for simulation if font not on remote
    //

    //
    // BOGUS LAURABU BUGBUG
    //
    // Baseline text orders not yet supported in Win95. But that's OK,
    // we don't mark any orders we generate on that platform with
    // NF_BASELINE, so they aren't treated as such.
    //

    g_cpcLocalCaps.orders.capsfFonts =  CAPS_FONT_R20_SIGNATURE |
                                    CAPS_FONT_ASPECT        |
                                    CAPS_FONT_CODEPAGE      |
                                    CAPS_FONT_ALLOW_BASELINE |
                                    CAPS_FONT_EM_HEIGHT     |
                                    CAPS_FONT_OLD_NEED_X    |
                                    CAPS_FONT_NEED_X_SOMETIMES;


    //
    // Fill in which orders we support.
    //

    for (i = 0; i < ORD_NUM_LEVEL_1_ORDERS; i++)
    {
        //
        // Order indices for desktop-scrolling and memblt variants are not
        // to be negotiated by this mechanism... these currently consume
        // 3 order indices which must be excluded from this negotiation.
        //
        if ( (i == ORD_RESERVED_INDEX  ) ||
             (i == ORD_MEMBLT_R2_INDEX ) ||
             (i == ORD_UNUSED_INDEX ) ||
             (i == ORD_MEM3BLT_R2_INDEX) )
        {
            continue;
        }

        g_cpcLocalCaps.orders.capsOrders[i] = ORD_LEVEL_1_ORDERS;
    }

    g_cpcLocalCaps.orders.capsMaxOrderlevel = ORD_LEVEL_1_ORDERS;

    //
    // Fill in encoding capabilities
    //

    //
    // Keep the "encoding disabled" option, it's handy for using our
    // protocol analyzer
    //
    COM_ReadProfInt(DBG_INI_SECTION_NAME, OE2_INI_2NDORDERENCODING,
        CAPS_ENCODING_DEFAULT, &property);
    g_cpcLocalCaps.orders.capsEncodingLevel = (TSHR_UINT16)property;

    //
    // Get the app and desktop icons, big and small
    //
    g_hetASIcon = LoadIcon(g_asInstance, MAKEINTRESOURCE(IDI_SHAREICON));
    if (!g_hetASIcon)
    {
        ERROR_OUT(("HET_Init: Failed to load app icon"));
        DC_QUIT;
    }

    g_hetDeskIcon = LoadIcon(g_asInstance, MAKEINTRESOURCE(IDI_DESKTOPICON));
    if (!g_hetDeskIcon)
    {
        ERROR_OUT(("HET_Init: failed to load desktop icon"));
        DC_QUIT;
    }

    // Get the small icon, created, that we paint on the window bar items
    g_hetASIconSmall = (HICON)LoadImage(g_asInstance, MAKEINTRESOURCE(IDI_SHAREICON),
        IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON),
        LR_DEFAULTCOLOR);
    if (!g_hetASIconSmall)
    {
        ERROR_OUT(("HET_Init: Failed to load app small icon"));
        DC_QUIT;
    }

    g_hetDeskIconSmall = (HICON)LoadImage(g_asInstance, MAKEINTRESOURCE(IDI_DESKTOPICON),
        IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON),
        LR_DEFAULTCOLOR);
    if (!g_hetDeskIconSmall)
    {
        ERROR_OUT(("HET_Init: Failed to load desktop small icon"));
        DC_QUIT;
    }

    //
    // Get the checkmark image
    //
    g_hetCheckBitmap = LoadBitmap(NULL, MAKEINTRESOURCE(OBM_CHECK));
    if (!g_hetCheckBitmap)
    {
        ERROR_OUT(("HET_Init: Failed to load checkmark bitmap"));
        DC_QUIT;
    }

    //
    // Create a bolded font for shared items in the host list
    //
    GetObject(GetStockObject(DEFAULT_GUI_FONT), sizeof(lf), &lf);
    lf.lfWeight += FW_LIGHT;
    g_hetSharedFont = CreateFontIndirect(&lf);
    if (!g_hetSharedFont)
    {
        ERROR_OUT(("HET_Init: Failed to create shared item font"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(HET_Init, rc);
    return(rc);
}



//
// HET_Term()
//
// Cleanup hosting objects
//
void HET_Term(void)
{
    DebugEntry(HET_Term);

    if (g_hetSharedFont != NULL)
    {
        DeleteFont(g_hetSharedFont);
        g_hetSharedFont = NULL;
    }

    if (g_hetCheckBitmap != NULL)
    {
        DeleteBitmap(g_hetCheckBitmap);
        g_hetCheckBitmap = NULL;
    }

    if (g_hetDeskIconSmall != NULL)
    {
        DestroyIcon(g_hetDeskIconSmall);
        g_hetDeskIconSmall = NULL;
    }

    if (g_hetDeskIcon != NULL)
    {
        DestroyIcon(g_hetDeskIcon);
        g_hetDeskIcon = NULL;
    }

    if (g_hetASIconSmall != NULL)
    {
        DestroyIcon(g_hetASIconSmall);
        g_hetASIconSmall = NULL;
    }

    if (g_hetASIcon != NULL)
    {
        DestroyIcon(g_hetASIcon);
        g_hetASIcon = NULL;
    }

    DebugExitVOID(HET_Term);
}



//
// HET_ShareDesktop()
//
void  ASShare::HET_ShareDesktop(void)
{
    ASPerson * pasT;

    DebugEntry(ASShare:HET_ShareDesktop);

    //
    // If we're sharing apps, ignore this.
    //
    if (m_pasLocal->hetCount != 0)
    {
        WARNING_OUT(("Ignoring share desktop request, sharing apps"));
        DC_QUIT;
    }

    TRACE_OUT(("HET_ShareDesktop: starting share"));

    if (!HETStartHosting(TRUE))
    {
        ERROR_OUT(("HET_ShareDesktop cannot start sharing desktop"));
        DC_QUIT;
    }

    //
    // Update the count of hosted entities (ie user-hosted windows)
    //
    HETUpdateLocalCount(HET_DESKTOPSHARED);

    //
    // Get the desktop(s) repainted if anybody's viewing it.
    //
    ASSERT(m_pHost);
    m_pHost->HET_RepaintAll();

DC_EXIT_POINT:
    DebugExitVOID(ASShare::HET_ShareDesktop);
}


//
// HET_UnshareAll()
// Unshares everything including the desktop.  If we had been sharing
// apps before, we will unshare them all.
//
void  ASShare::HET_UnshareAll(void)
{
    DebugEntry(ASShare::HET_UnshareAll);

    if (m_pasLocal->hetCount != 0)
    {
        HETUpdateLocalCount(0);
    }

    DebugExitVOID(ASShare::HET_UnshareAll);
}


//
// HET_PartyJoiningShare()
//
BOOL  ASShare::HET_PartyJoiningShare(ASPerson * pasPerson)
{
    BOOL    rc = TRUE;

    DebugEntry(ASShare::HET_PartyJoiningShare);

    HET_CalcViewers(NULL);

    DebugExitBOOL(ASShare::HET_PartyJoiningShare, rc);
    return(rc);
}



//
// HET_PartyLeftShare()
//
void  ASShare::HET_PartyLeftShare(ASPerson * pasPerson)
{
    DebugEntry(ASShare::HET_PartyLeftShare);

    // This guy is leaving the share, cleanup if he was sharing.
    ValidatePerson(pasPerson);

    if (pasPerson->hetCount != 0)
    {
        // This person is hosting
        if (pasPerson == m_pasLocal)
        {
            HETUpdateLocalCount(0);
        }
        else
        {
            HETUpdateRemoteCount(pasPerson, 0);
        }
    }

    //
    // If we're hosting, stop viewing if this is the last person in the share.
    //
    HET_CalcViewers(pasPerson);

    DebugExitVOID(ASShare::HET_PartyLeftShare);
}


//
// HET_CalcViewers()
//
// If we or a remote is viewing our shared stuff, then we must accumulate
// graphic output.  If not, don't other, but keep the app tracked as necessary.
//
// This is called when we start to host, when somebody joins, or somebody
// leaves the conference.
//
void ASShare::HET_CalcViewers(ASPerson * pasLeaving)
{
    BOOL    fViewers;

    DebugEntry(ASShare::HET_CalcViewers);

    fViewers = FALSE;

    if (m_pHost)
    {
        if (m_scfViewSelf)
        {
            fViewers = TRUE;
        }
        else if (!pasLeaving)
        {
            //
            // Nobody is leaving, so just check if anybody else is in the
            // share.
            //
            if (m_pasLocal->pasNext)
            {
                fViewers = TRUE;
            }
        }
        else if (pasLeaving->pasNext || (m_pasLocal->pasNext != pasLeaving))
        {
            //
            // Sombody is leaving.
            // The person leaving isn't the only other one besides us in the
            // share, since there are others after it or before it in the
            // members linked list.
            //
            fViewers = TRUE;
        }
    }

    if (fViewers != m_hetViewers)
    {
        HET_VIEWER  viewer;

        m_hetViewers            = fViewers;
        viewer.viewersPresent   = fViewers;

        OSI_FunctionRequest(HET_ESC_VIEWER, (LPOSI_ESCAPE_HEADER)&viewer,
            sizeof(viewer));
    }

    DebugExitVOID(ASShare::HET_CalcViewers);
}



//
// HET_ReceivedPacket()
//
void  ASShare::HET_ReceivedPacket
(
    ASPerson *      pasPerson,
    PS20DATAPACKET  pPacket
)
{
    PHETPACKET      pHETPacket;

    DebugEntry(ASShare:;HET_ReceivedPacket);

    ValidatePerson(pasPerson);

    pHETPacket = (PHETPACKET)pPacket;

    switch (pHETPacket->msg)
    {
        case HET_MSG_NUMHOSTED:
            HETUpdateRemoteCount(pasPerson, pHETPacket->hostState);
            break;

        default:
            ERROR_OUT(("Unknown HET packet type %u from [%d]", pHETPacket->msg,
                pasPerson->mcsID));
            break;
    }

    DebugExitVOID(ASShare::HET_ReceivedPacket);
}



//
// HET_SyncCommon()
//
// Called when somebody joins a share, after it is fully joined.  We repaint
// all shared windows and send the current hosted top-level count.
//
// Also called when sharing, and somebody joins later.
//
// NOTE that some of the resets don't do anything when are just starting to
// share.  But all are quick and benign.
//
void  ASHost::HET_SyncCommon(void)
{
    OSI_ESCAPE_HEADER   osi;

    DebugEntry(ASHost::HET_SyncCommon);

    m_upfSyncTokenRequired = TRUE;

    BA_SyncOutgoing();

    OE2_SyncOutgoing();     // To reset order encoding
    OA_SyncOutgoing();      // To clear pending orders

    SBC_SyncOutgoing();     // To clear bitmap cache
    PM_SyncOutgoing();      // To clear palette cache
    SSI_SyncOutgoing();     // To reset savebits orders

    CM_SyncOutgoing();      // To send cursor shape/pos

    //
    // Tell the driver we are syncing
    //
    OSI_FunctionRequest(OSI_ESC_SYNC_NOW, &osi, sizeof(osi));

    DebugExitVOID(ASHost::HET_SyncCommon);
}


//
// HET_SyncAlreadyHosting()
// Called in a sync when we are already hosting and somebody joins call
//
void ASHost::HET_SyncAlreadyHosting(void)
{
    DebugEntry(ASHost::HET_SyncAlreadyHosting);

    HET_RepaintAll();

    // Send out the current hosted count
    m_pShare->m_hetRetrySendState = TRUE;

    DebugExitVOID(ASHost::HET_SyncAlreadyHosting);
}



//
// HET_RepaintAll()
//
// Repaints all shared stuff if there's at least two people in the share...
//
void ASHost::HET_RepaintAll(void)
{
    DebugEntry(ASHost::HET_RepaintAll);

    ASSERT(m_pShare);
    ASSERT(m_pShare->m_pasLocal);
    if (m_pShare->m_hetViewers)
    {
        //
        // Only repaint if somebody's viewing
        //
        if (m_pShare->m_pasLocal->hetCount == HET_DESKTOPSHARED)
        {
            // Desktop sharing, so repaint desktop(s)
            USR_RepaintWindow(NULL);
            OSI_RepaintDesktop(); //special repaint for winlogon desktop
        }
        else
        {
            ERROR_OUT(("HET_RepaintAll - not sharing dekstop!"));
        }
    }

    DebugExitVOID(ASHost::HET_RepaintAll);
}



//
// HET_Periodic()
//
void  ASShare::HET_Periodic(void)
{
    DebugEntry(ASShare::HET_Periodic);

    if (m_hetRetrySendState)
    {
        TRACE_OUT(( "Retry sending hosted count"));
        HETSendLocalCount();
    }

    DebugExitVOID(ASShare::HET_Periodic);
}


//
// HET_WindowIsHosted - see het.h
//
BOOL  ASShare::HET_WindowIsHosted(HWND hwnd)
{
    BOOL rc = FALSE;

    DebugEntry(ASShare::HET_WindowIsHosted);

    //
    // Desktop sharing:  everything is shared
    //
    if (m_pasLocal->hetCount == HET_DESKTOPSHARED)
    {
        rc = TRUE;
    }

    DebugExitBOOL(ASShare::HET_WindowIsHosted, rc);
    return(rc);
}





//
//  HETStartHosting()
//
//  Called when we are about to begin sharing windows.  fDesktop is TRUE if
//  we are sharing the entire desktop, FALSE if just individual windows.
//
BOOL ASShare::HETStartHosting(BOOL fDesktop)
{
    BOOL    rc = FALSE;

    DebugEntry(ASShare::HETStartHosting);

    //
    // Create the hosting object
    //
    ASSERT(!m_pHost);

    m_pHost = new ASHost;
    if (!m_pHost)
    {
        ERROR_OUT(("HETStartHosting: couldn't create m_pHost"));
        DC_QUIT;
    }

    ZeroMemory(m_pHost, sizeof(*(m_pHost)));
    SET_STAMP(m_pHost, HOST);

    //
    // Init hosting
    //
    if (!m_pHost->HET_HostStarting(this))
    {
        ERROR_OUT(("Failed to init hosting for local person"));
        DC_QUIT;
    }

    //
    // Start tracking graphics/windows
    //
    ASSERT(fDesktop);

    {
        HET_SHARE_DESKTOP   hdr;

        //
        // Shortcut directly to display driver.  No need to track windows
        // since everything will be shared.
        //
        if (!OSI_FunctionRequest(HET_ESC_SHARE_DESKTOP, (LPOSI_ESCAPE_HEADER)&hdr, sizeof(hdr)))
        {
            ERROR_OUT(("HET_ESC_SHARE_DESKTOP failed"));
            DC_QUIT;
        }
    }

    if (m_scfViewSelf && !HET_ViewStarting(m_pasLocal))
    {
        ERROR_OUT(("ViewSelf option is on, but can't create ASView data"));
        DC_QUIT;
    }

    HET_CalcViewers(NULL);

    rc = TRUE;

DC_EXIT_POINT:
    //
    // Return to caller
    //
    DebugExitBOOL(ASShare::HETStartHosting, rc);
    return(rc);
}



//
//
// Name:        HETStopHosting
//
// Description: Called when the last hosted window is unshared
//              ALWAYS CALL THIS AFTER the "hethostedTopLevel" count is 0.
//
// Params:      none
//
//
void ASShare::HETStopHosting(BOOL fDesktop)
{
    DebugEntry(ASShare::HETStopHosting);

    m_hetViewers = FALSE;

    //
    // Stop tracking graphics/windows.  This will stop viewing, then uninstall
    // hooks.
    //
    ASSERT(fDesktop);

    {
        HET_UNSHARE_DESKTOP hdr;

        //
        // There is no window tracking, just shortcut directly to the
        // display driver.
        //
        OSI_FunctionRequest(HET_ESC_UNSHARE_DESKTOP, (LPOSI_ESCAPE_HEADER)&hdr, sizeof(hdr));
    }

    //
    // Tell areas we are finished hosting
    //
    if (m_pHost)
    {
        //
        // If we're viewing ourself, kill the view first
        //
        if (m_scfViewSelf)
        {
            HET_ViewEnded(m_pasLocal);
        }

        m_pHost->HET_HostEnded();

        //
        // Delete host object
        //
        delete m_pHost;
        m_pHost = NULL;
    }

    //
    // Return to caller
    //
    DebugExitVOID(ASShare::HETStopHosting);
}


//
// HETSendLocalCount()
// This sends the hosting count to remotes.
//      * If zero, we are not sharing
//      * If one,  we are sharing apps
//      * If 0xFFFF, we are sharing desktop
//
// Note that we used to send the real count of top level windows, so every
// time a new window came or went, we would broadcast a packet.  But
// remotes only care when the value goes from zero to non-zero or back,
// and when non-zero if it's the special desktop value or not.  So don't
// repeatedly broadcast values remotes don't care about!
//
void ASShare::HETSendLocalCount(void)
{

    PHETPACKET  pHETPacket;
#ifdef _DEBUG
    UINT        sentSize;
#endif // _DEBUG

    DebugEntry(ASShare::HETSendLocalCount);

    //
    // Allocate a packet for the HET data.
    //
    pHETPacket = (PHETPACKET)SC_AllocPkt(PROT_STR_MISC, g_s20BroadcastID,
        sizeof(HETPACKET));
    if (!pHETPacket)
    {
        WARNING_OUT(("Failed to alloc HET host packet"));
        m_hetRetrySendState = TRUE;
        DC_QUIT;
    }

    //
    // Packet successfully allocated.  Fill in the data and send it.
    //
    pHETPacket->header.data.dataType        = DT_HET;
    pHETPacket->msg                         = HET_MSG_NUMHOSTED;

    switch (m_pasLocal->hetCount)
    {
        case 0:
            // Not hosting
            pHETPacket->hostState = HET_NOTHOSTING;
            break;

        case HET_DESKTOPSHARED:
            // Sharing desktop - 3.0 only
            pHETPacket->header.data.dataType    = DT_HET30;
            pHETPacket->hostState               = HET_DESKTOPSHARED;
            break;

        default:
            // Sharing apps
            pHETPacket->hostState = HET_APPSSHARED;
            break;
    }

    //
    // Compress and send the packet.
    //
#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    DCS_CompressAndSendPacket(PROT_STR_MISC, g_s20BroadcastID,
        &(pHETPacket->header), sizeof(*pHETPacket));

    TRACE_OUT(("HET packet size: %08d, sent %08d", sizeof(*pHETPacket), sentSize));

    TRACE_OUT(("Sent new HET packet (%d)", m_pasLocal->hetCount));
    m_hetRetrySendState = FALSE;

    //
    // Return to caller
    //
DC_EXIT_POINT:
    DebugExitVOID(ASShare::HETSendLocalCount);
}



//
// HETUpdateLocalCount()
//
void ASShare::HETUpdateLocalCount(UINT newCount)
{
    UINT        oldCount;

    DebugEntry(ASShare::HETUpdateLocalCount);

    oldCount = m_pasLocal->hetCount;
    m_pasLocal->hetCount = newCount;

    if ((oldCount == 0) && (newCount != 0))
    {
        //
        // Don't bother sending net packets if nobody is viewing
        //
        if (m_hetViewers)
        {
            HETSendLocalCount();
        }

        HETCheckSharing(TRUE);
    }
    else if ((oldCount != 0) && (newCount == 0))
    {
        if (m_hetViewers)
        {
            //
            // Ending host, desktop or apps
            //
            HETSendLocalCount();
        }

        //
        // The local guy is stopping sharing.
        //
        HETStopHosting(oldCount == HET_DESKTOPSHARED);

        HETCheckSharing(FALSE);
    }

    DebugExitVOID(ASShare::HETUpdateLocalCount);
}



//
// HETUpdateRemoteCount()
//
// Updates the count of shared top level windows from a remote, and notifies
// the UI on transition from/to zero if a remote.  If local, kills the share.
//
void ASShare::HETUpdateRemoteCount
(
    ASPerson *  pasPerson,
    UINT        newCount
)
{
    UINT        oldCount;

    DebugEntry(ASShare::HETUpdateRemoteCount);

    ValidatePerson(pasPerson);
    ASSERT(pasPerson != m_pasLocal);

    oldCount = pasPerson->hetCount;
    pasPerson->hetCount = newCount;

    TRACE_OUT(("HETUpdateRemoteCount: Person [%d] old %d, new %d",
        pasPerson->mcsID, oldCount, newCount));

    //
    // We generate events for remote people if
    //      * They were sharing but now they aren't
    //      * There weren't sharing but now they are
    //
    if ((oldCount == 0) && (newCount != 0))
    {
        //
        // The remote dude started to share
        //
        if (!HET_ViewStarting(pasPerson))
        {
            ERROR_OUT(("HET_ViewStarting failed; pretending remote not sharing"));

            pasPerson->hetCount = 0;
            HET_ViewEnded(pasPerson);
        }
        else
        {
            HETCheckSharing(TRUE);
        }
    }
    else if ((oldCount != 0) && (newCount == 0))
    {
        //
        // The remote dude stopped sharing.  Notify the UI also.
        //
        HET_ViewEnded(pasPerson);
        HETCheckSharing(FALSE);
    }

    DebugExitVOID(ASShare::HETUpdateRemoteCount);
}



//
// HETCheckSharing()
// Called when any member of the conference (local or remote) transitions
// to/from sharing.  When the first person has shared something, we notify
// the UI.  When the last person has stopped sharing, we kill the share which
// will notify the UI.
//
void ASShare::HETCheckSharing(BOOL fStarting)
{
    DebugEntry(ASShare::HETCheckSharing);

    if (fStarting)
    {
        ++m_hetHostCount;
        if (m_hetHostCount == 1)
        {
            // First host started
            TRACE_OUT(("First person started hosting"));
            DCS_NotifyUI(SH_EVT_SHARING_STARTED, 0, 0);
        }
    }
    else
    {
        ASSERT(m_hetHostCount > 0);
        --m_hetHostCount;
        if (m_hetHostCount == 0)
        {
            //
            // Last host stopped sharing -- end share if we're not cleaning
            // up after the fact.  But don't do it NOW, post a message.
            // We may have come in here because the share is ending already.
            //
            PostMessage(g_asMainWindow, DCS_KILLSHARE_MSG, 0, 0);
        }
    }

    DebugExitVOID(ASShare::HETCheckSharing);
}



//
// HET_HostStarting()
//
// Called when we start to host applications.  This creates our host data
// then calls the component HostStarting() routines
//
BOOL ASHost::HET_HostStarting(ASShare * pShare)
{
    BOOL    rc = FALSE;

    DebugEntry(ASHost::HET_HostStarting);

    // Set back pointer to share
    m_pShare = pShare;

    //
    // Turn effects off
    //
    HET_SetGUIEffects(FALSE, &m_hetEffects);
    OSI_SetGUIEffects(FALSE);

    //
    // Now call HostStarting() routines
    //
    if (!USR_HostStarting())
    {
        ERROR_OUT(("USR_HostStarting failed"));
        DC_QUIT;
    }

    if (!OE2_HostStarting())
    {
        ERROR_OUT(("OE2_HostStarting failed"));
        DC_QUIT;
    }

    if (!SBC_HostStarting())
    {
        ERROR_OUT(("SBC_HostStarting failed"));
        DC_QUIT;
    }

    if (!CM_HostStarting())
    {
        ERROR_OUT(("CM_HostStarting failed"));
        DC_QUIT;
    }

    if (!SSI_HostStarting())
    {
        ERROR_OUT(("SSI_HostStarting failed"));
        DC_QUIT;
    }

    if (!PM_HostStarting())
    {
        ERROR_OUT(("PM_HostStarting failed"));
        DC_QUIT;
    }

    if (!SWL_HostStarting())
    {
        ERROR_OUT(("SWL_HostStarting failed"));
        DC_QUIT;
    }

    if (!VIEW_HostStarting())
    {
        ERROR_OUT(("VIEW_HostStarting failed"));
        DC_QUIT;
    }

    //
    // Now reset OUTGOING info.  2.x nodes do not; that's why we have to
    // hang on to RBC, OD2, CM, PM data for them.  When 2.x compat is gone,
    // we can move ASPerson data in to ASView, which is only around while
    // the person is in fact hosting.
    //
    OA_LocalHostReset();

    //
    // Reset OUTGOING data.
    // Note corresponding cleanup for 3.0 nodes
    //      in CM, OD2, RBC, and PM.
    // Note that we don't need to reset SSI incoming goop, since we will
    // clear all pending orders and are invalidating everything shared
    // from scratch.  There will be no reference to a previous savebits.
    //
    HET_SyncCommon();

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::HET_HostStarting, rc);
    return(rc);
}



//
// HET_HostEnded()
//
// Called when we stop hosting applications.
//
void ASHost::HET_HostEnded(void)
{
    DebugEntry(ASHost::HET_HostEnded);

    //
    // Call HostEnded() routines
    //
    CA_HostEnded();

    PM_HostEnded();
    CM_HostEnded();
    SBC_HostEnded();

    OE2_HostEnded();
    USR_HostEnded();

    //
    // Restore windows animation.
    //
    HET_SetGUIEffects(TRUE, &m_hetEffects);
    OSI_SetGUIEffects(TRUE);

    DebugExitVOID(ASHost::HET_HostEnded);
}



//
// HET_ViewStarting()
//
// Called to create the data needed to view somebody who is hosting.
//
BOOL ASShare::HET_ViewStarting(ASPerson * pasPerson)
{
    BOOL  rc = FALSE;

    DebugEntry(ASShare::HET_ViewStarting);

    ValidatePerson(pasPerson);

    //
    // Create ASView object
    //
    ASSERT(!pasPerson->m_pView);

    // Allocate VIEW structure
    pasPerson->m_pView = new ASView;
    if (!pasPerson->m_pView)
    {
        // Abject, total, failure.
        ERROR_OUT(("HET_ViewStarting: Couldn't allocate ASView for [%d]", pasPerson->mcsID));
        DC_QUIT;
    }

    ZeroMemory(pasPerson->m_pView, sizeof(*(pasPerson->m_pView)));
    SET_STAMP(pasPerson->m_pView, VIEW);

    //
    // Now call ViewStarting routines
    //
    if (!USR_ViewStarting(pasPerson))
    {
        ERROR_OUT(("USR_ViewStarting failed"));
        DC_QUIT;
    }

    if (!OD2_ViewStarting(pasPerson))
    {
        ERROR_OUT(("OD2_ViewStarting failed"));
        DC_QUIT;
    }

    if (!OD_ViewStarting(pasPerson))
    {
        ERROR_OUT(("OD_ViewStarting failed"));
        DC_QUIT;
    }

    if (!RBC_ViewStarting(pasPerson))
    {
        ERROR_OUT(("RBC_ViewStarting failed"));
        DC_QUIT;
    }

    if (!CM_ViewStarting(pasPerson))
    {
        ERROR_OUT(("CM_ViewStarting failed"));
        DC_QUIT;
    }

    if (!SSI_ViewStarting(pasPerson))
    {
        ERROR_OUT(("SSI_ViewStarting failed"));
        DC_QUIT;
    }

    if (!PM_ViewStarting(pasPerson))
    {
        ERROR_OUT(("PM_ViewStarting failed"));
        DC_QUIT;
    }


    if (!VIEW_ViewStarting(pasPerson))
    {
        ERROR_OUT(("VIEW_ViewStarting failed"));
        DC_QUIT;
    }

    if (!CA_ViewStarting(pasPerson))
    {
        ERROR_OUT(("CA_ViewStarting failed"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::HET_ViewStarting, rc);
    return(rc);
}



//
// HET_ViewEnded()
//
// Called when we stop viewing a host
//
void  ASShare::HET_ViewEnded(ASPerson * pasPerson)
{
    DebugEntry(ASShare::HET_ViewEnded);

    ValidatePerson(pasPerson);

    if (pasPerson->m_pView)
    {
        //
        // Call the component ViewEnded routines
        //
        CA_ViewEnded(pasPerson);
        VIEW_ViewEnded(pasPerson);

        PM_ViewEnded(pasPerson);
        SSI_ViewEnded(pasPerson);
        CM_ViewEnded(pasPerson);

        RBC_ViewEnded(pasPerson);
        OD_ViewEnded(pasPerson);
        OD2_ViewEnded(pasPerson);
        USR_ViewEnded(pasPerson);

        delete pasPerson->m_pView;
        pasPerson->m_pView = NULL;
    }

    DebugExitVOID(ASShare::HET_ViewEnded);
}



//
// HET_SetGUIEffects
//
// Turns various animations off/on when we start/stop hosting, to improve
// performance.  Currently, we mess with
//      * min animation
//      * all of the effects in SPI_SETUIEFFECTS (tooltip fade, menu animation,
//          etc.)
//      * cursor shadows
//
// We don't turn off smooth scroll or full drag.
//
void  HET_SetGUIEffects
(
    BOOL            fOn,
    GUIEFFECTS *    pEffects
)
{
    DebugEntry(HET_SetGUIEffects);

    ASSERT(!IsBadWritePtr(pEffects, sizeof(*pEffects)));

    //
    // NB.  We deliberately do not track the state of animation whilst we
    // are sharing.  A determined user could, using some other app (such as
    // the TweakUI control panel applet) reenable animation whilst in a
    // share.  We will respect this.
    //
    // We only affect the current 'in memory' setting - we do not write our
    // temporary change to file.
    //

    if (fOn)
    {
        //
        // If it was on before, restore it.
        //
        if (pEffects->hetAnimation.iMinAnimate)
        {
            pEffects->hetAnimation.cbSize = sizeof(pEffects->hetAnimation);
            SystemParametersInfo(SPI_SETANIMATION, sizeof(pEffects->hetAnimation),
                &pEffects->hetAnimation, 0);
        }

        if (pEffects->hetAdvanced)
        {
            SystemParametersInfo(SPI_SETUIEFFECTS, 0,
                (LPVOID)pEffects->hetAdvanced, 0);
        }

        if (pEffects->hetCursorShadow)
        {
            SystemParametersInfo(SPI_SETCURSORSHADOW, 0,
                (LPVOID)pEffects->hetCursorShadow, 0);
        }
    }
    else
    {
        //
        // Find out what animations are on.
        //
        ZeroMemory(&pEffects->hetAnimation, sizeof(pEffects->hetAnimation));
        pEffects->hetAnimation.cbSize = sizeof(pEffects->hetAnimation);
        SystemParametersInfo(SPI_GETANIMATION, sizeof(pEffects->hetAnimation),
                &pEffects->hetAnimation, 0);

        pEffects->hetAdvanced = FALSE;
        SystemParametersInfo(SPI_GETUIEFFECTS, 0, &pEffects->hetAdvanced, 0);

        pEffects->hetCursorShadow = FALSE;
        SystemParametersInfo(SPI_GETCURSORSHADOW, 0, &pEffects->hetCursorShadow, 0);

        //
        // Turn off the animations which are on.
        //

        if (pEffects->hetAnimation.iMinAnimate)
        {
            //
            // It's currently enabled, suppress it.
            //
            pEffects->hetAnimation.cbSize = sizeof(pEffects->hetAnimation);
            pEffects->hetAnimation.iMinAnimate = FALSE;
            SystemParametersInfo(SPI_SETANIMATION, sizeof(pEffects->hetAnimation),
                &pEffects->hetAnimation, 0);

            // SPI will wipe this out.  Keep it set so we know to restore it.
            pEffects->hetAnimation.iMinAnimate = TRUE;
        }

        if (pEffects->hetAdvanced)
        {
            SystemParametersInfo(SPI_SETUIEFFECTS, 0, FALSE, 0);
        }

        if (pEffects->hetCursorShadow)
        {
            SystemParametersInfo(SPI_SETCURSORSHADOW, 0, FALSE, 0);
        }
    }

    DebugExitVOID(ASHost::HET_SetGUIEffects);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\gdc.cpp ===
#include "precomp.h"


//
// GDC.CPP
// General Data Compressor
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_NET



//
// Tables used by the compression / decompression algorithms
//

const BYTE s_gdcExLenBits[GDC_LEN_SIZE] =
{
    0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8
};


const WORD s_gdcLenBase[GDC_LEN_SIZE] =
{
    0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 14, 22, 38, 70, 134, 262
};


//
// Dist:  Bits, Coded, Decoded
//
const BYTE s_gdcDistBits[GDC_DIST_SIZE] =
{
    2, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8
};


const BYTE s_gdcDistCode[GDC_DIST_SIZE] =
{
    0x03, 0x0d, 0x05, 0x19, 0x09, 0x11, 0x01, 0x3e,
    0x1e, 0x2e, 0x0e, 0x36, 0x16, 0x26, 0x06, 0x3a,
    0x1a, 0x2a, 0x0a, 0x32, 0x12, 0x22, 0x42, 0x02,
    0x7c, 0x3c, 0x5c, 0x1c, 0x6c, 0x2c, 0x4c, 0x0c,

    0x74, 0x34, 0x54, 0x14, 0x64, 0x24, 0x44, 0x04,
    0x78, 0x38, 0x58, 0x18, 0x68, 0x28, 0x48, 0x08,
    0xf0, 0x70, 0xb0, 0x30, 0xd0, 0x50, 0x90, 0x10,
    0xe0, 0x60, 0xa0, 0x20, 0xc0, 0x40, 0x80, 0x00
};



//
// Len:  Bits, Coded, Decoded
//
const BYTE s_gdcLenBits[GDC_LEN_SIZE] =
{
    3, 2, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7
};


const BYTE s_gdcLenCode[GDC_LEN_SIZE] =
{
    0x05, 0x03, 0x01, 0x06, 0x0A, 0x02, 0x0C, 0x14,
    0x04, 0x18, 0x08, 0x30, 0x10, 0x20, 0x40, 0x00
};




//
// GDC_Init()
//
// BOGUS LAURABU:
// Having one global scratch compression buffer is lousy in multiple
// conference situations.  Maybe allocate it or use caching scheme in
// future, then get rid of mutex.
//
void  GDC_Init(void)
{
    UINT    i, j, k;

    DebugEntry(GDC_Init);

    //
    // Set up the binary data used for PDC compression.  We 'calculate'
    // these since putting this in raw const data is too complicated!
    // The LitBits/LitCodes arrays have 774 entries each, and
    // the LenBits/DistBits arrays have 256 entries.
    //
    // Non-compressed chars take 9 bits in the compressed version:  one
    // bit (zero) to indicate that what follows is not a distance/size
    // code, then the 8 bits of the char.
    //
    for (k = 0; k < GDC_DECODED_SIZE; k++)
    {
        s_gdcLitBits[k] = 9;
        s_gdcLitCode[k] = (WORD)(k << 1);
    }

    for (i = 0; i < GDC_LEN_SIZE; i++)
    {
        for (j = 0; j < (1U << s_gdcExLenBits[i]); j++, k++)
        {
            s_gdcLitBits[k] = (BYTE)(s_gdcLenBits[i] + s_gdcExLenBits[i] + 1);
            s_gdcLitCode[k] = (WORD)((j << (s_gdcLenBits[i] + 1)) |
                                       (s_gdcLenCode[i] << 1) | 1);
        }
    }

    GDCCalcDecode(s_gdcLenBits, s_gdcLenCode, GDC_LEN_SIZE, s_gdcLenDecode);

    GDCCalcDecode(s_gdcDistBits, s_gdcDistCode, GDC_DIST_SIZE, s_gdcDistDecode);


    DebugExitVOID(GDC_Init);
}



//
// GDCCalcDecode()
// This calculates 'const' arrays for s_gdcLenDecode and s_gdcDistDecode.
//
void  GDCCalcDecode
(
    const BYTE *    pSrcBits,
    const BYTE *    pSrcCodes,
    UINT            cSrc,
    LPBYTE          pDstDecodes
)
{
    UINT            j;
    UINT            Incr;
    int             i;

    DebugEntry(GDC_CalcDecode);

    for (i = cSrc-1; i >= 0; i--)
    {
        Incr = 1 << pSrcBits[i];
        j = pSrcCodes[i];
        do
        {
            pDstDecodes[j] = (BYTE)i;
            j += Incr;
        }
        while (j < GDC_DECODED_SIZE);
    }

    DebugExitVOID(GDC_CalcDecode);
}




//
// Optimize compilation for speed (not space)
//
#pragma optimize ("s", off)
#pragma optimize ("t", on)



//
// GDC_Compress()
// Compresses data based on different options.
// This compresses data using PKZIP for both persistent and non-persistent
// types.  The differences between the algorithms are few:
//      * Persistent compression is never used for sources > 4096 bytes
//      * We copy in & update saved dictionary data before starting
//      * We copy back updated dictionary data after ending
//      * One byte of the used DistBits is used for PDC, 2 bytes for
//          plain PKZIP compression in the resulting compressed packet.
//
BOOL  GDC_Compress
(
    PGDC_DICTIONARY pDictionary,            // NULL if not persistent
    UINT            Options,                // Not meaningful if pDictionary
    LPBYTE          pWorkBuf,
    LPBYTE          pSrc,
    UINT            cbSrcSize,
    LPBYTE          pDst,
    UINT *          pcbDstSize
)
{
    BOOL            rc = FALSE;
    UINT            Len;
    UINT            cbRaw;
    UINT            Passes;
    LPBYTE          pCur;
    LPBYTE          pMax;
    PGDC_IMPLODE    pgdcImp;
#ifdef _DEBUG
    UINT            cbSrcOrg;
#endif // _DEBUG

    DebugEntry(GDC_Compress);

    pgdcImp = (PGDC_IMPLODE)pWorkBuf;
    ASSERT(pgdcImp);

#ifdef _DEBUG
    cbSrcOrg = cbSrcSize;
#endif // _DEBUG

    //
    // Figure out what size dictionary to use.
    //
    if (pDictionary)
        pgdcImp->cbDictSize = GDC_DATA_MAX;
    else if (Options == GDCCO_MAXSPEED)
    {
        //
        // Use the smallest for max speed.
        //
        pgdcImp->cbDictSize = GDC_DATA_SMALL;
    }
    else
    {
        ASSERT(Options == GDCCO_MAXCOMPRESSION);

        //
        // Use the nearest dictionary size to the source size.
        //
        if (cbSrcSize <= GDC_DATA_SMALL)
            pgdcImp->cbDictSize = GDC_DATA_SMALL;
        else if (cbSrcSize <= GDC_DATA_MEDIUM)
            pgdcImp->cbDictSize = GDC_DATA_MEDIUM;
        else
            pgdcImp->cbDictSize = GDC_DATA_MAX;
    }

    //
    // How many bits of distance are needed to back the dictionary size
    // # of bytes?
    //
    switch (pgdcImp->cbDictSize)
    {
        case GDC_DATA_SMALL:
            pgdcImp->ExtDistBits = EXT_DIST_BITS_MIN;
            break;

        case GDC_DATA_MEDIUM:
            pgdcImp->ExtDistBits = EXT_DIST_BITS_MEDIUM;
            break;

        case GDC_DATA_MAX:
            pgdcImp->ExtDistBits = EXT_DIST_BITS_MAC;
            break;
    }

    pgdcImp->ExtDistMask = 0xFFFF >> (16 - pgdcImp->ExtDistBits);


    //
    // We need at least 4 bytes (2 max for ExtDistBits, 2 for EOF code).
    //
    ASSERT(*pcbDstSize > 4);

    //
    // Now save the destination info in our struct.  That we we can just
    // pass a pointer to our GDC_IMPLODE routine around with everything
    // we need.
    //
    pgdcImp->pDst     =   pDst;
    pgdcImp->cbDst    =   *pcbDstSize;

    //
    // For non PDC compression, the first little-endian WORD is the ExtDistBits
    // used in decompression.  For PDC compression, just the first BYTE is
    // the ExtDistBits.
    //

    if (!pDictionary)
    {
        *(pgdcImp->pDst)++  = 0;
        --(pgdcImp->cbDst);
    }

    *(pgdcImp->pDst)++    =   (BYTE)pgdcImp->ExtDistBits;
    --(pgdcImp->cbDst);

    //
    // Since pDst could be huge, we don't zero it all out before using.
    // As the pointer into the destination advances, we zero out a byte
    // just before we start writing bits into it.
    //
    pgdcImp->iDstBit      = 0;
    *(pgdcImp->pDst)      = 0;


    //
    // Now, if we have a dictonary, restore the contents into our scratch
    // buffer.
    //
    if (pDictionary && pDictionary->cbUsed)
    {
        TRACE_OUT(("Restoring %u dictionary bytes before compression",
            pDictionary->cbUsed));

        //
        // NOTE:  the data saved in pDictionary->pData is front aligned.
        // But the data in RawData is end aligned so that we can slide up
        // new data chunk by chunk when compressing.  Therefore only copy
        // the part that is valid, but make it end at the back of the
        // space for the dictionary data.
        //
        ASSERT(pDictionary->cbUsed <= pgdcImp->cbDictSize);
        memcpy(pgdcImp->RawData + GDC_MAXREP + pgdcImp->cbDictSize - pDictionary->cbUsed,
            pDictionary->pData,  pDictionary->cbUsed);

        pgdcImp->cbDictUsed = pDictionary->cbUsed;
    }
    else
    {
        pgdcImp->cbDictUsed = 0;
    }

    //
    // We only compress GDC_DATA_MAX bytes at a time.  Therefore we have
    // this loop to grab at most that amount each time around.  Since we
    // only persistently compress packets <= GDC_DATA_MAX, we should never
    // go through it more than once for that compression type.  But normal
    // compression, you betcha since the max packet size is 32K.
    //
    Passes = 0;
    pCur = pgdcImp->RawData + GDC_MAXREP + pgdcImp->cbDictSize;

    do
    {
        //
        // cbRaw will either be GDC_DATA_MAX (if source has >= that to go)
        // or remainder.  Copy that much uncompressed data into our
        // working RawData buffer in the 'new data' space.
        //
        ASSERT(cbSrcSize);
        cbRaw = min(cbSrcSize, GDC_DATA_MAX);

        memcpy(pgdcImp->RawData + GDC_MAXREP + pgdcImp->cbDictSize,
                pSrc, cbRaw);
        pSrc += cbRaw;
        cbSrcSize -= cbRaw;

        //
        // Now get a pointer just past the end of the data we read.  Well,
        // almost.  We fed in cbRaw bytes starting at GDC_MAXREP +
        // pgdcImp->cbDictSize.  So unless this is the last chunk of raw
        // data to process, pMax is GDC_MAXREP before the end of the
        // new raw data.
        //
        // NOTE that in several of the functions that follow, we read
        // a byte or two past the end and the beginning of the valid new
        // raw data.  THIS IS INTENTIONAL.
        //
        // Doing so is the only way to get the beginning and ending bytes
        // indexed, since the hash function uses TWO bytes.  We won't
        // GPF because of padding in our RawData buffer.
        //

        pMax = pgdcImp->RawData + pgdcImp->cbDictSize + cbRaw;
        if (!cbSrcSize)
        {
            pMax += GDC_MAXREP;
        }
        else
        {
            //
            // This better NOT be persistent compression, since we don't
            // let you compress packets bigger than the chunk size we
            // process (GDC_DATA_MAX).
            //
            ASSERT(!pDictionary);
        }

        //
        // Generate the sort buffer, which orders the raw data according
        // to an index calculated using pairs of contiguous bytes that
        // occur within it.  Without a dictionary yet, the first pass
        // only indexes the current chunk.  With a dictionary (a second or
        // greater pass--or PERSISTENT COMPRESSION has saved enough data
        // from last time), we look back into the previous chunk (what we
        // call the dictionary).
        //
        // This takes longer since we go through more bytes, but produces
        // better results.  Hence the dictionary size controls the speed/
        // resulting size.
        //
        switch (Passes)
        {
            case 0:
            {
                if (pgdcImp->cbDictUsed > GDC_MAXREP)
                {
                    //
                    // On the zeroth pass, cbDictUsed is always ZERO
                    // for non-persistent PKZIP.
                    //
                    ASSERT(pDictionary);

                    GDCSortBuffer(pgdcImp, pCur - pgdcImp->cbDictUsed + GDC_MAXREP,
                        pMax + 1);
                }
                else
                {
                    GDCSortBuffer(pgdcImp, pCur, pMax + 1);
                }

                ++Passes;

                //
                // After completing a pass we slide the raw data up into
                // the dictionary slot, bumping out the older dictionary
                // data.
                //
                if (pgdcImp->cbDictSize != GDC_DATA_MAX)
                {
                    ASSERT(pgdcImp->cbDictUsed == 0);
                    ASSERT(!pDictionary);
                    ++Passes;
                }
            }
            break;

            case 1:
            {
                //
                // Start sorting GDC_MAXREP bytes after the start.  NOTE
                // that this is exactly what PERSISTENT compression does
                // on the zeroth pass--it acts like we already have
                // dictionary data, using the bytes from the last time
                // we compressed something.
                //
                GDCSortBuffer(pgdcImp, pCur - pgdcImp->cbDictSize + GDC_MAXREP,
                    pMax + 1);
                ++Passes;
            }
            break;

            default:
            {
                //
                // Start sort from the beginning of the dictionary.
                // This works because we copy raw data around before
                // starting the next pass.
                //
                GDCSortBuffer(pgdcImp, pCur - pgdcImp->cbDictSize, pMax + 1);
            }
            break;
        }


        //
        // Now compress the raw data chunk we ar working on.
        //
        while (pCur < pMax)
        {
            Len = GDCFindRep(pgdcImp, pCur);

SkipFindRep:
            if (!Len || (Len == GDC_MINREP && pgdcImp->Distance >= GDC_DECODED_SIZE))
            {
                if (!GDCOutputBits(pgdcImp, s_gdcLitBits[*pCur],
                        s_gdcLitCode[*pCur]))
                    DC_QUIT;

                pCur++;
                continue;
            }

            //
            // Only do this if we're on the last chunk
            //
            if (!cbSrcSize && (pCur + Len > pMax))
            {
                //
                // Peg run size so it doesn't go past end of raw data.
                //
                Len = (UINT)(pMax - pCur);
                if ((Len < GDC_MINREP) ||
                    (Len == GDC_MINREP && pgdcImp->Distance >= GDC_DECODED_SIZE))
                {
                    if (!GDCOutputBits(pgdcImp, s_gdcLitBits[*pCur],
                            s_gdcLitCode[*pCur]))
                        DC_QUIT;
                    pCur++;
                    continue;
                }
            }
            else if ((Len < 8) && (pCur + 1 < pMax))
            {
                UINT    Save_Distance;
                UINT    Save_Len;

                //
                // Make temp copies of Distance and Len so we can
                // look ahead and see if a better compression run is
                // looming.  If so, we won't bother starting it here,
                // we'll grab the better one next time around.
                //
                Save_Distance = pgdcImp->Distance;
                Save_Len = Len;

                Len = GDCFindRep(pgdcImp, pCur + 1);
                if ((Len > Save_Len) &&
                    ((Len > Save_Len + 1) || (Save_Distance > (GDC_DECODED_SIZE/2))))
                {
                    if (!GDCOutputBits(pgdcImp, s_gdcLitBits[*pCur],
                            s_gdcLitCode[*pCur]))
                        DC_QUIT;
                    ++pCur;
                    goto SkipFindRep;
                }

                //
                // Put back old Len and Distance, we'll take this one.
                //
                Len = Save_Len;
                pgdcImp->Distance = Save_Distance;
            }

            if (!GDCOutputBits(pgdcImp, s_gdcLitBits[256 + Len - GDC_MINREP],
                    s_gdcLitCode[256 + Len - GDC_MINREP]))
                DC_QUIT;

            if (Len == GDC_MINREP)
            {
                //
                // GDC_MINREP is 2, so we right shift Distance by 2
                // (divide by 4).  Then we mask out the last 2 bits
                // of Distance.
                //
                if (!GDCOutputBits(pgdcImp,
                        s_gdcDistBits[pgdcImp->Distance >> GDC_MINREP],
                        s_gdcDistCode[pgdcImp->Distance >> GDC_MINREP]))
                    DC_QUIT;

                if (!GDCOutputBits(pgdcImp, GDC_MINREP, (WORD)(pgdcImp->Distance & 3)))
                    DC_QUIT;
            }
            else
            {
                if (!GDCOutputBits(pgdcImp,
                        s_gdcDistBits[pgdcImp->Distance >> pgdcImp->ExtDistBits],
                        s_gdcDistCode[pgdcImp->Distance >> pgdcImp->ExtDistBits]))
                    DC_QUIT;

                if (!GDCOutputBits(pgdcImp, (WORD)pgdcImp->ExtDistBits,
                        (WORD)(pgdcImp->Distance & pgdcImp->ExtDistMask)))
                    DC_QUIT;
            }

            pCur += Len;
        }


        if (cbSrcSize)
        {
            //
            // There's more data to process.  Here's where we slide up the
            // current raw data into the dictionary space.  This is simply
            // the final cbDictSize + GDC_MAXREP bytes of data.  It
            // begins GDC_DATA_MAX after the start of the bufer.
            //
            // For example, if the dict size is 1K, the current data goes
            // from 1K to 5K, and we slide up the data from 4K to 5K.
            //
            memcpy(pgdcImp->RawData, pgdcImp->RawData + GDC_DATA_MAX,
                pgdcImp->cbDictSize + GDC_MAXREP);

            //
            // Now move our raw data pointer back and update the
            // dictonary used amount.  Since we have GDC_DATA_MAX of data,
            // we fill the dictionary completely.
            //
            pCur -= GDC_DATA_MAX;
            pgdcImp->cbDictUsed = pgdcImp->cbDictSize;
        }
    }
    while (cbSrcSize);

    //
    // Add the end code.
    //
    if (!GDCOutputBits(pgdcImp, s_gdcLitBits[EOF_CODE], s_gdcLitCode[EOF_CODE]))
        DC_QUIT;

    //
    // Return the resulting compressed data size.
    //
    // NOTE that partial bits are already in the destination.  But we
    // need to account for any in the total size.
    //
    if (pgdcImp->iDstBit)
        ++(pgdcImp->pDst);

    *pcbDstSize = (UINT)(pgdcImp->pDst - pDst);

    //
    // We're done.  If we have a persistent dictionary, copy back our
    // last block of raw data into it.  We only copy as much as is actually
    // valid however.
    //
    // We can only get here on successful compression.  NOTE that we do not
    // wipe out our dictionary on failure like we used to.  This helps us
    // by permitting better compression the next time.  The receiver will
    // be OK, since his receive dictionary won't be altered upon reception
    // of a non-compressed packet.
    //
    if (pDictionary)
    {
        pDictionary->cbUsed = min(pgdcImp->cbDictSize, pgdcImp->cbDictUsed + cbRaw);

        TRACE_OUT(("Copying back %u dictionary bytes after compression",
            pDictionary->cbUsed));

        memcpy(pDictionary->pData, pgdcImp->RawData + GDC_MAXREP +
            pgdcImp->cbDictSize + cbRaw - pDictionary->cbUsed,
            pDictionary->cbUsed);

    }

    TRACE_OUT(("%sCompressed %u bytes to %u",
        (pDictionary ? "PDC " : ""), cbSrcOrg, *pcbDstSize));

    rc = TRUE;

DC_EXIT_POINT:
    if (!rc && !pgdcImp->cbDst)
    {
        TRACE_OUT(("GDC_Compress: compressed size is bigger than decompressed size %u.",
            cbSrcOrg));
    }

    DebugExitBOOL(GDC_Compress, rc);
    return(rc);
}



//
// GDCSortBuffer()
//
void  GDCSortBuffer
(
    PGDC_IMPLODE    pgdcImp,
    LPBYTE          pStart,
    LPBYTE          pEnd
)
{
    WORD            Accum;
    WORD *          pHash;
    LPBYTE          pTmp;

    DebugEntry(GDCSortBuffer);

    ASSERT(pStart >= pgdcImp->RawData + pgdcImp->cbDictSize - pgdcImp->cbDictUsed);
    //
    // For each pair of bytes in the raw data, from pStart to pEnd,
    // calculate the hash value for the pair .  The hash value ranges from
    // 0 to GDC_HASH_SIZE-1.  Thus the HashArray structure is an array of
    // GDC_HASH_SIZE WORDs.  Keep a count of how many times a particular
    // hash value occurs in the uncompressed data.
    //
    //
    ZeroMemory(pgdcImp->HashArray, sizeof(pgdcImp->HashArray));

    pTmp = pStart;
    do
    {
        ++(pgdcImp->HashArray[GDC_HASHFN(pTmp)]);
    }
    while (++pTmp < pEnd);


    //
    // Now go back and make each HashArray entry a cumulative total of the
    // occurrences of the hash values up to and including itself.  Kind
    // of like the Fibonacci sequence actually.
    //
    Accum = 0;
    pHash = pgdcImp->HashArray;
    do
    {
        Accum += *pHash;
        *pHash = Accum;
    }
    while (++pHash < pgdcImp->HashArray + GDC_HASH_SIZE);


    //
    // Find the entry in the HashArray containing the accumulated
    // instance count for the current data WORD.  Since these values are
    // calculated from the data in the passed in range, we know that the
    // value in any slot we get to by hashing some bytes in the range is
    // at least 1.
    //
    // We start at the end and work towards the beginning so that we
    // end up with the first instance of such an occurrence in the SortArray.
    //
    pTmp = pEnd - 1;
    do
    {
        pHash = pgdcImp->HashArray + GDC_HASHFN(pTmp);

        ASSERT(*pHash > 0);

        //
        // The count (*pHash) is to be used as an array index, so subtract
        // one from it.  If there was only one instance, put it in array
        // element 0.  If there is more than one instance of a particular
        // hash, then next time we will start with a lower accumulated
        // total.  The array element will be one back, and so on.
        //
        --(*pHash);

        //
        // Store an offset from the beginning of the RawData buffer to
        // each byte of data into the SortArray.  This is inserted
        // using the hash instance count as the index.
        //
        // In other words, the buffer is sorted in ascending order of hash
        // for a particular piece of data.  Where two bytes of data have
        // the same hash, they are referenced in the SortBuffer in the
        // same order as in the RawData since we are scanning backwards.
        //
        pgdcImp->SortArray[*pHash] = (WORD)(pTmp - pgdcImp->RawData);
    }
    while (--pTmp >= pStart);


    //
    // Now all entries in the HashArray index the first occurrence of a byte
    // in the workspace which has a particular index, via the SortArray
    // offset.  That is, the above do-while loop decrements each HashArray
    // entry until all data bytes for that entry are written to SortBuffer.
    //
    DebugExitVOID(GDCSortBuffer);
}



//
// GDCFindRep
//
// This looks for byte patterns in the uncompressed data that can be
// represented in the compressed data with smaller sequences.  The biggest
// wins come from repeating byte sequences; later sequences can be
// compressed into a few bytes referring to an earlier sequence (how big,
// how many bytes back).
//
// This returns the length of the uncompressed data to be replaced.
//
UINT  GDCFindRep
(
    PGDC_IMPLODE    pgdcImp,
    LPBYTE          pDataStart
)
{
    UINT            CurLen;
    UINT            Len;
    LPBYTE          pDataPat;
    LPBYTE          pData;
    UINT            iDataMin;
    UINT            SortIndex;
    LPBYTE          pDataMax;
    UINT            HashVal;
    UINT            i1;
    short           j1;
    LPBYTE          pBase;

    DebugEntry(GDCFindRep);

    //
    // See GDCSortBuffer for a description of the contents of the
    // Index array.  GDC_HASHFN() returns a hash value for a byte
    // using it and its successor in the uncompressed data stream.
    //

    HashVal = GDC_HASHFN(pDataStart);
    ASSERT(HashVal < GDC_HASH_SIZE);

    SortIndex = pgdcImp->HashArray[HashVal];

    //
    // Find the minimum sort buffer value.  This is the offset of the
    // first byte of data.
    //
    iDataMin = (UINT)(pDataStart - pgdcImp->cbDictSize + 1 - pgdcImp->RawData);

    if (pgdcImp->SortArray[SortIndex] < iDataMin)
    {
        //
        // The SortArray is referencing stale data, data that is no
        // longer in the range we are processing.  Move forward until
        // we hit the first entry that's in the current chunk.
        //
        do
        {
            ++SortIndex;
        }
        while (pgdcImp->SortArray[SortIndex] < iDataMin);

        //
        // Save this new sort value in the hash.
        //
        pgdcImp->HashArray[HashVal] = (WORD)SortIndex;
    }

    //
    // Need more than 2 bytes with the same index before processing it.
    //
    pDataMax = pDataStart - 1;

    //
    // Get a Ptr to the first byte in the compression buffer referenced by
    // the SortBuffer offset indexed by the SortIndex we just calculated.
    // If this Ptr is not at least 2 bytes before pDataStart then return 0.
    // This means that the byte pointed to by Start does not share the
    // index with earlier bytes.
    //
    pData = pgdcImp->RawData + pgdcImp->SortArray[SortIndex];
    if (pData >= pDataMax)
       return 0;

    //
    // Now the current bytes have the same index as at least 2 other
    // sequences.  Ptr points to the first compress buffer byte with
    // the same index as that pointed to by pDataStart.
    //
    pDataPat = pDataStart;
    CurLen = 1;

    do
    {
        if (*(pData + CurLen - 1) == *(pDataPat + CurLen - 1) &&
            *(pData) == *(pDataPat))
        {
            //
            // This processes a sequence of identical bytes, one starting
            // at pDataPat, the other at pData.
            //
            ++pData;
            ++pDataPat;
            Len = 2;

            // Skip past matching bytes, keeping a count.
            while ((*++pData == *++pDataPat) && (++Len < GDC_MAXREP))
                ;

            pDataPat = pDataStart;
            if (Len >= CurLen)
            {
                pgdcImp->Distance = (UINT)(pDataPat - pData + Len - 1);
                if ((CurLen = Len) > KMP_THRESHOLD)
                {
                    if (Len == GDC_MAXREP)
                    {
                        --(pgdcImp->Distance);
                        return Len;
                    }
                    goto DoKMP;
                }
            }
        }

        //
        // Get a pointer to the next compress buffer byte having the same
        // hash.  If this byte comes before pDataMax, go back around the
        // loop and look for a matching sequence.
        //
        pData = pgdcImp->RawData + pgdcImp->SortArray[++SortIndex];

    }
    while (pData < pDataMax);

    return (CurLen >= GDC_MINREP) ? CurLen : 0;


DoKMP:
    if (pgdcImp->RawData + pgdcImp->SortArray[SortIndex+1] >= pDataMax)
        return CurLen;

    j1 = pgdcImp->Next[1] = 0;
    pgdcImp->Next[0] = -1;

    i1 = 1;
    do
    {
        if ((pDataPat[i1] == pDataPat[j1]) ||  ((j1 = pgdcImp->Next[j1]) == -1))
            pgdcImp->Next[++i1] = ++j1;
    }
    while (i1 < CurLen);

    Len = CurLen;
    pData = pgdcImp->RawData + pgdcImp->SortArray[SortIndex] + CurLen;

    while (TRUE)
    {
        if ((Len = pgdcImp->Next[Len]) == -1)
            Len = 0;

        do
        {
            pBase = pgdcImp->RawData + pgdcImp->SortArray[++SortIndex];
            if (pBase >= pDataMax)
                return CurLen;
        }
        while (pBase + Len < pData);

        if (*(pBase + CurLen - 2) != *(pDataPat + CurLen - 2))
        {
            do
            {
                pBase = pgdcImp->RawData + pgdcImp->SortArray[++SortIndex];
                if (pBase >= pDataMax)
                    return CurLen;
            }
            while ((*(pBase + CurLen - 2) != *(pDataPat + CurLen - 2)) ||
                   (*(pBase) != *(pDataPat)));

            Len = 2;
            pData = pBase + Len;
        }
        else if (pBase + Len != pData)
        {
            Len = 0;
            pData = pBase;
        }

        while ((*pData == pDataPat[Len]) && (++Len < GDC_MAXREP))
            pData++;

        if (Len >= CurLen)
        {
            ASSERT(pBase < pDataStart);
            pgdcImp->Distance = (UINT)(pDataStart - pBase - 1);

            if (Len > CurLen)
            {
                if (Len == GDC_MAXREP)
                    return Len;

                CurLen = Len;

                do
                {
                    if ((pDataPat[i1] == pDataPat[j1]) ||
                        ((j1 = pgdcImp->Next[j1]) == -1))
                        pgdcImp->Next[++i1] = ++j1;
                }
                while (i1 < CurLen);
            }
        }
    }

    DebugExitVOID(GDCFindRep);
}


//
// GDCOutputBits()
//
// This writes compressed output into our output buffer.  If the total
// goes past the max compressed chunk we have workspace for, we flush
// our buffer into the apps'destination.
//
// It returns FALSE on failure, i.e. we would go past the end of the
// destination.
//
BOOL  GDCOutputBits
(
    PGDC_IMPLODE    pgdcImp,
    WORD            Cnt,
    WORD            Code
)
{
    UINT            iDstBit;
    BOOL            rc = FALSE;

    DebugEntry(GDCOutputBits);

    //
    // If we are writing more than a byte's worth of bits, call ourself
    // recursively to write just 8.  NOTE THAT WE NEVER OUTPUT MORE THAN
    // A WORD'S WORTH, since Code is a WORD sized object.
    //
    if (Cnt > 8)
    {
        if (!GDCOutputBits(pgdcImp, 8, Code))
            DC_QUIT;

        Cnt -= 8;
        Code >>= 8;
    }

    ASSERT(pgdcImp->cbDst > 0);

    //
    // OR on the bits of the Code (Cnt of them).  Then advance our
    // current bit pointer and current byte pointer in the output buffer.
    //
    iDstBit = pgdcImp->iDstBit;
    ASSERT(iDstBit < 8);

    //
    // NOTE:  This is why it is extremely important to have zeroed out
    // the current destination byte when we advance.  We OR on bit
    // sequences to the current byte.
    //
    *(pgdcImp->pDst) |= (BYTE)(Code << iDstBit);
    pgdcImp->iDstBit += Cnt;

    if (pgdcImp->iDstBit >= 8)
    {
        //
        // We've gone past a byte.  Advance the destination ptr to the next
        // one.
        //
        ++(pgdcImp->pDst);
        if (--(pgdcImp->cbDst) == 0)
        {
            //
            // We just filled the last byte and are trying to move past
            // the end of the destination.  Bail out now
            //
            DC_QUIT;
        }

        //
        // Phew, we have room left.  Carry over the slop bits.
        //
        if (pgdcImp->iDstBit > 8)
        {
            //
            // Carry over slop.
            //
            *(pgdcImp->pDst) = (BYTE)(Code >> (8 - iDstBit));
        }
        else
            *(pgdcImp->pDst) = 0;

        // Now the new byte is fullly initialized.

        pgdcImp->iDstBit &= 7;
    }

    rc= TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(GDCOutputBits, rc);
    return(rc);
}




//
// GDC_Decompress()
//
BOOL  GDC_Decompress
(
    PGDC_DICTIONARY     pDictionary,
    LPBYTE              pWorkBuf,
    LPBYTE              pSrc,
    UINT                cbSrcSize,
    LPBYTE              pDst,
    UINT *              pcbDstSize
)
{
    BOOL                rc = FALSE;
    UINT                Len;
    UINT                Dist;
    UINT                i;
    UINT                cbDstSize;
    LPBYTE              pDstOrg;
    LPBYTE              pEarlier;
    LPBYTE              pNow;
    PGDC_EXPLODE        pgdcExp;
#ifdef _DEBUG
    UINT                cbSrcOrg;
#endif // _DEBUG

    DebugEntry(GDC_Decompress);

    pgdcExp = (PGDC_EXPLODE)pWorkBuf;
    ASSERT(pgdcExp);

#ifdef _DEBUG
    cbSrcOrg = cbSrcSize;
#endif // _DEBUG

    //
    // This shouldn't be possible--but since this compressed data
    // comes from another machine, we want to make sure _we_ don't blow
    // up if that machine flaked out.
    //
    if (cbSrcSize <= 4)
    {
        ERROR_OUT(("GDC_Decompress:  bogus compressed data"));
        DC_QUIT;
    }

    //
    // Get the distance bits and calculate the mask needed for that many.
    //
    // NOTE:  For PDC compression, the ExtDistBits are just in the first
    // byte.  For plain compression, the ExtDistBits are in the first
    // little-endian word.  Either way, we only allow from 4 to 6, so
    // the high byte in the non-PDC case is not useful.
    //
    if (!pDictionary)
    {
        // First byte better be zero
        if (*pSrc != 0)
        {
            ERROR_OUT(("GDC_Decompress:  unrecognized distance bits"));
            DC_QUIT;
        }

        ++pSrc;
        --cbSrcSize;
    }

    pgdcExp->ExtDistBits = *pSrc;
    if ((pgdcExp->ExtDistBits < EXT_DIST_BITS_MIN) ||
        (pgdcExp->ExtDistBits > EXT_DIST_BITS_MAC))
    {
        ERROR_OUT(("GDC_Decompress:  unrecognized distance bits"));
        DC_QUIT;
    }
    pgdcExp->ExtDistMask = 0xFFFF >> (16 - pgdcExp->ExtDistBits);


    //
    // Set up source data info (compressed goop).  SrcByte is the current
    // byte & bits we're reading from.  pSrc is the pointer to the next
    // byte.
    //
    pgdcExp->SrcByte  = *(pSrc+1);
    pgdcExp->SrcBits  = 0;
    pgdcExp->pSrc     = pSrc + 2;
    pgdcExp->cbSrc    = cbSrcSize - 2;

    //
    // Save the beginning of the result buffer so we can calculate how
    // many bytes we wrote into it afterwards.
    //
    pDstOrg = pDst;
    cbDstSize = *pcbDstSize;

    //
    // If we have a dictionary, put its data into our work area--the
    // compression might be referencing byte sequences in it (that's the
    // whole point, you get better compression that way when you send
    // packets with the same info over and over).
    //
    // We remember and update cbDictUsed to do the minimal dictionary
    // byte copying back and forth.
    //
    if (pDictionary && pDictionary->cbUsed)
    {
        TRACE_OUT(("Restoring %u dictionary bytes before decompression",
            pDictionary->cbUsed));

        memcpy(pgdcExp->RawData + GDC_DATA_MAX - pDictionary->cbUsed,
            pDictionary->pData, pDictionary->cbUsed);
        pgdcExp->cbDictUsed   = pDictionary->cbUsed;
    }
    else
    {
        pgdcExp->cbDictUsed = 0;
    }

    //
    // The decompressed data starts filling in at GDC_DATA_MAX bytes into
    // the RawData array.  We have to double buffer the output (just
    // like we double buffer the input during compression) because
    // decompressing may require reaching backwards into the decompressed
    // byte stream to pull out sequences.
    //
    pgdcExp->iRawData = GDC_DATA_MAX;

    while ((Len = GDCDecodeLit(pgdcExp)) < EOF_CODE)
    {
        if (Len < 256)
        {
            pgdcExp->RawData[pgdcExp->iRawData++] = (BYTE)Len;
        }
        else
        {
            Len -= (256 - GDC_MINREP);
            Dist = GDCDecodeDist(pgdcExp, Len);
            if (!Dist)
                DC_QUIT;

            //
            // Now we're reaching back, this may in fact spill into the
            // dictionary data that preceded us.
            //
            pNow = pgdcExp->RawData + pgdcExp->iRawData;
            pEarlier = pNow - Dist;

            ASSERT(pEarlier >= pgdcExp->RawData + GDC_DATA_MAX - pgdcExp->cbDictUsed);


            pgdcExp->iRawData += Len;
            do
            {
                *pNow++ = *pEarlier++;
            }
            while (--Len > 0);
        }

        //
        // We've gone past the end of our workspace, flush the decompressed
        // data out.  This is why RawData in GDC_EXPLODE has an extra pad of
        // GDC_MAXREP at the end.  This prevents us from spilling out of
        // the RawData buffer, we will never go more than GDC_MAXREP beyond
        // the last GDC_DATA_MAX chunk.
        //
        if (pgdcExp->iRawData >= 2*GDC_DATA_MAX)
        {
            //
            // Do we have enough space left in the destination?
            //
            if (cbDstSize < GDC_DATA_MAX)
            {
                cbDstSize = 0;
                DC_QUIT;
            }

            // Yup.
            memcpy(pDst, pgdcExp->RawData + GDC_DATA_MAX, GDC_DATA_MAX);

            pDst += GDC_DATA_MAX;
            cbDstSize -= GDC_DATA_MAX;

            //
            // Slide decoded data up to be used for decoding the next
            // chunk ofcompressed source.  It's convenient that the
            // dictionary size and flush size are the same.
            //
            pgdcExp->iRawData -= GDC_DATA_MAX;
            memcpy(pgdcExp->RawData, pgdcExp->RawData + GDC_DATA_MAX,
                pgdcExp->iRawData);
            pgdcExp->cbDictUsed = GDC_DATA_MAX;
        }
    }

    if (Len == ABORT_CODE)
        DC_QUIT;

    i = pgdcExp->iRawData - GDC_DATA_MAX;

    if (i > 0)
    {
        //
        // This is the remaining decompressed data--can we we right it
        // out?
        //
        if (cbDstSize < i)
        {
            cbDstSize = 0;
            DC_QUIT;
        }

        memcpy(pDst, pgdcExp->RawData + GDC_DATA_MAX, i);

        //
        // Advance pDst so that the delta between it and the original is
        // the resulting uncompressed size.
        //
        pDst += i;

        //
        // And update the dictionary used size
        //
        pgdcExp->cbDictUsed = min(pgdcExp->cbDictUsed + i, GDC_DATA_MAX);
    }

    //
    // If we make it to here, we've successfully decompressed the input.
    // So fill in the resulting uncompressed size.
    //
    *pcbDstSize = (UINT)(pDst - pDstOrg);

    //
    // If a persistent dictionary was passed in, save the current contents
    // back into the thing for next time.
    //
    if (pDictionary)
    {
        TRACE_OUT(("Copying back %u dictionary bytes after decompression",
            pgdcExp->cbDictUsed));

        memcpy(pDictionary->pData, pgdcExp->RawData + GDC_DATA_MAX +
            i - pgdcExp->cbDictUsed, pgdcExp->cbDictUsed);
        pDictionary->cbUsed = pgdcExp->cbDictUsed;
    }

    TRACE_OUT(("%sExploded %u bytes from %u",
        (pDictionary ? "PDC " : ""), *pcbDstSize, cbSrcOrg));

    rc = TRUE;

DC_EXIT_POINT:
    if (!rc && !cbDstSize)
    {
        ERROR_OUT(("GDC_Decompress:  decompressed data too big"));
    }

    DebugExitBOOL(GDC_Decompress, rc);
    return(rc);
}




//
// GDCDecodeLit()
//
UINT  GDCDecodeLit
(
    PGDC_EXPLODE    pgdcExp
)
{
    UINT            LitChar, i;

    if (pgdcExp->SrcByte & 0x01)
    {
        // Length found
        if (!GDCWasteBits(pgdcExp, 1))
            return ABORT_CODE;

        LitChar = s_gdcLenDecode[pgdcExp->SrcByte & 0xFF];

        if (!GDCWasteBits(pgdcExp, s_gdcLenBits[LitChar]))
            return ABORT_CODE;

        if (s_gdcExLenBits[LitChar])
        {
            i = pgdcExp->SrcByte & ((1 << s_gdcExLenBits[LitChar]) - 1);

            if (!GDCWasteBits(pgdcExp, s_gdcExLenBits[LitChar]))
            {
                // If this isn't EOF, something is wrong
                if (LitChar + i != 15 + 255)
                    return ABORT_CODE;
            }

            LitChar = s_gdcLenBase[LitChar] + i;
        }

        LitChar += 256;
    }
    else
    {
        // Char found
        if (!GDCWasteBits(pgdcExp, 1))
            return ABORT_CODE;

        LitChar = (pgdcExp->SrcByte & 0xFF);

        if (!GDCWasteBits(pgdcExp, 8))
             return ABORT_CODE;
    }

    return LitChar;
}


//
// GDCDecodeDist()
//
UINT  GDCDecodeDist
(
    PGDC_EXPLODE    pgdcExp,
    UINT            Len
)
{
    UINT            Dist;

    Dist = s_gdcDistDecode[pgdcExp->SrcByte & 0xFF];

    if (!GDCWasteBits(pgdcExp, s_gdcDistBits[Dist]))
        return 0;

    if (Len == GDC_MINREP)
    {
        // GDC_MINREP is 2, hence we shift over by 2 then mask the low 2 bits
        Dist <<= GDC_MINREP;
        Dist |= (pgdcExp->SrcByte & 3);
        if (!GDCWasteBits(pgdcExp, GDC_MINREP))
            return 0;
    }
    else
    {
        Dist <<= pgdcExp->ExtDistBits;
        Dist |=( pgdcExp->SrcByte & pgdcExp->ExtDistMask);
        if (!GDCWasteBits(pgdcExp, pgdcExp->ExtDistBits))
            return 0;
    }

    return Dist+1;
}


//
// GDCWasteBits()
//
BOOL  GDCWasteBits
(
    PGDC_EXPLODE    pgdcExp,
    UINT            cBits
)
{
    if (cBits <= pgdcExp->SrcBits)
    {
        pgdcExp->SrcByte >>= cBits;
        pgdcExp->SrcBits -= cBits;
    }
    else
    {
        pgdcExp->SrcByte >>= pgdcExp->SrcBits;

        //
        // We need to advance to the next source byte.  Can we, or have
        // we reached the end already?
        //
        if (!pgdcExp->cbSrc)
            return(FALSE);

        pgdcExp->SrcByte |= (*pgdcExp->pSrc) << 8;

        //
        // Move these to the next byte in the compressed source
        //
        ++(pgdcExp->pSrc);
        --(pgdcExp->cbSrc);

        pgdcExp->SrcByte >>= (cBits - pgdcExp->SrcBits);
        pgdcExp->SrcBits = 8 - (cBits - pgdcExp->SrcBits);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\globals.h ===
//
// GLOBALS.H
// Global variables
//
// This file included in normal source files generates the extern decls
// for our global variables.  In globals.c, because we define 
// DC_DEFINE_DATA before including this baby to generate the storage.
//
// Since there are many source files and one globals.c, it saves typing.
//
// Variables prefixed with m_ are per-conference
// Variables prefixed wiht g_ are global
//
// NOTE that by default, all data is initialized to zero when a dll is 
// loaded.  For other default values, use the DC_DATA_VAL instead of
// DC_DATA macro.
//

#include "dbgzones.h"

#include <ast120.h>
#include <shm.h>
#include <im.h>
#include <control.h>
#include <usr.h>
#include <sc.h>
#include <bcd.h>
#include <ba.h>
#include <ch.h>
#include <cm.h>
#include <oa.h>
#include <fh.h>
#include <oe.h>
#include <od.h>
#include <oe2.h>
#include <ssi.h>
#include <host.h>
#include <s20.h>
#include <gdc.h>
#include <pm.h>
#include <bmc.h>
#include <rbc.h>
#include <sbc.h>
#include <sch.h>
#include <swl.h>
#include <view.h>

// INCLUDE THIS LAST; IT USES DEFINITIONS IN THE ABOVE HEADERS
#include <as.h>

// Utility headers
#include <strutil.h>

//
// GLOBALS ACROSS MULTIPLE CALLS
//


// Utility stuff

// Critical sections
DC_DATA_ARRAY ( CRITICAL_SECTION,   g_utLocks, UTLOCK_MAX );

// Event info
DC_DATA ( ATOM,             g_utWndClass);

// Task list
DC_DATA_ARRAY ( UT_CLIENT,  g_autTasks, UTTASK_MAX );


// UI
DC_DATA     ( PUT_CLIENT,   g_putUI );
DC_DATA     ( HICON,        g_hetASIcon );
DC_DATA     ( HICON,        g_hetASIconSmall );
DC_DATA     ( HICON,        g_hetDeskIcon );
DC_DATA     ( HICON,        g_hetDeskIconSmall );
DC_DATA     ( HBITMAP,      g_hetCheckBitmap );
DC_DATA     ( HFONT,        g_hetSharedFont );

// Call Manager (T.120)
DC_DATA     ( PUT_CLIENT,   g_putCMG );
DC_DATA     ( PCM_PRIMARY,  g_pcmPrimary );
DC_DATA     ( UINT,         g_mgAttachCount );
DC_DATA_ARRAY ( MG_CLIENT,  g_amgClients, MGTASK_MAX);

// App Sharing
DC_DATA     ( PUT_CLIENT,   g_putAS );

DC_DATA     ( HINSTANCE,    g_asInstance );
DC_DATA     ( BOOL,         g_asWin95 );
DC_DATA     ( BOOL,         g_asNT5 );
DC_DATA     ( UINT,         g_asOptions );
DC_DATA     ( DWORD,        g_asMainThreadId );
DC_DATA     ( HWND,         g_asMainWindow );
DC_DATA     ( BOOL,         g_asCanHost );
DC_DATA     ( UINT,         g_asSettings );


//
// Shared Memory FOR DISPLAY DRIVER
//
DC_DATA     ( LPSHM_SHARED_MEMORY,  g_asSharedMemory );
DC_DATA_ARRAY ( LPOA_SHARED_DATA,   g_poaData,   2 );


//
// The BPP our driver is capturing at may NOT be the same as the screen's
// color depth.  At > 8 bpp, our driver always captures at 24bpp to avoid
// bitmask conversion nonsense.  In other words, in NT 5.0, our shadow 
// driver behaves a lot more like a real driver to GDI.  We must tell GDI
// what color format we want; GDI will not just hackily give us the same
// goop as the real disply like in NT 4.0 SP-3.  NT 5.0 has real multiple 
// monitor and driver support.
//

DC_DATA ( UINT,             g_usrScreenBPP );
DC_DATA ( UINT,             g_usrCaptureBPP );
DC_DATA ( BOOL,             g_usrPalettized );

DC_DATA ( ASSession,        g_asSession );

DC_DATA ( BOOL,             g_osiInitialized );

//
// CPC capabilities
//
DC_DATA ( CPCALLCAPS,       g_cpcLocalCaps );



//
// Font Handler
//

//
// List of local fonts
//
DC_DATA ( LPFHLOCALFONTS,   g_fhFonts );




//
// General Data Compressor
//



// This is effectively const, it's just too complicated to declare so we
// calculate it once in GDC_Init().
DC_DATA_ARRAY(BYTE, s_gdcDistDecode, GDC_DECODED_SIZE);

// This is effectively const, it's just too big to declare.  We calculate
// it once in GDC_Init().
DC_DATA_ARRAY(BYTE, s_gdcLenDecode, GDC_DECODED_SIZE);


//
// Lit:  Bits, Codes
// NOTE:  These are effectively _const.  There's just too many of them
// to put in a const array.  So we calculate them once in GDC_Init().
//
//
// Len and Lit codes
//

//
// BOGUS LAURABU
// BUGBUG
// s_gdcLitBits, s_gdcLitCode, s__gdcDistDecode, and s_gdcLenDecode are
// really constant.  Instead of computing once at Init time, get the data
// and put it const here.
//
DC_DATA_ARRAY(BYTE,     s_gdcLitBits, GDC_LIT_SIZE);
DC_DATA_ARRAY(WORD,     s_gdcLitCode, GDC_LIT_SIZE);




//
// Input Manager
//

//
// High level input manager in the core
//


// Pointer to IM variables accessed in NT/Win95 low level implementations
DC_DATA (LPIM_SHARED_DATA,  g_lpimSharedData );




//
// Order Decoder
//

//
// Table used to map Windows dword ROP values to logical ROP values.
//
#ifndef DC_DEFINE_DATA
extern const UINT s_odWindowsROPs[256];
#else
       const UINT s_odWindowsROPs[256] =
{
    0x00000042, 0x00010289, 0x00020C89, 0x000300AA,
    0x00040C88, 0x000500A9, 0x00060865, 0x000702C5,
    0x00080F08, 0x00090245, 0x000A0329, 0x000B0B2A,
    0x000C0324, 0x000D0B25, 0x000E08A5, 0x000F0001,
    0x00100C85, 0x001100A6, 0x00120868, 0x001302C8,
    0x00140869, 0x001502C9, 0x00165CCA, 0x00171D54,
    0x00180D59, 0x00191CC8, 0x001A06C5, 0x001B0768,
    0x001C06CA, 0x001D0766, 0x001E01A5, 0x001F0385,
    0x00200F09, 0x00210248, 0x00220326, 0x00230B24,
    0x00240D55, 0x00251CC5, 0x002606C8, 0x00271868,
    0x00280369, 0x002916CA, 0x002A0CC9, 0x002B1D58,
    0x002C0784, 0x002D060A, 0x002E064A, 0x002F0E2A,
    0x0030032A, 0x00310B28, 0x00320688, 0x00330008,
    0x003406C4, 0x00351864, 0x003601A8, 0x00370388,
    0x0038078A, 0x00390604, 0x003A0644, 0x003B0E24,
    0x003C004A, 0x003D18A4, 0x003E1B24, 0x003F00EA,
    0x00400F0A, 0x00410249, 0x00420D5D, 0x00431CC4,
    0x00440328, 0x00450B29, 0x004606C6, 0x0047076A,
    0x00480368, 0x004916C5, 0x004A0789, 0x004B0605,
    0x004C0CC8, 0x004D1954, 0x004E0645, 0x004F0E25,
    0x00500325, 0x00510B26, 0x005206C9, 0x00530764,
    0x005408A9, 0x00550009, 0x005601A9, 0x00570389,
    0x00580785, 0x00590609, 0x005A0049, 0x005B18A9,
    0x005C0649, 0x005D0E29, 0x005E1B29, 0x005F00E9,
    0x00600365, 0x006116C6, 0x00620786, 0x00630608,
    0x00640788, 0x00650606, 0x00660046, 0x006718A8,
    0x006858A6, 0x00690145, 0x006A01E9, 0x006B178A,
    0x006C01E8, 0x006D1785, 0x006E1E28, 0x006F0C65,
    0x00700CC5, 0x00711D5C, 0x00720648, 0x00730E28,
    0x00740646, 0x00750E26, 0x00761B28, 0x007700E6,
    0x007801E5, 0x00791786, 0x007A1E29, 0x007B0C68,
    0x007C1E24, 0x007D0C69, 0x007E0955, 0x007F03C9,
    0x008003E9, 0x00810975, 0x00820C49, 0x00831E04,
    0x00840C48, 0x00851E05, 0x008617A6, 0x008701C5,
    0x008800C6, 0x00891B08, 0x008A0E06, 0x008B0666,
    0x008C0E08, 0x008D0668, 0x008E1D7C, 0x008F0CE5,
    0x00900C45, 0x00911E08, 0x009217A9, 0x009301C4,
    0x009417AA, 0x009501C9, 0x00960169, 0x0097588A,
    0x00981888, 0x00990066, 0x009A0709, 0x009B07A8,
    0x009C0704, 0x009D07A6, 0x009E16E6, 0x009F0345,
    0x00A000C9, 0x00A11B05, 0x00A20E09, 0x00A30669,
    0x00A41885, 0x00A50065, 0x00A60706, 0x00A707A5,
    0x00A803A9, 0x00A90189, 0x00AA0029, 0x00AB0889,
    0x00AC0744, 0x00AD06E9, 0x00AE0B06, 0x00AF0229,
    0x00B00E05, 0x00B10665, 0x00B21974, 0x00B30CE8,
    0x00B4070A, 0x00B507A9, 0x00B616E9, 0x00B70348,
    0x00B8074A, 0x00B906E6, 0x00BA0B09, 0x00BB0226,
    0x00BC1CE4, 0x00BD0D7D, 0x00BE0269, 0x00BF08C9,
    0x00C000CA, 0x00C11B04, 0x00C21884, 0x00C3006A,
    0x00C40E04, 0x00C50664, 0x00C60708, 0x00C707AA,
    0x00C803A8, 0x00C90184, 0x00CA0749, 0x00CB06E4,
    0x00CC0020, 0x00CD0888, 0x00CE0B08, 0x00CF0224,
    0x00D00E0A, 0x00D1066A, 0x00D20705, 0x00D307A4,
    0x00D41D78, 0x00D50CE9, 0x00D616EA, 0x00D70349,
    0x00D80745, 0x00D906E8, 0x00DA1CE9, 0x00DB0D75,
    0x00DC0B04, 0x00DD0228, 0x00DE0268, 0x00DF08C8,
    0x00E003A5, 0x00E10185, 0x00E20746, 0x00E306EA,
    0x00E40748, 0x00E506E5, 0x00E61CE8, 0x00E70D79,
    0x00E81D74, 0x00E95CE6, 0x00EA02E9, 0x00EB0849,
    0x00EC02E8, 0x00ED0848, 0x00EE0086, 0x00EF0A08,
    0x00F00021, 0x00F10885, 0x00F20B05, 0x00F3022A,
    0x00F40B0A, 0x00F50225, 0x00F60265, 0x00F708C5,
    0x00F802E5, 0x00F90845, 0x00FA0089, 0x00FB0A09,
    0x00FC008A, 0x00FD0A0A, 0x00FE02A9, 0x00FF0062
};
#endif // !DC_DEFINE_DATA


//
// Table used by ODAdjustVGAColor (qv)
//
// Note that the table is searched from top to bottom, so black, white and
// the two greys are at the top, on the grounds that they will be used more
// often than the other colors.
//
#ifndef DC_DEFINE_DATA
extern const OD_ADJUST_VGA_STRUCT s_odVGAColors[16];
#else
       const OD_ADJUST_VGA_STRUCT s_odVGAColors[16] =
{
//       color   addMask   andMask  testMask         result
    { 0x000000, 0x000000, 0xF8F8F8, 0x000000, {0x00, 0x00, 0x00 }}, //
    { 0xFFFFFF, 0x000000, 0xF8F8F8, 0xF8F8F8, {0xFF, 0xFF, 0xFF }}, //
    { 0x808080, 0x080808, 0xF0F0F0, 0x808080, {0x80, 0x80, 0x80 }}, //
    { 0xC0C0C0, 0x080808, 0xF0F0F0, 0xC0C0C0, {0xC0, 0xC0, 0xC0 }}, //
    { 0x000080, 0x000008, 0xF8F8F0, 0x000080, {0x00, 0x00, 0x80 }}, //
    { 0x008000, 0x000800, 0xF8F0F8, 0x008000, {0x00, 0x80, 0x00 }}, //
    { 0x008080, 0x000808, 0xF8F0F0, 0x008080, {0x00, 0x80, 0x80 }}, //
    { 0x800000, 0x080000, 0xF0F8F8, 0x800000, {0x80, 0x00, 0x00 }}, //
    { 0x800080, 0x080008, 0xF0F8F0, 0x800080, {0x80, 0x00, 0x80 }}, //
    { 0x808000, 0x080800, 0xF0F0F8, 0x808000, {0x80, 0x80, 0x00 }}, //
    { 0x0000FF, 0x000000, 0xF8F8F8, 0x0000F8, {0x00, 0x00, 0xFF }}, //
    { 0x00FF00, 0x000000, 0xF8F8F8, 0x00F800, {0x00, 0xFF, 0x00 }}, //
    { 0x00FFFF, 0x000000, 0xF8F8F8, 0x00F8F8, {0x00, 0xFF, 0xFF }}, //
    { 0xFF0000, 0x000000, 0xF8F8F8, 0xF80000, {0xFF, 0x00, 0x00 }}, //
    { 0xFF00FF, 0x000000, 0xF8F8F8, 0xF800F8, {0xFF, 0x00, 0xFF }}, //
    { 0xFFFF00, 0x000000, 0xF8F8F8, 0xF8F800, {0xFF, 0xFF, 0x00 }}  //
};
#endif // !DC_DEFINE_DATA



//
// 2nd Level Order Decoder
//



//
// Entries can be of fixed size of variable size.  Variable size entries
// must be the last in each order structure.  OE2 encodes from packed
// structures containing variable entries.  (ie unused bytes are not
// present in the first level encoding structure passed to OE2).  OD2
// unencodes variable entries into the unpacked structures.
//

//
// Fields can either be signed or unsigned
//
#define SIGNED_FIELD    TRUE
#define UNSIGNED_FIELD  FALSE

//
// Field is a fixed size
//   type   - The unencoded order structure type
//   size   - The size of the encoded version of the field
//   signed - Is the field a signed field ?
//   field  - The name of the field in the order structure
//
#define ETABLE_FIXED_ENTRY(type,size,signed,field)      \
  { FIELD_OFFSET(type,field),                            \
    FIELD_SIZE(type,field),                              \
    size,                                               \
    signed,                                             \
    (UINT)(OE2_ETF_FIXED) }

//
// Field is coordinate of a fixed size
//   type   - The unencoded order structure type
//   size   - The size of the encoded version of the field
//   signed - Is the field a signed field ?
//   field  - The name of the field in the order structure
//
#define ETABLE_FIXED_COORDS_ENTRY(type,size,signed,field)      \
  { FIELD_OFFSET(type,field),                            \
    FIELD_SIZE(type,field),                              \
    size,                                               \
    signed,                                             \
    (UINT)(OE2_ETF_FIXED|OE2_ETF_COORDINATES) }

//
// Field is a fixed number of bytes (array?)
//   type   - The unencoded order structure type
//   size   - The number of bytes in the encoded version of the field
//   signed - Is the field a signed field ?
//   field  - The name of the field in the order structure
//
#define ETABLE_DATA_ENTRY(type,size,signed,field)       \
  { FIELD_OFFSET(type,field),                            \
    FIELD_SIZE(type,field),                              \
    size,                                               \
    signed,                                             \
    (UINT)(OE2_ETF_FIXED|OE2_ETF_DATA) }

//
// Field is a variable structure of the form
//   typedef struct
//   {
//      UINT len;
//      varType  varEntry[len];
//   } varStruct
//
//   type   - The unencoded order structure type
//   size   - The size of the encoded version of the field
//   signed - Is the field a signed field ?
//   field  - The name of the field in the order structure (varStruct)
//   elem   - The name of the variable element array (varEntry)
//
#define ETABLE_VARIABLE_ENTRY(type,size,signed,field,elem)     \
  { FIELD_OFFSET(type,field.len),                        \
    FIELD_SIZE(type,field.elem[0]),                      \
    size,                                               \
    signed,                                             \
    (UINT)(OE2_ETF_VARIABLE)}

//
// Field is a variable structure of the form
//   typedef struct
//   {
//      UINT len;
//      varType  varEntry[len];
//   } varStruct
//
//   type   - The unencoded order structure type
//   size   - The size of the encoded version of the field
//   signed - Is the field a signed field ?
//   field  - The name of the field in the order structure (varStruct)
//   elem   - The name of the variable element array (varEntry)
//
// This macro is used instead of the ETABLE_VARIABLE_ENTRY macro when the
// elements of the array are of type TSHR_POINT16.  Otherwise on bigendian
// machines the flipping macros will reverse the order of the coordinates.
//
#define ETABLE_VARIABLE_ENTRY_POINTS(type,size,signed,field,elem)     \
  { FIELD_OFFSET(type,field.len),                                      \
    FIELD_SIZE(type,field.elem[0].x),                                  \
    size,                                                             \
    signed,                                                           \
    (UINT)(OE2_ETF_VARIABLE)}

//
// Field is a variable structure containing coords of the form
//   typedef struct
//   {
//      UINT len;
//      varCoord varEntry[len];
//   } varStruct
//
//   type   - The unencoded order structure type
//   size   - The size of the encoded version of the field
//   signed - Is the field a signed field ?
//   field  - The name of the field in the order structure (varStruct)
//   elem   - The name of the variable element array (varEntry)
//
#define ETABLE_VARIABLE_COORDS_ENTRY(type,size,signed,field,elem)   \
  { FIELD_OFFSET(type,field.len),                                    \
    FIELD_SIZE(type,field.elem[0]),                                  \
    size,                                                           \
    signed,                                                         \
    (UINT)(OE2_ETF_VARIABLE|OE2_ETF_COORDINATES)}

#ifndef DC_DEFINE_DATA
extern const OE2ETTABLE s_etable;
#else
       const OE2ETTABLE s_etable =
{
    //
    // Pointers to the start of the entries for each order.
    //
    {
        s_etable.DstBltFields,
        s_etable.PatBltFields,
        s_etable.ScrBltFields,
        s_etable.MemBltFields,
        s_etable.Mem3BltFields,
        s_etable.TextOutFields,
        s_etable.ExtTextOutFields,
        NULL,						// Can be used for next order.
        s_etable.RectangleFields,
        s_etable.LineToFields,
        s_etable.OpaqueRectFields,
        s_etable.SaveBitmapFields,
        s_etable.DeskScrollFields,
        s_etable.MemBltR2Fields,
        s_etable.Mem3BltR2Fields,
        s_etable.PolygonFields,
        s_etable.PieFields,
        s_etable.EllipseFields,
        s_etable.ArcFields,
        s_etable.ChordFields,
        s_etable.PolyBezierFields,
        s_etable.RoundRectFields
    },

    //
    // Number of fields for each order.
    //
    {
        OE2_NUM_DSTBLT_FIELDS,
        OE2_NUM_PATBLT_FIELDS,
        OE2_NUM_SCRBLT_FIELDS,
        OE2_NUM_MEMBLT_FIELDS,
        OE2_NUM_MEM3BLT_FIELDS,
        OE2_NUM_TEXTOUT_FIELDS,
        OE2_NUM_EXTTEXTOUT_FIELDS,
        0,							// Change when installing new order.
        OE2_NUM_RECTANGLE_FIELDS,
        OE2_NUM_LINETO_FIELDS,
        OE2_NUM_OPAQUERECT_FIELDS,
        OE2_NUM_SAVEBITMAP_FIELDS,
        OE2_NUM_DESKSCROLL_FIELDS,
        OE2_NUM_MEMBLT_R2_FIELDS,
        OE2_NUM_MEM3BLT_R2_FIELDS,
        OE2_NUM_POLYGON_FIELDS,
        OE2_NUM_PIE_FIELDS,
        OE2_NUM_ELLIPSE_FIELDS,
        OE2_NUM_ARC_FIELDS,
        OE2_NUM_CHORD_FIELDS,
        OE2_NUM_POLYBEZIER_FIELDS,
        OE2_NUM_ROUNDRECT_FIELDS
    },

//
// Entries for the DSTBLT_ORDER
//
    {
        ETABLE_FIXED_COORDS_ENTRY(DSTBLT_ORDER, 2, SIGNED_FIELD, nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(DSTBLT_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(DSTBLT_ORDER, 2, SIGNED_FIELD, nWidth),
        ETABLE_FIXED_COORDS_ENTRY(DSTBLT_ORDER, 2, SIGNED_FIELD, nHeight),
        ETABLE_FIXED_ENTRY(DSTBLT_ORDER, 1, UNSIGNED_FIELD, bRop),
        { 0 }
    },

//
// Entries for the PATBLT_ORDER
//
    {
        ETABLE_FIXED_COORDS_ENTRY(PATBLT_ORDER, 2, SIGNED_FIELD, nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(PATBLT_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(PATBLT_ORDER, 2, SIGNED_FIELD, nWidth),
        ETABLE_FIXED_COORDS_ENTRY(PATBLT_ORDER, 2, SIGNED_FIELD, nHeight),
        ETABLE_FIXED_ENTRY(PATBLT_ORDER, 1, UNSIGNED_FIELD, bRop),
        ETABLE_DATA_ENTRY(PATBLT_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_DATA_ENTRY(PATBLT_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(PATBLT_ORDER, 1, SIGNED_FIELD, BrushOrgX),
        ETABLE_FIXED_ENTRY(PATBLT_ORDER, 1, SIGNED_FIELD, BrushOrgY),
        ETABLE_FIXED_ENTRY(PATBLT_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(PATBLT_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_DATA_ENTRY(PATBLT_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
        { 0 }
    },

//
// Entries for the SCRBLT_ORDER
//
    {
        ETABLE_FIXED_COORDS_ENTRY(SCRBLT_ORDER, 2, SIGNED_FIELD, nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(SCRBLT_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(SCRBLT_ORDER, 2, SIGNED_FIELD, nWidth),
        ETABLE_FIXED_COORDS_ENTRY(SCRBLT_ORDER, 2, SIGNED_FIELD, nHeight),
        ETABLE_FIXED_ENTRY(SCRBLT_ORDER, 1, UNSIGNED_FIELD, bRop),
        ETABLE_FIXED_COORDS_ENTRY(SCRBLT_ORDER, 2, SIGNED_FIELD, nXSrc),
        ETABLE_FIXED_COORDS_ENTRY(SCRBLT_ORDER, 2, SIGNED_FIELD, nYSrc),
        { 0 }
    },

//
// Entries for the MEMBLT_ORDER
//
    {
        ETABLE_FIXED_ENTRY(MEMBLT_ORDER, 2, UNSIGNED_FIELD, cacheId),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_ORDER, 2, SIGNED_FIELD, nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_ORDER, 2, SIGNED_FIELD, nWidth),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_ORDER, 2, SIGNED_FIELD, nHeight),
        ETABLE_FIXED_ENTRY(MEMBLT_ORDER, 1, UNSIGNED_FIELD, bRop),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_ORDER, 2, SIGNED_FIELD, nXSrc),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_ORDER, 2, SIGNED_FIELD, nYSrc),
        { 0 }
    },

//
// Entries for the MEM3BLT_ORDER
//
    {
        ETABLE_FIXED_ENTRY(MEM3BLT_ORDER, 2, UNSIGNED_FIELD, cacheId),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_ORDER, 2, SIGNED_FIELD, nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_ORDER, 2, SIGNED_FIELD, nWidth),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_ORDER, 2, SIGNED_FIELD, nHeight),
        ETABLE_FIXED_ENTRY(MEM3BLT_ORDER, 1, UNSIGNED_FIELD, bRop),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_ORDER, 2, SIGNED_FIELD, nXSrc),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_ORDER, 2, SIGNED_FIELD, nYSrc),
        ETABLE_DATA_ENTRY(MEM3BLT_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_DATA_ENTRY(MEM3BLT_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(MEM3BLT_ORDER, 1, SIGNED_FIELD, BrushOrgX),
        ETABLE_FIXED_ENTRY(MEM3BLT_ORDER, 1, SIGNED_FIELD, BrushOrgY),
        ETABLE_FIXED_ENTRY(MEM3BLT_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(MEM3BLT_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_DATA_ENTRY(MEM3BLT_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
        { 0 }
    },

//
// Entries for the TEXTOUT_ORDER
//
    {
        ETABLE_FIXED_ENTRY(TEXTOUT_ORDER, 2, SIGNED_FIELD, common.BackMode),
        ETABLE_FIXED_COORDS_ENTRY(TEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                              common.nXStart),
        ETABLE_FIXED_COORDS_ENTRY(TEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                              common.nYStart),
        ETABLE_DATA_ENTRY(TEXTOUT_ORDER, 3, UNSIGNED_FIELD, common.BackColor),
        ETABLE_DATA_ENTRY(TEXTOUT_ORDER, 3, UNSIGNED_FIELD, common.ForeColor),
        ETABLE_FIXED_ENTRY(TEXTOUT_ORDER, 2, SIGNED_FIELD, common.CharExtra),
        ETABLE_FIXED_ENTRY(TEXTOUT_ORDER, 2, SIGNED_FIELD, common.BreakExtra),
        ETABLE_FIXED_ENTRY(TEXTOUT_ORDER, 2, SIGNED_FIELD, common.BreakCount),
        ETABLE_FIXED_ENTRY(TEXTOUT_ORDER, 2, SIGNED_FIELD, common.FontHeight),
        ETABLE_FIXED_ENTRY(TEXTOUT_ORDER, 2, SIGNED_FIELD, common.FontWidth),
        ETABLE_FIXED_ENTRY(TEXTOUT_ORDER, 2, UNSIGNED_FIELD,
                                                           common.FontWeight),
        ETABLE_FIXED_ENTRY(TEXTOUT_ORDER, 2, UNSIGNED_FIELD,
                                                           common.FontFlags),
        ETABLE_FIXED_ENTRY(TEXTOUT_ORDER, 2, UNSIGNED_FIELD,
                                                           common.FontIndex),
        ETABLE_VARIABLE_ENTRY(TEXTOUT_ORDER, 1, UNSIGNED_FIELD,
                                                      variableString, string),
        { 0 }
    },

//
// Entries for the EXTTEXTOUT_ORDER
//
    {
        ETABLE_FIXED_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                             common.BackMode),
        ETABLE_FIXED_COORDS_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                              common.nXStart),
        ETABLE_FIXED_COORDS_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                              common.nYStart),
        ETABLE_DATA_ENTRY(EXTTEXTOUT_ORDER, 3, UNSIGNED_FIELD,
                                                            common.BackColor),
        ETABLE_DATA_ENTRY(EXTTEXTOUT_ORDER, 3, UNSIGNED_FIELD,
                                                            common.ForeColor),
        ETABLE_FIXED_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                            common.CharExtra),
        ETABLE_FIXED_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                           common.BreakExtra),
        ETABLE_FIXED_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                           common.BreakCount),
        ETABLE_FIXED_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                           common.FontHeight),
        ETABLE_FIXED_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                            common.FontWidth),
        ETABLE_FIXED_ENTRY(EXTTEXTOUT_ORDER, 2, UNSIGNED_FIELD,
                                                           common.FontWeight),
        ETABLE_FIXED_ENTRY(EXTTEXTOUT_ORDER, 2, UNSIGNED_FIELD,
                                                            common.FontFlags),
        ETABLE_FIXED_ENTRY(EXTTEXTOUT_ORDER, 2, UNSIGNED_FIELD,
                                                           common.FontIndex),
        ETABLE_FIXED_ENTRY(EXTTEXTOUT_ORDER, 2, UNSIGNED_FIELD, fuOptions),
        ETABLE_FIXED_COORDS_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                              rectangle.left),
        ETABLE_FIXED_COORDS_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                               rectangle.top),
        ETABLE_FIXED_COORDS_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                             rectangle.right),
        ETABLE_FIXED_COORDS_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                            rectangle.bottom),
        ETABLE_VARIABLE_ENTRY(EXTTEXTOUT_ORDER, 1, UNSIGNED_FIELD,
                                                      variableString, string),
        ETABLE_VARIABLE_COORDS_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                      variableDeltaX, deltaX),
        { 0 }
    },

//
// Entries for the RECTANGLE_ORDER
//
    {
        ETABLE_FIXED_ENTRY(RECTANGLE_ORDER, 2, SIGNED_FIELD, BackMode),
        ETABLE_FIXED_COORDS_ENTRY(RECTANGLE_ORDER, 2, SIGNED_FIELD,
                                                                   nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(RECTANGLE_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(RECTANGLE_ORDER, 2, SIGNED_FIELD,
                                                                  nRightRect),
        ETABLE_FIXED_COORDS_ENTRY(RECTANGLE_ORDER, 2, SIGNED_FIELD,
                                                                 nBottomRect),
        ETABLE_DATA_ENTRY(RECTANGLE_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_DATA_ENTRY(RECTANGLE_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(RECTANGLE_ORDER, 1, SIGNED_FIELD, BrushOrgX),
        ETABLE_FIXED_ENTRY(RECTANGLE_ORDER, 1, SIGNED_FIELD, BrushOrgY),
        ETABLE_FIXED_ENTRY(RECTANGLE_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(RECTANGLE_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_DATA_ENTRY(RECTANGLE_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
        ETABLE_FIXED_ENTRY(RECTANGLE_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(RECTANGLE_ORDER, 1, UNSIGNED_FIELD, PenStyle),
        ETABLE_FIXED_ENTRY(RECTANGLE_ORDER, 1, UNSIGNED_FIELD, PenWidth),
        ETABLE_DATA_ENTRY(RECTANGLE_ORDER, 3, UNSIGNED_FIELD, PenColor),
        { 0 }
    },

//
// Entries for the LINETO_ORDER
//
    {
        ETABLE_FIXED_ENTRY(LINETO_ORDER, 2, SIGNED_FIELD, BackMode),
        ETABLE_FIXED_COORDS_ENTRY(LINETO_ORDER, 2, SIGNED_FIELD, nXStart),
        ETABLE_FIXED_COORDS_ENTRY(LINETO_ORDER, 2, SIGNED_FIELD, nYStart),
        ETABLE_FIXED_COORDS_ENTRY(LINETO_ORDER, 2, SIGNED_FIELD, nXEnd),
        ETABLE_FIXED_COORDS_ENTRY(LINETO_ORDER, 2, SIGNED_FIELD, nYEnd),
        ETABLE_DATA_ENTRY(LINETO_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_FIXED_ENTRY(LINETO_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(LINETO_ORDER, 1, UNSIGNED_FIELD, PenStyle),
        ETABLE_FIXED_ENTRY(LINETO_ORDER, 1, UNSIGNED_FIELD, PenWidth),
        ETABLE_DATA_ENTRY(LINETO_ORDER, 3, UNSIGNED_FIELD, PenColor),
        { 0 }
    },

//
// Entries for the OPAQUERECT_ORDER
//
    {
        ETABLE_FIXED_COORDS_ENTRY(OPAQUERECT_ORDER, 2, SIGNED_FIELD,
                                                                   nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(OPAQUERECT_ORDER, 2, SIGNED_FIELD,
                                                                    nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(OPAQUERECT_ORDER, 2, SIGNED_FIELD, nWidth),
        ETABLE_FIXED_COORDS_ENTRY(OPAQUERECT_ORDER, 2, SIGNED_FIELD, nHeight),
        ETABLE_DATA_ENTRY(OPAQUERECT_ORDER, 3, UNSIGNED_FIELD, Color),
        { 0 }
    },

//
// Entries for the SAVEBITMAP_ORDER
//
    {
        ETABLE_FIXED_ENTRY(SAVEBITMAP_ORDER, 4, UNSIGNED_FIELD,
                                                         SavedBitmapPosition),
        ETABLE_FIXED_COORDS_ENTRY(SAVEBITMAP_ORDER, 2, SIGNED_FIELD,
                                                                   nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(SAVEBITMAP_ORDER, 2, SIGNED_FIELD,
                                                                    nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(SAVEBITMAP_ORDER, 2, SIGNED_FIELD,
                                                                  nRightRect),
        ETABLE_FIXED_COORDS_ENTRY(SAVEBITMAP_ORDER, 2, SIGNED_FIELD,
                                                                 nBottomRect),
        ETABLE_FIXED_ENTRY(SAVEBITMAP_ORDER, 1, UNSIGNED_FIELD, Operation),
        { 0 }
    },

//
// Entries for the DESKSCROLL_ORDER
//
    {
        ETABLE_FIXED_COORDS_ENTRY(DESKSCROLL_ORDER, 2, SIGNED_FIELD, xOrigin),
        ETABLE_FIXED_COORDS_ENTRY(DESKSCROLL_ORDER, 2, SIGNED_FIELD, yOrigin),
        { 0 }
    },

//
// Entries for the MEMBLT_R2_ORDER
//
    {
        ETABLE_FIXED_ENTRY(MEMBLT_R2_ORDER, 2, UNSIGNED_FIELD, cacheId),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_R2_ORDER, 2, SIGNED_FIELD,
                                                                   nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_R2_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_R2_ORDER, 2, SIGNED_FIELD, nWidth),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_R2_ORDER, 2, SIGNED_FIELD, nHeight),
        ETABLE_FIXED_ENTRY(MEMBLT_R2_ORDER, 1, UNSIGNED_FIELD, bRop),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_R2_ORDER, 2, SIGNED_FIELD, nXSrc),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_R2_ORDER, 2, SIGNED_FIELD, nYSrc),
        ETABLE_FIXED_ENTRY(MEMBLT_R2_ORDER, 2, UNSIGNED_FIELD, cacheIndex),
        { 0 }
    },

//
// Entries for the MEM3BLT_R2_ORDER
//
    {
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 2, UNSIGNED_FIELD, cacheId),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_R2_ORDER, 2, SIGNED_FIELD,
                                                                   nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_R2_ORDER, 2, SIGNED_FIELD,
                                                                    nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_R2_ORDER, 2, SIGNED_FIELD, nWidth),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_R2_ORDER, 2, SIGNED_FIELD, nHeight),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 1, UNSIGNED_FIELD, bRop),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_R2_ORDER, 2, SIGNED_FIELD, nXSrc),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_R2_ORDER, 2, SIGNED_FIELD, nYSrc),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 1, SIGNED_FIELD,   BrushOrgX),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 1, SIGNED_FIELD,   BrushOrgY),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 2, UNSIGNED_FIELD, cacheIndex),
        { 0 }
    },

//
// Entries for the POLYGON_ORDER
//
    {
        ETABLE_FIXED_ENTRY(POLYGON_ORDER, 2, SIGNED_FIELD, BackMode),
        ETABLE_DATA_ENTRY(POLYGON_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_DATA_ENTRY(POLYGON_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(POLYGON_ORDER, 1, SIGNED_FIELD, BrushOrgX),
        ETABLE_FIXED_ENTRY(POLYGON_ORDER, 1, SIGNED_FIELD, BrushOrgY),
        ETABLE_FIXED_ENTRY(POLYGON_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(POLYGON_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_DATA_ENTRY(POLYGON_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
        ETABLE_FIXED_ENTRY(POLYGON_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(POLYGON_ORDER, 1, UNSIGNED_FIELD, PenStyle),
        ETABLE_FIXED_ENTRY(POLYGON_ORDER, 1, UNSIGNED_FIELD, PenWidth),
        ETABLE_DATA_ENTRY(POLYGON_ORDER, 3, UNSIGNED_FIELD, PenColor),
        ETABLE_FIXED_ENTRY(POLYGON_ORDER, 1, UNSIGNED_FIELD, FillMode),
        ETABLE_VARIABLE_ENTRY_POINTS(POLYGON_ORDER, 2, UNSIGNED_FIELD,
                                                    variablePoints, aPoints),
        { 0 }
    },

//
// Entries for the PIE_ORDER
//
    {
        ETABLE_FIXED_ENTRY(PIE_ORDER, 2, SIGNED_FIELD, BackMode),
        ETABLE_FIXED_COORDS_ENTRY(PIE_ORDER, 2, SIGNED_FIELD, nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(PIE_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(PIE_ORDER, 2, SIGNED_FIELD, nRightRect),
        ETABLE_FIXED_COORDS_ENTRY(PIE_ORDER, 2, SIGNED_FIELD, nBottomRect),
        ETABLE_FIXED_COORDS_ENTRY(PIE_ORDER, 2, SIGNED_FIELD, nXStart),
        ETABLE_FIXED_COORDS_ENTRY(PIE_ORDER, 2, SIGNED_FIELD, nYStart),
        ETABLE_FIXED_COORDS_ENTRY(PIE_ORDER, 2, SIGNED_FIELD, nXEnd),
        ETABLE_FIXED_COORDS_ENTRY(PIE_ORDER, 2, SIGNED_FIELD, nYEnd),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 1, SIGNED_FIELD, BrushOrgX),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 1, SIGNED_FIELD, BrushOrgY),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 1, UNSIGNED_FIELD, PenStyle),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 1, UNSIGNED_FIELD, PenWidth),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 3, UNSIGNED_FIELD, PenColor),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 1, UNSIGNED_FIELD, ArcDirection),
        { 0 }
    },

//
// Entries for the ELLIPSE_ORDER
//
    {
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 2, SIGNED_FIELD, BackMode),
        ETABLE_FIXED_COORDS_ENTRY(ELLIPSE_ORDER, 2, SIGNED_FIELD, nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(ELLIPSE_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(ELLIPSE_ORDER, 2, SIGNED_FIELD, nRightRect),
        ETABLE_FIXED_COORDS_ENTRY(ELLIPSE_ORDER, 2, SIGNED_FIELD,
                                                                 nBottomRect),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 1, SIGNED_FIELD, BrushOrgX),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 1, SIGNED_FIELD, BrushOrgY),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 1, UNSIGNED_FIELD, PenStyle),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 1, UNSIGNED_FIELD, PenWidth),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 3, UNSIGNED_FIELD, PenColor),
        { 0 }
    },

//
// Entries for the ARC_ORDER
//
    {
        ETABLE_FIXED_ENTRY(ARC_ORDER, 2, SIGNED_FIELD, BackMode),
        ETABLE_FIXED_COORDS_ENTRY(ARC_ORDER, 2, SIGNED_FIELD, nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(ARC_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(ARC_ORDER, 2, SIGNED_FIELD, nRightRect),
        ETABLE_FIXED_COORDS_ENTRY(ARC_ORDER, 2, SIGNED_FIELD, nBottomRect),
        ETABLE_FIXED_COORDS_ENTRY(ARC_ORDER, 2, SIGNED_FIELD, nXStart),
        ETABLE_FIXED_COORDS_ENTRY(ARC_ORDER, 2, SIGNED_FIELD, nYStart),
        ETABLE_FIXED_COORDS_ENTRY(ARC_ORDER, 2, SIGNED_FIELD, nXEnd),
        ETABLE_FIXED_COORDS_ENTRY(ARC_ORDER, 2, SIGNED_FIELD, nYEnd),
        ETABLE_FIXED_ENTRY(ARC_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_FIXED_ENTRY(ARC_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(ARC_ORDER, 1, UNSIGNED_FIELD, PenStyle),
        ETABLE_FIXED_ENTRY(ARC_ORDER, 1, UNSIGNED_FIELD, PenWidth),
        ETABLE_FIXED_ENTRY(ARC_ORDER, 3, UNSIGNED_FIELD, PenColor),
        ETABLE_FIXED_ENTRY(ARC_ORDER, 1, UNSIGNED_FIELD, ArcDirection),
        { 0 }
    },

//
// Entries for the CHORD_ORDER
//
    {
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 2, SIGNED_FIELD, BackMode),
        ETABLE_FIXED_COORDS_ENTRY(CHORD_ORDER, 2, SIGNED_FIELD, nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(CHORD_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(CHORD_ORDER, 2, SIGNED_FIELD, nRightRect),
        ETABLE_FIXED_COORDS_ENTRY(CHORD_ORDER, 2, SIGNED_FIELD, nBottomRect),
        ETABLE_FIXED_COORDS_ENTRY(CHORD_ORDER, 2, SIGNED_FIELD, nXStart),
        ETABLE_FIXED_COORDS_ENTRY(CHORD_ORDER, 2, SIGNED_FIELD, nYStart),
        ETABLE_FIXED_COORDS_ENTRY(CHORD_ORDER, 2, SIGNED_FIELD, nXEnd),
        ETABLE_FIXED_COORDS_ENTRY(CHORD_ORDER, 2, SIGNED_FIELD, nYEnd),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 1, SIGNED_FIELD, BrushOrgX),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 1, SIGNED_FIELD, BrushOrgY),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 1, UNSIGNED_FIELD, PenStyle),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 1, UNSIGNED_FIELD, PenWidth),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 3, UNSIGNED_FIELD, PenColor),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 1, UNSIGNED_FIELD, ArcDirection),
        { 0 }
    },

//
// Entries for the POLYBEZIER_ORDER
//
    {
        ETABLE_FIXED_ENTRY(POLYBEZIER_ORDER, 2, SIGNED_FIELD, BackMode),
        ETABLE_DATA_ENTRY(POLYBEZIER_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_DATA_ENTRY(POLYBEZIER_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(POLYBEZIER_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(POLYBEZIER_ORDER, 1, UNSIGNED_FIELD, PenStyle),
        ETABLE_FIXED_ENTRY(POLYBEZIER_ORDER, 1, UNSIGNED_FIELD, PenWidth),
        ETABLE_DATA_ENTRY(POLYBEZIER_ORDER, 3, UNSIGNED_FIELD, PenColor),
        ETABLE_VARIABLE_ENTRY_POINTS(POLYBEZIER_ORDER, 2, UNSIGNED_FIELD,
                                                    variablePoints, aPoints),
        { 0 }
    },

//
// Entries for the ROUNDRECT_ORDER
//  
    {
        ETABLE_FIXED_ENTRY(ROUNDRECT_ORDER, 2, SIGNED_FIELD, BackMode),
        ETABLE_FIXED_COORDS_ENTRY(ROUNDRECT_ORDER, 2, SIGNED_FIELD,
                                                                   nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(ROUNDRECT_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(ROUNDRECT_ORDER, 2, SIGNED_FIELD,
                                                                  nRightRect),
        ETABLE_FIXED_COORDS_ENTRY(ROUNDRECT_ORDER, 2, SIGNED_FIELD,
                                                                 nBottomRect),

        ETABLE_FIXED_COORDS_ENTRY(ROUNDRECT_ORDER, 2, SIGNED_FIELD,
                                                               nEllipseWidth),
        ETABLE_FIXED_COORDS_ENTRY(ROUNDRECT_ORDER, 2, SIGNED_FIELD,
                                                              nEllipseHeight),

        ETABLE_DATA_ENTRY(ROUNDRECT_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_DATA_ENTRY(ROUNDRECT_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(ROUNDRECT_ORDER, 1, SIGNED_FIELD, BrushOrgX),
        ETABLE_FIXED_ENTRY(ROUNDRECT_ORDER, 1, SIGNED_FIELD, BrushOrgY),
        ETABLE_FIXED_ENTRY(ROUNDRECT_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(ROUNDRECT_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_DATA_ENTRY(ROUNDRECT_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
        ETABLE_FIXED_ENTRY(ROUNDRECT_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(ROUNDRECT_ORDER, 1, UNSIGNED_FIELD, PenStyle),
        ETABLE_FIXED_ENTRY(ROUNDRECT_ORDER, 1, UNSIGNED_FIELD, PenWidth),
        ETABLE_DATA_ENTRY(ROUNDRECT_ORDER, 3, UNSIGNED_FIELD, PenColor),
        { 0 }
    }
};
#endif // !DC_DEFINE_DATA



//
// T.120 S20 
//

//
// The S20 MCS channel registered with GCC.
//
DC_DATA( NET_UID,           g_s20LocalID );
DC_DATA( NET_CHANNEL_ID,    g_s20BroadcastID );

DC_DATA( UINT,              g_s20State );
DC_DATA( PMG_CLIENT,        g_s20pmgClient );
DC_DATA( BOOL,              g_s20JoinedLocal );

DC_DATA( UINT,              g_s20ShareCorrelator );
DC_DATA( UINT,              g_s20Generation );

//
// This is S20_CREATE or S20_JOIN if we need to issue a create or join when
// we have succesfully joined the channel.
//
DC_DATA( UINT, g_s20Pend );

//
// The control packet queue and indexes.  The head is the next packet which
// should be sent, the tail is where the next packet should be added.  If
// they are equal there are no packets on the queue.
//
DC_DATA( UINT, g_s20ControlPacketQHead );
DC_DATA( UINT, g_s20ControlPacketQTail );
DC_DATA_ARRAY( S20CONTROLPACKETQENTRY,
                    g_s20ControlPacketQ,
                    S20_MAX_QUEUED_CONTROL_PACKETS );



//
// Sent Bitmap Cache
//

DC_DATA ( BOOL,             g_sbcEnabled );
DC_DATA_ARRAY ( LPSBC_SHUNT_BUFFER,     g_asbcShuntBuffers, SBC_NUM_TILE_SIZES );
DC_DATA_ARRAY ( DWORD,                  g_asbcBitMasks, 3 );



//
// Share Controller
//

DC_DATA ( PCM_CLIENT,       g_pcmClientSc);


//
// Scheduler
//

DC_DATA     ( BOOL,             g_schTerminating );
DC_DATA     ( UINT,             g_schCurrentMode );
DC_DATA     ( UINT,             g_schTimeoutPeriod );
DC_DATA     ( UINT,             g_schLastTurboModeSwitch );
DC_DATA     ( HANDLE,           g_schEvent );
DC_DATA     ( DWORD,            g_schThreadID ); 
DC_DATA     ( BOOL,             g_schMessageOutstanding );
DC_DATA     ( BOOL,             g_schStayAwake );
DC_DATA     ( CRITICAL_SECTION, g_schCriticalSection );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\oa.cpp ===
#include "precomp.h"


//
// OA.CPP
// Order Accumulation, both cpi32 and display driver sides
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_ORDER



//
//
// FUNCTION: OA_ResetOrderList
//
//
// DESCRIPTION:
//
// Frees all Orders and Additional Order Data in the Order List.
// Frees up the Order Heap memory.
//
//
// PARAMETERS:
//
// None.
//
//
// RETURNS:
//
// Nothing.
//
//
void  ASHost::OA_ResetOrderList(void)
{
    LPOA_SHARED_DATA lpoaShared;

    DebugEntry(ASHost::OA_ResetOrderList);

    TRACE_OUT(("Free order list"));

    lpoaShared = OA_SHM_START_WRITING;

    //
    // First free all the orders on the list.
    //
    OAFreeAllOrders(lpoaShared);

    //
    // Ensure that the list pointers are NULL.
    //
    if ((lpoaShared->orderListHead.next != 0) || (lpoaShared->orderListHead.prev != 0))
    {
        ERROR_OUT(("Non-NULL list pointers (%lx)(%lx)",
                       lpoaShared->orderListHead.next,
                       lpoaShared->orderListHead.prev));

        COM_BasedListInit(&lpoaShared->orderListHead);
    }

    OA_SHM_STOP_WRITING;
    DebugExitVOID(ASHost::OA_ResetOrderList);
}

//
// OA_SyncOutgoing()
// Called when a share starts or somebody new joins the share.
// Resets currently accumulated orders, which were based on old obsolete
// caps and data.
//
void  ASHost::OA_SyncOutgoing(void)
{
    OAFreeAllOrders(g_poaData[1 - g_asSharedMemory->displayToCore.newBuffer]);
}


//
//
// OA_GetFirstListOrder()
//
// Returns:
//   Pointer to the first order in the Order List.
//
//
LPINT_ORDER  ASHost::OA_GetFirstListOrder(void)
{
    LPOA_SHARED_DATA lpoaShared;
    LPINT_ORDER retOrder = NULL;

    DebugEntry(ASHost::OA_GetFirstListOrder);

    lpoaShared = OA_SHM_START_READING;

    //
    // Get the first entry from the linked list.
    //
    retOrder = (LPINT_ORDER)COM_BasedListFirst(&lpoaShared->orderListHead,
        FIELD_OFFSET(INT_ORDER, OrderHeader.list));

    OA_SHM_STOP_READING;

    TRACE_OUT(("First order = 0x%08x", retOrder));

    DebugExitVOID(ASHost::OA_GetFirstListOrder);
    return(retOrder);
}


//
//
// OA_RemoveListOrder(..)
//
// Removes the specified order from the Order List by marking it as spoilt.
//
// Returns:
//   Pointer to the order following the removed order.
//
//
LPINT_ORDER  ASHost::OA_RemoveListOrder(LPINT_ORDER pCondemnedOrder)
{
    LPOA_SHARED_DATA lpoaShared;
    LPINT_ORDER      pSaveOrder;

    DebugEntry(ASHost::OA_RemoveListOrder);

    TRACE_OUT(("Remove list order 0x%08x", pCondemnedOrder));

    lpoaShared = OA_SHM_START_WRITING;

    //
    // Check for a valid order.
    //
    if (pCondemnedOrder->OrderHeader.Common.fOrderFlags & OF_SPOILT)
    {
        TRACE_OUT(("Invalid order"));
        DC_QUIT;
    }

    //
    // Mark the order as spoilt.
    //
    pCondemnedOrder->OrderHeader.Common.fOrderFlags |= OF_SPOILT;

    //
    // Update the count of bytes currently in the Order List.
    //
    lpoaShared->totalOrderBytes -= (UINT)MAX_ORDER_SIZE(pCondemnedOrder);

    //
    // SAve the order so we can remove it from the linked list after having
    // got the next element in the chain.
    //
    pSaveOrder = pCondemnedOrder;

    pCondemnedOrder = (LPINT_ORDER)COM_BasedListNext(&(lpoaShared->orderListHead),
        pCondemnedOrder, FIELD_OFFSET(INT_ORDER, OrderHeader.list));

    ASSERT(pCondemnedOrder != pSaveOrder);

    //
    // Delete the unwanted order from the linked list.
    //
    COM_BasedListRemove(&pSaveOrder->OrderHeader.list);

    //
    // Check that the list is still consistent with the total number of
    // order bytes.
    //
    if ( (lpoaShared->orderListHead.next != 0) &&
         (lpoaShared->orderListHead.prev != 0) &&
         (lpoaShared->totalOrderBytes    == 0) )
    {
        ERROR_OUT(("List head wrong: %ld %ld", lpoaShared->orderListHead.next,
                                                 lpoaShared->orderListHead.prev));
        COM_BasedListInit(&lpoaShared->orderListHead);
        pCondemnedOrder = NULL;
    }

DC_EXIT_POINT:
    OA_SHM_STOP_WRITING;

    DebugExitPVOID(ASHost::OA_RemoveListOrder, pCondemnedOrder);
    return(pCondemnedOrder);
}


//
//
// OA_GetTotalOrderListBytes(..)
//
// Returns:
//   The total number of bytes in the orders currently stored in the Order
//   List.
//
//
UINT  ASHost::OA_GetTotalOrderListBytes(void)
{
    LPOA_SHARED_DATA lpoaShared;
    UINT        rc;

    DebugEntry(ASHost::OA_GetTotalOrderListBytes);

    lpoaShared = OA_SHM_START_READING;

    rc = lpoaShared->totalOrderBytes;

    OA_SHM_STOP_READING;

    DebugExitDWORD(ASHost::OA_GetTotalOrderListBytes, rc);
    return(rc);
}



//
// OA_LocalHostReset()
//
void ASHost::OA_LocalHostReset(void)
{
    OA_FLOW_CONTROL oaFlowEsc;

    DebugEntry(ASHost::OA_LocalHostReset);

    m_oaFlow = OAFLOW_FAST;
    oaFlowEsc.oaFlow = m_oaFlow;
    OSI_FunctionRequest(OA_ESC_FLOW_CONTROL, (LPOSI_ESCAPE_HEADER)&oaFlowEsc, sizeof(oaFlowEsc));

    DebugExitVOID(ASHost::OA_LocalHostReset);
}


//
// OA_FlowControl()
// Sees if we've changed between fast and slow throughput, and adjusts some
// accumulation variables accordingly.
//
void  ASHost::OA_FlowControl(UINT newSize)
{
    OA_FLOW_CONTROL     oaFlowEsc;

    DebugEntry(ASHost::OA_FlowControl);

    //
    // Work out the new parameters.
    //
    if (newSize < OA_FAST_THRESHOLD)
    {
        //
        // Throughput is slow
        //
        if (m_oaFlow == OAFLOW_FAST)
        {
            m_oaFlow = OAFLOW_SLOW;
            TRACE_OUT(("OA_FlowControl:  SLOW; spoil more orders and spoil by SDA"));
        }
        else
        {
            // No change
            DC_QUIT;
        }
    }
    else
    {
        //
        // Throughput is fast
        //
        if (m_oaFlow == OAFLOW_SLOW)
        {
            m_oaFlow = OAFLOW_FAST;
            TRACE_OUT(("OA_FlowControl:  FAST; spoil fewer orders and don't spoil by SDA"));
        }
        else
        {
            // No change
            DC_QUIT;
        }
    }

    //
    // Tell the display driver about the new state
    //
    oaFlowEsc.oaFlow    = m_oaFlow;
    OSI_FunctionRequest(OA_ESC_FLOW_CONTROL, (LPOSI_ESCAPE_HEADER)&oaFlowEsc, sizeof(oaFlowEsc));

DC_EXIT_POINT:
    DebugExitVOID(ASHost::OA_FlowControl);
}


//
// OA_QueryOrderAccum - see oa.h
//
UINT  ASHost::OA_QueryOrderAccum(void)
{
    LPOA_FAST_DATA lpoaFast;
    UINT rc = 0;

    DebugEntry(ASHost::OA_QueryOrderAccum);

    lpoaFast = OA_FST_START_WRITING;

    //
    // Get the current value.
    //
    rc = lpoaFast->ordersAccumulated;

    //
    // Clear the value for next time we swap the buffers.
    //
    lpoaFast->ordersAccumulated = 0;

    OA_FST_STOP_WRITING;
    DebugExitDWORD(ASHost::OA_QueryOrderAccum, rc);
    return(rc);
}





//
// OAFreeAllOrders
//
// Free the all the individual orders on the orders list, without
// discarding the list itself.
//
void  ASHost::OAFreeAllOrders(LPOA_SHARED_DATA lpoaShared)
{
    DebugEntry(ASHost::OAFreeAllOrders);

    //
    // Simply clear the list head.
    //
    COM_BasedListInit(&lpoaShared->orderListHead);

    lpoaShared->totalHeapOrderBytes         = 0;
    lpoaShared->totalOrderBytes             = 0;
    lpoaShared->totalAdditionalOrderBytes   = 0;
    lpoaShared->nextOrder                   = 0;

    DebugExitVOID(ASHost::OAFreeAllOrders);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\od.cpp ===
#include "precomp.h"


//
// OD.CPP
// Order Decoding
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_ORDER




//
// OD_ViewStarting()
//
// Sets up the odLast... vars
//
BOOL ASShare::OD_ViewStarting(ASPerson * pasPerson)
{
    BOOL            rc = FALSE;
    TSHR_COLOR      colorWhite = {0xFF,0xFF,0xFF};
    BYTE            brushExtra[7] = {0,0,0,0,0,0,0};

    DebugEntry(ASShare::OD_ViewStarting);

    ValidateView(pasPerson);

    //
    // Invalidate OD results
    //
    pasPerson->m_pView->m_odInvalRgnTotal = CreateRectRgn(0, 0, 0, 0);
    if (pasPerson->m_pView->m_odInvalRgnTotal == NULL)
    {
        ERROR_OUT(("OD_PartyStartingHosting: Couldn't create total invalid OD region"));
        DC_QUIT;
    }

    pasPerson->m_pView->m_odInvalRgnOrder = CreateRectRgn(0, 0, 0, 0);
    if (pasPerson->m_pView->m_odInvalRgnOrder == NULL)
    {
        ERROR_OUT(("OD_PartyStartingHosting: Couldn't create order invalid OD region"));
        DC_QUIT;
    }

    //
    // Back color.
    //
    pasPerson->m_pView->m_odLastBkColor = 0;
    ODUseBkColor(pasPerson, TRUE, colorWhite);

    //
    // Text color.
    //
    pasPerson->m_pView->m_odLastTextColor = 0;
    ODUseTextColor(pasPerson, TRUE, colorWhite);

    //
    // Background mode.
    //
    pasPerson->m_pView->m_odLastBkMode = TRANSPARENT;
    ODUseBkMode(pasPerson, OPAQUE);

    //
    // ROP2.
    //
    pasPerson->m_pView->m_odLastROP2 = R2_BLACK;
    ODUseROP2(pasPerson, R2_COPYPEN);

    //
    // Fill Mode.  It's zero, we don't need to do anything since 0 isn't
    // a valid mode, so we'll change it the first order we get that uses
    // one.
    //
    ASSERT(pasPerson->m_pView->m_odLastFillMode == 0);

    //
    // Arc Direction.  It's zero, we don't need to do anything since 0
    // isn't a valid dir, so we'll change it the first order we get that
    // uses one.
    //
    ASSERT(pasPerson->m_pView->m_odLastArcDirection == 0);

    //
    // Pen.
    //
    pasPerson->m_pView->m_odLastPenStyle = PS_DASH;
    pasPerson->m_pView->m_odLastPenWidth = 2;
    pasPerson->m_pView->m_odLastPenColor = 0;
    ODUsePen(pasPerson, TRUE, PS_SOLID, 1, colorWhite);

    //
    // Brush.
    //
    pasPerson->m_pView->m_odLastBrushOrgX = 1;
    pasPerson->m_pView->m_odLastBrushOrgY = 1;
    pasPerson->m_pView->m_odLastBrushBkColor = 0;
    pasPerson->m_pView->m_odLastBrushTextColor = 0;
    pasPerson->m_pView->m_odLastLogBrushStyle = BS_NULL;
    pasPerson->m_pView->m_odLastLogBrushHatch = HS_VERTICAL;
    pasPerson->m_pView->m_odLastLogBrushColor.red = 0;
    pasPerson->m_pView->m_odLastLogBrushColor.green = 0;
    pasPerson->m_pView->m_odLastLogBrushColor.blue = 0;
    ODUseBrush(pasPerson, TRUE, 0, 0, BS_SOLID, HS_HORIZONTAL,
        colorWhite, brushExtra);

    //
    // Char extra.
    //
    pasPerson->m_pView->m_odLastCharExtra = 1;
    ODUseTextCharacterExtra(pasPerson, 0);

    //
    // Text justification.
    //
    pasPerson->m_pView->m_odLastJustExtra = 1;
    pasPerson->m_pView->m_odLastJustCount = 1;
    ODUseTextJustification(pasPerson, 0, 0);

    // odLastBaselineOffset.  This is zero, which is the default in the DC
    // right now so need to change anything.

    //
    // Font.
    //
    // We don't call ODUseFont because we know that the following values
    // are invalid.  The first valid font to arrive will be selected.
    //
    ASSERT(pasPerson->m_pView->m_odLastFontID == NULL);
    pasPerson->m_pView->m_odLastFontCodePage = 0;
    pasPerson->m_pView->m_odLastFontWidth    = 0;
    pasPerson->m_pView->m_odLastFontHeight   = 0;
    pasPerson->m_pView->m_odLastFontWeight   = 0;
    pasPerson->m_pView->m_odLastFontFlags    = 0;
    pasPerson->m_pView->m_odLastFontFaceLen  = 0;
    ZeroMemory(pasPerson->m_pView->m_odLastFaceName, sizeof(pasPerson->m_pView->m_odLastFaceName));

    //
    // These next 4 variables which describe the current clip rectangle are
    // only valid if fRectReset is FALSE.  If fRectReset is true then no
    // clipping is in force.
    //
    pasPerson->m_pView->m_odRectReset  = TRUE;
    pasPerson->m_pView->m_odLastLeft   = 0x12345678;
    pasPerson->m_pView->m_odLastTop    = 0x12345678;
    pasPerson->m_pView->m_odLastRight  = 0x12345678;
    pasPerson->m_pView->m_odLastBottom = 0x12345678;

    // odLastVGAColor?
    // odLastVGAResult?

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::OD_ViewStarting, rc);
    return(rc);
}


//
// OD_ViewEnded()
// Cleans up any created objects
//
void ASShare::OD_ViewEnded(ASPerson * pasPerson)
{
    DebugEntry(ASShare::OD_ViewEnded);

    ValidateView(pasPerson);

    //
    // We may create and select in a font and a pen for our drawing decode.
    // Select them out and delete them.  Since we can't delete stock objects,
    // if we didn't actually create one, there's no harm in it.
    //
    if (pasPerson->m_pView->m_usrDC != NULL)
    {
        DeleteBrush(SelectBrush(pasPerson->m_pView->m_usrDC, (HBRUSH)GetStockObject(BLACK_BRUSH)));
        DeletePen(SelectPen(pasPerson->m_pView->m_usrDC, (HPEN)GetStockObject(BLACK_PEN)));
    }

    //
    // Destroy the brush patern
    //
    if (pasPerson->m_pView->m_odLastBrushPattern != NULL)
    {
        DeleteBitmap(pasPerson->m_pView->m_odLastBrushPattern);
        pasPerson->m_pView->m_odLastBrushPattern = NULL;
    }

    //
    // Destroy the font -- but in this case we don't know that our font is
    // actually the one in the DC.  od2 also selects in fonts.
    //
    if (pasPerson->m_pView->m_odLastFontID != NULL)
    {
        // Make sure this isn't selected in to usrDC
        SelectFont(pasPerson->m_pView->m_usrDC, (HFONT)GetStockObject(SYSTEM_FONT));
        DeleteFont(pasPerson->m_pView->m_odLastFontID);
        pasPerson->m_pView->m_odLastFontID = NULL;
    }

    if (pasPerson->m_pView->m_odInvalRgnTotal != NULL)
    {
        DeleteRgn(pasPerson->m_pView->m_odInvalRgnTotal);
        pasPerson->m_pView->m_odInvalRgnTotal = NULL;
    }

    if (pasPerson->m_pView->m_odInvalRgnOrder != NULL)
    {
        DeleteRgn(pasPerson->m_pView->m_odInvalRgnOrder);
        pasPerson->m_pView->m_odInvalRgnOrder = NULL;
    }

    DebugExitVOID(ASShare::OD_ViewEnded);
}



//
// OD_ReceivedPacket()
//
// Handles incoming orders packet from a host.  Replays the drawing orders
// into the screen bitmap for the host, then repaints the view with the
// results.
//
void  ASShare::OD_ReceivedPacket
(
    ASPerson *      pasPerson,
    PS20DATAPACKET  pPacket
)
{
    PORDPACKET      pOrders;
    HPALETTE        hOldPalette;
    HPALETTE        hOldSavePalette;
    UINT            cOrders;
    UINT            cUpdates;
    UINT            i;
    LPCOM_ORDER_UA  pOrder;
    UINT            decodedLength;
    LPBYTE          pEncodedOrder;
    TSHR_INT32      xOrigin;
    TSHR_INT32      yOrigin;
    BOOL            fPalRGB;

    DebugEntry(ASShare::OD_ReceivedPacket);

    ValidateView(pasPerson);

    pOrders = (PORDPACKET)pPacket;

    //
    // The color type is RGB if we or they are < 256 colors
    // Else it's PALETTE if they are old, or new and not sending 24bpp
    //
    fPalRGB = TRUE;

    if ((g_usrScreenBPP < 8) || (pasPerson->cpcCaps.screen.capsBPP < 8))
    {
        TRACE_OUT(("OD_ReceivedPacket: no PALRGB"));
        fPalRGB = FALSE;
    }
    else
    {
        // At 24bpp, no palette matching for RGB values unless we're <= 8
        if ((g_usrScreenBPP > 8) && (pOrders->sendBPP > 8))
        {
            TRACE_OUT(("OD_ReceivedPacket: no PALRGB"));
            fPalRGB = FALSE;
        }
    }


    if (g_usrPalettized)
    {
        //
        // Select and realize the current remote palette into the device
        // context.
        //
        hOldPalette = SelectPalette(pasPerson->m_pView->m_usrDC, pasPerson->pmPalette, FALSE);
        RealizePalette(pasPerson->m_pView->m_usrDC);

        //
        // We must select the same palette into the Save Bitmap DC so that
        // no color conversion occurs during save and restore operations.
        //
        if (pasPerson->m_pView->m_ssiDC != NULL)
        {
            hOldSavePalette = SelectPalette(pasPerson->m_pView->m_ssiDC,
                pasPerson->pmPalette, FALSE);
            RealizePalette(pasPerson->m_pView->m_ssiDC);
        }
    }

    //
    // Extract the number of orders supplied.
    //
    cOrders = pOrders->cOrders;

    if (m_oefOE2EncodingOn)
    {
        pEncodedOrder = (LPBYTE)(&pOrders->data);
        pOrder = NULL;
    }
    else
    {
        pOrder = (LPCOM_ORDER_UA)(&pOrders->data);
        pEncodedOrder = NULL;
    }

    //
    // Get the desktop origin for this person.
    //
    TRACE_OUT(( "Begin replaying %u orders ((", cOrders));

    //
    // This should be empty, we should have reset it when we invalidated
    // the view of the host the last time we got a packet.
    //
#ifdef _DEBUG
    {
        RECT    rcBounds;

        ASSERT(pasPerson->m_pView->m_odInvalTotal == 0);
        GetRgnBox(pasPerson->m_pView->m_odInvalRgnTotal, &rcBounds);
        ASSERT(IsRectEmpty(&rcBounds));
    }
#endif // _DEBUG

    //
    // Repeat for each of the received orders.
    //
    for (i = 0; i < cOrders; i++)
    {
        if (m_oefOE2EncodingOn)
        {
            //
            // Decode the first order. The pOrder returned by
            // OD2_DecodeOrder should have all fields in local byte order
            //
            pOrder = OD2_DecodeOrder( (PDCEO2ORDER)pEncodedOrder,
                                      &decodedLength,
                                      pasPerson );

            if (pOrder == NULL)
            {
                ERROR_OUT(( "Failed to decode order from pasPerson %u", pasPerson));
                DC_QUIT;
            }
        }
        else
        {
            //
            // Convert any font ids to be local ids.
            //

            //
            // BOGUS LAURABU
            // pOrder is unaligned, FH_Convert... takes an aligned order
            //
            FH_ConvertAnyFontIDToLocal((LPCOM_ORDER)pOrder, pasPerson);
            decodedLength = pOrder->OrderHeader.cbOrderDataLength +
                                                    sizeof(COM_ORDER_HEADER);
        }

        //
        // If the order is a Private Order then it is dealt with by
        // the Bitmap Cache Controller.
        //
        if (EXTRACT_TSHR_UINT16_UA(&(pOrder->OrderHeader.fOrderFlags)) &
            OF_PRIVATE)
        {
            RBC_ProcessCacheOrder(pasPerson, pOrder);
        }
        else if (  EXTRACT_TSHR_UINT16_UA(
                 &(((LPPATBLT_ORDER)pOrder->abOrderData)->type)) ==
                                                LOWORD(ORD_DESKSCROLL))
        {
            ERROR_OUT(("Received DESKSCROLL order, obsolete, from 3.0 node [%d]",
                pasPerson->mcsID));
        }
        else
        {
            //
            // Replay the received order.  This will also add the
            // bounds to the invalidate region.
            //
            //
            OD_ReplayOrder(pasPerson, (LPCOM_ORDER)pOrder, fPalRGB);
        }

        if (m_oefOE2EncodingOn)
        {
            pEncodedOrder += decodedLength;
        }
        else
        {
            pOrder = (LPCOM_ORDER_UA)((LPBYTE)pOrder + decodedLength);
        }
    }
    TRACE_OUT(( "End replaying orders ))"));

    //
    // Pass the Update Region to the Shadow Window Presenter.
    //
    OD_UpdateView(pasPerson);

DC_EXIT_POINT:
    if (g_usrPalettized)
    {
        //
        // Reinstate the old palette(s).
        //
        SelectPalette(pasPerson->m_pView->m_usrDC, hOldPalette, FALSE);
        if (pasPerson->m_pView->m_ssiDC != NULL)
        {
            SelectPalette(pasPerson->m_pView->m_ssiDC, hOldSavePalette, FALSE);
        }
    }

    DebugExitVOID(ASShare::OD_ReceivedPacket);
}

//
// OD_UpdateView()
//
// This is called after we've processed an order packet and replayed the
// drawing into our bitmap for the host.
//
// Replaying the drawing keeps a running tally of the area changed.  This
// function invalidates the changed area in the view of the host, so it
// will repaint and show the updates.
//
void  ASShare::OD_UpdateView(ASPerson * pasHost)
{
    RECT        rcBounds;

    DebugEntry(ASShare::OD_UpdateView);

    ValidateView(pasHost);

    //
    // Do nothing if there are no updates.
    //
    if (pasHost->m_pView->m_odInvalTotal == 0)
    {
        // Nothing got played back, nothing to repaint
    }
    else if (pasHost->m_pView->m_odInvalTotal <= MAX_UPDATE_REGION_ORDERS)
    {
        VIEW_InvalidateRgn(pasHost, pasHost->m_pView->m_odInvalRgnTotal);
    }
    else
    {
        //
        // Rather than invalidating a very complex region, which will
        // chew up a lot of memory, just invalidate the bounding box.
        //
        GetRgnBox(pasHost->m_pView->m_odInvalRgnTotal, &rcBounds);
        TRACE_OUT(("OD_UpdateView: Update region too complex; use bounds {%04d, %04d, %04d, %04d}",
            rcBounds.left, rcBounds.top, rcBounds.right, rcBounds.bottom));

        //
        // BOGUS LAURABU!
        // This code used to add one to the right & bottom, which was
        // bogus EXCLUSIVE coordinate confusion.  I fixed this--the bound
        // box is the right area.
        //
        SetRectRgn(pasHost->m_pView->m_odInvalRgnTotal, rcBounds.left, rcBounds.top,
            rcBounds.right, rcBounds.bottom);
        VIEW_InvalidateRgn(pasHost, pasHost->m_pView->m_odInvalRgnTotal);
    }

    // Now reset the update region to empty
    SetRectRgn(pasHost->m_pView->m_odInvalRgnTotal, 0, 0, 0, 0);
    pasHost->m_pView->m_odInvalTotal = 0;

    DebugExitVOID(ASShare::OD_UpdateView);
}


//
// OD_ReplayOrder()
//
// Replays one drawing operation, the next one, in the packet of orders
// we received from a host.
//
void  ASShare::OD_ReplayOrder
(
    ASPerson *      pasPerson,
    LPCOM_ORDER     pOrder,
    BOOL            fPalRGB
)
{
    LPPATBLT_ORDER  pDrawing;
    LPSTR           faceName;
    UINT            faceNameLength;
    UINT            trueFontWidth;
    UINT            maxFontHeight;
    TSHR_UINT16     nFontFlags;
    TSHR_UINT16     nCodePage;
    UINT            i;
    RECT            rcDst;

    DebugEntry(ASShare::OD_ReplayOrder);

    ValidateView(pasPerson);

    pDrawing = (LPPATBLT_ORDER)pOrder->abOrderData;

    //
    // These are VD coords.
    // WHEN 2.X INTEROP IS GONE, GET RID OF m_pView->m_dsScreenOrigin
    //
    RECT_FROM_TSHR_RECT16(&rcDst, pOrder->OrderHeader.rcsDst);

    //
    // The host bitmap is in screen, not VD, coords
    //
    if (pOrder->OrderHeader.fOrderFlags & OF_NOTCLIPPED)
    {
        //
        // The rectangle associated with this order is the bounding
        // rectangle of the order and does not clip it.  We optimise this
        // case by passing in a large rectangle that will not result in
        // clipping to ODUseRectRegion.  ODUseRectRegion will spot if this
        // is the same as the last clip region we set and take a fast exit
        // path. This improves performance substantially.
        //
        ODUseRectRegion(pasPerson, 0, 0, 10000, 10000);
    }
    else
    {
        ODUseRectRegion(pasPerson, rcDst.left, rcDst.top, rcDst.right, rcDst.bottom);
    }

    switch (pDrawing->type)
    {
        case ORD_DSTBLT_TYPE:
            ODReplayDSTBLT(pasPerson, (LPDSTBLT_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_PATBLT_TYPE:
            ODReplayPATBLT(pasPerson, (LPPATBLT_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_SCRBLT_TYPE:
            ODReplaySCRBLT(pasPerson, (LPSCRBLT_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_MEMBLT_TYPE:
        case ORD_MEMBLT_R2_TYPE:
            ODReplayMEMBLT(pasPerson, (LPMEMBLT_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_MEM3BLT_TYPE:
        case ORD_MEM3BLT_R2_TYPE:
            ODReplayMEM3BLT(pasPerson, (LPMEM3BLT_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_RECTANGLE_TYPE:
            ODReplayRECTANGLE(pasPerson, (LPRECTANGLE_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_POLYGON_TYPE:
            ODReplayPOLYGON(pasPerson, (LPPOLYGON_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_PIE_TYPE:
            ODReplayPIE(pasPerson, (LPPIE_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_ELLIPSE_TYPE:
            ODReplayELLIPSE(pasPerson, (LPELLIPSE_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_ARC_TYPE:
            ODReplayARC(pasPerson, (LPARC_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_CHORD_TYPE:
            ODReplayCHORD(pasPerson, (LPCHORD_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_POLYBEZIER_TYPE:
            ODReplayPOLYBEZIER(pasPerson, (LPPOLYBEZIER_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_ROUNDRECT_TYPE:
            ODReplayROUNDRECT(pasPerson, (LPROUNDRECT_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_LINETO_TYPE:
            ODReplayLINETO(pasPerson, (LPLINETO_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_EXTTEXTOUT_TYPE:
            ODReplayEXTTEXTOUT(pasPerson, (LPEXTTEXTOUT_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_TEXTOUT_TYPE:
            ODReplayTEXTOUT(pasPerson, (LPTEXTOUT_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_OPAQUERECT_TYPE:
            ODReplayOPAQUERECT(pasPerson, (LPOPAQUERECT_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_SAVEBITMAP_TYPE:
            SSI_SaveBitmap(pasPerson, (LPSAVEBITMAP_ORDER)pDrawing);
            break;

        default:
            ERROR_OUT(( "ORDER: Unrecognised order %d from [%d]",
                         (int)pDrawing->type, pasPerson->mcsID));
            break;
    }

    //
    // rcDst is INCLUSIVE coords still
    //
    if ((rcDst.left <= rcDst.right) && (rcDst.top <= rcDst.bottom))
    {
        SetRectRgn(pasPerson->m_pView->m_odInvalRgnOrder, rcDst.left, rcDst.top,
            rcDst.right+1, rcDst.bottom+1);

        //
        // Combine the rectangle region with the update region.
        //
        if (UnionRgn(pasPerson->m_pView->m_odInvalRgnTotal, pasPerson->m_pView->m_odInvalRgnTotal, pasPerson->m_pView->m_odInvalRgnOrder) <= ERROR)
        {
            RECT    rcCur;

            //
            // Union failed; so simplyify the current region
            //
            WARNING_OUT(("OD_ReplayOrder: UnionRgn failed"));

            //
            // BOGUS LAURABU!
            // This code used to add one to the right & bottom, which is
            // bogus exclusive coord confusion.  The bound box is the right
            // area.
            //
            GetRgnBox(pasPerson->m_pView->m_odInvalRgnTotal, &rcCur);
            SetRectRgn(pasPerson->m_pView->m_odInvalRgnTotal, rcCur.left, rcCur.top, rcCur.right,
                rcCur.bottom);

            //
            // Reset odInvalTotal count -- this is really a # of bounds rects
            // count, and now we have just one.
            //
            pasPerson->m_pView->m_odInvalTotal = 1;

            if (UnionRgn(pasPerson->m_pView->m_odInvalRgnTotal, pasPerson->m_pView->m_odInvalRgnTotal, pasPerson->m_pView->m_odInvalRgnOrder) <= ERROR)
            {
                ERROR_OUT(("OD_ReplayOrder: UnionRgn failed after simplification"));
            }
        }

        pasPerson->m_pView->m_odInvalTotal++;
    }

    DebugExitVOID(ASShare::OD_ReplayOrder);
}



//
// ODReplayDSTBLT()
// Replays a DSTBLT order
//
void ASShare::ODReplayDSTBLT
(
    ASPerson *      pasPerson,
    LPDSTBLT_ORDER  pDstBlt,
    BOOL            fPalRGB
)
{
    DebugEntry(ASShare::ODReplayDSTBLT);

    TRACE_OUT(("ORDER: DstBlt X %hd Y %hd w %hd h %hd rop %08lX",
                         pDstBlt->nLeftRect,
                         pDstBlt->nTopRect,
                         pDstBlt->nWidth,
                         pDstBlt->nHeight,
                         (UINT)ODConvertToWindowsROP(pDstBlt->bRop)));

    //
    // Apply DS origin offset ourselves (do not use transform)
    //
    PatBlt(pasPerson->m_pView->m_usrDC,
        pDstBlt->nLeftRect - pasPerson->m_pView->m_dsScreenOrigin.x,
        pDstBlt->nTopRect - pasPerson->m_pView->m_dsScreenOrigin.y,
        pDstBlt->nWidth,
        pDstBlt->nHeight,
        ODConvertToWindowsROP(pDstBlt->bRop));

    DebugExitVOID(ASShare::ODReplayDSTBLT);
}



//
// ASShare::ODReplayPATBLT()
// Replays a PATBLT order
//
void ASShare::ODReplayPATBLT
(
    ASPerson *      pasPerson,
    LPPATBLT_ORDER  pPatblt,
    BOOL            fPalRGB
)
{
    TSHR_COLOR      BackColor;
    TSHR_COLOR      ForeColor;

    DebugEntry(ASShare::ODReplayPATBLT);

    TRACE_OUT(("ORDER: PatBlt BC %08lX FC %08lX Brush %02X %02X X %d Y %d w %d h %d rop %08lX",
                        pPatblt->BackColor,
                        pPatblt->ForeColor,
                        pPatblt->BrushStyle,
                        pPatblt->BrushHatch,
                        pPatblt->nLeftRect,
                        pPatblt->nTopRect,
                        pPatblt->nWidth,
                        pPatblt->nHeight,
                        ODConvertToWindowsROP(pPatblt->bRop) ));

    ODAdjustColor(pasPerson, &(pPatblt->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pPatblt->ForeColor), &ForeColor, OD_FORE_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseTextColor(pasPerson, fPalRGB, ForeColor);

    ODUseBrush(pasPerson, fPalRGB, pPatblt->BrushOrgX, pPatblt->BrushOrgY,
        pPatblt->BrushStyle, pPatblt->BrushHatch, ForeColor, pPatblt->BrushExtra);

    //
    // Apply DS origin offset ourselves (do not use transform)
    //
    PatBlt(pasPerson->m_pView->m_usrDC,
        pPatblt->nLeftRect - pasPerson->m_pView->m_dsScreenOrigin.x,
        pPatblt->nTopRect  - pasPerson->m_pView->m_dsScreenOrigin.y,
        pPatblt->nWidth,
        pPatblt->nHeight,
        ODConvertToWindowsROP(pPatblt->bRop));

    DebugExitVOID(ASShare::ODReplayPATBLT);
}



//
// ASShare::ODReplaySCRBLT()
// Replays SCRBLT order
//
void ASShare::ODReplaySCRBLT
(
    ASPerson *      pasPerson,
    LPSCRBLT_ORDER  pScrBlt,
    BOOL            fPalRGB
)
{
    DebugEntry(ASShare::ODReplaySCRBLT);

    TRACE_OUT(("ORDER: ScrBlt dx %d dy %d w %d h %d sx %d sy %d rop %08lX",
        pScrBlt->nLeftRect,
        pScrBlt->nTopRect,
        pScrBlt->nWidth,
        pScrBlt->nHeight,
        pScrBlt->nXSrc,
        pScrBlt->nYSrc,
        ODConvertToWindowsROP(pScrBlt->bRop)));

    //
    // Apply DS origin offset ourselves (do not use transform)
    //
    BitBlt(pasPerson->m_pView->m_usrDC,
        pScrBlt->nLeftRect - pasPerson->m_pView->m_dsScreenOrigin.x,
        pScrBlt->nTopRect - pasPerson->m_pView->m_dsScreenOrigin.y,
        pScrBlt->nWidth,
        pScrBlt->nHeight,
        pasPerson->m_pView->m_usrDC,
        pScrBlt->nXSrc - pasPerson->m_pView->m_dsScreenOrigin.x,
        pScrBlt->nYSrc - pasPerson->m_pView->m_dsScreenOrigin.y,
        ODConvertToWindowsROP(pScrBlt->bRop));

    DebugExitVOID(ASShare::ODReplaySCRBLT);
}



//
// ASShare::ODReplayMEMBLT()
// Replays MEMBLT and MEMBLT_R2 orders
//
void ASShare::ODReplayMEMBLT
(
    ASPerson *      pasPerson,
    LPMEMBLT_ORDER  pMemBlt,
    BOOL            fPalRGB
)
{
    HPALETTE        hpalOld;
    HPALETTE        hpalOld2;
    TSHR_UINT16     cacheIndex;
    UINT            nXSrc;
    HBITMAP         cacheBitmap;
    HBITMAP         hOldBitmap;
    COLORREF        clrBk;
    COLORREF        clrText;

    DebugEntry(ASShare::ODReplayMEMBLT);

    ValidateView(pasPerson);

    TRACE_OUT(("MEMBLT nXSrc %d",pMemBlt->nXSrc));

    hpalOld = SelectPalette(pasPerson->m_pView->m_usrWorkDC, pasPerson->pmPalette, FALSE);
    RealizePalette(pasPerson->m_pView->m_usrWorkDC);

    hpalOld2 = SelectPalette( pasPerson->m_pView->m_usrDC, pasPerson->pmPalette, FALSE );
    RealizePalette(pasPerson->m_pView->m_usrDC);

    //
    // Now get the source bitmap.  The cache is defined by
    // hBitmap.  For R1 protocols the cache index is indicated
    // by the source offset on the order.  For R2 it is
    // indicated by a separate field in the order.
    // The color table index is in the high order of hBitmap
    //
    cacheIndex = ((LPMEMBLT_R2_ORDER)pMemBlt)->cacheIndex;
    nXSrc = pMemBlt->nXSrc;

    TRACE_OUT(( "MEMBLT color %d cache %d:%d",
        MEMBLT_COLORINDEX(pMemBlt),
        MEMBLT_CACHETABLE(pMemBlt),
        cacheIndex));

    cacheBitmap = RBC_MapCacheIDToBitmapHandle(pasPerson,
        MEMBLT_CACHETABLE(pMemBlt), cacheIndex, MEMBLT_COLORINDEX(pMemBlt));

    hOldBitmap = SelectBitmap(pasPerson->m_pView->m_usrWorkDC, cacheBitmap);

    TRACE_OUT(("ORDER: MemBlt dx %d dy %d w %d h %d sx %d sy %d rop %08lX",
        pMemBlt->nLeftRect,
        pMemBlt->nTopRect,
        pMemBlt->nWidth,
        pMemBlt->nHeight,
        nXSrc,
        pMemBlt->nYSrc,
        ODConvertToWindowsROP(pMemBlt->bRop)));

    //
    // ALWAYS set back/fore color to white/black in case of rops like
    // SRCAND or SRCINVERT which will use their values.
    //
    clrBk = SetBkColor(pasPerson->m_pView->m_usrDC, RGB(255, 255, 255));
    clrText = SetTextColor(pasPerson->m_pView->m_usrDC, RGB(0, 0, 0));

    //
    // Apply DS origin offset ourselves (do not use transform)
    //
    BitBlt(pasPerson->m_pView->m_usrDC,
        pMemBlt->nLeftRect- pasPerson->m_pView->m_dsScreenOrigin.x,
        pMemBlt->nTopRect - pasPerson->m_pView->m_dsScreenOrigin.y,
        pMemBlt->nWidth,
        pMemBlt->nHeight,
        pasPerson->m_pView->m_usrWorkDC,
        nXSrc,
        pMemBlt->nYSrc,
        ODConvertToWindowsROP(pMemBlt->bRop));

    //
    // If the relevant property is set hatch the area in blue.
    //
    if (m_usrHatchBitmaps)
    {
        SDP_DrawHatchedRect(pasPerson->m_pView->m_usrDC,
            pMemBlt->nLeftRect - pasPerson->m_pView->m_dsScreenOrigin.x,
            pMemBlt->nTopRect  - pasPerson->m_pView->m_dsScreenOrigin.y,
            pMemBlt->nWidth,
            pMemBlt->nHeight,
            USR_HATCH_COLOR_BLUE);
    }

    //
    // Restore back, text colors
    //
    SetTextColor(pasPerson->m_pView->m_usrDC, clrText);
    SetBkColor(pasPerson->m_pView->m_usrDC, clrBk);

    //
    // Deselect the bitmap from the DC.
    //
    SelectBitmap(pasPerson->m_pView->m_usrWorkDC, hOldBitmap);

    SelectPalette(pasPerson->m_pView->m_usrWorkDC, hpalOld, FALSE);
    SelectPalette(pasPerson->m_pView->m_usrDC, hpalOld2, FALSE);

    DebugExitVOID(ASShare::ODReplayMEMBLT);
}


//
// ASShare::ODReplayMEM3BLT()
// Replays MEM3BLT and MEM3BLT_R2 orders
//
void ASShare::ODReplayMEM3BLT
(
    ASPerson *      pasPerson,
    LPMEM3BLT_ORDER pMem3Blt,
    BOOL            fPalRGB
)
{
    HPALETTE        hpalOld;
    HPALETTE        hpalOld2;
    TSHR_UINT16     cacheIndex;
    int             nXSrc;
    HBITMAP         cacheBitmap;
    HBITMAP         hOldBitmap;
    TSHR_COLOR      BackColor;
    TSHR_COLOR      ForeColor;

    DebugEntry(ASShare::ODReplayMEM3BLT);

    ValidateView(pasPerson);

    TRACE_OUT(("MEM3BLT nXSrc %d",pMem3Blt->nXSrc));
    TRACE_OUT(("ORDER: Mem3Blt brush %04lX %04lX dx %d dy %d "\
            "w %d h %d sx %d sy %d rop %08lX",
        pMem3Blt->BrushStyle,
        pMem3Blt->BrushHatch,
        pMem3Blt->nLeftRect,
        pMem3Blt->nTopRect,
        pMem3Blt->nWidth,
        pMem3Blt->nHeight,
        pMem3Blt->nXSrc,
        pMem3Blt->nYSrc,
        (UINT)ODConvertToWindowsROP(pMem3Blt->bRop)));


    hpalOld = SelectPalette(pasPerson->m_pView->m_usrWorkDC, pasPerson->pmPalette, FALSE);
    RealizePalette(pasPerson->m_pView->m_usrWorkDC);

    hpalOld2 = SelectPalette( pasPerson->m_pView->m_usrDC, pasPerson->pmPalette, FALSE);
    RealizePalette(pasPerson->m_pView->m_usrDC);

    //
    // Now get the source bitmap.  The cache is defined by
    // hBitmap.  For R1 protocols the cache index is indicated
    // by the source offset on the order.  For R2 it is
    // indicated by a separate field in the order.
    // The color table index is in the high order of hBitmap
    //
    cacheIndex = ((LPMEM3BLT_R2_ORDER)pMem3Blt)->cacheIndex;
    nXSrc = pMem3Blt->nXSrc;

    TRACE_OUT(("MEM3BLT color %d cache %d:%d",
        MEMBLT_COLORINDEX(pMem3Blt),
        MEMBLT_CACHETABLE(pMem3Blt),
        cacheIndex));

    cacheBitmap = RBC_MapCacheIDToBitmapHandle(pasPerson,
        MEMBLT_CACHETABLE(pMem3Blt), cacheIndex, MEMBLT_COLORINDEX(pMem3Blt));

    hOldBitmap = SelectBitmap(pasPerson->m_pView->m_usrWorkDC, cacheBitmap);

    ODAdjustColor(pasPerson, &(pMem3Blt->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pMem3Blt->ForeColor), &ForeColor, OD_FORE_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseTextColor(pasPerson, fPalRGB, ForeColor);

    ODUseBrush(pasPerson, fPalRGB, pMem3Blt->BrushOrgX, pMem3Blt->BrushOrgY,
        pMem3Blt->BrushStyle, pMem3Blt->BrushHatch, ForeColor,
        pMem3Blt->BrushExtra);

    //
    // Apply DS origin offset ourselves (do not use transform)
    //
    BitBlt(pasPerson->m_pView->m_usrDC,
        pMem3Blt->nLeftRect - pasPerson->m_pView->m_dsScreenOrigin.x,
        pMem3Blt->nTopRect - pasPerson->m_pView->m_dsScreenOrigin.y,
        pMem3Blt->nWidth,
        pMem3Blt->nHeight,
        pasPerson->m_pView->m_usrWorkDC,
        nXSrc,
        pMem3Blt->nYSrc,
        ODConvertToWindowsROP(pMem3Blt->bRop));

    //
    // If the relevant property is set hatch the area in blue.
    //
    if (m_usrHatchBitmaps)
    {
        SDP_DrawHatchedRect(pasPerson->m_pView->m_usrDC,
            pMem3Blt->nLeftRect - pasPerson->m_pView->m_dsScreenOrigin.x,
            pMem3Blt->nTopRect  - pasPerson->m_pView->m_dsScreenOrigin.y,
            pMem3Blt->nWidth,
            pMem3Blt->nHeight,
            USR_HATCH_COLOR_BLUE);
    }

    //
    // Deselect the bitmap from the DC.
    //
    SelectBitmap(pasPerson->m_pView->m_usrWorkDC, hOldBitmap);

    SelectPalette(pasPerson->m_pView->m_usrWorkDC, hpalOld, FALSE);
    SelectPalette(pasPerson->m_pView->m_usrDC, hpalOld2, FALSE);

    DebugExitVOID(ASShare::ODReplayMEM3BLT);
}



//
// ASShare::ODReplayRECTANGLE()
// Replays RECTANGLE order
//
void ASShare::ODReplayRECTANGLE
(
    ASPerson *          pasPerson,
    LPRECTANGLE_ORDER   pRectangle,
    BOOL                fPalRGB
)
{
    TSHR_COLOR          BackColor;
    TSHR_COLOR          ForeColor;
    TSHR_COLOR          PenColor;

    DebugEntry(ASShare::ODReplayRECTANGLE);

    TRACE_OUT(("ORDER: Rectangle BC %08lX FC %08lX BM %04hX brush %02hX " \
            "%02hX rop2 %04hX pen %04hX %04hX %08lX rect %d %d %d %d",
        pRectangle->BackColor,
        pRectangle->ForeColor,
        (TSHR_UINT16)pRectangle->BackMode,
        (TSHR_UINT16)pRectangle->BrushStyle,
        (TSHR_UINT16)pRectangle->BrushHatch,
        (TSHR_UINT16)pRectangle->ROP2,
        (TSHR_UINT16)pRectangle->PenStyle,
        (TSHR_UINT16)pRectangle->PenWidth,
        pRectangle->PenColor,
        (int)pRectangle->nLeftRect,
        (int)pRectangle->nTopRect,
        (int)pRectangle->nRightRect + 1,
        (int)pRectangle->nBottomRect + 1));

    ODAdjustColor(pasPerson, &(pRectangle->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pRectangle->ForeColor), &ForeColor, OD_FORE_COLOR);
    ODAdjustColor(pasPerson, &(pRectangle->PenColor), &PenColor, OD_PEN_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseTextColor(pasPerson, fPalRGB, ForeColor);

    ODUseBkMode(pasPerson, pRectangle->BackMode);

    ODUseBrush(pasPerson, fPalRGB, pRectangle->BrushOrgX, pRectangle->BrushOrgY,
        pRectangle->BrushStyle, pRectangle->BrushHatch, ForeColor,
        pRectangle->BrushExtra);

    ODUseROP2(pasPerson, pRectangle->ROP2);

    ODUsePen(pasPerson, fPalRGB, pRectangle->PenStyle, pRectangle->PenWidth,
        PenColor);

    //
    // The rectangle in the order is inclusive but Windows works
    // with exclusive rectangles.
    //
    // Apply DS origin offset ourselves (do not use transform)
    //
    Rectangle(pasPerson->m_pView->m_usrDC,
        pRectangle->nLeftRect  - pasPerson->m_pView->m_dsScreenOrigin.x,
        pRectangle->nTopRect   - pasPerson->m_pView->m_dsScreenOrigin.y,
        pRectangle->nRightRect - pasPerson->m_pView->m_dsScreenOrigin.x + 1,
        pRectangle->nBottomRect- pasPerson->m_pView->m_dsScreenOrigin.y + 1);

    DebugExitVOID(ASShare::ODReplayRECTANGLE);
}



//
// ASShare::ODReplayPOLYGON()
// Replays POLYGON order
//
void ASShare::ODReplayPOLYGON
(
    ASPerson *      pasPerson,
    LPPOLYGON_ORDER pPolygon,
    BOOL            fPalRGB
)
{
    POINT           aP[ORD_MAX_POLYGON_POINTS];
    UINT            i;
    UINT            cPoints;
    TSHR_COLOR      BackColor;
    TSHR_COLOR      ForeColor;
    TSHR_COLOR      PenColor;

    DebugEntry(ASShare::ODReplayPOLYGON);

    cPoints = pPolygon->variablePoints.len /
            sizeof(pPolygon->variablePoints.aPoints[0]);

    TRACE_OUT(("ORDER: Polygon BC %08lX FC %08lX BM %04hX brush %02hX %02hX "
            "%02hX %02hX rop2 %04hX pen %04hX %04hX %08lX points %d",
        pPolygon->BackColor,
        pPolygon->ForeColor,
        (TSHR_UINT16)pPolygon->BackMode,
        (TSHR_UINT16)pPolygon->BrushStyle,
        (TSHR_UINT16)pPolygon->BrushHatch,
        (TSHR_UINT16)pPolygon->ROP2,
        (TSHR_UINT16)pPolygon->PenStyle,
        (TSHR_UINT16)pPolygon->PenWidth,
        pPolygon->PenColor,
        cPoints));

    //
    // Apply DS origin offset ourselves (do not use transform)
    // while copying to native size point array.
    //
    for (i = 0; i < cPoints; i++)
    {
        TRACE_OUT(( "aPoints[%u]: %d,%d", i,
            (int)(pPolygon->variablePoints.aPoints[i].x),
            (int)(pPolygon->variablePoints.aPoints[i].y)));

        aP[i].x = pPolygon->variablePoints.aPoints[i].x -
                  pasPerson->m_pView->m_dsScreenOrigin.x;
        aP[i].y = pPolygon->variablePoints.aPoints[i].y -
                  pasPerson->m_pView->m_dsScreenOrigin.y;
    }

    ODAdjustColor(pasPerson, &(pPolygon->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pPolygon->ForeColor), &ForeColor, OD_FORE_COLOR);
    ODAdjustColor(pasPerson, &(pPolygon->PenColor), &PenColor, OD_PEN_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseTextColor(pasPerson, fPalRGB, ForeColor);

    ODUseBkMode(pasPerson, pPolygon->BackMode);

    ODUseBrush(pasPerson, fPalRGB, pPolygon->BrushOrgX, pPolygon->BrushOrgY,
        pPolygon->BrushStyle, pPolygon->BrushHatch, ForeColor,
        pPolygon->BrushExtra);

    ODUseROP2(pasPerson, pPolygon->ROP2);

    ODUsePen(pasPerson, fPalRGB, pPolygon->PenStyle, pPolygon->PenWidth,
        PenColor);

    ODUseFillMode(pasPerson, pPolygon->FillMode);


    Polygon(pasPerson->m_pView->m_usrDC, aP, cPoints);


    DebugExitVOID(ASShare::ODReplayPOLYGON);
}


//
// ASShare::ODReplayPIE()
// Replays PIE order
//
void ASShare::ODReplayPIE
(
    ASPerson *      pasPerson,
    LPPIE_ORDER     pPie,
    BOOL            fPalRGB
)
{
    TSHR_COLOR      BackColor;
    TSHR_COLOR      ForeColor;
    TSHR_COLOR      PenColor;

    DebugEntry(ASShare::ODReplayPIE);

    TRACE_OUT(("ORDER: Pie BC %08lX FC %08lX BM %04hX brush %02hX "
            " %02hX rop2 %04hX pen %04hX %04hX %08lX rect %d %d %d %d",
        pPie->BackColor,
        pPie->ForeColor,
        (TSHR_UINT16)pPie->BackMode,
        (TSHR_UINT16)pPie->BrushStyle,
        (TSHR_UINT16)pPie->BrushHatch,
        (TSHR_UINT16)pPie->ROP2,
        (TSHR_UINT16)pPie->PenStyle,
        (TSHR_UINT16)pPie->PenWidth,
        pPie->PenColor,
        (int)pPie->nLeftRect,
        (int)pPie->nTopRect,
        (int)pPie->nRightRect + 1,
        (int)pPie->nBottomRect + 1));

    ODAdjustColor(pasPerson, &(pPie->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pPie->ForeColor), &ForeColor, OD_FORE_COLOR);
    ODAdjustColor(pasPerson, &(pPie->PenColor), &PenColor, OD_PEN_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseTextColor(pasPerson, fPalRGB, ForeColor);

    ODUseBkMode(pasPerson, pPie->BackMode);

    ODUseBrush(pasPerson, fPalRGB, pPie->BrushOrgX, pPie->BrushOrgY,
        pPie->BrushStyle, pPie->BrushHatch, ForeColor, pPie->BrushExtra);

    ODUseROP2(pasPerson, pPie->ROP2);

    ODUsePen(pasPerson, fPalRGB, pPie->PenStyle, pPie->PenWidth,
        PenColor);

    ODUseArcDirection(pasPerson, (int)pPie->ArcDirection);


    Pie(pasPerson->m_pView->m_usrDC,
        pPie->nLeftRect   - pasPerson->m_pView->m_dsScreenOrigin.x,
        pPie->nTopRect    - pasPerson->m_pView->m_dsScreenOrigin.y,
        pPie->nRightRect  - pasPerson->m_pView->m_dsScreenOrigin.x + 1,
        pPie->nBottomRect - pasPerson->m_pView->m_dsScreenOrigin.y + 1,
        pPie->nXStart     - pasPerson->m_pView->m_dsScreenOrigin.x,
        pPie->nYStart     - pasPerson->m_pView->m_dsScreenOrigin.y,
        pPie->nXEnd       - pasPerson->m_pView->m_dsScreenOrigin.x,
        pPie->nYEnd       - pasPerson->m_pView->m_dsScreenOrigin.y);


    DebugExitVOID(ASShare::ODReplayPIE);
}



//
// ASShare::ODReplayELLIPSE()
// Replays ELLIPSE order
//
void ASShare::ODReplayELLIPSE
(
    ASPerson *      pasPerson,
    LPELLIPSE_ORDER pEllipse,
    BOOL            fPalRGB
)
{
    TSHR_COLOR      BackColor;
    TSHR_COLOR      ForeColor;
    TSHR_COLOR      PenColor;

    DebugEntry(ASShare::ODReplayELLIPSE);

    TRACE_OUT(("ORDER: Ellipse BC %08lX FC %08lX BM %04hX brush %02hX %02hX "
            "rop2 %04hX pen %04hX %04hX %08lX rect %d %d %d %d",
        pEllipse->BackColor,
        pEllipse->ForeColor,
        (TSHR_UINT16)pEllipse->BackMode,
        (TSHR_UINT16)pEllipse->BrushStyle,
        (TSHR_UINT16)pEllipse->BrushHatch,
        (TSHR_UINT16)pEllipse->ROP2,
        (TSHR_UINT16)pEllipse->PenStyle,
        (TSHR_UINT16)pEllipse->PenWidth,
        pEllipse->PenColor,
        (int)pEllipse->nLeftRect,
        (int)pEllipse->nTopRect,
        (int)pEllipse->nRightRect + 1,
        (int)pEllipse->nBottomRect + 1));

    ODAdjustColor(pasPerson, &(pEllipse->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pEllipse->ForeColor), &ForeColor, OD_FORE_COLOR);
    ODAdjustColor(pasPerson, &(pEllipse->PenColor), &PenColor, OD_PEN_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseTextColor(pasPerson, fPalRGB, ForeColor);

    ODUseBkMode(pasPerson, pEllipse->BackMode);

    ODUseBrush(pasPerson, fPalRGB, pEllipse->BrushOrgX, pEllipse->BrushOrgY,
        pEllipse->BrushStyle, pEllipse->BrushHatch, ForeColor,
        pEllipse->BrushExtra);

    ODUseROP2(pasPerson, pEllipse->ROP2);

    ODUsePen(pasPerson, fPalRGB, pEllipse->PenStyle, pEllipse->PenWidth,
        PenColor);


    Ellipse(pasPerson->m_pView->m_usrDC,
        pEllipse->nLeftRect   - pasPerson->m_pView->m_dsScreenOrigin.x,
        pEllipse->nTopRect    - pasPerson->m_pView->m_dsScreenOrigin.y,
        pEllipse->nRightRect  - pasPerson->m_pView->m_dsScreenOrigin.x + 1,
        pEllipse->nBottomRect - pasPerson->m_pView->m_dsScreenOrigin.y + 1);


    DebugExitVOID(ASShare::ODReplayELLIPSE);
}



//
// ASShare::ODReplayARC()
// Replays ARC order
//
void ASShare::ODReplayARC
(
    ASPerson *      pasPerson,
    LPARC_ORDER     pArc,
    BOOL            fPalRGB
)
{
    TSHR_COLOR      BackColor;
    TSHR_COLOR      PenColor;

    DebugEntry(ASShare::ODReplayARC);

    TRACE_OUT(("ORDER: Arc BC %08lX BM %04hX rop2 %04hX pen %04hX "
            "%04hX %08lX rect %d %d %d %d",
        pArc->BackColor,
        (TSHR_UINT16)pArc->BackMode,
        (TSHR_UINT16)pArc->ROP2,
        (TSHR_UINT16)pArc->PenStyle,
        (TSHR_UINT16)pArc->PenWidth,
        pArc->PenColor,
        (int)pArc->nLeftRect,
        (int)pArc->nTopRect,
        (int)pArc->nRightRect + 1,
        (int)pArc->nBottomRect + 1));

    ODAdjustColor(pasPerson, &(pArc->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pArc->PenColor), &PenColor, OD_PEN_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseBkMode(pasPerson, pArc->BackMode);

    ODUseROP2(pasPerson, pArc->ROP2);

    ODUsePen(pasPerson, fPalRGB, pArc->PenStyle, pArc->PenWidth,
        PenColor);

    ODUseArcDirection(pasPerson, pArc->ArcDirection);


    Arc(pasPerson->m_pView->m_usrDC,
        pArc->nLeftRect   - pasPerson->m_pView->m_dsScreenOrigin.x,
        pArc->nTopRect    - pasPerson->m_pView->m_dsScreenOrigin.y,
        pArc->nRightRect  - pasPerson->m_pView->m_dsScreenOrigin.x + 1,
        pArc->nBottomRect - pasPerson->m_pView->m_dsScreenOrigin.y + 1,
        pArc->nXStart     - pasPerson->m_pView->m_dsScreenOrigin.x,
        pArc->nYStart     - pasPerson->m_pView->m_dsScreenOrigin.y,
        pArc->nXEnd       - pasPerson->m_pView->m_dsScreenOrigin.x,
        pArc->nYEnd       - pasPerson->m_pView->m_dsScreenOrigin.y);


    DebugExitVOID(ASShare::ODReplayARC);
}



//
// ASShare::ODReplayCHORD()
// Replays CHORD order
//
void ASShare::ODReplayCHORD
(
    ASPerson *      pasPerson,
    LPCHORD_ORDER   pChord,
    BOOL            fPalRGB
)
{
    TSHR_COLOR      BackColor;
    TSHR_COLOR      ForeColor;
    TSHR_COLOR      PenColor;

    DebugEntry(ASShare::ODReplayCHORD);

    TRACE_OUT(("ORDER: Chord BC %08lX FC %08lX BM %04hX brush "
            "%02hX %02hX rop2 %04hX pen %04hX %04hX %08lX rect "
            "%d %d %d %d",
        pChord->BackColor,
        pChord->ForeColor,
        (TSHR_UINT16)pChord->BackMode,
        (TSHR_UINT16)pChord->BrushStyle,
        (TSHR_UINT16)pChord->BrushHatch,
        (TSHR_UINT16)pChord->ROP2,
        (TSHR_UINT16)pChord->PenStyle,
        (TSHR_UINT16)pChord->PenWidth,
        pChord->PenColor,
        (int)pChord->nLeftRect,
        (int)pChord->nTopRect,
        (int)pChord->nRightRect + 1,
        (int)pChord->nBottomRect + 1));


    ODAdjustColor(pasPerson, &(pChord->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pChord->ForeColor), &ForeColor, OD_FORE_COLOR);
    ODAdjustColor(pasPerson, &(pChord->PenColor), &PenColor, OD_PEN_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseTextColor(pasPerson, fPalRGB, ForeColor);

    ODUseBkMode(pasPerson, pChord->BackMode);

    ODUseBrush(pasPerson, fPalRGB, pChord->BrushOrgX, pChord->BrushOrgY,
        pChord->BrushStyle, pChord->BrushHatch, ForeColor,
        pChord->BrushExtra);

    ODUseROP2(pasPerson, pChord->ROP2);

    ODUsePen(pasPerson, fPalRGB, pChord->PenStyle, pChord->PenWidth,
        PenColor);

    ODUseArcDirection(pasPerson, pChord->ArcDirection);


    Chord(pasPerson->m_pView->m_usrDC,
        pChord->nLeftRect   - pasPerson->m_pView->m_dsScreenOrigin.x,
        pChord->nTopRect    - pasPerson->m_pView->m_dsScreenOrigin.y,
        pChord->nRightRect  - pasPerson->m_pView->m_dsScreenOrigin.x + 1,
        pChord->nBottomRect - pasPerson->m_pView->m_dsScreenOrigin.y + 1,
        pChord->nXStart     - pasPerson->m_pView->m_dsScreenOrigin.x,
        pChord->nYStart     - pasPerson->m_pView->m_dsScreenOrigin.y,
        pChord->nXEnd       - pasPerson->m_pView->m_dsScreenOrigin.x,
        pChord->nYEnd       - pasPerson->m_pView->m_dsScreenOrigin.y);


    DebugExitVOID(ASShare::ODReplayCHORD);
}



//
// ASShare::ODReplayPOLYBEZIER()
// Replays POLYBEZIER order
//
void ASShare::ODReplayPOLYBEZIER
(
    ASPerson *          pasPerson,
    LPPOLYBEZIER_ORDER  pPolyBezier,
    BOOL                fPalRGB
)
{
    POINT               aP[ORD_MAX_POLYBEZIER_POINTS];
    UINT                i;
    UINT                cPoints;
    TSHR_COLOR          BackColor;
    TSHR_COLOR          ForeColor;
    TSHR_COLOR          PenColor;

    DebugEntry(ASShare::ODReplayPOLYBEZIER);

    cPoints = pPolyBezier->variablePoints.len /
        sizeof(pPolyBezier->variablePoints.aPoints[0]);

    TRACE_OUT(("ORDER: PolyBezier BC %08lX FC %08lX BM %04hX rop2 "
            "%04hX pen %04hX %04hX %08lX points %d",
        pPolyBezier->BackColor,
        pPolyBezier->ForeColor,
        (TSHR_UINT16)pPolyBezier->BackMode,
        (TSHR_UINT16)pPolyBezier->ROP2,
        (TSHR_UINT16)pPolyBezier->PenStyle,
        (TSHR_UINT16)pPolyBezier->PenWidth,
        pPolyBezier->PenColor,
        (int)cPoints));

    //
    // Apply DS origin offset ourselves (do not use transform)
    // while copying to native size point array.
    //
    for (i = 0; i < cPoints; i++)
    {
        TRACE_OUT(("aPoints[%u]: %d,%d",(UINT)i,
            (int)(pPolyBezier->variablePoints.aPoints[i].x),
            (int)(pPolyBezier->variablePoints.aPoints[i].y)));

        aP[i].x = pPolyBezier->variablePoints.aPoints[i].x -
           pasPerson->m_pView->m_dsScreenOrigin.x;
        aP[i].y = pPolyBezier->variablePoints.aPoints[i].y -
           pasPerson->m_pView->m_dsScreenOrigin.y;
    }

    ODAdjustColor(pasPerson, &(pPolyBezier->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pPolyBezier->ForeColor), &ForeColor, OD_FORE_COLOR);
    ODAdjustColor(pasPerson, &(pPolyBezier->PenColor), &PenColor, OD_PEN_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseTextColor(pasPerson, fPalRGB, ForeColor);

    ODUseBkMode(pasPerson, pPolyBezier->BackMode);

    ODUseROP2(pasPerson, pPolyBezier->ROP2);

    ODUsePen(pasPerson, fPalRGB, pPolyBezier->PenStyle, pPolyBezier->PenWidth,
        PenColor);


    PolyBezier(pasPerson->m_pView->m_usrDC, aP, cPoints);


    DebugExitVOID(ASShare::ODReplayPOLYBEZIER);
}



//
// ASShare::ODReplayROUNDRECT()
//
void ASShare::ODReplayROUNDRECT
(
    ASPerson *          pasPerson,
    LPROUNDRECT_ORDER   pRoundRect,
    BOOL                fPalRGB
)
{
    TSHR_COLOR          BackColor;
    TSHR_COLOR          ForeColor;
    TSHR_COLOR          PenColor;

    DebugEntry(ASShare::ODReplayROUNDRECT);

    TRACE_OUT(("ORDER: RoundRect BC %08lX FC %08lX BM %04hX " \
            "brush %02hX %02hX rop2 %04hX pen %04hX %04hX " \
            "%08lX rect %d %d %d %d ellipse %d %d",
        pRoundRect->BackColor,
        pRoundRect->ForeColor,
        (TSHR_UINT16)pRoundRect->BackMode,
        (TSHR_UINT16)pRoundRect->BrushStyle,
        (TSHR_UINT16)pRoundRect->BrushHatch,
        (TSHR_UINT16)pRoundRect->ROP2,
        (TSHR_UINT16)pRoundRect->PenStyle,
        (TSHR_UINT16)pRoundRect->PenWidth,
        pRoundRect->PenColor,
        (int)pRoundRect->nLeftRect,
        (int)pRoundRect->nTopRect,
        (int)pRoundRect->nRightRect,
        (int)pRoundRect->nBottomRect,
        (int)pRoundRect->nEllipseWidth,
        (int)pRoundRect->nEllipseHeight));

    ODAdjustColor(pasPerson, &(pRoundRect->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pRoundRect->ForeColor), &ForeColor, OD_FORE_COLOR);
    ODAdjustColor(pasPerson, &(pRoundRect->PenColor), &PenColor, OD_PEN_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseTextColor(pasPerson, fPalRGB, ForeColor);

    ODUseBkMode(pasPerson, pRoundRect->BackMode);

    ODUseBrush(pasPerson, fPalRGB, pRoundRect->BrushOrgX, pRoundRect->BrushOrgY,
        pRoundRect->BrushStyle, pRoundRect->BrushHatch, ForeColor,
        pRoundRect->BrushExtra);

    ODUseROP2(pasPerson, pRoundRect->ROP2);

    ODUsePen(pasPerson, fPalRGB, pRoundRect->PenStyle, pRoundRect->PenWidth,
        PenColor);


    //
    // Apply DS origin offset ourselves (do not use transform).
    //
    RoundRect(pasPerson->m_pView->m_usrDC,
        pRoundRect->nLeftRect  - pasPerson->m_pView->m_dsScreenOrigin.x,
        pRoundRect->nTopRect   - pasPerson->m_pView->m_dsScreenOrigin.y,
        pRoundRect->nRightRect - pasPerson->m_pView->m_dsScreenOrigin.x + 1,
        pRoundRect->nBottomRect- pasPerson->m_pView->m_dsScreenOrigin.y + 1,
        pRoundRect->nEllipseWidth,
        pRoundRect->nEllipseHeight);


    DebugExitVOID(ASShare::ODReplayROUNDRECT);
}



//
// ASShare::ODReplayLINETO()
// Replays LINETO order
//
void ASShare::ODReplayLINETO
(
    ASPerson *      pasPerson,
    LPLINETO_ORDER  pLineTo,
    BOOL            fPalRGB
)
{
    TSHR_COLOR      BackColor;
    TSHR_COLOR      PenColor;

    DebugEntry(ASShare::ODReplayLINETO);

    TRACE_OUT(("ORDER: LineTo BC %08lX BM %04X rop2 %04X pen " \
            "%04X %04X %08lX x1 %d y1 %d x2 %d y2 %d",
        pLineTo->BackColor,
        pLineTo->BackMode,
        pLineTo->ROP2,
        pLineTo->PenStyle,
        pLineTo->PenWidth,
        pLineTo->PenColor,
        pLineTo->nXStart,
        pLineTo->nYStart,
        pLineTo->nXEnd,
        pLineTo->nYEnd));

    ODAdjustColor(pasPerson, &(pLineTo->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pLineTo->PenColor), &PenColor, OD_PEN_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseBkMode(pasPerson, pLineTo->BackMode);

    ODUseROP2(pasPerson, pLineTo->ROP2);
    ODUsePen(pasPerson, fPalRGB, pLineTo->PenStyle, pLineTo->PenWidth,
        PenColor);


    //
    // Apply DS origin offset ourselves (do not use transform)
    //
    MoveToEx(pasPerson->m_pView->m_usrDC,
        pLineTo->nXStart - pasPerson->m_pView->m_dsScreenOrigin.x,
        pLineTo->nYStart - pasPerson->m_pView->m_dsScreenOrigin.y,
        NULL);
    LineTo(pasPerson->m_pView->m_usrDC,
        pLineTo->nXEnd - pasPerson->m_pView->m_dsScreenOrigin.x,
        pLineTo->nYEnd - pasPerson->m_pView->m_dsScreenOrigin.y);


    DebugExitVOID(ASShare::ODReplayLINETO);
}



//
// ASShare::ODReplayEXTTEXTOUT()
// Replays EXTTEXTOUT order
//
void ASShare::ODReplayEXTTEXTOUT
(
    ASPerson *          pasPerson,
    LPEXTTEXTOUT_ORDER  pExtTextOut,
    BOOL                fPalRGB
)
{
    LPINT               lpDx;
    RECT                rect;

    DebugEntry(ASShare::ODReplayEXTTEXTOUT);

    ValidateView(pasPerson);

    //
    // Convert from TSHR_RECT32 to RECT we can manipulate
    // And convert to screen coords
    //
    rect.left = pExtTextOut->rectangle.left;
    rect.top  = pExtTextOut->rectangle.top;
    rect.right = pExtTextOut->rectangle.right;
    rect.bottom = pExtTextOut->rectangle.bottom;
    OffsetRect(&rect, -pasPerson->m_pView->m_dsScreenOrigin.x, -pasPerson->m_pView->m_dsScreenOrigin.y);

    //
    // Get pointers to the optional/variable parameters.
    //
    if (pExtTextOut->fuOptions & ETO_WINDOWS)
    {
        //
        // Make the rectangle exclusive for Windows to use.
        //
        rect.right++;
        rect.bottom++;
    }

    if (pExtTextOut->fuOptions & ETO_LPDX)
    {
        //
        // if OE2 encoding is in use, the 'variable' string is
        // in fact fixed at its maximum possible value, hence
        // deltaX is always in the same place.
        //
        if (m_oefOE2EncodingOn)
        {
            lpDx = (LPINT)(pExtTextOut->variableDeltaX.deltaX);
        }
        else
        {
            //
            // If OE2 encoding is not in use, the variable string is
            // truly variable, hence the position of deltaX depends
            // on the length of the string.
            //
            lpDx = (LPINT)( ((LPBYTE)pExtTextOut) +
                  FIELD_OFFSET(EXTTEXTOUT_ORDER, variableString.string) +
                  pExtTextOut->variableString.len +
                  sizeof(pExtTextOut->variableDeltaX.len) );
        }

        //
        // Note that deltaLen contains the number of bytes used
        // for the deltas, NOT the number of deltas.
        //

        //
        // THERE IS A BUG IN THE ORDER ENCODING - THE DELTA
        // LENGTH FIELD IS NOT ALWAYS SET UP CORRECTLY.  USE
        // THE STRING LENGTH INSTEAD.
        //
    }
    else
    {
        lpDx = NULL;
    }

    TRACE_OUT(( "ORDER: ExtTextOut %u %s",
        pExtTextOut->variableString.len,
        pExtTextOut->variableString.string));

    //
    // Call our internal routine to draw the text
    //
    ODDrawTextOrder(pasPerson,
        TRUE,           // ExtTextOut
        fPalRGB,
        &pExtTextOut->common,
        pExtTextOut->variableString.string,
        pExtTextOut->variableString.len,
        &rect,
        pExtTextOut->fuOptions,
        lpDx);


    DebugExitVOID(ASShare::ODReplayEXTTEXTOUT);
}



//
// ASShare::ODReplayTEXTOUT()
// Replays TEXTOUT order
//
void ASShare::ODReplayTEXTOUT
(
    ASPerson *          pasPerson,
    LPTEXTOUT_ORDER     pTextOut,
    BOOL                fPalRGB
)
{
    DebugEntry(ASShare::ODReplayTEXTOUT);

    TRACE_OUT(("ORDER: TextOut len %hu '%s' flags %04hx bc %08lX " \
            "fc %08lX bm %04hx",
        (TSHR_UINT16)(pTextOut->variableString.len),
        pTextOut->variableString.string,
        pTextOut->common.FontFlags,
        pTextOut->common.BackColor,
        pTextOut->common.ForeColor,
        pTextOut->common.BackMode));

    //
    // Call our internal routine to draw the text
    //
    ODDrawTextOrder(pasPerson,
        FALSE,          // Not ExtTextOut
        fPalRGB,
        &pTextOut->common,
        pTextOut->variableString.string,
        pTextOut->variableString.len,
        NULL,           // ExtTextOut specific
        0,              // ExtTextOut specific
        NULL);          // ExtTextOut specific


    DebugExitVOID(ASShare::ODReplayTEXTOUT);
}



//
// ASShare::ODReplayOPAQUERECT()
// Replays OPAQUERECT order
//
void ASShare::ODReplayOPAQUERECT
(
    ASPerson *          pasPerson,
    LPOPAQUERECT_ORDER  pOpaqueRect,
    BOOL                fPalRGB
)
{
    RECT                rect;
    TSHR_COLOR          ForeColor;

    DebugEntry(ASShare::ODReplayOPAQUERECT);

    TRACE_OUT(( "ORDER: OpaqueRect BC %08lX x %d y %d w %x h %d",
        pOpaqueRect->Color,
        (int)pOpaqueRect->nLeftRect,
        (int)pOpaqueRect->nTopRect,
        (int)pOpaqueRect->nWidth,
        (int)pOpaqueRect->nHeight));

    ODAdjustColor(pasPerson, &(pOpaqueRect->Color), &ForeColor, OD_FORE_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, ForeColor);

    //
    // Apply DS origin offset ourselves (do not use transform)
    //
    rect.left   = pOpaqueRect->nLeftRect- pasPerson->m_pView->m_dsScreenOrigin.x;
    rect.top    = pOpaqueRect->nTopRect - pasPerson->m_pView->m_dsScreenOrigin.y;
    rect.right  = rect.left + pOpaqueRect->nWidth;
    rect.bottom = rect.top  + pOpaqueRect->nHeight;


    ExtTextOut(pasPerson->m_pView->m_usrDC, 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL);


    DebugExitVOID(ASShare::ODReplayOPAQUERECT);
}



//
// OD_ResetRectRegion()
//
void  ASShare::OD_ResetRectRegion(ASPerson * pasPerson)
{
    DebugEntry(ASShare::OD_ResetRectRegion);

    ValidateView(pasPerson);

    if (!pasPerson->m_pView->m_odRectReset)
    {
        SelectClipRgn(pasPerson->m_pView->m_usrDC, NULL);

        //
        // Indicate that the region is currently reset.
        //
        pasPerson->m_pView->m_odRectReset = TRUE;
    }

    DebugExitVOID(ASShare::OD_ResetRectRegion);
}



//
// ODUseFont()
//
void  ASShare::ODUseFont
(
    ASPerson *  pasPerson,
    LPSTR       pName,
    UINT        facelength,
    UINT        CodePage,
    UINT        MaxHeight,
    UINT        Height,
    UINT        Width,
    UINT        Weight,
    UINT        flags
)
{
    BOOL          rc  = TRUE;
    TEXTMETRIC*   pfm = NULL;
    UINT          textAlign;

    DebugEntry(ASShare::ODUseFont);

    ValidateView(pasPerson);

    //
    // If the baseline alignment flag has been set or cleared, change the
    // alignment in our surface (do this now before we reset the
    // odLastFontFlags variable).
    //
    if ((flags & NF_BASELINE) != (pasPerson->m_pView->m_odLastFontFlags & NF_BASELINE))
    {
        textAlign = GetTextAlign(pasPerson->m_pView->m_usrDC);
        if ((flags & NF_BASELINE) != 0)
        {
            //
            // We are setting the baseline alignment flag.  We have to
            // clear the top alignment flag and set the baseline flag (they
            // are mutually exclusive).
            //
            textAlign &= ~TA_TOP;
            textAlign |= TA_BASELINE;
        }
        else
        {
            //
            // We are clearing the baseline alignment flag.  We have to set
            // the top alignment flag and clear the baseline flag (they are
            // mutually exclusive).
            //
            textAlign |= TA_TOP;
            textAlign &= ~TA_BASELINE;
        }
        SetTextAlign(pasPerson->m_pView->m_usrDC, textAlign);
    }

    //
    // The font face string is NOT null terminated in the order data so we
    // must use strncmp.
    //
    if ((pasPerson->m_pView->m_odLastFontFaceLen != facelength                        ) ||
        (memcmp((LPSTR)pasPerson->m_pView->m_odLastFaceName,pName,facelength) != 0 ) ||
        (pasPerson->m_pView->m_odLastFontCodePage != CodePage   ) ||
        (pasPerson->m_pView->m_odLastFontHeight   != Height     ) ||
        (pasPerson->m_pView->m_odLastFontWidth    != Width      ) ||
        (pasPerson->m_pView->m_odLastFontWeight   != Weight     ) ||
        (pasPerson->m_pView->m_odLastFontFlags    != flags      ))
    {
        TRACE_OUT((
                 "Change font from %s (CodePage %d height %d width %d "    \
                     "weight %d flags %04X) to %s (CodePage %d height %d " \
                     "width %d weight %u flags %04X)",
                 pasPerson->m_pView->m_odLastFaceName,
                 pasPerson->m_pView->m_odLastFontCodePage,
                 pasPerson->m_pView->m_odLastFontHeight,
                 pasPerson->m_pView->m_odLastFontWidth,
                 pasPerson->m_pView->m_odLastFontWeight,
                 pasPerson->m_pView->m_odLastFontFlags,
                 pName,
                 CodePage,
                 Height,
                 Width,
                 Weight,
                 flags));

        memcpy(pasPerson->m_pView->m_odLastFaceName, pName, facelength);
        pasPerson->m_pView->m_odLastFontFaceLen          = facelength;
        pasPerson->m_pView->m_odLastFaceName[facelength] = '\0';
        pasPerson->m_pView->m_odLastFontCodePage         = CodePage;
        pasPerson->m_pView->m_odLastFontHeight           = Height;
        pasPerson->m_pView->m_odLastFontWidth            = Width;
        pasPerson->m_pView->m_odLastFontWeight           = Weight;
        pasPerson->m_pView->m_odLastFontFlags            = flags;

        rc = USR_UseFont(pasPerson->m_pView->m_usrDC, &pasPerson->m_pView->m_odLastFontID,
                pfm, (LPSTR)pasPerson->m_pView->m_odLastFaceName, CodePage, MaxHeight,
                Height, Width, Weight, flags);
    }
    else
    {
        //
        // The font hasn't changed.  But we must still select it in since
        // both OD2 and OD code select in fonts.
        //
        ASSERT(pasPerson->m_pView->m_odLastFontID != NULL);
        SelectFont(pasPerson->m_pView->m_usrDC, pasPerson->m_pView->m_odLastFontID);
    }

    DebugExitVOID(ASShare::ODUseFont);
}

//
// FUNCTION: ASShare::ODUseRectRegion
//
// DESCRIPTION:
//
// Set the clipping rectangle in the ScreenBitmap to the given rectangle.
// The values passed are inclusive.
//
// PARAMETERS:
//
void  ASShare::ODUseRectRegion
(
    ASPerson *  pasPerson,
    int         left,
    int         top,
    int         right,
    int         bottom
)
{
    POINT   aPoints[2];
    HRGN    hrgnRect;

    DebugEntry(ASShare::ODUseRectRegion);

    ValidateView(pasPerson);

    // Adjust for 2.x desktop scrolling
    left   -= pasPerson->m_pView->m_dsScreenOrigin.x;
    top    -= pasPerson->m_pView->m_dsScreenOrigin.y;
    right  -= pasPerson->m_pView->m_dsScreenOrigin.x;
    bottom -= pasPerson->m_pView->m_dsScreenOrigin.y;

    if ((pasPerson->m_pView->m_odRectReset)            ||
        (left   != pasPerson->m_pView->m_odLastLeft)   ||
        (top    != pasPerson->m_pView->m_odLastTop)    ||
        (right  != pasPerson->m_pView->m_odLastRight)  ||
        (bottom != pasPerson->m_pView->m_odLastBottom))
    {
        //
        // The region clip rectangle has changed, so we change the region
        // in the screen bitmap DC.
        //
        aPoints[0].x = left;
        aPoints[0].y = top;
        aPoints[1].x = right;
        aPoints[1].y = bottom;

        //
        // Windows requires that the coordinates are in DEVICE values for
        // its SelectClipRgn call.
        //
        LPtoDP(pasPerson->m_pView->m_usrDC, aPoints, 2);

        if ((left > right) || (top > bottom))
        {
            //
            // We get this for SaveScreenBitmap orders.  SFR5292
            //
            TRACE_OUT(( "Null bounds of region rect"));
            hrgnRect = CreateRectRgn(0, 0, 0, 0);
        }
        else
        {
            // We must add one to right & bottom since coords were inclusive
            hrgnRect = CreateRectRgn( aPoints[0].x,
                               aPoints[0].y,
                               aPoints[1].x+1,
                               aPoints[1].y+1);

        }
        SelectClipRgn(pasPerson->m_pView->m_usrDC, hrgnRect);

        pasPerson->m_pView->m_odLastLeft   = left;
        pasPerson->m_pView->m_odLastTop    = top;
        pasPerson->m_pView->m_odLastRight  = right;
        pasPerson->m_pView->m_odLastBottom = bottom;
        pasPerson->m_pView->m_odRectReset = FALSE;

        if (hrgnRect != NULL)
        {
            DeleteRgn(hrgnRect);
        }
    }

    DebugExitVOID(ASShare::ODUseRectRegion);
}


//
// ODUseBrush creates the correct brush to use.  NB.  We rely on
// UseTextColor and UseBKColor being called before this routine to set up
// pasPerson->m_pView->m_odLastTextColor and pasPerson->m_pView->m_odLastBkColor correctly.
//
void  ASShare::ODUseBrush
(
    ASPerson *      pasPerson,
    BOOL            fPalRGB,
    int             x,
    int             y,
    UINT            Style,
    UINT            Hatch,
    TSHR_COLOR      Color,
    BYTE            Extra[7]
)
{
    HBRUSH hBrushNew = NULL;

    DebugEntry(ASShare::ODUseBrush);

    // Reset the origin
    if ((x != pasPerson->m_pView->m_odLastBrushOrgX) ||
        (y != pasPerson->m_pView->m_odLastBrushOrgY))
    {
        SetBrushOrgEx(pasPerson->m_pView->m_usrDC, x, y, NULL);

        // Update saved brush org
        pasPerson->m_pView->m_odLastBrushOrgX = x;
        pasPerson->m_pView->m_odLastBrushOrgY = y;
    }

    if ((Style != pasPerson->m_pView->m_odLastLogBrushStyle)               ||
        (Hatch != pasPerson->m_pView->m_odLastLogBrushHatch)               ||
        (memcmp(&Color, &pasPerson->m_pView->m_odLastLogBrushColor, sizeof(Color))) ||
        (memcmp(Extra,pasPerson->m_pView->m_odLastLogBrushExtra,sizeof(pasPerson->m_pView->m_odLastLogBrushExtra))) ||
        ((pasPerson->m_pView->m_odLastLogBrushStyle == BS_PATTERN)      &&
           ((pasPerson->m_pView->m_odLastTextColor != pasPerson->m_pView->m_odLastBrushTextColor) ||
            (pasPerson->m_pView->m_odLastBkColor   != pasPerson->m_pView->m_odLastBrushBkColor))))
    {
        pasPerson->m_pView->m_odLastLogBrushStyle = Style;
        pasPerson->m_pView->m_odLastLogBrushHatch = Hatch;
        pasPerson->m_pView->m_odLastLogBrushColor = Color;
        memcpy(pasPerson->m_pView->m_odLastLogBrushExtra, Extra, sizeof(pasPerson->m_pView->m_odLastLogBrushExtra));

        if (pasPerson->m_pView->m_odLastLogBrushStyle == BS_PATTERN)
        {
            //
            // A pattern from a bitmap is required.
            //
            if (pasPerson->m_pView->m_odLastBrushPattern == NULL)
            {
                TRACE_OUT(( "Creating bitmap to use for brush setup"));

                pasPerson->m_pView->m_odLastBrushPattern = CreateBitmap(8,8,1,1,NULL);
            }

            if (pasPerson->m_pView->m_odLastBrushPattern != NULL)
            {
                char      lpBits[16];

                //
                // Place the bitmap bits into an array of bytes in the
                // correct form for SetBitmapBits which uses 16 bits per
                // scanline.
                //
                lpBits[14] = (char)Hatch;
                lpBits[12] = Extra[0];
                lpBits[10] = Extra[1];
                lpBits[8]  = Extra[2];
                lpBits[6]  = Extra[3];
                lpBits[4]  = Extra[4];
                lpBits[2]  = Extra[5];
                lpBits[0]  = Extra[6];

                SetBitmapBits(pasPerson->m_pView->m_odLastBrushPattern,8*2,lpBits);

                hBrushNew = CreatePatternBrush(pasPerson->m_pView->m_odLastBrushPattern);
                if (hBrushNew == NULL)
                {
                    ERROR_OUT(( "Failed to create pattern brush"));
                }
                else
                {
                    pasPerson->m_pView->m_odLastBrushTextColor = pasPerson->m_pView->m_odLastTextColor;
                    pasPerson->m_pView->m_odLastBrushBkColor   = pasPerson->m_pView->m_odLastBkColor;
                }
            }
        }
        else
        {
            LOGBRUSH        logBrush;

            logBrush.lbStyle = pasPerson->m_pView->m_odLastLogBrushStyle;
            logBrush.lbHatch = pasPerson->m_pView->m_odLastLogBrushHatch;
            logBrush.lbColor = ODCustomRGB(pasPerson->m_pView->m_odLastLogBrushColor.red,
                                           pasPerson->m_pView->m_odLastLogBrushColor.green,
                                           pasPerson->m_pView->m_odLastLogBrushColor.blue,
                                           fPalRGB);
            hBrushNew = CreateBrushIndirect(&logBrush);
        }

        if (hBrushNew == NULL)
        {
            ERROR_OUT(( "Failed to create brush"));
        }
        else
        {
            TRACE_OUT(( "Selecting new brush 0x%08x", hBrushNew));
            DeleteBrush(SelectBrush(pasPerson->m_pView->m_usrDC, hBrushNew));
        }
    }

    DebugExitVOID(ASShare::ODUseBrush);
}



//
// ODDrawTextOrder()
// Common text order playback code for EXTTEXTOUT and TEXTOUT
//
void ASShare::ODDrawTextOrder
(
    ASPerson *          pasPerson,
    BOOL                isExtTextOut,
    BOOL                fPalRGB,
    LPCOMMON_TEXTORDER  pCommon,
    LPSTR               pText,
    UINT                textLength,
    LPRECT              pExtRect,
    UINT                extOptions,
    LPINT               pExtDx
)
{
    LPSTR               faceName;
    UINT                faceNameLength;
    UINT                maxFontHeight;
    TSHR_UINT16         nFontFlags;
    TSHR_UINT16         nCodePage;
    TSHR_COLOR          BackColor;
    TSHR_COLOR          ForeColor;

    DebugEntry(ASShare::ODDrawTextOrder);

    ODAdjustColor(pasPerson, &(pCommon->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pCommon->ForeColor), &ForeColor, OD_FORE_COLOR);

    ODUseTextBkColor(pasPerson, fPalRGB, BackColor);
    ODUseTextColor(pasPerson, fPalRGB, ForeColor);

    ODUseBkMode(pasPerson, pCommon->BackMode);

    ODUseTextCharacterExtra(pasPerson, pCommon->CharExtra);
    ODUseTextJustification(pasPerson, pCommon->BreakExtra, pCommon->BreakCount);

    faceName = FH_GetFaceNameFromLocalHandle(pCommon->FontIndex,
                                             &faceNameLength);

    maxFontHeight = FH_GetMaxHeightFromLocalHandle(pCommon->FontIndex);

    //
    // Get the local font flags for the font, so that we can merge in any
    // specific local flag information when setting up the font.  The prime
    // example of this is whether the local font we matched is TrueType or
    // not, which information is not sent over the wire, but does need to
    // be used when setting up the font - or else we may draw using a local
    // fixed font of the same facename.
    //
    nFontFlags = (TSHR_UINT16)FH_GetFontFlagsFromLocalHandle(pCommon->FontIndex);

    //
    // Get the local CodePage for the font.
    //
    nCodePage = (TSHR_UINT16)FH_GetCodePageFromLocalHandle(pCommon->FontIndex);

    ODUseFont(pasPerson, faceName, faceNameLength, nCodePage,
        maxFontHeight, pCommon->FontHeight, pCommon->FontWidth,
        pCommon->FontWeight, pCommon->FontFlags | (nFontFlags & NF_LOCAL));

    //
    // Make the call.
    //
    if (isExtTextOut)
    {
        //
        // Apply DS origin offset ourselves (do not use transform)
        //
        ExtTextOut(pasPerson->m_pView->m_usrDC,
                  pCommon->nXStart - pasPerson->m_pView->m_dsScreenOrigin.x,
                  pCommon->nYStart - pasPerson->m_pView->m_dsScreenOrigin.y,
                  extOptions & ETO_WINDOWS,
                  pExtRect,
                  pText,
                  textLength,
                  pExtDx);
    }
    else
    {
        //
        // Apply DS origin offset ourselves (do not use transform)
        //
        TextOut(pasPerson->m_pView->m_usrDC,
                pCommon->nXStart - pasPerson->m_pView->m_dsScreenOrigin.x,
                pCommon->nYStart - pasPerson->m_pView->m_dsScreenOrigin.y,
                pText,
                textLength);
    }


    DebugExitVOID(ASShare::ODDrawTextOrder);
}



//
// ODAdjustColor()
//
// Used for playback on 4bpp devices.  We convert colors that are 'close'
// to VGA to their VGA equivalents.
//
// This function tries to find a close match in the VGA color set for a
// given input color.  Close is defined as follows: each color element
// (red, green, blue) must be within 7 of the corresponding element in a
// VGA color, without wrapping.  For example
//
// - 0xc7b8c6 is 'close' to 0xc0c0c0
//
// - 0xf8f8f8 is 'close' to 0xffffff
//
// - 0xff0102 is not 'close' to 0x000000, but is 'close' to 0xff0000
//
// Closeness is determined as follows:
//
// - for each entry in the table s_odVGAColors
//   - ADD the addMask to the color
//   - AND the result with the andMask
//   - if the result equals the testMask, this VGA color is close match
//
// Think about it.  It works.
//
//
void ASShare::ODAdjustColor
(
    ASPerson *          pasPerson,
    const TSHR_COLOR *  pColorIn,
    LPTSHR_COLOR        pColorOut,
    int                 type
)
{
    int         i;
    COLORREF    color;
    COLORREF    work;

    DebugEntry(ASShare::ODAdjustColor);

    *pColorOut = *pColorIn;

    if (g_usrScreenBPP > 4)
    {
        // Nothing to convert; bail out
        DC_QUIT;
    }

    //
    // Convert the color to a single integer
    //
    color = (pColorOut->red << 16) + (pColorOut->green << 8) + pColorOut->blue;

    //
    // See if this is the same as the last call of this type
    //
    if (color == pasPerson->m_pView->m_odLastVGAColor[type])
    {
        *pColorOut = pasPerson->m_pView->m_odLastVGAResult[type];
        TRACE_OUT(("Same as last %s color",
                (type == OD_BACK_COLOR ? "background" :
                type == OD_FORE_COLOR ? "foreground" : "pen")));
        DC_QUIT;
    }


    //
    // Scan the table for a close match.
    //
    for (i = 0; i < 16; i++)
    {
        //
        // Check for a close match.  Don't bother to look for an exact
        // match, as that is caught by this code.  The trade off is between
        // - an additional test and jump in non-exact cases
        // - an 'add' and an 'and' in the exact case.
        //
        work = color;
        work += s_odVGAColors[i].addMask;
        work &= s_odVGAColors[i].andMask;
        if (work == s_odVGAColors[i].testMask)
        {
            TRACE_OUT(( "%#6.6lx is close match for %#6.6lx (%s)",
                s_odVGAColors[i].color, color,
                type == OD_BACK_COLOR ? "background" :
                type == OD_FORE_COLOR ? "foreground" : "pen"));
            *pColorOut = s_odVGAColors[i].result;
            break;
        }
    }

    if (i == 16)
    {
        TRACE_OUT(( "No close VGA match found for %#6.6lx (%s)",
            color,
            type == OD_BACK_COLOR ? "background" :
            type == OD_FORE_COLOR ? "foreground" : "pen"));
    }

    //
    // Save the result for next time.
    //
    pasPerson->m_pView->m_odLastVGAColor[type] = color;
    pasPerson->m_pView->m_odLastVGAResult[type] = *pColorOut;

DC_EXIT_POINT:
    DebugExitVOID(ASShare::ODAdjustColor);
}


//
// LITTLE ASShare::ODUse() functions
//

//
// ASShare::ODUseTextBkColor()
//
void ASShare::ODUseTextBkColor
(
    ASPerson *  pasPerson,
    BOOL        fPalRGB,
    TSHR_COLOR  color
)
{
    COLORREF    rgb;

    ValidateView(pasPerson);

    rgb = ODCustomRGB(color.red, color.green, color.blue, fPalRGB);
    SetBkColor(pasPerson->m_pView->m_usrDC, rgb);

    // Update BK COLOR cache
    pasPerson->m_pView->m_odLastBkColor = rgb;
}


//
// ASShare::ODUseBkColor()
//
void ASShare::ODUseBkColor
(
    ASPerson *  pasPerson,
    BOOL        fPalRGB,
    TSHR_COLOR  color
)
{
    COLORREF    rgb;

    ValidateView(pasPerson);

    rgb = ODCustomRGB(color.red, color.green, color.blue, fPalRGB);
    if (rgb != pasPerson->m_pView->m_odLastBkColor)
    {
        SetBkColor(pasPerson->m_pView->m_usrDC, rgb);

        // Update BK COLOR cache
        pasPerson->m_pView->m_odLastBkColor = rgb;
    }
}


//
// ASShare::ODUseTextColor()
//
void ASShare::ODUseTextColor
(
    ASPerson *  pasPerson,
    BOOL        fPalRGB,
    TSHR_COLOR  color
)
{
    COLORREF    rgb;

    ValidateView(pasPerson);

    rgb = ODCustomRGB(color.red, color.green, color.blue, fPalRGB);
    if (rgb != pasPerson->m_pView->m_odLastTextColor)
    {
        SetTextColor(pasPerson->m_pView->m_usrDC, rgb);

        // Update TEXT COLOR cache
        pasPerson->m_pView->m_odLastTextColor = rgb;
    }
}


//
// ASShare::ODUseBkMode()
//
void ASShare::ODUseBkMode(ASPerson * pasPerson, int mode)
{
    if (mode != pasPerson->m_pView->m_odLastBkMode)
    {
        SetBkMode(pasPerson->m_pView->m_usrDC, mode);

        // Update BK MODE cache
        pasPerson->m_pView->m_odLastBkMode = mode;
    }
}



//
// ASShare::ODUsePen()
//
void ASShare::ODUsePen
(
    ASPerson *      pasPerson,
    BOOL            fPalRGB,
    UINT            style,
    UINT            width,
    TSHR_COLOR      color
)
{
    HPEN            hPenNew;
    COLORREF        rgb;

    ValidateView(pasPerson);

    rgb = ODCustomRGB(color.red, color.green, color.blue, fPalRGB);

    if ((style != pasPerson->m_pView->m_odLastPenStyle)   ||
        (rgb   != pasPerson->m_pView->m_odLastPenColor)   ||
        (width != pasPerson->m_pView->m_odLastPenWidth))
    {
        hPenNew = CreatePen(style, width, rgb);

        DeletePen(SelectPen(pasPerson->m_pView->m_usrDC, hPenNew));

        // Update PEN cache
        pasPerson->m_pView->m_odLastPenStyle = style;
        pasPerson->m_pView->m_odLastPenColor = rgb;
        pasPerson->m_pView->m_odLastPenWidth = width;
    }
}


//
// ASShare::ODUseROP2()
//
void ASShare::ODUseROP2(ASPerson * pasPerson, int rop2)
{
    if (rop2 != pasPerson->m_pView->m_odLastROP2)
    {
        SetROP2(pasPerson->m_pView->m_usrDC, rop2);

        // Update ROP2 cache
        pasPerson->m_pView->m_odLastROP2 = rop2;
    }
}


//
// ASShare::ODUseTextCharacterExtra()
//
void ASShare::ODUseTextCharacterExtra(ASPerson * pasPerson, int extra)
{
    if (extra != pasPerson->m_pView->m_odLastCharExtra)
    {
        SetTextCharacterExtra(pasPerson->m_pView->m_usrDC, extra);

        // Update TEXT EXTRA cache
        pasPerson->m_pView->m_odLastCharExtra = extra;
    }
}



//
// ASShare::ODUseTextJustification()
//
void ASShare::ODUseTextJustification(ASPerson * pasPerson, int extra, int count)
{
    if ((extra != pasPerson->m_pView->m_odLastJustExtra) ||
        (count != pasPerson->m_pView->m_odLastJustCount))
    {
        SetTextJustification(pasPerson->m_pView->m_usrDC, extra, count);

        // Update TEXT JUST cache
        pasPerson->m_pView->m_odLastJustExtra = extra;
        pasPerson->m_pView->m_odLastJustCount = count;
    }
}


//
// ASShare::ODUseFillMode()
//
void ASShare::ODUseFillMode(ASPerson * pasPerson, UINT mode)
{
    if (mode != pasPerson->m_pView->m_odLastFillMode)
    {
        SetPolyFillMode(pasPerson->m_pView->m_usrDC, (mode == ORD_FILLMODE_WINDING) ?
            WINDING : ALTERNATE);

        // Update FILL MODE cache
        pasPerson->m_pView->m_odLastFillMode = mode;
    }
}


//
// ASShare::ODUseArcDirection()
//
void ASShare::ODUseArcDirection(ASPerson * pasPerson, UINT dir)
{
    if (dir != pasPerson->m_pView->m_odLastArcDirection)
    {
        SetArcDirection(pasPerson->m_pView->m_usrDC, (dir == ORD_ARC_CLOCKWISE) ?
            AD_CLOCKWISE : AD_COUNTERCLOCKWISE);

        // Update ARC DIR cache
        pasPerson->m_pView->m_odLastArcDirection = dir;
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\im.cpp ===
#include "precomp.h"


//
// IM.CPP
// Input Manager
//
// Copyright(c) Microsoft 1997-
//
#include <confreg.h>

#define MLZ_FILE_ZONE  ZONE_INPUT




//
// IM_ShareStarting()
//
BOOL ASShare::IM_ShareStarting(void)
{
    BOOL    rc = FALSE;
    HKEY    hkeyBandwidth;
    UINT    i;
    BYTE    tmpVK;

    DebugEntry(ASShare::IM_ShareStarting);

    //
    // Find out the scan codes for the left and right shift keys.
    //

    //
    // SFR 2537: Get the scan codes for this keyboard for the left-right
    // variants of SHIFT.
    //
    // We do not do this for the left-right variants of CONTROL and ALT (ie
    // menu) because they are extended keys.
    //
    // The scan codes are used in the keyboard hook (when sending) and in
    // the network translate to OS routine (when receiving), to
    // distinguish between the left-right variants of VK_SHIFT, where
    // Windows only reports a single value.
    //
    // This method is pretty long
    //
    m_imScanVKLShift = (BYTE) MapVirtualKey(VK_SHIFT, 0);
    for (i = 0; i < 256; i++)
    {
        tmpVK = (BYTE)MapVirtualKey(i, 1);
        if ( (tmpVK == VK_SHIFT) &&  (i != m_imScanVKLShift) )
        {
            m_imScanVKRShift = (BYTE)i;
            break;
        }
    }

    TRACE_OUT(( "Left/Right VK_SHIFT: scan codes = %02X, %02X",
        m_imScanVKLShift, m_imScanVKRShift));

    //
    // Check the user-reported bandwidth to decide if we should optimize
    // input for bandwidth or latency.
    // BUGBUG will want to vary this via flow control instead in future
    //
    m_imInControlMouseWithhold = 0;

    //
    // Find out if this is a DBCS enabled system - if it is then we'll need
    // to load IMM32.DLL.
    //
    ASSERT(m_imImmLib == NULL);
    ASSERT(m_imImmGVK == NULL);

    if (GetSystemMetrics(SM_DBCSENABLED))
    {
        //
        // DBCS system, so load IMM32.DLL
        //
        m_imImmLib = LoadLibrary("imm32.dll");
        if (!m_imImmLib)
        {
            ERROR_OUT(( "Failed to load imm32.dll"));
            DC_QUIT;
        }

        //
        // Now attempt to find the entry point in this DLL.
        //
        m_imImmGVK = (IMMGVK) GetProcAddress(m_imImmLib, "ImmGetVirtualKey");
        if (!m_imImmGVK)
        {
            ERROR_OUT(( "Failed to fixup <ImmGetVirtualKey>"));
            DC_QUIT;
        }
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::IM_ShareStarting, rc);
    return(rc);
}



//
// IM_ShareEnded()
//
void ASShare::IM_ShareEnded(void)
{
    DebugEntry(ASShare::IM_ShareEnded);

    // Free imm32 dll
    m_imImmGVK = NULL;

    if (m_imImmLib)
    {
        FreeLibrary(m_imImmLib);
        m_imImmLib = NULL;
    }

    DebugExitVOID(ASShare::IM_ShareEnded);
}



//
// IM_Controlled()
//
// Called when we start/stop being controlled.
//
BOOL ASShare::IM_Controlled(ASPerson * pasControlledBy)
{
    BOOL    rc;

    DebugEntry(ASShare::IM_Controlled);

    if (pasControlledBy)
    {
        // Incoming injected input queues should be empty
        ASSERT(m_imControlledEventQ.numEvents == 0);
        ASSERT(m_imControlledEventQ.head == 0);
        ASSERT(m_imControlledOSQ.numEvents == 0);
        ASSERT(m_imControlledOSQ.head == 0);

        //
        // Reset CONTROLLED vars
        //
        m_imfControlledMouseButtonsReversed = (GetSystemMetrics(SM_SWAPBUTTON) != 0);
        m_imfControlledMouseClipped             = FALSE;
        m_imfControlledPaceInjection            = FALSE;
        m_imfControlledNewEvent                 = TRUE;
        m_imControlledNumEventsPending          = 0;
        m_imControlledNumEventsReturned         = 0;

        m_imControlledLastLowLevelMouseEventTime  = GetTickCount();
        m_imControlledLastMouseRemoteTime       = 0;
        m_imControlledLastMouseLocalTime        = 0;
        m_imControlledLastIncompleteConversion  = 0;
        m_imControlledMouseBacklog              = 0;
        GetCursorPos(&m_imControlledLastMousePos);

        // Get current keyboard state
        GetKeyboardState(m_aimControlledKeyStates);

        // Save it so we can put it back when done being controlled
        ASSERT(sizeof(m_aimControlledSavedKeyStates) == sizeof(m_aimControlledKeyStates));
        CopyMemory(m_aimControlledSavedKeyStates, m_aimControlledKeyStates, sizeof(m_aimControlledKeyStates));

        // Clear original keyboard state
        ZeroMemory(m_aimControlledKeyStates, sizeof(m_aimControlledKeyStates));
        SetKeyboardState(m_aimControlledKeyStates);

        //
        // On the other side, the remote will start sending us events to
        // bring our keyboard in sync with his.  Then real input events.
        //
    }
    else
    {
        //
        // We're no longer controlled.  Clear the remote queues.
        //
        m_imControlledOSQ.head = 0;
        m_imControlledOSQ.numEvents = 0;

        m_imControlledEventQ.numEvents = 0;

        //
        // Put back our saved keyboard state
        //
        SetKeyboardState(m_aimControlledSavedKeyStates);
    }

    rc = OSI_InstallControlledHooks(pasControlledBy != NULL);
    if (!rc)
    {
        ERROR_OUT(("IM_Controlled:  Couldn't install controlled hooks"));
        DC_QUIT;
    }
    g_lpimSharedData->imControlled = (pasControlledBy != NULL);

DC_EXIT_POINT:
    DebugExitBOOL(ASShare:IM_Controlled, rc);
    return(rc);
}



//
// IM_InControl()
//
// Called when we start/stop being in control.  We must observe high-level
// keyboard events.
//
void ASShare::IM_InControl(ASPerson * pasInControlOf)
{
    DebugEntry(ASShare::IM_InControl);

    if (pasInControlOf)
    {
        //
        // Set up InControl vars.
        //

        // Get current key state
        GetKeyboardState(m_aimInControlKeyStates);

        m_imfInControlEventIsPending        = FALSE;
        m_imfInControlCtrlDown              = FALSE;
        m_imfInControlShiftDown             = FALSE;
        m_imfInControlMenuDown              = FALSE;
        m_imfInControlCapsLock              = FALSE;
        m_imfInControlNumLock               = FALSE;
        m_imfInControlScrollLock            = FALSE;
        m_imfInControlConsumeMenuUp         = FALSE;
        m_imfInControlConsumeEscapeUp       = FALSE;
        m_imfInControlNewEvent              = TRUE;
        m_imInControlMouseDownCount         = 0;
        m_imInControlMouseDownTime          = 0;
        m_imInControlMouseSpoilRate         = 0;
        m_imInControlNumEventsPending       = 0;
        m_imInControlNumEventsReturned      = 0;
        m_imInControlNextHotKeyEntry        = 0;

        //
        // Send mouse move with our current position to the dude we're in
        // control of.
        //
        ValidateView(pasInControlOf);
        ASSERT(pasInControlOf->m_caControlledBy == m_pasLocal);
    }
    else
    {
        // Clear outgoing queues
        m_imInControlEventQ.head      = 0;
        m_imInControlEventQ.numEvents = 0;
    }

    DebugExitVOID(ASShare::IM_InControl);
}


//
// IM_Periodic
//
void ASShare::IM_Periodic(void)
{
    POINT      cursorPos;
    UINT       timeDelta;

    DebugEntry(ASShare::IM_Periodic);

    if (m_pasLocal->m_caInControlOf)
    {
        //
        // Send outgoing input to person we're in control of
        //
        IMFlushOutgoingEvents();
    }
    else if (m_pasLocal->m_caControlledBy)
    {
        ASSERT(m_pHost);

        //
        // Playback input from person in control of us
        //
        IMMaybeInjectEvents();

        //
        // Get the current cursor position - we always need this.
        //
        GetCursorPos(&cursorPos);

        //
        // First check if we think that a cursor clip will have affected the
        // position when we replayed a remote event.
        //
        if (m_imfControlledMouseClipped)
        {
            RECT cursorClip;

            //
            // Get the current clip and the current cursor position.
            //
            GetClipCursor(&cursorClip);

            if ((cursorPos.x == cursorClip.left) ||
                (cursorPos.x == (cursorClip.right-1)) ||
                (cursorPos.y == cursorClip.top) ||
                (cursorPos.y == (cursorClip.bottom-1)))
            {
                WARNING_OUT(("CM_ApplicationMovedCursor {%04d, %04d}",
                    cursorPos.x, cursorPos.y));

                //
                // We thought the cursor was going to be clipped and now we
                // find it is right at the edge of the clip so tell the CM to
                // tell its peers about the cursor being moved.
                //
                m_pHost->CM_ApplicationMovedCursor();
                m_imfControlledMouseClipped = FALSE;
            }
        }

        // We are being controlled by somebody else.
        // So now's the time to decide if a SetCursorPos has
        // happened.  For us to believe that a SetCursorPos has actually
        // occurred, the elapsed time since the last low-level input event
        // was injected must be greater than IM_EVENT_PERCOLATE_TIME
        // and the cursor must be in a different position to that which we
        // currently believe it to be.
        //
        if ((cursorPos.x != m_imControlledLastMousePos.x) ||
            (cursorPos.y != m_imControlledLastMousePos.y))
        {
            TRACE_OUT(( "GCP gives (%d,%d), last mouse event is (%d,%d)",
                     cursorPos.x,
                     cursorPos.y,
                     m_imControlledLastMousePos.x,
                     m_imControlledLastMousePos.y));

            //
            // Get the current tick count.
            //
            timeDelta = GetTickCount() - m_imControlledLastLowLevelMouseEventTime;

            if (timeDelta > IM_EVENT_PERCOLATE_TIME)
            {
                //
                // Looks like a SetCursorPos has occured - tell CM.
                //
                WARNING_OUT(("CM_ApplicationMovedCursor {%04d, %04d}",
                    cursorPos.x, cursorPos.y));
                m_pHost->CM_ApplicationMovedCursor();

                //
                // Update the last high level mouse position.
                //
                m_imControlledLastMousePos.x = cursorPos.x;
                m_imControlledLastMousePos.y = cursorPos.y;
            }
        }
    }

    DebugExitVOID(ASShare::IM_Periodic);
}



//
// IM_ReceivedPacket()
//
// A null packet pointer can be used to trigger the injection of another
// pending event
//
//
// DESCRIPTION:
//
// Called when an IM events packet arrives at the PR.  The IM will accept
// the incoming packet.  It may copy it to an internal queue rather than
// process it immediately.  IM events packets contain a series of
// piggybacked IM events.
//
// PARAMETERS:
//
// personID - the source of the packet
//
// pPacket - a pointer to the packet
//
// RETURNS: NONE
//
void ASShare::IM_ReceivedPacket
(
    ASPerson *      pasFrom,
    PS20DATAPACKET  pPacket
)
{
    LPIMPACKET      pIMPacket;
    UINT            i;

    DebugEntry(ASShare::IM_ReceivedPacket);

    if (!pasFrom)
    {
        TRACE_OUT(("Simply inject any pending events in"));
        DC_QUIT;
    }

    ValidatePerson(pasFrom);

    pIMPacket = (PIMPACKET)pPacket;

    // If this person isn't in control of us, blow this off
    if (pasFrom->m_caInControlOf != m_pasLocal)
    {
        DC_QUIT;
    }

    //
    // For each packet in the piggybacked packets array...
    //
    TRACE_OUT(("IM_ReceivedPacket:  Processing packet with %d events",
        pIMPacket->numEvents));
    for (i = 0; i < pIMPacket->numEvents; i++)
    {
        switch (pIMPacket->aEvents[i].type)
        {
            case IM_TYPE_ASCII:
            case IM_TYPE_VK1:
            case IM_TYPE_VK2:
            case IM_TYPE_3BUTTON:
            {
                IMAppendNetEvent(&(pIMPacket->aEvents[i]));
                break;
            }

            default:
                //
                // Unexpected events are not error - we just ignore then
                // for future compatibility
                //
                TRACE_OUT(("Person [%d] unrecognised IM type (%04X) - event discarded",
                    pasFrom->mcsID, pIMPacket->aEvents[i].type));
                break;
        }
    }

DC_EXIT_POINT:

    //
    // Our final action is to feed one of the new events into USER.
    // We do NOT feed them all in at once because we want to simulate
    // typing them in, otherwise the amount of spoiling we see is
    // totally dependent upon the network latency and piggybacking.
    //
    ValidatePerson(m_pasLocal);
    if (m_pasLocal->m_caControlledBy)
    {
        //
        // @@@JPB: Temporary - want to inject as many events as possible -
        // this should be moved to a loop within IMMaybeInjectEvents...
        //
        // This greatly improves responsiveness when handling a large
        // number of input events in a short space of time (e.g. pounding
        // on the keyboard) - very little overrun.
        //
        for (i = 0; i < 10; i++)
        {
            IMMaybeInjectEvents();
        }

        //
        // Go into TURBO scheduling if this is a real input packet.
        //
        if (pPacket != NULL)
        {
            SCH_ContinueScheduling(SCH_MODE_TURBO);
        }
    }

    DebugExitVOID(ASShare::IM_ReceivedPacket);
}




//
// IMGetHighLevelKeyState
//
// DESCRIPTION:
//
// Called by the IEM when it is converting a local event to a network event
// to determine the state of the local keyboard when the event was
// generated.
//
// PARAMETERS:
//
// vk - the key
//
// RETURNS:
//
// Flags - bit 7 set/reset key down/up, bit 0 toggle
//
//
BYTE  ASShare::IMGetHighLevelKeyState(UINT  vk)
{
    int     keyState;
    BYTE    rc;

    DebugEntry(ASShare::IMGetHighLevelKeyState);

    keyState = GetKeyState(vk);

    rc = (BYTE) (((keyState & 0x8000) >> 8) | keyState & 0x0001);

    DebugExitDWORD(ASShare::IMGetHighLevelKeyState, rc);
    return(rc);
}



//
// FUNCTION: IMFlushOutgoingEvents
//
// DESCRIPTION:
//
// Called to send new IMEVENTs (as they are generated and periodically).
// This function will send as many IMEVENTs from the current backlog as
// possible.
//
// PARAMETERS: NONE
//
// RETURNS: NONE
//
//
void ASShare::IMFlushOutgoingEvents(void)
{
    UINT        i;
    UINT        sizeOfPacket;
    PIMPACKET   pIMPacket;
    UINT        lastEvent;
    UINT        secondLastEvent;
    UINT        elapsedTime;
    UINT        time;
    UINT        eventsToSend;
    UINT        curTime;
    BOOL        holdPacket;
#ifdef _DEBUG
    UINT        sentSize;
#endif // _DEBUG

    DebugEntry(ASShare::IMFlushOutgoingEvents);

    ValidateView(m_pasLocal->m_caInControlOf);

    //
    // Try to convert the input into a bunch of IMEVENTs
    //
    while (m_imfInControlEventIsPending && (m_imInControlEventQ.numEvents < IM_SIZE_EVENTQ))
    {
        //
        // There is space to try and convert the pending packet.
        //
        m_imfInControlEventIsPending = (IMTranslateOutgoing(&m_imInControlPendingEvent,
                      &m_imInControlEventQ.events[CIRCULAR_INDEX(m_imInControlEventQ.head,
                      m_imInControlEventQ.numEvents, IM_SIZE_EVENTQ)]) != FALSE);
        if (m_imfInControlEventIsPending)
        {
            //
            // We have added a packet to the queue - update our queue
            // tracking variables.
            //
            m_imInControlEventQ.numEvents++;
        }
    }

    //
    // Mouse handling has been improved in the following ways
    //   - withhold generation of packets while we are purely handling
    //     mouse moves and we are within the LOCAL_MOUSE_WITHHOLD range
    //     While we are doing this spoil them to the highest frequency
    //     we are permitted to generate (SAMPLING_GAP_HIGH)
    //   - if we exceed the withholding threshhold but remain within queue
    //     size/2 spoil down to the intermediate range
    //     (SAMPLING_GAP_MEDIUM)
    //   - otherwise spoil down to the low range
    //
    // We spoil the events by hanging on to the last event for a while, if
    // it was a mouse move, so that we can use it for subsequent spoiling.
    // Whenever we get a non-mouse message then we spoil the lot to
    // eliminate latency, on clicks, for example.
    //

    //
    // Calculate the mouse spoil rate - do we need more than just the high
    // rate spoiling?
    //
    if (m_imInControlEventQ.numEvents > m_imInControlMouseWithhold + 1)
    {
        //
        // Are we into intermediate or low spoiling?
        //
        if (m_imInControlEventQ.numEvents < (IM_SIZE_EVENTQ +
                               m_imInControlMouseWithhold) / 2)
        {
            TRACE_OUT(( "Mouse spoil rate to MEDIUM"));
            m_imInControlMouseSpoilRate = IM_LOCAL_MOUSE_SAMPLING_GAP_MEDIUM_MS;
        }
        else
        {
            TRACE_OUT(( "Mouse spoil rate to LOW"));
            m_imInControlMouseSpoilRate = IM_LOCAL_MOUSE_SAMPLING_GAP_LOW_MS;
        }
    }
    else
    {
        //
        // Spoil at the normal high rate
        //
        if (m_imInControlMouseSpoilRate != IM_LOCAL_MOUSE_SAMPLING_GAP_HIGH_MS)
        {
            TRACE_OUT(( "Mouse spoil rate to HIGH"));
            m_imInControlMouseSpoilRate = IM_LOCAL_MOUSE_SAMPLING_GAP_HIGH_MS;
        }
    }

    //
    // Firstly get a pointer to lastEvent for use here and in send arm
    // below (We wont use it if m_imInControlEventQ.numEvents == 0)
    //
    lastEvent = CIRCULAR_INDEX(m_imInControlEventQ.head,
        m_imInControlEventQ.numEvents - 1, IM_SIZE_EVENTQ);

    //
    // Now perform the spoiling, if necessary
    //
    if (m_imInControlEventQ.numEvents > 1)
    {
        if (lastEvent == 0)
        {
            secondLastEvent = IM_SIZE_EVENTQ - 1;
        }
        else
        {
            secondLastEvent = lastEvent - 1;
        }

        elapsedTime = m_imInControlEventQ.events[lastEvent].timeMS
                    - m_imInControlEventQ.events[secondLastEvent].timeMS;
        TRACE_OUT(( "Inter packet time %d, sampling gap %ld",
                    elapsedTime,m_imInControlMouseSpoilRate));

        if ((elapsedTime < m_imInControlMouseSpoilRate) &&
            (m_imInControlEventQ.events[lastEvent].type == IM_TYPE_3BUTTON) &&
            (m_imInControlEventQ.events[secondLastEvent].type == IM_TYPE_3BUTTON) &&
            (m_imInControlEventQ.events[lastEvent].data.mouse.flags &
                                                      IM_FLAG_MOUSE_MOVE) &&
            (m_imInControlEventQ.events[secondLastEvent].data.mouse.flags &
                                                          IM_FLAG_MOUSE_MOVE))
        {
            TRACE_OUT(( "spoil mouse move from pos %u", secondLastEvent));
            time = m_imInControlEventQ.events[secondLastEvent].timeMS;
            m_imInControlEventQ.events[secondLastEvent] =
                                                m_imInControlEventQ.events[lastEvent];
            m_imInControlEventQ.events[secondLastEvent].timeMS = time;
            m_imInControlEventQ.numEvents--;
            lastEvent = secondLastEvent;
        }
    }

    //
    // If we have any events queued up and we are not waiting for a mouse
    // button up event then try to send them.  (Note we do not wait for a
    // mouse up event if the queue is full because if we got a mouse up
    // when the queue was full then we would have nowhere to put it!)
    //
    curTime = GetTickCount();

    if ((m_imInControlEventQ.numEvents != 0) &&
        ((m_imfInControlEventIsPending ||
         (m_imInControlMouseDownCount == 0) ||
         (curTime - m_imInControlMouseDownTime > IM_MOUSE_UP_WAIT_TIME))))
    {
        //
        // If there are mouse move messages on the queue and they are not
        // so old that we should send them anyway then hold them to allow
        // some spoiling to take place.
        //
        holdPacket = FALSE;

        if (m_imInControlEventQ.numEvents <= m_imInControlMouseWithhold)
        {
            if ((m_imInControlEventQ.events[lastEvent].type == IM_TYPE_3BUTTON) &&
                (m_imInControlEventQ.events[lastEvent].data.mouse.flags &
                                                          IM_FLAG_MOUSE_MOVE))
            {
                if (curTime < (m_imInControlEventQ.events[m_imInControlEventQ.head].timeMS +
                                                     IM_LOCAL_WITHHOLD_DELAY))
                {
                    holdPacket = TRUE;
                }
            }
        }

        if (m_imInControlEventQ.numEvents <= IM_LOCAL_KEYBOARD_WITHHOLD)
        {
            //
            // If the message indicates the key is down then wait, either
            // for the release we know is coming, or intil it has auto
            // repeated for a while or until the buffer is full.
            //
            if (((m_imInControlEventQ.events[lastEvent].type == IM_TYPE_ASCII) ||
                 (m_imInControlEventQ.events[lastEvent].type == IM_TYPE_VK1)   ||
                 (m_imInControlEventQ.events[lastEvent].type == IM_TYPE_VK2))  &&
                 (m_imInControlEventQ.events[lastEvent].data.keyboard.flags &
                                                   IM_FLAG_KEYBOARD_DOWN))
            {
                curTime = GetTickCount();
                if (curTime < (m_imInControlEventQ.events[m_imInControlEventQ.head].timeMS +
                                                  IM_LOCAL_WITHHOLD_DELAY))
                {
                    holdPacket = TRUE;
                }
            }
        }

        if (!holdPacket)
        {
            UINT    destID;

            TRACE_OUT(( "Sending all %d packets",m_imInControlEventQ.numEvents));
            eventsToSend                    = m_imInControlEventQ.numEvents;
            m_imInControlEventQ.numEvents    = 0;

            destID = m_pasLocal->m_caInControlOf->mcsID;

            sizeOfPacket = sizeof(IMPACKET) + (eventsToSend-1)*sizeof(IMEVENT);
            pIMPacket = (PIMPACKET)SC_AllocPkt(PROT_STR_INPUT, destID, sizeOfPacket);
            if (!pIMPacket)
            {
                //
                // Failed to send this packet - keep the data on the queue
                // until the next time we are called.  To prevent the loss
                // of data, just make sure that the local packet list is
                // not overwritten by restoring the current out packets
                // count.
                //
                WARNING_OUT(("Failed to alloc IM packet, size %u", sizeOfPacket));
                m_imInControlEventQ.numEvents = eventsToSend;
            }
            else
            {
                TRACE_OUT(( "NetAllocPkt successful for %d packets size %d",
                           eventsToSend, sizeOfPacket));

                //
                // Fill in the packet header.
                //
                pIMPacket->header.data.dataType = DT_IM;

                //
                // Construct the contents of the IM specific part of the
                // packet.
                //
                pIMPacket->numEvents = (TSHR_UINT16)eventsToSend;
                for (i = 0; i < eventsToSend; i++)
                {
                    pIMPacket->aEvents[i] = m_imInControlEventQ.events[m_imInControlEventQ.head];
                    m_imInControlEventQ.head =
                        CIRCULAR_INDEX(m_imInControlEventQ.head, 1,
                            IM_SIZE_EVENTQ);
                }

                //
                // Now send the packet.
                //
#ifdef _DEBUG
                sentSize =
#endif // _DEBUG
                DCS_CompressAndSendPacket(PROT_STR_INPUT, destID,
                    &(pIMPacket->header), sizeOfPacket);

                TRACE_OUT(("IM packet size: %08d, sent %08d", sizeOfPacket, sentSize));
            }
        }
    }

    DebugExitVOID(ASShare::IMFlushOutgoingEvents);
}



//
// IMSpoilEvents()
//
// Called when outgoing IM packets get backlogged, we spoil every other
// mouse move to shrink the number of events and therefore the size of the
// IM packet(s).
//
void ASShare::IMSpoilEvents(void)
{
    UINT      lastEvent;
    UINT      i;
    UINT      j;
    UINT      k;
    BOOL      discard = TRUE;

    DebugEntry(ASShare::IMSpoilEvents);

    WARNING_OUT(( "Major spoiling due to IM packet queue backlog!"));

    i = CIRCULAR_INDEX(m_imInControlEventQ.head,
        m_imInControlEventQ.numEvents - 1, IM_SIZE_EVENTQ);
    while (i != m_imInControlEventQ.head)
    {
        if ((m_imInControlEventQ.events[i].type == IM_TYPE_3BUTTON) &&
            (m_imInControlEventQ.events[i].data.mouse.flags & IM_FLAG_MOUSE_MOVE))
        {
            if (discard)
            {
                TRACE_OUT(( "spoil mouse move from pos %u", i));
                j = CIRCULAR_INDEX(i, 1, IM_SIZE_EVENTQ);
                k = i;
                lastEvent = CIRCULAR_INDEX(m_imInControlEventQ.head,
                    m_imInControlEventQ.numEvents - 1, IM_SIZE_EVENTQ);
                while (k != lastEvent)
                {
                    //
                    // Shuffle the entries along the queue.
                    //
                    m_imInControlEventQ.events[k] = m_imInControlEventQ.events[j];

                    k = CIRCULAR_INDEX(k, 1, IM_SIZE_EVENTQ);
                    j = CIRCULAR_INDEX(j, 1, IM_SIZE_EVENTQ);
                }

                m_imInControlEventQ.numEvents--;
                discard = FALSE;
            }
            else
            {
                discard = TRUE;
            }
        }

        //
        // Move on to the next event infront of this one.
        //
        if (i > 0)
        {
            i = i - 1;
        }
        else
        {
            i = IM_SIZE_EVENTQ - 1;
        }
    }

    DebugExitVOID(ASShare::IMSpoilEvents);
}


//
// IMAppendNetEvent()
//
// Add the incoming event to the remote network queue, doing basic
// translation like mouse button swapping.  Ignore unrecognized events.
//
void ASShare::IMAppendNetEvent(PIMEVENT pIMEvent)
{
    int   i;
    BOOL  discard = TRUE;

    DebugEntry(ASShare::IMAppendNetEvent);

    switch (pIMEvent->type)
    {
        case IM_TYPE_3BUTTON:
            if (!(pIMEvent->data.mouse.flags & IM_FLAG_MOUSE_MOVE))
            {
                //
                // Swap the mouse buttons if necessary.
                //
                if (m_imfControlledMouseButtonsReversed &&
                    (pIMEvent->data.mouse.flags &
                            (TSHR_UINT16)(IM_FLAG_MOUSE_BUTTON1 |
                                       IM_FLAG_MOUSE_BUTTON2)))
                {
                    pIMEvent->data.mouse.flags ^=
                            (TSHR_UINT16)(IM_FLAG_MOUSE_BUTTON1 |
                                       IM_FLAG_MOUSE_BUTTON2);
                }
            }
            break;
    }


    //
    // Now put the IMEVENT into our queue.
    // Before we try to add the current packet we will try to inject some
    // more events (and therefore make space on the network event queue)
    //

    if (m_imControlledEventQ.numEvents >= IM_SIZE_EVENTQ)
    {
        //
        // Our network event queue is full - discard every other mouse
        // move event in the queue.
        //
        WARNING_OUT(( "Major spoiling due to network event queue backlog!"));

        for (i = m_imControlledEventQ.numEvents - 1; i >= 0; i--)
        {
            if (IM_IS_MOUSE_MOVE(m_imControlledEventQ.events[i].data.mouse.flags))
            {
                if (discard)
                {
                    //
                    // Remove this mouse move event by moving all events
                    // after it down one.
                    //
                    WARNING_OUT(("Discard mouse move to {%d, %d}",
                      (UINT)(m_imControlledEventQ.events[i].data.mouse.x),
                      (UINT)(m_imControlledEventQ.events[i].data.mouse.y)));

                    UT_MoveMemory(&(m_imControlledEventQ.events[i]),
                       &(m_imControlledEventQ.events[i+1]),
                       sizeof(IMEVENT) *
                            (m_imControlledEventQ.numEvents-1-i) );

                    m_imControlledEventQ.numEvents--;
                    discard = FALSE;
                }
                else
                {
                    discard = TRUE;
                }
            }
        }
    }

    if (m_imControlledEventQ.numEvents + 1 >= IM_SIZE_EVENTQ)
    {
        //
        // We've done our best and can't find any space.
        //
        WARNING_OUT(( "IM packet dropped %04X", pIMEvent->type));
    }
    else
    {
        //
        // Add this event to the queue
        //
        m_imControlledEventQ.events[m_imControlledEventQ.numEvents] = *pIMEvent;
        m_imControlledEventQ.numEvents++;
    }

    DebugExitVOID(ASShare::IMAppendNetEvent);
}




//
// IM_OutgoingMouseInput()
//
// Called to send mouse moves and clicks to the remote host.
// Called from the view window code.
//
void  ASShare::IM_OutgoingMouseInput
(
    ASPerson *  pasHost,
    LPPOINT     pMousePos,
    UINT        message,
    UINT        dwExtra
)
{
    IMEVENT     imEvent;

    DebugEntry(ASShare::IM_OutgoingMouseInput);

    ValidateView(pasHost);
    ASSERT(pasHost->m_caControlledBy == m_pasLocal);

    GetKeyboardState(m_aimInControlKeyStates);

    //
    // Create the event.
    //
    imEvent.type = IM_TYPE_3BUTTON;

    //
    // We should only get WM_MOUSE* messages.
    //
    ASSERT(message >= WM_MOUSEFIRST);
    ASSERT(message <= WM_MOUSELAST);

    //
    // Convert to bit flags.
    //
    switch (message)
    {
        case WM_MOUSEMOVE:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_MOVE;
            break;

        case WM_LBUTTONDOWN:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_BUTTON1 |
                                        IM_FLAG_MOUSE_DOWN;
            break;

        case WM_LBUTTONDBLCLK:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_BUTTON1 |
                                        IM_FLAG_MOUSE_DOUBLE  |
                                        IM_FLAG_MOUSE_DOWN;
            break;

        case WM_LBUTTONUP:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_BUTTON1;
            break;

        case WM_RBUTTONDOWN:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_BUTTON2 |
                                        IM_FLAG_MOUSE_DOWN;
            break;

        case WM_RBUTTONDBLCLK:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_BUTTON2 |
                                        IM_FLAG_MOUSE_DOUBLE  |
                                        IM_FLAG_MOUSE_DOWN;
            break;

        case WM_RBUTTONUP:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_BUTTON2;
            break;

        case WM_MBUTTONDOWN:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_BUTTON3 |
                                        IM_FLAG_MOUSE_DOWN;
            break;

        case WM_MBUTTONDBLCLK:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_BUTTON3 |
                                        IM_FLAG_MOUSE_DOUBLE  |
                                        IM_FLAG_MOUSE_DOWN;
            break;

        case WM_MBUTTONUP:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_BUTTON3;
            break;

        case WM_MOUSEWHEEL:
            //
            // LAURABU BOGUSBOGUS
            //
            // The HIWORD of wParam represents the # of clicks the wheel
            // has turned.
            //
            // But what about Win95?  NT and Win95 Magellan mouse work
            // differently.
            //
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_WHEEL;

            //
            // Check for overflows.  If the wheel delta is outside the
            // values that can be sent by the protocol, send the maximum
            // values.
            //
            if ((TSHR_INT16)HIWORD(dwExtra) >
                   (IM_FLAG_MOUSE_ROTATION_MASK - IM_FLAG_MOUSE_DIRECTION))
            {
                ERROR_OUT(( "Mouse wheel overflow %hd", HIWORD(dwExtra)));
                imEvent.data.mouse.flags |=
                      (IM_FLAG_MOUSE_ROTATION_MASK - IM_FLAG_MOUSE_DIRECTION);
            }
            else if ((TSHR_INT16)HIWORD(dwExtra) < -IM_FLAG_MOUSE_DIRECTION)
            {
                ERROR_OUT(( "Mouse wheel underflow %hd", HIWORD(dwExtra)));
                imEvent.data.mouse.flags |= IM_FLAG_MOUSE_DIRECTION;
            }
            else
            {
                imEvent.data.mouse.flags |=
                             (HIWORD(dwExtra) & IM_FLAG_MOUSE_ROTATION_MASK);
            }

            //
            // Win95 boxes need to know whether the middle mouse button is
            // up or down.
            //
            if (LOWORD(dwExtra) & MK_MBUTTON)
            {
                imEvent.data.mouse.flags |= IM_FLAG_MOUSE_DOWN;
            }
            break;

        default:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_MOVE;
            ERROR_OUT(( "Unrecognised mouse event - %#x", message));
            break;
    }

    TRACE_OUT(( "Mouse event flags %hx", imEvent.data.mouse.flags));

    imEvent.data.mouse.x = (TSHR_INT16)(pMousePos->x);
    imEvent.data.mouse.y = (TSHR_INT16)(pMousePos->y);
    imEvent.timeMS       = GetTickCount();

    //
    // If this is a mouse down event then we will wait a while before
    // sending the packet for a mouse up event so that a single click
    // can be sent in one packet to avoid timing problems on the remote
    // side - with for example a scroll bar scrolling multiple lines
    // instead of just one line.
    //

    if ((message == WM_LBUTTONDOWN) ||
        (message == WM_RBUTTONDOWN) ||
        (message == WM_MBUTTONDOWN) ||
        (message == WM_LBUTTONDBLCLK) ||
        (message == WM_RBUTTONDBLCLK) ||
        (message == WM_MBUTTONDBLCLK))
    {
        m_imInControlMouseDownCount++;
        m_imInControlMouseDownTime = GetTickCount();
    }
    else if ((message == WM_LBUTTONUP) ||
             (message == WM_RBUTTONUP) ||
             (message == WM_MBUTTONUP))
    {
        --m_imInControlMouseDownCount;
        if (m_imInControlMouseDownCount < 0)
        {
            TRACE_OUT(("Unmatched button down for %d", message));
            m_imInControlMouseDownCount = 0;
        }
    }

    //
    // Try to send the packet.
    //
    if (!IMConvertAndSendEvent(pasHost, &imEvent))
    {
        WARNING_OUT(("Couldn't send mouse packet from local node"));
    }

    DebugExitVOID(ASShare::IM_OutgoingMouseInput);
}



//
// IM_OutgoingKeyboardInput()
//
// Called to key downs, ups, and chars to the remote host.
// Called from the view window code.
//
void  ASShare::IM_OutgoingKeyboardInput
(
    ASPerson *  pasHost,
    UINT        wParam,
    UINT        lParam
)
{
    IMEVENT     imEvent;
    int         rc;
    int         retFlags;
    WORD        result[2];
    UINT        i;
    BOOL        fSwallowDeadKey;
    UINT        mainVK;

    DebugEntry(ASShare::IM_OutgoingKeyboardInput);

    ValidateView(pasHost);

    ASSERT(pasHost->m_caControlledBy = m_pasLocal);

    GetKeyboardState(m_aimInControlKeyStates);

    //
    // Trace out the parameters once we've got this far.
    //
    TRACE_OUT(( "wParam - %04X, lParam - %08lX", wParam, lParam));

    //
    // Create the event.
    //
    imEvent.data.keyboard.flags = (TSHR_UINT16)
                                 (HIWORD(lParam) & IM_MASK_KEYBOARD_SYSFLAGS);
    imEvent.timeMS = GetTickCount();
    imEvent.data.keyboard.keyCode = LOBYTE(wParam);

    retFlags = CA_SEND_EVENT | CA_ALLOW_EVENT;

    if ((wParam == VK_LWIN) || (wParam == VK_RWIN))
    {
        //
        // The Windows keys give control to the local user interface.
        //
        // The keys are defined to do the following by the spec "New key
        // support for Microsoft Windows Operating Systems and
        // Applications"
        //
        //   Left Windows key - set focus to Win95 user interface
        //   Right Windows key - as left
        //   Both Windows keys - Log-on key for Windows NT
        //   Windows key + any other - reserved for system hot keys
        //
        // Thus it does not make any sense to send these keys to the remote
        // system at all.
        //
		retFlags &= ~CA_SEND_EVENT;
    }
    else if ((wParam == VK_PROCESSKEY) && (m_imImmGVK != NULL))
    {
        //
        // An IME has processed this key - we want to find out what the
        // original key was so call <ImmGetVirtualKey>.
        //
        ValidateView(pasHost);
        wParam = m_imImmGVK(pasHost->m_pView->m_viewClient);

        TRACE_OUT(( "Translated wP from VK_PROCESSKEY to %#lx", wParam));
    }

    if (retFlags & CA_SEND_EVENT)
    {
        //
        // First check if this is a dead-key up stroke - if it is then
        // don't call ToAscii as the shift state may have changed and we'll
        // get the wrong accent or no accent at all.  Assume that if the VK
        // is a potential dead key VK (disregarding shift state) and
        // m_imInControlNumDeadKeysDown is > 0 that this is a dead key - swallow
        // it.
        //
        fSwallowDeadKey = FALSE;

        if ((m_imInControlNumDeadKeysDown != 0) &&
            (imEvent.data.keyboard.flags & IM_FLAG_KEYBOARD_RELEASE))
        {
            for (i = 0; i < m_imInControlNumDeadKeys; i++)
            {
                if (m_aimInControlDeadKeys[i] == (BYTE)imEvent.data.keyboard.keyCode)
                {
                    //
                    // Assume this is a dead key up and therefore we don't
                    // want to pass it through ToAscii or generate any
                    // events based on it.
                    //
                    m_imInControlNumDeadKeysDown--;
                    TRACE_OUT(( "m_imInControlNumDeadKeysDown - %d",
                             m_imInControlNumDeadKeysDown));
                    fSwallowDeadKey = TRUE;
                }
            }
        }

        if (!fSwallowDeadKey)
        {
            //
            // Find out if we can translate this virtual key into the
            // Windows character set.
            //

            //
            // Now try to convert this to an Ascii character.
            //
            rc = ToAscii(wParam,
                         LOBYTE(HIWORD(lParam)),
                         m_aimInControlKeyStates,
                         &result[0],
                         !(!(HIWORD(lParam) & KF_MENUMODE)));

            if ((rc == 1) && (LOBYTE(result[0]) <= ' '))
            {
                //
                // Don't use the results of ToAscii if its less than space
                // (32) or space itself as Windows claims that the
                // characters below this in the Windows character set are
                // not supported and ToAscii will convert space plus
                // modifiers to an ascii space and when we replay it
                // VkKeyScan will tell us that ascii space shouldn't have
                // any modifiers so we will undo any modifiers.  This will
                // clobber apps which interpret Ctrl-Space, Shift-Space.
                //
                rc = 0;
            }

            //
            // Some Ascii characters can be generated from more than one
            // key.  (Eg '-' is on the main keyboard and the number pad).
            // Convert this ASCII character back to a VK_ value.  If it is
            // different from the VK_ we started with, then do not send the
            // key press as ASCII (Ie only send the 'main' way of entering
            // an ASCII value as ASCII).
            //
            // Oprah1943: revert to the VK only if the ASCII code is less
            // than 0x80.  This avoids losing the diacritic in a dead-key
            // sequence.  VkKeyScan for the key down following the dead-key
            // up returns the dead-key VK rather than that of the keystroke
            // (wParam).
            //
            if (rc == 1)
            {
                mainVK = VkKeyScan(LOBYTE(result[0]));

                if ( (LOBYTE(mainVK) != LOBYTE(wParam)) &&
                     (LOBYTE(result[0]) < 0x80) )
                {
                    TRACE_OUT((
                      "Not MAIN VK pressed=0x%02hx main=0x%02hx ('%c'/%02hx)",
                             (TSHR_UINT16)LOBYTE(wParam),
                             (TSHR_UINT16)LOBYTE(mainVK),
                             (char)LOBYTE(result[0]),
                             (UINT)LOBYTE(result[0])));
                    rc = 0;
                }
            }

            //
            // If ToAscii converts this to a dead key then don't send any
            // packets at all.
            //
            if (rc != -1)
            {
                if (rc == 1)
                {
                    TRACE_OUT(( "ToAscii rc=1, result - %02X",
                             LOBYTE(result[0])));

                    //
                    // Succesfully converted to an Ascii key.
                    //
                    imEvent.type = IM_TYPE_ASCII;
                    imEvent.data.keyboard.keyCode = LOBYTE(result[0]);

                    //
                    // Try to send the packet.
                    //
                    if (!IMConvertAndSendEvent(pasHost, &imEvent))
                    {
                        WARNING_OUT(( "dropped local key press %u",
                                 (UINT)imEvent.data.keyboard.keyCode));
                    }
                }
                else if (rc == 2)
                {
                    TRACE_OUT(( "ToAscii rc=2, result - %04X", result[0]));

                    //
                    // Succesfully converted to two Ascii keys.  If this is
                    // a key down then we will return a key down and key up
                    // for the `dead' character first then the key down.
                    // If its a key up then just return the key up.
                    //
                    if (!(imEvent.data.keyboard.flags &
                                               IM_FLAG_KEYBOARD_RELEASE))
                    {
                        //
                        // This is the key down - so generate a fake
                        // keyboard press for the dead key.
                        //
                        IMGenerateFakeKeyPress(IM_TYPE_ASCII,
                                               LOBYTE(result[0]),
                                               imEvent.data.keyboard.flags);
                    }

                    //
                    // Now return the current keystroke.
                    //
                    imEvent.type = IM_TYPE_ASCII;
                    imEvent.data.keyboard.keyCode = LOBYTE(result[1]);

                    //
                    // Try to send the packet.
                    //
                    if (!IMConvertAndSendEvent(pasHost, &imEvent))
                    {
                        WARNING_OUT(( "dropped local key press %u",
                                 (UINT)imEvent.data.keyboard.keyCode));
                    }
                }
                else
                {
                    //
                    // Check for keys that we want to convert.
                    //
                    if (LOBYTE(wParam) == VK_KANJI)
                    {
                        //
                        // We only see a down press for VK_KANJI so we
                        // fake a complete key press so that the remote
                        // does not get confused.
                        //
                        IMGenerateFakeKeyPress(IM_TYPE_VK1,
                                               VK_KANJI,
                                               imEvent.data.keyboard.flags);
                    }
                    else
                    {
                        //
                        // No conversion - use the VK itself.
                        //
                        imEvent.type = IM_TYPE_VK1;
                        imEvent.data.keyboard.keyCode = LOBYTE(wParam);

                        //
                        // SFR 2537: If this is a right shift VK (which we
                        // can detect via the scan code in lParam), set the
                        // right_variant keyboard flag.  We do not do this
                        // for the right-variants of CONTROL and ALT (ie
                        // menu) because they are extended keys - already
                        // catered for by the extended flag.
                        //
                        if ( (m_imScanVKRShift != 0) &&
                             (m_imScanVKRShift == LOBYTE(HIWORD(lParam))) )
                        {
                            imEvent.data.keyboard.flags |=
                                                       IM_FLAG_KEYBOARD_RIGHT;
                        }

                        //
                        // Try to send the packet.
                        //
                        if (!IMConvertAndSendEvent(pasHost, &imEvent))
                        {
                            WARNING_OUT(( "dropped local key press %u",
                                     (UINT)imEvent.data.keyboard.keyCode));
                        }
                    }
                }
            }
            else
            {
                //
                // This is a dead key - add it to our array of dead keys if
                // we haven't already heard about it.
                //
                IMMaybeAddDeadKey(
                                (BYTE)imEvent.data.keyboard.keyCode);
                m_imInControlNumDeadKeysDown++;
                TRACE_OUT(( "m_imInControlNumDeadKeysDown - %d",
                         m_imInControlNumDeadKeysDown));
            }
        }
    }

    DebugExitVOID(ASShare::IM_OutgoingKeyboardInput);
}


//
// FUNCTION: IMGenerateFakeKeyPress(...)
//
// DESCRIPTION:
//
// Generates a fake keyboard press.
//
// PARAMETERS:
//
// type   - packet type to generate.
// key    - key to generate press for.
// flags  - flags on keyboard press.
//
// RETURNS:
//
// Nothing.
//
//
void  ASShare::IMGenerateFakeKeyPress
(
    TSHR_UINT16     type,
    TSHR_UINT16     key,
    TSHR_UINT16     flags
)
{
    IMEVENT         imEventFake;

    DebugEntry(ASShare::IMGenerateFakeKeyPress);

    TRACE_OUT(( "Faking keyboard press:%#hx type:%#hx", key, type));

    //
    // Generate the key down first of all.
    //
    ZeroMemory(&imEventFake, sizeof(imEventFake));

    imEventFake.type                  = type;
    imEventFake.timeMS                = GetTickCount();
    imEventFake.data.keyboard.keyCode = key;

    //
    // Try to send the packet.
    //
    if (!IMConvertAndSendEvent(m_pasLocal->m_caInControlOf, &imEventFake))
    {
        WARNING_OUT(( "Dropped local key press %hu (flags: %#hx)",
                 imEventFake.data.keyboard.keyCode,
                 imEventFake.data.keyboard.flags));
    }

    //
    // Set the release and down flags in order to fake the up.
    //
    imEventFake.data.keyboard.flags = IM_FLAG_KEYBOARD_DOWN | IM_FLAG_KEYBOARD_RELEASE;

    //
    // Try to send the packet.
    //
    if (!IMConvertAndSendEvent(m_pasLocal->m_caInControlOf, &imEventFake))
    {
        WARNING_OUT(( "Dropped local key press %hu (flags: %#hx)",
                 imEventFake.data.keyboard.keyCode,
                 imEventFake.data.keyboard.flags));
    }

    DebugExitVOID(ASShare::IMGenerateFakeKeyPress);
}








//
// FUNCTION: IMConvertAndSendEvent
//
// DESCRIPTION:
//
// Called with an IMEVENT this function will try to queue (and even send
// if possible) the packet.  If it fails it will return FALSE - the caller
// should discard the packet.  If it succeeds it will return TRUE.
//
// If pasFor is us, it means to send to everybody (and coords are relative
// to  sender's screen).
//
// If pasFor is a remote, it means that the IM packet is meant for just
// that person and the coords are relative to pasFor's screen.
//
//
// PARAMETERS:
//
// pIMEvent - the IMEVENT to convert and send
//
// RETURNS: TRUE or FALSE - success or failure
//
//
BOOL  ASShare::IMConvertAndSendEvent
(
    ASPerson *      pasFor,
    PIMEVENT        pIMEvent
)
{
    BOOL rc = FALSE;

    DebugEntry(ASShare::IMConvertAndSendEvent);

    //
    // If there is already a pending packet then see if we can flush some
    // packets onto the network.
    //
    if (m_imfInControlEventIsPending)
    {
        IMFlushOutgoingEvents();
    }

    //
    // If there is still a pending packet then see if we can spoil some
    // events.
    //
    if (m_imfInControlEventIsPending)
    {
        TRACE_OUT(( "trying to drop mouse move events"));
        IMSpoilEvents();
        IMFlushOutgoingEvents();
    }

    //
    // Now see if we are able to accept a new packet
    //
    if (m_imfInControlEventIsPending)
    {
        //
        // If there is still a previous IMEVENT which we are in the
        // process of converting then we are not ready to receive any more
        // packets.
        //
        TRACE_OUT(( "can't queue packet"));
        DC_QUIT;
    }

    //
    // Now set up the new packet and try to flush the packets again.
    //
    m_imfInControlEventIsPending = TRUE;
    m_imInControlPendingEvent = *pIMEvent;
    IMFlushOutgoingEvents();

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::IMConvertAndSendEvent, rc);
    return(rc);
}


//
// FUNCTION: IMMaybeAddDeadKey
//
// DESCRIPTION:
//
// Called whenever ToAscii tells us about a dead key.  If we haven't
// got it in our table already then we will add it.  We create the table
// incrementally because we have found that some keyboard drivers don't
// cope very well with being queried with all possible VKs to find the
// dead keys.  Note that this will not cope with someone switching their
// keyboard driver whilst DC-Share is running.
//
// PARAMETERS:
//
// vk - the VK in question
//
// RETURNS: NONE
//
//
void  ASShare::IMMaybeAddDeadKey(BYTE     vk)
{
    UINT  i;

    DebugEntry(IMMaybeAddDeadKey);

    //
    // First see if we already know about this key.
    //
    for (i = 0; i < m_imInControlNumDeadKeys; i++)
    {
        if (m_aimInControlDeadKeys[i] == vk)
        {
            DC_QUIT;
        }
    }

    //
    // Add this key if there's space in the array.
    //
    if (m_imInControlNumDeadKeys < IM_MAX_DEAD_KEYS)
    {
        TRACE_OUT(( "Add %02X", (TSHR_UINT16)vk));
        m_aimInControlDeadKeys[m_imInControlNumDeadKeys++] = vk;
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::IMMaybeAddDeadKey);
}



//
// IMConvertIMEventToOSEvent()
// Converts incoming event to something we can playback.
//
// PARAMETERS:
//
// pIMEvent -   the IMEVENT to be converted
//
// pOSEvent - the IMOSEVENT to be created
//
//
UINT  ASShare::IMConvertIMEventToOSEvent
(
    PIMEVENT        pIMEvent,
    LPIMOSEVENT     pOSEvent
)
{
    int             mouseX;
    int             mouseY;
    int             realMouseX;
    int             realMouseY;
    RECT            cursorClip;
    UINT            rc = (IM_IMQUEUEREMOVE | IM_OSQUEUEINJECT);

    DebugEntry(ASShare::IMConvertIMEventToOSEvent);

    switch (pIMEvent->type)
    {
        case IM_TYPE_3BUTTON:
            //
            // Fill in common fields.  Note that we claim to be a 3 button
            // mouse so that we can replay events from remote three button
            // mice and we always give absolute coordinates.
            //
            pOSEvent->type                    = IM_MOUSE_EVENT;
            pOSEvent->flags                   = 0;
            pOSEvent->time                    = pIMEvent->timeMS;
            pOSEvent->event.mouse.cButtons    = 3;
            pOSEvent->event.mouse.mouseData   = 0;
            pOSEvent->event.mouse.dwExtraInfo = 0;

            //
            // First check for a wheel rotate, since this is easy to
            // process.  (It cannot include any mouse movement as well).
            //
            if (pIMEvent->data.mouse.flags & IM_FLAG_MOUSE_WHEEL)
            {
                if (pIMEvent->data.mouse.flags &
                        (IM_FLAG_MOUSE_BUTTON1 |
                         IM_FLAG_MOUSE_BUTTON2 |
                         IM_FLAG_MOUSE_BUTTON3))
                {
                    //
                    // Using any of the button flags along with the wheel
                    // flag is currently undefined - for forward
                    // compatability we therefore ignore such an event by
                    // converting it into a NULL injected event.
                    //
                    // (We do not sg_lpimSharedData->imply discard it, since the logic to
                    // discard events does not seem to work).
                    //
                    pOSEvent->event.mouse.flags = 0;
                    pOSEvent->event.mouse.pt.x = 0;
                    pOSEvent->event.mouse.pt.y = 0;
                }
                else
                {
                    //
                    // This is a wheel movement.
                    //
                    // Note that the protocol has sent whether the mouse's
                    // middle button is depressed or released, but we don't
                    // need that info for NT, so just ignore it.
                    //
                    pOSEvent->event.mouse.flags = MOUSEEVENTF_WHEEL;

                    pOSEvent->event.mouse.mouseData =
                        (pIMEvent->data.mouse.flags & IM_FLAG_MOUSE_ROTATION_MASK);
                    pOSEvent->event.mouse.pt.x = 0;
                    pOSEvent->event.mouse.pt.y = 0;

                    //
                    // Sign extend the rotation amount up to the full 32
                    // bits
                    //
                    if (pOSEvent->event.mouse.mouseData & IM_FLAG_MOUSE_DIRECTION)
                    {
                        pOSEvent->event.mouse.mouseData |=
                                           ~IM_FLAG_MOUSE_ROTATION_MASK;
                    }
                }

                break;
            }

            //
            // We are left now with non wheel-rotate events.
            //
            pOSEvent->event.mouse.flags = MOUSEEVENTF_ABSOLUTE;

            //
            // We must convert from virtual desktop coordinates to local
            // screen coordinates here and we must also prevent the
            // position wrapping if we try to replay a mouse move to an
            // off-screen position.
            //

            realMouseX = pIMEvent->data.mouse.x;
            realMouseY = pIMEvent->data.mouse.y;

            //
            // Now lg_lpimSharedData->imit to the size of the real screen.
            //
            mouseX = min((m_pasLocal->cpcCaps.screen.capsScreenWidth-1), max(0, realMouseX));
            mouseY = min((m_pasLocal->cpcCaps.screen.capsScreenHeight-1), max(0, realMouseY));

            //
            // Work out if this event will be clipped by the clip cursor
            //
            GetClipCursor(&cursorClip);

            if ((mouseX < cursorClip.left) ||
                (mouseX >= cursorClip.right) ||
                (mouseY < cursorClip.top) ||
                (mouseY >= cursorClip.bottom))
            {
                //
                // This event will actually be clipped because of the
                // current clip cursor.  Remember this.
                //
                m_imfControlledMouseClipped = TRUE;
            }
            else
            {
                m_imfControlledMouseClipped = FALSE;

                //
                // If we clamp the mouse position before replaying then we
                // must remember the real packet and make the current
                // packet into a move so that we don't click down/up at the
                // wrong place.
                //
                if ((mouseX != realMouseX) || (mouseY != realMouseY))
                {
                    //
                    // The mouse position we've recieved is off the
                    // local physical screen.  Now that we no longer have
                    // desktop scrolling, we simply clamp it rather than
                    // inject it at the edge and wait for the scroll.
                    //
                    // We turn mouse down-clicks into moves and let
                    // up-clicks pass through (in case the mouse button
                    // has been pressed within the real screen).
                    //
                    // Note that the mouse position has already been
                    // adjusted so that it is within the real screen.
                    //
                    if (pIMEvent->data.mouse.flags & IM_FLAG_MOUSE_DOWN)
                    {
                        pIMEvent->data.mouse.flags = IM_FLAG_MOUSE_MOVE;
                    }
                }
            }

            //
            // Store the mouse position.
            //
            pOSEvent->event.mouse.pt.x = mouseX;
            pOSEvent->event.mouse.pt.y = mouseY;

            //
            // Add more flags as appropriate.
            //
            if (pIMEvent->data.mouse.flags & IM_FLAG_MOUSE_MOVE)
            {
                pOSEvent->event.mouse.flags |= MOUSEEVENTF_MOVE;
            }
            else
            {
                switch (pIMEvent->data.mouse.flags &
                                                   ( IM_FLAG_MOUSE_BUTTON1 |
                                                     IM_FLAG_MOUSE_BUTTON2 |
                                                     IM_FLAG_MOUSE_BUTTON3 |
                                                     IM_FLAG_MOUSE_DOWN ))
                {
                    case IM_FLAG_MOUSE_BUTTON1 | IM_FLAG_MOUSE_DOWN:
                        pOSEvent->event.mouse.flags |= MOUSEEVENTF_LEFTDOWN;
                        break;

                    case IM_FLAG_MOUSE_BUTTON1:
                        pOSEvent->event.mouse.flags |= MOUSEEVENTF_LEFTUP;
                        break;

                    case IM_FLAG_MOUSE_BUTTON2 | IM_FLAG_MOUSE_DOWN:
                        pOSEvent->event.mouse.flags |= MOUSEEVENTF_RIGHTDOWN;
                        break;

                    case IM_FLAG_MOUSE_BUTTON2:
                        pOSEvent->event.mouse.flags |= MOUSEEVENTF_RIGHTUP;
                        break;

                    case IM_FLAG_MOUSE_BUTTON3 | IM_FLAG_MOUSE_DOWN:
                        pOSEvent->event.mouse.flags |= MOUSEEVENTF_MIDDLEDOWN;
                        break;

                    case IM_FLAG_MOUSE_BUTTON3:
                        pOSEvent->event.mouse.flags |= MOUSEEVENTF_MIDDLEUP;
                        break;

                    default:
                        //
                        // If we don't recognise this then don't play it
                        // back
                        //
                        ERROR_OUT(("Unrecognised mouse flags (%04X)",
                                 pIMEvent->data.mouse.flags));
                        rc = IM_IMQUEUEREMOVE;
                        break;
                }
            }
            break;

        case IM_TYPE_VK1:
            //
            // Common fields.
            //
            pOSEvent->flags     = 0;
            if (pIMEvent->data.keyboard.flags & IM_FLAG_KEYBOARD_UPDATESTATE)
                pOSEvent->flags |= IM_FLAG_UPDATESTATE;

            pOSEvent->time      = pIMEvent->timeMS;

            //
            // Now handle normal keyboard events.
            //
            pOSEvent->type      = IM_KEYBOARD_EVENT;

            //
            // AX is the scancode in AL and 00h (press) or 80h (release) in
            // AH. Map the DC protocol VK to the equivalent OS VK.
            // AL = the scancode for the VK).
            //
            pOSEvent->event.keyboard.vkCode = LOBYTE(pIMEvent->data.keyboard.keyCode);

            pOSEvent->event.keyboard.flags = 0;
            if (IS_IM_KEY_RELEASE(pIMEvent->data.keyboard.flags))
            {
                pOSEvent->event.keyboard.flags |= KEYEVENTF_KEYUP;
            }

            //
            // SFR 2537: If the flags indicate that the received VK is the
            // right-variant, do not map the VK to a scan code, but rather
            // directly use the already acquired right-variant scan code
            // for the VK.  (For the moment, the only case we support is
            // for Windows, where this is an issue for SHIFT).
            //
            if ( IS_IM_KEY_RIGHT(pIMEvent->data.keyboard.flags) &&
                 (pIMEvent->data.keyboard.keyCode == VK_SHIFT)   )
            {
                pOSEvent->event.keyboard.scanCode = m_imScanVKRShift;
            }
            else
            {
                pOSEvent->event.keyboard.scanCode =
                         (WORD)MapVirtualKey(pIMEvent->data.keyboard.keyCode, 0);
            }

            if (pIMEvent->data.keyboard.flags & IM_FLAG_KEYBOARD_EXTENDED)
            {
                pOSEvent->event.keyboard.flags |= KEYEVENTF_EXTENDEDKEY;
            }

            pOSEvent->event.keyboard.dwExtraInfo = 0;
            break;

        default:
            ERROR_OUT(("Unrecognized imEvent (%d)", pIMEvent->type));
            //
            // Discard the event (remove from the IM queue and don't inject
            // into the OS).
            //
            rc = IM_IMQUEUEREMOVE;
            break;
    }


    DebugExitDWORD(ASShare::IMConvertIMEventToOSEvent, rc);
    return(rc);
}



//
// IMTranslateOutgoing()
//
// DESCRIPTION:
//
// Converts locally generated sequences of IMEVENTs into transmitted
// sequences of IMEVENTs.  Does a 1 to (0-n) translation.  Handles
// buffering modifier keys and translating DC-Share hot-key sequences.
//
// When the CA has decided an IMEVENT should be sent this function is
// called by the IM with a pointer to that packet in pIMEventIn.
// IMTranslateOutgoing can then return TRUE and fill in the packet at
// pIMEventOut or return FALSE.  If IMTranslateOutgoing returns TRUE the IM
// will call it again with the same packet.  The IMEVENTs returned are
// sent across the network by the IM.
//
// PARAMETERS:
//
// pIMEventIn - pointer to IMEVENT
//
// pIMEventOut - pointer to IMEVENT
//
// RETURNS:
//
// TRUE - packet returned (call function again)
//
// FALSE - no packet returned (don't call function again)
//
//

BOOL ASShare::IMTranslateOutgoing
(
    LPIMEVENT pIMEventIn,
    LPIMEVENT pIMEventOut
)
{
    UINT      hotKeyArrayIndex;
    UINT      hotKeyValue;
    BOOL      fHotKeyFound;
    BOOL      rc = FALSE;

    DebugEntry(ASShare::IMTranslateOutgoing);

    //
    // Here we need to tell the remote system about certain keys which are
    // consumed locally so that it can make good decisions about whether
    // and how to replay them.  We want to keep the remote system in step
    // with the current modifier and toggle key state on our system (as it
    // is possible that either a modifier/toggle key event occurred whilst
    // a local app was active and was therefore never sent) We also want to
    // recognise certain `hot key' sequences and send further packets as a
    // result of these.
    //
    // The keys we comsume locally are:
    //
    // Esc down or up when Ctrl is down - operates task list locally
    //
    // Tab down or up when Alt is down - operates task switcher locally
    //
    // Esc down or up when Alt is pressed - switches to next window locally
    //
    // Esc up when corresponding Esc down occurred when Alt was down - as
    // above
    //
    // The sequences we want to produce hot keys from are:
    //
    // Alt + 9??  on the numeric keypad
    //
    // To detect hotkeys we keep a record of the last four keypresses and
    // when we detect an Alt up we check if they form a valid sequence.
    //
    // The keystrokes which form part of the hotkey are sent to the remote
    // system so if they have some meaning on a remote system then that
    // system must decide whether to buffer them to determine if they are
    // part of a hotkey or play them back anyway - on Windows we play them
    // back anyway as they are a legitimate key sequence when controlling a
    // Windows app - the number typed on the numeric keypad has a % 256
    // applied to it.
    //
    // This means that for each incoming event we may want to generate 0 or
    // more outgoing events.  To do this we have a structure which looks
    // roughly like this:
    //
    //  IF m_m_imfInControlNewEvent
    //      calculate an array of events which we want to return
    //      set m_m_imfInControlNewEvent to FALSE
    //      set number of events returned to 0
    //  ENDIF
    //
    //  IF !m_m_imfInControlNewEvent
    //      IF this is the last event to return
    //          set m_m_imfInControlNewEvent to TRUE
    //      ENDIF
    //      return current event
    //  ENDIF
    //
    //

    if (m_imfInControlNewEvent)
    {
        //
        // This is the first time we have seen this event so accumulate
        // our list of events to generate.
        //

        //
        // Do tracing
        //
        if (pIMEventIn->type == IM_TYPE_ASCII)
        {
            TRACE_OUT(( "IN  ASCII code 0x%04X, flags 0x%04X",
                pIMEventIn->data.keyboard.keyCode, pIMEventIn->data.keyboard.flags));
        }
        else if (pIMEventIn->type == IM_TYPE_VK1)
        {
            TRACE_OUT(( "IN  VKEY  code %04X, flags %04X",
                pIMEventIn->data.keyboard.keyCode, pIMEventIn->data.keyboard.flags));
        }
        else if ((pIMEventIn->type == IM_TYPE_3BUTTON) &&
                 !(pIMEventIn->data.mouse.flags & IM_FLAG_MOUSE_MOVE))
        {
            TRACE_OUT(( "IN  3BTTN flags %04X (%d,%d)",
                pIMEventIn->data.mouse.flags, pIMEventIn->data.mouse.x,
                pIMEventIn->data.mouse.y));
        }
        else if (pIMEventIn->type == IM_TYPE_3BUTTON)
        {
            TRACE_OUT(( "IN  3BTTN flags %04X (%d,%d)",
                pIMEventIn->data.mouse.flags, pIMEventIn->data.mouse.x,
                pIMEventIn->data.mouse.y));
        }
        else if (pIMEventIn->type == IM_TYPE_VK_ASCII)
        {
            TRACE_OUT(("IN VK_ASC code %04X, flags %04X",
                pIMEventIn->data.keyboard.keyCode, pIMEventIn->data.keyboard.flags));
        }
        else
        {
            ERROR_OUT(("Invalid IM type %d", pIMEventIn->type));
        }

        //
        // Start from the beginning of our returned events array.
        //
        m_imInControlNumEventsPending = 0;
        m_imInControlNumEventsReturned = 0;

        //
        // First get our flags for the modifiers and locks we think we have
        // sent to the remote side up to date allowing for this event.
        //
        if (pIMEventIn->type == IM_TYPE_VK1)
        {
            switch (pIMEventIn->data.keyboard.keyCode)
            {
                case VK_CONTROL:
                    if (IS_IM_KEY_RELEASE(pIMEventIn->data.keyboard.flags))
                    {
                        m_imfInControlCtrlDown = FALSE;
                    }
                    else
                    {
                        m_imfInControlCtrlDown = TRUE;
                    }
                    break;

                case VK_SHIFT:
                    if (IS_IM_KEY_RELEASE(pIMEventIn->data.keyboard.flags))
                    {
                        m_imfInControlShiftDown = FALSE;
                    }
                    else
                    {
                        m_imfInControlShiftDown = TRUE;
                    }
                    break;

                case VK_MENU:
                    if (IS_IM_KEY_RELEASE(pIMEventIn->data.keyboard.flags))
                    {
                        m_imfInControlMenuDown = FALSE;
                    }
                    else
                    {
                        m_imfInControlMenuDown = TRUE;
                    }
                    break;

                case VK_CAPITAL:
                    if (IS_IM_KEY_PRESS(pIMEventIn->data.keyboard.flags))
                    {
                        m_imfInControlCapsLock = !m_imfInControlCapsLock;
                    }
                    break;

                case VK_NUMLOCK:
                    if (IS_IM_KEY_PRESS(pIMEventIn->data.keyboard.flags))
                    {
                        m_imfInControlNumLock = !m_imfInControlNumLock;
                    }
                    break;

                case VK_SCROLL:
                    if (IS_IM_KEY_PRESS(pIMEventIn->data.keyboard.flags))
                    {
                        m_imfInControlScrollLock = !m_imfInControlScrollLock;
                    }
                    break;

                default:
                    break;
            }
        }

        //
        // Now check the current state versus our remembered state and
        // prepare to insert events if necessary.  Do this for any events
        // (ie including mouse events) as mouse clicks can have different
        // effects depending on the current modifer state.
        //

        //
        // First the modifiers.  IMGetHighLevelKeyState will return us the
        // keyboard state including the event we are currently processing
        // because it is adjusted before the keyboard hook.  The top most
        // bit is set of the key is down otherwise it is reset.
        //
        if (IMGetHighLevelKeyState(VK_CONTROL) & 0x80)
        {
            if (!m_imfInControlCtrlDown)
            {
                //
                // The key is down locally but we last told the remote
                // machine it was up.
                //
                m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                          IEM_EVENT_CTRL_DOWN;
                m_imfInControlCtrlDown = TRUE;
            }
        }
        else
        {
            if (m_imfInControlCtrlDown)
            {
                //
                // The key is up locally but we last told the remote
                // machine it was down.
                //
                m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                            IEM_EVENT_CTRL_UP;
                m_imfInControlCtrlDown = FALSE;
            }
        }

        //
        // Do the same for shift and menu (alt).
        //
        if (IMGetHighLevelKeyState(VK_SHIFT) & 0x80)
        {
            if (!m_imfInControlShiftDown)
            {
                m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                         IEM_EVENT_SHIFT_DOWN;
                m_imfInControlShiftDown = TRUE;
            }
        }
        else
        {
            if (m_imfInControlShiftDown)
            {
                m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                           IEM_EVENT_SHIFT_UP;
                m_imfInControlShiftDown = FALSE;
            }
        }

        if (IMGetHighLevelKeyState(VK_MENU) & 0x80)
        {
            if (!m_imfInControlMenuDown)
            {
                m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                          IEM_EVENT_MENU_DOWN;
                m_imfInControlMenuDown = TRUE;
            }
        }
        else
        {
            if (m_imfInControlMenuDown)
            {
                m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                            IEM_EVENT_MENU_UP;
                m_imfInControlMenuDown = FALSE;
            }
        }

        //
        // Now handle the toggles.  The least significant bit is set when
        // the toggle is on, reset otherwise.
        //
        if ((IMGetHighLevelKeyState(VK_CAPITAL) & IM_KEY_STATE_FLAG_TOGGLE) ?
             !m_imfInControlCapsLock : m_imfInControlCapsLock)
        {
            //
            // The current caps lock state and what we've sent to the
            // remote system are out of synch - fix it.
            //
            m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                     IEM_EVENT_CAPS_LOCK_DOWN;
            m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                       IEM_EVENT_CAPS_LOCK_UP;
            m_imfInControlCapsLock = !m_imfInControlCapsLock;
        }

        //
        // Do the same for Num lock and Scroll lock.
        //
        if ((IMGetHighLevelKeyState(VK_NUMLOCK) & 0x01) ?
            !m_imfInControlNumLock : m_imfInControlNumLock)
        {
            m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                      IEM_EVENT_NUM_LOCK_DOWN;
            m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                        IEM_EVENT_NUM_LOCK_UP;
            m_imfInControlNumLock = !m_imfInControlNumLock;
        }

        if ((IMGetHighLevelKeyState(VK_SCROLL) & 0x01) ?
            !m_imfInControlScrollLock : m_imfInControlScrollLock)
        {
            m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                   IEM_EVENT_SCROLL_LOCK_DOWN;
            m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                     IEM_EVENT_SCROLL_LOCK_UP;
            m_imfInControlScrollLock = !m_imfInControlScrollLock;
        }

        //
        // Now we will do the appropriate processing for each type of
        // packet we expect.  We only expect to receive
        //
        //  IM_TYPE_VK1
        //  IM_TYPE_ASCII
        //  IM_TYPE_3BUTTON
        //
        //

        if (pIMEventIn->type == IM_TYPE_VK1)
        {
            //
            // Now process a VK packet generated from the real keyboard.
            // Check for Escape, Tab and Menu and decide whether to forward
            // them or consume them first.
            //

            if (pIMEventIn->data.keyboard.keyCode == VK_ESCAPE)
            {
                //
                // This is the escape key - check the current shift status
                // to see whether we should flag this as consumed locally.
                //
                if (IMGetHighLevelKeyState(VK_MENU) & 0x80)
                {
                    m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                           IEM_EVENT_CONSUMED;

                    //
                    // Also remember to consume the next Menu Up keystroke.
                    //
                    m_imfInControlConsumeMenuUp = TRUE;

                    if (!IS_IM_KEY_RELEASE(pIMEventIn->data.keyboard.flags))
                    {
                        //
                        // If this is an escape press then remember that we
                        // should consume the corresponding up stroke
                        // regardless of shift state.
                        //
                        m_imfInControlConsumeEscapeUp = TRUE;
                    }
                }
                else if (m_imfInControlConsumeEscapeUp &&
                         IS_IM_KEY_RELEASE(pIMEventIn->data.keyboard.flags))
                {
                    //
                    // This is the up stroke corresponding to a down
                    // stroke we consumed so consume it too.
                    //
                    m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                           IEM_EVENT_CONSUMED;
                    m_imfInControlConsumeEscapeUp = FALSE;
                }
                else
                {
                    //
                    // This Escape is not one of our special cases so
                    // forward it unchanged.
                    //
                    m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                            IEM_EVENT_FORWARD;
                }
            }
            else if (pIMEventIn->data.keyboard.keyCode == VK_TAB)
            {
                //
                // This is the Tab key - check for current shift status to
                // see whether we should flag this as consumed locally.
                //
                if (IMGetHighLevelKeyState(VK_MENU) & 0x80)
                {
                    m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                           IEM_EVENT_CONSUMED;

                    //
                    // Also remember to consume the next Menu Up keystroke.
                    //
                    m_imfInControlConsumeMenuUp = TRUE;
                }
                else
                {
                    //
                    // This Tab is not our special case so forward it
                    // unchanged.
                    //
                    m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                            IEM_EVENT_FORWARD;
                }
            }
            else if ((pIMEventIn->data.keyboard.keyCode == VK_MENU) &&
                         IS_IM_KEY_RELEASE(pIMEventIn->data.keyboard.flags))
            {
                //
                // This is a menu up - check for one we should consume or
                // for hotkeys.
                //
                if (m_imfInControlConsumeMenuUp)
                {
                    //
                    // This is a menu up we want to consume - do so.
                    //
                    m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                           IEM_EVENT_CONSUMED;
                    m_imfInControlConsumeMenuUp = FALSE;
                }
                else
                {
                    //
                    // This is a VK_MENU release
                    // hot key sequence in our array of last four key
                    // presses.  Start looking at the next entry (the array
                    // is circular).  A valid sequence is
                    //
                    //  VK_MENU
                    //  numeric pad 9
                    //  numeric pad number
                    //  numeric pad number
                    //
                    //
                    fHotKeyFound = FALSE;
                    hotKeyArrayIndex = m_imInControlNextHotKeyEntry;
                    if (m_aimInControlHotKeyArray[hotKeyArrayIndex] == VK_MENU)
                    {
                        hotKeyArrayIndex = (hotKeyArrayIndex+1)%4;
                        if (m_aimInControlHotKeyArray[hotKeyArrayIndex] == 9)
                        {
                            hotKeyArrayIndex = (hotKeyArrayIndex+1)%4;
                            if (m_aimInControlHotKeyArray[hotKeyArrayIndex] <= 9)
                            {
                                hotKeyValue =
                                         10*m_aimInControlHotKeyArray[hotKeyArrayIndex];
                                hotKeyArrayIndex = (hotKeyArrayIndex+1)%4;
                                if (m_aimInControlHotKeyArray[hotKeyArrayIndex] <= 9)
                                {
                                    //
                                    // This is a valid hot key - add a
                                    // consumed VK_MENU and then a hot key
                                    // packet.
                                    //
                                    hotKeyValue +=
                                             m_aimInControlHotKeyArray[hotKeyArrayIndex];
                                    m_aimInControlEventsToReturn[
                                                    m_imInControlNumEventsPending++] =
                                                           IEM_EVENT_CONSUMED;
                                    m_aimInControlEventsToReturn[
                                                    m_imInControlNumEventsPending++] =
                                          IEM_EVENT_HOTKEY_BASE + hotKeyValue;
                                    TRACE_OUT(("Hotkey found %d", hotKeyValue));
                                    fHotKeyFound = TRUE;
                                }
                            }
                        }
                    }

                    if (!fHotKeyFound)
                    {
                        //
                        // This was not a hotkey so send the menu up as
                        // normal.
                        //
                        m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                            IEM_EVENT_FORWARD;
                    }
                }
            }
            else if (IS_IM_KEY_PRESS(pIMEventIn->data.keyboard.flags))
            {
                //
                // Keep a record of the last four key presses (not
                // including auto
                // VK_MENU up event to determine if we have found a hotkey
                // sequence.
                //

                //
                // This is a key press and it is not a repeat.  Throw out
                // extended keys here so that we're not confused by the
                // grey cursor keys.
                //
                if (pIMEventIn->data.keyboard.flags &
                                                    IM_FLAG_KEYBOARD_EXTENDED)
                {
                    //
                    // An extended key breaks the sequence.
                    //
                    m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 0xFF;
                }
                else
                {
                    //
                    // Add an entry to our array for this key.  We add
                    // VK_MENUs and add and translate numeric keypad keys
                    // anything else breaks the sequencs.
                    //
                    switch (pIMEventIn->data.keyboard.keyCode)
                    {
                        case VK_MENU:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = VK_MENU;
                            break;

                        case VK_NUMPAD0:
                        case VK_INSERT:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 0;
                            break;

                        case VK_NUMPAD1:
                        case VK_END:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 1;
                            break;

                        case VK_NUMPAD2:
                        case VK_DOWN:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 2;
                            break;

                        case VK_NUMPAD3:
                        case VK_NEXT:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 3;
                            break;

                        case VK_NUMPAD4:
                        case VK_LEFT:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 4;
                            break;

                        case VK_NUMPAD5:
                        case VK_CLEAR:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 5;
                            break;

                        case VK_NUMPAD6:
                        case VK_RIGHT:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 6;
                            break;

                        case VK_NUMPAD7:
                        case VK_HOME:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 7;
                            break;

                        case VK_NUMPAD8:
                        case VK_UP:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 8;
                            break;

                        case VK_NUMPAD9:
                        case VK_PRIOR:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 9;
                            break;

                        default:
                            //
                            // Any unrecognised key breaks a sequence.
                            //
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 0xFF;
                            break;
                    }
                }

                //
                // Wrap the hot key array at 4 entries.
                //
                m_imInControlNextHotKeyEntry = (m_imInControlNextHotKeyEntry+1)%4;

                //
                // Forward the event.
                //
                m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                            IEM_EVENT_FORWARD;
            }
            else
            {
                //
                // Just forward the event as its not any of our special
                // cases.
                //
                m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                            IEM_EVENT_FORWARD;
            }
        }
        else if (pIMEventIn->type == IM_TYPE_VK_ASCII)
        {
            m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                        IEM_EVENT_FORWARD;
        }
        else if (pIMEventIn->type == IM_TYPE_ASCII)
        {
            //
            // Any IM_TYPE_ASCII breaks the hot key sequence.
            //
            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 0xFF;
            m_imInControlNextHotKeyEntry = (m_imInControlNextHotKeyEntry+1)%4;

            //
            // Then just forward the thing without doing anything clever.
            //
            m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                            IEM_EVENT_FORWARD;
        }
        else if (pIMEventIn->type == IM_TYPE_3BUTTON)
        {
            //
            // To be nice and clean we would ideally have a completely new
            // event for the wheeled Microsoft mouse.  However to maintain
            // backwards compatibility, we send the event out in such a way
            // that old incompatible systems interpret it as a NULL mouse
            // move.
            //
            if (pIMEventIn->data.mouse.flags & IM_FLAG_MOUSE_WHEEL)
            {
                //
                // This is a wheel rotatation.
                //
                // We massage this event so that new systems can see it for
                // what it truly is - a wheel rotation, but old systems
                // (which check the MOUSE_MOVE flag first, and ignore all
                // other flags if set) see it as a mouse move.
                //
                // We did not set the MOUSE_MOVE flag when we first
                // generated this event, since we did not want to trigger
                // any of the sending side mouse move processing which
                // would otherwise have been invoked.
                //
                pIMEventIn->data.mouse.flags |= IM_FLAG_MOUSE_MOVE;
            }

            //
            // Forward the event
            //
            m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                            IEM_EVENT_FORWARD;
        }

        //
        // Now we are going into a loop to return the m_iemLocalEvents we
        // have queued up.  We will return the first one below and then be
        // called again until we have returned them all and return FALSE.
        //
        m_imfInControlNewEvent = FALSE;
        m_imInControlNumEventsReturned = 0;
    }

    if (!m_imfInControlNewEvent)
    {
        if (m_imInControlNumEventsReturned == m_imInControlNumEventsPending)
        {
            //
            // There are no more m_aiemLocalEvents to return.
            //
            TRACE_OUT(( "NO MORE EVENTS"));
            m_imfInControlNewEvent = TRUE;
            DC_QUIT;
        }
        else
        {
            //
            // Return the next event.
            //

            if (m_aimInControlEventsToReturn[m_imInControlNumEventsReturned] >=
                                                        IEM_EVENT_HOTKEY_BASE)
            {
                TRACE_OUT(( "HOTKEY  "));
                //
                // Return a hotkey event.
                //
                pIMEventOut->type = IM_TYPE_VK2;
                pIMEventOut->data.keyboard.keyCode = (TSHR_UINT16)
                     (m_aimInControlEventsToReturn[m_imInControlNumEventsReturned] -
                                                       IEM_EVENT_HOTKEY_BASE);
                pIMEventOut->data.keyboard.flags = 0;
            }
            else
            {
                //
                // Return a non-hotkey event.
                //
                switch (m_aimInControlEventsToReturn[m_imInControlNumEventsReturned])
                {
                    case IEM_EVENT_CTRL_DOWN:
                        TRACE_OUT(( "CTRL DWN"));
                        //
                        // Set up a Ctrl down event.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_CONTROL;
                        pIMEventOut->data.keyboard.flags = 0;
                        break;

                    case IEM_EVENT_CTRL_UP:
                        TRACE_OUT(( "CTRL UP "));
                        //
                        // Set up a Ctrl up event with the quiet flag set
                        // - this means it should have no effect (other
                        // than to release the control key).
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_CONTROL;
                        pIMEventOut->data.keyboard.flags =
                                                       IM_FLAG_KEYBOARD_DOWN |
                                                    IM_FLAG_KEYBOARD_RELEASE |
                                                       IM_FLAG_KEYBOARD_QUIET;
                        break;

                    case IEM_EVENT_SHIFT_DOWN:
                        TRACE_OUT(( "SHFT DWN"));
                        //
                        // Set up a Shift down event.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_SHIFT;
                        pIMEventOut->data.keyboard.flags = 0;
                        break;

                    case IEM_EVENT_SHIFT_UP:
                        TRACE_OUT(( "SHFT UP "));
                        //
                        // Set up a Shift up event with the quiet flag set
                        // - this means it should have no effect (other
                        // than to release the shift key).
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_SHIFT;
                        pIMEventOut->data.keyboard.flags =
                                                       IM_FLAG_KEYBOARD_DOWN |
                                                    IM_FLAG_KEYBOARD_RELEASE |
                                                       IM_FLAG_KEYBOARD_QUIET;
                        break;

                    case IEM_EVENT_MENU_DOWN:
                        TRACE_OUT(( "MENU DWN"));
                        //
                        // Set up a Menu down event.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_MENU;
                        break;

                    case IEM_EVENT_MENU_UP:
                        TRACE_OUT(( "MENU UP "));
                        //
                        // Set up a Ctrl down event with the quiet flag set
                        // - ths is means it should have no effect (other
                        // than to release the menu key).
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_MENU;
                        pIMEventOut->data.keyboard.flags =
                                                       IM_FLAG_KEYBOARD_DOWN |
                                                    IM_FLAG_KEYBOARD_RELEASE |
                                                       IM_FLAG_KEYBOARD_QUIET;
                        break;

                    case IEM_EVENT_CAPS_LOCK_DOWN:
                        TRACE_OUT(( "CAPS DWN"));
                        //
                        // Send a caps lock down.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_CAPITAL;
                        pIMEventOut->data.keyboard.flags = 0;
                        break;

                    case IEM_EVENT_CAPS_LOCK_UP:
                        TRACE_OUT(( "CAPS UP "));
                        //
                        // Send a caps lock up.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_CAPITAL;
                        pIMEventOut->data.keyboard.flags =
                                                       IM_FLAG_KEYBOARD_DOWN |
                                                     IM_FLAG_KEYBOARD_RELEASE;
                        break;

                    case IEM_EVENT_NUM_LOCK_DOWN:
                        TRACE_OUT(( "NUM DOWN"));
                        //
                        // Send a num lock down - num lock is an extended
                        // key.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_NUMLOCK;
                        pIMEventOut->data.keyboard.flags =
                                                    IM_FLAG_KEYBOARD_EXTENDED;
                        break;

                    case IEM_EVENT_NUM_LOCK_UP:
                        //
                        // Send a num lock up - num lock is an extended
                        // key.
                        //
                        TRACE_OUT(( "NUM UP  "));
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_NUMLOCK;
                        pIMEventOut->data.keyboard.flags =
                                                       IM_FLAG_KEYBOARD_DOWN |
                                                    IM_FLAG_KEYBOARD_RELEASE |
                                                    IM_FLAG_KEYBOARD_EXTENDED;
                        break;

                    case IEM_EVENT_SCROLL_LOCK_DOWN:
                        //
                        // Send a scroll lock down.
                        //
                        TRACE_OUT(( "SCROLDWN"));
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_SCROLL;
                        pIMEventOut->data.keyboard.flags = 0;
                        break;

                    case IEM_EVENT_SCROLL_LOCK_UP:
                        //
                        // Send a scroll lock up.
                        //
                        TRACE_OUT(( "SCROLLUP"));
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_SCROLL;
                        pIMEventOut->data.keyboard.flags =
                                                       IM_FLAG_KEYBOARD_DOWN |
                                                     IM_FLAG_KEYBOARD_RELEASE;
                        break;

                    case IEM_EVENT_FORWARD:
                        //
                        // Just copy the packet.
                        //
                        TRACE_OUT(( "FORWARD"));
                        *pIMEventOut = *pIMEventIn;
                        break;

                    case IEM_EVENT_CONSUMED:
                        //
                        // Copy the packet and set the flag.
                        //
                        TRACE_OUT(( "CONSUMED"));
                        *pIMEventOut = *pIMEventIn;
                        pIMEventOut->data.keyboard.flags |=
                                                       IM_FLAG_KEYBOARD_QUIET;
                        break;

                    default:
                        ERROR_OUT(( "Invalid code path"));
                        break;
                }
            }
            m_imInControlNumEventsReturned++;

            //
            // Do tracing
            //
            if (pIMEventOut->type == IM_TYPE_ASCII)
            {
                TRACE_OUT(( "OUT ASCII code %04X, flags %04X",
                    pIMEventOut->data.keyboard.keyCode, pIMEventOut->data.keyboard.flags));
            }
            else if (pIMEventOut->type == IM_TYPE_VK1)
            {
                TRACE_OUT(( "OUT VK1   code %04X, flags %04X",
                    pIMEventOut->data.keyboard.keyCode, pIMEventOut->data.keyboard.flags));
            }
            else if (pIMEventOut->type == IM_TYPE_VK2)
            {
                TRACE_OUT(( "OUT VK2   code - %04X, flags - %04X",
                    pIMEventOut->data.keyboard.keyCode, pIMEventOut->data.keyboard.flags));
            }
            else if ((pIMEventOut->type == IM_TYPE_3BUTTON) &&
                       !(pIMEventOut->data.mouse.flags & IM_FLAG_MOUSE_MOVE))
            {
                TRACE_OUT(( "OUT 3BTTN flags - %04X (%d,%d)",
                    pIMEventOut->data.mouse.flags, pIMEventOut->data.mouse.x,
                    pIMEventOut->data.mouse.y));
            }
            else if (pIMEventOut->type == IM_TYPE_3BUTTON)
            {
                TRACE_OUT(( "OUT 3BTTN flags - %04X (%d,%d)",
                    pIMEventOut->data.mouse.flags, pIMEventOut->data.mouse.x,
                    pIMEventOut->data.mouse.y));
            }
            else
            {
                ERROR_OUT(("Invalid IM type %d", pIMEventOut->type));
            }

            rc = TRUE;
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::IMTranslateOutgoing);
    return(rc);
}



//
// IMTranslateIncoming()
//
// DESCRIPTION:
//
// Converts remotely generated sequences of IMEVENTs into sequences of
// IMEVENTs for replay.  Does a 1 to (0-n) translation.  Handles faking
// keys using ALT and keypad.
//
// When an IMEVENT is received and is ready to be replayed this function
// is called with a pointer to that packet in pIMEventIn.
// IMTranslateIncoming can then return TRUE and fill in the packet at
// pIMEventOut or return FALSE.  If IMTranslateIncoming returns TRUE the
// IM will call it again with the same packet.  The IMEVENTs returned are
// played back on the local machine using the journal playback hook by the
// IM.
//
// PARAMETERS:
//
// pIMEventIn - pointer to IMEVENT
//
// pIMEventOut - pointer to IMEVENT
//
// personID - the ID of the person this event was received from
//
// RETURNS:
//
// TRUE - packet returned (call function again)
//
// FALSE - no packet returned (don't call function again)
//
//
//
BOOL ASShare::IMTranslateIncoming
(
    PIMEVENT    pIMEventIn,
    PIMEVENT    pIMEventOut
)
{
    BYTE        curKbState;
    BYTE        rcVkKeyScanKbState;
    UINT        keyCode;
    TSHR_UINT16 rcVkKeyScan;
    BOOL        bTranslateOEM;
    char        chAnsi;
    char        chOEM;
    char        chNewAnsi;
    UINT        position;
    UINT        digit;
    UINT        i;

    DebugEntry(ASShare::IMTranslateIncoming);

    //
    // In this function we will receive several types of events
    //
    //  IM_TYPE_VK1 - processed
    //  IM_TYPE_ASCII - processed
    //  IM_TYPE_VK2 - ignored (discarded)
    //  IM_TYPE_3BUTTON - processed
    //
    // For IM_TYPE_VK1:
    //
    // If it has the consumed locally flag set then try and play it back
    // without anything happening.  This means that for an Alt up we make
    // sure that there have been some keyboard events between the Alt down
    // and this event.
    //
    // For IM_TYPE_ASCII:
    //
    // Try to convert this to a VK to playback.  If we are succesful then
    // playback one or more key strokes to get into the correct shift state
    // then play back the VK and then undo any shift states.  If we can't
    // convert to a VK then fake a sequence of Alt + numeric keypad keys to
    // get the key in.
    //
    // For IM_TYPE_VK2:
    //
    // Discard unceremoniously.
    //
    // For IM_TYPE_3BUTTON:
    //
    // Play back directly.
    //
    //
    keyCode = pIMEventIn->data.keyboard.keyCode;

    if (m_imfControlledNewEvent)
    {
        //
        // The first time we have seen a new event - accumulate an array
        // of events we want to return.
        //

        //
        // Start from the beginning of our returned events array.
        //
        m_imControlledNumEventsPending = 0;
        m_imControlledNumEventsReturned = 0;

        if (pIMEventIn->type == IM_TYPE_VK1)
        {
            //
            // Handle VK1s first.  Special cases are VK_MENU, VK_TAB and
            // VK_ESC.  We recognise VK_MENU down key strokes and remember
            // when they happened so that we can possibly fiddle with
            // VK_MENU up keystrokes later to go into menu mode.  We check
            // on VK_TAB for the IM_FLAG_KEYBOARD_QUIET flag and if it is
            // set then we don't replay anything
            // First translate the virtual key code from the DC-Share
            // protocol code to the OS virtual key code
            //
            if (keyCode == VK_MENU)
            {
                if (!IS_IM_KEY_RELEASE(pIMEventIn->data.keyboard.flags))
                {
                    //
                    // This is a VK_MENU press - return it without
                    // interfering.
                    //
                    m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                             IEM_EVENT_REPLAY;
                }
                else
                {
                    //
                    // Handle VK_MENU up events
                    //
                    // If the menu up has the `quiet' flag set then
                    // insert a couple of shift key events to prevent it
                    // having any effect.  There are two cases we're
                    // covering here where an Alt-UP can have some effect.
                    //
                    // 1. Alt-Down, Alt-Up causes the system menu button to
                    // be highlighted.
                    //
                    // 2. Entering characters from the numeric keypad takes
                    // effect on the Alt-Up.
                    //
                    // Both of these effects can be negated by adding the
                    // shift key strokes.
                    //
                    if (pIMEventIn->data.keyboard.flags &
                                                       IM_FLAG_KEYBOARD_QUIET)
                    {
                        //
                        // We need to `silence' this key - to do this we
                        // will insert to shift key strokes first
                        //
                        if (m_aimControlledControllerKeyStates[VK_SHIFT] & 0x80)
                        {
                            //
                            // Shift is currently down - insert an up then
                            // a down
                            //
                            m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                           IEM_EVENT_SHIFT_UP;
                            m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                         IEM_EVENT_SHIFT_DOWN;

                        }
                        else
                        {
                            //
                            // Shift is currently up - insert a down then
                            // an up
                            //
                            m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                         IEM_EVENT_SHIFT_DOWN;
                            m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                           IEM_EVENT_SHIFT_UP;
                        }
                    }

                    //
                    // Replay the menu up key stroke.
                    //
                    m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                             IEM_EVENT_REPLAY;

                }
            }
            else if ((pIMEventIn->data.keyboard.flags &
                                                   IM_FLAG_KEYBOARD_QUIET) &&
                     ((keyCode == VK_TAB) ||
                      (keyCode == VK_ESCAPE)))
            {
                //
                // Just get out of here - we don't want to play this back
                //
                return(FALSE);
            }
            else
            {
                //
                // All other VKs just get replayed
                //
                m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                             IEM_EVENT_REPLAY;
            }
        }
        else if (pIMEventIn->type == IM_TYPE_ASCII)
        {
            //
            // For ASCII packets we need to find out how we can replay them
            // on our local keyboard.  If we can replay them directly or
            // with shift or ctrl (but not with ALT), then we will do so,
            // otherwise we will simulate Alt + numeric keypad to replay
            // them.  If we have to generate fake modifier key strokes
            // ourselves then we will replay the whole key stroke on the
            // incoming key down.  If we don't need to generate fake key
            // strokes then we will play the down and up keystrokes as they
            // come in.
            //
            // We do not allow VK combinations involving ALT as this messes
            // up remote international keyboard support.  For example, if
            // the remote keyboard is UK and we are (say) Spanish,
            // VKKeyScan says we can do the "UK pound" character as
            // Ctrl+Alt+3.  While this works in Windows, and for DOS Boxes
            // on standard keyboards, DOS Boxes with enhanced keyboards
            // require ALTGR+3 (nb Windows seems to treat ALTGR as Ctrl+Alt
            // anyway - at least for VKs and Async state).  There is no VK
            // for ALTGR, so do an ALT-nnn sequence for these cases.
            //
            rcVkKeyScan = VkKeyScan((char)keyCode);
            TRACE_OUT(( "co_vk_key_scan of X%02x returns rcVkKeyScan X%02x",
                            keyCode, rcVkKeyScan));
            if ((rcVkKeyScan != 0xffff) && !(rcVkKeyScan & 0x0400))
            {
                //
                // This can be replayed using a combination of modifiers on
                // this keyboard.
                //
                rcVkKeyScanKbState = HIBYTE(rcVkKeyScan);

                //
                // The high byte of rcVkKeyScan contains three bit flags
                // which signify which modifiers ar required to generate
                // this character.  They are
                //
                //  bit 0 - Shift
                //  bit 1 - Ctrl
                //  bit 2 - Alt (Menu)
                //
                // We will construct an equivalent set of flags which
                // describes the current state of these modifiers.
                //
                curKbState = 0;

                if (m_aimControlledControllerKeyStates[VK_SHIFT] & 0x80)
                {
                    curKbState |= IEM_SHIFT_DOWN;
                }

                if (m_aimControlledControllerKeyStates[VK_CONTROL] & 0x80)
                {
                    curKbState |= IEM_CTRL_DOWN;
                }

                if (m_aimControlledControllerKeyStates[VK_MENU] & 0x80)
                {
                    curKbState |= IEM_MENU_DOWN;

                    //
                    // If the Alt key is down currently in this person's
                    // context then (in general
                    // it.  This means accelerators which need to be
                    // shifted will work as we won't release the Alt key in
                    // order to generate the key strokes.
                    //
                    // However, if the ALT key is being held down in
                    // combination with SHIFT and CTRL to generate a
                    // character (e.g.  CTRL-ALT-SHIFT-4 on a US keyboard
                    // to generate a  character) then we will allow the
                    // ALT key up before we play back the true character.
                    //
                    if ((curKbState & (IEM_SHIFT_DOWN | IEM_CTRL_DOWN)) !=
                                             (IEM_SHIFT_DOWN | IEM_CTRL_DOWN))
                    {
                        rcVkKeyScanKbState |= IEM_MENU_DOWN;
                    }
                }

                if ((m_aimControlledControllerKeyStates[VK_CAPITAL] & 0x01) &&
                    ((LOBYTE(rcVkKeyScan) >= 'A') &&
                    ((LOBYTE(rcVkKeyScan) <= 'Z'))))
                {
                    //
                    // If caps-lock is enabled then the effect of a shift
                    // down on VKs A thru Z is reversed.  This logic ( 'A'
                    // <= x <= 'Z' is encoded in the keyboard.drv so it
                    // should be pretty safe).
                    //
                    curKbState ^= IEM_SHIFT_DOWN;
                }

                if (curKbState == rcVkKeyScanKbState)
                {
                    //
                    // We are already in the correct shift state so just
                    // replay the VK.
                    //
                    m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                          IEM_EVENT_REPLAY_VK;
                    m_imControlledVKToReplay = LOBYTE(rcVkKeyScan);
                }
                else
                {
                    //
                    // We need to generate some fake modifiers - only do
                    // this on a key press.
                    //
                    if (pIMEventIn->data.keyboard.flags &
                                                     IM_FLAG_KEYBOARD_RELEASE)
                    {
                        return(FALSE);
                    }

                    //
                    // Insert modifiers to get into the correct state.
                    //
                    m_imControlledNumEventsPending += IMInsertModifierKeystrokes(
                                curKbState,
                                rcVkKeyScanKbState,
                                &(m_aimControlledEventsToReturn[m_imControlledNumEventsPending]));

                    //
                    // Now insert the VK itself - a down and up.
                    //
                    m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                     IEM_EVENT_REPLAY_VK_DOWN;
                    m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                       IEM_EVENT_REPLAY_VK_UP;

                    //
                    // Remeber the VK we want to replay when we come across
                    // IEM_EVENT_REPLAY_VK_DOWN/UP.
                    //
                    m_imControlledVKToReplay = LOBYTE(rcVkKeyScan);

                    //
                    // Now insert the modifiers to get back to the current
                    // state.
                    //
                    m_imControlledNumEventsPending += IMInsertModifierKeystrokes(
                                rcVkKeyScanKbState,
                                curKbState,
                                &(m_aimControlledEventsToReturn[m_imControlledNumEventsPending]));

                    //
                    // Now we have a complete set of events ready to replay
                    // so go for it.
                    //
                }
            }
            else
            {
                //
                // We can't replay directly, so will have to simulate an
                // Alt+keypad sequence.
                //
                TRACE_OUT(( "FAKE AN ALT-nnn SEQUENCE IF WINDOWS"));
                //
                // We only do this sort of stuff on a key-press.
                //
                if (pIMEventIn->data.keyboard.flags &
                                                     IM_FLAG_KEYBOARD_RELEASE)
                {
                    return(FALSE);
                }

                //
                // The following code relies on keyCode being less than 999
                // and we should receive a keycode > 255 so get out now if
                // we have.
                //
                if (keyCode > 255)
                {
                    return(FALSE);
                }

                //
                // First get modifiers into correct state - create bit
                // flags for current modifier state.
                //
                curKbState = 0;

                //
                // For windows we have a character to input that cannot
                // be replayed by pressing a key...replay by injecting
                // alt-nnn.
                //
                if (m_aimControlledControllerKeyStates[VK_SHIFT] & 0x80)
                {
                    curKbState |= IEM_SHIFT_DOWN;
                }

                if (m_aimControlledControllerKeyStates[VK_CONTROL] & 0x80)
                {
                    curKbState |= IEM_CTRL_DOWN;
                }

                if (m_aimControlledControllerKeyStates[VK_MENU] & 0x80)
                {
                    curKbState |= IEM_MENU_DOWN;
                }

                //
                // If necessary, reset all modifiers.
                //
                if (curKbState)
                {
                    m_imControlledNumEventsPending += IMInsertModifierKeystrokes(
                                curKbState,
                                0,
                                &(m_aimControlledEventsToReturn[m_imControlledNumEventsPending]));
                }

                //
                // Now determine whether we can do the ALT-nnn keypad
                // sequence using an OEM keycode or whether we have to use
                // an ANSI (Windows) keycode.
                //
                // The issue here is that:
                //
                // - hosted Windows applications (or rather Windows itself)
                //   can distinguish between, and handle correctly, ANSI
                //   keycodes and OEM keycodes (where the latter vary
                //   depending on the keyboard type).  For example,
                //   ALT-0163 is the ANSI "UK pound" on all keyboards,
                //   and on US national keyboards ALT-156 is the OEM
                //   keycode for "UK pound".
                //
                // - hosted DOS Boxes only understand OEM keycodes.
                //
                // So (for example), if we have a remote UK keyboard
                // controlling local Windows and DOS Box applications, and
                // we generate ALT-nnn using the OEM keycode (and without a
                // leading zero), both the Windows and DOS Box applications
                // interpret it as "UK pound" (Hoorah!).  In contrast, if
                // we generate ALT-nnn using the ANSI keycode (with a
                // leading zero), the Windows applications still do "UK
                // pound", BUT the DOS Box does an "u acute".
                //
                // As far as we can tell (eg by examining the DDK keyboard
                // driver source for AnsiToOem), there should always be a
                // translation.  However, it is possible that the ANSI to
                // OEM translation is not 1<->1.  We therefore check this
                // by doing a second translation back from OEM to ANSI.  If
                // this does not give us the original character we use the
                // original ANSI code and play it back with a ALT-0nnn
                // sequence.
                //
                chAnsi = (char)pIMEventIn->data.keyboard.keyCode;

                AnsiToOemBuff(&chAnsi, &chOEM, 1);
                OemToAnsiBuff(&chOEM, &chNewAnsi, 1);
                TRACE_OUT(( "Ansi: %02x OEM: %02x NewAnsi: %02x",
                                              (BYTE)chAnsi,
                                              (BYTE)chOEM,
                                              (BYTE)chNewAnsi ));

                bTranslateOEM = (chAnsi == chNewAnsi);

                keyCode = (bTranslateOEM)
                              ? (UINT)(BYTE)chOEM
                              : pIMEventIn->data.keyboard.keyCode;

                //
                // Now insert a VK_MENU down.
                //
                m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                          IEM_EVENT_MENU_DOWN;

                //
                // Now insert the numeric keypad keystrokes.  If we're
                // doing an ANSI ALT
                //
                if (!bTranslateOEM)
                {
                    m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                       IEM_EVENT_KEYPAD0_DOWN;
                    m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                         IEM_EVENT_KEYPAD0_UP;
                }


                //
                // Add keystrokes for hundreds, tens and units, taking care
                // to discard leading (but not trailing) zeros if we're
                // doing an OEM sequence (which would confuse Windows into
                // thinking an OEM ALT-nnn sequence was an ANSI sequence).
                //
                position = 100;
                for (i=0 ; i<3 ; i++)
                {
                    //
                    // Insert the correct digit for this position.
                    //
                    digit = keyCode / position;

                    if (!(digit == 0 && bTranslateOEM))
                    {
                        bTranslateOEM = FALSE;
                        m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                               IEM_EVENT_KEYPAD0_DOWN + digit;
                        m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                 IEM_EVENT_KEYPAD0_UP + digit;
                    }

                    //
                    // Move to next position.
                    //
                    keyCode %= position;
                    position /= 10;
                }

                //
                // Now insert a VK_MENU up.
                //
                m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                            IEM_EVENT_MENU_UP;


                //
                // If necessary, get the modifiers back to the state they
                // were in previously.
                //
                if (curKbState != 0)
                {
                    m_imControlledNumEventsPending += IMInsertModifierKeystrokes(
                                0,
                                curKbState,
                                &(m_aimControlledEventsToReturn[m_imControlledNumEventsPending]));
                }

                //
                // Now we have a buffer full of keystrokes - go for it.
                //
            }
        }
        else if (pIMEventIn->type == IM_TYPE_VK2)
        {
            //
            // Hot keys are thrown away - this is easy.
            //
            return(FALSE);
        }
        else if (pIMEventIn->type == IM_TYPE_3BUTTON)
        {
            //
            // Mouse events are just replayed.
            //
            m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] = IEM_EVENT_REPLAY;
        }
        else
        {
            //
            // Unknown events are thrown away - this is easy.
            //
            return(FALSE);
        }

        //
        // Now we have events to return.
        //
        m_imfControlledNewEvent = FALSE;
        m_imControlledNumEventsReturned = 0;
    }

    if (!m_imfControlledNewEvent)
    {
        if (m_imControlledNumEventsReturned == m_imControlledNumEventsPending)
        {
            //
            // There are no more events to return.
            //
            m_imfControlledNewEvent = TRUE;
            return(FALSE);
        }
        else
        {
            TRACE_OUT(("Event to return: %u",
                m_aimControlledEventsToReturn[m_imControlledNumEventsReturned]));
            if ((m_aimControlledEventsToReturn[m_imControlledNumEventsReturned] >=
                                                    IEM_EVENT_KEYPAD0_DOWN) &&
                (m_aimControlledEventsToReturn[m_imControlledNumEventsReturned] <=
                                                  (IEM_EVENT_KEYPAD0_DOWN+9)))
            {
                //
                // Return a keypad down event.
                //
                pIMEventOut->type = IM_TYPE_VK1;
                pIMEventOut->data.keyboard.keyCode = (TSHR_UINT16)
                  (VK_NUMPAD0 +
                          (m_aimControlledEventsToReturn[m_imControlledNumEventsReturned] -
                                                     IEM_EVENT_KEYPAD0_DOWN));
                pIMEventOut->data.keyboard.flags = IM_FLAG_KEYBOARD_ALT_DOWN;
            }
            else if ((m_aimControlledEventsToReturn[m_imControlledNumEventsReturned] >=
                                                      IEM_EVENT_KEYPAD0_UP) &&
                     (m_aimControlledEventsToReturn[m_imControlledNumEventsReturned] <=
                                                    (IEM_EVENT_KEYPAD0_UP+9)))
            {
                //
                // Return a keypad up event.
                //
                pIMEventOut->type = IM_TYPE_VK1;
                pIMEventOut->data.keyboard.keyCode = (TSHR_UINT16)
                  (VK_NUMPAD0 +
                             (m_aimControlledEventsToReturn[m_imControlledNumEventsReturned] -
                                                       IEM_EVENT_KEYPAD0_UP));
                pIMEventOut->data.keyboard.flags = IM_FLAG_KEYBOARD_DOWN |
                                                   IM_FLAG_KEYBOARD_RELEASE |
                                                   IM_FLAG_KEYBOARD_ALT_DOWN;
            }
            else
            {
                switch (m_aimControlledEventsToReturn[m_imControlledNumEventsReturned])
                {
                    case IEM_EVENT_CTRL_DOWN:
                        //
                        // Set up a Ctrl down event.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode =
                                                           VK_CONTROL;
                        pIMEventOut->data.keyboard.flags = 0;
                        break;

                    case IEM_EVENT_CTRL_UP:
                        //
                        // Set up a Ctrl up event.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode =
                                                           VK_CONTROL;
                        pIMEventOut->data.keyboard.flags =
                             IM_FLAG_KEYBOARD_DOWN | IM_FLAG_KEYBOARD_RELEASE;
                        break;

                    case IEM_EVENT_SHIFT_DOWN:
                        //
                        // Set up a Shift down event.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode =
                                                             VK_SHIFT;
                        pIMEventOut->data.keyboard.flags = 0;
                        break;

                    case IEM_EVENT_SHIFT_UP:
                        //
                        // Set up a Shift up event.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode =
                                                             VK_SHIFT;
                        pIMEventOut->data.keyboard.flags =
                             IM_FLAG_KEYBOARD_DOWN | IM_FLAG_KEYBOARD_RELEASE;
                        break;

                    case IEM_EVENT_MENU_DOWN:
                        //
                        // Set up a Menu down event.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_MENU;
                        pIMEventOut->data.keyboard.flags = 0;
                        break;

                    case IEM_EVENT_MENU_UP:
                        //
                        // Set up a Menu up event.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_MENU;
                        pIMEventOut->data.keyboard.flags =
                            IM_FLAG_KEYBOARD_DOWN | IM_FLAG_KEYBOARD_RELEASE;
                        break;

                    case IEM_EVENT_REPLAY:
                        //
                        // Just copy the packet.
                        //
                        *pIMEventOut = *pIMEventIn;
                        break;

                    case IEM_EVENT_REPLAY_VK:
                        //
                        // Replay the VK from m_imControlledVKToReplay using the
                        // flags on the incoming packet.
                        //
                        *pIMEventOut = *pIMEventIn;
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = (TSHR_UINT16)
                                                             m_imControlledVKToReplay;
                        break;

                    case IEM_EVENT_REPLAY_VK_UP:
                        //
                        // Replay an up key event for the VK in
                        // m_imControlledVKToReplay.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = (TSHR_UINT16)
                                                             m_imControlledVKToReplay;
                        pIMEventOut->data.keyboard.flags =
                             IM_FLAG_KEYBOARD_DOWN | IM_FLAG_KEYBOARD_RELEASE;
                        break;

                    case IEM_EVENT_REPLAY_VK_DOWN:
                        //
                        // Replay a down key event for the VK in
                        // m_imControlledVKToReplay.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = (TSHR_UINT16)
                                                             m_imControlledVKToReplay;
                        pIMEventOut->data.keyboard.flags = 0;
                        break;

                    case IEM_EVENT_NORMAL:
                        //
                        // Play back the event but force it to be normal.
                        //
                        *pIMEventOut = *pIMEventIn;
                        pIMEventOut->data.keyboard.flags &=
                                        (TSHR_UINT16)~IM_FLAG_KEYBOARD_ALT_DOWN;
                        break;

                    case IEM_EVENT_SYSTEM:
                        //
                        // Play back the event but force it to be system.
                        //
                        *pIMEventOut = *pIMEventIn;
                        pIMEventOut->data.keyboard.flags |=
                                                   IM_FLAG_KEYBOARD_ALT_DOWN;
                        break;

                    default:
                        ERROR_OUT(( "Invalid code path"));
                        break;
                }
            }
        }

        m_imControlledNumEventsReturned++;

        //
        // If we're going to playback a NUMLOCK event, make sure we force
        // the keyboard LEDs to be accurate.
        //
        if ((pIMEventOut->type == IM_TYPE_VK1) &&
            (pIMEventOut->data.keyboard.keyCode == VK_NUMLOCK) &&
            IS_IM_KEY_PRESS(pIMEventOut->data.keyboard.flags))
        {
            TRACE_OUT(("Playing back NUMLOCK; add IM_FLAG_KEYBOARD_UPDATESTATE"));
            pIMEventOut->data.keyboard.flags |= IM_FLAG_KEYBOARD_UPDATESTATE;
        }

        return(TRUE);
    }

    DebugExitBOOL(ASShare::IMTranslateIncoming, FALSE);
    return(FALSE);
}


//
// FUNCTION: IMInsertModifierKeystrokes
//
// DESCRIPTION:
//
// This function inserts various modifier keystrokes into the supplied
// buffer to move from one modifier state to another.
//
// PARAMETERS:
//
// curKbState - the current modifier state (bit 0 - Shift, bit 1 - Ctrl,
// bit 2 - Menu).
//
// targetKbState - the state we want the modifiers to be in
//
// pEventQueue - a pointer to an array where the required events can be
// inserted
//
// RETURNS: the number of events inserted
//
//
UINT ASShare::IMInsertModifierKeystrokes
(
    BYTE    curKbState,
    BYTE    targetKbState,
    LPUINT  pEventQueue
)
{

    UINT  kbDelta;
    UINT  events = 0;

    DebugEntry(ASShare::IMInsertModifierKeystrokes);

    //
    // Find out which modifiers are different.
    //
    kbDelta = curKbState ^ targetKbState;
    TRACE_OUT(( "Keyboard delat %x", kbDelta));

    //
    // Now generate the right events to get us into the correct modifier
    // state.
    //
    if (kbDelta & IEM_SHIFT_DOWN)
    {
        //
        // Shift state is different - do we need an up or down.
        //
        if (curKbState & IEM_SHIFT_DOWN)
        {
            //
            // We need an up.
            //
            pEventQueue[events++] = IEM_EVENT_SHIFT_UP;
        }
        else
        {
            //
            // We need a down.
            //
            pEventQueue[events++] = IEM_EVENT_SHIFT_DOWN;
        }
    }

    //
    // Same process for Ctrl and Alt.
    //
    if (kbDelta & IEM_CTRL_DOWN)
    {
        if (curKbState & IEM_CTRL_DOWN)
        {
            pEventQueue[events++] = IEM_EVENT_CTRL_UP;
        }
        else
        {
            pEventQueue[events++] = IEM_EVENT_CTRL_DOWN;
        }
    }

    if (kbDelta & IEM_MENU_DOWN)
    {
        if (curKbState & IEM_MENU_DOWN)
        {
            pEventQueue[events++] = IEM_EVENT_MENU_UP;
        }
        else
        {
            pEventQueue[events++] = IEM_EVENT_MENU_DOWN;
        }
    }

    DebugExitDWORD(ASShare::IMInsertModifierKeystrokes, events);
    return(events);
}


//
// IMInjectEvent()
//
// DESCRIPTION:
//
// Called by IMMaybeInjectEvents when it is ready to inject an event.
// Given a pointer to a IMOSEVENT this function formats it correctly and
// calls the appropriate USER callback.  It also updates the async key
// state arrays for the source queue and USER and sets m_imLastInjectTime to
// the tick count at which the event was injected.  We protect against
// injecting up key strokes/mouse buttons when USER does not think the
// key/button is down in this function.  It is quite possible (given the
// potential variety of CAs) that the IM will be asked to inject an up
// event when there has been no corresponding down event.  This should be
// harmless as it is possible for this to happen in real life (ie the
// system message queue is full when the down event happens but there is
// space when the up event happens).  However, it is quite unlikely and it
// is more likely that injecting these unmatched events will confuse
// applications.
//
// PARAMETERS:
//
// pEvent - pointer to an IMOSEVENT.
//
// THIS WORKS FOR NT AND WIN95.
//
BOOL  ASShare::IMInjectEvent(LPIMOSEVENT pEvent)
{
    UINT            clickTime;
    TSHR_UINT16     flags;
    TSHR_UINT16     flagsAfter;
    LPMSEV          pMouseEvent;

    DebugEntry(IMInjectEvent);

    //
    // Now inject the event.
    //
    switch (pEvent->type)
    {
        case IM_MOUSE_EVENT:
            //
            // Set up a pointer to the mouse event data.
            //
            pMouseEvent = &(pEvent->event.mouse);

            //
            // Check whether this is an unmatched up event
            //
            if ((IM_MEV_BUTTON1_UP(*pEvent) &&
                        IM_KEY_STATE_IS_UP(m_aimControlledKeyStates[VK_LBUTTON])) ||
                (IM_MEV_BUTTON2_UP(*pEvent) &&
                        IM_KEY_STATE_IS_UP(m_aimControlledKeyStates[VK_RBUTTON])) ||
                (IM_MEV_BUTTON3_UP(*pEvent) &&
                          IM_KEY_STATE_IS_UP(m_aimControlledKeyStates[VK_MBUTTON])))
            {
                //
                // This is an unmatched up event so just discard it here
                //
                TRACE_OUT(("IMInjectEvent: discarding unmatched mouse up event"));
                DC_QUIT;
            }

            //
            // Store the injection time of this event.
            //
            m_imControlledLastLowLevelMouseEventTime = GetTickCount();

            //
            // Store the mouse position - only consider absolute mouse
            // moves.  (Note that for the cases in which we inject a
            // relative mouse event we always set the co-ordinate change to
            // 0).
            //
            if (pMouseEvent->flags & MOUSEEVENTF_ABSOLUTE)
            {
                m_imControlledLastMousePos.x = pMouseEvent->pt.x;
                m_imControlledLastMousePos.y = pMouseEvent->pt.y;

                TRACE_OUT(( "Updating mouse position (%d:%d)",
                         m_imControlledLastMousePos.x,
                         m_imControlledLastMousePos.y));
            }

            //
            // Inject the event.
            //
            TRACE_OUT(("IMInjectEvent: MOUSE parameters are:"));
            TRACE_OUT(("      flags       0x%08x", pMouseEvent->flags));
            TRACE_OUT(("      time        0x%08x", m_imControlledLastLowLevelMouseEventTime));
            TRACE_OUT(("      position    (%d, %d)", pMouseEvent->pt.x, pMouseEvent->pt.y));
            TRACE_OUT(("      mouseData   %d", pMouseEvent->mouseData));
            TRACE_OUT(("      dwExtra     %d", pMouseEvent->dwExtraInfo));

            //
            // Finally scale the logical screen co-ordinates to the full
            // 16-bit range (0..65535).
            //

            ASSERT(m_pasLocal->cpcCaps.screen.capsScreenWidth);
            ASSERT(m_pasLocal->cpcCaps.screen.capsScreenHeight);

            pMouseEvent->pt.x = IM_MOUSEPOS_LOG_TO_OS(pMouseEvent->pt.x,
                                                      m_pasLocal->cpcCaps.screen.capsScreenWidth);
            pMouseEvent->pt.y = IM_MOUSEPOS_LOG_TO_OS(pMouseEvent->pt.y,
                                                      m_pasLocal->cpcCaps.screen.capsScreenHeight);

            OSI_InjectMouseEvent(pMouseEvent->flags, pMouseEvent->pt.x,
                pMouseEvent->pt.y, pMouseEvent->mouseData, pMouseEvent->dwExtraInfo);
            break;

        case IM_KEYBOARD_EVENT:
            //
            // Check whether this is an unmatched up event
            //
            if (IM_KEV_KEYUP(*pEvent) &&
                IM_KEY_STATE_IS_UP(m_aimControlledKeyStates[IM_KEV_VKCODE(*pEvent)]))
            {
                //
                // This is an unmatched up event so just discard it.
                //
                TRACE_OUT(("IMInjectEvent: discarding unmatched key up event %04hX",
                                                     IM_KEV_VKCODE(*pEvent)));
                DC_QUIT;
            }

            //
            // Inject the event.
            //
            TRACE_OUT(("IMInjectEvent: KEYBD parameters are:"));
            TRACE_OUT(("      flags       0x%08x", pEvent->event.keyboard.flags));
            TRACE_OUT(("      virtkey     %u", pEvent->event.keyboard.vkCode));
            TRACE_OUT(("      scan code   %u", pEvent->event.keyboard.scanCode));

            OSI_InjectKeyboardEvent(pEvent->event.keyboard.flags,
                pEvent->event.keyboard.vkCode, pEvent->event.keyboard.scanCode,
                pEvent->event.keyboard.dwExtraInfo);

            if (pEvent->flags & IM_FLAG_UPDATESTATE)
            {
                BYTE     kbState[256];

                TRACE_OUT(("Updating keyboard LED state after playing back toggle"));

                GetKeyboardState(kbState);
                SetKeyboardState(kbState);
            }
            break;

        default:
            //
            // We do nothing for unexpected events - this allow us to add
            // more events later that can be sent to back level systems
            // where they will be safely ignored
            //
            TRACE_OUT(( "Unexpected event %d", pEvent->type));
            DC_QUIT;
     }

    //
    // If we get here successfully then we want to update our copy of the
    // async key state so set the flag.
    //
    IMUpdateAsyncArray(m_aimControlledKeyStates, pEvent);

DC_EXIT_POINT:

    DebugExitBOOL(ASShare::IMInjectEvent, TRUE);
    return(TRUE);
}


//
// FUNCTION: IMInjectingEvents
//
BOOL  ASShare::IMInjectingEvents(void)
{
    LPIMOSEVENT     pNextEvent;
    IMOSEVENT       mouseMoveEvent;
    UINT            tick;
    UINT            targetTime;
    UINT            targetDelta;
    BOOL            rc = TRUE;

    DebugEntry(ASShare::IMInjectingEvents);

    if (m_pasLocal->m_caControlledBy && m_imControlledOSQ.numEvents)
    {
        pNextEvent = m_imControlledOSQ.events + m_imControlledOSQ.head;

        //
        // First check if this is a remote mouse event being injected too
        // soon after the previous one.  We used to only do this for mouse
        // move events to prevent them all being spoiled if they were
        // injected too quickly.  However, we now do it for all mouse
        // events because of a bug in Windows USER whereby if the mouse
        // press which brings up a menu is processed after the
        // corresponding mouse release has been passed to USER (so that the
        // async state of the mouse button is up) then the menu is brought
        // up in the position it is brought up in if it is selected via the
        // keyboard rather than the position it is brought up in if it is
        // selected by the mouse.  (These positions are only different when
        // the menu cannot be placed completely below or above the menu
        // bar).  This can then lead to the mouse release selecting an item
        // from the menu.
        //
        tick = GetTickCount();
        if (m_imfControlledPaceInjection &&
            (pNextEvent->type == IM_MOUSE_EVENT))
        {
            //
            // This is a remote mouse event so check that now is a good
            // time to inject it Smooth out the backlog adjustment so that
            // packet bursts do not get spoiled too much.  Set an absolute
            // lg_lpimSharedData->imit on injection delay of the low sample rate so that
            // timestamp anomolies do not cause us to withhold messages
            //

            //
            // The target delta between last and current events is
            // calculated from the remote timestamps
            //
            targetDelta = abs((int)(pNextEvent->time -
                                                m_imControlledLastMouseRemoteTime));
            if (targetDelta > IM_LOCAL_MOUSE_SAMPLING_GAP_LOW_MS)
            {
                targetDelta = IM_LOCAL_MOUSE_SAMPLING_GAP_LOW_MS;
            }

            //
            // The target injection time is based on the last injection
            // time and our target delta, adjusted for any backlog we are
            // seeing.  Because packeting gives a jerky backlog we need to
            // smooth our adjustment out (only modify by backlog/8)
            //
            targetTime = m_imControlledLastMouseLocalTime +
                         targetDelta - (m_imControlledMouseBacklog/8);

            TRACE_OUT(( "Last tremote %#lx, this tremote %#lx, backlog %#lx",
                          m_imControlledLastMouseRemoteTime,
                          pNextEvent->time,
                          m_imControlledMouseBacklog));
            TRACE_OUT(( "Last tlocal %#lx, tick %#lx, targetTime %#lx",
                          m_imControlledLastMouseLocalTime,
                          tick,
                          targetTime));

            //
            // Now inject the events - ignore them if they are too early
            //
            if (IM_MEV_ABS_MOVE(*pNextEvent) && (tick < targetTime))
            {
                //
                // If values seem wild (for example this is the first mouse
                // event ever) then reset them
                //
                if (targetTime > tick + 1000)
                {
                    m_imControlledLastMouseRemoteTime = pNextEvent->time;
                    m_imControlledLastMouseLocalTime  = tick;
                    m_imControlledMouseBacklog = 0;
                    TRACE_OUT(( "Wild values - reset"));
                }
                else
                {
                    //
                    // This is too early - get out of the loop.
                    //
                    rc = FALSE;
                    DC_QUIT;
                }
            }
            else
            {
                //
                // We will inject this event (and remember when we did it
                // so we don't inject the next one to quickly).  Calculate
                // the backlog because we may have to make up for a
                // processing delay If this event is long (1000 mS) after
                // our projected event time then assume a pause in movement
                // and reset the backlog to avoid progressive erosion.
                // Otherwise calculate the new backlog.
                //
                // Perf - don't reset backlog unless the time has expired.
                // Restting just because we see a click means that we
                // actually increase the latency by assuming that mouse
                // messages queued behind the tick are not backlogged.
                //
                if (tick < (targetTime + 1000))
                {
                    m_imControlledMouseBacklog += ( tick -
                                        m_imControlledLastMouseLocalTime -
                                        targetDelta );
                }
                else
                {
                    m_imControlledMouseBacklog = 0;
                    TRACE_OUT(( "Non move/big gap in move"));
                }
                m_imControlledLastMouseRemoteTime = pNextEvent->time;
                m_imControlledLastMouseLocalTime  = tick;
            }
        }
        else
        {
            //
            // This is not a remote mouse event.  Reset the
            // m_imNextRemoteMouseEvent to zero so we don't hold up the next
            // remote mouse event.
            //
            m_imControlledLastMouseRemoteTime   = pNextEvent->time;
            m_imControlledLastMouseLocalTime    = tick;
            m_imControlledMouseBacklog          = 0;
            TRACE_OUT(( "Local/non-paced/non-mouse - reset"));
        }

        //
        // Only inject the event if IM_FLAG_DONT_REPLAY is not set
        //
        if (!(pNextEvent->flags & IM_FLAG_DONT_REPLAY))
        {
            //
            // If the event is a mouse click then we always inject a mouse
            // move event g_lpimSharedData->immediately before it to ensure that the current
            // position is correct before the click is injected.
            //
            // This is because USER does not handle combined "move and
            // click" events correctly (it appears to treat them as "click
            // and move", generating a mouse move event AFTER the click
            // event, rather than before).  Under normal Windows operation
            // it appears (from observation) that movement events and click
            // events are generated separately (i.e.  a click event will
            // never have the movement flag set).  However, incoming mouse
            // click events may have positions that are different from the
            // last mouse move event so we must inject the extra move event
            // to keep USER happy.
            //
            if ( (pNextEvent->type == IM_MOUSE_EVENT) &&
                 (IM_MEV_BUTTON_DOWN(*pNextEvent) ||
                  IM_MEV_BUTTON_UP(*pNextEvent)) )
            {
                TRACE_OUT(( "Mouse clk: injecting extra"));

                //
                // Take a copy of the event.
                //
                mouseMoveEvent = *pNextEvent;

                //
                // Turn the mouse click event into a mouse move event with
                // the absolute/relative flag unchanged.
                //
                mouseMoveEvent.event.mouse.flags &= MOUSEEVENTF_ABSOLUTE;
                mouseMoveEvent.event.mouse.flags |= MOUSEEVENTF_MOVE;

                //
                // Inject the additional move event.
                //
                IMInjectEvent(&mouseMoveEvent);

                //
                // As the position is now correct, we turn the click into a
                // relative event with an unchanged position.
                //
                pNextEvent->event.mouse.flags &= ~MOUSEEVENTF_ABSOLUTE;
                pNextEvent->event.mouse.pt.x = 0;
                pNextEvent->event.mouse.pt.y = 0;

                //
                // If this is a mouse down click then flag the injection
                // heuristic as active.  We deactivate the heuristic when
                // the mouse is released so that dragging over menus can be
                // done without delay.  (We keep the heuristic active when
                // mouse is depressed because most drawing apps perform
                // freehand drawing in this way.
                //
                if (IM_MEV_BUTTON_DOWN(*pNextEvent))
                {
                    TRACE_OUT(( "Injection pacing active"));
                    m_imfControlledPaceInjection = TRUE;
                }
                else
                {
                    TRACE_OUT(( "Injection pacing inactive"));
                    m_imfControlledPaceInjection = FALSE;
                }
            }

            //
            // Inject the real event.
            //
            TRACE_OUT(( "Injecting the evnt now"));
            IMInjectEvent(pNextEvent);
        }

        IMUpdateAsyncArray(m_aimControlledControllerKeyStates, pNextEvent);

        ASSERT(m_imControlledOSQ.numEvents);
        m_imControlledOSQ.numEvents--;
        m_imControlledOSQ.head = CIRCULAR_INDEX(m_imControlledOSQ.head, 1,
            IM_SIZE_OSQ);

        //
        // We only inject a single keyboard event per pass to prevent
        // excessive spoiling of repeated events.  Having got them here it
        // seems a shame to spoil them.  Spoil down to 5 so we don't get
        // excessive overrun following a key repeat sequence.
        //
        if ((pNextEvent->type == IM_KEYBOARD_EVENT) &&
            (m_imControlledOSQ.numEvents < 5))
        {
            TRACE_OUT(( "Keyboard event so leaving loop"));
            rc = FALSE;
        }
    }
    else
    {
        //
        // We're done.
        //
        rc = FALSE;
    }

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::IMInjectingEvents, rc);
    return(rc);
}




//
// IMMaybeInjectEvents()
//
// DESCRIPTION:
//
// This is called whenever the IM believes there may be an opportunity to
// inject more events into USER via the input event callbacks.  The two
// main reasons for this are:
//
// 1.  We have received a new event in the mouse or keyboard hooks.  This
// will normally imply that an event has been removed from the system
// message queue so there will be at least one free slot on it.
//
// 2.  We have added a new event (or events) to either the local or remote
// USER event queues.  This means there will be at least one event waiting
// to be injected.
//
// This function is also called periodically (via IM_Periodic) to keep
// things moving.
//
// In order for an event to be injected there must be
//
//  - an event waiting (with IM_FLAG_DONT_REPLAY reset)
//  - a space on the USER system message queue
//  - a new time stamp (if we are switching event sources).
//
// This function works as a state machine.  It always starts in a specified
// state and will then take various actions and then possibly enter a new
// state.  It continues to loop through this process until it cannot take
// any actions in one of its states at which point it returns.
//
// There are four states (each of which is further qualified by whether it
// refers to local or remote events).  The states are:
//
// IM_INJECTING_EVENTS - we are injecting events into USER from the
// appropriate queue.
//
// IM_WAITING_FOR_TICK - we are waiting for a timer tick to give us a new
// timestamp before injecting events
//
// IM_DEVICE_TO_NEW_SOURCE - we are injecting fake events to bring the
// state of the keyboard and mouse (as seen by USER) into line with the
// state of the new source of input.
//
void  ASShare::IMMaybeInjectEvents(void)
{
    IMEVENT     eventIn;
    IMEVENT     eventOut;
    IMOSEVENT   OSEvent;
    BOOL        replay;
    UINT        rcConvert;
    UINT        now;
    HWND        hwndDest;
    HWND        hwndParent;
    POINT       ptMousePos;
    LPIMOSEVENT pNextEvent;

    DebugEntry(IMMaybeInjectEvents);

    ASSERT(m_pasLocal->m_caControlledBy);

    //
    // Check whether we should wait before converting events.  We need to
    // do this to prevent us being swamped with mouse move events when
    // we're waiting for the desktop to scroll.
    //
    now = GetTickCount();
    if (IN_TIME_RANGE(m_imControlledLastIncompleteConversion,
           m_imControlledLastIncompleteConversion + IM_MIN_RECONVERSION_INTERVAL_MS, now))
    {
        goto IM_DISCARD;
    }

    //
    // NOW TRANSLATE NETWORK EVENTS TO OS EVENTS
    // We'll discard or inject them when the time is right.
    // But don't do translation if there are still OS events left
    // waiting to be injected from the previous packet.
    //
    if (m_imControlledEventQ.numEvents && !m_imControlledOSQ.numEvents)
    {
        //
        // Get the event from the front of the network event queue.
        //
        eventIn = m_imControlledEventQ.events[0];

        replay = FALSE;
        switch (eventIn.type)
        {
            case IM_TYPE_3BUTTON:
            case IM_TYPE_VK1:
            case IM_TYPE_VK2:
            case IM_TYPE_ASCII:
            {
                replay = TRUE;
                break;
            }

            default:
                ERROR_OUT(("Bogus NETWORK event being translated"));
                break;
        }

        //
        // After this while loop we test rcConvert to see whether the
        // input packet can now be removed (has been fully processed).
        // We only SET rcConvert if IMTranslateIncoming returns TRUE,
        // yet IM_TR specifically returns FALSE to indicate that the
        // input packet does not contain an event and is to be
        // discarded.  To fix this - set rcConvert here.
        //
        rcConvert = IM_IMQUEUEREMOVE;
        while (IMTranslateIncoming(&eventIn, &eventOut))
        {
            rcConvert = IMConvertIMEventToOSEvent(&eventOut, &OSEvent);

            //
            // Inject the event into the OS queue (if required).
            //
            if (rcConvert & IM_OSQUEUEINJECT)
            {
                if (!replay)
                {
                    OSEvent.flags |= IM_FLAG_DONT_REPLAY;
                }

                // Add to playback queue

                // Is the queue filled up?
                if (m_imControlledOSQ.numEvents == IM_SIZE_OSQ)
                {
                    ERROR_OUT(("Failed to add OS event to queue"));
                }
                else
                {
                    // Put this element at the tail.
                    m_imControlledOSQ.events[CIRCULAR_INDEX(m_imControlledOSQ.head,
                        m_imControlledOSQ.numEvents, IM_SIZE_OSQ)] =
                        OSEvent;
                    m_imControlledOSQ.numEvents++;
                }
            }
        }

        //
        // The following test is not ideal as it relies on the fact
        // that any events for which IMConvertIMEventToUSEREvent does
        // not set IM_IMQUEUEREMOVE had a one-one mapping.
        //
        // However, we know that this is always the case with mouse
        // events, which are the only events that will be cause this
        // flag to be unset.
        //
        if (rcConvert & IM_IMQUEUEREMOVE)
        {
            //
            // Remove this from the network queue
            //
            m_imControlledEventQ.numEvents--;
            UT_MoveMemory(&(m_imControlledEventQ.events[0]),
                          &(m_imControlledEventQ.events[1]),
                          sizeof(IMEVENT) * m_imControlledEventQ.numEvents);
        }
        else
        {
            //
            // Remember this so we don't flood the input injection with
            // events when we don't remove the network event from the
            // queue.
            //
            TRACE_OUT(( "do not shuffle"));
            m_imControlledLastIncompleteConversion = GetTickCount();
        }
    }

IM_DISCARD:
    //
    // Get rid of all discarded events.  Update the remote controller's
    // key state array to reflect it.  But since we aren't going to replay
    // these, don't update our local key state table.
    //

    while (m_imControlledOSQ.numEvents > 0)
    {
        pNextEvent = m_imControlledOSQ.events + m_imControlledOSQ.head;
        if (!(pNextEvent->flags & IM_FLAG_DONT_REPLAY))
        {
            // We're done.
            break;
        }

        IMUpdateAsyncArray(m_aimControlledControllerKeyStates, pNextEvent);

        ASSERT(m_imControlledOSQ.numEvents);
        m_imControlledOSQ.numEvents--;
        m_imControlledOSQ.head = CIRCULAR_INDEX(m_imControlledOSQ.head, 1,
            IM_SIZE_OSQ);
    }


    //
    // NOW INJECT OS EVENTS into system
    //
    while (IMInjectingEvents())
    {
        ;
    }

    DebugExitVOID(ASShare::IMMaybeInjectEvents);
}


//
// FUNCTION: IMUpdateAsyncArray
//
// DESCRIPTION:
//
// Called with the address of one of our async key state arrays and a
// IMOSEVENT this function updates the async key state array according to
// the contents of the IMOSEVENT.
//
// PARAMETERS:
//
// paimKeyStates - pointer to async key state array.
//
// pEvent - pointer to IMOSEVENT.
//
// RETURNS: NONE
//
//
void  ASShare::IMUpdateAsyncArray
(
    LPBYTE          paimKeyStates,
    LPIMOSEVENT     pEvent
)
{
    UINT flags;
    UINT vkCode;

    DebugEntry(ASShare::IMUpdateAsyncArray);

    switch (pEvent->type)
    {
        case IM_MOUSE_EVENT:
            //
            // Update the async key state arrays for this event.  Note that
            // we treat each event as independent - this is how Windows
            // treats them and if all the up/down flags are set Windows
            // will generate six mouse message! (and in down,up order).
            //
            flags = pEvent->event.mouse.flags;

            if (flags & MOUSEEVENTF_LEFTDOWN)
            {
                IM_SET_VK_DOWN(paimKeyStates[VK_LBUTTON]);
            }

            if (flags & MOUSEEVENTF_LEFTUP)
            {
                IM_SET_VK_UP(paimKeyStates[VK_LBUTTON]);
            }

            if (flags & MOUSEEVENTF_RIGHTDOWN)
            {
                IM_SET_VK_DOWN(paimKeyStates[VK_RBUTTON]);
            }

            if (flags & MOUSEEVENTF_RIGHTUP)
            {
                IM_SET_VK_UP(paimKeyStates[VK_RBUTTON]);
            }

            if (flags & MOUSEEVENTF_MIDDLEDOWN)
            {
                IM_SET_VK_DOWN(paimKeyStates[VK_MBUTTON]);
            }

            if (flags & MOUSEEVENTF_MIDDLEUP)
            {
                IM_SET_VK_UP(paimKeyStates[VK_MBUTTON]);
            }
            break;

        case IM_KEYBOARD_EVENT:
            //
            // Update the async key state arrays.
            //
            vkCode = IM_KEV_VKCODE(*pEvent);

            if (IM_KEV_KEYUP(*pEvent))
            {
                IM_SET_VK_UP(paimKeyStates[vkCode]);
            }
            else
            {
                //
                // This is a key down event - check if it is a press or a
                // repeat.
                //
                if (IM_KEY_STATE_IS_UP(paimKeyStates[vkCode]))
                {
                    //
                    // This is a key press as the key was previously up -
                    // alter the toggle state.  We keep the toggle state
                    // for all keys although we currently only worry about
                    // it for the `known' toggles.
                    //
                    IM_TOGGLE_VK(paimKeyStates[vkCode]);
                }

                IM_SET_VK_DOWN(paimKeyStates[vkCode]);
            }
            break;

        default:
            //
            // Just ignore unexpected events.
            //
            ERROR_OUT(( "Unexpected event %u", pEvent->type));
            break;
    }

    DebugExitVOID(ASShare::IMUpdateAsyncArray);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\mgc.cpp ===
#include "precomp.h"


//
// MGC.CPP
// MCS Glue Layer, Legacy from simultaneous R.11 and T.120 support
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_NET

//
//
// CONSTANT DATA
//
// These arrays map between MCAT and DC-Grouwpare constants.  They are not
// in separate data file since only referenced from this source file.
//
//
UINT McsErrToNetErr (UINT rcMCS);

const UINT c_RetCodeMap1[] =
    {
        0,
        NET_RC_MGC_NOT_SUPPORTED,
        NET_RC_MGC_NOT_INITIALIZED,
        NET_RC_MGC_ALREADY_INITIALIZED,
        NET_RC_MGC_INIT_FAIL,
		NET_RC_MGC_INVALID_REMOTE_ADDRESS,
		NET_RC_NO_MEMORY,
		NET_RC_MGC_CALL_FAILED,
		NET_RC_MGC_NOT_SUPPORTED,
		NET_RC_MGC_NOT_SUPPORTED,
		NET_RC_MGC_NOT_SUPPORTED, // security failed
    };

const UINT c_RetCodeMap2[] =
    {
        NET_RC_MGC_DOMAIN_IN_USE,
        NET_RC_MGC_INVALID_DOMAIN,
        NET_RC_MGC_NOT_ATTACHED,
        NET_RC_MGC_INVALID_USER_HANDLE,
        NET_RC_MGC_TOO_MUCH_IN_USE,
        NET_RC_MGC_INVALID_CONN_HANDLE,
        NET_RC_MGC_INVALID_UP_DOWN_PARM,
        NET_RC_MGC_NOT_SUPPORTED,
        NET_RC_MGC_TOO_MUCH_IN_USE
    };

#define MG_NUM_OF_MCS_RESULTS       15
#define MG_INVALID_MCS_RESULT       MG_NUM_OF_MCS_RESULTS
NET_RESULT c_ResultMap[MG_NUM_OF_MCS_RESULTS+1] =
    {
        NET_RESULT_OK,
        NET_RESULT_NOK,
        NET_RESULT_NOK,
        NET_RESULT_CHANNEL_UNAVAILABLE,
        NET_RESULT_DOMAIN_UNAVAILABLE,
        NET_RESULT_NOK,
        NET_RESULT_REJECTED,
        NET_RESULT_NOK,
        NET_RESULT_NOK,
        NET_RESULT_TOKEN_ALREADY_GRABBED,
        NET_RESULT_TOKEN_NOT_OWNED,
        NET_RESULT_NOK,
        NET_RESULT_NOK,
        NET_RESULT_NOT_SPECIFIED,
        NET_RESULT_USER_REJECTED,
        NET_RESULT_UNKNOWN
    };




//
// MG_Register()
//
BOOL MG_Register
(
    MGTASK          task,
    PMG_CLIENT *    ppmgClient,
    PUT_CLIENT      putTask
)
{
    PMG_CLIENT      pmgClient =     NULL;
    CMTASK          cmTask;
    BOOL            rc = FALSE;

    DebugEntry(MG_Register);

    UT_Lock(UTLOCK_T120);

    ASSERT(task >= MGTASK_FIRST);
    ASSERT(task < MGTASK_MAX);

    //
    // Check the putTask passed in:
    //
    ValidateUTClient(putTask);

    //
    // Does this already exist?
    //
    if (g_amgClients[task].putTask != NULL)
    {
        ERROR_OUT(("MG task %d already exists", task));
        DC_QUIT;
    }

    pmgClient = &(g_amgClients[task]);
    ZeroMemory(pmgClient, sizeof(MG_CLIENT));

    pmgClient->putTask       = putTask;


    //
    // Register an exit procedure
    //
    UT_RegisterExit(putTask, MGExitProc, pmgClient);
    pmgClient->exitProcReg = TRUE;


    //
    // We register a high priority event handler (join by key handler) to
    // intercept various events which are generated as part of the join by
    // key processing.  We register it now, before the call to
    // MG_ChannelJoin below, to prevent events which we cant stop from
    // going to the client if UT_RegisterEvent fails.  This high priority
    // handler also looks after our internal scheduling of pending
    // requests.
    //
    UT_RegisterEvent(putTask, MGEventHandler, pmgClient, UT_PRIORITY_OBMAN);
    pmgClient->eventProcReg = TRUE;

    //
    // Register our hidden event handler for the client (the parameter to
    // be passed to the event handler is the pointer to the client CB):
    //
    UT_RegisterEvent(putTask, MGLongStopHandler, pmgClient, UT_PRIORITY_NETWORK);
    pmgClient->lowEventProcReg = TRUE;

    //
    // Register as a call manager secondary.
    //
    switch (task)
    {
        case MGTASK_OM:
            cmTask = CMTASK_OM;
            break;

        case MGTASK_DCS:
            cmTask = CMTASK_DCS;
            break;

        default:
            ASSERT(FALSE);
    }

    if (!CMS_Register(putTask, cmTask, &(pmgClient->pcmClient)))
    {
        ERROR_OUT(("CMS_Register failed"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:

    *ppmgClient = pmgClient;

    UT_Unlock(UTLOCK_T120);

    DebugExitBOOL(MG_Register, rc);
    return(rc);
}



//
// MG_Deregister(...)
//
void MG_Deregister(PMG_CLIENT * ppmgClient)
{
    PMG_CLIENT  pmgClient;

    DebugEntry(MG_Deregister);

    UT_Lock(UTLOCK_T120);

    ASSERT(ppmgClient);
    pmgClient = *ppmgClient;
    ValidateMGClient(pmgClient);

    MGExitProc(pmgClient);

    //
    // Dereg CMS handler.  In abnormal situations, the CMS exit proc will
    // clean it up for us.
    //
    if (pmgClient->pcmClient)
    {
        CMS_Deregister(&pmgClient->pcmClient);
    }

    *ppmgClient = NULL;
    UT_Unlock(UTLOCK_T120);

    DebugExitVOID(MG_Deregister);
}


//
// MGExitProc()
//
void CALLBACK MGExitProc(LPVOID uData)
{
    PMG_CLIENT      pmgClient = (PMG_CLIENT)uData;
    PMG_BUFFER      pmgBuffer;

    DebugEntry(MGExitProc);

    UT_Lock(UTLOCK_T120);

    ValidateMGClient(pmgClient);

    //
    // If the client has attached, detach it
    //
    if (pmgClient->userAttached)
    {
        MG_Detach(pmgClient);
    }

    //
    // Free all buffers the client may be using:
    //
    pmgBuffer = (PMG_BUFFER)COM_BasedListFirst(&(pmgClient->buffers), FIELD_OFFSET(MG_BUFFER, clientChain));
    while (pmgBuffer != NULL)
    {
        ValidateMGBuffer(pmgBuffer);

        //
        // This implicitly frees any user memory or MCS memory associated
        // with the buffer CB.
        //
        MGFreeBuffer(pmgClient, &pmgBuffer);

        //
        // MGFreeBuffer removed this CB from the list, so we get the first
        // one in what's left of the list - if the list is now empty, this
        // will give us NULL and we will break out of the while loop:
        //
        pmgBuffer = (PMG_BUFFER)COM_BasedListFirst(&(pmgClient->buffers), FIELD_OFFSET(MG_BUFFER, clientChain));
    }

    //
    // Deregister our event handler and exit procedure:
    //
    if (pmgClient->exitProcReg)
    {
        UT_DeregisterExit(pmgClient->putTask, MGExitProc, pmgClient);
        pmgClient->exitProcReg = FALSE;
    }

    if (pmgClient->lowEventProcReg)
    {
        UT_DeregisterEvent(pmgClient->putTask, MGLongStopHandler, pmgClient);
        pmgClient->lowEventProcReg = FALSE;
    }

    if (pmgClient->eventProcReg)
    {
        UT_DeregisterEvent(pmgClient->putTask, MGEventHandler, pmgClient);
        pmgClient->eventProcReg = FALSE;
    }

    //
    // We should only ever be asked to free a client CB which has had all
    // of its child resources already freed, so do a quick sanity check:
    //
    ASSERT(pmgClient->buffers.next == 0);

    //
    // Set the putTask to NULL; that's how we know if a client is in use or
    // not.
    //
    pmgClient->putTask = NULL;

    UT_Unlock(UTLOCK_T120);

    DebugExitVOID(MGExitProc);
}






//
// MG_Attach(...)
//
UINT MG_Attach
(
    PMG_CLIENT          pmgClient,
    UINT                callID,
    PNET_FLOW_CONTROL   pFlowControl
)
{
    UINT                rc = 0;

    DebugEntry(MG_Attach);

    UT_Lock(UTLOCK_T120);

    ValidateCMP(g_pcmPrimary);

    ValidateMGClient(pmgClient);
    if (!g_pcmPrimary->callID)
    {
        //
        // We aren't in a call yet/anymore.
        //
        WARNING_OUT(("MG_Attach failing; not in T.120 call"));
        rc = NET_RC_MGC_NOT_CONNECTED;
        DC_QUIT;
    }

    ASSERT(callID == g_pcmPrimary->callID);

    ASSERT(!pmgClient->userAttached);

    pmgClient->userIDMCS    = NET_UNUSED_IDMCS;
    ZeroMemory(&pmgClient->flo, sizeof(FLO_STATIC_DATA));
    pmgClient->userAttached = TRUE;

    //
    // Call through to the underlying MCS layer (normally, we need our
    // callbacks to happen with a task switch but since this is Windows it
    // doesn't really matter anyway):
    //
    rc = MCS_AttachRequest(&(pmgClient->m_piMCSSap),
                (DomainSelector)  &g_pcmPrimary->callID,
                sizeof(g_pcmPrimary->callID),
                (MCSCallBack)     MGCallback,
                (void *) 	      pmgClient,
                ATTACHMENT_DISCONNECT_IN_DATA_LOSS);
    if (rc != 0)
    {
        WARNING_OUT(("MCSAttachUserRequest failed with error %x", rc));

        MGDetach(pmgClient);
        rc = McsErrToNetErr(rc);
        DC_QUIT;
    }

    if (++g_mgAttachCount == 1)
    {
        UT_PostEvent(pmgClient->putTask,
                    pmgClient->putTask,
                    MG_TIMER_PERIOD,
                    NET_MG_WATCHDOG,
                    0, 0);
    }

    ASSERT(g_mgAttachCount <= MGTASK_MAX);

    //
    // It is assumed that the client will use the same latencies for every
    // attachment, so we keep them at the client level.
    //
    pmgClient->flowControl = *pFlowControl;

DC_EXIT_POINT:

    UT_Unlock(UTLOCK_T120);

    DebugExitDWORD(MG_Attach, rc);
    return(rc);
}




//
// MG_Detach(...)
//
void MG_Detach
(
    PMG_CLIENT      pmgClient
)
{
    DebugEntry(MG_Detach);

    UT_Lock(UTLOCK_T120);

    ValidateMGClient(pmgClient);

    if (!pmgClient->userAttached)
    {
        TRACE_OUT(("MG_Detach: client %x not attached", pmgClient));
        DC_QUIT;
    }

    //
    // Call FLO_UserTerm to ensure that flow control is stopped on all the
    // channels that have been flow controlled on our behalf.
    //
    FLO_UserTerm(pmgClient);

    //
    // Clear out the buffers, variabls.
    //
    MGDetach(pmgClient);

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_T120);

    DebugExitVOID(MG_Detach);
}



//
// MG_ChannelJoin(...)
//

UINT MG_ChannelJoin
(
    PMG_CLIENT          pmgClient,
    NET_CHANNEL_ID *    pCorrelator,
    NET_CHANNEL_ID      channel
)
{
    PMG_BUFFER          pmgBuffer;
    UINT                rc = 0;

    DebugEntry(MG_ChannelJoin);

    UT_Lock(UTLOCK_T120);

    ValidateMGClient(pmgClient);

    if (!pmgClient->userAttached)
    {
        TRACE_OUT(("MG_ChannelJoin:  client %x not attached", pmgClient));
        rc = NET_RC_MGC_INVALID_USER_HANDLE;
        DC_QUIT;
    }

    //
    // MCAT may bounce this request, so we must queue the request
    //
    rc = MGNewBuffer(pmgClient, MG_RQ_CHANNEL_JOIN, &pmgBuffer);
    if (rc != 0)
    {
        DC_QUIT;
    }

    MGNewCorrelator(pmgClient, pCorrelator);

    pmgBuffer->work      = *pCorrelator;
    pmgBuffer->channelId = (ChannelID)channel;

    TRACE_OUT(("Inserting join message 0x%08x into pending chain", pmgBuffer));
    COM_BasedListInsertBefore(&(pmgClient->pendChain), &(pmgBuffer->pendChain));

    UT_PostEvent(pmgClient->putTask,
                      pmgClient->putTask,
                      NO_DELAY,
                      NET_MG_SCHEDULE,
                      0,
                      0);

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_T120);

    DebugExitDWORD(MG_ChannelJoin, rc);
    return(rc);
}



//
// MG_ChannelJoinByKey(...)
//
UINT MG_ChannelJoinByKey
(
    PMG_CLIENT      pmgClient,
    NET_CHANNEL_ID * pCorrelator,
    WORD            channelKey
)
{
    PMG_BUFFER      pmgBuffer;
    UINT            rc = 0;

    DebugEntry(MG_ChannelJoinByKey);

    UT_Lock(UTLOCK_T120);

    ValidateMGClient(pmgClient);

    if (!pmgClient->userAttached)
    {
        TRACE_OUT(("MG_ChannelJoinByKey:  client %x not attached", pmgClient));
        rc = NET_RC_MGC_INVALID_USER_HANDLE;
        DC_QUIT;
    }

    //
    // MCAT may bounce this request, so we must queue the request
    //
    rc = MGNewBuffer(pmgClient, MG_RQ_CHANNEL_JOIN_BY_KEY, &pmgBuffer);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Store the various pieces of information in the joinByKeyInfo
    // structure of the client CB
    //
    MGNewCorrelator(pmgClient, pCorrelator);

    pmgBuffer->work         = *pCorrelator;
    pmgBuffer->channelKey   = (ChannelID)channelKey;
    pmgBuffer->channelId    = 0;

    TRACE_OUT(("Inserting join message 0x%08x into pending chain", pmgBuffer));
    COM_BasedListInsertBefore(&(pmgClient->pendChain), &(pmgBuffer->pendChain));

    UT_PostEvent(pmgClient->putTask,
                      pmgClient->putTask,
                      NO_DELAY,
                      NET_MG_SCHEDULE,
                      0,
                      0);

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_T120);

    DebugExitDWORD(MG_ChannelJoinByKey, rc);
    return(rc);
}




//
// MG_ChannelLeave(...)
//
void MG_ChannelLeave
(
    PMG_CLIENT          pmgClient,
    NET_CHANNEL_ID      channel
)
{
    PMG_BUFFER          pmgBuffer;

    DebugEntry(MG_ChannelLeave);

    UT_Lock(UTLOCK_T120);

    ValidateMGClient(pmgClient);

    if (!pmgClient->userAttached)
    {
        TRACE_OUT(("MG_ChannelLeave:  client %x not attached", pmgClient));
        DC_QUIT;
    }


    //
    // MCAT may bounce this request, so instead of processing it straight
    // away, we put it on the user's request queue and kick off a process
    // queue loop: This is a request CB, but we don't need any data buffer
    //
    if (MGNewBuffer(pmgClient, MG_RQ_CHANNEL_LEAVE, &pmgBuffer) != 0)
    {
        DC_QUIT;
    }

    //
    // Fill in the specific data fields in the request CB:
    //
    pmgBuffer->channelId = (ChannelID)channel;

    COM_BasedListInsertBefore(&(pmgClient->pendChain), &(pmgBuffer->pendChain));

    UT_PostEvent(pmgClient->putTask,
                      pmgClient->putTask,
                      NO_DELAY,
                      NET_MG_SCHEDULE,
                      0,
                      0);

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_T120);

    DebugExitVOID(MG_ChannelLeave);
}




//
// MG_SendData(...)
//
UINT MG_SendData
(
    PMG_CLIENT      pmgClient,
    NET_PRIORITY    priority,
    NET_CHANNEL_ID  channel,
    UINT            length,
    void **         ppData
)
{
    PMG_BUFFER      pmgBuffer;
    UINT            numControlBlocks;
    UINT            i;
    UINT            rc;

    DebugEntry(MG_SendData);

    UT_Lock(UTLOCK_T120);

    ValidateMGClient(pmgClient);

    if (!pmgClient->userAttached)
    {
        TRACE_OUT(("MG_SendData:  client %x not attached", pmgClient));
        rc = NET_RC_MGC_INVALID_USER_HANDLE;
        DC_QUIT;
    }

    //
    // Check for a packet greater than the permitted size
    // It must not cause the length to wrap into the flow flag
    //
    ASSERT(TSHR_MAX_SEND_PKT + sizeof(TSHR_NET_PKT_HEADER) < TSHR_PKT_FLOW);
    ASSERT(length <= TSHR_MAX_SEND_PKT);

    //
    // Ensure we have a priority which is valid for our use of MCS.
    //
    priority = (NET_PRIORITY)(MG_VALID_PRIORITY(priority));

    if (pmgClient->userIDMCS == NET_UNUSED_IDMCS)
    {
        //
        // We are not yet attached, so don't try to send data.
        //
        ERROR_OUT(("Sending data prior to attach indication"));
        rc = NET_RC_INVALID_STATE;
        DC_QUIT;
    }

    //
    // The <ppData> parameter points to a data buffer pointer.  This buffer
    // pointer should point to a buffer which the client acquired using
    // MG_GetBuffer.  MG_GetBuffer should have added a buffer CB to the
    // client's buffer list containing the same pointer. Note that if the
    // NET_SEND_ALL_PRIORITIES flag is set then there will be four buffers
    // in the client's buffer list containing the same pointer.
    //
    // So, we search through the client's buffer list looking for a match
    // on the data buffer pointer. Move to the first position in the list.
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pmgClient->buffers),
        (void**)&pmgBuffer, FIELD_OFFSET(MG_BUFFER, clientChain),
        FIELD_OFFSET(MG_BUFFER, pDataBuffer), (DWORD_PTR)*ppData,
        FIELD_SIZE(MG_BUFFER, pDataBuffer));

    ValidateMGBuffer(pmgBuffer);

    //
    // Check the NET_SEND_ALL_PRIORITIES flag to see if it is set
    //
    if (pmgBuffer->priority & NET_SEND_ALL_PRIORITIES)
    {
        //
        // Check that the priority and channel has not changed.  Changing
        // the priority between calling MG_GetBuffer and calling
        // MG_SendData is not allowed.
        //
        ASSERT(pmgBuffer->channelId == channel);
        ASSERT(priority & NET_SEND_ALL_PRIORITIES);

        //
        // The flag is set so there should be multiple control buffers
        // waiting to be sent.
        //
        numControlBlocks = MG_NUM_PRIORITIES;
    }
    else
    {
        //
        // Check that the priority and channel has not changed.
        //
        ASSERT(pmgBuffer->channelId == channel);
        ASSERT(pmgBuffer->priority  == priority);

        //
        // The flag is not set so there should be only one control buffer
        // waiting.
        //
        numControlBlocks = 1;
    }

    //
    // Now send the control blocks
    //
    for (i = 0; i < numControlBlocks; i++)
    {
        ValidateMGBuffer(pmgBuffer);

        //
        // Clear the NET_SEND_ALL_PRIORITIES flag.
        //
        pmgBuffer->priority &= ~NET_SEND_ALL_PRIORITIES;

        //
        // Set up the packet length for the send (this may be different
        // from the length in the buffer header since the app may not have
        // used all the buffer).
        //
        ASSERT(length + sizeof(TSHR_NET_PKT_HEADER) <= pmgBuffer->length);
        pmgBuffer->pPktHeader->header.pktLength = (TSHR_UINT16)(length + sizeof(TSHR_NET_PKT_HEADER));

        //
        // If the length has changed then tell FC about it.
        //
        if ((length + sizeof(MG_INT_PKT_HEADER)) < pmgBuffer->length)
        {
            FLO_ReallocSend(pmgClient, pmgBuffer->pStr,
                pmgBuffer->length - (length + sizeof(MG_INT_PKT_HEADER)));
        }

        TRACE_OUT(("Inserting send 0x%08x into pend chain, pri %u, chan 0x%08x",
                    pmgBuffer, pmgBuffer->priority, pmgBuffer->channelId));

        COM_BasedListInsertBefore(&(pmgClient->pendChain), &(pmgBuffer->pendChain));

        //
        // If there is one or more control block left to find then search
        // the client's buffer list for it.
        //
        if ((numControlBlocks - (i + 1)) > 0)
        {
            COM_BasedListFind(LIST_FIND_FROM_NEXT,  &(pmgClient->buffers),
                    (void**)&pmgBuffer, FIELD_OFFSET(MG_BUFFER, clientChain),
                    FIELD_OFFSET(MG_BUFFER, pDataBuffer),
                    (DWORD_PTR)*ppData, FIELD_SIZE(MG_BUFFER, pDataBuffer));
        }
    }

    UT_PostEvent(pmgClient->putTask,
                      pmgClient->putTask,
                      NO_DELAY,
                      NET_MG_SCHEDULE,
                      0,
                      0);

    //
    // Everything went OK - set the ppData pointer to NULL to prevent
    // the caller from accessing the memory.
    //
    *ppData = NULL;
    rc = 0;

DC_EXIT_POINT:

    UT_Unlock(UTLOCK_T120);

    DebugExitDWORD(MG_SendData, rc);
    return(rc);
}




//
// MG_TokenGrab(...)
//
UINT MG_TokenGrab
(
    PMG_CLIENT      pmgClient,
    NET_TOKEN_ID    tokenID
)
{
    PMG_BUFFER      pmgBuffer;
    UINT            rc = 0;

    DebugEntry(MG_TokenGrab);

    UT_Lock(UTLOCK_T120);

    ValidateMGClient(pmgClient);

    if (!pmgClient->userAttached)
    {
        TRACE_OUT(("MG_TokenGrab:  client 0x%08x not attached", pmgClient));
        rc = NET_RC_MGC_INVALID_USER_HANDLE;
        DC_QUIT;
    }


    //
    // MCAT may bounce this request, so instead of processing it straight
    // away, we put it on the user's request queue and kick off a process
    // queue loop:
    //
    rc = MGNewBuffer(pmgClient, MG_RQ_TOKEN_GRAB, &pmgBuffer);
    if (rc != 0)
    {
        WARNING_OUT(("MGNewBuffer failed in MG_TokenGrab"));
        DC_QUIT;
    }

    pmgBuffer->channelId = (ChannelID)tokenID;

    COM_BasedListInsertBefore(&(pmgClient->pendChain), &(pmgBuffer->pendChain));

    UT_PostEvent(pmgClient->putTask,
                      pmgClient->putTask,
                      NO_DELAY,
                      NET_MG_SCHEDULE,
                      0,
                      0);

DC_EXIT_POINT:

    UT_Unlock(UTLOCK_T120);

    DebugExitDWORD(MG_TokenGrab, rc);
    return(rc);
}




//
// MG_TokenInhibit(...)
//
UINT MG_TokenInhibit
(
    PMG_CLIENT      pmgClient,
    NET_TOKEN_ID    tokenID
)
{
    PMG_BUFFER      pmgBuffer;
    UINT            rc = 0;

    DebugEntry(MG_TokenInhibit);

    UT_Lock(UTLOCK_T120);

    ValidateMGClient(pmgClient);

    if (!pmgClient->userAttached)
    {
        TRACE_OUT(("MG_TokenInhibit:  client 0x%08x not attached", pmgClient));
        rc = NET_RC_MGC_INVALID_USER_HANDLE;
        DC_QUIT;
    }

    //
    // MCAT may bounce this request, so instead of processing it straight
    // away, we put it on the user's request queue and kick off a process
    // queue loop:
    //
    rc = MGNewBuffer(pmgClient, MG_RQ_TOKEN_INHIBIT, &pmgBuffer);
    if (rc != 0)
    {
        WARNING_OUT(("MGNewBuffer failed in MG_TokenInhibit"));
        DC_QUIT;
    }

    pmgBuffer->channelId = (ChannelID)tokenID;

    COM_BasedListInsertBefore(&(pmgClient->pendChain), &(pmgBuffer->pendChain));

    UT_PostEvent(pmgClient->putTask,
                      pmgClient->putTask,
                      NO_DELAY,
                      NET_MG_SCHEDULE,
                      0,
                      0);

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_T120);

    DebugExitDWORD(MG_TokenInhibit, rc);
    return(rc);
}



//
// MG_GetBuffer(...)
//
UINT MG_GetBuffer
(
    PMG_CLIENT          pmgClient,
    UINT                length,
    NET_PRIORITY        priority,
    NET_CHANNEL_ID      channel,
    void **             ppData
)
{
    PMG_BUFFER          pmgBuffer;
    UINT                rc;

    DebugEntry(MG_GetBuffer);

    UT_Lock(UTLOCK_T120);

    ValidateMGClient(pmgClient);

    if (!pmgClient->userAttached)
    {
        TRACE_OUT(("MG_GetBuffer:  client 0x%08x not attached", pmgClient));
        rc = NET_RC_MGC_INVALID_USER_HANDLE;
        DC_QUIT;
    }

    //
    // Ensure we have a priority which is valid for our use of MCS.
    //
    priority = (NET_PRIORITY)(MG_VALID_PRIORITY(priority));

    //
    // Obtain a buffer and store the info in a buffer CB hung off the
    // client's list:
    //
    rc = MGNewTxBuffer(pmgClient, priority, channel, length,
                     &pmgBuffer);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // We always return a pointer to the data buffer to an application.
    // The MG packet header is only used when giving data to MCS or
    // receiving data from MCS.
    //
    *ppData = pmgBuffer->pDataBuffer;

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_T120);

    DebugExitDWORD(MG_GetBuffer, rc);
    return(rc);
}



//
// MG_FreeBuffer(...)
//
void MG_FreeBuffer
(
    PMG_CLIENT      pmgClient,
    void **         ppData
)
{
    PMG_BUFFER      pmgBuffer;

    DebugEntry(MG_FreeBuffer);

    UT_Lock(UTLOCK_T120);

    ValidateMGClient(pmgClient);

    //
    // Find the buffer CB associated with the buffer - an application
    // always uses a pointer to the data buffer rather than the packet
    // header.
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pmgClient->buffers),
            (void**)&pmgBuffer, FIELD_OFFSET(MG_BUFFER, clientChain),
            FIELD_OFFSET(MG_BUFFER, pDataBuffer), (DWORD_PTR)*ppData,
            FIELD_SIZE(MG_BUFFER, pDataBuffer));

    ValidateMGBuffer(pmgBuffer);

    //
    // If the app is freeing a send buffer (e.g.  because it decided not to
    // send it) then inform flow control:
    //
    if (pmgBuffer->type == MG_TX_BUFFER)
    {
        FLO_ReallocSend(pmgClient,
                        pmgBuffer->pStr,
                        pmgBuffer->length);
    }

    //
    // Now free the buffer CB and all associated data:
    //
    MGFreeBuffer(pmgClient, &pmgBuffer);

    //
    // Reset the client's pointer:
    //
    *ppData = NULL;

    UT_Unlock(UTLOCK_T120);

    DebugExitVOID(MG_FreeBuffer);
}




//
// MG_FlowControlStart
//
void MG_FlowControlStart
(
    PMG_CLIENT      pmgClient,
    NET_CHANNEL_ID  channel,
    NET_PRIORITY    priority,
    UINT            backlog,
    UINT            maxBytesOutstanding
)
{
    DebugEntry(MG_FlowControlStart);

    ValidateMGClient(pmgClient);
    if (!pmgClient->userAttached)
    {
        TRACE_OUT(("MG_FlowControlStart:  client 0x%08x not attached", pmgClient));
        DC_QUIT;
    }

    //
    // Ensure we have a priority which is valid for our use of MCS.
    //
    priority = (NET_PRIORITY)(MG_VALID_PRIORITY(priority));

    FLO_StartControl(pmgClient,
                     channel,
                     priority,
                     backlog,
                     maxBytesOutstanding);

DC_EXIT_POINT:
    DebugExitVOID(MG_FlowControlStart);
}




//
// MGLongStopHandler(...)
//
BOOL CALLBACK MGLongStopHandler
(
    LPVOID      pData,
    UINT        event,
    UINT_PTR    UNUSEDparam1,
    UINT_PTR    param2
)
{
    PMG_CLIENT  pmgClient;
    BOOL        processed = FALSE;

    DebugEntry(MGLongStopHandler);

    pmgClient = (PMG_CLIENT)pData;
    ValidateMGClient(pmgClient);

    if (event == NET_EVENT_CHANNEL_JOIN)
    {
        WARNING_OUT(("Failed to process NET_EVENT_CHANNEL_JOIN; freeing buffer 0x%08x",
            param2));
        MG_FreeBuffer(pmgClient, (void **)&param2);

        processed = TRUE;
    }
    else if (event == NET_FLOW)
    {
        WARNING_OUT(("Failed to process NET_FLOW; freeing buffer 0x%08x",
            param2));
        processed = TRUE;
    }

    DebugExitBOOL(MGLongStopHandler, processed);
    return(processed);
}




//
// MGEventHandler(...)
//
BOOL CALLBACK MGEventHandler
(
    LPVOID              pData,
    UINT                event,
    UINT_PTR            param1,
    UINT_PTR            param2
)
{
    PMG_CLIENT          pmgClient;
    PNET_JOIN_CNF_EVENT pNetJoinCnf = NULL;
    BOOL                processed = TRUE;
    PMG_BUFFER          pmgBuffer;
    BOOL                joinComplete = FALSE;
    UINT                result = NET_RESULT_USER_REJECTED;

    DebugEntry(MGEventHandler);

    pmgClient = (PMG_CLIENT)pData;
    ValidateMGClient(pmgClient);

    switch (event)
    {
        case NET_EVENT_CHANNEL_JOIN:
        {
            //
            // If there are no join requests queued off the client CB then
            // we have nothing more to do.  The only NET events we are
            // interested in are NET_EV_JOIN_CONFIRM events - pass any others
            // on.
            //
            if (pmgClient->joinChain.next == 0)
            {
                //
                // Pass the event on...
                //
                processed = FALSE;
                DC_QUIT;
            }

            //
            // We must be careful not to process a completed channel join
            // which we intend to go to the client.  The correlator is only
            // filled in on completed events and is always non-zero.
            //
            pNetJoinCnf = (PNET_JOIN_CNF_EVENT)param2;

            if (pNetJoinCnf->correlator != 0)
            {
                //
                // Pass the event on...
                //
                processed = FALSE;
                DC_QUIT;
            }

            //
            // There is only ever one join request outstanding per client,
            // so the join confirm is for the first join request in the
            // list.
            //
            pmgBuffer = (PMG_BUFFER)COM_BasedListFirst(&(pmgClient->joinChain),
                FIELD_OFFSET(MG_BUFFER, pendChain));

            ValidateMGBuffer(pmgBuffer);

            //
            // We will post a join confirm to the application.  Set up the
            // parameters which are needed.
            //
            result = pNetJoinCnf->result;

            //
            // Assume for now that we have completed the pending join
            // request.
            //
            joinComplete = TRUE;

            //
            // If the result is a failure, we've finished
            //
            if (result != NET_RESULT_OK)
            {
                WARNING_OUT(("Failed to join channel 0x%08x, result %u",
                            pmgBuffer->channelId,
                            pNetJoinCnf->result));
                DC_QUIT;
            }

            //
            // The join request was successful.  There are three different
            // scenarios for issuing a join request...
            //
            // (a) A regular channel join.
            // (b) Stage 1 of a channel join by key (get MCS to assign a
            //     channel number, which we will try to register).
            // (c) Stage 2 of a channel join by key (join the registered
            //     channel).
            //
            if (pmgBuffer->type == MG_RQ_CHANNEL_JOIN)
            {
                //
                // This is the completion of a regular channel join.  Copy
                // the channel Id from the join confirm to the bufferCB
                // (the join request may have been for channel 0).
                //
                pmgBuffer->channelId = (ChannelID)pNetJoinCnf->channel;
                TRACE_OUT(("Channel join complete, channel 0x%08x",
                       pmgBuffer->channelId));
                DC_QUIT;
            }

            //
            // This is channel join by key
            //
            if (pmgBuffer->channelId != 0)
            {
                //
                // This is the completion of a channel join by key.
                //
                TRACE_OUT(("Channel join by key complete, channel 0x%08x, key %d",
                       pmgBuffer->channelId,
                       pmgBuffer->channelKey));
                DC_QUIT;
            }

            //
            // This is Stage 1 of a channel join by key.  Fill in the
            // channel Id which MCS has assigned us into the bufferCB,
            // otherwise we'll lose track of the channel Id which we're
            // registering.
            //
            pmgBuffer->channelId = (ChannelID)pNetJoinCnf->channel;

            //
            // This must be completion of stage 1 of a join by key.  We now
            // have to register the channel Id.
            //
            TRACE_OUT(("Registering channel 0x%08x, key %d",
                   pmgBuffer->channelId,
                   pmgBuffer->channelKey));

            if (!CMS_ChannelRegister(pmgClient->pcmClient,
                                     pmgBuffer->channelKey,
                                     pmgBuffer->channelId))
            {
                WARNING_OUT(("Failed to register channel, "
                            "channel 0x%08x, key %d, result %u",
                            pmgBuffer->channelId,
                            pmgBuffer->channelKey,
                            param1));

                //
                // This causes us to post an error notification
                //
                result = NET_RESULT_USER_REJECTED;
                DC_QUIT;
            }

            TRACE_OUT(("Waiting for CMS_CHANNEL_REGISTER_CONFIRM"));

            //
            // We're now waiting for a CMS_CHANNEL_REGISTER_CONFIRM, so we
            // haven't finished processing the join request
            //
            joinComplete = FALSE;

            break;
        }

        case CMS_CHANNEL_REGISTER_CONFIRM:
        {
            //
            // If there are no join requests queued off the client CB then
            // we have nothing more to do.
            //
            if (pmgClient->joinChain.next == 0)
            {
                processed = FALSE;
                DC_QUIT;
            }

            TRACE_OUT(("CMS_CHANNEL_REGISTER rcvd, result %u, channel %u",
                  param1, param2));

            //
            // Assume for now that we have completed the pending join
            // request.
            //
            joinComplete = TRUE;

            //
            // There is only ever one join request outstanding per client,
            // so the channel register confirm is for the first join
            // request in the list.
            //
            pmgBuffer = (PMG_BUFFER)COM_BasedListFirst(&(pmgClient->joinChain),
                FIELD_OFFSET(MG_BUFFER, pendChain));

            ValidateMGBuffer(pmgBuffer);

            //
            // Param1 contains the result, LOWORD(param2) contains the
            // channel number of the registered channel (NOT necessarily
            // the same as the channel we tried to register).
            //
            if (!param1)
            {
                WARNING_OUT(("Failed to register channel, "
                            "channel 0x%08x, key %d, result %u",
                            pmgBuffer->channelId,
                            pmgBuffer->channelKey,
                            param1));
                result = NET_RESULT_USER_REJECTED;
                DC_QUIT;
            }

            //
            // If the channel number returned in the confirm event is the
            // same as the channel number which we tried to register, then
            // we have finished.  Otherwise we have to leave the channel we
            // tried to register and join the channel returned instead.
            //
            if (LOWORD(param2) == pmgBuffer->channelId)
            {
                TRACE_OUT(("Channel join by key complete, "
                       "channel 0x%08x, key %d",
                       pmgBuffer->channelId,
                       pmgBuffer->channelKey));
                result = NET_RESULT_OK;
                DC_QUIT;
            }

            MG_ChannelLeave(pmgClient, pmgBuffer->channelId);
            pmgBuffer->channelId = (ChannelID)LOWORD(param2);

            //
            // Now we simply requeue the request onto the pending execution
            // chain, but now with a set channel id to join
            //
            TRACE_OUT(("Inserting 0x%08x into pending chain",pmgBuffer));
            COM_BasedListRemove(&(pmgBuffer->pendChain));
            COM_BasedListInsertBefore(&(pmgClient->pendChain),
                                 &(pmgBuffer->pendChain));

            //
            // We are now waiting for a join confirm (we've not finished
            // yet !).  However, we've requeued the bufferCB, so we can now
            // process another join request (or the one we've requeued if
            // its the only one).
            //
            joinComplete           = FALSE;
            pmgClient->joinPending = FALSE;
            MGProcessPendingQueue(pmgClient);
            break;
        }

        case NET_MG_SCHEDULE:
        {
            MGProcessPendingQueue(pmgClient);
            break;
        }

        case NET_MG_WATCHDOG:
        {
            MGProcessDomainWatchdog(pmgClient);
            break;
        }

        default:
        {
            //
            // Don't do anything - we want to pass this event on.
            //
            processed = FALSE;
            break;
        }
    }

DC_EXIT_POINT:

    if (processed && pNetJoinCnf)
    {
        //
        // Call MG_FreeBuffer to free up the event memory (we know that
        // MG_FreeBuffer doesn't use the hUser so we pass in zero):
        //
        MG_FreeBuffer(pmgClient, (void **)&pNetJoinCnf);
    }

    if (joinComplete)
    {
        //
        // We have either completed the channel join, or failed -
        // either way we have finished processing the join request.
        //
        // We have to:
        //   - post a NET_EVENT_CHANNEL_JOIN event to the client
        //   - free up the bufferCB
        //   - reset the client's joinPending state
        //
        MGPostJoinConfirm(pmgClient,
                        (NET_RESULT)result,
                        pmgBuffer->channelId,
                        (NET_CHANNEL_ID)pmgBuffer->work);

        MGFreeBuffer(pmgClient, &pmgBuffer);
        pmgClient->joinPending = FALSE;
    }

    DebugExitBOOL(MGEventHandler, processed);
    return(processed);
}


//
// MGCallback(...)
//
#ifdef _DEBUG
const char * c_szMCSMsgTbl[22] =
{
    "MCS_CONNECT_PROVIDER_INDICATION", //			0
    "MCS_CONNECT_PROVIDER_CONFIRM", //				1
    "MCS_DISCONNECT_PROVIDER_INDICATION", //		2
    "MCS_ATTACH_USER_CONFIRM", //					3
    "MCS_DETACH_USER_INDICATION", //				4
    "MCS_CHANNEL_JOIN_CONFIRM", //					5
    "MCS_CHANNEL_LEAVE_INDICATION", //				6
    "MCS_CHANNEL_CONVENE_CONFIRM", //				7
    "MCS_CHANNEL_DISBAND_INDICATION", //			8
    "MCS_CHANNEL_ADMIT_INDICATION", //				9
    "MCS_CHANNEL_EXPEL_INDICATION", //				10
    "MCS_SEND_DATA_INDICATION", //					11
    "MCS_UNIFORM_SEND_DATA_INDICATION", //			12
    "MCS_TOKEN_GRAB_CONFIRM", //					13
    "MCS_TOKEN_INHIBIT_CONFIRM", //					14
    "MCS_TOKEN_GIVE_INDICATION", //					15
    "MCS_TOKEN_GIVE_CONFIRM", //					16
    "MCS_TOKEN_PLEASE_INDICATION", //				17
    "MCS_TOKEN_RELEASE_CONFIRM", //					18
    "MCS_TOKEN_TEST_CONFIRM", //					19
    "MCS_TOKEN_RELEASE_INDICATION", //				20
    "MCS_TRANSMIT_BUFFER_AVAILABLE_INDICATION", //	21
};
// MCS_MERGE_DOMAIN_INDICATION					200
// MCS_TRANSPORT_STATUS_INDICATION				101

char * DbgGetMCSMsgStr(unsigned short mcsMessageType)
{
    if (mcsMessageType <= 21)
    {
        return (char *) c_szMCSMsgTbl[mcsMessageType];
    }
#ifdef USE_MERGE_DOMAIN_CODE
    else if (mcsMessageType == MCS_MERGE_DOMAIN_INDICATION)
    {
        return "MCS_MERGE_DOMAIN_INDICATION";
    }
#endif // USE_MERGE_DOMAIN_CODE
    else if (mcsMessageType == MCS_TRANSPORT_STATUS_INDICATION)
    {
        return "MCS_TRANSPORT_STATUS_INDICATION";
    }
    return "Unknown";
}
#endif // _DEBUG


void CALLBACK MGCallback
(
    unsigned int          	mcsMessageType,
    unsigned long           eventData,
    unsigned long           pData
)
{
    PMG_CLIENT              pmgClient;
    PMG_BUFFER              pmgBuffer;
    UINT                    rc =  0;

    DebugEntry(MGCallback);

    UT_Lock(UTLOCK_T120);

    pmgClient = (PMG_CLIENT)pData;
    ValidateMGClient(pmgClient);

    if (!pmgClient->userAttached)
    {
        TRACE_OUT(("MGCallback:  client 0x%08x not attached", pmgClient));
        DC_QUIT;
    }

    ValidateCMP(g_pcmPrimary);

    switch (mcsMessageType)
    {
        case MCS_UNIFORM_SEND_DATA_INDICATION:
        case MCS_SEND_DATA_INDICATION:
        {
            //
            // The processing for a SEND_DATA_INDICATION is complicated
            // significantly by MCS segmenting packets, so we call
            // MGHandleSendInd to do all the work , then quit out of the
            // function rather than special casing throughout.
            //
            rc = MGHandleSendInd(pmgClient, (PSendData)eventData);
            DC_QUIT;

            break;
        }

        case MCS_ATTACH_USER_CONFIRM:
        {
            NET_UID     user;
            NET_RESULT  result;

            user = LOWUSHORT(eventData);
            result = TranslateResult(HIGHUSHORT(eventData));

            //
            // If the attach did not succeed, clean up:
            //
            if (HIGHUSHORT(eventData) != RESULT_SUCCESSFUL)
            {
                WARNING_OUT(("MG_Attach failed; cleaning up"));
                MGDetach(pmgClient);
            }
            else
            {
                pmgClient->userIDMCS = user;

                //
                // Now initialize flow control for this user attachment
                //
                ZeroMemory(&(pmgClient->flo), sizeof(pmgClient->flo));
                pmgClient->flo.callBack = MGFLOCallBack;
            }

            UT_PostEvent(pmgClient->putTask, pmgClient->putTask, NO_DELAY,
                NET_EVENT_USER_ATTACH, MAKELONG(user, result),
                g_pcmPrimary->callID);

            break;
        }

        case MCS_DETACH_USER_INDICATION:
        {
            NET_UID     user;

            user = LOWUSHORT(eventData);

            //
            // If the detach is for the local user, then clean up
            // the user CB:
            //
            if (user == pmgClient->userIDMCS)
            {
                //
                // First terminate flow control
                //
                FLO_UserTerm(pmgClient);
                MGDetach(pmgClient);
            }
            else
            {
                //
                // Just remove the offending user from flow control
                //
                FLO_RemoveUser(pmgClient, user);
            }

            UT_PostEvent(pmgClient->putTask, pmgClient->putTask, NO_DELAY,
                NET_EVENT_USER_DETACH, user, g_pcmPrimary->callID);

            break;
        }

        case MCS_CHANNEL_JOIN_CONFIRM:
        {
            PNET_JOIN_CNF_EVENT pNetEvent;
            UINT i;

            //
            // Allocate a buffer for the event
            //
            rc = MGNewDataBuffer(pmgClient, MG_EV_BUFFER,
                sizeof(MG_INT_PKT_HEADER) + sizeof(NET_JOIN_CNF_EVENT), &pmgBuffer);
            if (rc != 0)
            {
                WARNING_OUT(("MGNewDataBuffer failed in MGCallback"));
                DC_QUIT;
            }

            pNetEvent = (PNET_JOIN_CNF_EVENT)pmgBuffer->pDataBuffer;

            //
            // Fill in the call ID:
            //
            pNetEvent->callID   = g_pcmPrimary->callID;
            pNetEvent->channel  = LOWUSHORT(eventData);
            pNetEvent->result   = TranslateResult(HIGHUSHORT(eventData));

            //
            // Now establish flow control for the newly joined channel
            // Only control priorities that have a non-zero latency
            // And remember to ignore our own user channel! And top priority.
            //
            if (HIGHUSHORT(eventData) == RESULT_SUCCESSFUL)
            {
                if (pNetEvent->channel != pmgClient->userIDMCS)
                {
                    for (i = 0; i < NET_NUM_PRIORITIES; i++)
                    {
                        if ((i == MG_VALID_PRIORITY(i)) &&
                            (pmgClient->flowControl.latency[i] != 0))
                        {
                            FLO_StartControl(pmgClient, pNetEvent->channel,
                                i, pmgClient->flowControl.latency[i],
                                pmgClient->flowControl.streamSize[i]);
                        }
                    }
                }
            }

            //
            // OK, we've built the DCG event so now post it to our client:
            //
            UT_PostEvent(pmgClient->putTask, pmgClient->putTask, NO_DELAY,
                NET_EVENT_CHANNEL_JOIN, 0, (UINT_PTR)pNetEvent);
            pmgBuffer->eventPosted = TRUE;

            break;
        }

        case MCS_CHANNEL_LEAVE_INDICATION:
        {
            NET_CHANNEL_ID  channel;

            channel = LOWUSHORT(eventData);
            MGProcessEndFlow(pmgClient, channel);

            UT_PostEvent(pmgClient->putTask, pmgClient->putTask, NO_DELAY,
                NET_EVENT_CHANNEL_LEAVE, channel, g_pcmPrimary->callID);

            break;
        }

        case MCS_TOKEN_GRAB_CONFIRM:
        {
            NET_RESULT  result;

            result = TranslateResult(HIGHUSHORT(eventData));
            UT_PostEvent(pmgClient->putTask, pmgClient->putTask, NO_DELAY,
                NET_EVENT_TOKEN_GRAB, result, g_pcmPrimary->callID);

            break;
        }

        case MCS_TOKEN_INHIBIT_CONFIRM:
        {
            NET_RESULT  result;

            result = TranslateResult(HIGHUSHORT(eventData));
            UT_PostEvent(pmgClient->putTask, pmgClient->putTask, NO_DELAY,
                NET_EVENT_TOKEN_INHIBIT, result, g_pcmPrimary->callID);

            break;
        }

        default:
            break;
    }


    UT_PostEvent(pmgClient->putTask, pmgClient->putTask, NO_DELAY,
        NET_MG_SCHEDULE, 0, 0);

DC_EXIT_POINT:
    if (rc != 0)
    {
        //
        // We hit an error, but must return OK to MCS - otherwise it will
        // keep sending us the callback forever!
        //
        WARNING_OUT(("MGCallback: Error 0x%08x processing MCS message %u",
            rc, mcsMessageType));
    }

    UT_Unlock(UTLOCK_T120);

    DebugExitDWORD(MGCallback, MCS_NO_ERROR);
}




//
// ProcessEndFlow(...)
//
void MGProcessEndFlow
(
    PMG_CLIENT      pmgClient,
    ChannelID       channel
)
{
    UINT            i;

    DebugEntry(MGProcessEndFlow);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    //
    // Terminate flow control for the newly left channel
    //
    if (channel != pmgClient->userIDMCS)
    {
        for (i = 0; i < NET_NUM_PRIORITIES; i++)
        {
            if ((i == MG_VALID_PRIORITY(i)) &&
                (pmgClient->flowControl.latency[i] != 0))
            {
                TRACE_OUT(("Ending flow control on channel 0x%08x priority %u",
                    channel, i));

                FLO_EndControl(pmgClient, channel, i);
            }
        }
    }

    DebugExitVOID(MGProcessEndFlow);
}




//
// MGHandleSendInd(...)
//
UINT MGHandleSendInd
(
    PMG_CLIENT          pmgClient,
    PSendData           pSendData
)
{
    PMG_BUFFER          pmgBuffer;
    PNET_SEND_IND_EVENT pEvent;
    NET_PRIORITY        priority;
    LPBYTE              pData;
    UINT                cbData;
    UINT                rc = 0;
    TSHR_NET_PKT_HEADER pktHeader;

    DebugEntry(MGHandleSendInd);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    priority = (NET_PRIORITY)MG_VALID_PRIORITY(
            (NET_PRIORITY)pSendData->data_priority);

    pData = pSendData->user_data.value;
    ASSERT(pData != NULL);
    cbData = pSendData->user_data.length;
    ASSERT(cbData > sizeof(TSHR_NET_PKT_HEADER));

    TRACE_OUT(("MCS Data Indication: flags 0x%08x, size %u, first dword 0x%08x",
        pSendData->segmentation, pSendData->user_data.length,
        *((DWORD *)pData)));

    ASSERT (pSendData->segmentation == (SEGMENTATION_BEGIN | SEGMENTATION_END));

    TRACE_OUT(("Only segment: channel %u, priority %u, length %u",
        pSendData->channel_id, pSendData->data_priority, cbData));

    //
    // Look at the header
    //
    memcpy(&pktHeader, pData, sizeof(TSHR_NET_PKT_HEADER));

    //
    // Trace out the MG header word
    //
    TRACE_OUT(("Got 1st MG segment (header=%X)", pktHeader.pktLength));

    //
    // First of all try for a flow control packet
    //
    if (pktHeader.pktLength & TSHR_PKT_FLOW)
    {
        TRACE_OUT(("Flow control packet"));
        if (pktHeader.pktLength == TSHR_PKT_FLOW)
        {
            FLO_ReceivedPacket(pmgClient,
                (PTSHR_FLO_CONTROL)(pData + sizeof(TSHR_NET_PKT_HEADER)));
        }
        else
        {
            WARNING_OUT(("Received obsolete throughput packet size 0x%04x", pktHeader.pktLength));
        }

        pmgClient->m_piMCSSap->FreeBuffer((PVoid) pData);
        DC_QUIT;        											
    }

    //
    // Allocate headers for the incoming buffer.
    //
    //
    ASSERT((sizeof(NET_SEND_IND_EVENT) + pktHeader.pktLength) <= 0xFFFF);
    ASSERT(pktHeader.pktLength == cbData);

    rc = MGNewRxBuffer(pmgClient,
                       priority,
                       pSendData->channel_id,
                       pSendData->initiator,
                       &pmgBuffer);
    if (rc != 0)
    {
        WARNING_OUT(("MGNewRxBuffer of size %u failed",
        			sizeof(NET_SEND_IND_EVENT) + sizeof(MG_INT_PKT_HEADER)));
        pmgClient->m_piMCSSap->FreeBuffer((PVoid) pData);
        DC_QUIT;
    }

    pEvent = (PNET_SEND_IND_EVENT) pmgBuffer->pDataBuffer;

    ValidateCMP(g_pcmPrimary);

    pEvent->callID          = g_pcmPrimary->callID;
    pEvent->priority        = priority;
    pEvent->channel         = pSendData->channel_id;

    //
    // Copy the length into the data buffer header.
    //
    pmgBuffer->pPktHeader->header = pktHeader;

    //
    // We want to skip past the packet header to the user data
    //
    pData += sizeof(TSHR_NET_PKT_HEADER);
    cbData -= sizeof(TSHR_NET_PKT_HEADER);

    //
    // Set the pointer in the buffer header to point to the received data.
    //
    // pEvent->lengthOfData contains the number of bytes received in this
    // event so far.
    //
    ASSERT(pData);
    pEvent->data_ptr        = pData;
    pEvent->lengthOfData    = cbData;

    TRACE_OUT(("New RX pmgBuffer 0x%08x pDataBuffer 0x%08x",
        pmgBuffer, pEvent));

    //
    // OK, we've got all the segments, so post it to our client:
    //
    UT_PostEvent(pmgClient->putTask, pmgClient->putTask, NO_DELAY,
        NET_EVENT_DATA_RECEIVED, 0, (UINT_PTR)pEvent);
    pmgBuffer->eventPosted = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(MGHandleSendInd, rc);
    return(rc);
}




//
// MGNewBuffer(...)
//
UINT MGNewBuffer
(
    PMG_CLIENT          pmgClient,
    UINT                bufferType,
    PMG_BUFFER *        ppmgBuffer
)
{
    PMG_BUFFER          pmgBuffer;
    void *              pBuffer = NULL;
    UINT                rc = 0;

    DebugEntry(MGNewBuffer);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    pmgBuffer = new MG_BUFFER;
    if (!pmgBuffer)
    {
        WARNING_OUT(("MGNewBuffer failed; out of memory"));
        rc = NET_RC_NO_MEMORY;
        DC_QUIT;
    }
    ZeroMemory(pmgBuffer, sizeof(*pmgBuffer));

    SET_STAMP(pmgBuffer, MGBUFFER);
    pmgBuffer->type         = bufferType;

    //
    // Insert it at the head of this client's list of allocated buffers:
    //
    COM_BasedListInsertAfter(&(pmgClient->buffers), &(pmgBuffer->clientChain));

    //
    // return the pointer
    //
    *ppmgBuffer = pmgBuffer;

DC_EXIT_POINT:
    DebugExitDWORD(MGNewBuffer, rc);
    return(rc);
}



//
// MGNewDataBuffer(...)
//
UINT MGNewDataBuffer
(
    PMG_CLIENT          pmgClient,
    UINT                bufferType,
    UINT                bufferSize,
    PMG_BUFFER *        ppmgBuffer
)
{
    void *              pBuffer = NULL;
    PMG_BUFFER          pmgBuffer;
    UINT                rc = 0;

    DebugEntry(MGNewDataBuffer);

    //
    // Buffers include an MG internal packet header that has a length field
    // which we add to the start of all user data passed to/received from
    // MCS.  This is four byte aligned, and since the data buffer starts
    // immediately after this, the data buffer will be aligned.
    //
    pBuffer = new BYTE[bufferSize];
    if (!pBuffer)
    {
        WARNING_OUT(("MGNewDataBuffer allocation of size %u failed", bufferSize));
        rc = NET_RC_NO_MEMORY;
        DC_QUIT;
    }
    ZeroMemory(pBuffer, bufferSize);

    //
    // Now we allocate the buffer CB which we will use to track the use of
    // the buffer.
    //
    rc = MGNewBuffer(pmgClient, bufferType, ppmgBuffer);
    if (rc != 0)
    {
        WARNING_OUT(("MGNewBuffer failed"));
        DC_QUIT;
    }

    //
    // Initialise the buffer entry
    //
    pmgBuffer = *ppmgBuffer;

    pmgBuffer->length      = bufferSize;
    pmgBuffer->pPktHeader  = (PMG_INT_PKT_HEADER)pBuffer;
    pmgBuffer->pDataBuffer = (LPBYTE)pBuffer + sizeof(MG_INT_PKT_HEADER);

    //
    // Initialize the use count of the data buffer
    //
    pmgBuffer->pPktHeader->useCount = 1;

DC_EXIT_POINT:

    if (rc != 0)
    {
        //
        // Cleanup:
        //
        if (pBuffer != NULL)
        {
            WARNING_OUT(("Freeing MG_BUFFER data 0x%08x; MGNewBuffer failed", pBuffer));
            delete[] pBuffer;
        }
    }

    DebugExitDWORD(MGNewDataBuffer, rc);
    return(rc);
}




//
// MGNewTxBuffer(...)
//
UINT MGNewTxBuffer
(
    PMG_CLIENT          pmgClient,
    NET_PRIORITY        priority,
    NET_CHANNEL_ID      channel,
    UINT                bufferSize,
    PMG_BUFFER *        ppmgBuffer
)
{
    int                 i;
    UINT                numPrioritiesToUse;
    UINT                rc = 0;
    UINT                nextPriority;
    PMG_BUFFER          pmgBufferArray[MG_NUM_PRIORITIES];
    PFLO_STREAM_DATA    pStr[MG_NUM_PRIORITIES];
    NET_PRIORITY        priorities[MG_NUM_PRIORITIES];

    DebugEntry(MGNewTxBuffer);

    ValidateMGClient(pmgClient);
    ASSERT(priority != NET_TOP_PRIORITY);

    //
    // Initialise the control buffer pointer array.  The first member of
    // this array is the normal buffer which is allocated regardless of the
    // NET_SEND_ALL_PRIORITIES flag.  The remaining members are used for
    // duplicate control buffer pointers needed for sending data on all
    // priorities.
    //
    ZeroMemory(pmgBufferArray, sizeof(pmgBufferArray));
    ZeroMemory(pStr, sizeof(pStr));

    //
    // SFR6025: Check for the NET_SEND_ALL_PRIORITIES flag.  This means
    //          that the data will be sent at all four priorities.  If it
    //          is not set then we just need to send data at one priority.
    //          In either case we need to:
    //
    //          Check with flow control that it is possible to send data on
    //          all channels
    //
    //          Allocate an additional three control blocks which all point
    //          to the same data block and bump up the usage count.
    //
    //
    //  NOTE:   Previously this function just checked with flow control for
    //          a single channel.
    //
    if (priority & NET_SEND_ALL_PRIORITIES)
    {
        numPrioritiesToUse = MG_NUM_PRIORITIES;
    }
    else
    {
        numPrioritiesToUse = 1;
    }

    //
    // Disable the flag to prevent FLO_AllocSend being sent an invalid
    // priority.
    //
    priority &= ~NET_SEND_ALL_PRIORITIES;

    nextPriority = priority;
    for (i = 0; i < (int) numPrioritiesToUse; i++)
    {
        //
        // Check with flow control to ensure that send space is available.
        // Start with the requested priority level and continue for the
        // other priority levels.
        //
        priorities[i] = (NET_PRIORITY)nextPriority;
        rc = FLO_AllocSend(pmgClient,
                           nextPriority,
                           channel,
                           bufferSize + sizeof(MG_INT_PKT_HEADER),
                           &(pStr[i]));

        //
        // If we have got back pressure then just return.
        //
        if (rc != 0)
        {
            TRACE_OUT(("Received back pressure"));

            //
            // Free any buffer space allocated by FLO_AllocSend.
            //
            for ( --i; i >= 0; i--)
            {
                FLO_ReallocSend(pmgClient,
                                pStr[i],
                      bufferSize + sizeof(MG_INT_PKT_HEADER));
            }

            DC_QUIT;
        }

        ValidateFLOStr(pStr[i]);

        //
        // Move on to the next priority level. There are MG_NUM_PRIORITY
        // levels, numbered contiguously from MG_PRIORITY_HIGHEST.  The
        // first priority processed can be any level in the valid range so
        // rather than simply add 1 to get to the next level, we need to
        // cope with the wrap-around back to MG_PRIORITY_HIGHEST when we
        // have just processed the last priority, ie MG_PRIORITY_HIGHEST +
        // MG_NUM_PRIORITIES - 1. This is achieved by rebasing the priority
        // level to zero (the - MG_PRIORITY_HIGHEST, below), incrementing
        // the rebased priority (+1), taking the modulus of the number of
        // priorities to avoid exceeding the limit (% MG_NUM_PRIORITIES)
        // and then restoring the base by adding back the first priority
        // level (+ MG_PRIORITY_HIGHEST).
        //
        nextPriority = (((nextPriority + 1 - MG_PRIORITY_HIGHEST) %
                                    MG_NUM_PRIORITIES) + MG_PRIORITY_HIGHEST);
    }

    //
    // Use MGNewDataBuffer to allocate the buffer
    //
    rc = MGNewDataBuffer(pmgClient,
                       MG_TX_BUFFER,
                       bufferSize + sizeof(MG_INT_PKT_HEADER),
                       &pmgBufferArray[0]);

    if (rc != 0)
    {
        WARNING_OUT(("MGNewDataBuffer failed in MGNewTxBuffer"));
        DC_QUIT;
    }

    //
    // Add the fields required for doing the send
    //
    pmgBufferArray[0]->priority  = priority;
    pmgBufferArray[0]->channelId = (ChannelID) channel;
    pmgBufferArray[0]->senderId  = pmgClient->userIDMCS;

    ValidateFLOStr(pStr[0]);
    pmgBufferArray[0]->pStr      = pStr[0];

    //
    // Now allocate an additional three control blocks which are identical
    // to the first one if required.
    //
    if (numPrioritiesToUse > 1)
    {
        //
        // Firstly re-enable the NET_SEND_ALL_PRIORITIES flag.  This is to
        // ensure that traversing the linked list in MG_SendData is
        // efficient.
        //
        pmgBufferArray[0]->priority |= NET_SEND_ALL_PRIORITIES;

        //
        // Create the duplicate buffers and initialise them.
        //
        for (i = 1; i < MG_NUM_PRIORITIES; i++)
        {
            TRACE_OUT(("Task allocating extra CB, priority %u",
                        priorities[i]));

            //
            // Allocate a new control buffer.
            //
            rc = MGNewBuffer(pmgClient,
                             MG_TX_BUFFER,
                             &pmgBufferArray[i]);

            if (rc != 0)
            {
                WARNING_OUT(("MGNewBuffer failed"));
                DC_QUIT;
            }

            //
            // Initialise the buffer control block.  The priority values of
            // these control blocks are in increasing order from that of
            // pmgBuffer.
            //
            pmgBufferArray[i]->priority    = priorities[i];
            pmgBufferArray[i]->channelId   = pmgBufferArray[0]->channelId;
            pmgBufferArray[i]->senderId    = pmgBufferArray[0]->senderId;
            pmgBufferArray[i]->length      = pmgBufferArray[0]->length;
            pmgBufferArray[i]->pPktHeader  = pmgBufferArray[0]->pPktHeader;
            pmgBufferArray[i]->pDataBuffer = pmgBufferArray[0]->pDataBuffer;

            ValidateFLOStr(pStr[i]);
            pmgBufferArray[i]->pStr        = pStr[i];

            //
            // Set the NET_SEND_ALL_PRIORITIES flag.
            //
            pmgBufferArray[i]->priority |= NET_SEND_ALL_PRIORITIES;

            //
            // Now bump up the usage count of the data block.
            //
            pmgBufferArray[i]->pPktHeader->useCount++;

            TRACE_OUT(("Use count of data buffer %#.8lx now %d",
                         pmgBufferArray[i]->pPktHeader,
                         pmgBufferArray[i]->pPktHeader->useCount));
        }
   }

   //
   // Assign the passed first control buffer allocated to the passed
   // control buffer parameter.
   //
   *ppmgBuffer = pmgBufferArray[0];

DC_EXIT_POINT:

    //
    // In the event of a problem we free any buffers that we have already
    // allocated.
    //
    if (rc != 0)
    {
        for (i = 0; i < MG_NUM_PRIORITIES; i++)
        {
            if (pmgBufferArray[i] != NULL)
            {
                TRACE_OUT(("About to free control buffer %u", i));
                MGFreeBuffer(pmgClient, &pmgBufferArray[i]);
            }
        }
    }

    DebugExitDWORD(MGNewTxBuffer, rc);
    return(rc);
}



//
// MGNewRxBuffer(...)
//
UINT MGNewRxBuffer
(
    PMG_CLIENT          pmgClient,
    NET_PRIORITY        priority,
    NET_CHANNEL_ID      channel,
    NET_CHANNEL_ID      senderID,
    PMG_BUFFER     *    ppmgBuffer
)
{
    UINT                rc = 0;

    DebugEntry(MGNewRxBuffer);

    ValidateMGClient(pmgClient);

    //
    // First tell flow control we need a buffer.
    // No back pressure may be applied here, but flow control uses this
    // notification to control responses to the sender.
    //
    // Note that we always use the sizes including the internal packet
    // header for flow control purposes.
    //
    FLO_AllocReceive(pmgClient,
                     priority,
                     channel,
                     senderID);

    //
    // Use MGNewDataBuffer to allocate the buffer.  bufferSize includes the
    // size of the network packet header (this comes over the wire), but
    // not the remainder of the internal packet header.
    //
    rc = MGNewDataBuffer(pmgClient,
                       MG_RX_BUFFER,
                       sizeof(NET_SEND_IND_EVENT) + sizeof(MG_INT_PKT_HEADER),
                       ppmgBuffer);

    //
    // Add the fields required for a receive buffer
    //
    if (rc == 0)
    {
        (*ppmgBuffer)->priority  = priority;
        (*ppmgBuffer)->channelId = (ChannelID)channel;
        (*ppmgBuffer)->senderId  = (ChannelID)senderID;
    }
    else
    {
        WARNING_OUT(("MGNewDataBuffer failed in MGNewRxBuffer"));
    }

    DebugExitDWORD(MGNewRxBuffer, rc);
    return(rc);
}



//
// MGFreeBuffer(...)
//
void MGFreeBuffer
(
    PMG_CLIENT          pmgClient,
    PMG_BUFFER       *  ppmgBuffer
)
{
    PMG_BUFFER          pmgBuffer;
    void *              pBuffer;

    DebugEntry(MGFreeBuffer);

    pmgBuffer = *ppmgBuffer;
    ValidateMGBuffer(pmgBuffer);

    //
    // If this is a receive buffer then we must first tell flow control
    // about the space available
    // This may trigger a pong, if we are waiting for the app to free up
    // some space
    //
    if (pmgBuffer->type == MG_RX_BUFFER)
    {
    	ASSERT (pmgBuffer->pPktHeader->useCount == 1);
        TRACE_OUT(("Free RX pmgBuffer 0x%08x", pmgBuffer));

        //
        // Do a sanity check on the client (there is a window where this
        // may have been freed).
        //
        if (!pmgClient->userAttached)
        {
            TRACE_OUT(("MGFreeBuffer:  client 0x%08x not attached", pmgClient));
        }
        else
        {
            FLO_FreeReceive(pmgClient,
                            pmgBuffer->priority,
                            pmgBuffer->channelId,
                            pmgBuffer->senderId);

            // Free the MCS buffer
        	if ((pmgBuffer->pPktHeader != NULL) && (pmgClient->m_piMCSSap != NULL))
            {
                ASSERT(pmgBuffer->pDataBuffer != NULL);
                ASSERT(((PNET_SEND_IND_EVENT)pmgBuffer->pDataBuffer)->data_ptr != NULL);

        		pmgClient->m_piMCSSap->FreeBuffer (
        				(PVoid) (((PNET_SEND_IND_EVENT) pmgBuffer->pDataBuffer)
        				->data_ptr - sizeof(TSHR_NET_PKT_HEADER)));

                TRACE_OUT(("MGFreeBuffer: Freed data_ptr for pmgBuffer 0x%08x pDataBuffer 0x%08x",
                    pmgBuffer, pmgBuffer->pDataBuffer));
                ((PNET_SEND_IND_EVENT)pmgBuffer->pDataBuffer)->data_ptr = NULL;
        	}
        }
    }

    //
    // Free the data buffer, if there is one present.  Note that this can
    // be referenced by more than one bufferCB, and so has a use count
    // which must reach zero before the buffer is freed.
    //
    if (pmgBuffer->pPktHeader != NULL)
    {
        ASSERT(pmgBuffer->pPktHeader->useCount != 0);

        pmgBuffer->pPktHeader->useCount--;

        TRACE_OUT(("Data buffer 0x%08x use count %d",
                     pmgBuffer->pPktHeader,
                     pmgBuffer->pPktHeader->useCount));

        if (pmgBuffer->pPktHeader->useCount == 0)
        {
            TRACE_OUT(("Freeing MG_BUFFER data 0x%08x; use count is zero", pmgBuffer->pPktHeader));

            delete[] pmgBuffer->pPktHeader;
            pmgBuffer->pPktHeader = NULL;
        }
    }

    //
    // If the buffer CB is in the pending queue then remove it first!
    //
    if (pmgBuffer->pendChain.next != 0)
    {
        COM_BasedListRemove(&(pmgBuffer->pendChain));
    }

    //
    // Now remove the buffer CB itself from the list and free it up:
    //
    COM_BasedListRemove(&(pmgBuffer->clientChain));

    delete pmgBuffer;
    *ppmgBuffer = NULL;

    DebugExitVOID(MGFreeBuffer);
}





//
// MGDetach(...)
//
void MGDetach
(
    PMG_CLIENT      pmgClient
)
{
    PMG_BUFFER      pmgBuffer;
    PMG_BUFFER      pmgT;
    PIMCSSap		pMCSSap;
#ifdef _DEBUG
	UINT			rc;
#endif // _DEBUG

    DebugEntry(MGDetach);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

	pMCSSap = pmgClient->m_piMCSSap;
    //
    // Remove any entries for this user from the channel join pending list.
    //
    pmgBuffer = (PMG_BUFFER)COM_BasedListFirst(&(pmgClient->joinChain),
        FIELD_OFFSET(MG_BUFFER, pendChain));
    while (pmgBuffer != NULL)
    {
        ValidateMGBuffer(pmgBuffer);

        //
        // Get a pointer to the next bufferCB in the list - we have to do
        // this before we free the current bufferCB (freeing it NULLs it,
        // so we won't be able to step along to the next entry in the
        // list).
        //
        pmgT = (PMG_BUFFER)COM_BasedListNext(&(pmgClient->joinChain), pmgBuffer,
            FIELD_OFFSET(MG_BUFFER, pendChain));

        MGFreeBuffer(pmgClient, &pmgBuffer);

        //
        // We won't get a match on a join request now, so we don't have
        // a join pending.
        //
        pmgClient->joinPending = FALSE;

        pmgBuffer = pmgT;
    }

    //
    // Remove any unsent receive buffers for this user from the buffer list
    //
    pmgBuffer = (PMG_BUFFER)COM_BasedListFirst(&(pmgClient->buffers),
        FIELD_OFFSET(MG_BUFFER, clientChain));
    while (pmgBuffer != NULL)
    {
        ValidateMGBuffer(pmgBuffer);

        //
        // Get a pointer to the next bufferCB in the list - we have to do
        // this before we free the current bufferCB (freeing it NULLs it,
        // so we won't be able to step along to the next entry in the
        // list).
        //
        pmgT = (PMG_BUFFER)COM_BasedListNext(&(pmgClient->buffers), pmgBuffer,
            FIELD_OFFSET(MG_BUFFER, clientChain));

		if (pmgBuffer->type == MG_RX_BUFFER)
        {
	        if (pmgBuffer->eventPosted)
            {
	        	if ((pmgBuffer->pPktHeader != NULL) && (pMCSSap != NULL))
                {
                    ASSERT(pmgBuffer->pDataBuffer != NULL);
                    ASSERT(((PNET_SEND_IND_EVENT)pmgBuffer->pDataBuffer)->data_ptr != NULL);

		        	pMCSSap->FreeBuffer (
        					(PVoid) (((PNET_SEND_IND_EVENT) pmgBuffer->pDataBuffer)
        					->data_ptr - sizeof(TSHR_NET_PKT_HEADER)));

                    TRACE_OUT(("MGDetach: Freed data_ptr for pmgBuffer 0x%08x pDataBuffer 0x%08x",
                        pmgBuffer, pmgBuffer->pDataBuffer));
                    ((PNET_SEND_IND_EVENT) pmgBuffer->pDataBuffer)->data_ptr = NULL;
		        }
	        }
	        else
            {
		        //
		        // The bufferCB's user matches the user we are freeing up,
		        // and we haven't posted the event to the user, so free it.
		        // MGFreeBuffer removes it from the pending list, so we don't
		        // have to do that.
		        //
		        MGFreeBuffer(pmgClient, &pmgBuffer);
		    }
        }

        pmgBuffer = pmgT;
    }

    //
    // Clear out the attachment info
    //
    pmgClient->userAttached = FALSE;
    pmgClient->userIDMCS = 0;

    //
    // We can safely do an MCS DetachRequest without adding a requestCB
    // - MCS will not bounce the request due to congestion, domain merging
    // etc.
    //
    if (pMCSSap != NULL)
    {
#ifdef _DEBUG
	    rc = pMCSSap->ReleaseInterface();
	    if (rc != 0) {
	        //
	        // No quit - we need to do our own cleanup.
	        //
	        // lonchanc: what cleanup needs to be done???
	        //
	        rc = McsErrToNetErr(rc);

	        switch (rc)
	        {
	            case 0:
	            case NET_RC_MGC_INVALID_USER_HANDLE:
	            case NET_RC_MGC_TOO_MUCH_IN_USE:
	                // These are normal.
	                TRACE_OUT(("MCSDetachUser normal error %d", rc));
	                break;

	            default:
	                ERROR_OUT(("MCSDetachUser abnormal error %d", rc));
	                break;

	        }
	    }
#else
		pMCSSap->ReleaseInterface();
#endif //_DEBUG

		pmgClient->m_piMCSSap = NULL;
	}

    --g_mgAttachCount;

    DebugExitVOID(MGDetach);
}


//
// MGProcessPendingQueue(...)
//
UINT MGProcessPendingQueue(PMG_CLIENT pmgClient)
{
    PMG_BUFFER      pmgBuffer;
    PMG_BUFFER      pNextBuffer;
    UINT            rc = 0;

    DebugEntry(MGProcessPendingQueue);

    ValidateMGClient(pmgClient);

    pNextBuffer = (PMG_BUFFER)COM_BasedListFirst(&(pmgClient->pendChain),
        FIELD_OFFSET(MG_BUFFER, pendChain));

    //
    // Try and clear all the pending request queue
    //
    for ( ; (pmgBuffer = pNextBuffer) != NULL; )
    {
        ValidateMGBuffer(pmgBuffer);

        pNextBuffer = (PMG_BUFFER)COM_BasedListNext(&(pmgClient->pendChain),
            pNextBuffer, FIELD_OFFSET(MG_BUFFER, pendChain));

        TRACE_OUT(("Got request 0x%08x from queue, type %u",
                   pmgBuffer, pmgBuffer->type));

        //
        // Check that the buffer is still valid.  There is a race at
        // conference termination where we can arrive here, but our user
        // has actually already detached.  In this case, free the buffer
        // and continue.
        //
        if (!pmgClient->userAttached)
        {
            TRACE_OUT(("MGProcessPendingQueue:  client 0x%08x not attached", pmgClient));
            MGFreeBuffer(pmgClient, &pmgBuffer);
            continue;
        }

        switch (pmgBuffer->type)
        {
            case MG_RQ_CHANNEL_JOIN:
            case MG_RQ_CHANNEL_JOIN_BY_KEY:
            {
                //
                // If this client already has a join outstanding, then skip
                // this request.
                //
                if (pmgClient->joinPending)
                {
                    //
                    // Break out of switch and goto next iteration of for()
                    //
                    continue;
                }

                pmgClient->joinPending = TRUE;

                //
                // Attempt the join
                //
                rc = pmgClient->m_piMCSSap->ChannelJoin(
                							(unsigned short) pmgBuffer->channelId);

                //
                // If the join failed then post an error back immediately
                //
                if (rc != 0)
                {
                    if ((rc != MCS_TRANSMIT_BUFFER_FULL) &&
                        (rc != MCS_DOMAIN_MERGING))
                    {
                        //
                        // Something terminal went wrong - post a
                        // NET_EV_JOIN_CONFIRM (failed) to the client
                        //
                        MGPostJoinConfirm(pmgClient,
                            NET_RESULT_USER_REJECTED,
                            pmgBuffer->channelId,
                            (NET_CHANNEL_ID)(pmgBuffer->work));
                    }

                    pmgClient->joinPending = FALSE;
                }
                else
                {
                    //
                    // If the request worked then we must move it to the
                    // join queue for completion
                    //
                    TRACE_OUT(("Inserting 0x%08x into join queue",pmgBuffer));

                    COM_BasedListRemove(&(pmgBuffer->pendChain));
                    COM_BasedListInsertBefore(&(pmgClient->joinChain),
                                         &(pmgBuffer->pendChain));

                    //
                    // Do not free this buffer - continue processing the
                    // pending queue
                    //
                    continue;
                }
            }
            break;

            case MG_RQ_CHANNEL_LEAVE:
            {
                //
                // Try to leave the channel:
                //
                rc = pmgClient->m_piMCSSap->ChannelLeave(
		                              (unsigned short) pmgBuffer->channelId);

                if (rc == 0)
                {
                    MGProcessEndFlow(pmgClient,
                                   pmgBuffer->channelId);
                }
            }
            break;

            case MG_RQ_TOKEN_GRAB:
            {
                rc = pmgClient->m_piMCSSap->TokenGrab(pmgBuffer->channelId);
            }
            break;

            case MG_RQ_TOKEN_INHIBIT:
            {
                rc = pmgClient->m_piMCSSap->TokenInhibit(pmgBuffer->channelId);
            }
            break;

            case MG_RQ_TOKEN_RELEASE:
            {
                rc = pmgClient->m_piMCSSap->TokenRelease(pmgBuffer->channelId);
            }
            break;

            case MG_TX_BUFFER:
            {
                ASSERT(!(pmgBuffer->pPktHeader->header.pktLength & TSHR_PKT_FLOW));

                //
                // Send the data.  Remember that we don't send all of the
                // packet header, only from the length...
                //
                ASSERT((pmgBuffer->priority != NET_TOP_PRIORITY));
                rc = pmgClient->m_piMCSSap->SendData(NORMAL_SEND_DATA,
                                           pmgBuffer->channelId,
                                           (Priority)(pmgBuffer->priority),
                     (unsigned char *) 	   &(pmgBuffer->pPktHeader->header),
                                            pmgBuffer->pPktHeader->header.pktLength,
                                           APP_ALLOCATION);

                //
                // Check the return code.
                //
                if (rc == 0)
                {
                    //
                    // Update the allocation.  FLO_DecrementAlloc will
                    // check that the stream pointer is not null for us.
                    // (It will be null if flow control has ended on this
                    // channel since this buffer was allocated or if this
                    // is an uncontrolled channel).
                    //
                    // Note that for flow control purposes, we always use
                    // packet sizes including the internal packet header.
                    //
                    FLO_DecrementAlloc(pmgBuffer->pStr,
                        (pmgBuffer->pPktHeader->header.pktLength
                            - sizeof(TSHR_NET_PKT_HEADER) + sizeof(MG_INT_PKT_HEADER)));
                }
            }
            break;

            case MG_TX_PING:
            case MG_TX_PONG:
            case MG_TX_PANG:
            {
                //
                // This is the length of a ping/pong message:
                //
                ASSERT(pmgBuffer->priority != NET_TOP_PRIORITY);
                rc = pmgClient->m_piMCSSap->SendData(NORMAL_SEND_DATA,
                                           pmgBuffer->channelId,
                                           (Priority)(pmgBuffer->priority),
                     (unsigned char *)     &(pmgBuffer->pPktHeader->header),
                                            sizeof(TSHR_NET_PKT_HEADER) + sizeof(TSHR_FLO_CONTROL),
                                           APP_ALLOCATION);
            }
            break;
        }

        rc = McsErrToNetErr(rc);

        //
        // If the request failed due to back pressure then just get out
        // now.  We will try again later.
        //
        if (rc == NET_RC_MGC_TOO_MUCH_IN_USE)
        {
            TRACE_OUT(("MCS Back pressure"));
            break;
        }

        //
        // Only for obman...
        //
        if (pmgClient == &g_amgClients[MGTASK_OM])
        {
            ValidateCMP(g_pcmPrimary);

            //
            // For any other error or if everything worked so far
            // then tell the user to keep going
            //
            TRACE_OUT(("Posting NET_FEEDBACK"));
            UT_PostEvent(pmgClient->putTask,
                     pmgClient->putTask,
                     NO_DELAY,
                     NET_FEEDBACK,
                     0,
                     g_pcmPrimary->callID);
        }

        //
        // All is OK, or the request failed fatally.  In either case we
        // should free this request and attempt to continue.
        //
        MGFreeBuffer(pmgClient, &pmgBuffer);
    }

    DebugExitDWORD(MGProcessPendingQueue, rc);
    return(rc);
}



//
// MGPostJoinConfirm(...)
//
UINT MGPostJoinConfirm
(
    PMG_CLIENT          pmgClient,
    NET_RESULT          result,
    NET_CHANNEL_ID      channel,
    NET_CHANNEL_ID      correlator
)
{
    PNET_JOIN_CNF_EVENT pNetJoinCnf;
    PMG_BUFFER          pmgBuffer;
    UINT                rc;

    DebugEntry(MGPostJoinConfirm);

    ValidateMGClient(pmgClient);

    //
    // Allocate a buffer to send the event in - this should only fail if we
    // really are out of virtual memory.
    //
    rc = MGNewDataBuffer(pmgClient, MG_EV_BUFFER,
        sizeof(MG_INT_PKT_HEADER) + sizeof(NET_JOIN_CNF_EVENT), &pmgBuffer);
    if (rc != 0)
    {
        WARNING_OUT(("Failed to alloc NET_JOIN_CNF_EVENT"));
        DC_QUIT;
    }

    pNetJoinCnf = (PNET_JOIN_CNF_EVENT) pmgBuffer->pDataBuffer;

    ValidateCMP(g_pcmPrimary);
    if (!g_pcmPrimary->callID)
    {
        WARNING_OUT(("MGPostJoinConfirm failed; not in call"));
        rc = NET_RC_MGC_NOT_CONNECTED;
        DC_QUIT;
    }

    //
    // Fill in the fields.
    //
    pNetJoinCnf->callID         = g_pcmPrimary->callID;
    pNetJoinCnf->result         = result;
    pNetJoinCnf->channel        = channel;
    pNetJoinCnf->correlator     = correlator;

    //
    // OK, we've built the event so now post it to our client:
    //
    UT_PostEvent(pmgClient->putTask,
                      pmgClient->putTask,
                      NO_DELAY,
                      NET_EVENT_CHANNEL_JOIN,
                      0,
                      (UINT_PTR) pNetJoinCnf);
    pmgBuffer->eventPosted = TRUE;

DC_EXIT_POINT:

    DebugExitDWORD(MGPostJoinConfirm, rc);
    return(rc);

}



//
// MCSErrToNetErr()
//
UINT McsErrToNetErr ( UINT rcMCS )
{
    UINT rc = NET_RC_MGC_NOT_SUPPORTED;

    //
    // We use a static array of values to map the return code:
    //
    if (rcMCS < sizeof(c_RetCodeMap1) / sizeof(c_RetCodeMap1[0]))
    {
        rc = c_RetCodeMap1[rcMCS];
    }
    else
    {
        UINT nNewIndex = rcMCS - MCS_DOMAIN_ALREADY_EXISTS;
        if (nNewIndex < sizeof(c_RetCodeMap2) / sizeof(c_RetCodeMap2[0]))
        {
            rc = c_RetCodeMap2[nNewIndex];
        }
    }

#ifdef _DEBUG
    if (MCS_TRANSMIT_BUFFER_FULL == rcMCS)
    {
        ASSERT(NET_RC_MGC_TOO_MUCH_IN_USE == rc);
    }
#endif

    return rc;
}



//
// TranslateResult(...)
//
NET_RESULT TranslateResult(WORD resultMCS)
{
    //
    // We use a static array of values to map the result code:
    //
    if (resultMCS >= MG_NUM_OF_MCS_RESULTS)
        resultMCS = MG_INVALID_MCS_RESULT;
    return(c_ResultMap[resultMCS]);
}


//
// MGFLOCallback(...)
//
void MGFLOCallBack
(
    PMG_CLIENT          pmgClient,
    UINT                callbackType,
    UINT                priority,
    UINT                newBufferSize
)
{
    PMG_BUFFER          pmgBuffer;

    DebugEntry(MGFLOCallBack);

    ASSERT(priority != NET_TOP_PRIORITY);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    //
    // If this is a buffermod callback then tell the app
    //
    if (pmgClient == &g_amgClients[MGTASK_DCS])
    {
        if (callbackType == FLO_BUFFERMOD)
        {
            UT_PostEvent(pmgClient->putTask,
                         pmgClient->putTask,
                         NO_DELAY,
                         NET_FLOW,
                         priority,
                         newBufferSize);
        }
    }
    else
    {
        ASSERT(pmgClient == &g_amgClients[MGTASK_OM]);

        //
        // Wake up the app in case we have applied back pressure.
        //
        TRACE_OUT(("Posting NET_FEEDBACK"));
        UT_PostEvent(pmgClient->putTask,
                 pmgClient->putTask,
                 NO_DELAY,
                 NET_FEEDBACK,
                 0,
                 g_pcmPrimary->callID);
    }

    DebugExitVOID(MGFLOCallback);
}



//
// MGProcessDomainWatchdog()
//
void MGProcessDomainWatchdog
(
    PMG_CLIENT      pmgClient
)
{
    int             task;

    DebugEntry(MGProcessDomainWatchdog);

    ValidateMGClient(pmgClient);

    //
    // Call FLO to check each user attachment for delinquency
    //
    if (g_mgAttachCount > 0)
    {
        for (task = MGTASK_FIRST; task < MGTASK_MAX; task++)
        {
            if (g_amgClients[task].userAttached)
            {
                FLO_CheckUsers(&(g_amgClients[task]));
            }
        }

        //
        // Continue periodic messages - but only if there are some users.
        //
        // TRACE_OUT(("Continue watchdog"));
        UT_PostEvent(pmgClient->putTask,
                     pmgClient->putTask,
                     MG_TIMER_PERIOD,
                     NET_MG_WATCHDOG,
                     0, 0);
    }
    else
    {
        TRACE_OUT(("Don't continue Watchdog timer"));
    }

    DebugExitVOID(MGProcessDomainWatchdog);
}



//
// FLO_UserTerm
//
void FLO_UserTerm(PMG_CLIENT pmgClient)
{
    UINT    i;
    UINT    cStreams;

    DebugEntry(FLO_UserTerm);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    cStreams = pmgClient->flo.numStreams;

    //
    // Stop flow control on all channels.  We scan the list of streams and
    // if flow control is active on a stream then we stop it.
    //
    for (i = 0; i < cStreams; i++)
    {
        //
        // Check that the stream is flow controlled.
        //
        if (pmgClient->flo.pStrData[i] != NULL)
        {
            //
            // End control on this controlled stream.
            //
            FLOStreamEndControl(pmgClient, i);
        }
    }

    DebugExitVOID(FLO_UserTerm);
}



//
// FLO_StartControl
//
void FLO_StartControl
(
    PMG_CLIENT      pmgClient,
    NET_CHANNEL_ID  channel,
    UINT            priority,
    UINT            backlog,
    UINT            maxBytesOutstanding
)
{
    UINT            rc = 0;
    PFLO_STREAM_DATA   pStr;
    UINT            i;
    UINT            stream;

    DebugEntry(FLO_StartControl);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);
    ASSERT(priority != NET_TOP_PRIORITY);

    //
    // Flow control is on by default.
    //

    //
    // Check to see if the channel is already flow controlled.  If it is
    // then we just exit.
    //
    stream = FLOGetStream(pmgClient, channel, priority, &pStr);
    if (stream != FLO_NOT_CONTROLLED)
    {
        ValidateFLOStr(pStr);

        TRACE_OUT(("Stream %u is already controlled (0x%08x:%u)",
               stream, channel, priority));
        DC_QUIT;
    }

    //
    // If we already have hit the stream limit for this app then give up.
    //
    for (i = 0; i < FLO_MAX_STREAMS; i++)
    {
        if ((pmgClient->flo.pStrData[i]) == NULL)
        {
            break;
        }
    }
    if (i == FLO_MAX_STREAMS)
    {
        ERROR_OUT(("Too many streams defined already"));
        DC_QUIT;
    }
    TRACE_OUT(("This is stream %u", i));

    //
    // Allocate memory for our stream data.  Hang the pointer off floHandle
    // - this should be returned to us on all subsequent API calls.
    //
    pStr = new FLO_STREAM_DATA;
    if (!pStr)
    {
        WARNING_OUT(("FLO_StartControl failed; out of memory"));
        DC_QUIT;
    }
    ZeroMemory(pStr, sizeof(*pStr));

    //
    // Store the channel and priorities for this stream.
    //
    SET_STAMP(pStr, FLOSTR);
    pStr->channel    = channel;
    pStr->priority   = priority;
    pStr->backlog    = backlog;
    if (maxBytesOutstanding == 0)
    {
        maxBytesOutstanding = FLO_MAX_STREAMSIZE;
    }
    pStr->DC_ABSMaxBytesInPipe = maxBytesOutstanding;
    pStr->maxBytesInPipe = FLO_INIT_STREAMSIZE;
    if (pStr->maxBytesInPipe > maxBytesOutstanding)
    {
        pStr->maxBytesInPipe = maxBytesOutstanding;
    }

    //
    // Set the initial stream bytesAllocated to 0.
    //
    pStr->bytesAllocated = 0;

    //
    // Ping needed immediately.
    //
    pStr->pingNeeded   = TRUE;
    pStr->pingTime     = FLO_INIT_PINGTIME;
    pStr->nextPingTime = GetTickCount();

    //
    // Initialize the users base pointers.
    //
    COM_BasedListInit(&(pStr->users));

    //
    // Hang the stream CB off the base control block.
    //
    pmgClient->flo.pStrData[i] = pStr;
    if (i >= pmgClient->flo.numStreams)
    {
        pmgClient->flo.numStreams++;
    }

    TRACE_OUT(("Flow control started, stream %u, (0x%08x:%u)",
           i, channel, priority));

DC_EXIT_POINT:
    DebugExitVOID(FLO_StartControl);
}



//
// FLO_EndControl
//
void FLO_EndControl
(
    PMG_CLIENT      pmgClient,
    NET_CHANNEL_ID  channel,
    UINT            priority
)
{
    UINT            stream;
    PFLO_STREAM_DATA    pStr;

    DebugEntry(FLO_EndControl);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);
    ASSERT(priority != NET_TOP_PRIORITY);

    //
    // Convert channel and stream into priority.
    //
    stream = FLOGetStream(pmgClient, channel, priority, &pStr);

    //
    // The stream is not controlled so we just trace and quit.
    //
    if (stream == FLO_NOT_CONTROLLED)
    {
        WARNING_OUT(("Uncontrolled stream channel 0x%08x priority %u",
                    channel, priority));
        DC_QUIT;
    }

    //
    // Call the internal FLOStreamEndControl to end flow control on a
    // given stream.
    //
    ValidateFLOStr(pStr);
    FLOStreamEndControl(pmgClient, stream);

DC_EXIT_POINT:
    DebugExitVOID(FLO_EndControl);
}



//
// FLO_AllocSend
//
UINT FLO_AllocSend
(
    PMG_CLIENT          pmgClient,
    UINT                priority,
    NET_CHANNEL_ID      channel,
    UINT                size,
    PFLO_STREAM_DATA *  ppStr
)
{
    UINT                stream;
    UINT                curtime;
    PFLO_STREAM_DATA    pStr;
    BOOL                denyAlloc    = FALSE;
    BOOL                doPing       = FALSE;
    UINT                rc           = 0;

    DebugEntry(FLO_AllocSend);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    ASSERT(priority != NET_TOP_PRIORITY);

    //
    // Convert channel and stream into priority
    //
    stream = FLOGetStream(pmgClient, channel, priority, ppStr);
    pStr = *ppStr;

    //
    // For non-controlled streams just send the data
    //
    if (stream == FLO_NOT_CONTROLLED)
    {
        TRACE_OUT(("Send %u bytes on uncontrolled channel/pri (0x%08x:%u)",
                   size, channel, priority));
        DC_QUIT;
    }

    //
    // Get the current tick count.
    //
    curtime = GetTickCount();

    //
    // Check whether this request is permitted.  We must allow one packet
    // beyond the specified limit to avoid problems determining when we
    // have started rejecting requests and also to avoid situations where a
    // single request exceeds the total pipe size.
    //
    // If we have not yet received a pong then we limit the amount of
    // allocated buffer space to below FLO_MAX_PRE_FC_ALLOC.  However this
    // data can be sent immediately so the overall throughput is still
    // relatively high.  In this way we minimize the amount of data held in
    // the glue layer to a maximum of FLO_MAX_PRE_FC_ALLOC if there are no
    // remote users.
    //
    ValidateFLOStr(pStr);
    if (!pStr->gotPong)
    {
        //
        // Flag that a ping is required.
        //
        pStr->pingNeeded = TRUE;
        if (curtime > pStr->nextPingTime)
        {
            doPing = TRUE;
        }

        //
        // We haven't got a pong yet (i.e.  FC is non-operational) so we
        // need to limit the maximum amount of data held in flow control to
        // FLO_MAX_PRE_FC_ALLOC.
        //
        if (pStr->bytesAllocated > FLO_MAX_PRE_FC_ALLOC)
        {
            denyAlloc = TRUE;
            TRACE_OUT(("Max allocation of %u bytes exceeded (currently %u)",
                     FLO_MAX_PRE_FC_ALLOC,
                     pStr->bytesAllocated));
            DC_QUIT;
        }

        pStr->bytesInPipe += size;
        pStr->bytesAllocated += size;
        TRACE_OUT((
                   "Alloc of %u succeeded: bytesAlloc %u, bytesInPipe %u"
                   " (0x%08x:%u)",
                   size,
                   pStr->bytesAllocated,
                   pStr->bytesInPipe,
                   pStr->channel,
                   pStr->priority));

        DC_QUIT;
    }

    if (pStr->bytesInPipe < pStr->maxBytesInPipe)
    {
        //
        // Check to see if a ping is required and if so send it now.
        //
        if ((pStr->pingNeeded) && (curtime > pStr->nextPingTime))
        {
            doPing = TRUE;
        }

        pStr->bytesInPipe += size;
        pStr->bytesAllocated += size;
        TRACE_OUT(("Stream %u - alloc %u (InPipe:MaxInPipe %u:%u)",
                   stream,
                   size,
                   pStr->bytesInPipe,
                   pStr->maxBytesInPipe));
        DC_QUIT;
    }

    //
    // If we get here then we cannot currently allocate any buffers so deny
    // the allocation.  Simulate back pressure with NET_OUT_OF_RESOURCE.
    // We also flag that a "wake up" event is required to get the app to
    // send more data.
    //
    denyAlloc = TRUE;
    pStr->eventNeeded   = TRUE;
    pStr->curDenialTime = pStr->lastPingTime;

    //
    // We are not allowed to apply back pressure unless we can guarantee
    // that we will wake up the app later on.  This is dependent upon our
    // receiving a pong later.  But if there is no ping outstanding
    // (because we have allocated all our buffer allowance within the ping
    // delay time) then we should first send a ping to trigger the wake up.
    // If this fails then our watchdog will finally wake us up.
    //
    if (pStr->pingNeeded)
    {
        doPing = TRUE;
    }


DC_EXIT_POINT:

    //
    // Check to see if we should deny the buffer allocation.
    //
    if (denyAlloc)
    {
        rc = NET_RC_MGC_TOO_MUCH_IN_USE;
        TRACE_OUT(("Denying buffer request on stream %u InPipe %u Alloc %u",
               stream,
               pStr->bytesInPipe,
               pStr->bytesAllocated));
    }

    if (doPing)
    {
        //
        // A ping is required so send it now.
        //
        FLOPing(pmgClient, stream, curtime);
    }

    DebugExitDWORD(FLO_AllocSend, rc);
    return(rc);
}



//
// FLO_ReallocSend
//
void FLO_ReallocSend
(
    PMG_CLIENT          pmgClient,
    PFLO_STREAM_DATA    pStr,
    UINT                size
)
{
    DebugEntry(FLO_ReallocSend);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    //
    // For non-controlled streams there is nothing to do so just exit.
    //
    if (pStr == NULL)
    {
        TRACE_OUT(("Realloc data on uncontrolled channel"));
        DC_QUIT;
    }

    //
    // Perform a quick sanity check.
    //
    ValidateFLOStr(pStr);

    if (size > pStr->bytesInPipe)
    {
        ERROR_OUT(("Realloc of %u makes bytesInPipe (%u) neg (0x%08x:%u)",
                   size,
                   pStr->bytesInPipe,
                   pStr->channel,
                   pStr->priority));
        DC_QUIT;
    }

    //
    // Add the length not sent back into the pool.
    //
    pStr->bytesInPipe -= size;
    TRACE_OUT(("Realloc %u FC bytes (bytesInPipe is now %u) (0x%08x:%u)",
               size,
               pStr->bytesInPipe,
               pStr->channel,
               pStr->priority));

DC_EXIT_POINT:

    //
    // Every time that we call FLO_ReallocSend we also want to call
    // FLO_DecrementAlloc (but not vice-versa) so call it now.
    //
    FLO_DecrementAlloc(pStr, size);

    DebugExitVOID(FLO_ReallocSend);
}



//
// FLO_DecrementAlloc
//
void FLO_DecrementAlloc
(
    PFLO_STREAM_DATA    pStr,
    UINT                size
)
{
    DebugEntry(FLO_DecrementAlloc);

    //
    // For non-controlled streams there is nothing to do so just exit.
    //
    if (pStr == NULL)
    {
        TRACE_OUT(("Decrement bytesAllocated on uncontrolled channel"));
        DC_QUIT;
    }

    //
    // Perform a quick sanity check.
    //
    ValidateFLOStr(pStr);

    if (size > pStr->bytesAllocated)
    {
        ERROR_OUT(("Dec of %u makes bytesAllocated (%u) neg (0x%08x:%u)",
                   size,
                   pStr->bytesAllocated,
                   pStr->channel,
                   pStr->priority));
        DC_QUIT;
    }

    //
    // Update the count of the data held in the glue for this stream.
    //
    pStr->bytesAllocated -= size;
    TRACE_OUT(("Clearing %u alloc bytes (bytesAlloc is now %u) (0x%08x:%u)",
               size,
               pStr->bytesAllocated,
               pStr->channel,
               pStr->priority));

DC_EXIT_POINT:
    DebugExitVOID(FLO_DecrementAlloc);
}



//
// FLO_CheckUsers
//
void FLO_CheckUsers(PMG_CLIENT pmgClient)
{
    PFLO_USER           pFloUser;
    PBASEDLIST             nextUser;
    int                 waited;
    BYTE                stream;
    UINT                curtime;
    PFLO_STREAM_DATA    pStr;

    DebugEntry(FLO_CheckUsers);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    curtime = GetTickCount();

    //
    // Check users of each stream
    //
    for (stream = 0; stream < pmgClient->flo.numStreams; stream++)
    {
        if (pmgClient->flo.pStrData[stream] == NULL)
        {
            continue;
        }

        pStr = pmgClient->flo.pStrData[stream];
        ValidateFLOStr(pStr);

        //
        // Check whether we have waited long enough and need to reset the
        // wait counters.  We only wait a certain time before resetting all
        // our counts.  What has happened is that someone has left the call
        // and we have been waiting for their pong.
        //
        // We detect the outage by checking against nextPingTime which, as
        // well as being set to the earliest time we can send a ping is
        // also updated to the current time as each pong comes in so we can
        // use it as a measure of the time since the last repsonse from any
        // user of the stream.
        //
        // To avoid false outages caused by new joiners or transient large
        // buffer situations each user is required to send a pong at the
        // rate of MAX_WAIT_TIME/2.  They do this by just sending a
        // duplicate pong if they have not yet got the ping they need to
        // to pong.
        //
        if ((pStr->eventNeeded) &&
            (!pStr->pingNeeded))
        {
            TRACE_OUT(("Checking for valid back pressure on stream %u",
                         stream));

            //
            // Note that if there are no remote users then we should reset
            // the flags regardless.  We get into this state when we first
            // start an app because OBMAN sends data before the app has
            // joined the channel at the other end.
            //
            waited = curtime - pStr->nextPingTime;
            if (waited > FLO_MAX_WAIT_TIME)
            {
                TRACE_OUT(("Stream %u - Waited for %d, resetting counter",
                       stream, waited));

                pStr->bytesInPipe  = 0;
                pStr->pingNeeded   = TRUE;
                pStr->nextPingTime = curtime;
                pStr->gotPong      = FALSE;

                //
                // Remove outdated records from our user queue
                //
                pFloUser = (PFLO_USER)COM_BasedNextListField(&(pStr->users));
                while (&(pFloUser->list) != &(pStr->users))
                {
                    ValidateFLOUser(pFloUser);

                    //
                    // Address the follow on record before we free the
                    // current
                    //
                    nextUser = COM_BasedNextListField(&(pFloUser->list));

                    //
                    // Free the current record, if necessary
                    //
                    if (pFloUser->lastPongRcvd != pStr->pingValue)
                    {
                        //
                        // Remove from the list
                        //
                        TRACE_OUT(("Freeing FLO_USER 0x%08x ID 0x%08x", pFloUser, pFloUser->userID));

                        COM_BasedListRemove(&(pFloUser->list));
                        delete pFloUser;
                    }
                    else
                    {
                        //
                        // At least one user still out there so keep flow
                        // control active or else we would suddenly send
                        // out a burst of data that might flood them
                        //
                        pStr->gotPong = TRUE;
                    }

                    //
                    // Move on to the next record in the list
                    //
                    pFloUser = (PFLO_USER)nextUser;
                }

                //
                // We have previously rejected an application request so we
                // had better call back now
                //
                if (pmgClient->flo.callBack != NULL)
                {
                    (*(pmgClient->flo.callBack))(pmgClient,
                                           FLO_WAKEUP,
                                           pStr->priority,
                                           pStr->maxBytesInPipe);
                }
                pStr->eventNeeded = FALSE;
            }
        }

    }

    DebugExitVOID(FLO_CheckUsers);
}



//
// FLO_ReceivedPacket
//
void FLO_ReceivedPacket
(
    PMG_CLIENT          pmgClient,
    PTSHR_FLO_CONTROL   pPkt
)
{
    BOOL                canPing = TRUE;
    PFLO_USER           pFloUser;
    BOOL                userFound = FALSE;
    UINT                stream;
    UINT                curtime;
    PFLO_STREAM_DATA    pStr;
    UINT                callbackType = 0;
    int                 latency;
    UINT                throughput;

    DebugEntry(FLO_ReceivedPacket);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    stream = pPkt->stream;
    ASSERT(stream < FLO_MAX_STREAMS);

    pStr = pmgClient->flo.pStrData[stream];

    //
    // If the stream CB has been freed up already then we can ignore any
    // flow information pertaining to it.
    //
    if (pStr == NULL)
    {
        TRACE_OUT(("Found a null stream pointer for stream %u", stream));
        DC_QUIT;
    }

    ValidateFLOStr(pStr);
    curtime = GetTickCount();

    //
    // First we must locate the user for this ping/pong/pang
    // Also, while we are doing it we can check to see if it is a pong and
    // if so whether it is the last pong we need
    //
    pFloUser = (PFLO_USER)COM_BasedNextListField(&(pStr->users));
    while (&(pFloUser->list) != &(pStr->users))
    {
        ValidateFLOUser(pFloUser);

        if (pFloUser->userID == pPkt->userID)
        {
            userFound = TRUE;

            //
            // We have got a match so set up the last pong value
            // Accumulate pong stats for query
            //
            if (pPkt->packetType == PACKET_TYPE_PONG)
            {
                pFloUser->lastPongRcvd = pPkt->pingPongID;
                pFloUser->gotPong = TRUE;
                pFloUser->numPongs++;
                pFloUser->pongDelay += curtime - pStr->lastPingTime;
            }
            else
            {
                break;
            }
        }

        //
        // So, is it the final pong - are there any users with different
        // pong required entries?
        // Note that if the user has never sent us a pong then we don't
        // reference their lastPongRcvd field at this stage.
        //
        if (pPkt->packetType == PACKET_TYPE_PONG)
        {
            if (pFloUser->gotPong &&
                (pFloUser->lastPongRcvd != pStr->pingValue))
            {
                TRACE_OUT(("%u,%u - Entry 0x%08x has different ping id %u",
                           stream,
                           pFloUser->userID,
                           pFloUser,
                           pFloUser->lastPongRcvd));
                canPing = FALSE;
            }
        }

        pFloUser = (PFLO_USER)COM_BasedNextListField(&(pFloUser->list));
    }

    //
    // If this is a new User then add them to the list
    //
    if (!userFound)
    {
        pFloUser = FLOAddUser(pPkt->userID, pStr);

        //
        // If this is a pong then we can set up the lastpong as well
        //
        if ((pFloUser != NULL) &&
            (pPkt->packetType == PACKET_TYPE_PONG))
        {
            pFloUser->lastPongRcvd = pPkt->pingPongID;
        }
    }

    //
    // Now perform the actual packet specific processing
    //
    switch (pPkt->packetType)
    {
        //
        // PING
        //
        // If this is a ping packet then just flag we must send a pong.  If
        // we failed to alloc a user CB then just ignore the ping and they
        // will continue in blissful ignorance of our presence
        //
        case PACKET_TYPE_PING:
        {
            TRACE_OUT(("%u,%u - PING %u received",
                stream, pPkt->userID, pPkt->pingPongID));

            ValidateFLOUser(pFloUser);

            pFloUser->sendPongID = pPkt->pingPongID;
            if (pFloUser->rxPackets < FLO_MAX_RCV_PACKETS)
            {
                FLOPong(pmgClient, stream, pFloUser->userID, pPkt->pingPongID);
                pFloUser->sentPongTime = curtime;
            }
            else
            {
                TRACE_OUT(("Receive backlog - just flagging pong needed"));
                pFloUser->pongNeeded = TRUE;
            }
        }
        break;

        //
        // PONG
        //
        // Flag we have got a pong from any user so we should start
        // applying send flow control to this stream now (Within the stream
        // we achieve per user granularity by ignoring those users that
        // have never ponged when we inspect the stream byte count.)
        //
        case PACKET_TYPE_PONG:
        {
            pStr->gotPong = TRUE;

            //
            // Keep a note that we are receiving messages on this stream by
            // moving nextPing on (but only if we have passed it)
            //
            if (curtime > pStr->nextPingTime)
            {
                pStr->nextPingTime = curtime;
            }

            //
            // Update the user entry and schedule a ping if necessary
            //
            TRACE_OUT(("%u,%u - PONG %u received",
                stream, pPkt->userID, pPkt->pingPongID));

            //
            // Check for readiness to send another ping This may be because
            // this is the first users pong, in which case we should also send
            // another ping when ready
            //
            if (canPing)
            {
                TRACE_OUT(("%u       - PING scheduled, pipe was %d",
                    stream,
                    pStr->bytesInPipe));

                //
                // Reset byte count and ping readiness flag
                //
                pStr->bytesInPipe = 0;
                pStr->pingNeeded  = TRUE;

                //
                // Adjust the buffer size limit based on our current throughput
                //
                // If we hit the back pressure point and yet we are ahead of
                // the target backlog then we should increase the buffer size
                // to avoid constraining the pipe.  If we have already
                // increased the buffer size to our maximum value then try
                // decreasing the tick delay.  If we are already ticking at the
                // max rate then we are going as fast as we can.  If we make
                // either of these adjustments then allow the next ping to flow
                // immediately so that we can ramp up as fast as possible to
                // LAN bandwidths.
                //
                // We dont need to do the decrease buffer checks if we have not
                // gone into back pressure during the last pong cycle
                //
                if (pStr->eventNeeded)
                {
                    TRACE_OUT(("We were in a back pressure situation"));
                    callbackType = FLO_WAKEUP;

                    TRACE_OUT(("Backlog %u denial delta %d ping delta %d",
                       pStr->backlog, curtime-pStr->lastDenialTime,
                       curtime-pStr->lastPingTime));

                    //
                    // The next is a little complex.
                    //
                    // If the turnaround of this ping pong is significantly
                    // less than our target then open the pipe up.  But we must
                    // adjust to allow for the ping being sent at a quiet
                    // period, which we do by remembering when each ping is
                    // sent and, if we encounter a backlog situation, storing
                    // that ping time for future reference
                    //
                    // So the equation for latency is
                    //
                    //     Pongtime-previous backlogged ping time
                    //
                    // The previous ping time is the that we sent prior to the
                    // last back pressure situation so there are two times in
                    // the control block, one for the last Ping time and one
                    // for the last but one ping time.
                    //
                    if ((int)(pStr->backlog/2 - curtime +
                              pStr->lastDenialTime) > 0)
                    {
                        //
                        // We are coping easily so increase the buffer to pump
                        // more data through.  Predict the new buffer size
                        // based on the latency for the current backlog so that
                        // we don't artificially constrain the app.  We do this
                        // by taking the observed latency, decrementing by a
                        // small factor to allow for the latency we might
                        // observe over the fastest possible link and then
                        // calculating the connection throughput.
                        //
                        //   latency = curtime - lastDenialTime - fudge(100mS)
                        //   amount sent = maxBytesInPipe (because we we were
                        //                                 backed up)
                        //   throughput = amount sent/latency (bytes/millisec)
                        //   New buffer = throughput * target latency
                        //
                        if (pStr->maxBytesInPipe < pStr->DC_ABSMaxBytesInPipe)
                        {
                            latency = (curtime -
                                            pStr->lastDenialTime -
                                            30);
                            if (latency <= 0)
                            {
                                latency = 1;
                            }

                            throughput = (pStr->maxBytesInPipe*8)/latency;
                            pStr->maxBytesInPipe = (throughput * pStr->backlog)/8;

                            TRACE_OUT(("Potential maxbytes of %d",
                                 pStr->maxBytesInPipe));

                            if (pStr->maxBytesInPipe > pStr->DC_ABSMaxBytesInPipe)
                            {
                                pStr->maxBytesInPipe = pStr->DC_ABSMaxBytesInPipe;
                            }

                            TRACE_OUT((
                               "Modified buffer maxBytesInPipe up to %u "
                               "(0x%08x:%u)",
                               pStr->maxBytesInPipe,
                               pStr->channel,
                               pStr->priority));
                            callbackType = FLO_BUFFERMOD;
                        }
                        else
                        {
                            //
                            // We have hit our maximum allowed pipe size but
                            // are still backlogged and yet pings are going
                            // through acceptably.
                            //
                            // Our first action is to try reducing the ping
                            // time thus increasing out throughput.
                            //
                            // If we have already decreased the ping time to
                            // its minimum then we cannot do anything else.  It
                            // is possible that the application parameters
                            // should be changed to increase the permissible
                            // throughput so log an alert to suggest this.
                            // however there are situations (input management)
                            // where we want some back pressure in order to
                            // prevent excessive cpu loading at the recipient.
                            //
                            // To increase the throughput either
                            //
                            // - Increase the maximum size of the stream.  The
                            //   disadvantage of this is that a low badwidth
                            //   joiner may suddenly see a lot of high
                            //   bandwidth data in the pipe.  However this
                            //   is the preferred solution in general, as
                            //   it avoids having the pipe flooded with pings.
                            //
                            // - Reduce the target latency.  This is a little
                            //   dangerous because the latency is composed of
                            //   the pre-queued data and the network turnaround
                            //   time and if the network turnaround time
                            //   approaches the target latency then the flow
                            //   control will simply close the pipe right down
                            //   irrespective of the achievable throughput.
                            //
                            pStr->maxBytesInPipe = pStr->DC_ABSMaxBytesInPipe;
                            pStr->pingTime   = pStr->pingTime/2;
                            if (pStr->pingTime < FLO_MIN_PINGTIME)
                            {
                                pStr->pingTime = FLO_MIN_PINGTIME;
                            }

                            TRACE_OUT((
                                 "Hit DC_ABS max - reduce ping time to %u",
                                 pStr->pingTime));
                        }

                        //
                        // Allow the ping just scheduled to flow immediately
                        //
                        pStr->nextPingTime = curtime;
                    }

                    pStr->eventNeeded = FALSE;
                }

                //
                // If we have exceeded our target latency at all then throttle
                // back
                //
                if ((int)(pStr->backlog - curtime + pStr->lastPingTime) < 0)
                {
                    pStr->maxBytesInPipe /= 2;
                    if (pStr->maxBytesInPipe < FLO_MIN_STREAMSIZE)
                    {
                        pStr->maxBytesInPipe = FLO_MIN_STREAMSIZE;
                    }

                    pStr->pingTime   = pStr->pingTime * 2;
                    if (pStr->pingTime > FLO_INIT_PINGTIME)
                    {
                        pStr->pingTime = FLO_INIT_PINGTIME;
                    }

                    TRACE_OUT((
                       "Mod buffer maxBytesInPipe down to %u, ping to %u "
                       "(0x%08x:%u)",
                       pStr->maxBytesInPipe,
                       pStr->pingTime,
                       pStr->channel,
                       pStr->priority));
                    callbackType = FLO_BUFFERMOD;
                }

                //
                // Now make athe callback if callbackType has been set
                //
                if ((callbackType != 0) &&
                    (pmgClient->flo.callBack != NULL))
                {
                    (pmgClient->flo.callBack)(pmgClient,
                                       callbackType,
                                       pStr->priority,
                                       pStr->maxBytesInPipe);
                }
            }
        }
        break;

        //
        // PANG
        //
        // Remove the user and continue
        //
        case PACKET_TYPE_PANG:
        {
            TRACE_OUT(("%u,%u - PANG received, removing user",
                stream, pPkt->userID));

            //
            // Remove from the list
            //
            ValidateFLOUser(pFloUser);

            TRACE_OUT(("Freeing FLO_USER 0x%08x ID 0x%08x", pFloUser, pFloUser->userID));

            COM_BasedListRemove(&(pFloUser->list));
            delete pFloUser;

            //
            // If we are currently waiting then generate an event for the
            // app to get it moving again
            //
            if ((pStr->eventNeeded) &&
                (pmgClient->flo.callBack != NULL))
            {
                TRACE_OUT(("Waking up the app because user has left"));
                (*(pmgClient->flo.callBack))(pmgClient,
                                   FLO_WAKEUP,
                                   pStr->priority,
                                   pStr->maxBytesInPipe);
                pStr->eventNeeded = FALSE;
            }
        }
        break;

        //
        // UNKNOWN
        //
        // Just trace alert and press on
        //
        default:
        {
            WARNING_OUT(("Invalid packet type 0x%08x", pPkt->packetType));
        }
        break;
    }

DC_EXIT_POINT:
    DebugExitVOID(FLO_ReceivedPacket);
}



//
// FLO_AllocReceive
//
void FLO_AllocReceive
(
    PMG_CLIENT          pmgClient,
    UINT                priority,
    NET_CHANNEL_ID      channel,
    UINT                userID
)
{
    UINT                stream;
    PFLO_USER           pFloUser;
    BOOL                userFound =     FALSE;
    PFLO_STREAM_DATA    pStr;
    UINT                curtime;

    DebugEntry(FLO_AllocReceive);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);
    ASSERT(priority != NET_TOP_PRIORITY);

    //
    // Convert channel and priority into stream
    //
    stream = FLOGetStream(pmgClient, channel, priority, &pStr);

    //
    // Only process controlled streams
    //
    if (stream == FLO_NOT_CONTROLLED)
    {
        DC_QUIT;
    }

    //
    // First we must locate the user
    //
    ValidateFLOStr(pStr);
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pStr->users),
        (void**)&pFloUser, FIELD_OFFSET(FLO_USER, list), FIELD_OFFSET(FLO_USER, userID),
        (DWORD)userID, FIELD_SIZE(FLO_USER, userID));

    //
    // SFR6101: If this is a new User then add them to the list
    //
    if (pFloUser == NULL)
    {
        TRACE_OUT(("Message from user 0x%08x who is not flow controlled", userID));
        pFloUser = FLOAddUser(userID, pStr);
    }

    //
    // If we failed to allocate a usr CB then just ignore for now
    //
    if (pFloUser != NULL)
    {
        ValidateFLOUser(pFloUser);

        //
        // Add in the new receive packet usage
        //
        pFloUser->rxPackets++;
        TRACE_OUT(("Num outstanding receives on stream %u now %u",
            stream, pFloUser->rxPackets));

        //
        // Now check that we have not got some kind of creep
        //
        if (pFloUser->rxPackets > FLO_MAX_RCV_PKTS_CREEP)
        {
            WARNING_OUT(("Creep?  Stream %u has %u unacked rcv pkts",
                stream, pFloUser->rxPackets));
        }

        //
        // Finally check to see that we are responding OK to this person
        //
        curtime = GetTickCount();
        if ((pFloUser->pongNeeded) &&
            (curtime - pFloUser->sentPongTime > (FLO_MAX_WAIT_TIME/4)))
        {
            TRACE_OUT(("Send keepalive pong"));
            FLOPong(pmgClient, stream, pFloUser->userID, pFloUser->sendPongID);
            pFloUser->sentPongTime = curtime;
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(FLO_AllocReceive);
}



//
// FLO_FreeReceive
//
void FLO_FreeReceive
(
    PMG_CLIENT          pmgClient,
    NET_PRIORITY        priority,
    NET_CHANNEL_ID      channel,
    UINT                userID
)
{
    UINT                stream;
    PFLO_USER           pFloUser;
    PFLO_STREAM_DATA    pStr;
    BOOL                userFound = FALSE;

    DebugEntry(FLO_FreeReceive);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);
    ASSERT(priority != NET_TOP_PRIORITY);

    //
    // Convert channel and priority into stream
    //
    stream = FLOGetStream(pmgClient, channel, priority, &pStr);

    //
    // Only process controlled streams
    //
    if (stream != FLO_NOT_CONTROLLED)
    {
        ValidateFLOStr(pStr);

        //
        // First we must locate the user
        //
        pFloUser = (PFLO_USER)COM_BasedNextListField(&(pStr->users));
        while (&(pFloUser->list) != &(pStr->users))
        {
            ValidateFLOUser(pFloUser);

            if (pFloUser->userID == userID)
            {
                userFound = TRUE;
                break;
            }
            pFloUser = (PFLO_USER)COM_BasedNextListField(&(pFloUser->list));
        }

        //
        // If we do not find the user record then two things may have
        // happened.
        // - They have joined the channel and immediately sent data
        // - They were removed as being delinquent and are now sending
        //   data again
        // - We failed to add them to our user list
        // Try and allocate the user entry now
        // (This will start tracking receive buffer space, but this user
        // will not participate in our send flow control until we receive
        // a pong from them and set "gotpong" in their FLO_USER CB.)
        //
        if (!userFound)
        {
            pFloUser = FLOAddUser(userID, pStr);
        }

        if (pFloUser != NULL)
        {
            ValidateFLOUser(pFloUser);

            //
            // Check that we have not got some kind of creep
            //
            if (pFloUser->rxPackets == 0)
            {
                WARNING_OUT(("Freed too many buffers for user 0x%08x on str %u",
                    userID, stream));
            }
            else
            {
                pFloUser->rxPackets--;
                TRACE_OUT(("Num outstanding receives now %u",
                    pFloUser->rxPackets));
            }

            //
            // Now we must Pong if there is a pong pending and we have
            // moved below the high water mark
            //
            if ((pFloUser->pongNeeded) &&
                (pFloUser->rxPackets < FLO_MAX_RCV_PACKETS))

            {
                FLOPong(pmgClient, stream, pFloUser->userID, pFloUser->sendPongID);
                pFloUser->pongNeeded = FALSE;
                pFloUser->sentPongTime = GetTickCount();
            }
        }
    }

    DebugExitVOID(FLO_FreeReceive);
}


//
// FLOPong()
//
void FLOPong
(
    PMG_CLIENT      pmgClient,
    UINT            stream,
    UINT            userID,
    UINT            pongID
)
{
    PTSHR_FLO_CONTROL    pFlo;
    PMG_BUFFER      pmgBuffer;
    UINT            rc;

    DebugEntry(FLOPong);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    rc = MGNewDataBuffer(pmgClient,
                       MG_TX_PONG,
                       sizeof(TSHR_FLO_CONTROL) + sizeof(MG_INT_PKT_HEADER),
                       &pmgBuffer);
    if (rc != 0)
    {
        WARNING_OUT(("MGNewDataBuffer failed in FLOPong"));
        DC_QUIT;
    }

    pFlo = (PTSHR_FLO_CONTROL)pmgBuffer->pDataBuffer;
    pmgBuffer->pPktHeader->header.pktLength = TSHR_PKT_FLOW;

    //
    // Set up pong contents
    //
    pFlo->packetType         = PACKET_TYPE_PONG;
    pFlo->userID             = pmgClient->userIDMCS;
    pFlo->stream             = (BYTE)stream;
    pFlo->pingPongID         = (BYTE)pongID;
    pmgBuffer->channelId     = (ChannelID)userID;
    pmgBuffer->priority      = MG_PRIORITY_HIGHEST;

    //
    // Now decouple the send request.  Note that we must put the pong at
    // the back of the request queue even though we want it to flow at
    // high priority because otherwise there are certain circumstances
    // where we get pong reversal due to receipt of multiple pings
    //
    TRACE_OUT(("Inserting pong message 0x%08x at head of pending chain", pmgBuffer));
    COM_BasedListInsertBefore(&(pmgClient->pendChain), &(pmgBuffer->pendChain));

    UT_PostEvent(pmgClient->putTask,
                      pmgClient->putTask,
                      NO_DELAY,
                      NET_MG_SCHEDULE,
                      0,
                      0);

    TRACE_OUT(("%u,0x%08x - PONG %u scheduled",
               pFlo->stream, pmgBuffer->channelId, pFlo->pingPongID));

DC_EXIT_POINT:
    DebugExitVOID(FLOPong);
}



//
// FLOPing()
//
void FLOPing
(
    PMG_CLIENT          pmgClient,
    UINT                stream,
    UINT                curtime
)
{

    PFLO_STREAM_DATA    pStr;
    PMG_BUFFER          pmgBuffer;
    PTSHR_FLO_CONTROL   pFlo;
    UINT                rc;

    DebugEntry(FLOPing);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    ASSERT(stream < FLO_MAX_STREAMS);
    pStr = pmgClient->flo.pStrData[stream];
    ValidateFLOStr(pStr);

    rc = MGNewDataBuffer(pmgClient,
                       MG_TX_PING,
                       sizeof(TSHR_FLO_CONTROL)+sizeof(MG_INT_PKT_HEADER),
                       &pmgBuffer);
    if (rc != 0)
    {
        WARNING_OUT(("MGNewDataBuffer failed in FLOPing"));
        DC_QUIT;
    }

    //
    // Flag ping not needed to avoid serialization problems across the
    // sendmessage!
    //
    pStr->pingNeeded    = FALSE;

    pFlo = (PTSHR_FLO_CONTROL)pmgBuffer->pDataBuffer;
    pmgBuffer->pPktHeader->header.pktLength = TSHR_PKT_FLOW;

    //
    // Set up ping contents
    //
    pFlo->packetType         = PACKET_TYPE_PING;
    pFlo->userID             = pmgClient->userIDMCS;
    pFlo->stream             = (BYTE)stream;
    pmgBuffer->channelId     = (ChannelID)pStr->channel;
    pmgBuffer->priority      = (NET_PRIORITY)pStr->priority;

    //
    // Generate the next ping value to be used
    //
    pFlo->pingPongID         = (BYTE)(pStr->pingValue + 1);

    //
    // Now decouple the send request
    //
    TRACE_OUT(("Inserting ping message 0x%08x into pending chain", pmgBuffer));
    COM_BasedListInsertBefore(&(pmgClient->pendChain), &(pmgBuffer->pendChain));

    UT_PostEvent(pmgClient->putTask,
                      pmgClient->putTask,
                      NO_DELAY,
                      NET_MG_SCHEDULE,
                      0,
                      0);

    //
    // Update flow control variables
    //
    pStr->pingValue = ((pStr->pingValue + 1) & 0xFF);
    pStr->lastPingTime  = curtime;
    pStr->nextPingTime  = curtime + pStr->pingTime;
    pStr->lastDenialTime = pStr->curDenialTime;
    TRACE_OUT(("%u       - PING %u sched, next in %u mS (0x%08x:%u)",
                   pFlo->stream,
                   pStr->pingValue,
                   pStr->pingTime,
                   pStr->channel,
                   pStr->priority));

DC_EXIT_POINT:
    DebugExitVOID(FLOPing);
}



//
// FLOPang()
//
void FLOPang
(
    PMG_CLIENT      pmgClient,
    UINT            stream,
    UINT            userID
)
{
    PMG_BUFFER      pmgBuffer;
    PTSHR_FLO_CONTROL    pFlo;
    UINT            rc;

    DebugEntry(FLOPang);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    rc = MGNewDataBuffer(pmgClient,
                       MG_TX_PANG,
                       sizeof(TSHR_FLO_CONTROL) + sizeof(MG_INT_PKT_HEADER),
                       &pmgBuffer);
    if (rc != 0)
    {
        WARNING_OUT(("MGNewDataBuffer failed in FLOPang"));
        DC_QUIT;
    }

    pFlo = (PTSHR_FLO_CONTROL)pmgBuffer->pDataBuffer;
    pmgBuffer->pPktHeader->header.pktLength = TSHR_PKT_FLOW;

    //
    // Set up pang contents
    //
    pFlo->packetType         = PACKET_TYPE_PANG;
    pFlo->userID             = pmgClient->userIDMCS;
    pFlo->stream             = (BYTE)stream;
    pFlo->pingPongID         = 0;
    pmgBuffer->channelId     = (ChannelID)userID;
    pmgBuffer->priority      = MG_PRIORITY_HIGHEST;

    //
    // Now decouple the send request
    //
    TRACE_OUT(("Inserting pang message 0x%08x into pending chain", pmgBuffer));
    COM_BasedListInsertBefore(&(pmgClient->pendChain),
                        &(pmgBuffer->pendChain));
    UT_PostEvent(pmgClient->putTask,
                      pmgClient->putTask,
                      NO_DELAY,
                      NET_MG_SCHEDULE,
                      0,
                      0);

DC_EXIT_POINT:
    DebugExitVOID(FLOPang);
}



//
// FLOGetStream()
//
UINT FLOGetStream
(
    PMG_CLIENT          pmgClient,
    NET_CHANNEL_ID      channel,
    UINT                priority,
    PFLO_STREAM_DATA *  ppStr
)
{
    UINT                i;
    UINT                cStreams;

    DebugEntry(FLOGetStream);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);
    ASSERT(priority != NET_TOP_PRIORITY);

    cStreams = pmgClient->flo.numStreams;
    ASSERT(cStreams <= FLO_MAX_STREAMS);

    //
    // Scan the list of streams for a match.
    //
    for (i = 0; i < cStreams; i++)
    {
        //
        // Check to ensure that this is a valid stream.
        //
        if (pmgClient->flo.pStrData[i] == NULL)
        {
            continue;
        }

        ValidateFLOStr(pmgClient->flo.pStrData[i]);

        //
        // If the channel and priority match then we have found the stream.
        //
        if ((pmgClient->flo.pStrData[i]->channel  == channel) &&
            (pmgClient->flo.pStrData[i]->priority == priority))
        {
            break;
        }
    }

    //
    // If we hit the end of the list then return FLO_NOT_CONTROLLED.
    //
    if (i == cStreams)
    {
        i = FLO_NOT_CONTROLLED;
        *ppStr = NULL;

        TRACE_OUT(("Uncontrolled stream (0x%08x:%u)",
                   channel,
                   priority));
    }
    else
    {
        *ppStr = pmgClient->flo.pStrData[i];

        TRACE_OUT(("Controlled stream %u (0x%08x:%u)",
                   i,
                   channel,
                   priority));
    }

    DebugExitDWORD(FLOGetStream, i);
    return(i);
}



//
// FUNCTION: FLOAddUser
//
// DESCRIPTION:
//
// Add a new remote user entry for a stream.
//
// PARAMETERS:
//
// userID   - ID of the new user (single member channel ID)
// pStr     - pointer to the stream to receive the new user.
//
// RETURNS: Nothing
//
//
PFLO_USER FLOAddUser
(
    UINT                userID,
    PFLO_STREAM_DATA    pStr
)
{
    PFLO_USER           pFloUser;

    DebugEntry(FLOAddUser);

    ValidateFLOStr(pStr);

    //
    // Allocate memory for the new user entry
    //
    pFloUser = new FLO_USER;
    if (!pFloUser)
    {
        WARNING_OUT(("FLOAddUser failed; out of memory"));
    }
    else
    {
        ZeroMemory(pFloUser, sizeof(*pFloUser));
        SET_STAMP(pFloUser, FLOUSER);

        //
        // Set up the new record
        //
        TRACE_OUT(("UserID %u - New user, CB = 0x%08x", userID, pFloUser));
        pFloUser->userID = (TSHR_UINT16)userID;

        //
        // Add the new User to the end of the list
        //
        COM_BasedListInsertBefore(&(pStr->users), &(pFloUser->list));
    }

    DebugExitVOID(FLOAddUser);
    return(pFloUser);
}


//
// FLO_RemoveUser()
//
void FLO_RemoveUser
(
    PMG_CLIENT          pmgClient,
    UINT                userID
)
{
    PFLO_USER           pFloUser;
    PBASEDLIST             nextUser;
    UINT                stream;
    UINT                cStreams;
    PFLO_STREAM_DATA    pStr;

    DebugEntry(FLO_RemoveUser);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    cStreams = pmgClient->flo.numStreams;
    ASSERT(cStreams <= FLO_MAX_STREAMS);

    //
    // Check each stream
    //
    for (stream = 0; stream < cStreams; stream++)
    {
        if (pmgClient->flo.pStrData[stream] == NULL)
        {
            continue;
        }

        pStr = pmgClient->flo.pStrData[stream];
        ValidateFLOStr(pStr);

        //
        // Remove this user from the queue, if present
        //
        pFloUser = (PFLO_USER)COM_BasedNextListField(&(pStr->users));
        while (&(pFloUser->list) != &(pStr->users))
        {
            ValidateFLOUser(pFloUser);

            //
            // Address the follow on record before we free the current
            //
            nextUser = COM_BasedNextListField(&(pFloUser->list));

            //
            // Free the current record, if necessary
            //
            if (pFloUser->userID == userID)
            {
                //
                // Remove from the list
                //
                TRACE_OUT(("Freeing FLO_USER 0x%08x ID 0x%08x", pFloUser, pFloUser->userID));

                COM_BasedListRemove(&(pFloUser->list));
                delete pFloUser;

                TRACE_OUT(("Stream %u - resetting due to user disappearance",
                         stream));

                ValidateFLOStr(pStr);
                pStr->bytesInPipe   = 0;
                pStr->pingNeeded    = TRUE;
                pStr->nextPingTime  = GetTickCount();
                pStr->gotPong       = FALSE;
                pStr->eventNeeded   = FALSE;
                break;
            }

            //
            // Move on to the next record in the list
            //
            pFloUser = (PFLO_USER)nextUser;
        }

        //
        // Now wake the app again for this stream
        //
        if (pmgClient->flo.callBack != NULL)
        {
            (*(pmgClient->flo.callBack))(pmgClient,
                                   FLO_WAKEUP,
                                   pStr->priority,
                                   pStr->maxBytesInPipe);
        }
    }

    DebugExitVOID(FLO_RemoveUser);
}



//
// FLOStreamEndControl()
//
void FLOStreamEndControl
(
    PMG_CLIENT          pmgClient,
    UINT                stream
)
{
    PFLO_USER           pFloUser;
    PFLO_STREAM_DATA    pStr;
    PMG_BUFFER          pmgBuffer;

    DebugEntry(FLOStreamEndControl);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    //
    // Convert the stream id into a stream pointer.
    //
    ASSERT(stream < FLO_MAX_STREAMS);
    pStr = pmgClient->flo.pStrData[stream];
    ValidateFLOStr(pStr);


    //
    // Trace out that we are about to end flow control.
    //
    TRACE_OUT(("Flow control about to end, stream %u, (0x%08x:%u)",
           stream,
           pStr->channel,
           pStr->priority));

    //
    // First check to see if there are any outstanding buffer CBs with
    // pStr set to this stream and reset pStr to null. We need to do this
    // as we may then try to dereference pStr when we come to send these
    // buffers.
    //
    pmgBuffer = (PMG_BUFFER)COM_BasedListFirst(&(pmgClient->pendChain),
        FIELD_OFFSET(MG_BUFFER, pendChain));

    while (pmgBuffer != NULL)
    {
        ValidateMGBuffer(pmgBuffer);

        if (pmgBuffer->type == MG_TX_BUFFER)
        {
            //
            // Set the stream pointer to NULL.
            //
            pmgBuffer->pStr = NULL;
            TRACE_OUT(("Nulling stream pointer in bufferCB: (0x%08x:%u)",
                   pStr->channel, pStr->priority));
        }

        pmgBuffer = (PMG_BUFFER)COM_BasedListNext(&(pmgClient->pendChain),
            pmgBuffer, FIELD_OFFSET(MG_BUFFER, pendChain));
    }

    //
    // Now free up the list of users.
    //
    pFloUser = (PFLO_USER)COM_BasedListFirst(&(pStr->users), FIELD_OFFSET(FLO_USER, list));
    while (pFloUser != NULL)
    {
        ValidateFLOUser(pFloUser);

        //
        // First send the remote user a "pang" to tell them we are not
        // interested in their data any more.
        //
        FLOPang(pmgClient, stream, pFloUser->userID);

        //
        // Remove the remote user from the list.
        //
        TRACE_OUT(("Freeing FLO_USER 0x%08x ID 0x%08x", pFloUser, pFloUser->userID));

        COM_BasedListRemove(&(pFloUser->list));
        delete pFloUser;

        //
        // Now get the next user in the list.
        //
        ValidateFLOStr(pStr);
        pFloUser = (PFLO_USER)COM_BasedListFirst(&(pStr->users), FIELD_OFFSET(FLO_USER, list));
    }

    //
    // Free the stream data.
    //
    ASSERT(pStr == pmgClient->flo.pStrData[stream]);
    TRACE_OUT(("Freeing FLO_STREAM_DATA 0x%08x", pStr));

    delete pStr;
    pmgClient->flo.pStrData[stream] = NULL;

    //
    // Adjust numStreams (if required)
    //
    if (stream == (pmgClient->flo.numStreams - 1))
    {
        while ((pmgClient->flo.numStreams > 0) &&
               (pmgClient->flo.pStrData[pmgClient->flo.numStreams - 1] == NULL))
        {
            pmgClient->flo.numStreams--;
        }
        TRACE_OUT(("numStreams %u", pmgClient->flo.numStreams));
    }

    DebugExitVOID(FLOStreamEndControl);
}



//
// MGNewCorrelator()
//
// Gets a new correlator for events to a particular MGC client
//
void MGNewCorrelator
(
    PMG_CLIENT  pmgClient,
    WORD *      pCorrelator
)
{
    ValidateMGClient(pmgClient);

    pmgClient->joinNextCorr++;
    if (pmgClient->joinNextCorr == 0)
    {
        pmgClient->joinNextCorr++;
    }

    *pCorrelator = pmgClient->joinNextCorr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\oe.cpp ===
#include "precomp.h"


//
// OE.CPP
// Order Encoding
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_ORDER


//
// OE_PartyLeftShare()
//
void  ASShare::OE_PartyLeftShare(ASPerson * pasPerson)
{
    DebugEntry(ASShare::OE_PartyLeftShare);

    ValidatePerson(pasPerson);

    //
    // Free any font info for this person.
    //
    if (pasPerson->poeFontInfo)
    {
        TRACE_OUT(("FREED FONT DATA"));
        delete[] pasPerson->poeFontInfo;
        pasPerson->poeFontInfo = NULL;
        pasPerson->oecFonts = 0;
    }

    DebugExitVOID(ASShare::OE_PartyLeftShare);
}


//
// OE_RecalcCaps()
//
// Recalculates orders and fonts when somebody joins or leaves the share.
// Unlike the other components, this happens even when we ourselves are not
// hosting, we need this info to interpret data from remote hosts.
//
void  ASShare::OE_RecalcCaps(BOOL fJoiner)
{
    UINT        iOrder;
    ASPerson *  pasT;

    DebugEntry(ASShare::OE_RecalcCaps);

    ValidatePerson(m_pasLocal);

    //
    // Set the initial support to the local support.
    //
    memcpy(m_aoeOrderSupported, m_pasLocal->cpcCaps.orders.capsOrders,
        sizeof(m_pasLocal->cpcCaps.orders.capsOrders));

    //
    // m_aoeOrderSupported contains more entries than the CAPS_MAX_NUM_ORDERS
    // entries in the g_cpcLocalCaps.orders entry.  Set the additional values
    // to FALSE.
    //
    for (iOrder = CAPS_MAX_NUM_ORDERS;
         iOrder < ORD_NUM_INTERNAL_ORDERS; iOrder++)
    {
        m_aoeOrderSupported[iOrder] = FALSE;
    }

    //
    // The combined support for the r1.1 font protocol is initially
    // whatever the local support is.
    //
    m_oeCombinedOrderCaps.capsfFonts = m_pasLocal->cpcCaps.orders.capsfFonts;

    //
    // The combined support for encoding is initially the local values
    //
    m_oefOE2Negotiable = ((m_pasLocal->cpcCaps.orders.capsEncodingLevel &
                                CAPS_ENCODING_OE2_NEGOTIABLE) != 0);

    m_oefOE2EncodingOn = !((m_pasLocal->cpcCaps.orders.capsEncodingLevel &
                                  CAPS_ENCODING_OE2_DISABLED) != 0);
    m_oeOE2Flag = OE2_FLAG_UNKNOWN;

    if (m_oefOE2EncodingOn)
    {
        m_oeOE2Flag |= OE2_FLAG_SUPPORTED;
    }
    else
    {
        m_oeOE2Flag |= OE2_FLAG_NOT_SUPPORTED;
    }

    m_oefBaseOE = ((m_pasLocal->cpcCaps.orders.capsEncodingLevel &
                         CAPS_ENCODING_BASE_OE) != 0);

    m_oefAlignedOE = ((m_pasLocal->cpcCaps.orders.capsEncodingLevel &
                            CAPS_ENCODING_ALIGNED_OE) != 0);

    //
    // Loop through the people in the share and examine their order caps
    //
    for (pasT = m_pasLocal->pasNext; pasT != NULL; pasT = pasT->pasNext)
    {
        ValidatePerson(pasT);

        //
        // Check the orders in the orders capabilities.
        //
        for (iOrder = 0; iOrder < CAPS_MAX_NUM_ORDERS; iOrder++)
        {
            if (pasT->cpcCaps.orders.capsOrders[iOrder] < ORD_LEVEL_1_ORDERS)
            {
                //
                // The order is not supported at the level we want to send out
                // (currently ORD_LEVEL_1_ORDERS) so set the combined caps to
                // say not supported.
                //
                m_aoeOrderSupported[iOrder] = FALSE;
            }
        }

        m_oeCombinedOrderCaps.capsfFonts &=
            (pasT->cpcCaps.orders.capsfFonts | ~CAPS_FONT_AND_FLAGS);

        m_oeCombinedOrderCaps.capsfFonts |=
            (pasT->cpcCaps.orders.capsfFonts & CAPS_FONT_OR_FLAGS);

        //
        // Check Order encoding support
        //
        if (!(pasT->cpcCaps.orders.capsEncodingLevel & CAPS_ENCODING_OE2_NEGOTIABLE))
        {
            m_oefOE2Negotiable = FALSE;
            TRACE_OUT(("OE2 negotiation switched off by person [%d]", pasT->mcsID));
        }

        if (pasT->cpcCaps.orders.capsEncodingLevel & CAPS_ENCODING_OE2_DISABLED)
        {
            m_oefOE2EncodingOn = FALSE;
            m_oeOE2Flag |= OE2_FLAG_NOT_SUPPORTED;
            TRACE_OUT(("OE2 switched off by person [%d]", pasT->mcsID));
        }
        else
        {
            m_oeOE2Flag |= OE2_FLAG_SUPPORTED;
            TRACE_OUT(("OE2 supported by person [%d]", pasT->mcsID));
        }

        if (!(pasT->cpcCaps.orders.capsEncodingLevel & CAPS_ENCODING_BASE_OE))
        {
            m_oefBaseOE = FALSE;
            TRACE_OUT(("Base OE switched off by person [%d]", pasT->mcsID));
        }

        if (!(pasT->cpcCaps.orders.capsEncodingLevel & CAPS_ENCODING_ALIGNED_OE))
        {
            m_oefAlignedOE = FALSE;
            TRACE_OUT(("Aligned OE switched off by [%d]", pasT->mcsID));
        }
    }

    //
    // At 2.x, the DESKSCROLL order support is implied by the SCRBLT
    // support.
    //
    m_aoeOrderSupported[HIWORD(ORD_DESKSCROLL)] = m_aoeOrderSupported[HIWORD(ORD_SCRBLT)];

    //
    // Turn on the order support now that the table is set up.
    //
    m_oefSendOrders = TRUE;

    //
    // Check for incompatible capabilities:
    // - OE2 not negotiable but parties don't agree on OE2
    // - OE2 not supported but parties don't agree on OE.
    // If incompatabilites exist, switch off all order support.
    //
    if ((!m_oefOE2Negotiable) && (m_oeOE2Flag == OE2_FLAG_MIXED))
    {
        ERROR_OUT(("OE2 not negotiable but parties don't agree"));
        m_oefSendOrders = FALSE;
    }

    if (!m_oefOE2EncodingOn && !m_oefBaseOE && !m_oefAlignedOE)
    {
        ERROR_OUT(("None of OE, OE' or OE2 supported"));
        m_oefSendOrders = FALSE;
    }

    FH_DetermineFontSupport();

    OECapabilitiesChanged();

    DebugExitVOID(ASShare::OE_RecalcCaps);
}


//
// OE_SyncOutgoing()
// Called when share is created or someone new joins the share.  Disables
// text orders until we get fonts from all remotes.  Broadcasts our local
// supported font list.
//
void  ASShare::OE_SyncOutgoing(void)
{
    DebugEntry(OE_SyncOutgoing);

    //
    // Stop sending text orders until the font negotiation is complete.
    //
    OE_EnableText(FALSE);

    //
    // Resend font info
    //
    m_fhLocalInfoSent = FALSE;

    DebugExitVOID(ASShare::OE_SyncOutgoing);
}



//
// OE_Periodic - see oe.h
//
void  ASShare::OE_Periodic(void)
{
    DebugEntry(ASShare::OE_Periodic);

    //
    // If our local font information has not been sent, then send it now.
    //
    if (!m_fhLocalInfoSent)
    {
        FH_SendLocalFontInfo();
    }

    DebugExitVOID(ASShare::OE_Periodic);
}




//
// OE_EnableText
//
void  ASShare::OE_EnableText(BOOL enable)
{
    DebugEntry(ASShare::OE_EnableText);

    m_oefTextEnabled = (enable != FALSE);

    OECapabilitiesChanged();

    DebugExitVOID(ASShare::OE_EnableText);
}



//
// OE_RectIntersectsSDA()
//
BOOL  ASHost::OE_RectIntersectsSDA(LPRECT pRect)
{
    RECT  rectVD;
    BOOL  fIntersection = FALSE;
    UINT  i;

    DebugEntry(ASHost::OE_RectIntersectsSDA);

    //
    // Copy the supplied rectangle, converting to inclusive Virtual
    // Desktop coords.
    //
    rectVD.left   = pRect->left;
    rectVD.top    = pRect->top;
    rectVD.right  = pRect->right - 1;
    rectVD.bottom = pRect->bottom - 1;

    //
    // Loop through each of the bounding rectangles checking for
    // an intersection with the supplied rectangle.
    //
    for (i = 0; i < m_baNumRects; i++)
    {
        if ( (m_abaRects[i].left <= rectVD.right) &&
             (m_abaRects[i].top <= rectVD.bottom) &&
             (m_abaRects[i].right >= rectVD.left) &&
             (m_abaRects[i].bottom >= rectVD.top) )
        {
            TRACE_OUT(("Rect {%d, %d, %d, %d} intersects SDA {%d, %d, %d, %d}",
                rectVD.left, rectVD.top, rectVD.right, rectVD.bottom,
                m_abaRects[i].left, m_abaRects[i].top,
                m_abaRects[i].right, m_abaRects[i].bottom));
            fIntersection = TRUE;
            break;
        }
    }

    DebugExitBOOL(ASHost::OE_RectIntersectsSDA, fIntersection);
    return(fIntersection);
}



//
// OE_SendAsOrder()
//
BOOL  ASShare::OE_SendAsOrder(DWORD order)
{
    BOOL  rc = FALSE;

    DebugEntry(ASShare::OE_SendAsOrder);

    //
    // Only check the order if we are allowed to send orders in the first
    // place!
    //
    if (m_oefSendOrders)
    {
        TRACE_OUT(("Orders enabled"));

        //
        // We are sending some orders, so check individual flags.
        //
        rc = (m_aoeOrderSupported[HIWORD(order)] != 0);
        TRACE_OUT(("Send order 0x%08x HIWORD %hu", order, HIWORD(order)));
    }

    DebugExitBOOL(ASShare::OE_SendAsOrder, rc);
    return(rc);
}




//
// OE_GetStringExtent(..)
//
int  OE_GetStringExtent
(
    HDC         hdc,
    PTEXTMETRIC pMetric,
    LPSTR       lpszString,
    UINT        cbString,
    LPRECT      pRect
)
{
    SIZE        textExtent;
    UINT        i;
    ABC         abcSpace;
    PTEXTMETRIC pTextMetrics;
    int         overhang = 0;
    TEXTMETRIC  metricT;


    DebugEntry(OE_GetStringExtent);

    //
    // If no text metrics supplied, then use the global text metrics.
    //
    pTextMetrics = (pMetric != (PTEXTMETRIC)NULL)
                   ? pMetric
                   : &metricT;

    //
    // If there are no characters then return a NULL rectangle.
    //
    pRect->left   = 1;
    pRect->top    = 0;
    pRect->right  = 0;
    pRect->bottom = 0;

    if (cbString == 0)
    {
        TRACE_OUT(( "Zero length string"));
        DC_QUIT;
    }

    if (!GetTextExtentPoint32(hdc, (LPCTSTR)lpszString, cbString, &textExtent))
    {
        ERROR_OUT(( "Failed to get text extent, rc = %lu",
                 GetLastError()));
        DC_QUIT;
    }

    pRect->left   = 0;
    pRect->top    = 0;
    pRect->right  = textExtent.cx;
    pRect->bottom = textExtent.cy;

    //
    // We have the Windows text extent, which is the advance distance
    // for the string.  However, some fonts (eg TrueType with C spacing
    // or italic) may extend beyond this.  Add in this extra value here
    // if necessary.
    //
    if (pTextMetrics->tmPitchAndFamily & TMPF_TRUETYPE)
    {
        //
        // Get the ABC spacing of the last character in the string.
        //
        GetCharABCWidths(hdc, lpszString[cbString-1], lpszString[cbString-1],
                              &abcSpace );

        //
        // SFR 2916: Add in (not subtract) the C space of the last
        // character from the string extent.
        //
        overhang = abcSpace.abcC;
    }
    else
    {
        //
        // The font is not TrueType.  Add any global font overhang onto
        // the string extent.
        //
        overhang = pTextMetrics->tmOverhang;
    }

    pRect->right += overhang;

DC_EXIT_POINT:
    DebugExitDWORD(OE_GetStringExtent, overhang);
    return(overhang);
}


//
//
// Name:      OECapabilitiesChanged
//
// Purpose:   Called when the OE capabilities have been renegotiated.
//
// Returns:   Nothing
//
// Params:    None
//
//
void  ASShare::OECapabilitiesChanged(void)
{
    DebugEntry(ASShare::OECapabilitiesChanged);

    if (g_asCanHost)
    {
        OE_NEW_CAPABILITIES newCapabilities;

        newCapabilities.sendOrders     = (m_oefSendOrders != FALSE);

        newCapabilities.textEnabled    = (m_oefTextEnabled != FALSE);

        newCapabilities.baselineTextEnabled =
              (m_oeCombinedOrderCaps.capsfFonts & CAPS_FONT_ALLOW_BASELINE) != 0;

        newCapabilities.orderSupported = m_aoeOrderSupported;

        OSI_FunctionRequest(OE_ESC_NEW_CAPABILITIES, (LPOSI_ESCAPE_HEADER)&newCapabilities,
            sizeof(newCapabilities));
    }

    DebugExitVOID(ASShare::OECapabilitiesChanged);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\oe2.cpp ===
#include "precomp.h"


//
// OE2.CPP
// Order Encoding Second Level
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_ORDER

//
// OE2_HostStarting()
//
BOOL  ASHost::OE2_HostStarting(void)
{
    DebugEntry(ASHost::OE2_HostStarting);

    //
    // Set up the pointers for 2nd level encoding
    //
    m_oe2Tx.LastOrder[OE2_DSTBLT_ORDER    ] = &m_oe2Tx.LastDstblt;
    m_oe2Tx.LastOrder[OE2_PATBLT_ORDER    ] = &m_oe2Tx.LastPatblt;
    m_oe2Tx.LastOrder[OE2_SCRBLT_ORDER    ] = &m_oe2Tx.LastScrblt;
    m_oe2Tx.LastOrder[OE2_MEMBLT_ORDER    ] = &m_oe2Tx.LastMemblt;
    m_oe2Tx.LastOrder[OE2_MEM3BLT_ORDER   ] = &m_oe2Tx.LastMem3blt;
    m_oe2Tx.LastOrder[OE2_TEXTOUT_ORDER   ] = &m_oe2Tx.LastTextOut;
    m_oe2Tx.LastOrder[OE2_EXTTEXTOUT_ORDER] = &m_oe2Tx.LastExtTextOut;
    m_oe2Tx.LastOrder[OE2_RECTANGLE_ORDER ] = &m_oe2Tx.LastRectangle;
    m_oe2Tx.LastOrder[OE2_LINETO_ORDER    ] = &m_oe2Tx.LastLineTo;
    m_oe2Tx.LastOrder[OE2_OPAQUERECT_ORDER] = &m_oe2Tx.LastOpaqueRect;
    m_oe2Tx.LastOrder[OE2_SAVEBITMAP_ORDER] = &m_oe2Tx.LastSaveBitmap;
    m_oe2Tx.LastOrder[OE2_DESKSCROLL_ORDER] = &m_oe2Tx.LastDeskScroll;
    m_oe2Tx.LastOrder[OE2_MEMBLT_R2_ORDER ] = &m_oe2Tx.LastMembltR2;
    m_oe2Tx.LastOrder[OE2_MEM3BLT_R2_ORDER] = &m_oe2Tx.LastMem3bltR2;
    m_oe2Tx.LastOrder[OE2_POLYGON_ORDER   ] = &m_oe2Tx.LastPolygon;
    m_oe2Tx.LastOrder[OE2_PIE_ORDER       ] = &m_oe2Tx.LastPie;
    m_oe2Tx.LastOrder[OE2_ELLIPSE_ORDER   ] = &m_oe2Tx.LastEllipse;
    m_oe2Tx.LastOrder[OE2_ARC_ORDER       ] = &m_oe2Tx.LastArc;
    m_oe2Tx.LastOrder[OE2_CHORD_ORDER     ] = &m_oe2Tx.LastChord;
    m_oe2Tx.LastOrder[OE2_POLYBEZIER_ORDER] = &m_oe2Tx.LastPolyBezier;
    m_oe2Tx.LastOrder[OE2_ROUNDRECT_ORDER ] = &m_oe2Tx.LastRoundRect;

    //
    // Set up the last order values to a known value.
    //
    m_oe2Tx.LastOrderType = OE2_PATBLT_ORDER;
    m_oe2Tx.pLastOrder = (LPCOM_ORDER)m_oe2Tx.LastOrder[m_oe2Tx.LastOrderType];

    DebugExitBOOL(ASHost::OE2_HostStarting, TRUE);
    return(TRUE);
}


//
// OE2_HostEnded()
//
void ASHost::OE2_HostEnded(void)
{
    DebugEntry(ASHost::OE2_HostEnded);

    //
    // For OUTGOING order encoding, free the last font we cached.
    //
    if (m_oe2Tx.LastHFONT != NULL)
    {
        ASSERT(m_pShare);
        ASSERT(m_usrWorkDC);

        SelectFont(m_usrWorkDC, (HFONT)GetStockObject(SYSTEM_FONT));

        DeleteFont(m_oe2Tx.LastHFONT);
        m_oe2Tx.LastHFONT = NULL;
    }

    DebugExitVOID(ASHost::OE2_HostEnded);
}


//
// OE2_SyncOutgoing()
// Called when NEW dude starts to host, a share is created, or somebody new
// joins the share.
// Resets the OUTGOING 2nd level order encoding data.
//
void  ASHost::OE2_SyncOutgoing(void)
{
    DebugEntry(ASHost::OE2_SyncOutgoing);

    //
    // Set up the last order values to a known value.
    //
    m_oe2Tx.LastOrderType = OE2_PATBLT_ORDER;
    m_oe2Tx.pLastOrder = (LPCOM_ORDER)m_oe2Tx.LastOrder[m_oe2Tx.LastOrderType];

    //
    // Clear out all the last orders.
    //
    ZeroMemory(&m_oe2Tx.LastDstblt, sizeof(m_oe2Tx.LastDstblt));
    ((PATBLT_ORDER*)&m_oe2Tx.LastDstblt)->type = ORD_DSTBLT_TYPE;

    ZeroMemory(&m_oe2Tx.LastPatblt, sizeof(m_oe2Tx.LastPatblt));
    ((PATBLT_ORDER*)&m_oe2Tx.LastPatblt)->type = ORD_PATBLT_TYPE;

    ZeroMemory(&m_oe2Tx.LastScrblt, sizeof(m_oe2Tx.LastScrblt));
    ((PATBLT_ORDER*)&m_oe2Tx.LastScrblt)->type = ORD_SCRBLT_TYPE;

    ZeroMemory(&m_oe2Tx.LastMemblt, sizeof(m_oe2Tx.LastMemblt));
    ((PATBLT_ORDER*)&m_oe2Tx.LastMemblt)->type = ORD_MEMBLT_TYPE;

    ZeroMemory(&m_oe2Tx.LastMem3blt,sizeof(m_oe2Tx.LastMem3blt));
    ((PATBLT_ORDER*)&m_oe2Tx.LastMem3blt)->type = ORD_MEM3BLT_TYPE;

    ZeroMemory(&m_oe2Tx.LastTextOut, sizeof(m_oe2Tx.LastTextOut));
    ((PATBLT_ORDER*)&m_oe2Tx.LastTextOut)->type = ORD_TEXTOUT_TYPE;

    ZeroMemory(&m_oe2Tx.LastExtTextOut, sizeof(m_oe2Tx.LastExtTextOut));
    ((PATBLT_ORDER*)&m_oe2Tx.LastExtTextOut)->type = ORD_EXTTEXTOUT_TYPE;

    ZeroMemory(&m_oe2Tx.LastRectangle, sizeof(m_oe2Tx.LastRectangle));
    ((PATBLT_ORDER*)&m_oe2Tx.LastRectangle)->type = ORD_RECTANGLE_TYPE;

    ZeroMemory(&m_oe2Tx.LastPolygon, sizeof(m_oe2Tx.LastPolygon));
    ((POLYGON_ORDER*)&m_oe2Tx.LastPolygon)->type = ORD_POLYGON_TYPE;

    ZeroMemory(&m_oe2Tx.LastPie, sizeof(m_oe2Tx.LastPie));
    ((PIE_ORDER*)&m_oe2Tx.LastPie)->type = ORD_PIE_TYPE;

    ZeroMemory(&m_oe2Tx.LastEllipse, sizeof(m_oe2Tx.LastEllipse));
    ((ELLIPSE_ORDER*)&m_oe2Tx.LastEllipse)->type = ORD_ELLIPSE_TYPE;

    ZeroMemory(&m_oe2Tx.LastArc, sizeof(m_oe2Tx.LastArc));
    ((ARC_ORDER*)&m_oe2Tx.LastArc)->type = ORD_ARC_TYPE;

    ZeroMemory(&m_oe2Tx.LastChord, sizeof(m_oe2Tx.LastChord));
    ((CHORD_ORDER*)&m_oe2Tx.LastChord)->type = ORD_CHORD_TYPE;

    ZeroMemory(&m_oe2Tx.LastPolyBezier, sizeof(m_oe2Tx.LastPolyBezier));
    ((POLYBEZIER_ORDER*)&m_oe2Tx.LastPolyBezier)->type = ORD_POLYBEZIER_TYPE;

    ZeroMemory(&m_oe2Tx.LastRoundRect, sizeof(m_oe2Tx.LastRoundRect));
    ((ROUNDRECT_ORDER*)&m_oe2Tx.LastRoundRect)->type = ORD_ROUNDRECT_TYPE;

    ZeroMemory(&m_oe2Tx.LastLineTo, sizeof(m_oe2Tx.LastLineTo));
    ((PATBLT_ORDER*)&m_oe2Tx.LastLineTo)->type = ORD_LINETO_TYPE;

    ZeroMemory(&m_oe2Tx.LastOpaqueRect, sizeof(m_oe2Tx.LastOpaqueRect));
    ((PATBLT_ORDER*)&m_oe2Tx.LastOpaqueRect)->type = ORD_OPAQUERECT_TYPE;

    ZeroMemory(&m_oe2Tx.LastSaveBitmap, sizeof(m_oe2Tx.LastSaveBitmap));
    ((PATBLT_ORDER*)&m_oe2Tx.LastSaveBitmap)->type = ORD_SAVEBITMAP_TYPE;

    ZeroMemory(&m_oe2Tx.LastDeskScroll, sizeof(m_oe2Tx.LastDeskScroll));
    ((PATBLT_ORDER*)&m_oe2Tx.LastDeskScroll)->type = ORD_DESKSCROLL_TYPE;

    ZeroMemory(&m_oe2Tx.LastMembltR2, sizeof(m_oe2Tx.LastMembltR2));
    ((PATBLT_ORDER*)&m_oe2Tx.LastMembltR2)->type = ORD_MEMBLT_R2_TYPE;

    ZeroMemory(&m_oe2Tx.LastMem3bltR2, sizeof(m_oe2Tx.LastMem3bltR2));
    ((PATBLT_ORDER*)&m_oe2Tx.LastMem3bltR2)->type = ORD_MEM3BLT_R2_TYPE;

    ZeroMemory(&m_oe2Tx.LastBounds, sizeof(m_oe2Tx.LastBounds));

    DebugExitVOID(ASHost::OE2_SyncOutgoing);
}


//
// OE2_EncodeOrder()
//
TSHR_UINT16  ASHost::OE2_EncodeOrder
(
    LPINT_ORDER     pIntOrder,
    void *          pBuffer,
    TSHR_UINT16     cbBufferSize
)
{
    POE2ETFIELD     pTableEntry;
    LPSTR           pNextFreeSpace;
    UINT            thisFlag = 0;
    RECT            Rect;
    TSHR_RECT16     Rect16;
    UINT            cbEncodedOrderSize;
    UINT            cbMaxEncodedOrderSize;
    LPBYTE          pControlFlags;
    LPTSHR_UINT32_UA pEncodingFlags;
    LPSTR           pEncodedOrder;
    UINT            numEncodingFlagBytes;
    LPSTR           pVariableField;
    BOOL            useDeltaCoords;
    UINT            i;
    LPCOM_ORDER     pComOrder;
    UINT            fieldLength;
    UINT            numReps;

    DebugEntry(ASHost::OE2_EncodeOrder);

#ifdef ORDER_TRACE
    if (OE2_DebugOrderTrace)
    {
        TrcUnencodedOrder(pIntOrder);
    }
#endif // ORDER_TRACE

    //
    // Set up a pointer to the Common Order.
    //
    pComOrder = (LPCOM_ORDER)&(pIntOrder->OrderHeader.Common);

    //
    // Calculate the maximum bytes required to encode this order.
    //
    if (pComOrder->OrderHeader.fOrderFlags & OF_PRIVATE)
    {
        //
        // Private order.
        //
        cbMaxEncodedOrderSize = OE2_CONTROL_FLAGS_FIELD_SIZE +
                                COM_ORDER_SIZE(pComOrder);
    }
    else
    {
        //
        // Normal (not Private) order.
        //
        cbMaxEncodedOrderSize = OE2_CONTROL_FLAGS_FIELD_SIZE +
                                OE2_TYPE_FIELD_SIZE +
                                OE2_MAX_FIELD_FLAG_BYTES +
                                OE2_MAX_ADDITIONAL_BOUNDS_BYTES +
                                COM_ORDER_SIZE(pComOrder);
    }

    //
    // If we are not absolutely certain that the supplied buffer is big
    // enough to hold this order (encoded) then return immediately.
    //
    if (cbMaxEncodedOrderSize > cbBufferSize)
    {
        cbEncodedOrderSize = 0;
        goto encode_order_exit;
    }

    //
    // Set up some local variables to access the encoding buffer in various
    // ways.
    //
    pControlFlags = &((PDCEO2ORDER)pBuffer)->ControlFlags;
    pEncodedOrder = (LPSTR)&((PDCEO2ORDER)pBuffer)->EncodedOrder[0];
    pEncodingFlags = (LPTSHR_UINT32_UA)&pEncodedOrder[0];

    //
    // Initialise the control flags field to indicate this is a standard
    // encoding (ie the rest of the control flags have the meaning defined
    // by the rest of the OE2_CF_XXX definitions).
    //
    *pControlFlags = OE2_CF_STANDARD_ENC;

    //
    // If the private flag is set then we must return the encoded order
    // as it is (ie without doing any further encoding).
    //
    if (pComOrder->OrderHeader.fOrderFlags & OF_PRIVATE)
    {
        *pControlFlags |= OE2_CF_UNENCODED;

        cbEncodedOrderSize = SBC_CopyPrivateOrderData(
                                   (LPBYTE)pEncodedOrder,
                                   pComOrder,
                                   cbMaxEncodedOrderSize -
                                     FIELD_OFFSET(DCEO2ORDER, EncodedOrder) );

        cbEncodedOrderSize += FIELD_OFFSET(DCEO2ORDER, EncodedOrder);

        TRACE_OUT(( "PRIVATE order size %u", cbEncodedOrderSize));

        goto encode_order_exit;
    }

    //
    // If the type of this order is different to the last order encoded,
    // get a pointer to the last order of this type encoded and remember
    // what type of order it is.  We must also tell the decoding end that
    // this type is different from the last one, so set the new type flag
    // and copy type into buffer
    //
    // The "type" field come before the encoding flags so that the number
    // of flags we have can vary depending on the order. Set up a pointer
    // to these flags here depending on whether or not we have to encode
    // the order type.
    //
    if (TEXTFIELD(pComOrder)->type != ((PATBLT_ORDER*)m_oe2Tx.pLastOrder)->type)
    {
        TRACE_OUT(( "change type from %04X to %04X",
                     LOWORD(((PATBLT_ORDER*)m_oe2Tx.pLastOrder)->type),
                     LOWORD(TEXTFIELD(pComOrder)->type)));

        m_oe2Tx.LastOrderType = OE2GetOrderType(pComOrder);
        m_oe2Tx.pLastOrder = (LPCOM_ORDER)m_oe2Tx.LastOrder[m_oe2Tx.LastOrderType];
        *(LPBYTE)pEncodedOrder = m_oe2Tx.LastOrderType;
        *pControlFlags |= OE2_CF_TYPE_CHANGE;
        pEncodingFlags = (LPTSHR_UINT32_UA)&pEncodedOrder[1];
    }
    else
    {
        pEncodingFlags = (LPTSHR_UINT32_UA)&pEncodedOrder[0];
    }

    //
    // Work out how many bytes we will need to store the encoding flags in.
    // (We have a flag for each field in the order structure). This code
    // we have written will cope with up to a DWORD of encoding flags.
    //
    numEncodingFlagBytes= (s_etable.NumFields[m_oe2Tx.LastOrderType]+7)/8;
    if (numEncodingFlagBytes > OE2_MAX_FIELD_FLAG_BYTES)
    {
        ERROR_OUT(( "Too many flag bytes (%d) for this code", numEncodingFlagBytes));
    }

    //
    // Now we know how many bytes make up the flags we can get a pointer
    // to the position at which to start encoding the orders fields into.
    //
    pNextFreeSpace = ((LPSTR)pEncodingFlags) + numEncodingFlagBytes;

    //
    // Calculate the bounds.  If these are the same as those already in the
    // order header then there is no need to send any bounds because we can
    // recalculate them at the receiver.
    //
    m_pShare->OD2_CalculateBounds(pComOrder, &Rect, FALSE, m_pShare->m_pasLocal);
    TSHR_RECT16_FROM_RECT(&Rect16, Rect);
    if (memcmp(&(pComOrder->OrderHeader.rcsDst), &Rect16, sizeof(Rect16)))
    {
        TRACE_OUT(( "copy bounding rect"));
        OE2EncodeBounds((LPBYTE*)&pNextFreeSpace,
                        &pComOrder->OrderHeader.rcsDst);
        *pControlFlags |= OE2_CF_BOUNDS;
    }

    //
    // Before we do the field encoding (using s_etable) check all the field
    // entries flagged as coordinates to see if we can switch to
    // OE2_CF_DELTACOORDS mode.
    //
    pTableEntry = s_etable.pFields[m_oe2Tx.LastOrderType];

    useDeltaCoords = TRUE;

    //
    // Loop through each fixed field in this order structure...
    //
    while ( useDeltaCoords
              && (pTableEntry->FieldPos != 0)
              && ((pTableEntry->FieldType & OE2_ETF_FIXED) != 0) )
    {
        //
        // If this field entry is a coordinate then compare it to the
        // previous coordinate we sent for this field to determine whether
        // we can send it as a delta
        //
        if (pTableEntry->FieldType & OE2_ETF_COORDINATES)
        {
            useDeltaCoords =
                     OE2CanUseDeltaCoords(((LPSTR)pComOrder->abOrderData)
                                                     + pTableEntry->FieldPos,
                                          ((LPSTR)m_oe2Tx.pLastOrder)
                                                     + pTableEntry->FieldPos,
                                          pTableEntry->FieldUnencodedLen,
                                          pTableEntry->FieldSigned,
                                          1);
        }
        pTableEntry++;
    }

    //
    // Loop through each of the variable fields...
    //
    pVariableField = ((LPSTR)(pComOrder->abOrderData))
                   + pTableEntry->FieldPos;
    while (useDeltaCoords && (pTableEntry->FieldPos != 0))
    {
        //
        // The length of the field (in bytes) is given in the first
        // TSHR_UINT32 of the variable sized field structure.
        //
        fieldLength     = *(TSHR_UINT32 FAR *)pVariableField;
        pVariableField += sizeof(TSHR_UINT32);

        //
        // If this field entry is a coordinate then compare it to the
        // previous coordinate we sent for this field to determine whether
        // we can send it as a delta
        //
        if (pTableEntry->FieldType & OE2_ETF_COORDINATES)
        {
            //
            // The number of coordinates is given by the number of bytes in
            // the field divided by the size of each entry
            //
            numReps        = fieldLength / pTableEntry->FieldUnencodedLen;
            useDeltaCoords =
                     OE2CanUseDeltaCoords(pVariableField,
                                          ((LPSTR)m_oe2Tx.pLastOrder)
                                                     + pTableEntry->FieldPos,
                                          pTableEntry->FieldUnencodedLen,
                                          pTableEntry->FieldSigned,
                                          numReps);
        }

        //
        // Move on to the next field in the order structure.  Note that
        // variable sized fields are packed on the send side.  (ie
        // increment pVariableField by fieldLength not by
        // pTableEntry->FieldLen).
        //
        pVariableField += fieldLength;
        pTableEntry++;
    }

    if (useDeltaCoords)
    {
        *pControlFlags |= OE2_CF_DELTACOORDS;
    }

    //
    // Now do the encoding...
    //
    pTableEntry = s_etable.pFields[m_oe2Tx.LastOrderType];

    //
    // Clear the encoding flag bytes.
    //
    for (i = 0; i < numEncodingFlagBytes; i++)
    {
        ((LPBYTE)pEncodingFlags)[i] = 0;
    }

    thisFlag = 0x00000001;

    //
    // First process all the fixed size fields in the order structure...
    // (These come before the variable sized fields).
    //
    while (   (pTableEntry->FieldPos != 0)
           && (pTableEntry->FieldType & OE2_ETF_FIXED) )
    {
        //
        // If the field has changed since it was previously transmitted then
        // we need to send it again.
        //
        if (memcmp(
               ((LPBYTE)(pComOrder->abOrderData)) + pTableEntry->FieldPos,
               ((LPBYTE)m_oe2Tx.pLastOrder) + pTableEntry->FieldPos,
               pTableEntry->FieldUnencodedLen))
        {
            //
            // Update the encoding flags
            //
            *pEncodingFlags |= thisFlag;

            //
            // If we are encoding in delta coordinate mode and this field
            // is a coordinate...
            //
            if (useDeltaCoords &&
                      ((pTableEntry->FieldType & OE2_ETF_COORDINATES) != 0) )
            {
                OE2CopyToDeltaCoords((LPTSHR_INT8*)&pNextFreeSpace,
                                     (((LPSTR)pComOrder->abOrderData)
                                                     + pTableEntry->FieldPos),
                                     (((LPSTR)m_oe2Tx.pLastOrder)
                                                     + pTableEntry->FieldPos),
                                     pTableEntry->FieldUnencodedLen,
                                     pTableEntry->FieldSigned,
                                     1);
            }
            else
            {
                //
                // Update the data to be sent
                //
                OE2EncodeField(((LPBYTE)(pComOrder->abOrderData)) +
                                                       pTableEntry->FieldPos,
                               (LPBYTE*)&pNextFreeSpace,
                               pTableEntry->FieldUnencodedLen,
                               pTableEntry->FieldEncodedLen,
                               pTableEntry->FieldSigned,
                               1);

            }

            //
            // Save the current value for comparison next time.
            //
            memcpy(((LPBYTE)m_oe2Tx.pLastOrder) + pTableEntry->FieldPos,
                   ((LPBYTE)(pComOrder->abOrderData)) + pTableEntry->FieldPos,
                   pTableEntry->FieldUnencodedLen);
        }

        //
        // Move on to the next field in the structure.
        //
        thisFlag = thisFlag << 1;
        pTableEntry++;
    }

    //
    // Now process the variable sized entries...
    //
    pVariableField = ((LPSTR)(pComOrder->abOrderData))
                   + pTableEntry->FieldPos;
    while (pTableEntry->FieldPos != 0)
    {
        //
        // The length of the field is given in the first UINT of the
        // variable sized field structure.
        //
        fieldLength = *(TSHR_UINT32 FAR *)pVariableField;

        //
        // If the field has changed (either in size or in contents) then we
        // need to copy it across.
        //
        if (memcmp(pVariableField, ((LPBYTE)m_oe2Tx.pLastOrder) +
                    pTableEntry->FieldPos, fieldLength + sizeof(TSHR_UINT32)))
        {
            //
            // Update the encoding flags
            //
            *pEncodingFlags |= thisFlag;

            //
            // Work out how many elements we are encoding for this field.
            //
            numReps = fieldLength / pTableEntry->FieldUnencodedLen;

            //
            // Fill in the length of the field into the encoded buffer
            // (this is always encoded in a single byte), then increment
            // the pointer ready to encode the actual field.
            //
            // Note that the length must always be set to the length
            // required for regular second level encoding of the field,
            // regardless of whether regular encoding or delta encoding is
            // used.
            //
            ASSERT(numReps * pTableEntry->FieldEncodedLen < 256);
            *pNextFreeSpace =
                            (BYTE)(numReps * pTableEntry->FieldEncodedLen);
            pNextFreeSpace++;

            //
            // If we are encoding in delta coordinate mode and this field
            // is a coordinate...
            //
            if (useDeltaCoords &&
                       ((pTableEntry->FieldType & OE2_ETF_COORDINATES) != 0) )
            {
                //
                // Encode using delta coordinate encoding
                //
                OE2CopyToDeltaCoords((LPTSHR_INT8*)&pNextFreeSpace,
                                     pVariableField + sizeof(TSHR_UINT32),
                                     ((LPSTR)m_oe2Tx.pLastOrder)
                                           + pTableEntry->FieldPos
                                           + sizeof(TSHR_UINT32),
                                     pTableEntry->FieldUnencodedLen,
                                     pTableEntry->FieldSigned,
                                     numReps);
            }
            else
            {
                //
                // Use regular encoding
                //
                OE2EncodeField((LPBYTE)(pVariableField + sizeof(TSHR_UINT32)),
                               (LPBYTE*)&pNextFreeSpace,
                               pTableEntry->FieldUnencodedLen,
                               pTableEntry->FieldEncodedLen,
                               pTableEntry->FieldSigned,
                               numReps);

            }

            //
            // Keep data for comparison next time.
            //
            // Note that the variable fields of pLastOrder are not packed
            // (unlike the order which we are encoding), so we can use
            // pTableEntry->FieldPos to get the start of the field.
            //
            memcpy(((LPSTR)m_oe2Tx.pLastOrder) + pTableEntry->FieldPos,
                      pVariableField,
                      fieldLength + sizeof(TSHR_UINT32));
        }

        //
        // Move on to the next field in the order structure, remembering to
        // step.  Note that past the size field.  variable sized fields are
        // packed on the send side.  (ie increment pVariableField by
        // fieldLength not by pTableEntry->FieldLen).
        //
        pVariableField += fieldLength + sizeof(TSHR_UINT32);

        //
        // Make sure that we are at the next 4-byte boundary
        //
        if ((((UINT_PTR)pVariableField) % 4) != 0)
        {
            pVariableField += 4 - (((UINT_PTR)pVariableField) % 4);
        }

        thisFlag = thisFlag << 1;
        pTableEntry++;
    }

    //
    // record some stats:
    // Increment the count of order bytes of this type
    // Set the flags on for the fields which have been encoded
    //

    cbEncodedOrderSize = (UINT)(pNextFreeSpace - (LPSTR)pBuffer);

    TRACE_OUT(( "return %u flags %x,%x", cbEncodedOrderSize,
                                 (UINT)*pControlFlags, *pEncodingFlags));

encode_order_exit:
    //
    // "Insurance" check that we have not overwritten the end of the buffer.
    //
    if (cbEncodedOrderSize > cbBufferSize)
    {
        //
        // Oh dear!
        // We should never take this path - if we do, the code has gone
        // seriously wrong.
        //
        ERROR_OUT(( "End of buffer overwritten! enc(%d) buff(%d) type(%d)",
                     cbEncodedOrderSize,
                     cbBufferSize,
                     m_oe2Tx.LastOrderType));
    }

    //
    // Return the length of the encoded order
    //
    DebugExitDWORD(ASShare::OE2_EncodeOrder, cbEncodedOrderSize);
    return((TSHR_UINT16)cbEncodedOrderSize);
}



//
//
// OE2GetOrderType() - see oe2.h
//
//
BYTE  OE2GetOrderType(LPCOM_ORDER  pOrder)
{
    BYTE    type = 0xff;

    DebugEntry(OE2GetOrderType);

    TRACE_OUT(( "order type = %hx", TEXTFIELD(pOrder)->type));

    switch ( TEXTFIELD(pOrder)->type )
    {
        case ORD_DSTBLT_TYPE:
            type = OE2_DSTBLT_ORDER;
            break;

        case ORD_PATBLT_TYPE:
            type = OE2_PATBLT_ORDER;
            break;

        case ORD_SCRBLT_TYPE:
            type = OE2_SCRBLT_ORDER;
            break;

        case ORD_MEMBLT_TYPE:
            type = OE2_MEMBLT_ORDER;
            break;

        case ORD_MEM3BLT_TYPE:
            type = OE2_MEM3BLT_ORDER;
            break;

        case ORD_MEMBLT_R2_TYPE:
            type = OE2_MEMBLT_R2_ORDER;
            break;

        case ORD_MEM3BLT_R2_TYPE:
            type = OE2_MEM3BLT_R2_ORDER;
            break;

        case ORD_TEXTOUT_TYPE:
            type = OE2_TEXTOUT_ORDER;
            break;

        case ORD_EXTTEXTOUT_TYPE:
            type = OE2_EXTTEXTOUT_ORDER;
            break;

        case ORD_RECTANGLE_TYPE:
            type = OE2_RECTANGLE_ORDER;
            break;

        case ORD_LINETO_TYPE:
            type = OE2_LINETO_ORDER;
            break;

        case ORD_OPAQUERECT_TYPE:
            type = OE2_OPAQUERECT_ORDER;
            break;

        case ORD_SAVEBITMAP_TYPE:
            type = OE2_SAVEBITMAP_ORDER;
            break;

        case ORD_DESKSCROLL_TYPE:
            type = OE2_DESKSCROLL_ORDER;
            break;

        case ORD_POLYGON_TYPE:
            type = OE2_POLYGON_ORDER;
            break;

        case ORD_PIE_TYPE:
            type = OE2_PIE_ORDER;
            break;

        case ORD_ELLIPSE_TYPE:
            type = OE2_ELLIPSE_ORDER;
            break;

        case ORD_ARC_TYPE:
            type = OE2_ARC_ORDER;
            break;

        case ORD_CHORD_TYPE:
            type = OE2_CHORD_ORDER;
            break;

        case ORD_POLYBEZIER_TYPE:
            type = OE2_POLYBEZIER_ORDER;
            break;

        case ORD_ROUNDRECT_TYPE:
            type = OE2_ROUNDRECT_ORDER;
            break;

        default:
            ERROR_OUT(( "Unknown order type %x",
                        TEXTFIELD(pOrder)->type));

    }

    DebugExitDWORD(OE2GetOrderType, type);
    return(type);
}



//
// Given a pointer to 2 arrays, work out if the difference between every
// element at corresponding indices in the arrays can be represented by a
// delta (1 byte integer).
//
//   ARRAY1         - The first array
//   ARRAY2         - The second array
//   NUMELEMENTS    - The number of elements in the arrays
//   DELTASPOSSIBLE - The "return value".  Set to TRUE if all differences
//                    can be represented by deltas, FALSE if not.
//
#define CHECK_DELTA_ARRAY(ARRAY1, ARRAY2, NUMELEMENTS, DELTASPOSSIBLE)  \
{                                                                       \
    UINT  index;                                                      \
    int   delta;                                                      \
    (DELTASPOSSIBLE) = TRUE;                                            \
    for (index=0 ; index<(NUMELEMENTS) ; index++)                       \
    {                                                                   \
        delta = (ARRAY1)[index] - (ARRAY2)[index];                      \
        if (delta != (int)(TSHR_INT8)delta)                             \
        {                                                               \
            (DELTASPOSSIBLE) = FALSE;                                   \
            break;                                                      \
        }                                                               \
    }                                                                   \
}


//
//
// Name:      OE2CanUseDeltaCoords
//
// Purpose:   This function compares two arrays containing a number of
//            coordinate values.  If the difference between each
//            coordinate pair can be expressed as a byte sized delta
//            quantity then the function returns TRUE otherwise it returns
//            FALSE.
//
// Returns:   TRUE if delta coords can be used, FALSE otherwise
//
// Params:    IN pNewCoords  - Pointer to the new array
//            IN pOldCoords  - Pointer to the existing array
//            IN fieldLength - The size (in bytes) of each element in the
//                             array.
//            IN signedValue - TRUE of the elements in the arrays are
//                             signed values, FALSE otherwise.
//            IN numElements - The number of elements in the arrays.
//
//
BOOL  OE2CanUseDeltaCoords(void *  pNewCoords,
                                               void *  pOldCoords,
                                               UINT   fieldLength,
                                               BOOL   signedValue,
                                               UINT   numElements)
{
    LPTSHR_INT16    pNew16Signed   = (LPTSHR_INT16)pNewCoords;
    LPTSHR_INT32    pNew32Signed   = (LPTSHR_INT32)pNewCoords;
    LPTSHR_UINT16   pNew16Unsigned = (LPTSHR_UINT16)pNewCoords;
    LPUINT   pNew32Unsigned = (LPUINT)pNewCoords;
    LPTSHR_INT16    pOld16Signed   = (LPTSHR_INT16)pOldCoords;
    LPTSHR_INT32    pOld32Signed   = (LPTSHR_INT32)pOldCoords;
    LPTSHR_UINT16   pOld16Unsigned = (LPTSHR_UINT16)pOldCoords;
    LPUINT   pOld32Unsigned = (LPUINT)pOldCoords;
    BOOL      useDeltaCoords;

    DebugEntry(OE2CanUseDeltaCoords);

    switch (fieldLength)
    {
        case 2:
        {
            if (signedValue)
            {
                CHECK_DELTA_ARRAY(pNew16Signed,
                                  pOld16Signed,
                                  numElements,
                                  useDeltaCoords);
            }
            else
            {
                CHECK_DELTA_ARRAY(pNew16Unsigned,
                                  pOld16Unsigned,
                                  numElements,
                                  useDeltaCoords);
            }
        }
        break;

        case 4:
        {
            if (signedValue)
            {
                CHECK_DELTA_ARRAY(pNew32Signed,
                                  pOld32Signed,
                                  numElements,
                                  useDeltaCoords);
            }
            else
            {
                CHECK_DELTA_ARRAY(pNew32Unsigned,
                                  pOld32Unsigned,
                                  numElements,
                                  useDeltaCoords);
            }
        }
        break;

        default:
        {
            ERROR_OUT(( "Bad field length %d", fieldLength));
            useDeltaCoords = FALSE;
        }
        break;
    }

    DebugExitDWORD(OE2CanUseDeltaCoords, useDeltaCoords);
    return(useDeltaCoords);
}


//
// Given two arrays, fill in a delta array with each element holding
// ARRAY1[i] - ARRAY2[i]
//
//   DESTARRAY   - The delta array.  This is an array of TSHR_INT8s
//   ARRAY1      - The first array
//   ARRAY2      - The second array
//   NUMELEMENTS - The number of elements in the arrays
//
//
#define COPY_TO_DELTA_ARRAY(DESTARRAY, ARRAY1, ARRAY2, NUMELEMENTS)         \
{                                                                           \
    UINT index;                                                           \
    for (index=0 ; index<(NUMELEMENTS) ; index++)                           \
    {                                                                       \
        (DESTARRAY)[index] = (TSHR_INT8)((ARRAY1)[index] - (ARRAY2)[index]);   \
    }                                                                       \
}



//
//
// Name:      OE2CopyToDeltaCoords
//
// Purpose:   Copies an array of coordinate values to an array of delta
//            (byte sized) coordinate values relative to a reference array
//            of coordinate values.
//
// Returns:   Nothing
//
// Params:    IN/OUT ppDestination - Pointer to the start of the
//                                   destination delta array.  This is
//                                   updated to point to the byte following
//                                   the last delta on exit.
//            IN     pNewCoords    - Pointer to the new array
//            IN     pOldCoords    - Pointer to the reference array
//            IN     fieldLength   - The size (in bytes) of each element in
//                                   New/OldCoords arrays.
//            IN     signedValue   - TRUE of the elements in the coords
//                                   arrays are signed values, FALSE
//                                   otherwise.
//            IN     numElements   - The number of elements in the arrays.
//
// Operation: The caller should call OE2CanUseDeltaCoords() before calling
//            this function to ensure that the differences can be
//            encoded using delta coordingates.
//
//
void  OE2CopyToDeltaCoords(LPTSHR_INT8* ppDestination,
                                               void *  pNewCoords,
                                               void *  pOldCoords,
                                               UINT   fieldLength,
                                               BOOL   signedValue,
                                               UINT   numElements)
{

    LPTSHR_INT16    pNew16Signed   = (LPTSHR_INT16)pNewCoords;
    LPTSHR_INT32    pNew32Signed   = (LPTSHR_INT32)pNewCoords;
    LPTSHR_UINT16   pNew16Unsigned = (LPTSHR_UINT16)pNewCoords;
    LPUINT   pNew32Unsigned = (LPUINT)pNewCoords;
    LPTSHR_INT16    pOld16Signed   = (LPTSHR_INT16)pOldCoords;
    LPTSHR_INT32    pOld32Signed   = (LPTSHR_INT32)pOldCoords;
    LPTSHR_UINT16   pOld16Unsigned = (LPTSHR_UINT16)pOldCoords;
    LPUINT   pOld32Unsigned = (LPUINT)pOldCoords;

    DebugEntry(OE2CopyToDeltaCoords);

    switch (fieldLength)
    {
        case 2:
        {
            if (signedValue)
            {
                COPY_TO_DELTA_ARRAY(*ppDestination,
                                    pNew16Signed,
                                    pOld16Signed,
                                    numElements);
            }
            else
            {
                COPY_TO_DELTA_ARRAY(*ppDestination,
                                    pNew16Unsigned,
                                    pOld16Unsigned,
                                    numElements);
            }
        }
        break;

        case 4:
        {
            if (signedValue)
            {
                COPY_TO_DELTA_ARRAY(*ppDestination,
                                    pNew32Signed,
                                    pOld32Signed,
                                    numElements);
            }
            else
            {
                COPY_TO_DELTA_ARRAY(*ppDestination,
                                    pNew32Unsigned,
                                    pOld32Unsigned,
                                    numElements);
            }
        }
        break;

        default:
        {
            ERROR_OUT(( "Bad field length %d", fieldLength));
        }
        break;
    }

    //
    // Update the next free position in the destination buffer
    //
    *ppDestination += numElements;
    DebugExitVOID(OE2CopyToDeltaCoords);
}


//
// OE2EncodeBounds()
//
void  ASHost::OE2EncodeBounds
(
    LPBYTE *        ppNextFreeSpace,
    LPTSHR_RECT16   pRect
)
{
    LPBYTE          pFlags;

    DebugEntry(ASHost::OE2EncodeBounds);

    //
    // The encoding used is a byte of flags followed by a variable number
    // of 16bit coordinate values and 8bit delta coordinate values (which
    // may be interleaved).
    //

    //
    // The first byte of the encoding will contain the flags that represent
    // how the coordinates of the rectangle were encoded.
    //
    pFlags = *ppNextFreeSpace;
    *pFlags = 0;
    (*ppNextFreeSpace)++;

    //
    // For each of the four coordinate values in the rectangle:  If the
    // coordinate has not changed then the encoding is null.  If the
    // coordinate can be encoded as a delta then do so and set the
    // appropriate flag.  Otherwise copy the coordinate as a 16bit value
    // and set the appropriate flag.
    //
    if (m_oe2Tx.LastBounds.left != pRect->left)
    {
        if (OE2CanUseDeltaCoords(&pRect->left,
                                 &m_oe2Tx.LastBounds.left,
                                 sizeof(pRect->left),
                                 TRUE,  // signed value
                                 1))
        {
            OE2CopyToDeltaCoords((LPTSHR_INT8*)ppNextFreeSpace,
                                 &pRect->left,
                                 &m_oe2Tx.LastBounds.left,
                                 sizeof(pRect->left),
                                 TRUE,  // signed value
                                 1);
            *pFlags |= OE2_BCF_DELTA_LEFT;
        }
        else
        {
            *((LPTSHR_UINT16)(*ppNextFreeSpace)) = pRect->left;
            *pFlags |= OE2_BCF_LEFT;
            (*ppNextFreeSpace) = (*ppNextFreeSpace) + sizeof(TSHR_UINT16);
        }
    }

    if (m_oe2Tx.LastBounds.top != pRect->top)
    {
        if (OE2CanUseDeltaCoords(&pRect->top,
                                 &m_oe2Tx.LastBounds.top,
                                 sizeof(pRect->top),
                                 TRUE,  // signed value
                                 1))
        {
            OE2CopyToDeltaCoords((LPTSHR_INT8*)ppNextFreeSpace,
                                 &pRect->top,
                                 &m_oe2Tx.LastBounds.top,
                                 sizeof(pRect->top),
                                 TRUE,  // signed value
                                 1);
            *pFlags |= OE2_BCF_DELTA_TOP;
        }
        else
        {
            *((LPTSHR_UINT16)(*ppNextFreeSpace)) = pRect->top;
            *pFlags |= OE2_BCF_TOP;
            (*ppNextFreeSpace) = (*ppNextFreeSpace) + sizeof(TSHR_UINT16);
        }
    }

    if (m_oe2Tx.LastBounds.right != pRect->right)
    {
        if (OE2CanUseDeltaCoords(&pRect->right,
                                 &m_oe2Tx.LastBounds.right,
                                 sizeof(pRect->right),
                                 TRUE,  // signed value
                                 1))
        {
            OE2CopyToDeltaCoords((LPTSHR_INT8*)ppNextFreeSpace,
                                 &pRect->right,
                                 &m_oe2Tx.LastBounds.right,
                                 sizeof(pRect->right),
                                 TRUE,  // signed value
                                 1);
            *pFlags |= OE2_BCF_DELTA_RIGHT;
        }
        else
        {
            *((LPTSHR_UINT16)(*ppNextFreeSpace)) = pRect->right;
            *pFlags |= OE2_BCF_RIGHT;
            (*ppNextFreeSpace) = (*ppNextFreeSpace) + sizeof(TSHR_UINT16);
        }
    }

    if (m_oe2Tx.LastBounds.bottom != pRect->bottom)
    {
        if (OE2CanUseDeltaCoords(&pRect->bottom,
                                 &m_oe2Tx.LastBounds.bottom,
                                 sizeof(pRect->bottom),
                                 TRUE,  // signed value
                                 1))
        {
            OE2CopyToDeltaCoords((LPTSHR_INT8*)ppNextFreeSpace,
                                 &pRect->bottom,
                                 &m_oe2Tx.LastBounds.bottom,
                                 sizeof(pRect->bottom),
                                 TRUE,  // signed value
                                 1);
            *pFlags |= OE2_BCF_DELTA_BOTTOM;
        }
        else
        {
            *((LPTSHR_UINT16)(*ppNextFreeSpace)) = pRect->bottom;
            *pFlags |= OE2_BCF_BOTTOM;
            (*ppNextFreeSpace) = (*ppNextFreeSpace) + sizeof(TSHR_UINT16);
        }
    }

    //
    // Copy the rectangle for reference with the next encoding.
    //
    m_oe2Tx.LastBounds = *pRect;

    DebugExitVOID(ASHost::OE2EncodeBounds);
}



//
// OE2_UseFont()
//
BOOL  ASHost::OE2_UseFont
(
    LPSTR           pName,
    TSHR_UINT16     facelength,
    TSHR_UINT16     CodePage,
    TSHR_UINT16     MaxHeight,
    TSHR_UINT16     Height,
    TSHR_UINT16     Width,
    TSHR_UINT16     Weight,
    TSHR_UINT16     flags
)
{
    BOOL      rc = TRUE;

    DebugEntry(ASHost::OE2_UseFont);

    if ((!m_oe2Tx.LastHFONT) ||
        (m_oe2Tx.LastFontFaceLen != facelength) ||
        (memcmp(m_oe2Tx.LastFaceName, pName, facelength)) ||
        (m_oe2Tx.LastCodePage   != CodePage) ||
        (m_oe2Tx.LastFontHeight != Height ) ||
        (m_oe2Tx.LastFontWidth  != Width  ) ||
        (m_oe2Tx.LastFontWeight != Weight ) ||
        (m_oe2Tx.LastFontFlags  != flags  ))
    {
        memcpy(m_oe2Tx.LastFaceName, pName, facelength);
        m_oe2Tx.LastFaceName[facelength] = '\0';
        m_oe2Tx.LastFontFaceLen          = facelength;
        m_oe2Tx.LastCodePage   = CodePage;
        m_oe2Tx.LastFontHeight = Height;
        m_oe2Tx.LastFontWidth  = Width;
        m_oe2Tx.LastFontWeight = Weight;
        m_oe2Tx.LastFontFlags  = flags;

        rc = m_pShare->USR_UseFont(m_usrWorkDC,
                         &m_oe2Tx.LastHFONT,
                         &m_oe2Tx.LastFontMetrics,
                         (LPSTR)m_oe2Tx.LastFaceName,
                         CodePage,
                         MaxHeight,
                         Height,
                         Width,
                         Weight,
                         flags);
    }

    DebugExitBOOL(ASHost::OE2_UseFont, rc);
    return(rc);
}



//
// Copy an array of source elements to an array of destination elements,
// converting the types as the copy takes place.
//
//   DESTARRAY   - The destination array
//   SRCARRAY    - The source array
//   DESTTYPE    - The type of the elements in the destination array
//   NUMELEMENTS - The number of elements in the array
//
//
#define CONVERT_ARRAY(DESTARRAY, SRCARRAY, DESTTYPE, NUMELEMENTS)     \
{                                                           \
    UINT index;                                           \
    for (index=0 ; index<(NUMELEMENTS) ; index++)           \
    {                                                       \
        (DESTARRAY)[index] = (DESTTYPE)(SRCARRAY)[index];   \
    }                                                       \
}


//
// OE2EncodeField - see oe2.h
//
void  OE2EncodeField(void *    pSrc,
                    LPBYTE*  ppDest,
                                         UINT     srcFieldLength,
                                         UINT     destFieldLength,
                                         BOOL     signedValue,
                                         UINT     numElements)
{
    LPTSHR_UINT8    pSrc8           = (LPTSHR_UINT8)pSrc;
    LPTSHR_INT16    pSrc16Signed    = (LPTSHR_INT16)pSrc;
    LPTSHR_INT32    pSrc32Signed    = (LPTSHR_INT32)pSrc;
    LPTSHR_INT8     pDest8Signed    = (LPTSHR_INT8)*ppDest;
    LPTSHR_INT16_UA pDest16Signed   = (LPTSHR_INT16_UA)*ppDest;

    //
    // Note that the source fields may not be aligned correctly, so we use
    // unaligned pointers.  The destination is aligned correctly.
    //

    DebugEntry(OE2EncodeField);

    //
    // We can ignore signed values since we only ever truncate the data.
    // Consider the case where we have a 16 bit integer that we want to
    // convert to 8 bits.  We know our values are permissable within the
    // lower integer size (ie.  we know the unsigned value will be less
    // than 256 of that a signed value will be -128 >= value >= 127), so we
    // just need to make sure that we have the right high bit set.
    //
    // But this must be the case for a 16-bit equivalent of an 8-bit
    // number.  No problems - just take the truncated integer.
    //
    //
    // Make sure that the destination field length is larger or equal to
    // the source field length.  If it isn't, something has gone wrong.
    //
    if (srcFieldLength < destFieldLength)
    {
        ERROR_OUT(( "Source field length %d is smaller than destination %d",
                     srcFieldLength,
                     destFieldLength));
        DC_QUIT;
    }

    //
    // If the source and destination field lengths are the same, we can
    // just do a copy (no type conversion required).
    //
    if (srcFieldLength == destFieldLength)
    {
        memcpy(*ppDest, pSrc, destFieldLength * numElements);
    }
    else
    {
        //
        // We know that srcFieldLength must be greater than destFieldLength
        // because of our checks above.  So there are only three
        // conversions to consider:
        //
        //   16 bit ->  8 bit
        //   32 bit ->  8 bit
        //   32 bit -> 16 bit
        //
        // We can ignore the sign as all we are ever doing is truncating
        // the integer.
        //
        if ((srcFieldLength == 4) && (destFieldLength == 1))
        {
            CONVERT_ARRAY(pDest8Signed,
                          pSrc32Signed,
                          TSHR_INT8,
                          numElements);
        }
        else if ((srcFieldLength == 4) && (destFieldLength == 2))
        {
            CONVERT_ARRAY(pDest16Signed,
                          pSrc32Signed,
                          TSHR_INT16,
                          numElements);
        }
        else if ((srcFieldLength == 2) && (destFieldLength == 1))
        {
            CONVERT_ARRAY(pDest8Signed,
                          pSrc16Signed,
                          TSHR_INT8,
                          numElements);
        }
        else
        {
            ERROR_OUT(( "Bad conversion, dest length = %d, src length = %d",
                         destFieldLength,
                         srcFieldLength));
        }
    }

DC_EXIT_POINT:
    *ppDest += destFieldLength * numElements;
    DebugExitVOID(OE2EncodeField);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\pm.cpp ===
#include "precomp.h"


//
// PM.CPP
// Palette Manager
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE

//
//
// PALETTE MANAGER (PM) OVERVIEW
//
// Palette Manager is responsible for sending palette packets.  A palette
// packet:
//
// (1) indicates the colors being used on the host machine - and therefore
// specifies which colors the remote machine should use if it can choose
// (e.g.  by selecting and realizing the given colors into the display
// hardware).  [A palette packet may not contain the exact colors being
// used on the host if the protocol bpp is different from the host bpp].
//
// (2) specifies the colors which correspond to the values in bitmap
// (screen) data i.e.  the values in 4bpp and 8bpp bitmap data are indices
// into the table of colors sent in the palette packet.
//
//
// (1) affects order replay and (2) affects screen data replay, so a
// correct palette packet must be sent (by calling
// PM_MaybeSendPalettePacket) before a batch of updates are sent.
//
// Palette Manager also handles incoming palette packets from other parties
// in the conference and creates corresponding local palettes which the
// Update Receiver can query and use when processing updates.
//
// When a new palette packet is sent (e.g.  due to the System Palette
// changing), all shared areas of the screen will be retransmitted in due
// course.  A receiving Palette Manager therefore does not have to (and
// should not attempt to) convert any updates/bitmaps that have been
// received prior to the arrival of the new palette packet.
//
//

//
// PM strategy when network packets cannot be allocated.
//
// PM_MaybeSendPalettePacket returns a boolean indicating whether it has
// succesfully sent a palette packet.  The USR will only send updates if
// the corresponding palette packet is successfully sent.
//
//


const COLORREF s_apmGreyRGB[PM_GREY_COUNT] =
{
    PM_GREY1,
    PM_GREY2,
    PM_GREY3,
    PM_GREY4,
    PM_GREY5
};



//
// PM_PartyLeftShare()
//
void  ASShare::PM_PartyLeftShare(ASPerson * pasPerson)
{
    DebugEntry(ASShare::PM_PartyLeftShare);

    ValidatePerson(pasPerson);

    // This should be cleared already!
    ASSERT(!pasPerson->pmcColorTable);
    ASSERT(!pasPerson->apmColorTable);
    ASSERT(!pasPerson->pmPalette);

    DebugExitVOID(ASShare::PM_PartyLeftShare);
}



//
// PM_RecalcCaps()
//
// This calculates the PM hosting caps when
//      * we start to host
//      * we're hosting and somebody joins the share
//      * we're hosting and somebody leaves the share
//
// This can GO AWAY WHEN 2.x COMPAT IS GONE -- no more min() of cache size
//
void  ASShare::PM_RecalcCaps(BOOL fJoiner)
{
    ASPerson *  pasT;

    DebugEntry(ASShare::PM_RecalcCaps);

    if (!m_pHost || !fJoiner)
    {
        //
        // Nothing to do if we're not hosting.  And also, if somebody has
        // left, no recalculation -- 2.x didn't.
        //
        DC_QUIT;
    }

    ValidatePerson(m_pasLocal);

    //
    // NOTE:
    // The default size is 6 palettes cached.  The result is going to be
    // <= that number.  There's no point in recreating the cache, it's
    // so small.
    //
    m_pHost->m_pmNumTxCacheEntries = m_pasLocal->cpcCaps.palette.capsColorTableCacheSize;

DC_EXIT_POINT:
    DebugExitVOID(ASShare::PM_Recalccaps);
}


//
// PM_HostStarting()
//
// Called when we start to host; sets up color palette stuff and creates
// outgoing palette cache
//
BOOL  ASHost::PM_HostStarting(void)
{
    BOOL    rc = FALSE;
    TSHR_COLOR  localPalColors[PM_NUM_8BPP_PAL_ENTRIES];

    DebugEntry(ASHost::PM_HostStarting);

    //
    // Get palette caps.  NOTE PM_RecalcCaps must be called AFTER
    // USR_RecalcCaps(), because that updates m_usrSendingBPP.
    //
    if (g_usrPalettized)
    {
        ASSERT(g_usrScreenBPP <= 8);

        ZeroMemory(localPalColors, sizeof(localPalColors));

        //
        // Now create the Local Palette.
        //
        if (!m_pShare->PM_CreatePalette(COLORS_FOR_BPP(g_usrScreenBPP),
                localPalColors, &m_pmTxPalette))
        {
            ERROR_OUT(( "Failed to create Local Palette"));
            DC_QUIT;
        }
    }
    else
    {
        m_pmTxPalette = (HPALETTE)GetStockObject(DEFAULT_PALETTE);
        PMGetGrays();
    }

    //
    // With NM 3.0, why not just create a receive cache the size that
    // the host specifies in his caps?
    //
    // So I did that.  For back compat, OUTGOING caches use the min size.
    // When we only have to be compatible with NM 3.0 and up, we won't
    // have to do this min stuff.
    //
    // Note similar code in CM, SSI, and SBC
    //

    // Figure out how many outgoing entries we can actually use
    m_pShare->PM_RecalcCaps(TRUE);

    //
    // Create the PM color table cache with a single eviction
    // category.
    //
    if (!CH_CreateCache(&m_pmTxCacheHandle, TSHR_PM_CACHE_ENTRIES,
            1, 0, PMCacheCallback))
    {
        ERROR_OUT(("Could not create PM cache"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::PM_HostStarting, rc);
    return(rc);
}



//
// PM_HostEnded()
//
// We free resources created when we started to host
//
void  ASHost::PM_HostEnded(void)
{
    DebugEntry(ASHost::PM_HostEnded);

    if (m_pmTxPalette)
    {
        m_pShare->PM_DeletePalette(m_pmTxPalette);
        m_pmTxPalette = NULL;
    }

    if (m_pmTxCacheHandle)
    {
        CH_DestroyCache(m_pmTxCacheHandle);
        m_pmTxCacheHandle = 0;
        m_pmNumTxCacheEntries = 0;
    }

    DebugExitVOID(ASHost::PM_HostEnded);
}



//
// PM_ViewStarting()
//
// For 3.0 nodes, we create the PM cache each time they start hosting
// For 2.x nodes, we create the PM cache once and use it until they leave
//      the share.
//
BOOL  ASShare::PM_ViewStarting(ASPerson * pasPerson)
{
    BOOL    rc = FALSE;

    DebugEntry(ASShare::PM_ViewStarting);

    ValidatePerson(pasPerson);

    //
    // In normal operation, we will receive a palette packet from the host
    // before any updates, which we use to create the correct palette for
    // this host.
    //
    // However, in some back-level calls we may not receive a palette
    // packet before the first updates, so we initialize this host's
    // palette to the default palette to allow us to generate some sort
    // of output.
    //
    pasPerson->pmPalette = (HPALETTE)GetStockObject(DEFAULT_PALETTE);

    //
    // Allocate color table cache memory based on the negotiated options
    // Space needed is (n)x256xRGBQUAD where n is the number of color
    // tables the conference supports.
    //
    pasPerson->pmcColorTable = pasPerson->cpcCaps.palette.capsColorTableCacheSize;

    if (!pasPerson->pmcColorTable)
    {
        WARNING_OUT(("PM_ViewStarting: person [%d] has no palette cache size",
            pasPerson->cpcCaps.palette.capsColorTableCacheSize));
        rc = TRUE;
        DC_QUIT;
    }

    pasPerson->apmColorTable = new COLORTABLECACHE[pasPerson->pmcColorTable];
    if (!pasPerson->apmColorTable)
    {
        ERROR_OUT(( "Failed to get memory for PM color table cache"));
        DC_QUIT;
    }

    ZeroMemory(pasPerson->apmColorTable, pasPerson->pmcColorTable * sizeof(COLORTABLECACHE));

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::PM_ViewStarting, rc);
    return(rc);
}



//
// PM_ViewEnded()
//
void  ASShare::PM_ViewEnded(ASPerson * pasPerson)
{
    DebugEntry(ASShare::PM_ViewEnded);

    ValidatePerson(pasPerson);

    PMFreeIncoming(pasPerson);

    DebugExitVOID(ASShare::PM_PartyViewEnded);
}



//
// PMFreeIncoming()
//
void ASShare::PMFreeIncoming(ASPerson * pasPerson)
{
    DebugEntry(ASShare::PMFreeIncoming);

    //
    // Free the color table cache
    //
    pasPerson->pmcColorTable = 0;
    if (pasPerson->apmColorTable)
    {
        delete[] pasPerson->apmColorTable;
        pasPerson->apmColorTable = NULL;
    }

    if (pasPerson->pmPalette != NULL)
    {
        //
        // Free this host's palette.  and set it to NULL so that we can tell
        // that this host has left the share.
        //
        PM_DeletePalette(pasPerson->pmPalette);
        pasPerson->pmPalette = NULL;
    }

    DebugExitVOID(ASShare::PMFreeIncoming);
}

//
// PM_MaybeSendPalettePacket()
//
BOOL  ASHost::PM_MaybeSendPalettePacket(void)
{
    BOOL  rc = TRUE;

    DebugEntry(ASHost::PM_MaybeSendPalettePacket);

    if (m_pmMustSendPalette)
    {
        ASSERT(m_usrSendingBPP <= 8);

        //
        // Ensure that our palette colors are up to date before we send the
        // palette packet.
        //
        if (g_usrPalettized)
        {
            PMUpdateSystemPaletteColors();
        }

        PMUpdateTxPaletteColors();
    }
    else if (g_usrPalettized)
    {
        ASSERT(m_usrSendingBPP <= 8);

        //
        // If the System Palette has changed then we may need to send
        // another palette packet.
        //
        if (PMUpdateSystemPaletteColors())
        {
            //
            // The System Palette has changed, but we only need to send
            // another palette packet if the palette colors have changed.
            //
            TRACE_OUT(( "System Palette changed"));

            if (PMUpdateTxPaletteColors())
            {
                TRACE_OUT(( "Tx Palette changed"));
                m_pmMustSendPalette = TRUE;
            }
        }
    }

    if (m_pmMustSendPalette)
    {
        ASSERT(m_usrSendingBPP <= 8);

        TRACE_OUT(( "Send palette packet"));

        rc = PMSendPalettePacket(m_apmTxPaletteColors, COLORS_FOR_BPP(m_usrSendingBPP));

        if (rc)
        {
            m_pmMustSendPalette = FALSE;
        }
    }

    DebugExitBOOL(ASHost::PM_MaybeSendPalettePacket, rc);
    return(rc);
}


//
// PM_ReceivedPacket
//
void  ASShare::PM_ReceivedPacket
(
    ASPerson *      pasPerson,
    PS20DATAPACKET  pPacket
)
{
    PPMPACKET       pPMPacket;
    HPALETTE        newPalette    = NULL;

    DebugEntry(ASShare::PM_ReceivedPacket);

    ValidateView(pasPerson);

    pPMPacket = (PPMPACKET)pPacket;

    //
    // Create a new palette from the received packet.
    //
    // We cannot just update the current palette colors (using
    // SetPaletteEntries) because Windows does not handle the repainting
    // of other local Palette Manager apps correctly (it does not
    // broadcast the WM_PALETTE.. messages as the palette mapping does
    // not change).
    //
    if (PM_CreatePalette(pPMPacket->numColors, pPMPacket->aColors,
            &newPalette))
    {
        PM_DeletePalette(pasPerson->pmPalette);
        pasPerson->pmPalette = newPalette;

        TRACE_OUT(( "Created new palette 0x%08x from packet", newPalette));
    }
    else
    {
        WARNING_OUT(( "Failed to create palette. person(%u) numColors(%u)",
            pasPerson, pPMPacket->numColors));
    }


    DebugExitVOID(ASShare::PM_ReceivedPacket);
}


//
// PM_SyncOutgoing()
//
void  ASHost::PM_SyncOutgoing(void)
{
    DebugEntry(ASHost::PM_SyncOutgoing);

    //
    //  Ensure we send a palette to the remote PM next time we are called.
    //
    if (m_usrSendingBPP <= 8)
    {
        m_pmMustSendPalette = TRUE;

        //
        // The sync discards any as-yet-unsent accumulated orders. Since these
        // orders may include color table cache orders, clear the cache.
        //
        ASSERT(m_pmTxCacheHandle);
        CH_ClearCache(m_pmTxCacheHandle);
    }

    DebugExitVOID(ASHost::PM_SyncOutgoing);
}


//
// PM_CacheTxColorTable
//
BOOL  ASHost::PM_CacheTxColorTable
(
    LPUINT          pIndex,
    LPBOOL          pCacheChanged,
    UINT            cColors,
    LPTSHR_RGBQUAD  pColors
)
{
    BOOL                rc             = FALSE;
    UINT                cacheIndex     = 0;
    UINT                i              = 0;
    PCOLORTABLECACHE    pEntry         = NULL;
    COLORTABLECACHE     newEntry       = { 0 };

    DebugEntry(ASHost::PM_CacheTxColorTable);

    ASSERT(m_usrSendingBPP <= 8);
    ASSERT(m_pmTxCacheHandle);

    TRACE_OUT(( "Caching table of %u colors", cColors));

    //
    // Create the data we want to cache.  It may be that there is already
    // an entry in the cache for this set of colors, but we still need to
    // create a cache entry in local memory so we can search the cache to
    // find out.
    //
    ZeroMemory(&newEntry, sizeof(COLORTABLECACHE));

    newEntry.inUse = TRUE;
    newEntry.cColors = cColors;
    memcpy(&newEntry.colors, pColors, cColors * sizeof(TSHR_RGBQUAD));

    //
    // Check to see if the table is already cached. (No hint or eviction
    // category.)
    //
    if (CH_SearchCache(m_pmTxCacheHandle, (LPBYTE)(&newEntry),
            sizeof(COLORTABLECACHE), 0, &cacheIndex ))
    {
        TRACE_OUT(( "Found existing entry at %u",cacheIndex));
        *pIndex = cacheIndex;
        *pCacheChanged = FALSE;
        rc = TRUE;
        DC_QUIT;
    }

    //
    // Find a free cache entry
    //
    // We arrange that our transmit cache is always one greater than the
    // negotiated cache size so that we should never fail to find a free
    // array entry.  Once we have fully populated our Tx cache we will
    // always find the free entry as the one last given back to us by CH.
    // Note the scan to <= m_pmNumTxCacheEntries is NOT a mistake.
    //
    if (m_pmNextTxCacheEntry != NULL)
    {
        pEntry = m_pmNextTxCacheEntry;
        m_pmNextTxCacheEntry = NULL;
    }
    else
    {
        for (i = 0; i <= m_pmNumTxCacheEntries; i++)
        {
            if (!m_apmTxCache[i].inUse)
            {
                break;
            }
        }

        //
        // We should never run out of free entries, but cope with it
        //
        if (i > m_pmNumTxCacheEntries)
        {
            ERROR_OUT(( "All PM cache entries in use"));
            rc = FALSE;
            DC_QUIT;
        }
        pEntry = m_apmTxCache + i;
    }


    //
    // Set up the color table in the free entry we just found
    //
    memcpy(pEntry, &newEntry, sizeof(COLORTABLECACHE));

    //
    // Add the new entry to the cache
    // We do not use hints or eviction so set to 0
    //
    cacheIndex = CH_CacheData(m_pmTxCacheHandle, (LPBYTE)pEntry,
        sizeof(COLORTABLECACHE), 0 );
    TRACE_OUT(( "Color table 0x%08x cached at index %u", pEntry, cacheIndex));
    *pIndex = cacheIndex;
    *pCacheChanged = TRUE;
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(ASHost::PM_CacheTxColorTable, rc);
    return(rc);
}


//
// PM_CacheRxColorTable
//
BOOL  ASShare::PM_CacheRxColorTable
(
    ASPerson *          pasPerson,
    UINT                index,
    UINT                cColors,
    LPTSHR_RGBQUAD      pColors
)
{
    BOOL                rc             = FALSE;
    PCOLORTABLECACHE    pColorTable;

    DebugEntry(ASShare::PM_CacheRxColorTable);

    ValidatePerson(pasPerson);

    pColorTable = pasPerson->apmColorTable;
    TRACE_OUT(( "Person [%d] color table rx cache 0x%08x cache %u, %u colors",
         pasPerson->mcsID, pColorTable, index, cColors));

    if (pColorTable == NULL)
    {
        ERROR_OUT(( "Asked to cache when no cache allocated"));
        DC_QUIT;
    }

    //
    // The index must be within the currently negotiated cache limits
    //
    if (index > pasPerson->pmcColorTable)
    {
        ERROR_OUT(( "Invalid color table index %u",index));
        DC_QUIT;
    }

    //
    // Set up the color table entry
    //
    pColorTable[index].inUse = TRUE;
    pColorTable[index].cColors = cColors;
    memcpy(pColorTable[index].colors, pColors, cColors * sizeof(TSHR_RGBQUAD));

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(ASShare::PM_CacheRxColorTable, rc);
    return(rc);
}



//
// PMSendPalettePacket
//
// DESCRIPTION:
//
// Sends a palette packet containing the given colors.
//
// PARAMETERS:
//
// pColorTable - pointer to an array of TSHR_RGBQUAD colors to be sent in the
// palette packet.
//
// numColors - the number of entries in the TSHR_RGBQUAD array
//
// RETURNS: TRUE if the palette packet is sent, FALSE otherwise
//
//
BOOL  ASHost::PMSendPalettePacket
(
    LPTSHR_RGBQUAD  pColorTable,
    UINT            numColors
)
{
    PPMPACKET       pPMPacket;
    UINT            sizePkt;
    UINT            i;
    BOOL            rc = FALSE;
#ifdef _DEBUG
    UINT            sentSize;
#endif // _DEBUG

    DebugEntry(ASHost::PMSendPalettePacket);

    //
    // Send a palette packet.
    //
    // First calculate the packet size.
    //
    sizePkt = sizeof(PMPACKET) + (numColors - 1) * sizeof(TSHR_COLOR);
    pPMPacket = (PPMPACKET)m_pShare->SC_AllocPkt(PROT_STR_UPDATES, g_s20BroadcastID, sizePkt);
    if (!pPMPacket)
    {
        WARNING_OUT(("Failed to alloc PM packet, size %u", sizePkt));
        DC_QUIT;
    }

    //
    // Fill in the packet contents.
    //
    pPMPacket->header.header.data.dataType  = DT_UP;
    pPMPacket->header.updateType            = UPD_PALETTE;

    //
    // Convert the TSHR_RGBQUADs in the color table to TSHR_COLORs as we copy
    // them into the packet.
    //
    pPMPacket->numColors = numColors;
    for (i = 0; i < numColors; i++)
    {
        //
        // Convert each RGBQuad entry in the color table to a DCColor.
        //
        TSHR_RGBQUAD_TO_TSHR_COLOR(pColorTable[i],
            pPMPacket->aColors[i]);
    }

    //
    // Now send the packet to the remote application.
    //
    if (m_pShare->m_scfViewSelf)
        m_pShare->PM_ReceivedPacket(m_pShare->m_pasLocal, &(pPMPacket->header.header));

#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    m_pShare->DCS_CompressAndSendPacket(PROT_STR_UPDATES, g_s20BroadcastID,
        &(pPMPacket->header.header), sizePkt);

    TRACE_OUT(("PM packet size: %08d, sent %08d", sizePkt, sentSize));

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(ASHost::PMSendPalettePacket, rc);
    return(rc);
}





//
// FUNCTION: PMCacheCallback
//
// DESCRIPTION:
//
// Cursor Manager's Cache Manager callback function.  Called whenever an
// entry is removed from the cache to allow us to free up the object.
//
// PARAMETERS:
//
// hCache - cache handle
//
// event - the cache event that has occured
//
// iCacheEntry - index of the cache entry that the event is affecting
//
// pData - pointer to the cache data associated with the given cache entry
//
// cbDataSize - size in bytes of the cached data
//
// RETURNS: Nothing
//
//
void  PMCacheCallback
(
    ASHost *    pHost,
    PCHCACHE    pCache,
    UINT        iCacheEntry,
    LPBYTE      pData
)
{
    DebugEntry(PMCacheCallback);


    //
    // Release the cache entry for reuse
    //
    TRACE_OUT(( "Releasing cache entry %d at 0x%08x",
            iCacheEntry, pData));
    pHost->m_pmNextTxCacheEntry = (PCOLORTABLECACHE)pData;
    pHost->m_pmNextTxCacheEntry->inUse = FALSE;

    //
    // Let SBC know that the cache entry has been released
    //
    pHost->SBC_PMCacheEntryRemoved(iCacheEntry);

    DebugExitVOID(PMCacheCallback);
}




//
// PM_GetSystemPaletteEntries
//
void  ASHost::PM_GetSystemPaletteEntries(LPTSHR_RGBQUAD pColors)
{
    UINT i;

    DebugEntry(ASHost::PM_GetSystemPaletteEntries);

    PMUpdateSystemPaletteColors();

    for (i = 0; i < PM_NUM_8BPP_PAL_ENTRIES; i++)
    {
        pColors[i].rgbRed       = m_apmCurrentSystemPaletteEntries[i].peRed;
        pColors[i].rgbGreen     = m_apmCurrentSystemPaletteEntries[i].peGreen;
        pColors[i].rgbBlue      = m_apmCurrentSystemPaletteEntries[i].peBlue;
        pColors[i].rgbReserved  = 0;
    }

    //
    // This function in its current form always returns TRUE - it is always
    // able to obtain the system colors.
    //
    DebugExitVOID(ASHost::PM_GetSystemPaletteEntries);
}


//
// PM_GetLocalPalette()
//
HPALETTE  ASHost::PM_GetLocalPalette(void)
{
    //
    // Ensure the palette is up to date
    //
    if (g_usrPalettized)
    {
        PMUpdateSystemPaletteColors();
    }

    //
    // Return the handle to the Local Palette.
    //
    return(m_pmTxPalette);
}



//
// PM_GetColorTable
//
void ASShare::PM_GetColorTable
(
    ASPerson *      pasPerson,
    UINT            index,
    LPUINT          pcColors,
    LPTSHR_RGBQUAD  pColors
)
{
    PCOLORTABLECACHE pColorTable;

    DebugEntry(ASShare::PM_GetColorTable);

    ValidatePerson(pasPerson);

    ASSERT(pasPerson->apmColorTable);

    pColorTable = &(pasPerson->apmColorTable[index]);
    TRACE_OUT(( "Color table requested for [%d], table ptr 0x%08x index %d",
            pasPerson->mcsID, pColorTable,index));

    if (!pColorTable->inUse)
    {
        ERROR_OUT(( "Asked for PM cache entry %hu when cache not yet in use",
                    index));
        DC_QUIT;
    }

    //
    // Copy the colors into the structure we have been passed
    //
    *pcColors = pColorTable->cColors;

    memcpy( pColors,
               pColorTable->colors,
               sizeof(TSHR_RGBQUAD) * pColorTable->cColors );

    TRACE_OUT(( "Returning %u colors",*pcColors));

DC_EXIT_POINT:
    DebugExitVOID(ASShare::PM_GetColorTable);
}





//
// PMADJUSTBUGGEDCOLOR()
//
// Macro used to tweak an 8 bit palette entry that the Win95 16 bit
// driver returns incorrectly
//
#define PMADJUSTBUGGEDCOLOR(pColor)                                          \
    if ( ((pColor)->rgbBlue != 0x00) &&                                      \
         ((pColor)->rgbBlue != 0xFF) )                                       \
    {                                                                        \
        (pColor)->rgbBlue += 0x40;                                           \
    }                                                                        \
                                                                             \
    if ( ((pColor)->rgbGreen != 0x00) &&                                     \
         ((pColor)->rgbGreen != 0xFF) )                                      \
    {                                                                        \
        (pColor)->rgbGreen += 0x20;                                          \
    }                                                                        \
                                                                             \
    if ( ((pColor)->rgbRed != 0x00) &&                                       \
         ((pColor)->rgbRed != 0xFF) )                                        \
    {                                                                        \
        (pColor)->rgbRed += 0x20;                                            \
    }

//
// PMGetGrays()
//
// Gets display driver specific versions of gray RGBs
//
void  ASHost::PMGetGrays(void)
{
    HBITMAP          hOldBitmap = NULL;
    BITMAPINFO_ours  bitmapInfo;
    BYTE          bitmapBuffer[16];
    UINT           i;

    DebugEntry(ASHost::PMGetGrays);

    //
    // Initialise the bitmapinfo local structure header contents.  This
    // structure will be used in the GetDIBits calls.
    //
    m_pShare->USR_InitDIBitmapHeader((BITMAPINFOHEADER *)&bitmapInfo, 8);

    bitmapInfo.bmiHeader.biWidth   = 16;
    bitmapInfo.bmiHeader.biHeight  = 1;

    //
    // Select the bitmap into the work DC
    //
    hOldBitmap = SelectBitmap(m_usrWorkDC, m_pShare->m_usrBmp16);
    if (hOldBitmap == NULL)
    {
        ERROR_OUT(( "Failed to select bitmap. hp(%08lX) hbmp(%08lX)",
            m_usrWorkDC, m_pShare->m_usrBmp16 ));
        DC_QUIT;
    }

    //
    // Use the real GDI to set each bit to each supplied color.
    //
    for (i = PM_GREY_COUNT; i-- != 0; )
    {
        SetPixel(m_usrWorkDC, i, 0, s_apmGreyRGB[i]);
    }

    //
    // Because this function is only used for true color scenarios we do
    // not need to select a palette into our compatible DC.  We just need
    // to get the bits.
    //
    if (!GetDIBits(m_usrWorkDC, m_pShare->m_usrBmp16, 0, 1, &bitmapBuffer,
            (BITMAPINFO *)&bitmapInfo, DIB_RGB_COLORS ))
    {
        ERROR_OUT(( "GetDIBits failed. hp(%x) hbmp(%x)",
                m_usrWorkDC, m_pShare->m_usrBmp16));
        DC_QUIT;
    }

    //
    // Check if we need to adjust the palette colors for the 16 bit driver
    // bug.
    //
    m_pmBuggedDriver = ((g_usrScreenBPP > 8) &&
                        (bitmapInfo.bmiColors[1].rgbRed == 0) &&
                        (bitmapInfo.bmiColors[1].rgbGreen == 0) &&
                        (bitmapInfo.bmiColors[1].rgbBlue == 0x40));

    //
    // Extract the RGBs returned by the display driver with the sending bpp
    // DIB.
    //
    for (i = PM_GREY_COUNT; i-- != 0; )
    {
        //
        // Extract the RGB from the color table
        //
        m_apmDDGreyRGB[i] = *((LPTSHR_RGBQUAD)(&bitmapInfo.bmiColors[bitmapBuffer[i]]));

        //
        // Adjust the palette colors for the 16 bit driver bug, if needed.
        //
        if (m_pmBuggedDriver)
        {
            TRACE_OUT(( "Adjusting for bugged driver"));
            PMADJUSTBUGGEDCOLOR(&m_apmDDGreyRGB[i]);
        }
    }

DC_EXIT_POINT:
    //
    // clean up
    //
    if (hOldBitmap != NULL)
    {
        SelectBitmap(m_usrWorkDC, hOldBitmap);

    }

    DebugExitVOID(ASHost::PMGetGrays);
}






//
// FUNCTION: PMUpdateSystemPaletteColors
//
// DESCRIPTION:
//
// Determines whether the colors in the System Palette have changed since
// the last time this function was called and if so, updates the supplied
// palette so that it contains the same colors as the System Palette.
//
// The first time that this function is called after PM_Init the System
// Palette colors will be returned and the function will return TRUE.
//
// PARAMETERS:
//
// shadowSystemPalette - handle of the palette to be updated with the
// current System Palette colors
//
// RETURNS: TRUE if the System Palette has changed since the last call,
// FALSE otherwise.
//
//
BOOL  ASHost::PMUpdateSystemPaletteColors(void)
{
    BOOL            rc = FALSE;
    PALETTEENTRY    systemPaletteEntries[PM_NUM_8BPP_PAL_ENTRIES];
    HDC             hdcScreen = NULL;
    UINT            cbSystemPaletteEntries;
    int             irgb, crgb, crgbFixed;

    DebugEntry(ASHost::PMUpdateSystemPaletteColors);

    ASSERT(g_usrPalettized);
    ASSERT(g_usrScreenBPP <= 8);
    ASSERT(m_usrSendingBPP <= 8);

    //
    // Don't bother with all this stuff if the system palette has not
    // changed at all.  We track notifications to our UI to detect
    // palette changes.
    //
    if (!g_asSharedMemory->pmPaletteChanged)
    {
        DC_QUIT;
    }

    hdcScreen = GetDC(NULL);
    if (!hdcScreen)
    {
        WARNING_OUT(( "GetDC failed"));
        DC_QUIT;
    }

    if (GetSystemPaletteEntries(hdcScreen, 0, COLORS_FOR_BPP(g_usrScreenBPP),
        systemPaletteEntries) != (UINT)COLORS_FOR_BPP(g_usrScreenBPP))
    {
        WARNING_OUT(( "GetSystemPaletteEntries failed"));
        DC_QUIT;
    }

    //
    // Now that we have succesfully queried the system palette, we can
    // reset our flag.
    //
    g_asSharedMemory->pmPaletteChanged = FALSE;

    cbSystemPaletteEntries = COLORS_FOR_BPP(g_usrScreenBPP) * sizeof(PALETTEENTRY);

    //
    // See if the System Palette has changed from the last time we queried.
    //
    if (!memcmp(systemPaletteEntries, m_apmCurrentSystemPaletteEntries,
            cbSystemPaletteEntries ))
    {
        //
        // The System Palette has not changed
        //
        TRACE_OUT(( "System palette has NOT changed"));
        rc = TRUE;
        DC_QUIT;
    }

    //
    // Take a copy of the new System Palette.
    //
    memcpy(m_apmCurrentSystemPaletteEntries, systemPaletteEntries, cbSystemPaletteEntries );

    //
    // Update the current local paleete.
    //
    // NOTE FOR WIN95:
    // We need to add PC_NOCOLLAPSE to non-system palette entries.
    //
    if (g_asWin95)
    {
        if (GetSystemPaletteUse(hdcScreen) == SYSPAL_STATIC)
            crgbFixed = GetDeviceCaps(hdcScreen, NUMRESERVED) / 2;
        else
            crgbFixed = 1;

        crgb = COLORS_FOR_BPP(g_usrScreenBPP) - crgbFixed;

        for (irgb = crgbFixed; irgb < crgb; irgb++)
        {
            systemPaletteEntries[irgb].peFlags = PC_NOCOLLAPSE;
        }
    }

    SetPaletteEntries(m_pmTxPalette, 0, COLORS_FOR_BPP(g_usrScreenBPP),
                       systemPaletteEntries );

    m_pmMustSendPalette = TRUE;

    //
    // SFR0407: The system palette has changed so re-fetch our set of RGBs
    // which the driver returns on an 8-bit GetDIBits for greys.
    //
    PMGetGrays();

    rc = TRUE;

DC_EXIT_POINT:
    if (hdcScreen)
    {
        ReleaseDC(NULL, hdcScreen);
    }

    DebugExitBOOL(ASHost::PMUpdateSystemPaletteColors, rc);
    return(rc);
}


//
// FUNCTION: PMUpdateTxPaletteColors
//
// DESCRIPTION:
//
// Returns the colors that make up the current Tx Palette (the palette that
// is SENT from the local machine).  These are not necessarily the colors
// in the local machine's palette, because the local machine's bpp and the
// protocol bpp may be different (e.g.  on an 8bpp machine talking at 4bpp
// the Tx Palette has 16 entries).
//
// PARAMETERS:
//
// pColorTable - pointer to an array of RGBQUADs which is filled with the
// colors that make up the current Tx Palette.
//
// RETURNS: TRUE if successful, FALSE otherwise.
//
//
BOOL  ASHost::PMUpdateTxPaletteColors(void)
{
    UINT            i;
    UINT            j;
    BOOL            rc = FALSE;
    HDC             hdcMem = NULL;
    HBITMAP         hbmpDummy = NULL;
    HPALETTE        hpalOld = NULL;
    BITMAPINFO_ours pmBitmapInfo;

    DebugEntry(ASHost::PMUpdateTxPaletteColors);

    //
    // Returns the values returned by a GetDIBits call with the
    // m_pmTxPalette selected.
    //
    ASSERT(m_usrSendingBPP <= 8);

    //
    // If we are at 8bpp locally, and sending at 8bpp, then the TxPalette
    // is simply the system palette.
    //
    if ((g_usrScreenBPP == 8) && (m_usrSendingBPP == 8))
    {
        PM_GetSystemPaletteEntries(pmBitmapInfo.bmiColors);
    }
    else
    {
        hdcMem = CreateCompatibleDC(NULL);
        if (!hdcMem)
        {
            ERROR_OUT(("PMUpdateTxPaletteColors: couldn't create memory DC"));
            DC_QUIT;
        }

        hpalOld = SelectPalette(hdcMem, m_pmTxPalette, TRUE);
        RealizePalette(hdcMem);

        #define DUMMY_WIDTH  8
        #define DUMMY_HEIGHT 8

        hbmpDummy = CreateBitmap(DUMMY_WIDTH, DUMMY_HEIGHT, 1,
            g_usrScreenBPP, NULL);
        if (hbmpDummy == NULL)
        {
            ERROR_OUT(( "Failed to create bitmap"));
            DC_QUIT;
        }


        //
        // Set up the structure required by GetDIBits.
        //
        pmBitmapInfo.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
        pmBitmapInfo.bmiHeader.biWidth  = DUMMY_WIDTH;
        pmBitmapInfo.bmiHeader.biHeight = DUMMY_HEIGHT;
        pmBitmapInfo.bmiHeader.biPlanes = 1;
        pmBitmapInfo.bmiHeader.biBitCount = (WORD)m_usrSendingBPP;
        pmBitmapInfo.bmiHeader.biCompression = BI_RGB;
        pmBitmapInfo.bmiHeader.biSizeImage = 0;
        pmBitmapInfo.bmiHeader.biXPelsPerMeter = 10000;
        pmBitmapInfo.bmiHeader.biYPelsPerMeter = 10000;
        pmBitmapInfo.bmiHeader.biClrUsed = 0;
        pmBitmapInfo.bmiHeader.biClrImportant = 0;

        if (0 == GetDIBits( hdcMem,
                            hbmpDummy,
                            0,
                            DUMMY_HEIGHT,
                            NULL,
                            (LPBITMAPINFO)&pmBitmapInfo.bmiHeader,
                            DIB_RGB_COLORS ))
        {
            WARNING_OUT(( "GetDIBits failed hdc(%x) hbmp(%x)",
                                                        HandleToUlong(hdcMem),
                                                        HandleToUlong(hbmpDummy)));
            DC_QUIT;
        }

        SelectPalette(hdcMem, hpalOld, TRUE);

        PM_AdjustColorsForBuggedDisplayDrivers(
            (LPTSHR_RGBQUAD)pmBitmapInfo.bmiColors,
            COLORS_FOR_BPP(m_usrSendingBPP));

        //
        // This doesn't work for VGA.
        //
        if (g_usrScreenBPP > 4)
        {
            //
            // Check the new color table for any occurrences of the dodgy-grey
            // RGBs which the display driver returns (getDIBits at 8bpp can
            // return RGBs with unequal R, G and B for a supplied RGB with
            // equal components, causing poor quality output).
            //
            for (i = COLORS_FOR_BPP(m_usrSendingBPP); i-- != 0;)
            {
                for ( j = 0; j < PM_GREY_COUNT; j++ )
                {
                    if (!memcmp(&pmBitmapInfo.bmiColors[i],
                            &m_apmDDGreyRGB[j],
                            sizeof(pmBitmapInfo.bmiColors[i])) )
                    {
                        //
                        // Found a dodgy grey in the color table, so replace
                        // with a "good" grey, ie one with equal R, G and B.
                        //
                        pmBitmapInfo.bmiColors[i].rgbRed =
                                                   GetRValue(s_apmGreyRGB[j]);
                        pmBitmapInfo.bmiColors[i].rgbGreen =
                                                   GetGValue(s_apmGreyRGB[j]);
                        pmBitmapInfo.bmiColors[i].rgbBlue =
                                                   GetBValue(s_apmGreyRGB[j]);
                        TRACE_OUT(( "match our grey %#x", s_apmGreyRGB[j]));
                        break;
                    }
                }
            }
        }
    }

    //
    // If the colors have changed then return TRUE and copy the new color
    // table back, else return FALSE.
    //
    if (!memcmp(m_apmTxPaletteColors, pmBitmapInfo.bmiColors,
                COLORS_FOR_BPP(m_usrSendingBPP) * sizeof(RGBQUAD) ))
    {
        rc = FALSE;
    }
    else
    {
        memcpy(m_apmTxPaletteColors, pmBitmapInfo.bmiColors,
               COLORS_FOR_BPP(m_usrSendingBPP) * sizeof(RGBQUAD) );

        rc = TRUE;
    }

DC_EXIT_POINT:
    if (hbmpDummy != NULL)
    {
        DeleteBitmap(hbmpDummy);
    }

    if (hdcMem != NULL)
    {
        DeleteDC(hdcMem);
    }

    DebugExitDWORD(ASHost::PMUpdateTxPaletteColors, rc);
    return(rc);
}

//
// FUNCTION: PMCreatePalette
//
// DESCRIPTION:
//
// Creates a new palette using the given colors.
//
// PARAMETERS:
//
// cEntries - number of entries in the pNewEntries array
//
// pNewEntries - pointer to a TSHR_COLOR array containing the new palette
// entries
//
// phPal - pointer to a HPALETTE variable that receives the new palette
// handle.
//
//
// RETURNS - TRUE if successful, FALSE otherwise.
//
//
BOOL  ASShare::PM_CreatePalette
(
    UINT            cEntries,
    LPTSHR_COLOR    pNewEntries,
    HPALETTE *      phPal
)
{
    UINT            i;
    BYTE            pmLogPaletteBuffer[sizeof(LOGPALETTE) + (PM_NUM_8BPP_PAL_ENTRIES-1)*sizeof(PALETTEENTRY)];
    LPLOGPALETTE    pLogPalette;
    BOOL            rc = FALSE;

    DebugEntry(ASShare::PM_CreatePalette);

    ASSERT(cEntries <= PM_NUM_8BPP_PAL_ENTRIES);

    //
    // Set up a palette structure.
    //
    pLogPalette = (LPLOGPALETTE)pmLogPaletteBuffer;

    // This is a random windows constant
    pLogPalette->palVersion    = 0x300;
    pLogPalette->palNumEntries = (WORD)cEntries;

    //
    // This palette packet contains an array of TSHR_COLOR structures which
    // contains 3 fields (RGB).  We have to convert each of these
    // structures to a PALETTEENTRY structure which has the same 3 fields
    // (RGB) plus some flags.
    //
    for (i = 0; i < cEntries; i++)
    {
        TSHR_COLOR_TO_PALETTEENTRY( pNewEntries[i],
                                 pLogPalette->palPalEntry[i] );
    }

    //
    // Create the palette.
    //
    *phPal = CreatePalette(pLogPalette);

    //
    // Return TRUE if the palette was created.
    //
    rc = (*phPal != NULL);

    DebugExitDWORD(ASShare::PM_CreatePalette, rc);
    return(rc);
}





//
// FUNCTION: PM_AdjustColorsForBuggedDisplayDrivers
//
// DESCRIPTION:
//
// Adjusts the supplied color table if necessary to take account of display
// driver bugs.
//
// PARAMETERS:
//
// pColors - pointer to the color table (an array of RGBQUADs)
//
// cColors - number of colors in the supplied color table
//
// RETURNS: Nothing.
//
//
// NOTE: There is similar code in NormalizeRGB below (although not similar
// enough to macro it.)  If you change this code you should probably do
// the same there.)
//
void  ASHost::PM_AdjustColorsForBuggedDisplayDrivers
(
    LPTSHR_RGBQUAD  pColors,
    UINT            cColors
)
{
    LPTSHR_RGBQUAD  pColor;
    UINT      i;

    DebugEntry(ASHost::PM_AdjustColorsForBuggedDisplayDrivers);

    //
    // The Win95 16bpp display drivers return wrong colors when querying at
    // 8bpp.  The palette depends on the driver itself (5-6-5, 6-5-5, 5-6-5,
    // or 5-5-5).  Only when R, G, and B have the same # of bits are we
    // going to end up with an even distribution.
    //
    // Detect this case and try to adjust the colors.
    //
    m_pmBuggedDriver = ((g_usrScreenBPP > 8) &&
                        (pColors[1].rgbRed == 0) &&
                        (pColors[1].rgbGreen == 0) &&
                        (pColors[1].rgbBlue == 0x40));

    if (m_pmBuggedDriver)
    {
        TRACE_OUT(( "Adjusting for bugged driver"));
        pColor = pColors;

        for (i = 0; i < cColors; i++)
        {
            PMADJUSTBUGGEDCOLOR(pColor);
            pColor++;
        }
    }

    DebugExitVOID(ASHost::PM_AdjustColorsForBuggedDisplayDrivers);
}



//
// FUNCTION: PM_DeletePalette
//
// DESCRIPTION:
//
// Deletes the given palette, if it is not the default palette.
//
// PARAMETERS:
//
// palette - palette to be deleted
//
// RETURNS: Nothing.
//
//
void  ASShare::PM_DeletePalette(HPALETTE palette)
{
    DebugEntry(ASShare::PM_DeletePalette);

    if ((palette != NULL) &&
        (palette != (HPALETTE)GetStockObject(DEFAULT_PALETTE)))
    {
        DeletePalette(palette);
    }

    DebugExitVOID(ASShare::PM_DeletePalette);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\od2.cpp ===
#include "precomp.h"


//
// OD2.CPP
// Order Decoding Second Level
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_ORDER



//
// OD2_ViewStarting()
//
// For 3.0 nodes, we create the decoding data each time they start hosting.
// For 2.x nodes, we create the decoding data once and use it until they
//      leave the share.
//
BOOL  ASShare::OD2_ViewStarting(ASPerson * pasPerson)
{
    PPARTYORDERDATA     pThisParty;
    BOOL                rc = FALSE;

    DebugEntry(ASShare::OD2_ViewStarting);

    ValidatePerson(pasPerson);

    //
    // Allocate memory for the required structure.
    //
    pThisParty = new PARTYORDERDATA;
    pasPerson->od2Party = pThisParty;
    if (!pThisParty)
    {
        ERROR_OUT(( "Failed to get memory for od2Party entry"));
        DC_QUIT;
    }

    //
    // Ensure the pointers are correctly set up.
    //
    ZeroMemory(pThisParty, sizeof(*pThisParty));
    SET_STAMP(pThisParty, PARTYORDERDATA);

    pThisParty->LastOrder[OE2_DSTBLT_ORDER    ] = &pThisParty->LastDstblt;
    pThisParty->LastOrder[OE2_PATBLT_ORDER    ] = &pThisParty->LastPatblt;
    pThisParty->LastOrder[OE2_SCRBLT_ORDER    ] = &pThisParty->LastScrblt;
    pThisParty->LastOrder[OE2_MEMBLT_ORDER    ] = &pThisParty->LastMemblt;
    pThisParty->LastOrder[OE2_MEM3BLT_ORDER   ] = &pThisParty->LastMem3blt;
    pThisParty->LastOrder[OE2_TEXTOUT_ORDER   ] = &pThisParty->LastTextOut;
    pThisParty->LastOrder[OE2_EXTTEXTOUT_ORDER] = &pThisParty->LastExtTextOut;
    pThisParty->LastOrder[OE2_RECTANGLE_ORDER ] = &pThisParty->LastRectangle;
    pThisParty->LastOrder[OE2_LINETO_ORDER    ] = &pThisParty->LastLineTo;
    pThisParty->LastOrder[OE2_OPAQUERECT_ORDER] = &pThisParty->LastOpaqueRect;
    pThisParty->LastOrder[OE2_SAVEBITMAP_ORDER] = &pThisParty->LastSaveBitmap;
    pThisParty->LastOrder[OE2_DESKSCROLL_ORDER] = &pThisParty->LastDeskScroll;
    pThisParty->LastOrder[OE2_MEMBLT_R2_ORDER ] = &pThisParty->LastMembltR2;
    pThisParty->LastOrder[OE2_MEM3BLT_R2_ORDER] = &pThisParty->LastMem3bltR2;
    pThisParty->LastOrder[OE2_POLYGON_ORDER   ] = &pThisParty->LastPolygon;
    pThisParty->LastOrder[OE2_PIE_ORDER       ] = &pThisParty->LastPie;
    pThisParty->LastOrder[OE2_ELLIPSE_ORDER   ] = &pThisParty->LastEllipse;
    pThisParty->LastOrder[OE2_ARC_ORDER       ] = &pThisParty->LastArc;
    pThisParty->LastOrder[OE2_CHORD_ORDER     ] = &pThisParty->LastChord;
    pThisParty->LastOrder[OE2_POLYBEZIER_ORDER] = &pThisParty->LastPolyBezier;
    pThisParty->LastOrder[OE2_ROUNDRECT_ORDER]  = &pThisParty->LastRoundRect;

    OD2_SyncIncoming(pasPerson);

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::OD2_ViewStarting, rc);
    return(rc);
}



//
// OD2_SyncIncoming()
// Called when NEW dude starts to share, a share is created, or someone new
// joins the share.
//
void ASShare::OD2_SyncIncoming(ASPerson * pasPerson)
{
    PPARTYORDERDATA     pThisParty;

    DebugEntry(ASShare::OD2_SyncIncoming);

    ValidateView(pasPerson);

    pThisParty = pasPerson->od2Party;

    pThisParty->LastOrderType = OE2_PATBLT_ORDER;
    pThisParty->pLastOrder    =
               (LPCOM_ORDER)(pThisParty->LastOrder[pThisParty->LastOrderType]);

    //
    // Set all buffers to NULL Fill in the datalength fields and the type
    // field.  Note that because the type field is always the first one in
    // an order we can cast each pointer to a TEXTOUT order to get the
    // correct position for this field
    //
#define Reset(field, ord)                                               \
{                                                                       \
    ZeroMemory(&pThisParty->field, sizeof(pThisParty->field));             \
    ((LPCOM_ORDER_HEADER)pThisParty->field)->cbOrderDataLength =          \
           sizeof(pThisParty->field) - sizeof(COM_ORDER_HEADER);         \
    TEXTFIELD(((LPCOM_ORDER)pThisParty->field))->type = LOWORD(ord);      \
}

    //
    // The compiler generates a warning for our use of LOWORD here on a
    // constant.  We disable the warning just for now.
    //

    Reset(LastDstblt,     ORD_DSTBLT);
    Reset(LastPatblt,     ORD_PATBLT);
    Reset(LastScrblt,     ORD_SCRBLT);
    Reset(LastMemblt,     ORD_MEMBLT);
    Reset(LastMem3blt,    ORD_MEM3BLT);
    Reset(LastTextOut,    ORD_TEXTOUT);
    Reset(LastExtTextOut, ORD_EXTTEXTOUT);
    Reset(LastRectangle,  ORD_RECTANGLE);
    Reset(LastLineTo,     ORD_LINETO);
    Reset(LastOpaqueRect, ORD_OPAQUERECT);
    Reset(LastSaveBitmap, ORD_SAVEBITMAP);
    Reset(LastDeskScroll, ORD_DESKSCROLL);
    Reset(LastMembltR2,   ORD_MEMBLT_R2);
    Reset(LastMem3bltR2,  ORD_MEM3BLT_R2);
    Reset(LastPolygon,    ORD_POLYGON);
    Reset(LastPie,        ORD_PIE);
    Reset(LastEllipse,    ORD_ELLIPSE);
    Reset(LastArc,        ORD_ARC);
    Reset(LastChord,      ORD_CHORD);
    Reset(LastPolyBezier, ORD_POLYBEZIER);
    Reset(LastRoundRect,  ORD_ROUNDRECT);

    //
    // Reset the bounds rectangle
    //
    ZeroMemory(&pThisParty->LastBounds, sizeof(pThisParty->LastBounds));

    //
    // The sender and the receiver both set their structures to the same
    // NULL state and the sender only ever sends differences from the
    // current state.  However the fontID fields in the received orders
    // refer to the sender, so we must actually set our fontID fields to
    // the local equivalent of the NULL entries just set.
    // We cannot do this until we have actually received the font details
    // so set the field to a dummy value we can recognise later.
    //
    TEXTFIELD(((LPCOM_ORDER)pThisParty->LastTextOut))->common.FontIndex =
                                                                DUMMY_FONT_ID;
    EXTTEXTFIELD(((LPCOM_ORDER)pThisParty->LastExtTextOut))->common.
                                                   FontIndex = DUMMY_FONT_ID;

    DebugExitVOID(ASShare::OD2_SyncIncoming);
}



//
// OD2_ViewEnded()
//
void  ASShare::OD2_ViewEnded(ASPerson * pasPerson)
{
    DebugEntry(ASShare::OD2_ViewEnded);

    ValidatePerson(pasPerson);

    //
    // For 3.0 nodes, we can free the decode data; 3.0 senders clear theirs
    //      every time they host.
    // For 2.x nodes, we must keep it around while they are in the share.
    //

    OD2FreeIncoming(pasPerson);

    DebugExitVOID(ASShare::OD2_ViewEnded);
}



//
// OD2_PartyLeftShare()
// For 2.x nodes, frees the incoming OD2 data
//
void ASShare::OD2_PartyLeftShare(ASPerson * pasPerson)
{
    DebugEntry(ASShare::OD2_PartyLeftShare);

    ValidatePerson(pasPerson);

    DebugExitVOID(ASShare::OD2_PartyLeftShare);
}


//
// OD2FreeIncoming()
// Frees per-party incoming OD2 resources
//
void ASShare::OD2FreeIncoming(ASPerson * pasPerson)
{
    DebugEntry(OD2FreeIncoming);

    if (pasPerson->od2Party != NULL)
    {
        if (pasPerson->od2Party->LastHFONT != NULL)
        {
            if (pasPerson->m_pView)
            {
                // For 3.0 nodes, pView won't be NULL; for 2.x nodes it may.

                //
                // This font might be currently selected into the DC for
                // this person's desktop.  Select it out.
                //
                SelectFont(pasPerson->m_pView->m_usrDC, (HFONT)GetStockObject(SYSTEM_FONT));
            }

            DeleteFont(pasPerson->od2Party->LastHFONT);
            pasPerson->od2Party->LastHFONT = NULL;
        }

        delete pasPerson->od2Party;
        pasPerson->od2Party = NULL;
    }

    DebugExitVOID(ASShare::OD2FreeIncoming);
}

//
// OD2_DecodeOrder()
//
LPCOM_ORDER  ASShare::OD2_DecodeOrder
(
    void *      pEOrder,
    LPUINT      pLengthDecoded,
    ASPerson *  pasPerson
)
{
    POE2ETFIELD       pTableEntry;
    UINT          FieldChangedBits;
    UINT          FieldsChanged;
    LPBYTE          pNextDataToCopy;
    RECT            Rect;
    LPBYTE          pControlFlags;
    LPTSHR_UINT32_UA      pEncodingFlags;
    LPSTR           pEncodedOrder;
    UINT            numEncodingFlagBytes;
    UINT            encodedFieldLength;
    UINT            unencodedFieldLength;
    UINT            numReps;
    UINT            i;
    LPBYTE          pDest;

    DebugEntry(ASShare::OD2_DecodeOrder);

    ValidatePerson(pasPerson);

    //
    // Set up some local variables to access the encoding buffer in various
    // ways.
    //
    pControlFlags  = &((PDCEO2ORDER)pEOrder)->ControlFlags;
    pEncodedOrder  = (LPSTR)&((PDCEO2ORDER)pEOrder)->EncodedOrder[0];
    pEncodingFlags = (LPTSHR_UINT32_UA)pEncodedOrder;

    if ( (*pControlFlags & OE2_CF_STANDARD_ENC) == 0)
    {
        ERROR_OUT(("Specially encoded order received from %d", pasPerson));
        return(NULL);
    }

    //
    // If the unencoded flag is set, the order has not been encoded, so
    // just return a pointer to the start of the data.
    //
    if ( (*pControlFlags & OE2_CF_UNENCODED) != 0)
    {
        //
        // Convert the fields of the order header from wire format.  Note
        // that unencoded orders are also PRIVATE, and hence do not
        // actually have the rcsDst field.
        //
        *pLengthDecoded = sizeof(COM_ORDER_HEADER)
          + EXTRACT_TSHR_UINT16_UA(
             &(((LPCOM_ORDER_UA)pEncodedOrder)->OrderHeader.cbOrderDataLength))
                      + FIELD_OFFSET(DCEO2ORDER, EncodedOrder);
        TRACE_OUT(("Person [%d] Returning unencoded buffer length %u",
                pasPerson->mcsID, *pLengthDecoded));
        return((LPCOM_ORDER)pEncodedOrder);
    }

    //
    // If type has changed, new type will be first byte in encoded order.
    // Get pointer to last order of this type. The encoding flags follow
    // this byte (if it is present).
    //
    if ( (*pControlFlags & OE2_CF_TYPE_CHANGE) != 0)
    {
        TRACE_OUT(("Person [%d] change type from %d to %d", pasPerson->mcsID,
                   (UINT)pasPerson->od2Party->LastOrderType,
                   (UINT)*(LPBYTE)pEncodedOrder));
        pasPerson->od2Party->LastOrderType = *(LPTSHR_UINT8)pEncodedOrder;
        pasPerson->od2Party->pLastOrder =
              (LPCOM_ORDER)(pasPerson->od2Party->LastOrder[pasPerson->od2Party->LastOrderType]);
        pEncodingFlags = (LPTSHR_UINT32_UA)&pEncodedOrder[1];
    }
    else
    {
        pEncodingFlags = (LPTSHR_UINT32_UA)&pEncodedOrder[0];
    }

    TRACE_OUT(("Person [%d] type %x", pasPerson->mcsID, pasPerson->od2Party->LastOrderType));

    //
    // Work out how many bytes we will need to store the encoding flags in.
    // (We have a flag for each field in the order structure). This code
    // we have written will cope with up to a DWORD of encoding flags.
    //
    numEncodingFlagBytes = (s_etable.NumFields[pasPerson->od2Party->LastOrderType]+7)/8;
    if (numEncodingFlagBytes > 4)
    {
        ERROR_OUT(( "[%#lx] Too many flag bytes (%d) for this code",
                   pasPerson, numEncodingFlagBytes));
    }

    //
    // Now we know how many bytes make up the flags we can get a pointer
    // to the position at which to start encoding the orders fields into.
    //
    pNextDataToCopy = (LPBYTE)pEncodingFlags + numEncodingFlagBytes;

    //
    // Reset the flags field to zero
    //
    pasPerson->od2Party->pLastOrder->OrderHeader.fOrderFlags = 0;

    //
    // Rebuild the Order Common Header in the same order as it was
    // encoded:
    //
    //
    // If a bounding rectangle is included, copy it into the order header
    //
    if ( *pControlFlags & OE2_CF_BOUNDS )
    {
        OD2DecodeBounds((LPTSHR_UINT8*)&pNextDataToCopy,
                        &pasPerson->od2Party->pLastOrder->OrderHeader.rcsDst,
                        pasPerson);
    }

    //
    // locate entry in encoding table for this ORDER type and extract the
    // encoded order flags from the Encoded order
    //
    pTableEntry      = s_etable.pFields[pasPerson->od2Party->LastOrderType];
    FieldChangedBits = 0;
    for (i=numEncodingFlagBytes; i>0; i--)
    {
        FieldChangedBits  = FieldChangedBits << 8;
        FieldChangedBits |= (UINT)((LPBYTE)pEncodingFlags)[i-1];
    }

    //
    // We need to keep a record of which fields we change.
    //
    FieldsChanged = FieldChangedBits;

    //
    // Now decode the order: While field changed bits are non-zero
    //   If rightmost bit is non-zero
    //       copy data from the buffer to the copy of this order type
    //   skip to next entry in Encoding table
    //   shift field changed bits right one bit
    //
    while (FieldChangedBits != 0)
    {
        //
        // If this field was encoded (ie changed since the last order)...
        //
        if ((FieldChangedBits & 1) != 0)
        {
            //
            // Set up a pointer to the destination (unencoded) field.
            //
            pDest = ((LPBYTE)pasPerson->od2Party->pLastOrder)
                  + pTableEntry->FieldPos
                  + sizeof(COM_ORDER_HEADER);

            //
            // If the field type is OE2_ETF_DATA, we just copy the number
            // of bytes given by the encoded length in the table.
            //
            if ((pTableEntry->FieldType & OE2_ETF_DATA) != 0)
            {
                encodedFieldLength   = 1;
                unencodedFieldLength = 1;
                numReps              = pTableEntry->FieldEncodedLen;

                TRACE_OUT(("Byte data field, len %d", numReps));
            }
            else
            {
                //
                // This is not a straightforward data copy.  The length of
                // the source and destination data is given in the table in
                // the FieldEncodedLen and FieldUnencodedLen elements
                // respectively.
                //
                encodedFieldLength   = pTableEntry->FieldEncodedLen;
                unencodedFieldLength = pTableEntry->FieldUnencodedLen;

                if ((pTableEntry->FieldType & OE2_ETF_FIXED) != 0)
                {
                    //
                    // If the field type is fixed (OE2_ETF_FIXED is set),
                    // we just have to decode one element of the given
                    // size.
                    //
                    numReps = 1;
                    TRACE_OUT(("Fixed fld: encoded size %d, unencoded size %d",
                             encodedFieldLength,
                             unencodedFieldLength));
                }
                else
                {
                    //
                    // This is a variable field.  The next byte to be
                    // decoded contains the number of BYTES of encoded data
                    // (not elements), so divide by the encoded field size
                    // to get numReps.
                    //
                    numReps = *pNextDataToCopy / encodedFieldLength;
                    TRACE_OUT(("Var field: encoded size %d, unencoded size " \
                                 "%d, reps %d",
                             encodedFieldLength,
                             unencodedFieldLength,
                             numReps));

                    //
                    // Step past the length field in the encoded order
                    //
                    pNextDataToCopy++;

                    //
                    // For a variable length field, the unencoded version
                    // contains a UINT for the length (in bytes) of the
                    // following variable data, followed by the actual
                    // data.  Fill in the length field in the unencoded
                    // order.
                    //
                    *(LPTSHR_UINT32)pDest = numReps * unencodedFieldLength;
                    pDest += sizeof(TSHR_UINT32);
                }
            }

            //
            // If the order was encoded using delta coordinate mode and
            // this field is a coordinate then convert the coordinate from
            // the single byte sized delta to a value of the size given by
            // unencodedFieldLen...
            //
            // Note that we've already handled the leading length field of
            // variable length fields above, so we don't have to worry
            // about FIXED / VARIABLE issues here.
            //
            if ( (*pControlFlags & OE2_CF_DELTACOORDS) &&
                 (pTableEntry->FieldType & OE2_ETF_COORDINATES) )
            {
                //
                // NOTE:
                // numReps can be zero in the case of an EXTTEXTOUT
                // order that needs the opaque rect but has no absolute
                // char positioning
                //
                OD2CopyFromDeltaCoords((LPTSHR_INT8*)&pNextDataToCopy,
                                       pDest,
                                       unencodedFieldLength,
                                       pTableEntry->FieldSigned,
                                       numReps);
            }
            else
            {
                if ((pasPerson->od2Party->LastOrderType == OE2_POLYGON_ORDER) ||
                    (pasPerson->od2Party->LastOrderType == OE2_POLYBEZIER_ORDER))
                {
                    //
                    // numReps can never be zero in this case
                    //
                    ASSERT(numReps);
                }
                OD2DecodeField(&pNextDataToCopy,
                               pDest,
                               encodedFieldLength,
                               unencodedFieldLength,
                               pTableEntry->FieldSigned,
                               numReps);
            }
        }

        //
        // Move on to the next field in the order structure...
        //
        FieldChangedBits = FieldChangedBits >> 1;
        pTableEntry++;
    }

    //
    // Check to see if we just got a font handle.
    // Because of the rather nasty test against an unnamed bit in the
    // FieldsChanged bits, we have a compile time check against the number
    // of fields in the TEXT orders structures.
    // The requirement for this code not to break is that the font handle
    // field must stay as the 13th field (hence 1 << 12).
    //

#if (OE2_NUM_TEXTOUT_FIELDS != 15) || (OE2_NUM_EXTTEXTOUT_FIELDS != 22)
#error code breaks if font handle not 13th field
#endif // OE2_NUM_TEXTOUT_FIELDS is 15 or 22

    if (((pasPerson->od2Party->LastOrderType == OE2_EXTTEXTOUT_ORDER) &&
         ((FieldsChanged & (1 << 12)) ||
          (EXTTEXTFIELD(((LPCOM_ORDER)pasPerson->od2Party->LastExtTextOut))->common.
                                             FontIndex == DUMMY_FONT_ID))) ||
        ((pasPerson->od2Party->LastOrderType == OE2_TEXTOUT_ORDER) &&
         ((FieldsChanged & (1 << 12)) ||
          (TEXTFIELD(((LPCOM_ORDER)pasPerson->od2Party->LastTextOut))->common.
                                             FontIndex == DUMMY_FONT_ID))))
    {
        //
        // This was a text order, and the font changed for it.
        //
        FH_ConvertAnyFontIDToLocal(pasPerson->od2Party->pLastOrder, pasPerson);
    }

    //
    // if the OE2_CF_BOUNDS flag is not set, we have not yet constructed
    // the bounding rectangle, so call OD2ReconstructBounds to do so
    //
    if ( (*pControlFlags & OE2_CF_BOUNDS) == 0)
    {
        OD2_CalculateBounds(pasPerson->od2Party->pLastOrder,
                           &Rect,
                           TRUE,
                           pasPerson);
        pasPerson->od2Party->pLastOrder->OrderHeader.rcsDst.left
                                                      = (TSHR_INT16)Rect.left;
        pasPerson->od2Party->pLastOrder->OrderHeader.rcsDst.right
                                                      = (TSHR_INT16)Rect.right;
        pasPerson->od2Party->pLastOrder->OrderHeader.rcsDst.top
                                                      = (TSHR_INT16)Rect.top;
        pasPerson->od2Party->pLastOrder->OrderHeader.rcsDst.bottom
                                                      = (TSHR_INT16)Rect.bottom;
        pasPerson->od2Party->pLastOrder->OrderHeader.fOrderFlags |= OF_NOTCLIPPED;
    }

    //
    // Return the decoded order length and a pointer to the order.
    //
    *pLengthDecoded = (UINT)(pNextDataToCopy - (LPBYTE)pEOrder);

    TRACE_OUT(("Person [%d] Return decoded order length %u",
               pasPerson->mcsID, *pLengthDecoded));

    DebugExitPVOID(ASShare::OD2_DecodeOrder, pasPerson->od2Party->pLastOrder);
    return(pasPerson->od2Party->pLastOrder);
}


//
// FUNCTION: OD2UseFont
//
// DESCRIPTION:
//
// Selects the font described by the parameters into the person's DC.
// so that we can then query the text extent etc.
// The queried metrics are available from pasPerson->od2Party->LastFontMetrics.
//
// PARAMETERS:
//
// RETURNS: TRUE if successful, FALSE otherwise.
//
//
BOOL  ASShare::OD2UseFont
(
    ASPerson *      pasPerson,
    LPSTR           pName,
    UINT            facelength,
    UINT            codePage,
    UINT            MaxHeight,
    UINT            Height,
    UINT            Width,
    UINT            Weight,
    UINT            flags
)
{
    BOOL          rc = TRUE;

    DebugEntry(ASShare::OD2UseFont);

    ValidatePerson(pasPerson);

    if ((pasPerson->od2Party->LastFontFaceLen != facelength                      ) ||
        (memcmp((LPSTR)(pasPerson->od2Party->LastFaceName),pName,
                                                facelength)   != 0      ) ||
        (pasPerson->od2Party->LastCodePage                             != codePage) ||
        (pasPerson->od2Party->LastFontHeight                           != Height ) ||
        (pasPerson->od2Party->LastFontWidth                            != Width  ) ||
        (pasPerson->od2Party->LastFontWeight                           != Weight ) ||
        (pasPerson->od2Party->LastFontFlags                            != flags  ))
    {
        TRACE_OUT(("Person [%d] Font %s (CP%d,w%d,h%d,f%04X,wgt%d) to %s (CP%d,w%d,h%d,f%04X,wgt%d)",
            pasPerson->mcsID, pasPerson->od2Party->LastFaceName,
            pasPerson->od2Party->LastCodePage, pasPerson->od2Party->LastFontWidth,
            pasPerson->od2Party->LastFontHeight,
                                                   pasPerson->od2Party->LastFontFlags,
                                                   pasPerson->od2Party->LastFontWeight,
                                                   pName,
                                                   codePage,
                                                   Width,
                                                   Height,
                                                   flags,
                                                   Weight ));

        memcpy(pasPerson->od2Party->LastFaceName,pName,facelength);
        pasPerson->od2Party->LastFontFaceLen            = facelength;
        pasPerson->od2Party->LastFaceName[facelength]   = '\0';
        pasPerson->od2Party->LastFontHeight             = Height;
        pasPerson->od2Party->LastCodePage                = codePage;
        pasPerson->od2Party->LastFontWidth              = Width;
        pasPerson->od2Party->LastFontWeight             = Weight;
        pasPerson->od2Party->LastFontFlags              = flags;

        rc = USR_UseFont(pasPerson->m_pView->m_usrDC,
                         &pasPerson->od2Party->LastHFONT,
                         &pasPerson->od2Party->LastFontMetrics,
                         (LPSTR)pasPerson->od2Party->LastFaceName,
                         codePage,
                         MaxHeight,
                         Height,
                         Width,
                         Weight,
                         flags);
    }
    else
    {
        //
        // The font hasn't changed, so LastHFONT should be the one we
        // want.  We must still select it in however, since several fonts
        // get selected into usrDC.
        //
        ASSERT(pasPerson->od2Party->LastHFONT != NULL);
        SelectFont(pasPerson->m_pView->m_usrDC, pasPerson->od2Party->LastHFONT);
    }

    DebugExitBOOL(ASShare::OD2UseFont, rc);
    return(rc);
}




//
// OD2_CalculateTextOutBounds()
//
void  ASShare::OD2_CalculateTextOutBounds
(
    LPTEXTOUT_ORDER pTextOut,
    LPRECT          pRect,
    BOOL            fDecoding,
    ASPerson *      pasPerson
)
{
    LPSTR            pString;
    int              cbString;
    BOOL             fExtTextOut;
    LPEXTTEXTOUT_ORDER pExtTextOut = NULL;
    LPCOMMON_TEXTORDER  pCommon;
    LPSTR            faceName;
    UINT             faceNameLength;
    BOOL             fFontSelected;
    UINT           FontIndex;
    UINT             width;
    UINT             maxFontHeight;
    UINT           nFontFlags;
    UINT           nCodePage;

    DebugEntry(ASShare::OD2_CalculateTextOutBounds);

    ValidatePerson(pasPerson);

    //
    // Workout if this is a TextOut or ExtTextOut order.
    //
    if (pTextOut->type == ORD_EXTTEXTOUT_TYPE)
    {
        fExtTextOut = TRUE;
        pExtTextOut = (LPEXTTEXTOUT_ORDER)pTextOut;
        pCommon     = &(pExtTextOut->common);

        //
        // This code does not cope with calculating the bounds of an
        // ExtTextOut order with a delta X array.  We return a NULL
        // rectangle in this case to force the OE2 code to transmit the
        // bounds explicitly.  However if we are decoding then we must
        // calculate the rectangle (even though it may be wrong) to
        // maintain backward compatability to previous versions of the
        // product (R11) which did not return a NULL rect if delta-x was
        // present.
        //
        if (  (pExtTextOut->fuOptions & ETO_LPDX)
           && (!fDecoding) )
        {
            TRACE_OUT(( "Delta X so return NULL rect"));
            pRect->left = 0;
            pRect->right = 0;
            pRect->top = 0;
            pRect->bottom = 0;
            return;
        }
    }
    else if (pTextOut->type == ORD_TEXTOUT_TYPE)
    {
        fExtTextOut = FALSE;
        pCommon     = &(pTextOut->common);
    }
    else
    {
        ERROR_OUT(( "{%p} Unexpected order type %x",
                    pasPerson, (int)pTextOut->type));
        return;
    }

    //
    // The order structures both have the variableString as their first
    // variable field. If this were not the case then the code here would
    // have to take into account that the encoding side packs variable
    // sized fields while the decoding side does not pack them.
    //
    if (fExtTextOut)
    {
        cbString   = pExtTextOut->variableString.len;
        pString    = (LPSTR)&pExtTextOut->variableString.string;
    }
    else
    {
        cbString   = pTextOut->variableString.len;
        pString    = (LPSTR)&pTextOut->variableString.string;
    }
    FontIndex = pCommon->FontIndex;
    width      = pCommon->FontWidth;

    //
    // Get the facename from the handle, and get the various font width/
    // height adjusted values.
    //
    faceName      = FH_GetFaceNameFromLocalHandle(FontIndex,
                                                  &faceNameLength);
    maxFontHeight = (UINT)FH_GetMaxHeightFromLocalHandle(FontIndex);

    //
    // Get the local font flags for the font, so that we can merge in any
    // specific local flag information when setting up the font.  The prime
    // example of this is whether the local font we matched is TrueType or
    // not, which information is not sent over the wire, but does need to
    // be used when setting up the font - or else we may draw using a local
    // fixed font of the same facename.
    //
    nFontFlags = FH_GetFontFlagsFromLocalHandle(FontIndex);

    //
    // Get the local codePage for the font.
    //
    nCodePage = FH_GetCodePageFromLocalHandle(FontIndex);

    //
    // Hosting only version does not ever decode orders.
    //

    //
    // Select the font into the appropriate DC and query the text extent.
    //
    if (fDecoding)
    {
        fFontSelected = OD2UseFont(pasPerson,
                                    faceName,
                                   faceNameLength,
                                   nCodePage,
                                   maxFontHeight,
                                   pCommon->FontHeight,
                                   width,
                                   pCommon->FontWeight,
                                   pCommon->FontFlags
                                                    | (nFontFlags & NF_LOCAL));
        if (!fFontSelected)
        {
            //
            // We failed to select the correct font - so we cannot
            // calculate the bounds correctly.  However, the fact that we
            // are in this routine means that on the host the text was
            // unclipped.  Therefore we just return a (fairly arbitrary)
            // very big rect.
            //
            // This is far from a perfect answer (for example, it will
            // force a big repaint), but allow us to keep running in a
            // difficult situation (i.e. acute resource shortage).
            //
            pRect->left = 0;
            pRect->right = 2000;
            pRect->top = -2000;
            pRect->bottom = 2000;
            return;
        }

        OE_GetStringExtent(pasPerson->m_pView->m_usrDC,
                            &pasPerson->od2Party->LastFontMetrics,
                            pString, cbString, pRect );
    }
    else
    {
        ASSERT(m_pHost);

        fFontSelected = m_pHost->OE2_UseFont(faceName,
                                   (TSHR_UINT16)faceNameLength,
                                   (TSHR_UINT16)nCodePage,
                                   (TSHR_UINT16)maxFontHeight,
                                   (TSHR_UINT16)pCommon->FontHeight,
                                   (TSHR_UINT16)width,
                                   (TSHR_UINT16)pCommon->FontWeight,
                                   (TSHR_UINT16)(pCommon->FontFlags
                                                  | (nFontFlags & NF_LOCAL)));

        if (!fFontSelected)
        {
            //
            // We failed to select the correct font. We return a NULL
            // rectangle in this case to force the OE2 code to transmit
            // the bounds explicitly.
            //
            pRect->left = 0;
            pRect->right = 0;
            pRect->top = 0;
            pRect->bottom = 0;
            return;
        }

        OE_GetStringExtent(m_pHost->m_usrWorkDC, NULL, pString, cbString, pRect );
    }

    //
    // We have a rectangle with the text extent in it relative to (0,0) so
    // add in the text starting position to this to give us the bounding
    // rectangle. At the same time we will convert the exclusive rect
    // returned by OE_GetStringExtent to an inclusive rectangle as us
    //
    pRect->left   += pCommon->nXStart;
    pRect->right  += pCommon->nXStart - 1;
    pRect->top    += pCommon->nYStart;
    pRect->bottom += pCommon->nYStart - 1;

    //
    // If this is an ExtTextOut order then we must take into account the
    // opaque/clipping rectangle if there is one.
    //
    if (fExtTextOut)
    {
        //
        // If the rectangle is an opaque rectangle then expand the bounding
        // rectangle to bound the opaque rectangle also.
        //
        if (pExtTextOut->fuOptions & ETO_OPAQUE)
        {
            pRect->left   = min(pExtTextOut->rectangle.left, pRect->left);
            pRect->right  = max(pExtTextOut->rectangle.right,
                                   pRect->right);
            pRect->top    = min(pExtTextOut->rectangle.top,
                                   pRect->top);
            pRect->bottom = max(pExtTextOut->rectangle.bottom,
                                   pRect->bottom);
        }

        //
        // If the rectangle is a clip rectangle then restrict the bounding
        // rectangle to be within the clip rectangle.
        //
        if (pExtTextOut->fuOptions & ETO_CLIPPED)
        {
            pRect->left   = max(pExtTextOut->rectangle.left,
                                   pRect->left);
            pRect->right  = min(pExtTextOut->rectangle.right,
                                   pRect->right);
            pRect->top    = max(pExtTextOut->rectangle.top,
                                   pRect->top);
            pRect->bottom = min(pExtTextOut->rectangle.bottom,
                                   pRect->bottom);
        }
    }

    DebugExitVOID(ASShare::OD2_CalculateTextOutBounds);
}


//
// OD2_CalculateBounds()
//
void  ASShare::OD2_CalculateBounds
(
    LPCOM_ORDER     pOrder,
    LPRECT          pRect,
    BOOL            fDecoding,
    ASPerson *      pasPerson
)
{
    UINT            i;
    UINT            numPoints;

    DebugEntry(ASShare::OD2_CalculateBounds);

    ValidatePerson(pasPerson);

    //
    // Calculate the bounds according to the order type.
    // All blts can be handled in the same way.
    //
    switch ( ((LPPATBLT_ORDER)pOrder->abOrderData)->type )
    {
        //
        // Calculate bounds for the blts.
        // This is the destination rectangle. Bounds are inclusive.
        //
        case ORD_DSTBLT_TYPE:

            pRect->left   =
                           ((LPDSTBLT_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top    = ((LPDSTBLT_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right  = pRect->left
                          + ((LPDSTBLT_ORDER)(pOrder->abOrderData))->nWidth
                          - 1;
            pRect->bottom = pRect->top
                          + ((LPDSTBLT_ORDER)(pOrder->abOrderData))->nHeight
                          - 1;
            break;


        case ORD_PATBLT_TYPE:

            pRect->left =
                  ((LPPATBLT_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top =
                  ((LPPATBLT_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right =
                  pRect->left +
                  ((LPPATBLT_ORDER)(pOrder->abOrderData))->nWidth - 1;
            pRect->bottom =
                  pRect->top +
                  ((LPPATBLT_ORDER)(pOrder->abOrderData))->nHeight - 1;
            break;


        case ORD_SCRBLT_TYPE:

            pRect->left =
                  ((LPSCRBLT_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top =
                  ((LPSCRBLT_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right =
                  pRect->left +
                  ((LPSCRBLT_ORDER)(pOrder->abOrderData))->nWidth - 1;
            pRect->bottom =
                  pRect->top +
                  ((LPSCRBLT_ORDER)(pOrder->abOrderData))->nHeight - 1;
            break;

        case ORD_MEMBLT_TYPE:

            pRect->left =
                  ((LPMEMBLT_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top =
                  ((LPMEMBLT_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right =
                  pRect->left +
                  ((LPMEMBLT_ORDER)(pOrder->abOrderData))->nWidth - 1;
            pRect->bottom =
                  pRect->top +
                  ((LPMEMBLT_ORDER)(pOrder->abOrderData))->nHeight - 1;
            break;

        case ORD_MEM3BLT_TYPE:

            pRect->left =
                  ((LPMEM3BLT_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top =
                  ((LPMEM3BLT_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right =
                  pRect->left +
                  ((LPMEM3BLT_ORDER)(pOrder->abOrderData))->nWidth - 1;
            pRect->bottom =
                  pRect->top +
                  ((LPMEM3BLT_ORDER)(pOrder->abOrderData))->nHeight - 1;
            break;

        case ORD_MEMBLT_R2_TYPE:
            pRect->left =
                  ((LPMEMBLT_R2_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top =
                  ((LPMEMBLT_R2_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right =
                  pRect->left +
                  ((LPMEMBLT_R2_ORDER)(pOrder->abOrderData))->nWidth - 1;
            pRect->bottom =
                  pRect->top +
                  ((LPMEMBLT_R2_ORDER)(pOrder->abOrderData))->nHeight - 1;
            break;

        case ORD_MEM3BLT_R2_TYPE:
            pRect->left =
                  ((LPMEM3BLT_R2_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top =
                  ((LPMEM3BLT_R2_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right =
                  pRect->left +
                  ((LPMEM3BLT_R2_ORDER)(pOrder->abOrderData))->nWidth - 1;
            pRect->bottom =
                  pRect->top +
                  ((LPMEM3BLT_R2_ORDER)(pOrder->abOrderData))->nHeight - 1;
            break;

        //
        // Calculate bounds for Rectangle.
        // This is the rectangle itself. Bounds are inclusive.
        //
        case ORD_RECTANGLE_TYPE:

            pRect->left =
                  ((LPRECTANGLE_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top =
                  ((LPRECTANGLE_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right =
                  ((LPRECTANGLE_ORDER)(pOrder->abOrderData))->nRightRect;
            pRect->bottom =
                  ((LPRECTANGLE_ORDER)(pOrder->abOrderData))->nBottomRect;
            break;


        case ORD_ROUNDRECT_TYPE:

            pRect->left =
                  ((LPROUNDRECT_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top =
                  ((LPROUNDRECT_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right =
                  ((LPROUNDRECT_ORDER)(pOrder->abOrderData))->nRightRect;
            pRect->bottom =
                  ((LPROUNDRECT_ORDER)(pOrder->abOrderData))->nBottomRect;
            break;

        case ORD_POLYGON_TYPE:
            //
            // Calculate bounds for Polygon.
            //
            pRect->left = 0x7fff;
            pRect->right = 0;
            pRect->top = 0x7fff;
            pRect->bottom = 0;

            //
            // BOGUS! LAURABU BUGBUG
            //
            // In NM 2.0, the wrong fields were being compared.  x to top/
            // bottom, and y to left/right.
            //
            // Effectively, this meant that we never matched the bounds
            // in the rcsDst rect.
            //
            numPoints = ((LPPOLYGON_ORDER)(pOrder->abOrderData))->
                        variablePoints.len
                    / sizeof(((LPPOLYGON_ORDER)(pOrder->abOrderData))->
                        variablePoints.aPoints[0]);

            for (i = 0; i < numPoints; i++ )
            {
                if ( ((LPPOLYGON_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].y > pRect->bottom )
                {
                    pRect->bottom = ((LPPOLYGON_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].y;
                }

                if ( ((LPPOLYGON_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].y < pRect->top )
                {
                    pRect->top = ((LPPOLYGON_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].y;
                }

                if ( ((LPPOLYGON_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].x > pRect->right )
                {
                    pRect->right = ((LPPOLYGON_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].x;
                }

                if ( ((LPPOLYGON_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].x < pRect->left )
                {
                    pRect->left = ((LPPOLYGON_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].x;
                }
            }

            TRACE_OUT(("Poly bounds: left:%d, right:%d, top:%d, bottom:%d",
                pRect->left, pRect->right, pRect->top, pRect->bottom ));

            break;

        case ORD_PIE_TYPE:
            //
            // Pull out the bounding rectangle directly from the PIE order.
            //

            pRect->left = ((LPPIE_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top = ((LPPIE_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right = ((LPPIE_ORDER)(pOrder->abOrderData))->nRightRect;
            pRect->bottom = ((LPPIE_ORDER)(pOrder->abOrderData))->nBottomRect;

            break;

        case ORD_ELLIPSE_TYPE:
            //
            // Pull out the bounding rectangle directly from ELLIPSE order.
            //
            pRect->left = ((LPELLIPSE_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top = ((LPELLIPSE_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right =
                         ((LPELLIPSE_ORDER)(pOrder->abOrderData))->nRightRect;
            pRect->bottom =
                        ((LPELLIPSE_ORDER)(pOrder->abOrderData))->nBottomRect;

            break;

        case ORD_ARC_TYPE:
            //
            // Pull out the bounding rectangle directly from the ARC order.
            //
            pRect->left = ((LPARC_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top = ((LPARC_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right = ((LPARC_ORDER)(pOrder->abOrderData))->nRightRect;
            pRect->bottom = ((LPARC_ORDER)(pOrder->abOrderData))->nBottomRect;

            break;

        case ORD_CHORD_TYPE:
            //
            // Pull out the bounding rectangle directly from the CHORD
            // order.
            //
            pRect->left = ((LPCHORD_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top = ((LPCHORD_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right = ((LPCHORD_ORDER)(pOrder->abOrderData))->nRightRect;
            pRect->bottom =
                          ((LPCHORD_ORDER)(pOrder->abOrderData))->nBottomRect;

            break;


        case ORD_POLYBEZIER_TYPE:
            //
            // Calculate bounds for PolyBezier.
            //
            pRect->left = 0x7fff;
            pRect->right = 0;
            pRect->top = 0x7fff;
            pRect->bottom = 0;

            numPoints = ((LPPOLYBEZIER_ORDER)(pOrder->abOrderData))->
                        variablePoints.len
                    / sizeof(((LPPOLYBEZIER_ORDER)(pOrder->abOrderData))->
                        variablePoints.aPoints[0]);

            //
            // BOGUS! LAURABU BUGBUG
            //
            // In NM 2.0, the wrong fields were being compared.  x to top/
            // bottom, and y to left/right.
            //
            // Effectively, this meant that we never matched the bounds
            // in the rcsDst rect.
            //
            for (i = 0; i < numPoints; i++ )
            {
                if ( ((LPPOLYBEZIER_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].y > pRect->bottom )
                {
                    pRect->bottom = ((LPPOLYBEZIER_ORDER)(pOrder->abOrderData))
                                   ->variablePoints.aPoints[i].y;
                }

                if ( ((LPPOLYBEZIER_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].y < pRect->top )
                {
                    pRect->top = ((LPPOLYBEZIER_ORDER)(pOrder->abOrderData))
                                 ->variablePoints.aPoints[i].y;
                }

                if ( ((LPPOLYBEZIER_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].x > pRect->right )
                {
                    pRect->right = ((LPPOLYBEZIER_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].x;
                }

                if ( ((LPPOLYBEZIER_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].x < pRect->left )
                {
                    pRect->left = ((LPPOLYBEZIER_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].x;
                }
            }

            TRACE_OUT((
                     "PolyBezier bounds: left:%d, right:%d, top:%d, bot:%d",
                     pRect->left, pRect->right, pRect->top, pRect->bottom));
            break;


        case ORD_LINETO_TYPE:
            //
            // Calculate bounds for LineTo.  This is the rectangle with
            // opposite vertices on the start and end points of the line.
            // The gradient of the line determines whether the start or end
            // point provides the top or bottom, left or right of the
            // rectangle.  Bounds are inclusive.
            //
            if ( ((LPLINETO_ORDER)(pOrder->abOrderData))->nXStart <
                  ((LPLINETO_ORDER)(pOrder->abOrderData))->nXEnd )
            {
                pRect->left =
                      ((LPLINETO_ORDER)(pOrder->abOrderData))->nXStart;
                pRect->right =
                      ((LPLINETO_ORDER)(pOrder->abOrderData))->nXEnd;
            }
            else
            {
                pRect->right =
                      ((LPLINETO_ORDER)pOrder->abOrderData)->nXStart;
                pRect->left =
                      ((LPLINETO_ORDER)pOrder->abOrderData)->nXEnd;
            }

            if ( ((LPLINETO_ORDER)pOrder->abOrderData)->nYStart <
                  ((LPLINETO_ORDER)pOrder->abOrderData)->nYEnd )
            {
                pRect->top =
                      ((LPLINETO_ORDER)pOrder->abOrderData)->nYStart;
                pRect->bottom =
                      ((LPLINETO_ORDER)pOrder->abOrderData)->nYEnd;
            }
            else
            {
                pRect->bottom =
                      ((LPLINETO_ORDER)pOrder->abOrderData)->nYStart;
                pRect->top =
                      ((LPLINETO_ORDER)pOrder->abOrderData)->nYEnd;
            }
            break;

        case ORD_OPAQUERECT_TYPE:
            //
            // Calculate bounds for OpaqueRect.  This is the rectangle
            // itself.  Bounds are inclusive.
            //
            pRect->left =
                  ((LPOPAQUERECT_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top =
                  ((LPOPAQUERECT_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right =
                  pRect->left +
                  ((LPOPAQUERECT_ORDER)(pOrder->abOrderData))->nWidth - 1;
            pRect->bottom =
                  pRect->top +
                  ((LPOPAQUERECT_ORDER)(pOrder->abOrderData))->nHeight - 1;
            break;

        case ORD_SAVEBITMAP_TYPE:
            //
            // Calculate bounds for SaveBitmap.  This is the rectangle
            // itself.  Bounds are inclusive.
            //
            pRect->left =
                  ((LPSAVEBITMAP_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top =
                  ((LPSAVEBITMAP_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->bottom =
                  ((LPSAVEBITMAP_ORDER)(pOrder->abOrderData))->nBottomRect;
            pRect->right =
                  ((LPSAVEBITMAP_ORDER)(pOrder->abOrderData))->nRightRect;
            break;


        case ORD_TEXTOUT_TYPE:
        case ORD_EXTTEXTOUT_TYPE:
            //
            // TextOut and ExtTextOut bounds calculations are done by the
            // OD2_CalculateTextOutBounds function.
            //
            OD2_CalculateTextOutBounds((LPTEXTOUT_ORDER)pOrder->abOrderData,
                                      pRect,
                                      fDecoding,
                                      pasPerson);
            break;


        case ORD_DESKSCROLL_TYPE:
            pRect->left   = 0;
            pRect->top    = 0;
            pRect->right  = 0;
            pRect->bottom = 0;
            break;


        default:
            ERROR_OUT((
                "{%p} unrecognized type passed to OD2ReconstructBounds: %d",
                       pasPerson,
                       (int)((LPPATBLT_ORDER)pOrder->abOrderData)->type));
            break;
    }

    DebugExitVOID(ASShare::OD2_CalculateBounds);
}




//
// OD2DecodeBounds()
//
void  ASShare::OD2DecodeBounds
(
    LPBYTE*         ppNextDataToCopy,
    LPTSHR_RECT16   pRect,
    ASPerson *      pasPerson
)
{
    LPBYTE pFlags;

    DebugEntry(ASShare::OD2DecodeBounds);

    ValidatePerson(pasPerson);

    //
    // The encoding used is a byte of flags followed by a variable number
    // of 16bit coordinate values and 8bit delta coordinate values (which
    // may be interleaved).
    //

    //
    // The first byte of the encoding will contain the flags that represent
    // how the coordinates of the rectangle were encoded.
    //
    pFlags = *ppNextDataToCopy;
    (*ppNextDataToCopy)++;

    //
    // Initialise the rectangle with the last decoded coordinates.
    //
    *pRect = pasPerson->od2Party->LastBounds;

    //
    // If the flags indicate that none of the coordinates have changed then
    // fast path and exit now.
    //
    if (*pFlags == 0)
    {
        return;
    }

    //
    // For each of the four coordinate values in the rectangle: If the
    // coordinate was encoded as an 8bit delta then add on the delta to the
    // previous value.  If the coordinate was encoded as a 16bit value
    // then copy the value across. Otherwise the coordinate was the same
    // as the previous one so leave it alone.
    //
    if (*pFlags & OE2_BCF_DELTA_LEFT)
    {
        OD2CopyFromDeltaCoords((LPTSHR_INT8*)ppNextDataToCopy,
                               &pRect->left,
                               sizeof(pRect->left),
                               TRUE,        // The value is signed
                               1);
    }
    else if (*pFlags & OE2_BCF_LEFT)
    {
        pRect->left          = EXTRACT_TSHR_INT16_UA(*ppNextDataToCopy);
        (*ppNextDataToCopy) += sizeof(TSHR_INT16);
    }

    if (*pFlags & OE2_BCF_DELTA_TOP)
    {
        OD2CopyFromDeltaCoords((LPTSHR_INT8*)ppNextDataToCopy,
                               &pRect->top,
                               sizeof(pRect->top),
                               TRUE,        // The value is signed
                               1);
    }
    else if (*pFlags & OE2_BCF_TOP)
    {
        pRect->top           = EXTRACT_TSHR_INT16_UA(*ppNextDataToCopy);
        (*ppNextDataToCopy) += sizeof(TSHR_INT16);
    }

    if (*pFlags & OE2_BCF_DELTA_RIGHT)
    {
        OD2CopyFromDeltaCoords((LPTSHR_INT8*)ppNextDataToCopy,
                               &pRect->right,
                               sizeof(pRect->right),
                               TRUE,        // The value is signed
                               1);
    }
    else if (*pFlags & OE2_BCF_RIGHT)
    {
        pRect->right         = EXTRACT_TSHR_INT16_UA(*ppNextDataToCopy);
        (*ppNextDataToCopy) += sizeof(TSHR_INT16);
    }

    if (*pFlags & OE2_BCF_DELTA_BOTTOM)
    {
        OD2CopyFromDeltaCoords((LPTSHR_INT8*)ppNextDataToCopy,
                               &pRect->bottom,
                               sizeof(pRect->bottom),
                               TRUE,        // The value is signed
                               1);
    }
    else if (*pFlags & OE2_BCF_BOTTOM)
    {
        pRect->bottom        = EXTRACT_TSHR_INT16_UA(*ppNextDataToCopy);
        (*ppNextDataToCopy) += sizeof(TSHR_INT16);
    }

    //
    // Copy the rectangle for reference with the next encoding.
    //
    pasPerson->od2Party->LastBounds = *pRect;

    DebugExitVOID(ASShare::OD2DecodeBounds);
}


//
// Copy an array of source elements to an array of destination elements,
// converting the types as the copy takes place.
//
//   DESTARRAY   - The destination array
//   SRCARRAY    - The source array
//   DESTTYPE    - The type of the elements in the destination array
//   NUMELEMENTS - The number of elements in the array
//
//
#define CONVERT_ARRAY(DESTARRAY, SRCARRAY, DESTTYPE, NUMELEMENTS)     \
{                                                           \
    UINT index;                                           \
    for (index=0 ; index<(NUMELEMENTS) ; index++)           \
    {                                                       \
        (DESTARRAY)[index] = (DESTTYPE)(SRCARRAY)[index];   \
    }                                                       \
}

//
// Copy an array of source elements to an array of destination elements,
// converting the types as the copy takes place. This version allows for
// unaligned INT16 pointers
//
//   DESTARRAY   - The destination array
//   SRCARRAY    - The source array
//   DESTTYPE    - The type of the elements in the destination array
//   NUMELEMENTS - The number of elements in the array
//
//
#define CONVERT_ARRAY_INT16_UA(DESTARRAY, SRCARRAY, DESTTYPE, NUMELEMENTS)   \
{                                                           \
    UINT index;                                           \
    TSHR_INT16 value;                                          \
    for (index=0 ; index<(NUMELEMENTS) ; index++)           \
    {                                                       \
        value = EXTRACT_TSHR_INT16_UA((SRCARRAY)+index);      \
        (DESTARRAY)[index] = (DESTTYPE)value;               \
    }                                                       \
}

//
// Copy an array of source elements to an array of destination elements,
// converting the types as the copy takes place. This version allows for
// unaligned TSHR_UINT16 pointers
//
//   DESTARRAY   - The destination array
//   SRCARRAY    - The source array
//   DESTTYPE    - The type of the elements in the destination array
//   NUMELEMENTS - The number of elements in the array
//
//
#define CONVERT_ARRAY_UINT16_UA(DESTARRAY, SRCARRAY, DESTTYPE, NUMELEMENTS)  \
{                                                                            \
    UINT index;                                                            \
    TSHR_UINT16 value;                                                          \
    for (index=0 ; index<(NUMELEMENTS) ; index++)                            \
    {                                                                        \
        value = EXTRACT_TSHR_UINT16_UA((SRCARRAY)+index);                      \
        (DESTARRAY)[index] = (DESTTYPE)((TSHR_INT16)value);                    \
    }                                                                        \
}

//
// OD2DecodeField()
//
void  ASShare::OD2DecodeField
(
    LPBYTE*     ppSrc,
    LPVOID      pDst,
    UINT        cbSrcField,
    UINT        cbDstField,
    BOOL        fSigned,
    UINT        numElements
)
{
    LPTSHR_UINT8    pDst8          = (LPTSHR_UINT8)pDst;
    LPTSHR_INT16    pDst16Signed   = (LPTSHR_INT16)pDst;
    LPTSHR_INT32    pDst32Signed   = (LPTSHR_INT32)pDst;
    LPTSHR_UINT16   pDst16Unsigned = (LPTSHR_UINT16)pDst;
    LPTSHR_UINT32   pDst32Unsigned = (LPTSHR_UINT32)pDst;
    LPTSHR_INT8     pSrc8Signed     = (LPTSHR_INT8)*ppSrc;
    LPTSHR_UINT8    pSrc8Unsigned   = (LPTSHR_UINT8)*ppSrc;
    LPTSHR_INT16_UA pSrc16Signed    = (LPTSHR_INT16_UA)*ppSrc;
    LPTSHR_UINT16_UA pSrc16Unsigned  = (LPTSHR_UINT16_UA)*ppSrc;

    //
    // Note that the source fields may not be aligned correctly, so we use
    // unaligned pointers.  The destination is aligned correctly.
    //
    DebugEntry(ASShare::OD2DecodeField);

    //
    // Make sure that the destination field length is larger or equal to
    // the source field length.  If it isn't, something has gone wrong.
    //
    if (cbDstField < cbSrcField)
    {
        ERROR_OUT(( "Source field length %d is larger than destination %d",
                     cbSrcField,
                     cbDstField));
        DC_QUIT;
    }

    //
    // If the source and destination field lengths are the same, we can
    // just do a copy (no type conversion required).
    //
    if (cbSrcField == cbDstField)
    {
        memcpy(pDst8, *ppSrc, cbDstField * numElements);
    }
    else
    {
        //
        // We know that cbDstField must be greater than cbSrcField
        // because of our checks above.  So there are only three
        // conversions to consider:
        //
        //    8 bit -> 16 bit
        //    8 bit -> 32 bit
        //   16 bit -> 32 bit
        //
        // We also have to get the signed / unsigned attributes correct. If
        // we try to promote a signed value using unsigned pointers, we
        // will get the wrong result.
        //
        // e.g. Consider converting the value -1 from a TSHR_INT16 to TSHR_INT32
        //      using unsigned pointers.
        //
        //      -1 -> TSHR_UINT16 == 65535
        //         -> UINT == 65535
        //         -> TSHR_INT32  == 65535
        //
        //
        if ((cbDstField == 4) && (cbSrcField == 1))
        {
            if (fSigned)
            {
                CONVERT_ARRAY(pDst32Signed,
                              pSrc8Signed,
                              TSHR_INT32,
                              numElements);
            }
            else
            {
                CONVERT_ARRAY(pDst32Unsigned,
                              pSrc8Unsigned,
                              TSHR_UINT32,
                              numElements);
            }
        }
        else if ((cbDstField == 4) && (cbSrcField == 2))
        {
            if (fSigned)
            {
                CONVERT_ARRAY_INT16_UA(pDst32Signed,
                                       pSrc16Signed,
                                       TSHR_INT32,
                                       numElements);
            }
            else
            {
                CONVERT_ARRAY_UINT16_UA(pDst32Unsigned,
                                        pSrc16Unsigned,
                                        TSHR_UINT32,
                                        numElements);
            }
        }
        else if ((cbDstField == 2) && (cbSrcField == 1))
        {
            if (fSigned)
            {
                CONVERT_ARRAY(pDst16Signed,
                              pSrc8Signed,
                              TSHR_INT16,
                              numElements);
            }
            else
            {
                CONVERT_ARRAY(pDst16Unsigned,
                              pSrc8Unsigned,
                              TSHR_UINT16,
                              numElements);
            }
        }
        else
        {
            ERROR_OUT(( "Bad conversion, dest length = %d, src length = %d",
                         cbDstField,
                         cbSrcField));
        }
    }

DC_EXIT_POINT:
    *ppSrc += cbSrcField * numElements;
    DebugExitVOID(ASShare::OD2DecodeField);
}



//
// Given two arrays, a source array and an array of deltas, add each delta
// to the corresponding element in the source array, storing the results in
// the source array.
//
//   srcArray     - The array of source values
//   srcArrayType - The type of the array of source values
//   deltaArray   - The array of deltas
//   numElements  - The number of elements in the arrays
//
//
#define COPY_DELTA_ARRAY(srcArray, srcArrayType, deltaArray, numElements)  \
{                                                            \
    UINT index;                                            \
    for (index = 0; index < (numElements); index++)          \
    {                                                        \
        (srcArray)[index] = (srcArrayType)                   \
           ((srcArray)[index] + (deltaArray)[index]);        \
    }                                                        \
}


//
// OD2CopyFromDeltaCoords()
//
void  ASShare::OD2CopyFromDeltaCoords
(
    LPTSHR_INT8*    ppSrc,
    LPVOID          pDst,
    UINT            cbDstField,
    BOOL            fSigned,
    UINT            numElements
)
{
    LPTSHR_INT8     pDst8Signed    = (LPTSHR_INT8)pDst;
    LPTSHR_INT16    pDst16Signed   = (LPTSHR_INT16)pDst;
    LPTSHR_INT32    pDst32Signed   = (LPTSHR_INT32)pDst;
    LPTSHR_UINT8    pDst8Unsigned  = (LPTSHR_UINT8)pDst;
    LPTSHR_UINT16   pDst16Unsigned = (LPTSHR_UINT16)pDst;
    LPTSHR_UINT32   pDst32Unsigned = (LPTSHR_UINT32)pDst;

    DebugEntry(ASShare::OD2CopyFromDeltaCoords);

    switch (cbDstField)
    {
        case 1:
            if (fSigned)
            {
                COPY_DELTA_ARRAY(pDst8Signed, TSHR_INT8, *ppSrc, numElements);
            }
            else
            {
                COPY_DELTA_ARRAY(pDst8Unsigned, TSHR_UINT8, *ppSrc, numElements);
            }
            break;

        case 2:
            if (fSigned)
            {
                COPY_DELTA_ARRAY(pDst16Signed, TSHR_INT16, *ppSrc, numElements);
            }
            else
            {
                COPY_DELTA_ARRAY(pDst16Unsigned, TSHR_UINT16, *ppSrc, numElements);
            }
            break;

        case 4:
            if (fSigned)
            {
                COPY_DELTA_ARRAY(pDst32Signed, TSHR_INT32, *ppSrc, numElements);
            }
            else
            {
                COPY_DELTA_ARRAY(pDst32Unsigned, TSHR_UINT32, *ppSrc, numElements);
            }
            break;

        default:
            ERROR_OUT(( "Bad destination field length %d",
                         cbDstField));
            DC_QUIT;
            // break;
    }

DC_EXIT_POINT:
    *ppSrc += numElements;
    DebugExitVOID(ASShare::OD2CopyFromDeltaCoords);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\precomp.h ===
#include <dcg.h>
#include <ut.h>
#include <dcs.h>
#include <globals.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\s20.cpp ===
#include "precomp.h"


//
// S20.CPP
// T.128 Protocol
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_NET



//
// S20_Init()
// Initializes the T.128 protocol layer
//
BOOL  S20_Init(void)
{
    BOOL    rc = FALSE;

    DebugEntry(S20_Init);

    ASSERT(g_s20State == S20_TERM);

    //
    // Register with the network layer.
    //
    if (!MG_Register(MGTASK_DCS, &g_s20pmgClient, g_putAS))
    {
        ERROR_OUT(("Failed to register MG layer"));
        DC_QUIT;
    }

    g_s20State = S20_INIT;
    TRACE_OUT(("g_s20State is S20_INIT"));

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(S20_Init, rc);
    return(rc);
}



//
// S20_Term()
// This cleans up the T.128 protocol layer.
//
void S20_Term(void)
{
    DebugEntry(S20_Term);

    //
    // Note that this case statement is unusual in that it falls through
    // from each condition.  This happens to suit the termination
    // processing rather well.
    //
    switch (g_s20State)
    {
        case S20_IN_SHARE:
        case S20_SHARE_PEND:
            //
            // Notify share ended
            //
            SC_End();

            //
            // FALL THROUGH
            //

        case S20_NO_SHARE:
        case S20_JOIN_PEND:
            //
            // Leave our channels
            //
            if (g_s20BroadcastID != 0)
            {
                MG_ChannelLeave(g_s20pmgClient, g_s20BroadcastID);
                g_s20BroadcastID = 0;
            }
            if (g_s20JoinedLocal)
            {
                MG_ChannelLeave(g_s20pmgClient, g_s20LocalID);
                g_s20JoinedLocal = FALSE;
            }

            //
            // FALL THROUGH
            //

        case S20_ATTACH_PEND:
            //
            // Detach from the domain.
            //
            MG_Detach(g_s20pmgClient);

        case S20_INIT:
            //
            // We may end up here with g_s20BroadcastID & g_s20JoinedLocal
            // non-zero if Term was called in the middle of a share.  Clear these
            // variables so when we start back up again via Init, it
            // works the same way as first initialization.
            //
            // Note we do not need to leave the channels.
            //
            g_s20BroadcastID = 0;
            g_s20JoinedLocal = FALSE;

            //
            // Deregister.
            //
            MG_Deregister(&g_s20pmgClient);
            g_s20State = S20_TERM;
            TRACE_OUT(("g_s20State is S20_TERM"));

        case S20_TERM:
            //
            // Finally we break out.
            //
            break;

        default:
            ERROR_OUT(("invalid state %d", g_s20State));
            break;
    }

    DebugExitVOID(S20_Term);
}



//
// S20_AllocPkt
// Allocates a SEND packet for either the S20 protocol, syncs, or data
//
PS20DATAPACKET S20_AllocDataPkt
(
    UINT            streamID,
    UINT            nodeID,                 // One person or broadcast
    UINT            cbSizePacket
)
{
    PS20DATAPACKET  pS20Packet = NULL;
    NET_PRIORITY    priority;
    BOOL            rc = FALSE;

    DebugEntry(S20_AllocDataPkt);

    ASSERT(g_s20State == S20_IN_SHARE);

    //
    // Try to send queued control packets first.
    //
    if (S20SendQueuedControlPackets() != 0)
    {
        //
        // If there are still queued control packets then don't allow any
        // allocation.
        //
        DC_QUIT;
    }

    priority = S20StreamToS20Priority(streamID);

    //
    // Note:
    // Sends to an individual node are NOT flow-controlled.  Only the
    // global app sharing channel is.
    //
    if (MG_GetBuffer(g_s20pmgClient, cbSizePacket, priority,
                        (NET_CHANNEL_ID)nodeID, (void **)&pS20Packet) != 0)
    {
        TRACE_OUT(("MG_GetBuffer failed; can't allocate S20 packet"));
    }
    else
    {
        pS20Packet->header.packetType   = S20_DATA | S20_ALL_VERSIONS;
        pS20Packet->header.user         = g_s20LocalID;

        pS20Packet->correlator  = g_s20ShareCorrelator;
        pS20Packet->stream      = 0;
        pS20Packet->dataLength  = cbSizePacket - sizeof(S20DATAPACKET) + sizeof(DATAPACKETHEADER);

        rc = TRUE;
    }

DC_EXIT_POINT:
    DebugExitPVOID(S20_AllocDataPkt, pS20Packet);
    return(pS20Packet);
}


//
// S20_FreeDataPkt - see s20.h
//
void  S20_FreeDataPkt(PS20DATAPACKET pS20Packet)
{
    DebugEntry(S20_FreeDataPkt);

    MG_FreeBuffer(g_s20pmgClient, (void **)&pS20Packet);

    DebugExitVOID(S20_FreeDataPkt);
}

//
// S20_SendDataPkt - see s20.h
//
void  S20_SendDataPkt
(
    UINT            streamID,
    UINT            nodeID,
    PS20DATAPACKET  pS20Packet
)
{
    UINT            rc;
    NET_PRIORITY    priority;

    DebugEntry(S20_SendDataPkt);

    priority = S20StreamToS20Priority(streamID);

    //
    // Note:
    // Sends to an individual are not flow-controlled.  Only sends to
    // everybody on the global app sharing channel are.
    //

    //
    // Try to send queued control packets first.
    //
    rc = S20SendQueuedControlPackets();
    if (rc == 0)
    {
        //
        // Fill in the stream, length and correlator before sending.
        //
        pS20Packet->stream      = (BYTE)streamID;
        pS20Packet->correlator  = g_s20ShareCorrelator;

        //
        // dataLength includes the DATAPACKETHEADER part of the S20DATAPACKET
        // structure
        //
        TRACE_OUT(("S20_SendPkt: sending data packet size %d",
            pS20Packet->dataLength + sizeof(S20DATAPACKET) - sizeof(DATAPACKETHEADER)));

        rc = MG_SendData(g_s20pmgClient, priority, (NET_CHANNEL_ID)nodeID,
            pS20Packet->dataLength + sizeof(S20DATAPACKET) - sizeof(DATAPACKETHEADER),
            (void **)&pS20Packet);
    }

    // lonchanc: it is ok for MG_SendData returns 0 and NET_CHANNEL_EMPTY

    if (rc == NET_RC_MGC_NOT_CONNECTED)
    {
        S20LeaveOrEndShare();
    }
    else
    {
        if (rc != 0)
        {
            ERROR_OUT(("SendData rc=%lx - expecting share termination soon", rc));
        }
    }

    DebugExitVOID(S20_SendDataPkt);
}


//
// S20_UTEventProc()
//
BOOL CALLBACK  S20_UTEventProc
(
    LPVOID      userData,
    UINT        event,
    UINT_PTR    data1,
    UINT_PTR    data2
)
{
    BOOL        processed;

    DebugEntry(S20_UTEventProc);

    processed = TRUE;

    switch (event)
    {
        case NET_EVENT_USER_ATTACH:
            S20AttachConfirm(LOWORD(data1), HIWORD(data1), (UINT)data2);
            break;

        case NET_EVENT_USER_DETACH:
            S20DetachIndication(LOWORD(data1), (UINT)data2);
            break;

        case NET_EVENT_CHANNEL_JOIN:
            S20JoinConfirm((PNET_JOIN_CNF_EVENT)data2);
            MG_FreeBuffer(g_s20pmgClient, (void **)&data2);
            break;

        case NET_EVENT_CHANNEL_LEAVE:
            S20LeaveIndication(LOWORD(data1), (UINT)data2);
            break;

        case NET_EVENT_DATA_RECEIVED:
            S20SendIndication((PNET_SEND_IND_EVENT)data2);
            break;

        case NET_FLOW:
            //
            // Handle the feedback event.
            //
            S20Flow((UINT)data1, (UINT)data2);
            break;

        case CMS_NEW_CALL:
            if (g_asSession.scState == SCS_INIT)
            {
                //
                // This happens when (a) a new real call is started
                // (b) creating a new share in a call fails, so we want to
                // then try to join an existing share.
                //
                SCCheckForCMCall();
            }
            break;

        case CMS_END_CALL:
            if (g_asSession.callID)
            {
                //
                // AS lock protects g_asSession global fields
                //
                TRACE_OUT(("AS LOCK:  CMS_END_CALL"));
                UT_Lock(UTLOCK_AS);

                g_asSession.gccID  = 0;
                g_asSession.callID = 0;

                UT_Unlock(UTLOCK_AS);
                TRACE_OUT(("AS UNLOCK:  CMS_END_CALL"));

                if (g_asSession.scState > SCS_SHAREENDING)
                {
                    SC_EndShare();
                }

                DCS_NotifyUI(SH_EVT_APPSHARE_READY, FALSE, 0);

                g_s20BroadcastID = 0;
                g_s20JoinedLocal = FALSE;
                g_s20State = S20_INIT;
                TRACE_OUT(("g_s20State is S20_INIT"));
            }
            break;

        default:
            processed = FALSE;
            break;
    }

    DebugExitBOOL(S20_UTEventProc, processed);
    return(processed);
}



//
// FUNCTION: S20AttachUser
//
// DESCRIPTION:
//
// Called when we want to attach this sets up the various parameters for
// MG_Attach, calls it and handles the return codes from NET.
//
// PARAMETERS:
//
// callID - the callID provided by the SC user
//
//
//
const NET_FLOW_CONTROL c_S20FlowControl =
    {
        // latency
        {
            S20_LATENCY_TOP_PRIORITY,
            S20_LATENCY_HIGH_PRIORITY,
            S20_LATENCY_MEDIUM_PRIORITY,
            S20_LATENCY_LOW_PRIORITY
        },
        // stream size
        {
            S20_SIZE_TOP_PRIORITY,
            S20_SIZE_HIGH_PRIORITY,
            S20_SIZE_MEDIUM_PRIORITY,
            S20_SIZE_LOW_PRIORITY
        }
    };


//
// S20CreateOrJoinShare()
// Creates a share for the first time or joins an existing one
//
// Normally, creating a share requires
//      * registration
//      * broadcast of S20_CREATE packet
//      * reception of one S20_RESPOND packet
// for the share to be created.  However, if we're the top provider, we
// assume it's created without waiting for an S20_RESPOND.  If something
// goes wrong later, it will clean itself up anyway.  Then that allows us
// to host a conference, share an app, and have it be shared through the
// life of the conference, even if remotes call/hang up repeatedly.
//
BOOL S20CreateOrJoinShare
(
    UINT    what,
    UINT    callID
)
{
    UINT    rc = 0;
    BOOL    noFlowControl;
    NET_FLOW_CONTROL    flowControl;

    DebugEntry(S20CreateOrJoinShare);

    ASSERT((what == S20_CREATE) || (what == S20_JOIN));

    switch (g_s20State)
    {
        case S20_INIT:
            //
            // Remember what to do when we have attached and joined.
            //
            g_s20Pend = what;

            //
            // ATTACH the S20 MCS USER
            //

            COM_ReadProfInt(DBG_INI_SECTION_NAME, S20_INI_NOFLOWCONTROL,
                FALSE, &noFlowControl);
            if (noFlowControl)
            {
                WARNING_OUT(("S20 Flow Control is OFF"));
                ZeroMemory(&flowControl, sizeof(flowControl));
            }
            else
            {
                // Set up our target latencies and stream sizes
                flowControl = c_S20FlowControl;
            }

            //
            // Initiate an attach - the domain equals the callID.
            //
            rc = MG_Attach(g_s20pmgClient, callID, &flowControl);
            if (rc == 0)
            {
                //
                // Make the state change if we succeeded
                //
                g_s20State = S20_ATTACH_PEND;
                TRACE_OUT(("g_s20State is S20_ATTACH_PEND"));
            }
            else
            {
                //
                // End the share immediately and no state change.
                //
                WARNING_OUT(("MG_Attach of S20 User failed, rc = %u", rc));

                g_s20Pend = 0;
                SC_End();
            }
            break;

        case S20_ATTACH_PEND:
        case S20_JOIN_PEND:
            //
            // We just need to set the flag in these cases - we will try
            // to create a share when we have attached and joined our
            // channel.
            //
            g_s20Pend = what;
            break;

        case S20_SHARE_PEND:
            //
            // If a share is pending but the SC user wants to create
            // or join again we let them.  Multiple outstanding joins are
            // benign and another create will have a new correlator so the
            // previous one (and any responses to it) will be obsolete.
            //
            // NOTE DELIBERATE FALL THROUGH
            //
            //

        case S20_NO_SHARE:
            TRACE_OUT(("S20_NO_SHARE"));
            //
            // Broadcast a S20CREATE packet.
            //
            if (what == S20_CREATE)
            {
                g_s20ShareCorrelator = S20NewCorrelator();
                TRACE_OUT(("CP CREATE %lu %d", g_s20ShareCorrelator, 0));
                rc = S20FlushAndSendControlPacket(what,
                                                  g_s20ShareCorrelator,
                                                  0,
                                                  NET_TOP_PRIORITY);
            }
            else
            {
                g_s20ShareCorrelator = 0;
                TRACE_OUT(("CP JOIN %lu %d", 0, 0));
                rc = S20FlushAndSendControlPacket(what, 0, 0,
                                                  NET_TOP_PRIORITY);
            }
            TRACE_OUT(("S20FlushAndSendControlPacket %u", rc));

            if (rc == 0)
            {
                //
                // Switch state.
                //
                g_s20State = S20_SHARE_PEND;
                TRACE_OUT(("g_s20State is S20_SHARE_PEND"));

                //
                // Assume success right away when creating the share.  We'll
                // hear back in a bit if there's a problem.
                //
                if (what == S20_CREATE)
                {
                    // Don't check for top provider, assume success always.
                    TRACE_OUT(("S20: Creating share, assume success"));

                    //
                    // LAURABU -- IF THIS CAUSES PROBLEMS, fall back to
                    // checking for one person only in call.
                    //
                    if (!SC_Start(g_s20LocalID))
                    {
                        WARNING_OUT(("S20CreateOrJoin: couldn't start share"));
                        SC_End();
                    }
                    else
                    {
                        g_s20State = S20_IN_SHARE;
                        TRACE_OUT(("g_s20State is S20_IN_SHARE"));
                    }
                }
            }
            else
            {
                //
                // Something failed so we will just forget about the share.
                //
                WARNING_OUT(("Failed to create share"));
                if (what == S20_CREATE)
                {
                    SC_End();
                }
            }
            break;

        default:
            ERROR_OUT(("Invalid state %u for %u", g_s20State, what));
    }

    DebugExitBOOL(S20CreateOrJoinShare, (rc == 0));
    return(rc == 0);
}

//
// FUNCTION: S20LeaveOrEndShare
//
// DESCRIPTION:
//
// Handles processing a S20_LeaveShare or a S20_EndShare call.
//
// PARAMETERS:
//
// what - what to do (the protocol packet type corresponding to the
// action).
//
// RETURNS: NONE
//
//
void S20LeaveOrEndShare(void)
{
    UINT    what;

    DebugEntry(S20LeaveOrEndShare);

    //
    // The share is destroyed whenever the creator leaves.  Nobody else
    // can end it.
    //
    if (S20_GET_CREATOR(g_s20ShareCorrelator) == g_s20LocalID)
    {
        what = S20_END;
    }
    else
    {
        what = S20_LEAVE;
    }

    ASSERT(what == S20_LEAVE || what == S20_END);

    switch (g_s20State)
    {
        case S20_ATTACH_PEND:
        case S20_JOIN_PEND:
            //
            // We just need to reset the pending flags here - no state
            // change required.
            //
            g_s20Pend = 0;
            break;

        case S20_IN_SHARE:
        case S20_SHARE_PEND:
            TRACE_OUT(("S20_SHARE_PEND"));
            //
            // Now try and make and send the appropriate control packet.
            //
            TRACE_OUT(("CP %u %u %d", what, g_s20ShareCorrelator, 0));
            S20FlushSendOrQueueControlPacket(what,
                                             g_s20ShareCorrelator,
                                             0,
                                             NET_TOP_PRIORITY);

            //
            // Make the SHARE_ENDED callback.
            //
            SC_End();
            break;

        default:
            WARNING_OUT(("invalid state %d for %d", g_s20State, what));
            break;
    }

    DebugExitVOID(S20LeaveOrEndShare);
}

//
// FUNCTION: S20MakeControlPacket
//
// DESCRIPTION:
//
// Attempts to allocate and construct a S20 control packet.
//
// PARAMETERS:
//
// what - which type of packet
//
// correlator - the correlator to place in the packet
//
// who - the target party (if what is a S20_DELETE) or the originator (if
// what is S20_RESPOND)
//
// ppPacket - where to return a pointer to the packet.
//
// pLength - where to return the length of the packet.
//
// priority - priority of packet to make
//
// RETURNS:
//
//
UINT S20MakeControlPacket
(
    UINT            what,
    UINT            correlator,
    UINT            who,
    PS20PACKETHEADER * ppPacket,
    LPUINT          pcbPacketSize,
    UINT            priority
)
{
    UINT      rc;
    BOOL      fPutNameAndCaps;
    UINT      cbPacketSize;
    UINT      personNameLength;
    PS20PACKETHEADER  pS20Packet = NULL;
    LPBYTE    pData;

    DebugEntry(S20MakeControlPacket);

    //
    // Assume success
    //
    rc = 0;

    //
    // Work out how big the packet needs to be.  Start with the fixed
    // length then add in capabilities and our name (if they are required).
    //
    switch (what)
    {
        case S20_CREATE:
            cbPacketSize = sizeof(S20CREATEPACKET) - 1;
            fPutNameAndCaps = TRUE;
            break;

        case S20_JOIN:
            cbPacketSize = sizeof(S20JOINPACKET) - 1;
            fPutNameAndCaps = TRUE;
            break;

        case S20_RESPOND:
            cbPacketSize = sizeof(S20RESPONDPACKET) - 1;
            fPutNameAndCaps = TRUE;
            break;

        case S20_DELETE:
            cbPacketSize = sizeof(S20DELETEPACKET) - 1;
            fPutNameAndCaps = FALSE;
            break;

        case S20_LEAVE:
            cbPacketSize = sizeof(S20LEAVEPACKET);
            fPutNameAndCaps = FALSE;
            break;

        case S20_END:
            cbPacketSize = sizeof(S20ENDPACKET) - 1;
            fPutNameAndCaps = FALSE;
            break;

        case S20_COLLISION:
            cbPacketSize = sizeof(S20COLLISIONPACKET);
            fPutNameAndCaps = FALSE;
            break;

        default:
            ERROR_OUT(("BOGUS S20 packet %u", what));
            break;
    }

    if (fPutNameAndCaps)
    {
        ASSERT(g_asSession.gccID);
        ASSERT(g_asSession.cchLocalName);

        //
        // The name data is always dword aligned (including the NULL)
        //
        personNameLength = DC_ROUND_UP_4(g_asSession.cchLocalName+1);
        cbPacketSize += personNameLength + sizeof(g_cpcLocalCaps);
    }

    //
    // Now try to allocate a buffer for this.
    //
    rc = MG_GetBuffer( g_s20pmgClient,
                       cbPacketSize,
                           (NET_PRIORITY)priority,
                           g_s20BroadcastID,
                           (void **)&pS20Packet );

    if (rc != 0)
    {
        TRACE_OUT(("MG_GetBuffer failed; can't send S20 control packet"));
        DC_QUIT;
    }

    pS20Packet->packetType  = (TSHR_UINT16)what | S20_ALL_VERSIONS;
    pS20Packet->user        = g_s20LocalID;

    //
    // This will point to where we need to stuff the name and/or
    // capabilities.
    //
    pData = NULL;

    //
    // Now do the packet dependant fields.
    //
    switch (what)
    {
        case S20_CREATE:
        {
            ASSERT(fPutNameAndCaps);
            ((PS20CREATEPACKET)pS20Packet)->correlator  = correlator;
            ((PS20CREATEPACKET)pS20Packet)->lenName     = (TSHR_UINT16)personNameLength;
            ((PS20CREATEPACKET)pS20Packet)->lenCaps     = (TSHR_UINT16)sizeof(g_cpcLocalCaps);
            pData = ((PS20CREATEPACKET)pS20Packet)->data;
        }
        break;

        case S20_JOIN:
        {
            ASSERT(fPutNameAndCaps);
            ((PS20JOINPACKET)pS20Packet)->lenName       = (TSHR_UINT16)personNameLength;
            ((PS20JOINPACKET)pS20Packet)->lenCaps       = (TSHR_UINT16)sizeof(g_cpcLocalCaps);
            pData = ((PS20JOINPACKET)pS20Packet)->data;
        }
        break;

        case S20_RESPOND:
        {
            ASSERT(fPutNameAndCaps);
            ((PS20RESPONDPACKET)pS20Packet)->correlator = correlator;
            ((PS20RESPONDPACKET)pS20Packet)->originator = (TSHR_UINT16)who;
            ((PS20RESPONDPACKET)pS20Packet)->lenName    = (TSHR_UINT16)personNameLength;
            ((PS20RESPONDPACKET)pS20Packet)->lenCaps    = (TSHR_UINT16)sizeof(g_cpcLocalCaps);
            pData = ((PS20RESPONDPACKET)pS20Packet)->data;
        }
        break;

        case S20_DELETE:
        {
            ASSERT(!fPutNameAndCaps);
            ((PS20DELETEPACKET)pS20Packet)->correlator = correlator;
            ((PS20DELETEPACKET)pS20Packet)->target = (TSHR_UINT16)who;
            ((PS20DELETEPACKET)pS20Packet)->lenName = 0;
        }
        break;

        case S20_LEAVE:
        {
            ASSERT(!fPutNameAndCaps);
            ((PS20LEAVEPACKET)pS20Packet)->correlator = correlator;
        }
        break;

        case S20_END:
        {
            ASSERT(!fPutNameAndCaps);
            ((PS20ENDPACKET)pS20Packet)->correlator = correlator;
            ((PS20ENDPACKET)pS20Packet)->lenName    = 0;
        }
        break;

        case S20_COLLISION:
        {
            ASSERT(!fPutNameAndCaps);
            ((PS20COLLISIONPACKET)pS20Packet)->correlator = correlator;
        }
        break;

        default:
        {
            ERROR_OUT(("Invalid type %u", what));
        }
        break;
    }

    //
    // Now we can copy in the name and capabilities.
    //
    if (fPutNameAndCaps)
    {
        lstrcpy((LPSTR)pData, g_asSession.achLocalName);

        // The local name is always null-terminated (truncated to fit in 48 bytes inc. null)
        pData += personNameLength;

        memcpy(pData, &g_cpcLocalCaps, sizeof(g_cpcLocalCaps));

        //
        // FILL IN GCC-ID HERE; the local caps are shared but the local
        // person entity in the share doesn't exist yet.
        //
        ((CPCALLCAPS *)pData)->share.gccID = g_asSession.gccID;
    }

    //
    // Return the packet and length.
    //
    *ppPacket       = pS20Packet;
    *pcbPacketSize  = cbPacketSize;

DC_EXIT_POINT:
    DebugExitDWORD(S20MakeControlPacket, rc);
    return(rc);
}

//
// FUNCTION: S20FlushSendOrQueueControlPacket
//
// DESCRIPTION:
//
// Attempts to flush any queued S20 control packets and then attempte to
// send a S20 control packet.  If this fails the queue the packet (the
// actual packet is freed.
//
// PARAMETERS:
//
// what - which type of packet
//
// correlator - the correlator to place in the packet
//
// who - the target party (if what is a S20_DELETE) or the originator (if
// what is S20_RESPOND)
//
// priority - priority to send packet at
//
// RETURNS: NONE
//
//
UINT S20FlushSendOrQueueControlPacket(
    UINT      what,
    UINT      correlator,
    UINT      who,
    UINT      priority)
{
    UINT rc;

    DebugEntry(S20FlushSendOrQueueControlPacket);

    rc = S20FlushAndSendControlPacket(what, correlator, who, priority);
    if (rc != 0)
    {
        // Let's queue this packet
        if (((g_s20ControlPacketQTail + 1) % S20_MAX_QUEUED_CONTROL_PACKETS) ==
                                                            g_s20ControlPacketQHead)
        {
            //
            // There is no more space in the control packet queue.  We will
            // discard everything from it and say the share ended because of
            // a network error (if we're in a share).
            //
            ERROR_OUT(("No more space in control packet queue"));
        }
        else
        {
            S20CONTROLPACKETQENTRY *p = &(g_s20ControlPacketQ[g_s20ControlPacketQTail]);

            p->who        = who;
            p->correlator = correlator;
            p->what       = what;
            p->priority   = priority;

            g_s20ControlPacketQTail = (g_s20ControlPacketQTail + 1) %
                                                   S20_MAX_QUEUED_CONTROL_PACKETS;
            rc = 0;
        }
    }

    DebugExitDWORD(S20FlushSendOrQueueControlPacket, rc);
    return rc;
}


//
// FUNCTION: S20FlushAndSendControlPacket
//
// DESCRIPTION:
//
// Attempts to flush any queued S20 control packets and then send a S20
// control packet.  If sending fails then free the packet.
//
// PARAMETERS:
//
// what - which type of packet
//
// correlator - the correlator to place in the packet
//
// who - the target party (if what is a S20_DELETE) or the originator (if
// what is S20_RESPOND)
//
// priority - priority to send packet at
//
// RETURNS:
//
//
UINT S20FlushAndSendControlPacket
(
    UINT        what,
    UINT        correlator,
    UINT        who,
    UINT        priority
)
{
    UINT        rc;
    PS20PACKETHEADER  pS20Packet;
    UINT      length;

    DebugEntry(S20FlushAndSendControlPacket);

    //
    // First try to flush.
    //
    rc = S20SendQueuedControlPackets();
    if (rc != 0)
    {
        TRACE_OUT(("S20SendQueuedControlPackets %u", rc));
        DC_QUIT;
    }

    rc = S20MakeControlPacket(what, correlator, who, &pS20Packet, &length, priority);
    if (rc != 0)
    {
        TRACE_OUT(("S20MakeControlPacket %u", rc));
        DC_QUIT;
    }

    TRACE_OUT(("CP %u %lu %u sent", what, correlator, who));

    rc = S20SendControlPacket(pS20Packet, length, priority);
    if (rc != 0)
    {
        TRACE_OUT(("S20SendControlPacket %u", rc));
        DC_QUIT;
    }

DC_EXIT_POINT:
    DebugExitDWORD(S20FlushAndSendControlPacket, rc);
    return(rc);
}

//
// FUNCTION: S20SendControlPacket
//
// DESCRIPTION:
//
// Attempts to send a S20 control packet.  If sending fails then free the
// packet.
//
// PARAMETERS:
//
// pPacket - pointer to the control packet to send.  These are always
// broadcast.
//
// length - length of aforementioned packet.
//
// priority - priority to send packet at
//
// RETURNS:
//
//
UINT S20SendControlPacket
(
    PS20PACKETHEADER    pS20Packet,
    UINT                length,
    UINT                priority
)
{
    UINT rc;

    DebugEntry(S20SendControlPacket);

    TRACE_OUT(("S20SendControlPacket: sending packet type %x, size %d",
        pS20Packet->packetType, length));

    rc = MG_SendData( g_s20pmgClient,
                          (NET_PRIORITY)priority,
                          g_s20BroadcastID,
                          length,
                          (void **)&pS20Packet );
    if (rc != 0)
    {
        TRACE_OUT(("MG_SendData %lx", rc));
    }

    if (pS20Packet != NULL)
    {
        //
        // The packet was not freed by the NL - we will do it instead.
        //
        MG_FreeBuffer(g_s20pmgClient, (void **)&pS20Packet);
    }

    DebugExitDWORD(S20SendControlPacket, rc);
    return(rc);
}


//
// FUNCTION: S20SendQueuedControlPackets
//
// DESCRIPTION:
//
// Sends as many queued packets as possible
//
// PARAMETERS:
//
//
// RETURNS:
//
//  0 - all queued packets have been sent.
//
//
UINT S20SendQueuedControlPackets(void)
{
    PS20PACKETHEADER    pS20Packet;
    UINT                length;
    UINT                rc;
    UINT                priority;

    DebugEntry(S20SendQueuedControlPackets);

    //
    // Assume success until something fails.
    //
    rc = 0;

    //
    // While there are packets to send - try to send them
    //
    while (g_s20ControlPacketQTail != g_s20ControlPacketQHead)
    {
        S20CONTROLPACKETQENTRY *p = &(g_s20ControlPacketQ[g_s20ControlPacketQHead]);
        priority = p->priority;

        rc = S20MakeControlPacket(p->what, p->correlator, p->who,
                                      &pS20Packet, &length, priority);
        if (rc != 0)
        {
            //
            // Failed to make the packet - give up.
            //
            WARNING_OUT(("S20MakeControlPacket failed error %u", rc));
            break;
        }

        rc = S20SendControlPacket(pS20Packet, length, priority);
        if (rc != 0)
        {
            //
            // Failed to send the packet - give up.
            //
            break;
        }

        //
        // Succesfully sent the queue packet - move the head of the queue
        // along one.
        //
        g_s20ControlPacketQHead = (g_s20ControlPacketQHead + 1) %
                                               S20_MAX_QUEUED_CONTROL_PACKETS;
    }

    DebugExitDWORD(S20SendQueuedControlPackets, rc);
    return(rc);
}


//
// S20AttachConfirm()
//
// Handles the MCS attach confirmation
//
void S20AttachConfirm
(
    NET_UID         userId,
    NET_RESULT      result,
    UINT            callID
)
{
    NET_CHANNEL_ID  correlator;
    UINT            rc;

    DebugEntry(S20AttachConfirm);

    if (g_s20State == S20_ATTACH_PEND)
    {
        //
        // Assume we need to clear up.
        //
        rc = NET_RC_S20_FAIL;

        if (result == NET_RESULT_OK)
        {
            //
            // We're in.  Now try to join our channel and remember our
            // userID.
            //
            g_s20LocalID = userId;

            //
            // We must join our single member channel for flow control
            //
            rc = MG_ChannelJoin(g_s20pmgClient,
                                    &correlator,
                                    g_s20LocalID);
            if (rc == 0)
            {
                //
                // Now join the broadcast channel
                //
                rc = MG_ChannelJoinByKey(g_s20pmgClient,
                                             &correlator,
                                             GCC_AS_CHANNEL_KEY);
                if (rc != 0)
                {
                    MG_ChannelLeave(g_s20pmgClient, g_s20LocalID);
                }

            }

            if (rc == 0)
            {
                //
                // It worked - make the state change.
                //
                g_s20State = S20_JOIN_PEND;
                TRACE_OUT(("g_s20State is S20_JOIN_PEND"));
            }
            else
            {
                //
                // Everything else is some sort of logic error (we will
                // follow our recovery path).
                //
                WARNING_OUT(("ChannelJoin unexpected error %u", rc));
            }
        }

        if (rc != 0)
        {
            //
            // Something didn't work work out - clear up with a
            // SHARE_ENDED if a create or join was pending.
            //

            if (result == NET_RESULT_OK)
            {
                //
                // The attach succeeded so detach because the join
                // failed and we want to go back to initialised state.
                //
                MG_Detach(g_s20pmgClient);
                g_s20LocalID = 0;
            }

            //
            // Now make the state change and generate event if
            // necessary.
            //
            g_s20State = S20_INIT;
            TRACE_OUT(("g_s20State is S20_INIT"));

            if (g_s20Pend)
            {
                g_s20Pend = 0;
                SC_End();
            }

        }
    }

    DebugExitVOID(S20AttachConfirm);
}



//
// S20DetachIndication()
//
// Handles NET_EVENT_DETACH notification for a user
//
void  S20DetachIndication
(
    NET_UID     userId,
    UINT        callID
)
{
    DebugEntry(S20DetachIndication);

    //
    // There are three possibilities here
    //
    //  1.  We have been forced out.
    //  2.  All remote users have detached.
    //  3.  A remote user has detached.
    //
    // 2 is effectively a 3 for each current remote user.  We report 1 as a
    // network error.
    //
    if (userId == g_s20LocalID)
    {
        //
        // We have been forced out.
        //
        switch (g_s20State)
        {
            case S20_IN_SHARE:
            case S20_SHARE_PEND:
            case S20_SHARE_STARTING:
                //
                // Generate a share ended event.
                //
                SC_End();

                // FALL THROUGH
            case S20_NO_SHARE:
                //
                // Just revert to init state.
                //
                g_s20State = S20_INIT;
                TRACE_OUT(("g_s20State is S20_INIT"));
                break;

            case S20_JOIN_PEND:
            case S20_ATTACH_PEND:
                //
                // Check the join or create pending flags here and if
                // either one is set then generate a share ended
                //
                if (g_s20Pend)
                {
                    g_s20Pend = 0;
                    SC_End();
                }

                g_s20State = S20_INIT;
                TRACE_OUT(("g_s20State is S20_INIT"));
                break;

            case S20_TERM:
            case S20_INIT:
                //
                // Unusual but not impossible.
                //
                TRACE_OUT(("Ignored in state %u", g_s20State));
                break;

            default:
                ERROR_OUT(("Invalid state %u", g_s20State));
                break;
        }

    }
    else
    {
        ASSERT(userId != NET_ALL_REMOTES);

        //
        // A single remote user has left.
        //
        switch (g_s20State)
        {
            case S20_IN_SHARE:
            {
                //
                // If we are in a share then issue a PARTY_DELETED event
                // for the appropriate party if they have been added.
                // S20MaybeIssuePersonDelete will only issue deletes for
                // parties which have been added succesfully.
                //
                S20MaybeIssuePersonDelete(userId);
            }
            break;

            default:
            {
                //
                // In any other state this makes no difference to us.
                //
                TRACE_OUT(("ignored in state %u", g_s20State));
            }
            break;
        }
    }

    DebugExitVOID(S20DetachIndication);
}


//
// FUNCTION: S20JoinConfirm
//
// DESCRIPTION:
//
// Handles the NET_EVENT_CHANNEL_JOIN message from the NL
//
// PARAMETERS:
//
// pNetEventHeader - pointer to the event
//
// RETURNS: NONE
//
//
void  S20JoinConfirm(PNET_JOIN_CNF_EVENT pJoinConfirm)
{
    UINT             rc;

    DebugEntry(S20JoinConfirm);

    if (g_s20State == S20_JOIN_PEND)
    {
        //
        // Handle the join completing
        //
        if (pJoinConfirm->result == NET_RESULT_OK)
        {
            //
            // We have sucessfully joined, either our single user
            // channel or our broadcast channel
            // We detect that both are successful when the g_s20BroadcastID
            // field is filled in and g_s20JoinedLocal is TRUE
            //
            if (pJoinConfirm->channel == g_s20LocalID)
            {
                g_s20JoinedLocal = TRUE;
                TRACE_OUT(("Joined user channel"));
            }
            else
            {
                //
                // Store the assigned channel.
                //
                g_s20BroadcastID = pJoinConfirm->channel;
                TRACE_OUT(("Joined channel %u", (UINT)g_s20BroadcastID));
            }

            //
            // If we have joined both channels then let it rip
            //
            if (g_s20JoinedLocal && g_s20BroadcastID)
            {
                g_s20State = S20_NO_SHARE;
                TRACE_OUT(("g_s20State is S20_NO_SHARE"));

                DCS_NotifyUI(SH_EVT_APPSHARE_READY, TRUE, 0);

                //
                // Issue create or join if they are pending.
                //
                if (g_s20Pend != 0)
                {
                    ASSERT(g_s20Pend == S20_JOIN);

                    UINT sPend;

                    sPend = g_s20Pend;
                    g_s20Pend = 0;
                    S20CreateOrJoinShare(sPend, pJoinConfirm->callID);
                }
            }
        }
        else
        {
            ERROR_OUT(("Channel join failed"));

            //
            // Clear up by reverting to initialised state.
            //
            MG_Detach(g_s20pmgClient);

            g_s20LocalID  = 0;
            g_s20BroadcastID = 0;
            g_s20JoinedLocal = FALSE;

            //
            // Now make the state change and generate event if
            // necessary.
            //
            g_s20State = S20_INIT;
            TRACE_OUT(("g_s20State is S20_INIT"));

            if (g_s20Pend)
            {
                g_s20Pend = 0;
                SC_End();
            }
        }
    }
    DebugExitVOID(S20JoinConfirm);
}

//
// FUNCTION: S20LeaveIndication
//
// DESCRIPTION:
//
// Handles the NET_EV_LEAVE_INDICATION message from the NL
//
// PARAMETERS:
//
// pNetEventHeader - pointer to the event
//
// RETURNS: NONE
//
//
void  S20LeaveIndication
(
    NET_CHANNEL_ID  channelID,
    UINT            callID
)
{
    UINT rc;

    DebugEntry(S20LeaveIndication);

    //
    // A leave indication means we were forced out of a channel.  As we
    // only use one channel this is bound to be terminal and we will
    // generate appropriate share ending type events and detach (this will
    // hopefully tell the remote systems we have gone - also we have no
    // state which is attached but not trying to join so the alternatives
    // would be to 1) add a new state or 2) try and re-join a channel
    // immediately we get chucked out.  Neither appeals.
    //
    switch (g_s20State)
    {
        case S20_IN_SHARE:
        case S20_SHARE_PEND:
        case S20_SHARE_STARTING:
            //
            // Generate a share ended event.
            //
            SC_End();

            // FALL THROUGH

        case S20_NO_SHARE:
        case S20_JOIN_PEND:
        case S20_ATTACH_PEND:
            //
            // Detach from the domain.
            //
            MG_Detach(g_s20pmgClient);
            g_s20LocalID = 0;

            //
            // Check the join or create pending flags here and if either
            // one is set then generate a share ended
            //
            if (g_s20Pend)
            {
                g_s20Pend = 0;
                SC_End();
            }

            g_s20State = S20_INIT;
            TRACE_OUT(("g_s20State is S20_INIT"));
            break;

        case S20_TERM:
        case S20_INIT:
            //
            // Unusual but not impossible.
            //
            TRACE_OUT(("Ignored in state %u", g_s20State));
            break;

        default:
            ERROR_OUT(("Invalid state %u", g_s20State));
            break;
    }

    DebugExitVOID(S20LeaveIndication);
}


//
// S20SendIndication()
//
// Handles received data notification
//
void  S20SendIndication(PNET_SEND_IND_EVENT pSendIndication)
{
    PS20PACKETHEADER        pS20Packet;

    DebugEntry(S20SendIndication);

    pS20Packet = (PS20PACKETHEADER)(pSendIndication->data_ptr);

	//
	// If App Sharing detaches from the T.120 conference, it will free up
	// all data indication buffers.  We need to check for this condition.
	//
    if (NULL != pS20Packet)
    {
	    if (!(pS20Packet->packetType & S20_ALL_VERSIONS))
	    {
	        ERROR_OUT(("User is trying to connect from %#hx system",
	                 pS20Packet->packetType & 0xF0));

	        //
	        // This should never happen, but if it does then we assert in the
	        // debug build and quietly fail in the retail build.
	        //
	        ERROR_OUT(("An unsupported version of app sharing joined the conference"));
	        DC_QUIT;
	    }

	    //
	    // Mask out the protocol version
	    //
	    switch (pS20Packet->packetType & S20_PACKET_TYPE_MASK)
	    {
	        case S20_CREATE:
	            S20CreateMsg((PS20CREATEPACKET)pS20Packet);
	            break;

	        case S20_JOIN:
	            S20JoinMsg((PS20JOINPACKET)pS20Packet);
	            break;

	        case S20_RESPOND:
	            S20RespondMsg((PS20RESPONDPACKET)pS20Packet);
	            break;

	        case S20_DELETE:
	            S20DeleteMsg((PS20DELETEPACKET)pS20Packet);
	            break;

	        case S20_LEAVE:
	            S20LeaveMsg((PS20LEAVEPACKET)pS20Packet);
	            break;

	        case S20_END:
	            S20EndMsg((PS20ENDPACKET)pS20Packet);
	            break;

            case S20_COLLISION:
                S20CollisionMsg((PS20COLLISIONPACKET)pS20Packet);
                break;

	        case S20_DATA:
	            S20DataMsg((PS20DATAPACKET)pS20Packet);
	            break;

	        default:
	            ERROR_OUT(("invalid packet %hu", pS20Packet->packetType));
	            break;
	    }
    }

DC_EXIT_POINT:
    MG_FreeBuffer(g_s20pmgClient, (void **)&pSendIndication);

    DebugExitVOID(S20SendIndication);
}


//
// FUNCTION: S20Flow
//
// DESCRIPTION:
//
// Handles the NET_FLOW event
//
// PARAMETERS:
//
// data1, data2 - the data from the UT event handler
//
// RETURNS: NONE
//
//
void S20Flow
(
    UINT    priority,
    UINT    newBufferSize
)
{
    DebugEntry(S20Flow);

    //
    // We know this is our data channel (it is the only one we flow
    // control) but if this is not the UPDATE stream, then ignore it.
    // UPDATEs are low priority.
    //
    ASSERT(priority == NET_LOW_PRIORITY);

    if (g_asSession.pShare != NULL)
    {
        TRACE_OUT(("Received flow control notification, new size %lu",
               newBufferSize));

        if (g_asSession.pShare->m_pHost != NULL)
        {
            //
            // First try and improve the LAN performance by sending orders in
            // large buffers, if we find that the throughput can handle it.
            //
            g_asSession.pShare->m_pHost->UP_FlowControl(newBufferSize);

            //
            // Adjust the depth which we try to spoil orders to based on
            // feedback.
            //
            g_asSession.pShare->m_pHost->OA_FlowControl(newBufferSize);
        }

        //
        // Tell DCS so that we can skip GDC compression.
        // This improves responsiveness over high bandwidth links because it
        // reduces the CPU loading on the sender
        //
        g_asSession.pShare->DCS_FlowControl(newBufferSize);
    }

    DebugExitVOID(S20Flow);
}

//
// FUNCTION: S20CreateMsg
//
// DESCRIPTION:
//
// Handles an incoming create message.
//
// PARAMETERS:
//
// pS20Packet - pointer to the create message itself
//
// RETURNS: NONE
//
void  S20CreateMsg
(
    PS20CREATEPACKET  pS20Packet
)
{
    BOOL    rc;

    DebugEntry(S20CreateMsg);

    TRACE_OUT(("S20_CREATE from [%d - %s], correlator %x",
        pS20Packet->header.user, (LPSTR)pS20Packet->data,
        pS20Packet->correlator));

    //
    // First of all check if the correlator on this CREATE is the same as
    // our current view of the correlator.  This may happen if a sweep
    // RESPOND overtakes a CREATE - in this case we will create the share
    // on the RESPOND and this is simply the delayed CREATE arriving now so
    // we don't need to do anything here.
    //
    if (g_s20ShareCorrelator == pS20Packet->correlator)
    {
        WARNING_OUT(("Received S20_CREATE from [%d] with bogus correlator %x",
            pS20Packet->header.user, pS20Packet->correlator));
        DC_QUIT;
    }

    if ((g_s20State == S20_NO_SHARE) ||
        ((g_s20State == S20_SHARE_PEND) &&
         (g_s20ShareCorrelator == 0)))
    {
        //
        // Either there is no share or we have issued a join.  In these
        // curcumstances we want to try to accept the create message.
        //

        //
        // Remember the share correlator.
        //
        g_s20ShareCorrelator = pS20Packet->correlator;

        //
        // Start the share
        // CHECK FOR FAILURE FOR THE FIRST ONE.
        //
        rc = SC_Start(g_s20LocalID);
        if (rc)
        {
            g_s20State = S20_SHARE_STARTING;
            TRACE_OUT(("g_s20State is S20_SHARE_STARTING"));

            rc = S20MaybeAddNewParty(pS20Packet->header.user,
                pS20Packet->lenCaps, pS20Packet->lenName,
                pS20Packet->data);
        }

        if (!rc)
        {
            //
            // Something went wrong.  Kill the share, this will clean up
            // everything.
            //
            SC_End();
        }
    }
    else if ((g_s20State == S20_SHARE_PEND) ||
             (g_s20State == S20_SHARE_STARTING) ||
             (g_s20State == S20_IN_SHARE))
    {
        //
        // Only current share creator should tell other dude there's an
        // error.
        //
        if (S20_GET_CREATOR(g_s20ShareCorrelator) == g_s20LocalID)
        {
            //
            // If we know about a share already then ignore this one.
            //
            WARNING_OUT(("Received S20_CREATE from [%d] with correlator %x, share colllision",
                pS20Packet->header.user, pS20Packet->correlator));

            S20FlushSendOrQueueControlPacket(S20_END,
                pS20Packet->correlator, 0, NET_TOP_PRIORITY);
            S20FlushSendOrQueueControlPacket(S20_COLLISION,
                pS20Packet->correlator, 0, NET_TOP_PRIORITY);
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(S20CreateMsg);
}

//
// FUNCTION: S20JoinMsg
//
// DESCRIPTION:
//
// Handles an incoming join message.
//
// PARAMETERS:
//
// pS20Packet - pointer to the join message itself
//
// RETURNS: NONE
//
void  S20JoinMsg
(
    PS20JOINPACKET  pS20Packet
)
{
    DebugEntry(S20JoinMsg);

    TRACE_OUT(("S20_JOIN from [%d - %s]",
        pS20Packet->header.user, (LPSTR)pS20Packet->data));

    switch (g_s20State)
    {
        case S20_SHARE_PEND:
            //
            // If we receive a join when a share is pending which we are
            // creating then we will try to add the party.  If it succeeds
            // then we will respond to the join as we would if we were in a
            // share (and we will indeed then be in a share).  If it fails
            // we will delete the joiner.
            //
            // If we receive a join when a share is pending because we are
            // trying to join (ie simultaneous joiners) then we can just
            // ignore it because a party which is joining a share will send
            // a respond as soon as they know the correlator for the share
            // they have succesfully joined.  This respond will be ignored
            // by any parties which saw and added the new party but it will
            // be seen by any simultaneous joiners and they will then get a
            // chance to try and add the other joiner.  If this fails they
            // will then do the normal processing for a failure handling a
            // respond message when we joined a share (ie delete
            // themselves).
            //
            // This will potentially mean that simultaneous joiners will
            // cause each other to delete themselves when there was room
            // for one of them in the share - we accept this.
            //

            //
            // Why is the share pending?  If the correlator is non-zero
            // then we are creating a share.
            //
            if (g_s20ShareCorrelator != 0)
            {
                //
                // We are creating a share - treat this like a respond.
                //
                if (!SC_Start(g_s20LocalID))
                {
                    WARNING_OUT(("S20Join: couldn't create share, clean up"));
                    SC_End();
                }
                else
                {
                    g_s20State = S20_SHARE_STARTING;
                    TRACE_OUT(("g_s20State is S20_SHARE_STARTING"));

                    S20MaybeAddNewParty(pS20Packet->header.user,
                        pS20Packet->lenCaps, pS20Packet->lenName,
                        pS20Packet->data);
                }
            }
            else
            {
                //
                // We are joining a share - simultaneous joiners.
                //
                TRACE_OUT(("Simultaneous joiner - ignored for now, expect a respond"));
            }
            break;

        case S20_IN_SHARE:
        case S20_SHARE_STARTING:
        {
            //
            // When we are in a share we will try and add this person then
            // give them a respond or a delete depending on what we did.
            //
            S20MaybeAddNewParty(pS20Packet->header.user,
                pS20Packet->lenCaps, pS20Packet->lenName,
                pS20Packet->data);
            break;
        }

        default:
            break;
    }

    DebugExitVOID(S20JoinMsg);
}


//
// FUNCTION: S20RespondMsg
//
// DESCRIPTION:
//
// Handles an incoming respond message.
//
// PARAMETERS:
//
// pS20Packet - pointer to the respond message itself
//
// RETURNS: NONE
//
void  S20RespondMsg
(
    PS20RESPONDPACKET  pS20Packet
)
{
    BOOL        rc;

    DebugEntry(S20RespondMsg);

    TRACE_OUT(("S20_RESPOND from [%d - %s], for [%d], correlator %x",
        pS20Packet->header.user, pS20Packet->data, pS20Packet->originator,
        pS20Packet->correlator));

    //
    // First filter the incoming respond messages as follows.
    //
    // If we know what share we are in and this does not have the same
    // correlator then respond with a delete and don't process any further.
    //
    // If the respond is not a response for us (ie we are not the
    // originator and it is not a sweep-up response (the originator equals
    // zero) then ignore it.
    //
    if ((g_s20ShareCorrelator != 0) &&
        (pS20Packet->correlator != g_s20ShareCorrelator))
    {
        //
        // Make sure sender knows we're not in this share.
        //
        TRACE_OUT(("S20_RESPOND from [%d] with unknown correlator %x",
            pS20Packet->header.user, pS20Packet->correlator));
        S20FlushSendOrQueueControlPacket(S20_LEAVE,
            pS20Packet->correlator, 0, NET_TOP_PRIORITY);
        DC_QUIT;
    }

    //
    // Now handle incoming message according to state.
    //
    switch (g_s20State)
    {
        case S20_SHARE_PEND:
            if ((pS20Packet->originator == g_s20LocalID) ||
                (pS20Packet->originator == 0))
            {
                //
                // A respond in share pending and it is for us.  First,
                // start a share.
                //
                rc = SC_Start(g_s20LocalID);
                if (!rc)
                {
                    SC_End();
                }
                else
                {
                    g_s20State = S20_SHARE_STARTING;
                    TRACE_OUT(("g_s20State is S20_SHARE_STARTING"));

                    //
                    // Why is the share pending?  If the correlator is non-zero
                    // then we are creating a share.
                    //
                    if (g_s20ShareCorrelator == 0)
                    {
                        //
                        // We are joining a share so do nothing if we fail (we
                        // will move back to NO_SHARE state if this happens).
                        //
                        g_s20ShareCorrelator = pS20Packet->correlator;
                    }

                    //
                    // Now try and add this new party.
                    //
                    rc = S20MaybeAddNewParty(pS20Packet->header.user,
                        pS20Packet->lenCaps, pS20Packet->lenName,
                        pS20Packet->data);

                    if (!rc)
                    {

                        //
                        // The responding party has been rejected by us.  What
                        // happens next depends on whether we are creating the
                        // share or not.
                        //
                        if (S20_GET_CREATOR(g_s20ShareCorrelator) != g_s20LocalID)
                        {
                            //
                            // We are not creating (ie we are joining) and we
                            // have failed to add a party so end the share
                            // (indicating that we are rejecting the remote
                            // party).
                            //
                            SC_End();
                        }

                        //
                        // If we were creating the share then there is nothing
                        // to do - just stay in SHARE_STARTING waiting for the
                        // next response.
                        //
                    }
                }
            }
            break;

        case S20_IN_SHARE:
        case S20_SHARE_STARTING:
            //
            // Who created this share.  If it was us then we want to
            // delete people we reject, otherwise we want to leave if we
            // reject people.
            //

            //
            // Now try and add this new party.  Of course it is entirely
            // possible that we've already added them at this stage - but
            // S20MaybeAddNewParty will just pretend to add them and return
            // if that's the case.
            //
            rc = S20MaybeAddNewParty(pS20Packet->header.user,
                pS20Packet->lenCaps, pS20Packet->lenName,
                pS20Packet->data);

            if (!rc)
            {
                WARNING_OUT(("Couldn't add [%d] to our share party list",
                    pS20Packet->header.user));
            }
            break;

        default:
            break;
    }

DC_EXIT_POINT:
    DebugExitVOID(S20RespondMsg);
}

//
// FUNCTION: S20DeleteMsg
//
// DESCRIPTION:
//
// Handles an incoming delete message.
//
// PARAMETERS:
//
// pS20Packet - pointer to the delete message itself
//
// RETURNS: NONE
//
void  S20DeleteMsg
(
    PS20DELETEPACKET  pS20Packet
)
{
    DebugEntry(S20DeleteMsg);

    TRACE_OUT(("S20_DELETE from [%d], for [%d], correlator %x",
        pS20Packet->header.user, pS20Packet->target, pS20Packet->correlator));

    //
    // ONLY SHARE CREATOR can delete people from share
    //

    if (!g_s20ShareCorrelator)
    {
        WARNING_OUT(("S20_DELETE, ignoring we're not in a share"));
        DC_QUIT;
    }

    if (pS20Packet->target != g_s20LocalID)
    {
        //
        // Not for us, ignore.
        //
        DC_QUIT;
    }

    if (g_s20ShareCorrelator != pS20Packet->correlator)
    {
        WARNING_OUT(("Received S20_DELETE from [%d] with unknown correlator %x",
            pS20Packet->header.user, pS20Packet->correlator));
        S20FlushSendOrQueueControlPacket(S20_LEAVE, pS20Packet->correlator,
            0, NET_TOP_PRIORITY);
        DC_QUIT;
    }

    if (S20_GET_CREATOR(g_s20ShareCorrelator) != pS20Packet->header.user)
    {
        WARNING_OUT(("Received S20_DELETE from [%d] who did not create share, ignore",
            pS20Packet->header.user));
        DC_QUIT;
    }

    //
    // Now handle incoming messages according to state.
    //
    switch (g_s20State)
    {
        case S20_SHARE_PEND:
        case S20_SHARE_STARTING:
            //
            // Just tell everyone else we're leaving and then issue a
            // SHARE_ENDED event.
            //
            TRACE_OUT(("CP LEAVE %lu %d", g_s20ShareCorrelator, 0));
            S20FlushSendOrQueueControlPacket(S20_LEAVE,
                                             g_s20ShareCorrelator,
                                             0,
                                             NET_TOP_PRIORITY);
            // FALL THROUGH

        case S20_IN_SHARE:
            SC_End();
            g_s20State = S20_NO_SHARE;
            TRACE_OUT(("g_s20State is S20_NO_SHARE"));
            break;

        default:
            break;
    }

DC_EXIT_POINT:
    DebugExitVOID(S20DeleteMsg);
}


//
// FUNCTION: S20LeaveMsg
//
// DESCRIPTION:
//
// Handles an incoming leave message.
//
// PARAMETERS:
//
// pS20Packet - pointer to the leave message itself
//
// RETURNS: NONE
//
void  S20LeaveMsg(PS20LEAVEPACKET  pS20Packet)
{
    DebugEntry(S20LeaveMsg);

    TRACE_OUT(("S20_LEAVE from [%d], correlator %x",
        pS20Packet->header.user, pS20Packet->correlator));

    if (!g_s20ShareCorrelator)
    {
        WARNING_OUT(("S20_LEAVE, ignoring we're not in a share"));
        DC_QUIT;
    }

    if (g_s20ShareCorrelator != pS20Packet->correlator)
    {
        WARNING_OUT(("Received S20_LEAVE from [%d] for unknown correlator %x",
            pS20Packet->header.user, pS20Packet->correlator));
        DC_QUIT;
    }

    switch (g_s20State)
    {
        case S20_IN_SHARE:
            //
            // We only need to handle this when we are in a share.
            //
            S20MaybeIssuePersonDelete(pS20Packet->header.user);
            break;

        default:
            break;
    }

DC_EXIT_POINT:
    DebugExitVOID(S20LeaveMsg);
}


//
// FUNCTION: S20EndMsg
//
// DESCRIPTION:
//
// Handles an incoming end message.
//
// PARAMETERS:
//
// pS20Packet - pointer to the end message itself
//
// RETURNS: NONE
//
void  S20EndMsg(PS20ENDPACKET  pS20Packet)
{
    DebugEntry(S20EndMsg);

    TRACE_OUT(("S20_END from [%d], correlator %x",
        pS20Packet->header.user, pS20Packet->correlator));

    if (!g_s20ShareCorrelator)
    {
        // We don't care
        WARNING_OUT(("S20_END ignored, not in share"));
        DC_QUIT;
    }

    if (g_s20ShareCorrelator != pS20Packet->correlator)
    {
        //
        // Just discard this.
        //
        WARNING_OUT(("Received S20_END from [%d] with unknown correlator %x",
            pS20Packet->header.user, pS20Packet->correlator));
        DC_QUIT;
    }

    //
    // Only the share creator can end the share.
    //
    if (S20_GET_CREATOR(g_s20ShareCorrelator) != pS20Packet->header.user)
    {
        WARNING_OUT(("Received S20_END from [%d] who did not create share, simply remove from user list.",
            pS20Packet->header.user));
        if (g_s20State == S20_IN_SHARE)
        {
            S20MaybeIssuePersonDelete(pS20Packet->header.user);
        }
        DC_QUIT;
    }

    switch (g_s20State)
    {
        case S20_IN_SHARE:
        case S20_SHARE_PEND:
        case S20_SHARE_STARTING:
            //
            // We just need to generate a share ended event.
            //
            SC_End();
            g_s20State = S20_NO_SHARE;
            TRACE_OUT(("g_s20State is S20_NO_SHARE"));
            break;

        default:
            break;
    }

DC_EXIT_POINT:
    DebugExitVOID(S20EndMsg);
}



//
// S20CollisionMsg()
//
// DESCRIPTION:
//
// Handles an incoming collision message.
//
// PARAMETERS:
//
// pS20Packet - pointer to the collision message itself
//
// RETURNS: NONE
//
void  S20CollisionMsg(PS20COLLISIONPACKET pS20Packet)
{
    DebugEntry(S20CollisionMsg);

    TRACE_OUT(("S20_COLLISION from [%d], correlator %x",
        pS20Packet->header.user, pS20Packet->correlator));

    if (!g_s20ShareCorrelator)
    {
        // We don't care
        WARNING_OUT(("S20_COLLISION ignored, not in share"));
        DC_QUIT;

    }

    if (g_s20ShareCorrelator != pS20Packet->correlator)
    {
        //
        // Just discard this.
        //
        WARNING_OUT(("Received S20_COLLISION from [%d] with unknown correlator %x",
            pS20Packet->header.user, pS20Packet->correlator));
        DC_QUIT;
    }

    //
    // If we created our own share, but got a collision from the remote,
    // then kill our share.
    //
    if (S20_GET_CREATOR(g_s20ShareCorrelator) != g_s20LocalID)
    {
        TRACE_OUT(("S20_COLLISION ignored, we didn't create share"));
        DC_QUIT;
    }

    switch (g_s20State)
    {
        case S20_IN_SHARE:
        case S20_SHARE_PEND:
        case S20_SHARE_STARTING:
            //
            // We just need to generate a share ended event.
            //
            SC_End();
            g_s20State = S20_NO_SHARE;
            TRACE_OUT(("g_s20State is S20_NO_SHARE"));
            break;

        default:
            break;
    }

DC_EXIT_POINT:
    DebugExitVOID(S20CollisionMsg);
}


//
// FUNCTION: S20DataMsg
//
// DESCRIPTION:
//
// Handles an incoming data message.
//
// PARAMETERS:
//
// pS20Packet - pointer to the data message itself
//
// RETURNS: TRUE - free the event, FALSE - do not free the event
//
void S20DataMsg(PS20DATAPACKET  pS20Packet)
{
    DebugEntry(S20DataMsg);

    ASSERT(!IsBadWritePtr(pS20Packet, sizeof(S20DATAPACKET)));
    ASSERT(!IsBadWritePtr(pS20Packet, sizeof(S20DATAPACKET) - sizeof(DATAPACKETHEADER) +
        pS20Packet->dataLength));

    //
    // Check if we're interseted in this data.
    //
    if ((pS20Packet->correlator == g_s20ShareCorrelator) &&
        (g_s20State == S20_IN_SHARE) &&
        g_asSession.pShare)
    {
        //
        // Return it.
        //
        g_asSession.pShare->SC_ReceivedPacket(pS20Packet);
    }

    DebugExitVOID(S20DataMsg);
}


//
// FUNCTION: S20MaybeAddNewParty
//
// DESCRIPTION:
//
// If the specified party has not already been added then try to add them
// now.
//
// PARAMETERS:
//
// userID     - the new party's network user ID.
// lenCaps    - the length of the new party's capabilities.
// lenName    - the length of the new party's name.
// pData      - a pointer to the new party's data which contains the name
//               followed by the capabilities data.
//
// RETURNS:
// BOOL for success
//
BOOL  S20MaybeAddNewParty
(
    MCSID   mcsID,
    UINT    lenCaps,
    UINT    lenName,
    LPBYTE  pData
)
{
    BOOL    rc = FALSE;
    UINT    oldState;
    LPBYTE  pCaps        = NULL;
    BOOL    memAllocated = FALSE;

    DebugEntry(S20MaybeAddNewParty);

    //
    // If we don't have a share, fail.
    //
    if (!g_asSession.pShare)
    {
        WARNING_OUT(("No ASShare; ignoring add party for [%d]", mcsID));
        DC_QUIT;
    }

    //
    // Check if this party has already been added.
    //
    if (g_asSession.pShare->SC_ValidateNetID(mcsID, NULL))
    {
        TRACE_OUT(("S20MaybeAddNewParty: already added %u", mcsID));
        rc = TRUE;
        DC_QUIT;
    }

    //
    // We need the caps structure to be 4-byte aligned.  It currently
    // follows a variable-length name string and may therefore not be
    // aligned.  If it is not aligned, we allocate an aligned buffer and
    // copy it there.
    //
    if (0 != (((UINT_PTR)pData + lenName) % 4))
    {
        TRACE_OUT(("Capabilities data is unaligned - realigning"));

        //
        // Get a 4-byte aligned buffer for the capabilities data.
        //
        pCaps = new BYTE[lenCaps];
        if (!pCaps)
        {
            ERROR_OUT(("Could not allocate %u bytes for aligned caps.",
                     lenCaps));
            DC_QUIT;
        }

        //
        // Flag so we know to free the memory later.
        //
        memAllocated = TRUE;

        //
        // Copy the caps data into our 4-byte aligned memory block.
        //
        memcpy(pCaps, (pData + lenName), lenCaps);
    }
    else
    {
        //
        // The capabilities data is already aligned so we don't need to
        // move it.
        //
        pCaps = pData + lenName;
    }

    //
    // Make sure we are in a share before we issue person add events.
    //
    oldState = g_s20State;
    g_s20State = S20_IN_SHARE;
    TRACE_OUT(("g_s20State is S20_IN_SHARE"));

    //
    // Attempt to add the new party.
    //
    rc = g_asSession.pShare->SC_PartyAdded(mcsID, (LPSTR)pData, lenCaps, pCaps);
    if (rc)
    {
        //
        // The new party has been accepted so send a response packet.  Do
        // this at ALL priorities, so it gets there before any type of data
        // at one particular priority.
        //
        TRACE_OUT(("CP RESPOND %lu %d", g_s20ShareCorrelator, 0));
        S20FlushSendOrQueueControlPacket(S20_RESPOND, g_s20ShareCorrelator,
                mcsID, NET_TOP_PRIORITY | NET_SEND_ALL_PRIORITIES);
    }
    else
    {
        g_asSession.pShare->SC_PartyDeleted(mcsID);

        //
        // Reset the state back to what it was if we failed.
        //
        g_s20State = oldState;
        TRACE_OUT(("g_s20State is %u", g_s20State));

        if (S20_GET_CREATOR(g_s20ShareCorrelator) == g_s20LocalID)
        {
             //
             // The new party has been rejected so send a delete packet.
             //
             TRACE_OUT(("CP DELETE %lu %u", g_s20ShareCorrelator, mcsID));
             S20FlushSendOrQueueControlPacket(S20_DELETE, g_s20ShareCorrelator,
                    mcsID, NET_TOP_PRIORITY);
        }
    }

DC_EXIT_POINT:
    //
    // Free memory used to store aligned caps.
    //
    if (memAllocated)
    {
        delete[] pCaps;
    }

    DebugExitBOOL(S20MaybeAddNewParty, rc);
    return(rc);
}


//
// FUNCTION: S20NewCorrelator
//
// DESCRIPTION:
//
// Returns a new correlator for us to use when we are creating a share.
// This is a combination of our mcsID (low 16 bits in Intel format) and
// a generation count (high 16 bits in Intel format).
//
// PARAMETERS: NONE
//
// RETURNS: the new correlator
//
//
UINT  S20NewCorrelator(void)
{
    UINT    correlator;

    DebugEntry(S20NewCorrelator);

    g_s20Generation++;

    correlator = g_s20LocalID | (((UINT)(g_s20Generation & 0xFFFF)) << 16);

    DebugExitDWORD(S20NewCorrelator, correlator);
    return(correlator);
}




//
// FUNCTION: S20MaybeIssuePersonDelete
//
// DESCRIPTION:
//
// If the supplied person is in the share then issue a PARTY_DELETED event
// for them.
//
// PARAMTERS:
//
// mcsID - a network personID
//
// reason - the reason code to use
//
// RETURNS: NONE
//
//
void  S20MaybeIssuePersonDelete(MCSID mcsID)
{
    DebugEntry(S20MaybeIssuePersonDelete);

    if (g_asSession.pShare)
    {
        g_asSession.pShare->SC_PartyDeleted(mcsID);
    }

    //
    // HET will kill the share if there aren't any hosts left.  So we
    // don't need to do anything here.
    //

    DebugExitVOID(S20MaybeIssuePersonDelete);
}

//
// FUNCTION: S20StreamToS20Priority
//
// DESCRIPTION:
//
// Converts a stream ID into a NET priority
//
// PARAMETERS:
//
// streamID - the stream ID.
//
// RETURNS: the priority
//
//
const NET_PRIORITY c_StreamS20Priority[NUM_PROT_STR - 1] =
{
    NET_LOW_PRIORITY,       // PROT_STR_UPDATES
    NET_MEDIUM_PRIORITY,    // PROT_STR_MISC
    NET_MEDIUM_PRIORITY,    // PROT_STR_UNUSED
    NET_MEDIUM_PRIORITY,    // PROT_STR_INPUT
};

NET_PRIORITY S20StreamToS20Priority(UINT  streamID)
{
    NET_PRIORITY priority;

    DebugEntry(S20StreamToS20Priority);

    ASSERT(streamID > PROT_STR_INVALID);
    ASSERT(streamID < NUM_PROT_STR);
    ASSERT(streamID != PROT_STR_UNUSED);

    priority = c_StreamS20Priority[streamID - 1];

    DebugExitDWORD(S20StreamToS20Priority, priority);
    return(priority);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\rbc.cpp ===
#include "precomp.h"


//
// RBC.CPP
// Received Bitmap Cache
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE



//
// RBC_ViewStarting()
//
// For 3.0 nodes, we create the cache each time they start hosting.
// For 2.x nodes, we create the cache once and use it until they leave the
//      share.
//
BOOL  ASShare::RBC_ViewStarting(ASPerson * pasPerson)
{
    BOOL                  rc = FALSE;

    DebugEntry(ASShare::RBC_ViewStarting);

    ValidatePerson(pasPerson);

    //
    // Allocate the INCOMING cache data for this host.
    //
    pasPerson->prbcHost = new RBC_HOST_INFO;
    if (!pasPerson->prbcHost)
    {
        ERROR_OUT(( "Failed to get memory for prbcHost info"));
        DC_QUIT;
    }
    ZeroMemory(pasPerson->prbcHost, sizeof(*(pasPerson->prbcHost)));
    SET_STAMP(pasPerson->prbcHost, RBCHOST);

    TRACE_OUT(( "Allocated RBC root for host [%d] at 0x%08x",
        pasPerson->mcsID, pasPerson->prbcHost));

    //
    // Create the bitmap caches for the sender
    //

    // SMALL
    if (!BMCAllocateCacheData(pasPerson->cpcCaps.bitmaps.sender.capsSmallCacheNumEntries,
            pasPerson->cpcCaps.bitmaps.sender.capsSmallCacheCellSize,
            ID_SMALL_BMP_CACHE,
            &(pasPerson->prbcHost->bitmapCache[ID_SMALL_BMP_CACHE])))
    {
        DC_QUIT;
    }

    // MEDIUM
    if (!BMCAllocateCacheData(pasPerson->cpcCaps.bitmaps.sender.capsMediumCacheNumEntries,
            pasPerson->cpcCaps.bitmaps.sender.capsMediumCacheCellSize,
            ID_MEDIUM_BMP_CACHE,
            &(pasPerson->prbcHost->bitmapCache[ID_MEDIUM_BMP_CACHE])))
    {
        DC_QUIT;
    }

    // LARGE
    if (!BMCAllocateCacheData(pasPerson->cpcCaps.bitmaps.sender.capsLargeCacheNumEntries,
            pasPerson->cpcCaps.bitmaps.sender.capsLargeCacheCellSize,
            ID_LARGE_BMP_CACHE,
            &(pasPerson->prbcHost->bitmapCache[ID_LARGE_BMP_CACHE])))
    {
        DC_QUIT;
    }

    //
    // The host can join the share.
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::RBC_ViewStarting, rc);
    return(rc);
}


//
// RBC_ViewEnded()
//
void  ASShare::RBC_ViewEnded(ASPerson * pasPerson)
{
    DebugEntry(ASShare::RBC_ViewEnded);

    ValidatePerson(pasPerson);

    RBCFreeIncoming(pasPerson);

    DebugExitVOID(ASShare::RBC_ViewEnded);
}


//
// RBC_PartyLeftShare()
// For 2.x nodes, frees the incoming RBC data
//
void ASShare::RBC_PartyLeftShare(ASPerson * pasPerson)
{
    DebugEntry(ASShare::RBC_PartyLeftShare);

    ValidatePerson(pasPerson);

    // This should be gone!
    ASSERT(pasPerson->prbcHost == NULL);

    DebugExitVOID(ASShare::RBC_PartyLeftShare);
}


//
// RBCFreeIncoming()
// Frees the party RBC incoming structures.  This happens
//      * For 3.0 nodes when they stop hosting
//      * For 2.x nodes when leave the share
//
void ASShare::RBCFreeIncoming(ASPerson * pasPerson)
{
    DebugEntry(ASShare::RBCFreeIncoming);

    //
    // Free this host's cache bitmaps.
    //
    if (pasPerson->prbcHost != NULL)
    {
        UINT  i;

        //
        // Delete all of this host's cache bitmaps.
        //
        for (i = 0; i < NUM_BMP_CACHES; i++)
        {
            BMCFreeCacheData(&(pasPerson->prbcHost->bitmapCache[i]));
        }

        delete pasPerson->prbcHost;
        pasPerson->prbcHost = NULL;
    }

    DebugExitVOID(ASShare::RBCFreeIncoming);
}


//
// RBC_ProcessCacheOrder(..)
//
void  ASShare::RBC_ProcessCacheOrder
(
    ASPerson *              pasPerson,
    LPCOM_ORDER_UA          pOrder
)
{
    PBMC_ORDER_HDR               pBmcOrderHdr;
    PBMC_COLOR_TABLE_ORDER_UA    pColorOrder;
    PBMC_BITMAP_BITS_ORDER_R2_UA pBitsOrderR2;
    BOOL                    fCompressed = FALSE;
    UINT                    cxFixedBitmapWidth;
    UINT                    iCacheEntry;
    LPBYTE                  pBitmapBits;
    UINT                    cbBitmapBits;

    DebugEntry(ASShare::RBC_ProcessCacheOrder);

    ValidatePerson(pasPerson);

    //
    // The rectangle is not included in the header for private order data
    // (see SBC_CopyPrivateOrderData) so we must take this into account
    // when working out the address of the order data.
    //
    pBmcOrderHdr = (PBMC_ORDER_HDR)
                   (pOrder->abOrderData - sizeof(pOrder->OrderHeader.rcsDst));

    switch (pBmcOrderHdr->bmcPacketType)
    {
        case BMC_PT_COLOR_TABLE:
            //
            // This is a new color table.  Simply cache the RGB values for
            // use when we come to process a memblt order
            // For backlevel calls the color table is always stored at
            // index 0 because the index field in the order reuses a
            // zero initialized "padding" field in the old structure.
            //
            TRACE_OUT(("Person [%d] Caching color table", pasPerson->mcsID));
            pColorOrder = (PBMC_COLOR_TABLE_ORDER_UA)pBmcOrderHdr;

            PM_CacheRxColorTable(pasPerson, pColorOrder->index,
                EXTRACT_TSHR_UINT16_UA(&(pColorOrder->colorTableSize)),
                                 (LPTSHR_RGBQUAD)&pColorOrder->data[0]);
            break;

        case BMC_PT_BITMAP_BITS_COMPRESSED:
            fCompressed = TRUE;
            TRACE_OUT(( "Compressed BMP"));
        case BMC_PT_BITMAP_BITS_UNCOMPRESSED:
            //
            // This is some cached bitmap data.  We have to store it in the
            // specified slot in the specified cache.
            //

            //
            // The width of the bitmaps we use are actually fixed as
            // multiples of 16 pels wide.  Work out the width that
            // corresponds to the sub-bitmap width of data we are caching.
            //
            pBitsOrderR2 = (PBMC_BITMAP_BITS_ORDER_R2_UA)pBmcOrderHdr;

            cbBitmapBits = EXTRACT_TSHR_UINT16_UA(
                                        &(pBitsOrderR2->header.cbBitmapBits));

            cxFixedBitmapWidth =
                          ((pBitsOrderR2->header.cxSubBitmapWidth +15)/16)*16;

            //
            // The location of cache entry field depends on the R1/R2
            // protocol
            //
            iCacheEntry = EXTRACT_TSHR_UINT16_UA(&(pBitsOrderR2->iCacheEntryR2));
            pBitmapBits = pBitsOrderR2->data;

            TRACE_OUT(("Person [%d] Rx bmp: id(%d) entry(%d) size(%dx%d) " \
                        "fixed(%d) bpp(%d) bytes(%d) compressed(%d)",
                    pasPerson->mcsID,
                    pBitsOrderR2->header.cacheID,
                    iCacheEntry,
                    pBitsOrderR2->header.cxSubBitmapWidth,
                    pBitsOrderR2->header.cySubBitmapHeight,
                    cxFixedBitmapWidth,
                    pBitsOrderR2->header.bpp,
                    cbBitmapBits,
                    fCompressed));

            //
            // Pass the BMC data to the caching code.  When calculating the
            // pointer to the bitmap bits remember that we did not send the
            // pBitmapBits field of the BMC_BITMAP_BITS_ORDER_Rx structure
            // (see SBC_CopyPrivateOrderData).
            //
            RBCStoreBitsInCacheBitmap(pasPerson,
                             pBitsOrderR2->header.cacheID,
                             iCacheEntry,
                             pBitsOrderR2->header.cxSubBitmapWidth,
                             cxFixedBitmapWidth,
                             pBitsOrderR2->header.cySubBitmapHeight,
                             pBitsOrderR2->header.bpp,
                             pBitmapBits,
                             cbBitmapBits,
                             fCompressed);
            break;

        default:
            ERROR_OUT(( "[%u]Invalid packet type(%d)",
                       pasPerson,
                       (UINT)pBmcOrderHdr->bmcPacketType));
            break;
    }

    DebugExitVOID(ASShare::RBC_ProcessCacheOrder);
}


//
// RBC_MapCacheIDToBitmapHandle(..)
//
HBITMAP  ASShare::RBC_MapCacheIDToBitmapHandle
(
    ASPerson *          pasPerson,
    UINT                cache,
    UINT                cacheEntry,
    UINT                colorIndex
)
{
    PBMC_DIB_CACHE      pDIBCache;
    PBMC_DIB_ENTRY      pDIBEntry;
    BITMAPINFO_ours     bitmapInfo;
    UINT                cColors;
    HBITMAP             hWorkBitmap = NULL;
    HPALETTE            hpalOldDIB = NULL;
    LPBYTE              pBits;
    UINT                cacheOffset;

    DebugEntry(ASShare::RBC_MapCacheIDToBitmapHandle);

    ValidateView(pasPerson);

    //
    // Check that the supplied cache ID is valid.
    //
    if (cache >= NUM_BMP_CACHES)
    {
        ERROR_OUT(( "[%u]Invalid cache ID (%d)", pasPerson, cache));
        cache = 0;
    }

    //
    // Get a pointer to the bitmap data
    //
    // Note that there are two indexes floating around.  From the host's
    // perspective this index is a Cache Handler token and it must be
    // translated in order to address the associated data.  However we
    // use it as the direct index into our receive cache and so the
    // slots used on host and remote will be diferent.
    //
    // There is no reason why the slots should be the same.  This is just
    // to warn you that if you try correlating cache offsets between
    // host and remote you will get confused as soon as the cache fills
    // up and entries are reallocated in different positions.
    //
    //
    pDIBCache = &(pasPerson->prbcHost->bitmapCache[cache]);
    TRACE_OUT(( "Local person [%d] cache id %d pointer %lx",
        pasPerson->mcsID, cache, pDIBCache));
    cacheOffset = cacheEntry * pDIBCache->cSize;
    pDIBEntry = (PBMC_DIB_ENTRY)(pDIBCache->data + cacheOffset);

    TRACE_OUT(( "Bits for index %u are at offset %ld, pointer 0x%08x",
        cacheEntry, (cacheEntry * pDIBCache->cSize), pDIBEntry));

    //
    // Set up the BitmapInfo structure.
    //
    USR_InitDIBitmapHeader((BITMAPINFOHEADER *)&bitmapInfo, pDIBEntry->bpp);
    bitmapInfo.bmiHeader.biWidth  = pDIBEntry->cxFixed;
    bitmapInfo.bmiHeader.biHeight = pDIBEntry->cy;

    //
    // Copy the Rx color table into the bitmap header.
    //
    if ( (pDIBEntry->bpp == 1) ||
         (pDIBEntry->bpp == 4) ||
         (pDIBEntry->bpp == 8) )
    {
        cColors = COLORS_FOR_BPP(pDIBEntry->bpp);

        PM_GetColorTable( pasPerson,
                          colorIndex,
                          &cColors,
                          (LPTSHR_RGBQUAD)(&bitmapInfo.bmiColors) );
        TRACE_OUT(( "Got %u colors from table",cColors));
        bitmapInfo.bmiHeader.biClrUsed = cColors;
    }
    else if (pDIBEntry->bpp == 24)
    {
        ASSERT(colorIndex == COLORCACHEINDEX_NONE);
    }
    else
    {
        ERROR_OUT(("RBC: Unexpected bpp %d from [%d]", pDIBEntry->bpp, pasPerson->mcsID));
        DC_QUIT;
    }

    //
    // Select which fixed width bitmap we are going to use to store the
    // incoming DIB bits.
    //
    switch (pDIBEntry->cxFixed)
    {
        case 16:
            hWorkBitmap = m_usrBmp16;
            break;

        case 32:
            hWorkBitmap = m_usrBmp32;
            break;

        case 48:
            hWorkBitmap = m_usrBmp48;
            break;

        case 64:
            hWorkBitmap = m_usrBmp64;
            break;

        case 80:
            hWorkBitmap = m_usrBmp80;
            break;

        case 96:
            hWorkBitmap = m_usrBmp96;
            break;

        case 112:
            hWorkBitmap = m_usrBmp112;
            break;

        case 128:
            hWorkBitmap = m_usrBmp128;
            break;

        case 256:
            hWorkBitmap = m_usrBmp256;
            break;

        default:
            ERROR_OUT(("RBC_MapCacheIDToBitmapHandle: invalid size from [%d]",
                pDIBEntry->cxFixed, pasPerson->mcsID));
            hWorkBitmap = m_usrBmp256;
            break;
    }

    ASSERT(hWorkBitmap != NULL);


    //
    // If the cached bitmap bits are compressed, we first have to
    // decompress them.
    //
    if (pDIBEntry->bCompressed)
    {
        ASSERT(pDIBEntry->bpp <= 8);

        //
        // Use the decompression buffer to decompress the bitmap data.
        //
        if (!BD_DecompressBitmap(pDIBEntry->bits, m_usrPBitmapBuffer,
                                 pDIBEntry->cCompressed,
                                 pDIBEntry->cxFixed,
                                 pDIBEntry->cy,
                                 pDIBEntry->bpp))
        {
             ERROR_OUT((
                      "Failed to decompress bitmap pBits(%lx)"
                      " pBuf(%lx) cb(%x) cx(%d) cy(%d) bpp(%d)",
                      pDIBEntry->bits,
                      m_usrPBitmapBuffer,
                      pDIBEntry->cCompressed,
                      pDIBEntry->cxFixed,
                      pDIBEntry->cy,
                      pDIBEntry->bpp));
             DC_QUIT;
        }

        pBits = m_usrPBitmapBuffer;
    }
    else
    {
        //
        // For uncompressed data just use direct from the cache
        //
        TRACE_OUT(( "Bitmap bits are uncompressed"));
        pBits = pDIBEntry->bits;
    }


    //
    // Set the bits into the bitmap we are about to return to the caller
    //
    hpalOldDIB = SelectPalette(pasPerson->m_pView->m_usrWorkDC,
        pasPerson->pmPalette, FALSE);
    RealizePalette(pasPerson->m_pView->m_usrWorkDC);

    if (!SetDIBits(pasPerson->m_pView->m_usrWorkDC,
                      hWorkBitmap,
                      0,
                      pDIBEntry->cy,
                      pBits,
                      (BITMAPINFO *)&bitmapInfo,
                      DIB_RGB_COLORS))
    {
        ERROR_OUT(("SetDIBits failed in RBC_MapCacheIDToBitmapHandle"));
    }

    SelectPalette(pasPerson->m_pView->m_usrWorkDC, hpalOldDIB, FALSE );

    TRACE_OUT(( "Returning bitmap for person [%d] cache %u index %u color %u",
        pasPerson->mcsID, cache, cacheEntry, colorIndex));


DC_EXIT_POINT:
    DebugExitVOID(ASShare::RBC_MapCacheIDToBitmapHandle);
    return(hWorkBitmap);
}






//
// FUNCTION: RBCStoreBitsInCacheBitmap(..)
//
// DESCRIPTION:
//
// Stores received bitmap bits into one of the receiver's cache bitmaps.
//
// PARAMETERS:
//
// pasPerson - pasPerson of host the bits came from.
//
// cache - the id of the cache bitmap to store the bits in.
//
// iCacheEntry - the cache entry number (index).
//
// cxSubBitmapWidth - the width in pels of the actual sub-bitmap (ie.
// excluding padding)
//
// cxFixedWidth - the fixed width in pels of the supplied bits (ie.
// including padding)
//
// cySubBitmapHeight - the height in pels of the sub-bitmap.
//
// pBitmapBits - a pointer to the actual bitmap bits. These may or may
// not be compressed (determined by the value of the fCompressed
// flag).
//
// cbBitmapBits - the size of the bitmap bits pointed to by pBitmapBits.
//
// fCompressed - a flag specifying whether the supplied bitmap
// bits are compressed.
//
// RETURNS:
//
// Nothing.
//
//
void  ASShare::RBCStoreBitsInCacheBitmap
(
    ASPerson *          pasPerson,
    UINT                cache,
    UINT                iCacheEntry,
    UINT                cxSubBitmapWidth,
    UINT                cxFixedWidth,
    UINT                cySubBitmapHeight,
    UINT                bpp,
    LPBYTE              pBitmapBits,
    UINT                cbBitmapBits,
    BOOL                fCompressed
)
{
    PBMC_DIB_ENTRY      pDIBEntry;

    DebugEntry(ASShare::RBCStoreBitsInCacheBitmap);

    ValidatePerson(pasPerson);

    //
    // Do some error checking.
    //
    if (cache >= NUM_BMP_CACHES)
    {
        ERROR_OUT(("Invalid cache ID %d from [%d]", cache, pasPerson->mcsID));
        DC_QUIT;
    }

    //
    // Now store the bits in the cache
    // The cache is a huge chunk of memory comprising cache slots of cSize
    // bytes each.  cSize is rounded to a power of 2 to ensure the array
    // spans segment boundaries cleanly for segmented architecture OSs.
    //
    pDIBEntry = (PBMC_DIB_ENTRY)
        (((LPBYTE)(pasPerson->prbcHost->bitmapCache[cache].data) +
         (iCacheEntry * pasPerson->prbcHost->bitmapCache[cache].cSize)));
    TRACE_OUT(( "Selected cache entry 0x%08x",pDIBEntry));

    pDIBEntry->inUse       = TRUE;
    pDIBEntry->cx          = (TSHR_UINT16)cxSubBitmapWidth;
    pDIBEntry->cxFixed     = (TSHR_UINT16)cxFixedWidth;
    pDIBEntry->cy          = (TSHR_UINT16)cySubBitmapHeight;
    pDIBEntry->bpp         = (TSHR_UINT16)bpp;
    pDIBEntry->bCompressed = (fCompressed != FALSE);
    pDIBEntry->cCompressed = cbBitmapBits;

    //
    // Now copy the bits into the cache entry
    //
    memcpy(pDIBEntry->bits, pBitmapBits, cbBitmapBits);

    //
    // THIS FIELD IS NEVER ACCESSED.
    //
    pDIBEntry->cBits = BYTES_IN_BITMAP(cxFixedWidth, cySubBitmapHeight,
        pDIBEntry->bpp);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::RBCStoreBitsInCacheBitmap);
}




//
// BMCAllocateCacheData()
//
// DESCRIPTION:
//
// Allocates memory for a bitmap cache
//
// PARAMETERS:
//
// cellSize
//
// RETURNS:
//
// Area needed
//
//
BOOL  BMCAllocateCacheData
(
    UINT            numEntries,
    UINT            cellSize,
    UINT            cacheID,
    PBMC_DIB_CACHE  pCache
)
{
    BOOL            rc = TRUE;
    UINT            memoryNeeded;
    UINT            workSize;
    PBMC_DIB_ENTRY  pCacheEntry;
    UINT            i;

    DebugEntry(BMCAllocateCacheData);

    //
    // First we must free up any data, if it has been allocated
    //
    BMCFreeCacheData(pCache);

    //
    // For 2.x compat, we have SEND caps of 1 entry, 1 byte since 2.x
    // remotes fail for zero entries.  But we don't want a small cache
    // at all, and for W95 nodes that don't have a cache at all, we don't
    // want viewers to alloc memory which will never be used.
    //
    if ((cellSize > 1) && (numEntries > 1))
    {
        //
        // Calculate the cell area
        //
        workSize        = cellSize + sizeof(BMC_DIB_ENTRY) - 1;
        memoryNeeded    = numEntries * workSize;

        TRACE_OUT(("Need 0x%08x bytes for cache %d, %d cells of size 0x%08x",
            memoryNeeded, cacheID, numEntries, cellSize));

        //
        // Malloc the huge space
        //
        pCache->data = new BYTE[memoryNeeded];
        if (pCache->data == NULL)
        {
            ERROR_OUT(( "Failed to alloc bitmap cache %d", cacheID));
            rc = FALSE;
            DC_QUIT;
        }

        pCache->cCellSize   = cellSize;
        pCache->cEntries    = numEntries;
        pCache->cSize       = workSize;
        pCache->freeEntry   = NULL;
        pCacheEntry         = (PBMC_DIB_ENTRY)(pCache->data);

        for (i = 0; i < numEntries; i++)
        {
            pCacheEntry->inUse = FALSE;
            pCacheEntry = (PBMC_DIB_ENTRY)(((LPBYTE)pCacheEntry) + workSize);
        }

        TRACE_OUT(( "Allocated cache %d size %d, pointer 0x%08x stored at 0x%08x",
                     cacheID,
                     memoryNeeded,
                     pCache->data,
                     &pCache->data));
    }

DC_EXIT_POINT:
    DebugExitBOOL(BMCAllocateCacheData, rc);
    return(rc);
}



//
// FUNCTION: BMCFreeCacheData()
//
// DESCRIPTION:
//
// Deletes selected cache's memory
//
// PARAMETERS:
//
// cacheID - id of cache for free
// pCache  - pointer to memory to be freed
//
//
// RETURNS:
//
// Nothing.
//
//
void  BMCFreeCacheData(PBMC_DIB_CACHE pCache)
{
    DebugEntry(BMCFreeCacheData);

    if (pCache->data)
    {
        delete[] pCache->data;
        pCache->data = NULL;
    }

    pCache->cCellSize   = 0;
    pCache->cEntries    = 0;

    DebugExitVOID(BMCFreeCacheData);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\sc.cpp ===
#include "precomp.h"


//
// SC.CPP
// Share Controller
//
// NOTE:
// We must take the UTLOCK_AS every time we
//      * create/destroy the share object
//      * add/remove a person from the share
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE

//
// SC_Init()
// Initializes the share controller
//
BOOL  SC_Init(void)
{
    BOOL            rc = FALSE;

    DebugEntry(SC_Init);

    ASSERT(!g_asSession.callID);
    ASSERT(!g_asSession.gccID);
    ASSERT(g_asSession.scState == SCS_TERM);

    //
    // Register as a Call Manager Secondary task
    //
    if (!CMS_Register(g_putAS, CMTASK_DCS, &g_pcmClientSc))
    {
        ERROR_OUT(( "Failed to register with CMS"));
        DC_QUIT;
    }

    g_asSession.scState = SCS_INIT;
    TRACE_OUT(("g_asSession.scState is SCS_INIT"));

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SC_Init, rc);
    return(rc);
}


//
// SC_Term()
//
// See sc.h for description.
//
//
void  SC_Term(void)
{
    DebugEntry(SC_Term);

    //
    // Clear up the core's state by generating appropriate PARTY_DELETED and
    // SHARE_ENDED events.
    //
    switch (g_asSession.scState)
    {
        case SCS_SHARING:
        case SCS_SHAREENDING:
        case SCS_SHAREPENDING:
            SC_End();
            break;
    }

    //
    // Deregister from the Call Manager
    //
    if (g_pcmClientSc)
    {
        CMS_Deregister(&g_pcmClientSc);
    }

    g_asSession.gccID = 0;
    g_asSession.callID = 0;

    g_asSession.scState = SCS_TERM;
    TRACE_OUT(("g_asSession.scState is SCS_TERM"));

    DebugExitVOID(SC_Term);
}





//
// SC_CreateShare()
// Creates a new share or joins an existing one
//
BOOL SC_CreateShare(UINT s20CreateOrJoin)
{
    BOOL    rc = FALSE;

    DebugEntry(SC_CreateShare);

    //
    // If we are initialised but there is no Call Manager call, return the
    // race condition.
    //
    if ((g_asSession.scState != SCS_INIT) && (g_asSession.scState != SCS_SHAREPENDING))
    {
        TRACE_OUT(("Ignoring SC_CreateShare() request; in bad state %d",
            g_asSession.scState));
        DC_QUIT;
    }

    if (!g_asSession.callID)
    {
        WARNING_OUT(("Ignoring SC_CreateShare() request; not in T120 call"));
        DC_QUIT;
    }

    //
    // Remember that we created this share.
    //
    g_asSession.fShareCreator = (s20CreateOrJoin == S20_CREATE);
    TRACE_OUT(("CreatedShare is %s", (s20CreateOrJoin == S20_CREATE) ?
        "TRUE" : "FALSE"));

    g_asSession.scState               = SCS_SHAREPENDING;
    TRACE_OUT(("g_asSession.scState is SCS_SHAREPENDING"));

    rc = S20CreateOrJoinShare(s20CreateOrJoin, g_asSession.callID);
    if (!rc)
    {
        WARNING_OUT(("%s failed", (s20CreateOrJoin == S20_CREATE ? "S20_CREATE" : "S20_JOIN")));
    }

DC_EXIT_POINT:
    DebugExitBOOL(SC_CreateShare, rc);
    return(rc);
}


//
// SC_EndShare()
// This will end a share if we are in one or in the middle of establishing
// one, and clean up afterwards.
//
void  SC_EndShare(void)
{
    DebugEntry(SC_EndShare);

    if (g_asSession.scState <= SCS_SHAREENDING)
    {
        TRACE_OUT(("Ignoring SC_EndShare(); nothing to do in state %d", g_asSession.scState));
    }
    else
    {
        //
        // If we are in a share or in the middle of creating/joining one, stop
        // the process.
        //

        //
        // Kill the share
        // NOTE that this will call SC_End(), when we come back
        // from this function our g_asSession.scState() should be SCS_INIT.
        //
        g_asSession.scState = SCS_SHAREENDING;
        TRACE_OUT(("g_asSession.scState is SCS_SHAREENDING"));

        S20LeaveOrEndShare();

        g_asSession.scState = SCS_INIT;
    }

    DebugExitVOID(SC_EndShare);
}






//
// SC_PersonFromNetID()
//
ASPerson *  ASShare::SC_PersonFromNetID(MCSID mcsID)
{
    ASPerson * pasPerson;

    DebugEntry(SC_PersonFromNetID);

    ASSERT(mcsID != MCSID_NULL);

    //
    // Search for the mcsID.
    //
    if (!SC_ValidateNetID(mcsID, &pasPerson))
    {
        ERROR_OUT(("Invalid [%u]", mcsID));
    }

    DebugExitPVOID(ASShare::SC_PersonFromNetID, pasPerson);
    return(pasPerson);
}



//
// SC_ValidateNetID()
//
BOOL  ASShare::SC_ValidateNetID
(
    MCSID           mcsID,
    ASPerson * *    ppasPerson
)
{
    BOOL            rc = FALSE;
    ASPerson *      pasPerson;

    DebugEntry(ASShare::SC_ValidateNetID);


    // Init to empty
    pasPerson = NULL;

    //
    // MCSID_NULL matches no one.
    //
    if (mcsID == MCSID_NULL)
    {
        WARNING_OUT(("SC_ValidateNetID called with MCSID_NULL"));
        DC_QUIT;
    }

    //
    // Search for the mcsID.
    //
    for (pasPerson = m_pasLocal; pasPerson != NULL; pasPerson = pasPerson->pasNext)
    {
        ValidatePerson(pasPerson);

        if (pasPerson->mcsID == mcsID)
        {
            //
            // Found required person, set return values and quit
            //
            rc = TRUE;
            break;
        }
    }

DC_EXIT_POINT:
    if (ppasPerson)
    {
        *ppasPerson = pasPerson;
    }

    DebugExitBOOL(ASShare::SC_ValidateNetID, rc);
    return(rc);
}



//
// SC_PersonFromGccID()
//
ASPerson * ASShare::SC_PersonFromGccID(UINT gccID)
{
    ASPerson * pasPerson;

    DebugEntry(ASShare::SC_PersonFromGccID);

    for (pasPerson = m_pasLocal; pasPerson != NULL; pasPerson = pasPerson->pasNext)
    {
        ValidatePerson(pasPerson);

        if (pasPerson->cpcCaps.share.gccID == gccID)
        {
            // Found it
            break;
        }
    }

    DebugExitPVOID(ASShare::SC_PersonFromGccID, pasPerson);
    return(pasPerson);
}


//
// SC_Start()
// Inits the share (if all is OK), and adds local person to it.
//
BOOL SC_Start(UINT mcsID)
{
    BOOL        rc = FALSE;
    ASShare *   pShare;
    ASPerson *  pasPerson;

    DebugEntry(SC_Start);

    ASSERT(g_asSession.callID);
    ASSERT(g_asSession.gccID);

    if ((g_asSession.scState != SCS_INIT) && (g_asSession.scState != SCS_SHAREPENDING))
    {
        WARNING_OUT(("Ignoring SC_Start(); in bad state"));
        DC_QUIT;
    }
    if (g_asSession.pShare)
    {
        WARNING_OUT(("Ignoring SC_Start(); have ASShare object already"));
        DC_QUIT;
    }

    g_asSession.scState = SCS_SHARING;
    TRACE_OUT(("g_asSession.scState is SCS_SHARING"));

#ifdef _DEBUG
    //
    // Use this to calculate time between joining share and getting
    // first view
    //
    g_asSession.scShareTime = ::GetTickCount();
#endif // _DEBUG

    //
    // Allocate the share object and add the local dude to the share.
    //

    pShare = new ASShare;
    if (pShare)
    {
        ZeroMemory(pShare, sizeof(*(pShare)));
        SET_STAMP(pShare, SHARE);

        rc = pShare->SC_ShareStarting();
    }

    UT_Lock(UTLOCK_AS);
    g_asSession.pShare = pShare;
    UT_Unlock(UTLOCK_AS);

    if (!rc)
    {
        ERROR_OUT(("Can't create/init ASShare"));
        DC_QUIT;
    }

    DCS_NotifyUI(SH_EVT_SHARE_STARTED, 0, 0);


    //
    // Join local dude into share. If that fails, also bail out.
    //
    pasPerson = g_asSession.pShare->SC_PartyJoiningShare(mcsID, g_asSession.achLocalName, sizeof(g_cpcLocalCaps), &g_cpcLocalCaps);
    if (!pasPerson)
    {
        ERROR_OUT(("Local person not joined into share successfully"));
        DC_QUIT;
    }

    //
    // Okay!  We have a share, and it's set up.
    //

    //
    // Tell the UI that we're in the share.
    //
    DCS_NotifyUI(SH_EVT_PERSON_JOINED, pasPerson->cpcCaps.share.gccID, 0);


    //
    // Start periodic processing if ViewSelf or record/playback is on.
    //
    if (g_asSession.pShare->m_scfViewSelf)
    {
        SCH_ContinueScheduling(SCH_MODE_NORMAL);
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SC_Start, rc);
    return(rc);
}



//
// SC_End()
// Removes any remotes from the share, removes the local person, and
// cleans up after the fact.
//
void SC_End(void)
{
    DebugEntry(SC_End);

    if (g_asSession.scState < SCS_SHAREENDING)
    {
        TRACE_OUT(("Ignoring SC_EVENT_SHAREENDED"));
    }
    else
    {
        if (g_asSession.pShare)
        {
            g_asSession.pShare->SC_ShareEnded();

            UT_Lock(UTLOCK_AS);

            delete g_asSession.pShare;
            g_asSession.pShare = NULL;

            UT_Unlock(UTLOCK_AS);

            DCS_NotifyUI(SH_EVT_SHARE_ENDED, 0, 0);
        }

        //
        // If the previous state was SCS_SHARE_PENDING then we
        // may have ended up here as the result of a 'back off' after
        // trying to create two shares.  Let's try to join again...
        //
        if (g_asSession.fShareCreator)
        {
            g_asSession.fShareCreator = FALSE;
            TRACE_OUT(("CreatedShare is FALSE"));

            if (g_asSession.scState == SCS_SHAREPENDING)
            {
                WARNING_OUT(("Got share end while share pending - retry join"));
                UT_PostEvent(g_putAS, g_putAS, 0, CMS_NEW_CALL, 0, 0);
            }
        }

        g_asSession.scState = SCS_INIT;
        TRACE_OUT(("g_asSession.scState is SCS_INIT"));
    }

    g_s20ShareCorrelator = 0;

    //
    // Reset the queued control packets.
    //
    g_s20ControlPacketQHead = 0;
    g_s20ControlPacketQTail = 0;

    g_s20State = S20_NO_SHARE;
    TRACE_OUT(("g_s20State is S20_NO_SHARE"));

    DebugExitVOID(SC_End);
}


//
// SC_PartyAdded()
//
BOOL ASShare::SC_PartyAdded
(
    UINT    mcsID,
    LPSTR   szName,
    UINT    cbCaps,
    LPVOID  pCaps
)
{
    BOOL        rc = FALSE;
    ASPerson *  pasPerson;

    if (g_asSession.scState != SCS_SHARING)
    {
        WARNING_OUT(("Ignoring SC_EVENT_PARTYADDED; not in share"));
        DC_QUIT;
    }

    ASSERT(g_asSession.callID);
    ASSERT(g_asSession.gccID);

    //
    // A remote party is joining the share
    //

    //
    // Notify everybody
    //
    pasPerson = SC_PartyJoiningShare(mcsID, szName, cbCaps, pCaps);
    if (!pasPerson)
    {
        WARNING_OUT(("SC_PartyJoiningShare failed for remote [%d]", mcsID));
        DC_QUIT;
    }

    //
    // SYNC now
    // We should NEVER SEND ANY PACKETS when syncing.  We aren't ready
    // because we haven't joined the person into the share. yet.
    // So we simply set variables for us to send data off the next
    // periodic schedule.
    //
#ifdef _DEBUG
    m_scfInSync = TRUE;
#endif // _DEBUG

    //
    // Stuff needed for being in the share, hosting or not
    //
    DCS_SyncOutgoing();
    OE_SyncOutgoing();

    if (m_pHost != NULL)
    {
        //
        // Common to both starting sharing and retransmitting sharing info
        //
        m_pHost->HET_SyncCommon();
        m_pHost->HET_SyncAlreadyHosting();
        m_pHost->CA_SyncAlreadyHosting();
    }

#ifdef _DEBUG
    m_scfInSync = FALSE;
#endif // _DEBUG


    //
    // DO THIS LAST -- tell the UI this person is in the share.
    //
    DCS_NotifyUI(SH_EVT_PERSON_JOINED, pasPerson->cpcCaps.share.gccID, 0);

    //
    // Start periodic processing
    //
    SCH_ContinueScheduling(SCH_MODE_NORMAL);

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::SC_PartyAdded, rc);
    return(rc);
}



//
// SC_PartyDeleted()
//
void ASShare::SC_PartyDeleted(UINT mcsID)
{
    if ((g_asSession.scState != SCS_SHARING) && (g_asSession.scState != SCS_SHAREENDING))
    {
        WARNING_OUT(("Ignoring SC_EVENT_PARTYDELETED; wrong state"));
        DC_QUIT;
    }

    SC_PartyLeftShare(mcsID);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::SC_PartyDeleted);
}


//
// SC_ReceivedPacket()
//
void ASShare::SC_ReceivedPacket(PS20DATAPACKET pPacket)
{
    ASPerson *      pasPerson;
    PSNIPACKET      pSNIPacket;

    DebugEntry(ASShare::SC_ReceivedPacket);

    if (g_asSession.scState != SCS_SHARING)
    {
        WARNING_OUT(("Ignoring received data because we're not in right state"));
        DC_QUIT;
    }

    //
    // Ignore packets on streams we don't know about.
    //
    if ((pPacket->stream < SC_STREAM_LOW) ||
        (pPacket->stream > SC_STREAM_HIGH))
    {
        TRACE_OUT(("Ignoring received data on unrecognized stream %d",
            pPacket->stream));
        DC_QUIT;
    }

    //
    // It is possible to get a packet from a person we do not know
    // about.
    //
    // This can happen if we join a conference that has an existing
    // share session.  All existing parties will be sending data on
    // the channels we have joined but we will not yet have
    // received the events to add them to our share session.
    //
    // Data packets from unknown people are ignored (ignoring this
    // data is OK as we will resync with them when they are added
    // to our share session)
    //
    if (!SC_ValidateNetID(pPacket->header.user, &pasPerson))
    {
        WARNING_OUT(("Ignoring data packet from unknown person [%d]",
            pPacket->header.user));
        DC_QUIT;
    }

    if (pPacket->data.dataType == DT_SNI)
    {
        //
        // This is an SNI packet - handle it here.
        //
        pSNIPacket = (PSNIPACKET)pPacket;

        switch(pSNIPacket->message)
        {
            case SNI_MSG_SYNC:
                //
                // This is a sync message.
                //
                if (pSNIPacket->destination == m_pasLocal->mcsID)
                {
                    //
                    // This sync message is for us.
                    //
                    pasPerson->scSyncRecStatus[pPacket->stream-1] = SC_SYNCED;
                }
                else
                {
                    TRACE_OUT(("Ignoring SYNC on stream %d for [%d] from [%d]",
                            pPacket->stream, pSNIPacket->destination,
                            pPacket->header.user));
                }
                break;

            default:
                ERROR_OUT(("Unknown SNI message %u", pSNIPacket->message));
                break;
        }
    }
    else if (pasPerson->scSyncRecStatus[pPacket->stream-1] == SC_SYNCED)
    {
        PS20DATAPACKET  pPacketUse;
        UINT            cbBufferSize;
        UINT            compression;
        BOOL            decompressed;
        UINT            dictionary;

        //
        // Decompress the packet if necessary
        //

        //
        // Use the temporary buffer.  This will never fail, so we don't
        // need to check the return value.  THIS MEANS THAT THE HANDLING OF
        // INCOMING PACKETS CAN NEVER IMMEDIATELY TURN AROUND AND SEND AN
        // OUTGOING PACKET.  Our scratch buffer is in use.
        //
        pPacketUse = (PS20DATAPACKET)m_ascTmpBuffer;

        TRACE_OUT(( "Got data pkt type %u from [%d], compression %u",
            pPacket->data.dataType, pasPerson->mcsID,
            pPacket->data.compressionType));

        //
        // If the packet has CT_OLD_COMPRESSED set, it has used simple PKZIP
        // compression
        //
        if (pPacket->data.compressionType & CT_OLD_COMPRESSED)
        {
            compression = CT_PKZIP;
        }
        else
        {
            compression = pPacket->data.compressionType;
        }

        TRACE_OUT(( "packet compressed with algorithm %u", compression));

        //
        // If the packet is compressed, decompress it now
        //
        if (compression)
        {
            PGDC_DICTIONARY pgdcDict = NULL;

            //
            // Copy the uncompressed packet header into the buffer.
            //
            memcpy(pPacketUse, pPacket, sizeof(*pPacket));

            cbBufferSize = TSHR_MAX_SEND_PKT - sizeof(*pPacket);

            if (compression == CT_PERSIST_PKZIP)
            {
                //
                // Figure out what dictionary to use based on stream priority
                //
                switch (pPacket->stream)
                {
                    case PROT_STR_UPDATES:
                        dictionary = GDC_DICT_UPDATES;
                        break;

                    case PROT_STR_MISC:
                        dictionary = GDC_DICT_MISC;
                        break;

                    case PROT_STR_INPUT:
                        dictionary = GDC_DICT_INPUT;
                        break;

                    default:
                        ERROR_OUT(("Unrecognized stream ID"));
                        break;
                }

                pgdcDict = pasPerson->adcsDict + dictionary;
            }
            else if (compression != CT_PKZIP)
            {
                //
                // If this isn't PKZIP or PERSIST_PKZIP, we don't know what the
                // heck it is (corrupted packet or incompatible T.128.  Bail
                // out now.
                //
                WARNING_OUT(("SC_ReceivedPacket: ignoring packet, don't recognize compression type"));
                DC_QUIT;
            }

            //
            // Decompress the data following the packet header.
            // This should never fail - if it does, the data has probably been
            // corrupted.
            //
            decompressed = GDC_Decompress(pgdcDict, m_agdcWorkBuf,
                (LPBYTE)(pPacket + 1),
                pPacket->data.compressedLength - sizeof(DATAPACKETHEADER),
                (LPBYTE)(pPacketUse + 1),
                &cbBufferSize);

            if (!decompressed)
            {
                ERROR_OUT(( "Failed to decompress packet from [%d]!", pasPerson->mcsID));
                DC_QUIT;
            }
        }
        else
        {
            // We have received an uncompressed buffer.  Since we may modify the
            // buffer's contents and what we have is an MCS buffer that may be
            // sent to other nodes, we copy the data.
            memcpy(pPacketUse, pPacket, pPacket->dataLength + sizeof(S20DATAPACKET)
                - sizeof(DATAPACKETHEADER));
        }

        // The packet (pPacketUse) is now decompressed

        //
        // ROUTE the packet
        //
        TRACE_OUT(("SC_ReceivedPacket:  Received packet type %04d size %04d from [%d]",
            pPacketUse->data.dataType, pPacketUse->data.compressedLength,
            pPacketUse->header.user));

        switch (pPacketUse->data.dataType)
        {
            case DT_CA:
                CA_ReceivedPacket(pasPerson, pPacketUse);
                break;

            case DT_CA30:
                CA30_ReceivedPacket(pasPerson, pPacketUse);
                break;

            case DT_IM:
                IM_ReceivedPacket(pasPerson, pPacketUse);
                break;

            case DT_HET:
            case DT_HET30:
                HET_ReceivedPacket(pasPerson, pPacketUse);
                break;

            case DT_UP:
                UP_ReceivedPacket(pasPerson, pPacketUse);
                break;

            case DT_FH:
                FH_ReceivedPacket(pasPerson, pPacketUse);
                break;

            case DT_CM:
                CM_ReceivedPacket(pasPerson, pPacketUse);
                break;

            case DT_CPC:
                CPC_ReceivedPacket(pasPerson, pPacketUse);
                break;

            case DT_AWC:
                AWC_ReceivedPacket(pasPerson, pPacketUse);
                break;

            case DT_UNUSED_DS:
                TRACE_OUT(("Ignoring DS packet received from NM 2.x node"));
                break;

            case DT_UNUSED_USR_FH_11:   // Old R.11 FH packets
            case DT_UNUSED_USR_FH_10:   // Old R.10 FH packets
            case DT_UNUSED_HCA:         // Old High-Level Control Arbiter
            case DT_UNUSED_SC:          // Old R.11 SC packets
            default:
                ERROR_OUT(( "Invalid packet received %u",
                           pPacketUse->data.dataType));
                break;
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::SC_ReceivedPacket);
}


//
// SC_ShareStarting()
// Share initialization
//
// This in turn calls other component share starting
//
BOOL ASShare::SC_ShareStarting(void)
{
    BOOL    rc = FALSE;
    BOOL    fViewSelf;

    DebugEntry(ASShare::SC_ShareStarting);

    //
    // SC specific init
    //

    // Find out whether to view own shared stuff (a handy debugging tool)
    COM_ReadProfInt(DBG_INI_SECTION_NAME, VIEW_INI_VIEWSELF, FALSE, &fViewSelf);
    m_scfViewSelf = (fViewSelf != FALSE);

    // Create scratch compression buffer for outgoing/incoming packets
    m_ascTmpBuffer = new BYTE[TSHR_MAX_SEND_PKT];
    if (!m_ascTmpBuffer)
    {
        ERROR_OUT(("SC_Init: couldn't allocate m_ascTmpBuffer"));
        DC_QUIT;
    }

    // Share version
    m_scShareVersion        = CAPS_VERSION_CURRENT;


    //
    // Component inits
    //

    if (!BCD_ShareStarting())
    {
        ERROR_OUT(("BCD_ShareStarting failed"));
        DC_QUIT;
    }

    if (!IM_ShareStarting())
    {
        ERROR_OUT(("IM_ShareStarting failed"));
        DC_QUIT;
    }

    if (!CM_ShareStarting())
    {
        ERROR_OUT(("CM_ShareStarting failed"));
        DC_QUIT;
    }

    if (!USR_ShareStarting())
    {
        ERROR_OUT(("USR_ShareStarting failed"));
        DC_QUIT;
    }

    if (!VIEW_ShareStarting())
    {
        ERROR_OUT(("VIEW_ShareStarting failed"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::SC_ShareStarting, rc);
    return(rc);
}



//
// SC_ShareEnded()
// Share cleanup
//
// This in turn calls other component share ended routines
//
void ASShare::SC_ShareEnded(void)
{
    DebugEntry(ASShare::SC_ShareEnded);

    //
    // Delete remotes from share
    //
    if (m_pasLocal)
    {
        while (m_pasLocal->pasNext)
        {
            SC_PartyDeleted(m_pasLocal->pasNext->mcsID);
        }

        //
        // Delete local self from share
        //
        SC_PartyDeleted(m_pasLocal->mcsID);
    }


    //
    // Component Notifications
    //

    VIEW_ShareEnded();

    USR_ShareEnded();

    CM_ShareEnded();

    IM_ShareEnded();

    BCD_ShareEnded();

    //
    // SC specific term
    //
    // Free scratch buffer
    if (m_ascTmpBuffer)
    {
        delete[] m_ascTmpBuffer;
        m_ascTmpBuffer = NULL;
    }

    DebugExitVOID(ASShare::SC_ShareEnded);
}





//
// SC_PartyJoiningShare()
//
// Called when a new party is joining the share.  This is an internal
// function because it is the SC which calls all these functions.  The
// processing done here relies on the capabilities - so it is in here as
// this is called after CPC_PartyJoiningShare.
//
// RETURNS:
//
// TRUE if the party can join the share.
//
// FALSE if the party can NOT join the share.
//
//
ASPerson * ASShare::SC_PartyJoiningShare
(
    UINT        mcsID,
    LPSTR       szName,
    UINT        cbCaps,
    LPVOID      pCaps
)
{
    BOOL        rc = FALSE;
    ASPerson *  pasPerson = NULL;

    DebugEntry(ASShare::SC_PartyJoiningShare);

    //
    // Allocate an ASPerson for this dude.  If this is the local person,
    // it gets stuck at the front.  Otherwise it gets stuck just past
    // the front.
    //
    pasPerson = SC_PersonAllocate(mcsID, szName);
    if (!pasPerson)
    {
        ERROR_OUT(("SC_PartyAdded: can't allocate ASPerson for [%d]", mcsID));
        DC_QUIT;
    }

    //
    // DO THIS FIRST -- we need the person's caps set up
    //
    if (!CPC_PartyJoiningShare(pasPerson, cbCaps, pCaps))
    {
        ERROR_OUT(("CPC_PartyJoiningShare failed for [%d]", pasPerson->mcsID));
        DC_QUIT;
    }

    //
    // Call the component joined routines.
    //
    if (!DCS_PartyJoiningShare(pasPerson))
    {
        ERROR_OUT(("DCS_PartyJoiningShare failed for [%d]", pasPerson->mcsID));
        DC_QUIT;
    }

    if (!CM_PartyJoiningShare(pasPerson))
    {
        ERROR_OUT(("CM_PartyJoiningShare failed for [%d]", pasPerson->mcsID));
        DC_QUIT;
    }

    if (!HET_PartyJoiningShare(pasPerson))
    {
        ERROR_OUT(("HET_PartyJoiningShare failed for [%d]", pasPerson->mcsID));
        DC_QUIT;
    }


    //
    // NOW THE PERSON IS JOINED.
    // Recalculate capabilities of the share with this new person.
    //
    SC_RecalcCaps(TRUE);

    rc = TRUE;

DC_EXIT_POINT:
    if (!rc)
    {
        //
        // Don't worry, this person object will still be cleaned up,
        // code at a higher layer will free by using the MCSID.
        //
        pasPerson = NULL;
    }
    DebugExitPVOID(ASShare::SC_PartyJoiningShare, pasPerson);
    return(pasPerson);
}



//
// SC_RecalcCaps()
//
// Recalculates share capabilities after somebody has joined or left the
// share.
//
void  ASShare::SC_RecalcCaps(BOOL fJoiner)
{
    ASPerson * pasT;

    DebugEntry(ASShare::SC_RecalcCaps);

    //
    // DO THIS FIRST -- recalculate the share version.
    //
    ValidatePerson(m_pasLocal);
    m_scShareVersion = m_pasLocal->cpcCaps.general.version;

    for (pasT = m_pasLocal->pasNext; pasT != NULL; pasT = pasT->pasNext)
    {
        ValidatePerson(pasT);
        m_scShareVersion = min(m_scShareVersion, pasT->cpcCaps.general.version);
    }

    //
    // Do viewing & hosting stuff first
    //
    DCS_RecalcCaps(fJoiner);
    OE_RecalcCaps(fJoiner);

    //
    // Do hosting stuff second
    //
    USR_RecalcCaps(fJoiner);
    CM_RecalcCaps(fJoiner);
    PM_RecalcCaps(fJoiner);
    SBC_RecalcCaps(fJoiner);
    SSI_RecalcCaps(fJoiner);

    DebugExitVOID(ASShare::SC_RecalcCaps);
}



//
// FUNCTION: SC_PartyLeftShare()
//
// DESCRIPTION:
//
// Called when a party has left the share.
//
//
void  ASShare::SC_PartyLeftShare(UINT mcsID)
{
    ASPerson *  pasPerson;
    ASPerson *  pasT;

    DebugEntry(SC_PartyLeftShare);

    if (!SC_ValidateNetID(mcsID, &pasPerson))
    {
        TRACE_OUT(("Couldn't find ASPerson for [%d]", mcsID));
        DC_QUIT;
    }

    // Tell the UI this dude is gone
    if (!pasPerson->cpcCaps.share.gccID)
    {
        WARNING_OUT(("Skipping PartyLeftShare for person [%d], no GCC id",
            pasPerson->mcsID));
        DC_QUIT;
    }

    DCS_NotifyUI(SH_EVT_PERSON_LEFT, pasPerson->cpcCaps.share.gccID, 0);

    //
    // Tell everybody this person is gone.
    //
    //
    // Notes on order of PartyLeftShare calls
    //
    // 1. HET must be called first, since that halts any sharing from this
    //    person, before we kick the person out of the share.
    //
    // 2. CA must be called before IM (as CA calls IM functions)
    //
    //

    // This will stop hosting early
    HET_PartyLeftShare(pasPerson);

    CA_PartyLeftShare(pasPerson);
    CM_PartyLeftShare(pasPerson);

    VIEW_PartyLeftShare(pasPerson);

    PM_PartyLeftShare(pasPerson);
    RBC_PartyLeftShare(pasPerson);
    OD2_PartyLeftShare(pasPerson);

    OE_PartyLeftShare(pasPerson);
    DCS_PartyLeftShare(pasPerson);

    //
    // Free the person
    //
    SC_PersonFree(pasPerson);

    //
    // Recalculate the caps with him gone.  But there's no point in doing
    // this if it's the local dude, since the share will exit imminently.
    //
    if (m_pasLocal)
    {
        SC_RecalcCaps(FALSE);
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::SC_PartyLeftShare);
}


//
// FUNCTION: SCCheckForCMCall
//
// DESCRIPTION:
//
// This is called when we want to check if a CM call now exists (and do
// whatever is appropriate to join it etc).
//
// PARAMETERS: NONE
//
// RETURNS: TRUE if success; otherwise, FALSE.
//
//
void SCCheckForCMCall(void)
{
    CM_STATUS   cmStatus;

    DebugEntry(SCCheckForCMCall);

    ASSERT(g_asSession.scState == SCS_INIT);

    //
    // See if a call already exists
    //
    if (!g_asSession.callID)
    {
        if (CMS_GetStatus(&cmStatus))
        {
            //
            // The AS lock protects the g_asSession fields.
            //
            TRACE_OUT(("AS LOCK:  SCCheckForCMCall"));
            UT_Lock(UTLOCK_AS);

            g_asSession.callID = cmStatus.callID;

            //
            // This is the time to update our local person name.  It's
            // on our thread, but before the control packets exchange it
            //
            lstrcpy(g_asSession.achLocalName, cmStatus.localName);
            g_asSession.cchLocalName = lstrlen(g_asSession.achLocalName);
            TRACE_OUT(("Local Name is %s", g_asSession.achLocalName));

            g_asSession.gccID = cmStatus.localHandle;

            UT_Unlock(UTLOCK_AS);
            TRACE_OUT(("AS UNLOCK:  SCCheckForCMCall"));
        }
    }

    if (g_asSession.callID)
    {
        SC_CreateShare(S20_JOIN);
    }

    DebugExitVOID(SCCheckForCMCall);
}



#ifdef _DEBUG
void ASShare::ValidatePerson(ASPerson * pasPerson)
{
    ASSERT(!IsBadWritePtr(pasPerson, sizeof(ASPerson)));
    ASSERT(!lstrcmp(pasPerson->stamp.idStamp, "ASPerso"));
    ASSERT(pasPerson->mcsID != MCSID_NULL);
}

void ASShare::ValidateView(ASPerson * pasPerson)
{
    ValidatePerson(pasPerson);
    ASSERT(!IsBadWritePtr(pasPerson->m_pView, sizeof(ASView)));
    ASSERT(!lstrcmp(pasPerson->m_pView->stamp.idStamp, "ASVIEW"));
}

#endif // _DEBUG


//
// SC_PersonAllocate()
// This allocates a new ASPerson structure, fills in the debug/mcsID fields,
// and links it into the people-in-the-conference list.
//
// Eventually, all the PartyJoiningShare routines that simply init a field
// should go away and that info put here.
//
ASPerson * ASShare::SC_PersonAllocate(UINT mcsID, LPSTR szName)
{
    ASPerson * pasNew;

    DebugEntry(ASShare::SC_PersonAllocate);

    pasNew = new ASPerson;
    if (!pasNew)
    {
        ERROR_OUT(("Unable to allocate a new ASPerson"));
        DC_QUIT;
    }
    ZeroMemory(pasNew, sizeof(*pasNew));
    SET_STAMP(pasNew, Person);

    //
    // Set up mcsID and name
    //
    pasNew->mcsID = mcsID;
    lstrcpyn(pasNew->scName, szName, TSHR_MAX_PERSON_NAME_LEN);

    UT_Lock(UTLOCK_AS);

    //
    // Is this the local person?
    //
    if (!m_pasLocal)
    {
        m_pasLocal = pasNew;
    }
    else
    {
        UINT        streamID;

        //
        // This is a remote.  Set up the sync status right away in case
        // the join process fails in the middle.  Cleaning up will undo
        // this always.
        //

        //
        // Mark this person's streams as needing a sync from us before we
        //      can send data to him
        // And and that we need a sync from him on each stream before we'll
        //      receive data from him
        //
        for (streamID = SC_STREAM_LOW; streamID <= SC_STREAM_HIGH; streamID++ )
        {
            //
            // Set up the sync status.
            //
            ASSERT(pasNew->scSyncSendStatus[streamID-1] == SC_NOT_SYNCED);
            ASSERT(pasNew->scSyncRecStatus[streamID-1] == SC_NOT_SYNCED);
            m_ascSynced[streamID-1]++;
        }

        //
        // Link into list
        //
        pasNew->pasNext = m_pasLocal->pasNext;
        m_pasLocal->pasNext = pasNew;
    }

    UT_Unlock(UTLOCK_AS);

DC_EXIT_POINT:
    DebugExitPVOID(ASShare::SC_PersonAllocate, pasNew);
    return(pasNew);
}



//
// SC_PersonFree()
// This gets a person out of the linked list and frees the memory for them.
//
void ASShare::SC_PersonFree(ASPerson * pasFree)
{
    ASPerson ** ppasPerson;
    UINT        streamID;


    DebugEntry(ASShare::SC_PersonFree);

    ValidatePerson(pasFree);

    for (ppasPerson = &m_pasLocal; *(ppasPerson) != NULL; ppasPerson = &((*ppasPerson)->pasNext))
    {
        if ((*ppasPerson) == pasFree)
        {
            //
            // Found it.
            //
            TRACE_OUT(("SC_PersonUnhook: unhooking person [%d]", pasFree->mcsID));

            if (pasFree == m_pasLocal)
            {
                ASSERT(pasFree->pasNext == NULL);
            }
            else
            {
                //
                // Clear syncs
                //
                // If this person was never synced, subtract them from the
                // global "needing sync" count on each stream
                //
                for (streamID = SC_STREAM_LOW; streamID <= SC_STREAM_HIGH; streamID++ )
                {
                    if (pasFree->scSyncSendStatus[streamID-1] == SC_NOT_SYNCED)
                    {
                        ASSERT(m_ascSynced[streamID-1] > 0);
                        m_ascSynced[streamID-1]--;
                    }
                }
            }

            UT_Lock(UTLOCK_AS);

            //
            // Fix up linked list.
            //
            (*ppasPerson) = pasFree->pasNext;

#ifdef _DEBUG
            ZeroMemory(pasFree, sizeof(ASPerson));
#endif // _DEBUG
            delete pasFree;

            UT_Unlock(UTLOCK_AS);
            DC_QUIT;
        }
    }

    //
    // We didn't find this guy in the list--this is very bad.
    //
    ERROR_OUT(("SC_PersonFree: didn't find person %d", pasFree));

DC_EXIT_POINT:
    DebugExitVOID(ASShare::SC_PersonFree);
}



//
// SC_AllocPkt()
// Allocates a SEND packet
//
PS20DATAPACKET ASShare::SC_AllocPkt
(
    UINT        streamID,
    UINT        nodeID,
    UINT        cbSizePkt
)
{
    PS20DATAPACKET  pPacket = NULL;

    DebugEntry(ASShare::SC_AllocPkt);

    if (g_asSession.scState != SCS_SHARING)
    {
        TRACE_OUT(("SC_AllocPkt failed; share is ending"));
        DC_QUIT;
    }

    ASSERT((streamID >= SC_STREAM_LOW) && (streamID <= SC_STREAM_HIGH));
    ASSERT(cbSizePkt >= sizeof(S20DATAPACKET));

    //
    // We'd better not be in the middle of a sync!
    //
    ASSERT(!m_scfInSync);

    //
    // Try and send any outstanding syncs
    //
    if (!SCSyncStream(streamID))
    {
        //
        // If the stream is still not synced, don't allocate the packet
        //
        WARNING_OUT(("SC_AllocPkt failed; outstanding syncs are present"));
        DC_QUIT;
    }

    pPacket = S20_AllocDataPkt(streamID, nodeID, cbSizePkt);

DC_EXIT_POINT:
    DebugExitPVOID(ASShare::SC_AllocPkt, pPacket);
    return(pPacket);
}




//
// SCSyncStream()
//
// This broadcasts a SNI sync packet intended for a new person who has just
// joined the share.  That person ignores all received data from us until
// they get the sync.  That's because data in transit before they are synced
// could refer to PKZIP data they don't have, second level order encoding
// info they can't decode, orders they can't process, etc.
//
// When we receive a SYNC from a remote, we then know that following
// data from that remote will make sense.  The remote has settled us into
// the share, and the data encorporates our capabilities and will not refer
// to prior state info from before we joined the share.
//
// NOTE that in 2.x, this was O(N^2) where N is the number of people now in
// the share!  Each person in the share would send SNI sync packets for each
// stream for each other person in the share, even for people who weren't new.
// But those people wouldn't reset received state, and would (could) continue
// processing data from us.  When they finally got their sync packet, it
// would do nothing!  Even more worst, 2 of the 5 streams are never used,
// and one stream is only used when a person is hosting.  So 3 of these 5
// O(N^2) broadcasts were useless all or the majority of the time.
//
// So now we only send SNI sync packets for new joiners.  This makes joining
// an O(N) broadcast algorithm.
//
// LAURABU BOGUS
// Post Beta1, we can make this even better.  Each broadcast is itself O(N)
// packets.  So for beta1, joining/syncing is O(N^2) packets instead of
// O(N^3) packets.  With targeted sends (not broadcasts) whenever possible,
// we can drop this to O(N) total packets.
//
// NOTE also that no real app sharing packets are sent on a stream until
// we have fully synced everybody.  That means we've reduced a lot the
// lag between somebody dialing into a conference and their seeing a result,
// and everybody else being able to work again.
//
BOOL ASShare::SCSyncStream(UINT streamID)
{
    ASPerson *      pasPerson;
    PSNIPACKET      pSNIPacket;
    BOOL            rc = TRUE;

    DebugEntry(ASShare::SCSyncStream);

    //
    // Loop through each person in the call broadcasting sync packets as
    // necessary.
    //
    // LAURABU BOGUS
    // We can change this to a targeted send after Beta 1.
    //

    //
    // Note that new people are added to the front of the this.  So we will
    // bail out of this loop very quickly when sending syncs to newcomers.
    //
    ValidatePerson(m_pasLocal);

    pasPerson = m_pasLocal->pasNext;
    while ((m_ascSynced[streamID-1] > 0) && (pasPerson != NULL))
    {
        ValidatePerson(pasPerson);

        //
        // If this person is new, we need to send them a SYNC packet so
        // they know we are done processing their join and know they
        // are in the share.
        //
        if (pasPerson->scSyncSendStatus[streamID-1] != SC_SYNCED)
        {
            TRACE_OUT(("Syncing stream %d for person [%d] in broadcast way",
                streamID, pasPerson->mcsID));

            //
            // YES, syncs are broadcast even though they have the mcsID of
            // just one person, the person they are intended for.  Since we
            // broadcast all state data, we also broadcast syncs.  That's
            // the only way to make sure the packets arrive in the same
            // order, SYNC before data.
            //

            pSNIPacket = (PSNIPACKET)S20_AllocDataPkt(streamID,
                    g_s20BroadcastID, sizeof(SNIPACKET));
            if (!pSNIPacket)
            {
                TRACE_OUT(("Failed to alloc SNI sync packet"));
                rc = FALSE;
                break;
            }

            //
            // Set SNI packet fields
            //
            pSNIPacket->header.data.dataType = DT_SNI;
            pSNIPacket->message = SNI_MSG_SYNC;
            pSNIPacket->destination = (NET_UID)pasPerson->mcsID;

            S20_SendDataPkt(streamID, g_s20BroadcastID, &(pSNIPacket->header));

            pasPerson->scSyncSendStatus[streamID-1] = SC_SYNCED;

            ASSERT(m_ascSynced[streamID-1] > 0);
            m_ascSynced[streamID-1]--;
        }

        pasPerson = pasPerson->pasNext;
    }

    DebugExitBOOL(ASShare::SCSyncStream, rc);
    return(rc);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\sdg.cpp ===
#include "precomp.h"


//
// SDG.CPP
// Screen Data Grabber
// Sends OUTGOING screen data when hosting
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE

//
// SDG_SendScreenDataArea()
//
void  ASHost::SDG_SendScreenDataArea(LPBOOL pBackPressure, UINT * pcPackets)
{
    UINT     i;
    BOOL     fBltOK = TRUE;
    RECT     sdaRect[BA_NUM_RECTS];
    UINT     cRects;
    BOOL     backPressure = FALSE;
    BOOL     secondaryTransmit = FALSE;

    DebugEntry(ASHost::SDG_SendScreenDataArea);

    //
    // Get the bounds of the screen data area.  At entry this is always    
    // our primary transmission area.  Even if we had already flushed      
    // the primary region and were in the middle of the secondary region   
    // we will switch back to the primary region if any more SD            
    // accumulates.  In this way we keep our spoiling of the secondary     
    // screendata maximized.                                               
    //
    BA_CopyBounds(sdaRect, &cRects, TRUE);

    //
    // If there is a pending rectangle that was unable to be sent on a     
    // previous transmission then try to send it first.                    
    //                                                                     
    // Leave the lossy flag as it was at the last pass                     
    //
    if (m_sdgRectIsPending)
    {
        TRACE_OUT(( "Sending pending rectangle"));
        m_sdgRectIsPending = FALSE;

        //
        // Try to send the pending rectangle.  SDGSplitBlt...  will remove 
        // any portions of it that are sent successfully.  We will add all 
        // the rest of the SDA back to the bounds in the loop below        
        //
        if (!SDGSplitBltToNetwork(&m_sdgPendingRect, pcPackets))
        {
            fBltOK           = FALSE;
            m_sdgRectIsPending = TRUE;
        }
        else
        {
            //
            // The pending rectangle was successfully sent.                
            //
            TRACE_OUT(( "Sent pending rect"));
        }

    }

    //
    // We have copied the primary transmit region so now move the secondary
    // transmit bounds into the screendata bounds because when we send data
    // in the primary transmission we want to accumulate any rectangles    
    // that need subsequent retransmission.  The retransmit bounds are     
    // generally different from the original SD bounds because the         
    // compression function is permitted to override our lossy request for 
    // any portion of the data if it finds that the data is pretty         
    // compressible anyway.  In this way we end up with retransmission of  
    // embedded photos etc, but the toolbars/buttons are only sent once.   
    //                                                                     
    // For the non-lossy case the secondary bounds will always be null,    
    // so there is no point in special casing here.                        
    //
    if (fBltOK)
    {
        for (i = 0; i < m_sdgcLossy; i++)
        {
            TRACE_OUT(("Setting up pseudo-primary bounds {%d, %d, %d, %d}",
                m_asdgLossyRect[i].left, m_asdgLossyRect[i].top,
                m_asdgLossyRect[i].right, m_asdgLossyRect[i].bottom ));

            //
            // Add the rectangle into the bounds.                          
            //
            BA_AddRect(&m_asdgLossyRect[i]);
        }

        //
        // If there is no primary bitmap data to send then send the        
        // secondary data.  If none of that either then just exit          
        //
        if (cRects == 0)
        {

            BA_CopyBounds(sdaRect, &cRects, TRUE);
            if (cRects == 0)
            {
                DC_QUIT;
            }
            else
            {
                TRACE_OUT(("Starting secondary transmission now"));
                secondaryTransmit = TRUE;
            }
        }
    }

    //
    // Process each of the supplied rectangles in turn.                    
    //
    TRACE_OUT(( "%d SDA rectangles", cRects));

    for (i = 0; i < cRects; i++)
    {
        TRACE_OUT(("Rect %d: {%d, %d, %d, %d}", i,
            sdaRect[i].left, sdaRect[i].top, sdaRect[i].right, sdaRect[i].bottom ));

        //
        // Clip the rectangle to the physical screen and reject totally    
        // any rectangle that refers to data that has now been scrolled off
        // the physical screen as a result of a desktop scroll between the 
        // time the rectangle was accumulated and now.                     
        //
        if (sdaRect[i].left < 0)
        {
            if (sdaRect[i].right < 0)
            {
                //
                // This was scrolled off the physical screen by a desktop  
                // scroll.                                                 
                //
                continue;
            }

            //
            // Partially off screen - just clip the left edge.             
            //
            sdaRect[i].left = 0;
        }

        if (sdaRect[i].top < 0)
        {
            if (sdaRect[i].bottom < 0)
            {
                //
                // This was scrolled off the physical screen by a desktop  
                // scroll.                                                 
                //
                continue;
            }

            //
            // Partially off screen - just clip the top edge.              
            //
            sdaRect[i].top = 0;
        }

        if (sdaRect[i].right >= m_pShare->m_pasLocal->cpcCaps.screen.capsScreenWidth)
        {
            if (sdaRect[i].left >= m_pShare->m_pasLocal->cpcCaps.screen.capsScreenWidth)
            {
                //
                // This was scrolled off the physical screen by a desktop  
                // scroll.                                                 
                //
                continue;
            }

            //
            // Partially off screen - just clip the right edge.            
            //
            sdaRect[i].right = m_pShare->m_pasLocal->cpcCaps.screen.capsScreenWidth-1;
        }

        if (sdaRect[i].bottom >= m_pShare->m_pasLocal->cpcCaps.screen.capsScreenHeight)
        {
            if (sdaRect[i].top >= m_pShare->m_pasLocal->cpcCaps.screen.capsScreenHeight)
            {
                //
                // This was scrolled off the physical screen by a desktop  
                // scroll.                                                 
                //
                continue;
            }

            //
            // Partially off screen - just clip the bottom edge.           
            //
            sdaRect[i].bottom = m_pShare->m_pasLocal->cpcCaps.screen.capsScreenHeight-1;
        }


        //
        // If all of the previous rectangles have been successfully sent   
        // then try to send this rectangle.                                
        // If a previous rectangle failed to be sent then we don't bother  
        // trying to send the rest of the rectangles in the same batch -   
        // they are added back into the SDA so that they will be sent later.
        //
        if (fBltOK)
        {
            fBltOK = SDGSplitBltToNetwork(&(sdaRect[i]), pcPackets);

            //
            // On the first blit failure we must transfer the posible      
            // secondary transmit bounds over to the save area for next    
            // time because down below we are going to add back any unsent 
            // transmit rectangles to the primary SD area.                 
            //                                                             
            // Dont worry if this was a secondary transmit because these   
            // bounds will be zero and will be overwritten when we copy    
            // the current SDA region to the secondary area for our next   
            // pass                                                        
            //
            if (!fBltOK && !secondaryTransmit)
            {
                TRACE_OUT(("Send failed so getting new secondary bounds"));
                BA_CopyBounds(m_asdgLossyRect, &m_sdgcLossy, TRUE);
            }
        }

        if (!fBltOK)
        {
            //
            // The blt to network failed - probably because a network      
            // packet could not be allocated.                              
            // We add the rectangle back into the SDA so that we will try  
            // to retransmit the area later.                               
            //

            TRACE_OUT(("Blt failed - add back rect {%d, %d, %d, %d}",
                                                         sdaRect[i].left,
                                                         sdaRect[i].top,
                                                         sdaRect[i].right,
                                                         sdaRect[i].bottom ));

            //
            // Add the rectangle into the bounds.                          
            //
            BA_AddRect(&(sdaRect[i]));

            backPressure = TRUE;

        }
    }

    //
    // If all went fine and we were sending primary transmit data then we  
    // should just go back and send secondary data, using the bounds which 
    // are located in the SD area at the moment.  We can do this by copying
    // these secondary bounds to the save area, where they will be used at 
    // the next schedule pass.  It is a good idea to yield, because we may 
    // be about to accumulate some more primary data.                      
    //
    if (fBltOK || secondaryTransmit)
    {
        TRACE_OUT(("Done with the primary bounds so getting pseudo-primary to secondary"));
        BA_CopyBounds(m_asdgLossyRect, &m_sdgcLossy, TRUE);
    }

DC_EXIT_POINT:
    *pBackPressure = backPressure;
    DebugExitVOID(ASHost::SDG_SendScreenDataArea);
}




//
// SDGSplitBltToNetwork(..)                                                
//                                                                         
// Sends the specified rectangle over the network.                         
//                                                                         
// The Screen Data rects that we can send over the network are limited     
// to certain sizes (determined by the sizes of the Transfer Bitmaps).     
// If necessary, this function splits the rect into smaller sub-rectangles 
// for transmission.                                                       
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// pRect - pointer to the rectangle to send.                               
//                                                                         
// RETURNS:                                                                
//                                                                         
// TRUE - rectangle was successfully sent. Supplied rectangle is updated   
// to be NULL.                                                             
//                                                                         
// FALSE - rectangle was not completely sent. Supplied rectangle is        
// updated to contain the area that was NOT sent.                          
//                                                                         
//
BOOL  ASHost::SDGSplitBltToNetwork(LPRECT pRect, UINT * pcPackets)
{
    RECT   smallRect;
    UINT   maxHeight;
    BOOL   rc;

    DebugEntry(ASHost::SDGSplitBltToNetwork);

    //
    // Loop processing strips.                                             
    //
    while (pRect->top <= pRect->bottom)
    {
        smallRect = *pRect;

        //
        // Split the given rectangles into multiple smaller rects if       
        // necessary.  If it is wider than our 256 byte work bitmap then   
        // switch to the mega 1024 byte one first.                         
        //

        // Note that the calculations don't work for VGA...
        maxHeight = max(8, m_usrSendingBPP);

        if ((smallRect.right-smallRect.left+1) > MEGA_X_SIZE)
        {
            maxHeight = MaxBitmapHeight(MEGA_WIDE_X_SIZE, maxHeight);
        }
        else
        {
            maxHeight = MaxBitmapHeight(MEGA_X_SIZE, maxHeight);
        }

        if ((unsigned)(smallRect.bottom - smallRect.top + 1) > maxHeight)
        {
            //
            // Split the rectangle to bring the height within the correct  
            // range.                                                      
            //
            TRACE_OUT(( "Split Y size(%d) by maxHeight(%d)",
                                         smallRect.bottom - smallRect.top,
                                         maxHeight));
            smallRect.bottom = smallRect.top + maxHeight - 1;
        }


        while ((pRect->right - smallRect.left + 1) > 0)
        {
            if (!SDGSmallBltToNetwork(&smallRect))
            {
                TRACE_OUT(( "Small blt failed"));
                rc = FALSE;
                DC_QUIT;
            }
            else
            {
                ++(*pcPackets);
            }
        }

        //
        // Move to the next strip.                                         
        //
        pRect->top = smallRect.bottom+1;

    }

    rc = TRUE;

DC_EXIT_POINT:
    if (!rc)
    {
        //
        // A small blt failed.  If we return FALSE then the supplied       
        // rectangle will be added back into the SDA bounds so that it will
        // be retransmitted later.                                         
        //                                                                 
        // However, we want to avoid the situation where we have sent the  
        // top left-hand corner of a rectangle and then add the remainder  
        // back into the SDA bounds, because this could cause the original 
        // bounding rectangle to be regenerated (because the bounds are    
        // stored in a fixed number of rectangles).                        
        //                                                                 
        // Therefore if we are not on the last strip of the rectangle then 
        // we keep the current strip as a "pending" rectangle.  The        
        // supplied rectangle is adjusted to remove the whole of this      
        // strip.  Next time this function is called the pending rectangle 
        // will be sent before anything else.                              
        //                                                                 
        // If we are on the last strip (which will be the normal case -    
        // there will usually only be one strip) then we update the        
        // supplied rectangle to be the area that has not been sent and    
        // return FALSE to indicate that it must be added back into the    
        // SDA.                                                            
        //
        if (m_sdgRectIsPending)
        {
            ERROR_OUT(( "Unexpected small blt failure with pending rect"));
        }
        else
        {
            if (smallRect.bottom == pRect->bottom)
            {
                //
                // This is the last strip.  Adjust the supplied rect to    
                // contain the area that has not been sent.                
                //
                pRect->top = smallRect.top;
                pRect->left = smallRect.left;
            }
            else
            {
                //
                // This is not the last strip Copy the remainder of the    
                // current strip into the pending rect.                    
                //
                smallRect.right = pRect->right;
                m_sdgPendingRect = smallRect;
                m_sdgRectIsPending = TRUE;

                //
                // Adjust the supplied rectangle to contain the remaining  
                // area that we have not sent and is not covered by the    
                // pending rect.                                           
                //
                pRect->top = smallRect.bottom+1;
            }
        }
    }

    DebugExitBOOL(ASHost::SDGSplitBltToNetwork, rc);
    return(rc);
}


//
// FUNCTION: SDGSmallBltToNetwork                                          
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Sends the screen data within the specified rectangle across the network.
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// pRect - pointer to the rectangle (in screen coords) to send as Screen   
// Data.                                                                   
//                                                                         
// RETURNS:                                                                
//                                                                         
// TRUE - screen data successfully sent                                    
//                                                                         
// FALSE - screen data could not be sent.  Caller should retry later.      
//                                                                         
//

//
// BOGUS BUGBUG LAURABU!
// This function affects the results on the screen!  If drawing happens
// between the time we realize the palette then unrealize it, it will look
// messed up.  You can easily see this in Visio 4.5 when it is in the 
// foreground (in the background, NM controls the colors so no effect).
//
BOOL  ASHost::SDGSmallBltToNetwork(LPRECT pRect)
{
    BOOL            fLossy = FALSE;
    HDC             hdcDesktop;
    HBITMAP         hBitmap = NULL;
    HBITMAP         hOldBitmap = NULL;
    UINT            width;
    UINT            height;
    UINT            fixedWidth;
    PSDPACKET       pSDPacket = NULL;
    BITMAPINFO_ours bitmapInfo;
    UINT            sizeBitmapPkt;
    UINT            sizeBitmap;
    HPALETTE        hpalOldDIB = NULL;
    HPALETTE        hpalOldDesktop = NULL;
    HPALETTE        hpalLocal;
    BOOL            fPacketSent = FALSE;
    RECT            smallRect;
    int             useWidth;
#ifdef _DEBUG
    UINT            sentSize;
#endif // _DEBUG

    DebugEntry(ASHost::SDGSmallBltToNetwork);

    hdcDesktop = GetDC(NULL);
    if (!hdcDesktop)
    {
        DC_QUIT;
    }
    width = pRect->right - pRect->left + 1;
    height = pRect->bottom - pRect->top + 1;

    //
    // Determine the width of the work buffer and the width that we        
    // will be sending this time                                           
    //
    fixedWidth = ((width + 15) / 16) * 16;
    useWidth = width;
    if (fixedWidth > MAX_X_SIZE)
    {
        if (fixedWidth > MEGA_X_SIZE)
        {
            fixedWidth = MEGA_WIDE_X_SIZE;
            if (width > MEGA_WIDE_X_SIZE)
            {
                useWidth = fixedWidth;
            }
        }
        else
        {
            fixedWidth = MEGA_X_SIZE;
            if (width > MEGA_X_SIZE)
            {
                useWidth = fixedWidth;
            }
        }
    }

    switch (fixedWidth)
    {
        case 16:
            hBitmap = m_pShare->m_usrBmp16;
            break;

        case 32:
            hBitmap = m_pShare->m_usrBmp32;
            break;

        case 48:
            hBitmap = m_pShare->m_usrBmp48;
            break;

        case 64:
            hBitmap = m_pShare->m_usrBmp64;
            break;

        case 80:
            hBitmap = m_pShare->m_usrBmp80;
            break;

        case 96:
            hBitmap = m_pShare->m_usrBmp96;
            break;

        case 112:
            hBitmap = m_pShare->m_usrBmp112;
            break;

        case 128:
            hBitmap = m_pShare->m_usrBmp128;
            break;

        case 256:
            hBitmap = m_pShare->m_usrBmp256;
            break;

        case 1024:
            hBitmap = m_pShare->m_usrBmp1024;
            break;

        default:
            ERROR_OUT(( "Invalid bitmap size(%d)", fixedWidth));
            break;
    }

    //
    // Initialise the BITMAPINFO_ours local structure header contents.     
    // This structure will be used in the GetDIBits calls but only the     
    // header part of the structure will be sent across the network, the   
    // color table is sent via the Palette Manager.                        
    //
    m_pShare->USR_InitDIBitmapHeader((BITMAPINFOHEADER *)&bitmapInfo, m_usrSendingBPP);

    bitmapInfo.bmiHeader.biWidth   = fixedWidth;
    bitmapInfo.bmiHeader.biHeight  = height;

    //
    // Calculate the size of the bitmap packet in BYTES.                   
    //
    sizeBitmap = BYTES_IN_BITMAP(fixedWidth, height, bitmapInfo.bmiHeader.biBitCount);

    sizeBitmapPkt = sizeof(SDPACKET) + sizeBitmap - 1;
    ASSERT(sizeBitmapPkt <= TSHR_MAX_SEND_PKT);

    //
    // Allocate a packet for the bitmap data.                              
    //                                                                     
    // *** NB. This assumes that this code is called ONLY when there   *** 
    // *** no unacknowledged bitmaps packets floating around the       *** 
    // *** network layer. This means, at the moment, if this code is   *** 
    // *** called due to anything other than a WM_TIMER                *** 
    // *** message we're in trouble.                                   *** 
    //                                                                     
    //
    pSDPacket = (PSDPACKET)m_pShare->SC_AllocPkt(PROT_STR_UPDATES, g_s20BroadcastID,
        sizeBitmapPkt);
    if (!pSDPacket)
    {
        //
        // Failed to allocate the bitmap packet - clear up and exit adding 
        // the rectangle back into the bounds.                             
        //
        TRACE_OUT(("Failed to alloc SDG packet, size %u", sizeBitmapPkt));
        DC_QUIT;
    }

    //
    // Since we are bltting off the screen, which by definition is using   
    // the system palette, we place the system palette in both DC's (so    
    // that the bitblt we are about to do will not do any color            
    // conversion).                                                        
    //

    //
    // This will determine if the palette changed since the last time we
    // sent one to the remote.
    //
    if (m_usrSendingBPP <= 8)
    {
        hpalLocal = PM_GetLocalPalette();
    }

    hOldBitmap = SelectBitmap(m_usrWorkDC, hBitmap);

    if (m_usrSendingBPP <= 8)
    {
        hpalOldDIB = SelectPalette(m_usrWorkDC, hpalLocal, FALSE);
        RealizePalette(m_usrWorkDC);
    }

    //
    // We can now do a bitblt from the screen (hpDesktop) to memory and the
    // bits are untranslated.                                              
    //                                                                     
    // We then do a GetDIBits using the local palette which returns us the 
    // bits at the correct bits per pel, (and with properly translated     
    // colors) in order to transmit the data.                              
    //
    BitBlt(m_usrWorkDC, 0, 0, useWidth, height, hdcDesktop,
        pRect->left, pRect->top, SRCCOPY);

    //
    // Zero any unused space on the right side to aid compression.
    //
    if (width < fixedWidth)
    {
        PatBlt(m_usrWorkDC, width, 0, fixedWidth - width, height, BLACKNESS);
    }

    //
    // Do a GetDIBits into our global stash of memory for now.  We will try
    // and compress this data into our packet after.                       
    //
    GetDIBits(m_usrWorkDC, hBitmap, 0, height, m_pShare->m_usrPBitmapBuffer,
        (PBITMAPINFO)&bitmapInfo, DIB_RGB_COLORS);

    //
    // Deselect the bitmap                                                 
    //
    SelectBitmap(m_usrWorkDC, hOldBitmap);

    //
    // Get the color table directly from the system since we can't trust
    // any palette realization color stuff via the messages at this stage.
    // We only need to do this on an 8bpp host sending 8bpp data.
    //
    if ((g_usrScreenBPP == 8) && (m_usrSendingBPP == 8))
    {
        PM_GetSystemPaletteEntries(bitmapInfo.bmiColors);
    }

    if (m_usrSendingBPP <= 8)
    {
        //
        // Whack old palettes back.
        //
        SelectPalette(m_usrWorkDC, hpalOldDIB, FALSE);
    }

    //
    // Fill in packet contents and send it.                                
    //
    pSDPacket->header.header.data.dataType   = DT_UP;
    pSDPacket->header.updateType        = UPD_SCREEN_DATA;

    //
    // Send Virtual desktop coordinates.                                   
    //
    pSDPacket->position.left    = (TSHR_INT16)(pRect->left);
    pSDPacket->position.right   = (TSHR_INT16)(pRect->left + useWidth - 1);

    pSDPacket->position.top     = (TSHR_INT16)(pRect->top);
    pSDPacket->position.bottom  = (TSHR_INT16)(pRect->bottom);

    pSDPacket->realWidth        = (TSHR_UINT16)fixedWidth;
    pSDPacket->realHeight       = (TSHR_UINT16)height;

    pSDPacket->format           = (TSHR_UINT16)m_usrSendingBPP;
    pSDPacket->compressed       = FALSE;

    //
    // Compress the bitmap data                                            
    //
    if (m_pShare->BC_CompressBitmap(m_pShare->m_usrPBitmapBuffer,
                           pSDPacket->data,
                           &sizeBitmap,
                           fixedWidth,
                           height,
                           bitmapInfo.bmiHeader.biBitCount,
                           &fLossy) )
    {
        //
        // We have successfully compressed the bitmap data into our packet 
        // data buffer.                                                    
        //
        pSDPacket->compressed = TRUE;

        //
        // Write the updated size of the data into the header.             
        //
        pSDPacket->dataSize = (TSHR_UINT16)sizeBitmap;

        //
        // Now update the size of the total data (including header)
        //
        sizeBitmapPkt = sizeof(SDPACKET) + sizeBitmap - 1;
        pSDPacket->header.header.dataLength = sizeBitmapPkt - sizeof(S20DATAPACKET)
            + sizeof(DATAPACKETHEADER);
    }
    else
    {
        //
        // The compression failed so just copy the uncompressed data from  
        // the global buffer to the packet and send it uncompressed.       
        //
        TRACE_OUT(("Failed to compress bitmap of size %d cx(%d) cy(%d) bpp(%d)",
            sizeBitmap, fixedWidth, height, bitmapInfo.bmiHeader.biBitCount));

        memcpy(pSDPacket->data,
                  m_pShare->m_usrPBitmapBuffer,
                  sizeBitmap );

        //
        // Write the size of the data into the header.                     
        //
        pSDPacket->dataSize = (TSHR_UINT16)sizeBitmap;
    }

    TRACE_OUT(("Sending %d bytes of screen data", sizeBitmap));

    if (m_pShare->m_scfViewSelf)
        m_pShare->UP_ReceivedPacket(m_pShare->m_pasLocal, &(pSDPacket->header.header));

#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    m_pShare->DCS_CompressAndSendPacket(PROT_STR_UPDATES, g_s20BroadcastID,
        &(pSDPacket->header.header), sizeBitmapPkt);

    TRACE_OUT(("SDG packet size: %08d, sent: %08d", sizeBitmapPkt, sentSize));

    //
    // We have sent the packet.                                            
    //
    fPacketSent = TRUE;

    //
    // If it was lossy then we must accumulate the area for resend.  We    
    // accumulate it into the current SDA because we know this was cleared 
    // before the transmission started.  We will then move the accumulated 
    // non-lossy rectangles to a save area before we return.               
    //
    if (fLossy)
    {
        //
        // Convert the rect back into Virtual Desktop coords.              
        //
        smallRect = *pRect;
        smallRect.right = smallRect.left + useWidth - 1;
        WARNING_OUT(( "Lossy send so add non-lossy area (%d,%d)(%d,%d)",
                                              smallRect.left,
                                              smallRect.top,
                                              smallRect.right,
                                              smallRect.bottom ));

        //
        // Add the rectangle into the bounds.                              
        //
        BA_AddRect(&(smallRect));
    }

    //
    // Now we modify the supplied rectangle to exclude the area just sent  
    //
    pRect->left = pRect->left + useWidth;
    TRACE_OUT(("Rect now {%d, %d, %d, %d}", pRect->left, pRect->top,
                                            pRect->right,
                                            pRect->bottom ));

DC_EXIT_POINT:
    if (hdcDesktop != NULL)
    {
        ReleaseDC(NULL, hdcDesktop);
    }

    DebugExitBOOL(ASHost::SDGSmallBltToNetwork, fPacketSent);
    return(fPacketSent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\shm.cpp ===
#include "precomp.h"


//
// SHM.CPP
// Shared Memory Access, cpi32 and display driver sides both
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE

//
// WAIT_FOR_BUFFER
//
// Wait until the display driver is accessing the new buffer.
//
// There are logically 8 states for a set of 3 boolean variables.  We can
// cut this down to 4 by some simple analysis:
//
//  - The overall busy flag overrides the other flags if it is clear.
//  - We can never have the display driver in both buffers (it's single
//    threaded).
//
// So the 4 states are as follows.
//
// STATE    BUSY FLAGS       DISPLAY DRIVER STATE
//          New Old Overall
//
// 1        0   0   0        Not using shared memory
// 2        0   0   1        Using shared memory (wait to see which)
// 3        1   0   1        Using the new buffer
// 4        0   1   1        Using the old buffer
//
// Obviously we wait while states 2 or 4 hold true....
//
#define WAIT_FOR_BUFFER(MEMORY, NEWBUFFER, OLDBUFFER)                        \
            while ( g_asSharedMemory->MEMORY.busyFlag &&                     \
                   ( g_asSharedMemory->MEMORY.bufferBusy[OLDBUFFER] ||       \
                    !g_asSharedMemory->MEMORY.bufferBusy[NEWBUFFER] )  )     \
            {                                                                \
                TRACE_OUT(("Waiting for SHM"));                            \
                Sleep(0);                                                    \
            }



//
// SHM_SwitchReadBuffer - see shm.h
//
void  SHM_SwitchReadBuffer(void)
{
    int     oldBuffer;
    int     newBuffer;

    DebugEntry(SHM_SwitchReadBuffer);

    //
    //
    // BUFFER SWITCHING FOR THE DISPLAY DRIVER -> SHARE CORE DATA
    //
    //
    // This is a forced switch.  The Share Core calls this function only
    // when it wants to force the switching of the buffers used to pass the
    // data back from the display driver.
    //
    //
    //      ͻ
    //       Kernel to Share Core data block                     
    //       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                     
    //        Ŀ               Ŀ  
    //                          BUSY FLAG1                   
    //         Share Core           1        Display Driver  
    //                                                       
    //         (read buffer)     SWITCH      (write buffer)  
    //                                                      
    //                       <>                 
    //         BUSY FLAG2                    BUSY FLAG2      
    //             0                             1           
    //                           IN USE                      
    //                                                      
    //                              >                 
    //                                                       
    //                                                       
    //                           COUNT                       
    //                              5                        
    //                         
    //                                                           
    //                                                           
    //      ͼ
    //
    //
    // On entry it is safe to clean out the current read buffer (to leave
    // it in a virgin state for the display driver once the buffers have
    // switched).
    //
    // The logic for the switch is as follows.
    //
    //  - Set the new value for the SWITCH pointer
    //
    //  - If the shared memory BUSY FLAG1 is clear we've finished and can
    //    exit now.
    //
    //  - We can exit as soon as either of the following are true.
    //
    //    - BUSY FLAG1 is clear                        DDI has finished
    //    - BUSY FLAG1 is set AND BUSY FLAG2 is set    DDI is in new memory
    //
    //

    //
    // Check for a valid pointer
    //
    ASSERT(g_asSharedMemory);

    //
    // Do that switch...The display driver may be in the middle of an
    // access at the moment, so we will test the state afterwards.
    //
    oldBuffer = g_asSharedMemory->displayToCore.newBuffer;
    newBuffer = 1 - oldBuffer;

    g_asSharedMemory->displayToCore.newBuffer = newBuffer;

    WAIT_FOR_BUFFER(displayToCore, newBuffer, oldBuffer);

    DebugExitVOID(SHM_SwitchReadBuffer);
}


//
// SHM_SwitchFastBuffer - see shm.h
//
void  SHM_SwitchFastBuffer(void)
{
    int oldBuffer;
    int newBuffer;

    DebugEntry(SHM_SwitchFastBuffer);

    //
    // Check for a valid pointer
    //
    ASSERT(g_asSharedMemory);

    //
    // Do that switch...The display driver may be in the middle of an
    // access at the moment, so we will test the state afterwards.
    //
    oldBuffer = g_asSharedMemory->fastPath.newBuffer;
    newBuffer = 1 - oldBuffer;

    g_asSharedMemory->fastPath.newBuffer = newBuffer;

    //
    // Wait for completion
    //
    WAIT_FOR_BUFFER(fastPath, newBuffer, oldBuffer);

    DebugExitVOID(SHM_SwitchFastBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\sbc.cpp ===
#include "precomp.h"


//
// SBC.CPP
// Send Bitmap Cache
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE






//
// SBC_HostStarting()
//
BOOL ASHost::SBC_HostStarting(void)
{
    BITMAPINFO_ours bitmapInfo;
    int             i;
    BOOL            rc = FALSE;

    DebugEntry(ASHost::SBC_HostStarting);

    if (g_sbcEnabled)
    {
        //
        // We create a DIB section for each tile size which we use during the
        // conversion of a bitmap from the native (device) bpp to the protocol
        // bpp.  We create the DIB sections at the device bpp.
        //
        ZeroMemory(&bitmapInfo, sizeof(bitmapInfo));
        m_pShare->USR_InitDIBitmapHeader((BITMAPINFOHEADER *)&bitmapInfo, g_usrCaptureBPP);

        // We only capture at 8 or 24 for NT 5.0, otherwise the screen depth
        if ((g_usrCaptureBPP > 8) && (g_usrCaptureBPP != 24))
        {
            //
            // If the device bpp is > 8 (but not 24), we have to set up the DIB
            // section to use the same bitmasks as the device.  This means
            // setting the compression type to BI_BITFIELDS and setting the
            // first 3 DWORDS of the bitmap info color table to be the bitmasks
            // for R, G and B respectively.
            //
            // 24bpp does not use bitmasks - it must use
            // regular BI_RGB format with 8 bits for each colour.
            //
            bitmapInfo.bmiHeader.biCompression = BI_BITFIELDS;

            ASSERT(g_asbcBitMasks[0]);
            ASSERT(g_asbcBitMasks[1]);
            ASSERT(g_asbcBitMasks[2]);

            bitmapInfo.bmiColors[0] = ((LPTSHR_RGBQUAD)g_asbcBitMasks)[0];
            bitmapInfo.bmiColors[1] = ((LPTSHR_RGBQUAD)g_asbcBitMasks)[1];
            bitmapInfo.bmiColors[2] = ((LPTSHR_RGBQUAD)g_asbcBitMasks)[2];
        }

        //
        // Initialize m_asbcWorkInfo array which holds the info we use to
        // convert from native bpp to protocol bpp.
        //

        //
        // First, intialize all the fields to default values
        //
        for (i = 0; i < SBC_NUM_TILE_SIZES ; i++)
        {
            ASSERT(!m_asbcWorkInfo[i].pShuntBuffer);
            ASSERT(g_asbcShuntBuffers[i]);

            m_asbcWorkInfo[i].pShuntBuffer = g_asbcShuntBuffers[i];

            ASSERT(m_asbcWorkInfo[i].mruIndex       == 0);
            ASSERT(m_asbcWorkInfo[i].workBitmap     == 0);
            ASSERT(m_asbcWorkInfo[i].pWorkBitmapBits == NULL);

            if (i == SBC_MEDIUM_TILE_INDEX)
            {
                m_asbcWorkInfo[i].tileWidth    = MP_MEDIUM_TILE_WIDTH;
                m_asbcWorkInfo[i].tileHeight   = MP_MEDIUM_TILE_HEIGHT;
            }
            else
            {
                m_asbcWorkInfo[i].tileWidth    = MP_LARGE_TILE_WIDTH;
                m_asbcWorkInfo[i].tileHeight   = MP_LARGE_TILE_HEIGHT;
            }

            bitmapInfo.bmiHeader.biWidth  = m_asbcWorkInfo[i].tileWidth;
            bitmapInfo.bmiHeader.biHeight = m_asbcWorkInfo[i].tileHeight;

            m_asbcWorkInfo[i].workBitmap = CreateDIBSection(NULL,
                                  (BITMAPINFO*)&bitmapInfo,
                                  DIB_RGB_COLORS,
                                  (void **)&(m_asbcWorkInfo[i].pWorkBitmapBits),
                                  NULL,             // File mapping object
                                  0);               // Offset into file
                                                    //   mapping object
            if (!m_asbcWorkInfo[i].workBitmap)
            {
                ERROR_OUT(("Failed to create SBC DIB section %d", i));
                DC_QUIT;
            }

            ASSERT(m_asbcWorkInfo[i].pWorkBitmapBits);
            TRACE_OUT(( "Created work DIB section %d, pBits = 0x%08x",
                     i, m_asbcWorkInfo[i].pWorkBitmapBits));
        }

        //
        // Initialize the fastpath
        //
        if (!SBCInitFastPath())
        {
            TRACE_OUT(( "Failed to init fastpath"));
            DC_QUIT;
        }

        if (!SBCInitInternalOrders())
        {
            ERROR_OUT(( "Failed to init SBC internal order struct"));
            DC_QUIT;
        }

        m_pShare->SBC_RecalcCaps(TRUE);
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::SBC_HostStarting, rc);
    return(rc);
}



//
// ASShare::SBC_HostEnded()
//
void ASHost::SBC_HostEnded(void)
{
    int     i;

    DebugEntry(ASHost::SBC_HostEnded);

    if (g_sbcEnabled)
    {
        //
        // Free up the memory associated with sbcOrderInfo.
        //
        SBCFreeInternalOrders();

        SBCInitCacheStructures();

        //
        // Free our fast path info
        //
        if (m_sbcFastPath)
        {
            delete m_sbcFastPath;
            m_sbcFastPath = NULL;
        }

        //
        // Clear our cache handles.
        //
        for (i = 0; i < NUM_BMP_CACHES; i++)
        {
            if (m_asbcBmpCaches[i].handle != 0)
            {
                TRACE_OUT(( "Clear cache %d", i));
                CH_DestroyCache(m_asbcBmpCaches[i].handle);
                BMCFreeCacheData(&m_asbcBmpCaches[i]);
            }
        }

        //
        // Free our work DIB sections
        //

        //
        // We just have to delete the DIB sections and reset our variables.
        //
        for (i = 0 ; i < SBC_NUM_TILE_SIZES ; i++)
        {
            m_asbcWorkInfo[i].pShuntBuffer = NULL;

            if (m_asbcWorkInfo[i].workBitmap != NULL)
            {
                DeleteBitmap(m_asbcWorkInfo[i].workBitmap);
                m_asbcWorkInfo[i].workBitmap      = NULL;
                m_asbcWorkInfo[i].pWorkBitmapBits = NULL;
            }
        }
    }

    DebugExitVOID(ASHost::SBC_HostEnded);
}



//
// SBC_SyncOutgoing()
// Called when we're already hosting and someone new joins the share.
// Resets the OUTGOING bitmap cache for bitblt orders.
//
void  ASHost::SBC_SyncOutgoing(void)
{
    int   i;

    DebugEntry(ASHost::SBC_SyncOutgoing);

    //
    // Only do anything if SBC is enabled
    //
    if (g_sbcEnabled)
    {
        //
        // Discard all currently cached bitmaps and set the colour table to
        // zero so that the next bitmap order which arrives will trigger the
        // sending of a new colour table first.  Note that if the colour table
        // is then full of zeros(!) it will still be OK because the RBC zeros
        // out its copy of the colour table when a new host joins the share.
        //
        TRACE_OUT(( "Clearing all send caches"));
        SBCInitCacheStructures();

        //
        // All we have to do here is to reset our MRU indices for each of the
        // shunt buffers.  Each of the entries in the shunt buffer will be
        // marked as free down in the driver.
        //
        for (i = 0; i < SBC_NUM_TILE_SIZES; i++)
        {
            m_asbcWorkInfo[i].mruIndex = 0;
        }
    }

    DebugExitVOID(ASHost::SBC_SyncOutgoing);
}



//
//
// SBC_CopyPrivateOrderData()
//
//
UINT  ASHost::SBC_CopyPrivateOrderData
(
    LPBYTE          pDst,
    LPCOM_ORDER     pOrder,
    UINT            freeBytesInBuffer
)
{
    UINT      orderSize;
    LPBYTE    pBitmapBits;

    DebugEntry(ASHost::SBC_CopyPrivateOrderData);

    //
    // Copy the order header without the rectangle structure (which we
    // do not use).
    //
    orderSize = sizeof(pOrder->OrderHeader)
              - sizeof(pOrder->OrderHeader.rcsDst);
    memcpy(pDst, pOrder, orderSize);

    //
    // Copy the basic order data.
    //
    memcpy(pDst + orderSize,
              pOrder->abOrderData,
              pOrder->OrderHeader.cbOrderDataLength);
    orderSize += pOrder->OrderHeader.cbOrderDataLength;

    if (orderSize > freeBytesInBuffer)
    {
        ERROR_OUT(( "Overwritten end of buffer. (%u) > (%u)",
                      orderSize,
                      freeBytesInBuffer));
    }

    //
    // Set the length field in the order header to be the total amount of
    // data we have copied (including the partial header) minus the
    // size of a full header. This is horrible! - but is needed because
    // the OD2 code looks at the header (which it really should not know
    // about) and uses the length field to calculate the total length of
    // the order. The OD2 code does not know that we have omitted some
    // of the header.
    //
    ((LPCOM_ORDER)pDst)->OrderHeader.cbOrderDataLength =
        (WORD)(orderSize - sizeof(COM_ORDER_HEADER));

    //
    // Return the total number of bytes that we have copied.
    //
    DebugExitDWORD(ASHost::SBC_CopyPrivateOrderData, orderSize);
    return(orderSize);
}



//
// Name:      SBCInitCacheStructures()
//
// Purpose:
//
// Returns:
//
// Params:
//
// Operation:
//
//
void  ASHost::SBCInitCacheStructures(void)
{
    UINT  i;

    DebugEntry(ASHost::SBCInitCacheStructures);

    ASSERT(g_sbcEnabled);

    //
    // Reset caches
    //
    for (i = 0; i < NUM_BMP_CACHES; i++)
    {
        if (m_asbcBmpCaches[i].handle)
        {
            CH_ClearCache(m_asbcBmpCaches[i].handle);
        }
    }

    //
    // Do any OS specific processing
    //
    SBC_CacheCleared();

    DebugExitVOID(ASHost::SBCInitCacheStructures);
}



//
// SBC_CacheCleared()
//
void  ASHost::SBC_CacheCleared(void)
{
    int   i;

    DebugEntry(ASHost::SBC_CacheCleared);

    ASSERT(g_sbcEnabled);
    ASSERT(m_sbcFastPath);

    //
    // The cache has been cleared.  Reset our fast path.
    //
    COM_BasedListInit(&m_sbcFastPath->usedList);
    COM_BasedListInit(&m_sbcFastPath->freeList);

    for (i = 0; i < SBC_FASTPATH_ENTRIES; i++)
    {
        m_sbcFastPath->entry[i].list.next = 0;
        m_sbcFastPath->entry[i].list.prev = 0;
        COM_BasedListInsertBefore(&m_sbcFastPath->freeList,
                             &m_sbcFastPath->entry[i].list);
    }

    DebugExitVOID(ASHost::SBC_CacheCleared);
}


//
//
// SBCSelectCache(..)
//
// Decides which cache a sub-bitmap from a source bitmap of the specified
// size should go in.
//
// To be cached, the sub-bitmap must:
// have a size, in compressed bytes, which fits in the cache
//
// The R1.1 cache selection is irrespective of the actual memory
// requirement for the cached data.  This is wasteful of space, but is
// necessary for R1.1 compatibility.  (The R1.1 cache paremeters mean that
// the total cache will be below about 128K in any case)
//
// For R2.0 the cache is selected by this function by comparing the
// post-compress size with the cell area of each of the caches.  This gives
// us a much better space usage on both server and client.
//
// Returns:
//   TRUE if the sub-bitmap can be cached.
//   *pCache is updated with the index of the selected cache.
//
//   FALSE if the sub-bitmap cannot be cached.
//   *pCache is not updated.
//
//
BOOL  ASHost::SBCSelectCache
(
    UINT            cSize,
    UINT *          pCache
)
{
    BOOL    fCacheSelected;
    BOOL    fSelectedCacheIsFull;
    UINT    i;

    DebugEntry(ASHost::SBCSelectCache);

    fCacheSelected       = FALSE;
    fSelectedCacheIsFull = FALSE;

    //
    // This loop makes the assumption that cache 0 is the smallest.  If
    // abmcint.h changes this assumption it will need rewriting.
    //
    for (i = 0; i < NUM_BMP_CACHES; i++)
    {
        if (m_asbcBmpCaches[i].cEntries <= 0)
        {
            //
            // No entries in this cache, so skip to the next one
            //
            continue;
        }

        //
        // R2 bitmap cache - only consider total cell size.
        //
        // Only consider this cache if
        //  - we haven't yet found a cache
        // OR
        //  - we have found a cache, but it is full (i.e.  will
        //    require an entry to be ejected) AND this one is not
        //    full
        //
        // (Note that a cache is full if freeEntry != NULL)
        //
        if (!fCacheSelected ||
            (fSelectedCacheIsFull &&
             ((m_asbcBmpCaches[i].freeEntry == NULL)
                     || !m_asbcBmpCaches[i].freeEntry->inUse)))
        {
            if (cSize <= m_asbcBmpCaches[i].cSize)
            {
                if (fSelectedCacheIsFull)
                {
                    TRACE_OUT(("Using cache %u because cache %u is full",
                                 *pCache, i));
                }

                *pCache        = i;
                fCacheSelected = TRUE;

                fSelectedCacheIsFull =
                                  ((m_asbcBmpCaches[i].freeEntry != NULL) &&
                                   m_asbcBmpCaches[i].freeEntry->inUse);

                if (!fSelectedCacheIsFull)
                {
                    break;
                }
            }
        }
    }

    DebugExitDWORD(ASHost::SBCSelectCache, fCacheSelected);
    return(fCacheSelected);
}


//
// FUNCTION: SBC_RecreateSendCache
//
// DESCRIPTION:
//
// (Re)creates the send bitmap cache with a size suitable for the current
// capabilities.
//
// PARAMETERS:
// cache - index to the cache being recreated
// cOldEntries - the previous max number of entries in the cache
// oldCellSize - the previous cell size
//
// RETURNS: NONE
//
//
void  ASHost::SBC_RecreateSendCache
(
    UINT    cache,
    UINT    newNumEntries,
    UINT    newCellSize
)
{
    PBMC_DIB_CACHE pCache = &(m_asbcBmpCaches[cache]);

    DebugEntry(ASHost::SBC_RecreateSendCache);

    //
    // Allocate the memory for the new send cache
    //
    ASSERT((newCellSize != pCache->cCellSize) ||
           (newNumEntries != pCache->cEntries));

    //
    // If the cache already exists then destroy it first
    //
    if (pCache->handle != 0)
    {
        TRACE_OUT(( "Destroy SBC cache %d", cache));

        CH_DestroyCache(pCache->handle);
        pCache->handle = 0;
    }

    //
    // Now reallocate the cache data.  This will free any memory previously
    // allocated.  If the entries/cellsize is zero, it will return success.
    //
    if (!BMCAllocateCacheData(newNumEntries, newCellSize, cache, pCache))
    {
        ERROR_OUT(( "Bitmap caching disabled for cache %u", cache));
    }

    if (pCache->cEntries > 0)
    {
        //
        // Allocate cache handler cache.  Note that we force the cache
        // handler to leave us with one entry in our hand at all times by
        // decrementing its count of entries.
        //
        if (!CH_CreateCache(&(pCache->handle),
                            pCache->cEntries - 1,
                            SBC_NUM_CATEGORIES,
                            BMC_DIB_NOT_HASHED,
                            SBCCacheCallback ))
        {
            ERROR_OUT(( "Could not allocate SBC cache of (%u)",
                         pCache->cEntries));
            pCache->cEntries = 0;
        }
    }

    TRACE_OUT(( "Created new cache: 0x%08x, size %u",
                 pCache->handle,
                 pCache->cEntries));

    //
    // Copy the relevant cache information into the shared memory buffer
    //
    m_asbcCacheInfo[cache].cEntries  = (WORD)pCache->cEntries;
    m_asbcCacheInfo[cache].cCellSize = (WORD)pCache->cCellSize;

    TRACE_OUT(("SBC cache %d: %d entries of size %d",
        cache, m_asbcCacheInfo[cache].cEntries, m_asbcCacheInfo[cache].cCellSize));

    DebugExitVOID(ASHost::SBC_RecreateSendCache);
}



//
// SBC_RecalcCaps()
//
// Enumerates all the people in the share and redetermines the size of the
// bitmap cache depending on their and the local receive capabilities.
//
//
// THIS CAN GO AWAY WHEN 2.X COMPAT DOES
//
void  ASShare::SBC_RecalcCaps(BOOL fJoiner)
{
    SBC_NEW_CAPABILITIES newCapabilities;
    UINT                newSmallCellSize;
    UINT                newSmallMaxEntries;
    UINT                newMediumCellSize;
    UINT                newMediumMaxEntries;
    UINT                newLargeCellSize;
    UINT                newLargeMaxEntries;
    PBMC_DIB_CACHE      pSmall;
    PBMC_DIB_CACHE      pMedium;
    PBMC_DIB_CACHE      pLarge;
    BOOL                cacheChanged = FALSE;
    ASPerson *          pasT;

    DebugEntry(ASShare::SBC_RecalcCaps);

    if (!m_pHost || !g_sbcEnabled)
    {
        //
        // Nothing to do -- we're not hosting, or there is no SBC.  Note that
        // 2.x always recalculated this stuff when somebody joined AND
        // somebody left.
        //
        DC_QUIT;
    }

    ValidatePerson(m_pasLocal);

    pSmall = &(m_pHost->m_asbcBmpCaches[ID_SMALL_BMP_CACHE]);
    pMedium= &(m_pHost->m_asbcBmpCaches[ID_MEDIUM_BMP_CACHE]);
    pLarge = &(m_pHost->m_asbcBmpCaches[ID_LARGE_BMP_CACHE]);

    //
    // Enumerate all the bitmap cache receive capabilities of the parties
    // in the share.  The usable size of the send bitmap cache is then the
    // minimum of all the remote receive caches and the local send cache
    // size.
    //

    //
    // Start by setting the size of the local send bitmap cache to the
    // local default values.
    //
    newSmallCellSize    = m_pasLocal->cpcCaps.bitmaps.sender.capsSmallCacheCellSize;
    newSmallMaxEntries  = m_pasLocal->cpcCaps.bitmaps.sender.capsSmallCacheNumEntries;

    newMediumCellSize   = m_pasLocal->cpcCaps.bitmaps.sender.capsMediumCacheCellSize;
    newMediumMaxEntries = m_pasLocal->cpcCaps.bitmaps.sender.capsMediumCacheNumEntries;

    newLargeCellSize    = m_pasLocal->cpcCaps.bitmaps.sender.capsLargeCacheCellSize;
    newLargeMaxEntries  = m_pasLocal->cpcCaps.bitmaps.sender.capsLargeCacheNumEntries;

    TRACE_OUT(("Recalced SBC caps:  Small {%d of %d}, Medium {%d of %d}, Large {%d of %d}",
            newSmallMaxEntries, newSmallCellSize,
            newMediumMaxEntries, newMediumCellSize,
            newLargeMaxEntries, newLargeCellSize));


    //
    // If we've changed the size, reset the cache before continuing.
    //
    if ((pSmall->cCellSize != newSmallCellSize) ||
        (pSmall->cEntries != newSmallMaxEntries))
    {
        m_pHost->SBC_RecreateSendCache(ID_SMALL_BMP_CACHE,
                             newSmallMaxEntries,
                             newSmallCellSize);
        cacheChanged = TRUE;
    }

    if ((pMedium->cCellSize != newMediumCellSize) ||
        (pMedium->cEntries != newMediumMaxEntries))
    {
        m_pHost->SBC_RecreateSendCache(ID_MEDIUM_BMP_CACHE,
                             newMediumMaxEntries,
                             newMediumCellSize);
        cacheChanged = TRUE;
    }

    if ((pLarge->cCellSize != newLargeCellSize) ||
        (pLarge->cEntries != newLargeMaxEntries))
    {
        m_pHost->SBC_RecreateSendCache(ID_LARGE_BMP_CACHE,
                             newLargeMaxEntries,
                             newLargeCellSize);
        cacheChanged = TRUE;
    }

    //
    // If we had to recreate any of the send caches, make sure that we
    // clear the fast path.
    //
    if (cacheChanged)
    {
        m_pHost->SBC_CacheCleared();
    }

    //
    // Handle new capabilities
    //

    //
    // Set up the new capabilities structure...
    //
    newCapabilities.sendingBpp     = m_pHost->m_usrSendingBPP;

    newCapabilities.cacheInfo      = m_pHost->m_asbcCacheInfo;

    //
    // ... and pass it through to the driver.
    //
    if (! OSI_FunctionRequest(SBC_ESC_NEW_CAPABILITIES,
                            (LPOSI_ESCAPE_HEADER)&newCapabilities,
                            sizeof(newCapabilities)))
    {
        ERROR_OUT(("SBC_ESC_NEW_CAPABILITIES failed"));
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::SBC_RecalcCaps);
}



//
// FUNCTION: SBCCacheCallback
//
// DESCRIPTION:
//
// Send BMC Cache Manager callback function.  Called whenever an entry is
// removed from the cache to allow us to free up the object.
//
// PARAMETERS:
//
// hCache - cache handle
//
// event - the cache event that has occured
//
// iCacheEntry - index of the cache entry that the event is affecting
//
// pData - pointer to the cache data associated with the given cache entry
//
// cbDataSize - size in bytes of the cached data
//
// RETURNS: Nothing
//
//
void  SBCCacheCallback
(
    ASHost *    pHost,
    PCHCACHE    pCache,
    UINT        iCacheEntry,
    LPBYTE      pData
)
{
    UINT cache;

    DebugEntry(SBCCacheCallback);

    //
    // Simply release the cache entry for reuse.  We must scan for
    // the correct cache root
    //
    for (cache = 0; cache < NUM_BMP_CACHES; cache++)
    {
        if (pHost->m_asbcBmpCaches[cache].handle == pCache)
        {
            pHost->m_asbcBmpCaches[cache].freeEntry = (PBMC_DIB_ENTRY)pData;
            pHost->m_asbcBmpCaches[cache].freeEntry->inUse = FALSE;

            TRACE_OUT(("0x%08x SBC cache entry 0x%08x now free", pCache, pData));

            pHost->SBC_CacheEntryRemoved(cache, iCacheEntry);
            break;
        }
    }

    DebugExitVOID(SBCCacheCallback);
}



//
//
// SBC_ProcessMemBltOrder()
//
//
BOOL  ASHost::SBC_ProcessMemBltOrder
(
    LPINT_ORDER         pOrder,
    LPINT_ORDER *       ppNextOrder
)
{
    BOOL                rc = FALSE;
    UINT                orderType;
    UINT                tileId;
    UINT                tileType;
    LPSBC_TILE_DATA     pTileData = NULL;
    UINT                bitmapWidth;
    int                 bitmapHeight;
    LPINT_ORDER         pBMCOrder = NULL;
    UINT                colorCacheIndex;
    UINT                bitsCache;
    UINT                bitsCacheIndex;
    UINT                numColors;
    LPLONG              pXSrc;
    LPLONG              pYSrc;
    BOOL                isNewColorTableEntry;
    BOOL                isNewBitsEntry;
    BOOL                canFastPath  = TRUE;
    LPMEMBLT_ORDER      pMemBltOrder = (LPMEMBLT_ORDER)&(pOrder->abOrderData);
    LPMEM3BLT_ORDER     pMem3BltOrder   = (LPMEM3BLT_ORDER)pMemBltOrder;
    LPMEMBLT_R2_ORDER   pMemBltR2Order  = (LPMEMBLT_R2_ORDER)pMemBltOrder;
    LPMEM3BLT_R2_ORDER  pMem3BltR2Order = (LPMEM3BLT_R2_ORDER)pMemBltOrder;
    BITMAPINFO_ours     sbcBitmapInfo;

    DebugEntry(ASHost::SBC_ProcessMemBltOrder);

    *ppNextOrder = NULL;

    //
    // We may already have processed this MEMBLT order and have the color
    // table and bitmap bits for it, ready to go across the wire.  This
    // would happen if the update packager called this function to process
    // the MEMBLT, but then didn't have enough room in its current network
    // packet to send the color table or the bitmap bits.
    //
    // So, if we've already processed this order, bail out now.
    //
    if (m_sbcOrderInfo.pOrder == pOrder)
    {
        //
        // We've got a match !  Do we have valid data for it ?  If we don't
        // we must have failed last time, so we'll probably fail again (we
        // don't do any memory allocation, so it's unlikely that the error
        // condition has cleared up).  In any case, we should not have been
        // called again if we failed last time...
        //
        if (m_sbcOrderInfo.validData)
        {
            TRACE_OUT(( "Already have valid data for this MEMBLT"));
            rc = TRUE;
        }
        else
        {
            WARNING_OUT(( "Have invalid data for this MEMBLT"));
        }
        DC_QUIT;
    }

    //
    // Re-initialise m_sbcOrderInfo
    //
    m_sbcOrderInfo.pOrder         = pOrder;
    m_sbcOrderInfo.validData      = FALSE;
    m_sbcOrderInfo.sentColorTable = FALSE;
    m_sbcOrderInfo.sentBitmapBits = FALSE;
    m_sbcOrderInfo.sentMemBlt     = FALSE;

    //
    // Here's on overview of what we do here...
    //
    // We've been given a MEMBLT order which references an entry in a shunt
    // buffer containing the bits for the MEMBLT at the native bpp (the bpp
    // of the display).  We want to cache the bits and a color table at the
    // protocol bpp.  So, we
    //
    // - copy the bits from the shunt buffer into a work DIB section
    // - call GetDIBits to get the data from the work DIB section at the
    //   protocol bpp
    // - cache the bits and the color table
    // - if we add new cache entries for the bits and / or the color table,
    //   we fill in m_sbcOrderInfo.pBitmapBits order and / or
    //   m_sbcOrderInfo.pColorTableInfo to hold the orders to be sent before
    //   the MEMBLT order.
    //

    //
    // Make sure that we've been given the correct order type.  Note that
    // we will never be given the R2 versions of the MEMBLT orders.
    //
    orderType = pMemBltOrder->type;
    ASSERT(((orderType == ORD_MEMBLT_TYPE) ||
                (orderType == ORD_MEM3BLT_TYPE)));

    //
    // Get a pointer to the entry in one of the shunt buffers which matches
    // this order.
    //
    if (orderType == ORD_MEMBLT_TYPE)
    {
        tileId = pMemBltOrder->cacheId;
    }
    else
    {
        tileId = pMem3BltOrder->cacheId;
    }

    if (!SBCGetTileData(tileId, &pTileData, &tileType))
    {
        ERROR_OUT(( "Failed to find entry for tile %hx in shunt buffer",
                     tileId));
        DC_QUIT;
    }

    bitmapWidth  = pTileData->width;
    bitmapHeight = pTileData->height;

    //
    // Check if we should do any fast path operations on this bitmap
    //
    if (pTileData->majorCacheInfo == SBC_DONT_FASTPATH)
    {
        TRACE_OUT(( "Tile %x should not be fastpathed", tileId));
        canFastPath = FALSE;
    }
    //
    // Try to find an entry for this bitmap in the fast path (unless the
    // bitmap is marked as being non-fastpathable).
    //
    if (canFastPath && SBCFindInFastPath(pTileData->majorCacheInfo,
                                         pTileData->minorCacheInfo,
                                         pTileData->majorPalette,
                                         pTileData->minorPalette,
                                         pTileData->srcX,
                                         pTileData->srcY,
                                         pTileData->tilingWidth,
                                         pTileData->tilingHeight,
                                         &bitsCache,
                                         &bitsCacheIndex,
                                         &colorCacheIndex))
    {
        isNewBitsEntry       = FALSE;
        isNewColorTableEntry = FALSE;

        //
        // Call the cache handler to get it to update its MRU entry for
        // this cache entry
        //
        CH_TouchCacheEntry(m_asbcBmpCaches[bitsCache].handle, bitsCacheIndex);
    }
    else
    {
        //
        // There is no entry in the fast path...
        //
        // Copy the data from the tile in the shunt buffer into the work
        // DIB section.  Note that this only works correctly because both
        // our work DIB and the tile data are "top down" rather than the
        // default of "bottom up".  i.e the data for the first scanline is
        // stored first in memory.  If this wasn't the case, we'd have to
        // work out an offset into the work DIB to start copying to.
        //
        memcpy(m_asbcWorkInfo[tileType].pWorkBitmapBits,
                  pTileData->bitData,
                  pTileData->bytesUsed);

        //
        // Now set up the destination for the GetDIBits call.  First set up
        // a bitmap info header to pass to GetDIBits.  Only the header part
        // of the structure will be sent across the network - the color
        // table is sent via the palette packets.
        //
        // Note that we set the height in the bitmap info header to be
        // negative.  This forces a convertion from our "top down" DIB
        // format to the default "bottom up" format which we want to cache
        // and send over the wire.
        //
        ZeroMemory(&sbcBitmapInfo, sizeof(sbcBitmapInfo));
        m_pShare->USR_InitDIBitmapHeader((BITMAPINFOHEADER *)&sbcBitmapInfo,
            m_usrSendingBPP);
        sbcBitmapInfo.bmiHeader.biWidth  = m_asbcWorkInfo[tileType].tileWidth;
        sbcBitmapInfo.bmiHeader.biHeight = -(int)m_asbcWorkInfo[tileType].tileHeight;

        //
        // OK, we've set up the source and the destination, so now get the
        // data at the protocol bpp.  We get the bits into the usr general
        // bitmap work buffer.
        //
        if (GetDIBits(m_usrWorkDC,
                         m_asbcWorkInfo[tileType].workBitmap,
                         0,
                         bitmapHeight,
                         m_pShare->m_usrPBitmapBuffer,
                         (BITMAPINFO *)&sbcBitmapInfo,
                         DIB_RGB_COLORS) != (int)bitmapHeight)
        {
            ERROR_OUT(( "GetDIBits failed"));
            DC_QUIT;
        }

        TRACE_OUT(( "%d x %d, (fixed %d) -> (%d, %d)",
                     bitmapWidth,
                     bitmapHeight,
                     m_asbcWorkInfo[tileType].tileWidth,
                     pMemBltOrder->nLeftRect,
                     pMemBltOrder->nTopRect));

        numColors = COLORS_FOR_BPP(m_usrSendingBPP);

        //
        // There is no color table to cache if there is no color table at
        // all, which is the case when sending at 24BPP
        //
        if (numColors)
        {
            //
            // Cache the color table.  If this succeeds, colorCacheIndex will
            // be set up to contain the details of the cache entry which the
            // data is cached in.  In addition, if isNewColorTableEntry is TRUE
            // on return, psbcOrders.colorTableOrder will be fully initialized
            // and ready to go across the wire.
            //
            if (!SBCCacheColorTable(m_sbcOrderInfo.pColorTableOrder,
                                sbcBitmapInfo.bmiColors,
                                numColors,
                                &colorCacheIndex,
                                &isNewColorTableEntry))
            {
                TRACE_OUT(( "Failed to cache color table"));
                DC_QUIT;
            }

            ASSERT(colorCacheIndex != COLORCACHEINDEX_NONE);
        }
        else
        {
            colorCacheIndex = COLORCACHEINDEX_NONE;
            isNewColorTableEntry = FALSE;
        }


        //
        // Cache the bits.  If this succeeds, bitsCache and bitsCacheIndex
        // will be set up to contain the details of the cache entry which
        // the data is cached in.  In addition, if isNewBitsEntry is TRUE
        // on return, psbcOrders.bitmapBitsOrder will be fully initialized
        // and ready to go across the wire.
        //
        // If this fails, the above values will be undefined.
        //
        if (!SBCCacheBits(m_sbcOrderInfo.pBitmapBitsOrder,
                          m_sbcOrderInfo.bitmapBitsDataSize,
                          m_pShare->m_usrPBitmapBuffer,
                          bitmapWidth,
                          m_asbcWorkInfo[tileType].tileWidth,
                          bitmapHeight,
                          BYTES_IN_BITMAP(m_asbcWorkInfo[tileType].tileWidth,
                                          bitmapHeight,
                                          sbcBitmapInfo.bmiHeader.biBitCount),
                          &bitsCache,
                          &bitsCacheIndex,
                          &isNewBitsEntry))
        {
            TRACE_OUT(( "Failed to cache bits"));
            DC_QUIT;
        }

        //
        // Add the newly cached item to the fast path (unless the bitmap is
        // marked as being non-fastpathable).
        //
        if (canFastPath)
        {
            SBCAddToFastPath(pTileData->majorCacheInfo,
                             pTileData->minorCacheInfo,
                             pTileData->majorPalette,
                             pTileData->minorPalette,
                             pTileData->srcX,
                             pTileData->srcY,
                             pTileData->tilingWidth,
                             pTileData->tilingHeight,
                             bitsCache,
                             bitsCacheIndex,
                             colorCacheIndex);
        }
    }

    //
    // We've now got valid cache entries for the DIB bits and the color
    // table, so we should now fill them into the MEMBLT order.
    //
    // Set up the source co-ordinates. For R1 protocols, the x-coordinate
    // includes the offset which is required to get the right cell within
    // the receive bitmap cache. For R2, we set up the cache entry in a
    // separate field.
    //
    if (orderType == ORD_MEMBLT_TYPE)
    {
        pXSrc = &pMemBltOrder->nXSrc;
        pYSrc = &pMemBltOrder->nYSrc;
    }
    else
    {
        pXSrc = &pMem3BltOrder->nXSrc;
        pYSrc = &pMem3BltOrder->nYSrc;
    }

    *pXSrc = *pXSrc % pTileData->tilingWidth;
    *pYSrc = *pYSrc % pTileData->tilingHeight;

    //
    // The sub-bitmap and color table are in the cache.  Store a cache
    // handle and color handle.  Also store the cache index for R2
    // protocols (see above).
    //
    if (orderType == ORD_MEMBLT_TYPE)
    {
        pMemBltOrder->cacheId = MEMBLT_COMBINEHANDLES(colorCacheIndex,
                                                      bitsCache);

        pMemBltR2Order->type       = (TSHR_UINT16)ORD_MEMBLT_R2_TYPE;
        pMemBltR2Order->cacheIndex = (TSHR_UINT16)bitsCacheIndex;

        TRACE_OUT(( "MEMBLT color %u bitmap %u:%u",
                     colorCacheIndex,
                     bitsCache,
                     bitsCacheIndex));
    }
    else
    {
        pMem3BltOrder->cacheId = MEMBLT_COMBINEHANDLES(colorCacheIndex,
                                                       bitsCache);

        pMem3BltR2Order->type       = ORD_MEM3BLT_R2_TYPE;
        pMem3BltR2Order->cacheIndex = (TSHR_UINT16)bitsCacheIndex;

        TRACE_OUT(( "MEM3BLT color %u bitmap %u:%u",
                     colorCacheIndex,
                     bitsCache,
                     bitsCacheIndex));
    }

    //
    // Must have successfully completed processing the order to get to
    // here.  Fill in the appropriate info in the m_sbcOrderInfo structure.
    // If we got a cache hit on the color table or the bitmap bits then
    // we've already sent the data for them.
    //
    m_sbcOrderInfo.validData        = TRUE;
    m_sbcOrderInfo.sentColorTable   = !isNewColorTableEntry;
    m_sbcOrderInfo.sentBitmapBits   = !isNewBitsEntry;
    rc                              = TRUE;

DC_EXIT_POINT:
    if (rc)
    {
        //
        // We've successfully processed the MEMBLT, so set up a pointer to
        // the next order which should be sent by the caller.
        //
        // Note that if we have already sent these orders, then we return
        // a NULL order.
        //
        if (!m_sbcOrderInfo.sentColorTable)
        {
            TRACE_OUT(( "Returning color table order"));
            *ppNextOrder = m_sbcOrderInfo.pColorTableOrder;
        }
        else if (!m_sbcOrderInfo.sentBitmapBits)
        {
            TRACE_OUT(( "Returning bitmap bits order"));
            *ppNextOrder = m_sbcOrderInfo.pBitmapBitsOrder;
        }
        else if (!m_sbcOrderInfo.sentMemBlt)
        {
            TRACE_OUT(( "Returning MemBlt order"));
            *ppNextOrder = pOrder;
        }
        else
        {
            TRACE_OUT(( "No order to return"));
            rc = FALSE;
        }
    }

    //
    // We've finished with the entry in the shunt buffer, so reset the
    // inUse flag to allow the driver to re-use it.
    //
    if (pTileData != NULL)
    {
        pTileData->inUse = FALSE;
    }

    DebugExitBOOL(ASHost::SBC_ProcessMemBltOrder, rc);
    return(rc);
}


//
//
// SBC_OrderSentNotification()
//
//
void  ASHost::SBC_OrderSentNotification(LPINT_ORDER pOrder)
{
    DebugEntry(ASHost::SBC_OrderSentNotification);

    //
    // pOrder should be a pointer to either our internal bitmap bits order,
    // or our color table order.
    //
    if (pOrder == m_sbcOrderInfo.pBitmapBitsOrder)
    {
        TRACE_OUT(( "Bitmap bits order has been sent"));
        m_sbcOrderInfo.sentBitmapBits = TRUE;
    }
    else if (pOrder == m_sbcOrderInfo.pColorTableOrder)
    {
        TRACE_OUT(( "Color table order has been sent"));
        m_sbcOrderInfo.sentColorTable = TRUE;
    }
    else if (pOrder == m_sbcOrderInfo.pOrder)
    {
        TRACE_OUT(( "Memblt order has been sent"));
        m_sbcOrderInfo.sentMemBlt = TRUE;

        //
        // All parts of the Memblt have been sent now, so reset our pointer
        // to the order.  This avoids a problem where
        // SBC_ProcessMemBltOrder is called twice in a row with the same
        // pOrder, but with different data (i.e.  consecutive MemBlts
        // ending up in the same point in the order heap).  It can happen...
        //
        m_sbcOrderInfo.pOrder = NULL;
    }
    else
    {
        ERROR_OUT(( "Notification for unknown order %#.8lx", pOrder));
    }

    DebugExitVOID(ASHost::SBC_OrderSentNotification);
}


//
//
// SBC_ProcessInternalOrder()
//
//
void  ASHost::SBC_ProcessInternalOrder(LPINT_ORDER pOrder)
{
    UINT                            orderType;
    LPINT_COLORTABLE_ORDER_1BPP     pColorTableOrder;
    HBITMAP                         oldBitmap = 0;
    UINT                            numEntries;
    int                             i;

    DebugEntry(ASHost::SBC_ProcessInternalOrder);

    //
    // Make sure that we've been given an order type which we recognise.
    // Currently, the only internal order we support is a color table
    // order.
    //
    pColorTableOrder = (LPINT_COLORTABLE_ORDER_1BPP)&(pOrder->abOrderData);
    orderType        = pColorTableOrder->header.type;

    ASSERT(orderType == INTORD_COLORTABLE_TYPE);

    //
    // Make sure that the color table order is the same bpp as the work DIB
    // sections.
    //
    ASSERT(pColorTableOrder->header.bpp == g_usrCaptureBPP);

    //
    // All we have to do is to copy the color table from the order into our
    // two work DIB sections.  To do that, we have to select the DIB
    // sections into a DC then set the color table for the DC - this sets
    // the color table in the DIB section.
    //
    numEntries = COLORS_FOR_BPP(g_usrCaptureBPP);
    ASSERT(numEntries);

    for (i = 0 ; i < SBC_NUM_TILE_SIZES; i++)
    {
        oldBitmap = SelectBitmap(m_usrWorkDC, m_asbcWorkInfo[i].workBitmap);

        SetDIBColorTable(m_usrWorkDC,
                         0,                     // First index
                         numEntries,            // Number of entries
                         (RGBQUAD*)pColorTableOrder->colorData);
    }

    if (oldBitmap != NULL)
    {
        SelectBitmap(m_usrWorkDC, oldBitmap);
    }

    DebugExitVOID(ASHost::SBC_ProcessInternalOrder);
}


//
//
// SBC_PMCacheEntryRemoved()
//
//
void  ASHost::SBC_PMCacheEntryRemoved(UINT cacheIndex)
{
    LPSBC_FASTPATH_ENTRY pEntry;
    LPSBC_FASTPATH_ENTRY pNextEntry;

    DebugEntry(ASHost::SBC_PMCacheEntryRemoved);

    ASSERT(m_sbcFastPath);

    //
    // An entry has been removed from the color cache.  We have to remove
    // all entries from the fast path which reference this color table.
    //
    TRACE_OUT(( "Color table cache entry %d removed - removing references",
                 cacheIndex));

    pEntry = (LPSBC_FASTPATH_ENTRY)COM_BasedListFirst(&m_sbcFastPath->usedList, FIELD_OFFSET(SBC_FASTPATH_ENTRY, list));
    while (pEntry != NULL)
    {
        pNextEntry = (LPSBC_FASTPATH_ENTRY)COM_BasedListNext(&m_sbcFastPath->usedList, pEntry,
            FIELD_OFFSET(SBC_FASTPATH_ENTRY, list));

        if (pEntry->colorIndex == cacheIndex)
        {
            COM_BasedListRemove(&pEntry->list);
            COM_BasedListInsertAfter(&m_sbcFastPath->freeList, &pEntry->list);
        }

        pEntry = pNextEntry;
    }

    DebugExitVOID(ASHost::SBC_PMCacheEntryRemoved);
}




//
//
// Name:      SBCInitInternalOrders
//
// Purpose:   Allocate memory for the internal orders used during MEMBLT
//            order processing.
//
// Returns:   TRUE if initialized OK, FALSE otherwise.
//
// Params:    None
//
// Operation: If successful, this function initializes the following
//
//              g_Share->sbcOrderInfo
//
//
BOOL  ASHost::SBCInitInternalOrders(void)
{
    BOOL                initOK = FALSE;
    UINT                orderSize;
    LPINT_ORDER_HEADER  pOrderHeader;

    DebugEntry(ASHost::SBCInitInternalOrders);

    //
    // Start with the bitmap bits order.  Calculate the number of bytes
    // required to store the bits for the largest bitmap bits order we will
    // ever send.  This includes room for the compression header which gets
    // added before the bits if the data is compressed.
    //
    if (g_usrCaptureBPP >= 24)
    {
        // Can possibly send 24bpp TRUE COLOR data
        m_sbcOrderInfo.bitmapBitsDataSize =
            BYTES_IN_BITMAP(MP_LARGE_TILE_WIDTH, MP_LARGE_TILE_HEIGHT, 24)
            + sizeof(CD_HEADER);
    }
    else
    {
        // Can't send 24bpp TRUE color data
        m_sbcOrderInfo.bitmapBitsDataSize =
            BYTES_IN_BITMAP(MP_LARGE_TILE_WIDTH, MP_LARGE_TILE_WIDTH, 8)
            + sizeof(CD_HEADER);
    }

    //
    // Now allocate memory for the bitmap bits order.  The size required
    // is:
    //   The size of an INT_ORDER_HEADER (this is added in by OA when you
    //   call OA_AllocOrderMem)
    //   + the size of the largest BMC_BITMAP_BITS_ORDER structure
    //   + the number of bytes required for the bitmap bits
    //   + contingency for RLE compression overruns !
    //
    orderSize = sizeof(INT_ORDER_HEADER)
              + sizeof(BMC_BITMAP_BITS_ORDER_R2)
              + m_sbcOrderInfo.bitmapBitsDataSize
              + 4;

    TRACE_OUT(( "Allocating %d bytes for SBC bitmap bits order (bits %d)",
                 orderSize,
                 m_sbcOrderInfo.bitmapBitsDataSize));

    m_sbcOrderInfo.pBitmapBitsOrder = (LPINT_ORDER)new BYTE[orderSize];
    if (!m_sbcOrderInfo.pBitmapBitsOrder)
    {
        ERROR_OUT((
               "Failed to alloc %d bytes for SBC bitmap bits order (bits %d)",
               orderSize,
               m_sbcOrderInfo.bitmapBitsDataSize));
        DC_QUIT;
    }

    //
    // Initialize the INT_ORDER_HEADER - this is normally done in
    // OA_AllocOrderMem().  For the bitmap bits order, we can't fill in the
    // orderLength because it is not a fixed size - this has to be done
    // later when we fill in the bitmap bits.  Note that the order length
    // excludes the size of the INT_ORDER_HEADER.
    //
    pOrderHeader = &m_sbcOrderInfo.pBitmapBitsOrder->OrderHeader;
    pOrderHeader->additionalOrderData         = 0;
    pOrderHeader->cbAdditionalOrderDataLength = 0;

    //
    // Now the color table order.  The size required is:
    //   The size of an INT_ORDER_HEADER (this is added in by OA when you
    //   call OA_AllocOrderMem)
    //   + the size of a BMC_COLOR_TABLE_ORDER structure
    //   + the number of bytes required for the color table entries (note
    //     that the BMC_COLOR_TABLE_ORDER structure contains the first
    //     color table entry, so adjust the number of extra bytes required)
    //

    // Color tables are only for 8bpp and less.
    orderSize = sizeof(INT_ORDER_HEADER)
              + sizeof(BMC_COLOR_TABLE_ORDER)
              + (COLORS_FOR_BPP(8) - 1) * sizeof(TSHR_RGBQUAD);

    TRACE_OUT(( "Allocating %d bytes for SBC color table order", orderSize));

    m_sbcOrderInfo.pColorTableOrder = (LPINT_ORDER)new BYTE[orderSize];
    if (!m_sbcOrderInfo.pColorTableOrder)
    {
        ERROR_OUT(( "Failed to alloc %d bytes for SBC color table order",
                     orderSize));
        DC_QUIT;
    }

    pOrderHeader = &m_sbcOrderInfo.pColorTableOrder->OrderHeader;
    pOrderHeader->additionalOrderData         = 0;
    pOrderHeader->cbAdditionalOrderDataLength = 0;
    pOrderHeader->Common.cbOrderDataLength    = (WORD)(orderSize - sizeof(INT_ORDER_HEADER));

    //
    // Fill in the remaining fields in m_sbcOrderInfo
    //
    m_sbcOrderInfo.pOrder         = NULL;
    m_sbcOrderInfo.validData      = FALSE;
    m_sbcOrderInfo.sentColorTable = FALSE;
    m_sbcOrderInfo.sentBitmapBits = FALSE;
    m_sbcOrderInfo.sentMemBlt     = FALSE;

    //
    // Must be OK to get to here
    //
    initOK = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(ASHost::SBCInitInternalOrders, initOK);
    return(initOK);
}


//
//
// Name:      SBCFreeInternalOrders
//
// Purpose:   Free up the internal orders used by SBC during MEMBLT order
//            processing.
//
// Returns:   Nothing
//
// Params:    None
//
//
void  ASHost::SBCFreeInternalOrders(void)
{
    DebugEntry(ASHost::SBCFreeInternalOrders);

    //
    // First free up the memory.
    //
    if (m_sbcOrderInfo.pBitmapBitsOrder)
    {
        delete m_sbcOrderInfo.pBitmapBitsOrder;
        m_sbcOrderInfo.pBitmapBitsOrder = NULL;
    }

    if (m_sbcOrderInfo.pColorTableOrder)
    {
        delete m_sbcOrderInfo.pColorTableOrder;
        m_sbcOrderInfo.pColorTableOrder = NULL;
    }

    //
    // Now reset the remaining fields in m_sbcOrderInfo
    //
    m_sbcOrderInfo.pOrder             = NULL;
    m_sbcOrderInfo.validData          = FALSE;
    m_sbcOrderInfo.sentColorTable     = FALSE;
    m_sbcOrderInfo.sentBitmapBits     = FALSE;
    m_sbcOrderInfo.bitmapBitsDataSize = 0;

    DebugExitVOID(ASHost::SBCFreeInternalOrders);
}





//
//
// Name:      SBCInitFastPath
//
// Purpose:   Initialize the SBC fast path
//
// Returns:   TRUE if successful, FALSE otherwise
//
// Params:    None
//
//
BOOL  ASHost::SBCInitFastPath(void)
{
    BOOL    rc = FALSE;

    DebugEntry(ASHost::SBCInitFastPath);

    m_sbcFastPath = new SBC_FASTPATH;
    if (!m_sbcFastPath)
    {
        ERROR_OUT(("Failed to alloc m_sbcFastPath"));
        DC_QUIT;
    }

    SET_STAMP(m_sbcFastPath, SBCFASTPATH);

    //
    // Initialize the structure.
    //
    SBC_CacheCleared();

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::SBCInitFastPath, rc);
    return(rc);
}


//
//
// Name:      SBCGetTileData
//
// Purpose:   Given the ID of a tile data entry in one of the SBC shunt
//            buffers, return a pointer to the entry with that ID.
//
// Returns:   TRUE if the entry is found, FALSE otherwise
//
// Params:    IN  tileId     - The ID of the shunt buffer entry to be
//                             found.
//            OUT ppTileData - A pointer to the start of the shunt buffer
//                             entry (if found)
//            OUT pTileType  - The type of shunt buffer entry found.  One
//                             of:
//                                 SBC_MEDIUM_TILE
//                                 SBC_LARGE_TILE
//
//
BOOL  ASHost::SBCGetTileData
(
    UINT                tileId,
    LPSBC_TILE_DATA *   ppTileData,
    LPUINT              pTileType
)
{
    BOOL                gotTileData = FALSE;
    UINT                workTile;
    LPSBC_TILE_DATA     pWorkTile;

    DebugEntry(ASHost::SBCGetTileData);

    TRACE_OUT(( "Looking for tile Id %x", tileId));

    //
    // Find out which of the shunt buffers the entry should be in.
    //
    *pTileType = SBC_TILE_TYPE(tileId);

    //
    // We implement the shunt buffers as circular FIFO queues, so in
    // general, we are looking for the entry following the last one which
    // we found.  However, this wont always be the case because we do some
    // out of order processing when we do spoiling.
    //
    // So, get the index of the last tile we accessed.
    //
    workTile = m_asbcWorkInfo[*pTileType].mruIndex;

    //
    // OK, so lets go for it !  Start at the tile following the last one we
    // accessed, and loop through the circular buffer until we get a match,
    // or have circled back to the beginning.
    //
    // Note that this has been coded as a "do while" loop, rather than just
    // a "while" loop so that we don't miss mruTile.
    //
    do
    {
        //
        // On to the next tile
        //
        workTile++;
        if (workTile == m_asbcWorkInfo[*pTileType].pShuntBuffer->numEntries)
        {
            workTile = 0;
        }

        pWorkTile = SBCTilePtrFromIndex(m_asbcWorkInfo[*pTileType].pShuntBuffer,
                                        workTile);

        if (pWorkTile->inUse)
        {
            if (pWorkTile->tileId == tileId)
            {
                //
                // We've got a match.
                //
                TRACE_OUT(( "Matched tile Id %x at index %d",
                             tileId,
                             workTile));
                *ppTileData                      = pWorkTile;
                gotTileData                      = TRUE;
                m_asbcWorkInfo[*pTileType].mruIndex = workTile;
                DC_QUIT;
            }
        }
    }
    while (workTile != m_asbcWorkInfo[*pTileType].mruIndex);

    //
    // If we get to here, we've not found a match.
    //
    TRACE_OUT(( "No match for tile Id %x", tileId));

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::SBCGetTileData, gotTileData);
    return(gotTileData);
}




//
//
// Name:      SBCCacheColorTable
//
// Purpose:   Ensure that the given color table is cached.
//
// Returns:   TRUE if the color table is cached successfully, FALSE
//            otherwise.
//
// Params:    IN  pOrder      - A pointer to a color table order to be
//                              filled in.
//            IN  pColorTable - A pointer to the start of the color table
//                              to be cached.
//            IN  numColors   - The number of colors in the color table.
//            OUT pCacheIndex - The index of the cached color table.
//            OUT pIsNewEntry - TRUE if we added a new cache entry,
//                              FALSE if we matched an existing entry.
//
// Operation: pOrder is only filled in if *pIsNewEntry is FALSE.
//
//
BOOL  ASHost::SBCCacheColorTable
(
    LPINT_ORDER     pOrder,
    LPTSHR_RGBQUAD  pColorTable,
    UINT            numColors,
    UINT *          pCacheIndex,
    LPBOOL          pIsNewEntry
)
{
    BOOL                  cachedOK = FALSE;
    UINT                  cacheIndex;
    PBMC_COLOR_TABLE_ORDER  pColorTableOrder;

    DebugEntry(ASHost::SBCCacheColorTable);

    //
    // Call PM to do the caching.
    //
    if (!PM_CacheTxColorTable(&cacheIndex,
                              pIsNewEntry,
                              numColors,
                              pColorTable))
    {
        ERROR_OUT(( "Failed to cache color table"));
        DC_QUIT;
    }

    //
    // If the cache operation resulted in a cache update then we have to
    // fill in the color table order.
    //
    if (*pIsNewEntry)
    {
        //
        // The color table is new so we have to transmit it
        //
        TRACE_OUT(( "New color table"));

        pOrder->OrderHeader.Common.fOrderFlags = OF_PRIVATE;
        pColorTableOrder = (PBMC_COLOR_TABLE_ORDER)(pOrder->abOrderData);
        pColorTableOrder->bmcPacketType  = BMC_PT_COLOR_TABLE;
        pColorTableOrder->colorTableSize = (TSHR_UINT16)numColors;
        pColorTableOrder->index          = (BYTE)cacheIndex;

        //
        // Copy the new color table into the Order Packet.
        //
        memcpy(pColorTableOrder->data, pColorTable,
                  numColors * sizeof(TSHR_RGBQUAD));
    }
    else
    {
        TRACE_OUT(( "Existing color table"));
    }

    //
    // Return the color table index to the caller
    //
    *pCacheIndex = cacheIndex;
    cachedOK     = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::SBCCacheColorTable, cachedOK);
    return(cachedOK);
}


//
//
// Name:      SBCCacheBits
//
// Purpose:   This function adds the supplied bitmap bits to a bitmap
//            cache.  The cache selected depends on the bitmap size, but
//            may be different for R1 and R2.  SBCSelectCache handles the
//            determination of the correct cache.
//
// Returns:   TRUE if the bits have been cached OK, FALSE otherwise
//
// Params:    IN  pOrder           - A pointer to a BMC order.
//            IN  destBitsSize     - The number of bytes available in
//                                   pOrder to store the bitmap data.
//            IN  pDIBits          - A pointer to the bits to be cached.
//            IN  bitmapWidth      - The "in use" width of the bitmap
//            IN  fixedBitmapWidth - The actual width of the bitmap
//            IN  bitmapHeight     - The height of the bitmap
//            IN  numBytes         - The number of bytes in the bitmap.
//            OUT pCache           - The cache that we put the bits into.
//            OUT pCacheIndex      - The cache index within *pCache at
//                                   which we cached the data.
//            OUT pIsNewEntry      - TRUE if we added a new cache entry,
//                                   FALSE if we matched an existing entry.
//
// Operation: pOrder is only filled in if *pIsNewEntry is FALSE.
//
//
BOOL  ASHost::SBCCacheBits
(
    LPINT_ORDER     pOrder,
    UINT            destBitsSize,
    LPBYTE          pDIBits,
    UINT            bitmapWidth,
    UINT            fixedBitmapWidth,
    UINT            bitmapHeight,
    UINT            numBytes,
    UINT *          pCache,
    UINT *          pCacheIndex,
    LPBOOL          pIsNewEntry
)
{
    BOOL                        cachedOK = FALSE;
    UINT                        cacheIndex;
    UINT                        i;
    LPBYTE                      pCompressed;
    UINT                        compressedSize;
    BOOL                        compressed;
    PBMC_DIB_ENTRY              pEntry;
    PBMC_DIB_CACHE              pCacheHdr;
    PBMC_BITMAP_BITS_ORDER_R2   pBitsOrderR2;
    PBMC_BITMAP_BITS_DATA       pBmcData;
    LPBYTE                      pDestBits;

    DebugEntry(ASHost::SBCCacheBits);

    pBmcData     = (PBMC_BITMAP_BITS_DATA)(pOrder->abOrderData);
    pBitsOrderR2 = (PBMC_BITMAP_BITS_ORDER_R2)pBmcData;

    //
    // Get a pointer to where the bitmap data starts in the order.  This
    // depends on whether it is an R1 or an R2 bitmap bits order.
    //
    pDestBits = pBitsOrderR2->data;

    //
    // Before we can select a cache entry we need to compress the bits.
    // This therefore mandates a memcpy into the cache entry when we come
    // to add it.  The saving in memory by storing the bits compressed
    // makes it all worthwhile.
    //
    // Compress the bitmap data.  At this stage we don't know whether the
    // bitmap will compress well or not, so allow cells that are larger
    // than our maximum cell size.  The largest we expect to see is 120*120*
    // 24.
    //
    compressedSize = destBitsSize;
    if (m_pShare->BC_CompressBitmap(pDIBits, pDestBits, &compressedSize,
            fixedBitmapWidth, bitmapHeight, m_usrSendingBPP,
            NULL ) &&
        (compressedSize < numBytes))

    {
        TRACE_OUT(( "Compressed bmp data from %u bytes to %u bytes",
                     numBytes,
                     compressedSize));
        compressed  = TRUE;
        pCompressed = pDestBits;
    }
    else
    {
        //
        // The bitmap could not be compressed, or bitmap compression is not
        // enabled.  Send the bitmap uncompressed.
        //
        compressed     = FALSE;
        compressedSize = numBytes;
        pCompressed    = pDIBits;
    }

    //
    // Make sure that the data will fit into the order.  Do this after
    // compression since it is possible that the uncompressed data will not
    // fit, but the compressed version will.
    //
    if (compressedSize > destBitsSize)
    {
        WARNING_OUT(( "Data (%d bytes) does not fit into order (%d bytes)",
                     compressedSize,
                     destBitsSize));
        DC_QUIT;
    }

    //
    // Select the cache based on the compressed size - we pass in the
    // sub-bitmap dimensions for R1 caching; R2 caching just uses the
    // total size of the bits.
    //
    if (!SBCSelectCache(compressedSize + sizeof(BMC_DIB_ENTRY) - 1, pCache))
    {
        TRACE_OUT(( "No cache selected"));
        DC_QUIT;
    }
    else
    {
        TRACE_OUT(( "Selected cache %d", *pCache));
    }

    //
    // Find a free cache entry in our selected cache
    //
    // We arrange that our transmit cache is always one greater than the
    // negotiated cache size so that we should never fail to find a free
    // array entry.  Once we have fully populated our Tx cache we will
    // always find the free entry as the one last given back to us by CH.
    // Note the scan to <= sbcTxCache[pmNumTxCacheEntries is NOT a mistake.
    //
    pCacheHdr = &(m_asbcBmpCaches[*pCache]);
    if (pCacheHdr->data == NULL)
    {
        ERROR_OUT(( "Asked to cache when no cache allocated"));
        DC_QUIT;
    }

    //
    // If the cache has returned an entry to us then use that without
    // having to scan.  This will be the default mode for adding entries
    // to a fully populated cache.
    //
    if (pCacheHdr->freeEntry != NULL)
    {
        pEntry               = pCacheHdr->freeEntry;
        pCacheHdr->freeEntry = NULL;
        TRACE_OUT(( "Cache fully populated - using entry 0x%08x", pEntry));
    }
    else
    {
        //
        // We are in the process of feeding the cache so we need to search
        // for a free entry
        //
        pEntry = (PBMC_DIB_ENTRY)(pCacheHdr->data);
        for (i=0 ; i < pCacheHdr->cEntries ; i++)
        {
            if (!pEntry->inUse)
            {
                break;
            }
            pEntry = (PBMC_DIB_ENTRY)(((LPBYTE)pEntry) + pCacheHdr->cSize);
        }

        //
        // We should never run out of free entries, but cope with it
        //
        if (i == pCacheHdr->cEntries)
        {
            ERROR_OUT(( "All Tx DIB cache entries in use"));
            DC_QUIT;
        }
    }

    //
    // Set up the DIB entry for caching
    //
    pEntry->inUse       = TRUE;
    pEntry->cx          = (TSHR_UINT16)bitmapWidth;
    pEntry->cxFixed     = (TSHR_UINT16)fixedBitmapWidth;
    pEntry->cy          = (TSHR_UINT16)bitmapHeight;
    pEntry->bpp         = (TSHR_UINT16)m_usrSendingBPP;
    pEntry->cBits       = numBytes;
    pEntry->bCompressed = (BYTE)compressed;
    pEntry->cCompressed = compressedSize;
    memcpy(pEntry->bits, pCompressed, compressedSize);

    //
    // Now cache the data
    //
    if (CH_SearchAndCacheData(pCacheHdr->handle,
                              (LPBYTE)pEntry,
                              sizeof(BMC_DIB_ENTRY) + compressedSize - 1,
                              0,
                              &cacheIndex))
    {
        //
        // The sub-bitmap is already in the cache
        //
        *pCacheIndex = cacheIndex;
        TRACE_OUT(( "Bitmap already cached %u:%u cx(%d) cy(%d)",
                     *pCache,
                     *pCacheIndex,
                     bitmapWidth,
                     bitmapHeight));
        *pIsNewEntry = FALSE;

        //
        // Free up the entry we just created
        //
        pEntry->inUse = FALSE;
    }
    else
    {
        *pCacheIndex = cacheIndex;
        TRACE_OUT(( "Cache entry at 0x%08x now in use", pEntry));
        TRACE_OUT(( "New cache entry %u:%u cx(%d) cy(%d)",
                     *pCache,
                     *pCacheIndex,
                     bitmapWidth,
                     bitmapHeight));
        *pIsNewEntry        = TRUE;
        pEntry->iCacheIndex = (TSHR_UINT16)*pCacheIndex;
    }

    //
    // We've got the bits into the cache.  If the cache attempt added a
    // cache entry we must fill in the bitmap cache order.
    //
    if (*pIsNewEntry)
    {
        //
        // Fill in the order details.
        //
        // Remember that we have to fill in the order size into the
        // INT_ORDER_HEADER as well as filling in the bitmap bits order
        // header.  When doing this, adjust for the number of bitmap bits
        // which are included in the bitmap bits order header.
        //
        pOrder->OrderHeader.Common.fOrderFlags = OF_PRIVATE;

        if (compressed)
        {
            pBmcData->bmcPacketType = BMC_PT_BITMAP_BITS_COMPRESSED;
        }
        else
        {
            pBmcData->bmcPacketType = BMC_PT_BITMAP_BITS_UNCOMPRESSED;

            //
            // The data is not compressed, so copy the uncompressed data
            // into the order.  In the case where we compressed the data
            // successfully, we did so directly into the order, so the
            // compressed bits are already there.
            //
            memcpy(pDestBits, pDIBits, compressedSize);
        }

        pBmcData->cacheID           = (BYTE)*pCache;
        pBmcData->cxSubBitmapWidth  = (TSHR_UINT8)fixedBitmapWidth;
        pBmcData->cySubBitmapHeight = (TSHR_UINT8)bitmapHeight;
        pBmcData->bpp               = (TSHR_UINT8)m_usrSendingBPP;
        pBmcData->cbBitmapBits      = (TSHR_UINT16)compressedSize;

        //
        // The iCacheEntryR1 field is unused for R2 - we use
        // iCacheEntryR2 instead.
        //
        pBmcData->iCacheEntryR1     = 0;
        pBitsOrderR2->iCacheEntryR2 = (TSHR_UINT16)*pCacheIndex;

        pOrder->OrderHeader.Common.cbOrderDataLength =
                                       (compressedSize
                                        + sizeof(BMC_BITMAP_BITS_ORDER_R2)
                                        - sizeof(pBitsOrderR2->data));
    }

    cachedOK = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::SBCCacheBits, cachedOK);
    return(cachedOK);
}


//
//
// Name:      SBCAddToFastPath
//
// Purpose:   Add a bitmap to the fast path
//
// Returns:   Nothing
//
// Params:    IN majorInfo       - The major caching info passed up from
//                                 the driver (the bitmap ID)
//            IN minorInfo       - The minor caching info passed up from
//                                 the driver (the bitmap revision number)
//            IN majorPalette    - The major palette info passed up from
//                                 the driver (the XLATEOBJ)
//            IN minorPalette    - The minor palette info passed up from
//                                 the driver (the XLATEOBJ iUniq)
//            IN srcX            - The x coord of the source of the Blt
//            IN srcY            - The y coord of the source of the Blt
//            IN width           - The width of the area being Blted
//            IN height          - The height of the area being Blted
//            IN cache           - The cache the bits were placed in
//            IN cacheIndex      - The index at which the bits were placed
//                                 in the cache
//            IN colorCacheIndex - The index in the color table cache of
//                                 the color table associated with the bits
//
//
void  ASHost::SBCAddToFastPath
(
    UINT_PTR        majorInfo,
    UINT            minorInfo,
    UINT_PTR        majorPalette,
    UINT            minorPalette,
    int             srcX,
    int             srcY,
    UINT            width,
    UINT            height,
    UINT            cache,
    UINT            cacheIndex,
    UINT            colorCacheIndex
)
{
    LPSBC_FASTPATH_ENTRY pEntry;

    DebugEntry(ASHost::SBCAddToFastPath);

    //
    // First get a free entry
    //
    pEntry = (LPSBC_FASTPATH_ENTRY)COM_BasedListFirst(&m_sbcFastPath->freeList,
        FIELD_OFFSET(SBC_FASTPATH_ENTRY, list));
    if (pEntry == NULL)
    {
        //
        // There are no entries in the free list, so we have to use the
        // oldest entry in the used list.  The used list is stored in MRU
        // order, so we just have to get the last item in the list.
        //
        pEntry = (LPSBC_FASTPATH_ENTRY)COM_BasedListLast(&m_sbcFastPath->usedList,
            FIELD_OFFSET(SBC_FASTPATH_ENTRY, list));
        TRACE_OUT(( "Evicting fast path info for %x %x (%d, %d)",
                     pEntry->majorInfo,
                     pEntry->minorInfo,
                     pEntry->srcX,
                     pEntry->srcY));
    }

    //
    // Remove the entry from its current list
    //
    COM_BasedListRemove(&pEntry->list);

    //
    // Now fill in the details
    //
    pEntry->majorInfo    = majorInfo;
    pEntry->minorInfo    = minorInfo;
    pEntry->majorPalette = majorPalette;
    pEntry->minorPalette = minorPalette;
    pEntry->srcX         = srcX;
    pEntry->srcY         = srcY;
    pEntry->width        = width;
    pEntry->height       = height;
    pEntry->cache        = (WORD)cache;
    pEntry->cacheIndex   = (WORD)cacheIndex;
    pEntry->colorIndex   = (WORD)colorCacheIndex;

    //
    // Finally, add the entry to the front of the used list
    //
    TRACE_OUT(( "Adding fast path info for %x %x (%d, %d)",
                 pEntry->majorInfo,
                 pEntry->minorInfo,
                 pEntry->srcX,
                 pEntry->srcY));
    COM_BasedListInsertAfter(&m_sbcFastPath->usedList, &pEntry->list);

    DebugExitVOID(ASHost::SBCAddToFastPath);
}


//
//
// Name:      SBCFindInFastPath
//
// Purpose:   Check to see if a bitmap with the given attributes is in the
//            SBC fast path.  If so, return the cache info for the bitmap.
//
// Returns:   TRUE if the bitmap is in the fast path, FALSE if not.
//
// Params:    IN  majorInfo        - The major caching info passed up from
//                                   the driver (the bitmap ID)
//            IN  minorInfo        - The minor caching info passed up from
//                                   the driver (the bitmap revision
//                                   number)
//            IN  majorPalette     - The major palette info passed up from
//                                   the driver (the XLATEOBJ)
//            IN  minorPalette     - The minor palette info passed up from
//                                   the driver (the XLATEOBJ iUniq)
//            IN  srcX             - The x coord of the source of the Blt
//            IN  srcY             - The y coord of the source of the Blt
//            IN  width            - The width of the area being Blted
//            IN  height           - The height of the area being Blted
//            OUT pCache           - The cache the bits were placed in
//            OUT pCacheIndex      - The index at which the bits were
//                                   placed in the cache
//            OUT pColorCacheIndex - The index in the color table cache of
//                                   the color table associated with the
//                                   bits
//
// Operation: The contents of pCache, pCacheIndex and pColorCacheIndex
//            are only valid on return if the function returns TRUE.
//
//
BOOL  ASHost::SBCFindInFastPath
(
    UINT_PTR        majorInfo,
    UINT            minorInfo,
    UINT_PTR        majorPalette,
    UINT            minorPalette,
    int             srcX,
    int             srcY,
    UINT            width,
    UINT            height,
    UINT *          pCache,
    UINT *          pCacheIndex,
    UINT *          pColorCacheIndex
)
{
    BOOL              found = FALSE;
    LPSBC_FASTPATH_ENTRY pEntry;
    LPSBC_FASTPATH_ENTRY pNextEntry;

    DebugEntry(ASHost::SBCFindInFastPath);

    //
    // Traverse the in use list looking for a match on the parameters
    // passed in.
    //
    pEntry = (LPSBC_FASTPATH_ENTRY)COM_BasedListFirst(&m_sbcFastPath->usedList, FIELD_OFFSET(SBC_FASTPATH_ENTRY, list));
    while (pEntry != NULL)
    {
        if ((pEntry->majorInfo    == majorInfo)    &&
            (pEntry->minorInfo    == minorInfo)    &&
            (pEntry->majorPalette == majorPalette) &&
            (pEntry->minorPalette == minorPalette) &&
            (pEntry->srcX         == srcX)         &&
            (pEntry->srcY         == srcY)         &&
            (pEntry->width        == width)        &&
            (pEntry->height       == height))
        {
            //
            // We've found a match - hurrah !  Fill in the return info.
            //
            TRACE_OUT(( "Hit for %x %x (%d, %d) cache %d",
                         pEntry->majorInfo,
                         pEntry->minorInfo,
                         pEntry->srcX,
                         pEntry->srcY,
                         pEntry->cache,
                         pEntry->cacheIndex));

            found             = TRUE;
            *pCache           = pEntry->cache;
            *pCacheIndex      = pEntry->cacheIndex;
            *pColorCacheIndex = pEntry->colorIndex;

            //
            // We order the used list in MRU order, so remove the entry
            // from its current position and add it at the head of the used
            // list.
            //
            COM_BasedListRemove(&pEntry->list);
            COM_BasedListInsertAfter(&m_sbcFastPath->usedList, &pEntry->list);

            //
            // Got a match, so we can break out of the while loop
            //
            break;
        }
        else if ((pEntry->majorInfo == majorInfo) &&
                 (pEntry->minorInfo != minorInfo))
        {
            //
            // We have been given a bitmap which we have seen before, but
            // the revision number has changed i.e.  the bitmap has been
            // updated (majorInfo identifies the bitmap, and minorInfo
            // identifies the revision number of that bitmap - it is
            // incremented every time the bitmap is changed).
            //
            // We have to remove all entries from the used list which
            // reference this bitmap.  We can start from the current
            // position since we know that we can't have an entry for this
            // bitmap earlier in the list, but we have to be careful to get
            // the next entry in the list before removing an entry.
            //
            TRACE_OUT(( "Bitmap %x updated - removing references",
                         pEntry->majorInfo));
            pNextEntry = pEntry;

            while (pNextEntry != NULL)
            {
                pEntry = pNextEntry;

                pNextEntry = (LPSBC_FASTPATH_ENTRY)COM_BasedListNext(&m_sbcFastPath->usedList,
                    pNextEntry, FIELD_OFFSET(SBC_FASTPATH_ENTRY, list));

                if (pEntry->majorInfo == majorInfo)
                {
                    COM_BasedListRemove(&pEntry->list);
                    COM_BasedListInsertAfter(&m_sbcFastPath->freeList,
                                        &pEntry->list);
                }
            }

            //
            // We know we wont find a match, so we can break out of the
            // while loop
            //
            break;
        }

        pEntry = (LPSBC_FASTPATH_ENTRY)COM_BasedListNext(&m_sbcFastPath->usedList, pEntry,
            FIELD_OFFSET(SBC_FASTPATH_ENTRY, list));
    }

    DebugExitBOOL(ASShare::SBCFindInFastPath, found);
    return(found);
}





//
// SBC_CacheEntryRemoved()
//
void  ASHost::SBC_CacheEntryRemoved
(
    UINT    cache,
    UINT    cacheIndex
)
{
    LPSBC_FASTPATH_ENTRY pEntry;
    LPSBC_FASTPATH_ENTRY pNextEntry;

    DebugEntry(ASHost::SBC_CacheEntryRemoved);

    ASSERT(m_sbcFastPath);

    //
    // An entry has been removed from the cache.  If we have this entry in
    // our fast path, we have to remove it.
    //
    // Just traverse the used list looking for an entry with matching cache
    // and cacheIndex.  Note that there may be more than one entry - if the
    // source bitmap has a repeating image, we will get a match on the bits
    // when we cache different areas of the bitmap.
    //
    pNextEntry = (LPSBC_FASTPATH_ENTRY)COM_BasedListFirst(&m_sbcFastPath->usedList,
        FIELD_OFFSET(SBC_FASTPATH_ENTRY, list));
    while (pNextEntry != NULL)
    {
        pEntry = pNextEntry;

        pNextEntry = (LPSBC_FASTPATH_ENTRY)COM_BasedListNext(&m_sbcFastPath->usedList,
            pNextEntry, FIELD_OFFSET(SBC_FASTPATH_ENTRY, list));

        if ((pEntry->cache == cache) && (pEntry->cacheIndex == cacheIndex))
        {
            //
            // Move the entry to the free list
            //
            TRACE_OUT(("Fast path entry %x %x (%d, %d) evicted from cache",
                     pEntry->majorInfo,
                     pEntry->minorInfo,
                     pEntry->srcX,
                     pEntry->srcY));
            COM_BasedListRemove(&pEntry->list);
            COM_BasedListInsertAfter(&m_sbcFastPath->freeList,
                                &pEntry->list);
        }
    }

    DebugExitVOID(ASHost::SBC_CacheEntryRemoved);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\sch.cpp ===
#include "precomp.h"


//
// SCH.CPP
// Scheduler
//
// Copyright(c) Microsoft Corporation 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE

//
//
// SCH_Init - see sch.h
//
//
BOOL  SCH_Init(void)
{
    BOOL    rc = FALSE;

    DebugEntry(SCH_Init);

    ASSERT(!g_schEvent);
    ASSERT(!g_schThreadID);
    ASSERT(!g_schMessageOutstanding);

    //
    // Create g_schEvent with:
    // - default security descriptor
    // - auto-reset (resets when a thread is unblocked)
    // - initially signalled
    //
    g_schEvent = CreateEvent( NULL, FALSE, TRUE, SCH_EVENT_NAME );
    if (g_schEvent == NULL)
    {
        ERROR_OUT(( "Failed to create g_schEvent"));
        DC_QUIT;
    }

    InitializeCriticalSection(&g_schCriticalSection);

    g_schCurrentMode = SCH_MODE_ASLEEP;

    // lonchanc: do not start the scheduler as default
    // SCHSetMode(SCH_MODE_NORMAL);
    if (!DCS_StartThread(SCH_PacingProcessor))
    {
        ERROR_OUT(( "Failed to create SCH_PacingProcessor thread"));
        DC_QUIT;
    }

    ASSERT(g_schThreadID);
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SCH_Init, rc);
    return(rc);
}


//
//
// SCH_Term - see sch.h
//
//
void  SCH_Term(void)
{
    DebugEntry(SCH_Term);

    //
    // This code needs to work even if SCH_Init hasn't been called or
    // failed in the middle.
    //
    if (g_schEvent)
    {
        if (g_schThreadID)
        {
            //
            // The scheduler thread exits its main loop when it spots that
            // g_schTerminating is TRUE.  So all we have to do is ensure
            // that it runs its loop at least once more...  It will clear g_schTerm-
            // inated just before exiting.
            //
            g_schTerminating = TRUE;
            SCH_ContinueScheduling(SCH_MODE_NORMAL);
            while (g_schTerminating)
            {
                Sleep(0);
            }

            ASSERT(!g_schThreadID);
            TRACE_OUT(("sch thread terminated"));

            //
            // Make sure we clear the message outstanding variable when
            // our thread exits.
            //
            g_schMessageOutstanding = FALSE;
        }

        DeleteCriticalSection(&g_schCriticalSection);

        CloseHandle(g_schEvent);
        g_schEvent = NULL;
    }

    DebugExitVOID(SCH_Term);
}


//
//
// SCH_ContinueScheduling - see sch.h
//
//
void  SCH_ContinueScheduling(UINT schedulingMode)
{
    DebugEntry(SCH_ContinueScheduling);

    ASSERT( ((schedulingMode == SCH_MODE_NORMAL) ||
                 (schedulingMode == SCH_MODE_TURBO)));

    EnterCriticalSection(&g_schCriticalSection); // lonchanc: need crit sect protection

    if (g_schCurrentMode == SCH_MODE_TURBO)
    {
        if (schedulingMode == SCH_MODE_TURBO)
        {
            SCHSetMode(schedulingMode);
        }
        DC_QUIT;
    }

    if (schedulingMode != g_schCurrentMode)
    {
        SCHSetMode(schedulingMode);
    }

DC_EXIT_POINT:
    g_schStayAwake = TRUE;

    LeaveCriticalSection(&g_schCriticalSection); // lonchanc: need crit sect protection

    DebugExitVOID(SCH_ContinueScheduling);
}


//
//
// SCH_SchedulingMessageProcessed - see sch.h
//
//
void  SCH_SchedulingMessageProcessed()
{
    DebugEntry(SCH_SchedulingMessageProcessed);

    g_schMessageOutstanding = FALSE;

    DebugExitVOID(SCH_SchedulingMessageProcessed);
}


//
// Name:      SCH_PacingProcessor
//
// Purpose:   The main function executed by the scheduling thread.
//
// Returns:   Zero.
//
// Params:    syncObject - object to pass back to SetEvent
//
// Operation: The thread enters a main loop which continues while the
//            scheduler is initialized.
//
//            The thread sets its priority to TIME_CRITICAL in order
//            that it runs as soon as possible when ready.
//
//            The thread waits on an event (g_schEvent) with a timeout that
//            is set according to the current scheduler mode.
//
//            The thread runs due to either:
//              - the timeout expiring, which is the normal periodic
//                scheduler behavior, or
//              - g_schEvent being signalled, which is how the scheduler is
//                woken from ASLEEP mode.
//
//            The thread then posts a scheduler message the the Share Core
//            (if there is not one already outstanding) and loops back
//            to wait on g_schEvent.
//
//            Changes in the scheduler mode are caused by calls to
//            SCH_ContinueScheduling updating variables accessed in this
//            routine, or by calculations made within the main loop of
//            this routine (e.g. TURBO mode timeout).
//
//
DWORD WINAPI SCH_PacingProcessor(LPVOID hEventWait)
{
    UINT        rc = 0;
    DWORD       rcWait;
    UINT        timeoutPeriod;

    DebugEntry(SCH_PacingProcessor);

    //
    // Give ourselves the highest possible priority (within our process
    // priority class) to ensure that we run regularly to keep the
    // scheduling messages flowing.
    //
    if (!SetThreadPriority( GetCurrentThread(),
                            THREAD_PRIORITY_TIME_CRITICAL ))
    {
        WARNING_OUT(( "SetThreadPriority failed"));
    }

    timeoutPeriod = g_schTimeoutPeriod;

    g_schThreadID = GetCurrentThreadId();

    //
    // Let the caller continue
    //
    SetEvent((HANDLE)hEventWait);

    //
    // Keep looping until the scheduler terminates.
    //
    while (!g_schTerminating)
    {
        //
        // Wait on g_schEvent with a timeout value that is set according
        // to the current scheduling mode.
        //
        // When we are active (NORMAL/TURBO scheduling) the timeout
        // period is a fraction of a second, so the normal behavior is
        // for this call to timeout, rather than be signalled.
        //
        rcWait = WaitForSingleObject(g_schEvent, timeoutPeriod);

        EnterCriticalSection(&g_schCriticalSection);

        if (g_schMessageOutstanding)
        {
            //
            // We must ensure that we post at least one scheduling message
            // before we can attempt to sleep - so force schStayAwake to
            // TRUE to keep us awake until we do post another message.
            //
            TRACE_OUT(( "Don't post message - one outstanding"));
            g_schStayAwake = TRUE;
        }

        //
        // If g_schEvent was signalled, then enter NORMAL scheduling mode.
        //
        if (rcWait == WAIT_OBJECT_0)
        {
            SCHSetMode(SCH_MODE_NORMAL);
        }
        else if (!g_schStayAwake)
        {
            TRACE_OUT(( "Sleep!"));
            SCHSetMode(SCH_MODE_ASLEEP);
        }
        else if ( (g_schCurrentMode == SCH_MODE_TURBO) &&
                  ((GetTickCount() - g_schLastTurboModeSwitch) >
                                                   SCH_TURBO_MODE_DURATION) )
        {
            //
            // Switch from turbo state back to normal state.
            //
            SCHSetMode(SCH_MODE_NORMAL);
        }

        //
        // Post the scheduling message - but only if there is not one
        // already outstanding.
        //
        if (!g_schMessageOutstanding && !g_schTerminating)
        {
            SCHPostSchedulingMessage();
            g_schStayAwake = FALSE;
        }

        timeoutPeriod = g_schTimeoutPeriod;

        LeaveCriticalSection(&g_schCriticalSection);
    }

    g_schThreadID = 0;
    g_schTerminating = FALSE;

    DebugExitDWORD(SCH_PacingProcessor, rc);
    return(rc);
}



//
// Name:      SCHPostSchedulingMessage
//
// Purpose:   Posts the scheduling message to the main Share Core window.
//
// Returns:   Nothing.
//
// Params:    None.
//
//
void  SCHPostSchedulingMessage(void)
{
    DebugEntry(SCHPostSchedulingMessage);

    if (PostMessage( g_asMainWindow, DCS_PERIODIC_SCHEDULE_MSG, 0, 0 ))
    {
        g_schMessageOutstanding = TRUE;
    }

    DebugExitVOID(SCHPostSchedulingMessage);
}


//
// Name:      SCHSetMode
//
// Purpose:   Sets the current scheduler mode - and wakes the scheduler
//            thread if necessary.
//
// Returns:   Nothing.
//
// Params:    newMode
//
//
void  SCHSetMode(UINT newMode)
{
    DebugEntry(SCHSetMode);

    ASSERT( ((newMode == SCH_MODE_ASLEEP) ||
                 (newMode == SCH_MODE_NORMAL) ||
                 (newMode == SCH_MODE_TURBO) ));

    EnterCriticalSection(&g_schCriticalSection);

    TRACE_OUT(( "Switching from state %u -> %u", g_schCurrentMode, newMode));

    if (newMode == SCH_MODE_TURBO)
    {
        g_schLastTurboModeSwitch = GetTickCount();
    }

    if (g_schCurrentMode == SCH_MODE_ASLEEP)
    {
        //
        // Wake up the scheduler.
        //
        TRACE_OUT(( "Waking up scheduler - SetEvent"));
        if (!SetEvent(g_schEvent))
        {
            ERROR_OUT(( "Failed SetEvent(%#x)", g_schEvent));
        }
    }

    g_schCurrentMode = newMode;
    g_schTimeoutPeriod = (newMode == SCH_MODE_ASLEEP) ? INFINITE :
                       ((newMode == SCH_MODE_NORMAL) ? SCH_PERIOD_NORMAL :
                                                            SCH_PERIOD_TURBO);

    LeaveCriticalSection(&g_schCriticalSection);

    DebugExitVOID(SCHSetMode);
}



//
// DCS_StartThread(...)
//
// See ut.h
//
// DESCRIPTION:
// ============
// Start a new thread.
//
// PARAMETERS:
// ===========
// entryFunction   : A pointer to the thread entry point.
// timeout         : timeout in milliseconds
//
// RETURNS:
// ========
// Nothing.
//
//
BOOL DCS_StartThread
(
    LPTHREAD_START_ROUTINE entryFunction
)
{
    BOOL            rc = FALSE;
    HANDLE          hndArray[2];
    DWORD           tid;
    DWORD           dwrc;

    DebugEntry(DCS_StartThread);
	
	//
	// The event handle ( hndArray[0] ) is initialized in the call to CreateEvent,
	// but in the case where that fails, we would try to CloseHandle on 
	// a garbage hndArray[1]. So we have to initialize the ThreadHandle
	//
	hndArray[1] = 0;

    //
    // Create event - initially non-signalled; manual control.
    //
    hndArray[0] = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (hndArray[0] == 0)
    {
        ERROR_OUT(("Failed to create event: sys rc %lu", GetLastError()));
        DC_QUIT;
    }
    TRACE_OUT(("Event 0x%08x created - now create thread", hndArray[0]));


    //
    // Start a new thread to run the DC-Share core task.
    // Use C runtime (which calls CreateThread) to avoid memory leaks.
    //
    hndArray[1] = CreateThread(NULL, 0, entryFunction, (LPVOID)hndArray[0],
        0, &tid);
    if (hndArray[1] == 0)
    {
        //
        // Failed!
        //
        ERROR_OUT(("Failed to create thread: sys rc %lu", GetLastError()));
        DC_QUIT;
    }
    TRACE_OUT(("Thread 0x%08x created - now wait signal", hndArray[1]));

    //
    // Wait for thread exit or event to be set.
    //
    dwrc = WaitForMultipleObjects(2, hndArray, FALSE, INFINITE);
    switch (dwrc)
    {
        case WAIT_OBJECT_0:
            //
            // Event triggered - thread initialised OK.
            //
            TRACE_OUT(("event signalled"));
            rc = TRUE;
            break;

        case WAIT_OBJECT_0 + 1:
            ERROR_OUT(("Thread exited with rc"));
            break;

        case WAIT_TIMEOUT:
            TRACE_OUT(("Wait timeout"));
            break;

        default:
            TRACE_OUT(("Wait returned %d", dwrc));
            break;
    }

DC_EXIT_POINT:
    //
    // Destroy event object.
    //
    if (hndArray[0] != 0)
    {
        TRACE_OUT(("Destroy event object"));
        CloseHandle(hndArray[0]);
    }

    //
    // Destroy thread handle object.
    //
    if (hndArray[1] != 0)
    {
        TRACE_OUT(("Destroy thread handle object"));
        CloseHandle(hndArray[1]);
    }

    DebugExitBOOL(DCS_StartThread, rc);
    return(rc);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\sdp.cpp ===
#include "precomp.h"


//
// SDP.CPP
// Screen Data Player
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE



//
// SDP_ReceivedPacket()
//
void  ASShare::SDP_ReceivedPacket
(
    ASPerson *      pasPerson,
    PS20DATAPACKET  pPacket
)
{
    PSDPACKET       pBitmap;
    LPBYTE          pBits;
    RECT            rectRDB;
    HRGN            regionRDB = NULL;

    DebugEntry(ASShare::SDP_ReceivedPacket);

    ValidateView(pasPerson);

    ASSERT(m_usrPBitmapBuffer);

    pBitmap = (PSDPACKET)pPacket;

    //
    // At some point, we'd like to be able to pass an ARRAY of screen
    // data blocks, if they'd fit in a packet of size TSHR_MAX_SEND_PKT
    //
    ASSERT(pBitmap->header.padding == 0);

    //
    // Now try to decompress the packet.
    //
    if (pBitmap->compressed)
    {
        if (!BD_DecompressBitmap(&(pBitmap->data[0]), m_usrPBitmapBuffer,
                pBitmap->dataSize, pBitmap->realWidth, pBitmap->realHeight,
                pBitmap->format))
        {
            //
            // Could not decompress.
            //
            ERROR_OUT(( "Could not decompress"));
            DC_QUIT;
        }
        else
        {
            pBits = m_usrPBitmapBuffer;
        }
    }
    else
    {
        pBits = pBitmap->data;
    }

    //
    // The position (like all protocol coordinates) is specified in virtual
    // desktop coordinates. Convert it to RDB coordinates.
    //
    RECT_FROM_TSHR_RECT16(&rectRDB, pBitmap->position);
    OffsetRect(&rectRDB, -pasPerson->m_pView->m_dsScreenOrigin.x,
        -pasPerson->m_pView->m_dsScreenOrigin.y);

    TRACE_OUT(("Received screen data rect {%d, %d, %d, %d}",
                 rectRDB.left,
                 rectRDB.top,
                 rectRDB.right,
                 rectRDB.bottom ));

    //
    // We must ensure that data written to the ScreenBitmap is not clipped
    // (any orders processed earlier will have used clipping).
    //
    OD_ResetRectRegion(pasPerson);

    //
    // Play screen data into the remote desktop bitmap.
    //
    SDPPlayScreenDataToRDB(pasPerson, pBitmap, pBits, &rectRDB);

    //
    // Construct a region equivalent to the update rectangle in RDB coords.
    // INCLUSIVE COORDS
    //
    regionRDB = CreateRectRgn(rectRDB.left, rectRDB.top,
        rectRDB.right + 1, rectRDB.bottom + 1);
    if (regionRDB == NULL)
    {
        ERROR_OUT(( "Failed to create region"));
        DC_QUIT;
    }

    //
    // Hatch the bitmap data area, if enabled.
    //
    if (m_usrHatchScreenData)
    {
        SDPDrawHatchedRegion(pasPerson->m_pView->m_usrDC, regionRDB, USR_HATCH_COLOR_RED );
    }

    //
    // Now pass the region we have updated to the SWP. (We must convert it
    // back to VD coordinates before we pass it
    //
    OffsetRgn(regionRDB, pasPerson->m_pView->m_dsScreenOrigin.x,
        pasPerson->m_pView->m_dsScreenOrigin.y);

    VIEW_InvalidateRgn(pasPerson, regionRDB);

DC_EXIT_POINT:
    if (regionRDB != NULL)
    {
        //
        // Free the region.
        //
        DeleteRgn(regionRDB);
    }

    DebugExitVOID(ASShare::SDP_ReceivedPacket);
}


//
// FUNCTION: SDPDrawHatchedRegion(...)
//
// DESCRIPTION:
//
// Draws a hatched region on the specified surface in the given color.
//
// PARAMETERS:
//
// surface - the surface to draw on
//
// region - the region to hatch
//
// hatchColor - the color to hatch in
//
// RETURNS: Nothing.
//
//
void  ASShare::SDPDrawHatchedRegion
(
    HDC         hdc,
    HRGN        region,
    UINT        hatchColor
)
{
    HBRUSH      hbrHatch;
    UINT        brushStyle;
    UINT        oldBkMode;
    UINT        oldRop2;
    POINT       oldOrigin;
    COLORREF    hatchColorRef    = 0;

    DebugEntry(ASShare::SDPDrawHatchedRegion);

    //
    // Set the brush style to the appropriate value.
    //
    switch (hatchColor)
    {
        case USR_HATCH_COLOR_RED:
        {
            brushStyle = HS_BDIAGONAL;
        }
        break;

        case USR_HATCH_COLOR_BLUE:
        {
            brushStyle = HS_FDIAGONAL;
        }
        break;

        default:
        {
            brushStyle = HS_BDIAGONAL;
        }
        break;
    }

    //
    // Cycle the color to use.  Note that the hatchColor parameter is now
    // in fact just used to set the hatching direction.
    //
    m_usrHatchColor++;
    m_usrHatchColor %= 7;
    switch (m_usrHatchColor)
    {
        case 0: hatchColorRef = RGB(0xff,0x00,0x00); break;
        case 1: hatchColorRef = RGB(0x00,0xff,0x00); break;
        case 2: hatchColorRef = RGB(0xff,0xff,0x00); break;
        case 3: hatchColorRef = RGB(0x00,0x00,0xff); break;
        case 4: hatchColorRef = RGB(0xff,0x00,0xff); break;
        case 5: hatchColorRef = RGB(0x00,0xff,0xff); break;
        case 6: hatchColorRef = RGB(0xff,0xff,0xff); break;
    }

    //
    // Create the brush, set the background mode etc.
    //
    hbrHatch = CreateHatchBrush(brushStyle, hatchColorRef);
    oldBkMode = SetBkMode(hdc, TRANSPARENT);
    oldRop2 = SetROP2(hdc, R2_COPYPEN);
    SetBrushOrgEx(hdc, 0, 0, &oldOrigin);

    //
    // Fill the region.
    //
    FillRgn(hdc, region, hbrHatch);

    //
    // Reset everything.
    //
    SetBrushOrgEx(hdc, oldOrigin.x, oldOrigin.y, NULL);
    SetROP2(hdc, oldRop2);
    SetBkMode(hdc, oldBkMode);
    DeleteBrush(hbrHatch);

    DebugExitVOID(ASShare::SDPDrawHatchedRegion);
}


//
//
// SDPPlayScreenDataToRDB()
//
// DESCRIPTION:
//
// Play the contents of a screen data packet into the specified person ID's
// remote desktop bitmap.
//
// PARAMETERS:
//
//  personID - ID of person whose RDB is the target for the screen data
//  pBitmapUpdate - pointer to protocol update packet
//  pBits - pointer to uncompressed screen data
//  pPosition - returns updated rectangle in RDB coordinates
//
// RETURNS:
//
//  None
//
//
void  ASShare::SDPPlayScreenDataToRDB
(
    ASPerson *      pasPerson,
    PSDPACKET       pBitmap,
    LPBYTE          pBits,
    LPRECT          pRectRDB
)
{
    UINT            width;
    UINT            height;
    HPALETTE        hOldPalette;
    LPTSHR_UINT16   pIndexTable;
    UINT            cColors;
    UINT            i;
    BITMAPINFO_ours bitmapInfo;
    UINT            dibFormat;

    DebugEntry(ASShare::SDPPlayScreenDataToRDB);

    ValidateView(pasPerson);

    //
    // Calculate the extent of the actual area to be updated.  This is an
    // area less than or equal to the stock DIB allocated to contain it and
    // is defined in the position field of the bitmap packet.
    //
    width  = pRectRDB->right - pRectRDB->left + 1;
    height = pRectRDB->bottom - pRectRDB->top + 1;

    //
    // Put the DIB data into a Device Dependent bitmap.
    //
    USR_InitDIBitmapHeader((BITMAPINFOHEADER *)&bitmapInfo, pBitmap->format);

    bitmapInfo.bmiHeader.biWidth = pBitmap->realWidth;
    bitmapInfo.bmiHeader.biHeight = pBitmap->realHeight;

    //
    // Select and realize the current remote palette into the device
    // context.
    //
    hOldPalette = SelectPalette(pasPerson->m_pView->m_usrDC, pasPerson->pmPalette, FALSE);
    RealizePalette(pasPerson->m_pView->m_usrDC);

    //
    // The DIB_PAL_COLORS option requires a table of indexes into the
    // currently selected palette to follow the bmi header (in place of the
    // color table).
    //
    if (pBitmap->format <= 8)
    {
        pIndexTable = (LPTSHR_UINT16)&(bitmapInfo.bmiColors[0]);
        cColors = (1 << pBitmap->format);
        for (i = 0; i < cColors; i++)
        {
            *pIndexTable++ = (TSHR_UINT16)i;
        }

        dibFormat = DIB_PAL_COLORS;
    }
    else
    {
        dibFormat = DIB_RGB_COLORS;
    }

    //
    // We go from the bitmap to the screen bitmap in one go.
    //
    if (!StretchDIBits(pasPerson->m_pView->m_usrDC,
                       pRectRDB->left,
                       pRectRDB->top,
                       width,
                       height,
                       0,
                       0,
                       width,
                       height,
                       pBits,
                       (BITMAPINFO *)&bitmapInfo,
                       dibFormat,
                       SRCCOPY))
    {
        ERROR_OUT(( "StretchDIBits failed"));
    }

    //
    // Reinstate the old palette.
    //
    SelectPalette(pasPerson->m_pView->m_usrDC, hOldPalette, FALSE);

    DebugExitVOID(ASShare::SDPPlayScreenDataToRDB);
}



//
// SDP_DrawHatchedRect(...)
//
void  ASShare::SDP_DrawHatchedRect
(
    HDC     surface,
    int     x,
    int     y,
    int     width,
    int     height,
    UINT    color
)
{
    HRGN hrgn;

    DebugEntry(ASShare::SDP_DrawHatchedRect);

    //
    // Create the exclusive region.
    //
    hrgn = CreateRectRgn(x, y, x + width, y + height);
    if (hrgn)
    {
        //
        // Now draw the hatched region.
        //
        SDPDrawHatchedRegion(surface, hrgn, color);

        //
        // Finally delete the region.
        //
        DeleteRgn(hrgn);
    }

    DebugExitVOID(ASShare::SDP_DrawHatchedRect);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\swl.cpp ===
#include "precomp.h"


//
// SWL.CPP
// Shared Window List
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE

//
// SWL strategy when network packets are not available
//
// The SWL only sends one type of message - the window structure message.
// When no network packets are available the SWL will drop its current
// packet and remember that the window structure has changed since it was
// last able to send a packet.  SWL_Periodic will also return FALSE when
// this happens so that the DCS will know not to send any updates if it
// failed to send a window structure.
//
// This pending of window structure messages is integrated with the
// ignore envelopes where the SWL wants to ignore changes caused by itself
// (or other components if they call the SWL_Begin/EndIgnoreWindowChanges
// functions).
//

//
// SWL strategy for backward compatibility.
//
// The differences between the R2.0 and 3.0 SWL protocol are:
// 1.  Tokenless packets.
// 2.  No shadows.
//




//
// SWL_HostStarting()
//
BOOL ASHost::SWL_HostStarting(void)
{
    BOOL    rc = FALSE;

    DebugEntry(ASHost::SWL_HostStarting);

    //
    // If this is NT, get the name of our startup desktop
    //
    if (!g_asWin95)
    {
        ASSERT(m_aswlOurDesktopName[0] == 0);
        GetUserObjectInformation(GetThreadDesktop(g_asMainThreadId),
                UOI_NAME, m_aswlOurDesktopName,
                sizeof(m_aswlOurDesktopName), NULL);

        TRACE_OUT(("Our desktop name is %s", m_aswlOurDesktopName));
    }

    if (!m_aswlOurDesktopName[0])
    {
        // Use default name
        TRACE_OUT(("Couldn't get desktop name; using %s",
                NAME_DESKTOP_DEFAULT));
        lstrcpy(m_aswlOurDesktopName, NAME_DESKTOP_DEFAULT);
    }

    rc = TRUE;

    DebugExitBOOL(ASHost::SWL_HostStarting, rc);
    return(rc);
}



//
// SWL_UpdateCurrentDesktop()
//
// This checks what the current desktop is, and if it's changed, updates
// the NT input hooks for winlogon/screensaver for the service.  But normal
// SWL and AWC also make use of this info.
//
void  ASHost::SWL_UpdateCurrentDesktop(void)
{
    HDESK   hDeskCurrent = NULL;
    UINT    newCurrentDesktop;
    char    szName[SWL_DESKTOPNAME_MAX];

    DebugEntry(ASHost::SWL_UpdateCurrentDesktop);

    newCurrentDesktop = DESKTOP_OURS;

    if (g_asWin95)
    {
        // Nothing to do
        DC_QUIT;
    }

    //
    // Get the current desktop.  If we can't even get it, assume it's the
    // winlogon desktop.
    //
    hDeskCurrent = OpenInputDesktop(0, TRUE, DESKTOP_READOBJECTS);
    if (!hDeskCurrent)
    {
        TRACE_OUT(("OpenInputDesktop failed; must be WINLOGON"));
        newCurrentDesktop = DESKTOP_WINLOGON;
        DC_QUIT;
    }

    // Get the name of the current desktop
    szName[0] = 0;
    GetUserObjectInformation(hDeskCurrent, UOI_NAME, szName,
        sizeof(szName), NULL);
    TRACE_OUT(("GetUserObjectInformation returned %s for name", szName));

    if (!lstrcmpi(szName, m_aswlOurDesktopName))
    {
        newCurrentDesktop = DESKTOP_OURS;
    }
    else if (!lstrcmpi(szName, NAME_DESKTOP_SCREENSAVER))
    {
        newCurrentDesktop = DESKTOP_SCREENSAVER;
    }
    else if (!lstrcmpi(szName, NAME_DESKTOP_WINLOGON))
    {
        newCurrentDesktop = DESKTOP_WINLOGON;
    }
    else
    {
        newCurrentDesktop = DESKTOP_OTHER;
    }

DC_EXIT_POINT:
    if (newCurrentDesktop != m_swlCurrentDesktop)
    {
        //
        // If this is the service, adjust where we playback events
        // and/or block local input.
        //
        OSI_DesktopSwitch(m_swlCurrentDesktop, newCurrentDesktop);
        m_swlCurrentDesktop = newCurrentDesktop;
    }

    if (hDeskCurrent != NULL)
    {
        CloseDesktop(hDeskCurrent);
    }

    DebugExitVOID(ASHost::SWL_UpdateCurrentDesktop);
}


//
// SWL_IsOurDesktopActive()
//
BOOL ASHost::SWL_IsOurDesktopActive(void)
{
    return(!g_asSharedMemory->fullScreen && (m_swlCurrentDesktop == DESKTOP_OURS));
}





//
// SWL_Periodic()
//
// DESCRIPTION:
//
// Called periodically.  If the window structure has changed (such that it
// impacts remote systems) then send a new one if we can.
//
//
void  ASHost::SWL_Periodic(void)
{
    DebugEntry(ASSHost::SWL_Periodic);

    SWL_UpdateCurrentDesktop();

    DebugExitVOID(ASHost::SWL_Periodic);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\ssi.cpp ===
#include "precomp.h"


//
// SSI.CPP
// Save Screenbits Interceptor
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE




//
// SSI_HostStarting()
//
// Called when we start to host, figures out the max save bitmap bits size
// etc.
//
BOOL ASHost::SSI_HostStarting(void)
{
    DebugEntry(ASHost::SSI_HostStarting);

    m_pShare->SSI_RecalcCaps(TRUE);

    DebugExitBOOL(ASHost::SSI_HostStarting, TRUE);
    return(TRUE);
}



//
// SSI_ViewStarted()
//
// Called when someone we are viewing has started to host.  Creates save bits
// bitmap for them.
//
BOOL  ASShare::SSI_ViewStarting(ASPerson * pasPerson)
{
    BOOL                rc = FALSE;
    HDC                 hdcScreen = NULL;

    DebugEntry(ASShare::SSI_ViewStarting);

    ValidateView(pasPerson);

    //
    // ASSERT that this persons' variables are clear.
    //
    ASSERT(pasPerson->m_pView->m_ssiBitmapHeight == 0);
    ASSERT(pasPerson->m_pView->m_ssiBitmap == NULL);
    ASSERT(pasPerson->m_pView->m_ssiOldBitmap == NULL);

    //
    // Does this person support savebits?
    //
    if (!pasPerson->cpcCaps.orders.capsSaveBitmapSize)
    {
        // No receive SSI capability, bail out now.
        rc = TRUE;
        DC_QUIT;
    }

    //
    // Store the height of this host's bitmap.                             
    //
    pasPerson->m_pView->m_ssiBitmapHeight = (int)
        (pasPerson->cpcCaps.orders.capsSaveBitmapSize / TSHR_SSI_BITMAP_WIDTH);

    //
    // If the calculated bitmap size is not exactly divisible by the bitmap
    // width increase the bitmap height to fit in the partial row.         
    //
    if (pasPerson->cpcCaps.orders.capsSaveBitmapSize % TSHR_SSI_BITMAP_WIDTH)
    {
        pasPerson->m_pView->m_ssiBitmapHeight += pasPerson->cpcCaps.orders.capsSaveBitmapYGranularity;
    }

    TRACE_OUT(("Person [%d] SSI Bitmap height %d",
            pasPerson->mcsID,
            pasPerson->m_pView->m_ssiBitmapHeight));

    //
    // Create this host's save screen bitmap.                              
    //
    hdcScreen = GetDC(NULL);
    if (hdcScreen == NULL)
    {
        ERROR_OUT(( "Failed to get screen surface"));
        DC_QUIT;
    }

    //
    // Create the save screen bitmap DC.                                   
    //
    ASSERT(pasPerson->m_pView->m_ssiDC == NULL);
    pasPerson->m_pView->m_ssiDC = CreateCompatibleDC(hdcScreen);
    if (!pasPerson->m_pView->m_ssiDC)
    {
        ERROR_OUT(("Failed to create SSI DC"));
        DC_QUIT;
    }

    //
    // Create the save screen bitmap.
    //
    ASSERT(pasPerson->m_pView->m_ssiBitmap == NULL);
    pasPerson->m_pView->m_ssiBitmap = CreateCompatibleBitmap(hdcScreen,
            TSHR_SSI_BITMAP_WIDTH, pasPerson->m_pView->m_ssiBitmapHeight);
    if (!pasPerson->m_pView->m_ssiBitmap)
    {
        ERROR_OUT(("SSI_ViewStarting: can't create bitmap for person %x",
            pasPerson->mcsID));
            DC_QUIT;
    }

    //
    // Select the save screen bitmap into the DC
    //
    ASSERT(pasPerson->m_pView->m_ssiOldBitmap == NULL);
    pasPerson->m_pView->m_ssiOldBitmap = SelectBitmap(pasPerson->m_pView->m_ssiDC,
            pasPerson->m_pView->m_ssiBitmap);

    rc = TRUE;

DC_EXIT_POINT:

    if (hdcScreen != NULL)
    {
        ReleaseDC(NULL, hdcScreen);
    }

    DebugExitBOOL(ASShare::SSI_ViewStarting, rc);
    return(rc);
}



//
// SSI_ViewEnded()
//
// Called when someone we are viewing has stopped hosting, so we can clean
// up our view data for them.
//
void  ASShare::SSI_ViewEnded(ASPerson * pasPerson)
{
    DebugEntry(ASShare::SSI_ViewEnded);

    ValidateView(pasPerson);

    //
    // Deselect the save screen bitmap if there is one
    //
    if (pasPerson->m_pView->m_ssiOldBitmap != NULL)
    {
        SelectBitmap(pasPerson->m_pView->m_ssiDC, pasPerson->m_pView->m_ssiOldBitmap);
        pasPerson->m_pView->m_ssiOldBitmap = NULL;
    }

    //
    // Delete the save screen bitmap
    //
    if (pasPerson->m_pView->m_ssiBitmap != NULL)
    {
        DeleteBitmap(pasPerson->m_pView->m_ssiBitmap);
        pasPerson->m_pView->m_ssiBitmap = NULL;
    }

    //
    // Delete the save screen DC
    //
    if (pasPerson->m_pView->m_ssiDC != NULL)
    {
        DeleteDC(pasPerson->m_pView->m_ssiDC);
        pasPerson->m_pView->m_ssiDC = NULL;
    }

    DebugExitVOID(ASShare::SSI_ViewEnded);
}



//
// SSI_SyncOutgoing()
// Called when NEW (3.0) dude starts to share, a share is created, or 
// someone new joins the share.
// Resets save state for OUTGOING save/restore orders.
//
void  ASHost::SSI_SyncOutgoing(void)
{
    OSI_ESCAPE_HEADER request;

    DebugEntry(ASHost::SSI_SyncOutgoing);

    //
    // Discard any saved bitmaps.  This ensures that the subsequent        
    // datastream will not refer to any previously sent data.              
    //
    //
    // Make sure the display driver resets the save level.  Note we don't  
    // really care what happens in the display driver, so don't bother with
    // a special request block - use a standard request header.            
    //
    OSI_FunctionRequest(SSI_ESC_RESET_LEVEL, &request, sizeof(request));

    DebugExitVOID(ASHost::SSI_SyncOutgoing);
}



//
// FUNCTION: SSI_SaveBitmap                                                
//
// DESCRIPTION:
// Replays a SaveBitmap order by saving or restoring a specified area of
// the user's desktop bitmap.
//                                                                         
//
void  ASShare::SSI_SaveBitmap
(
    ASPerson *          pasPerson,
    LPSAVEBITMAP_ORDER  pSaveBitmap
)
{
    RECT            screenBitmapRect;
    RECT            saveBitmapRect;
    int             xSaveBitmap;
    int             ySaveBitmap;
    int             xScreenBitmap;
    int             yScreenBitmap;
    int             cxTile;
    int             cyTile;

    DebugEntry(ASShare::SSI_SaveBitmap);

    ValidateView(pasPerson);

    if ((pSaveBitmap->Operation != SV_SAVEBITS) &&
        (pSaveBitmap->Operation != SV_RESTOREBITS))
    {
        ERROR_OUT(("SSI_SaveBitmap: unrecognized SV_ value %d",
            pSaveBitmap->Operation));
        DC_QUIT;
    }

    //
    // Calculate the (x,y) start position from the pel start position      
    // given in the order.                                                 
    //
    ySaveBitmap = (pSaveBitmap->SavedBitmapPosition /
                  (TSHR_SSI_BITMAP_WIDTH *
                    (UINT)pasPerson->cpcCaps.orders.capsSaveBitmapYGranularity)) *
                pasPerson->cpcCaps.orders.capsSaveBitmapYGranularity;

    xSaveBitmap =  (pSaveBitmap->SavedBitmapPosition -
                  (ySaveBitmap *
                   (UINT)TSHR_SSI_BITMAP_WIDTH)) /
                pasPerson->cpcCaps.orders.capsSaveBitmapYGranularity;


    screenBitmapRect.left   = pSaveBitmap->nLeftRect
                              - pasPerson->m_pView->m_dsScreenOrigin.x;
    screenBitmapRect.top    = pSaveBitmap->nTopRect
                              - pasPerson->m_pView->m_dsScreenOrigin.y;
    screenBitmapRect.right  = pSaveBitmap->nRightRect + 1
                              - pasPerson->m_pView->m_dsScreenOrigin.x;
    screenBitmapRect.bottom = pSaveBitmap->nBottomRect + 1
                              - pasPerson->m_pView->m_dsScreenOrigin.y;
    saveBitmapRect.left     = 0;
    saveBitmapRect.top      = 0;
    saveBitmapRect.right    = TSHR_SSI_BITMAP_WIDTH;
    saveBitmapRect.bottom   = pasPerson->m_pView->m_ssiBitmapHeight;

    //
    // Start tiling in the top left corner of the Screen Bitmap rectangle. 
    //
    xScreenBitmap = screenBitmapRect.left;
    yScreenBitmap = screenBitmapRect.top;

    //
    // The height of the tile is the vertical granularity (or less - if    
    // the Screen Bitmap rect is thinner than the granularity).            
    //
    cyTile = min(screenBitmapRect.bottom - yScreenBitmap,
                 (int)pasPerson->cpcCaps.orders.capsSaveBitmapYGranularity );

    //
    // Repeat while there are more tiles in the Screen Bitmap rect to      
    // process.                                                            
    //
    while (yScreenBitmap < screenBitmapRect.bottom)
    {
        //
        // The width of the tile is the minimum of:                        
        //                                                                 
        // - the width of the remaining rectangle in the current strip of  
        //   the Screen Bitmap rectangle                                   
        //                                                                 
        // - the width of the remaining empty space in the current strip of
        //   the Save Bitmap                                               
        //                                                                 
        //
        cxTile = min( saveBitmapRect.right - xSaveBitmap,
                      screenBitmapRect.right - xScreenBitmap );

        TRACE_OUT(( "screen(%d,%d) save(%d,%d) cx(%d) cy(%d)",
                    xScreenBitmap,
                    yScreenBitmap,
                    xSaveBitmap,
                    ySaveBitmap,
                    cxTile,
                    cyTile ));

        //
        // Save or Restore this tile
        //
        if (pSaveBitmap->Operation == SV_SAVEBITS)
        {
            //
            // Save user's desktop area to SSI bitmap
            //
            BitBlt(pasPerson->m_pView->m_ssiDC,
                xSaveBitmap, ySaveBitmap, cxTile, cyTile,
                pasPerson->m_pView->m_usrDC,
                xScreenBitmap, yScreenBitmap, SRCCOPY);
        }
        else
        {
            //
            // Restore user's desktop area from SSI bitmap
            //
            BitBlt(pasPerson->m_pView->m_usrDC,
                xScreenBitmap, yScreenBitmap, cxTile, cyTile,
                pasPerson->m_pView->m_ssiDC,
                xSaveBitmap, ySaveBitmap, SRCCOPY);
        }

        //
        // Move to the next tile in the Screen Bitmap rectangle.           
        //
        xScreenBitmap += cxTile;
        if (xScreenBitmap >= screenBitmapRect.right)
        {
            xScreenBitmap = screenBitmapRect.left;
            yScreenBitmap += cyTile;
            cyTile = min( screenBitmapRect.bottom - yScreenBitmap,
                             (int)pasPerson->cpcCaps.orders.capsSaveBitmapYGranularity );
        }

        //
        // Move to the next free space in the Save Bitmap.                 
        //
        xSaveBitmap += ROUNDUP(cxTile, pasPerson->cpcCaps.orders.capsSaveBitmapXGranularity);
        if (xSaveBitmap >= saveBitmapRect.right)
        {
            xSaveBitmap = saveBitmapRect.left;
            ySaveBitmap += ROUNDUP(cyTile, pasPerson->cpcCaps.orders.capsSaveBitmapYGranularity);
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::SSI_SaveBitmap);
}



//
// SSI_RecalcCaps()
//
// Called when we are hosting and someone joins/leaves the share.
//
// When 2.x COMPAT IS GONE, THIS IS OBSOLETE
//
void  ASShare::SSI_RecalcCaps(BOOL fJoiner)
{
    ASPerson *  pasT;
    SSI_NEW_CAPABILITIES newCapabilities;

    DebugEntry(ASShare::SSI_RecalcCaps);

    if (!m_pHost)
    {
        //
        // Nothing to do.  Note that we recalc when someone joins AND
        // when someone leaves, like SBC.
        //
        DC_QUIT;
    }

    ValidatePerson(m_pasLocal);

    //
    // Enumerate all the save screen bitmap receive capabilities of the    
    // parties in the share.  The usable size of the send save screen      
    // bitmap is then the minimum of all the remote receive sizes and the  
    // local send size.                                                    
    //

    //
    // Copy the locally registered send save screen bitmap size capability 
    // to our global variable used to communicate with the enumeration     
    // function SSIEnumBitmapCacheCaps().                                  
    //
    m_pHost->m_ssiSaveBitmapSize = m_pasLocal->cpcCaps.orders.capsSaveBitmapSize;

    //
    // Set up the new capabilities structure...                            
    //
    newCapabilities.sendSaveBitmapSize = m_pHost->m_ssiSaveBitmapSize;

    newCapabilities.xGranularity       = TSHR_SSI_BITMAP_X_GRANULARITY;

    newCapabilities.yGranularity       = TSHR_SSI_BITMAP_Y_GRANULARITY;

    //
    // ... and pass it through to the driver.                              
    //
    if (!OSI_FunctionRequest(SSI_ESC_NEW_CAPABILITIES, (LPOSI_ESCAPE_HEADER)&newCapabilities,
                sizeof(newCapabilities)))
    {
        ERROR_OUT(("SSI_ESC_NEW_CAPABILITIES failed"));
    }

DC_EXIT_POINT:
    DebugExitVOID(ASHost::SSI_RecalcCaps);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\up.cpp ===
#include "precomp.h"


//
// UP.CPP
// Update Packager
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_NET



//
// UP_FlowControl()
// Checks if we've switched between slow and fast throughput
//
void  ASHost::UP_FlowControl(UINT newBufferSize)
{
    DebugEntry(ASHost::UP_FlowControl);

    if (newBufferSize > (LARGE_ORDER_PACKET_SIZE / 2))
    {
        if (m_upfUseSmallPackets)
        {
            m_upfUseSmallPackets = FALSE;
            TRACE_OUT(("UP_FlowControl:  FAST; use large packets"));
        }
    }
    else
    {
        if (!m_upfUseSmallPackets)
        {
            m_upfUseSmallPackets = TRUE;
            TRACE_OUT(("UP_FlowControl:  SLOW; use small packets"));
        }
    }

    DebugExitVOID(ASHost::UP_FlowControl);
}



//
// UP_Periodic()
//
// Called periodically, to send graphical updates as orders and/or screen
// data.
//
void ASHost::UP_Periodic(UINT currentTime)
{
    BOOL    fSendSD     = FALSE;
    BOOL    fSendOrders = FALSE;
    UINT    tmpTime;
    UINT    timeSinceOrders;
    UINT    timeSinceSD;
    UINT    timeSinceTrying;

    DebugEntry(ASHost::UP_Periodic);

    //
    // This is a
    // performance critical part of the scheduling so we apply some
    // heuristics to try and keep the overheads down.
    //
    // 1.If there was no back pressure last time then we check the
    //   rate of accumulation of screendata over the last period.
    //   If it was high then we apply a time slice to the sending
    //   of screendata.
    //
    // 2.If the rate of order accumulation was also high then we
    //   apply a timeslice to the order accumulation as well, just
    //   to avoid too high a CPU overhead trying to send orders
    //   when we will eventually fail to keep up.  We keep this
    //   time period low because the objective is simply to avoid
    //   sending hundreds of packets containing few orders each.
    //   (On the other hand, we want to send the single textout
    //   following a keystoke ASAP so we must not timeslice all the
    //   time.)
    //
    // 3.If neither orders nor screendata is piling up quickly then
    //   we do a full send immediately.
    //
    // 4.If there was back pressure on the last send then we still
    //   send orders, but always on the time slice, independent of
    //   the order accumulation rate.
    //
    // Note that we cannot sample the accumulation rates for every
    // pass because the app doing the drawing may be interrupted by
    // us for a few hundred milliseconds.  Therefore we only sample
    // the bounds every VOLUME_SAMPLE milliseconds.
    //
    //
    timeSinceSD      = currentTime - m_upLastSDTime;
    timeSinceOrders  = currentTime - m_upLastOrdersTime;
    timeSinceTrying  = currentTime - m_upLastTrialTime;

    //
    // Sample the accumulation rates.
    //
    m_upSDAccum     += BA_QueryAccumulation();
    m_upOrdersAccum += OA_QueryOrderAccum();

    //
    // Sample the throughput over the last period to see whether we
    // can operate in rapid respose mode or whether we should
    // timeslice.
    //
    if (timeSinceTrying > DCS_VOLUME_SAMPLE)
    {
        //
        // Take the newly accumulated deltas.
        //
        m_upDeltaSD     = m_upSDAccum;
        m_upDeltaOrders = m_upOrdersAccum;

        //
        // Store time of last retrieval.
        //
        m_upLastTrialTime = currentTime;

        //
        // Reset the running totals.
        //
        m_upSDAccum     = 0;
        m_upOrdersAccum = 0;
    }

    //
    // If we are way out of line then send updates.  Not that this
    // will reset the update timer independent of whether the send
    // works or not, so that we don't enter this arm continually
    // when we time out but are in a back pressure situation
    //
    // The long stop timer is there to catch apps that keep a
    // continual flow of orders/SD at above the suppression rate.
    // We want to tune our heuristics to avoid this, but if it
    // happens than we must send the data eventually.  The problem
    // is that this objective clashes with the scenario of the user
    // paging down twenty times, where our most efficient approach
    // is to let him run and snapshot the SD at the end, rather
    // than every PERIOD_LONG milliseconds.  (A screen snapshot
    // will stop the host for a second!).
    //
    if (timeSinceSD > DCS_SD_UPDATE_LONG_PERIOD)
    {
        fSendSD = TRUE;
    }
    else
    {
        //
        // We only disregard our time slicing if the rate of orders
        // and screendata is low enough to warrant it.  If the rate
        // is too high then hold off so that we can do some packet
        // consolidation.  If we had no back pressure last time or
        // the screendata rate is now low enough then try sending
        // SD as well as orders.
        //
        // The order threshold is measured in number of orders over
        // the period.  Screendata is measured in the total area
        // accumulated (prior to any spoiling).
        //
        if (!m_upBackPressure)
        {
            if (m_upDeltaOrders < DCS_ORDERS_TURNOFF_FREQUENCY)
            {
                fSendOrders = TRUE;
                if (m_upDeltaSD < DCS_BOUNDS_TURNOFF_RATE)
                {
                    if ((timeSinceSD < DCS_SD_UPDATE_SHORT_PERIOD) &&
                        (m_upDeltaSD > DCS_BOUNDS_IMMEDIATE_RATE))
                    {
                        fSendSD = FALSE;
                    }
                    else
                    {
                        fSendSD = TRUE;
                    }
                }
            }
        }

        //
        // Even in a back pressure situation we try and send orders
        // periodically to keep current.  If we overflow the order
        // buffer then we will constrain the buffer size to prevent
        // sending too many non-productive orders.  (But we dont
        // turn orders off because we still want the user to see
        // things happening.) Generally we send orders immediately,
        // provided the rate of accumulation is within the limits.
        // This test is to time slice orders if they are being
        // generated at a high rate.  The constant must be
        // reasonably small otherwise we force the order buffer to
        // overflow and order processing will be turned off.
        //
        if (!fSendSD && !fSendOrders)
        {
            if (timeSinceOrders > DCS_ORDER_UPDATE_PERIOD)
            {
                fSendOrders = TRUE;
            }
        }
    }

    //
    // Now we can go ahead and try sending!  First look to see if
    // we can do both screendata and orders
    //
    if (fSendSD)
    {
        //
        // Indicate no back pressure (even if this send is
        // triggered by a timout our initial assumption is no back
        // pressure).  Back pressure will be reinstated by
        // SendUpdates if necessary.
        //
        m_upBackPressure = FALSE;
        UPSendUpdates();

        //
        // Sending screendata can take a long time.  It messes up
        // our heuristics unless we adjust for it.
        //
        tmpTime = GetTickCount();
        timeSinceTrying    -= (tmpTime - currentTime);
        m_pShare->m_dcsLastScheduleTime   = tmpTime;
        m_upLastSDTime          = tmpTime;
        m_upLastOrdersTime      = tmpTime;
    }
    else
    {
        if (fSendOrders)
        {
            //
            // Either the update rate is too high or we are
            // experiencing back pressure so just send the orders
            // and not the screendata.  This is because we want to
            // avoid entering screendata mode as a result of order
            // back pressure for as long as we can.  The screendata
            // will come later, when things have settled down a bit
            //
            m_upLastOrdersTime = currentTime;
            m_upBackPressure = TRUE;
            if (!UPSendUpdates())
            {
                //
                // This is the only real action so leave all the
                // tracing separate for cleanliness.  If there are
                // orders in transit then everything is fine.  If none
                // are sent for a while then we want to break out of
                // our SD back pressure wait.  This is because we are
                // only sampling the flow rates every DCS_VOLUME_SAMPLE msecs,
                // but we dont want to have to wait that long to flush the SD.
                // We cannot increase the flow sample rate because then
                // it becomes too erratic because of system scheduling.
                //
                m_upBackPressure = FALSE;
                UPSendUpdates();
                m_upLastSDTime   = currentTime;
            }
        }
    }

    DebugExitVOID(ASHost::UP_Periodic);
}




//
// UPSendUpdates()
// Actually tries to allocate and send orders + screen data.  What it does
// depends on
//      * Presence of back-pressure due to previous send failures
//      * How much screen data & orders there are
//      * Whether we're in serious spoiling mode and can't keep up
//      * What packet size to send
//
// Returns:
//      # of packets sent
//
UINT ASHost::UPSendUpdates(void)
{
    BOOL    synced;
    BOOL    ordersSent;
    UINT    numPackets = 0;

    DebugEntry(ASHost::UPSendUpdates);

    //
    // If we actually have updates to send then try to send a sync token.
    //
    if ((OA_GetTotalOrderListBytes() > 0) ||
        (m_sdgcLossy != 0) ||
        (m_baNumRects > 0))
    {
        synced = UP_MaybeSendSyncToken();

        //
        // Only send updates if we have sent the sync token succesfully.
        //
        if (synced)
        {
            //
            // There is no outstanding sync token waiting to be sent, so we
            // can send the orders and screen data updates.
            //
            //
            // Send accumulated orders.  If this call fails (probably out
            // of memory) then don't send any other updates - we'll try
            // sending the whole lot later.  The orders MUST be sent before
            // the screen data.
            //
            if (PM_MaybeSendPalettePacket())
            {
                ordersSent = UPSendOrders(&numPackets);
                if (!ordersSent)
                {
                    m_upBackPressure = TRUE;
                }
                else
                {
                    //
                    // Orders sent OK so go for the screendata, provided
                    // the caller wants us to.
                    //
                    if (!m_upBackPressure)
                    {
                        //
                        // We may now try and send screen data.  However,
                        // we need to be careful not to do this too
                        // frequently, because DC-Share is now being
                        // scheduled to send as soon as network buffers
                        // become available.  On the other hand, some
                        // apps respond to keystrokes with screendata so
                        // we cannot just slow it down!
                        //
                        // The approach is to have SendScreenDataArea
                        // return the amount of data sent, together with
                        // an indication as to whether we hit back pressure
                        //
                        // We return these to dcsapi which has control of
                        // when we are scheduled and passes the paramaters
                        // in again
                        //
                        //
                        TRACE_OUT(( "Sending SD"));
                        SDG_SendScreenDataArea(&m_upBackPressure, &numPackets);
                    }
                    else
                    {
                        //
                        // We sent the orders OK an so we must reset
                        // the back pressure indicator even though we
                        // were asked not to send screendata
                        //
                        TRACE_OUT(( "Orders sent and BP relieved"));
                        m_upBackPressure = FALSE;
                    }
                }
            }
        }
    }
    else
    {
        m_upBackPressure = FALSE;
    }

    DebugExitDWORD(ASHost::UPSendUpdates, numPackets);
    return(numPackets);
}



//
// UP_MaybeSendSyncToken()
//
BOOL  ASHost::UP_MaybeSendSyncToken(void)
{
    PUPSPACKET  pUPSPacket;
#ifdef _DEBUG
    UINT        sentSize;
#endif // _DEBUG

    DebugEntry(ASHost::UP_MaybeSendSyncToken);

    //
    // Check to see if we should send a sync token.
    //
    if (m_upfSyncTokenRequired)
    {
        //
        // The sync packet consists of an updates packets as far as the end
        // of the header.
        //
        pUPSPacket = (PUPSPACKET)m_pShare->SC_AllocPkt(PROT_STR_UPDATES,
            g_s20BroadcastID, sizeof(UPSPACKET));
        if (!pUPSPacket)
        {
            //
            // We will try again later.
            //
            TRACE_OUT(("Failed to alloc UP sync packet"));
        }
        else
        {
            //
            // Fill in the packet contents.
            //
            pUPSPacket->header.header.data.dataType = DT_UP;
            pUPSPacket->header.updateType = UPD_SYNC;

            //
            // Now send the packet to the remote application.
            //
            if (m_pShare->m_scfViewSelf)
                m_pShare->UP_ReceivedPacket(m_pShare->m_pasLocal,
                    &(pUPSPacket->header.header));

#ifdef _DEBUG
            sentSize =
#endif // _DEBUG
            m_pShare->DCS_CompressAndSendPacket(PROT_STR_UPDATES,
                g_s20BroadcastID, &(pUPSPacket->header.header),
                sizeof(*pUPSPacket));

            TRACE_OUT(("UP SYNC packet size: %08d, sent %08d",
                sizeof(*pUPSPacket), sentSize));

            //
            // The sync packet was successfully sent.
            //
            m_upfSyncTokenRequired = FALSE;
        }
    }

    DebugExitBOOL(ASHost::UP_MaybeSendSyncToken, (!m_upfSyncTokenRequired));
    return(!m_upfSyncTokenRequired);
}



//
// UPSendOrders(..)
//
// Sends all accumulated orders.
//
// Returns:
//   TRUE if all orders successfully sent
//   FALSE if send failed (e.g.  if unable to allocate network packet)
//
//
BOOL  ASHost::UPSendOrders(UINT * pcPackets)
{
    PORDPACKET      pPacket = NULL;
    UINT            cbOrderBytes;
    UINT            cbOrderBytesRemaining;
    UINT            cbPacketSize;
    BOOL            rc = TRUE;
#ifdef _DEBUG
    UINT            sentSize;
#endif // _DEBUG

    DebugEntry(ASHost::UPSendOrders);

    //
    // Find out how many bytes of orders there are in the Order List.
    //
    cbOrderBytesRemaining = UPFetchOrdersIntoBuffer(NULL, NULL, NULL);

    //
    // Process any orders on the list.
    //
    if (cbOrderBytesRemaining > 0)
    {
        TRACE_OUT(( "%u order bytes to fetch", cbOrderBytesRemaining));

        //
        // Keep sending packets while there are some orders to do.
        //
        while (cbOrderBytesRemaining > 0)
        {
            UINT    cbMax;
            //

            // Make sure the order size does not exceed the max packet
            // size.
            //
            cbMax = (m_upfUseSmallPackets) ? SMALL_ORDER_PACKET_SIZE :
                                             LARGE_ORDER_PACKET_SIZE;

            cbPacketSize = min(cbOrderBytesRemaining,
                (cbMax - sizeof(ORDPACKET) + 1));

            //
            // Allocate a packet to send the data in.
            //
            pPacket = (PORDPACKET)m_pShare->SC_AllocPkt(PROT_STR_UPDATES, g_s20BroadcastID,
                sizeof(ORDPACKET) + cbPacketSize - 1);
            if (!pPacket)
            {
                //
                // Failed to allocate a packet.  We skip out immediately -
                // we'll try again later.
                //
                TRACE_OUT(("Failed to alloc UP order packet, size %u",
                    sizeof(ORDPACKET) + cbPacketSize - 1));
                rc = FALSE;
                DC_QUIT;
            }

            //
            // Transfer as many orders into the packet as will fit.
            //
            cbOrderBytes = cbPacketSize;
            cbOrderBytesRemaining = UPFetchOrdersIntoBuffer(
                pPacket->data, &pPacket->cOrders, &cbOrderBytes);

            TRACE_OUT(( "%u bytes fetched into %u byte pkt. %u remain.",
                cbOrderBytes, cbPacketSize, cbOrderBytesRemaining));

            //
            // If no order bytes were transferred then try again with a
            // Large Order Packet.
            //
            if (cbOrderBytes == 0)
            {
                //
                // We need to use a larger packet to transfer the
                // orders into.  (The first order must be a very large
                // order such as a large bitmap cache update).
                //
                S20_FreeDataPkt(&(pPacket->header.header));

                //
                // cbOrderBytesRemaining may not accurate if there are
                // any MemBlt orders in the order heap.  This is
                // because we may have to insert a color table order
                // and / or a bitmap bits order before the MemBlt.
                //
                // To avoid getting into an infinite loop if there is
                // only a MemBlt remaining but we actually have to send
                // a color table and / or a bitmap bits order
                // (cbOrderBytesRemaining would never get set high
                // enough to allow us to send the color table / bitmap
                // bits order), make the buffer at least large enough
                // to hold the largest amount of data required for all
                // the parts of a MemBlt.
                //

                //
                // The maximum number of bytes required to send a MemBlt order.  This is
                //   The size of the largest possible color table order
                //   + the size of the largest possible bitmap bits order
                //   + the size of the largest MemBlt order.
                //
                cbPacketSize = sizeof(BMC_COLOR_TABLE_ORDER)    +
                        (256 * sizeof(TSHR_RGBQUAD))            +
                        sizeof(BMC_BITMAP_BITS_ORDER_R2)        +
                        sizeof(MEM3BLT_R2_ORDER)                +
                        MP_CACHE_CELLSIZE(MP_LARGE_TILE_WIDTH, MP_LARGE_TILE_HEIGHT,
                            m_usrSendingBPP);
                cbPacketSize = max(cbPacketSize, cbOrderBytesRemaining);

                if (cbPacketSize > (UINT)(LARGE_ORDER_PACKET_SIZE -
                        sizeof(ORDPACKET) + 1))
                {
                    TRACE_OUT(("Too many order bytes for large packet(%d)",
                                                      cbOrderBytesRemaining));
                    cbPacketSize = LARGE_ORDER_PACKET_SIZE -
                        sizeof(ORDPACKET) + 1;
                }

                pPacket = (PORDPACKET)m_pShare->SC_AllocPkt(PROT_STR_UPDATES,
                    g_s20BroadcastID, sizeof(ORDPACKET) + cbPacketSize - 1);
                if (!pPacket)
                {
                    TRACE_OUT(("Failed to alloc UP order packet, size %u",
                        sizeof(ORDPACKET) + cbPacketSize - 1));
                    rc = FALSE;
                    DC_QUIT;
                }

                //
                // Transfer as many orders into the packet as will
                // fit.
                //
                cbOrderBytes = cbPacketSize;
                cbOrderBytesRemaining = UPFetchOrdersIntoBuffer(
                    pPacket->data, &pPacket->cOrders, &cbOrderBytes );

                //
                // If no orders were transferred then something has
                // gone wrong.  Probably flow control kicked in or
                // a dekstop switch occurred.
                //      Return failure now!
                // Hopefully things will sort themselves out later
                // or we will resort to sending updates as screen
                // data once the order accumulation heap becomes
                // full.
                //
                if (cbOrderBytes == 0)
                {
                    WARNING_OUT(("No orders fetched into %u byte packet, %u bytes left",
                        cbPacketSize, cbOrderBytesRemaining));
                    S20_FreeDataPkt(&(pPacket->header.header));
                    rc = FALSE;
                    DC_QUIT;
                }
            }

            //
            // Fill in the packet header.
            //
            pPacket->header.header.data.dataType     = DT_UP;
            pPacket->header.updateType          = UPD_ORDERS;
            pPacket->sendBPP                    = (TSHR_UINT16)m_usrSendingBPP;

            //
            // If encoding is switched on, update the data size to reflect
            // it with encoded orders
            //
            if (m_pShare->m_oefOE2EncodingOn)
            {
                pPacket->header.header.dataLength = sizeof(ORDPACKET) + cbOrderBytes - 1
                    - sizeof(S20DATAPACKET) + sizeof(DATAPACKETHEADER);
            }

            //
            // Now send it.
            //
            if (m_pShare->m_scfViewSelf)
                m_pShare->UP_ReceivedPacket(m_pShare->m_pasLocal,
                        &(pPacket->header.header));

#ifdef _DEBUG
            sentSize =
#endif // _DEBUG
            m_pShare->DCS_CompressAndSendPacket(PROT_STR_UPDATES, g_s20BroadcastID,
                &(pPacket->header.header), sizeof(ORDPACKET) + cbOrderBytes - 1);

            TRACE_OUT(("UP ORDERS packet size: %08d, sent %08d",
                sizeof(ORDPACKET) + cbOrderBytes - 1, sentSize));

            ++(*pcPackets);
        }
    }

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::UPSendOrders, rc);
    return(rc);
}

//
//
// UPFetchOrdersIntoBuffer(..)
//
// Encodes orders from the Order List and copies them into the supplied
// buffer, then frees up the memory of each order copied.
//
// Orders are copied until the buffer is full or there are no more orders.
//
// Returns:
//   The number of order bytes that were NOT returned.
//   i.e.  0 if all orders were returned.
//   A simple way to find out the total number of order bytes
//   in the Order List is to call the function with a buffer length
//   of zero.
//
//   *pcbBufferSize is updated to contain the total number of bytes
//   returned.
//
//
UINT  ASHost::UPFetchOrdersIntoBuffer
(
    LPBYTE          pBuffer,
    LPTSHR_UINT16   pcOrders,
    LPUINT          pcbBufferSize
)
{
    LPINT_ORDER     pListOrder;
    LPINT_ORDER     pCurrentOrder;
    UINT            cbFreeBytesInBuffer;
    UINT            cOrdersCopied;
    LPBYTE          pDst;
    UINT            cbOrderSize;
    UINT            ulRemainingOrderBytes;
    BOOL            processingMemBlt;

    DebugEntry(ASHost::UPFetchOrdersIntoBuffer);

    //
    // Make a quick exit if the Order List length is being queried.
    //
    if ( (pcbBufferSize == NULL) ||
         (*pcbBufferSize == 0) )
    {
        goto fetch_orders_exit;
    }

    //
    // Initialize the buffer pointer and size.
    //
    pDst = pBuffer;
    cbFreeBytesInBuffer = *pcbBufferSize;

    //
    // Keep a count of the number of orders we copy.
    //
    cOrdersCopied = 0;

    //
    // Return as many orders as possible.
    //
    pListOrder = OA_GetFirstListOrder();
    TRACE_OUT(( "First order: 0x%08x", pListOrder));
    while (pListOrder != NULL)
    {
        if (pListOrder->OrderHeader.Common.fOrderFlags & OF_INTERNAL)
        {
            //
            // This is an internal order.  Currently SBC is the only
            // component to use internal orders, so get SBC to process it.
            //
            SBC_ProcessInternalOrder(pListOrder);

            //
            // Internal order must not get sent over the wire, so skip on
            // to the next order
            //
            pListOrder = OA_RemoveListOrder(pListOrder);
            continue;
        }

        if (ORDER_IS_MEMBLT(pListOrder) || ORDER_IS_MEM3BLT(pListOrder))
        {
            //
            // This is a MEMBLT or a MEM3BLT so we have to do some extra
            // processing...  This function returns us a pointer to the
            // next order which should be sent - this will often not be the
            // MEMBLT, but a color table order or a bitmap bits order.
            //
            if (!SBC_ProcessMemBltOrder(pListOrder, &pCurrentOrder))
            {
                //
                // This can fail if
                //      * we're low on memory
                //      * we changed from 8BPP to 24BPP sending, because
                //          somebody left the share, and we have queued up
                //          SBC orders that we can no longer process.
                //
                TRACE_OUT(("Failed to process SBC order, fall back to SDG"));
                pListOrder = OA_RemoveListOrder(pListOrder);
                continue;
            }

            processingMemBlt = TRUE;
        }
        else
        {
            //
            // This isn't a MEMBLT or a MEM3BLT - just set pCurrentOrder to
            // be pListOrder
            //
            pCurrentOrder    = pListOrder;
            processingMemBlt = FALSE;
        }

        if (m_pShare->m_oefOE2EncodingOn)
        {
            //
            // Encoding is switched on.
            // Encode the order into the next free space in the buffer
            //
            cbOrderSize = OE2_EncodeOrder( pCurrentOrder,
                                           pDst,
                                           (TSHR_UINT16)cbFreeBytesInBuffer );
            TRACE_OUT(( "Encoded size, %u bytes", cbOrderSize));
        }
        else
        {
            //
            // Copy the order into the buffer.
            //
            cbOrderSize = COM_ORDER_SIZE(
                        ((LPCOM_ORDER)(&(pCurrentOrder->OrderHeader.Common))));

            if (cbOrderSize <= cbFreeBytesInBuffer)
            {
                memcpy(pDst,
                         (LPCOM_ORDER)(&(pCurrentOrder->OrderHeader.Common)),
                         cbOrderSize);
            }
            else
            {
                //
                // No room for this order in this packet.
                //
                cbOrderSize = 0;
            }
        }

        //
        // Check whether the order was copied into the buffer.
        //
        if (cbOrderSize == 0)
        {
            //
            // The order was too big to fit in this buffer.
            // Exit the loop - this order will go in the next packet.
            //
            break;
        }

        //
        // Update the buffer pointer past the encoded order.
        //
        pDst                += cbOrderSize;
        cbFreeBytesInBuffer -= cbOrderSize;
        cOrdersCopied++;

        if (processingMemBlt)
        {
            //
            // If we are processing a MEMBLT order, we have to notify SBC
            // that we've dealt with it successfully so that it returns us
            // a different order next time.
            //
            SBC_OrderSentNotification(pCurrentOrder);
        }

        if (pCurrentOrder == pListOrder)
        {
            //
            // We successfully copied the order into the buffer - on to the
            // next one UNLESS we haven't processed the last one we picked
            // out of the order list i.e.  pCurrentOrder is not the same as
            // pListOrder.  This will happen if we just processed a color
            // table order or a bitmap bits order returned from
            // SBC_ProcessMemBltOrder (if we processed the MEMBLT itself,
            // we can safely move on to the next order).
            //
            pListOrder = OA_RemoveListOrder(pListOrder);
        }
    }

    //
    // Fill in the packet header.
    //
    if (pcOrders != NULL)
    {
        *pcOrders = (TSHR_UINT16)cOrdersCopied;
    }

    //
    // Update the buffer size to indicate how much data we have
    // written.
    //
    *pcbBufferSize -= cbFreeBytesInBuffer;

    TRACE_OUT(( "Returned %d orders in %d bytes",
                 cOrdersCopied,
                 *pcbBufferSize));

fetch_orders_exit:
    //
    // Return the number of bytes still to be processed
    //
    ulRemainingOrderBytes = OA_GetTotalOrderListBytes();

    DebugExitDWORD(ASHost::UPFetchOrdersIntoBuffer, ulRemainingOrderBytes);
    return(ulRemainingOrderBytes);
}



//
// UP_ReceivePacket()
//
void  ASShare::UP_ReceivedPacket
(
    ASPerson *      pasPerson,
    PS20DATAPACKET  pPacket
)
{
    PUPPACKETHEADER pUPPacket;

    DebugEntry(ASShare::UP_ReceivedPacket);

    ValidatePerson(pasPerson);

    if (!pasPerson->m_pView)
    {
        //
        // Updates for parties which we don't recognise as hosts are just
        // discarded.
        //

        // NOTE:
        // 2.0 Win95 does not have HET, where we kick off sharing/unsharing.
        // But it did have TT, and the packet type/messages were defined
        // cleverly for HET so that 2.0 Win95 works the same.  When they
        // start to share, we get a PT_TT packet with a non-zero count.
        // The difference really is that the number is apps for Win95 2.0
        // and HWNDs for everybody else.
        //
        WARNING_OUT(("UP_ReceivedUpdates:  Ignoring updates from person [%d] not hosting",
            pasPerson->mcsID));

        DC_QUIT;
    }

    pUPPacket = (PUPPACKETHEADER)pPacket;
    switch (pUPPacket->updateType)
    {
        case UPD_SCREEN_DATA:
            SDP_ReceivedPacket(pasPerson, pPacket);
            break;

        case UPD_ORDERS:
            OD_ReceivedPacket(pasPerson, pPacket);
            break;

        case UPD_PALETTE:
            PM_ReceivedPacket(pasPerson, pPacket);
            break;

        case UPD_SYNC:
            //
            // We need to reset our INCOMING decoding info since the sender
            // resets his OUTGOING encoding info for a sync.
            //
            OD2_SyncIncoming(pasPerson);

            //
            // NOTE:
            // We do not need to reset INCOMING data for
            //      PM  -- the host won't send us old palette references
            //      RBC -- the host won't send us old bitmap references.
            //             Even though it would be nice to delete the existing
            //              bitmaps, recreating the cache is a hassle.
            //      CM  -- the host won't send us old cursor references
            //      SSI -- the host won't send us old savebits references
            //
            break;

        default:
            ERROR_OUT(("Unknown UP packet type %u from [%d]",
                    pUPPacket->updateType,
                    pasPerson->mcsID));
            break;
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::UP_ReceivedPacket);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\usr.cpp ===
#include "precomp.h"


//
// USR.CPP
// Update Sender/Receiver
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_NET

//
// USR strategy when network packets cannot be allocated.
//
// The USR sends three different types of packets:
//
//  - font negotiation packets
//  - order packets
//  - screen data packets
//
// Font negotiation packets are sent by the USR_Periodic function.  If the
// packet cannot be sent first time then the USR will retry (on each call
// to the USR_Periodic function) until it has succesfully sent the packet.
// The only dependency on font packets is that until the systems in a share
// have been able to exchange font negotiation packets they will not be
// able to send text output as orders - they will simply send text as
// screen data.
//
// The USR function UP_SendUpdates sends all update packets (both order
// packets and screen data packets).  Order packets must be sent first and
// screen data packets are only sent if all the orders have been
// succesfully sent.  When sending screen data packets they are only sent
// if the corresponding palette packets have been sent - otherwise they are
// re-absorbed into the screen data to be transmitted later.
//
//



//
// USR_ShareStarting()
// Creates share resources
//
BOOL ASShare::USR_ShareStarting(void)
{
    BOOL    rc = FALSE;
    BITMAPINFOHEADER    bitmapInfo;
    HDC                 hdcDesktop = NULL;

    DebugEntry(ASShare::USR_ShareStarting);

    //
    // Set the black bitmap data and hatch bitmap data flags which can be
    // used as an aid for debugging.  These are false unless there is an
    // entry in the ini file to override them.
    //
    COM_ReadProfInt(DBG_INI_SECTION_NAME, USR_INI_HATCHSCREENDATA, FALSE,
            &m_usrHatchScreenData);

    COM_ReadProfInt(DBG_INI_SECTION_NAME, USR_INI_HATCHBMPORDERS, FALSE,
            &m_usrHatchBitmaps);

    //
    // Double-check the order packet sizes are OK
    //
    ASSERT(SMALL_ORDER_PACKET_SIZE < LARGE_ORDER_PACKET_SIZE);
    ASSERT(LARGE_ORDER_PACKET_SIZE <= TSHR_MAX_SEND_PKT);

    //
    // Allocate a chunk of memory big enough to contain the largest packet
    // an application can receive from the network.  This is required to
    // store uncompressed bitmaps and repeated general use by the USR.
    //
    m_usrPBitmapBuffer = new BYTE[TSHR_MAX_SEND_PKT];
    if (!m_usrPBitmapBuffer)
    {
        ERROR_OUT(("USR_ShareStarted: failed to alloc memory m_usrPBitmapBuffer"));

        //
        // To continue the share would cause a GP fault as soon as anything
        // tries to use this buffer so delete this person from the share.
        // The reason is lack of resources.
        //
        DC_QUIT;
    }

    //
    // Create the transfer bitmaps for screen data and bitmap orders
    //

    USR_InitDIBitmapHeader(&bitmapInfo, g_usrScreenBPP);

    //
    // Create the transfer bitmaps.  These are used for both outgoing and
    // incoming data.
    //
    // To avoid having to recreate the bitmaps whenever the parties in the
    // share change, (and hence the various bpp may change) from r2.0 we
    // now use a fixed vertical size and if necessary can handle incoming
    // bitmaps in multiple bands.
    //
    // These are the resulting heights for 256 pixel wide segments.
    //
    // TSHR_MAX_SEND_PKT - sizeof(DATAPACKETHEADER) / bytes per scan line
    //
    //     4bpp -->    (32000 - 4)    /     128              = 249
    //     8bpp -->    (32000 - 4)    /     256              = 124
    //    24bpp -->    (32000 - 4)    /     768              =  41
    //
    //

    //
    // NOTE:
    // The VGA driver has a problem when the bitmap ends exactly on a 4K
    // (page) boundary.  So we create the bitmaps one pixel taller.
    //
    // BOGUS BUGBUG LAURABU
    // Is this really true anymore?  If not, save some memory and make these
    // the right size.
    //

    hdcDesktop = GetDC(NULL);
    if (!hdcDesktop)
    {
        ERROR_OUT(("USR_ShareStarting: can't get screen DC"));
        DC_QUIT;
    }

    // The large bitmap is short.  The rest are medium height.
    bitmapInfo.biWidth      = 1024;
    bitmapInfo.biHeight     = MaxBitmapHeight(MEGA_WIDE_X_SIZE, 8) + 1;
    m_usrBmp1024 = CreateDIBitmap(hdcDesktop, &bitmapInfo, 0,  NULL, NULL,
            DIB_RGB_COLORS);
    if (!m_usrBmp1024)
    {
        ERROR_OUT(("USR_ShareStarting: failed to reate m_usrBmp1024"));
        DC_QUIT;
    }

    bitmapInfo.biHeight     = MaxBitmapHeight(MEGA_X_SIZE, 8) + 1;

    bitmapInfo.biWidth      = 256;
    m_usrBmp256 = CreateDIBitmap(hdcDesktop, &bitmapInfo, 0, NULL, NULL,
            DIB_RGB_COLORS);
    if (!m_usrBmp256)
    {
        ERROR_OUT(("USR_ShareStarting: failed to create m_usrBmp256"));
        DC_QUIT;
    }

    bitmapInfo.biWidth      = 128;
    m_usrBmp128 = CreateDIBitmap(hdcDesktop, &bitmapInfo, 0, NULL, NULL,
            DIB_RGB_COLORS);
    if (!m_usrBmp128)
    {
        ERROR_OUT(("USR_ShareStarting: failed to create m_usrBmp128"));
        DC_QUIT;
    }

    bitmapInfo.biWidth      = 112;
    m_usrBmp112 = CreateDIBitmap(hdcDesktop, &bitmapInfo, 0, NULL, NULL,
            DIB_RGB_COLORS);
    if (!m_usrBmp112)
    {
        ERROR_OUT(("USR_ShareStarting: failed to create m_usrBmp112"));
        DC_QUIT;
    }

    bitmapInfo.biWidth      = 96;
    m_usrBmp96  = CreateDIBitmap(hdcDesktop, &bitmapInfo, 0, NULL, NULL,
            DIB_RGB_COLORS);
    if (!m_usrBmp96)
    {
        ERROR_OUT(("USR_ShareStarting: failed to create m_usrBmp96"));
        DC_QUIT;
    }

    bitmapInfo.biWidth      = 80;
    m_usrBmp80  = CreateDIBitmap(hdcDesktop, &bitmapInfo, 0, NULL, NULL,
            DIB_RGB_COLORS);
    if (!m_usrBmp80)
    {
        ERROR_OUT(("USR_ShareStarting: failed to create m_usrBmp80"));
        DC_QUIT;
    }

    bitmapInfo.biWidth      = 64;
    m_usrBmp64  = CreateDIBitmap(hdcDesktop, &bitmapInfo, 0, NULL, NULL,
            DIB_RGB_COLORS);
    if (!m_usrBmp64)
    {
        ERROR_OUT(("USR_ShareStarting: failed to create m_usrBmp64"));
        DC_QUIT;
    }

    bitmapInfo.biWidth      = 48;
    m_usrBmp48  = CreateDIBitmap(hdcDesktop, &bitmapInfo, 0, NULL, NULL,
            DIB_RGB_COLORS);
    if (!m_usrBmp48)
    {
        ERROR_OUT(("USR_ShareStarting: failed to create m_usrBmp48"));
        DC_QUIT;
    }

    bitmapInfo.biWidth      = 32;
    m_usrBmp32  = CreateDIBitmap(hdcDesktop, &bitmapInfo, 0, NULL, NULL,
            DIB_RGB_COLORS);
    if (!m_usrBmp32)
    {
        ERROR_OUT(("USR_ShareStarting: failed to create m_usrBmp32"));
        DC_QUIT;
    }

    bitmapInfo.biWidth      = 16;
    m_usrBmp16  = CreateDIBitmap(hdcDesktop, &bitmapInfo, 0, NULL, NULL,
            DIB_RGB_COLORS);
    if (!m_usrBmp16)
    {
        ERROR_OUT(("USR_ShareStarting: failed to create m_usrBmp16"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    if (hdcDesktop)
    {
        ReleaseDC(NULL, hdcDesktop);
    }

    DebugExitBOOL(ASShare::USR_ShareStarting, rc);
    return(rc);
}



//
// USR_ShareEnded()
// Cleans up share resources
//
void ASShare::USR_ShareEnded(void)
{
    DebugEntry(ASShare::USR_ShareEnded);

    //
    // Delete Transfer Bitmaps.
    //
    if (m_usrBmp1024)
    {
        DeleteBitmap(m_usrBmp1024);
        m_usrBmp1024= NULL;
    }

    if (m_usrBmp256)
    {
        DeleteBitmap(m_usrBmp256);
        m_usrBmp256 = NULL;
    }

    if (m_usrBmp128)
    {
        DeleteBitmap(m_usrBmp128);
        m_usrBmp128 = NULL;
    }

    if (m_usrBmp112)
    {
        DeleteBitmap(m_usrBmp112);
        m_usrBmp112 = NULL;
    }

    if (m_usrBmp96)
    {
        DeleteBitmap(m_usrBmp96);
        m_usrBmp96 = NULL;
    }

    if (m_usrBmp80)
    {
        DeleteBitmap(m_usrBmp80);
        m_usrBmp80 = NULL;
    }

    if (m_usrBmp64)
    {
        DeleteBitmap(m_usrBmp64);
        m_usrBmp64 = NULL;
    }

    if (m_usrBmp48)
    {
        DeleteBitmap(m_usrBmp48);
        m_usrBmp48 = NULL;
    }

    if (m_usrBmp32)
    {
        DeleteBitmap(m_usrBmp32);
        m_usrBmp32 = NULL;
    }

    if (m_usrBmp16)
    {
        DeleteBitmap(m_usrBmp16);
        m_usrBmp16 = NULL;
    }

    //
    // Free Bitmap Buffer.
    //
    if (m_usrPBitmapBuffer != NULL)
    {
        delete[] m_usrPBitmapBuffer;
        m_usrPBitmapBuffer = NULL;
    }

    DebugExitVOID(ASShare::USR_ShareEnded);
}




//
// USR_RecalcCaps()
//
// DESCRIPTION:
//
// Enumerates the bitmap capabilities of all parties currently in the
// share, and determines the common capabilities.
//
// PARAMETERS: None.
//
// RETURNS: TRUE if there are good common caps, or false on failure (which
// has the effect of rejecting a new party from joining the share).
//
//
void  ASShare::USR_RecalcCaps(BOOL fJoiner)
{
    ASPerson *  pasT;
    UINT        capsMaxBPP;
    UINT        capsMinBPP;
    UINT        capsSupports4BPP;
    UINT        capsSupports8BPP;
    UINT        capsSupports24BPP;
    UINT        capsOldBPP;

    DebugEntry(ASShare::USR_RecalcCaps);

    if (!m_pHost)
    {
        // Nothing to do
        DC_QUIT;
    }

    ValidatePerson(m_pasLocal);

    capsOldBPP = m_pHost->m_usrSendingBPP;

    //
    // Init the caps
    //
    capsSupports4BPP    = m_pasLocal->cpcCaps.screen.capsSupports4BPP;
    capsSupports8BPP    = m_pasLocal->cpcCaps.screen.capsSupports8BPP;
    capsSupports24BPP   = m_pasLocal->cpcCaps.screen.capsSupports24BPP;
    capsMaxBPP          = 0;
    capsMinBPP          = 0xFFFFFFFF;

    for (pasT = m_pasLocal->pasNext; pasT != NULL; pasT = pasT->pasNext)
    {
        //
        // Check the bpps supported.
        //
        if (pasT->cpcCaps.screen.capsSupports4BPP != CAPS_SUPPORTED)
        {
            capsSupports4BPP = CAPS_UNSUPPORTED;
        }
        if (pasT->cpcCaps.screen.capsSupports8BPP != CAPS_SUPPORTED)
        {
            capsSupports8BPP = CAPS_UNSUPPORTED;
        }
        if (pasT->cpcCaps.screen.capsSupports24BPP != CAPS_SUPPORTED)
        {
            capsSupports24BPP = CAPS_UNSUPPORTED;
        }

        //
        // Set the combined bpp to the maximum so far found.
        // (If we send data at this bpp then one of the remote systems can
        // usefully process this number of colors).
        //
        capsMaxBPP = max(capsMaxBPP, pasT->cpcCaps.screen.capsBPP);
        capsMinBPP = min(capsMinBPP, pasT->cpcCaps.screen.capsBPP);
    }

    //
    // Now figure out what BPP we will transmit at.
    //
    //
    // Limit the combined caps bpp (which is currently the maximum bpp that
    // any system in the share wants) to the local bpp, since there is no
    // point sending at higher bpp than the local machine has.
    //
    capsMaxBPP = min(capsMaxBPP, g_usrScreenBPP);
    if (!capsMaxBPP)
        capsMaxBPP = g_usrScreenBPP;

    capsMinBPP = min(capsMinBPP, g_usrScreenBPP);

    //
    // m_usrSendingBPP is most often going to be 8.  So it's easier to assume
    // it, then check for cases where it won't be.
    //
    m_pHost->m_usrSendingBPP = 8;

    if ((capsMaxBPP <= 4) && (capsSupports4BPP == CAPS_SUPPORTED))
    {
        m_pHost->m_usrSendingBPP = 4;
    }
    else if ((capsMinBPP >= 24) &&
             (g_asSettings & SHP_SETTING_TRUECOLOR) &&
             (capsSupports24BPP == CAPS_SUPPORTED))
    {
        m_pHost->m_usrSendingBPP = 24;
    }

    if (capsOldBPP != m_pHost->m_usrSendingBPP)
    {
        //
        // If switching to/from palettized, we need to update the
        // "need to send palette" flag.  Note that 4bpp is also a
        // palettized color depth.
        //
        if ((capsOldBPP <= 8) && (m_pHost->m_usrSendingBPP > 8))
            m_pHost->m_pmMustSendPalette = FALSE;
        else if ((capsOldBPP > 8) && (m_pHost->m_usrSendingBPP <= 8))
            m_pHost->m_pmMustSendPalette = TRUE;

#ifdef _DEBUG
        if (capsOldBPP == 24)
        {
            WARNING_OUT(("TRUE COLOR SHARING is now FINISHED"));
        }
        else if (m_pHost->m_usrSendingBPP == 24)
        {
            WARNING_OUT(("TRUE COLOR SHARING is now STARTING"));
        }
#endif

        if (!fJoiner)
        {
            //
            // Sending BPP changed.  Repaint all shared stuff.
            // NOTE:
            // We recalc the sendBPP at three points:
            //      * When we start to share
            //      * When a person joins
            //      * When a person leaves
            //
            // In the first two cases, shared stuff is repainted,
            // so everybody gets the new sendBPP data.  Only in the
            // leave case do we need to force this.
            //
            m_pHost->HET_RepaintAll();
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::USR_RecalcCaps);
}


//
// USR_HostStarting()
//
BOOL ASHost::USR_HostStarting(void)
{
    BOOL    rc = FALSE;
    HDC     hdc;

    DebugEntry(ASHost::USR_HostStarting);

    //
    // Create scratch DC
    //
    hdc = GetDC(NULL);
    if (!hdc)
    {
        ERROR_OUT(("USR_HostStarting: can't get screen DC"));
        DC_QUIT;
    }

    m_usrWorkDC = CreateCompatibleDC(hdc);
    ReleaseDC(NULL, hdc);

    if (!m_usrWorkDC)
    {
        ERROR_OUT(("USR_HostStarting: can't create m_usrWorkDC"));
        DC_QUIT;
    }

    m_pShare->USR_RecalcCaps(TRUE);

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::USR_HostStarting, rc);
    return(rc);
}



//
// USR_HostEnded()
//
void ASHost::USR_HostEnded(void)
{
    DebugEntry(ASHost::USR_HostEnded);

    if (m_usrWorkDC != NULL)
    {
        DeleteDC(m_usrWorkDC);
        m_usrWorkDC = NULL;
    }

    DebugExitVOID(ASHost::USR_HostEnded);
}




//
// USR_ScrollDesktop
//
void  ASShare::USR_ScrollDesktop
(
    ASPerson *  pasPerson,
    int         xNew,
    int         yNew
)
{
    int         xOld;
    int         yOld;

    DebugEntry(ASShare::USR_ScrollDesktop);

    ValidateView(pasPerson);

    //
    // If the origin has changed then do the update.
    //
    xOld = pasPerson->m_pView->m_dsScreenOrigin.x;
    yOld = pasPerson->m_pView->m_dsScreenOrigin.y;

    if ((xOld != xNew) || (yOld != yNew))
    {
        pasPerson->m_pView->m_dsScreenOrigin.x = xNew;
        pasPerson->m_pView->m_dsScreenOrigin.y = yNew;

        //
        // We must ensure that data written to the ScreenBitmap is not
        // clipped
        //
        OD_ResetRectRegion(pasPerson);

        //
        // Offset the existing bitmap by the change in desktop origins.
        //

        BitBlt(pasPerson->m_pView->m_usrDC,
                          0,
                          0,
                          pasPerson->cpcCaps.screen.capsScreenWidth,
                          pasPerson->cpcCaps.screen.capsScreenHeight,
                          pasPerson->m_pView->m_usrDC,
                          xNew - xOld,
                          yNew - yOld,
                          SRCCOPY);

        //
        // Offset the shadow cursor pos -- same place on remote screen
        // but now different place in VD
        //
        pasPerson->cmPos.x += xNew - xOld;
        pasPerson->cmPos.y += yNew - yOld;

        //
        // Repaint the view
        //
        VIEW_InvalidateRgn(pasPerson, NULL);
    }

    DebugExitVOID(ASShare::USR_ScrollDesktop);
}



//
// FUNCTION: USR_InitDIBitmapHeader
//
// DESCRIPTION:
//
// Initialises a Device Independent bitmap header to be the given bits per
// pel.
//
// PARAMETERS:
//
// pbh - pointer to the bitmap header to be initialised.
// bpp - bpp to be used for the bitmap
//
// RETURNS: VOID
//
//
void  ASShare::USR_InitDIBitmapHeader
(
    BITMAPINFOHEADER *  pbh,
    UINT                bpp
)
{
    DebugEntry(ASShare::USR_InitDIBitmapHeader);

    pbh->biSize          = sizeof(BITMAPINFOHEADER);
    pbh->biPlanes        = 1;
    pbh->biBitCount      = (WORD)bpp;
    pbh->biCompression   = BI_RGB;
    pbh->biSizeImage     = 0;
    pbh->biXPelsPerMeter = 10000;
    pbh->biYPelsPerMeter = 10000;
    pbh->biClrUsed       = 0;
    pbh->biClrImportant  = 0;

    DebugExitVOID(ASShare::USR_InitDIBitmapHeader);
}



//
// USR_ViewStarting()
//
// Called when someone we're viewing starts to host.  We create the desktop
// bitmap for them plus scratch objects
//
BOOL  ASShare::USR_ViewStarting(ASPerson *  pasPerson)
{
    BOOL   rc;

    DebugEntry(ASShare::USR_ViewStarting);

    ValidateView(pasPerson);

    //
    // Create a bitmap for this new party
    //
    rc = USRCreateRemoteDesktop(pasPerson);

    DebugExitBOOL(ASShare::USR_ViewStarting, rc);
    return(rc);
}


//
// FUNCTION: USRCreateRemoteDesktop
//
// DESCRIPTION:
//
// Creates the shadow bitmap for a remote party.
//
// PARAMETERS:
//
// personID - person to create the shadow bitmap for.
//
// RETURNS: TRUE if successful, FALSE otherwise.
//
//
BOOL  ASShare::USRCreateRemoteDesktop(ASPerson * pasPerson)
{
    BOOL            rc = FALSE;
    HDC             hdcDesktop = NULL;
    RECT            desktopRect;

    DebugEntry(ASShare::USRCreateRemoteDesktop);

    ValidateView(pasPerson);

    ASSERT(pasPerson->m_pView->m_usrDC == NULL);
    ASSERT(pasPerson->m_pView->m_usrBitmap == NULL);
    ASSERT(pasPerson->m_pView->m_usrOldBitmap == NULL);

    hdcDesktop = GetDC(NULL);

    //
    // Create the scratch DC
    //
    pasPerson->m_pView->m_usrWorkDC = CreateCompatibleDC(hdcDesktop);
    if (!pasPerson->m_pView->m_usrWorkDC)
    {
        ERROR_OUT(("Couldn't create workDC for person [%d]", pasPerson->mcsID));
        DC_QUIT;
    }

    //
    // Create the DC that keeps the screen bitmap for this party
    //
    pasPerson->m_pView->m_usrDC = CreateCompatibleDC(hdcDesktop);
    if (!pasPerson->m_pView->m_usrDC)
    {
        ERROR_OUT(("Couldn't create usrDC for person [%d]", pasPerson->mcsID));
        DC_QUIT;
    }

    //
    // We can't use this person's usrDC, since that currently has a MONO
    // bitmap selected into it.
    //
    pasPerson->m_pView->m_usrBitmap = CreateCompatibleBitmap(hdcDesktop, pasPerson->cpcCaps.screen.capsScreenWidth, pasPerson->cpcCaps.screen.capsScreenHeight);
    if (pasPerson->m_pView->m_usrBitmap == NULL)
    {
        ERROR_OUT(("Couldn't create screen bitmap for [%d]", pasPerson->mcsID));
        DC_QUIT;
    }

    //
    // Select the screen bitmap into the person's DC, and save the previous
    // 1x1 bitmap away, so we can deselect it when done.
    //
    pasPerson->m_pView->m_usrOldBitmap = SelectBitmap(pasPerson->m_pView->m_usrDC, pasPerson->m_pView->m_usrBitmap);

    //
    // Fill the Screen Bitmap with grey.
    //
    // In practice the Shadow Window Presenter(SWP) should never display
    // any area of the Screen Bitmap that has not been updated with data
    // from a remote system.
    //
    // Therefore this operation is just "insurance" in case the SWP goes
    // wrong and momentarily displays a non-updated area - a flash of grey
    // is better than a flash of garbage.
    //
    desktopRect.left = 0;
    desktopRect.top = 0;
    desktopRect.right = pasPerson->cpcCaps.screen.capsScreenWidth;
    desktopRect.bottom = pasPerson->cpcCaps.screen.capsScreenHeight;

    FillRect(pasPerson->m_pView->m_usrDC, &desktopRect, GetSysColorBrush(COLOR_APPWORKSPACE));
    rc = TRUE;

DC_EXIT_POINT:

    if (hdcDesktop != NULL)
    {
        ReleaseDC(NULL, hdcDesktop);
    }

    DebugExitBOOL(ASShare::USRCreateRemoteDesktop, rc);
    return(rc);
}



//
// USR_ViewEnded()
//
// Called when person we're viewing stops hosting.  We get rid of their
// desktop bitmap.
//
void  ASShare::USR_ViewEnded(ASPerson *  pasPerson)
{
    ValidateView(pasPerson);

    //
    // Delete the desktop bitmap for the party that has left
    //
    USRDeleteRemoteDesktop(pasPerson);
}


//
// FUNCTION: USRDeleteRemoteDesktop
//
// DESCRIPTION:
//
// Deletes a remote party's shadow bitmap.
//
// PARAMETERS:
//
// personID - party whose shadow bitmap is to be deleted.
//
// RETURNS: Nothing.
//
//
void  ASShare::USRDeleteRemoteDesktop(ASPerson * pasPerson)
{
    DebugEntry(ASShare::USRDeleteRemoteDesktop);

    ValidateView(pasPerson);

    if (pasPerson->m_pView->m_usrOldBitmap != NULL)
    {
        // Deselect screen bitmap
        SelectBitmap(pasPerson->m_pView->m_usrDC, pasPerson->m_pView->m_usrOldBitmap);
        pasPerson->m_pView->m_usrOldBitmap = NULL;
    }

    if (pasPerson->m_pView->m_usrBitmap != NULL)
    {
        // Delete the screen bitmap
        DeleteBitmap(pasPerson->m_pView->m_usrBitmap);
        pasPerson->m_pView->m_usrBitmap = NULL;
    }

    if (pasPerson->m_pView->m_usrDC != NULL)
    {
        //
        // Delete the screen DC.  Created objects should have
        // been selected out of it before now.
        //
        DeleteDC(pasPerson->m_pView->m_usrDC);
        pasPerson->m_pView->m_usrDC = NULL;
    }

    if (pasPerson->m_pView->m_usrWorkDC != NULL)
    {
        DeleteDC(pasPerson->m_pView->m_usrWorkDC);
        pasPerson->m_pView->m_usrWorkDC = NULL;
    }

    DebugExitVOID(ASShare::USRDeleteRemoteDesktop);
}




//
// This function is a mess! First because it ought to be an FH API
// function, and secondly because it mixes portable code and Windows API
// calls. The details of what is to be done with it are deferred until the
// UNIX port of FH is designed, though. STOPPRESS! Function replaced by new
// FH_CreateAndSelectFont, which combines old USR_UseFont and
// FH_CreateAndSelectFont - you have to write an NT version.
//
//
// USR_UseFont()
//
BOOL  ASShare::USR_UseFont
(
    HDC             surface,
    HFONT*          pHFont,
    TEXTMETRIC*     pFontMetrics,
    LPSTR           pName,
    UINT            codePage,
    UINT            MaxHeight,
    UINT            Height,
    UINT            Width,
    UINT            Weight,
    UINT            flags
)
{
    BOOL      rc = FALSE;
    HFONT     hNewFont;
    HFONT     hOldFont;

    DebugEntry(ASShare::USR_UseFont);

    rc = FH_CreateAndSelectFont(surface,
                                &hNewFont,
                                &hOldFont,
                                pName,
                                codePage,
                                MaxHeight,
                                Height,
                                Width,
                                Weight,
                                flags);

    if (rc == FALSE)
    {
        //
        // Failed to create or select the font.
        //
        DC_QUIT;
    }

    //
    // Select in the new font which ensures that the old one is deselected.
    //
    // NB.  We do not delete the font we are deselecting, rather the old
    // one that was passed to us.  This is beacuse multiple components use
    // "surface", and so the deselected font may not be the current
    // component's last font at all - the important thing is that by
    // selecting in the new font we are ensuring that the old font is not
    // the selected one.
    //
    SelectFont(surface, hNewFont);
    if (*pHFont)
    {
        DeleteFont(*pHFont);
    }

    //
    // If a pointer to font metrics was passed in then we need to query
    // the metrics now.
    //
    if (pFontMetrics)
        GetTextMetrics(surface, pFontMetrics);

    //
    // Update the record of the last font we selected.
    //
    *pHFont = hNewFont;
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(ASShare::USR_UseFont, rc);
    return(rc);
}

//
// USR_ScreenChanged()
//
void  ASShare::USR_ScreenChanged(ASPerson * pasPerson)
{
    DebugEntry(ASShare::USR_ScreenChanged);

    ValidatePerson(pasPerson);

    pasPerson->cpcCaps.screen.capsScreenWidth = pasPerson->cpcCaps.screen.capsScreenWidth;
    pasPerson->cpcCaps.screen.capsScreenHeight = pasPerson->cpcCaps.screen.capsScreenHeight;

    if (pasPerson->m_pView)
    {
        //
        // Recreate screen bitmap
        //

        //
        // Discard the remote users current shadow bitmap
        //
        USRDeleteRemoteDesktop(pasPerson);

        //
        // Create a new shadow bitmap for remote user that is of the new size
        //
        USRCreateRemoteDesktop(pasPerson);
    }

    VIEW_ScreenChanged(pasPerson);

    DebugExitVOID(ASShare::USR_ScreenChanged);
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\ut.cpp ===
#include "precomp.h"


//
// UT.CPP
// Utility Functions
//
#include <limits.h>
#include <process.h>
#include <mmsystem.h>
#include <confreg.h>

#define MLZ_FILE_ZONE  ZONE_UT



//
//
// UT_InitTask(...)
//
//
BOOL UT_InitTask
(
    UT_TASK         task,
    PUT_CLIENT *    pputTask
)
{
    BOOL            fInit = FALSE;
    BOOL            locked    = FALSE;
    PUT_CLIENT      putTask = NULL;

    DebugEntry(UT_InitTask);

    UT_Lock(UTLOCK_UT);

    //
    // Initialise handle to NULL
    //
    *pputTask = NULL;

    ASSERT(task >= UTTASK_FIRST);
    ASSERT(task < UTTASK_MAX);

    //
    // The UT_TASK is an index into the tasks array.
    //
    putTask = &(g_autTasks[task]);

    if (putTask->dwThreadId)
    {
        ERROR_OUT(("Task %d already exists", task));
        putTask = NULL;
        DC_QUIT;
    }

    ZeroMemory(putTask, sizeof(UT_CLIENT));

    //
    // Call routine to set up the process id information in the task CB.
    //
    putTask->dwThreadId   =   GetCurrentThreadId();

    //
    // Create the window
    //
    putTask->utHwnd = CreateWindow(MAKEINTATOM(g_utWndClass),
                            NULL,               // name
                            0,                  // style
                            1,                  // x
                            1,                  // y
                            200,                // width
                            100,                // height
                            NULL,               // parent
                            NULL,               // menu
                            g_asInstance,
                            NULL);              // create struct
    if (!putTask->utHwnd)
    {
        ERROR_OUT(("Failed to create UT msg window"));
        DC_QUIT;
    }

    //
    // Now store the UT handle in the user data associated with the
    // window.  We will use this to get the UT handle when we are in
    // the event procedure.
    //

	SetWindowLongPtr(putTask->utHwnd, GWLP_USERDATA, (LPARAM)putTask);

    fInit = TRUE;

DC_EXIT_POINT:
    //
    // Callers will call UT_TermTask() on error, which will bump down
    // the shared memory count.  So we have no clean up on error here.
    //
    *pputTask = putTask;

    //
    // Release access to task stuff
    //
    UT_Unlock(UTLOCK_UT);

    DebugExitBOOL(UT_InitTask, fInit);
    return(fInit);
}



//
// UT_TermTask(...)
//
void UT_TermTask(PUT_CLIENT * pputTask)
{
    DebugEntry(UT_TermTask);

    //
    // Check that the putTask is valid
    //
    if (!*pputTask)
    {
        WARNING_OUT(("UT_TermTask: null task"));
        DC_QUIT;
    }

	UTTaskEnd(*pputTask);
    *pputTask = NULL;

DC_EXIT_POINT:

    DebugExitVOID(UT_TermTask);
}


//
//
// UTTaskEnd(...)
//
//
void UTTaskEnd(PUT_CLIENT putTask)
{
    int                 i;
    PUTEXIT_PROC_INFO   pExit;
    PUTEVENT_INFO       pEventInfo;

    DebugEntry(UTTaskEnd);

    UT_Lock(UTLOCK_UT);

    if (!putTask->dwThreadId)
    {
        // Nothing to do
        DC_QUIT;
    }

    ValidateUTClient(putTask);

    //
    // Call any registered exit procedures.  Since we guarantee to call
    // exit procs in the reverse order to the order they were registered,
    // we start at the end of the array and call each proc in turn back to
    // the first one registered:
    //
    TRACE_OUT(("Calling exit procedures..."));
    for (i = UTEXIT_PROCS_MAX-1 ; i >= 0; i--)
    {
        pExit = &(putTask->exitProcs[i]);

        if (pExit->exitProc != NULL)
        {
            pExit->exitProc(pExit->exitData);

            //
            // If any exit proc still exists in slot i, then this proc has
            // failed to deregister itself.  This is not mandatory but is
            // expected.
            //
            if (pExit->exitProc != NULL)
            {
               TRACE_OUT(("Exit proc 0x%08x failed to deregister itself when called",
                      pExit->exitProc));
            }
        }
    }

    //
    // Free delayed events
    //
    pEventInfo = (PUTEVENT_INFO)COM_BasedListFirst(&(putTask->delayedEvents),
        FIELD_OFFSET(UTEVENT_INFO, chain));
    while (pEventInfo != NULL)
    {
        COM_BasedListRemove(&(pEventInfo->chain));
        delete pEventInfo;

        pEventInfo = (PUTEVENT_INFO)COM_BasedListFirst(&(putTask->delayedEvents),
            FIELD_OFFSET(UTEVENT_INFO, chain));
    }

    //
    // Free pending events
    //
    pEventInfo = (PUTEVENT_INFO)COM_BasedListFirst(&(putTask->pendingEvents),
        FIELD_OFFSET(UTEVENT_INFO, chain));
    while (pEventInfo != NULL)
    {
        COM_BasedListRemove(&(pEventInfo->chain));
        delete pEventInfo;

        pEventInfo = (PUTEVENT_INFO)COM_BasedListFirst(&(putTask->pendingEvents),
            FIELD_OFFSET(UTEVENT_INFO, chain));
    }

    //
    // If we created a window to post UT events to for this task, then
    // destroy the window.  This will also kill all the timers which are
    // pending for this window.
    //
    if (putTask->utHwnd != NULL)
    {
        DestroyWindow(putTask->utHwnd);
        putTask->utHwnd = NULL;
    }

    //
    // Clear out the thread ID
    //
    putTask->dwThreadId = 0;


DC_EXIT_POINT:
    UT_Unlock(UTLOCK_UT);

    DebugExitVOID(UTTaskEnd);
}



//
//
// UT_RegisterEvent(...)
//
//
void WINAPI UT_RegisterEvent
(
    PUT_CLIENT      putTask,
    UTEVENT_PROC    eventProc,
    LPVOID          eventData,
    UT_PRIORITY     priority
)
{
    int             i;
    PUTEVENT_PROC_INFO  pEventProcData;

    DebugEntry(UT_RegisterEvent);

    ValidateUTClient(putTask);

    //
    // Check that the priority is valid
    //
    ASSERT(priority <= UT_PRIORITY_MAX);

    //
    // Check that we have room for this event handler
    //
    pEventProcData = putTask->eventHandlers;
    ASSERT(pEventProcData[UTEVENT_HANDLERS_MAX-1].eventProc == NULL);

    //
    // Find the place to insert this event handler
    //
    TRACE_OUT(("Looking for pos for event proc at priority %d", priority));

    for (i = 0; i < UTEVENT_HANDLERS_MAX; i++)
    {
        if (pEventProcData[i].eventProc == NULL)
        {
            TRACE_OUT(("Found NULL slot at position %d", i));
            break;
        }

        if (pEventProcData[i].priority <= priority)
        {
            TRACE_OUT(("Found event proc of priority %d at pos %d",
                        pEventProcData[i].priority, i));
            break;
        }
    }

    //
    // Shift all lower and equal priority event handlers down a slot
    //
    UT_MoveMemory(&pEventProcData[i+1], &pEventProcData[i],
        sizeof(UTEVENT_PROC_INFO) * (UTEVENT_HANDLERS_MAX - 1 - i));

    pEventProcData[i].eventProc    = eventProc;
    pEventProcData[i].eventData    = eventData;
    pEventProcData[i].priority     = priority;

    DebugExitVOID(UT_RegisterEvent);
}




//
//
// UT_DeregisterEvent(...)
//
//
void UT_DeregisterEvent
(
    PUT_CLIENT          putTask,
    UTEVENT_PROC        eventProc,
    LPVOID              eventData
)
{
    int                 i;
    BOOL                found = FALSE;

    DebugEntry(UT_DeregisterEvent);

    ValidateUTClient(putTask);

    //
    // Find the Event handler
    //
    for (i = 0; i < UTEVENT_HANDLERS_MAX; i++)
    {
        if ( (putTask->eventHandlers[i].eventProc == eventProc) &&
             (putTask->eventHandlers[i].eventData == eventData) )
        {
            //
            // Found handler - shuffle down stack on top of it
            //
            TRACE_OUT(("Deregistering event proc 0x%08x from position %d",
                     eventProc, i));
            found = TRUE;

            //
            // Slide all the other event procs up one
            //
            UT_MoveMemory(&putTask->eventHandlers[i],
                &putTask->eventHandlers[i+1],
                sizeof(UTEVENT_PROC_INFO) * (UTEVENT_HANDLERS_MAX - 1 - i));

            putTask->eventHandlers[UTEVENT_HANDLERS_MAX-1].eventProc = NULL;
            break;
        }
    }

    //
    // Check that we found the event handler
    //
    ASSERT(found);

    DebugExitVOID(UT_DeregisterEvent);
}


//
//
// UT_PostEvent(...)
//
//
void UT_PostEvent
(
    PUT_CLIENT  putFrom,
    PUT_CLIENT  putTo,
    UINT        delay,
    UINT        eventNo,
    UINT_PTR    param1,
    UINT_PTR    param2
)
{
    DebugEntry(UT_PostEvent);

    //
    // Get exclusive access to the UTM while we move event pool entries --
    // we are changing fields in a task, so we need to protect it.
    //
    UT_Lock(UTLOCK_UT);

    if (!putTo || (putTo->utHwnd == NULL))
    {
        TRACE_OUT(("NULL destination task %x in UT_PostEvent", putTo));
        DC_QUIT;
    }

    ValidateUTClient(putFrom);
    ValidateUTClient(putTo);

    if (delay != 0)
    {
        //
        // A delay was specified...
        //
        UTPostDelayedEvt(putFrom, putTo, delay, eventNo, param1, param2);
    }
    else
    {
        //
        // No delay specified - post the event now
        //
        UTPostImmediateEvt(putFrom, putTo, eventNo, param1, param2);
    }

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_UT);

    DebugExitVOID(UT_PostEvent);
}



//
// UTPostImmediateEvt(...)
//
void UTPostImmediateEvt
(
    PUT_CLIENT      putFrom,
    PUT_CLIENT      putTo,
    UINT            event,
    UINT_PTR        param1,
    UINT_PTR        param2
)
{
    PUTEVENT_INFO   pEventInfo;
    BOOL            destQueueEmpty;

    DebugEntry(UTPostImmediateEvt);

    TRACE_OUT(("Posting event %d (%#.4hx, %#.8lx) from 0x%08x to 0x%08x",
             event,
             param1,
             param2,
             putFrom, putTo));

    //
    // Allocate an event.
    //
    pEventInfo = new UTEVENT_INFO;
    if (!pEventInfo)
    {
        WARNING_OUT(("UTPostImmediateEvent failed; out of memory"));
        DC_QUIT;
    }
    ZeroMemory(pEventInfo, sizeof(*pEventInfo));
    SET_STAMP(pEventInfo, UTEVENT);

    //
    // Determine whether the target queue is empty
    //
    destQueueEmpty = COM_BasedListIsEmpty(&(putTo->pendingEvents));

    //
    // Copy the event into the memory
    //
    pEventInfo->putTo       = putTo;
    pEventInfo->popTime     = 0;
    pEventInfo->event       = event;
    pEventInfo->param1      = param1;
    pEventInfo->param2      = param2;

    //
    // Add to the end of the target queue
    //
    COM_BasedListInsertBefore(&(putTo->pendingEvents), &(pEventInfo->chain));

    //
    // If the target queue was empty, or the destination task is currently
    // waiting for an event (in UT_WaitEvent()), we have to post a trigger
    // event to get it to check its event queue.
    //
    if (destQueueEmpty)
    {
        UTTriggerEvt(putFrom, putTo);
    }

DC_EXIT_POINT:
    DebugExitVOID(UTPostImmediateEvt);
}


//
//
// UTPostDelayedEvt(...)
//
//
void UTPostDelayedEvt
(
    PUT_CLIENT          putFrom,
    PUT_CLIENT          putTo,
    UINT                delay,
    UINT                event,
    UINT_PTR            param1,
    UINT_PTR            param2
)
{
    PUTEVENT_INFO       pDelayedEventInfo;
    PUTEVENT_INFO       pTempEventInfo;
    BOOL                firstDelayed = TRUE;

    DebugEntry(UTPostDelayedEvt);

    TRACE_OUT(("Posting delayed event %d (%#.4hx, %#.8lx) " \
                 "from 0x%08x to 0x%08x, delay %u ms",
             event,
             param1,
             param2, putFrom, putTo, delay));

    //
    // Get an entry from the event pool of the destination
    //
    pDelayedEventInfo = new UTEVENT_INFO;
    if (!pDelayedEventInfo)
    {
        ERROR_OUT(("UTPostDelayedEvt failed; out of memory"));
        DC_QUIT;
    }
    ZeroMemory(pDelayedEventInfo, sizeof(*pDelayedEventInfo));
    SET_STAMP(pDelayedEventInfo, UTEVENT);

    //
    // Copy the event into the memory
    //
    pDelayedEventInfo->putTo   = putTo;
    pDelayedEventInfo->popTime = GetTickCount() + delay;
    pDelayedEventInfo->event   = event;
    pDelayedEventInfo->param1  = param1;
    pDelayedEventInfo->param2  = param2;
    TRACE_OUT(("This event set to pop at %x",
            pDelayedEventInfo->popTime));

    //
    // Insert the delayed event into the delayed queue at the sender.  The
    // list is ordered by the time the event needs to be scheduled.
    //
    pTempEventInfo = (PUTEVENT_INFO)COM_BasedListFirst(&(putFrom->delayedEvents),
        FIELD_OFFSET(UTEVENT_INFO, chain));

    while (pTempEventInfo != NULL)
    {
        ValidateEventInfo(pTempEventInfo);

        TRACE_OUT(("Check if before %d popTime %x",
                pTempEventInfo->event, pTempEventInfo->popTime));
        if (pTempEventInfo->popTime > pDelayedEventInfo->popTime)
        {
            //
            // we have found the first event in the list which pops after
            // this event so insert before it.
            //
            break;
        }

        pTempEventInfo = (PUTEVENT_INFO)COM_BasedListNext(&(putFrom->delayedEvents),
            pTempEventInfo, FIELD_OFFSET(UTEVENT_INFO, chain));
        //
        // Flag that we are not the first delayed event so we know not to
        // (re)start a timer.
        //
        firstDelayed = FALSE;
    }

    if (pTempEventInfo == NULL)
    {
        //
        // After all in queue so add to end
        //
        COM_BasedListInsertBefore(&(putFrom->delayedEvents),
                             &(pDelayedEventInfo->chain));
    }
    else
    {
        //
        // Delayed event pops before pTempEventInfo so insert before.
        //
        COM_BasedListInsertBefore(&(pTempEventInfo->chain),
                             &(pDelayedEventInfo->chain));
    }

    //
    // If we have inserted the delayed event at the front of the queue then
    // restart the timer with the time this event is set to pop.
    //
    if (firstDelayed)
    {
        UTStartDelayedEventTimer(putFrom, pDelayedEventInfo->popTime);
    }

DC_EXIT_POINT:
    DebugExitVOID(UTPostDelayedEvt);
}


//
//
// UTCheckDelayedEvents(...)
//
//
void UTCheckDelayedEvents
(
    PUT_CLIENT      putTask
)
{
    PUT_CLIENT      putTo;
    UINT            timeNow;
    PUTEVENT_INFO   pEventInfo;

    DebugEntry(UTCheckDelayedEvents);

    //
    // Get exclusive access to the UTM while we move event pool entries
    // (these are in shared memory)
    //
    UT_Lock(UTLOCK_UT);

    ValidateUTClient(putTask);

    //
    // Get time now to check against popTime.
    //
    timeNow = GetTickCount();
    TRACE_OUT(("time now is %x", timeNow));

    //
    // Move through the queue of delayed events to see if any have popped.
    // If so send them immediately.  When we get to the first one that
    // hasn't popped restart a timer to schedule it.
    //
    pEventInfo = (PUTEVENT_INFO)COM_BasedListFirst(&(putTask->delayedEvents),
        FIELD_OFFSET(UTEVENT_INFO, chain));
    while (pEventInfo != NULL)
    {
        ValidateEventInfo(pEventInfo);

        //
        // Got an event so check to see if it has popped
        //
        TRACE_OUT(("Event popTime is %x", pEventInfo->popTime));
        if (timeNow >= pEventInfo->popTime)
        {
            TRACE_OUT(("Event popped so post now"));
            //
            // Event has popped so remove from delayed queue and post as an
            // immediate event.
            //
            COM_BasedListRemove(&(pEventInfo->chain));

            //
            // The check on the destination handle should be less strict
            // than that on the source (we shouldn't assert).  This is
            // because the caller may be pre-empted before this check is
            // done, and the destination may shut down in this time.
            //
            ValidateUTClient(pEventInfo->putTo);

            UTPostImmediateEvt(putTask, pEventInfo->putTo,
                                   pEventInfo->event,
                                   pEventInfo->param1,
                                   pEventInfo->param2);

            //
            // Free the event
            //
            delete pEventInfo;

            //
            // Last one popped so move on to next to see if that has popped
            // too.
            //
            pEventInfo = (PUTEVENT_INFO)COM_BasedListFirst(&(putTask->delayedEvents),
                FIELD_OFFSET(UTEVENT_INFO, chain));
        }
        else
        {
            //
            // got to an event which hasn't popped yet.  Start timer to pop
            // for this one.  The OS specific code in UTStartDelayedEventTimer checks
            // to see if the new timer is required (not already running)
            // and will stop and restart if already running but has the
            // incorrect timeout.
            //
            TRACE_OUT(("Event not popped so restart timer and leave"));
            UTStartDelayedEventTimer(putTask, pEventInfo->popTime);
            break;
        }
    }

    UT_Unlock(UTLOCK_UT);

    DebugExitVOID(UTCheckDelayedEvents);
}



//
// UTProcessEvent(...)
//
void UTProcessEvent
(
    PUT_CLIENT          putTask,
    UINT                event,
    UINT_PTR            param1,
    UINT_PTR            param2
)
{
    int                 i;
    PUTEVENT_PROC_INFO  pEventHandler;

    DebugEntry(UTProcessEvent);

    ValidateUTClient(putTask);

    //
    // Call all registered event handlers until somebody returns TRUE, that
    // the event has been processed.
    //
    for (i = 0; i < UTEVENT_HANDLERS_MAX ; i++)
    {
        pEventHandler = &(putTask->eventHandlers[i]);

        if (pEventHandler->eventProc == NULL)
        {
            //
            // Nothing's here.
            //
            break;
        }

        //
        // Call the registered event handler
        //
        TRACE_OUT(("Call event proc 0x%08x priority %d from position %d",
                   pEventHandler->eventProc,
                   pEventHandler->priority,
                   i));
        if ((pEventHandler->eventProc)(pEventHandler->eventData, event,
                param1, param2))
        {
            //
            // Event handler processed event
            //
            break;
        }
    }

    DebugExitVOID(UTProcessEvent);
}


//
//
//
// EXIT PROCS
//
// Our strategy for registering/deregistering/calling exit procs is as
// follows:
//
// - we register procs in the first free slot in the array hung off the
//   task data
//
// - we deregister procs by shuffling down other procs after it in the
//   array
//
// - we call procs starting at the last entry in the array and working
//   backwards.
//
// The above ensures that
//
// - if a proc deregisters itself before task termination, no gaps are
//   left in the array
//
// - if a proc deregisters itself during task termination, all
//   remaining procs are called in the correct order
//
// - if a proc doesn't deregister itself during task termination, it is
//   left in the array but does not affect future processing as the task
//   end loop will call the previous one anyway.
//
//
//

//
//
// UT_RegisterExit(...)
//
//
void UT_RegisterExit
(
    PUT_CLIENT  putTask,
    UTEXIT_PROC exitProc,
    LPVOID      exitData
)
{
    int                 i;
    PUTEXIT_PROC_INFO   pExitProcs;

    DebugEntry(UT_RegisterExit);

    ValidateUTClient(putTask);

    pExitProcs = putTask->exitProcs;
    ASSERT(pExitProcs[UTEXIT_PROCS_MAX-1].exitProc == NULL);

    //
    // Now we look for the first free slot in the array, since we guarantee
    // to call exit procs in the order they were registered in:
    //
    for (i = 0; i < UTEXIT_PROCS_MAX; i++)
    {
        if (pExitProcs[i].exitProc == NULL)
        {
            TRACE_OUT(("Storing exit proc 0x%08x data 0x%08x at position %d",
                exitProc, exitData, i));

            pExitProcs[i].exitProc = exitProc;
            pExitProcs[i].exitData = exitData;
            break;
        }
    }

    ASSERT(i < UTEXIT_PROCS_MAX);


    DebugExitVOID(UT_RegisterExit);
}


//
//
// UT_DeregisterExit(...)
//
//
void UT_DeregisterExit
(
    PUT_CLIENT      putTask,
    UTEXIT_PROC     exitProc,
    LPVOID          exitData
)
{
    int                i;
    BOOL               found = FALSE;
    PUTEXIT_PROC_INFO  pExitProcs;

    DebugEntry(UT_DeregisterExit);

    ValidateUTClient(putTask);

    pExitProcs = putTask->exitProcs;

    //
    // Find this exit proc
    //
    for (i = 0 ; i < UTEXIT_PROCS_MAX; i++)
    {

        if ((pExitProcs[i].exitProc == exitProc) &&
            (pExitProcs[i].exitData == exitData))
        {
            //
            // Found exit proc.  Shuffle list down.
            //
            TRACE_OUT(("Deregistering exit proc 0x%08x from position %d",
                 exitProc, i));
            found = TRUE;

            UT_MoveMemory(&pExitProcs[i],
                &pExitProcs[i+1],
                sizeof(UTEXIT_PROC_INFO) * (UTEXIT_PROCS_MAX - 1 - i));

            pExitProcs[UTEXIT_PROCS_MAX-1].exitProc = NULL;
            break;
        }
    }

    //
    // Check that we found the exit procs
    //
    ASSERT(found);

    DebugExitVOID(UT_DeregisterExit);

}




//
// UTTriggerEvt()
//
void UTTriggerEvt
(
    PUT_CLIENT      putFrom,
    PUT_CLIENT      putTo
)
{
    DebugEntry(UTTriggerEvt);

    ValidateUTClient(putFrom);
    ValidateUTClient(putTo);

    if (putTo->utHwnd)
    {
        if (!PostMessage(putTo->utHwnd, WM_UTTRIGGER_MSG, 0, 0))
        {
            //
            // Failed to send event
            //
            WARNING_OUT(("Failed to post trigger message from %x to %x",
                putFrom, putTo));
        }
    }

    DebugExitVOID(UTTriggerEvt);
}


//
//
// UTStartDelayedEventTimer(...)
//
//
void UTStartDelayedEventTimer(PUT_CLIENT putTask, UINT popTime)
{
    UINT    currentTickCount;
    UINT    delay = 1;

    DebugEntry(UTStartDelayedEventTimer);

    //
    // Work out the delay from the current time to popTime (popTime is
    // given in terms of the system tick count).  Be careful in the case
    // where we have already passed popTime...
    //
    currentTickCount = GetTickCount();
    if (popTime > currentTickCount)
    {
        delay = popTime - currentTickCount;
    }

    //
    // Set the timer going.  Note that if the timer has already been
    // started, this call will reset it using the new delay.
    //
    if (!SetTimer(putTask->utHwnd, UT_DELAYED_TIMER_ID, delay, NULL))
    {
        ERROR_OUT(("Could not create timer for delayed event"));
    }

    DebugExitVOID(UTStartDelayedEventTimer);
}



//
// UT_HandleProcessStart()
//
BOOL UT_HandleProcessStart(HINSTANCE hInstance)
{
    BOOL        rc = FALSE;
    int         lock;
    WNDCLASS    windowClass;

    DebugEntry(UT_HandleProcessStart);

    //
    // Save our dll handle.
    //
    g_asInstance = hInstance;

    //
    // Init our critical sections
    //
    for (lock = UTLOCK_FIRST; lock < UTLOCK_MAX; lock++)
    {
        InitializeCriticalSection(&g_utLocks[lock]);
    }

    //
    // Register the UT window class
    //
    windowClass.style         = 0;
    windowClass.lpfnWndProc   = UT_WndProc;
    windowClass.cbClsExtra    = 0;
    windowClass.cbWndExtra    = 0;
    windowClass.hInstance     = g_asInstance;
    windowClass.hIcon         = NULL;
    windowClass.hCursor       = NULL;
    windowClass.hbrBackground = NULL;
    windowClass.lpszMenuName  = NULL;
    windowClass.lpszClassName = UT_WINDOW_CLASS;

    g_utWndClass = RegisterClass(&windowClass);
    if (!g_utWndClass)
    {
        ERROR_OUT(("Failed to register class"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(UT_HandleProcessStart, rc);
    return(rc);
}


//
// UT_HandleProcessEnd()
//
void UT_HandleProcessEnd(void)
{
    int                 lock;
    PUT_CLIENT          putTask;
    int                 task;

    DebugEntry(UT_HandleProcessEnd);

    TRACE_OUT(("Process is ending"));

    //
    // Loop through all the registered UT tasks looking for those on this
    // process.  Start at the end, and work up to the front.
    //
    putTask = &(g_autTasks[UTTASK_MAX - 1]);
    for (task = UTTASK_MAX - 1; task >= UTTASK_FIRST; task--, putTask--)
    {
        //
        // Is this entry in the UTM in use ?
        //
        if (putTask->dwThreadId)
        {
            //
            // Clean up after this UT task
            //
            TRACE_OUT(("Task %x ending without calling UT_TermTask", putTask));

            //
            // On ProcessEnd, the windows are no longer valid.  If it took
            // too long to shutdown, we might not have received a thread
            // detach notification.  In which case we wouldn't have cleaned
            // up the thread objects.
            //
            if (putTask->dwThreadId != GetCurrentThreadId())
            {
                putTask->utHwnd = NULL;
            }
            UTTaskEnd(putTask);
        }
    }

    if (g_utWndClass)
    {
        UnregisterClass(MAKEINTATOM(g_utWndClass), g_asInstance);
        g_utWndClass = 0;
    }

    //
    // Clean up the critical sections.  Do this last to first, in inverse
    // order that they are created.
    //
    for (lock = UTLOCK_MAX-1; lock >= UTLOCK_FIRST; lock--)
    {
        DeleteCriticalSection(&g_utLocks[lock]);
    }

    DebugExitVOID(UT_HandleProcessEnd);
}


//
// UT_HandleThreadEnd()
//
void UT_HandleThreadEnd(void)
{
    PUT_CLIENT      putTask;
    DWORD           dwThreadId;
    int             task;

    DebugEntry(UT_HandleThreadEnd);

    UT_Lock(UTLOCK_UT);

    //
    // Get the current thread ID
    //
    dwThreadId = GetCurrentThreadId();

    //
    // Loop through all the registered UT tasks looking for one on this
    // process and thread.  Note that there should only be one entry in the
    // UTM for each thread, so we can break out of the loop if we get a
    // match.
    //
    putTask = &(g_autTasks[UTTASK_MAX - 1]);
    for (task = UTTASK_MAX - 1; task >= UTTASK_FIRST; task--, putTask--)
    {
        //
        // Is there a task here that matches the current thread?
        // Tasks not present have 0 for the thread ID, which won't match
        //
        if (putTask->dwThreadId == dwThreadId)
        {
            //
            // Clean up after this UT task
            //
            WARNING_OUT(("Task %x ending without calling UT_TermTask", putTask));
            UTTaskEnd(putTask);
        }
    }

    UT_Unlock(UTLOCK_UT);

    DebugExitVOID(UT_HandleThreadEnd);
}


//
//
// UT_WndProc(...)
//
//
LRESULT CALLBACK UT_WndProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    LRESULT     retVal = 0;
    PUT_CLIENT  putTask;

    DebugEntry(UT_WndProc);

    //
    // This isn't a UT message, so we should handle it
    //
    switch (message)
    {
        case WM_TIMER:
            //
            // WM_TIMER is used for delayed events...
            //
            TRACE_OUT(("Timer Id is 0x%08x", wParam));

            if (wParam == UT_DELAYED_TIMER_ID) // defined as 0x10101010
            {
                //
                // Get our UT handle from the window data
                //
                putTask = (PUT_CLIENT)GetWindowLongPtr(hwnd, GWLP_USERDATA);
                ValidateUTClient(putTask);

                //
                // Stop the timer before it ticks again !
                //
                KillTimer(putTask->utHwnd, UT_DELAYED_TIMER_ID);

                //
                // Process the delayed event
                //
                UTCheckDelayedEvents(putTask);
            }
            break;

        case WM_UTTRIGGER_MSG:
            putTask = (PUT_CLIENT)GetWindowLongPtr(hwnd, GWLP_USERDATA);
            ValidateUTClient(putTask);

            //
            // Distribute pending events
            //
            UTCheckEvents(putTask);
            break;

        default:
            //
            // Call on to the default handler
            //
            retVal = DefWindowProc(hwnd, message, wParam, lParam);
            break;
    }

    DebugExitDWORD(UT_WndProc, retVal);
    return(retVal);
}


//
//
// UTCheckEvents()
// This delivers any normal pending events
//
//
void UTCheckEvents
(
    PUT_CLIENT          putTask
)
{
    PUTEVENT_INFO       pEventInfo;
    BOOL                eventsOnQueue     = TRUE;
    int                 eventsProcessed   = 0;
    UINT                event;
    UINT_PTR            param1, param2;

    DebugEntry(UTCheckEvents);

    UT_Lock(UTLOCK_UT);

    //
    // This while-loop picks any events off our queue and calls the
    // handers.  We only process a certain number, to be a well behaved
    // task.  Many event handlers in turn post other events...
    //
    while (eventsOnQueue && (eventsProcessed < MAX_EVENTS_TO_PROCESS))
    {
        //
        // Are there any events waiting on the queue?
        //
        pEventInfo = (PUTEVENT_INFO)COM_BasedListFirst(&(putTask->pendingEvents),
            FIELD_OFFSET(UTEVENT_INFO, chain));
        if (pEventInfo != NULL)
        {
            ValidateEventInfo(pEventInfo);

            TRACE_OUT(("Event(s) pending - returning first one in queue"));

            //
            // Return event from queue
            //
            event  = pEventInfo->event;
            param1 = pEventInfo->param1;
            param2 = pEventInfo->param2;

            //
            // Remove event from queue
            //
            COM_BasedListRemove(&(pEventInfo->chain));

            //
            // Free the event
            //
            delete pEventInfo;
        }
        else
        {
            //
            // No events on the queue - this can happen if we
            // process the event queue between the trigger event
            // being sent, amd the trigger event being received.
            //
            TRACE_OUT(("Got event trigger but no events on queue!"));
            DC_QUIT;
        }

        //
        // Check now if there are still events on the queue.
        //
        // NOTE:
        // We set up eventsOnQueue now, rather than after the call
        // to ProcessEvent - this means that if processing the last
        // event on the queue (say, event A) causes event B to be
        // posted back to ourselves, we will not process B until
        // later, when the event arrives for it.  This may seem
        // like an unnecessary delay but it is vital to prevent
        // yield nesting.
        //
        pEventInfo = (PUTEVENT_INFO)COM_BasedListFirst(&(putTask->pendingEvents),
            FIELD_OFFSET(UTEVENT_INFO, chain));
        if (pEventInfo == NULL)
        {
            eventsOnQueue = FALSE;
        }

        //
        // Unlock access to shared memory -- we're about to yield
        //
        UT_Unlock(UTLOCK_UT);
        UTProcessEvent(putTask, event, param1, param2);
        UT_Lock(UTLOCK_UT);

        if (!putTask->dwThreadId)
        {
            //
            // The task was terminated by the event.  bail out.
            //
            WARNING_OUT(("Task %x terminated in event handler", putTask));
            DC_QUIT;
        }

        //
        // Increment the number of events we've processed in this
        // loop.
        //
        eventsProcessed++;
    }

    //
    // There is an upper limit to the number of events we try to
    // process in one loop.  If we've reached this limit, post a
    // trigger event to ensure that we process the remaining events
    // later, then quit.
    //
    if (eventsProcessed >= MAX_EVENTS_TO_PROCESS)
    {
        TRACE_OUT(("Another trigger event required"));
        UTTriggerEvt(putTask, putTask);
    }

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_UT);

    DebugExitVOID(UTUtilitiesWndProc);
}



//
// UT_MallocRefCount()
//
// This allocates a ref-count block, one that doesn't go away until
// the ref-count reaches zero.
//
void * UT_MallocRefCount
(
    UINT    cbSizeMem,
    BOOL    fZeroMem
)
{
    PUTREFCOUNTHEADER   pHeader;
    void *              pMemory = NULL;

    DebugEntry(UT_MallocRefCount);

    //
    // Allocate a block the client's size + our header's size
    //
    pHeader = (PUTREFCOUNTHEADER)new BYTE[sizeof(UTREFCOUNTHEADER) + cbSizeMem];
    if (!pHeader)
    {
        ERROR_OUT(("UT_MallocRefCount failed; out of memory"));
        DC_QUIT;
    }

    if (fZeroMem)
    {
        ZeroMemory(pHeader, sizeof(UTREFCOUNTHEADER) + cbSizeMem);
    }

    SET_STAMP(pHeader, UTREFCOUNTHEADER);
    pHeader->refCount   = 1;

    pMemory = (pHeader + 1);

DC_EXIT_POINT:
    DebugExitPTR(UT_MallocRefCount, pMemory);
    return(pMemory);
}


//
// UT_BumpUpRefCount()
//
void UT_BumpUpRefCount
(
    void *  pMemory
)
{
    PUTREFCOUNTHEADER   pHeader;

    DebugEntry(UT_BumpUpRefCount);

    ASSERT(pMemory);

    pHeader = (PUTREFCOUNTHEADER)((LPBYTE)pMemory - sizeof(UTREFCOUNTHEADER));
    ASSERT(!IsBadWritePtr(pHeader, sizeof(UTREFCOUNTHEADER)));
    ASSERT(pHeader->stamp.idStamp[0] == 'A');
    ASSERT(pHeader->stamp.idStamp[1] == 'S');
    ASSERT(pHeader->refCount);

    pHeader->refCount++;
    TRACE_OUT(("Bumped up ref-counted memory block 0x%08x to %d", pHeader, pHeader->refCount));

    DebugExitVOID(UT_BumpUpRefCount);
}


//
// UT_FreeRefCount()
//
void UT_FreeRefCount
(
    void ** ppMemory,
    BOOL    fNullOnlyWhenFreed
)
{
    void *              pMemory;
    PUTREFCOUNTHEADER   pHeader;

    DebugEntry(UT_FreeRefCount);

    ASSERT(ppMemory);
    pMemory = *ppMemory;
    ASSERT(pMemory);

    pHeader = (PUTREFCOUNTHEADER)((LPBYTE)pMemory - sizeof(UTREFCOUNTHEADER));
    ASSERT(!IsBadWritePtr(pHeader, sizeof(UTREFCOUNTHEADER)));
    ASSERT(pHeader->stamp.idStamp[0] == 'A');
    ASSERT(pHeader->stamp.idStamp[1] == 'S');
    ASSERT(pHeader->refCount);

    if (--(pHeader->refCount) == 0)
    {
        TRACE_OUT(("Freeing ref-counted memory block 0x%08x", pHeader));
        delete[] pHeader;

        *ppMemory = NULL;
    }
    else
    {
        TRACE_OUT(("Bumped down ref-counted memory block 0x%08x to %d", pHeader, pHeader->refCount));
        if (!fNullOnlyWhenFreed)
            *ppMemory = NULL;
    }

    DebugExitVOID(UT_FreeRefCount);
}





//
// UT_MoveMemory - Copy source buffer to destination buffer
//
// Purpose:
//       UT_MoveMemory() copies a source memory buffer to a destination memory buffer.
//       This routine recognize overlapping buffers to avoid propogation.
//       For cases where propogation is not a problem, memcpy() can be used.
//
// Entry:
//       void *dst = pointer to destination buffer
//       const void *src = pointer to source buffer
//       size_t count = number of bytes to copy
//
// Exit:
//       Returns a pointer to the destination buffer
//
//Exceptions:
//

void *  UT_MoveMemory (
        void * dst,
        const void * src,
        size_t count
        )
{
        void * ret = dst;

        if (dst <= src || (char *)dst >= ((char *)src + count)) {
                //
                // Non-Overlapping Buffers
                // copy from lower addresses to higher addresses
                //
                while (count--) {
                        *(char *)dst = *(char *)src;
                        dst = (char *)dst + 1;
                        src = (char *)src + 1;
                }
        }
        else {
                //
                // Overlapping Buffers
                // copy from higher addresses to lower addresses
                //
                dst = (char *)dst + count - 1;
                src = (char *)src + count - 1;

                while (count--) {
                        *(char *)dst = *(char *)src;
                        dst = (char *)dst - 1;
                        src = (char *)src - 1;
                }
        }
        return(ret);
}




//
// COM_BasedListInsertBefore(...)
//
// See ut.h for description.
//
void COM_BasedListInsertBefore(PBASEDLIST pExisting, PBASEDLIST pNew)
{
    PBASEDLIST  pTemp;

    DebugEntry(COM_BasedListInsertBefore);

    //
    // Check for bad parameters.
    //
    ASSERT((pNew != NULL));
    ASSERT((pExisting != NULL));

    //
    // Find the item before pExisting:
    //
    pTemp = COM_BasedPrevListField(pExisting);
    ASSERT((pTemp != NULL));

    TRACE_OUT(("Inserting item at 0x%08x into list between 0x%08x and 0x%08x",
                 pNew, pTemp, pExisting));

    //
    // Set its <next> field to point to the new item
    //
    pTemp->next = PTRBASE_TO_OFFSET(pNew, pTemp);
    pNew->prev  = PTRBASE_TO_OFFSET(pTemp, pNew);

    //
    // Set <prev> field of pExisting to point to new item:
    //
    pExisting->prev = PTRBASE_TO_OFFSET(pNew, pExisting);
    pNew->next      = PTRBASE_TO_OFFSET(pExisting, pNew);

    DebugExitVOID(COM_BasedListInsertBefore);
} // COM_BasedListInsertBefore


//
// COM_BasedListInsertAfter(...)
//
// See ut.h for description.
//
void COM_BasedListInsertAfter(PBASEDLIST pExisting,
                                          PBASEDLIST pNew)
{
    PBASEDLIST  pTemp;

    DebugEntry(COM_BasedListInsertAfter);

    //
    // Check for bad parameters.
    //
    ASSERT((pNew != NULL));
    ASSERT((pExisting != NULL));

    //
    // Find the item after pExisting:
    //
    pTemp = COM_BasedNextListField(pExisting);
    ASSERT((pTemp != NULL));

    TRACE_OUT(("Inserting item at 0x%08x into list between 0x%08x and 0x%08x",
                 pNew, pExisting, pTemp));

    //
    // Set its <prev> field to point to the new item
    //
    pTemp->prev = PTRBASE_TO_OFFSET(pNew, pTemp);
    pNew->next  = PTRBASE_TO_OFFSET(pTemp, pNew);

    //
    // Set <next> field of pExisting to point to new item:
    //
    pExisting->next = PTRBASE_TO_OFFSET(pNew, pExisting);
    pNew->prev      = PTRBASE_TO_OFFSET(pExisting, pNew);

    DebugExitVOID(COM_BasedListInsertAfter);
} // COM_BasedListInsertAfter


//
// COM_BasedListRemove(...)
//
// See ut.h for description.
//
void COM_BasedListRemove(PBASEDLIST pListItem)
{
    PBASEDLIST pNext     = NULL;
    PBASEDLIST pPrev     = NULL;

    DebugEntry(COM_BasedListRemove);

    //
    // Check for bad parameters.
    //
    ASSERT((pListItem != NULL));

    pPrev = COM_BasedPrevListField(pListItem);
    pNext = COM_BasedNextListField(pListItem);

    ASSERT((pPrev != NULL));
    ASSERT((pNext != NULL));

    TRACE_OUT(("Removing item 0x%08x from list", pListItem));

    pPrev->next = PTRBASE_TO_OFFSET(pNext, pPrev);
    pNext->prev = PTRBASE_TO_OFFSET(pPrev, pNext);

    DebugExitVOID(COM_BasedListRemove);
}


void FAR * COM_BasedListNext ( PBASEDLIST pHead, void FAR * pEntry, UINT nOffset )
{
     PBASEDLIST p;

     ASSERT(pHead != NULL);
     ASSERT(pEntry != NULL);

     p = COM_BasedNextListField(COM_BasedStructToField(pEntry, nOffset));
     return ((p == pHead) ? NULL : COM_BasedFieldToStruct(p, nOffset));
}

void FAR * COM_BasedListPrev ( PBASEDLIST pHead, void FAR * pEntry, UINT nOffset )
{
     PBASEDLIST p;

     ASSERT(pHead != NULL);
     ASSERT(pEntry != NULL);

     p = COM_BasedPrevListField(COM_BasedStructToField(pEntry, nOffset));
     return ((p == pHead) ? NULL : COM_BasedFieldToStruct(p, nOffset));
}


void FAR * COM_BasedListFirst ( PBASEDLIST pHead, UINT nOffset )
{
    return (COM_BasedListIsEmpty(pHead) ?
            NULL :
            COM_BasedFieldToStruct(COM_BasedNextListField(pHead), nOffset));
}

void FAR * COM_BasedListLast ( PBASEDLIST pHead, UINT nOffset )
{
    return (COM_BasedListIsEmpty(pHead) ?
            NULL :
            COM_BasedFieldToStruct(COM_BasedPrevListField(pHead), nOffset));
}


void COM_BasedListFind ( LIST_FIND_TYPE   eType,
                           PBASEDLIST          pHead,
                           void FAR * FAR*  ppEntry,
                           UINT             nOffset,
                           int              nOffsetKey,
                           DWORD_PTR        Key,
                           int              cbKeySize )
{
    void *p = *ppEntry;
    DWORD val;

    switch (eType)
    {
        case LIST_FIND_FROM_FIRST:
	        p = COM_BasedListFirst(pHead, nOffset);
            break;

        case LIST_FIND_FROM_NEXT:
        	p = COM_BasedListNext(pHead, p, nOffset);
            break;

        default:
            ASSERT(FALSE);
    }

    // make sure the key size is no more than a dword
    ASSERT(cbKeySize <= sizeof(DWORD_PTR));

    while (p != NULL)
    {
        val = 0;
        CopyMemory(&val, (void *) ((DWORD_PTR) p + nOffsetKey), cbKeySize);
        if (val == Key)
        {
            break;
        }

        p = COM_BasedListNext(pHead, p, nOffset);
    }

    *ppEntry = p;
}



//
// COM_SimpleListAppend()
//
// For simple lists, such as hwnd list, app name list, proc id list
//

PSIMPLE_LIST COM_SimpleListAppend ( PBASEDLIST pHead, void FAR * pData )
{
    PSIMPLE_LIST p = new SIMPLE_LIST;
    if (p != NULL)
    {
        ZeroMemory(p, sizeof(*p));
        p->pData = pData;
        COM_BasedListInsertBefore(pHead, &(p->chain));
    }

    return p;
}

void FAR * COM_SimpleListRemoveHead ( PBASEDLIST pHead )
{
    void *pData = NULL;
    PBASEDLIST pdclist;
    PSIMPLE_LIST p;

    if (! COM_BasedListIsEmpty(pHead))
    {
        // get the first entry in the list
        pdclist = COM_BasedNextListField(pHead);
        p = (PSIMPLE_LIST) COM_BasedFieldToStruct(pdclist,
                                             offsetof(SIMPLE_LIST, chain));
        pData = p->pData;

        // remove the first entry in the list
        COM_BasedListRemove(pdclist);
        delete p;
    }

    return pData;
}


//
// COM_ReadProfInt(...)
//
// See ut.h for description.
//
void COM_ReadProfInt
(
    LPSTR   pSection,
    LPSTR   pEntry,
    int     defaultValue,
    int *   pValue
)
{
    int     localValue;

    DebugEntry(COM_ReadProfInt);

    //
    // Check for NULL parameters
    //
    ASSERT(pSection != NULL);
    ASSERT(pEntry != NULL);

    //
    // First try to read the value from the current user section.
    // Then try to read the value from the global local machine section.
    //
    if (COMReadEntry(HKEY_CURRENT_USER, pSection, pEntry, (LPSTR)&localValue,
            sizeof(int), REG_DWORD) ||
        COMReadEntry(HKEY_LOCAL_MACHINE, pSection, pEntry, (LPSTR)&localValue,
            sizeof(int), REG_DWORD))
    {
        *pValue = localValue;
    }
    else
    {
        *pValue = defaultValue;
    }

    DebugExitVOID(COM_ReadProfInt);
}



//
// FUNCTION: COMReadEntry(...)
//
// DESCRIPTION:
// ============
// Read an entry from the given section of the registry.  Allow type
// REG_BINARY (4 bytes) if REG_DWORD was requested.
//
//
// PARAMETERS:
// ===========
// topLevelKey      : one of:
//                      - HKEY_CURRENT_USER
//                      - HKEY_LOCAL_MACHINE
// pSection         : the section name to read from.  The DC_REG_PREFIX
//                    string is prepended to give the full name.
// pEntry           : the entry name to read.
// pBuffer          : a buffer to read the entry to.
// bufferSize       : the size of the buffer.
// expectedDataType : the type of data stored in the entry.
//
// RETURNS:
// ========
// Nothing.
//
//
BOOL COMReadEntry(HKEY    topLevelKey,
                                 LPSTR pSection,
                                 LPSTR pEntry,
                                 LPSTR pBuffer,
                                 int   bufferSize,
                                 ULONG expectedDataType)
{
    LONG        sysrc;
    HKEY        key;
    ULONG       dataType;
    ULONG       dataSize;
    char        subKey[COM_MAX_SUBKEY];
    BOOL        keyOpen = FALSE;
    BOOL        rc = FALSE;

    DebugEntry(COMReadEntry);

    //
    // Get a subkey for the value.
    //
    wsprintf(subKey, "%s%s", DC_REG_PREFIX, pSection);

    //
    // Try to open the key.  If the entry does not exist, RegOpenKeyEx will
    // fail.
    //
    sysrc = RegOpenKeyEx(topLevelKey,
                         subKey,
                         0,                   // reserved
                         KEY_ALL_ACCESS,
                         &key);

    if (sysrc != ERROR_SUCCESS)
    {
        //
        // Don't trace an error here since the subkey may not exist...
        //
        TRACE_OUT(("Failed to open key %s, rc = %d", subKey, sysrc));
        DC_QUIT;
    }
    keyOpen = TRUE;

    //
    // We successfully opened the key so now try to read the value.  Again
    // it may not exist.
    //
    dataSize = bufferSize;
    sysrc    = RegQueryValueEx(key,
                               pEntry,
                               0,          // reserved
                               &dataType,
                               (LPBYTE)pBuffer,
                               &dataSize);

    if (sysrc != ERROR_SUCCESS)
    {
        TRACE_OUT(("Failed to read value of [%s] %s, rc = %d",
                     pSection,
                     pEntry,
                     sysrc));
        DC_QUIT;
    }

    //
    // Check that the type is correct.  Special case: allow REG_BINARY
    // instead of REG_DWORD, as long as the length is 32 bits.
    //
    if ((dataType != expectedDataType) &&
        ((dataType != REG_BINARY) ||
         (expectedDataType != REG_DWORD) ||
         (dataSize != 4)))
    {
        WARNING_OUT(("Read value from [%s] %s, but type is %d - expected %d",
                     pSection,
                     pEntry,
                     dataType,
                     expectedDataType));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:

    //
    // Close the key (if required).
    //
    if (keyOpen)
    {
        sysrc = RegCloseKey(key);
        if (sysrc != ERROR_SUCCESS)
        {
            ERROR_OUT(("Failed to close key, rc = %d", sysrc));
        }
    }

    DebugExitBOOL(COMReadEntry, rc);
    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32.9x\global95.cpp ===
#include "precomp.h"


//
// This file generates the storage for our Win95 specific global variables
//

#include <datainit.h>
#include <global95.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32.9x\global95.h ===
//
// GLOBAL95.H
// Global variables specific to Win95
//

DC_DATA ( DWORD,     g_hInstAs16 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\remdsk\rds\as\cpi32\view.cpp ===
#include "precomp.h"
#include <version.h>

//
// VIEW.CPP
// The frame, widgets, and client area that presents the shared apps/desktop
// for a remote host.
//
// Copyright(c) Microsoft 1997-
//

//
// NOTE:
// The client of the shared view frame represents the virtual desktop (VD)
// of the host.  For 3.0 hosts, the VD is the same as the screen.  But for
// 2.x hosts, the VD is the union of the screen size of all hosts.  Hence
// the recalculation every time someone starts sharing or changes screen
// size, and the extra fun this entails for existing shared 2.x views.
//

#define MLZ_FILE_ZONE  ZONE_CORE


// Help file
static const TCHAR s_cszHtmlHelpFile[] = TEXT("conf.chm");

//
// VIEW_Init()
//
BOOL  VIEW_Init(void)
{
    BOOL        rc = FALSE;
    WNDCLASSEX  wc;


    DebugEntry(VIEW_Init);

    //
    // Register the frame window class.
    // NOTE:  Change CS_NOCLOSE if/when we ever let you close the view
    // of a person's shared apps.
    //
    wc.cbSize           = sizeof(wc);
    wc.style            = CS_DBLCLKS | CS_NOCLOSE;
    wc.lpfnWndProc      = VIEWFrameWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = g_asInstance;
    wc.hIcon            = NULL;
    wc.hCursor          = ::LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_3DFACE+1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = VIEW_FRAME_CLASS_NAME;
    wc.hIconSm          = NULL;

    if (!RegisterClassEx(&wc))
    {
        ERROR_OUT(("Failed to register AS Frame class"));
        DC_QUIT;
    }

    //
    // Register the view window class.  This sits in the client area of
    // the frame along with the statusbar, tray, etc.  It displays
    // the remote host's shared contents.
    //
    wc.cbSize           = sizeof(wc);
    wc.style            = CS_DBLCLKS | CS_NOCLOSE;
    wc.lpfnWndProc      = VIEWClientWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = g_asInstance;
    wc.hIcon            = NULL;
    wc.hCursor          = NULL;
    wc.hbrBackground    = NULL;
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = VIEW_CLIENT_CLASS_NAME;
    wc.hIconSm          = NULL;

    if (!RegisterClassEx(&wc))
    {
        ERROR_OUT(("Failed to register AS Client class"));
        DC_QUIT;
    }

    //
    // Register the full screen exit button class.  This is a child of the
    // the view client when present.
    //
    wc.cbSize           = sizeof(wc);
    wc.style            = 0;
    wc.lpfnWndProc      = VIEWFullScreenExitProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = g_asInstance;
    wc.hIcon            = NULL;
    wc.hCursor          = ::LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = NULL;
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = VIEW_FULLEXIT_CLASS_NAME;
    wc.hIconSm          = NULL;

    if (!RegisterClassEx(&wc))
    {
        ERROR_OUT(("Failed to register AS full screen exit class"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:

    DebugExitBOOL(VIEW_Init, rc);
    return(rc);
}


//
// VIEW_Term()
//
void  VIEW_Term(void)
{
    DebugEntry(VIEW_Term);

    //
    // Free all resources we created (or may have created in window class
    // case).
    //
    UnregisterClass(VIEW_FULLEXIT_CLASS_NAME, g_asInstance);
    UnregisterClass(VIEW_CLIENT_CLASS_NAME, g_asInstance);
    UnregisterClass(VIEW_FRAME_CLASS_NAME, g_asInstance);

    DebugExitVOID(VIEW_Term);
}



//
// VIEW_ShareStarting()
// Creates share resources
//
BOOL ASShare::VIEW_ShareStarting(void)
{
    BOOL        rc = FALSE;
    HBITMAP     hbmpT;
    TEXTMETRIC  tm;
    HDC         hdc;
    HFONT       hfnOld;
    char        szRestore[256];
    SIZE        extent;

    DebugEntry(ASShare::VIEW_ShareStarting);

    ASSERT(m_viewVDSize.x == 0);
    ASSERT(m_viewVDSize.y == 0);

    //
    // Get NODROP cursor
    //
    m_viewNotInControl = ::LoadCursor(NULL, IDC_NO);

    //
    // Get MOUSEWHEEL lines metric
    //
    SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0,
        &m_viewMouseWheelScrollLines, 0);

    //
    // Create a pattern brush from the obscured bitmap
    //
    hbmpT = LoadBitmap(g_asInstance, MAKEINTRESOURCE(IDB_OBSCURED));
    m_viewObscuredBrush = CreatePatternBrush(hbmpT);
    DeleteBitmap(hbmpT);

    if (!m_viewObscuredBrush)
    {
        ERROR_OUT(( "Failed to create obscured bitmap brush"));
        DC_QUIT;
    }

    //
    // NOTE THAT since the icons are VGA colors, we don't need to recreate
    // our brush on a SYSCOLOR change.
    //

    // Get the full screen cancel icon
    m_viewFullScreenExitIcon = (HICON)LoadImage(g_asInstance,
        MAKEINTRESOURCE(IDI_CANCELFULLSCREEN), IMAGE_ICON,
        GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON),
        LR_DEFAULTCOLOR);

    m_viewEdgeCX    = ::GetSystemMetrics(SM_CXEDGE);
    m_viewEdgeCY    = ::GetSystemMetrics(SM_CYEDGE);

    //
    // Get metrics of GUI_FONT, the one we use in the window bar and
    // status bar.
    //
    LoadString(g_asInstance, IDS_RESTORE, szRestore, sizeof(szRestore));

    hdc = ::GetDC(NULL);
    hfnOld = (HFONT)::SelectObject(hdc, ::GetStockObject(DEFAULT_GUI_FONT));

    ::GetTextMetrics(hdc, &tm);

    ::GetTextExtentPoint(hdc, szRestore, lstrlen(szRestore), &extent);

    ::SelectObject(hdc, hfnOld);
    ::ReleaseDC(NULL, hdc);

    //
    // Calculate size of full screen button
    // Edge on left + margin on left + sm icon + margin + text + margin on
    //      right + edge on right == 5 edges + sm icon + text
    //
    m_viewFullScreenCX = extent.cx + 5*m_viewEdgeCX + GetSystemMetrics(SM_CXSMICON);
    m_viewFullScreenCY = max(GetSystemMetrics(SM_CYSMICON), extent.cy) + 4*m_viewEdgeCY;

    //
    // Calculate size of items on window bar
    //
    m_viewItemCX = 4*m_viewEdgeCX + ::GetSystemMetrics(SM_CXSMICON) +
        m_viewEdgeCX + VIEW_MAX_ITEM_CHARS * tm.tmAveCharWidth;
    m_viewItemCY = max(::GetSystemMetrics(SM_CYSMICON), tm.tmHeight) +
        2*m_viewEdgeCY + 2*m_viewEdgeCY;

    //
    // Calculate the width & height of the items scroll buttons.  We want
    // to make sure it fits, but isn't ungainly.
    //
    m_viewItemScrollCX = ::GetSystemMetrics(SM_CXHSCROLL);
    m_viewItemScrollCX = 2 * min(m_viewItemScrollCX, m_viewItemCY);

    m_viewItemScrollCY = ::GetSystemMetrics(SM_CYHSCROLL);
    m_viewItemScrollCY = min(m_viewItemScrollCY, m_viewItemCY);

    //
    // Calculate height of status bar.  It's height of GUIFONT plus edge
    // space.
    //

    m_viewStatusBarCY = tm.tmHeight + 4*m_viewEdgeCY;

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::VIEW_ShareStarting, rc);
    return(rc);
}



//
// VIEW_ShareEnded()
// Cleans up resources for share
//
void ASShare::VIEW_ShareEnded(void)
{
    DebugEntry(ASShare::VIEW_ShareEnded);

    //
    // Destroy the full screen cancel icon
    //
    if (m_viewFullScreenExitIcon != NULL)
    {
        DestroyIcon(m_viewFullScreenExitIcon);
        m_viewFullScreenExitIcon = NULL;
    }

    if (m_viewObscuredBrush != NULL)
    {
        DeleteBrush(m_viewObscuredBrush);
        m_viewObscuredBrush = NULL;
    }

    DebugExitVOID(ASShre::VIEW_ShareEnded);
}




//
// VIEW_PartyLeftShare()
//
// This is called when somebody leaves a share.  We need this to
// simulate what back-level systems did to calculate the virtual desktop
// size.  They didn't recalc when someone stopped shared, that person's
// screne size counted until they left the share.
//
void ASShare::VIEW_PartyLeftShare(ASPerson * pasPerson)
{
    DebugEntry(ASShare::VIEW_PartyLeftShare);

    ValidatePerson(pasPerson);

    // If this dude ever shared, now remove him from the VD total
    if (pasPerson->viewExtent.x != 0)
    {
        pasPerson->viewExtent.x            = 0;
        pasPerson->viewExtent.y            = 0;
        VIEW_RecalcVD();
    }

    DebugExitVOID(ASShare::VIEW_PartyLeftShare);
}




//
// VIEW_HostStarting()
//
// Called when we start to host.
//
BOOL ASHost::VIEW_HostStarting(void)
{
    DebugEntry(ASHost:VIEW_HostStarting);

    m_pShare->VIEW_RecalcExtent(m_pShare->m_pasLocal);
    m_pShare->VIEW_RecalcVD();

    DebugExitBOOL(ASHost::VIEW_HostStarting, TRUE);
    return(TRUE);
}


//
// VIEW_ViewStarting()
// Called when someone in the meeting starts to share.  For all in the
// conference, we keep a running tally of the VD, but use it only for
// 2.x views.  For remotes only, we create a view of their desktop.
//
BOOL ASShare::VIEW_ViewStarting(ASPerson * pasHost)
{
    BOOL    rc = FALSE;
    HWND    hwnd;
    RECT    rcSize;

    DebugEntry(ASShare::VIEW_ViewStarting);

    ValidateView(pasHost);

    //
    // First, calculate the extents, and the VD size.
    //
    VIEW_RecalcExtent(pasHost);
    VIEW_RecalcVD();

    //
    // Next, create scratch regions
    //
    pasHost->m_pView->m_viewExtentRgn = CreateRectRgn(0, 0, 0, 0);
    pasHost->m_pView->m_viewScreenRgn = CreateRectRgn(0, 0, 0, 0);
    pasHost->m_pView->m_viewPaintRgn  = CreateRectRgn(0, 0, 0, 0);
    pasHost->m_pView->m_viewScratchRgn = CreateRectRgn(0, 0, 0, 0);

    if (!pasHost->m_pView->m_viewExtentRgn || !pasHost->m_pView->m_viewScreenRgn || !pasHost->m_pView->m_viewPaintRgn || !pasHost->m_pView->m_viewScratchRgn)
    {
        ERROR_OUT(("ViewStarting: Couldn't create scratch regions"));
        DC_QUIT;
    }


    ASSERT(pasHost->m_pView->m_viewFrame == NULL);
    ASSERT(pasHost->m_pView->m_viewClient  == NULL);
    ASSERT(pasHost->m_pView->m_viewSharedRgn == NULL);
    ASSERT(pasHost->m_pView->m_viewObscuredRgn == NULL);
    ASSERT(pasHost->m_pView->m_viewPos.x == 0);
    ASSERT(pasHost->m_pView->m_viewPos.y == 0);
    ASSERT(pasHost->m_pView->m_viewPage.x == 0);
    ASSERT(pasHost->m_pView->m_viewPage.y == 0);

    ASSERT(!pasHost->m_pView->m_viewStatusBarOn);
    ASSERT(!pasHost->m_pView->m_viewFullScreen);

    pasHost->m_pView->m_viewStatusBarOn = TRUE;

    //
    // Calculate the ideal size for this window.
    //
    VIEWFrameGetSize(pasHost, &rcSize);

    //
    // Create the frame.  This will in turn create its children.
    //
    pasHost->m_pView->m_viewMenuBar = ::LoadMenu(g_asInstance,
        MAKEINTRESOURCE(IDM_FRAME));
    if (!pasHost->m_pView->m_viewMenuBar)
    {
        ERROR_OUT(("ViewStarting: couldn't load frame menu"));
        DC_QUIT;
    }

    //
    // Do once-only capabilities/menu stuff.
    //

    //
    // SEND CTRL+ALT+DEL:
    // Append Ctrl+Alt+Del after separator to control menu, if this
    // is a view of a service host on NT.
    //
    if (pasHost->hetCount == HET_DESKTOPSHARED)
    {
        //
        // Remove applications submenu
        //
        DeleteMenu(pasHost->m_pView->m_viewMenuBar, IDSM_WINDOW,
            MF_BYPOSITION);

        if ((pasHost->cpcCaps.general.typeFlags & AS_SERVICE) &&
            (pasHost->cpcCaps.general.OS == CAPS_WINDOWS)     &&
            (pasHost->cpcCaps.general.OSVersion == CAPS_WINDOWS_NT))
        {
            HMENU   hSubMenu;
            MENUITEMINFO mii;
            CHAR szMenu[32];

            hSubMenu = GetSubMenu(pasHost->m_pView->m_viewMenuBar, IDSM_CONTROL);

            ZeroMemory(&mii, sizeof(mii));

            // Separator
            mii.cbSize  = sizeof(mii);
            mii.fMask   = MIIM_TYPE;
            mii.fType   = MFT_SEPARATOR;
            InsertMenuItem(hSubMenu, -1, TRUE, &mii);

            // Send Ctrl-Alt-Del command
            mii.fMask   = MIIM_ID | MIIM_STATE | MIIM_TYPE;
            mii.fType   = MFT_STRING;
            mii.fState  = MFS_ENABLED;
            mii.wID     = CMD_CTRLALTDEL;

            LoadString(g_asInstance, IDS_CMD_CTRLALTDEL, szMenu,
                                                    sizeof(szMenu));
            mii.dwTypeData  = szMenu;
            mii.cch         = lstrlen(szMenu);

            InsertMenuItem(hSubMenu, -1, TRUE, &mii);
        }
    }

    //
    // FULL SCREEN:
    // We only enable Full Screen for 3.0 hosts (since with 2.x desktop
    // scrolling the view area can change) who have screen sizes identical
    // to ours.
    //
    if (
        (pasHost->cpcCaps.screen.capsScreenWidth ==
            m_pasLocal->cpcCaps.screen.capsScreenWidth) &&
        (pasHost->cpcCaps.screen.capsScreenHeight ==
            m_pasLocal->cpcCaps.screen.capsScreenHeight))
    {
        ::EnableMenuItem(pasHost->m_pView->m_viewMenuBar, CMD_VIEWFULLSCREEN,
            MF_ENABLED | MF_BYCOMMAND);
    }

    if (m_pasLocal->m_caControlledBy)
    {
        WARNING_OUT(("VIEWStarting: currently controlled, create view hidden"));
    }

    //
    // If we are currently controlled, create the frame invisible since
    // we hid all the visible ones when we started being this way.
    //
    hwnd = CreateWindowEx(
            WS_EX_WINDOWEDGE,
            VIEW_FRAME_CLASS_NAME,  // See RegisterClass() call.
            NULL,
            WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX |
                WS_MAXIMIZEBOX | WS_CLIPCHILDREN | (!m_pasLocal->m_caControlledBy ? WS_VISIBLE : 0),
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            pasHost->viewExtent.x >= m_pasLocal->cpcCaps.screen.capsScreenWidth ?
                CW_USEDEFAULT : rcSize.right - rcSize.left,

            pasHost->viewExtent.y >= m_pasLocal->cpcCaps.screen.capsScreenHeight ?
                CW_USEDEFAULT : rcSize.bottom - rcSize.top,
            NULL,
            pasHost->m_pView->m_viewMenuBar,
            g_asInstance,
            pasHost                       // Pass in person ptr
            );

    if (hwnd == NULL)
    {
        ERROR_OUT(("ViewStarting: couldn't create frame window"));
        DC_QUIT;
    }

    //
    // OK, now we've created this frame window.  Go through the sizing
    // process again to make sure the scrollbars are OK.
    //
    VIEWClientExtentChange(pasHost, FALSE);

    if (!m_pasLocal->m_caControlledBy)
    {
        SetForegroundWindow(hwnd);
        UpdateWindow(hwnd);
    }

#ifdef _DEBUG
    TRACE_OUT(("TIME TO SEE SOMETHING: %08d MS",
        ::GetTickCount() - g_asSession.scShareTime));
    g_asSession.scShareTime = 0;
#endif // DEBUG

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::VIEW_ViewStarting, rc);
    return(rc);
}


//
// VIEW_ViewEnded()
//
// Called when someone we are viewing stops hosting, so we can clean up.
//
void  ASShare::VIEW_ViewEnded(ASPerson * pasHost)
{
    DebugEntry(ASShare::VIEW_ViewEnded);

    ValidateView(pasHost);

    if (pasHost->m_pView->m_viewInformDlg != NULL)
    {
        SendMessage(pasHost->m_pView->m_viewInformDlg, WM_COMMAND, IDCANCEL, 0);
        ASSERT(!pasHost->m_pView->m_viewInformDlg);
        ASSERT(!pasHost->m_pView->m_viewInformMsg);
        ASSERT(IsWindowEnabled(pasHost->m_pView->m_viewFrame));
    }

    if (pasHost->m_pView->m_viewFrame != NULL)
    {
        //
        // The frame is the parent of the view, toolbar, etc.  Those
        // should all be NULL when we return.
        //
        DestroyWindow(pasHost->m_pView->m_viewFrame);
        ASSERT(pasHost->m_pView->m_viewFrame == NULL);
    }

    ASSERT(pasHost->m_pView->m_viewClient == NULL);

    if (pasHost->m_pView->m_viewMenuBar != NULL)
    {
        ::DestroyMenu(pasHost->m_pView->m_viewMenuBar);
        pasHost->m_pView->m_viewMenuBar = NULL;
    }

    if (pasHost->m_pView->m_viewSharedRgn != NULL)
    {
        DeleteRgn(pasHost->m_pView->m_viewSharedRgn);
        pasHost->m_pView->m_viewSharedRgn = NULL;
    }

    if (pasHost->m_pView->m_viewObscuredRgn != NULL)
    {
        DeleteRgn(pasHost->m_pView->m_viewObscuredRgn);
        pasHost->m_pView->m_viewObscuredRgn = NULL;
    }

    //
    // Destroy scratch regions
    //
    if (pasHost->m_pView->m_viewScratchRgn != NULL)
    {
        DeleteRgn(pasHost->m_pView->m_viewScratchRgn);
        pasHost->m_pView->m_viewScratchRgn = NULL;
    }

    if (pasHost->m_pView->m_viewPaintRgn != NULL)
    {
        DeleteRgn(pasHost->m_pView->m_viewPaintRgn);
        pasHost->m_pView->m_viewPaintRgn = NULL;
    }

    if (pasHost->m_pView->m_viewScreenRgn != NULL)
    {
        DeleteRgn(pasHost->m_pView->m_viewScreenRgn);
        pasHost->m_pView->m_viewScreenRgn = NULL;
    }

    if (pasHost->m_pView->m_viewExtentRgn != NULL)
    {
        DeleteRgn(pasHost->m_pView->m_viewExtentRgn);
        pasHost->m_pView->m_viewExtentRgn = NULL;
    }


    pasHost->m_pView->m_viewPos.x                = 0;
    pasHost->m_pView->m_viewPos.y                = 0;
    pasHost->m_pView->m_viewPage.x               = 0;
    pasHost->m_pView->m_viewPage.y               = 0;
    pasHost->m_pView->m_viewPgSize.x             = 0;
    pasHost->m_pView->m_viewPgSize.y             = 0;
    pasHost->m_pView->m_viewLnSize.x             = 0;
    pasHost->m_pView->m_viewLnSize.y             = 0;

    DebugExitVOID(ASShare::VIEW_ViewEnded);
}



//
// VIEW_InControl()
//
// Called when we start/stop controlling this host.  We enable the
// toolbar, statusbar, tray, etc., and change the cursor from being the
// nodrop.
//
void ASShare::VIEW_InControl
(
    ASPerson *  pasHost,
    BOOL        fStart
)
{
    POINT       ptCursor;

    DebugEntry(ASShare::VIEW_InControl);

    //
    // We're changing our state, and that affects the contents of our
    // menu bar.  So cancel out of menu mode, and spare problems/faults/
    // inapplicable commands.
    //
    if (pasHost->m_pView->m_viewInMenuMode)
    {
        SendMessage(pasHost->m_pView->m_viewFrame, WM_CANCELMODE, 0, 0);
        ASSERT(!pasHost->m_pView->m_viewInMenuMode);
    }

    //
    // If starting in control and a message is up, kill it.  Then bring our
    // window to the front.
    //
    if (fStart)
    {
        if (pasHost->m_pView->m_viewInformDlg != NULL)
        {
            SendMessage(pasHost->m_pView->m_viewInformDlg, WM_COMMAND, IDCANCEL, 0);
            ASSERT(!pasHost->m_pView->m_viewInformDlg);
            ASSERT(!pasHost->m_pView->m_viewInformMsg);
            ASSERT(IsWindowEnabled(pasHost->m_pView->m_viewFrame));
        }

        SetForegroundWindow(pasHost->m_pView->m_viewFrame);
    }

    //
    // Change title bar
    //
    VIEW_HostStateChange(pasHost);

    //
    // Turn off/on shadow cursors
    //
    CM_UpdateShadowCursor(pasHost, fStart, pasHost->cmPos.x, pasHost->cmPos.y,
        pasHost->cmHotSpot.x, pasHost->cmHotSpot.y);

    //
    // This will reset cursor image:
    //      * from nodrop to shared if in control
    //      * from shared to nodrop if not in control
    //
    // This will also, if in control, cause a mousemove to get sent to the
    // host we're controlling so his cursor pos is synced with ours, if the
    // mouse is over the frame client area.
    //
    GetCursorPos(&ptCursor);
    SetCursorPos(ptCursor.x, ptCursor.y);

    DebugExitVOID(ASShare::VIEW_InControl);
}




//
// VIEW_HostStateChange()
//
// Called when a host's state has changed, via broadcast notification or
// local operations.
//
// We update the titlebar and commands.
//
void ASShare::VIEW_HostStateChange
(
    ASPerson *  pasHost
)
{
    char        szFormat[256];
    char        szTitleText[256];
    char        szOtherPart[128];

    DebugEntry(ASShare::VIEW_HostStateChange);

    ValidatePerson(pasHost);

    //
    // If this person isn't hosting anymore, don't do anything.  We're
    // cleaning up after him.
    //
    if (!pasHost->hetCount)
    {
        DC_QUIT;
    }

    //
    // Make up trailing string
    //
    if (pasHost->m_caControlledBy)
    {
        LoadString(g_asInstance, IDS_TITLE_INCONTROL, szFormat, sizeof(szFormat));
        wsprintf(szOtherPart, szFormat, pasHost->m_caControlledBy->scName);
    }
    else if (pasHost->m_caAllowControl)
    {
        LoadString(g_asInstance, IDS_TITLE_CONTROLLABLE, szOtherPart, sizeof(szOtherPart));
    }
    else
    {
        szOtherPart[0] = 0;
    }

    if (pasHost->hetCount == HET_DESKTOPSHARED)
    {
        LoadString(g_asInstance, IDS_TITLE_SHAREDDESKTOP, szFormat, sizeof(szFormat));
    }
    else
    {
        ASSERT(pasHost->hetCount);
        LoadString(g_asInstance, IDS_TITLE_SHAREDPROGRAMS, szFormat, sizeof(szFormat));
    }

    wsprintf(szTitleText, szFormat, pasHost->scName, szOtherPart);

    ::SetWindowText(pasHost->m_pView->m_viewFrame, szTitleText);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::VIEW_HostStateChange);
}



//
// VIEW_UpdateStatus()
//
// Updates the PERMANENT status of this frame.  When we go into menu mode,
// the strings shown are temporary only, not saved.  When we come out of
// menu mode, we put back the temporary status.
//
void ASShare::VIEW_UpdateStatus
(
    ASPerson *  pasHost,
    UINT        idsStatus
)
{
    DebugEntry(ASShare::VIEW_UpdateStatus);

    ValidatePerson(pasHost);

    pasHost->m_pView->m_viewStatus = idsStatus;
    VIEWFrameSetStatus(pasHost, idsStatus);

    DebugExitVOID(ASShare::VIEW_UpdateStatus);
}


void ASShare::VIEWFrameSetStatus
(
    ASPerson *  pasHost,
    UINT        idsStatus
)
{
    char szStatus[256];

    DebugEntry(ASShare::VIEWFrameSetStatus);

    if (idsStatus != IDS_STATUS_NONE)
    {
        LoadString(g_asInstance, idsStatus, szStatus, sizeof(szStatus));
    }
    else
    {
        szStatus[0] = 0;
    }
    ::SetWindowText(pasHost->m_pView->m_viewStatusBar, szStatus);

    DebugExitVOID(ASShare::VIEWFrameSetStatus);
}




//
// VIEW_Message()
//
// Puts up a message to inform the end user of something.
//
void ASShare::VIEW_Message
(
    ASPerson *  pasHost,
    UINT        ids
)
{
    DebugEntry(ASShare::VIEW_Message);

    ValidateView(pasHost);

    if (!pasHost->m_pView)
    {
        WARNING_OUT(("Can't show VIEW message; [%d] not hosting", pasHost->mcsID));
        DC_QUIT;
    }

    if (pasHost->m_pView->m_viewInformDlg)
    {
        // Kill the previous one
        TRACE_OUT(("Killing previous informational mesage for [%d]",
            pasHost->mcsID));
        SendMessage(pasHost->m_pView->m_viewInformDlg, WM_COMMAND, IDCANCEL, 0);
        ASSERT(!pasHost->m_pView->m_viewInformDlg);
        ASSERT(!pasHost->m_pView->m_viewInformMsg);
    }

    if (m_pasLocal->m_caControlledBy)
    {
        WARNING_OUT(("VIEW_Message:  ignoring, view is hidden since we're controlled"));
    }
    else
    {
        pasHost->m_pView->m_viewInformMsg = ids;
        pasHost->m_pView->m_viewInformDlg = CreateDialogParam(g_asInstance,
            ((ids != IDS_ABOUT) ? MAKEINTRESOURCE(IDD_INFORM) : MAKEINTRESOURCE(IDD_ABOUT)),
            pasHost->m_pView->m_viewFrame, VIEWDlgProc, (LPARAM)pasHost);
        if (!pasHost->m_pView->m_viewInformDlg)
        {
            ERROR_OUT(("Failed to create inform message box for [%d]",
                pasHost->mcsID));
            pasHost->m_pView->m_viewInformMsg = 0;
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::VIEW_Message);
}



//
// VIEWStartControlled()
//
// If we are about to start being controlled, we hide all the frames
// to get them out of the way AND prevent hangs caused by modal loop code
// in Win9x title bar dragging.
//
void ASShare::VIEWStartControlled(BOOL fStart)
{
    ASPerson *  pasT;

    DebugEntry(ASShare::VIEWStartControlled);

    for (pasT = m_pasLocal; pasT != NULL; pasT = pasT->pasNext)
    {
        if (pasT->m_pView)
        {
            if (fStart)
            {
                ASSERT(IsWindowVisible(pasT->m_pView->m_viewFrame));
                ShowOwnedPopups(pasT->m_pView->m_viewFrame, FALSE);
                SetWindowPos(pasT->m_pView->m_viewFrame, NULL, 0, 0, 0, 0,
                    SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER |
                    SWP_HIDEWINDOW);
            }
            else
            {
                ASSERT(!IsWindowVisible(pasT->m_pView->m_viewFrame));
                SetWindowPos(pasT->m_pView->m_viewFrame, NULL, 0, 0, 0, 0,
                    SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER |
                    SWP_SHOWWINDOW);
                ShowOwnedPopups(pasT->m_pView->m_viewFrame, TRUE);
            }
        }
    }

    DebugEntry(ASShare::VIEWStartControlled);
}


//
// VIEW_DlgProc()
//
// Handles informing user dialog
//
INT_PTR CALLBACK VIEWDlgProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    return(g_asSession.pShare->VIEW_DlgProc(hwnd, message, wParam, lParam));
}


BOOL ASShare::VIEW_DlgProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    BOOL        rc = TRUE;
    ASPerson *  pasHost;

    DebugEntry(VIEW_DlgProc);

    pasHost = (ASPerson *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if (pasHost)
    {
        ValidateView(pasHost);
    }

    switch (message)
    {
        case WM_INITDIALOG:
        {
            char szT[256];
            char szRes[512];
            RECT rc;
            RECT rcOwner;

            pasHost = (ASPerson *)lParam;
            ValidateView(pasHost);
            pasHost->m_pView->m_viewInformDlg = hwnd;

            SetWindowLongPtr(hwnd, GWLP_USERDATA, lParam);

            ASSERT(pasHost->m_pView->m_viewInformMsg);

            if (pasHost->m_pView->m_viewInformMsg == IDS_ABOUT)
            {
                // About box
                GetDlgItemText(hwnd, CTRL_ABOUTVERSION, szT, sizeof(szT));
                wsprintf(szRes, szT, VER_PRODUCTRELEASE_STR,
                    VER_PRODUCTVERSION_STR);
                SetDlgItemText(hwnd, CTRL_ABOUTVERSION, szRes);
            }
            else
            {
                HDC     hdc;
                HFONT   hfn;

                // Set title.
                if ((pasHost->m_pView->m_viewInformMsg >= IDS_ERR_TAKECONTROL_FIRST) &&
                    (pasHost->m_pView->m_viewInformMsg <= IDS_ERR_TAKECONTROL_LAST))
                {
                    LoadString(g_asInstance, IDS_TITLE_TAKECONTROL_FAILED,
                        szT, sizeof(szT));
                    SetWindowText(hwnd, szT);
                }

                // Set message
                LoadString(g_asInstance, pasHost->m_pView->m_viewInformMsg,
                    szT, sizeof(szT));
                wsprintf(szRes, szT, pasHost->scName);
                SetDlgItemText(hwnd, CTRL_INFORM, szRes);

                // Center the message vertically
                GetWindowRect(GetDlgItem(hwnd, CTRL_INFORM), &rcOwner);
                MapWindowPoints(NULL, hwnd, (LPPOINT)&rcOwner, 2);

                rc = rcOwner;

                hdc = GetDC(hwnd);
                hfn = (HFONT)SendDlgItemMessage(hwnd, CTRL_INFORM, WM_GETFONT, 0, 0);
                hfn = SelectFont(hdc, hfn);

                DrawText(hdc, szRes, -1, &rc, DT_NOCLIP | DT_EXPANDTABS |
                    DT_NOPREFIX | DT_WORDBREAK | DT_CALCRECT);

                SelectFont(hdc, hfn);
                ReleaseDC(hwnd, hdc);

                ASSERT((rc.bottom - rc.top) <= (rcOwner.bottom - rcOwner.top));

                SetWindowPos(GetDlgItem(hwnd, CTRL_INFORM), NULL,
                    rcOwner.left,
                    ((rcOwner.top + rcOwner.bottom) - (rc.bottom - rc.top)) / 2,
                    (rcOwner.right - rcOwner.left),
                    rc.bottom - rc.top,
                    SWP_NOACTIVATE | SWP_NOZORDER);
            }

            // Disable owner
            EnableWindow(pasHost->m_pView->m_viewFrame, FALSE);

            // Show window, centered around owner midpoint
            GetWindowRect(pasHost->m_pView->m_viewFrame, &rcOwner);
            GetWindowRect(hwnd, &rc);

            SetWindowPos(hwnd, NULL,
                ((rcOwner.left + rcOwner.right) - (rc.right - rc.left)) / 2,
                ((rcOwner.top + rcOwner.bottom) - (rc.bottom - rc.top)) / 2,
                0, 0, SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER);

            ShowWindow(hwnd, SW_SHOWNORMAL);
            UpdateWindow(hwnd);
            break;
        }

        case WM_COMMAND:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                case IDCANCEL:
                {
                    ASSERT(!IsWindowEnabled(pasHost->m_pView->m_viewFrame));
                    EnableWindow(pasHost->m_pView->m_viewFrame, TRUE);

                    DestroyWindow(hwnd);
                    break;
                }
            }
            break;
        }

        case WM_DESTROY:
        {
            if (pasHost)
            {
                pasHost->m_pView->m_viewInformDlg = NULL;
                pasHost->m_pView->m_viewInformMsg = 0;
            }

            SetWindowLongPtr(hwnd, GWLP_USERDATA, NULL);
            break;
        }

        default:
        {
            rc = FALSE;
            break;
        }
    }

    DebugExitBOOL(VIEW_DlgProc, rc);
    return(rc);
}



//
// VIEW_RecalcExtent()
//
// This recalculates the extent of the view of the host.
//
void ASShare::VIEW_RecalcExtent(ASPerson * pasHost)
{
    DebugEntry(ASShare::VIEW_RecalcExtent);

    TRACE_OUT(("VIEW_RecalcExtent:  New view extent (%04d, %04d) for [%d] version %x",
        pasHost->viewExtent.x, pasHost->viewExtent.y,
        pasHost->mcsID, pasHost->cpcCaps.general.version));

    pasHost->viewExtent.x = pasHost->cpcCaps.screen.capsScreenWidth;
    pasHost->viewExtent.y = pasHost->cpcCaps.screen.capsScreenHeight;

    DebugExitVOID(ASShare::VIEW_RecalcExtent);
}

//
// VIEW_RecalcVD()
// This recalculates the virtual desktop size when a remote starts/stops
// sharing, or if a host's screen changes size.  The VD is the union of
// all the screen sizes of those hosting.  2.x nodes work in a virtual
// desktop, and may scroll over.  For each 2.x view, we want the client to
// represent the VD, but with only the stuff on screen on the host to be
// interactable.
//
void ASShare::VIEW_RecalcVD(void)
{
    POINT       ptVDNew;
    ASPerson *  pas;

    DebugEntry(ASShare::VIEW_RecalcVD);

    //
    // First, loop through all the hosts and recompute the VD.
    //
    ptVDNew.x = 0;
    ptVDNew.y = 0;

    for (pas = m_pasLocal; pas != NULL; pas = pas->pasNext)
    {
        //
        // NOTE:
        // For local dudes, we won't have an HWND.  Use viewExtent, if
        // we don't think the person is sharing, it will be zero.
        //
        if (pas->viewExtent.x != 0)
        {
            TRACE_OUT(("VIEW_RecalcVD: Found host [%d], screen size (%04d, %04d)",
                pas->mcsID, pas->cpcCaps.screen.capsScreenWidth, pas->cpcCaps.screen.capsScreenHeight));

            ptVDNew.x = max(ptVDNew.x, pas->cpcCaps.screen.capsScreenWidth);
            ptVDNew.y = max(ptVDNew.y, pas->cpcCaps.screen.capsScreenHeight);

            TRACE_OUT(("VIEW_RecalcVD: Computed VD size now (%04d, %04d)",
                ptVDNew.x, ptVDNew.y));
        }
    }

    //
    // If the VD size didn't change, we're done.
    //
    if ((ptVDNew.x != m_viewVDSize.x) || (ptVDNew.y != m_viewVDSize.y))
    {
        TRACE_OUT(("VIEW_RecalcVD: VD size changed from (%04d, %04d) to (%04d, %04d)",
            m_viewVDSize.x, m_viewVDSize.y, ptVDNew.x, ptVDNew.y));

        m_viewVDSize = ptVDNew;

        //
        // Now loop through all the 2.x hosts, and update their extent, then
        // have them do the resize voodoo so the scrollbar pos isn't out of
        // range, etc.
        //
        // NOTE:  Since us, the local guy, is not 2.x we can skip ourselves.
        //
        ValidatePerson(m_pasLocal);
    }

    DebugExitVOID(ASShare::VIEW_RecalcVD);
}


//
// VIEW_IsPointShared()
// This determines, given a point relative to the client of the view for
// the remote on this system, if it is in a shared area.
//
BOOL  ASShare::VIEW_IsPointShared
(
    ASPerson *  pasHost,
    POINT       ptLocal
)
{
    BOOL        rc = FALSE;
    RECT        rcClient;

    DebugEntry(ASShare::VIEW_IsPointShared);

    ValidateView(pasHost);

    //
    // Convert to client coords, and adjust for scrolling offset.  That
    // result is the equivalent point on the host desktop.
    //
    GetClientRect(pasHost->m_pView->m_viewClient, &rcClient);
    if (!PtInRect(&rcClient, ptLocal))
    {
        TRACE_OUT(("VIEW_IsPointShared: point not in client area"));
        return(FALSE);
    }

    //
    // The obscured and shared areas are saved in frame client coords,
    // so we don't need to account for the scroll position all the time.
    // When the scroll position changes the regions are updated.
    //

    //
    // NOTE that this order works for both desktop and app sharing
    //
    if ((pasHost->m_pView->m_viewObscuredRgn != NULL) &&
        PtInRegion(pasHost->m_pView->m_viewObscuredRgn, ptLocal.x, ptLocal.y))
    {
        rc = FALSE;
    }
    else if ((pasHost->m_pView->m_viewSharedRgn != NULL) &&
        !PtInRegion(pasHost->m_pView->m_viewSharedRgn, ptLocal.x, ptLocal.y))
    {
        rc = FALSE;
    }
    else
    {
        //
        // 2.x hosts may be scrolled over.  If so, shared stuff offscreen
        // is also considered to be obscured.
        //
        RECT    rcScreen;

        //
        // Compute what part of the VD, in local client coords, is visible
        // on the remote's screen.
        //
        SetRect(&rcScreen, 0, 0, pasHost->cpcCaps.screen.capsScreenWidth, pasHost->cpcCaps.screen.capsScreenHeight);

        OffsetRect(&rcScreen,
            pasHost->m_pView->m_dsScreenOrigin.x - pasHost->m_pView->m_viewPos.x,
            pasHost->m_pView->m_dsScreenOrigin.y - pasHost->m_pView->m_viewPos.y);
        if (!PtInRect(&rcScreen, ptLocal))
        {
            TRACE_OUT(("VIEW_IsPointShared: point is in shared stuff but not visible on remote screen"));
            rc = FALSE;
        }
        else
        {
            rc = TRUE;
        }
    }

    DebugExitBOOL(AShare::VIEW_IsPointShared, rc);
    return(rc);
}



//
// VIEW_ScreenChanged()
//
void  ASShare::VIEW_ScreenChanged(ASPerson * pasPerson)
{
    DebugEntry(ASShare::VIEW_ScreenChanged);

    ValidatePerson(pasPerson);

    //
    // Recompute the extent
    //
    VIEW_RecalcExtent(pasPerson);
    VIEWClientExtentChange(pasPerson, TRUE);

    VIEW_RecalcVD();

    DebugExitVOID(ASShare::VIEW_ScreenChanged);
}



//
// VIEW_SetHostRegions()
// This sets the new shared & obscured areas.
//
// Note that this routine takes responsibility for the regions pass in; it
// will delete them and/or the old ones if necessary.
//
void  ASShare::VIEW_SetHostRegions
(
    ASPerson *  pasHost,
    HRGN        rgnShared,
    HRGN        rgnObscured
)
{
    DebugEntry(ASShare::VIEW_SetHostRegions);

    ValidateView(pasHost);

    //
    // Return immediately if either region handle is bogus.  This can happen
    // when we are running low on memory.
    //
    if (!rgnShared || !rgnObscured)
    {
        ERROR_OUT(("Bad host regions for person [%u]", pasHost->mcsID));

        if (rgnShared != NULL)
        {
            DeleteRgn(rgnShared);
        }

        if (rgnObscured != NULL)
        {
            DeleteRgn(rgnObscured);
        }
    }
    else
    {
        HRGN    hrgnInvalid;
#ifdef _DEBUG
        RECT    rcT;

        ::GetRgnBox(rgnShared, &rcT);
        TRACE_OUT(("Shared region {%04d, %04d, %04d, %04d} for host [%d]",
            rcT.left, rcT.top, rcT.right, rcT.bottom, pasHost->mcsID));

        ::GetRgnBox(rgnObscured, &rcT);
        TRACE_OUT(("Obscured region {%04d, %04d, %04d, %04d} for host [%d]",
            rcT.left, rcT.top, rcT.right, rcT.bottom, pasHost->mcsID));
#endif // _DEBUG

        //
        // Update the current shared, obscured areas.  Adjust for the
        // scroll position so these are saved in client-relative coords.
        //
        OffsetRgn(rgnShared, -pasHost->m_pView->m_viewPos.x, -pasHost->m_pView->m_viewPos.y);
        OffsetRgn(rgnObscured, -pasHost->m_pView->m_viewPos.x, -pasHost->m_pView->m_viewPos.y);

        //
        // The invalid area is whatever changed in the obscured area and
        // the shared area.  In other words, the union - the intersection.
        //
        hrgnInvalid = NULL;

        if (pasHost->m_pView->m_viewSharedRgn != NULL)
        {
            HRGN    hrgnU;
            HRGN    hrgnI;

            ASSERT(pasHost->m_pView->m_viewObscuredRgn != NULL);

            //
            // If we're in a low memory situation, just invalidate everything
            // and hope it can be repainted.
            //
            hrgnU = CreateRectRgn(0, 0, 0, 0);
            hrgnI = CreateRectRgn(0, 0, 0, 0);
            if (!hrgnU || !hrgnI)
                goto SkipMinimalInvalidate;

            hrgnInvalid = CreateRectRgn(0, 0, 0, 0);
            if (!hrgnInvalid)
                goto SkipMinimalInvalidate;


            //
            // WE'RE GOING TO DO THE SAME THING FOR BOTH SHARED AND
            // OBSCURED REGIONS.
            //

            // Get the union of the old and new shared regions
            UnionRgn(hrgnU, pasHost->m_pView->m_viewSharedRgn, rgnShared);

            // Get the intersection of the old and new shared regions
            IntersectRgn(hrgnI, pasHost->m_pView->m_viewSharedRgn, rgnShared);

            //
            // The intersection is what used to be shared and is still shared.
            // The rest is changing, it needs to be repainted.  That's the
            // union minus the intersection.
            //
            SubtractRgn(hrgnU, hrgnU, hrgnI);
#ifdef _DEBUG
            GetRgnBox(hrgnU, &rcT);
            TRACE_OUT(("VIEW_SetHostRegions: Shared area change {%04d, %04d, %04d, %04d}",
                rcT.left, rcT.top, rcT.right, rcT.bottom));
#endif // _DEBUG

            // Add this to the invalidate total
            UnionRgn(hrgnInvalid, hrgnInvalid, hrgnU);

            //
            // REPEAT FOR THE OBSCURED REGION
            //
            UnionRgn(hrgnU, pasHost->m_pView->m_viewObscuredRgn, rgnObscured);
            IntersectRgn(hrgnI, pasHost->m_pView->m_viewObscuredRgn, rgnObscured);
            SubtractRgn(hrgnU, hrgnU, hrgnI);

#ifdef _DEBUG
            GetRgnBox(hrgnU, &rcT);
            TRACE_OUT(("VIEW_SetHostRegions: Obscured area change {%04d, %04d, %04d, %04d}",
                rcT.left, rcT.top, rcT.right, rcT.bottom));
#endif // _DEBUG
            UnionRgn(hrgnInvalid, hrgnInvalid, hrgnU);

SkipMinimalInvalidate:
            //
            // Clean up scratch regions
            //
            if (hrgnI != NULL)
                DeleteRgn(hrgnI);
            if (hrgnU != NULL)
                DeleteRgn(hrgnU);

            DeleteRgn(pasHost->m_pView->m_viewSharedRgn);
            pasHost->m_pView->m_viewSharedRgn = rgnShared;

            DeleteRgn(pasHost->m_pView->m_viewObscuredRgn);
            pasHost->m_pView->m_viewObscuredRgn = rgnObscured;

            //
            // DO NOT CALL VIEW_InvalidateRgn here, that expects a region in
            // screen coords of pasHost.  We have a region that is
            // client coords relative.  So just call InvalidateRgn() directly.
            //
            InvalidateRgn(pasHost->m_pView->m_viewClient, hrgnInvalid, FALSE);

            if (hrgnInvalid != NULL)
                DeleteRgn(hrgnInvalid);
        }
        else
        {
            RECT    rcBound;

            // The shared & obscured regions are both NULL or both non-NULL
            ASSERT(pasHost->m_pView->m_viewObscuredRgn == NULL);

            pasHost->m_pView->m_viewSharedRgn = rgnShared;
            pasHost->m_pView->m_viewObscuredRgn = rgnObscured;

            //
            // This is the first SWL packet we've received.  Snap the
            // scrollbars to the start of the total shared area.  This avoids
            // having the view come up, but look empty because the shared
            // apps are out of the range.  We do this even if the user
            // scrolled around in the window already.
            //
            // The total shared area is the union of the real shared +
            // obscured shared areas.  Convert back to remote VD coords!
            //
            UnionRgn(pasHost->m_pView->m_viewScratchRgn, rgnShared, rgnObscured);
            GetRgnBox(pasHost->m_pView->m_viewScratchRgn, &rcBound);
            OffsetRect(&rcBound, pasHost->m_pView->m_viewPos.x, pasHost->m_pView->m_viewPos.y);

            //
            // Is any part of what was shared within the extent of the view?
            // If not, we can't do anything--there's nothing to show.
            //
            if ((rcBound.right <= 0) ||
                (rcBound.left  >= pasHost->viewExtent.x) ||
                (rcBound.bottom <= 0) ||
                (rcBound.top >= pasHost->viewExtent.y))
            {
                TRACE_OUT(("VIEW_SetHostRegions:  Can't snap to shared area; none is visible"));
            }
            else
            {
                //
                // Use top left corner of bounds
                // VIEWClientScroll() will pin position w/in range
                //
                VIEWClientScroll(pasHost, rcBound.left, rcBound.top);
            }

            InvalidateRgn(pasHost->m_pView->m_viewClient, NULL, FALSE);
        }
    }

    DebugExitVOID(ASShare::VIEW_SetHostRegions);
}


//
// VIEW_InvalidateRect()
// Repaints the given rect.  This is for EXTERNAL code which passes in VD
// coords.  We convert to client coordinates by accounting for the scroll
// position.
//
void  ASShare::VIEW_InvalidateRect
(
    ASPerson *  pasPerson,
    LPRECT      lprc
)
{
    DebugEntry(ASShare::VIEW_InvalidateRect);

    ValidateView(pasPerson);

    //
    // Convert to client coords
    //
    if (lprc != NULL)
    {
        OffsetRect(lprc, -pasPerson->m_pView->m_viewPos.x, -pasPerson->m_pView->m_viewPos.y);
    }

    InvalidateRect(pasPerson->m_pView->m_viewClient, lprc, FALSE);

    //
    // Convert back so caller doesn't get a modified lprc
    //
    if (lprc != NULL)
    {
        OffsetRect(lprc, pasPerson->m_pView->m_viewPos.x, pasPerson->m_pView->m_viewPos.y);
    }

    DebugExitVOID(ASShare::VIEW_InvalidateRect);
}



//
// VIEW_InvalidateRgn()
// Repaints the given region.  This is for EXTERNAL code which passes in VD
// coords.  We convert to client coordinates by accounting fo the scroll
// position.
//
void  ASShare::VIEW_InvalidateRgn
(
    ASPerson *  pasHost,
    HRGN        rgnInvalid
)
{
#ifdef _DEBUG
    //
    // Make sure we the invalid region goes back to the caller unaltered,
    // even though we modify it temporarily here to avoid a copy.
    //
    RECT        rcBoundBefore;
    RECT        rcBoundAfter;
#endif // _DEBUG

    DebugEntry(ASShare::VIEW_InvalidateRgn);

    ValidatePerson(pasHost);

    //
    // Adjust the region if the frame view is scrolled over.
    //
    if (rgnInvalid != NULL)
    {
#ifdef _DEBUG
        GetRgnBox(rgnInvalid, &rcBoundBefore);
#endif // _DEBUG

        OffsetRgn(rgnInvalid, -pasHost->m_pView->m_viewPos.x, -pasHost->m_pView->m_viewPos.y);

#ifdef _DEBUG
        TRACE_OUT(("VIEW_InvalidateRgn: Invalidating area {%04d, %04d, %04d, %04d}",
            rcBoundBefore.left, rcBoundBefore.top, rcBoundBefore.right, rcBoundBefore.bottom));
#endif // _DEBUG
    }
    else
    {
        TRACE_OUT(("VIEW_InvalidateRgn: Invalidating entire client area"));
    }

    InvalidateRgn(pasHost->m_pView->m_viewClient, rgnInvalid, FALSE);

    if (rgnInvalid != NULL)
    {
        OffsetRgn(rgnInvalid, pasHost->m_pView->m_viewPos.x, pasHost->m_pView->m_viewPos.y);
#ifdef _DEBUG
        GetRgnBox(rgnInvalid, &rcBoundAfter);
        ASSERT(EqualRect(&rcBoundBefore, &rcBoundAfter));
#endif // _DEBUG
    }

    DebugExitVOID(ASShare::VIEW_InvalidateRgn);
}



//
// VIEWClientExtentChange()
//
void ASShare::VIEWClientExtentChange(ASPerson * pasHost, BOOL fRedraw)
{
    RECT    rcl;
    SCROLLINFO si;

    DebugEntry(ASShare::VIEWClientExtentChange);

    ValidatePerson(pasHost);
    if (!pasHost->m_pView)
        DC_QUIT;

#ifdef _DEBUG
    //
    // The client area (page size) shouldn't have changed.  Only the
    // extent has.
    //
    GetClientRect(pasHost->m_pView->m_viewClient, &rcl);
    ASSERT(pasHost->m_pView->m_viewPage.x == rcl.right - rcl.left);
    ASSERT(pasHost->m_pView->m_viewPage.y == rcl.bottom - rcl.top);
#endif // _DEBUG

    pasHost->m_pView->m_viewPgSize.x = pasHost->viewExtent.x / 8;
    pasHost->m_pView->m_viewPgSize.y = pasHost->viewExtent.y / 8;
    pasHost->m_pView->m_viewLnSize.x = pasHost->viewExtent.x / 64;
    pasHost->m_pView->m_viewLnSize.y = pasHost->viewExtent.y / 64;

    //
    // Move the scroll position to the origin.
    //

    //
    // Clip the current scroll pos if we need to, now that the extent
    // has changed size.
    //
    VIEWClientScroll(pasHost, pasHost->m_pView->m_viewPos.x, pasHost->m_pView->m_viewPos.y);

    si.cbSize = sizeof(SCROLLINFO);
    si.fMask = SIF_PAGE|SIF_POS|SIF_RANGE|SIF_DISABLENOSCROLL;

    // Set vertical info.  Is vert pos out of range now?
    si.nMin = 0;
    si.nMax = pasHost->viewExtent.y - 1;
    si.nPage = pasHost->m_pView->m_viewPage.y;
    si.nPos = pasHost->m_pView->m_viewPos.y;
    ASSERT(si.nPos <= si.nMax);

    TRACE_OUT(("VIEWClientExtentChange: Setting VERT scroll info:"));
    TRACE_OUT(("VIEWClientExtentChange:     nMin    %04d", si.nMin));
    TRACE_OUT(("VIEWClientExtentChange:     nMax    %04d", si.nMax));
    TRACE_OUT(("VIEWClientExtentChange:     nPage   %04d", si.nPage));
    TRACE_OUT(("VIEWClientExtentChange:     nPos    %04d", si.nPos));
    SetScrollInfo(pasHost->m_pView->m_viewClient, SB_VERT, &si, TRUE );

    // Set horizontal (x) information
    si.nMin = 0;
    si.nMax = pasHost->viewExtent.x - 1;
    si.nPage = pasHost->m_pView->m_viewPage.x;
    si.nPos = pasHost->m_pView->m_viewPos.x;
    ASSERT(si.nPos <= si.nMax);

    TRACE_OUT(("VIEWClientExtentChange: Setting HORZ scroll info:"));
    TRACE_OUT(("VIEWClientExtentChange:     nMin    %04d", si.nMin));
    TRACE_OUT(("VIEWClientExtentChange:     nMax    %04d", si.nMax));
    TRACE_OUT(("VIEWClientExtentChange:     nPage   %04d", si.nPage));
    TRACE_OUT(("VIEWClientExtentChange:     nPos    %04d", si.nPos));
    SetScrollInfo(pasHost->m_pView->m_viewClient, SB_HORZ, &si, TRUE );

    if (fRedraw)
    {
        // Is the frame window too big now?
        if ( (pasHost->m_pView->m_viewPage.x > pasHost->viewExtent.x) ||
             (pasHost->m_pView->m_viewPage.y > pasHost->viewExtent.y) )
        {
            TRACE_OUT(("VIEWClientExtentChange: client size (%04d, %04d) now bigger than view extent (%04d, %04d)",
                pasHost->m_pView->m_viewPage.x, pasHost->m_pView->m_viewPage.y,
                pasHost->viewExtent.x, pasHost->viewExtent.y));

            //
            // Calculate the ideal size for this window.
            //
            VIEWFrameGetSize(pasHost, &rcl);

            SetWindowPos( pasHost->m_pView->m_viewFrame,
                NULL, 0, 0, rcl.right - rcl.left, rcl.bottom - rcl.top,
                SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
        }

        TRACE_OUT(("VIEWClientExtentChange: Invalidating client area"));
        VIEW_InvalidateRgn(pasHost, NULL);
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::VIEWClientExtentChange);
}



//
// VIEWFrameWindowProc()
//
LRESULT CALLBACK VIEWFrameWindowProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    return(g_asSession.pShare->VIEW_FrameWindowProc(hwnd, message, wParam, lParam));
}


LRESULT ASShare::VIEW_FrameWindowProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    LRESULT     rc = 0;
    ASPerson *  pasHost;

    DebugEntry(VIEW_FrameWindowProc);

    pasHost = (ASPerson *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if (pasHost)
    {
        ValidateView(pasHost);
    }

    switch (message)
    {
        case WM_NCCREATE:
        {
            // Get the passed in host pointer, and set in our window long
            pasHost = (ASPerson *)((LPCREATESTRUCT)lParam)->lpCreateParams;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pasHost);

            pasHost->m_pView->m_viewFrame = hwnd;

            //
            // Set the window icon
            //
            SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)
                ((pasHost->hetCount == HET_DESKTOPSHARED) ?
                  g_hetDeskIcon : g_hetASIcon));
            goto DefWndProc;
            break;
        }

        case WM_NCDESTROY:
        {
            if (pasHost != NULL)
            {
                pasHost->m_pView->m_viewFrame = NULL;
            }

            goto DefWndProc;
            break;
        }

        case WM_CREATE:
        {
            // Set title
            VIEW_HostStateChange(pasHost);

            if (!VIEWFrameCreate(pasHost))
            {
                ERROR_OUT(("VIEWFrameWindowProc: errors in creation handling for [%d]", pasHost->mcsID));
                rc = -1;
            }

            break;
        }

        case WM_DESTROY:
        {
            //
            // Clear menu bar; we always destroy it ourself.
            //
            ::SetMenu(hwnd, NULL);
            break;
        }

        case WM_ACTIVATE:
        {
            //
            // If we're switching back to the view of the host we're in
            // control of, update the key states.
            //
            if (wParam)
            {
                SetFocus(pasHost->m_pView->m_viewClient);
            }
            else
            {
                //
                // If we're full screen but are deactivating, kick out of
                // full screenmode.
                //
                if (pasHost->m_pView->m_viewFullScreen)
                {
                    // Do this later, so title bar state isn't messed up
                    ::PostMessage(hwnd, WM_COMMAND, MAKELONG(CMD_VIEWFULLSCREEN, 0), 0);
     