alue
            if (DlgDirList (
                hwndDlg,
                szLocalPath,
                NCDU_DIR_LIST,
                NCDU_DIR_PATH,
                DDL_DIRECTORY | DDL_EXCLUSIVE)) {

                // select dir in new list
                SendDlgItemMessage (hwndDlg, NCDU_DIR_LIST,
                    LB_SETCURSEL, (WPARAM)0, 0);
                SendDlgItemMessage (hwndDlg, NCDU_DIR_LIST,
                    LB_SETCARETINDEX, (WPARAM)0, MAKELPARAM(TRUE,0));
            }
        } else {
            SendDlgItemMessage (hwndDlg, NCDU_DIR_LIST,
                LB_RESETCONTENT, (WPARAM)0, (LPARAM)0);
            SetDlgItemText (hwndDlg, NCDU_DIR_PATH, szLocalPath);
        }
        FREE_IF_ALLOC (szLocalPath);
        return TRUE;
    } else {
        return FALSE;
    }
}

static
LPCTSTR
GetVolumeName (
    IN  LPCTSTR szPath
)
/*++

Routine Description:

    looks up the volume name (or net path for redirected dirs) and return's
        it to the caller. The caller is assumed to check for the existence
        of the path to prevent any OS errors.

Arguments:

    IN  LPCTSTR szPath
        path containing drive to look up

Return Value:

    volume name string if name or path found, otherwise an
    empty string if an error.

--*/
{
    static TCHAR    szVolumeName[MAX_PATH];
    TCHAR   szRootDir[4];
    DWORD   dwBufLen;

    szVolumeName[0] = 0;    // initialize string

    if (!IsUncPath(szPath)) {
        szRootDir[0] = szPath[0];       // create DriveName and root path
        szRootDir[1] = cColon;
        szRootDir[2] = cBackslash;
        szRootDir[3] = 0;

        dwBufLen = MAX_PATH * sizeof(TCHAR);
        if (OnRemoteDrive (szRootDir)) {
            // look up server and share of redirected drive
            LookupRemotePath (
                szRootDir,
                szVolumeName,
                &dwBufLen);
            // remove trailing backslash
            if (szVolumeName[lstrlen(szVolumeName)-1] == cBackslash) {
                szVolumeName[lstrlen(szVolumeName)-1] = 0;
            }
        } else {
            // look up volume name
            GetVolumeInformation (
                szRootDir,
                szVolumeName,
                dwBufLen / sizeof(TCHAR),
                NULL,
                NULL,
                NULL,
                NULL,
                0);
        }
    }  else {
        lstrcpy (szVolumeName, szPath);
    }
    return (LPCTSTR)&szVolumeName[0];
}

static
DWORD
LoadVolumeNames (
    DWORD   dwArg
)
/*++

Routine Description:

    scans the combo box entries of the drive list and adds the
        corresponding volume names to the drives in the list.
        This routine is meant to be called by the CreateThread function.

Arguments:

    Handle to dialog box window (passed in as a DWORD to conform to the
    CreateThread calling format)

Return Value:

    ERROR_SUCCESS if successful
    WIN32 Error if not

--*/
{
    HWND    hwndDlg;
    HWND    hwndDriveList;
    LONG    lItems;
    LONG    lThisItem;
    LONG    lCurrentSel;

    DWORD   dwReturn;

    LPTSTR  szListBoxText;
    TCHAR   szRootDir[4];


    szListBoxText = GlobalAlloc (GPTR, MAX_PATH_BYTES);

    if (szListBoxText == NULL) {
        dwReturn = ERROR_OUTOFMEMORY;
    } else {
        hwndDlg = (HWND)ULongToPtr(dwArg);
        hwndDriveList = GetDlgItem (hwndDlg, NCDU_DRIVE_LIST);

        lItems = (LONG)SendMessage (hwndDriveList, CB_GETCOUNT, 0, 0);

        szRootDir[1] = cColon;
        szRootDir[2] = cBackslash;
        szRootDir[3] = 0;

        for (lThisItem = 0; lThisItem < lItems; lThisItem++) {
            lCurrentSel = (LONG)SendMessage (hwndDriveList, CB_GETCURSEL, 0, 0);
            *szListBoxText = 0;
            SendMessage (hwndDriveList, CB_GETLBTEXT,
                (WPARAM)lThisItem, (LPARAM)szListBoxText);
            szRootDir[0] = szListBoxText[0];
            if (MediaPresent(szRootDir, TRUE)) {
                lstrcpy (&szListBoxText[2], csz2Spaces);
                lstrcat (szListBoxText, GetVolumeName(szRootDir));
                SendMessage (hwndDriveList, CB_DELETESTRING, (WPARAM)lThisItem, 0);
                SendMessage (hwndDriveList, CB_INSERTSTRING,
                    (WPARAM)lThisItem, (LPARAM)szListBoxText);
                if (lCurrentSel == lThisItem) {
                    szRootDir[2] = 0;
                    SendMessage (hwndDriveList, CB_SELECTSTRING, (WPARAM)-1,
                        (LPARAM)szRootDir);
                    szRootDir[2] = cBackslash;
                }
            }
        }
        dwReturn = ERROR_SUCCESS;
    }

    FREE_IF_ALLOC (szListBoxText);

    return dwReturn;
}

static
BOOL
LoadDriveList (
    IN  HWND    hwndDlg,
    IN  LPCTSTR szPath
)
/*++

Routine Description:

    initializes the drive list combo box with the drive letters of the
        valid drives then calls the LoadVolumeNames function as a
        separate thread to add the volume names.

Arguments:

    IN  HWND    hwndDlg
        window handle of dialog box

    IN  LPCTSTR szPath
        path to initialize as default

Return Value:

    TRUE if successful
    FALSE if not

--*/
{
    HWND    hwndDriveList;
    LPTSTR  szDriveName;
    TCHAR   szRootDir[4];
    LONG    nCurrentDrive;
    DWORD   idThread;

    szDriveName = GlobalAlloc (GPTR, MAX_PATH_BYTES);

    if (szDriveName != NULL) {

        hwndDriveList = GetDlgItem (hwndDlg, NCDU_DRIVE_LIST);

        SendMessage (hwndDriveList, CB_RESETCONTENT, 0, 0);

        szRootDir[0] = 0;
        szRootDir[1] = cColon;
        szRootDir[2] = cBackslash;
        szRootDir[3] = 0;

        for (szRootDir[0] = ca; szRootDir[0] <= cz; szRootDir[0] += 1) {
            // load floppy disks always
            if ((szRootDir[0] == ca) || (szRootDir[0] == cb)) {
                szRootDir[2] = 0;   // make it just a drive
                SendMessage (hwndDriveList, CB_ADDSTRING, 0, (LPARAM)szRootDir);
                szRootDir[2] = cBackslash;
            } else {
                if (MediaPresent(szRootDir, TRUE)) {
                    szRootDir[2] = 0;   // make it just a drive
                    SendMessage (hwndDriveList, CB_ADDSTRING, 0, (LPARAM)szRootDir);
                    szRootDir[2] = cBackslash;
                }
            }
        }
        if (!IsUncPath(szPath)) {
            szRootDir[0] = szPath[0];
            szRootDir[1] = szPath[1];
            szRootDir[2] = 0;
        } else {
            GetCurrentDirectory (MAX_PATH, szDriveName);
            szRootDir[0] = szDriveName[0];
            szRootDir[1] = szDriveName[1];
            szRootDir[2] = 0;
        }
        _tcslwr (szRootDir);
        nCurrentDrive = (int)SendMessage (hwndDriveList, CB_SELECTSTRING,
            (WPARAM)-1, (LPARAM)szRootDir);
        if (nCurrentDrive == CB_ERR) {
            szRootDir[0] = cc;
            nCurrentDrive = (int)SendMessage (hwndDriveList, CB_SELECTSTRING,
                (WPARAM)-1, (LPARAM)szRootDir);
            if (nCurrentDrive == CB_ERR) {
                SendMessage (hwndDriveList, CB_SETCURSEL, (WPARAM)2, 0);
            }
        }
    }

    // start thread to fill in volume names

    CreateThread ((LPSECURITY_ATTRIBUTES)NULL, 0,
        (LPTHREAD_START_ROUTINE)LoadVolumeNames,
        (LPVOID)hwndDlg, 0, &idThread);

    FREE_IF_ALLOC (szDriveName);

    return TRUE;

}

static
BOOL
DirBrowseDlg_WM_INITDIALOG (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Process the WM_INITDIALOG windows message. Initializea the
        values in the dialog box controls to reflect the current
        values of browser struct passed in.

Arguments:

    IN  HWND    hwndDlg
        handle to dialog box window

    IN  WPARAM  wParam
        Not Used

    IN  LPARAM  lParam
        address of a DIR_BROWSER_STRUCT used to pass args back & forth

Return Value:

    FALSE

--*/
{
    TCHAR   szTitle[MAX_PATH];

    if (lParam != 0) {
    	pDbData = (PDB_DATA)lParam;
        if (pDbData->dwTitle != 0) {
            if (LoadString (
                (HINSTANCE)GetWindowLongPtr(hwndDlg, GWLP_HINSTANCE),
                pDbData->dwTitle,
                szTitle,
                MAX_PATH) > 0) {
                SetWindowText (hwndDlg, szTitle);
             }
        }

        // save the current directory
        GetCurrentDirectory (MAX_PATH, szSaveCurrentDir);

        if (*pDbData->szPath != 0) {
            lstrcpy (szReturnPath, GetDefaultDisplayDir (pDbData->szPath));
        } else {
            lstrcpy (szReturnPath, szSaveCurrentDir);
        }
        LoadDriveList (hwndDlg, szReturnPath);
        ListDirsInEditPath (hwndDlg, szReturnPath);
        SetFocus (GetDlgItem (hwndDlg, NCDU_DIR_LIST));

    } else {
        EndDialog (hwndDlg, IDCANCEL); // error
    }

    return FALSE;
}

static
BOOL
DirBrowseDlg_IDOK (
    IN  HWND    hwndDlg
)
/*++

Routine Description:

    Processes the IDOK button click. Validates the entries and looks up
        the distribution path to try and translate it to a UNC path.
        Then ends the dialog and calls the next dialog box.

Arguments:

    IN  HWND    hwndDlg
        handle to the dialog box window

Return Value:

    FALSE

--*/
{
    lstrcpy(pDbData->szPath, szReturnPath);
    EndDialog (hwndDlg, IDOK);

    return TRUE;
}

static
BOOL
DirBrowseDlg_IDCANCEL (
    IN  HWND    hwndDlg
)
/*++

Routine Description:

    ends the dialog box (and ultimately the app)

Arguments:

    IN  HWND    hwndDlg

Return Value:

    FALSE

--*/
{
    EndDialog (hwndDlg, IDCANCEL);
    return TRUE;
}

static
BOOL
DirBrowseDlg_WM_COMMAND (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Processes the WM_COMMAND windows message and dispatches to
        the routine that corresponds to the control issuing the
        message.

Arguments:

    IN  HWND    hwndDlg
        Handle to dialog box window

    IN  WPARAM  wParam
        LOWORD  has ID of control initiating the message

    IN  LPARAM  lParam
        Not Used

Return Value:

    TRUE if message not processed by this routine, otherwise the
        value of the dispatched routine .

--*/
{
    LPTSTR  szTempPath;
    BOOL    bCheckDrive;
    BOOL    bNewDriveOk;
    UINT    nMessageBoxButton;

    switch (LOWORD(wParam)) {
        case IDCANCEL:              return DirBrowseDlg_IDCANCEL (hwndDlg);
        case IDOK:                  return DirBrowseDlg_IDOK (hwndDlg);
        case NCDU_DIR_LIST:
            // test notification message
            switch (HIWORD(wParam)) {
                case LBN_DBLCLK:
                    if (SendDlgItemMessage(hwndDlg, NCDU_DIR_LIST,
                        LB_GETCOUNT, 0, 0) > 0) {
                        szTempPath = GlobalAlloc (GPTR, MAX_PATH_BYTES);
                        if (szTempPath != NULL) {
                            // there's items in the list box and the
                            // selection changed so update dlg contents
                            DlgDirSelectEx (
                                hwndDlg,
                                szTempPath,
                                MAX_PATH,
                                NCDU_DIR_LIST);

                            UpdateReturnPath (szTempPath);

                            ListDirsInEditPath (
                                hwndDlg,
                                szReturnPath);

                            FREE_IF_ALLOC (szTempPath);
                            return TRUE;
                        } else {
                            // unable to allocate memory
                            return FALSE;
                        }
                    } else {
                        // no list box items
                        return FALSE;
                    }

                default:
                    return FALSE;
            }

        case NCDU_DRIVE_LIST:
            switch (HIWORD(wParam)) {
                case CBN_SELCHANGE:
                case CBN_DBLCLK:
                    szTempPath = GlobalAlloc (GPTR, MAX_PATH_BYTES);
                    if (szTempPath != NULL) {
                        SendDlgItemMessage (hwndDlg, NCDU_DRIVE_LIST,
                            WM_GETTEXT, (WPARAM)MAX_PATH,
                            (LPARAM)szTempPath);
                        szTempPath[2] = cBackslash;
                        szTempPath[3] = 0;
                        if ((pDbData->Flags & PDB_FLAGS_NOCHECKDIR) == PDB_FLAGS_NOCHECKDIR) {
                            bCheckDrive = FALSE;
                            bNewDriveOk = TRUE;
                        } else {
                            bCheckDrive = TRUE;
                            bNewDriveOk = FALSE;
                        }

                        while (bCheckDrive) {
                            if (!MediaPresent(szTempPath, TRUE)) {
                                nMessageBoxButton = DisplayMessageBox (
                                    hwndDlg,
                                    NCDU_DRIVE_NOT_AVAILABLE,
                                    0,
                                    MB_ICONEXCLAMATION | MB_RETRYCANCEL | MB_TASKMODAL);
                                if (nMessageBoxButton == IDCANCEL) {
                                    bCheckDrive = FALSE;
                                    bNewDriveOk = FALSE;
                                }
                            } else {
                                bCheckDrive = FALSE;
                                bNewDriveOk = TRUE;
                            }
                        }

                        if (bNewDriveOk) {
                            // update dir list for new drive
                            lstrcpy (szReturnPath, szTempPath);
                            ListDirsInEditPath (
                                hwndDlg,
                                szReturnPath);
                        } else {
                            // reset drive list selection
                            szTempPath[0] = szReturnPath[0];
                            szTempPath[1] = cColon;
                            szTempPath[2] = 0;
                            SendDlgItemMessage (hwndDlg, NCDU_DRIVE_LIST,
                                CB_SELECTSTRING, (WPARAM)-1, (LPARAM)szTempPath);
                        }

                        FREE_IF_ALLOC (szTempPath);
                        return TRUE;
                    } else {
                        return FALSE;
                    }

                default:
                    return FALSE;
            }

        case NCDU_BROWSE_NETWORK:
            WNetConnectionDialog (hwndDlg, RESOURCETYPE_DISK);
            // update dir list
            LoadDriveList (hwndDlg, szReturnPath);
            ListDirsInEditPath (hwndDlg, szReturnPath);
            return TRUE;

        default:
            return FALSE;
    }
}

static
BOOL
DirBrowseDlg_WM_VKEYTOITEM (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Processes the WM_COMMAND windows message and dispatches to
        the routine that corresponds to the control issuing the
        message.

Arguments:

    IN  HWND    hwndDlg
        Handle to dialog box window

    IN  WPARAM  wParam
        LOWORD  has Virtual Key code of key pressed
        HIWORD  has current caret position

    IN  LPARAM  lParam
        Handle of list box issuing message

Return Value:

    -2 if no further action required by DefWindowProc
    -1 if default action for key should be taken by DefWindowProc
   >=0 if default action should be take on the n'th item in the list


--*/
{
    HWND    hwndListBox;
    WORD    wCaretPos = 0;
    int     nLbItemCount = 0;
    BOOL    bSetCaretPos = FALSE;
    int     nReturn;
    LPTSTR  szTempPath;

    hwndListBox = GetDlgItem(hwndDlg, NCDU_DIR_LIST);
    if ((HWND)lParam == hwndListBox) {
        // this is from the dir list box
        wCaretPos = HIWORD(wParam);
        switch (LOWORD(wParam)) {
            // take action on specific key code.
            case VK_UP:
            case VK_LEFT:
                // go up one item if not at top
                if (wCaretPos > 0){
                    wCaretPos -= 1; // decrement one
                }
                bSetCaretPos = TRUE;
                nReturn = -2;
                break;

            case VK_RIGHT:
            case VK_DOWN:
                // go down one if not at bottom
                nLbItemCount = (int)SendDlgItemMessage (
                    hwndDlg, NCDU_DIR_LIST, LB_GETCOUNT, 0, 0);
                // adjust to be Max Index
                nLbItemCount -= 1;

                if ((int)wCaretPos < nLbItemCount) {
                    wCaretPos += 1;
                }
                bSetCaretPos = TRUE;
                nReturn = -2;
                break;

            case VK_SPACE:
                if (SendDlgItemMessage(hwndDlg, NCDU_DIR_LIST,
                    LB_GETCOUNT, 0, 0) > 0) {
                    szTempPath = GlobalAlloc (GPTR, MAX_PATH_BYTES);
                    if (szTempPath != NULL) {
                        // select this item
                        DlgDirSelectEx (
                            hwndDlg,
                            szTempPath,
                            MAX_PATH,
                            NCDU_DIR_LIST);
                        UpdateReturnPath (szTempPath);
                        ListDirsInEditPath (hwndDlg, szReturnPath);
                        bSetCaretPos = FALSE;
                        FREE_IF_ALLOC (szTempPath);
                    }
                } else {
                    // no items in list box so ignore.
                }
                nReturn = -2;
                break;


            default:
                bSetCaretPos = FALSE;
                nReturn = -1;
                break;
        }
        if (bSetCaretPos) {
            SendDlgItemMessage (hwndDlg, NCDU_DIR_LIST,
                LB_SETCURSEL, (WPARAM)wCaretPos, 0);
            SendDlgItemMessage (hwndDlg, NCDU_DIR_LIST,
                LB_SETCARETINDEX, (WPARAM)wCaretPos, MAKELPARAM(TRUE,0));
        }
        return (BOOL)nReturn;
    } else {
        return (BOOL)-1;
    }
}

INT_PTR CALLBACK
DirBrowseDlgProc (
    IN  HWND    hwndDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Main Dialog Box Window Procedure for the Initial configuration screen
        Processes the following windows messages by dispatching the
        appropriate routine.

            WM_INITDIALOG:  dialog box initialization
            WM_COMMAND:     user input

        All other windows messages are processed by the default dialog box
        procedure.

Arguments:

    Standard WNDPROC arguments

Return Value:

    FALSE if the message is not processed by this routine, otherwise the
        value returned by the dispatched routine.

--*/
{
    switch (message) {
        case WM_INITDIALOG: return (DirBrowseDlg_WM_INITDIALOG (hwndDlg, wParam, lParam));
        case WM_COMMAND:    return (DirBrowseDlg_WM_COMMAND (hwndDlg, wParam, lParam));
        case WM_VKEYTOITEM: return (DirBrowseDlg_WM_VKEYTOITEM (hwndDlg, wParam, lParam));
        case WM_DESTROY:
            SetCurrentDirectory (szSaveCurrentDir);
            return TRUE;
        default:            return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\clcreator\dirutils.c ===
/*++

    Copyright (c) 1994  Microsoft Corporation

Module Name:

    DirUtils.C

Abstract:

    directory, file, filename and network utility functions.

Author:

    Bob Watson (a-robw)

Revision History:

    24 Jun 94    Written

--*/
//
//  Windows Include Files
//

#include <windows.h>
#include <stdio.h>
#include <malloc.h>
#include <tchar.h>      // unicode macros
#include <stdlib.h>     // string to number conversions
#include <lmcons.h>     // lanman API constants
#include <lmerr.h>      // lanman error returns
#include <lmshare.h>    // sharing API prototypes
#include <lmapibuf.h>   // lanman buffer API prototypes
#include <commdlg.h>    // common dialog include
//
//  app include files
//
#include "otnboot.h"
#include "otnbtdlg.h"

LPCTSTR
GetRootFromPath (
    IN  LPCTSTR  szPath
)
{
    static TCHAR szReturnBuffer[MAX_PATH];
    LPTSTR      szNextChar;
    LONG        lIndex;

    if (IsUncPath(szPath)) {
        // return server & share
        lstrcpy (szReturnBuffer, cszDoubleBackslash);
        szNextChar = &szReturnBuffer[2];
        if (GetServerFromUnc (szPath, szNextChar)) {
            lstrcat (szReturnBuffer, cszBackslash);
            szNextChar = &szReturnBuffer[lstrlen(szReturnBuffer)];
            if (GetShareFromUnc(szPath, szNextChar)) {
                // append trailing backslash
                lstrcat (szReturnBuffer, cszBackslash);
            } else {
                szReturnBuffer[0] = 0;
            }
        } else {
            szReturnBuffer[0] = 0;
        }
    } else {
        // dos path name
        for (lIndex = 0; lIndex < 3; lIndex++) {
            if (szPath[lIndex] > cSpace) {
                szReturnBuffer[lIndex] = szPath[lIndex];
            } else {
                break;
            }
        }
        szReturnBuffer[lIndex] = 0;
  }
    return (LPCTSTR)&szReturnBuffer[0];
}

BOOL
GetShareFromUnc (
    IN  LPCTSTR  szPath,
    OUT LPTSTR   szShare
)
/*++

Routine Description:

    Parses a UNC path name and returns the Sharepoint name in the buffer
        supplied by the caller. The buffer size is not checked and is
        assumed to be at least (MAX_SHARENAME+1) characters
        long.

Arguments:

    IN  LPCTSTR  szPath     UNC path name to parse

    OUT LPTSTR   szShare    buffer supplied by caller to receive the server


Return Value:

    TRUE    if a sharename is returned, otherwise...
    FALSE   if unable to parse out a share name

--*/
{
    int nSlashCount = 0;    // count of backslashes found in string

    LPTSTR  szPathPtr;      // pointer to char in szPath
    LPTSTR  szSharePtr;     // pointer to char in szShare

    szPathPtr = (LPTSTR)szPath;
    szSharePtr = szShare;

    if (IsUncPath(szPath)) {
        while (*szPathPtr != 0) {
            if (nSlashCount < 3) {
                if (*szPathPtr++ == cBackslash) nSlashCount++;
            } else {
                if (*szPathPtr == cBackslash) {
                    szPathPtr++;
                    break;
                } else {
                    *szSharePtr++ = *szPathPtr++;
                }
            }
        }
    }

    *szSharePtr = 0; // terminate share name

    if (szSharePtr == szShare) {
        return FALSE;
    } else {
        return TRUE;
    }
}

BOOL
GetNetPathInfo (
    IN  LPCTSTR szPath,
    OUT LPTSTR  szServer,
    OUT LPTSTR  szRemotePath
)
/*++

Routine Description:

    Processes a path and returns the machine the files are on and the
        local path on that machine. UNC, Redirected and local paths may
        be processed by this routine. On remote machine paths (e.g.
        redir'd dos paths and UNC paths on another machine) the shared
        path on the remote machine is returned if there user has sufficient
        permission to access that information. On local paths, the
        local computer name and root path is returned.

Arguments:

    IN  LPCTSTR szPath
        the input path to analyze.

    OUT LPTSTR  szServer
        the server/computername that the path references. The buffer size
        is NOT checked and must be at least MAX_COMPUTERNAME_LENGTH+1 char's
        long.

    OUT LPTSTR  szRemotePath
        the path on the "szServer" machine that corresponds to the
        input path. The buffer size is NOT checked and must be at least
        MAX_PATH + 1 characters long.

Return Value:

    TRUE if a path was processed and data returned
    FALSE if an error occurred or unable to process the path

--*/
{
    DWORD   dwBufLen;               // buffer length value used in fn. calls
    DWORD   dwStatus;               // status value returned by fn. calls
    TCHAR   szShareName[NNLEN+1];   // net share name from path
    LPTSTR  szUncPath;              // buffer to get path from redir'd drive
    TCHAR   szDrive[4];             // buffer to build drive string in
    LPTSTR  szSubDirs;              // pointer to start of dirs not in share
    LONG    lBsCount;               // count of backslashes found parsing UNC
    BOOL    bReturn = FALSE;        // return valie
    PSHARE_INFO_2    psi2Data;      // pointer to Net data buffer

    // check args
    if ((szServer == NULL) || (szRemotePath == NULL)) {
        // an invalid argument was passed
        return FALSE;
    }

    szUncPath = GlobalAlloc (GPTR, MAX_PATH_BYTES);

    if (szUncPath == NULL) {
        *szServer = 0;
        *szRemotePath = 0;
        return FALSE;
    }

    // args ok, so take a look at the path passed in to process
    if (IsUncPath(szPath)) {
        // extract the server from the path string
        if (GetServerFromUnc(szPath, szServer)) {
            // that worked, so extract the share name.
            if (GetShareFromUnc(szPath, szShareName)) {
                // find end of UNC so sub dirs may be appended to final path
                for (szSubDirs = (LPTSTR)szPath, lBsCount = 0;
                     (lBsCount < 4) && (*szSubDirs != 0);
                     szSubDirs++) {
                    if (*szSubDirs == cBackslash) lBsCount++;
                }
                // now look up the share on the server to get the
                // source path on the server machine
                if (NetShareGetInfo (szServer, (LPWSTR)szShareName, 2L, (LPBYTE *)&psi2Data) == NERR_Success) {
                    // successful call so copy the data to the user's buffer
                    lstrcpy (szRemotePath, psi2Data->shi2_path);
                    NetApiBufferFree (psi2Data);
                    // add this only if there's a subdir to append
                    if (*szSubDirs != 0) {
                        if (szRemotePath[lstrlen(szRemotePath)-1] != cBackslash)
                            lstrcat(szRemotePath, cszBackslash);
                        lstrcat (szRemotePath, szSubDirs);
                    }
                    bReturn = TRUE;
                } else {
                    // unable to get path on server
                    *szRemotePath = 0;
                    bReturn = FALSE;
                }
            } else {
                // unable to get parse share name
                *szRemotePath = 0;
                bReturn = FALSE;
            }
        } else {
            // unable to parse server name
            *szServer = 0;
            *szRemotePath = 0;
            bReturn = FALSE;
        }
    } else {
        // it's a dos pathname so see if it's a redirected drive
        if (OnRemoteDrive(szPath)) {
            // yes it's been redirected so look up the information
            // get drive letter of redirected drive
            szDrive[0] = szPath[0];
            szDrive[1] = szPath[1];
            szDrive[2] = 0;
            szSubDirs = (LPTSTR)&szPath[3];
            dwBufLen = MAX_PATH;
            dwStatus = WNetGetConnection (
                szDrive,
                szUncPath,
                &dwBufLen);
            if (dwStatus == NO_ERROR) {
                // UNC of shared dir looked up ok, now proccess that to
                // find the server and path on the server
                if (GetServerFromUnc(szUncPath, szServer)) {
                    if (GetShareFromUnc(szUncPath, szShareName)) {
                        // now look up the share on the server
                        if (NetShareGetInfo (szServer, (LPWSTR)szShareName, 2L, (LPBYTE *)&psi2Data) == NERR_Success) {
                            // successful call so return pointer to path string
                            lstrcpy (szRemotePath, psi2Data->shi2_path);
                            NetApiBufferFree (psi2Data);
                            if (*szSubDirs != 0) {
                                if (szRemotePath[lstrlen(szRemotePath)-1] != cBackslash)
                                    lstrcat(szRemotePath, cszBackslash);
                                lstrcat (szRemotePath, szSubDirs);
                            }
                            bReturn = TRUE;
                        } else {
                            // unable to get path on server
                            *szRemotePath = 0;
                            bReturn = FALSE;
                        }
                    } else {
                        // unable to get parse share name
                        *szRemotePath = 0;
                        bReturn = FALSE;
                    }
                } else {
                    // unable to parse server name
                    *szServer = 0;
                    *szRemotePath = 0;
                    bReturn = FALSE;
                }
            }
        } else {
            // this is a local path so return the local machine name
            // and the path passed in
            dwBufLen = MAX_COMPUTERNAME_LENGTH+1;
            GetComputerName (szServer, &dwBufLen);
            lstrcpy (szRemotePath, szPath);
            bReturn = TRUE;
        }
    }

    FREE_IF_ALLOC (szUncPath);
    return bReturn;
}

BOOL
ComputerPresent (
    IN  LPCTSTR     szMachine
)
/*++

Routine Description:

    Try to connect to the registry on the machine name in order to
        determine if the machine is available on the network.

Arguments:

    IN  LPCTSTR     szMachine
        computer name to try (must be in the form of \\machine)

Return Value:

    TRUE    "szMachine" is present
    FALSE   unable to connect to machine

--*/
{
    LONG    lStatus;                // status of function call
    HKEY    hKey;                   // handle to registry key opened

    lStatus = RegConnectRegistry (
        (LPTSTR)szMachine,
        HKEY_LOCAL_MACHINE,
        &hKey);

    if (lStatus == ERROR_SUCCESS) {
        RegCloseKey (hKey);
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
GetServerFromUnc (
    IN  LPCTSTR  szPath,
    OUT LPTSTR  szServer
)
/*++

Routine Description:

    reads a UNC path and returns the name of the server referenced in
        the buffer provided by the caller

Arguments:

    IN  LPCTSTR  szPath
        UNC path to parse

    OUT LPTSTR  szServer
        buffer to receive name of server (must be large enough!)

Return Value:

    TRUE if successful,
    FALSE if not

--*/
{
    LPTSTR  szPathPtr;          // pointer to char in szPath
    LPTSTR  szServPtr;          // pointer to char in szServer
    int     nSlashCount = 0;    // count of backslash chars found

    szPathPtr = (LPTSTR)szPath;
    szServPtr = szServer;

    if (IsUncPath(szPath)) {
        while (szPathPtr != 0) {
            if (*szPathPtr == cBackslash) nSlashCount++;
            if ((nSlashCount == 2) && (*szPathPtr != cBackslash)) {
                *szServPtr++ = *szPathPtr;
            } else {
                if (nSlashCount == 3) break;  // exit loop
            }
            szPathPtr++;
        }
    }

    *szServPtr = 0; // terminate server name

    if (szServPtr == szServer) {
        return FALSE;
    } else {
        return TRUE;
    }
}

BOOL
LookupLocalShare (
    IN  LPCTSTR  szDrivePath,
    IN  BOOL    bExactMatch,
    OUT LPTSTR  szLocalPath,
    IN  PDWORD  pdwBuffLen
)
/*++

Routine Description:

    Searches registry to see if a file is already shared and returns
        the UNC name of the path if it is. (note this function is
        satisfied by the first match it finds, it doesn't try to
        find the "Best" match, just "A" match.

Arguments:

    IN  LPCTSTR  szDrivePath
        DOS file path to look up

    IN  BOOL    bExactMatch
        TRUE    find a share that matches the szDrivePath EXACTLY
        FALSE   find a share that has any higher path in szDrivePath
            (e.g. if c:\dir is shared as XXX, then XXX would satisfy
            the lookup if the path was c:\dir\subdir\etc)

    OUT LPTSTR  szLocalPath
        buffer to receive UNC version of path if a share exists

    IN  PDWORD  pdwBuffLen
        length of buffer referenced by szLocalPath

Return Value:

    TRUE if a match is found,
    FALSE if not

--*/
{
    HKEY    hkeyShareList;      // handle to registry listing shares
    LONG    lStatus;            // called function status return value
    BOOL    bReturn = FALSE;    // routine status to return to caller
    BOOL    bMatch;             // true when strings match
    DWORD   dwIndex;            // index used to increment through search
    LPTSTR  szValueBuffer;      // value name string to examine
    LPTSTR  szValueName;        // value value string
    DWORD   dwBufferSize;       // buffer length variable
    DWORD   dwNameSize;         // Name Buffer size
    DWORD   dwDataType;         // data type read from registry

    LPTSTR  szThisItem;         // pointer to value in enumerated list of values
    LPTSTR  szThisItemChar;     // char in name value to compare to path
    LPTSTR  szThisMatchChar;    // matching character  found
    LPTSTR  szFilePath;         // pointer into path buffer where filename is

    TCHAR   szLocalMachine[MAX_COMPUTERNAME_LENGTH + 1];

    szValueName = GlobalAlloc (GPTR, MAX_PATH_BYTES);
    szValueBuffer = GlobalAlloc (GPTR, (SMALL_BUFFER_SIZE * sizeof(TCHAR)));

    if ((szValueName != NULL) && (szValueBuffer != NULL)) {
        // read the registry on the machine the user is
        // running the app on, not the server
        lStatus = RegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            cszLanmanServerShares,
            0L,
            KEY_READ,
            &hkeyShareList);

        if (lStatus == ERROR_SUCCESS) {
            // loop through all values under this key until
            // a match is found or all have been examined
            dwIndex = 0;
            dwIndex = 0;
            dwNameSize = MAX_PATH;
            dwBufferSize = SMALL_BUFFER_SIZE;
            dwNameSize = MAX_PATH;
            dwBufferSize = SMALL_BUFFER_SIZE;
            while ((RegEnumValue(hkeyShareList, dwIndex,
                szValueName, &dwNameSize,
                0L, &dwDataType,
                (LPBYTE)szValueBuffer, &dwBufferSize) == ERROR_SUCCESS) && !bReturn) {
                // value read in so scan multi-sz returned to find path entry
                for (szThisItem = szValueBuffer;
                    *szThisItem != 0;
                    szThisItem += (lstrlen(szThisItem)+1)) {
                    // compare the current entry to the "Path" string.
                    // if the characters don't match then exit the loop
                    // after the loop, if the match char == 0 then all
                    // characters in the "item" matched so this is the
                    // Path entry. otherwise, it's not the path so go to the
                    // the next item.
                    for (szThisItemChar = szThisItem, szThisMatchChar = (LPTSTR)cszPath;
                        (*szThisMatchChar != 0) && (*szThisItemChar != 0);
                        szThisItemChar++, szThisMatchChar++) {
                        if (*szThisMatchChar != *szThisItemChar) break;
                    }
                    if (*szThisMatchChar == 0) {
                        // this is a match so see what the path that is
                        // shared.
                        while (*szThisItemChar != cEqual) szThisItemChar++;
                        szThisItemChar++;
                        // szThisItemChar now points to the path that is shared
                        // compare it to the path that was passed in. if it matches,
                        // then return the local machine and share name in a UNC
                        // format
                        if (bExactMatch) {
                            if (lstrcmpi(szThisItemChar, szDrivePath) == 0) {
                                bMatch = TRUE;
                            } else {
                                bMatch = FALSE;
                            }
                        } else {
                            bMatch = MatchFirst(szThisItemChar, szDrivePath);
                        }
                        if (bMatch) {
                            // it's a match so format return value
                            dwBufferSize = MAX_COMPUTERNAME_LENGTH + 1;
                            GetComputerName(
                                szLocalMachine,
                                &dwBufferSize);
                            if (szLocalPath != NULL) {
                                //
                                //  format name by replacing drive letter and colon
                                //  with UNC format \\server\path
                                //
                                lstrcpy (szLocalPath, cszDoubleBackslash);
                                lstrcat (szLocalPath, szLocalMachine);
                                lstrcat (szLocalPath, cszBackslash);
                                lstrcat (szLocalPath, szValueName);
                                szFilePath = (LPTSTR)&szDrivePath[lstrlen(szThisItemChar)];
                                if (*szFilePath != cBackslash) lstrcat (szLocalPath, cszBackslash);
                                lstrcat (szLocalPath, szFilePath);
                            }
                            bReturn = TRUE;
                        }
                    } else {
                        // this is not the path entry so break and go to the
                        // next one.
                    }
                }

                // read next value
                dwIndex++;
                dwNameSize = MAX_PATH;
                dwBufferSize = SMALL_BUFFER_SIZE;
            }
            RegCloseKey (hkeyShareList);
        } else {
            // unable to open registry key
            bReturn = FALSE;
        }
    } else {
        // unable to allocate memory
        bReturn = FALSE;
    }

    FREE_IF_ALLOC (szValueName);
    FREE_IF_ALLOC (szValueBuffer);

    return bReturn;
}

BOOL
LookupRemotePath (
    IN  LPCTSTR  szDrivePath,
    OUT LPTSTR  szRemotePath,
    IN  PDWORD  pdwBuffLen
)
/*++

Routine Description:

    Looks up a path on a remote server to see if a Dos file path is really
        on a remote drive and returns the UNC path if it is.

Arguments:

    IN  LPCTSTR  szDrivePath
        DOS file path to examine

    OUT LPTSTR  szRemotePath
        buffer to get UNC version of path if one exists

    IN  PDWORD  pdwBuffLen
        length of szRemotePath buffer in bytes

Return Value:

    TRUE if match found
    FALSE if no match

--*/
{
    HKEY    hkeyNetDrive;       // handle to registry describing remote drive
    LONG    lStatus;            // function status returned by called fn's
    LPTSTR  szKeyName;          // buffer to build name string in
    TCHAR   szLocalDrive[4];    // buffer to build local drive string in
    LPTSTR   szFilePath;        // pointer into buffer where file path goes
    DWORD   dwValueType;        // buffer for registry query
    BOOL    bReturn;            // return value of this function

    szKeyName = GlobalAlloc (GPTR, MAX_PATH_BYTES);

    if (szKeyName == NULL) return FALSE;

    lstrcpy (szKeyName, cszNetDriveListKeyName);
    szLocalDrive[0] = szDrivePath[0];
    szLocalDrive[1] = 0;
    lstrcat (szKeyName, szLocalDrive);
    szFilePath = (LPTSTR)&szDrivePath[2];

    lStatus = RegOpenKeyEx (
        HKEY_CURRENT_USER,
        szKeyName,
        0L,
        KEY_READ,
        &hkeyNetDrive);

    if (lStatus == ERROR_SUCCESS) {
        lStatus = RegQueryValueEx (
            hkeyNetDrive,
            (LPTSTR)cszRemotePathValue,
            0L,
            &dwValueType,
            (LPBYTE)szRemotePath,
            pdwBuffLen);

        RegCloseKey (hkeyNetDrive);

        if (lStatus == ERROR_SUCCESS) {
            //append the rest of the path and exit
            lstrcat (szRemotePath, szFilePath);
            bReturn = TRUE;
        } else {
            bReturn = FALSE;
        }
    } else {
        //  unable to find drive or open key
        bReturn = FALSE;
    }

    FREE_IF_ALLOC (szKeyName);

    return bReturn;
}

BOOL
OnRemoteDrive (
    IN  LPCTSTR  szPath
)
/*++

Routine Description:

    Returns TRUE if drive referenced is a network drive as opposed to
        on on the local machine

Arguments:

    IN  LPCTSTR  szPath
        path to look up

Return Value:

    TRUE if szPath references a remote drive
    FALSE if szPath references a local drive

--*/
{
    TCHAR   szRootDir[4];                               // drive string
    TCHAR   szServerName[MAX_COMPUTERNAME_LENGTH*2];    // server name buffer
    TCHAR   szComputerName[MAX_COMPUTERNAME_LENGTH+1];  // local machine name
    DWORD   dwBufLen;                                   // buffer len. var.

    if (IsUncPath(szPath)) {
        if (GetServerFromUnc(szPath, szServerName)) {
            dwBufLen = MAX_COMPUTERNAME_LENGTH+1;
            GetComputerName (szComputerName, &dwBufLen);
            if (lstrcmpi(szServerName, szComputerName) == 0) {
                // shared on this machine so not remote
                return FALSE;
            } else {
                // not on this machine so it must be remote
                return TRUE;
            }
        }
    } else {
        // check the DOS path
        // see if this is a network or local drive
        szRootDir[0]    =   szPath[0]; // letter
        szRootDir[1]    =   szPath[1]; // colon
        szRootDir[2]    =   cBackslash;
        szRootDir[3]    =   0;

        if (GetDriveType(szRootDir) == DRIVE_REMOTE) {
            return TRUE;
        } else {
            return FALSE;
        }
    }
    return FALSE;
}

DWORD
ComputeFreeSpace (
    IN  LPCTSTR  szPath
)
/*++

Routine Description:

    Function to return free space on drive referenced in path
        (NOTE: assumes DOS file path specification)

Arguments:

    IN  LPCTSTR  szPath
        Path including Drive to check free space of. (MUST BE A DOS
        FILE Path)

Return Value:

    Free space found in BYTES

--*/
{
    DWORD   dwSectorsPerCluster;
    DWORD   dwBytesPerSector;
    DWORD   dwFreeClusters;
    DWORD   dwClusters;
    TCHAR   szRoot[MAX_PATH];              // root dir of path
    DWORD   dwFreeBytes = 0;

    UINT    nErrorMode;

    // disable windows error message popup
    nErrorMode = SetErrorMode  (SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

    lstrcpy (szRoot, GetRootFromPath(szPath));
    if (lstrlen(szRoot) > 0) {
        // we have a path to process so get info from the root
        if (GetDiskFreeSpace(szRoot, &dwSectorsPerCluster,
            &dwBytesPerSector, &dwFreeClusters, &dwClusters)) {

            ULONGLONG ullFreeBytes;

            ullFreeBytes =
                (ULONGLONG)dwFreeClusters *
                    dwSectorsPerCluster * dwBytesPerSector;

            dwFreeBytes = (DWORD) ullFreeBytes;

            if( (ULONGLONG)dwFreeBytes != ullFreeBytes ) {

                //
                // Overflow has occured.
                //

                dwFreeBytes = 0xFFFFFFFF;
            }
        }
    } else {
        dwFreeBytes = 0xFFFFFFFF;
    }
    SetErrorMode (nErrorMode);  // restore old error mode
    return dwFreeBytes;
}

BOOL
IsShareNameUsed (
    IN      LPCTSTR szServerName,
    IN      LPCTSTR szShareName,
    IN  OUT PDWORD  pdwType,
    IN  OUT LPTSTR  pszPath
)
/*++

Routine Description:

    Looks up a share name on a sever to determine if the name is in use
        and if so, what type of directory is shared.

Arguments:

    IN      LPCTSTR szServerName
        server name to look up share name on (NULL == the local machine)

    IN      LPCTSTR szShareName
        share name to look up

    IN  OUT PDWORD  pdwType
        buffer to return share type in options are:
            NCDU_SHARE_IS_NOT_USED:     name not found on server
            NCDU_SHARE_IS_CLIENT_TREE:  name is a client distribution tree
            NCDU_SHARE_IS_SERVER_TOOLS: name is a server tool tree
            NCDU_SHARE_IS_OTHER_DIR:    name is shared to some other dir.

    IN  OUT LPTSTR  pszPath
        if path is shared, then this is the path on the server that
        is shared

Return Value:

    TRUE    if share name is in use
    FALSE   if the share name is not found on the server.

--*/
{
    LPTSTR  szLocalPath;                // local buffer to build path string in
    LPTSTR  szLocalName;                // pointer into path where sharename starts
    DWORD   dwShareAttrib;              // file attributes of share point
    DWORD   dwBufLen;                   // buffer length variable
    BOOL    bReturn = FALSE;            // function return value
    DWORD   dwLocalType;                // share dir type
    PSHARE_INFO_2   psi2Data = NULL;    // net info buffer pointer
    LPTSTR  szReturnPath
        = (LPTSTR)cszEmptyString;       // pointer to path string to return

    szLocalPath = GlobalAlloc (GPTR, MAX_PATH_BYTES);

    if (szLocalPath != NULL) {
        // make share name into a UNC name using the appropriate machine
        lstrcpy (szLocalPath, cszDoubleBackslash);
        if (szServerName == NULL) {
            dwBufLen = MAX_COMPUTERNAME_LENGTH + 1;
            GetComputerName (&szLocalPath[2], &dwBufLen);
        } else {
            lstrcat (szLocalPath, szServerName);
        }
        lstrcat (szLocalPath, cszBackslash);
        szLocalName = &szLocalPath[lstrlen(szLocalPath)];
        lstrcpy (szLocalName, szShareName);
        TrimSpaces (szLocalName);

        // see if it's a valid path
        dwShareAttrib = QuietGetFileAttributes (szLocalPath);

        if (dwShareAttrib == 0xFFFFFFFF) {
            // it's not a valid file or dir, so
            bReturn = FALSE;    // share name is not used
            szReturnPath = (LPTSTR)cszEmptyString;
            dwLocalType = NCDU_SHARE_IS_NOT_USED;
        } else {
            // it's a valid path so see if it's anything we want
            bReturn = TRUE;
            // terminate local path after server name for use in net API Call
            *(szLocalName - 1) = 0;
            // get share info
            if (NetShareGetInfo ((LPWSTR)szLocalPath, (LPWSTR)szShareName,
                2L, (LPBYTE *)&psi2Data) == NERR_Success) {
                // successful call so return pointer to path string
                szReturnPath = psi2Data->shi2_path;
            } else {
                // function failed so return empty path
                szReturnPath = (LPTSTR)cszEmptyString;
            }
            // restore local path string
            *(szLocalName - 1) = cBackslash;
            // share is used, so see if it's a clients path
            if (*szReturnPath != 0) {
                if (ValidSharePath (szLocalPath) == 0) {
                    dwLocalType = NCDU_SHARE_IS_CLIENT_TREE;
                } else if (ValidSrvToolsPath (szLocalPath) == 0) {
                    dwLocalType = NCDU_SHARE_IS_SERVER_TOOLS;
                } else {
                    dwLocalType = NCDU_SHARE_IS_OTHER_DIR;
                }
            } else {
                // no path name
                bReturn = FALSE;
                dwLocalType = NCDU_SHARE_IS_NOT_USED;
            }
        }
        FREE_IF_ALLOC (szLocalPath);
    } else {
        // unable to allocate memory
        bReturn = FALSE;
        dwLocalType = 0;
    }

    if (pdwType != NULL) {
        *pdwType = dwLocalType;
    }

    if (pszPath != NULL) {
        lstrcpy (pszPath, szReturnPath);
    }
    // free buffer created by net call
    if (psi2Data != NULL) NetApiBufferFree (psi2Data);

    return bReturn;
}

DWORD
QuietGetFileAttributes (
    IN  LPCTSTR lpszFileName
)
/*++

Routine Description:

    Reads the attributes of the path in lpzsFileName without triggering
        any Windows error dialog if there's an OS error (e.g. drive not
        ready)

Arguments:

    IN  LPCTSTR lpszFileName
        path to retrieve attributes from

Return Value:

    file attributes DWORD returned from GetFileAttributes or
        0xFFFFFFFF if unable to open path.

--*/
{
    DWORD   dwReturn;
    UINT    nErrorMode;

    // disable windows error message popup
    nErrorMode = SetErrorMode  (SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

    dwReturn = GetFileAttributes (lpszFileName);

    SetErrorMode (nErrorMode);  // restore old error mode

    return dwReturn;
}

BOOL
GetSizeOfDirs (
    IN  LPCTSTR szPath,
    IN  BOOL    bFlags,
    IN  OUT PDWORD  pdwSize
)
/*++

Routine Description:

    Scans a directory and optionally a subdirectory to total the sizes
        of the files found.

        NOTE: This function will only process files that are < 4GB in size
        and dir paths that total less then 4GB total.

Arguments:

    IN  LPCTSTR szPath
        top dir or dir tree to scan.

    IN  BOOL    bFlags
        operation modification flags:
            0                   :   specified path only.
            GSOD_INCLUDE_SUBDIRS:   include sub dirs

    IN  OUT PDWORD  pdwSize
        buffer to return size in.

Return Value:

    TRUE    size returned in pdwSize
    FALSE   error occurred

--*/
{
    HANDLE              hSearch;
    HANDLE              hFile;
    WIN32_FIND_DATA     fdSearch;
    PDWORD              pdwSizeBuffer;
    DWORD               dwLocalSize = 0;
    DWORD               dwPathAttrib;
    BOOL                bSearching;
    LPTSTR              szLocalPath;
    LPTSTR              szSearchPath;
    LPTSTR              szLocalFileName;
    DWORD               dwFileSizeLow;
    DWORD               dwFileSizeHigh;
    LPTSTR              szThisFileName;
    BOOL                bReturn;
    //
    //  check path to see if it's a directory
    //
    dwPathAttrib = QuietGetFileAttributes (szPath);
    // if an invalid attribute or it's not a directory then return FALSE and set error
    if ((dwPathAttrib == 0xFFFFFFFF) ||
        ((dwPathAttrib & FILE_ATTRIBUTE_DIRECTORY) != FILE_ATTRIBUTE_DIRECTORY)) {
        SetLastError (ERROR_BAD_PATHNAME);
        return FALSE;
    }
    //
    //  Initialize size buffer
    //
    if (pdwSize == NULL) {
        pdwSizeBuffer = &dwLocalSize;
    } else {
        pdwSizeBuffer = pdwSize;
    }
    //  get a local buffer for the path
    szSearchPath = GlobalAlloc (GPTR, MAX_PATH_BYTES);
    szLocalPath = GlobalAlloc (GPTR, MAX_PATH_BYTES);
    if ((szLocalPath != NULL) && (szSearchPath != NULL)) {
        // make a local copy of the input path
        lstrcpy (szLocalPath, szPath);
        lstrcpy (szSearchPath, szLocalPath);
        // make full path prefix for sub dir searches & filenames
        if (szLocalPath[lstrlen(szLocalPath)-1] != cBackslash) lstrcat (szLocalPath, cszBackslash);
        szLocalFileName = &szLocalPath[lstrlen(szLocalPath)];
        // make wildcard path for searching this directory
        lstrcat (szSearchPath, cszWildcardFile);
        //
        //  start search of files in this path
        //
        hSearch = FindFirstFile (szSearchPath, &fdSearch);
        if (hSearch != INVALID_HANDLE_VALUE) {
            bSearching = TRUE;
            while (bSearching) {
                // if an alternate filename is defined, then use it, otherwise
                // use the regular name
                szThisFileName = ((fdSearch.cAlternateFileName[0] == 0) ?
                            fdSearch.cFileName : fdSearch.cAlternateFileName);
                // if it's a dot or a dot dot (. or ..) dir, then skip
                if (!DotOrDotDotDir(szThisFileName)) {
                    lstrcpy (szLocalFileName, szThisFileName);
                    // if it's a dir and the SUB DIR flag is set, then
                    // recurse through the next directory, otherwise
                    // get the file size of this file and continue
                    dwPathAttrib = QuietGetFileAttributes (szLocalPath);
                    if ((dwPathAttrib & FILE_ATTRIBUTE_DIRECTORY) ==
                        FILE_ATTRIBUTE_DIRECTORY) {
                        // this is a directory, so call this routine again
                        // if the sub-dir flag is set.
                        if ((bFlags & GSOD_INCLUDE_SUBDIRS) == GSOD_INCLUDE_SUBDIRS) {
                            if (!GetSizeOfDirs (szLocalPath, bFlags, pdwSizeBuffer)) {
                                // this call returned an errror so propogate it
                                // up the call stack and exit the loop here
                                bSearching = FALSE;
                                continue;
                            }
                        } else {
                            // the caller doesn't want sub dirs so ignore it
                        }
                    } else {
                        // this is a file so get the size of it and add
                        // it to the total
                        hFile = CreateFile (
                            szLocalPath,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);
                        if (hFile != INVALID_HANDLE_VALUE) {
                            // then the file was opened successfully
                            // go get it's size and add it to the total
                            dwFileSizeLow = GetFileSize (hFile, &dwFileSizeHigh);
                            if (dwFileSizeLow != 0xFFFFFFFF) {
                                *pdwSizeBuffer += dwFileSizeLow;
                            }
                            // now close the file handle
                            CloseHandle (hFile);
                        } else {
                            // unable to open file so skip it
                        }
                    }
                }
                bSearching = FindNextFile (hSearch, &fdSearch);
            }
            FindClose (hSearch);
        } else {
            // unable to start search so return 0 size
        }
        bReturn = TRUE;
    } else {
        // unable to allocate memory
        SetLastError (ERROR_OUTOFMEMORY);
        bReturn = FALSE;
    }

    FREE_IF_ALLOC (szLocalPath);
    FREE_IF_ALLOC (szSearchPath);

    return bReturn;
}

BOOL
MediaPresent (
    IN  LPCTSTR szPath,
    IN  BOOL    bPresentAndValid
)
/*++

Routine Description:

    determines if the specified path is present and available

Arguments:

    IN  LPCTSTR szPath
        path to examine (Must be a DOS path)

Return Value:

    TRUE:   path is available
    FALSE:  unable to find/open path

--*/
{
    TCHAR   szDev[8];
    DWORD   dwBytes = 0;
    DWORD   dwAttrib;
    DWORD   dwLastError = ERROR_SUCCESS;
    BOOL    bMediaPresent = FALSE;
    UINT    nErrorMode;

    if (!IsUncPath(szPath)) {
        // build device name string
        szDev[0] = szPath[0];
        szDev[1] = cColon;
        szDev[2] = cBackslash;
        szDev[3] = 0;

        // disable windows error message popup
        nErrorMode = SetErrorMode  (SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

        dwAttrib = QuietGetFileAttributes (szDev);
        if ((dwAttrib != 0xFFFFFFFF) && ((dwAttrib & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY)) {
            // if the root dir is a dir, then it must be present and formatted
            bMediaPresent = TRUE;
        } else {
            // otherwise see if it's present and not formatted or not present
            dwLastError = GetLastError();
            if (dwLastError == ERROR_NOT_READY) {
                // then no disk in drive
                    bMediaPresent = FALSE;
            } else if ((dwLastError == ERROR_FILE_NOT_FOUND) ||
#ifdef TERMSRV
                (dwLastError == ERROR_UNRECOGNIZED_MEDIA) ||
                (dwLastError == ERROR_SECTOR_NOT_FOUND)) {
#else // TERMSRV
                (dwLastError == ERROR_UNRECOGNIZED_MEDIA)) {
#endif // TERMSRV
                // then and UNFORMATTED disk is in drive
                if (bPresentAndValid) {
                    // this isn't good enough if it's supposed to be formatted
                    bMediaPresent = FALSE;
                } else {
                    // we're just looking for a disk so this is OK
                    bMediaPresent = TRUE;
                }
            }
        }

        SetErrorMode (nErrorMode);  // restore old error mode
    } else {
        // assume UNC path devices are present
        bMediaPresent = TRUE;
    }
    return bMediaPresent;
}

BOOL
FileExists (
    IN  LPCTSTR   szFileName
)
/*++

Routine Description:

    Opens the file to test for it's presences and returns TRUE if the
        open was successful and FALSE if not.

Arguments:

        file name to open

ReturnValue:

        TRUE    if file found
        FALSE   if not.

--*/
{
    BOOL    bMediaPresent;
    UINT    nDriveType;
    DWORD   dwAttr;

    nDriveType = GetDriveType((LPTSTR)szFileName);
    if ((nDriveType == DRIVE_REMOVABLE) || (nDriveType == DRIVE_CDROM)) {
        // see if a formatted drive is really there
        bMediaPresent = MediaPresent(szFileName, TRUE);
    } else {
        // if drive is not removable, then assume it's there
        bMediaPresent = TRUE;
    }

    // try to get inforation on the file
    dwAttr = QuietGetFileAttributes ((LPTSTR)szFileName);
    if (dwAttr == 0xFFFFFFFF) {
        // unable to obtain attributes, so assume it's not there
        // or we can't access it
        return FALSE;
    } else {
        // found, so close it and return TRUE
        return TRUE;
    }
}

BOOL
IsBootDisk (
    IN  LPCTSTR  szPath
)
/*++

Routine Description:

    examines the path (which should be the root dir of a floppy drive)
        and looks for the "signature" files that indicate it's a bootable
        (i.e. system) disk.

Arguments:

    IN LPCTSTR  szPath
        drive path to look at

Return Value:

    TRUE if one of the signature files was found
    FALSE if not.

--*/
{
    TCHAR   szDrive[16];
    LPTSTR  szTestFile;
    LPTSTR  *szTryFile;

    szTestFile = GlobalAlloc (GPTR, MAX_PATH_BYTES);

    if (szTestFile == NULL) {
        SetLastError (ERROR_OUTOFMEMORY);
        return FALSE;   // unable to continue
    }

    if (!IsUncPath(szPath)) {
        szDrive[0] = szPath[0]; // drive letter
        szDrive[1] = szPath[1]; // colon
        szDrive[2] = cBackslash;
        szDrive[3] = 0;         // terminator

        for (szTryFile = (LPTSTR *)szBootIdFiles;
            *szTryFile != NULL;
            szTryFile++) {

            lstrcpy (szTestFile, szDrive);
            lstrcat (szTestFile, *szTryFile);

            if (FileExists(szTestFile)) return TRUE;
        }
        // if we didn't bail out already, it must not be a bootable disk
        return FALSE;
    } else {
        // unc path name automatically is not a bootable drive
        return FALSE;
    }

    FREE_IF_ALLOC (szTestFile);
}

MEDIA_TYPE
GetDriveTypeFromPath (
    IN  LPCTSTR  szPath
)
/*++

Routine Description:

    returns the drive type of the drive specified in the path argument

Arguments:

    IN  LPCTSTR szPath
        path on drive to examine

Return Value:

    MEDIA_TYPE value identifying drive type

--*/
{
    HANDLE  hFloppy;
    DWORD   dwRetSize;
    DISK_GEOMETRY   dgFloppy;
    TCHAR   szDevicePath[16];
    UINT    nDriveType;
    UINT    nErrorMode;

    nDriveType = GetDriveType((LPTSTR)szPath);
    // see if this is a remote disk and exit if it is.
    if (nDriveType == DRIVE_REMOTE) return Unknown;

    if ((nDriveType == DRIVE_REMOVABLE) || (nDriveType == DRIVE_CDROM)) {
        // see if it's a UNC path and return unknown if so
        if (IsUncPath(szPath)) return Unknown;

        // it should be local and a DOS pathname so
        // make device name from path

        szDevicePath[0] = cBackslash;
        szDevicePath[1] = cBackslash;
        szDevicePath[2] = cPeriod;
        szDevicePath[3] = cBackslash;
        szDevicePath[4] = szPath[0]; // drive letter
        szDevicePath[5] = szPath[1]; // colon
        szDevicePath[6] = 0;    // null terminator

        // disable windows error message popup
        nErrorMode = SetErrorMode  (SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

        // open device to get type
        hFloppy = CreateFile (
            szDevicePath,
            GENERIC_READ,
            (FILE_SHARE_READ | FILE_SHARE_WRITE),
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

        if (hFloppy != INVALID_HANDLE_VALUE) {
            // get drive information
            if (!DeviceIoControl (hFloppy,
                IOCTL_DISK_GET_DRIVE_GEOMETRY,
                NULL, 0,
                &dgFloppy,
                sizeof(DISK_GEOMETRY),
                &dwRetSize,
                NULL) ){
                // unable to get data so set to unknown
                dgFloppy.MediaType = Unknown;
            } // else return data from returned structure
            CloseHandle (hFloppy);
        } else {
            // unable to open handle to device
            dgFloppy.MediaType = Unknown;
        }
        SetErrorMode (nErrorMode); // reset error mode
    }
    return dgFloppy.MediaType;
}

BOOL
DotOrDotDotDir (
    IN  LPCTSTR   szFileName
)
/*++

Routine Description:

    examines the filename in the parameter list to see if it is one
    of the default subdirectories (e.g. the . or the .. dirs). This
    routine assumes that the argument is a filename only. (i.e. NO
    PATH!)

Arguments:

    Filename to compare

Return Value:

    TRUE if filename is either the . or the .. dir
    FALSE if it is any other string

--*/
{
    if (szFileName != NULL) {     // check for null parameter
        if (lstrcmp(szFileName, cszDot) == 0) {
            return TRUE; // it's the . dir
        } else if (lstrcmp(szFileName, cszDotDot) == 0) {
            return TRUE; // it's the .. dir
        } else {
            return FALSE; // it's neither
        }
    } else {
        return FALSE; // null filename, so not a . or .. dir
    }
}

UINT
ValidSharePath (
    IN  LPCTSTR  szPath
)
/*++

Routine Description:

    examines the path to see if it contains the "signature" file
        that identifies the path as as that of a valid client
        distribution directory tree.

Arguments:

    IN  LPCTSTR  szPath
        path to examine

Return Value:

    ERROR_SUCCESS if it is
        otherwise the ID of a string resource that describes
        what was found and why it isn't a distribution tree

--*/
{
    DWORD   dwPathAttr;
    UINT    nReturn = 0;

    LPTSTR  szInfName;

    szInfName = GlobalAlloc (GPTR, MAX_PATH_BYTES);

    if (szInfName == NULL) {
        SetLastError (ERROR_OUTOFMEMORY);
        return NCDU_ERROR_NOMEMORY;
    }

    // validate share path by looking for INF file, display
    // error box if necessary.
    // Return 0 if valid
    // return message string ID if not valid, for what ever reason.
    //
    dwPathAttr = QuietGetFileAttributes((LPTSTR)szPath);
    if (dwPathAttr == 0xFFFFFFFF) {
        // an error occured...
        nReturn = NCDU_UNABLE_READ_DIR;
    } else {
        if ((dwPathAttr & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY) {
            // so far so good!
            lstrcpy (szInfName, szPath);
            if (szInfName[lstrlen(szInfName)-1] != cBackslash) lstrcat(szInfName, cszBackslash);
            lstrcat (szInfName, cszAppInfName);
            dwPathAttr = QuietGetFileAttributes(szInfName);
            if (dwPathAttr != 0xFFFFFFFF) {
                nReturn = 0;
            } else {
                nReturn = NCDU_NOT_DIST_TREE;
            }
        } else {
            nReturn = NCDU_PATH_NOT_DIR;
        }
    }

    FREE_IF_ALLOC (szInfName);

    return (nReturn);
}

UINT
ValidSrvToolsPath (
    IN  LPCTSTR  szPath
)
/*++

Routine Description:

    examines the path to see if it contains the "signature" file
        that identifies the path as as that of a valid server tools
        distribution directory tree.

Arguments:

    IN  LPCTSTR  szPath
        path to examine

Return Value:

    ERROR_SUCCESS if it is
        otherwise the ID of a string resource that describes
        what was found and why it isn't a server tools tree

--*/
{
    UINT    nReturn = 0;
    DWORD   dwAttrib;

    LPTSTR  szClientPath;

    szClientPath = GlobalAlloc (GPTR, MAX_PATH_BYTES);

    if (szClientPath == NULL) {
        SetLastError (ERROR_OUTOFMEMORY);
        return NCDU_ERROR_NOMEMORY;
    }

    // make local copy of the path
    lstrcpy (szClientPath, szPath);

    // get file attributes of dir path to make sure it's really a dir
    dwAttrib = QuietGetFileAttributes (szClientPath);
    if ((dwAttrib != 0xFFFFFFFF) && ((dwAttrib & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY)) {
        if (szClientPath[lstrlen(szClientPath)-1] != cBackslash) lstrcat(szClientPath, cszBackslash);
        lstrcat (szClientPath, cszSrvToolSigFile);
        // now get the file attributes of the signature file to see if this is a valid path
        dwAttrib = QuietGetFileAttributes (szClientPath);
        if (dwAttrib != 0xFFFFFFFF) {
            nReturn = 0;
        } else {
            nReturn = NCDU_NOT_TOOL_TREE;
        }
    } else {
        nReturn = NCDU_PATH_NOT_DIR;
    }

    FREE_IF_ALLOC (szClientPath);

    return (nReturn);
}

BOOL
IsPathADir (
    IN  LPCTSTR szPath
)
/*++

Routine Description:

    Checks the path passed in to see if it's a directory or not

Arguments:

    IN  LPCTSTR szPath
        path to check

Return Value:

    TRUE if path is a valid directory
    FALSE if unable to find path or if path is not a directory

--*/
{
    DWORD    dwAttrib;
    dwAttrib = QuietGetFileAttributes (szPath);
    if ((dwAttrib != 0xffffffff) &&
        ((dwAttrib & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY)) {
        return TRUE;
    } else {
        return FALSE;
    }
}

static
DWORD
GetSectorSize (
    IN  LPTSTR   szDriveName
)
/*++

Routine Description:

    Returns the sector size in bytes of the disk drive specified in the
        argument list.

Arguments:

    IN  LPTSTR   szDriveName     ASCIZ of drive to return data for (e.g. "C:")

Return Value:

    size of disk sector in bytes,
    0xFFFFFFFF ((DWORD)-1) if error, error retrieved using GetLastError()

--*/
{
    BOOL    bStatus;
    LONG    lReturn = 0xFFFFFFFF;

    DWORD   dwBytesReturned;

    HANDLE  hDrive;

    DISK_GEOMETRY   dgBuffer;

    // open existing file (root drive)

    hDrive = CreateFile (
        szDriveName,
        GENERIC_READ,
        (FILE_SHARE_READ | FILE_SHARE_WRITE),
        NULL,
        OPEN_EXISTING,
        0L,
        NULL);

    if (hDrive != INVALID_HANDLE_VALUE) {
        // get disk inoformation
        bStatus = DeviceIoControl(
            hDrive,
            IOCTL_DISK_GET_DRIVE_GEOMETRY,
            NULL,
            0L,
            &dgBuffer,
            sizeof(dgBuffer),
            &dwBytesReturned,
            NULL);

        // if data was returned by IOCTL, then return
        // sector size other wise return error value

        if (bStatus) {
            lReturn = dgBuffer.BytesPerSector;
        } else {
            lReturn = 0xFFFFFFFF;
        }

        CloseHandle (hDrive);   // don't forget to close the handle

    } else {
        // unable to open device
        lReturn = 0xFFFFFFFF;
    }

    return lReturn;
}

static
LONG
CopyFatBootSectorToBuffer (
    IN  LPTSTR   szBootDrive,
    IN  LPBYTE  *pOutputBuffer
)
/*++

Routine Description:

    Copies the first sector of the volume to the specified file

Arguments:

    IN  LPTSTR   szBootDrive     volume to locate boot sector on
    IN  LPBYTE  *pOutputBuffer  address of pointer to buffer created

Return Value:

    Win 32 Status Value:

        ERROR_SUCCESS   The routine complete all operations normally

--*/
{

    LONG    lStatus = ERROR_SUCCESS;
    BOOL    bStatus = FALSE;

    DWORD   dwByteCount;
    DWORD   dwBytesRead;

    HANDLE  hDrive;

    LPBYTE  pBootSector;

    dwByteCount = GetSectorSize (szBootDrive);

    if (dwByteCount != 0xFFFFFFFF) {
        // allocate buffer to read data into
        pBootSector = (LPBYTE)GlobalAlloc(GPTR, dwByteCount);
    } else {
        pBootSector = NULL;
        lStatus = GetLastError();
    }

    if (pBootSector != NULL) {
        // if memory allocated successfully, then open drive

        hDrive = CreateFile (
            szBootDrive,
            GENERIC_READ,
            (FILE_SHARE_READ | FILE_SHARE_WRITE),
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

        if (hDrive != INVALID_HANDLE_VALUE) {

            SetFilePointer (hDrive, 0, NULL, FILE_BEGIN);   // go to beginning

            bStatus = ReadFile (
                hDrive,
                pBootSector,
                dwByteCount,
                &dwBytesRead,
                NULL);

            if (bStatus) {
                *pOutputBuffer = pBootSector;
                lStatus = ERROR_SUCCESS;
            } else {
                // unable to read the file (drive) so return error
                *pOutputBuffer = NULL;
                lStatus = GetLastError();
            }
            // close handle now that we're done with it.
            CloseHandle (hDrive);
        } else {
            // unable to open drive
            *pOutputBuffer = NULL;
            lStatus = GetLastError();
        }
    } else {
        lStatus = ERROR_OUTOFMEMORY;
    }

    return lStatus;
}

DWORD
GetBootDiskDosVersion (
   IN   LPCTSTR szPath
)
/*++

Routine Description:

    examines the boot sector of the disk in the drive described in the
        path variable and returns the MAJOR version of the OS that
        formatted the disk.

Arguments:

    IN  LPCTSTR szPath
        path containing drive to examine


Return Value:

    Major version of MS-DOS that formatted the disk.

    Zero is returned when:
        -- the boot sector on the drive cannot be read
        -- the drive is not a bootable drive

--*/
{
    PDOS_BOOT_SECTOR  pBootSector = NULL;
    TCHAR   szDrive[8];
    DWORD   dwReturn;

    if (IsBootDisk(szPath)) {
        szDrive[0] = cBackslash;
        szDrive[1] = cBackslash;
        szDrive[2] = cPeriod;
        szDrive[3] = cBackslash;
        szDrive[4] = szPath[0];
        szDrive[5] = szPath[1];
        szDrive[6] = 0;
        szDrive[7] = 0;

        if (CopyFatBootSectorToBuffer (
            szDrive, (LPBYTE *)&pBootSector) == ERROR_SUCCESS) {
            dwReturn = (pBootSector->bsOemName[5] - '0');
        } else {
            dwReturn = 0;
        }

        // free buffer allocated in CopyFatBootSectorToBuffer call.
        FREE_IF_ALLOC (pBootSector);
    } else {
        dwReturn = 0;
    }
    return dwReturn;
}

DWORD
GetClusterSizeOfDisk (
    IN  LPCTSTR szPath
)
/*++

Routine Description:

    returns the cluster size (in bytes) of the disk in the path

Arguments:

    Path containing disk drive to examine

Return Value:

    cluster size (allocation unit size) of disk in bytes.
    if the function cannot determine the cluster size, then
    a value of 512 for floppy disk or 4096 for hard disks will
    be returned.

--*/
{
    DWORD   dwSectorsPerCluster;
    DWORD   dwBytesPerSector;
    DWORD   dwFreeClusters;
    DWORD   dwClusters;
    TCHAR   szRoot[4];              // root dir of path
    DWORD   dwClusterSize = 0;

    UINT    nErrorMode;

    // disable windows error message popup
    nErrorMode = SetErrorMode  (SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

    if (!IsUncPath(szPath)) {
        szRoot[0] = szPath[0];  // drive letter
        szRoot[1] = szPath[1];  // colon
        szRoot[2] = cBackslash;   // backslash
        szRoot[3] = 0;          // null terminator

        if (GetDiskFreeSpace(szRoot, &dwSectorsPerCluster,
            &dwBytesPerSector, &dwFreeClusters, &dwClusters)) {
            dwClusterSize = dwSectorsPerCluster * dwBytesPerSector;
        } else {
            if (GetDriveType (szRoot) == DRIVE_FIXED) {
                dwClusterSize = 4096;
            } else {
                dwClusterSize = 512;
            }
        }
    } else {
        dwClusterSize = 4096;
    }
    SetErrorMode (nErrorMode);  // restore old error mode
    return dwClusterSize;
}

DWORD
QuietGetFileSize (
    IN  LPCTSTR szPath
)
/*++

Routine Description:

    Returns the size of the file passed in the arg list ( file sizz < 4GB)
        while supressing any windows system error messages.

Arguments:

    path to file to size

Return Value:

    size of the file (if less then 4GB) or 0xFFFFFFFF if error

--*/
{
    HANDLE  hFile;
    DWORD   dwFileSizeLow, dwFileSizeHigh;
    DWORD   dwReturn;
    UINT    nErrorMode;

    // disable windows error message popup
    nErrorMode = SetErrorMode  (SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

    // get the size of the file and add it to the total
    hFile = CreateFile (
        szPath,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);
    if (hFile != INVALID_HANDLE_VALUE) {
        // then the file was opened successfully
        // go get it's size
        dwFileSizeLow = GetFileSize (hFile, &dwFileSizeHigh);
        dwReturn = dwFileSizeLow;
        // now close the file handle
        CloseHandle (hFile);
    } else {
        // unable to open file so return error
        dwReturn = 0xFFFFFFFF;
    }

    SetErrorMode (nErrorMode);  // restore old error mode

    return dwReturn;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\clcreator\exitmess.c ===
/*++

    Copyright (c) 1994  Microsoft Corporation

Module Name:

    EXITMESS.C

Abstract:

    good bye message dialog box

Author:

    Bob Watson (a-robw)

Revision History:

    17 Feb 94    Written

--*/
//
//  Windows Include Files
//

#include <windows.h>
#include <stdio.h>
#include <malloc.h>
#include <tchar.h>      // unicode macros
//
//  app include files
//
#include "otnboot.h"
#include "otnbtdlg.h"
//
extern BOOL bDisplayExitMessages;

static
DWORD
FormatExitMessageString (
    IN      HWND    hTextWnd,
    IN  OUT LPTSTR  szBuffer,
    IN      DWORD   dwBufSize
)
/*++

Routine Description:

    Formats the message string to fit in the Text Window by word wrapping
        and indenting the text string in szBuffer.

Arguments:

    IN      HWND    hTextWnd
            handle of text window that will display the text

    IN  OUT LPTSTR  szBuffer
            string to display

    IN      DWORD   dwBufSize
            size of szBuffer in characters

Return Value:



--*/
{
    LPTSTR  szWorkString;
    LPTSTR  szSrc, szDest, szLine, szSrcWord, szDestWord;
    HDC     hDC;
    SIZE    sizeText;
    RECT    rTextWnd;
    int     nCharsInLine;
    DWORD   dwCharsInString = 0;
    LONG    nWindowWidth;
//#ifdef DBCS
// fixed kkntbug #10802
//    NCAdmin: The sentence of an end message is strange

    WORD    wCharType;
    WCHAR   szCheckStyle[2];
    LCID    lcid = GetSystemDefaultLCID();
    HFONT   hf, hfOld;

//#endif

    szWorkString = GlobalAlloc (GPTR, dwBufSize * sizeof(TCHAR));

    if (szWorkString != NULL) {
        // get DC of window
        hDC = GetDC (hTextWnd);

        if( hDC != NULL ) {
//#ifdef DBCS
// fixed kkntbug #10802
//    NCAdmin: The sentence of an end message is strange

            // reset DC with font object for getting correct size
            hf = (HFONT)SendMessage(hTextWnd, WM_GETFONT, 0, 0);
            if (hf) hfOld = SelectObject(hDC, hf);
//#endif

            // get size of window
            GetWindowRect (hTextWnd, &rTextWnd);
            nWindowWidth = rTextWnd.right - rTextWnd.left;
            // subtract left & right borders
            nWindowWidth -= (GetSystemMetrics (SM_CXBORDER) * 2);
            // subtract scroll bar width
            nWindowWidth -= GetSystemMetrics (SM_CXVSCROLL);
            // subtract text indent
//#ifdef DBCS
// fixed kkntbug #10802
//    NCAdmin: The sentence of an end message is strange

            sizeText.cx = sizeText.cy = 0;
            GetTextExtentPoint32 (hDC,
                                  fmtLeadingSpaces,
                                  lstrlen(fmtLeadingSpaces),
                                  &sizeText);
            nWindowWidth -= sizeText.cx;
//#else
//        nWindowWidth -= 4;  // as measured
//#endif
            // initialize pointers & counters
            szSrc = szSrcWord = szBuffer;
            szLine = szDestWord = szDest = szWorkString;
            nCharsInLine = 0;
            dwCharsInString = 0;
            // process string
            while (*szSrc != 0) {
                *szDest = *szSrc;
                // get length of new string after a word has been copied

//#ifdef DBCS
// fixed kkntbug #10802
//    NCAdmin: The sentence of an end message is strange
// fixed kkntbug #13147
//    NCAdmin:When ending "Make Network Installation Setup Disk" ,apllication error occurs.

                //
                // check what the "szSrc"(just 1 character) is type
                //
                szCheckStyle[0] = *szSrc;
                szCheckStyle[1] = UNICODE_NULL;
                if (!GetStringTypeEx(lcid,
                                     CT_CTYPE3,
                                     szCheckStyle,
                                     1,
                                     &wCharType))
                    wCharType = 0;

                if ((*szSrc == cSpace)        ||
                    (wCharType & C3_KATAKANA) ||
                   !(wCharType & C3_HALFWIDTH)) {
//#else
//            if (*szSrc == cSpace) {
//#endif
                    // reset size variable
                    sizeText.cx = sizeText.cy = 0;
                    GetTextExtentPoint32 (hDC, szLine, nCharsInLine, &sizeText);
                    // then check the size
                    if (sizeText.cx >= nWindowWidth) {
                        // this word pushes past the edge so wrap the word
                        // and place it on the next line
                        lstrcpy (szDestWord, cszCrLf);
                        szLine = szDestWord+2;  // start new line after CrLf
                        dwCharsInString += 2;
                        lstrcat (szDestWord, fmtLeadingSpaces);
                        szSrc = szSrcWord;
                        szDest = szDestWord + lstrlen(szDestWord);
                        // copy last word to new line
//#ifdef DBCS
// fixed kkntbug #10802
//    NCAdmin: The sentence of an end message is strange
// fixed kkntbug #13147
//    NCAdmin:When ending "Make Network Installation Setup Disk" ,apllication error occurs.

                        while (*szSrc) {
                            //
                            // check what the "szSrc"(just 1 character) is type
                            //
                            szCheckStyle[0] = *szSrc;
                            szCheckStyle[1] = UNICODE_NULL;
                            if (!GetStringTypeEx(lcid,
                                                 CT_CTYPE3,
                                                 szCheckStyle,
                                                 1,
                                                 &wCharType))
                                 wCharType = 0;

                            if ((wCharType & C3_KATAKANA)   ||
                               !(wCharType & C3_HALFWIDTH)  ||
                                (*szSrc == cSpace)          ||
                                (*szSrc == 0))
                                break;
//#else
//                    while ((*szSrc != cSpace) && (*szSrc != 0)) {
//#endif
                            *szDest++ = *szSrc++;
                        }
//#ifdef DBCS
// fixed kkntbug #10802
//    NCAdmin: The sentence of an end message is strange

                        if ((*szSrc != 0)              &&
                           !(wCharType & C3_KATAKANA)  &&
                            (wCharType & C3_HALFWIDTH)) {
//#else
//                    if (*szSrc != 0) {
//#endif
                            // copy space after word to get back to pre-wrap
                            // position
                            *szDest++ = *szSrc++;
                        }
                        // update counters
                        nCharsInLine = lstrlen(szLine);
                        dwCharsInString += nCharsInLine;
                    } else {
                        //this one fits, so advance pointer to next char
                        szDest++;
                        szSrc++;
                        nCharsInLine++;
                        dwCharsInString++;
                    }
                    // update word pointers
                    szSrcWord = szSrc;
                    szDestWord = szDest;
                } else {
                    szSrc++;
                    szDest++;
                    nCharsInLine++;
                    dwCharsInString++;
                }
                if (dwCharsInString >= dwBufSize) break; // quit before overflow
            }
//#ifdef DBCS
            // restore old font object
            if (hf) SelectObject(hDC, hfOld);
//#endif
            ReleaseDC (hTextWnd, hDC);
            // copy new string to orig.
            lstrcpy (szBuffer, szWorkString);
            FREE_IF_ALLOC (szWorkString);
        }
    }
    return dwCharsInString;
}

static
BOOL
ExitMessDlg_WM_INITDIALOG (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Initializes message display translating all buffered message codes
        and writing the corresponding messages to the display. If no
        messages are in the list, the the dialog box is closed and not
        displayed.

Arguments:

    IN  HWND    hwndDlg
        Handle to dialog box window

    IN  WPARAM  wParam
        Not Used

    IN  LPARAM  lParam
        Not Used

Return Value:

    FALSE if messages displayed
    TRUE if dialog box is closed

--*/
{
    LPTSTR  szTextBuff;
    LPTSTR  szStringBuff;
    DWORD   dwMsgNdx;
    RECT    rEditWindow;
    BOOL    bReturn;

    // don't even bother unless the "display Exit Messages" flag is set

    if (bDisplayExitMessages)  {
        szStringBuff = GlobalAlloc (GPTR, SMALL_BUFFER_SIZE * sizeof(TCHAR));

        if (szStringBuff == NULL) return TRUE;

        // only display if there are any messages to show

        if (pAppInfo->uExitMessages[0] != 0) {
            RemoveMaximizeFromSysMenu (hwndDlg);
            PositionWindow  (hwndDlg);

            szTextBuff = GlobalAlloc (GPTR, (MEDIUM_BUFFER_SIZE * sizeof(TCHAR)));

            if (szTextBuff != NULL) {
                *szTextBuff = 0;
                // load TextBuff with strings that should appear in message box
                for (dwMsgNdx = 0; dwMsgNdx < MAX_EXITMSG; dwMsgNdx++) {
                    if (pAppInfo->uExitMessages[dwMsgNdx] > 0) {
                        if (LoadString (
                            (HINSTANCE)GetWindowLongPtr(GetParent(hwndDlg), GWLP_HINSTANCE),
                            pAppInfo->uExitMessages[dwMsgNdx],
                            szStringBuff,
                            MAX_PATH) > 0) {
                            FormatExitMessageString (
                                GetDlgItem (hwndDlg, NCDU_CONTINUE_MESSAGE),
                                szStringBuff, SMALL_BUFFER_SIZE);
                            if ((lstrlen(szStringBuff) + lstrlen(szTextBuff) + 2) > MEDIUM_BUFFER_SIZE) {
                                if(GlobalReAlloc(szTextBuff, (lstrlen(szStringBuff) + lstrlen(szTextBuff) + 2), GPTR) == NULL) {
                                    break;
                                }
                                lstrcat (szTextBuff, szStringBuff);
                                lstrcat (szTextBuff, cszCrLf);
                            }
                        }
                    } else {
                        break;
                    }
                }
                GetClientRect (GetDlgItem (hwndDlg, NCDU_CONTINUE_MESSAGE), &rEditWindow);
                SendDlgItemMessage (hwndDlg, NCDU_CONTINUE_MESSAGE, EM_SETRECT,
                    (WPARAM)0, (LPARAM)&rEditWindow);
                SendDlgItemMessage (hwndDlg, NCDU_CONTINUE_MESSAGE, EM_FMTLINES,
                    (WPARAM)TRUE, 0);
                SetDlgItemText (hwndDlg, NCDU_CONTINUE_MESSAGE, szTextBuff);
                GetDlgItemText (hwndDlg, NCDU_CONTINUE_MESSAGE,
                    szTextBuff, (int)GlobalSize (szTextBuff));
                SetDlgItemText (hwndDlg, NCDU_CONTINUE_MESSAGE, szTextBuff);

                FREE_IF_ALLOC (szTextBuff);
            } else {
                // this is OK because this dialog never "registered"
                EndDialog (hwndDlg, (int)WM_CLOSE);
            }

            SetFocus (GetDlgItem(hwndDlg, IDOK));
            bReturn = FALSE;
        } else {
            // no mesaages to show so end dialog now
            EndDialog (hwndDlg, (int)WM_CLOSE);
            bReturn = TRUE;
        }

        FREE_IF_ALLOC (szStringBuff);

        PostMessage (GetParent(hwndDlg), NCDU_CLEAR_DLG, (WPARAM)hwndDlg, IDOK);
        PostMessage (GetParent(hwndDlg), NCDU_REGISTER_DLG,
            NCDU_EXIT_MESSAGE_DLG, (LPARAM)hwndDlg);
        SetCursor(LoadCursor(NULL, IDC_ARROW));
    } else {
        // this is OK because this dialog never "registered"
        EndDialog (hwndDlg, (int)WM_CLOSE);
        bReturn = TRUE;
    }

    return bReturn;
}

static
BOOL
ExitMessDlg_WM_COMMAND (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Processes the windows message sent when a user presses a button or
        menu item

Arguments:

    IN  HWND    hwndDlg
        Handle to dialog box window

    IN  WPARAM  wParam
        LOPARAM contains the ID of the control that initiated the command
            (i.e. the one that was pushed)

    IN  LPARAM  lParam
            Not used

Return Value:

    TRUE    if the message was processed
    FALSE     if not
--*/
{
    switch (LOWORD(wParam)) {
        case IDCANCEL:
            switch (HIWORD(wParam)) {
                case BN_CLICKED:
                    PostMessage (GetParent (hwndDlg),
                        (int)NCDU_SHOW_SW_CONFIG_DLG, 0, 0);
                    SetCursor(LoadCursor(NULL, IDC_WAIT));
                    return TRUE;

                default:
                    return FALSE;
            }

        case IDOK:
            switch (HIWORD(wParam)) {
                case BN_CLICKED:
                    PostMessage (GetParent (hwndDlg),
                        (int)WM_CLOSE, 0, 0);
                    SetCursor(LoadCursor(NULL, IDC_WAIT));
                    return TRUE;

                default:
                    return FALSE;
            }

        default:
            return FALSE;
    }
}

INT_PTR CALLBACK
ExitMessDlgProc (
    IN  HWND    hwndDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Main Dialog Box Param. Dispatchs to the local processing routine
        on receipt of the following messages.

            WM_INITDIALOG:  Dialog box initialization
            WM_COMMAND:     Sent when user selects a button
            WM_PAINT:       for painting icon when minimized
            WM_MOVE:        for saving the new location of the window
            WM_SYSCOMMAND:  for processing menu messages

        all other messages are passed to the default dialag box
        procedure.

Arguments:

    Standard WNDPROC arguments

Return Value:

    FALSE if not processed otherwise, the value returned by the
        called routine.

--*/
{
    switch (message) {
        case WM_INITDIALOG: return (ExitMessDlg_WM_INITDIALOG (hwndDlg, wParam, lParam));
        case WM_COMMAND:    return (ExitMessDlg_WM_COMMAND (hwndDlg, wParam, lParam));
        case WM_PAINT:      return (Dlg_WM_PAINT (hwndDlg, wParam, lParam));
        case WM_MOVE:       return (Dlg_WM_MOVE (hwndDlg, wParam, lParam));
        case WM_SYSCOMMAND: return (Dlg_WM_SYSCOMMAND (hwndDlg, wParam, lParam));
        default:            return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\clcreator\fmifs.h ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    fmifs.h

Abstract:

    This header file contains the specification of the interface
    between the file manager and fmifs.dll for the purposes of
    accomplishing IFS functions.

Author:

    Norbert P. Kusters (norbertk) 6-Mar-92

--*/

#if !defined( _FMIFS_DEFN_ )

#define _FMIFS_DEFN_

//
// These are the defines for 'PacketType'.
//

typedef enum _FMIFS_PACKET_TYPE {
    FmIfsPercentCompleted,
    FmIfsFormatReport,
    FmIfsInsertDisk,
    FmIfsIncompatibleFileSystem,
    FmIfsFormattingDestination,
    FmIfsIncompatibleMedia,
    FmIfsAccessDenied,
    FmIfsMediaWriteProtected,
    FmIfsCantLock,
    FmIfsCantQuickFormat,
    FmIfsIoError,
    FmIfsFinished,
    FmIfsBadLabel
} FMIFS_PACKET_TYPE, *PFMIFS_PACKET_TYPE;

typedef struct _FMIFS_PERCENT_COMPLETE_INFORMATION {
    DWORD   PercentCompleted;
} FMIFS_PERCENT_COMPLETE_INFORMATION, *PFMIFS_PERCENT_COMPLETE_INFORMATION;

typedef struct _FMIFS_FORMAT_REPORT_INFORMATION {
    DWORD   KiloBytesTotalDiskSpace;
    DWORD   KiloBytesAvailable;
} FMIFS_FORMAT_REPORT_INFORMATION, *PFMIFS_FORMAT_REPORT_INFORMATION;

#define DISK_TYPE_GENERIC           0
#define DISK_TYPE_SOURCE            1
#define DISK_TYPE_TARGET            2
#define DISK_TYPE_SOURCE_AND_TARGET 3

typedef struct _FMIFS_INSERT_DISK_INFORMATION {
    DWORD   DiskType;
} FMIFS_INSERT_DISK_INFORMATION, *PFMIFS_INSERT_DISK_INFORMATION;

typedef struct _FMIFS_IO_ERROR_INFORMATION {
    DWORD   DiskType;
    DWORD   Head;
    DWORD   Track;
} FMIFS_IO_ERROR_INFORMATION, *PFMIFS_IO_ERROR_INFORMATION;

typedef struct _FMIFS_FINISHED_INFORMATION {
    BOOLEAN Success;
} FMIFS_FINISHED_INFORMATION, *PFMIFS_FINISHED_INFORMATION;


//
// This is a list of supported floppy media types for format.
//

typedef enum _FMIFS_MEDIA_TYPE {
    FmMediaUnknown,
    FmMediaF5_160_512,      // 5.25", 160KB,  512 bytes/sector
    FmMediaF5_180_512,      // 5.25", 180KB,  512 bytes/sector
    FmMediaF5_320_512,      // 5.25", 320KB,  512 bytes/sector
    FmMediaF5_320_1024,     // 5.25", 320KB,  1024 bytes/sector
    FmMediaF5_360_512,      // 5.25", 360KB,  512 bytes/sector
    FmMediaF3_720_512,      // 3.5",  720KB,  512 bytes/sector
    FmMediaF5_1Pt2_512,     // 5.25", 1.2MB,  512 bytes/sector
    FmMediaF3_1Pt44_512,    // 3.5",  1.44MB, 512 bytes/sector
    FmMediaF3_2Pt88_512,    // 3.5",  2.88MB, 512 bytes/sector
    FmMediaF3_20Pt8_512,    // 3.5",  20.8MB, 512 bytes/sector
    FmMediaRemovable,       // Removable media other than floppy
    FmMediaFixed
#ifdef JAPAN // JAPAN && i386
    ,
    FmMediaF3_120M_512,      // 3.5", 120M Floppy
    // FMR Sep.8.1994 SFT YAM
    // FMR Jul.14.1994 SFT KMR
    FmMediaF3_640_512,      // 3.5" ,  640KB,  512 bytes/sector
    FmMediaF5_640_512,      // 5.25",  640KB,  512 bytes/sector
    FmMediaF5_720_512,      // 5.25",  720KB,  512 bytes/sector
    // FMR Sep.8.1994 SFT YAM
    // FMR Jul.14.1994 SFT KMR
    FmMediaF3_1Pt2_512,     // 3.5" , 1.2Mb,   512 bytes/sector
    // FMR Sep.8.1994 SFT YAM
    // FMR Jul.14.1994 SFT KMR
    FmMediaF3_1Pt23_1024,   // 3.5" , 1.23Mb, 1024 bytes/sector
    FmMediaF5_1Pt23_1024,   // 5.25", 1.23MB, 1024 bytes/sector
    FmMediaF3_128Mb_512,    // 3.5" , 128MB,  512 bytes/sector  3.5"MO
    FmMediaF3_230Mb_512,    // 3.5" , 230MB,  512 bytes/sector  3.5"MO
    FmMediaEndOfData        // Total data count.
#endif
} FMIFS_MEDIA_TYPE, *PFMIFS_MEDIA_TYPE;


//
// Function types/interfaces.
//

typedef BOOLEAN
(*FMIFS_CALLBACK)(
    IN  FMIFS_PACKET_TYPE   PacketType,
    IN  DWORD               PacketLength,
    IN  PVOID               PacketData
    );

typedef
VOID
(*PFMIFS_FORMAT_ROUTINE)(
    IN  PWSTR               DriveName,
    IN  FMIFS_MEDIA_TYPE    MediaType,
    IN  PWSTR               FileSystemName,
    IN  PWSTR               Label,
    IN  BOOLEAN             Quick,
    IN  FMIFS_CALLBACK      Callback
    );

typedef
VOID
(*PFMIFS_DISKCOPY_ROUTINE)(
    IN  PWSTR           SourceDrive,
    IN  PWSTR           DestDrive,
    IN  BOOLEAN         Verify,
    IN  FMIFS_CALLBACK  Callback
    );

typedef
BOOLEAN
(*PFMIFS_SETLABEL_ROUTINE)(
    IN  PWSTR   DriveName,
    IN  PWSTR   Label
    );

typedef
BOOLEAN
(*PFMIFS_QSUPMEDIA_ROUTINE)(
    IN  PWSTR               DriveName,
    OUT PFMIFS_MEDIA_TYPE   MediaTypeArray  OPTIONAL,
    IN  DWORD               NumberOfArrayEntries,
    OUT PDWORD              NumberOfMediaTypes
    );



VOID
Format(
    IN  PWSTR               DriveName,
    IN  FMIFS_MEDIA_TYPE    MediaType,
    IN  PWSTR               FileSystemName,
    IN  PWSTR               Label,
    IN  BOOLEAN             Quick,
    IN  FMIFS_CALLBACK      Callback
    );

VOID
DiskCopy(
    IN  PWSTR           SourceDrive,
    IN  PWSTR           DestDrive,
    IN  BOOLEAN         Verify,
    IN  FMIFS_CALLBACK  Callback
    );

BOOLEAN
SetLabel(
    IN  PWSTR   DriveName,
    IN  PWSTR   Label
    );

BOOLEAN
QuerySupportedMedia(
    IN  PWSTR               DriveName,
    OUT PFMIFS_MEDIA_TYPE   MediaTypeArray  OPTIONAL,
    IN  DWORD               NumberOfArrayEntries,
    OUT PDWORD              NumberOfMediaTypes
    );

#endif // _FMIFS_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\clcreator\mainwnd.c ===
/*++

    Copyright (c) 1994  Microsoft Corporation

Module Name:

    MAINWND.H

Abstract:

    Main Window Procedure

Author:

    Bob Watson (a-robw)

Revision History:

    17 Feb 94    Written

--*/
//
//  Windows Include Files
//

#include <windows.h>
#include <stdio.h>
#include <malloc.h>
#include <tchar.h>      // unicode macros
//
//  app include files
//
#include "otnboot.h"
#include "otnbtdlg.h"

#ifdef TERMSRV
extern TCHAR szCommandLineVal[MAX_PATH];
extern TCHAR szHelpFileName[MAX_PATH];
#endif // TERMSRV
//
//
#define     HELP_USE_STRING 0   // use context strings, not id #'s for help
//
//
extern POINT    ptWndPos;   // top left corner of window for placement
static  HWND    hwndDisplay = NULL; // dialog to be/being displayed
static  HWND    hwndMain = NULL;    // window handle for Help interface
static  DWORD   dwHelpContextId = 0; //  id to send to help for context sens.
//
typedef struct _DLG_DATA {
    HWND    hWnd;       // handle of parent window
    HINSTANCE   hInst;  // instance containing resources
    LPTSTR  szIdDlg;    // ID of Dialog to start
    DLGPROC ProcName;   // dialog Procedure to call
    LPARAM    lArg;     // optional argument  (0 if not used);
} DLG_DATA, *PDLG_DATA;

BOOL
ShowAppHelp (
    IN  HWND    hwndDlg,
    IN  WORD    wContext
)
/*++

Routine Description:

    Generic routine to call WinHelp engine for displaying application
        help. wContext parameter is used for context.

Arguments:

    IN  HWND    hwndDlg
        window handle of dialog calling function

    IN  WORD    wContext
        help context:
            id of a string resource that is used as help context string

Return Value:

    TRUE if help called successfully

--*/
{
    LPTSTR  szKeyString;
    UINT    nHelpCmd;
    DWORD   dwHelpParam;

    szKeyString = (LPTSTR)GlobalAlloc(GPTR, MAX_PATH_BYTES);

    if (szKeyString == NULL) return FALSE;

#if HELP_USE_STRING
    if (wContext != 0) {
        if (LoadString (
            (HINSTANCE)GetWindowLongPtr(hwndDlg, GWLP_HINSTANCE),
            wContext,
            szKeyString,
            MAX_PATH) > 0) {
            nHelpCmd = HELP_KEY;
            dwHelpParam = (DWORD)szKeyString;
        } else {
            nHelpCmd = HELP_CONTENTS;
            dwHelpParam = 0;
        }
    } else {
        nHelpCmd = HELP_CONTENTS;
        dwHelpParam = 0;
    }
#else
    nHelpCmd = HELP_CONTEXT;
    dwHelpParam = wContext;
#endif

#ifdef TERMSRV
    if( szHelpFileName[0] != _T('\0') ) {
        WinHelp (hwndMain,
            szHelpFileName,
            HELP_FINDER,
            0 );
    }
    else {
#endif // TERMSRV
        WinHelp (hwndMain,
            cszHelpFile,
            nHelpCmd,
            dwHelpParam);
#ifdef TERMSRV
    }
#endif // TERMSRV

    FREE_IF_ALLOC (szKeyString);
    return TRUE;
}

static
LRESULT
MainWnd_UPDATE_WINDOW_POS (
    IN  HWND    hWnd,
    IN  WPARAM  wParam, // x Pos of top left corner
    IN  LPARAM  lParam  // y Pos of top left corner
)
/*++

Routine Description:

    External window message used to register location of a dialog box
        window so the next dialo can be placed in the same spot.
        Dialog box sends this message whenever it's moved and the top
        left corner is stored in a global variable by this message.

Arguments:

    IN  HWND    hWnd,
    IN  WPARAM  wParam, // x Pos of top left corner
    IN  LPARAM  lParam  // y Pos of top left corner
        location coordinates are in SCREEN pixels

Return Value:

    ERROR_SUCCESS

--*/
{
    ptWndPos.x = (LONG)wParam;
    ptWndPos.y = (LONG)lParam;

    return (ERROR_SUCCESS);
}

static
LRESULT
MainWnd_CLEAR_DLG (
    IN  HWND    hWnd,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam  // dlg exit value
)
/*++

Routine Description:

    Called by a dialog box to clear the previous dialog.

Arguments:

    IN  HWND    hWnd
        main window handle
    IN  WPARAM  wParam,
        mot used
    IN  LPARAM  lParam
        dlg box exit value

Return Value:

    ERROR_SUCCESS

--*/
{
    if (hwndDisplay != NULL) {
        EndDialog (hwndDisplay, lParam);
        hwndDisplay = NULL;
    }
    return ERROR_SUCCESS;
}

static
LRESULT
MainWnd_REGISTER_DLG (
    IN  HWND    hWnd,
    IN  WPARAM  wParam, // help context ID
    IN  LPARAM  lParam  // handle to dialog to register
)
/*++

Routine Description:

    external message sent by dialog boxes when they initialize.
        This message and the CLEAR_DLG message above are used to
        overlap dialog boxes to prevent "dead" space between dialogs

Arguments:

    IN  HWND    hWnd
        main window handle
    IN  WPARAM  wParam
        help context ID for dialog
    IN  LPARAM  lParam
        handle to dialog box window to register

Return Value:

    ERROR_SUCCESS

--*/
{
    hwndDisplay = (HWND)lParam;
    dwHelpContextId = (DWORD)wParam;
    UpdateWindow (hwndDisplay);
    return ERROR_SUCCESS;
}

BOOL
RegisterMainWindowClass(
    IN  HINSTANCE   hInstance
)
/*++

Routine Description:

    Exported function called by main routine to register the
        window class used by this module.

Arguments:

    IN  HINSTANCE   hInstance of application

Return Value:

    Boolean Status of RegisterClass function

--*/
{
    WNDCLASS    wc;
    LOGBRUSH    lbBackBrush;

    lbBackBrush.lbStyle = BS_SOLID;
    lbBackBrush.lbColor = RGB(0,0,255);
    lbBackBrush.lbHatch = 0;


    // Fill in window class structure with parameters that describe the
    // main window.

    wc.style         = CS_HREDRAW | CS_VREDRAW;// Class style(s).
    wc.lpfnWndProc   = (WNDPROC)MainWndProc;   // Window Procedure
    wc.cbClsExtra    = 0;                      // No per-class extra data.
    wc.cbWndExtra    = MAINWND_EXTRA_BYTES;    // amount of Window extra data.
    wc.hInstance     = hInstance;              // Owner of this class
    wc.hIcon         = LoadIcon(hInstance, MAKEINTRESOURCE(NCDU_APP_ICON));  // Icon name
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);// Cursor
    wc.hbrBackground = CreateBrushIndirect(&lbBackBrush);// Default back color
    wc.lpszMenuName  = NULL;                   // Menu name from .RC
    wc.lpszClassName = szAppName;              // Name to register as

    // Register the window class and return success/failure code.
    return (BOOL)RegisterClass(&wc);
}

static
LRESULT
MainWnd_WM_NCCREATE(
    IN  HWND    hWnd
)
/*++

Routine Description:

    Processes the WM_NCCREATE message to the main window

Arguments:
    IN  HWND    hWnd

Return Value:
    TRUE if all went OK
    FALSE if not (which will cause the window creation to fail

--*/
{
    hwndMain = hWnd;        // load static data
    return (LRESULT)TRUE;
}

static
LRESULT
MainWnd_WM_CREATE (
    IN  HWND    hWnd
)
/*++

Routine Description:
    Processes the WM_CREATE message to the main window

Arguments:

    IN  HWND handle to main window

Return Value:

    Win32 Status Value:
        ERROR_SUCCESS

--*/
{
    RECT    rDesktop;

    // position window off desktop so it can't be seen
    GetWindowRect (GetDesktopWindow(), &rDesktop);
    SetWindowPos (hWnd,
        NULL,
        rDesktop.right+1,   // locate it off the bottom-rt. corner of screen
        rDesktop.bottom+1,
        1,                  // and make it 1 x 1
        1,
        SWP_NOZORDER);

    // show first dialog box
    PostMessage (hWnd, NCDU_SHOW_SW_CONFIG_DLG, 0, 0);

    // display wait cursor until dialog appears
    SetCursor(LoadCursor(NULL, IDC_WAIT));


    return (LRESULT)ERROR_SUCCESS;
}

static
LRESULT
MainWnd_SHOW_SW_CONFIG_DLG (
    IN  HWND    hWnd
)
/*++

Routine Description:

    Called to display the Initial Configuration dialog box. The value
        returned by the dialog box is the ID of then next message to
        post to the main window.

Arguments:

    IN  HWND    hwnd
        Handle to main window

Return Value:

    ERROR_SUCCESS

--*/
{
#ifdef TERMSRV
    HWND   nNextMessage;

    nNextMessage = CreateDialog (
        (HINSTANCE)GetWindowLongPtr(hWnd, GWLP_HINSTANCE),
        MAKEINTRESOURCE(NCDU_SW_CONFIG_DLG),
        hWnd,
        SwConfigDlgProc);

    if (szCommandLineVal[0] != 0x00)
       ShowWindow(nNextMessage, SW_HIDE);
    else
       ShowWindow(nNextMessage, SW_SHOW);

#else // TERMSRV

    UINT    nNextMessage;

    nNextMessage = (UINT)DialogBox (
        (HINSTANCE)GetWindowLongPtr(hWnd, GWLP_HINSTANCE),
        MAKEINTRESOURCE(NCDU_SW_CONFIG_DLG),
        hWnd,
        SwConfigDlgProc);

#endif // TERMSRV

    return (LRESULT)ERROR_SUCCESS;
}

static
LRESULT
MainWnd_SHOW_TARGET_WS_DLG (
    IN  HWND    hWnd
)
/*++

Routine Description:

    Called to display the Target Workstation Config. dialog box. The value
        returned by the dialog box is the ID of then next message to
        post to the main window.

Arguments:

    IN  HWND    hwnd
        Handle to main window

Return Value:

    ERROR_SUCCESS

--*/
{
    UINT    nNextMessage;

    nNextMessage = (UINT)DialogBox (
        (HINSTANCE)GetWindowLongPtr(hWnd, GWLP_HINSTANCE),
        MAKEINTRESOURCE(NCDU_TARGET_WS_DLG),
        hWnd,
        TargetWsDlgProc);

//    PostMessage (hWnd, nNextMessage, 0, 0); called by dialog box

    return (LRESULT)ERROR_SUCCESS;
}

static
LRESULT
MainWnd_SHOW_SERVER_CFG_DLG (
    IN  HWND    hWnd
)
/*++

Routine Description:

    Called to display the Server Configuration dialog box. The value
        returned by the dialog box is the ID of then next message to
        post to the main window.

Arguments:

    IN  HWND    hwnd
        Handle to main window

Return Value:

    ERROR_SUCCESS

--*/
{
    UINT    nNextMessage;

    nNextMessage = (UINT)DialogBox (
        (HINSTANCE)GetWindowLongPtr(hWnd, GWLP_HINSTANCE),
        MAKEINTRESOURCE(NCDU_SERVER_CFG_DLG),
        hWnd,
        ServerConnDlgProc);

//    PostMessage (hWnd, nNextMessage, 0, 0); called by dialog box

    return (LRESULT)ERROR_SUCCESS;
}

static
LRESULT
MainWnd_SHOW_CONFIRM_DLG (
    IN  HWND    hWnd
)
/*++

Routine Description:

    Called to display the Configuration Confirmation dialog box. The value
        returned by the dialog box is the ID of then next message to
        post to the main window.

Arguments:

    IN  HWND    hwnd
        Handle to main window

Return Value:

    ERROR_SUCCESS

--*/
{
    UINT    nNextMessage;

    nNextMessage = (UINT)DialogBox (
        (HINSTANCE)GetWindowLongPtr(hWnd, GWLP_HINSTANCE),
        MAKEINTRESOURCE(NCDU_CONFIRM_BOOTDISK_DLG),
        hWnd,
        ConfirmSettingsDlgProc);

//    PostMessage (hWnd, nNextMessage, 0, 0);   called by dialog proc

    return (LRESULT)ERROR_SUCCESS;
}

static
LRESULT
MainWnd_SHOW_CREATE_DISKS_DLG (
    IN  HWND    hWnd
)
/*++

Routine Description:

    Called to display the Create Floppy Disk dialog box. The value
        returned by the dialog box is the ID of then next message to
        post to the main window.

Arguments:

    IN  HWND    hwnd
        Handle to main window

Return Value:

    ERROR_SUCCESS

--*/
{
    UINT    nNextMessage;

    nNextMessage = (UINT)DialogBox (
        (HINSTANCE)GetWindowLongPtr(hWnd, GWLP_HINSTANCE),
        MAKEINTRESOURCE(NCDU_CREATE_INSTALL_DISKS_DLG),
        hWnd,
        CopyFlopDlgProc);

//    PostMessage (hWnd, nNextMessage, 0, 0); called by dialog proc

    return (LRESULT)ERROR_SUCCESS;
}

static
LRESULT
MainWnd_SHOW_SHARE_NET_SW_DLG (
    IN  HWND    hWnd
)
/*++

Routine Description:

    Called to display the Copy Dist files and Share dialog box. The value
        returned by the dialog box is the ID of then next message to
        post to the main window.

Arguments:

    IN  HWND    hwnd
        Handle to main window

Return Value:

    ERROR_SUCCESS

--*/
{
#ifdef TERMSRV

    HWND    nNextMessage;

    nNextMessage = CreateDialog (
        (HINSTANCE)GetWindowLongPtr(hWnd, GWLP_HINSTANCE),
        MAKEINTRESOURCE(NCDU_SHARE_NET_SW_DLG),
        hWnd,
        ShareNetSwDlgProc);

    if ( szCommandLineVal[0] != 0x00 )
       ShowWindow(nNextMessage, SW_HIDE);
    else
       ShowWindow(nNextMessage, SW_SHOW);

#else // TERMSRV

    UINT    nNextMessage;

    nNextMessage = (UINT)DialogBox (
        (HINSTANCE)GetWindowLongPtr(hWnd, GWLP_HINSTANCE),
        MAKEINTRESOURCE(NCDU_SHARE_NET_SW_DLG),
        hWnd,
        ShareNetSwDlgProc);

#endif // TERMSRV

    return (LRESULT)ERROR_SUCCESS;
}

static
LRESULT
MainWnd_SHOW_COPYING_DLG (
    IN  HWND    hWnd
)
/*++

Routine Description:

    Called to display the  Making Boot Floppy dialog box. The value
        returned by the dialog box is the ID of then next message to
        post to the main window.

Arguments:

    IN  HWND    hwnd
        Handle to main window

Return Value:

    ERROR_SUCCESS

--*/
{
    if (DialogBox (
        (HINSTANCE)GetWindowLongPtr(hWnd, GWLP_HINSTANCE),
        MAKEINTRESOURCE(NCDU_COPYING_FILES_DLG),
        hWnd,
        MakeFlopDlgProc) == IDOK) {
        // operation completed successfully so return to main menu
        PostMessage (hWnd, NCDU_SHOW_SW_CONFIG_DLG, 0, 0);
    } else {
        // an error ocurred so go back to configuration dialog to see
        // if there's something to fix and retry.
        PostMessage (hWnd, NCDU_SHOW_CONFIRM_DLG, 0, 0);
    }

    return (LRESULT)ERROR_SUCCESS;
}

static
LRESULT
MainWnd_SHOW_EXIT_MESSAGE_DLG (
    IN  HWND    hWnd
)
/*++

Routine Description:

    Called to display the Exit Messages dialog box. The value
        returned by the dialog box is the ID of then next message to
        post to the main window.

Arguments:

    IN  HWND    hwnd
        Handle to main window

Return Value:

    ERROR_SUCCESS

--*/
{
    UINT    nNextMessage;

    nNextMessage = (UINT)DialogBox (
        (HINSTANCE)GetWindowLongPtr(hWnd, GWLP_HINSTANCE),
        MAKEINTRESOURCE(NCDU_EXIT_MESSAGE_DLG),
        hWnd,
        ExitMessDlgProc);

    PostMessage (hWnd, nNextMessage, 0, 0);

    return (LRESULT)ERROR_SUCCESS;
}

static
LRESULT
MainWnd_SHOW_COPY_ADMIN_UTILS (
    IN  HWND    hWnd
)
{
    int nNextMessage;

    nNextMessage = (int)DialogBox (
        (HINSTANCE)GetWindowLongPtr(hWnd, GWLP_HINSTANCE),
        MAKEINTRESOURCE(NCDU_COPY_NET_UTILS_DLG),
        hWnd,
        CopyNetUtilsDlgProc);


//    PostMessage (hWnd, nNextMessage, 0, 0);

    return (LRESULT)ERROR_SUCCESS;
}

static
LRESULT
MainWnd_WM_ACTIVATEAPP (
    IN  HWND    hWnd,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    enables and disables the F1 hot key to be active only
        when the app is active (i.e. has focus)


Arguments:

    IN  HWND    hWnd
        window handle

    IN  WPARAM  wParam
        TRUE when app is being activated
        FALSE when app is being deactivated

    IN  LPARAM  lParam
        Thread getting focus (if wParam = FALSE)

Return Value:

    ERROR_SUCCESS

--*/
{
    if ((BOOL)wParam) {
        // getting focus so enable hot key
        RegisterHotKey (
            hWnd,
            NCDU_HELP_HOT_KEY,
            0,
            VK_F1);
    } else {
        UnregisterHotKey (
            hWnd,
            NCDU_HELP_HOT_KEY);
    }
    return ERROR_SUCCESS;
}

static
LRESULT
MainWnd_WM_HOTKEY (
    IN  HWND    hWnd,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    processes hot key messages to call help when f1 is pressed

Arguments:

    IN  HWND    hWnd
        window handle

    IN  WPARAM  wParam
        id of hotkey pressed

    IN  LPARAM  lParam
        Not Used

Return Value:

    ERROR_SUCCESS

--*/
{
    switch ((int)wParam) {
        case NCDU_HELP_HOT_KEY:
            ShowAppHelp (
                hWnd,
                (WORD)(dwHelpContextId & 0x0000FFFF));
            return ERROR_SUCCESS;

        default:
            return DefWindowProc (hWnd, WM_HOTKEY, wParam, lParam);
    }
}

static
LRESULT
MainWnd_WM_CLOSE (
    IN  HWND    hWnd
)
/*++

Routine Description:

    Processes the WM_CLOSE message to the main window. Closes the key
        to the registry if it's open and destroys the window.

Arguments:

    IN HWND hWnd
        handle to the main window


Return Value:

    ERROR_SUCCESS

--*/
{
    SetCursor(LoadCursor(NULL, IDC_ARROW)); // reset cursor
    if (pAppInfo->hkeyMachine != NULL) RegCloseKey (pAppInfo->hkeyMachine);
    SendMessage (hWnd, NCDU_CLEAR_DLG, (WPARAM)hWnd, IDOK);
    DestroyWindow (hWnd);
    return (LRESULT)ERROR_SUCCESS;
}

static
LRESULT
MainWnd_WM_DESTROY (
    IN  HWND    hWnd
)
/*++

Routine Description:
    Processes WM_DESTROY windows message;
        Posts Quit message to app.

Arguments:
    IN  HWND    hWnd
        Handle to main window


Return Value:

    Always 0

--*/
{
#ifdef TERMSRV
    if( szHelpFileName[0] != _T('\0') ) {
        WinHelp (hWnd, szHelpFileName, HELP_QUIT, 0L);
    }
    else {
#endif // TERMSRV
        WinHelp (hWnd, cszHelpFile, HELP_QUIT, 0L);
#ifdef TERMSRV
    }
#endif // TERMSRV

    PostQuitMessage (ERROR_SUCCESS);
    return (LRESULT)ERROR_SUCCESS;
}

static
LRESULT
MainWnd_WM_NCDESTROY (
    HWND    hWnd
)
/*++

Routine Description:
    Processes WM_NCDESTROY windows message
        free's global memory

Arguments:
    IN  HWND    hWnd
        Handle to window being destroyed

Return Value:


    always ERROR_SUCCESS

--*/
{
    return (LRESULT)ERROR_SUCCESS;
}

LRESULT CALLBACK
MainWndProc (
    IN  HWND hWnd,         // window handle
    IN  UINT message,      // type of message
    IN  WPARAM uParam,     // additional information
    IN  LPARAM lParam      // additional information
)
/*++

Routine Description:

    Windows Message processing routine for CPS Util application.
        Dispatches messages that are processed by this app and
        all others are passed to DefWindowProc

Arguments:

    Standard WNDPROC api arguments

ReturnValue:

    value returned by dispatched function

--*/
{
    switch (message) {
        case WM_NCCREATE:   return (MainWnd_WM_NCCREATE(hWnd));
        case WM_CREATE:     return (MainWnd_WM_CREATE(hWnd));
        case WM_ACTIVATEAPP:    return (MainWnd_WM_ACTIVATEAPP(hWnd, uParam, lParam));
        case WM_HOTKEY:     return (MainWnd_WM_HOTKEY(hWnd, uParam, lParam));

        case NCDU_SHOW_SW_CONFIG_DLG:   return (MainWnd_SHOW_SW_CONFIG_DLG (hWnd));
        case NCDU_SHOW_TARGET_WS_DLG:   return (MainWnd_SHOW_TARGET_WS_DLG (hWnd));
        case NCDU_SHOW_SERVER_CFG_DLG:  return (MainWnd_SHOW_SERVER_CFG_DLG (hWnd));
        case NCDU_SHOW_CONFIRM_DLG:     return (MainWnd_SHOW_CONFIRM_DLG (hWnd));
        case NCDU_SHOW_CREATE_DISKS_DLG: return (MainWnd_SHOW_CREATE_DISKS_DLG (hWnd));
        case NCDU_SHOW_SHARE_NET_SW_DLG: return (MainWnd_SHOW_SHARE_NET_SW_DLG (hWnd));
        case NCDU_SHOW_COPYING_DLG:     return (MainWnd_SHOW_COPYING_DLG (hWnd));
        case NCDU_SHOW_EXIT_MESSAGE_DLG: return (MainWnd_SHOW_EXIT_MESSAGE_DLG (hWnd));
        case NCDU_SHOW_COPY_ADMIN_UTILS: return (MainWnd_SHOW_COPY_ADMIN_UTILS (hWnd));
        case NCDU_CLEAR_DLG:            return (MainWnd_CLEAR_DLG (hWnd, uParam, lParam));
        case NCDU_REGISTER_DLG:         return (MainWnd_REGISTER_DLG (hWnd, uParam, lParam));
        case NCDU_UPDATE_WINDOW_POS:    return (MainWnd_UPDATE_WINDOW_POS (hWnd, uParam, lParam));

        case WM_CLOSE:      return (MainWnd_WM_CLOSE(hWnd));
        case WM_DESTROY:    return (MainWnd_WM_DESTROY(hWnd));
        case WM_NCDESTROY:  return (MainWnd_WM_NCDESTROY(hWnd));
        default:            return (DefWindowProc(hWnd, message, uParam, lParam));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\clcreator\fmt_disk.c ===
/*++

Routine Description:

    contains functions to format a floppy disk

Arguments:



Return Value:



--*/
#include <windows.h>    // required for all Windows applications
#include <tchar.h>      // unicode definitions

#include "otnboot.h"    // application definitions
#include "otnbtdlg.h"   // dialog box constants
#include "fmifs.h"      // file manager IFS DLL functions

#ifdef JAPAN
// fixed kkntbug #11940
//    Network client administrator can not make install disks on PC with C drive as FD

#define OEM_ID_PC98  0X0D00

//
//  Japanese specific floppy format styles
//
#define F3_12               1   // 3.5" drive that supports 1.2M-byte format
#define F3_123              2   // 3.5" drive that supports 1.23M-byte format
#define F5_123              4   // 5.25" drive that supports 1.23M-byte format
#endif

//
//  local windows messages
//
#define FS_CANCELUPDATE         (WM_USER+104)

//
//  Disk format information structure
//
#define FF_ONLYONE          0x1000
#define FF_RETRY            0x4000

typedef struct _CANCEL_INFO {
   HWND hCancelDlg;
   BOOL bCancel;
   HANDLE hThread;
   BOOL fmifsSuccess;
   UINT dReason;
   UINT fuStyle;                      // Message box style
   INT  nPercentDrawn;                // percent drawn so FAR
   enum _CANCEL_TYPE {
      CANCEL_NULL=0,
      CANCEL_FORMAT,
      CANCEL_COPY,
      CANCEL_BACKUP,
      CANCEL_RESTORE,
      CANCEL_COMPRESS,
      CANCEL_UNCOMPRESS
   } eCancelType;
   BOOL bModal;
   struct _INFO {
      struct _FORMAT {
         INT iFormatDrive;
         FMIFS_MEDIA_TYPE fmMediaType;
         BOOL fQuick;
         DWORD fFlags;                 // FF_ONLYONE = 0x1000
         TCHAR szLabel[MAXLABELLEN+1];
      } Format;
      struct _COPY {
         INT iSourceDrive;
         INT iDestDrive;
         BOOL bFormatDest;
      } Copy;
   } Info;
} CANCEL_INFO, *PCANCEL_INFO;

static HANDLE   hfmifsDll   = NULL;                     // dll w/ file system utils
static TCHAR    szFmifsDll[] = {TEXT("fmifs.dll")};     // dll for FAT file system
static TCHAR SZ_PERCENTFORMAT[] = {TEXT("%3d%%")};
//
//  pointers to DLL functions;
//
static PFMIFS_FORMAT_ROUTINE       lpfnFormat = NULL;
static PFMIFS_DISKCOPY_ROUTINE     lpfnDiskCopy = NULL;
static PFMIFS_SETLABEL_ROUTINE     lpfnSetLabel = NULL;
static PFMIFS_QSUPMEDIA_ROUTINE    lpfnQuerySupportedMedia = NULL;
//
//      Format dialog box information
//
static CANCEL_INFO  CancelInfo;
static BOOL         bDataInitialized = FALSE;

ULONG   ulSpaceAvail    = 0;
ULONG   ulTotalSpace    = 0;

static
LONG
GetFloppyDiskSize (
    IN  TCHAR   cDrive
)
/*++

Routine Description:

    Examines the specified floppy drive to determine if it
        supports 1.2M or 1.44M formats.

Arguments:

    IN  TCHAR   cDrive
        drive letter of floppy drive to examine

Return Value:

    0   if unable to read drive or drive does not support a HD format
    3   if the drive is a 3.5" drive that supports 1.44M-byte format
    5   if the drive is a 5.25" drive that supports the 1.2M-byte format
//  Japanese specific floppy format styles
    F3_12  if the drive is a 3.5" drive that supports 1.2M-byte format
    F3_123 if the drive is a 3.5" drive that supports 1.23M-byte format
    F5_123 if the drive is a 5.25" drive that supports 1.23M-byte format

--*/
{
#define     DG_ELEMS    16      // accomodate up to 16 different formats
    TCHAR   szDrivePath[8];     // local drive spec. string
    HANDLE  hDrive;             // handle to drive device driver
    DWORD   dwError;            // local error code
    DWORD   dwBytesReturned;    // size of buffer returned
    LONG    lSize;              // disk size returned to calling fn.
    DWORD   dwCount;            // number of DISK_GEOMETRY structures in buffer
    DWORD   dwEntry;            // structure being evaluated
    DISK_GEOMETRY   dgArray[DG_ELEMS];  // buffer to put data in

#ifndef JAPAN
// fixed kkntbug #11940
//    Network client administrator can not make install disks on PC with C drive as FD

    // check input argument
    switch (cDrive){
        case TEXT('A'):
        case TEXT('a'):
        case TEXT('B'):
        case TEXT('b'):
            break;

        default:
            SetLastError (ERROR_INVALID_PARAMETER);
            return 0;
    }
#endif

    // make NT device path for drive
    szDrivePath[0] = cBackslash;
    szDrivePath[1] = cBackslash;
    szDrivePath[2] = cPeriod;
    szDrivePath[3] = cBackslash;
    szDrivePath[4] = cDrive;
    szDrivePath[5] = cColon;
    szDrivePath[6] = 0;
    szDrivePath[7] = 0;

    // open drive
    hDrive = CreateFile (
        szDrivePath,            // drive to open
        0,                      // just talk to the driver, not the drive
        FILE_SHARE_READ | FILE_SHARE_WRITE, // allow sharing
        NULL,                   // default security
        OPEN_EXISTING,          // open existing device
        FILE_ATTRIBUTE_NORMAL,  // this is ignored
        NULL);                  // no template

    if (hDrive == INVALID_HANDLE_VALUE) {
        // unable to open drive so return error
        dwError = GetLastError ();
        return 0;
    }

    // get device information
    if (DeviceIoControl (hDrive,
        IOCTL_DISK_GET_MEDIA_TYPES,
        NULL, 0,                                    // no input buffer
        &dgArray[0], sizeof(DISK_GEOMETRY)*DG_ELEMS,// output buffer info
        &dwBytesReturned, NULL)) {                  // return information
        // see if at least one entry was returned
        if (dwBytesReturned >= sizeof(DISK_GEOMETRY)) {
            dwCount = dwBytesReturned / sizeof(DISK_GEOMETRY);
            // go through array to see if there's a desired entry
            // i.e. a HD format in the list of supported formats
            for (lSize = 0, dwEntry = 0;
                (dwEntry < dwCount) && (lSize == 0);
                dwEntry++) {
                switch (dgArray[dwEntry].MediaType) {
                    // only return a size if a supported
                    // format is allowed by this drive
                    case F5_1Pt2_512:
                        lSize = 5;
                        break;

                    case F3_1Pt44_512:
                        lSize = 3;
                        break;
#ifdef JAPAN
// fixed kkntbug #11940
//    Network client administrator can not make install disks on PC with C drive as FD
                    case F5_1Pt23_1024:
                        lSize = F5_123;
                        break;

                    case F3_1Pt2_512:
                        lSize = F3_12;
                        break;

                    case F3_1Pt23_1024:
                        lSize = F3_123;
                        break;
#endif

                    case F5_360_512:
                    case F5_320_512:
                    case F5_320_1024:
                    case F5_180_512:
                    case F5_160_512:
                    case F3_2Pt88_512:
                    case F3_20Pt8_512:
                    case F3_720_512:
                    default:
                        lSize = 0;
                        break;
                }
            }
        } else {
            // no data returned so return error
            dwError = GetLastError ();
            SetLastError (ERROR_NO_DATA);
            lSize = 0;
        }
    } else {
        // unable to read device driver info
        dwError = GetLastError ();
        lSize = 0;
    }
    // close handle and return data found.
    CloseHandle (hDrive);

    return lSize;
}

static
BOOL
DriveLoaded (
    IN  TCHAR   cDrive,
    IN  BOOL    bCheckFormat
)
/*++

Routine Description:

    formats call to MediaPresent function for use with just a drive letter

Arguments:

    IN  TCHAR   cDrive
        drive letter to detect.

Return Value:

    TRUE if a disk (formatted or unformatted) is detected.
    FALSE if disk is not present in drive

--*/
{
    TCHAR szPath[4];
    szPath[0] = cDrive;
    szPath[1] = cColon;
    szPath[2] = cBackslash;
    szPath[3] = 0;

    return MediaPresent (szPath, bCheckFormat);
}

static
VOID
CancelDlgQuit(
    VOID
)
/////////////////////////////////////////////////////////////////////
//
// Name:     CancelDlgQuit
//
// Synopsis: Quits the cancel modeless dialog (status for diskcopy/format)
//
// IN: VOID
//
// Return:   VOID
//
// Assumes:  Called from worker thread only; CancelInfo.hThread valid
//
// Effects:  Kills calling thread
//
//
// Notes:
//
/////////////////////////////////////////////////////////////////////
{
   //
   // Close thread if successful
   //

   if (CancelInfo.hThread) {
      CloseHandle(CancelInfo.hThread);
      CancelInfo.hThread = NULL;
   }

   //
   // At this point, when we call FS_CANCELEND,
   // the other thread thinks that this one has died since
   // CancelInfo.hThread is NULL.
   // This is exactly what we want, since we will very shortly
   // exit after the SendMessage.
   //
   EndDialog (CancelInfo.hCancelDlg, IDOK);

   ExitThread(0L);
}

static
BOOL
Callback_Function(
    IN  FMIFS_PACKET_TYPE   PacketType,
    IN  DWORD PacketLength,
    IN  PVOID PacketData
)
/*++

Routine Description:

    Callback function used by IFS dll (stolen from Winfile code)

Arguments:



Return Value:



--*/
{
    TCHAR   szTemp[128];

       // Quit if told to do so..

    if (CancelInfo.bCancel)
        return FALSE;

    switch (PacketType) {
        case FmIfsPercentCompleted:
            //
            // If we are copying and we just finished a destination format,
            // then set the window text back to the original message
            //
            if (CANCEL_COPY == CancelInfo.eCancelType &&
                CancelInfo.Info.Copy.bFormatDest) {

                CancelInfo.Info.Copy.bFormatDest = FALSE;
                lstrcpy (szTemp,
                    GetStringResource (CancelInfo.Info.Copy.bFormatDest ?
                        IDS_FORMATTINGDEST : IDS_COPYINGDISKTITLE));

                SetWindowText(CancelInfo.hCancelDlg, szTemp);
            }
            CancelInfo.nPercentDrawn = ((PFMIFS_PERCENT_COMPLETE_INFORMATION)PacketData)->PercentCompleted;
            PostMessage(CancelInfo.hCancelDlg, FS_CANCELUPDATE, ((PFMIFS_PERCENT_COMPLETE_INFORMATION)PacketData)->PercentCompleted, 0L);

            break;

        case FmIfsFormatReport:
            ulTotalSpace = ((PFMIFS_FORMAT_REPORT_INFORMATION)PacketData)->KiloBytesTotalDiskSpace * 1024L;
            ulSpaceAvail = ((PFMIFS_FORMAT_REPORT_INFORMATION)PacketData)->KiloBytesAvailable * 1024L;
            break;

        case FmIfsInsertDisk:
            switch(((PFMIFS_INSERT_DISK_INFORMATION)PacketData)->DiskType) {
                case DISK_TYPE_GENERIC:
                    CancelInfo.fuStyle = MB_OK_TASK_INFO;
                    return DisplayMessageBox(CancelInfo.hCancelDlg,
                        IDS_INSERTSRC, IDS_COPYDISK, CancelInfo.fuStyle);

                case DISK_TYPE_SOURCE:
                    CancelInfo.fuStyle = MB_OK_TASK_INFO;
                    return DisplayMessageBox(CancelInfo.hCancelDlg,
                        IDS_INSERTSRC, IDS_COPYDISK, CancelInfo.fuStyle);

                case DISK_TYPE_TARGET:
                    CancelInfo.fuStyle = MB_OK_TASK_INFO;
                    return DisplayMessageBox(CancelInfo.hCancelDlg,
                        IDS_INSERTDEST, IDS_COPYDISK, CancelInfo.fuStyle);

                case DISK_TYPE_SOURCE_AND_TARGET:
                    CancelInfo.fuStyle = MB_OK_TASK_INFO;
                    return DisplayMessageBox(CancelInfo.hCancelDlg,
                        IDS_INSERTSRCDEST, IDS_COPYDISK, CancelInfo.fuStyle);
            }
            break;

        case FmIfsIncompatibleFileSystem:
            CancelInfo.dReason = IDS_FFERR_INCFS;
            break;

        case FmIfsFormattingDestination:
            CancelInfo.Info.Copy.bFormatDest = TRUE;
            lstrcpy (szTemp, GetStringResource (
                (CancelInfo.Info.Copy.bFormatDest ?
                    IDS_FORMATTINGDEST : IDS_COPYINGDISKTITLE)));
            SetWindowText(CancelInfo.hCancelDlg, szTemp);
            CancelInfo.nPercentDrawn = ((PFMIFS_PERCENT_COMPLETE_INFORMATION)PacketData)->PercentCompleted;
            PostMessage(CancelInfo.hCancelDlg, FS_CANCELUPDATE, ((PFMIFS_PERCENT_COMPLETE_INFORMATION)PacketData)->PercentCompleted, 0L);
            break;

        case FmIfsIncompatibleMedia:
            CancelInfo.fuStyle = MB_ICONHAND | MB_OK;
            return DisplayMessageBox(CancelInfo.hCancelDlg,
                IDS_COPYSRCDESTINCOMPAT, IDS_COPYDISK, CancelInfo.fuStyle);

        case FmIfsAccessDenied:
            CancelInfo.dReason = IDS_FFERR_ACCESSDENIED;
            break;

        case FmIfsMediaWriteProtected:
            CancelInfo.dReason = IDS_FFERR_DISKWP;
            break;

        case FmIfsCantLock:
            CancelInfo.dReason = IDS_FFERR_CANTLOCK;
            break;

        case FmIfsBadLabel:
            CancelInfo.fuStyle = MB_OK_TASK_EXCL;
            return DisplayMessageBox(CancelInfo.hCancelDlg,
                IDS_FFERR_BADLABEL, IDS_COPYERROR + FUNC_LABEL, CancelInfo.fuStyle);

        case FmIfsCantQuickFormat:
            // Can't quick format, ask if user wants to regular format:
            CancelInfo.fuStyle = MB_ICONEXCLAMATION | MB_YESNO;

            if (IDYES == DisplayMessageBox(
                CancelInfo.hCancelDlg,
                IDS_FORMATQUICKFAILURE,
                IDS_FORMATERR,
                CancelInfo.fuStyle)) {

                CancelInfo.Info.Format.fQuick = FALSE;
                CancelInfo.Info.Format.fFlags |= FF_RETRY;

            } else {

                //
                // Just fake a cancel
                //
                CancelInfo.fmifsSuccess = FALSE;
                CancelInfo.bCancel = TRUE;
            }

            break;

        case FmIfsIoError:
            switch(((PFMIFS_IO_ERROR_INFORMATION)PacketData)->DiskType) {
                case DISK_TYPE_GENERIC:
                    CancelInfo.dReason = IDS_FFERR_GENIOERR;
                    break;

                case DISK_TYPE_SOURCE:
                    CancelInfo.dReason = IDS_FFERR_SRCIOERR;
                    break;

                case DISK_TYPE_TARGET:
                    CancelInfo.dReason = IDS_FFERR_DSTIOERR;
                    break;

                case DISK_TYPE_SOURCE_AND_TARGET:
                    CancelInfo.dReason = IDS_FFERR_SRCDSTIOERR;
                    break;
            }
            break;

        case FmIfsFinished:
            CancelInfo.fmifsSuccess = ((PFMIFS_FINISHED_INFORMATION)PacketData)->Success;
            break;

        default:
            break;
    }
    return TRUE;
}

static
VOID
FormatDrive(
    IN PVOID ThreadParameter
)
/*++

Routine Description:

    Thread routine to format the floppy diskette as described in the
        CancelInfo data structure.

Arguments:

    Not used

Return Value:

    None

--*/
{
   WCHAR wszDrive[3];
   WCHAR wszFileSystem[4] = L"FAT";

   wszDrive[0] = (WCHAR)(CancelInfo.Info.Format.iFormatDrive + cA);
   wszDrive[1] = cColon;
   wszDrive[2] = 0;

#define wszLabel CancelInfo.Info.Format.szLabel

   do {
      CancelInfo.Info.Format.fFlags &= ~FF_RETRY;

      (*lpfnFormat)(wszDrive,
         CancelInfo.Info.Format.fmMediaType,
         wszFileSystem,
         wszLabel,
         (BOOLEAN)CancelInfo.Info.Format.fQuick,
         (FMIFS_CALLBACK)&Callback_Function);
   } while (CancelInfo.Info.Format.fFlags & FF_RETRY);

   CancelDlgQuit();
}

static
FMIFS_MEDIA_TYPE
GetDriveTypeFromDriveLetter (
    IN  TCHAR   cDrive
)
/*++

Routine Description:

    returns the drive type of the drive specified in the path argument

Arguments:

    IN  LPCTSTR szPath
        path on drive to examine

Return Value:

    MEDIA_TYPE value identifying drive type in format compatible with
        IFS DLL

--*/
{
    HANDLE  hFloppy;
    DWORD   dwRetSize;
    DISK_GEOMETRY   dgFloppy;
    TCHAR   szDevicePath[16];
    UINT    nDriveType;
    UINT    nErrorMode;

    // make device name from drive letter

    szDevicePath[0] = cBackslash;
    szDevicePath[1] = cBackslash;
    szDevicePath[2] = cPeriod;
    szDevicePath[3] = cBackslash;
    szDevicePath[4] = cDrive;
    szDevicePath[5] = cColon; // colon
    szDevicePath[6] = cBackslash;    // null terminator
    szDevicePath[7] = 0;    // null terminator

    nDriveType = GetDriveType((LPTSTR)&szDevicePath[4]);
    // see if this is a remote disk and exit if it is.
    if (nDriveType == DRIVE_REMOTE) return FmMediaUnknown;

    if ((nDriveType == DRIVE_REMOVABLE) || (nDriveType == DRIVE_CDROM)) {
        // make device path into an NT device path
        szDevicePath[6] = 0;    // null terminator

        // disable windows error message popup
        nErrorMode = SetErrorMode  (SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

        // open device to get type
        hFloppy = CreateFile (
            szDevicePath,
            GENERIC_READ,
            (FILE_SHARE_READ | FILE_SHARE_WRITE),
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

        if (hFloppy != INVALID_HANDLE_VALUE) {
            // get drive information
            if (!DeviceIoControl (hFloppy,
                IOCTL_DISK_GET_DRIVE_GEOMETRY,
                NULL, 0,
                &dgFloppy,
                sizeof(DISK_GEOMETRY),
                &dwRetSize,
                NULL) ){
                // unable to get data so set to unknown
                dgFloppy.MediaType = Unknown;
            } // else return data from returned structure
            CloseHandle (hFloppy);
        } else {
            // unable to open handle to device
            dgFloppy.MediaType = Unknown;
        }
        SetErrorMode (nErrorMode); // reset error mode
    }
    // translate from MEDIA_TYPE to FMIFS_MEDIA_TYPE here

    switch (dgFloppy.MediaType) {
#ifdef  JAPAN
// fixed kkntbug #11940
//    Network client administrator can not make install disks on PC with C drive as FD

        case (F3_1Pt2_512):     return FmMediaF3_1Pt2_512;
        case (F3_1Pt23_1024):   return FmMediaF3_1Pt23_1024;
        case (F5_1Pt23_1024):   return FmMediaF5_1Pt23_1024;
#endif
        case (F5_1Pt2_512):     return FmMediaF5_1Pt2_512;
        case (F3_1Pt44_512):    return FmMediaF3_1Pt44_512;
        case (F3_2Pt88_512):    return FmMediaF3_2Pt88_512;
        case (F3_20Pt8_512):    return FmMediaF3_20Pt8_512;
        case (F3_720_512):      return FmMediaF3_720_512;
        case (F5_360_512):      return FmMediaF5_360_512;
        case (F5_320_512):      return FmMediaF5_320_512;
        case (F5_320_1024):     return FmMediaF5_320_1024;
        case (F5_180_512):      return FmMediaF5_180_512;
        case (F5_160_512):      return FmMediaF5_160_512;
        case (FixedMedia):      return FmMediaFixed;
        case (Unknown):         return FmMediaUnknown;
        default:                return FmMediaUnknown;
    }
}

static
BOOL
FmifsLoaded(
    IN  HWND    hWnd
)
/*++

Routine Description:

    loads (if not already loaded) the File Manager IFS dll and initializes
        the pointers to it's functions

Arguments:

    IN  HWND    hWnd
        window handle of parent, used for MessageBox calls

Return Value:

    TRUE if file loaded
    FALSE if not

--*/
{
   // Load the fmifs dll.

   if (hfmifsDll < (HANDLE)32) {
      hfmifsDll = LoadLibrary(szFmifsDll);
      if (hfmifsDll < (HANDLE)32) {
         /* FMIFS not available. */
         DisplayMessageBox(hWnd,
            IDS_APP_NAME,
            IDS_FMIFSLOADERR,
            MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
         hfmifsDll = NULL;
         return FALSE;
      }
      else {
         lpfnFormat = (PVOID)GetProcAddress(hfmifsDll, "Format");
         lpfnQuerySupportedMedia = (PVOID)GetProcAddress(hfmifsDll, "QuerySupportedMedia");
         lpfnSetLabel = (PVOID)GetProcAddress(hfmifsDll, "SetLabel");
         lpfnDiskCopy = (PVOID)GetProcAddress(hfmifsDll, "DiskCopy");
         if (!lpfnFormat || !lpfnQuerySupportedMedia ||
            !lpfnSetLabel || !lpfnDiskCopy) {
            DisplayMessageBox(hWnd,
                IDS_APP_NAME,
                IDS_FMIFSLOADERR,
                MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
            FreeLibrary(hfmifsDll);
            hfmifsDll = NULL;
            return FALSE;
         }
      }
   }
   return TRUE;
}

static
VOID
DestroyCancelWindow(
    VOID
)
/*++

Routine Description:

    Destroys the CANCEL (i.e. Format) window.

Arguments:

    None

Return Value:

    None

--*/
{
   if (!CancelInfo.hCancelDlg)
      return;

   if (CancelInfo.bModal) {
      EndDialog(CancelInfo.hCancelDlg,0);
   } else {
      DestroyWindow(CancelInfo.hCancelDlg);
   }
   CancelInfo.hCancelDlg = NULL;
}

static
INT_PTR
CancelDlgProc(HWND hDlg,
   IN   UINT    message,
   IN   WPARAM  wParam,
   IN   LPARAM  lParam
)
/*-------------------------  CancelDlgProc
 *
 *  DESCRIPTION:
 *    dialog procedure for the modeless dialog. two main purposes
 *    here:
 *
 *      1. if the user chooses CANCEL we set bCancel to TRUE
 *         which will end the PeekMessage background processing loop
 *
 *      2. handle the private FS_CANCELUPDATE message and draw
 *         a "gas gauge" indication of how FAR the background job
 *         has progressed
 *
 *  ARGUMENTS:
 *      stock dialog proc arguments
 *
 *  RETURN VALUE:
 *      stock dialog proc return value - BOOL
 *
 *  GLOBALS READ:
 *      none
 *
 *  GLOBALS WRITTEN:
 *      CancelInfo structure
 *
 *  MESSAGES:
 *      WM_COMMAND      - handle IDCANCEL by setting bCancel to TRUE
 *                        and calling DestroyWindow to end the dialog
 *
 *      WM_INITDIALOG   - set control text, get coordinates of gas gauge,
 *                        disable main window so we look modal
 *
 *      WM_PAINT        - draw the "gas gauge" control
 *
 *      FS_CANCELUPDATE - the percentage done has changed, so update
 *                        nPercentDrawn and force a repaint
 *
 *  NOTES:
 *
 *    The bCancel global variable is used to communicate
 *    with the main window. If the user chooses to cancel
 *    we set bCancel to TRUE.
 *
 *    When we get the private message FS_CANCELUPDATE
 *    we update the "gas gauge" control that indicates
 *    what percentage of the rectangles have been drawn
 *    so FAR. This shows that we can draw in the dialog
 *    as the looping operation progresses.  (FS_CANCELUPDATE is sent
 *    first to hwndFrame, which sets %completed then sends message to us.)
 *
 */
{
   static RECT rectGG;              // GasGauge rectangle
   DWORD Ignore;
   TCHAR szTemp[128];
   static BOOL bLastQuick;

   static HFONT hFont = NULL;

   switch (message) {
        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDCANCEL:
                    DestroyCancelWindow();
                    if (hFont != NULL) {
                        DeleteObject(hFont);
                        hFont = NULL;
                    }
                    CancelInfo.bCancel = TRUE;
                    return TRUE;

                default:
                    return FALSE;
            }

        case WM_INITDIALOG:
            {
                CancelInfo.hCancelDlg = hDlg;
                bLastQuick = TRUE;

                switch(CancelInfo.eCancelType) {
                    case CANCEL_FORMAT:

                        //
                        // Formatting disk requires that we release any notification
                        // requests on this drive.
                        //
//                      NotifyPause(CancelInfo.Info.Format.iFormatDrive, DRIVE_REMOVABLE);

                        break;
                    case CANCEL_COPY:

                        //
                        // Pause notifications on dest drive.
                        //
//                      NotifyPause(CancelInfo.Info.Copy.iDestDrive, DRIVE_REMOVABLE);
                        lstrcpy (szTemp, GetStringResource(
                            CancelInfo.Info.Copy.bFormatDest ?
                                IDS_FORMATTINGDEST : IDS_COPYINGDISKTITLE));
                        SetWindowText(hDlg, szTemp);

                        break;
                    default:
                        break;
                }

                if (!CancelInfo.hThread) {
                    switch (CancelInfo.eCancelType) {
                        case CANCEL_FORMAT:
                            CancelInfo.hThread = CreateThread( NULL,      // Security
                                0L,                                        // Stack Size
                                (LPTHREAD_START_ROUTINE)FormatDrive,
                                NULL,
                                0L,
                                &Ignore );
                            break;

                        default:
                            break;
                    }
                }

                // a-jagram: bug fix 305171

                // Create the font
                if (hFont == NULL) { // it should be
                    LOGFONT lf;
                    HGDIOBJ hGObj;

                    hGObj = GetStockObject(SYSTEM_FONT);

                    if( hGObj != NULL ) {
                        if (GetObject(hGObj, sizeof(lf), (LPVOID) &lf)) {
                            lstrcpy(lf.lfFaceName, TEXT("MS Shell Dlg"));
                            hFont = CreateFontIndirect(&lf);
                        }
                    }
                }

                // Get the coordinates of the gas gauge static control rectangle,
                // and convert them to dialog client area coordinates
                GetClientRect(GetDlgItem(hDlg, IDD_GASGAUGE), &rectGG);
                ClientToScreen(GetDlgItem(hDlg, IDD_GASGAUGE), (LPPOINT)&rectGG.left);
                ClientToScreen(GetDlgItem(hDlg, IDD_GASGAUGE), (LPPOINT)&rectGG.right);
                ScreenToClient(hDlg, (LPPOINT)&rectGG.left);
                ScreenToClient(hDlg, (LPPOINT)&rectGG.right);

                return TRUE;
            }

        case WM_PAINT:
            {
            HDC         hDC;
            PAINTSTRUCT ps;
            TCHAR       buffer[48];
            SIZE        size;
            INT         xText, yText;
            INT         nDivideRects;
            RECT        rectDone, rectLeftToDo;
            HGDIOBJ     hOldFont = NULL;

            // The gas gauge is drawn by drawing a text string stating
            // what percentage of the job is done into the middle of
            // the gas gauge rectangle, and by separating that rectangle
            // into two parts: rectDone (the left part, filled in blue)
            // and rectLeftToDo(the right part, filled in white).
            // nDivideRects is the x coordinate that divides these two rects.
            //
            // The text in the blue rectangle is drawn white, and vice versa
            // This is easy to do with ExtTextOut()!

            hDC = BeginPaint(hDlg, &ps);

            if (hFont) {
                hOldFont = SelectObject(hDC, hFont);
            }

            //
            // If formatting quick, set this display
            //
            if (CancelInfo.Info.Format.fQuick &&
                CANCEL_FORMAT == CancelInfo.eCancelType) {
                lstrcpy (buffer, GetStringResource (IDS_QUICKFORMATTINGTITLE));
                SendDlgItemMessage(hDlg, IDD_TEXT, WM_SETTEXT, 0, (LPARAM)cszEmptyString);

                bLastQuick = TRUE;

            } else {

                if (bLastQuick) {
                    lstrcpy (buffer, GetStringResource (IDS_PERCENTCOMPLETE));
                    SendDlgItemMessage(hDlg, IDD_TEXT, WM_SETTEXT, 0, (LPARAM)buffer);

                    bLastQuick = FALSE;
                }

                wsprintf(buffer, SZ_PERCENTFORMAT, CancelInfo.nPercentDrawn);
            }

            GetTextExtentPoint32(hDC, buffer, lstrlen(buffer), &size);
            xText    = rectGG.left
                        + ((rectGG.right - rectGG.left) - size.cx) / 2;
            yText    = rectGG.top
                        + ((rectGG.bottom - rectGG.top) - size.cy) / 2;

            nDivideRects = ((rectGG.right - rectGG.left) * CancelInfo.nPercentDrawn) / 100;

            // Paint in the "done so FAR" rectangle of the gas
            // gauge with blue background and white text
            SetRect(&rectDone, rectGG.left, rectGG.top,
                                        rectGG.left + nDivideRects, rectGG.bottom);
            SetTextColor(hDC, RGB(255, 255, 255));
            SetBkColor(hDC, RGB(0, 0, 255));

            ExtTextOut(hDC, xText, yText, ETO_CLIPPED | ETO_OPAQUE,
                                &rectDone, buffer, lstrlen(buffer), NULL);

            // Paint in the "still left to do" rectangle of the gas
            // gauge with white background and blue text
            SetRect(&rectLeftToDo, rectGG.left+nDivideRects, rectGG.top,
                                        rectGG.right, rectGG.bottom);
            SetTextColor(hDC, RGB(0, 0, 255));
            SetBkColor(hDC, RGB(255, 255, 255));

            ExtTextOut(hDC, xText, yText, ETO_CLIPPED | ETO_OPAQUE,
                            &rectLeftToDo, buffer, lstrlen(buffer), NULL);

            if (hOldFont) {
                SelectObject(hDC, hOldFont);
            }

            EndPaint(hDlg, &ps);

            return TRUE;
            }

        case FS_CANCELUPDATE:
            InvalidateRect(hDlg, &rectGG, TRUE);
            UpdateWindow(hDlg);
            return TRUE;

        default:
            return FALSE;
   }
}

static
BOOL
InitUserData (
    IN  HWND    hWnd
)
/*++

Routine Description:

    initializes the CancelInfo data structure used to format the disk

Arguments:

    Window handle of calling function

Return Value:

    TRUE If library loaded and data initialized

--*/
{
    CancelInfo.hCancelDlg = NULL;
    CancelInfo.bCancel = FALSE;
    CancelInfo.hThread = NULL;
    CancelInfo.fmifsSuccess = FmifsLoaded(hWnd);
    CancelInfo.dReason = 0;
    CancelInfo.fuStyle = 0;
    CancelInfo.nPercentDrawn = 0;
    CancelInfo.eCancelType = CANCEL_NULL;
    CancelInfo.bModal = TRUE;

    CancelInfo.Info.Format.iFormatDrive = 0;
    CancelInfo.Info.Format.fmMediaType = Unknown;
    CancelInfo.Info.Format.fQuick = FALSE;
    CancelInfo.Info.Format.fFlags = 0;
    CancelInfo.Info.Format.szLabel[0] = 0;

    CancelInfo.Info.Copy.iSourceDrive = 0;
    CancelInfo.Info.Copy.iDestDrive = 0;
    CancelInfo.Info.Copy.bFormatDest = FALSE;

    if (CancelInfo.fmifsSuccess) {
        bDataInitialized = TRUE;
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
FormatDiskInDrive (
    IN  HWND    hWnd,           // owner window
    IN  TCHAR   cDrive,         // drive letter to format (only A or B)
    IN  LPCTSTR szLabel,        // label text
    IN  BOOL    bConfirmFormat  // prompt with "r-u-sure?" dialog
)
/*++

Routine Description:

    formats the floppy disk in the specified drive and labels it if desired.
    Always use a complete format.
Arguments:

    IN  HWND    hWnd,           // owner window
    IN  TCHAR   cDrive,         // drive letter to format (only A or B)
    IN  LPCTSTR szLabel,        // label text
    IN  BOOL    bConfirmFormat  // prompt with "r-u-sure?" dialog before formatting

Return Value:

    TRUE if disk is formatted
    FALSE if not

--*/
{
    UINT    nDlgBox;
#if defined(JAPAN) && defined(_X86_)
// fixed kkntbug #11940
//    Network client administrator can not make install disks on PC with C drive as FD

    LONG   lFloppyDiskSize;
#endif

#ifndef JAPAN
// fixed kkntbug #11940
//    Network client administrator can not make install disks on PC with C drive as FD

    // check input argument
    switch (cDrive){
        case TEXT('A'):
        case TEXT('a'):
        case TEXT('B'):
        case TEXT('b'):
            break;

        default:
            SetLastError (ERROR_INVALID_PARAMETER);
            return FALSE;
    }
#endif

    if (lstrlen(szLabel) > MAXLABELLEN) {
            SetLastError (ERROR_INVALID_PARAMETER);
            return FALSE;
    }

    // make sure the DLL and data structures are initialized
    if (!bDataInitialized) {
        if (!InitUserData (hWnd)) {
            SetLastError (ERROR_FILE_NOT_FOUND);
            return FALSE;
        }
    }

    // set the remaining fields to format the diskette
    CancelInfo.hThread = NULL;
    CancelInfo.hCancelDlg = NULL;
    CancelInfo.eCancelType = CANCEL_FORMAT;
    CancelInfo.bCancel = FALSE;
    CancelInfo.dReason = 0;
    CancelInfo.nPercentDrawn = 0;
    CancelInfo.Info.Format.iFormatDrive = (cDrive - TEXT('A'));
    CancelInfo.Info.Format.fmMediaType = GetDriveTypeFromDriveLetter (cDrive);
    if (CancelInfo.Info.Format.fmMediaType == FmMediaUnknown) {
        switch (GetFloppyDiskSize(cDrive)) {
            case 3:
                CancelInfo.Info.Format.fmMediaType = FmMediaF3_1Pt44_512;
                break;

            case 5:
                CancelInfo.Info.Format.fmMediaType = FmMediaF5_1Pt2_512;
                break;

#ifdef JAPAN
// fixed kkntbug #11940
//    Network client administrator can not make install disks on PC with C drive as FD

            case F3_12:
                CancelInfo.Info.Format.fmMediaType = FmMediaF3_1Pt2_512;
                break;

            case F3_123:
                CancelInfo.Info.Format.fmMediaType = FmMediaF3_1Pt23_1024;
                break;

            case F5_123:
                CancelInfo.Info.Format.fmMediaType = FmMediaF5_1Pt23_1024;
                break;
#endif

            default:
                return FALSE;
        }
        CancelInfo.Info.Format.fQuick = FALSE;
    } else {
#if defined(JAPAN) && defined(_X86_)
// fixed kkntbug #11940
//    Network client administrator can not make install disks on PC with C drive as FD

        lFloppyDiskSize = GetFloppyDiskSize(cDrive);

        if ( ((GetKeyboardType(1)&0xff00) == OEM_ID_PC98) &&
             ((lFloppyDiskSize == 3)      ||
              (lFloppyDiskSize == F3_123) ||
              (lFloppyDiskSize == F3_12)) ) {
            if (CancelInfo.Info.Format.fmMediaType == FmMediaF5_1Pt23_1024) {
                CancelInfo.Info.Format.fmMediaType = FmMediaF3_1Pt23_1024;
            }
            if (CancelInfo.Info.Format.fmMediaType == FmMediaF5_1Pt2_512) {
                CancelInfo.Info.Format.fmMediaType = FmMediaF3_1Pt2_512;
            }
        }
#endif
        //
        // Always do a full format.
        //
        CancelInfo.Info.Format.fQuick = FALSE;
    }
    CancelInfo.Info.Format.fFlags = FF_ONLYONE;
    lstrcpy (CancelInfo.Info.Format.szLabel, szLabel);
    if (bConfirmFormat) {
        if (DisplayMessageBox(hWnd,
            IDS_DISKCOPYCONFIRM,
            IDS_DISKCOPYCONFIRMTITLE,
            MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON1) != IDYES)
            // bail out here if they don't want to format the disk
            return FALSE;
    }

    // make sure disk is in drive and prompt if not
    while (!DriveLoaded (cDrive, FALSE)) {
        if (DisplayMessageBox (hWnd,
            IDS_INSERTDEST,
            FMT_INSERT_FLOPPY,
            MB_OKCANCEL_TASK_INFO) == IDCANCEL) {
            return FALSE;
        }
    }

    // display formatting... dialog box
    nDlgBox = (int)DialogBox(GetModuleHandle(NULL), (LPTSTR) MAKEINTRESOURCE(CANCELDLG), hWnd, CancelDlgProc);

    if (nDlgBox == IDOK) {
        if (CancelInfo.dReason != 0) {
           // display reason for not being formatted if it didn't work
            DisplayMessageBox (hWnd,
                CancelInfo.dReason,
                IDS_APP_NAME,
                MB_OK_TASK_EXCL);
            return FALSE;
        } else {
            return TRUE;
        }
    } else {
        return FALSE;
    }
}

BOOL
LabelDiskInDrive (
    IN  HWND    hWnd,           // owner window
    IN  TCHAR   cDrive,         // drive letter to format (only A or B)
    IN  LPCTSTR szLabel         // label text
)
/*++

Routine Description:

    labels the floppy disk in the specified drive.

Arguments:

    IN  HWND    hWnd,           // owner window
    IN  TCHAR   cDrive,         // drive letter to label (only A or B)
    IN  LPCTSTR szLabel,        // label text

Return Value:

    TRUE if disk is formatted
    FALSE if not

--*/
{
    TCHAR   szDrive[4];

#ifndef JAPAN
    // check input argument
    switch (cDrive){
        case TEXT('A'):
        case TEXT('a'):
        case TEXT('B'):
        case TEXT('b'):
            break;

        default:
            SetLastError (ERROR_INVALID_PARAMETER);
            return FALSE;
    }

#endif

    if (lstrlen(szLabel) > MAXLABELLEN) {
            SetLastError (ERROR_INVALID_PARAMETER);
            return FALSE;
    }

    // make sure the DLL and data structures are initialized
    if (!bDataInitialized) {
        if (!InitUserData (hWnd)) {
            SetLastError (ERROR_FILE_NOT_FOUND);
            return FALSE;
        }
    }

    szDrive[0] = cDrive;
    szDrive[1] = cColon;
    szDrive[2] = 0;

    // make sure disk is in drive and prompt if not
    while (!DriveLoaded (cDrive, FALSE)) {
        if (DisplayMessageBox (hWnd,
            IDS_INSERTDEST,
            FMT_INSERT_FLOPPY,
            MB_OKCANCEL_TASK_INFO) == IDCANCEL) {
            return FALSE;
        }
    }

    return (*lpfnSetLabel)(szDrive, (PWSTR)szLabel);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\clcreator\findclnt.c ===
/*++

    Copyright (c) 1994  Microsoft Corporation

Module Name:

    FindClnt.C

Abstract:

    Displays the Searching for clients dialog box and looks for the selected
    client distribution tree returning the path and type of path found.

Author:

    Bob Watson (a-robw)

Revision History:

    24 Jun 94    Written

--*/
//
//  Windows Include Files
//

#include <windows.h>
#include <stdio.h>
#include <malloc.h>
#include <tchar.h>      // unicode macros
#include <lmcons.h>     // lanman API constants
#include <lmerr.h>      // lanman error returns
#include <lmshare.h>    // sharing API prototypes
#include <lmapibuf.h>   // lanman buffer API prototypes
//
//  app include files
//
#include "otnboot.h"
#include "otnbtdlg.h"
//
// local dialog box messages
//
#define     NCDU_SEARCH_FOR_CLIENTS       (WM_USER+101)
//
//      Search Phases
#define     SEARCH_REGISTRY         (0x00000001)
#define     SEARCH_SHARED_DIRS      (0x00000002)
#define     SEARCH_HARD_DRIVES      (0x00000004)
#define     SEARCH_CD_ROM           (0x00000008)
#define     SEARCH_LAST_PHASE       SEARCH_CD_ROM
//
//  module static variables
//
static BOOL     bSearchForClients;  // flag to trip out of search
static HCURSOR  hOrigCursor = NULL; // cursor to save/restore

LONG
GetDistributionPath (
    IN  HWND        hwndDlg,        // handle to dialog box window
    IN  DWORD       dwSearchType,   // type of dir to find: Client/tools
    IN  OUT LPTSTR  szPath,         // buffer to return path in (Req'd)
    IN  DWORD       dwPathLen,      // size of path buffer in chars
    IN  PLONG       plPathType      // pointer to buffer recieving path type (opt)
)
/*++

Routine Description:

    Gets the default distribution file path for loading the dialog box
        entries with.

Arguments:

    IN  HWND        hwndDlg
        handle to parent dialog box window
    IN  DWORD       dwSearchType
        type of dir to find: Client/tools
    IN  OUT LPTSTR  szPath
        buffer to return path in (Req'd)
    IN  DWORD       dwPathLen
        size of path buffer in chars
    IN  PLONG       plPathType
        pointer to buffer recieving path type (opt)

Return Value:

    ERROR_SUCCESS if file found
    ERROR_FILE_NOT_FOUND if unable to find file

--*/
{
    FDT_DATA    Fdt;
    UINT        nDBReturn;

    // build data structure for search

    Fdt.szPathBuffer = szPath;
    Fdt.dwPathBufferLen = dwPathLen;
    Fdt.plPathType = plPathType;
    Fdt.dwSearchType = dwSearchType;

    nDBReturn = (UINT)DialogBoxParam (
        (HINSTANCE)GetWindowLongPtr(hwndDlg, GWLP_HINSTANCE),
        MAKEINTRESOURCE(NCDU_FINDING_CLIENT_DIRS_DLG),
        hwndDlg,
        FindClientsDlgProc,
        (LPARAM)&Fdt);

    if (nDBReturn == IDOK) {
        return ERROR_SUCCESS;
    } else {
        return ERROR_FILE_NOT_FOUND;
    }
}

static
LPCTSTR
GetLastPathFromRegistry (
    IN  DWORD   dwSearchType
)
/*++

Routine Description:

    looks up the last path (server\share) for either the tools directory
        or the client tree as it appears in the registry. If unable to
        find both components of the selected search, then an empty string
        is returned.

Arguments:

    IN  DWORD   dwSearchType
        FDT_TOOLS_TREE  for server tools path
        FDT_CLIENT_TREE for client distribution path

Return Value:

    pointer to a read only string that contains the desired path if
        one was stored in the registry or an empty string if not.

--*/
{
    static  TCHAR    szLastPath[MAX_PATH];
    HKEY    hkeyUserInfo;
    HKEY    hkeyAppInfo;

    LONG    lStatus;
    DWORD   dwBufLen;

    // open registry key containing net apps

    lStatus = RegOpenKeyEx (
        HKEY_CURRENT_USER,
        cszUserInfoKey,
        0L,
        KEY_READ,
        &hkeyUserInfo);

    if (lStatus != ERROR_SUCCESS) {
        // unable to open key so return an empty buffer
        szLastPath[0] = 0;
    } else {
        // open registry key containing this app's info
        lStatus = RegOpenKeyEx (
            hkeyUserInfo,
            szAppName,
            0L,
            KEY_READ,
            &hkeyAppInfo);

        if (lStatus != ERROR_SUCCESS) {
            // unable to open key so return an empty buffer
            szLastPath[0] = 0;
        } else {
            // initialize path variable
            lstrcpy (szLastPath, cszDoubleBackslash);

            // get server name from registry
            dwBufLen = MAX_COMPUTERNAME_LENGTH + 1;
            lStatus = RegQueryValueEx (
                hkeyAppInfo,
                (LPTSTR)(dwSearchType == FDT_TOOLS_TREE ? cszLastToolsServer : cszLastClientServer),
                (LPDWORD)NULL,
                (LPDWORD)NULL,
                (LPBYTE)&szLastPath[lstrlen(szLastPath)],
                &dwBufLen);

            if (lStatus != ERROR_SUCCESS) {
                // unable to read value so return an empty buffer
                szLastPath[0] = 0;
            } else {
                // get sharepoint name from registry
                lstrcat (szLastPath, cszBackslash);
                dwBufLen = MAX_SHARENAME + 1;
                lStatus = RegQueryValueEx (
                    hkeyAppInfo,
                    (LPTSTR)(dwSearchType == FDT_TOOLS_TREE ? cszLastToolsSharepoint : cszLastClientSharepoint),
                    (LPDWORD)NULL,
                    (LPDWORD)NULL,
                    (LPBYTE)&szLastPath[lstrlen(szLastPath)],
                    &dwBufLen);

                if (lStatus != ERROR_SUCCESS) {
                    // unable to read value so return an empty buffer
                    szLastPath[0] = 0;
                }
            }
            RegCloseKey (hkeyAppInfo);
        }
        RegCloseKey (hkeyUserInfo);
    }

    return (LPCTSTR)&szLastPath[0];
}

static
LONG
SearchForDistPath (
    IN  OUT LPTSTR  szPath,         // buffer to return path in (Req'd)
    IN  DWORD       dwPathLen,      // size of path buffer in chars
    IN  PLONG       plPathType,     // pointer to buffer recieving path type (opt)
    IN  DWORD       dwSearchType,   // type of tree to look for
    IN  DWORD       dwPhase         // phase(s) to search
)
/*++

Routine Description:

    function that looks for the desired directory tree in the following
        locations:
            a) the registry, for the stored server\share
            b) the shared directories on the system
            c) the local and redirected drives
            d) the CD-Rom

        The search is divided into phases to allow the user to cancel the
        search.

Arguments:

    IN  OUT LPTSTR  szPath,         // buffer to return path in (Req'd)
    IN  DWORD       dwPathLen,      // size of path buffer in chars
    IN  PLONG       plPathType,     // pointer to buffer recieving path type (opt)
    IN  DWORD       dwSearchType,   // type of tree to look for
    IN  DWORD       dwPhase         // phase(s) to search

Return Value:

    ERROR_SUCCESS

--*/
{
    LONG    lStatus = ERROR_SUCCESS;
    LONG    lPathType = NCDU_NO_CLIENT_PATH_FOUND;
    LPTSTR  szLocalPath = NULL;
    NET_API_STATUS  naStatus = NERR_Success;
    DWORD   dwTotalEntries;
    DWORD   dwEntriesRead;
    DWORD   dwEntriesProcessed;
    DWORD   dwResumeHandle;
    DWORD   dwIndex;
    DWORD   dwBufLen;
    BOOL    bFound;
    UINT    nDriveType;
    TCHAR   szRootDir[32];
    PSHARE_INFO_2    psi2Data;
    UINT    nErrorMode;
    BOOL    bValidPath;

    if (szPath == NULL) {
        // the pointer to the path is required
        return ERROR_INVALID_PARAMETER;
    }

    // allocate temp buffers

    szLocalPath = GlobalAlloc (GPTR, MAX_PATH_BYTES);

    if (szLocalPath == NULL) {
        return ERROR_OUTOFMEMORY;
    }

    // disable windows error message popup
    nErrorMode = SetErrorMode  (SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

    bFound = FALSE;

    if ((dwPhase & SEARCH_REGISTRY) == SEARCH_REGISTRY) {
        // check registry for saved server/sharepoint

        // if server/share found in registry, make into a UNC path
        //  and validate that it's really a client tree. return path if valid

        lstrcpy (szLocalPath, GetLastPathFromRegistry(dwSearchType));
        if (szLocalPath[lstrlen(szLocalPath)] != cBackslash) lstrcat (szLocalPath, cszBackslash);
        if (dwSearchType == FDT_TOOLS_TREE){
            bValidPath = (BOOL)(ValidSrvToolsPath (szLocalPath) == 0);
        } else {
            bValidPath = (BOOL)(ValidSharePath (szLocalPath) == 0);
         }
        if (bValidPath) {
            // it's there so save it in user's buffer and leave
            lstrcpy (szPath, szLocalPath);
            lPathType = NCDU_PATH_FROM_REGISTRY;
            lStatus = ERROR_SUCCESS;
            goto GDP_ExitPoint;
        }
    }

    if ((dwPhase & SEARCH_SHARED_DIRS) == SEARCH_SHARED_DIRS)  {
        // if here, then no valid server/share was found in registry, so
        // look at shared dir's on this machine and see if any of them are
        // valid client trees. If one is found, return the path in UNC form

        // search all current shares on this system

        dwEntriesProcessed = 0;
        dwEntriesRead = 0;
        dwTotalEntries = 0;
        dwResumeHandle = 0;
        while ((naStatus = NetShareEnum(
            NULL,
            2,
            (LPBYTE *)&psi2Data,
            0x00010000,
            &dwEntriesRead,
            &dwTotalEntries,
            &dwResumeHandle)) == NERR_Success) {
            if (dwEntriesRead == 0) break;  // then it'd done
            for (dwIndex = 0; dwIndex < dwEntriesRead; dwIndex++){
                // don't check shares that translate to floppy drives A: & B:
                if ((_tcsnicmp(psi2Data[dwIndex].shi2_path, cszADriveRoot, 3) != 0) &&
                    (_tcsnicmp(psi2Data[dwIndex].shi2_path, cszBDriveRoot, 3) != 0)) {
                    if (dwSearchType == FDT_TOOLS_TREE){
                        bValidPath = (BOOL)(ValidSrvToolsPath (psi2Data[dwIndex].shi2_path) == 0);
                    } else {
                        bValidPath = (BOOL)(ValidSharePath (psi2Data[dwIndex].shi2_path) == 0);
                    }
                    if (bValidPath) {
                        // make a UNC name out of share name
                        lstrcpy (szLocalPath, cszDoubleBackslash);
                        dwBufLen = MAX_COMPUTERNAME_LENGTH+1;
                        GetComputerName (&szLocalPath[2],  &dwBufLen);
                        lstrcat (szLocalPath, cszBackslash);
                        lstrcat (szLocalPath, psi2Data[dwIndex].shi2_netname);
                        lstrcat (szLocalPath, cszBackslash);

                        if (lstrlen(szLocalPath) < (LONG)dwPathLen) {
                            // save path string in user's buffer and leave
                            lstrcpy (szPath, szLocalPath);
                            lPathType = NCDU_LOCAL_SHARE_PATH;
                            lStatus = ERROR_SUCCESS;
                            bFound = TRUE;
                        }
                        break;
                    }
                }
            }
            // free buffer created by Net API
            if (psi2Data != NULL) NetApiBufferFree (psi2Data);
            // update entry counters to know when to stop looping
            dwEntriesProcessed += dwEntriesRead;
            if ((dwEntriesProcessed >= dwTotalEntries) || bFound) {
                break; // out of while loop
            }
        }
        if (bFound) goto GDP_ExitPoint;
    }

    if ((dwPhase & SEARCH_HARD_DRIVES) == SEARCH_HARD_DRIVES) {
        // if here, then no shared path was found, so search hard drives for
        // a client tree in the root directory and return the DOS path if one
        // is found

        szRootDir[0] = 0;
        szRootDir[1] = cColon;
        szRootDir[2] = cBackslash;
        szRootDir[3] = 0;
        for (szRootDir[0] = cC; szRootDir[0] <= cZ; szRootDir[0]++) {
            // if it's local or remote drive look for a clients dir.
            // don't check CD_ROM, RAM Disks or Removable drive
            nDriveType = GetDriveType(szRootDir);
            if ((nDriveType == DRIVE_FIXED) || (nDriveType == DRIVE_REMOTE)) {
                // see if this is drive has the appropriate sub-dir on it
                if (dwSearchType == FDT_TOOLS_TREE){
                    lstrcpy (&szRootDir[3], cszToolsDir);
                    bValidPath = (BOOL)(ValidSrvToolsPath (szRootDir) == 0);
                } else {
                    lstrcpy (&szRootDir[3], cszClientsDir);
                    bValidPath = (BOOL)(ValidSharePath (szRootDir) == 0);
                }
                if (bValidPath) {
                    // a valid path was found
                    if (nDriveType == DRIVE_REMOTE) {
                        // then this drive is shared on another machine
                        // so return the UNC version of the path
                        dwBufLen = MAX_PATH * sizeof(TCHAR);
                        if (LookupRemotePath (szRootDir, szLocalPath, &dwBufLen)) {
                            // save path string in user's buffer and leave
                            lstrcpy (szPath, szLocalPath);
                            lPathType = NCDU_LOCAL_SHARE_PATH;
                            lStatus = ERROR_SUCCESS;
                        } else {
                            // unable to look up redirected drive so return dos
                            // version of path (this shouldn't happen);
                            lstrcpy (szPath, szRootDir);
                            lPathType = NCDU_HARD_DRIVE_PATH;
                            lStatus = ERROR_SUCCESS;
                        }
                    } else {
                        // this is a Local drive so return the DOS
                        // version of path
                        lstrcpy (szPath, szRootDir);
                        lPathType = NCDU_HARD_DRIVE_PATH;
                        lStatus = ERROR_SUCCESS;
                    }
                    bFound = TRUE;
                    break;
                }
            } // else ignore if not a local or remote hard drive
            szRootDir[3] = 0;   // reset string back to a drive only
        } // end of for loop
        if (bFound) goto GDP_ExitPoint;
    }

    if ((dwPhase & SEARCH_CD_ROM) == SEARCH_CD_ROM) {
        // if here, then no client tree was found on a hard drive, so see if
        // they have a CD-ROM with the client tree on it. If they do, then
        // return the DOS path of the dir.

        // find CD-ROM drive
        szRootDir[0] = 0;
        szRootDir[1] = cColon;
        szRootDir[2] = cBackslash;
        szRootDir[3] = 0;

        for (szRootDir[0] = cC; szRootDir[0] <= cZ; szRootDir[0]++) {
            if (GetDriveType(szRootDir) == DRIVE_CDROM) break;
        }

        if (szRootDir[0] <= cZ) {
            // then a CD-ROM must have been found, so append the "clients" dir
            // and see if this is a valid client tree
            if (dwSearchType == FDT_TOOLS_TREE){
                lstrcat (szRootDir, cszToolsDir);
                bValidPath = (BOOL)(ValidSrvToolsPath (szRootDir) == 0);
            } else {
                lstrcat (szRootDir, cszClientsDir);
                bValidPath = (BOOL)(ValidSharePath (szRootDir) == 0);
            }
            if (bValidPath) {
                // found one on the CD so return the DOS
                // version of path
                lstrcpy (szPath, szRootDir);
                lPathType = NCDU_CDROM_PATH;
                lStatus = ERROR_SUCCESS;
                bFound = TRUE;
            }
        }
        goto GDP_ExitPoint;
    }

    // if here, then NO client tree was found. so return an empty string
    // bufffer and error code.

    lStatus = ERROR_SUCCESS;
    lPathType = NCDU_NO_CLIENT_PATH_FOUND;
    *szPath = 0;   // make string buffer empty

GDP_ExitPoint:

    if (plPathType != NULL) {
        *plPathType = lPathType;
    }

    FREE_IF_ALLOC (szLocalPath);

    SetErrorMode (nErrorMode);  // restore old error mode

    return lStatus;
}

static
BOOL
FindClientsDlg_WM_INITDIALOG (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Dialog Box initialization routine:
        calls routines that format the currently selected options
        for display in the static text fields of the dialog box

Arguments:

    IN  HWND    hwndDlg
        Handle to dialog box window

    IN  WPARAM  wParam
        Not Used

    IN  LPARAM  lParam
        pointer to client search data strucutre

Return Value:

    FALSE  because focus is set in this routine to the CANCEL button

--*/
{
    PFDT_DATA   pFdt = (PFDT_DATA)lParam;
    LPTSTR      szTitle;

    // locate windw
    PositionWindow  (hwndDlg);

    // set global flag
    bSearchForClients = TRUE;

    // clear dialog box text
    SetDlgItemText (hwndDlg, NCDU_CLIENT_SEARCH_PHASE, cszEmptyString);

    // display Tools Tree search string if appropriate
    szTitle = GlobalAlloc (GPTR, MAX_PATH_BYTES);
    if (szTitle != NULL) {
        if (pFdt->dwSearchType == FDT_TOOLS_TREE) {
            if (LoadString (
                (HINSTANCE)GetWindowLongPtr(hwndDlg, GWLP_HINSTANCE),
                NCDU_FINDING_TOOLS_PATH,
                szTitle,
                80) > 0) {
                SetDlgItemText (hwndDlg, NCDU_SEARCH_TYPE_TITLE, szTitle);
            }
        }
        FREE_IF_ALLOC (szTitle);
    }

    // start 1st phase of search
    PostMessage (hwndDlg, NCDU_SEARCH_FOR_CLIENTS, (WPARAM)SEARCH_REGISTRY, lParam);

    // set focus
    SetFocus (GetDlgItem(hwndDlg, IDCANCEL));

    // need an arrow cursor to cancel out of dialog box.

    hOrigCursor = SetCursor (LoadCursor(NULL, IDC_ARROW));

    return FALSE;
}

static
BOOL
FindClientsDlg_SEARCH_FOR_CLIENTS (
    IN  HWND    hwndDlg,    // dlg window handle
    IN  WPARAM  wParam,     // search phase
    IN  LPARAM  lParam      // search data structure
)
/*++

Routine Description:

    message processing routine to perform client tree search in phases

Arguments:

    IN  HWND    hwndDlg
        dlg window handle

    IN  WPARAM  wParam
        search phase

    IN  LPARAM  lParam
        search data structure

Return Value:

    TRUE

--*/
{
    UINT        nPhaseName;
    PFDT_DATA   pFdt;

    if (bSearchForClients) {
        // perform this phase of the search
        // set dlg box text
        switch (wParam) {
            case SEARCH_REGISTRY:
                nPhaseName = CSZ_SYSTEM_REGISTRY;
                break;

            case SEARCH_SHARED_DIRS:
                nPhaseName = CSZ_SHARED_DIRS;
                break;

            case SEARCH_HARD_DRIVES:
                nPhaseName = CSZ_HARD_DISK_DIRS;
                break;

            case SEARCH_CD_ROM:
                nPhaseName = CSZ_CD_ROM;
                break;

            default:
                nPhaseName = CSZ_LOCAL_MACHINE;
                break;
        }
        SetDlgItemText (hwndDlg, NCDU_CLIENT_SEARCH_PHASE,
            GetStringResource (nPhaseName));

        pFdt = (PFDT_DATA)lParam;

        // search for clients

        SearchForDistPath (
            pFdt->szPathBuffer,
            pFdt->dwPathBufferLen,
            pFdt->plPathType,
            pFdt->dwSearchType,
            (DWORD)wParam);

        if (*pFdt->plPathType != NCDU_NO_CLIENT_PATH_FOUND) {
            // client found, so end here
            EndDialog (hwndDlg, IDOK);
        } else {
            // try next phase
            if (wParam != SEARCH_LAST_PHASE) {
                wParam <<= 1;  // go to next phase
                PostMessage (hwndDlg, NCDU_SEARCH_FOR_CLIENTS,
                    wParam, lParam);
            } else {
                // this is the last phase so exit
                EndDialog (hwndDlg, (bSearchForClients ? IDOK : IDCANCEL));
            }
        }
    }
    return TRUE;
}

static
BOOL
FindClientsDlg_WM_COMMAND (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    WM_COMMAND message dispatching routine.
        Dispatches IDCANCEL and IDOK button messages, sends all others
        to the DefDlgProc.

Arguments:

    IN  HWND    hwndDlg
        Handle to dialog box window

    IN  WPARAM  wParam
        windows message wParam arg

    IN  LPARAM  lParam
        windows message lParam arg

Return Value:

    TRUE if message is not dispatched (i.e. not processed)
        othewise the value returned by the called routine.

--*/
{

    switch (LOWORD(wParam)) {
        case IDCANCEL:
            switch (HIWORD(wParam)) {
                case BN_CLICKED:
                    bSearchForClients = FALSE;
                    return TRUE;

                default:
                    return FALSE;
            }

        default:
            return FALSE;
    }
}
static
BOOL
FindClientsDlg_WM_DESTROY (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    restores original cursor when dialog box exits

Arguments:

    std. windows message args

Return Value:

    TRUE

--*/
{
    if (hOrigCursor != NULL) SetCursor (hOrigCursor);
    hOrigCursor = NULL;
    return TRUE;
}

static
INT_PTR CALLBACK
FindClientsDlgProc (
    IN  HWND    hwndDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    main dialog proc for this dialog box.
        Processes the following messages:

            WM_INITDIALOG:              dialog box initialization
            WM_COMMAND:                 command button/item selected
            WM_DESTROY:                 restore cursor on exit
            NCDU_SEARCH_FOR_CLIENTS:    execute search message

Arguments:

    IN  HWND    hwndDlg
        handle to dialog box window

    IN  UINT    message
        message id

    IN  WPARAM  wParam
        message wParam arg

    IN  LPARAM  lParam
        message lParam arg

Return Value:

    FALSE if message not processed by this module, otherwise the
        value returned by the message processing routine.

--*/
{
    switch (message) {
        // windows messages
        case WM_INITDIALOG: return (FindClientsDlg_WM_INITDIALOG (hwndDlg, wParam, lParam));
        case WM_COMMAND:    return (FindClientsDlg_WM_COMMAND (hwndDlg, wParam, lParam));
        case WM_DESTROY:    return (FindClientsDlg_WM_DESTROY (hwndDlg, wParam, lParam));
        // local messages
        case NCDU_SEARCH_FOR_CLIENTS:    return (FindClientsDlg_SEARCH_FOR_CLIENTS (hwndDlg, wParam, lParam));
        default:            return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\clcreator\otnboot.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    otnboot.H

Abstract:

    Constant definitions for the Net Client Disk Utility.

Author:

    Bob Watson (a-robw)

Revision History:

    17 Feb 94    Written


--*/
#ifndef     _otnboot_H_
#define     _otnboot_H_

#include    <winioctl.h>
#include    <nddeapi.h>

#ifndef DS_3DLOOK
#define DS_3DLOOK 0x0004L
#endif

#ifdef JAPAN
#define NCDU_DOSV_CHECK             1000
#endif

//Note: above NCDU_DOSV_CHECK should be added to file otnbtdlg.h, but that file cannot
// be checked in to the SLM, so moved here.
//



//
//  Application specific windows messages
//
#define NCDU_SHOW_SW_CONFIG_DLG     (WM_USER+11)
#define NCDU_SHOW_TARGET_WS_DLG     (WM_USER+12)
#define NCDU_SHOW_SERVER_CFG_DLG    (WM_USER+13)
#define NCDU_SHOW_CONFIRM_DLG       (WM_USER+14)
#define NCDU_SHOW_CREATE_DISKS_DLG  (WM_USER+15)
#define NCDU_SHOW_SHARE_NET_SW_DLG  (WM_USER+16)
#define NCDU_SHOW_COPYING_DLG       (WM_USER+17)
#define NCDU_SHOW_EXIT_MESSAGE_DLG  (WM_USER+18)
#define NCDU_SHOW_COPY_ADMIN_UTILS  (WM_USER+19)
#define NCDU_CLEAR_DLG              (WM_USER+20)
#define NCDU_REGISTER_DLG           (WM_USER+21)
#define NCDU_UPDATE_WINDOW_POS      (WM_USER+22)

//
//  resource constant definitions
//
//#define     NCDU_APP_ICON           0x7000

#define     NCDU_ID_ABOUT           0xFF10

#define     STRING_BASE             0x8000

#ifdef TERMSRV
#define     WFC_STRING_BASE         0x9000
#endif // TERMSRV

#define     NCDU_CANCEL_CAPTION     (STRING_BASE    + 1)
#define     NCDU_CANCEL_PROMPT      (STRING_BASE    + 2)
#define     NCDU_MAKING_FLOPPIES    (STRING_BASE    + 3)
#define     NCDU_LANMAN_MESSAGE     (STRING_BASE    + 4)
#define     NCDU_COPYING_TO_SHARE   (STRING_BASE    + 5)

#define     NCDU_INSERT_BOOTDISK_A  (STRING_BASE    + 6)
#define     NCDU_INSERT_BOOTDISK_B  (STRING_BASE    + 7)
#define     NCDU_SHARE_PATH_NOW     (STRING_BASE    + 8)
#define     NCDU_EXIT_SHARE_PATH    (STRING_BASE    + 9)
#define     NCDU_UNABLE_READ_DIR    (STRING_BASE    +10)

#define     NCDU_PATH_NOT_DIR       (STRING_BASE    +11)
#define     NCDU_PATH_CANNOT_BE_BLANK   (STRING_BASE    + 12)
#define     NCDU_SHARING_DIR        (STRING_BASE    +13)
#define     NCDU_NOT_REAL           (STRING_BASE    +14)
#define     NCDU_NOT_DIST_TREE      (STRING_BASE    +15)

#define     NCDU_NO_SHARE_NAME      (STRING_BASE    +16)
#define     NCDU_UNKNOWN_FLOPPY     (STRING_BASE    +17)
#define     NCDU_UNABLE_CONNECT_REG (STRING_BASE    +18)
#define     NCDU_INVALID_MACHINENAME (STRING_BASE   +19)
#define     NCDU_COPY_TO_FLOPPY     (STRING_BASE    +20)

#define     NCDU_DEST_NOT_FLOPPY    (STRING_BASE    +21)
#define     NCDU_INSUFFICIENT_DISK_SPACE    (STRING_BASE    +22)
#define     NCDU_DRIVE_NOT_BOOTDISK (STRING_BASE    +23)
#define     NCDU_UNABLE_SHARE_UNC   (STRING_BASE    +24)
#define     NCDU_UNABLE_COPY_CLIENTS    (STRING_BASE+25)

#define     NCDU_RU_SURE            (STRING_BASE    + 26)
#define     NCDU_BAD_SUBNET_MASK    (STRING_BASE    + 27)
#define     NCDU_BAD_IP_ADDR        (STRING_BASE    + 28)
#define     NCDU_FLOPPY_NOT_COMPLETE    (STRING_BASE+ 29)
#define     NCDU_CHECK_PROTOCOL_INI (STRING_BASE    + 30)

#define     NCDU_NO_CLIENTS_SELECTED (STRING_BASE   + 31)
#define     NCDU_UNABLE_SHARE_DIR   (STRING_BASE    + 32)
#define     NCDU_BAD_DEFAULT_GATEWAY (STRING_BASE   + 33)
#define     NCDU_COPY_NET_ADMIN     (STRING_BASE    + 34)
#define     NCDU_ERROR_NOMEMORY     (STRING_BASE    + 35)

#define     NCDU_USERNAME_ACCESS    (STRING_BASE    + 36)
#define     NCDU_UNSUP_PROTOCOL     (STRING_BASE    + 37)
#define     NCDU_NO_MEDIA           (STRING_BASE    + 38)
#define     NCDU_CONFIRM_FLOPPY     (STRING_BASE    + 39)
#define     NCDU_COPY_COMPLETE      (STRING_BASE    + 40)

#define     NCDU_FLOPPY_COMPLETE    (STRING_BASE    + 41)
#define     NCDU_NETUTILS_SHARED    (STRING_BASE    + 42)
#define     NCDU_NETBEUI_NOT_ROUT   (STRING_BASE    + 43)

#define     NCDU_CANNOT_SHARE_REMDIR (STRING_BASE   + 46)
#define     NCDU_SHARE_IS_NOT_USED  (STRING_BASE    + 47)
#define     NCDU_SHARE_IS_CLIENT_TREE (STRING_BASE  + 48)
#define     NCDU_SHARE_IS_SERVER_TOOLS (STRING_BASE + 49)
#define     NCDU_SHARE_IS_OTHER_DIR (STRING_BASE    + 50)

#define     NCDU_SERVER_NOT_PRESENT (STRING_BASE    + 51)
#define     NCDU_NO_SERVER          (STRING_BASE    + 52)
#define     NCDU_NOT_DOS_SHARE      (STRING_BASE    + 53)
#define     NCDU_NOT_TOOL_TREE      (STRING_BASE    + 54)
#define     NCDU_BROWSE_TOOL_DIST_PATH (STRING_BASE    + 55)

#define     NCDU_BROWSE_CLIENT_DIST_PATH (STRING_BASE    + 56)
#define     NCDU_BROWSE_COPY_DEST_PATH (STRING_BASE    + 57)
#define     NCDU_FINDING_TOOLS_PATH (STRING_BASE    + 58)
#define     NCDU_MAKE_COMP_NAME     (STRING_BASE    + 59)
#define     NCDU_DISK_NOT_DONE      (STRING_BASE    + 60)

#define     NCDU_DRIVE_NOT_AVAILABLE (STRING_BASE   + 61)
#define     NCDU_UNABLE_GET_PATH_INFO (STRING_BASE   + 62)
#define     NCDU_INSUF_MEM_AT_BOOT  (STRING_BASE    + 63)

#define     NCDU_NW_LINK_TRANSPORT  (STRING_BASE    + 66)
#define     NCDU_TCP_IP_TRANSPORT   (STRING_BASE    + 67)
#define     NCDU_NETBEUI_TRANSPORT  (STRING_BASE    + 68)
#define     NCDU_SYSTEM_MAY_NOT_FIT (STRING_BASE    + 69)
#define     NCDU_SMALL_DISK_WARN    (STRING_BASE    + 70)
#define     NCDU_CLEAN_DISK_REQUIRED    (STRING_BASE    + 71)

#define     FORMAT_BASE             0x9000

#define SZ_APP_TITLE            (FORMAT_BASE + 1)
#define FMT_CREATE_SHARE_ERROR  (FORMAT_BASE + 2)
#define CSZ_ABOUT_ENTRY         (FORMAT_BASE + 3)

#define FMT_LOAD_NET_CLIENT     (FORMAT_BASE + 4)
#define FMT_CONFIRM_TARGET      (FORMAT_BASE + 5)
#define FMT_INSTALL_TARGET_CLIENT       (FORMAT_BASE + 6)
#define FMT_LOGON_USERNAME      (FORMAT_BASE + 7)
#define FMT_PROMPT_USERNAME     (FORMAT_BASE + 8)
#define FMT_CONFIRM_FLOPPY_IP   (FORMAT_BASE + 9)
#define FMT_USING_DHCP          (FORMAT_BASE + 10)

#define FMT_WORKING             (FORMAT_BASE + 11)
#define FMT_PERCENT_COMPLETE    (FORMAT_BASE + 12)
#define FMT_ZERO_PERCENT_COMPLETE       (FORMAT_BASE + 13)
#define FMT_PREPARE_TO_COPY     (FORMAT_BASE + 14)

#define FMT_CLIENT_DISK_AND_DRIVE       (FORMAT_BASE + 16)
#define FMT_CLIENT_DISPLAY_NAME (FORMAT_BASE + 17)
#define FMT_COPY_COMPLETE_STATS (FORMAT_BASE + 18)
#define FMT_INSERT_FLOPPY       (FORMAT_BASE + 19)
#define FMT_1_DISK_REQUIRED     (FORMAT_BASE + 20)
#define FMT_N_DISKS_REQUIRED    (FORMAT_BASE + 21)

#define FMT_INTERNAL_BUFFER     (FORMAT_BASE + 22)
#define FMT_CONNECTING_COMMENT  (FORMAT_BASE + 23)
#define FMT_RUNNING_SETUP_COMMENT       (FORMAT_BASE + 24)
#define FMT_OTN_COMMENT         (FORMAT_BASE + 25)
#define FMT_OTN_BOOT_FILES      (FORMAT_BASE + 26)

#define FMT_K_BYTES             (FORMAT_BASE + 27)
#define FMT_M_BYTES             (FORMAT_BASE + 28)
#define FMT_CLIENT_INFO_DISPLAY (FORMAT_BASE + 29)
#define FMT_NONE                (FORMAT_BASE + 30)
#define FMT_SHARE_REMARK        (FORMAT_BASE + 31)
#define FMT_SHARE_TOOLS_REMARK  (FORMAT_BASE + 32)
#define FMT_SHARE_IS_CLIENT_TREE        (FORMAT_BASE + 33)
#define FMT_SHARE_IS_ALREADY_USED       (FORMAT_BASE + 34)

#define CSZ_SETUP_ADM           (FORMAT_BASE + 35)
#define FMT_SHARE_IS_TOOLS_DIR  (FORMAT_BASE + 36)
#define CSZ_SYSTEM_REGISTRY     (FORMAT_BASE + 37)
#define CSZ_SHARED_DIRS         (FORMAT_BASE + 38)
#define CSZ_HARD_DISK_DIRS      (FORMAT_BASE + 39)
#define CSZ_CD_ROM              (FORMAT_BASE + 40)
#define CSZ_LOCAL_MACHINE       (FORMAT_BASE + 41)

#define CSZ_DOMAIN_ADMINS       (FORMAT_BASE + 43)

#define CSZ_WINDOWS_FOR_WORKGROUPS      (FORMAT_BASE + 44)
#define CSZ_LAN_MANAGER         (FORMAT_BASE + 45)
#define CSZ_MS_NETWORK_CLIENT   (FORMAT_BASE + 46)
#define CSZ_BROWSE_DIST_PATH_TITLE      (FORMAT_BASE + 47)
#define CSZ_BROWSE_DEST_PATH_TITLE      (FORMAT_BASE + 48)
#define CSZ_BROWSE_COPY_DEST_PATH_TITLE (FORMAT_BASE + 49)
#define CSZ_NW_LINK_PROTOCOL    (FORMAT_BASE + 50)
#define CSZ_TCP_IP_PROTOCOL     (FORMAT_BASE + 51)
#define CSZ_NETBEUI_PROTOCOL    (FORMAT_BASE + 52)
#define CSZ_COPYING_NET_UTILS   (FORMAT_BASE + 53)
#define CSZ_UNABLE_COPY         (FORMAT_BASE + 54)
#define CSZ_COPY_ERROR          (FORMAT_BASE + 55)

#define CSZ_ABOUT_TITLE         (FORMAT_BASE + 56)

#define CSZ_35_HD               (FORMAT_BASE + 57)
#define CSZ_525_HD              (FORMAT_BASE + 58)
#define CSZ_DEFAULT_CLIENT_SHARE (FORMAT_BASE + 59)
#define CSZ_WINDOWS_95              (FORMAT_BASE + 60)

#define CSZ_WINDOWS_NT          (FORMAT_BASE + 61)
#ifdef JAPAN
#define FMT_LOAD_NET_CLIENT1    (FORMAT_BASE + 62)
#define FMT_LOAD_NET_CLIENT2    (FORMAT_BASE + 63)
#define FMT_LOAD_NET_CLIENT2_TITLE    (FORMAT_BASE + 64)

#define FMT_LOAD_AUTOEXEC_ECHO   (FORMAT_BASE + 65)
#define FMT_OTN_BOOT_FILES_DOSV  (FORMAT_BASE + 66)
#endif

#ifdef TERMSRV
#define FMT_COPY_COMPLETE_STATS1 (FORMAT_BASE + 67)
#define FMT_COPY_COMPLETE_STATS2 (FORMAT_BASE + 68)
#endif // TERMSRV


#define DISK_FORMAT_BASE            0xA000
#define IDS_APP_NAME                (DISK_FORMAT_BASE + 1)
#define IDS_FMIFSLOADERR            (DISK_FORMAT_BASE + 2)
#define IDS_DISKCOPYCONFIRM         (DISK_FORMAT_BASE + 3)
#define IDS_DISKCOPYCONFIRMTITLE    (DISK_FORMAT_BASE + 4)
#define IDS_FFERR                   (DISK_FORMAT_BASE + 5)

#define IDS_FORMATTINGDEST          (DISK_FORMAT_BASE + 6)
#define IDS_COPYINGDISKTITLE        (DISK_FORMAT_BASE + 7)
#define IDS_QUICKFORMATTINGTITLE    (DISK_FORMAT_BASE + 8)
#define IDS_PERCENTCOMPLETE         (DISK_FORMAT_BASE + 9)
#define IDS_COPYDISK                (DISK_FORMAT_BASE + 10)

#define IDS_INSERTDEST              (DISK_FORMAT_BASE + 11)
#define IDS_INSERTSRC               (DISK_FORMAT_BASE + 12)
#define IDS_INSERTSRCDEST           (DISK_FORMAT_BASE + 13)
#define IDS_FFERR_INCFS             (DISK_FORMAT_BASE + 14)
#define IDS_FFERR_ACCESSDENIED      (DISK_FORMAT_BASE + 15)

#define IDS_FFERR_DISKWP            (DISK_FORMAT_BASE + 16)
#define IDS_FFERR_CANTLOCK          (DISK_FORMAT_BASE + 17)
#define IDS_FFERR_CANTQUICKF        (DISK_FORMAT_BASE + 18)
#define IDS_FFERR_SRCIOERR          (DISK_FORMAT_BASE + 19)
#define IDS_FFERR_DSTIOERR          (DISK_FORMAT_BASE + 20)

#define IDS_FFERR_SRCDSTIOERR       (DISK_FORMAT_BASE + 21)
#define IDS_FFERR_GENIOERR          (DISK_FORMAT_BASE + 22)
#define   IDS_FFERR_MEDIASENSE      (DISK_FORMAT_BASE + 23)
#define IDS_FFERR_BADLABEL          (DISK_FORMAT_BASE + 25)

#define IDS_COPYSRCDESTINCOMPAT     (DISK_FORMAT_BASE + 26)
#define IDS_FORMATERR               (DISK_FORMAT_BASE + 27)
#define IDS_FORMATQUICKFAILURE      (DISK_FORMAT_BASE + 28)
//#define  IDS_FORMATERRMSG           (DISK_FORMAT_BASE + 29)
//#define  IDS_FORMATCURERR           (DISK_FORMAT_BASE + 30)

#define IDS_FORMATCOMPLETE          (DISK_FORMAT_BASE + 31)
#define IDS_FORMATANOTHER           (DISK_FORMAT_BASE + 32)
#define IDS_CORRECT_FMT_ERROR       (DISK_FORMAT_BASE + 33)

#define IDS_COPYERROR               (DISK_FORMAT_BASE + 100)
#define FUNC_COPY                   1
#define FUNC_MOVE                   2
#define FUNC_DELETE                 3
#define FUNC_RENAME                 4
#define FUNC_SETDRIVE               5
#define FUNC_EXPAND                 6
#define FUNC_LABEL                  7

//
//  Application constant definitions
//

#define     NCDU_CANCEL_STYLE   (MB_ICONQUESTION | MB_YESNOCANCEL | MB_TASKMODAL)

#define     MAX_PATH_BYTES          (MAX_PATH * sizeof(TCHAR))
#define     SMALL_BUFFER_SIZE       4096
#define     MEDIUM_BUFFER_SIZE      (SMALL_BUFFER_SIZE * 4)

#define     MAX_EXITMSG             32
#define     MAX_SHARENAME           16
#define     NETCARD_KEY_SIZE        64

#define     MAXMESSAGELEN   80
#define     MAXTITLELEN     32
#define     MAXLABELLEN     11
//
//  Common Message Box Button configurations
//
#define MB_OK_TASK_EXCL             (MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL)
#define MB_OK_TASK_INFO             (MB_OK | MB_ICONINFORMATION | MB_TASKMODAL)
#define MB_OKCANCEL_TASK_EXCL       (MB_OKCANCEL | MB_ICONEXCLAMATION | MB_TASKMODAL)
#define MB_OKCANCEL_TASK_INFO       (MB_OKCANCEL | MB_ICONINFORMATION | MB_TASKMODAL)
#define MB_OKCANCEL_TASK_EXCL_DEF2  (MB_OKCANCEL | MB_ICONEXCLAMATION | MB_TASKMODAL | MB_DEFBUTTON2)

// button state definitions
#define     CHECKED         1
#define     UNCHECKED       0

// Load Client List Type values
#define     CLT_ALL_BUT_HIDDEN   0
#define     CLT_OTNBOOT_FLOPPY   1
#define     CLT_FLOPPY_INSTALL   2

#define     NCDU_HELP_HOT_KEY   0x0BEE  // whotkey id for f1 help
// Copy Dir dwFlags values:

#define  CD_FLAGS_COPY_SUB_DIR  0x00000001  // copies all sub dir's as well
#define  CD_FLAGS_DONT_CREATE   0x00000002  // default is to create dirs as needed
#define  CD_FLAGS_IGNORE_ATTR   0x00000004  // ignore attributes
#define  CD_FLAGS_COPY_ATTR     0x00000008  // copy attributes as well (default
                                            //     is for dest fils to be normal)
#define  CD_FLAGS_IGNORE_ERROR  0x00000010  // continue with copy even if errors occur
#define  CD_FLAGS_LONG_NAMES    0x00000040  // allows names longer than 8.3

//
//  Main Window Extra Bytes
//
#define  MAINWND_EXTRA_BYTES    0

//
//  Macro definitions
//
#define FREE_IF_ALLOC(x)    if (x != NULL) GlobalFree(x)
#define BOOL_TO_STATUS(x)   (x ? ERROR_SUCCESS : GetLastError())

#ifndef     CLEAR_FIRST_FOUR_BYTES
#define     CLEAR_FIRST_FOUR_BYTES(x)     *(DWORD *)(x) = 0L
#endif




//
//  Data structure Definitions
//
typedef enum _INSTALL_TYPE {
    FloppyDiskInstall = 0,
    OverTheNetInstall,
    CopyNetAdminUtils,
    ShowRemoteBootInfo} INSTALL_TYPE;

typedef enum _SOURCE_TYPE {
    SourceUndef = 0,
    ServerShare,
    DirectoryPath} SOURCE_TYPE;

typedef enum _SHARE_TYPE {
    ShareExisting = 0,
    CopyAndShare} SHARE_TYPE;

typedef struct _NETCARD_INFO {
    TCHAR   szInf[MAX_PATH+1];              // inf file name
    TCHAR   szName[MAX_PATH+1];             // description
    TCHAR   szDriverFile[MAX_PATH+1];       // device driver FileName
    TCHAR   szInfKey[NETCARD_KEY_SIZE];     // Netcard Key Name
    TCHAR   szDeviceKey[NETCARD_KEY_SIZE];  // netcard device key
    TCHAR   szNifKey[NETCARD_KEY_SIZE];     // Netcard Info Key
    BOOL    bTokenRing;                     // TRUE = Token Ring Netcard
} NETCARD_INFO, *PNETCARD_INFO;

typedef struct _PROTOCOL_INFO {
    TCHAR   szName[MAX_PATH+1];
    TCHAR   szKey[MAX_PATH+1];
    TCHAR   szDir[MAX_PATH+1];
} PROTOCOL_INFO, *PPROTOCOL_INFO;

typedef struct _TCPIP_INFO {
    USHORT  IpAddr[4];
    USHORT  SubNetMask[4];
    USHORT  DefaultGateway[4];
} TCPIP_INFO, *PTCPIP_INFO;

typedef enum _MACHINE_TYPE {
    UnknownSoftwareType = 0,
    AdvancedServer,
    NtWorkstation} MACHINE_TYPE;

typedef struct _NCDU_DATA {
    MACHINE_TYPE    mtLocalMachine;
    HKEY            hkeyMachine;
    INSTALL_TYPE    itInstall;
    BOOL            bUseExistingPath;
    SHARE_TYPE      shShareType;
    TCHAR           szDistShowPath[MAX_PATH+1];
    TCHAR           szDistPath[MAX_PATH+1];
    TCHAR           szDestPath[MAX_PATH+1];
    SOURCE_TYPE     stDistPathType;
    MEDIA_TYPE      mtBootDriveType;
    BOOL            bRemoteBootReqd;
    NETCARD_INFO    niNetCard;
    TCHAR           szBootFilesPath[MAX_PATH+1];
    PROTOCOL_INFO   piFloppyProtocol;
    PROTOCOL_INFO   piTargetProtocol;
    TCHAR           szTargetSetupCmd[MAX_PATH+1];
    TCHAR           szComputerName[MAX_COMPUTERNAME_LENGTH+1];
    TCHAR           szUsername[MAX_USERNAME+1];
    TCHAR           szDomain[MAX_DOMAINNAME+1];
    BOOL            bUseDhcp;
    TCPIP_INFO      tiTcpIpInfo;
    TCHAR           szFloppyClientName[MAX_PATH+1];
    UINT            uExitMessages[MAX_EXITMSG];
} NCDU_DATA, *PNCDU_DATA;

typedef struct _COPY_FILE_DLG_STRUCT {
    LPTSTR      szDisplayName;
    LPTSTR      szSourceDir;
    LPTSTR      szDestDir;
    DWORD       dwCopyFlags;
    DWORD       dwTotalSize;
    DWORD       dwFilesCopied;
    DWORD       dwDirsCreated;
} CF_DLG_DATA, *PCF_DLG_DATA;

typedef struct _DIR_BROWSER_STRUCT {
    DWORD       dwTitle;    // dialog box title Resource ID: 0="Directory Browser"
    LPTSTR      szPath;     // initial path in and resulting path out
    DWORD       Flags;      // see below
} DB_DATA,  *PDB_DATA;

#define     PDB_FLAGS_NOCHECKDIR    0x00000001      // allow non-existent paths

typedef struct _SHARE_PATH_DLG_STRUCT {
    LPWSTR      szServer;
    LPWSTR      szPath;
    LPWSTR      szShareName;
    LPWSTR      szRemark;
} SPS_DATA, *PSPS_DATA;

typedef struct _FIND_DIST_TREE_STRUCT {
    LPTSTR      szPathBuffer;       // buffer to load found path in
    DWORD       dwPathBufferLen;    // size of path buffer (above)
    PLONG       plPathType;         // pointer to buffer recieving path type
    DWORD       dwSearchType;       // search type (see flags below)
} FDT_DATA, *PFDT_DATA;
#pragma pack(1)
typedef struct _DOS_BOOT_SECTOR {
    BYTE        bsJump[3];
    CHAR        bsOemName[8];
    WORD        bsBytesPerSec;
    BYTE        bsSecPerClust;
    WORD        bsResSectors;
    BYTE        bsFats;
    WORD        bsRootDirEnts;
    WORD        bsSectors;
    BYTE        bsMedia;
    WORD        bsFatSecs;
    WORD        bsSecsPerTrack;
    WORD        bsHeads;
    DWORD       bsHiddenSecs;
    DWORD       bsHugeSectors;
    BYTE        bsDriveNumber;
    BYTE        bsReserved1;
    BYTE        bsBootSignature;
    DWORD       bsVolumeId;
    CHAR        bsVolumeLabel[11];
    CHAR        bsFileSysType[8];
    BYTE        bsBootSectorBytes[1];
} DOS_BOOT_SECTOR, *PDOS_BOOT_SECTOR;
#pragma pack()

//
#define     FDT_CLIENT_TREE     (0x00000001)
#define     FDT_TOOLS_TREE      (0x00000002)

//
//  Directory Browser Flags
//
#define DBS_VALIDATE_PATH   0x00000001  // only allow valid paths
#define DBS_CLIENT_PATH     0x00000003  // only allow valid dist. paths

// global variables
// these are allocated and initialized in otnboot.c
//

extern PNCDU_DATA   pAppInfo;
#ifdef JAPAN
extern USHORT       usLangID;

//  fixed kkntbug #12382
//      NCAdmin:"[] Make Japanese startup disks" is not functioning.

extern BOOL         bJpnDisk;
#endif


//
// external function definitions
//
//
// *** UTILS.C ***
//
BOOL
GetShareFromUnc (
    IN  LPCTSTR  szPath,
    OUT LPTSTR   szShare
);

BOOL
GetNetPathInfo (
    IN  LPCTSTR szPath,
    OUT LPTSTR  szServer,
    OUT LPTSTR  szRemotePath
);

BOOL
ComputerPresent (
    IN  LPCTSTR     szMachine
);

BOOL
GetServerFromUnc (
    IN  LPCTSTR szPath,
    OUT LPTSTR  szServer
);

BOOL
MatchFirst (
    IN LPCTSTR   szStringA,
    IN LPCTSTR   szStringB
);

BOOL
LookupLocalShare (
    IN  LPCTSTR  szDrivePath,
    IN  BOOL    bExactMatch,
    OUT LPTSTR  szLocalPath,
    IN  PDWORD  pdwBuffLen
);

BOOL
LookupRemotePath (
    IN  LPCTSTR  szDrivePath,
    OUT LPTSTR  szRemotePath,
    IN  PDWORD  pdwBuffLen
);

BOOL
OnRemoteDrive (
    IN  LPCTSTR  szPath
);

DWORD
ComputeFreeSpace (
    IN  LPCTSTR  szPath
);

DWORD
GetSizeFromInfString (
    IN  LPCTSTR  szString
);

BOOL
IsShareNameUsed (
    IN      LPCTSTR szServerName,
    IN      LPCTSTR szShareName,
    IN  OUT PDWORD  pdwType,
    IN  OUT LPTSTR  pszPath
);

BOOL
SavePathToRegistry (
    LPCTSTR szPath,
    LPCTSTR szServerKey,
    LPCTSTR szShareKey
);

BOOL
Dlg_WM_SYSCOMMAND (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

LRESULT
Dlg_WM_MOVE (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

BOOL
Dlg_WM_PAINT (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

DWORD
QuietGetFileAttributes (
    IN  LPCTSTR szFileName
);

DWORD
QuietGetPrivateProfileString (
    IN  LPCTSTR lpszSection,
    IN  LPCTSTR lpszKey,
    IN  LPCTSTR lpszDefault,
    OUT LPTSTR  lpszReturnBuffer,
    IN  DWORD   cchReturnBuffer,
    IN  LPCTSTR lpszFile
);

BOOL
GetSizeOfDirs (
    IN  LPCTSTR szPath,
    IN  BOOL    bFlags,
    IN  OUT PDWORD  pdwSize
);
#define GSOD_INCLUDE_SUBDIRS    0x00000001

BOOL
MediaPresent (
    IN  LPCTSTR szPath,
    IN  BOOL    bCheckFormat
);

LPCTSTR
GetKeyFromEntry (
    IN  LPCTSTR  szEntry
);

LPCTSTR
GetItemFromEntry (
    IN  LPCTSTR  szEntry,
    IN  DWORD   dwItem

);

LPCTSTR
GetFileNameFromEntry (
    IN  LPCTSTR szEntry
);

BOOL
FileExists (
    IN  LPCTSTR   szFileName
);

//
//  *** FindClnt.C ***
//
LONG
GetDistributionPath (
    IN  HWND        hwndDlg,        // handle to dialog box window
    IN  DWORD       dwSearchType,   // type of dir to find: Client/tools
    IN  OUT LPTSTR  szPath,         // buffer to return path in (Req'd)
    IN  DWORD       dwPathLen,      // size of path buffer in chars
    IN  PLONG       plPathType      // pointer to buffer recieving path type (opt)
);
// path type
#define NCDU_NO_CLIENT_PATH_FOUND   0x00000000
#define NCDU_PATH_FROM_REGISTRY     0x00000001
#define NCDU_LOCAL_SHARE_PATH       0x00000002
#define NCDU_HARD_DRIVE_PATH        0x00000004
#define NCDU_CDROM_PATH             0x00000008

#ifdef JAPAN
// fixed kkntbug #11940
//    Network client administrator can not make install disks on PC with C drive as FD

#define NCDU_LOGICAL_DRIVE_MASK     0x00000001
#endif

INT_PTR CALLBACK
FindClientsDlgProc (
    IN  HWND    hwndDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

//
//  ShareNet.C
//
INT_PTR CALLBACK
ShareNetSwDlgProc (
    IN  HWND    hwndDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

//
//
//
LONG
CreateDirectoryFromPath (
    IN  LPCTSTR                 szPath,
    IN  LPSECURITY_ATTRIBUTES   lpSA
);

BOOL
IsPathADir (
    IN  LPCTSTR szPath
);

int
PositionWindow (
    IN  HWND    hwnd
);

LPCTSTR
GetNetErrorMsg (
    IN  LONG    lNetErr
);

BOOL
ShowAppHelp (
    IN  HWND    hwndDlg,
    IN  WORD    wContext
);

BOOL
SetSysMenuMinimizeEntryState (
    IN  HWND    hwnd,
    IN  BOOL    bState
);

BOOL
RemoveMaximizeFromSysMenu (
    IN  HWND    hWnd   // window handle
);

BOOL
IsBootDisk (
    IN  LPCTSTR  szPath
);

BOOL
TrimSpaces (
    IN  OUT LPTSTR  szString
);

DWORD
TranslateEscapeChars (
    IN  LPTSTR szNewString,
    IN  LPTSTR szString
);

BOOL
IsUncPath (
    IN  LPCTSTR  szPath
);

MEDIA_TYPE
GetDriveTypeFromPath (
    IN  LPCTSTR  szPath
);

MACHINE_TYPE
GetSystemType (
    VOID
);

LPCTSTR
GetEntryInMultiSz (
    IN  LPCTSTR   mszList,
    IN  DWORD   dwEntry

);

BOOL
RegisterMainWindowClass(
    IN  HINSTANCE   hInstance
);

DWORD
AddStringToMultiSz (
    LPTSTR OUT   mszDest,
    LPCTSTR IN    szSource
);

DWORD
StringInMultiSz (
    IN  LPCTSTR   szString,
    IN  LPCTSTR   mszList
);

LPCTSTR
GetStringResource (
    IN  UINT    nId
);

UINT
ValidSharePath (
    IN  LPCTSTR  szPath
);

UINT
ValidSrvToolsPath (
    IN  LPCTSTR  szPath
);

BOOL
DotOrDotDotDir (
    IN  LPCTSTR   szFileName
);

BOOL
LoadClientList (
    IN  HWND    hwndDlg,
    IN  int     nListId,
    IN  LPCTSTR  szPath,
    IN  UINT    nListType,
    OUT LPTSTR  mszDirList
);

BOOL
EnableExitMessage (
    IN  BOOL    bNewState
);

BOOL
AddMessageToExitList (
    IN  PNCDU_DATA  pData,
    IN  UINT        nMessage
);

BOOL
CenterWindow (
   HWND hwndChild,
   HWND hwndParent
);

int
DisplayMessageBox (
    IN  HWND    hWndOwner,
    IN  UINT    nMsgId,
    IN  UINT    nTitleId,
    IN  UINT    nStyle
);

VOID
InitAppData (
    IN  PNCDU_DATA   pData
);

LRESULT CALLBACK
MainWndProc (
    IN  HWND hWnd,         // window handle
    IN  UINT message,      // type of message
    IN  WPARAM uParam,     // additional information
    IN  LPARAM lParam      // additional information
);

INT_PTR CALLBACK
SwConfigDlgProc (
    IN  HWND    hwndDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

INT_PTR CALLBACK
TargetWsDlgProc (
    IN  HWND    hwndDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

INT_PTR CALLBACK
ServerConnDlgProc (
    IN  HWND    hwndDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

INT_PTR CALLBACK
LanManCfgDlgProc (
    IN  HWND    hwndDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

INT_PTR CALLBACK
CopyFlopDlgProc (
    IN  HWND    hwndDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

INT_PTR CALLBACK
CopyFileDlgProc (
    IN  HWND    hwndDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

INT_PTR CALLBACK
ConfirmSettingsDlgProc (
    IN  HWND    hwndDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

INT_PTR CALLBACK
ExitMessDlgProc (
    IN  HWND    hwndDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

INT_PTR CALLBACK
MakeFlopDlgProc (
    IN  HWND    hwndDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

INT_PTR CALLBACK
DirBrowseDlgProc (
    IN  HWND    hwndDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

INT_PTR CALLBACK
CopyNetUtilsDlgProc (
    IN  HWND    hwndDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

INT_PTR CALLBACK
SharePathDlgProc (
    IN  HWND    hwndDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

INT_PTR CALLBACK
SelToolsDlgProc (
    IN  HWND    hwndDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

INT_PTR CALLBACK
AboutDlgProc (
    IN  HWND    hwndDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);

BOOL
FormatDiskInDrive (
    IN  HWND    hWnd,           // "owning" window
    IN  TCHAR   cDrive,         // drive letter to format (only A or B)
    IN  LPCTSTR szLabel,        // label text
    IN  BOOL    bConfirmFormat  // prompt with "r-u-sure?" dialog
);

BOOL
LabelDiskInDrive (
    IN  HWND    hWnd,           // owner window
    IN  TCHAR   cDrive,         // drive letter to format (only A or B)
    IN  LPCTSTR szLabel         // label text
);

DWORD
GetBootDiskDosVersion (
   IN   LPCTSTR szPath
);

DWORD
GetMultiSzLen (
    IN  LPCTSTR     mszInString
);

DWORD
GetClusterSizeOfDisk (
    IN  LPCTSTR szPath
);

DWORD
QuietGetFileSize (
    IN  LPCTSTR szPath
);

#include    "otnbtstr.h"    // string constant definitions

#endif      //_otnboot_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\clcreator\netutils.c ===
/*++

    Copyright (c) 1994  Microsoft Corporation

Module Name:

    NetUtils.C

Abstract:

    File copy and sharing dialog

Author:

    Bob Watson (a-robw)

Revision History:

    17 Feb 94    Written

--*/
//
//  Windows Include Files
//

#include <windows.h>
#include <stdio.h>
#include <malloc.h>
#include <tchar.h>      // unicode macros
#include <stdlib.h>     // string to number conversions
#include <lmcons.h>     // lanman API constants
//
//  app include files
//
#include "otnboot.h"
#include "otnbtdlg.h"
//
//  local windows messages
//
#define NCDU_SHARE_DIR              (WM_USER    +101)
#define NCDU_VALIDATE_AND_END       (WM_USER    +103)
#define NCDU_BROWSE_DIST_PATH       (WM_USER    +104)
#define NCDU_BROWSE_DEST_PATH       (WM_USER    +105)
//
//  static variables
//
//
static  int     nNextDialog;            // select dialog to follow this on OK
static  BOOL    bShareNotCopy;          // select default button mode
//
//  these variables are used to remember the contents of the edit controls
//  that are disabled and/or blanked
//
static  TCHAR   szShareName1[MAX_PATH];
static  TCHAR   szDestPath[MAX_PATH];
static  TCHAR   szShareName2[MAX_PATH];
static  TCHAR   szServerName[MAX_PATH];
static  TCHAR   szShareName3[MAX_PATH];

static
UINT
GetRealToolSourcePath (
    IN  LPCTSTR szInPath,
    OUT LPTSTR szOutPath
)
/*++

Routine Description:

    checks the path in to see if it's a tool tree, if not, then it checks
        to see if it's a client tree with a tool tree in it and returns
        the name of the tool path found (if any) or an error message ID and
        an empty string if a tool path cannot be found

Arguments:

    IN  LPCTSTR szInPath,
        Initial path to check

    OUT LPTSTR szOutPath
        resulting tool path or empty string if no path found

Return Value:

    0 if success
    NCDU error message string ID if error or tree not found

--*/
{
    UINT    nResult;
    UINT    nFirstResult;
    LPTSTR  szNewPath;

    if (szOutPath == NULL) {
        return NCDU_UNABLE_READ_DIR;
    }

    if ((nResult = ValidSrvToolsPath(szInPath)) == 0) {
        // then the "in" path was a server tools path
        lstrcpy (szOutPath, szInPath);
        nResult = 0;
    } else {
        nFirstResult = nResult; // save for later
        // the "in" path is NOT a server tools path, so see if it's
        // a client tree
        if ((nResult = ValidSharePath(szInPath)) == 0) {
            // then this is a valid net client tree so see
            // if there's a srvtools dir 'underneath' it.
            szNewPath = (LPTSTR)GlobalAlloc(GPTR, MAX_PATH_BYTES);
            if (szNewPath != NULL) {
                // build new path
                lstrcpy (szNewPath, szInPath);
                if (szNewPath[lstrlen(szNewPath)-1] != cBackslash) {
                    lstrcat(szNewPath, cszBackslash);
                }
                lstrcat (szNewPath, cszSrvtoolsDir);
                // now test the new path
                if ((nResult = ValidSrvToolsPath(szNewPath)) == 0) {
                    // that worked so return it
                    lstrcpy (szOutPath, szNewPath);
                    nResult = 0; // success
                } else {
                    // this isn't a tools dir either so give up
                    // and return nResult from first call (from
                    // the original path)
                    nResult = nFirstResult;
                    *szOutPath = 0;
                }
                //release temporary memory buffer
                FREE_IF_ALLOC (szNewPath);
            } else {
                nResult = NCDU_ERROR_NOMEMORY;
                *szOutPath = 0;
            }
        } else {
            // return error from first call (szInPath)
            nResult = nFirstResult;
            *szOutPath = 0;
        }
    }

    return nResult;

}

static
LPCTSTR
GetDefaultDestPath (
    VOID
)
/*++

Routine Description:

    Creates a valid path to use as the default destination to copy the
        client files to from the CD. The routine finds the first valid
        local drive, then on that drive, finds the first permutation of
        "Clients\\srvtools" or "Clients\\srvtool[0-9]" that isn't currently on that drive.

Arguments:

    None

Return Value:

    Pointer to the read only string containing the resulting path or
        an empty string if a valid path could not be concocted.

--*/
{
    static TCHAR    szPathBuffer[MAX_PATH];
    BOOL            bFound;
    UINT            nDriveType;
    DWORD           dwFileAttrib;
    LPTSTR          szUniqueChar;

    // start by finding a valid disk drive

    szPathBuffer[0] = cC;
    szPathBuffer[1] = cColon;
    szPathBuffer[2] = cBackslash;
    szPathBuffer[3] = 0;

    bFound = FALSE;

    while (!bFound) {
        nDriveType = GetDriveType (szPathBuffer);
        if (nDriveType == DRIVE_FIXED) {
            bFound = TRUE;
        } else {
            // increment drive letter
            szPathBuffer[0]++;
            if (szPathBuffer[0] > cZ) break;
        }
    }

    if (!bFound) {
        // unable to find a suitable drive so bail out.
        szPathBuffer[0] = 0;
    } else {
        // found a suitable drive so add a directory
        lstrcat (szPathBuffer, cszToolsDir);
        szUniqueChar = &szPathBuffer[lstrlen(szPathBuffer)-1];
        *(szUniqueChar + 1) = 0;    // add extra null char
        bFound = FALSE;
        while (!bFound) {
            // the path is "found" when it references a non-
            // existent directory
            dwFileAttrib = QuietGetFileAttributes (szPathBuffer);
            if (dwFileAttrib == 0xFFFFFFFF) {
                bFound = TRUE;
            } else {
                if (*szUniqueChar == cs)  {
                    *szUniqueChar = c0;
                } else {
                    if (*szUniqueChar < c9)  {
                        *szUniqueChar += 1; // increment digit
                    } else {
                        // used up all the letters with out finding an
                        // unused dir so return an empty string
                        szPathBuffer[0] = 0;
                        break;
                    }
                }
            }
        }
    }
    return (LPCTSTR)&szPathBuffer[0];
}

static
LPCTSTR
GetDefaultShareName (
    IN  LPCTSTR szServer
)
/*++

Routine Description:

    Creates a share name to be used as a default share. If an unused
        name can be created, then it is returned, if all names are used,
        then an empty string is returned.

Arguments:

    IN  LPCTSTR szServer    pointer to the buffer containing the name of
                            the server on which to look up the share name.
                            if this parameter is NULL, then the local
                            machine is used.

Return Value:

    the pointer to a read-only buffer containing either the name of an
        unused share point or an empty string if such a name cannot be
        created.

--*/
{
    static TCHAR    szNameBuffer[MAX_PATH];

    LPTSTR  szLocalPath;
    LPTSTR  szShareName;
    LPTSTR  szShareIndex;
    TCHAR   cOrigIndexChar;
    DWORD   dwBufLen;
    DWORD   dwFileAttrib;
    BOOL    bFound;

    // allocate a local buffer for building dir path in
    szLocalPath = GlobalAlloc (GPTR, MAX_PATH_BYTES);

    if (szLocalPath == NULL) {
        // unable to allocate mem for local path buffer so return an
        // empty string and leave
        szNameBuffer[0] = 0;
    } else {
        // build a UNC path in the local buffer to test for the
        // existence of the share point
        *szLocalPath = 0;
        lstrcpy (szLocalPath, cszDoubleBackslash);
        if (szServer == NULL) {
            // then look up local computer name
            dwBufLen = MAX_COMPUTERNAME_LENGTH+1;
            GetComputerName (&szLocalPath[2], &dwBufLen);
        } else {
            // use server sent in path
            lstrcat (szLocalPath, szServer);
        }

        lstrcat (szLocalPath, cszBackslash);

        // save pointer to sharepoint name in UNC string

        szShareName = &szLocalPath[lstrlen(szLocalPath)];

        lstrcpy (szShareName, GetStringResource (CSZ_SETUP_ADM));

        // limit name to 8 characters
        if (lstrlen(szShareName) > 8) {
            szShareName[8] = 0;
        }

        // for uniqueness, count the last digit from 0 - 9
        if (lstrlen(szShareName) >= 7) {
            // overwrite the last character
            szShareIndex = &szShareName[7];
            cOrigIndexChar = *szShareIndex;
        } else {
            szShareIndex = &szShareName[lstrlen(szShareName)];
            cOrigIndexChar = 0;
        }

        *(szShareIndex + 1) = 0; // add extra terminating null char

        bFound = FALSE;

        while (!bFound) {
            dwFileAttrib = QuietGetFileAttributes (szLocalPath);
            if (dwFileAttrib == 0xFFFFFFFF) {
                bFound = TRUE;
            } else {
                // this share point already exists, so try the
                // next one in the sequence
                if (*szShareIndex == cOrigIndexChar) {
                    // this is the first retry
                    *szShareIndex = c0;
                } else {
                    if (*szShareIndex < c9) {
                        *szShareIndex += 1; // increment character
                    } else {
                        // all attempted names are in use so bail out with
                        // an empty buffer
                        break;
                    }
                }
            }
        }

        if (bFound) {
            // copy server name to output buffer
            lstrcpy (szNameBuffer, szShareName);
        } else {
            // a valid unused share name wasn't found, so return empty buffer
            szNameBuffer[0] = 0;
        }

        FREE_IF_ALLOC (szLocalPath);
    }

    return (LPCTSTR)&szNameBuffer[0];
}

static
DWORD
UpdateDiskSpace (
    IN  HWND    hwndDlg
)
/*++

 Routine Description:

    Computes and display the total estimated disk space required
        to copy the network utilities as read from the .INF

Arguments:

    IN  HWND    hwndDlg

Return Value:

    total bytes required (sum of all selected items)

--*/
{
    DWORD   dwBytesReqd = 0;
    LPTSTR  szFileInfo;
    LPTSTR  szInfName;

    szFileInfo = GlobalAlloc (GPTR, MAX_PATH_BYTES);
    szInfName = GlobalAlloc (GPTR, MAX_PATH_BYTES);

    if ((szFileInfo != NULL) && (szInfName != NULL)) {
        GetDlgItemText (hwndDlg, NCDU_DISTRIBUTION_PATH, szFileInfo, MAX_PATH);
        GetRealToolSourcePath (szFileInfo, szInfName);

        if (szInfName[lstrlen(szInfName)-1] != cBackslash) lstrcat(szInfName, cszBackslash);
        lstrcat (szInfName, cszSrvToolsInf);

        QuietGetPrivateProfileString (cszSizes, csz_ToolsTree_, cszEmptyString,
            szFileInfo, MAX_PATH, szInfName);

        dwBytesReqd = GetSizeFromInfString (szFileInfo);

        // reuse InfName buffer for output string
        // add 500,000 to bytes rquired in order to round M's up. (div
        // will simply truncate)

        _stprintf (szInfName, GetStringResource (FMT_M_BYTES),
            ((dwBytesReqd+500000)/1000000));
        SetDlgItemText (hwndDlg, NCDU_DISK_SPACE_REQD, szInfName);
    }

    FREE_IF_ALLOC(szFileInfo);
    FREE_IF_ALLOC(szInfName);

    return dwBytesReqd;
}

static
VOID
UpdateDialogMode (
    IN  HWND hwndDlg
)
/*++

Routine Description:

    Called to size the dialog box based on the currently selected
        mode. If the "Use existing share" mode is selected, then
        only the top half of the dialog box is visible, if the
        "copy" mode is selected then the entire dialog box is
        visible. All concealed controls are disabled for proper
        tab sequencing.

Arguments:

    IN  HWND    hwndDlg

Return Value:

    None

--*/
{
    BOOL    bUseExistingPath;
    BOOL    bShareFiles;
    BOOL    bCopyAndShare;
    BOOL    bUseExistingShare;
    BOOL    bEnablePath;

    // save any share/path information in case the fields have to be cleared

    EnableWindow (GetDlgItem (hwndDlg, NCDU_FILES_ALREADY_SHARED), TRUE);

    if ( SendDlgItemMessage (hwndDlg, NCDU_DESTINATION_PATH, WM_GETTEXTLENGTH, 0, 0) > 0) {
        GetDlgItemText (hwndDlg, NCDU_DESTINATION_PATH, szDestPath, MAX_PATH);
    }

    if ( SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_1, WM_GETTEXTLENGTH, 0, 0) > 0) {
        GetDlgItemText (hwndDlg, NCDU_SHARE_NAME_1, szShareName1, MAX_PATH);
    }

    if ( SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_2, WM_GETTEXTLENGTH, 0, 0) > 0) {
        GetDlgItemText (hwndDlg, NCDU_SHARE_NAME_2, szShareName2, MAX_PATH);
    }

    if ( SendDlgItemMessage (hwndDlg, NCDU_SERVER_NAME, WM_GETTEXTLENGTH, 0, 0) > 0) {
        GetDlgItemText (hwndDlg, NCDU_SERVER_NAME, szServerName, MAX_PATH);
    }

    if ( SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_3, WM_GETTEXTLENGTH, 0, 0) > 0) {
        GetDlgItemText (hwndDlg, NCDU_SHARE_NAME_3, szShareName3, MAX_PATH);
    }
    // buttons are mutually exclusive so only one of these can (should) be
    // true at a time

    bUseExistingPath =
        (BOOL)(IsDlgButtonChecked(hwndDlg, NCDU_USE_DIST_PATH) == CHECKED);

    bShareFiles =
        (BOOL)(IsDlgButtonChecked(hwndDlg, NCDU_USE_EXISTING_SHARE) == CHECKED);

    bCopyAndShare =
        (BOOL)(IsDlgButtonChecked(hwndDlg, NCDU_COPY_AND_MAKE_SHARE) == CHECKED);

    bUseExistingShare =
        (BOOL)(IsDlgButtonChecked(hwndDlg, NCDU_FILES_ALREADY_SHARED) == CHECKED);

    bEnablePath = !bUseExistingShare;

    // set the dialog to be approrpriate for the current button

    // set the path edit controls
    EnableWindow (GetDlgItem (hwndDlg, NCDU_TOP_PATH_TITLE), bEnablePath);
    EnableWindow (GetDlgItem (hwndDlg, NCDU_DISTRIBUTION_PATH), bEnablePath);
    EnableWindow (GetDlgItem (hwndDlg, NCDU_BROWSE_DIST), bEnablePath);

    // set the "Share Files" controls
    EnableWindow (GetDlgItem (hwndDlg, NCDU_SHARE_FILES_TEXT), bShareFiles);
    EnableWindow (GetDlgItem (hwndDlg, NCDU_SHARE_NAME_1_TITLE), bShareFiles);
    EnableWindow (GetDlgItem (hwndDlg, NCDU_SHARE_NAME_1), bShareFiles);

    if (bShareFiles) {
        SetDlgItemText (hwndDlg, NCDU_SHARE_NAME_1, szShareName1);
    } else {
        SetDlgItemText (hwndDlg, NCDU_SHARE_NAME_1, cszEmptyString);
    }

    // set the "Copy Files..." controls
    EnableWindow (GetDlgItem (hwndDlg, NCDU_DISK_SPACE_REQD), bCopyAndShare);
    EnableWindow (GetDlgItem (hwndDlg, NCDU_DISK_SPACE_REQD_LABEL), bCopyAndShare);
    EnableWindow (GetDlgItem (hwndDlg, NCDU_DESTINATION_PATH_LABEL), bCopyAndShare);
    EnableWindow (GetDlgItem (hwndDlg, NCDU_DESTINATION_PATH), bCopyAndShare);
    EnableWindow (GetDlgItem (hwndDlg, NCDU_SHARE_NAME_2_TITLE), bCopyAndShare);
    EnableWindow (GetDlgItem (hwndDlg, NCDU_SHARE_NAME_2), bCopyAndShare);

    if (bCopyAndShare) {
        SetDlgItemText (hwndDlg, NCDU_DESTINATION_PATH, szDestPath);
        SetDlgItemText (hwndDlg, NCDU_SHARE_NAME_2, szShareName2);
    } else {
        SetDlgItemText (hwndDlg, NCDU_DESTINATION_PATH, cszEmptyString);
        SetDlgItemText (hwndDlg, NCDU_SHARE_NAME_2, cszEmptyString);
    }

    // set "Use Existing Share..." controls
    EnableWindow (GetDlgItem (hwndDlg, NCDU_SERVER_NAME_TITLE), bUseExistingShare);
    EnableWindow (GetDlgItem (hwndDlg, NCDU_SERVER_NAME), bUseExistingShare);
    EnableWindow (GetDlgItem (hwndDlg, NCDU_SHARE_NAME_3_TITLE), bUseExistingShare);
    EnableWindow (GetDlgItem (hwndDlg, NCDU_SHARE_NAME_3), bUseExistingShare);

    if (bUseExistingShare) {
        SetDlgItemText (hwndDlg, NCDU_SERVER_NAME, szServerName);
        SetDlgItemText (hwndDlg, NCDU_SHARE_NAME_3, szShareName3);
    } else {
        SetDlgItemText (hwndDlg, NCDU_SERVER_NAME, cszEmptyString);
        SetDlgItemText (hwndDlg, NCDU_SHARE_NAME_3, cszEmptyString);
    }

    // redraw button box
    UpdateWindow (hwndDlg);
}

static
BOOL
CopyFilesFromDistToDest (
    IN  HWND    hwndDlg
)
/*++

Routine Description:

    copies the selected clients listed under the distribution directory
        to the destination directory.

Arguments:

    IN  HWND    hwndDlg
        handle to dialog box window

Return Value:

    TRUE if all went ok
    FALSE if the operation was aborted or ended in error.

--*/
{
    LPTSTR  szSourceDir;
    LPTSTR  szDestDir;
    DWORD   dwBytesReqd = 0;
    LPTSTR  szFileInfo;
    DWORD   dwCopyFlags = CD_FLAGS_COPY_SUB_DIR + CD_FLAGS_LONG_NAMES;
    LPTSTR  szClientName;
    LPTSTR  szInfName;
    LPTSTR  szDisplayString;
    int     nCopyResult;
    CF_DLG_DATA cfData;

    szSourceDir = GlobalAlloc (GPTR, MAX_PATH_BYTES);
    szDestDir = GlobalAlloc (GPTR, MAX_PATH_BYTES);
    szFileInfo = GlobalAlloc (GPTR, MAX_PATH_BYTES);
    szClientName = GlobalAlloc (GPTR, MAX_PATH_BYTES);
    szInfName = GlobalAlloc (GPTR, MAX_PATH_BYTES);

    if ((szSourceDir != NULL) &&
        (szDestDir != NULL) &&
        (szFileInfo != NULL) &&
        (szClientName != NULL) &&
        (szInfName != NULL)) {
        //    copy the files in the netutils dir to the specified path

        lstrcpy (szInfName, pAppInfo->szDistPath);
        if (szInfName[lstrlen(szInfName)-1] != cBackslash) lstrcat(szInfName, cszBackslash);
        lstrcat (szInfName, cszSrvToolsInf);

        // make source & dest pathnames
        lstrcpy (szSourceDir, pAppInfo->szDistPath);
        if (szSourceDir[lstrlen(szSourceDir)-1] == cBackslash) szSourceDir[lstrlen(szSourceDir)-1] = 0;

        // remove trailing backslash
        lstrcpy (szDestDir, pAppInfo->szDestPath);
        if (szDestDir[lstrlen(szDestDir)-1] == cBackslash) szDestDir[lstrlen(szDestDir)-1] = 0;

        // copy files
        lstrcpy (szClientName, GetStringResource (CSZ_COPYING_NET_UTILS));
        cfData.szDisplayName = szClientName;
        cfData.szSourceDir = szSourceDir;
        cfData.szDestDir = szDestDir;
        cfData.dwCopyFlags = CD_FLAGS_COPY_SUB_DIR | CD_FLAGS_LONG_NAMES;
        QuietGetPrivateProfileString (cszSizes, csz_ToolsTree_, cszEmptyString,
            szFileInfo, MAX_PATH, szInfName);
        // add to total
        cfData.dwTotalSize = GetSizeFromInfString (szFileInfo);
        cfData.dwFilesCopied = 0;
        cfData.dwDirsCreated = 0;

        nCopyResult = (int)DialogBoxParam (
            (HANDLE)GetWindowLongPtr(GetParent(hwndDlg), GWLP_HINSTANCE),
            MAKEINTRESOURCE(NCDU_COPYING_FILES_DLG),
            hwndDlg,
            CopyFileDlgProc,
            (LPARAM)&cfData);

        if (nCopyResult == IDOK) {
            szDisplayString = GlobalAlloc (GPTR, MAX_PATH_BYTES);
            if (szDisplayString == NULL) {
                // unable to allocate string buffer so try default message
                DisplayMessageBox (
                hwndDlg,
                NCDU_COPY_COMPLETE,
                0,
                MB_OK_TASK_INFO);
            } else {
                _stprintf (szDisplayString,
                    GetStringResource (FMT_COPY_COMPLETE_STATS),
                    cfData.dwDirsCreated, cfData.dwFilesCopied);
                MessageBox (
                    hwndDlg, szDisplayString,
                    GetStringResource (SZ_APP_TITLE),
                    MB_OK_TASK_INFO);
                FREE_IF_ALLOC (szDisplayString);
            }
        }
    } else {
        nCopyResult = IDCANCEL;
    }

    FREE_IF_ALLOC (szSourceDir);
    FREE_IF_ALLOC (szDestDir);
    FREE_IF_ALLOC (szFileInfo);
    FREE_IF_ALLOC (szClientName);
    FREE_IF_ALLOC (szInfName);

    return (nCopyResult == IDOK ? TRUE : FALSE);
}

static
BOOL
CopyNetUtilsDlg_WM_INITDIALOG (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Processes the WM_INITDIALOG windows message. Loads the controls
        with the values from the application data structure and
        initializes the display mode (i.e. the dlg box size)

Arguments:

    IN  HWND    hwndDlg
        Handle to the dialog box window

    IN  WPARAM  wParam
        Not Used

    IN  LPARAM  lParam
        Not Used

Return Value:

    FALSE

--*/
{
    LPTSTR  szDlgDistPath;
    DWORD   dwShareType;

    RemoveMaximizeFromSysMenu (hwndDlg);
    PositionWindow  (hwndDlg);

    szDlgDistPath = GlobalAlloc(GPTR, MAX_PATH_BYTES);
    if (szDlgDistPath == NULL) {
        EndDialog (hwndDlg, IDCANCEL);
        return FALSE;
    }

    //
    //  Determine next message for EndDialog Return based on
    //  installation to perform
    //

    nNextDialog = NCDU_SHOW_SW_CONFIG_DLG;

    // get source path for client files
    if (*pAppInfo->szDistShowPath == 0) {
        // load default values if an existing source dir doesn't exist
        if (GetDistributionPath (hwndDlg, FDT_TOOLS_TREE,
            szDlgDistPath, MAX_PATH, &dwShareType) == ERROR_FILE_NOT_FOUND) {
            // tool tree not found so try client tree
            GetDistributionPath (hwndDlg, FDT_CLIENT_TREE,
                szDlgDistPath, MAX_PATH, &dwShareType);
        }
        //then initialize with a default value
        lstrcpy (pAppInfo->szDistShowPath, szDlgDistPath);
    } else {
        // on entry into the dialog box only shared TOOL dirs are allowed
        // if the user wants to use the root client dir rather than the
        // actual tool dir later, that's OK, but here it's got to be the
        // real thing!
        if (ValidSrvToolsPath (pAppInfo->szDistShowPath) == 0) {
            lstrcpy (pAppInfo->szDistPath, pAppInfo->szDistShowPath);
            // a valid path is already loaded
            if (IsUncPath(pAppInfo->szDistShowPath)) {
                dwShareType = NCDU_LOCAL_SHARE_PATH;
            } else {
                dwShareType = NCDU_HARD_DRIVE_PATH;
            }
        } else {
            // lookup a default path to use
            if (GetDistributionPath (hwndDlg, FDT_TOOLS_TREE,
                szDlgDistPath, MAX_PATH, &dwShareType) == ERROR_FILE_NOT_FOUND) {
                // tool tree not found so try client tree
                GetDistributionPath (hwndDlg, FDT_CLIENT_TREE,
                    szDlgDistPath, MAX_PATH, &dwShareType);
            }
            //then initialize with a default value
            lstrcpy (pAppInfo->szDistShowPath, szDlgDistPath);
        }
    }

    // load fields using data from data structure

    SetDlgItemText (hwndDlg, NCDU_DISTRIBUTION_PATH, pAppInfo->szDistShowPath);
    SetDlgItemText (hwndDlg, NCDU_DESTINATION_PATH, pAppInfo->szDestPath);

    // set edit box text limits
    SendDlgItemMessage (hwndDlg, NCDU_DISTRIBUTION_PATH,
        EM_LIMITTEXT, (WPARAM)(MAX_PATH-1), (LPARAM)0);

    SendDlgItemMessage (hwndDlg, NCDU_DESTINATION_PATH,
        EM_LIMITTEXT, (WPARAM)(MAX_PATH-1), (LPARAM)0);

    SendDlgItemMessage (hwndDlg, NCDU_SERVER_NAME,
        EM_LIMITTEXT, (WPARAM)(MAX_COMPUTERNAME_LENGTH), (LPARAM)0);

    SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_1,
        EM_LIMITTEXT, (WPARAM)(MAX_SHARENAME-1), (LPARAM)0);

    SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_2,
        EM_LIMITTEXT, (WPARAM)(MAX_SHARENAME-1), (LPARAM)0);

    SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_3,
        EM_LIMITTEXT, (WPARAM)(MAX_SHARENAME-1), (LPARAM)0);

    // initialize field variables
    lstrcpy (szShareName1, GetDefaultShareName(NULL));
    lstrcpy (szShareName2, GetDefaultShareName(NULL));
    lstrcpy (szDestPath, GetDefaultDestPath());
    SetDlgItemText (hwndDlg, NCDU_SHARE_NAME_1, szShareName1);
    SetDlgItemText (hwndDlg, NCDU_DESTINATION_PATH, szDestPath);
    SetDlgItemText (hwndDlg, NCDU_SHARE_NAME_2, szShareName2);

    // set dialog state to appropriate value
    bShareNotCopy = (dwShareType == NCDU_CDROM_PATH ? FALSE : TRUE);

    switch (dwShareType) {
        case NCDU_NO_CLIENT_PATH_FOUND:
            // no path found
            CheckRadioButton (hwndDlg,
                NCDU_USE_DIST_PATH,
                NCDU_FILES_ALREADY_SHARED,
                NCDU_USE_EXISTING_SHARE);
            SendDlgItemMessage (hwndDlg, NCDU_DISTRIBUTION_PATH,
                EM_SETSEL, (WPARAM)0, (LPARAM)-1);
            SetFocus (GetDlgItem(hwndDlg, NCDU_DISTRIBUTION_PATH));
            break;

        case NCDU_HARD_DRIVE_PATH:
            // path found on hard drive so default is to share
            CheckRadioButton (hwndDlg,
                NCDU_USE_DIST_PATH,
                NCDU_FILES_ALREADY_SHARED,
                NCDU_USE_EXISTING_SHARE);
            SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_1,
                EM_SETSEL, (WPARAM)0, (LPARAM)-1);
            SetFocus (GetDlgItem(hwndDlg, NCDU_SHARE_NAME_1));
            break;

        case NCDU_CDROM_PATH:
            // path found on CD-ROM so default is to copy & share
            CheckRadioButton (hwndDlg,
                NCDU_USE_DIST_PATH,
                NCDU_FILES_ALREADY_SHARED,
                NCDU_COPY_AND_MAKE_SHARE);
            SendDlgItemMessage (hwndDlg, NCDU_DESTINATION_PATH,
                EM_SETSEL, (WPARAM)0, (LPARAM)-1);
            SetFocus (GetDlgItem(hwndDlg, NCDU_DESTINATION_PATH));
            break;

        case NCDU_PATH_FROM_REGISTRY:
        case NCDU_LOCAL_SHARE_PATH:
            // path already shared
            CheckRadioButton (hwndDlg,
                NCDU_USE_DIST_PATH,
                NCDU_FILES_ALREADY_SHARED,
                NCDU_FILES_ALREADY_SHARED);
            if (GetServerFromUnc (pAppInfo->szDistShowPath, szDlgDistPath)) {
                _tcsupr(szDlgDistPath);
                lstrcpy (szServerName, szDlgDistPath);
                SetDlgItemText (hwndDlg, NCDU_SERVER_NAME, szDlgDistPath);
                if (GetShareFromUnc (pAppInfo->szDistShowPath, szDlgDistPath)) {
                    lstrcpy (szShareName3, szDlgDistPath);
                    SetDlgItemText (hwndDlg, NCDU_SHARE_NAME_3, szDlgDistPath);
                } else {
                    // unable to look up share point so go back to dist path
                    SetDlgItemText (hwndDlg, NCDU_SERVER_NAME, cszEmptyString);
                    CheckRadioButton (hwndDlg,
                        NCDU_USE_DIST_PATH,
                        NCDU_FILES_ALREADY_SHARED,
                        NCDU_USE_EXISTING_SHARE);
                }
            } else {
                // unable to look up server, so go back to dist path
                SetDlgItemText (hwndDlg, NCDU_SERVER_NAME, cszEmptyString);
                CheckRadioButton (hwndDlg,
                    NCDU_USE_DIST_PATH,
                    NCDU_FILES_ALREADY_SHARED,
                    NCDU_USE_EXISTING_SHARE);
            }
            SetFocus (GetDlgItem (hwndDlg, IDOK));
            break;
    }

    UpdateDiskSpace(hwndDlg);
    UpdateDialogMode (hwndDlg);

    PostMessage (GetParent(hwndDlg), NCDU_CLEAR_DLG, (WPARAM)hwndDlg, IDOK);
    PostMessage (GetParent(hwndDlg), NCDU_REGISTER_DLG,
        NCDU_COPY_NET_UTILS_DLG, (LPARAM)hwndDlg);

    SetCursor(LoadCursor(NULL, IDC_ARROW));

    FREE_IF_ALLOC (szDlgDistPath);
    return FALSE;
}

static
BOOL
CopyNetUtilsDlg_NCDU_SHARE_DIR (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam, // not used
    IN  LPARAM  lParam  // pointer to SPS_DATA block
)
/*++

Routine Description:

    Shares the Distribution dir path.
        Uses the share name entered in the display. If
        successful this message terminates the dialog box, otherwise
        an error message will be displayed.

Arguments:

    IN  HWND    hwndDlg
        Handle to dialog box window

    IN  WPARAM  wParam
        Not Used

    IN  LPARAM  lParam
        pointer to SPS_DATA block

Return Value:

    TRUE if dir shared
    FALSE if not (GetLastError for info)

--*/
{
    PSPS_DATA   pspData;
    LPWSTR      szTempMachineName = NULL;
    int         nDlgBoxStatus;

    pspData = (PSPS_DATA)lParam;

    if (*pspData->szServer != cBackslash) {
        szTempMachineName = GlobalAlloc (GPTR, MAX_PATH_BYTES);
        if (szTempMachineName != NULL) {
            lstrcpy (szTempMachineName, cszDoubleBackslash);
            lstrcat (szTempMachineName, pspData->szServer);
            pspData->szServer = szTempMachineName;
        }
    }

    nDlgBoxStatus = (int)DialogBoxParam (
        (HINSTANCE)GetWindowLongPtr(hwndDlg, GWLP_HINSTANCE),
        MAKEINTRESOURCE (NCDU_DLG_SHARING_PATH),
        hwndDlg,
        SharePathDlgProc,
        lParam);

    FREE_IF_ALLOC (szTempMachineName);

    return (nDlgBoxStatus == IDOK ? TRUE : FALSE);
}

static
BOOL
CopyNetUtilsDlg_IDOK (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Processes the IDOK button depending on the mode selected. If the
        copy files mode is selected, then the source, destination and
        clients are validated and the files are copied. If the share
        distribution mode is selected, then the directory path is
        shared on the local machine.

        The validation consists of the following:

        FILES_ALREADY_SHARED: (bottom button)
            Get Server Name
                must be non blank
                must be name of machine on network
            Get Sharepoint Name
                must be non-blank
                must exist on above server
                signal if > DOS compatible name length
            \\server\share must be a valid server tools directory tree

        Use the distribution path: (any of the top buttons)
            Check Destination path
                must be non-blank
                must be a valid server tools directory tree

            SHARE DISTRIBUTION_PATH:
                Get share name
                    must be non-blank
                        if blank, then dest path must already be shared
                          or a UNC path
                    must not be in use
                    signal if > DOS compatible name length
                    Signal if name is in currently in use
                        user may either use current name or change

            COPY AND SHARE:
                Get Destination Path
                    must be non-blank

                Get share name
                    must be non-blank
                    must not be in use
                    signal if > DOS compatible name length
                    Signal if name is in currently in use

                Check disk space on destination machine
                Copy files from distribution to destination dir's
                If copy  went OK, then update dlg fields and share

Arguments:

    IN HWND hwndDlg

Return Value:

    TRUE if the message is processed by this routine
    FALSE if not

--*/
{
    LPTSTR  szDlgDistPath;
    LPTSTR  szDlgDestPath;
    LPTSTR  szPathBuff;
    LPTSTR  szMsgBuff;
    LPTSTR  szSharePath;
    TCHAR   szDlgShareName[MAX_SHARENAME];
    TCHAR   szServerName[MAX_COMPUTERNAME_LENGTH+1];
    UINT    nDirMsg;
    BOOL    bShareDest;
    DWORD   dwBytesToCopy;
    DWORD   dwShareType;
    SPS_DATA    spData;
    LPTSTR  szShareName;
    int     nMbResult;
    BOOL    bFinishOff = FALSE;

    switch (HIWORD(wParam)) {
        case BN_CLICKED:
            SetCursor(LoadCursor(NULL, IDC_WAIT));

            szDlgDistPath = GlobalAlloc (GPTR, MAX_PATH_BYTES);
            szDlgDestPath = GlobalAlloc (GPTR, MAX_PATH_BYTES);
            szPathBuff = GlobalAlloc (GPTR, MAX_PATH_BYTES);
            szMsgBuff = GlobalAlloc (GPTR, SMALL_BUFFER_SIZE * sizeof(TCHAR));
            szSharePath = GlobalAlloc (GPTR, MAX_PATH_BYTES);

            if ((szDlgDistPath != NULL) &&
                (szDlgDestPath != NULL) &&
                (szMsgBuff != NULL) &&
                (szSharePath != NULL) &&
                (szPathBuff != NULL)) {
                if (IsDlgButtonChecked(hwndDlg, NCDU_FILES_ALREADY_SHARED) == CHECKED) {
                    // use server & share found in the group box
                    // make UNC from server & share found in dialog box
                    lstrcpy (szDlgDistPath, cszDoubleBackslash);
                    GetDlgItemText (hwndDlg, NCDU_SERVER_NAME,
                        &szDlgDistPath[2], MAX_COMPUTERNAME_LENGTH+1);
                    TrimSpaces (&szDlgDistPath[2]);
                    if (lstrlen (&szDlgDistPath[2]) == 0) {
                        DisplayMessageBox (
                            hwndDlg,
                            NCDU_NO_SERVER,
                            0,
                            MB_OK_TASK_EXCL);
                        SetDlgItemText (hwndDlg, NCDU_SERVER_NAME,
                            &szDlgDistPath[2]);
                        SetFocus (GetDlgItem (hwndDlg, NCDU_SERVER_NAME));
                        SendDlgItemMessage (hwndDlg, NCDU_SERVER_NAME,
                            EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                        goto IDOK_ExitClicked;
                    }
                    if (ComputerPresent (szDlgDistPath)) {
                        lstrcat (szDlgDistPath, cszBackslash);
                        szShareName = &szDlgDistPath[lstrlen(szDlgDistPath)];
                        GetDlgItemText (hwndDlg, NCDU_SHARE_NAME_3,
                            szShareName, MAX_SHARENAME+1);
                        TrimSpaces(szShareName);
                        SetDlgItemText (hwndDlg, NCDU_SHARE_NAME_3,
                            szShareName);
                        if (lstrlen(szShareName) > LM20_DEVLEN) {
                            nMbResult = DisplayMessageBox (
                                hwndDlg,
                                NCDU_NOT_DOS_SHARE,
                                0,
                                MB_OKCANCEL_TASK_EXCL_DEF2);
                            if (nMbResult == IDCANCEL) {
                                // they pressed cancel, so go back to the offending share  and
                                // try again
                                SetFocus (GetDlgItem (hwndDlg, NCDU_SHARE_NAME_3));
                                SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_3,
                                    EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                                goto IDOK_ExitClicked;
                            }
                            // if here the user want's to keep the share name so continue
                        }
                        if (lstrlen(szShareName) == 0) {
                            DisplayMessageBox (
                                hwndDlg,
                                NCDU_NO_SHARE_NAME,
                                0,
                                MB_OK_TASK_EXCL);
                            SetFocus (GetDlgItem (hwndDlg, NCDU_SHARE_NAME_3));
                            SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_3,
                                EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                            goto IDOK_ExitClicked;
                        }
                        if (szDlgDistPath[lstrlen(szDlgDistPath)-1] != cBackslash)
                            lstrcat (szDlgDistPath, cszBackslash);
                        dwShareType =  ValidSrvToolsPath (szDlgDistPath);
                        if (dwShareType == 0) {
                            // valid, so copy to dist path and exit
                            lstrcpy (pAppInfo->szDistShowPath, szDlgDistPath);
                            bFinishOff = TRUE;
                        } else {
                            // unable to locate sharepoint
                            DisplayMessageBox (
                                hwndDlg,
                                dwShareType,
                                0,
                                MB_OK_TASK_EXCL);

                            SetFocus (GetDlgItem (hwndDlg, NCDU_SHARE_NAME_3));
                            SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_3,
                                EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                        }
                    } else {
                        // unable to locate server
                        DisplayMessageBox (
                            hwndDlg,
                            NCDU_SERVER_NOT_PRESENT,
                            0,
                            MB_OK_TASK_EXCL);

                        SetFocus (GetDlgItem (hwndDlg, NCDU_SERVER_NAME));
                        SendDlgItemMessage (hwndDlg, NCDU_SERVER_NAME,
                            EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                    }
                } else {
                    // they want to use the path in the edit box so
                    // validate distribution directory path
                    GetDlgItemText (hwndDlg, NCDU_DISTRIBUTION_PATH, szDlgDistPath, MAX_PATH);
                    TrimSpaces (szDlgDistPath);
                    if (lstrlen(szDlgDistPath) == 0) {
                        // no source path
                        DisplayMessageBox (
                            hwndDlg,
                            NCDU_PATH_CANNOT_BE_BLANK,
                            0,
                            MB_OK_TASK_EXCL);
                        // set focus and leave so the user can correct
                        SetFocus (GetDlgItem (hwndDlg, NCDU_DISTRIBUTION_PATH));
                        SendDlgItemMessage (hwndDlg, NCDU_DISTRIBUTION_PATH,
                            EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                        goto IDOK_ExitClicked;
                    }

                    if ((nDirMsg = GetRealToolSourcePath(
                        szDlgDistPath, pAppInfo->szDistPath)) != 0) {
                        // error in Distribution path
                        DisplayMessageBox (
                            hwndDlg,
                            nDirMsg,
                            0,
                            MB_OK_TASK_EXCL);
                        // error in directory path so set focus to directory entry
                        SendDlgItemMessage (hwndDlg, NCDU_DISTRIBUTION_PATH,
                            EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                        SetFocus (GetDlgItem(hwndDlg, NCDU_DISTRIBUTION_PATH));
                        SendDlgItemMessage (hwndDlg, NCDU_DISTRIBUTION_PATH,
                            EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                        goto IDOK_ExitClicked;
                    }

                    // distribution path is valid so save the path
                    // and the server and then continue
                    lstrcpy (pAppInfo->szDistShowPath, szDlgDistPath);

                    if (IsDlgButtonChecked(hwndDlg, NCDU_USE_EXISTING_SHARE) == CHECKED) {
                        // then they want to share the path in the edit box
                        GetNetPathInfo (pAppInfo->szDistPath, szServerName,
                            szSharePath);

                        if ((*szServerName == 0) || (*szSharePath == 0)) {
                            // unable to get path information
                            DisplayMessageBox (
                                hwndDlg,
                                NCDU_UNABLE_GET_PATH_INFO,
                                0,
                                MB_OK_TASK_EXCL);
                            SetFocus (GetDlgItem(hwndDlg, NCDU_DISTRIBUTION_PATH));
                            SendDlgItemMessage (hwndDlg, NCDU_DISTRIBUTION_PATH,
                                EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                            goto IDOK_ExitClicked;
                        }

                        // share the path in the source name edit control

                        GetDlgItemText (hwndDlg, NCDU_SHARE_NAME_1, szDlgShareName, MAX_SHARENAME);
                        TrimSpaces (szDlgShareName);
                        // update edit field in case we need to come back
                        SetDlgItemText (hwndDlg, NCDU_SHARE_NAME_1, szDlgShareName);

                        if (lstrlen(szDlgShareName) > LM20_DEVLEN) {
                            nMbResult = DisplayMessageBox (
                                hwndDlg,
                                NCDU_NOT_DOS_SHARE,
                                0,
                                MB_OKCANCEL_TASK_EXCL_DEF2);
                            if (nMbResult == IDCANCEL) {
                                // they pressed cancel, so go back to the offending share  and
                                // try again
                                SetFocus (GetDlgItem (hwndDlg, NCDU_SHARE_NAME_1));
                                SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_1,
                                    EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                                goto IDOK_ExitClicked;
                            }
                            // if here the user want's to keep the share name so continue
                        }
                        if (lstrlen(szDlgShareName) == 0) {
                            // no share name specified so display error and
                            // exit
                            DisplayMessageBox (
                                hwndDlg,
                                NCDU_NO_SHARE_NAME,
                                0,
                                MB_OK_TASK_EXCL);
                            SetFocus (GetDlgItem(hwndDlg,
                                NCDU_SHARE_NAME_1));
                            SendDlgItemMessage (hwndDlg,
                                NCDU_SHARE_NAME_1,
                                EM_SETSEL, (WPARAM)0,
                                (LPARAM)-1);
                            goto IDOK_ExitClicked;
                        } else {
                            // there is a share name so try to share the source path
                            if (IsShareNameUsed (szServerName, szDlgShareName,
                                &dwShareType, szPathBuff)) {
                                if (dwShareType == NCDU_SHARE_IS_SERVER_TOOLS) {
                                    // then this is the name of a shared client
                                    // dir tree already, so tell the user about it
                                    _stprintf (szMsgBuff,
                                        GetStringResource (FMT_SHARE_IS_TOOLS_DIR),
                                        szDlgShareName, szServerName, szPathBuff);
                                    if (MessageBox (hwndDlg, szMsgBuff,
                                        GetStringResource (SZ_APP_TITLE),
                                        MB_OKCANCEL_TASK_EXCL_DEF2) == IDOK) {
                                        // use the existing path and share name
                                        lstrcpy (pAppInfo->szDistShowPath, cszDoubleBackslash);
                                        lstrcat (pAppInfo->szDistShowPath, szServerName);
                                        lstrcat (pAppInfo->szDistShowPath, cszBackslash);
                                        lstrcat (pAppInfo->szDistShowPath, szDlgShareName);
                                        lstrcat (pAppInfo->szDistShowPath, cszBackslash);
                                        lstrcpy (pAppInfo->szDistPath, pAppInfo->szDistShowPath);
                                        SetDlgItemText (hwndDlg, NCDU_DISTRIBUTION_PATH, pAppInfo->szDistShowPath);
                                        SetDlgItemText (hwndDlg, NCDU_SHARE_NAME_1, cszEmptyString);
                                        // that's it then, so exit
                                        bFinishOff = TRUE;
                                    } else {
                                        // they want to try again
                                        SetFocus (GetDlgItem (hwndDlg, NCDU_SHARE_NAME_1));
                                        SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_1,
                                            EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                                        goto IDOK_ExitClicked;
                                    }
                                } else {
                                    // this is the name of some other shared
                                    // directory so tell the user
                                    _stprintf (szMsgBuff,
                                        GetStringResource (FMT_SHARE_IS_ALREADY_USED),
                                        szDlgShareName, szServerName, szPathBuff);
                                    MessageBox (hwndDlg, szMsgBuff,
                                        GetStringResource (SZ_APP_TITLE),
                                        MB_OK_TASK_EXCL);
                                    SetFocus (GetDlgItem (hwndDlg, NCDU_SHARE_NAME_1));
                                    SendDlgItemMessage (hwndDlg,
                                        NCDU_SHARE_NAME_1,
                                        EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                                    goto IDOK_ExitClicked;
                                }
                            } else {
                                // share name isn't in use, so go ahead and share it
                                // try to share
                                lstrcpy (szMsgBuff, GetStringResource (FMT_SHARE_TOOLS_REMARK));
                                spData.szServer = szServerName;
                                spData.szPath = szSharePath;
                                spData.szShareName = szDlgShareName;
                                spData.szRemark = szMsgBuff;
                                if (CopyNetUtilsDlg_NCDU_SHARE_DIR (hwndDlg,
                                    (WPARAM)0, (LPARAM)&spData)) {
                                    // shared successfully so
                                    //  make new UNC for distribution path
                                    //  then exit
                                    lstrcpy (pAppInfo->szDistShowPath, cszDoubleBackslash);
                                    lstrcat (pAppInfo->szDistShowPath, szServerName);
                                    lstrcat (pAppInfo->szDistShowPath, cszBackslash);
                                    lstrcat (pAppInfo->szDistShowPath, szDlgShareName);
                                    lstrcpy (pAppInfo->szDistPath, pAppInfo->szDistShowPath);
                                    SetDlgItemText (hwndDlg, NCDU_DISTRIBUTION_PATH,
                                        pAppInfo->szDistShowPath);
                                    bFinishOff = TRUE;
                                } else {
                                    // unable to share dir, error has been
                                    // signaled via message box already
                                    SetFocus (GetDlgItem(hwndDlg,
                                        NCDU_SHARE_NAME_1));
                                    SendDlgItemMessage (hwndDlg,
                                        NCDU_SHARE_NAME_1,
                                        EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                                }
                            }
                        } // end if sharename has some text
                    } else if (IsDlgButtonChecked(hwndDlg, NCDU_COPY_AND_MAKE_SHARE) == CHECKED) {
                        // copy the files from the distribution path to the destination
                        // path then share the destination path
                        // check destination string
                        GetDlgItemText (hwndDlg, NCDU_DESTINATION_PATH, szDlgDestPath, MAX_PATH);
                        TrimSpaces (szDlgDestPath);
                        SetDlgItemText (hwndDlg, NCDU_DESTINATION_PATH, szDlgDestPath);
                        if (lstrlen(szDlgDestPath) == 0) {
                            // destination path is empty so go back and try again
                            // no source path
                            DisplayMessageBox (
                                hwndDlg,
                                NCDU_PATH_CANNOT_BE_BLANK,
                                0,
                                MB_OK_TASK_EXCL);
                            // set focus and leave so the user can correct
                            SetFocus (GetDlgItem (hwndDlg, NCDU_DESTINATION_PATH));
                            SendDlgItemMessage (hwndDlg, NCDU_DESTINATION_PATH,
                                EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                            goto IDOK_ExitClicked;
                        } else {
                            // there's a string in the destination so
                            // trim and copy to global struct
                            lstrcpy (pAppInfo->szDestPath, szDlgDestPath);
                            // see if there's a share name
                            GetDlgItemText (hwndDlg, NCDU_SHARE_NAME_2,
                                szDlgShareName, MAX_SHARENAME);
                            TrimSpaces (szDlgShareName);
                            SetDlgItemText (hwndDlg, NCDU_SHARE_NAME_2,
                                szDlgShareName);
                            if (lstrlen(szDlgShareName) > LM20_DEVLEN) {
                                nMbResult = DisplayMessageBox (
                                    hwndDlg,
                                    NCDU_NOT_DOS_SHARE,
                                    0,
                                    MB_OKCANCEL_TASK_EXCL_DEF2);
                                if (nMbResult == IDCANCEL) {
                                    // they pressed cancel, so go back to the offending share  and
                                    // try again
                                    SetFocus (GetDlgItem (hwndDlg, NCDU_SHARE_NAME_2));
                                    SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_2,
                                        EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                                    goto IDOK_ExitClicked;
                                }
                                // if here the user want's to keep the share name so continue
                            }
                            if (lstrlen(szDlgShareName) == 0) {
                                // no share name so display error and
                                // bail out
                                DisplayMessageBox (
                                    hwndDlg,
                                    NCDU_NO_SHARE_NAME,
                                    0,
                                    MB_OK_TASK_EXCL);
                                SetFocus (GetDlgItem(hwndDlg,
                                    NCDU_SHARE_NAME_2));
                                SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_2,
                                    EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                                goto IDOK_ExitClicked;
                            } else {
                                GetNetPathInfo (pAppInfo->szDestPath,
                                    szServerName,
                                    szSharePath);

                                if ((*szServerName == 0) || (*szSharePath == 0)) {
                                    // unable to get path information
                                    DisplayMessageBox (
                                        hwndDlg,
                                        NCDU_UNABLE_GET_PATH_INFO,
                                        0,
                                        MB_OK_TASK_EXCL);
                                    SetFocus (GetDlgItem (hwndDlg, NCDU_DESTINATION_PATH));
                                    SendDlgItemMessage (hwndDlg, NCDU_DESTINATION_PATH,
                                        EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                                    goto IDOK_ExitClicked;
                                }

                                if (IsShareNameUsed (szServerName, szDlgShareName,
                                    &dwShareType, szPathBuff)) {
                                    // this is the name of some other shared
                                    // directory so tell the user
                                    _stprintf (szMsgBuff,
                                        GetStringResource (FMT_SHARE_IS_ALREADY_USED),
                                        szDlgShareName, szServerName, szPathBuff);
                                    MessageBox (hwndDlg, szMsgBuff,
                                        GetStringResource (SZ_APP_TITLE),
                                        MB_OK_TASK_EXCL);
                                    SetFocus (GetDlgItem (hwndDlg, NCDU_SHARE_NAME_2));
                                    SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_2,
                                        EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                                    goto IDOK_ExitClicked;
                                } else {
                                    // indicate that the destination dir
                                    // should be shared after the files have been
                                    // copied.
                                    bShareDest = TRUE;
                                }
                            }
                            // so at this point there's a destination dir and
                            // a share name if one's needed. finally we need to
                            // see if any client's have been selected to be
                            // copied.

                            dwBytesToCopy = UpdateDiskSpace(hwndDlg);

                            if (dwBytesToCopy == 0) {
                                DisplayMessageBox (
                                    hwndDlg,
                                    NCDU_NO_CLIENTS_SELECTED,
                                    0,
                                    MB_OK_TASK_EXCL);
                                SetFocus (GetDlgItem(hwndDlg, NCDU_DISTRIBUTION_PATH));
                                SendDlgItemMessage (hwndDlg, NCDU_DISTRIBUTION_PATH,
                                    EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                                goto IDOK_ExitClicked;
                            }
                            // there's clients selected, now see if they'll fit
                            if (ComputeFreeSpace(pAppInfo->szDestPath) < dwBytesToCopy) {
                                DisplayMessageBox (
                                    hwndDlg,
                                    NCDU_INSUFFICIENT_DISK_SPACE,
                                    0,
                                    MB_OK_TASK_EXCL);
                                SetFocus (GetDlgItem(hwndDlg, NCDU_DESTINATION_PATH));
                                SendDlgItemMessage (hwndDlg, NCDU_DESTINATION_PATH,
                                    EM_SETSEL, (WPARAM)0, (LPARAM)-1);

                                goto IDOK_ExitClicked;
                            }
                            // so there should be enough free space
                            if (CopyFilesFromDistToDest (hwndDlg)) {
                                // copy was successful so
                                // copy destination name to distribution name
                                lstrcpy (pAppInfo->szDistShowPath,
                                    pAppInfo->szDestPath);
                                lstrcpy (pAppInfo->szDistPath,
                                    pAppInfo->szDestPath);
                                *pAppInfo->szDestPath = 0;
                                // update dialog box fields
                                SetDlgItemText (hwndDlg, NCDU_DISTRIBUTION_PATH,
                                    pAppInfo->szDistShowPath);
                                SetDlgItemText (hwndDlg, NCDU_DESTINATION_PATH,
                                    pAppInfo->szDestPath);
                                // since the files have been successfully copied and
                                // and the paths have been transposed (i.e. dest is now
                                // dist) update the button state so that if a sharing
                                // error occurs, the files won't have to be copied again
                                CheckRadioButton (hwndDlg,
                                    NCDU_USE_DIST_PATH,
                                    NCDU_FILES_ALREADY_SHARED,
                                    NCDU_USE_EXISTING_SHARE);

                                bShareNotCopy = TRUE;
                                UpdateDialogMode (hwndDlg);
                                //
                                // then share the destination dir (which is now
                                // in the distribution path)
                                if (bShareDest) {
                                    lstrcpy (szMsgBuff, GetStringResource (FMT_SHARE_TOOLS_REMARK));
                                    spData.szServer = szServerName; // local machine
                                    spData.szPath = szSharePath;
                                    spData.szShareName = szDlgShareName;
                                    spData.szRemark = szMsgBuff;
                                    if (CopyNetUtilsDlg_NCDU_SHARE_DIR (hwndDlg,
                                        (WPARAM)0, (LPARAM)&spData)) {
                                        // shared successfully so
                                        //  make new UNC for distribution path
                                        //  then exit
                                        lstrcpy (pAppInfo->szDistShowPath, cszDoubleBackslash);
                                        lstrcat (pAppInfo->szDistShowPath, szServerName);
                                        lstrcat (pAppInfo->szDistShowPath, cszBackslash);
                                        lstrcat (pAppInfo->szDistShowPath, szDlgShareName);
                                        lstrcpy (pAppInfo->szDistPath, pAppInfo->szDistShowPath);
                                        SetDlgItemText (hwndDlg, NCDU_DISTRIBUTION_PATH,
                                            pAppInfo->szDistShowPath);
                                        bFinishOff = TRUE;
                                    } else {
                                        // the share operation failed, but was
                                        // already signaled.
                                        SetFocus (GetDlgItem (hwndDlg, NCDU_SHARE_NAME_1));
                                        SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_1,
                                            EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                                    }
                                } else {
                                    // just leave
                                    bFinishOff = TRUE;
                                }
                            } else {
                                // copy was not successful, but error has
                                // already been signaled to the user
                                SetFocus (GetDlgItem (hwndDlg, NCDU_DESTINATION_PATH));
                                SendDlgItemMessage (hwndDlg, NCDU_DESTINATION_PATH,
                                    EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                            }
                        } // end if there's a destination directory entry
                    } else { // end if copy and share is checked
                        bFinishOff = TRUE;
                    }
                }// end if files not already shared
            } // end if memory allocation was successful

IDOK_ExitClicked:
            FREE_IF_ALLOC(szDlgDistPath);
            FREE_IF_ALLOC(szDlgDestPath);
            FREE_IF_ALLOC(szMsgBuff);
            FREE_IF_ALLOC(szPathBuff);
            FREE_IF_ALLOC(szSharePath);

            if (bFinishOff) {
                PostMessage (hwndDlg, NCDU_VALIDATE_AND_END,
                    (WPARAM)FALSE, (LPARAM)0);
            } else {
                SetCursor (LoadCursor(NULL, IDC_ARROW));
            }
            return TRUE;

        default:
            return FALSE;
    }
}

static
BOOL
CopyNetUtilsDlg_WM_COMMAND (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Processes the WM_COMMAND windows message in response to user input.
        Dispatches to the appropriate routine based on the control that
        was selected.

Arguments:

    IN  HWND    hwndDlg
        Handle to dialog box window

    IN  WPARAM  wParam
        LOWORD  has id of control sending the message
        HIWORD  has the notification code (if applicable)

    IN  LPARAM  lParam
        Not Used

Return Value:

    TRUE if message not processed by this routine, otherwise the value
        returned by the dispatched routine

--*/
{
    switch (LOWORD(wParam)) {
        case IDOK:      return CopyNetUtilsDlg_IDOK (hwndDlg, wParam, lParam);
        case IDCANCEL:
            switch (HIWORD(wParam)) {
                case BN_CLICKED:
                    PostMessage (GetParent(hwndDlg), NCDU_SHOW_SW_CONFIG_DLG, 0, 0);
                    SetCursor(LoadCursor(NULL, IDC_WAIT));
                    return TRUE;

                default:
                    return FALSE;
            }

        case NCDU_BROWSE_DIST:
            switch (HIWORD(wParam)) {
                case BN_CLICKED:
                    PostMessage (hwndDlg, NCDU_BROWSE_DIST_PATH, 0, 0);
                    SetCursor(LoadCursor(NULL, IDC_WAIT));
                    return TRUE;

                default:
                    return FALSE;
            }


        case NCDU_USE_DIST_PATH:
        case NCDU_USE_EXISTING_SHARE:
        case NCDU_COPY_AND_MAKE_SHARE:
        case NCDU_FILES_ALREADY_SHARED:
            // these buttons don't send a notification message
            UpdateDiskSpace (hwndDlg);
            UpdateDialogMode (hwndDlg);
            return TRUE;

        case NCDU_DISTRIBUTION_PATH:
            switch (HIWORD(wParam)) {
                case EN_KILLFOCUS:
                    UpdateDiskSpace (hwndDlg);
                    return TRUE;

                default:
                    return FALSE;
            }

        case NCDU_SHARE_NET_SW_DLG_HELP:
            switch (HIWORD(wParam)) {
                case BN_CLICKED:
//                    return ShowAppHelp (hwndDlg, LOWORD(wParam));
                    return PostMessage (GetParent(hwndDlg), WM_HOTKEY,
                        (WPARAM)NCDU_HELP_HOT_KEY, 0);

                default:
                    return FALSE;
            }

        default:
            return FALSE;
    }
}

static
BOOL
CopyNetUtilsDlg_NCDU_BROWSE_DIST_PATH (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Displays the file /dir browser to find distribution path entry

Arguments:

    IN  HWND    hwndDlg
        Handle to dialog box window

    IN  WPARAM  wParam
        Not Used

    IN  LPARAM  lParam
        Not Used

Return Value:

    TRUE

--*/
{
    DB_DATA BrowseInfo;
    LPTSTR  szTempPath;

    szTempPath = GlobalAlloc (GPTR, (MAX_PATH_BYTES + sizeof(TCHAR)));

    if (szTempPath == NULL) return TRUE;

    GetDlgItemText (hwndDlg, NCDU_DISTRIBUTION_PATH, szTempPath, MAX_PATH);

    BrowseInfo.dwTitle = NCDU_BROWSE_TOOL_DIST_PATH;
    BrowseInfo.szPath = szTempPath;
    BrowseInfo.Flags = 0;

    if (DialogBoxParam (
        (HINSTANCE)GetWindowLongPtr(hwndDlg, GWLP_HINSTANCE),
        MAKEINTRESOURCE(NCDU_DIR_BROWSER),
        hwndDlg,
        DirBrowseDlgProc,
        (LPARAM)&BrowseInfo) == IDOK) {

        SetDlgItemText (hwndDlg, NCDU_DISTRIBUTION_PATH, szTempPath);
    }
    SetFocus (GetDlgItem (hwndDlg, NCDU_DISTRIBUTION_PATH));

    FREE_IF_ALLOC (szTempPath);
    return TRUE;
}

static
BOOL
CopyNetUtilsDlg_NCDU_VALIDATE_AND_END (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Performs all validation and field updates before exiting the
        dialog to the nNextDialog. If all validations are successful
        then the EndDialog is called, otherwise the function returns
        to the dialog box after displaying an error message and
        setting the focus to the offending control if necessary.

Arguments:

    IN  HWND    hwndDlg
        Handle to dialog box window

    IN  WPARAM  wParam
        Not Used

    IN  LPARAM  lParam
        Not Used

Return Value:

    FALSE

--*/
{

    BOOL    bSharedOk = FALSE;
    LPTSTR  szDlgDistPath;
    DWORD   dwBufLen;

    szDlgDistPath = GlobalAlloc (GPTR, MAX_PATH_BYTES);

    if (szDlgDistPath == NULL) return TRUE;

    // copy the app data to the local path for validation

    GetRealToolSourcePath (pAppInfo->szDistShowPath, szDlgDistPath);

    // just validate the dist path (look up sharepoint) an continue
    if (!IsUncPath(szDlgDistPath)) {
        // dos file spec
        if (!OnRemoteDrive(szDlgDistPath)) {
             // dir is on local machine
            if (pAppInfo->itInstall == CopyNetAdminUtils) {
                dwBufLen = (DWORD)GlobalSize(szDlgDistPath);
                if (!LookupLocalShare(szDlgDistPath, TRUE, pAppInfo->szDistPath, &dwBufLen)) {
                    // not shared so display error
                    DisplayMessageBox (hwndDlg,
                        NCDU_NO_SHARE_NAME,
                        0,
                        MB_OK_TASK_EXCL);
                    bSharedOk = FALSE;
                } else {
                    lstrcpy (pAppInfo->szDistPath, szDlgDistPath);
                    bSharedOk = TRUE;
                }
            } else {
                lstrcpy (pAppInfo->szDistPath, szDlgDistPath);
                bSharedOk = TRUE;
            }
        } else {
            // dir is on remote drive so translate to UNC
            dwBufLen = (DWORD)GlobalSize(szDlgDistPath);
            LookupRemotePath (szDlgDistPath, pAppInfo->szDistPath, &dwBufLen);
            bSharedOk = TRUE;
        }
    } else {
        // dist path is UNC name so copy it
        lstrcpy (pAppInfo->szDistPath, szDlgDistPath);
        bSharedOk = TRUE;
    }

    if (bSharedOk) {
        SetCursor(LoadCursor(NULL, IDC_ARROW));
        DisplayMessageBox (hwndDlg,
            NCDU_NETUTILS_SHARED,
            0,
            MB_OK_TASK_INFO);
        //
        //  save the path in the registry for next time
        //
        SavePathToRegistry (pAppInfo->szDistPath,
            cszLastToolsServer,
            cszLastToolsSharepoint);
        PostMessage (GetParent(hwndDlg), (int)NCDU_SHOW_SW_CONFIG_DLG, 0, 0);
        SetCursor(LoadCursor(NULL, IDC_WAIT));
    }

    FREE_IF_ALLOC (szDlgDistPath);

    return TRUE;
}

INT_PTR CALLBACK
CopyNetUtilsDlgProc (
    IN  HWND    hwndDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Main Dialog message procedure. Dispatches to the appropriate routine
        to process the following windows messages:

            WM_INITDIALOG:              Dialog box initialization
            WM_COMMAND:                 User Input
            NCDU_SHARE_DIR:             shares the specified dir to the net

        all other windows messages are handled by the default dialog proc.

Arguments:

    Standard WNDPROC args

Return Value:

    FALSE if the message is not processed by this module, otherwise
        the value returned by the dispatched routine.

--*/
{
    switch (message) {
        case WM_INITDIALOG:     return (CopyNetUtilsDlg_WM_INITDIALOG (hwndDlg, wParam, lParam));
        case WM_COMMAND:        return (CopyNetUtilsDlg_WM_COMMAND (hwndDlg, wParam, lParam));
        case NCDU_SHARE_DIR:    return (CopyNetUtilsDlg_NCDU_SHARE_DIR (hwndDlg, wParam, lParam));
        case NCDU_BROWSE_DIST_PATH:
                                return (CopyNetUtilsDlg_NCDU_BROWSE_DIST_PATH (hwndDlg, wParam, lParam));
        case NCDU_VALIDATE_AND_END:
                                return (CopyNetUtilsDlg_NCDU_VALIDATE_AND_END (hwndDlg, wParam, lParam));
        case WM_PAINT:      return (Dlg_WM_PAINT (hwndDlg, wParam, lParam));
        case WM_MOVE:       return (Dlg_WM_MOVE (hwndDlg, wParam, lParam));
        case WM_SYSCOMMAND: return (Dlg_WM_SYSCOMMAND (hwndDlg, wParam, lParam));
        default:            return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\clcreator\otnbtdlg.h ===
#define NCDU_OVER_THE_NET           121
#define NCDU_FLOPPY_INSTALL         122
#define NCDU_SW_CONFIG_DLG          100
#define NCDU_TARGET_WS_DLG          200
#define NCDU_35HD_DISK              202
#define NCDU_525HD_DISK             203
#define NCDU_SW_CONFIG_HELP         1001
#define NCDU_TARGET_WS_HELP         1002
#define NCDU_NETCARD_COMBO_BOX      206
#define NCDU_TARGET_DRIVEPATH       212
#define NCDU_SERVER_CFG_DLG         300
#define NCDU_TCPIP_INFO_FRAME       302
#define NCDU_PROTOCOL_COMBO_BOX     305
#define NCDU_FLOPPY_DOMAIN_LABEL    306
#define NCDU_FLOPPY_DOMAIN          307
#define NCDU_FLOPPY_USERNAME_LABEL  308
#define NCDU_FLOPPY_USERNAME        309
#define NCDU_FLOPPY_IP_ADDR_LABEL   310
#define NCDU_FLOPPY_IP_ADDR         311
#define NCDU_FLOPPY_SUBNET_LABEL    312
#define NCDU_FLOPPY_SUBNET_MASK     313
#define NCDU_SERVER_CONN_CFG_HELP   1003
#define NCDU_CREATE_INSTALL_DISKS_DLG 500
#define NCDU_MAKE_DISKS             504
#define NCDU_DRIVE_LIST             506
#define NCDU_CREATE_INSTALL_DISKS_HELP 1005
#define NCDU_SHARE_NET_SW_DLG       600
#define NCDU_USE_EXISTING_SHARE     606
#define NCDU_COPY_AND_MAKE_SHARE    607
#define NCDU_DISTRIBUTION_PATH      609
#define NCDU_CLIENT_SOFTWARE_LIST   611
#define NCDU_SHARE_NAME_1           616
#define NCDU_DESTINATION_PATH       617
#define NCDU_SHARE_NET_SW_DLG_HELP  1006
#define NCDU_DISK_SPACE_REQD_LABEL  618
#define NCDU_DISK_SPACE_REQD        619
#define NCDU_COPYING_FILES_DLG      700
#define NCDU_FROM_PATH              703
#define NCDU_TO_PATH                704
#define NCDU_CONFIRM_BOOTDISK_DLG   800
#define NCDU_CONFIRM_PROTOCOL       814
#define NCDU_EXIT_MESSAGE_DLG       900
#define NCDU_CONTINUE_MESSAGE       901
#define NCDU_NETCARD_COMBO_BOX_LABEL 205
#define NCDU_TARGET_DRIVEPATH_LABEL 211
#define NCDU_CONFIRM_DISK_FORMAT    802
#define NCDU_CONFIRM_TARGET_NET     804
#define NCDU_PERCENT_COMPLETE       705
#define NCDU_COPY_APPNAME           706
#define NCDU_CLIENT_SOFTWARE_LIST_LABEL 214
#define NCDU_FLOPPY_COMPUTER_NAME   303
#define NCDU_USE_DHCP               314
#define NCDU_DEFAULT_GATEWAY        315
#define NCDU_DEFAULT_GATEWAY_LABEL  316
#define NCDU_BROWSE                 0x025a
#define NCDU_COPY_NET_ADMIN_UTILS   123
#define NCDU_DESTINATION_PATH_LABEL 0x0262
#define NCDU_DIR_BROWSER            0x03e8
#define NCDU_DIRECTORY_LABEL        0x03f1
#define NCDU_DIR_LIST               0x03f4
#define NCDU_DIR_PATH               0x03ef
#define NCDU_BROWSE_DIST            0x0264
#define NCDU_EXIT                   109
#define NCDU_BROWSE_NETWORK         1004
#define NCDU_COPY_NET_UTILS_DLG     1100
#define NCDU_REMOTEBOOT_INFO        124
#define NCDU_DLG_SHARING_PATH       1300
#define NCDU_CTL_SHARING_PATH_AS    1301
#define NCDU_SHARE_NAME_1_TITLE     601
#define NCDU_TOP_PATH_TITLE         650
#define NCDU_SHARE_NAME_2           613
#define NCDU_SHARE_NAME_2_TITLE     614
#define NCDU_SERVER_NAME            621
#define NCDU_SHARE_NAME_3           622
#define NCDU_SERVER_NAME_TITLE      623
#define NCDU_SHARE_NAME_3_TITLE     624
#define NCDU_FORMAT_DISKS           502
#define NCDU_NUM_DISKS_REQUIRED     505
#define NCDU_FILES_ALREADY_SHARED   608
#define NCDU_ICON_INFORMATION       1011
#define NCDU_ABOUT_DLG              400
#define NCDU_ABOUT_ICON             401
#define NCDU_APP_ICON               402
#define NCDU_FINDING_CLIENT_DIRS_DLG  1600
#define NCDU_ICON_CONTROL           1602
#define NCDU_CLIENT_SEARCH_PHASE    1603
#define NCDU_SEARCH_TYPE_TITLE      1601
#define NCDU_SHARE_FILES_TEXT       604
#define NCDU_USE_DIST_PATH          605
#define NCDU_DRIVE_LIST_LABEL       1010
#define CANCELDLG                   2000
#define IDD_TEXT                    2001
#define IDD_GASGAUGE                2002
#define NCDU_CTL_SHARING_PATH_NAME  1305
#define NCDU_CTL_SHARING_PATH_ON    1306
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\clcreator\otnbtstr.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    otnbtstr.H

Abstract:

    string constant definitions for the Net Client Disk Utility.

Author:

    Bob Watson (a-robw)

Revision History:

    17 Feb 94    Written


--*/
#ifndef     _otnbtstr_H_
#define     _otnbtstr_H_
//
//  ncadmin.c strings
//
extern LPCTSTR  szAppName;
//
//  copyflop.c format strings
//
extern LPCTSTR cszNames;
extern LPCTSTR cszLabel;
//
//  makeflop.c format strings
//
extern LPCTSTR fmtNetcardEntry;
extern LPCTSTR fmtTcpTransportEntry;
extern LPCTSTR fmtNdisTransportEntry;
extern LPCTSTR fmtTransportItem;
extern LPCTSTR fmtLana0Entry;
extern LPCTSTR fmtLana1Entry;
extern LPCTSTR fmtIniSection;
extern LPCTSTR fmtIniKeyEntry;
extern LPCTSTR fmtCmntIniKeyEntry;
extern LPCTSTR fmtProtmanSection;
extern LPCTSTR fmtBindingsEntry;
extern LPCTSTR fmtXifEntry;
extern LPCTSTR fmtLanabase0;
extern LPCTSTR fmtNoFilesharing;
extern LPCTSTR fmtNoPrintsharing;
extern LPCTSTR fmtYesAutologon;
extern LPCTSTR fmtComputernameEntry;
extern LPCTSTR fmtLanaRootOnA;
extern LPCTSTR fmtUsernameEntry;
extern LPCTSTR fmtWorkgroupEntry;
extern LPCTSTR fmtNoReconnect;
extern LPCTSTR fmtNoDirectHost;
extern LPCTSTR fmtNoDosPopHotKey;
extern LPCTSTR fmtLmLogon0;
extern LPCTSTR fmtLmLogon1;
extern LPCTSTR fmtLogonDomainEntry;
extern LPCTSTR fmtPreferredRedirBasic;
extern LPCTSTR fmtAutostartBasic;
extern LPCTSTR fmtPreferredRedirFull;
extern LPCTSTR fmtAutostartFull;
extern LPCTSTR fmtMaxConnections;
extern LPCTSTR fmtNetworkDriversSection;
extern LPCTSTR fmtNetcardDefEntry;
extern LPCTSTR fmtTransportDefEntry;
extern LPCTSTR fmtNetbeuiAddon;
extern LPCTSTR fmtDevdir;
extern LPCTSTR fmtLoadRmDrivers;
extern LPCTSTR fmtPasswordListSection;
#ifdef JAPAN
extern LPCTSTR fmtPause;
#endif
extern LPCTSTR fmtPathSpec;
extern LPCTSTR fmtNetPrefix;
extern LPCTSTR fmtNetUseDrive;
extern LPCTSTR fmtSetupCommand;
extern LPCTSTR fmtFilesParam;
extern LPCTSTR fmtDeviceIfsHlpSys;
extern LPCTSTR fmtLastDrive;
extern LPCTSTR fmtEmptyParam;
extern LPCTSTR fmtIpParam;
extern LPCTSTR fmtAutoexec;
extern LPCTSTR fmtNBSessions;
extern LPCTSTR fmtLoadHiMem;
extern LPCTSTR fmtLoadEMM386;
extern LPCTSTR fmtDosHigh;
#ifdef JAPAN
extern LPCTSTR fmtBilingual;
extern LPCTSTR fmtFontSys;
extern LPCTSTR fmtDispSys;
extern LPCTSTR fmtKeyboard;
extern LPCTSTR fmtNlsFunc;
#endif
//
//  servconn.c format strings
//
extern LPCTSTR fmtRandomName;
extern LPCTSTR fmtIpAddr;
extern LPCTSTR fmtIpAddrParse;
extern LPCTSTR cszZeroNetAddress;
#ifdef JAPAN
extern LPCTSTR fmtWinntUs;
extern LPCTSTR fmtAppendUs;
#endif
//
//  findclnt.c
//
extern LPCTSTR cszToolsDir;
extern LPCTSTR cszSrvtoolsDir;
extern LPCTSTR cszClientsDir;
//
//  exitmess.c format strings
//
extern LPCTSTR fmtLeadingSpaces;
//
//  INF file strings
//
extern LPCTSTR cszOTNCommonFiles;
#ifdef JAPAN
extern LPCTSTR cszOTNDOSVFiles;
extern LPCTSTR cszDOSV;
extern LPCTSTR cszDOSVLabel1;
extern LPCTSTR cszDOSVLabel2;
extern LPCTSTR cszDOSVCommonFiles;
#endif
extern LPCTSTR cszNetworkSetup;
extern LPCTSTR cszInfVersion;
extern LPCTSTR cszNdis2;
extern LPCTSTR cszDrivername;
extern LPCTSTR cszProtmanInstall;
extern LPCTSTR cszNetdir;
extern LPCTSTR cszProtman;
extern LPCTSTR cszMsNdisHlp;
extern LPCTSTR cszMsNdisHlpXif;
extern LPCTSTR cszNetworkSection;
extern LPCTSTR cszDirs;
extern LPCTSTR cszDontShowDirs;
extern LPCTSTR cszSizes;
extern LPCTSTR cszOtnInstall;
extern LPCTSTR cszClient;
extern LPCTSTR cszInf;
extern LPCTSTR cszNetcard;
extern LPCTSTR cszOEMInfs;
extern LPCTSTR cszOTN;
extern LPCTSTR cszDiskSet;
extern LPCTSTR cszCopyClients;
extern LPCTSTR csz_ClientTree_;
extern LPCTSTR csz_ToolsTree_;
extern LPCTSTR csz_SystemFileSize_;
extern LPCTSTR cszWarningClients;
extern LPCTSTR cszCaption;
extern LPCTSTR cszDiskOptions;
extern LPCTSTR cszUseCleanDisk;
extern LPCTSTR cszUseCleanDiskYes;
//
//  "hardcoded" filenames
//
extern LPCTSTR cszAppInfName;
extern LPCTSTR cszOtnBootInf;
extern LPCTSTR cszSrvToolsInf;
extern LPCTSTR cszConfigSys;
extern LPCTSTR cszAutoexecBat;
extern LPCTSTR cszSystemIni;
extern LPCTSTR cszProtocolIni;
extern LPCTSTR cszNetUtils;
extern LPCTSTR cszSrvToolSigFile;
extern LPCTSTR cszNetMsgDll;
extern LPCTSTR fmtDiskNumber;

// files to look for in order to tell if it's bootable floppy

extern const LPCTSTR  szBootIdFiles[];

//
// "hardcoded" registry entries
//
extern LPCTSTR cszSystemProductOptions;
extern LPCTSTR cszProductType;
extern LPCTSTR cszLanmanNt;
extern LPCTSTR cszWinNt;
extern LPCTSTR cszNetDriveListKeyName;
extern LPCTSTR cszRemotePathValue;
extern LPCTSTR cszLanmanServerShares;
extern LPCTSTR cszPath;
extern LPCTSTR cszSoftwareMicrosoft;
extern LPCTSTR cszCurrentVersion;
extern LPCTSTR cszSoftwareType;
extern LPCTSTR cszTransport;
extern LPCTSTR cszTitle;
extern LPCTSTR cszProtocol;
extern LPCTSTR cszUserInfoKey;
extern LPCTSTR cszLastClientServer;
extern LPCTSTR cszLastClientSharepoint;
extern LPCTSTR cszLastToolsServer;
extern LPCTSTR cszLastToolsSharepoint;
//
//  miscellaneous strings
//
extern LPCTSTR cszNet;
extern LPCTSTR cszLanManager;
extern LPCTSTR cszMSNetworkClient;
extern LPCTSTR cszTCP;
extern LPCTSTR cszNetbeui;
extern LPCTSTR cszBackslash;
extern LPCTSTR cszWildcardFile;
extern LPCTSTR cszWildcard;
extern LPCTSTR cszEmptyString;
extern LPCTSTR cszAColon;
extern LPCTSTR cszBColon;
#ifdef JAPAN
// fixed kkntbug #11940
//    Network client administrator can not make install disks on PC with C drive as FD

extern LPCTSTR cszLastDrive;
extern LPCTSTR cszColon;
#endif
extern LPCTSTR cszDisksSubDir;
extern LPCTSTR csz12M;
extern LPCTSTR csz144;
extern LPCTSTR cszCR;
extern LPCTSTR cszCrLf;
extern LPCTSTR cszComma;
extern LPCTSTR cszDot;
extern LPCTSTR cszDotDot;
extern LPCTSTR cszDoubleBackslash;
extern LPCTSTR cszADriveRoot;
extern LPCTSTR cszBDriveRoot;
extern LPCTSTR cszBrowseFilterList;
extern LPCTSTR cszBrowseDistPathTitle;
extern LPCTSTR cszBrowseDestPathTitle;
extern LPCTSTR cszBrowseCopyDestPathTitle;
extern LPCTSTR cszTcpKey;
extern LPCTSTR cszTcpIpEntry;
extern LPCTSTR cszNetbeuiKey;
extern LPCTSTR cszNetbeuiEntry;
extern LPCTSTR cszIpxKey;
extern LPCTSTR cszIpxEntry;
extern LPCTSTR cszNetsetup;
extern LPCTSTR cszDisks;
extern LPCTSTR cszDisk;
extern LPCTSTR cszSetupCmd;
extern LPCTSTR cszDefaultGateway;
extern LPCTSTR cszSubNetMask;
extern LPCTSTR cszIPAddress;
extern LPCTSTR cszDisableDHCP;
extern LPCTSTR cszTcpIpDriver;
extern LPCTSTR csz1;
extern LPCTSTR csz0;
extern LPCTSTR cszBindings;
extern LPCTSTR cszHelpFile;
#ifdef TERMSRV
extern LPCTSTR cszHelpFileNameKey;
extern LPCTSTR cszHelpSession;
#endif // TERMSRV
extern LPCTSTR cszWfwDir;
extern LPCTSTR cszWin95Dir;
extern LPCTSTR cszDebug;
extern LPCTSTR csz2Spaces;
extern LPCTSTR cszPoundSign;
extern LPCTSTR cszDefaultLocalizer;
extern LPCTSTR cszFrame;
extern LPCTSTR cszTokenRing;
extern LPCTSTR cszTokenRingEntry;
//
//  miscellaneous character constants
//
#define c0              TEXT('0')
#define c9              TEXT('9')
#define cA              TEXT('A')
#define ca              TEXT('a')
#define cb              TEXT('b')
#define cC              TEXT('C')
#define cc              TEXT('c')
#define cm              TEXT('m')
#define cs              TEXT('s')
#define cZ              TEXT('Z')
#define cz              TEXT('z')
//
#define cBackslash      TEXT('\\')
#define cEqual          TEXT('=')
#define cComma          TEXT(',')
#define cDoubleQuote    TEXT('\"')
#define cColon          TEXT(':')
#define cSpace          TEXT(' ')
#define cPeriod         TEXT('.')
#define cPound          TEXT('#')
#endif  // _otnbtstr_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\clcreator\makeflop.c ===
/*++

    Copyright (c) 1994  Microsoft Corporation

Module Name:

    MakeFLOP.C

Abstract:

    Boot Floppy disk creation setup dialog

Author:

    Bob Watson (a-robw)

Revision History:

    17 Feb 94    Written

--*/
//
//  Windows Include Files
//

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <tchar.h>      // unicode macros
//
//  app include files
//
#include "otnboot.h"
#include "otnbtdlg.h"

// local windows message

#define     NCDU_START_FILE_COPY    (WM_USER +1)

#ifdef JAPAN
//
//  For DOS/V setup disk define
//
#define     SETUP_DOSV_1	1
#define     SETUP_DOSV_2	2
#endif

//
//  Module Static Data
//
static  BOOL    bCopying;    // TRUE when copying files, FALSE to abort

static
BOOL
IsZeroIpAddr (
    IN  PUSHORT pwIpVal
)
/*++

Routine Description:

    evaluates an IP address array structure to determine if it's all
        zeroes

Arguments:

    IN  PUSHORT pwIpVal
        pointer to an IP address array of integers

Return Value:

    TRUE if all 4 elements in the array are 0, otherwise
    FALSE

--*/
{
    PUSHORT pwTest;
    int     nElem;

    pwTest = pwIpVal;
    nElem = 0;
    while (nElem < 4) {
        if (*pwTest == 0) {
            pwTest++;
            nElem++;
        } else {
            return FALSE;
        }
    }
    return TRUE;
}

static
LPCTSTR
GetDirPathFromUnc (
    IN  LPCTSTR  szPath
)
/*++

Routine Description:

    Parses the Directories from a UNC path specification, removing the
        Server and share point.

Arguments:

    IN LPCTSTR   szPath
        pointer to a zero terminated UNC path specification.

Return Value:

    Pointer to somewhere in the string passed in the argument list where
        the directory path begins or a pointer to an empty string if
        the path specified contains only a server and sharepoint.

--*/
{
    int nSlashCount = 0;

    LPTSTR  szPathPtr;

    szPathPtr = (LPTSTR)szPath;

    if (IsUncPath(szPath)) {
        while (szPathPtr != 0) {
            if (*szPathPtr == cBackslash) nSlashCount++;
            ++szPathPtr;
            if (nSlashCount == 4) {
                break;  // exit loop
            }
        }
    }

    if (nSlashCount != 4) {
        return cszEmptyString;
    } else {
        return szPathPtr;
    }
}

static
BOOL
GetServerAndSharepointFromUnc (
    IN  LPCTSTR  szPath,
    OUT LPTSTR  szServer
)
/*++

Routine Description:

    copies only the server and share point to the buffer provided
        by the caller.

Arguments:

    IN  LPCTSTR  szPath
        UNC path to parse

    OUT LPCTSTR  szServer
        buffer provided to receive the Server and sharepoint. The buffer
        is assumed to be large enough to recieve the data.

Return Value:

    TRUE    if successful
    FALSE   if error

--*/
{
    int nSlashCount = 0;

    LPTSTR  szPathPtr;
    LPTSTR  szServPtr;

    szPathPtr = (LPTSTR)szPath;
    szServPtr = szServer;

    if (IsUncPath(szPath)) {
        while (szPathPtr != 0) {
            if (*szPathPtr == cBackslash) nSlashCount++;
            if (nSlashCount < 4) {
                *szServPtr++ = *szPathPtr++;
            } else {
                break;  // exit loop
            }
        }
    }

    *szServPtr = 0; // terminate server name

    if (szServPtr == szServer) {
        return FALSE;
    } else {
        return TRUE;
    }
}

static
DWORD
UpdatePercentComplete (
    IN  HWND    hwndDlg,
    IN  DWORD   dwDone,
    IN  DWORD   dwTotal
)
/*++

Routine Description:

    Update's the percent complete text in the dialog box using the
        information from the argument list.

Arguments:

    IN  HWND    hwndDlg
        Handle to the dialog box window

    IN  DWORD   dwDone
        Units completed  (Must be less than 42,949,671)

    IN  DWORD   dwTotal
        Total Units  (must be less than 4,394,967,296)

Return Value:

    Percent completed.

--*/
{
    DWORD   dwPercent = 0;
    LPTSTR  szOutBuff;

    szOutBuff = (LPTSTR)GlobalAlloc(GPTR, MAX_PATH_BYTES);

    if (szOutBuff != NULL) {
        dwPercent = ((dwDone * 100) + 50) / dwTotal;
        if (dwPercent > 100) dwPercent = 100;
        _stprintf (szOutBuff,
            GetStringResource (FMT_PERCENT_COMPLETE), dwPercent);
        SetDlgItemText (hwndDlg, NCDU_PERCENT_COMPLETE, szOutBuff);
        FREE_IF_ALLOC (szOutBuff);
    }

    return dwPercent;
}

static
BOOL
IsDestBootableDosFloppy (
)
/*++

Routine Description:

    Checks device in boot file path (from global structure) to see any
        of the "signature" boot files are present

Arguments:

    None

Return Value:

    TRUE if any of the boot files were found on the poot file path drive
    FALSE if not

--*/
{
    LPTSTR  szTestFileName;
    LPTSTR  *pszThisFile;
    LPTSTR  szNameStart;
    BOOL    bReturn = FALSE;

    szTestFileName = (LPTSTR)GlobalAlloc (GPTR, MAX_PATH_BYTES);

    if (szTestFileName == NULL) return FALSE;

    if (!IsUncPath(pAppInfo->szBootFilesPath)) {
        lstrcpy (szTestFileName, pAppInfo->szBootFilesPath);
        if (szTestFileName[lstrlen(szTestFileName)-1] == cBackslash) lstrcat(szTestFileName, cszBackslash);
        szNameStart = &szTestFileName[lstrlen(szTestFileName)];
        // go through list of "test files" and see if any are present
        for (pszThisFile = (LPTSTR *)&szBootIdFiles[0];
            *pszThisFile != NULL;
            pszThisFile++) {
            lstrcpy (szNameStart, *pszThisFile);
            if (FileExists(szTestFileName)) bReturn = TRUE;
        }
        // if here then none of the files could be found.
    } else {
        // if a UNC name return false
    }

    FREE_IF_ALLOC (szTestFileName);
    return bReturn;
}

static
BOOL
WriteMszToFile (
    IN  HWND    hwndDlg,
    IN  LPCTSTR  mszList,
    IN  LPCTSTR  szFileName,
    IN  DWORD   dwCreateFlags
)
/*++

Routine Description:

    Function to output each entry in the "list" as a record in the "file"
        Entries that start with a left "square bracket" ([) will be
        prefixed with a new line. (for INF file formatting);

    NOTE: this function outputs ANSI characters to an ANSI file regardless
        if the _UNICODE flags are set or not.

Arguments:

    IN  HWND    hwndDlg
        Handle to dialog box window

    IN  LPCTSTR  mszList
        Multi SZ list to write to the files

    IN  LPCTSTR  szFileName
        file name & path to write data to

    IN  DWORD   dwCreateFlags
        flags used by CreateFile function to open file.

Return Value:

    TRUE    no errors
    FALSE   error (use GetLastError() to get more error data)

--*/
{
    HANDLE  hFile;
    LPTSTR  szEntry;
    DWORD   dwBytes;
    LPSTR   szAnsiBuffer;
    BOOL    bReturn;

    MSG     msg;

#if _UNICODE
    szAnsiBuffer = (LPSTR)GlobalAlloc(GPTR, SMALL_BUFFER_SIZE);

    if (szAnsiBuffer == NULL) return FALSE;

    *(PDWORD)szAnsiBuffer = 0L;
#endif

    hFile = CreateFile (
        szFileName,
        GENERIC_WRITE,
        (FILE_SHARE_READ | FILE_SHARE_WRITE),
        NULL,
        dwCreateFlags,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (hFile != INVALID_HANDLE_VALUE) {
        for (szEntry = (LPTSTR)mszList;
            *szEntry != 0;
            szEntry += lstrlen(szEntry) + 1) {
#if _UNICODE
            // convert output buffer to ANSI
//#if defined(DBCS)
            WideCharToMultiByte(CP_ACP,
                                0L,
                                szEntry,
                                -1,
                                szAnsiBuffer,
                                SMALL_BUFFER_SIZE,
                                NULL,
                                NULL);
//#else  // defined(DBCS)
//            wcstombs (szAnsiBuffer, szEntry, SMALL_BUFFER_SIZE);
//#endif // defined(DBCS)
#else
            // copy ansi data to output buffer
            szAnsiBuffer = szEntry;
#endif
            // output to dialog box
            SetDlgItemText (hwndDlg, NCDU_FROM_PATH,
                GetStringResource (FMT_INTERNAL_BUFFER));
            SetDlgItemText (hwndDlg, NCDU_TO_PATH, _tcslwr((LPTSTR)szFileName));

            if (*szAnsiBuffer == '[') {
                WriteFile (hFile, "\r\n", 2, &dwBytes, NULL);
            }
            WriteFile (hFile, szAnsiBuffer, strlen(szAnsiBuffer),
                &dwBytes, NULL);
            WriteFile (hFile, "\r\n", 2, &dwBytes, NULL);

            // check for messages

            while (PeekMessage (&msg, 0, 0, 0, PM_REMOVE)) {
                TranslateMessage (&msg);
                DispatchMessage (&msg);
            }
        }
        CloseHandle (hFile);
        bReturn = TRUE;
    } else {
        bReturn = FALSE;
    }

#if _UNICODE
    FREE_IF_ALLOC(szAnsiBuffer);
#endif

    return bReturn;
}

static
BOOL
LoadProtocolIni (
    OUT LPTSTR  mszProtocolIni,
    OUT LPTSTR  mszNetFileList,
    OUT PDWORD  pdwNetFileCount
)
/*++

Routine Description:

    Creates the Protocol.Ini file using information from the user specified
        configuration

Arguments:

    OUT LPTSTR  mszProtocolIni
        buffer to receive the file data

    OUT LPTSTR  mszNetFileList
        buffer to recieve the list of files to copy as determined by
        scanning the INF based on the selected protocol & driver info.

    OUT PDWORD  pdwNetFileCount
        pointer to DWORD variable used to maintain a running total count of
        the number of files to copy for the % done calculation.

Return Value:

    TRUE if Protocol.INI file contents were generated
    FALSE if an error occured.

--*/
{
    LPTSTR  szThisString;
    LPTSTR  szTemp;
    LPTSTR  szTemp2;
    LPTSTR  szNifKey;
    LPTSTR  szSectionBuffer;
    LPCTSTR  szDefaultValue = cszEmptyString;
    BOOL    bTcp;   // TRUE if protocol is TCP
    BOOL    bIpx;   // TRUE if protocol is IPX

    szSectionBuffer = (LPTSTR)GlobalAlloc(GPTR, SMALL_BUFFER_SIZE * sizeof(TCHAR));
    szTemp = (LPTSTR)GlobalAlloc (GPTR, MAX_PATH_BYTES);
    szTemp2 = (LPTSTR)GlobalAlloc (GPTR, MAX_PATH_BYTES);
    szNifKey = (LPTSTR)GlobalAlloc (GPTR, MAX_PATH_BYTES);

    if ((szSectionBuffer == NULL) ||
        (szTemp == NULL) ||
        (szTemp2 == NULL) ||
        (szNifKey == NULL)) {
        return FALSE;
    }

    //
    //  TCP/IP & IPX are special cases, so detect them here
    //
    if (_tcsnicmp(pAppInfo->piFloppyProtocol.szKey, cszTcpKey, lstrlen(cszTcpKey)) == 0) {
        bTcp = TRUE;
        bIpx = FALSE;
    } else if (_tcsnicmp(pAppInfo->piFloppyProtocol.szName, cszIpxKey, lstrlen(cszTcpKey)) == 0) {
        bTcp = FALSE;
        bIpx = TRUE;
    } else { // it's neither
        bTcp = FALSE;
        bIpx = FALSE;
    }

    if (szSectionBuffer != NULL) {
        *(PDWORD)szSectionBuffer = 0;
    } else {
        return FALSE;
    }
    //fill in text of protocol ini file
    //
    //  add common files to Net dir list
    //
    lstrcpy (szTemp, pAppInfo->szDistPath);
    if (szTemp[lstrlen(szTemp)-1] != cBackslash) lstrcat (szTemp, cszBackslash);
    lstrcat (szTemp, cszOtnBootInf);

    GetPrivateProfileSection (cszOTNCommonFiles,
        szSectionBuffer, SMALL_BUFFER_SIZE, szTemp);

    for (szThisString = szSectionBuffer;
        *szThisString != 0;
        szThisString += (lstrlen(szThisString)+1)) {
        AddStringToMultiSz (mszNetFileList, GetKeyFromEntry (szThisString));
        *pdwNetFileCount += 1;
    }

    //
    //  add in protocol specific files here
    //

    GetPrivateProfileSection (pAppInfo->piFloppyProtocol.szKey,
        szSectionBuffer, SMALL_BUFFER_SIZE, szTemp);

    for (szThisString = szSectionBuffer;
        *szThisString != 0;
        szThisString += (lstrlen(szThisString)+1)) {
        AddStringToMultiSz (mszNetFileList, GetKeyFromEntry (szThisString));
        *pdwNetFileCount += 1;
    }

    // [network.setup] section

    AddStringToMultiSz (mszProtocolIni, cszNetworkSetup);
    AddStringToMultiSz (mszProtocolIni, cszInfVersion);

    // examine & log netcard info
    lstrcpy (szTemp2, pAppInfo->niNetCard.szInfKey);
    _tcsupr (szTemp2);

    _stprintf (szTemp, fmtNetcardDefEntry,
        pAppInfo->niNetCard.szInfKey,
        szTemp2);
    AddStringToMultiSz (mszProtocolIni, szTemp);

    // load transport information
    if (!bTcp) {
        // load the ndishlp transport
        AddStringToMultiSz (mszProtocolIni, fmtTransportDefEntry);
    }

    // load transport from listbox
    lstrcpy (szTemp2, pAppInfo->piFloppyProtocol.szKey);
    _tcsupr (szTemp2);
    _stprintf (szTemp, fmtTransportItem,
        pAppInfo->piFloppyProtocol.szKey,
        szTemp2);
    AddStringToMultiSz (mszProtocolIni, szTemp);

    // format the bindings
    _stprintf (szTemp, fmtLana0Entry,
        pAppInfo->niNetCard.szInfKey,
        pAppInfo->piFloppyProtocol.szKey);
    AddStringToMultiSz (mszProtocolIni, szTemp);
    if (!bTcp) {
        _stprintf (szTemp, fmtLana1Entry,
            pAppInfo->niNetCard.szInfKey);
        AddStringToMultiSz (mszProtocolIni, szTemp);
    }

    // format the netcard settings to the default values
    // add the net card driver file to the list of NetDir files
    QuietGetPrivateProfileString (pAppInfo->niNetCard.szDeviceKey,
        cszNdis2, cszEmptyString,
        szTemp2, MAX_PATH,
        pAppInfo->niNetCard.szInf);
    // save filename
    lstrcpy (pAppInfo->niNetCard.szDriverFile, GetFileNameFromEntry(szTemp2));
    AddStringToMultiSz (mszNetFileList, pAppInfo->niNetCard.szDriverFile);
    *pdwNetFileCount += 1;

    // output section with default values

    _stprintf (szTemp2, fmtIniSection, pAppInfo->niNetCard.szInfKey);
    AddStringToMultiSz (mszProtocolIni,  szTemp2);

    // lookup parameters
    GetPrivateProfileSection (pAppInfo->niNetCard.szNifKey,
        szSectionBuffer, MEDIUM_BUFFER_SIZE,
        pAppInfo->niNetCard.szInf);

    // process section. Format of each line is:
    //  entry=IniName,DescriptionString,Type,OptionRange,Default,?
    //  for each entry, I'll print:
    //      IniName=Default
    //  in the protocol.ini file
    //
    for (szThisString = szSectionBuffer;
        *szThisString != 0;
        szThisString += lstrlen(szThisString) +1) {
        if (_tcsnicmp(szThisString, cszDrivername, 10) == 0) {
            // drivername entry is a special case
            AddStringToMultiSz (mszProtocolIni, szThisString);
        } else {
            szDefaultValue = GetItemFromEntry(szThisString, 5);
            _stprintf (szTemp, fmtCmntIniKeyEntry,
                GetItemFromEntry(szThisString, 1),
                szDefaultValue);
            AddStringToMultiSz (mszProtocolIni, szTemp);
        }
    }
    //
    //  add protman files to the list
    //
    QuietGetPrivateProfileString (cszProtmanInstall,
        cszNetdir, cszEmptyString,
        szSectionBuffer, MEDIUM_BUFFER_SIZE,
        pAppInfo->niNetCard.szInf);

    // add all files to the list

    szThisString = _tcstok (szSectionBuffer, cszComma);
    while (szThisString != NULL ) {
        AddStringToMultiSz (mszNetFileList, GetFileNameFromEntry (szThisString));
        *pdwNetFileCount += 1;
        szThisString = _tcstok (NULL, cszComma);
    }

    // do protman entry

    AddStringToMultiSz (mszProtocolIni, fmtProtmanSection);
    lstrcpy (szNifKey, cszProtman);

    GetPrivateProfileSection (szNifKey,
        szSectionBuffer, MEDIUM_BUFFER_SIZE,
        pAppInfo->niNetCard.szInf);

    // process section. Format of each line is:
    //  entry=IniName,DescriptionString,Type,Default
    //  for each entry, I'll print:
    //      IniName=Default
    //  in the protocol.ini file
    //
    for (szThisString = szSectionBuffer;
        *szThisString != 0;
        szThisString += lstrlen(szThisString) +1) {
        if (_tcsnicmp(szThisString, cszDrivername, lstrlen(cszDrivername)) == 0) {
            // drivername entry is a special case
            AddStringToMultiSz (mszProtocolIni, szThisString);
        } else {
            szDefaultValue = GetItemFromEntry(szThisString, 4);
            if (lstrlen(szDefaultValue) > 0) {
                _stprintf (szTemp, fmtIniKeyEntry,
                    GetItemFromEntry(szThisString, 1),
                    szDefaultValue);
                AddStringToMultiSz (mszProtocolIni, szTemp);
            }
        }
    }

    if (!bTcp) {
        // do NdisHlp section

        AddStringToMultiSz (mszProtocolIni, cszMsNdisHlp);
        lstrcpy (szNifKey, cszMsNdisHlpXif);

        GetPrivateProfileSection (szNifKey,
            szSectionBuffer, MEDIUM_BUFFER_SIZE,
            pAppInfo->niNetCard.szInf);

        // process section. Format of each line is:
        //  drivername=name
        //
        for (szThisString = szSectionBuffer;
            *szThisString != 0;
            szThisString += lstrlen(szThisString) +1) {
            if (_tcsnicmp(szThisString, cszDrivername, lstrlen(cszDrivername)) == 0) {
                // drivername entry is a special case
                AddStringToMultiSz (mszProtocolIni, szThisString);
            } else {
                _stprintf (szTemp, fmtIniKeyEntry,
                    GetKeyFromEntry(szThisString),
                    GetItemFromEntry(szThisString, 1));
                AddStringToMultiSz (mszProtocolIni, szTemp);
            }
        }
        // do bindings

        _stprintf (szTemp, fmtBindingsEntry, pAppInfo->niNetCard.szInfKey);
        AddStringToMultiSz (mszProtocolIni, szTemp);
    }

    // do Protocol configuration

    _stprintf (szTemp2, fmtIniSection, pAppInfo->piFloppyProtocol.szKey);
    AddStringToMultiSz (mszProtocolIni, szTemp2);
    _stprintf (szNifKey, fmtXifEntry, pAppInfo->piFloppyProtocol.szKey);

    if (bTcp) {
        // format the TCP/IP protocol section here using information
        // from the previous dialog boxes
        AddStringToMultiSz (mszProtocolIni, fmtNBSessions);
        if (IsZeroIpAddr (&pAppInfo->tiTcpIpInfo.DefaultGateway[0])) {
            _stprintf (szTemp, fmtEmptyParam, cszDefaultGateway);
        } else {
            _stprintf (szTemp, fmtIpParam, cszDefaultGateway,
                pAppInfo->tiTcpIpInfo.DefaultGateway[0],
                pAppInfo->tiTcpIpInfo.DefaultGateway[1],
                pAppInfo->tiTcpIpInfo.DefaultGateway[2],
                pAppInfo->tiTcpIpInfo.DefaultGateway[3]);
        }
        AddStringToMultiSz (mszProtocolIni, szTemp);

        if (IsZeroIpAddr (&pAppInfo->tiTcpIpInfo.SubNetMask[0])) {
            _stprintf (szTemp, fmtEmptyParam, cszSubNetMask);
        } else {
            _stprintf (szTemp, fmtIpParam, cszSubNetMask,
                pAppInfo->tiTcpIpInfo.SubNetMask[0],
                pAppInfo->tiTcpIpInfo.SubNetMask[1],
                pAppInfo->tiTcpIpInfo.SubNetMask[2],
                pAppInfo->tiTcpIpInfo.SubNetMask[3]);
        }
        AddStringToMultiSz (mszProtocolIni, szTemp);

        if (IsZeroIpAddr (&pAppInfo->tiTcpIpInfo.IpAddr[0])) {
            _stprintf (szTemp, fmtEmptyParam, cszIPAddress);
        } else {
            _stprintf (szTemp, fmtIpParam, cszIPAddress,
                pAppInfo->tiTcpIpInfo.IpAddr[0],
                pAppInfo->tiTcpIpInfo.IpAddr[1],
                pAppInfo->tiTcpIpInfo.IpAddr[2],
                pAppInfo->tiTcpIpInfo.IpAddr[3]);
        }
        AddStringToMultiSz (mszProtocolIni, szTemp);

        _stprintf (szTemp, fmtIniKeyEntry,
            cszDisableDHCP,
            ((pAppInfo->bUseDhcp) ? csz0 : csz1));
        AddStringToMultiSz (mszProtocolIni, szTemp);
        AddStringToMultiSz (mszProtocolIni, cszTcpIpDriver);
    } else {
        // for Protocols other than TCP/IP get the info from the INF

        GetPrivateProfileSection (szNifKey,
            szSectionBuffer, MEDIUM_BUFFER_SIZE,
            pAppInfo->niNetCard.szInf);

        // process section. Format of each line is:
        //  entry=IniName,DescriptionString,Type,OptionRange,Default
        //  for each entry, I'll print:
        //      IniName=Default
        //  in the protocol.ini file
        //
        for (szThisString = szSectionBuffer;
            *szThisString != 0;
            szThisString += lstrlen(szThisString) +1) {
            if (_tcsnicmp(szThisString, cszDrivername, lstrlen(cszDrivername)) == 0) {
                // drivername entry is a special case
                AddStringToMultiSz (mszProtocolIni, szThisString);
            } else {
                if (bIpx && pAppInfo->niNetCard.bTokenRing) {
                // another special case is when IPX is used with Token Ring
                // cards.
                    if (_tcsnicmp(GetItemFromEntry(szThisString,1),
                        cszFrame, lstrlen(cszFrame)) == 0) {
                        szDefaultValue = cszTokenRingEntry;
                    }
                } else {
                    szDefaultValue = GetItemFromEntry(szThisString, 5);
                }
                // only write parameters that actually have a default value
                // to write
                if (lstrlen(szDefaultValue) > 0) {
                    _stprintf (szTemp, fmtIniKeyEntry,
                        GetItemFromEntry(szThisString, 1),
                        szDefaultValue);
                    AddStringToMultiSz (mszProtocolIni, szTemp);
                }
            }
        }
    }


    _stprintf (szTemp, fmtBindingsEntry, pAppInfo->niNetCard.szInfKey);
    AddStringToMultiSz (mszProtocolIni, szTemp);

    // IPX does not get a LANABASE entry

    if (_tcsnicmp(pAppInfo->piFloppyProtocol.szKey, cszIpxKey, lstrlen(cszIpxKey)) != 0) {
        AddStringToMultiSz (mszProtocolIni, fmtLanabase0);
    }

    FREE_IF_ALLOC (szSectionBuffer);
    FREE_IF_ALLOC (szTemp);
    FREE_IF_ALLOC (szTemp2);
    FREE_IF_ALLOC (szNifKey);

    return TRUE;

}

static
BOOL
LoadSystemIni (
    OUT  LPTSTR  mszList
)
/*++

Routine Description:

    Routine to generate the System.INI file for the boot floppy

Arguments:

    OUT LPTSTR   mszList
        buffer to fill with system.INI records
        NOTE: BUFFER SIZE is assumed to be sufficient (i.e. it's not checked!)

Return Value:

    TRUE    if entries generated
    FALSE   if error

--*/
{
    LPTSTR  szTemp1;
    LPTSTR  szTemp2;
    LPSTR   szAnsi1;
    BOOL    bReturn;

    szTemp1 = (LPTSTR)GlobalAlloc (GPTR, MAX_PATH_BYTES);
    szTemp2 = (LPTSTR)GlobalAlloc (GPTR, MAX_PATH_BYTES);
    szAnsi1 = (LPSTR)GlobalAlloc (GPTR, MAX_PATH);

    if ((szTemp1 != NULL) &&
        (szTemp2 != NULL) &&
        (szAnsi1 != NULL))  {
        AddStringToMultiSz (mszList, cszNetworkSection);
        AddStringToMultiSz (mszList, fmtNoFilesharing);
        AddStringToMultiSz (mszList, fmtNoPrintsharing);
        AddStringToMultiSz (mszList, fmtYesAutologon);
        _stprintf (szTemp1, fmtComputernameEntry, pAppInfo->szComputerName);
        CharToOemBuff (szTemp1, szAnsi1, (DWORD)(lstrlen(szTemp1)+1));
#ifdef UNICODE
        mbstowcs (szTemp2, szAnsi1, MAX_PATH);
#else
        lstrcpy (szTemp2, szAnsi1);
#endif
        AddStringToMultiSz (mszList, szTemp2);
        AddStringToMultiSz (mszList, fmtLanaRootOnA);
        _stprintf (szTemp1, fmtUsernameEntry, pAppInfo->szUsername);
        CharToOemBuff (szTemp1, szAnsi1, (DWORD)(lstrlen(szTemp1)+1));
#ifdef UNICODE
        mbstowcs (szTemp2, szAnsi1, MAX_PATH);
#else
        lstrcpy (szTemp2, szAnsi1);
#endif
        AddStringToMultiSz (mszList, szTemp2);
        _stprintf (szTemp1, fmtWorkgroupEntry, pAppInfo->szDomain);
        CharToOemBuff (szTemp1, szAnsi1, (DWORD)(lstrlen(szTemp1)+1));
#ifdef UNICODE
        mbstowcs (szTemp2, szAnsi1, MAX_PATH);
#else
        lstrcpy (szTemp2, szAnsi1);
#endif
        AddStringToMultiSz (mszList, szTemp2);
        AddStringToMultiSz (mszList, fmtNoReconnect);
        if (_tcsnicmp(pAppInfo->piFloppyProtocol.szName, cszNetbeuiKey, lstrlen(cszNetbeuiKey)) == 0) {
            // only NetBEUI gets this
            AddStringToMultiSz (mszList, fmtNoDirectHost);
        }
        AddStringToMultiSz (mszList, fmtNoDosPopHotKey);
        if (_tcsnicmp(pAppInfo->piFloppyProtocol.szKey, cszIpxKey, lstrlen(cszIpxKey)) == 0) {
            AddStringToMultiSz (mszList, fmtLmLogon1);
        } else {
            AddStringToMultiSz (mszList, fmtLmLogon0);
        }
        _stprintf (szTemp1, fmtLogonDomainEntry, pAppInfo->szDomain);
        CharToOemBuff (szTemp1, szAnsi1, (DWORD)(lstrlen(szTemp1)+1));
#ifdef UNICODE
        mbstowcs (szTemp2, szAnsi1, MAX_PATH);
#else
        lstrcpy (szTemp2, szAnsi1);
#endif
        AddStringToMultiSz (mszList, szTemp2);
        AddStringToMultiSz (mszList, fmtPreferredRedirFull);
        AddStringToMultiSz (mszList, fmtAutostartFull);
        AddStringToMultiSz (mszList, fmtMaxConnections);

        // network driver section

        AddStringToMultiSz (mszList, fmtNetworkDriversSection);
        _stprintf (szTemp1, fmtNetcardEntry, pAppInfo->niNetCard.szDriverFile);
        CharToOemBuff (szTemp1, szAnsi1, (DWORD)(lstrlen(szTemp1)+1));
#ifdef UNICODE
        mbstowcs (szTemp2, szAnsi1, MAX_PATH);
#else
        lstrcpy (szTemp2, szAnsi1);
#endif
        AddStringToMultiSz (mszList, szTemp2);
        if (_tcsnicmp(pAppInfo->piFloppyProtocol.szName, cszTCP, lstrlen(cszTCP)) == 0 ) {
            // tcpip Transport
            lstrcpy (szTemp1, fmtTcpTransportEntry);
        } else {
            lstrcpy (szTemp1, fmtNdisTransportEntry);
            if (_tcsnicmp(pAppInfo->piFloppyProtocol.szName, cszNetbeui, lstrlen(cszNetbeui)) == 0 ) {
                // add NetBEUI string
                lstrcat (szTemp1, fmtNetbeuiAddon);
            }
        }
        AddStringToMultiSz (mszList, szTemp1);
        AddStringToMultiSz (mszList, fmtDevdir);
        AddStringToMultiSz (mszList, fmtLoadRmDrivers);

        // password file list (header only)
        AddStringToMultiSz (mszList, fmtPasswordListSection);
        bReturn = TRUE;
    } else {
        bReturn = FALSE;
    }

    FREE_IF_ALLOC (szTemp1);
    FREE_IF_ALLOC (szTemp2);
    FREE_IF_ALLOC (szAnsi1);

    return bReturn;
}

static
BOOL
LoadAutoexecBat (
    OUT LPTSTR mszList
)
/*++

Routine Description:

    Routine to generate the Autoexec.bat file for the boot floppy

Arguments:

    OUT  LPTSTR  mszList
        Buffer to write autoexec.bat entries into
        NOTE: BUFFER SIZE is assumed to be sufficient (i.e. it's not checked!)


Return Value:

    TRUE    if entries generated
    FALSE   if error

--*/
{
    LPTSTR  szTemp;
    LPTSTR  szTemp2;
    LPTSTR  szSectionBuffer;
    LPTSTR  szDir;
    LPTSTR  szEntry;

    szSectionBuffer = GlobalAlloc (GPTR, (SMALL_BUFFER_SIZE * sizeof(TCHAR)));
    szTemp = (LPTSTR)GlobalAlloc (GPTR, MAX_PATH_BYTES);
    szTemp2 = (LPTSTR)GlobalAlloc (GPTR, MAX_PATH_BYTES);

    if ((szSectionBuffer == NULL) ||
        (szTemp == NULL) ||
        (szTemp2 == NULL)) {
        return FALSE;
    }

#ifdef JAPAN
//  fixed kkntbug #12382
//      NCAdmin:"[] Make Japanese startup disks" is not functioning.

    if (bJpnDisk)  {
        AddStringToMultiSz (mszList, GetStringResource (FMT_LOAD_AUTOEXEC_ECHO));
        AddStringToMultiSz (mszList, fmtPause);
    }
#endif
    AddStringToMultiSz (mszList, fmtPathSpec);

    // load network starting commands from INF
    // get commands from INF for this protocol

    //
    //  put INF filename into szTemp
    //
    lstrcpy (szTemp, pAppInfo->szDistPath);
    if (szTemp[lstrlen(szTemp)-1] != cBackslash) lstrcat (szTemp, cszBackslash);
    lstrcat (szTemp, cszAppInfName);
    //
    //  put key name made from protocol and "_autoexec" into szTemp2
    //
    lstrcpy (szTemp2, pAppInfo->piFloppyProtocol.szKey);
    lstrcat (szTemp2, fmtAutoexec);

    GetPrivateProfileSection (szTemp2, szSectionBuffer,
        SMALL_BUFFER_SIZE, szTemp);

    for (szEntry = szSectionBuffer;
         *szEntry != 0;
         szEntry += (lstrlen(szEntry) + 1)) {
        lstrcpy (szTemp, fmtNetPrefix);
        lstrcat (szTemp, GetKeyFromEntry(szEntry));
        AddStringToMultiSz (mszList, szTemp);
    }

    // create network connection commands

    if (GetServerAndSharepointFromUnc(pAppInfo->piTargetProtocol.szDir, szTemp2)) {
        _stprintf (szTemp, fmtNetUseDrive, szTemp2);
        AddStringToMultiSz (mszList, szTemp);
    } else {
        AddStringToMultiSz (mszList,
            GetStringResource (FMT_CONNECTING_COMMENT));
    }

    // create setup command

    szDir = (LPTSTR)GetDirPathFromUnc(pAppInfo->piTargetProtocol.szDir);
    if (lstrlen(szDir) > 0) {
        AddStringToMultiSz (mszList,
            GetStringResource (FMT_RUNNING_SETUP_COMMENT));
        _stprintf (szTemp, fmtSetupCommand,
            szDir, pAppInfo->szTargetSetupCmd);
        AddStringToMultiSz (mszList, szTemp);
    } else {
        AddStringToMultiSz (mszList,
            GetStringResource (FMT_OTN_COMMENT));
    }

    FREE_IF_ALLOC (szSectionBuffer);
    FREE_IF_ALLOC (szTemp);
    FREE_IF_ALLOC (szTemp2);

    return TRUE;
}

static
BOOL
LoadConfigSys (
    OUT LPTSTR mszList
)
/*++

Routine Description:

    Routine to write Config.Sys entries for the Boot Floppy.

Arguments:

    OUT LPTSTR mszList
        Buffer to write Config.sys commands into
        NOTE: BUFFER SIZE is assumed to be sufficient (i.e. it's not checked!)


Return Value:

    TRUE

--*/
{
    AddStringToMultiSz (mszList, fmtFilesParam);
    AddStringToMultiSz (mszList, fmtDeviceIfsHlpSys);
    AddStringToMultiSz (mszList, fmtLastDrive);
    if (GetBootDiskDosVersion (pAppInfo->szBootFilesPath) >= 5) {
        AddStringToMultiSz (mszList, fmtLoadHiMem);
        AddStringToMultiSz (mszList, fmtLoadEMM386);
        AddStringToMultiSz (mszList, fmtDosHigh);
#ifdef JAPAN
//  fixed kkntbug #12382
//      NCAdmin:"[] Make Japanese startup disks" is not functioning.

        if (bJpnDisk)  {
            AddStringToMultiSz (mszList, fmtBilingual);
            AddStringToMultiSz (mszList, fmtFontSys);
            AddStringToMultiSz (mszList, fmtDispSys);
            AddStringToMultiSz (mszList, fmtKeyboard);
            AddStringToMultiSz (mszList, fmtNlsFunc);
        }
#endif
    }

    return TRUE;
}

static
BOOL
MakeFlopDlg_NCDU_START_FILE_COPY (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Processes NCDU_START_FILE_COPY message. Allocates buffers to be
        used in creating boot and network configuration files. Fills
        them in using information from the pAppInfo struct then
        writes them to the output files on the destination drive.
        Once the generated files have been written, the other
        files are copied from the OTN dir to the destination drive.
        If all goes well, then the dialog box is closed.

Arguments:

    IN  HWND    hwndDlg
        Handle to dialog box window

    IN  WPARAM  wParam
        Not Used

    IN  LPARAM  lParam
        Not Used

Return Value:

    FALSE.

--*/
{
    LPTSTR  mszNetFileList;
    LPTSTR  mszProtocolIni;
    LPTSTR  mszSystemIni;
    LPTSTR  mszAutoexecBat;
    LPTSTR  mszConfigSys;
    DWORD   dwNetFileCount = 0;
    DWORD   dwFilesCopied = 0;
    DWORD   dwDestClusterSize = 0;

    DWORD   dwFileBytesToCopy = 0;
    DWORD   dwDestFreeSpace = 0;
    DWORD   dwFileSize;

    LPTSTR  szSrcFile;
    LPTSTR  szSrcFilePart;

    LPTSTR  szDestFile;
    LPTSTR  szDestFilePart;

    LPTSTR  szThisFile;
    LPTSTR  szInfFile;

    int     nMbResult;
    BOOL    bBootable;
    BOOL    bAborted = FALSE;

    DWORD   dwSystemFileSize;

    MSG     msg;
    UINT    nExitCode = IDOK;
#ifdef  JAPAN
    LPTSTR  szThisString;
    LPTSTR  szVolumeName;
    LPTSTR  szTextString;
    LPTSTR  szSectionBuffer;
    LPTSTR  szDOSVDirectory;
    LPTSTR  szTemp;
#endif

    mszNetFileList = (LPTSTR)GlobalAlloc(GPTR, MEDIUM_BUFFER_SIZE);
    mszProtocolIni = (LPTSTR)GlobalAlloc(GPTR, MEDIUM_BUFFER_SIZE);
    mszSystemIni = (LPTSTR)GlobalAlloc(GPTR, MEDIUM_BUFFER_SIZE);
    mszAutoexecBat = (LPTSTR)GlobalAlloc(GPTR, SMALL_BUFFER_SIZE);
    mszConfigSys = (LPTSTR)GlobalAlloc(GPTR, SMALL_BUFFER_SIZE);
    szSrcFile = (LPTSTR)GlobalAlloc(GPTR, MAX_PATH_BYTES);
    szDestFile = (LPTSTR)GlobalAlloc(GPTR, MAX_PATH_BYTES);
    szInfFile = (LPTSTR)GlobalAlloc(GPTR, MAX_PATH_BYTES);
#ifdef  JAPAN
    szVolumeName = (LPTSTR)GlobalAlloc(GPTR, SMALL_BUFFER_SIZE);
    szTextString = (LPTSTR)GlobalAlloc(GPTR, SMALL_BUFFER_SIZE);
    szSectionBuffer = (LPTSTR)GlobalAlloc(GPTR, SMALL_BUFFER_SIZE);
    szDOSVDirectory = (LPTSTR)GlobalAlloc(GPTR, SMALL_BUFFER_SIZE);
    szTemp = (LPTSTR)GlobalAlloc(GPTR, SMALL_BUFFER_SIZE);
#endif

    if ((mszNetFileList != NULL) &&
        (mszProtocolIni != NULL) &&
        (mszConfigSys != NULL) &&
        (mszAutoexecBat != NULL) &&
        (szSrcFile != NULL) &&
        (szDestFile != NULL) &&
        (szInfFile != NULL) &&
#ifdef JAPAN
        (szVolumeName != NULL) &&
        (szTextString != NULL) &&
        (szSectionBuffer != NULL) &&
        (szDOSVDirectory != NULL) &&
        (szTemp != NULL) &&
#endif
        (mszSystemIni != NULL)) {

        *(PDWORD)mszNetFileList = 0L;
        *(PDWORD)mszProtocolIni = 0L;
        *(PDWORD)mszSystemIni = 0L;
        *(PDWORD)mszAutoexecBat = 0L;
        *(PDWORD)mszConfigSys = 0L;

#ifdef JAPAN
        if (wParam) {
            wsprintf(szTemp, GetStringResource (FMT_OTN_BOOT_FILES_DOSV), wParam);
            SetDlgItemText (hwndDlg, NCDU_COPY_APPNAME, szTemp);
        }
#endif

        szDestFilePart = szDestFile;    // to initialize the var

        lstrcpy (szInfFile, pAppInfo->szDistPath);
        if (szInfFile[lstrlen(szInfFile)-1] != cBackslash)
            lstrcat (szInfFile, cszBackslash);
        lstrcat (szInfFile, cszAppInfName);

        if (GetPrivateProfileString (cszSizes, csz_SystemFileSize_,
            cszEmptyString, szSrcFile, MAX_PATH, szInfFile) > 0) {
            // a value was found so get the filesize value from the string
            dwSystemFileSize = GetSizeFromInfString (szSrcFile);
        } else {
            dwSystemFileSize = 0;
        }

#ifdef JAPAN
        if (wParam == SETUP_DOSV_2) {
            _stprintf (szTextString,
                GetStringResource (FMT_LOAD_NET_CLIENT2),
                GetStringResource (
                    (pAppInfo->mtBootDriveType == F3_1Pt44_512) ?
                        CSZ_35_HD : CSZ_525_HD),
                pAppInfo->szBootFilesPath);

            while(1) {

                GetVolumeInformation(
                    pAppInfo->szBootFilesPath,
                    szVolumeName,
                    SMALL_BUFFER_SIZE,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    0);

                if (lstrcmp(szVolumeName, cszDOSVLabel1)) {
                    SetVolumeLabel(pAppInfo->szBootFilesPath, cszDOSVLabel2);
                    break;
                }
                else {

                    nMbResult = DisplayMessageBox (
                                           hwndDlg,
                                           NCDU_DRIVE_NOT_BOOTDISK,
                                           FMT_LOAD_NET_CLIENT2_TITLE,
                                           MB_OKCANCEL_TASK_EXCL);

                    if (nMbResult == IDCANCEL) {
                        bCopying = FALSE;
                        break;
                    }
                }
            }
        }
#endif

        if (!(bBootable = IsDestBootableDosFloppy())) {
#ifdef JAPAN
			if (wParam == SETUP_DOSV_2) {
                while ((nMbResult = DisplayMessageBox (
                                               hwndDlg,
                                               NCDU_DRIVE_NOT_BOOTDISK,
                                               0,
                                               MB_OKCANCEL_TASK_INFO)) != IDCANCEL) {
                    if ((bBootable = IsDestBootableDosFloppy())) {
                        break;
                    }
                }

                if (nMbResult == IDCANCEL) bCopying = FALSE;
			}

            if (bCopying == FALSE)
#endif
            AddMessageToExitList (pAppInfo, NCDU_COPY_TO_FLOPPY);
        }

#ifdef JAPAN
        if (wParam == SETUP_DOSV_1)
            SetVolumeLabel(pAppInfo->szBootFilesPath, cszDOSVLabel1);

#endif

#ifdef JAPAN
        if ((wParam == SETUP_DOSV_2) || !wParam) {
#endif
        // generate protocol.ini

        LoadProtocolIni (
            mszProtocolIni,
            mszNetFileList,
            &dwNetFileCount);
        dwNetFileCount += 1;     // account for protocol.ini file

        // generate system.ini
        LoadSystemIni (mszSystemIni);
        dwNetFileCount += 1;
#ifdef JAPAN
        }
        else  {
            if (QuietGetPrivateProfileString (cszOtnInstall, cszDOSV, cszEmptyString,
                szDOSVDirectory, SMALL_BUFFER_SIZE, szInfFile) > 0) {

                GetPrivateProfileSection (cszOTNDOSVFiles,
                    szSectionBuffer, SMALL_BUFFER_SIZE, szInfFile);

                for (szThisString = szSectionBuffer;
                    *szThisString != 0;
                    szThisString += (lstrlen(szThisString)+1)) {
                    lstrcpy(szTemp, szDOSVDirectory);
                    lstrcat(szTemp, cszBackslash);
                    lstrcat(szTemp, GetKeyFromEntry (szThisString));
                    AddStringToMultiSz (mszNetFileList, szTemp);
                    dwNetFileCount += 1;
                }
            }

            GetPrivateProfileSection (cszDOSVCommonFiles,
                szSectionBuffer, SMALL_BUFFER_SIZE, szInfFile);

            for (szThisString = szSectionBuffer;
                *szThisString != 0;
                szThisString += (lstrlen(szThisString)+1)) {
                AddStringToMultiSz (mszNetFileList, GetKeyFromEntry (szThisString));
                dwNetFileCount += 1;
            }
        }
#endif

        // generate autoexec.bat
        LoadAutoexecBat (mszAutoexecBat);
        dwNetFileCount += 1;

#ifdef JAPAN
        if ((wParam == SETUP_DOSV_1) || !wParam) {
#endif
        // generate config.sys
        LoadConfigSys (mszConfigSys);
        dwNetFileCount += 1;
#ifdef JAPAN
        }
#endif

        // determine number of bytes to copy to destination

        dwDestClusterSize = GetClusterSizeOfDisk (pAppInfo->szBootFilesPath);

        dwFileBytesToCopy = 0;  // clear

#ifdef  JAPAN
        if ((wParam == SETUP_DOSV_2) || !wParam) {
#endif
        // get size of file that will be written
        dwFileBytesToCopy += GetMultiSzLen (mszProtocolIni);
        // and round up to the next sector size
        dwFileBytesToCopy += dwDestClusterSize -
            (dwFileBytesToCopy % dwDestClusterSize);

        // get size of file that will be written
        dwFileBytesToCopy += GetMultiSzLen (mszSystemIni);
        // and round up to the next sector size
        dwFileBytesToCopy += dwDestClusterSize -
            (dwFileBytesToCopy % dwDestClusterSize);
#ifdef JAPAN
        }
#endif

        // get size of file that will be written
        dwFileBytesToCopy += GetMultiSzLen (mszAutoexecBat);
        // and round up to the next sector size
        dwFileBytesToCopy += dwDestClusterSize -
            (dwFileBytesToCopy % dwDestClusterSize);

#ifdef JAPAN
        if ((wParam == SETUP_DOSV_1) || !wParam) {
#endif
        // get size of file that will be written
        dwFileBytesToCopy += GetMultiSzLen (mszConfigSys);
        // and round up to the next sector size
        dwFileBytesToCopy += dwDestClusterSize -
            (dwFileBytesToCopy % dwDestClusterSize);
#ifdef JAPAN
        }
#endif

#ifdef JAPAN
        if ((wParam == SETUP_DOSV_1) || !wParam) {
#endif
        // get size of files in copy list and add to internally created files

        lstrcpy (szSrcFile, pAppInfo->piFloppyProtocol.szDir);
        if (szSrcFile[lstrlen(szSrcFile)-1] != cBackslash) lstrcat (szSrcFile, cszBackslash);
        szSrcFilePart = &szSrcFile[lstrlen(szSrcFile)];
#ifdef JAPAN
        }
#endif

        for (szThisFile = mszNetFileList;
            *szThisFile != 0;
            szThisFile += (lstrlen(szThisFile) + 1)) {
            // make full path of filename
            lstrcpy (szSrcFilePart, szThisFile);
            // get the size of the file and add it to the total
            dwFileSize = QuietGetFileSize (szSrcFile);
            if (dwFileSize != 0xFFFFFFFF) {
                dwFileBytesToCopy += dwFileSize;
                // and round to the next larger allocation unit
                dwFileBytesToCopy += dwDestClusterSize -
                    (dwFileBytesToCopy % dwDestClusterSize);
            }
        }

        dwDestFreeSpace = ComputeFreeSpace (pAppInfo->szBootFilesPath);

        if (dwDestFreeSpace < dwFileBytesToCopy) {
            DisplayMessageBox (hwndDlg,
                NCDU_INSUFFICIENT_DISK_SPACE,
                0,
                MB_OK_TASK_EXCL);
            bCopying = FALSE;
            bAborted = TRUE;
            nExitCode = IDCANCEL; // operation ended in error
        } else {
            if (!bBootable) {
                // see if there will be room to add the system files
                // later...
                dwFileBytesToCopy += dwSystemFileSize;
                if (dwDestFreeSpace < dwFileBytesToCopy) {
                   if (DisplayMessageBox (hwndDlg,
                        NCDU_SYSTEM_MAY_NOT_FIT,
                        0,
                        MB_OKCANCEL_TASK_INFO | MB_DEFBUTTON2) == IDCANCEL) {
                        bCopying = FALSE;
                        bAborted = TRUE;
                        nExitCode = IDCANCEL; // operation ended in error
                    } else {
                        // they want to continue so stick a message in the
                        // exit messages
                        AddMessageToExitList (pAppInfo, NCDU_SMALL_DISK_WARN);
                    }
                }
            }
        }

        if (bCopying) {
            // write files to root directory

            lstrcpy (szDestFile, pAppInfo->szBootFilesPath);
            if (szDestFile[lstrlen(szDestFile)-1] != cBackslash) lstrcat (szDestFile, cszBackslash);
            szDestFilePart = &szDestFile[lstrlen(szDestFile)];

            // make sure destination path exists
            CreateDirectoryFromPath (szDestFile, NULL);

#ifdef JAPAN
            if ((wParam == SETUP_DOSV_1) || !wParam) {
#endif
            // config.sys
            lstrcpy (szDestFilePart, cszConfigSys);
            if (WriteMszToFile (hwndDlg, mszConfigSys, szDestFile, CREATE_ALWAYS)) {
                UpdatePercentComplete (hwndDlg, ++dwFilesCopied, dwNetFileCount);
            } else {
                // bail out here since there was a copy error
                nMbResult = MessageBox (
                    hwndDlg,
                 	   GetStringResource (CSZ_UNABLE_COPY),
                    szDestFile,
                    MB_OKCANCEL_TASK_EXCL);
                if (nMbResult == IDCANCEL) {
                    bCopying = FALSE;
                    nExitCode = IDCANCEL; // operation ended in error
                } else {
                    AddMessageToExitList (pAppInfo, NCDU_FLOPPY_NOT_COMPLETE);
                }
            }
#ifdef JAPAN
            }
#endif
        }

        if (bCopying) {
            // autoexec.bat
            lstrcpy (szDestFilePart, cszAutoexecBat);
            if (WriteMszToFile (hwndDlg, mszAutoexecBat, szDestFile, CREATE_ALWAYS)) {
                UpdatePercentComplete (hwndDlg, ++dwFilesCopied, dwNetFileCount);
            } else {
                // bail out here since there was a copy error
                nMbResult = MessageBox (
                    hwndDlg,
                    GetStringResource (CSZ_UNABLE_COPY),
                    szDestFile,
                    MB_OKCANCEL_TASK_EXCL);
                if (nMbResult == IDCANCEL) {
                    bCopying = FALSE;
                    nExitCode = IDCANCEL; // operation ended in error
                } else {
                    AddMessageToExitList (pAppInfo, NCDU_FLOPPY_NOT_COMPLETE);
                }
            }
        }


        if (bCopying) {
            // write INI files
            // make NET subdir
            lstrcpy (szDestFilePart, cszNet);
            CreateDirectory (szDestFile, NULL);

            // add net sub dir to dest path
            if (szDestFile[lstrlen(szDestFile)-1] != cBackslash) lstrcat (szDestFile, cszBackslash);
            szDestFilePart = &szDestFile[lstrlen(szDestFile)];
#ifdef JAPAN
            if ((wParam == SETUP_DOSV_2) || !wParam) {
#endif
            lstrcpy (szDestFilePart, cszSystemIni);

            if (WriteMszToFile (hwndDlg, mszSystemIni, szDestFile, CREATE_ALWAYS)) {
                UpdatePercentComplete (hwndDlg, ++dwFilesCopied, dwNetFileCount);
            } else {
                // bail out here since there was a copy error
                nMbResult = MessageBox (
                    hwndDlg,
                    GetStringResource (CSZ_UNABLE_COPY),
                    szDestFile,
                    MB_OKCANCEL_TASK_EXCL);
                if (nMbResult == IDCANCEL) {
                    bCopying = FALSE;
                    nExitCode = IDCANCEL; // operation ended in error
                } else {
                    AddMessageToExitList (pAppInfo, NCDU_FLOPPY_NOT_COMPLETE);
                }
            }
#ifdef JAPAN
            }
            else  {
                // make DOSV subdir
                lstrcpy (szDestFilePart, cszDOSV);
                CreateDirectory (szDestFile, NULL);
           }
#endif
        }

#ifdef JAPAN
        if ((wParam == SETUP_DOSV_2) || !wParam) {
#endif
        if (bCopying) {
            lstrcpy (szDestFilePart, cszProtocolIni);
            if (WriteMszToFile (hwndDlg, mszProtocolIni, szDestFile, CREATE_ALWAYS)) {
                UpdatePercentComplete (hwndDlg, ++dwFilesCopied, dwNetFileCount);
            } else {
                // bail out here since there was a copy error
                nMbResult = MessageBox (
                    hwndDlg,
                    GetStringResource (CSZ_UNABLE_COPY),
                    szDestFile,
                    MB_OKCANCEL_TASK_EXCL);
                if (nMbResult == IDCANCEL) {
                    bCopying = FALSE;
                    nExitCode = IDCANCEL; // operation ended in error
                } else {
                    AddMessageToExitList (pAppInfo, NCDU_FLOPPY_NOT_COMPLETE);
                }
            }
        }
#ifdef JAPAN
        }
#endif

        if (bCopying) {
            // copy files in list from ??? to destination dir
            lstrcpy (szSrcFile, pAppInfo->piFloppyProtocol.szDir);
            if (szSrcFile[lstrlen(szSrcFile)-1] != cBackslash) lstrcat (szSrcFile, cszBackslash);
            szSrcFilePart = &szSrcFile[lstrlen(szSrcFile)];

            for (szThisFile = mszNetFileList;
                *szThisFile != 0;
                szThisFile += (lstrlen(szThisFile) + 1)) {
                lstrcpy (szSrcFilePart, szThisFile);
                lstrcpy (szDestFilePart, szThisFile);

                if (bCopying) {
                    SetDlgItemText (hwndDlg, NCDU_FROM_PATH, szSrcFile);
                    SetDlgItemText (hwndDlg, NCDU_TO_PATH, szDestFile);

                    if (!CopyFile (szSrcFile, szDestFile, FALSE)) {
                        // error in file copy so bail out here
                        // bail out here since there was a copy error
                        nMbResult = MessageBox (
                            hwndDlg,
                            GetStringResource (CSZ_UNABLE_COPY),
                            szSrcFile,
                            MB_OKCANCEL_TASK_EXCL);
                        if (nMbResult == IDCANCEL) {
                            bCopying = FALSE;
                            nExitCode = IDCANCEL; // operation ended in error
                        } else {
                            AddMessageToExitList (pAppInfo, NCDU_FLOPPY_NOT_COMPLETE);
                        }
                    } else {
                        // copy was successful so update the  % complete
                        // and Set destination File attributest to NORMAL
                        SetFileAttributes (szDestFile, FILE_ATTRIBUTE_NORMAL);
                        UpdatePercentComplete (hwndDlg, ++dwFilesCopied, dwNetFileCount);
                    }

                    // check for messages

                    while (PeekMessage (&msg, 0, 0, 0, PM_REMOVE)) {
                        TranslateMessage (&msg);
                        DispatchMessage (&msg);
                    }
                } else {
                    break;
                }
            }
        }
    }

#ifdef JAPAN
    if (bCopying) {
        if (wParam == SETUP_DOSV_1) {
            _stprintf (szTextString,
                GetStringResource (FMT_LOAD_NET_CLIENT2),
                GetStringResource (
                    (pAppInfo->mtBootDriveType == F3_1Pt44_512) ?
                        CSZ_35_HD : CSZ_525_HD),
                pAppInfo->szBootFilesPath);

            nMbResult = MessageBox (
                hwndDlg,
                szTextString,
                GetStringResource (FMT_LOAD_NET_CLIENT2_TITLE),
                MB_OKCANCEL_TASK_EXCL);

            if (nMbResult == IDCANCEL)  {
                bCopying = FALSE;
            }
        }
    }
#endif

    if (bCopying) {
#ifdef JAPAN
        if (((wParam == SETUP_DOSV_2) && bBootable) || !wParam) {
#endif
        // files copied completely, but check params.
        AddMessageToExitList (pAppInfo, NCDU_CHECK_PROTOCOL_INI);
        DisplayMessageBox (
            hwndDlg,
            NCDU_FLOPPY_COMPLETE,
            0,
            MB_OK_TASK_INFO);
#ifdef JAPAN
        }
#endif
    } else {
        if (!bAborted) {
            // don't show "not copied" dialog since they know
            // this
            // floppy not copied completely
            AddMessageToExitList (pAppInfo, NCDU_FLOPPY_NOT_COMPLETE);
            DisplayMessageBox (
                hwndDlg,
                NCDU_FLOPPY_NOT_COMPLETE,
                0,
                MB_OK_TASK_EXCL);
        }
    }

    if (nExitCode == IDOK) {
        // enable display of exit messages since a floppy was created
        EnableExitMessage(TRUE);
    }

#ifdef JAPAN
    if (!wParam ||
        (wParam == SETUP_DOSV_2) ||
       ((wParam == SETUP_DOSV_1) && !bCopying))  {
#endif
    EndDialog (hwndDlg, nExitCode);
#ifdef JAPAN
    }
#endif

    FREE_IF_ALLOC (mszNetFileList);
    FREE_IF_ALLOC (mszProtocolIni);
    FREE_IF_ALLOC (mszSystemIni);
    FREE_IF_ALLOC (mszConfigSys);
    FREE_IF_ALLOC (mszAutoexecBat);
    FREE_IF_ALLOC (szSrcFile);
    FREE_IF_ALLOC (szDestFile);
    FREE_IF_ALLOC (szInfFile);
#ifdef JAPAN
    FREE_IF_ALLOC (szVolumeName);
    FREE_IF_ALLOC (szTextString);
    FREE_IF_ALLOC (szSectionBuffer);
    FREE_IF_ALLOC (szDOSVDirectory);
    FREE_IF_ALLOC (szTemp);
#endif

#ifdef JAPAN
    if ((wParam == SETUP_DOSV_1) && !bCopying)
        return FALSE;
#endif
    return TRUE;
}

static
BOOL
MakeFlopDlg_WM_INITDIALOG (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Initializes the text fields of the dialog box and post's the
        "start copying" message

Arguments:

    IN  HWND    hwndDlg
        Handle to dialog box window

    IN  WPARAM  wParam
        Not Used

    IN  LPARAM  lParam
        Not Used

Return Value:

--*/
{
    // intialize Global data
     bCopying = TRUE;

    RemoveMaximizeFromSysMenu (hwndDlg);
    PositionWindow  (hwndDlg);
    SetDlgItemText (hwndDlg, NCDU_COPY_APPNAME,
        GetStringResource (FMT_OTN_BOOT_FILES));
    SetDlgItemText (hwndDlg, NCDU_FROM_PATH, cszEmptyString);
    SetDlgItemText (hwndDlg, NCDU_TO_PATH, cszEmptyString);
    SetDlgItemText (hwndDlg, NCDU_PERCENT_COMPLETE,
        GetStringResource (FMT_ZERO_PERCENT_COMPLETE));
    SetFocus (GetDlgItem(hwndDlg, IDCANCEL));

    // start copying files
    PostMessage (hwndDlg, NCDU_START_FILE_COPY, 0, lParam);
    // clear old Dialog and register current
    PostMessage (GetParent(hwndDlg), NCDU_CLEAR_DLG, (WPARAM)hwndDlg, IDOK);
    PostMessage (GetParent(hwndDlg), NCDU_REGISTER_DLG,
        NCDU_COPYING_FILES_DLG, (LPARAM)hwndDlg);
    SetCursor(LoadCursor(NULL, IDC_ARROW));

    return FALSE;
}

static
BOOL
MakeFlopDlg_WM_COMMAND (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Process WM_COMMAND message. Stops copying if the Cancel (abort)
        button is pressed.

Arguments:

    IN  HWND    hwndDlg
        Handle to dialog box procedure

    IN  WPARAM  wParam
        LOWORD contains the id of the control that initiated this message

    IN  LPARAM  lParam
        Not Used

Return Value:

--*/
{
    switch (LOWORD(wParam)) {
        case IDCANCEL:
            bCopying = FALSE;
            return TRUE;

        default:    return FALSE;
    }
}

INT_PTR CALLBACK
MakeFlopDlgProc (
    IN  HWND    hwndDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Main Dialog Box Procedure. Dispatches Windows messages to the appropriate
        processing routine. The following windows messages are processed
        by this module:

            WM_INITDIALOG:      dialog initialization routine
            WM_COMMAND:         user input
            NCDU_START_FILE_COPY:   local windows message to start copy op.


Arguments:

    Standard WNDPROC arguments

Return Value:

    FALSE  if message is not processed by this routine, otherwise
        the value returned by the dispatched routine.

--*/
{
    switch (message) {
        case WM_INITDIALOG: return (MakeFlopDlg_WM_INITDIALOG (hwndDlg, wParam, lParam));
        case WM_COMMAND:    return (MakeFlopDlg_WM_COMMAND (hwndDlg, wParam, lParam));
#ifdef JAPAN
//  fixed kkntbug #12382
//      NCAdmin:"[] Make Japanese startup disks" is not functioning.

        case NCDU_START_FILE_COPY:
                            if (bJpnDisk)  {
                                if (!MakeFlopDlg_NCDU_START_FILE_COPY (hwndDlg, SETUP_DOSV_1, lParam))
                                    return TRUE;

                                return (MakeFlopDlg_NCDU_START_FILE_COPY (hwndDlg, SETUP_DOSV_2, lParam));
                            }
                            else
                                return (MakeFlopDlg_NCDU_START_FILE_COPY (hwndDlg, wParam, lParam));
#else
        case NCDU_START_FILE_COPY: return (MakeFlopDlg_NCDU_START_FILE_COPY (hwndDlg, wParam, lParam));
#endif
        case WM_PAINT:      return (Dlg_WM_PAINT (hwndDlg, wParam, lParam));
        case WM_MOVE:       return (Dlg_WM_MOVE (hwndDlg, wParam, lParam));
        case WM_SYSCOMMAND: return (Dlg_WM_SYSCOMMAND (hwndDlg, wParam, lParam));
        default:            return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\clcreator\sharenet.c ===
/*++

    Copyright (c) 1994  Microsoft Corporation

Module Name:

    ShareNet.C

Abstract:

    File copy and sharing dialog

Author:

    Bob Watson (a-robw)

Revision History:

    17 Feb 94    Written

--*/
//
//  Windows Include Files
//

#include <windows.h>
#include <stdio.h>
#include <malloc.h>
#include <tchar.h>      // unicode macros
#include <stdlib.h>     // string to number conversions
#include <lmcons.h>     // lanman API constants
//
//  app include files
//
#include "otnboot.h"
#include "otnbtdlg.h"
//
//  local windows messages
//
#define NCDU_SHARE_DIR              (WM_USER    +101)
#define NCDU_VALIDATE_AND_END       (WM_USER    +103)
#define NCDU_BROWSE_DIST_PATH       (WM_USER    +104)
#define NCDU_BROWSE_DEST_PATH       (WM_USER    +105)
//
//  static variables
//
//
static  int     nNextDialog;            // select dialog to follow this on OK
static  BOOL    bShareNotCopy;          // select default button mode
//
//  these variables are used to remember the contents of the edit controls
//  that are disabled and/or blanked
//
static  TCHAR   szShareName1[MAX_PATH];
static  TCHAR   szDestPath[MAX_PATH];
static  TCHAR   szShareName2[MAX_PATH];
static  TCHAR   szServerName[MAX_PATH];
static  TCHAR   szShareName3[MAX_PATH];

#ifdef TERMSRV
extern TCHAR szCommandLineVal[MAX_PATH];
#endif // TERMSRV


static
LPCTSTR
GetDefaultDestPath (
    VOID
)
/*++

Routine Description:

    Creates a valid path to use as the default destination to copy the
        client files to from the CD. The routine finds the first valid
        local drive, then on that drive, finds the first permutation of
        "Clients" or "Clients[0-9]" that isn't currently on that drive.

Arguments:

    None

Return Value:

    Pointer to the read only string containing the resulting path or
        an empty string if a valid path could not be concocted.

--*/
{
    static TCHAR    szPathBuffer[MAX_PATH];
    BOOL            bFound;
    UINT            nDriveType;
    DWORD           dwFileAttrib;
    LPTSTR          szUniqueChar;

    // start by finding a valid disk drive

    szPathBuffer[0] = cC;
    szPathBuffer[1] = cColon;
    szPathBuffer[2] = cBackslash;
    szPathBuffer[3] = 0;

    bFound = FALSE;

    while (!bFound) {
        nDriveType = GetDriveType (szPathBuffer);
        if (nDriveType == DRIVE_FIXED) {
            bFound = TRUE;
        } else {
            // increment drive letter
            szPathBuffer[0]++;
            if (szPathBuffer[0] > cZ) break;
        }
    }

    if (!bFound) {
        // unable to find a suitable drive so bail out.
        szPathBuffer[0] = 0;
    } else {
        // found a suitable drive so add a directory
        lstrcat (szPathBuffer, cszClientsDir);
        szUniqueChar = &szPathBuffer[lstrlen(szPathBuffer)];
        *(szUniqueChar + 1) = 0;    // add extra null char
        bFound = FALSE;
        while (!bFound) {
            // the path is "found" when it references a non-
            // existent directory
            dwFileAttrib = QuietGetFileAttributes (szPathBuffer);
            if (dwFileAttrib == 0xFFFFFFFF) {
                bFound = TRUE;
            } else {
                if (*szUniqueChar == 0)  {
                    *szUniqueChar = c0;
                } else {
                    if (*szUniqueChar < c9)  {
                        *szUniqueChar += 1; // increment digit
                    } else {
                        // used up all the letters with out finding an
                        // unused dir so return an empty string
                        szPathBuffer [0] = 0;
                        break;
                    }
                }
            }
        }
    }
    return (LPCTSTR)&szPathBuffer[0];
}

static
LPCTSTR
GetDefaultShareName (
    IN  LPCTSTR szServer
)
/*++

Routine Description:

    Creates a share name to be used as a default share. If an unused
        name can be created, then it is returned, if all names are used,
        then an empty string is returned.

Arguments:

    IN  LPCTSTR szServer    pointer to the buffer containing the name of
                            the server on which to look up the share name.
                            if this parameter is NULL, then the local
                            machine is used.

Return Value:

    the pointer to a read-only buffer containing either the name of an
        unused share point or an empty string if such a name cannot be
        created.

--*/
{
    static TCHAR    szNameBuffer[MAX_PATH];

    LPTSTR  szLocalPath;
    LPTSTR  szShareName;
    LPTSTR  szShareIndex;
    TCHAR   cOrigIndexChar;
    DWORD   dwBufLen;
    DWORD   dwFileAttrib;
    BOOL    bFound;

    // allocate a local buffer for building dir path in
    szLocalPath = GlobalAlloc (GPTR, MAX_PATH_BYTES);

    if (szLocalPath == NULL) {
        // unable to allocate mem for local path buffer so return an
        // empty string and leave
        szNameBuffer[0] = 0;
    } else {
        // build a UNC path in the local buffer to test for the
        // existence of the share point
        *szLocalPath = 0;
        lstrcpy (szLocalPath, cszDoubleBackslash);
        if (szServer == NULL) {
            // then look up local computer name
            dwBufLen = MAX_COMPUTERNAME_LENGTH+1;
            GetComputerName (&szLocalPath[2], &dwBufLen);
        } else {
            // use server sent in path
            lstrcat (szLocalPath, szServer);
        }

        lstrcat (szLocalPath, cszBackslash);

        // save pointer to sharepoint name in UNC string

        szShareName = &szLocalPath[lstrlen(szLocalPath)];

        lstrcpy (szShareName, GetStringResource (CSZ_DEFAULT_CLIENT_SHARE));
        // limit name to 8 characters
        if (lstrlen(szShareName) > 8) {
            szShareName[8] = 0;
        }
        // for uniqueness, count the last digit from 0 - 9
        if (lstrlen(szShareName) >= 7) {
            // overwrite the last character
            szShareIndex = &szShareName[7];
            cOrigIndexChar = *szShareIndex;
        } else {
            szShareIndex = &szShareName[lstrlen(szShareName)];
            cOrigIndexChar = 0;
        }

        *(szShareIndex + 1) = 0; // add extra terminating null char

        bFound = FALSE;

        while (!bFound) {
            dwFileAttrib = QuietGetFileAttributes (szLocalPath);
            if (dwFileAttrib == 0xFFFFFFFF) {
                bFound = TRUE;
            } else {
                // this share point already exists, so try the
                // next one in the sequence
                if (*szShareIndex == cOrigIndexChar) {
                    // this is the first retry
                    *szShareIndex = c0;
                } else {
                    if (*szShareIndex < c9) {
                        *szShareIndex += 1; // increment character
                    } else {
                        // all attempted names are in use so bail out with
                        // an empty buffer
                        break;
                    }
                }
            }
        }

        if (bFound) {
            // copy server name to output buffer
            lstrcpy (szNameBuffer, szShareName);
        } else {
            // a valid unused share name wasn't found, so return empty buffer
            szNameBuffer[0] = 0;
        }

        FREE_IF_ALLOC (szLocalPath);
    }

    return (LPCTSTR)&szNameBuffer[0];
}

static
DWORD
UpdateDiskSpace (
    IN  HWND    hwndDlg
)
/*++

Routine Description:

    Computes and display the total estimated disk space required
        to copy the network utilities as read from the .INF

Arguments:

    IN  HWND    hwndDlg

Return Value:

    total bytes required as read from the INI

--*/
{
    DWORD   dwBytesReqd = 0;
    LPTSTR  szFileInfo;
    LPTSTR  szInfName;

    szFileInfo = GlobalAlloc (GPTR, MAX_PATH_BYTES);
    szInfName = GlobalAlloc (GPTR, MAX_PATH_BYTES);

    if ((szFileInfo != NULL) && (szInfName != NULL)) {
        GetDlgItemText (hwndDlg, NCDU_DISTRIBUTION_PATH, szInfName, MAX_PATH);
        if (szInfName[lstrlen(szInfName)-1] != cBackslash) lstrcat(szInfName, cszBackslash);
        lstrcat (szInfName, cszAppInfName);

        QuietGetPrivateProfileString (cszSizes, csz_ClientTree_, cszEmptyString,
            szFileInfo, MAX_PATH, szInfName);

        dwBytesReqd = GetSizeFromInfString (szFileInfo);

        // reuse InfName buffer for output string
        // add 500,000 to bytes rquired in order to round M's up. (div
        // will simply truncate)

        _stprintf (szInfName,
            GetStringResource (FMT_M_BYTES),
            ((dwBytesReqd+500000)/1000000));
        SetDlgItemText (hwndDlg, NCDU_DISK_SPACE_REQD, szInfName);
    }

    FREE_IF_ALLOC(szFileInfo);
    FREE_IF_ALLOC(szInfName);

    return dwBytesReqd;
}

static
VOID
UpdateDialogMode (
    IN  HWND hwndDlg
)
/*++

Routine Description:

    Called to size the dialog box based on the currently selected
        mode. If the "Use existing share" mode is selected, then
        only the top half of the dialog box is visible, if the
        "copy" mode is selected then the entire dialog box is
        visible. All concealed controls are disabled for proper
        tab sequencing.

Arguments:

    IN  HWND    hwndDlg

Return Value:

    None

--*/
{
    BOOL    bUseExistingPath;
    BOOL    bShareFiles;
    BOOL    bCopyAndShare;
    BOOL    bUseExistingShare;
    BOOL    bEnablePath;

    // save any share/path information in case the fields have to be cleared

    EnableWindow (GetDlgItem (hwndDlg, NCDU_FILES_ALREADY_SHARED), TRUE);

    if ( SendDlgItemMessage (hwndDlg, NCDU_DESTINATION_PATH, WM_GETTEXTLENGTH, 0, 0) > 0) {
        GetDlgItemText (hwndDlg, NCDU_DESTINATION_PATH, szDestPath, MAX_PATH);
    }

    if ( SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_1, WM_GETTEXTLENGTH, 0, 0) > 0) {
        GetDlgItemText (hwndDlg, NCDU_SHARE_NAME_1, szShareName1, MAX_PATH);
    }

    if ( SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_2, WM_GETTEXTLENGTH, 0, 0) > 0) {
        GetDlgItemText (hwndDlg, NCDU_SHARE_NAME_2, szShareName2, MAX_PATH);
    }

    if ( SendDlgItemMessage (hwndDlg, NCDU_SERVER_NAME, WM_GETTEXTLENGTH, 0, 0) > 0) {
        GetDlgItemText (hwndDlg, NCDU_SERVER_NAME, szServerName, MAX_PATH);
    }

    if ( SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_3, WM_GETTEXTLENGTH, 0, 0) > 0) {
        GetDlgItemText (hwndDlg, NCDU_SHARE_NAME_3, szShareName3, MAX_PATH);
    }
    // buttons are mutually exclusive so only one of these can (should) be
    // true at a time

    bUseExistingPath =
        (BOOL)(IsDlgButtonChecked(hwndDlg, NCDU_USE_DIST_PATH) == CHECKED);

    bShareFiles =
        (BOOL)(IsDlgButtonChecked(hwndDlg, NCDU_USE_EXISTING_SHARE) == CHECKED);

    bCopyAndShare =
        (BOOL)(IsDlgButtonChecked(hwndDlg, NCDU_COPY_AND_MAKE_SHARE) == CHECKED);

    bUseExistingShare =
        (BOOL)(IsDlgButtonChecked(hwndDlg, NCDU_FILES_ALREADY_SHARED) == CHECKED);

    bEnablePath = !bUseExistingShare;

    // set the dialog to be approrpriate for the current button

    // set the path edit controls
    EnableWindow (GetDlgItem (hwndDlg, NCDU_TOP_PATH_TITLE), bEnablePath);
    EnableWindow (GetDlgItem (hwndDlg, NCDU_DISTRIBUTION_PATH), bEnablePath);
    EnableWindow (GetDlgItem (hwndDlg, NCDU_BROWSE_DIST), bEnablePath);

    // set the "Share Files" controls
    EnableWindow (GetDlgItem (hwndDlg, NCDU_SHARE_FILES_TEXT), bShareFiles);
    EnableWindow (GetDlgItem (hwndDlg, NCDU_SHARE_NAME_1_TITLE), bShareFiles);
    EnableWindow (GetDlgItem (hwndDlg, NCDU_SHARE_NAME_1), bShareFiles);

    if (bShareFiles) {
        SetDlgItemText (hwndDlg, NCDU_SHARE_NAME_1, szShareName1);
    } else {
        SetDlgItemText (hwndDlg, NCDU_SHARE_NAME_1, cszEmptyString);
    }

    // set the "Copy Files..." controls
    EnableWindow (GetDlgItem (hwndDlg, NCDU_DISK_SPACE_REQD), bCopyAndShare);
    EnableWindow (GetDlgItem (hwndDlg, NCDU_DISK_SPACE_REQD_LABEL), bCopyAndShare);
    EnableWindow (GetDlgItem (hwndDlg, NCDU_DESTINATION_PATH_LABEL), bCopyAndShare);
    EnableWindow (GetDlgItem (hwndDlg, NCDU_DESTINATION_PATH), bCopyAndShare);
    EnableWindow (GetDlgItem (hwndDlg, NCDU_SHARE_NAME_2_TITLE), bCopyAndShare);
    EnableWindow (GetDlgItem (hwndDlg, NCDU_SHARE_NAME_2), bCopyAndShare);

    if (bCopyAndShare) {
        SetDlgItemText (hwndDlg, NCDU_DESTINATION_PATH, szDestPath);
        SetDlgItemText (hwndDlg, NCDU_SHARE_NAME_2, szShareName2);
    } else {
        SetDlgItemText (hwndDlg, NCDU_DESTINATION_PATH, cszEmptyString);
        SetDlgItemText (hwndDlg, NCDU_SHARE_NAME_2, cszEmptyString);
    }

    // set "Use Existing Share..." controls
    EnableWindow (GetDlgItem (hwndDlg, NCDU_SERVER_NAME_TITLE), bUseExistingShare);
    EnableWindow (GetDlgItem (hwndDlg, NCDU_SERVER_NAME), bUseExistingShare);
    EnableWindow (GetDlgItem (hwndDlg, NCDU_SHARE_NAME_3_TITLE), bUseExistingShare);
    EnableWindow (GetDlgItem (hwndDlg, NCDU_SHARE_NAME_3), bUseExistingShare);

    if (bUseExistingShare) {
        SetDlgItemText (hwndDlg, NCDU_SERVER_NAME, szServerName);
        SetDlgItemText (hwndDlg, NCDU_SHARE_NAME_3, szShareName3);
    } else {
        SetDlgItemText (hwndDlg, NCDU_SERVER_NAME, cszEmptyString);
        SetDlgItemText (hwndDlg, NCDU_SHARE_NAME_3, cszEmptyString);
    }

    // redraw button box
    UpdateWindow (hwndDlg);
}

static
BOOL
CopyFilesFromDistToDest (
    IN  HWND    hwndDlg
)
/*++

Routine Description:

    copies all clients listed under the distribution directory
        to the destination directory.

Arguments:

    IN  HWND    hwndDlg
        handle to dialog box window

Return Value:

    TRUE if all went ok
    FALSE if the operation was aborted or ended in error.

--*/
{
    LPTSTR  szSourceDir;
    LPTSTR  szDestDir;
    DWORD   dwBytesReqd = 0;
    LPTSTR  szFileInfo;
    DWORD   dwCopyFlags = CD_FLAGS_COPY_SUB_DIR + CD_FLAGS_LONG_NAMES;
    LPTSTR  szClientName;
    LPTSTR  szInfName;
    LPTSTR  mszDirList;
    LPTSTR  szDisplayString;
    LPTSTR  szThisDir;
    DWORD   dwFileAttrib;
    int     nCopyResult;
    CF_DLG_DATA cfData;

    szSourceDir = GlobalAlloc (GPTR, MAX_PATH_BYTES);
    szDestDir = GlobalAlloc (GPTR, MAX_PATH_BYTES);
    szFileInfo = GlobalAlloc (GPTR, MAX_PATH_BYTES);
    szClientName = GlobalAlloc (GPTR, MAX_PATH_BYTES);
    szInfName = GlobalAlloc (GPTR, MAX_PATH_BYTES);
    mszDirList = GlobalAlloc (GPTR, MEDIUM_BUFFER_SIZE * sizeof(TCHAR));

    if ((szSourceDir != NULL) &&
        (szDestDir != NULL) &&
        (szFileInfo != NULL) &&
        (szClientName != NULL) &&
        (mszDirList != NULL) &&
        (szInfName != NULL)){
        // copy files from root dir only first

        lstrcpy (szClientName, GetStringResource (FMT_CLIENT_INFO_DISPLAY));
        cfData.szDisplayName = szClientName;
        cfData.szSourceDir = pAppInfo->szDistShowPath;
        cfData.szDestDir = pAppInfo->szDestPath;
        cfData.dwCopyFlags = CD_FLAGS_LONG_NAMES;
        cfData.dwTotalSize = 0;
        cfData.dwFilesCopied = 0;
        cfData.dwDirsCreated = 0;

        nCopyResult = (int)DialogBoxParam (
            (HANDLE)GetWindowLongPtr(GetParent(hwndDlg), GWLP_HINSTANCE),
            MAKEINTRESOURCE(NCDU_COPYING_FILES_DLG),
            hwndDlg,
            CopyFileDlgProc,
            (LPARAM)&cfData);

        //    go through list of client software to copy an and copy the
        //     selected ones

        lstrcpy (szInfName, pAppInfo->szDistShowPath);
        if (szInfName[lstrlen(szInfName)-1] != cBackslash) lstrcat(szInfName, cszBackslash);
        lstrcat (szInfName, cszAppInfName);

        // get list of keys under the [CopyClients] section
        CLEAR_FIRST_FOUR_BYTES (mszDirList);
        QuietGetPrivateProfileString (cszCopyClients, NULL, cszEmptyString,
            mszDirList, MEDIUM_BUFFER_SIZE, szInfName);

        for (szThisDir = mszDirList;
             (*szThisDir != 0) && (nCopyResult == IDOK);
             szThisDir += lstrlen(szThisDir) + 1) {
            // make dir path for this dir & copy the files if valid
            lstrcpy (szSourceDir, pAppInfo->szDistShowPath);
            if (szSourceDir[lstrlen(szSourceDir)-1] != cBackslash) lstrcat (szSourceDir, cszBackslash);
            lstrcat (szSourceDir, szThisDir);

            dwFileAttrib = QuietGetFileAttributes (szSourceDir);
            // if the resulting source path is a directory then copy it to the
            // destination path
            if ((dwFileAttrib != 0xFFFFFFFF) &&
                ((dwFileAttrib  & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY)) {
                // make dest path
                lstrcpy (szDestDir, pAppInfo->szDestPath);
                if (szDestDir[lstrlen(szDestDir)-1] != cBackslash) lstrcat (szDestDir, cszBackslash);
                lstrcat (szDestDir, szThisDir);

                // copy files

                        QuietGetPrivateProfileString (cszCopyClients, szThisDir, cszEmptyString,
                                szClientName, MAX_PATH, szInfName);

                cfData.szDisplayName = szClientName;
                cfData.szSourceDir = szSourceDir;
                cfData.szDestDir = szDestDir;
                cfData.dwCopyFlags = CD_FLAGS_COPY_SUB_DIR | CD_FLAGS_LONG_NAMES;
                QuietGetPrivateProfileString (cszSizes, szThisDir, cszEmptyString,
                    szFileInfo, MAX_PATH, szInfName);
                // add to total
                cfData.dwTotalSize = GetSizeFromInfString (szFileInfo);
                // keep adding to file and dir counters

                nCopyResult = (int)DialogBoxParam (
                    (HANDLE)GetWindowLongPtr(GetParent(hwndDlg), GWLP_HINSTANCE),
                    MAKEINTRESOURCE(NCDU_COPYING_FILES_DLG),
                    hwndDlg,
                    CopyFileDlgProc,
                    (LPARAM)&cfData);
            } // end if source is really a dir
        } // end for each dir in list loop

        if (nCopyResult == IDOK) {
            szDisplayString = GlobalAlloc (GPTR, MAX_PATH_BYTES);
            if (szDisplayString == NULL) {
                // unable to allocate string buffer so try default message
                DisplayMessageBox (
                hwndDlg,
                NCDU_COPY_COMPLETE,
                0,
                MB_OK_TASK_INFO);
            } else {
                _stprintf (szDisplayString,
                    GetStringResource (FMT_COPY_COMPLETE_STATS),
                    cfData.dwDirsCreated, cfData.dwFilesCopied);
                MessageBox (
                    hwndDlg, szDisplayString,
                    GetStringResource (SZ_APP_TITLE),
                    MB_OK_TASK_INFO);
                FREE_IF_ALLOC (szDisplayString);
            }
        }
    } else {
        nCopyResult = IDCANCEL;
    }

    FREE_IF_ALLOC(szSourceDir);
    FREE_IF_ALLOC(szDestDir);
    FREE_IF_ALLOC(szFileInfo);
    FREE_IF_ALLOC(szClientName);
    FREE_IF_ALLOC(szInfName);
    FREE_IF_ALLOC(mszDirList);

    return (nCopyResult == IDOK ? TRUE : FALSE);
}

static
BOOL
ShareNetSwDlg_WM_INITDIALOG (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Processes the WM_INITDIALOG windows message. Loads the controls
        with the values from the application data structure and
        initializes the display mode (i.e. the dlg box size)

Arguments:

    IN  HWND    hwndDlg
        Handle to the dialog box window

    IN  WPARAM  wParam
        Not Used

    IN  LPARAM  lParam
        Not Used

Return Value:

    FALSE

--*/
{
    LPTSTR  szDlgDistPath;
    DWORD   dwShareType;

    RemoveMaximizeFromSysMenu (hwndDlg);
    PositionWindow  (hwndDlg);

    szDlgDistPath = GlobalAlloc(GPTR, MAX_PATH_BYTES);
    if (szDlgDistPath == NULL) {
        EndDialog (hwndDlg, IDCANCEL);
        return FALSE;
    }
    //
    //  Determine next message for EndDialog Return based on
    //  installation to perform
    //

    if (pAppInfo->itInstall == FloppyDiskInstall) {
        nNextDialog = NCDU_SHOW_CREATE_DISKS_DLG;
    } else if (pAppInfo->itInstall == OverTheNetInstall) {
        nNextDialog = NCDU_SHOW_TARGET_WS_DLG;
    } else if (pAppInfo->itInstall == CopyNetAdminUtils) {
        nNextDialog = NCDU_SHOW_COPY_ADMIN_UTILS;
    }

    // get source path for client files
    if (*pAppInfo->szDistShowPath == 0) {
        // load default values if an existing source dir doesn't exist
        GetDistributionPath (hwndDlg, FDT_CLIENT_TREE,
            szDlgDistPath, MAX_PATH, &dwShareType);
        //then initialize with a default value
        lstrcpy (pAppInfo->szDistShowPath, szDlgDistPath);
    } else {
        if (ValidSharePath(pAppInfo->szDistShowPath) == 0) {
            // a valid path is already loaded
            if (IsUncPath(pAppInfo->szDistShowPath)) {
                dwShareType = NCDU_LOCAL_SHARE_PATH;
            } else {
                dwShareType = NCDU_HARD_DRIVE_PATH;
            }
        } else {
            // lookup a default path to use
            GetDistributionPath (hwndDlg, FDT_CLIENT_TREE,
                szDlgDistPath, MAX_PATH, &dwShareType);
            //then initialize with a default value
            lstrcpy (pAppInfo->szDistShowPath, szDlgDistPath);
        }
    }

    // load fields using data from data structure

    SetDlgItemText (hwndDlg, NCDU_DISTRIBUTION_PATH, pAppInfo->szDistShowPath);
    SetDlgItemText (hwndDlg, NCDU_DESTINATION_PATH, pAppInfo->szDestPath);

    // set edit box text limits
    SendDlgItemMessage (hwndDlg, NCDU_DISTRIBUTION_PATH,
        EM_LIMITTEXT, (WPARAM)(MAX_PATH-1), (LPARAM)0);

    SendDlgItemMessage (hwndDlg, NCDU_DESTINATION_PATH,
        EM_LIMITTEXT, (WPARAM)(MAX_PATH-1), (LPARAM)0);

    SendDlgItemMessage (hwndDlg, NCDU_SERVER_NAME,
        EM_LIMITTEXT, (WPARAM)(MAX_COMPUTERNAME_LENGTH), (LPARAM)0);

    SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_1,
        EM_LIMITTEXT, (WPARAM)(MAX_SHARENAME-1), (LPARAM)0);

    SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_2,
        EM_LIMITTEXT, (WPARAM)(MAX_SHARENAME-1), (LPARAM)0);

    SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_3,
        EM_LIMITTEXT, (WPARAM)(MAX_SHARENAME-1), (LPARAM)0);

    // initialize field variables
    lstrcpy (szShareName1, GetDefaultShareName(NULL));
    lstrcpy (szShareName2, GetDefaultShareName(NULL));
    lstrcpy (szDestPath, GetDefaultDestPath());
    SetDlgItemText (hwndDlg, NCDU_SHARE_NAME_1, szShareName1);
    SetDlgItemText (hwndDlg, NCDU_DESTINATION_PATH, szDestPath);
    SetDlgItemText (hwndDlg, NCDU_SHARE_NAME_2, szShareName2);

    // set dialog state to appropriate value
    bShareNotCopy = (dwShareType == NCDU_CDROM_PATH ? FALSE : TRUE);
    if (pAppInfo->bUseExistingPath) {
        CheckRadioButton (hwndDlg,
            NCDU_USE_DIST_PATH,
            NCDU_FILES_ALREADY_SHARED,
            NCDU_USE_DIST_PATH);
        SendDlgItemMessage (hwndDlg, NCDU_DISTRIBUTION_PATH,
            EM_SETSEL, (WPARAM)0, (LPARAM)-1);
        SetFocus (GetDlgItem(hwndDlg, NCDU_DISTRIBUTION_PATH));
    } else {
        switch (dwShareType) {
            case NCDU_NO_CLIENT_PATH_FOUND:
                // no path found
                CheckRadioButton (hwndDlg,
                    NCDU_USE_DIST_PATH,
                    NCDU_FILES_ALREADY_SHARED,
                    NCDU_USE_EXISTING_SHARE);
                SendDlgItemMessage (hwndDlg, NCDU_DISTRIBUTION_PATH,
                    EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                SetFocus (GetDlgItem(hwndDlg, NCDU_DISTRIBUTION_PATH));
                break;

            case NCDU_HARD_DRIVE_PATH:
                // path found on hard drive so default is to share
                CheckRadioButton (hwndDlg,
                    NCDU_USE_DIST_PATH,
                    NCDU_FILES_ALREADY_SHARED,
                    NCDU_USE_EXISTING_SHARE);
                SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_1,
                    EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                SetFocus (GetDlgItem(hwndDlg, NCDU_SHARE_NAME_1));
                break;

            case NCDU_CDROM_PATH:
                // path found on CD-ROM so default is to copy & share
                CheckRadioButton (hwndDlg,
                    NCDU_USE_DIST_PATH,
                    NCDU_FILES_ALREADY_SHARED,
                    NCDU_COPY_AND_MAKE_SHARE);
                SendDlgItemMessage (hwndDlg, NCDU_DESTINATION_PATH,
                    EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                SetFocus (GetDlgItem(hwndDlg, NCDU_DESTINATION_PATH));
                break;

            case NCDU_PATH_FROM_REGISTRY:
            case NCDU_LOCAL_SHARE_PATH:
                // path already shared
                CheckRadioButton (hwndDlg,
                    NCDU_USE_DIST_PATH,
                    NCDU_FILES_ALREADY_SHARED,
                    NCDU_FILES_ALREADY_SHARED);
                if (GetServerFromUnc (pAppInfo->szDistShowPath, szDlgDistPath)) {
                    _tcsupr(szDlgDistPath);
                    lstrcpy (szServerName, szDlgDistPath);
                    SetDlgItemText (hwndDlg, NCDU_SERVER_NAME, szDlgDistPath);
                    if (GetShareFromUnc (pAppInfo->szDistShowPath, szDlgDistPath)) {
                        lstrcpy (szShareName3, szDlgDistPath);
                        SetDlgItemText (hwndDlg, NCDU_SHARE_NAME_3, szDlgDistPath);
                    } else {
                        // unable to look up share point so go back to dist path
                        SetDlgItemText (hwndDlg, NCDU_SHARE_NAME_1, cszEmptyString);
                        CheckRadioButton (hwndDlg,
                            NCDU_USE_DIST_PATH,
                            NCDU_FILES_ALREADY_SHARED,
                            NCDU_USE_EXISTING_SHARE);
                    }
                } else {
                    // unable to look up server, so go back to dist path
                    SetDlgItemText (hwndDlg, NCDU_SERVER_NAME, cszEmptyString);
                    CheckRadioButton (hwndDlg,
                        NCDU_USE_DIST_PATH,
                        NCDU_FILES_ALREADY_SHARED,
                        NCDU_USE_EXISTING_SHARE);
                }
                SetFocus (GetDlgItem (hwndDlg, IDOK));
                break;
        }
    }


    UpdateDiskSpace(hwndDlg);
    UpdateDialogMode (hwndDlg);

    PostMessage (GetParent(hwndDlg), NCDU_CLEAR_DLG, (WPARAM)hwndDlg, IDOK);
    PostMessage (GetParent(hwndDlg), NCDU_REGISTER_DLG,
        NCDU_SHARE_NET_SW_DLG, (LPARAM)hwndDlg);

    SetCursor(LoadCursor(NULL, IDC_ARROW));

    FREE_IF_ALLOC (szDlgDistPath);
    return FALSE;
}

static
BOOL
ShareNetSwDlg_NCDU_SHARE_DIR (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam, // not used
    IN  LPARAM  lParam  // pointer to SPS_DATA block
)
/*++

Routine Description:

    Shares the Distribution dir path.
        Uses the share name entered in the display. If
        successful this message terminates the dialog box, otherwise
        an error message will be displayed.

Arguments:

    IN  HWND    hwndDlg
        Handle to dialog box window

    IN  WPARAM  wParam
        Not Used

    IN  LPARAM  lParam
        pointer to SPS_DATA block

Return Value:

    TRUE if shared
    FALSE if not (GetLastError for info)

--*/
{
    PSPS_DATA   pspData;
    LPWSTR      szTempMachineName = NULL;
    int         nDlgBoxStatus;

    pspData = (PSPS_DATA)lParam;

    if (*pspData->szServer != cBackslash) {
        szTempMachineName = GlobalAlloc (GPTR, MAX_PATH_BYTES);
        if (szTempMachineName != NULL) {
            lstrcpy (szTempMachineName, cszDoubleBackslash);
            lstrcat (szTempMachineName, pspData->szServer);
            pspData->szServer = szTempMachineName;
        }
    }

    nDlgBoxStatus = (int)DialogBoxParam (
        (HINSTANCE)GetWindowLongPtr(hwndDlg, GWLP_HINSTANCE),
        MAKEINTRESOURCE (NCDU_DLG_SHARING_PATH),
        hwndDlg,
        SharePathDlgProc,
        lParam);

    FREE_IF_ALLOC (szTempMachineName);

    return (nDlgBoxStatus == IDOK ? TRUE : FALSE);
}

static
BOOL
ShareNetSwDlg_IDOK (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Processes the IDOK button depending on the mode selected. If the
        copy files mode is selected, then the source, destination and
        clients are validated and the files are copied. If the share
        distribution mode is selected, then the directory path is
        shared on the local machine.

        The validation consists of the following:

        FILES_ALREADY_SHARED: (bottom button)
            Get Server Name
                must be non blank
                must be name of machine on network
            Get Sharepoint Name
                must be non-blank
                must exist on above server
                signal if > DOS compatible name length
            \\server\share must be a valid client directory tree

        Use the distribution path: (any of the top buttons)
            Check Destination path
                must be non-blank
                must be a valid client distribution directory tree

            SHARE DISTRIBUTION_PATH:
                Get share name
                    must be non-blank
                    must not be in use
                    signal if > DOS compatible name length
                    Signal if name is in currently in use
                        user may either use current name or change

            COPY AND SHARE:
                Get Destination Path
                    must be non-blank

                Get share name
                    must be non-blank
                    must not be in use
                    signal if > DOS compatible name length
                    Signal if name is in currently in use

                Check disk space on destination machine
                Copy files from distribution to destination dir's
                If copy  went OK, then update dlg fields and share

            USE EXISTING PATH:
                no sharing or validation:

Arguments:

    IN HWND hwndDlg

Return Value:

    TRUE if the message is processed by this routine
    FALSE if not

--*/
{
    LPTSTR  szDlgDistPath;
    LPTSTR  szDlgDestPath;
    LPTSTR  szPathBuff;
    LPTSTR  szMsgBuff;
    LPTSTR  szSharePath;
    TCHAR   szDlgShareName[MAX_SHARENAME];
    TCHAR   szServerName[MAX_COMPUTERNAME_LENGTH+1];
    UINT    nDirMsg;
    BOOL    bShareDest;
    DWORD   dwBytesToCopy;
    DWORD   dwBufLen;
    DWORD   dwShareType;
    SPS_DATA    spData;
    LPTSTR  szShareName;
    int     nMbResult;
    BOOL    bFinishOff = FALSE;

    switch (HIWORD(wParam)) {
        case BN_CLICKED:
            szDlgDistPath = GlobalAlloc (GPTR, MAX_PATH_BYTES);
            szDlgDestPath = GlobalAlloc (GPTR, MAX_PATH_BYTES);
            szPathBuff = GlobalAlloc (GPTR, MAX_PATH_BYTES);
            szMsgBuff = GlobalAlloc (GPTR, SMALL_BUFFER_SIZE * sizeof(TCHAR));
            szSharePath = GlobalAlloc (GPTR, MAX_PATH_BYTES);

            if ((szDlgDistPath != NULL) &&
                (szDlgDestPath != NULL) &&
                (szMsgBuff != NULL) &&
                (szSharePath != NULL) &&
                (szPathBuff != NULL)) {
                if (IsDlgButtonChecked(hwndDlg, NCDU_FILES_ALREADY_SHARED) == CHECKED) {
                    // use server & share found in the group box
                    // make UNC from server & share found in dialog box
                    lstrcpy (szDlgDistPath, cszDoubleBackslash);
                    GetDlgItemText (hwndDlg, NCDU_SERVER_NAME,
                        &szDlgDistPath[2], MAX_COMPUTERNAME_LENGTH+1);
                    TrimSpaces (&szDlgDistPath[2]);
                    if (lstrlen (&szDlgDistPath[2]) == 0) {
                        DisplayMessageBox (
                            hwndDlg,
                            NCDU_NO_SERVER,
                            0,
                            MB_OK_TASK_EXCL);
                        SetDlgItemText (hwndDlg, NCDU_SERVER_NAME,
                            &szDlgDistPath[2]);
                        SetFocus (GetDlgItem (hwndDlg, NCDU_SERVER_NAME));
                        SendDlgItemMessage (hwndDlg, NCDU_SERVER_NAME,
                            EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                        goto IDOK_ExitClicked;
                    }
                    if (ComputerPresent (szDlgDistPath)) {
                        lstrcat (szDlgDistPath, cszBackslash);
                        szShareName = &szDlgDistPath[lstrlen(szDlgDistPath)];
                        GetDlgItemText (hwndDlg, NCDU_SHARE_NAME_3,
                            szShareName, MAX_SHARENAME+1);
                        TrimSpaces(szShareName);
                        SetDlgItemText (hwndDlg, NCDU_SHARE_NAME_3,
                            szShareName);
                        if (lstrlen(szShareName) > LM20_DEVLEN) {
                            nMbResult = DisplayMessageBox (
                                hwndDlg,
                                NCDU_NOT_DOS_SHARE,
                                0,
                                MB_OKCANCEL_TASK_EXCL_DEF2);
                            if (nMbResult == IDCANCEL) {
                                // they pressed cancel, so go back to the offending share  and
                                // try again
                                SetFocus (GetDlgItem (hwndDlg, NCDU_SHARE_NAME_3));
                                SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_3,
                                    EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                                goto IDOK_ExitClicked;
                            }
                            // if here the user want's to keep the share name so continue
                        }

                        if (lstrlen(szShareName) == 0) {
                            DisplayMessageBox (
                                hwndDlg,
                                NCDU_NO_SHARE_NAME,
                                0,
                                MB_OK_TASK_EXCL);
                            SetFocus (GetDlgItem (hwndDlg, NCDU_SHARE_NAME_3));
                            SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_3,
                                EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                            goto IDOK_ExitClicked;
                        }
                        if (szDlgDistPath[lstrlen(szDlgDistPath)-1] != cBackslash)
                            lstrcat (szDlgDistPath, cszBackslash);
                        dwShareType =  ValidSharePath (szDlgDistPath);
                        if (dwShareType == 0) {
                            // valid, so copy to dist path and exit
                            lstrcpy (pAppInfo->szDistShowPath, szDlgDistPath);
                            lstrcpy (pAppInfo->szDistPath, szDlgDistPath);
                            bFinishOff = TRUE;
                        } else {
                            // unable to locate sharepoint
                            DisplayMessageBox (
                                hwndDlg,
                                dwShareType,
                                0,
                                MB_OK_TASK_EXCL);

                            SetFocus (GetDlgItem (hwndDlg, NCDU_SHARE_NAME_3));
                            SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_3,
                                EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                        }
                    } else {
                        // unable to locate server
                        DisplayMessageBox (
                            hwndDlg,
                            NCDU_SERVER_NOT_PRESENT,
                            0,
                            MB_OK_TASK_EXCL);

                        SetFocus (GetDlgItem (hwndDlg, NCDU_SERVER_NAME));
                        SendDlgItemMessage (hwndDlg, NCDU_SERVER_NAME,
                            EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                    }
                } else {
                    // they want to use the path in the edit box so
                    // validate distribution directory path
                    GetDlgItemText (hwndDlg, NCDU_DISTRIBUTION_PATH, szDlgDistPath, MAX_PATH);
                    TrimSpaces (szDlgDistPath);
                    if (lstrlen(szDlgDistPath) == 0) {
                        // no source path
                        DisplayMessageBox (
                            hwndDlg,
                            NCDU_PATH_CANNOT_BE_BLANK,
                            0,
                            MB_OK_TASK_EXCL);
                        // set focus and leave so the user can correct
                        SetFocus (GetDlgItem (hwndDlg, NCDU_DISTRIBUTION_PATH));
                        SendDlgItemMessage (hwndDlg, NCDU_DISTRIBUTION_PATH,
                            EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                        goto IDOK_ExitClicked;
                    }

                    if ((nDirMsg = ValidSharePath(szDlgDistPath)) != 0) {
                        // error in Distribution path
                        DisplayMessageBox (
                            hwndDlg,
                            nDirMsg,
                            0,
                            MB_OK_TASK_EXCL);
#ifdef TERMSRV
                        szCommandLineVal[0] = 0x00;
#endif // TERMSRV
                        // error in directory path so set focus to directory entry
                        SetFocus (GetDlgItem(hwndDlg, NCDU_DISTRIBUTION_PATH));
                        SendDlgItemMessage (hwndDlg, NCDU_DISTRIBUTION_PATH,
                            EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                        goto IDOK_ExitClicked;
                    }

                    // distribution path is valid so save the path
                    // and the server and then continue
                    lstrcpy (pAppInfo->szDistShowPath, szDlgDistPath);

                    if (IsDlgButtonChecked(hwndDlg, NCDU_USE_EXISTING_SHARE) == CHECKED) {
                        GetNetPathInfo (pAppInfo->szDistShowPath, szServerName,
                            szSharePath);

                        if ((*szServerName == 0) || (*szSharePath == 0)) {
                            // unable to get path information
                            DisplayMessageBox (
                                hwndDlg,
                                NCDU_UNABLE_GET_PATH_INFO,
                                0,
                                MB_OK_TASK_EXCL);
                            SetFocus (GetDlgItem(hwndDlg, NCDU_DISTRIBUTION_PATH));
                            SendDlgItemMessage (hwndDlg, NCDU_DISTRIBUTION_PATH,
                                EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                            goto IDOK_ExitClicked;
                        }

                        // share the path in the source name edit control

                        GetDlgItemText (hwndDlg, NCDU_SHARE_NAME_1, szDlgShareName, MAX_SHARENAME);
                        TrimSpaces (szDlgShareName);
                        // update edit field in case we need to come back
                        SetDlgItemText (hwndDlg, NCDU_SHARE_NAME_1, szDlgShareName);

                        if (lstrlen(szDlgShareName) > LM20_DEVLEN) {
                            nMbResult = DisplayMessageBox (
                                hwndDlg,
                                NCDU_NOT_DOS_SHARE,
                                0,
                                MB_OKCANCEL_TASK_EXCL_DEF2);
                            if (nMbResult == IDCANCEL) {
                                // they pressed cancel, so go back to the offending share  and
                                // try again
                                SetFocus (GetDlgItem (hwndDlg, NCDU_SHARE_NAME_1));
                                SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_1,
                                    EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                                goto IDOK_ExitClicked;
                            }
                            // if here the user want's to keep the share name so continue
                        } else if (lstrlen(szDlgShareName) == 0) {
                            // no share name specified so display error and
                            // exit
                            DisplayMessageBox (
                                hwndDlg,
                                NCDU_NO_SHARE_NAME,
                                0,
                                MB_OK_TASK_EXCL);
                            SetFocus (GetDlgItem(hwndDlg,
                                NCDU_SHARE_NAME_1));
                            SendDlgItemMessage (hwndDlg,
                                NCDU_SHARE_NAME_1,
                                EM_SETSEL, (WPARAM)0,
                                (LPARAM)-1);
                            goto IDOK_ExitClicked;
                        }
                        // there is a share name so try to share the source
                        // dir. if it's not a UNC since they are by
                        // definition shared
                        if (IsShareNameUsed (szServerName, szDlgShareName,
                            &dwShareType, szPathBuff)) {
                            if (dwShareType == NCDU_SHARE_IS_CLIENT_TREE) {
                                // then this is the name of a shared client
                                // dir tree already, so tell the user about it
                                _stprintf (szMsgBuff,
                                    GetStringResource (FMT_SHARE_IS_CLIENT_TREE),
                                    szDlgShareName, szServerName, szPathBuff);
                                if (MessageBox (hwndDlg, szMsgBuff,
                                    GetStringResource (SZ_APP_TITLE),
                                    MB_OKCANCEL_TASK_EXCL_DEF2) == IDOK) {
                                    // use the existing path and share name
                                    lstrcpy (pAppInfo->szDistShowPath, cszDoubleBackslash);
                                    lstrcat (pAppInfo->szDistShowPath, szServerName);
                                    lstrcat (pAppInfo->szDistShowPath, cszBackslash);
                                    lstrcat (pAppInfo->szDistShowPath, szDlgShareName);
                                    lstrcat (pAppInfo->szDistShowPath, cszBackslash);
                                    SetDlgItemText (hwndDlg, NCDU_DISTRIBUTION_PATH, pAppInfo->szDistShowPath);
                                    SetDlgItemText (hwndDlg, NCDU_SHARE_NAME_1, cszEmptyString);
                                    // that's it then, so exit
                                    lstrcpy (pAppInfo->szDistPath, pAppInfo->szDistShowPath);
                                    bFinishOff = TRUE;
                                } else {
                                    // they want to try again
                                    SetFocus (GetDlgItem (hwndDlg, NCDU_SHARE_NAME_1));
                                    SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_1,
                                        EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                                    goto IDOK_ExitClicked;
                                }
                            } else {
                                // this is the name of some other shared
                                // directory so tell the user
                                _stprintf (szMsgBuff,
                                    GetStringResource (FMT_SHARE_IS_ALREADY_USED),
                                    szDlgShareName, szServerName, szPathBuff);
                                MessageBox (hwndDlg, szMsgBuff,
                                    GetStringResource (SZ_APP_TITLE),
                                    MB_OK_TASK_EXCL);
                                SetFocus (GetDlgItem (hwndDlg, NCDU_SHARE_NAME_1));
                                SendDlgItemMessage (hwndDlg,
                                    NCDU_SHARE_NAME_1,
                                    EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                                goto IDOK_ExitClicked;
                            }
                        } else {
                            // share name isn't in use, so go ahead and share it
                            // try to share
                            lstrcpy (szMsgBuff, GetStringResource (FMT_SHARE_REMARK));
                            spData.szServer = szServerName;
                            spData.szPath = szSharePath;
                            spData.szShareName = szDlgShareName;
                            spData.szRemark = szMsgBuff;
                            if (ShareNetSwDlg_NCDU_SHARE_DIR (hwndDlg,
                                (WPARAM)0, (LPARAM)&spData)) {
                                // shared successfully so
                                //  make new UNC for distribution path
                                //  then exit
                                lstrcpy (pAppInfo->szDistShowPath, cszDoubleBackslash);
                                lstrcat (pAppInfo->szDistShowPath, szServerName);
                                lstrcat (pAppInfo->szDistShowPath, cszBackslash);
                                lstrcat (pAppInfo->szDistShowPath, szDlgShareName);
                                SetDlgItemText (hwndDlg, NCDU_DISTRIBUTION_PATH,
                                    pAppInfo->szDistShowPath);
                                lstrcpy (pAppInfo->szDistPath, pAppInfo->szDistShowPath);
                                bFinishOff = TRUE;
                            } else {
                                // unable to share dir, error has been
                                // signaled via message box already
                                SetFocus (GetDlgItem(hwndDlg,
                                    NCDU_SHARE_NAME_1));
                                SendDlgItemMessage (hwndDlg,
                                    NCDU_SHARE_NAME_1,
                                    EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                            }
                        } // end if sharename has some text
                    } else if (IsDlgButtonChecked(hwndDlg, NCDU_COPY_AND_MAKE_SHARE) == CHECKED) {
                        // copy the files from the distribution path to the destination
                        // path then share the destination path
                        // check destination string
                        GetDlgItemText (hwndDlg, NCDU_DESTINATION_PATH, szDlgDestPath, MAX_PATH);
                        TrimSpaces (szDlgDestPath);
                        SetDlgItemText (hwndDlg, NCDU_DESTINATION_PATH, szDlgDestPath);
                        if (lstrlen(szDlgDestPath) == 0) {
                            // destination path is empty so go back and try again
                            // no source path
                            DisplayMessageBox (
                                hwndDlg,
                                NCDU_PATH_CANNOT_BE_BLANK,
                                0,
                                MB_OK_TASK_EXCL);
                            // set focus and leave so the user can correct
                            SetFocus (GetDlgItem (hwndDlg, NCDU_DESTINATION_PATH));
                            SendDlgItemMessage (hwndDlg, NCDU_DESTINATION_PATH,
                                EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                            goto IDOK_ExitClicked;
                        } else {
                            // there's a string in the destination so
                            // trim and copy to global struct
                            lstrcpy (pAppInfo->szDestPath, szDlgDestPath);
                            // see if there's a share name
                            GetDlgItemText (hwndDlg, NCDU_SHARE_NAME_2,
                                szDlgShareName, MAX_SHARENAME);
                            TrimSpaces (szDlgShareName);
                            SetDlgItemText (hwndDlg, NCDU_SHARE_NAME_2,
                                szDlgShareName);
                            if (lstrlen(szDlgShareName) > LM20_DEVLEN) {
                                nMbResult = DisplayMessageBox (
                                    hwndDlg,
                                    NCDU_NOT_DOS_SHARE,
                                    0,
                                    MB_OKCANCEL_TASK_EXCL_DEF2);
                                if (nMbResult == IDCANCEL) {
                                    // they pressed cancel, so go back to the offending share  and
                                    // try again
                                    SetFocus (GetDlgItem (hwndDlg, NCDU_SHARE_NAME_2));
                                    SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_2,
                                        EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                                    goto IDOK_ExitClicked;
                                }
                                // if here the user want's to keep the share name so continue
                            }
                            if (lstrlen(szDlgShareName) == 0) {
                                // no share name so display error and
                                // bail out
                                DisplayMessageBox (
                                    hwndDlg,
                                    NCDU_NO_SHARE_NAME,
                                    0,
                                    MB_OK_TASK_EXCL);
                                SetFocus (GetDlgItem(hwndDlg,
                                    NCDU_SHARE_NAME_2));
                                SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_2,
                                    EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                                goto IDOK_ExitClicked;
                            } else {
                                GetNetPathInfo (pAppInfo->szDestPath,
                                    szServerName,
                                    szSharePath);

                                if ((*szServerName == 0) || (*szSharePath == 0)) {
                                    // unable to get path information
                                    DisplayMessageBox (
                                        hwndDlg,
                                        NCDU_UNABLE_GET_PATH_INFO,
                                        0,
                                        MB_OK_TASK_EXCL);
                                    SetFocus (GetDlgItem (hwndDlg, NCDU_DESTINATION_PATH));
                                    SendDlgItemMessage (hwndDlg, NCDU_DESTINATION_PATH,
                                        EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                                    goto IDOK_ExitClicked;
                                }

                                if (IsShareNameUsed (szServerName, szDlgShareName,
                                    &dwShareType, szPathBuff)) {
                                    // this is the name of some other shared
                                    // directory so tell the user
                                    _stprintf (szMsgBuff,
                                        GetStringResource (FMT_SHARE_IS_ALREADY_USED),
                                        szDlgShareName, szServerName, szPathBuff);
                                    MessageBox (hwndDlg, szMsgBuff,
                                        GetStringResource (SZ_APP_TITLE),
                                        MB_OK_TASK_EXCL);
                                    SetFocus (GetDlgItem (hwndDlg, NCDU_SHARE_NAME_2));
                                    SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_2,
                                        EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                                    goto IDOK_ExitClicked;
                                } else {
                                    // indicate that the destination dir
                                    // should be shared after the files have been
                                    // copied.
                                    bShareDest = TRUE;
                                }
                            }
                            // so at this point there's a destination dir and
                            // a share name if one's needed. finally we need to
                            // see if any client's have been selected to be
                            // copied.
                            dwBytesToCopy = UpdateDiskSpace(hwndDlg);
                            if (dwBytesToCopy == 0) {
                                DisplayMessageBox (
                                    hwndDlg,
                                    NCDU_NO_CLIENTS_SELECTED,
                                    0,
                                    MB_OK_TASK_EXCL);
                                SetFocus (GetDlgItem(hwndDlg, NCDU_DISTRIBUTION_PATH));
                                SendDlgItemMessage (hwndDlg, NCDU_DISTRIBUTION_PATH,
                                    EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                                goto IDOK_ExitClicked;
                            }
                            // there's clients selected, now see if they'll fit
                            if (ComputeFreeSpace(pAppInfo->szDestPath) < dwBytesToCopy) {
                                DisplayMessageBox (
                                    hwndDlg,
                                    NCDU_INSUFFICIENT_DISK_SPACE,
                                    0,
                                    MB_OK_TASK_EXCL);
                                SetFocus (GetDlgItem(hwndDlg, NCDU_DESTINATION_PATH));
                                SendDlgItemMessage (hwndDlg, NCDU_DESTINATION_PATH,
                                    EM_SETSEL, (WPARAM)0, (LPARAM)-1);

                                goto IDOK_ExitClicked;
                            }
                            // so there should be enough free space
                            if (CopyFilesFromDistToDest (hwndDlg)) {
                                // copy was successful so
                                // copy destination name to distribution name
                                lstrcpy (pAppInfo->szDistShowPath,
                                    pAppInfo->szDestPath);
                                *pAppInfo->szDestPath = 0;
                                // update dialog box fields
                                SetDlgItemText (hwndDlg, NCDU_DISTRIBUTION_PATH,
                                    pAppInfo->szDistShowPath);
                                SetDlgItemText (hwndDlg, NCDU_DESTINATION_PATH,
                                    pAppInfo->szDestPath);
                                // since the files have been successfully copied and
                                // and the paths have been transposed (i.e. dest is now
                                // dist) update the button state so that if a sharing
                                // error occurs, the files won't have to be copied again
                                CheckRadioButton (hwndDlg,
                                    NCDU_USE_DIST_PATH,
                                    NCDU_FILES_ALREADY_SHARED,
                                    NCDU_USE_EXISTING_SHARE);

                                bShareNotCopy = TRUE;
                                UpdateDialogMode (hwndDlg);
                                //
                                // then share the destination dir (which is now
                                // in the distribution path)
                                if (bShareDest) {
                                    lstrcpy (szMsgBuff, GetStringResource (FMT_SHARE_REMARK));
                                    spData.szServer = szServerName; // local machine
                                    spData.szPath = szSharePath;
                                    spData.szShareName = szDlgShareName;
                                    spData.szRemark = szMsgBuff;
                                    if (ShareNetSwDlg_NCDU_SHARE_DIR (hwndDlg,
                                        (WPARAM)0, (LPARAM)&spData)) {
                                        // shared successfully so
                                        //  make new UNC for distribution path
                                        //  then exit
                                        lstrcpy (pAppInfo->szDistShowPath, cszDoubleBackslash);
                                        lstrcat (pAppInfo->szDistShowPath, szServerName);
                                        lstrcat (pAppInfo->szDistShowPath, cszBackslash);
                                        lstrcat (pAppInfo->szDistShowPath, szDlgShareName);
                                        SetDlgItemText (hwndDlg, NCDU_DISTRIBUTION_PATH,
                                            pAppInfo->szDistShowPath);
                                        lstrcpy (pAppInfo->szDistPath, pAppInfo->szDistShowPath);
                                        bFinishOff = TRUE;
                                    } else {
                                        // the share operation failed, but was
                                        // already signaled.
                                        SetFocus (GetDlgItem (hwndDlg, NCDU_SHARE_NAME_1));
                                        SendDlgItemMessage (hwndDlg, NCDU_SHARE_NAME_1,
                                            EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                                    }
                                } else {
                                    // just leave
                                    lstrcpy (pAppInfo->szDistPath, pAppInfo->szDistShowPath);
                                    bFinishOff = TRUE;
                                }
                            } else {
                                // copy was not successful, but error has
                                // already been signaled to the user
                                SetFocus (GetDlgItem (hwndDlg, NCDU_DESTINATION_PATH));
                                SendDlgItemMessage (hwndDlg, NCDU_DESTINATION_PATH,
                                    EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                            }
                        } // end if there's a destination directory entry
                    } else { // end if copy and share is checked
                        // they must want to use an existing path
                        // if this is for the Make Over The Net boot disk
                        // then this must be a shared path
                        //
                        // at this point we can assume the path is VALID and a
                        // distribution tree. Now see if it's visible over
                        // the network if it's needed for an OTN install disk
                        if (pAppInfo->itInstall == OverTheNetInstall) {
                            if (IsUncPath (pAppInfo->szDistShowPath)) {
                                // if it's UNC and VALID then it must be shared so
                                // just copy from display to use path
                                lstrcpy (pAppInfo->szDistPath,
                                    pAppInfo->szDistShowPath);
                                bFinishOff = TRUE;
                            } else {
                                // not a UNC, so see if the path is shared
                                if (OnRemoteDrive(pAppInfo->szDistShowPath)) {
                                    // If it's on a remote drive, then it
                                    // must be shared some where
                                    // make into a UNC before leaving
                                    lstrcpy (szDlgDistPath, pAppInfo->szDistShowPath);
                                    dwBufLen = MAX_PATH_BYTES;
                                    LookupRemotePath (szDlgDistPath, pAppInfo->szDistPath, &dwBufLen);
                                    bFinishOff = TRUE;
                                } else {
                                    // it's not a remote drive so see if it's shared
                                    // locally.
                                    dwBufLen = MAX_PATH_BYTES;
                                    if (LookupLocalShare(pAppInfo->szDistShowPath, TRUE, szDlgDistPath, &dwBufLen)) {
                                        lstrcpy (pAppInfo->szDistPath, szDlgDistPath);
                                        bFinishOff = TRUE;
                                    } else {
                                        // it's not shared on this or any other
                                        // machine so there's no point in continuing
                                        // with an OTN install disk.
                                        DisplayMessageBox (
                                            hwndDlg,
                                            NCDU_EXIT_SHARE_PATH,
                                            0,
                                            MB_OK_TASK_EXCL);
                                        bFinishOff = FALSE;
                                    } // endif look up local share
                                } // end if lookup remote drive
                            } // end if UNC path name
                        } else {
                            // there's no reason to require the path be
                            // shared just to make some floppy disks so
                            // continue
                            lstrcpy (pAppInfo->szDistPath, pAppInfo->szDistShowPath);
                            bFinishOff = TRUE;
                        } // end if OTN install
                    } // endif Use Exisiting Path
                }// end if files not already shared
            } // end if memory allocation was successful

IDOK_ExitClicked:
            FREE_IF_ALLOC(szDlgDistPath);
            FREE_IF_ALLOC(szDlgDestPath);
            FREE_IF_ALLOC(szMsgBuff);
            FREE_IF_ALLOC(szPathBuff);
            FREE_IF_ALLOC(szSharePath);

            if (bFinishOff){
                PostMessage (hwndDlg, NCDU_VALIDATE_AND_END,
                    (WPARAM)FALSE, (LPARAM)0);
            } else {
                SetCursor(LoadCursor(NULL, IDC_ARROW));
            }

            return TRUE;

        default:
            return FALSE;
    }
}

static
BOOL
ShareNetSwDlg_WM_COMMAND (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Processes the WM_COMMAND windows message in response to user input.
        Dispatches to the appropriate routine based on the control that
        was selected.

Arguments:

    IN  HWND    hwndDlg
        Handle to dialog box window

    IN  WPARAM  wParam
        LOWORD  has id of control sending the message
        HIWORD  has the notification code (if applicable)

    IN  LPARAM  lParam
        Not Used

Return Value:

    TRUE if message not processed by this routine, otherwise the value
        returned by the dispatched routine

--*/
{
    switch (LOWORD(wParam)) {
        case IDOK:      return ShareNetSwDlg_IDOK (hwndDlg, wParam, lParam);
        case IDCANCEL:
            switch (HIWORD(wParam)) {
                case BN_CLICKED:
                    PostMessage (GetParent(hwndDlg), NCDU_SHOW_SW_CONFIG_DLG, 0, 0);
                    SetCursor(LoadCursor(NULL, IDC_WAIT));
                    return TRUE;

                default:
                    return FALSE;
            }

        case NCDU_BROWSE_DIST:
            switch (HIWORD(wParam)) {
                case BN_CLICKED:
                    PostMessage (hwndDlg, NCDU_BROWSE_DIST_PATH, 0, 0);
                    SetCursor(LoadCursor(NULL, IDC_WAIT));
                    return TRUE;

                default:
                    return FALSE;
            }

        case NCDU_USE_DIST_PATH:
        case NCDU_USE_EXISTING_SHARE:
        case NCDU_COPY_AND_MAKE_SHARE:
        case NCDU_FILES_ALREADY_SHARED:
            // these buttons don't send a notification message
            UpdateDiskSpace (hwndDlg);
            UpdateDialogMode (hwndDlg);
            return TRUE;

        case NCDU_DISTRIBUTION_PATH:
            switch (HIWORD(wParam)) {
                case EN_KILLFOCUS:
                    UpdateDiskSpace(hwndDlg);
                    return TRUE;

                default:
                    return FALSE;
            }

        case NCDU_SHARE_NET_SW_DLG_HELP:
            switch (HIWORD(wParam)) {
                case BN_CLICKED:
//                    return ShowAppHelp (hwndDlg, LOWORD(wParam));
                    return PostMessage (GetParent(hwndDlg), WM_HOTKEY,
                        (WPARAM)NCDU_HELP_HOT_KEY, 0);

                default:
                    return FALSE;
            }

        default:
            return FALSE;
    }
}

static
BOOL
ShareNetSwDlg_NCDU_BROWSE_DIST_PATH (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Displays the file /dir browser to find distribution path entry

Arguments:

    IN  HWND    hwndDlg
        Handle to dialog box window

    IN  WPARAM  wParam
        Not Used

    IN  LPARAM  lParam
        Not Used

Return Value:

    TRUE

--*/
{
    DB_DATA BrowseInfo;
    LPTSTR  szTempPath;

    szTempPath = GlobalAlloc (GPTR, (MAX_PATH_BYTES + sizeof(TCHAR)));

    if (szTempPath == NULL) return TRUE;

    GetDlgItemText (hwndDlg, NCDU_DISTRIBUTION_PATH, szTempPath, MAX_PATH);

    BrowseInfo.dwTitle = NCDU_BROWSE_CLIENT_DIST_PATH;
    BrowseInfo.szPath = szTempPath;
    BrowseInfo.Flags = 0;

    if (DialogBoxParam (
        (HINSTANCE)GetWindowLongPtr(hwndDlg, GWLP_HINSTANCE),
        MAKEINTRESOURCE(NCDU_DIR_BROWSER),
        hwndDlg,
        DirBrowseDlgProc,
        (LPARAM)&BrowseInfo) == IDOK) {

        SetDlgItemText (hwndDlg, NCDU_DISTRIBUTION_PATH, szTempPath);
    }
    SetFocus (GetDlgItem (hwndDlg, NCDU_DISTRIBUTION_PATH));
    SendDlgItemMessage (hwndDlg, NCDU_DISTRIBUTION_PATH,
        EM_SETSEL, (WPARAM)0, (LPARAM)-1);

    FREE_IF_ALLOC (szTempPath);

    return TRUE;
}

static
BOOL
ShareNetSwDlg_NCDU_VALIDATE_AND_END (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Performs all validation and field updates before exiting the
        dialog to the nNextDialog. If all validations are successful
        then the EndDialog is called, otherwise the function returns
        to the dialog box after displaying an error message and
        setting the focus to the offending control if necessary.

Arguments:

    IN  HWND    hwndDlg
        Handle to dialog box window

    IN  WPARAM  wParam
        (BOOL) validate dist path (ignored, now since all the validation
        is performed in the _IDOK function.

    IN  LPARAM  lParam
        Not Used

Return Value:

    FALSE

--*/
{
    BOOL    bValidate = FALSE;
    LPTSTR  szDlgDistPath;
    LONG    lTrysLeft;

    szDlgDistPath = GlobalAlloc (GPTR, MAX_PATH_BYTES);

    if (szDlgDistPath == NULL) return TRUE;

    // copy the app data to the local path for validation

    lstrcpy (szDlgDistPath, pAppInfo->szDistPath);
    bValidate = TRUE;
    // if bValidate is true at this point, pAppInfo->szDistShowPath should
    //  contain the UNC version of the original file path. The "signature"
    //  file (i.e. the INF) will be appended to the path to determine if
    //  this is indeed a valid path.
    if (bValidate) {
        lstrcpy (szDlgDistPath, pAppInfo->szDistPath);
        if (szDlgDistPath[lstrlen(szDlgDistPath)-1] != cBackslash) lstrcat (szDlgDistPath, cszBackslash);
        lstrcat (szDlgDistPath, cszAppInfName);
        lTrysLeft = 50; // wait for 5 seconds
        while (!FileExists(szDlgDistPath)) {
            Sleep (100);    // wait for server to establish
                            // connection and try again
            if (--lTrysLeft == 0) break;
        }
        if (!FileExists(szDlgDistPath)) {
            // not a valid distribution share so display error message
            DisplayMessageBox (
                hwndDlg,
                NCDU_NOT_DIST_TREE,
                0,
                MB_OK_TASK_EXCL);
            SendDlgItemMessage (hwndDlg, NCDU_DISTRIBUTION_PATH,
                EM_SETSEL, (WPARAM)0, (LPARAM)-1);
            SetFocus (GetDlgItem(hwndDlg, NCDU_DISTRIBUTION_PATH));
            SendDlgItemMessage (hwndDlg, NCDU_DISTRIBUTION_PATH,
                EM_SETSEL, (WPARAM)0, (LPARAM)-1);
        } else {
            if (IsUncPath(pAppInfo->szDistPath)) {
                // valid path so extract the server and open the registry on
                // the server
                lstrcpy (szDlgDistPath, cszDoubleBackslash);
                GetServerFromUnc (pAppInfo->szDistPath, &szDlgDistPath[2]);
                if (RegConnectRegistry (szDlgDistPath,
                    HKEY_LOCAL_MACHINE, &pAppInfo->hkeyMachine) != ERROR_SUCCESS) {
                    // if unable to connect to remote registry, use local registry
                    pAppInfo->hkeyMachine = HKEY_LOCAL_MACHINE;
                }
            } else {
                // not a UNC so assume it's on the local machine
                pAppInfo->hkeyMachine = HKEY_LOCAL_MACHINE;
            }
            //
            //  save dlg mode
            //
            if (IsDlgButtonChecked(hwndDlg, NCDU_USE_DIST_PATH) == CHECKED) {
                pAppInfo->bUseExistingPath = TRUE;
            } else {
                pAppInfo->bUseExistingPath = FALSE;
               //
               //  save the path in the registry for next time
               //
               SavePathToRegistry (pAppInfo->szDistPath,
                  cszLastClientServer,
                  cszLastClientSharepoint);
            }
            PostMessage (GetParent(hwndDlg), nNextDialog, 0, 0);
        }
    }

    FREE_IF_ALLOC (szDlgDistPath);

    return TRUE;
}

INT_PTR CALLBACK
ShareNetSwDlgProc (
    IN  HWND    hwndDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Main Dialog message procedure. Dispatches to the appropriate routine
        to process the following windows messages:

            WM_INITDIALOG:              Dialog box initialization
            WM_COMMAND:                 User Input
            NCDU_SHARE_DIR:             shares the specified dir to the net

        all other windows messages are handled by the default dialog proc.

Arguments:

    Standard WNDPROC args

Return Value:

    FALSE if the message is not processed by this module, otherwise
        the value returned by the dispatched routine.

--*/
{
    switch (message) {
#ifdef TERMSRV
        case WM_INITDIALOG: if ( szCommandLineVal[0] != 0x00 ) {
                               ShareNetSwDlg_WM_INITDIALOG (hwndDlg, wParam, lParam);
                               CheckRadioButton (hwndDlg,
                                   NCDU_USE_DIST_PATH,
                                   NCDU_FILES_ALREADY_SHARED,
                                   NCDU_USE_DIST_PATH);
                               UpdateDialogMode (hwndDlg);
                               SetDlgItemText (hwndDlg, NCDU_DISTRIBUTION_PATH, szCommandLineVal);
                               ShareNetSwDlg_IDOK (hwndDlg, BN_CLICKED, lParam);
                               return FALSE;
                            }
                            else
                              return (ShareNetSwDlg_WM_INITDIALOG (hwndDlg, wParam, lParam));
#else // TERMSRV
        case WM_INITDIALOG: return (ShareNetSwDlg_WM_INITDIALOG (hwndDlg, wParam, lParam));
#endif // TERMSRV
        case WM_COMMAND:    return (ShareNetSwDlg_WM_COMMAND (hwndDlg, wParam, lParam));
        case NCDU_SHARE_DIR:    return (ShareNetSwDlg_NCDU_SHARE_DIR (hwndDlg, wParam, lParam));
        case NCDU_BROWSE_DIST_PATH:
                                return (ShareNetSwDlg_NCDU_BROWSE_DIST_PATH (hwndDlg, wParam, lParam));
        case NCDU_VALIDATE_AND_END:
                                return (ShareNetSwDlg_NCDU_VALIDATE_AND_END (hwndDlg, wParam, lParam));
        case WM_PAINT:      return (Dlg_WM_PAINT (hwndDlg, wParam, lParam));
        case WM_MOVE:       return (Dlg_WM_MOVE (hwndDlg, wParam, lParam));
        case WM_SYSCOMMAND: return (Dlg_WM_SYSCOMMAND (hwndDlg, wParam, lParam));
        default:            return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\clcreator\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

!ifndef U_UNICODE
U_UNICODE=1
!endif

!if $(U_UNICODE)
C_DEFINES=-DUNICODE=1 -D_UNICODE=1
!endif

C_DEFINES= $(C_DEFINES) -DTERMSRV

MAJORCOMP=termsrv
MINORCOMP=clcreate
GPSIZE=32

INCLUDES=

TARGETNAME=clcreate
TARGETPATH=obj
TARGETTYPE=LIBRARY

SOURCES=..\clcreate.c      \
        ..\mainwnd.c       \
        ..\swconfig.c      \
        ..\targetws.c      \
        ..\servconn.c      \
        ..\copyflop.c      \
        ..\sharenet.c      \
        ..\netutils.c      \
        ..\copyfile.c      \
        ..\confsett.c      \
        ..\exitmess.c      \
        ..\makeflop.c      \
        ..\dirbrows.c      \
        ..\strings.c       \
        ..\sharpath.c      \
        ..\findclnt.c      \
        ..\fmt_disk.c      \
        ..\dirutils.c      \
        ..\winutils.c      \
        ..\strutils.c      \
        ..\otnboot.rc

UMENTRY=winmain
UMTYPE=windows
UMAPPL=clcreate
UMLIBS=obj\*\clcreate.lib \
        obj\*\otnboot.res \
        $(SDK_LIB_PATH)\comdlg32.lib        \
        $(SDK_LIB_PATH)\netapi32.lib        \
        $(SDK_LIB_PATH)\shell32.lib        \
        $(SDK_LIB_PATH)\mpr.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\clcreator\servconn.c ===
/*++

    Copyright (c) 1994  Microsoft Corporation

Module Name:

    SERVCONN.C

Abstract:

    Show server connection configuration dialog box

Author:

    Bob Watson (a-robw)

Revision History:

    17 Feb 94    Written

--*/
//
//  Windows Include Files
//

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <malloc.h>
#include <tchar.h>      // unicode macros
#include <commdlg.h>    // common dialog defines
#include <lmcons.h>     // lanman API constant definitions
#include <lmserver.h>   // server info API's
//
//  app include files
//
#include "otnboot.h"
#include "otnbtdlg.h"
//
#define IP_CHARLIMIT    15
//
#define NCDU_BROWSE_DEST_PATH       (WM_USER    + 101)
//
//  Local data structures
//
typedef struct _NETWORK_PROTOCOL_NAMES {
    UINT    nDisplayName;
    UINT    nTransportName;
    DWORD   dwTransportNameLength;
    BOOL    bLoaded;
    int     nListBoxEntry;
} NETWORK_PROTOCOL_NAMES, *PNETWORK_PROTOCOL_NAMES;
//
//  static data
//
static  NETWORK_PROTOCOL_NAMES  NetProtocolList[] = {
    {CSZ_NW_LINK_PROTOCOL,  NCDU_NW_LINK_TRANSPORT,     0, FALSE,  CB_ERR},
    {CSZ_TCP_IP_PROTOCOL,   NCDU_TCP_IP_TRANSPORT,      0, FALSE,  CB_ERR},
    {CSZ_NETBEUI_PROTOCOL,  NCDU_NETBEUI_TRANSPORT,     0, FALSE,  CB_ERR},
    // "terminating" entry in array
    {0,                     0,                          0, FALSE,  CB_ERR}
};

static
LPCTSTR
GetDefaultDomain (
)
/*++

Routine Description:

    Returns the domain the system is logged in to from the registry.


Arguments:

    None

Return Value:

    pointer to domain name string if successful or pointer to an
        empty strin if not.

--*/
{
    DWORD   dwBufLen;
    DWORD   dwDomainLen;
    static TCHAR   szDomainName[32];
    TCHAR   szUserName[MAX_USERNAME + 1];
    PSID    pSid;
    SID_NAME_USE    snu;

    szDomainName[0] = 0;
    dwBufLen = MAX_USERNAME;
    if (GetUserName(szUserName, &dwBufLen)) {
        pSid = (PSID)GlobalAlloc(GPTR, SMALL_BUFFER_SIZE);
        if (pSid != NULL) {
            dwBufLen = (DWORD)GlobalSize(pSid);
            dwDomainLen = sizeof (szDomainName) / sizeof(TCHAR);
            LookupAccountName (
                NULL,           // Local system
                szUserName,     // username to look up
                pSid,           // SID buffer
                &dwBufLen,      // SID buffer size
                szDomainName,   // return buffer for domain name
                &dwDomainLen,   // size of buffer
                &snu);
            FREE_IF_ALLOC(pSid);
        }
    }

    return szDomainName;

}

static
LPCTSTR
GetDefaultUsername (
)
/*++

Routine Description:

    Returns the user name of the account running the app

Arguments:

    None

Return Value:

    pointer to user name string if successful or pointer to an empty
        string if not.

--*/
{
    DWORD   dwBufLen;
    static TCHAR   szUserName[32];

    szUserName[0] = 0;
    dwBufLen    = sizeof(szUserName) / sizeof(TCHAR); // compute # of chars

    GetUserName(szUserName, &dwBufLen);

    return szUserName;

}

static
LPCTSTR
MakeIpAddrString (
    IN  USHORT IpAddr[]
)
/*++

Routine Description:

    formats integer array into an address string for display

Arguments:

    IP Address info structure

Return Value:

    pointer to formatted IP address string if successful or pointer to
        an empty string if not.

--*/
{
    static TCHAR    szAddrBuffer[32];

    szAddrBuffer[0] = 0;

    _stprintf (szAddrBuffer,  fmtIpAddr,
        IpAddr[0], IpAddr[1], IpAddr[2], IpAddr[3]);

    return szAddrBuffer;
}

static
LONG
ListNetworkTransports (
    IN  HWND    hwndDlg,
    IN  LPTSTR  szServerName

)
/*++

Routine Description:

    reads the registry and builds a list of  the network protocols that are
        supported on the selected server and loads the combo box with all
        possible transports.

Arguments:

    IN  HWND    hwndDlg
        handle to dialog box window

    IN  LPTSTR  szServerName
        server to validate protocols on

Return Value:

    ERROR_SUCCESS if successful or WIN32 error value if not

--*/
{
    DWORD   dwIndex;
    BOOL    bDefaultFound;

    DWORD   dwSumOfEntries;
    DWORD   dwEntriesRead;
    DWORD   dwTotalEntries;
    DWORD   dwResumeHandle;

    LONG    lStatus = ERROR_SUCCESS;

    PNETWORK_PROTOCOL_NAMES     pThisNetProtocol;
    PSERVER_TRANSPORT_INFO_0    pSrvrTransportInfo;
    PSERVER_TRANSPORT_INFO_0    pThisSrvrTransport;
    NET_API_STATUS              netStatus;

    pSrvrTransportInfo = (PSERVER_TRANSPORT_INFO_0)GlobalAlloc(GPTR, MEDIUM_BUFFER_SIZE);

    if (pSrvrTransportInfo == NULL) {
            return ERROR_OUTOFMEMORY;
    }

    // initialize static data

    for (pThisNetProtocol = &NetProtocolList[0];
        pThisNetProtocol->nDisplayName != 0;
        pThisNetProtocol = &pThisNetProtocol[1]) {
        pThisNetProtocol->dwTransportNameLength =
            lstrlen (GetStringResource (pThisNetProtocol->nTransportName));
        pThisNetProtocol->bLoaded = FALSE;
        pThisNetProtocol->nListBoxEntry = CB_ERR;
    }

    // build list of available network transports on server

    dwEntriesRead = 0L;
    dwSumOfEntries = 0L;
    dwTotalEntries = 0xFFFFFFFF;
    dwResumeHandle = 0L;
    while (dwSumOfEntries != dwTotalEntries)  {
        netStatus = NetServerTransportEnum (
            szServerName,
            0L,
            (LPBYTE *)&pSrvrTransportInfo,
            MEDIUM_BUFFER_SIZE,
            &dwEntriesRead,
            &dwTotalEntries,
            &dwResumeHandle);

        if (netStatus == NO_ERROR) {
            dwSumOfEntries += dwEntriesRead;
            for (dwIndex = 0; dwIndex < dwEntriesRead; dwIndex++) {
                pThisSrvrTransport = &pSrvrTransportInfo[dwIndex];
                for (pThisNetProtocol = &NetProtocolList[0];
                    pThisNetProtocol->nDisplayName != 0;
                    pThisNetProtocol = &pThisNetProtocol[1]) {
                    if (_tcsnicmp (GetStringResource(pThisNetProtocol->nTransportName),
                        pThisSrvrTransport->svti0_transportname,
                        pThisNetProtocol->dwTransportNameLength) == 0) {
                        if (lstrcmp (pThisSrvrTransport->svti0_networkaddress,
                            cszZeroNetAddress) != 0) {
                            pThisNetProtocol->bLoaded = TRUE;
                            break;
                        }
                    }
                }
            }
        } else {
            // bail out of loop if an error is encountered
            break;
        }
    }

    // so all the supported protocols have been identified here, now
    // reload the combo box.

    bDefaultFound = FALSE;
    dwIndex = 0;

    // empty the combo box
    SendDlgItemMessage (hwndDlg, NCDU_PROTOCOL_COMBO_BOX,
        CB_RESETCONTENT, 0, 0);

    for (pThisNetProtocol = &NetProtocolList[0];
        pThisNetProtocol->nDisplayName != 0;
        pThisNetProtocol = &pThisNetProtocol[1]) {
        // load combo box with each "transports"
        pThisNetProtocol->nListBoxEntry = (int)SendDlgItemMessage (hwndDlg,
            NCDU_PROTOCOL_COMBO_BOX, CB_ADDSTRING, (WPARAM)0,
            (LPARAM)GetStringResource (pThisNetProtocol->nDisplayName));

        if (!bDefaultFound) {
            if (pThisNetProtocol->bLoaded) {
                bDefaultFound = TRUE;
                dwIndex = (DWORD)pThisNetProtocol->nListBoxEntry;
            }
        }
    }

    // select default entry
    SendDlgItemMessage (hwndDlg, NCDU_PROTOCOL_COMBO_BOX,
        CB_SETCURSEL, (WPARAM)dwIndex, 0);

    FREE_IF_ALLOC(pSrvrTransportInfo);

    return lStatus;
}

static
BOOL
LoadIpAddrArray (
    IN  LPCTSTR  szIpString,
    OUT USHORT  nAddrItem[]
)
/*++

Routine Description:

    Parses the display string into the IP address array

Arguments:

    IN  LPCTSTR  szIpString
        input string to parse

    OUT USHORT  nAddrItem[]
        array to receive the address elements. Element 0 is the
        left-most element in the display string.

Return Value:

    TRUE if parsed successfully
    FALSE if error


--*/
{
    int     nArgs;
    int     nThisArg;

    DWORD   dw[4];

    nArgs = _stscanf (szIpString, fmtIpAddrParse,
        &dw[0], &dw[1], &dw[2], &dw[3]);

    if (nArgs == 4) {
        for (nThisArg = 0; nThisArg < nArgs; nThisArg++) {
            if (dw[nThisArg] > 255) {
                // bad value
                return FALSE;
            } else {
                // valid so copy the low byte of the value since that's
                // all that's allowed for an IP address or mask
                nAddrItem[nThisArg] = (USHORT)(dw[nThisArg] & 0x000000FF);
            }
        }
    } else {
        return FALSE;
    }

    return TRUE;

}

static
VOID
SetTcpIpWindowState (
    IN  HWND    hwndDlg
)
/*++

Routine Description:

    enables the IP address fields when TCP/IP protocol is enabled and
        disabled the IP address fields when it is not selected.

Arguments:

    IN  HWND    hwndDlg
        handle to the dialog box window

Return Value:

    NONE

--*/
{
    LPTSTR  szProtocol;
    int     nComboItem;
    BOOL    bFrameState, bAddrState;

    szProtocol = (LPTSTR)GlobalAlloc (GPTR, MAX_PATH_BYTES);

    if (szProtocol == NULL) return;

    nComboItem = (int)SendDlgItemMessage (hwndDlg, NCDU_PROTOCOL_COMBO_BOX,
        CB_GETCURSEL, 0, 0);
    SendDlgItemMessage (hwndDlg, NCDU_PROTOCOL_COMBO_BOX, CB_GETLBTEXT,
        (WPARAM)nComboItem, (LPARAM)szProtocol);

    if (_tcsnicmp(szProtocol, cszTcpKey, lstrlen(cszTcpKey)) == 0) {
        bFrameState = TRUE;
        if (IsDlgButtonChecked(hwndDlg, NCDU_USE_DHCP) == CHECKED) {
            bAddrState = FALSE;
        } else {
            bAddrState = TRUE;
        }
    } else {
        bFrameState = FALSE;
        bAddrState = FALSE;
    }

    EnableWindow (GetDlgItem(hwndDlg,NCDU_USE_DHCP), bFrameState);
    EnableWindow (GetDlgItem(hwndDlg,NCDU_FLOPPY_IP_ADDR_LABEL), bAddrState);
    EnableWindow (GetDlgItem(hwndDlg,NCDU_FLOPPY_IP_ADDR), bAddrState);
    EnableWindow (GetDlgItem(hwndDlg,NCDU_FLOPPY_SUBNET_LABEL), bAddrState);
    EnableWindow (GetDlgItem(hwndDlg,NCDU_FLOPPY_SUBNET_MASK), bAddrState);
    EnableWindow (GetDlgItem(hwndDlg,NCDU_DEFAULT_GATEWAY_LABEL), bFrameState);
    EnableWindow (GetDlgItem(hwndDlg,NCDU_DEFAULT_GATEWAY), bFrameState);
    EnableWindow (GetDlgItem(hwndDlg,NCDU_TCPIP_INFO_FRAME), bFrameState);

    FREE_IF_ALLOC (szProtocol);
}

static
BOOL
ComputeDefaultDefaultGateway (
    IN  HWND    hwndDlg
)
/*++

Routine Description:

    Generates a default value for the default gateway using the
        IP address and Sub Net mask

Arguments:

    Handle to the dialog box window


Return Value:

    TRUE if a default value was entered,
    FALSE if not

--*/
{
    TCHAR   szIpAddr[IP_CHARLIMIT+1];
    TCHAR   szSubNet[IP_CHARLIMIT+1];
    TCHAR   szDefGate[IP_CHARLIMIT+1];

    USHORT  usIpArray[4], usSnArray[4], usDgArray[4];

    // if not initialized, then preset to
    // default value

    GetDlgItemText (hwndDlg, NCDU_FLOPPY_IP_ADDR, szIpAddr, IP_CHARLIMIT);
    if (LoadIpAddrArray(szIpAddr, &usIpArray[0])) {
        GetDlgItemText (hwndDlg, NCDU_FLOPPY_SUBNET_MASK, szSubNet, IP_CHARLIMIT);
        if (LoadIpAddrArray(szSubNet, &usSnArray[0])) {
            GetDlgItemText (hwndDlg, NCDU_DEFAULT_GATEWAY, szDefGate, IP_CHARLIMIT);
            if (LoadIpAddrArray(szDefGate, &usDgArray[0])) {
                if ((usDgArray[0] == 0) &&
                    (usDgArray[1] == 0) &&
                    (usDgArray[2] == 0) &&
                    (usDgArray[3] == 0)) {
                    usDgArray[0] = usIpArray[0] & usSnArray[0];
                    usDgArray[1] = usIpArray[1] & usSnArray[1];
                    usDgArray[2] = usIpArray[2] & usSnArray[2];
                    usDgArray[3] = usIpArray[3] & usSnArray[3];
                    SetDlgItemText (hwndDlg, NCDU_DEFAULT_GATEWAY,
                        MakeIpAddrString(&usDgArray[0]));
                    return TRUE; // value updated
                }
            }
        }
    }
    return FALSE; // value not updated
}

static
BOOL
ServerConnDlg_WM_INITDIALOG (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Processes the WM_INITDIALOG windows message by initializing the
        display fields in the dialog box and setting focus to the first
        entry field

Arguments:

    IN  HWND    hwndDlg
        Handle to the dialog box window

    IN  WPARAM  wParam
        Not Used

    IN  LPARAM  lParam
        Not Used

Return Value:

    FALSE

--*/
{
    LONG    lProtocolNdx;
    LPTSTR  szServerArg;
    LPTSTR  szServerName;
    LPTSTR  szPathOnServer;

    szServerName = (LPTSTR)GlobalAlloc (GPTR, MAX_PATH_BYTES);
    szPathOnServer = (LPTSTR)GlobalAlloc (GPTR, MAX_PATH_BYTES);

    if ((szServerName == NULL) ||
        (szPathOnServer == NULL)) {
        SetLastError (ERROR_OUTOFMEMORY);
        EndDialog (hwndDlg, (int)WM_CLOSE);
        return FALSE;
    }

    RemoveMaximizeFromSysMenu (hwndDlg);
    PositionWindow  (hwndDlg);

    // get name of server with client tree

    lstrcpy (szServerName, cszDoubleBackslash);
    if (!GetNetPathInfo (pAppInfo->szDistPath,
        &szServerName[2], szPathOnServer)) {
        // unable to look up server, so use local path
        szServerArg = NULL;
    } else {
        szServerArg = szServerName;
    }


    ListNetworkTransports (hwndDlg, szServerArg);

    // select current protocol (if any)
    if (*pAppInfo->piFloppyProtocol.szName != 0) {
        lProtocolNdx = (LONG)SendDlgItemMessage (hwndDlg, NCDU_PROTOCOL_COMBO_BOX, CB_FINDSTRING,
            (WPARAM)0, (LPARAM)pAppInfo->piFloppyProtocol.szName);
        if (lProtocolNdx == CB_ERR) {
            // selection not found so apply default
            lProtocolNdx = 0;
        }
        SendDlgItemMessage (hwndDlg, NCDU_PROTOCOL_COMBO_BOX, CB_SETCURSEL,
            (WPARAM)lProtocolNdx, 0);
    }

    SendDlgItemMessage (hwndDlg, NCDU_FLOPPY_USERNAME, EM_LIMITTEXT, MAX_USERNAME, 0);
    if (pAppInfo->szUsername[0] == 0) {
        SetDlgItemText (hwndDlg, NCDU_FLOPPY_USERNAME, GetDefaultUsername());
    } else {
        SetDlgItemText (hwndDlg, NCDU_FLOPPY_USERNAME, pAppInfo->szUsername);
    }

    SendDlgItemMessage (hwndDlg, NCDU_FLOPPY_COMPUTER_NAME, EM_LIMITTEXT, MAX_COMPUTERNAME_LENGTH, 0);
    SetDlgItemText (hwndDlg, NCDU_FLOPPY_COMPUTER_NAME, pAppInfo->szComputerName);

    SendDlgItemMessage (hwndDlg, NCDU_FLOPPY_DOMAIN, EM_LIMITTEXT, MAX_DOMAINNAME, 0);
    if (pAppInfo->szDomain[0] == 0) {
        SetDlgItemText (hwndDlg, NCDU_FLOPPY_DOMAIN, GetDefaultDomain());
    } else {
        SetDlgItemText (hwndDlg, NCDU_FLOPPY_DOMAIN, pAppInfo->szDomain);
    }
    SendDlgItemMessage (hwndDlg, NCDU_FLOPPY_IP_ADDR, EM_LIMITTEXT, (WPARAM)IP_CHARLIMIT, 0);
    SendDlgItemMessage (hwndDlg, NCDU_FLOPPY_SUBNET_MASK, EM_LIMITTEXT, (WPARAM)IP_CHARLIMIT, 0);
    SetDlgItemText (hwndDlg, NCDU_FLOPPY_IP_ADDR, MakeIpAddrString(&pAppInfo->tiTcpIpInfo.IpAddr[0]));
    SetDlgItemText (hwndDlg, NCDU_FLOPPY_SUBNET_MASK, MakeIpAddrString(&pAppInfo->tiTcpIpInfo.SubNetMask[0]));
    SetDlgItemText (hwndDlg, NCDU_DEFAULT_GATEWAY, MakeIpAddrString(&pAppInfo->tiTcpIpInfo.DefaultGateway[0]));

    if (pAppInfo->bUseDhcp) {
        CheckDlgButton (hwndDlg, NCDU_USE_DHCP, CHECKED);
    } else {
        CheckDlgButton (hwndDlg, NCDU_USE_DHCP, UNCHECKED);
    }

    SendDlgItemMessage (hwndDlg, NCDU_TARGET_DRIVEPATH, EM_LIMITTEXT,
        (WPARAM)(MAX_PATH-1), (LPARAM)0);

    if (*pAppInfo->szBootFilesPath == 0) {
        SetDlgItemText (hwndDlg, NCDU_TARGET_DRIVEPATH, cszADriveRoot);
    } else {
        SetDlgItemText (hwndDlg, NCDU_TARGET_DRIVEPATH, pAppInfo->szBootFilesPath);
    }

    SetTcpIpWindowState (hwndDlg);
    SetFocus (GetDlgItem(hwndDlg, NCDU_FLOPPY_COMPUTER_NAME));
    // clear old Dialog and register current
    PostMessage (GetParent(hwndDlg), NCDU_CLEAR_DLG, (WPARAM)hwndDlg, IDOK);
    PostMessage (GetParent(hwndDlg), NCDU_REGISTER_DLG,
        NCDU_SERVER_CFG_DLG, (LPARAM)hwndDlg);

    FREE_IF_ALLOC(szServerName);
    FREE_IF_ALLOC(szPathOnServer);

    return FALSE;
}

static
BOOL
ServerConnDlg_IDOK (
    IN  HWND    hwndDlg
)
/*++

Routine Description:

    Processes the OK button command by validating the entries and
        storing them in the global application data structure. If an
        invalid value is detected a message box is displayed and the
        focus is set to the offending field, otherwise, the dialog
        box is terminated.

Arguments:

    IN  HWND    hwndDlg
        Handle to the dialog box window

Return Value:

    FALSE

--*/
{
    int nComboItem;
    int nMbResult;

    TCHAR   szIp[IP_CHARLIMIT*2];
    MEDIA_TYPE  mtDest;

    BOOL    bProtocolLoaded;
    PNETWORK_PROTOCOL_NAMES     pThisNetProtocol;

    // save settings
    GetDlgItemText (hwndDlg, NCDU_FLOPPY_COMPUTER_NAME, pAppInfo->szComputerName, MAX_COMPUTERNAME_LENGTH);
    TrimSpaces (pAppInfo->szComputerName);
    // see if there is a string...signal if no entry
    if (lstrlen(pAppInfo->szComputerName) == 0) {
        DisplayMessageBox (
            hwndDlg,
            NCDU_INVALID_MACHINENAME,
            0,
            MB_OK_TASK_EXCL);
        SetFocus (GetDlgItem (hwndDlg, NCDU_FLOPPY_COMPUTER_NAME));
        return TRUE;
    }

    GetDlgItemText (hwndDlg, NCDU_FLOPPY_USERNAME, pAppInfo->szUsername, MAX_USERNAME);
    TrimSpaces (pAppInfo->szUsername);
    GetDlgItemText (hwndDlg, NCDU_FLOPPY_DOMAIN, pAppInfo->szDomain, MAX_DOMAINNAME);
    TrimSpaces (pAppInfo->szDomain);
    nComboItem = (int)SendDlgItemMessage (hwndDlg, NCDU_PROTOCOL_COMBO_BOX,
        CB_GETCURSEL, 0, 0);
    SendDlgItemMessage (hwndDlg, NCDU_PROTOCOL_COMBO_BOX, CB_GETLBTEXT,
        (WPARAM)nComboItem, (LPARAM)pAppInfo->piFloppyProtocol.szName);

    // look up keyname from protocol name

    if (_tcsnicmp(pAppInfo->piFloppyProtocol.szName, cszTcpKey, lstrlen(cszTcpKey)) == 0) {
        lstrcpy(pAppInfo->piFloppyProtocol.szKey, cszTcpIpEntry);
    } else if (_tcsnicmp(pAppInfo->piFloppyProtocol.szName, cszNetbeuiKey, lstrlen(cszNetbeuiKey)) == 0) {
        AddMessageToExitList (pAppInfo, NCDU_NETBEUI_NOT_ROUT);
        lstrcpy(pAppInfo->piFloppyProtocol.szKey, cszNetbeuiEntry);
    } else if (_tcsnicmp(pAppInfo->piFloppyProtocol.szName, cszIpxKey, lstrlen(cszIpxKey)) == 0) {
        lstrcpy(pAppInfo->piFloppyProtocol.szKey, cszIpxEntry);
    } else {
        lstrcpy(pAppInfo->piFloppyProtocol.szKey, cszEmptyString);
    }

    // see if this protocol is supported by the server

    bProtocolLoaded = FALSE;

    for (pThisNetProtocol = &NetProtocolList[0];
        pThisNetProtocol->nDisplayName != 0;
        pThisNetProtocol = &pThisNetProtocol[1]) {
        // load combo box with "transports"

        if (pThisNetProtocol->nListBoxEntry == nComboItem) {
            if (pThisNetProtocol->bLoaded) {
                bProtocolLoaded = TRUE;
            }
        }
    }

    if (!bProtocolLoaded) {
        nMbResult = DisplayMessageBox (hwndDlg,
            NCDU_UNSUP_PROTOCOL,
            0,
            MB_OKCANCEL_TASK_EXCL);
        if (nMbResult != IDOK) {
            return TRUE;
        }
    }

    //
    //  Get target drive and path
    //
    GetDlgItemText (hwndDlg, NCDU_TARGET_DRIVEPATH, pAppInfo->szBootFilesPath, MAX_PATH);
    TrimSpaces (pAppInfo->szBootFilesPath);
    mtDest = GetDriveTypeFromPath(pAppInfo->szBootFilesPath);
    if (mtDest == Unknown) {
        nMbResult = DisplayMessageBox (
            hwndDlg,
            NCDU_NO_MEDIA,
            0,
            MB_OKCANCEL_TASK_EXCL);
        switch (nMbResult) {
            case IDOK:
                break;

            case IDCANCEL:
                // they want to go back to the dialog and insert a disk so bail out
                return TRUE;
        }
    } else if (mtDest != pAppInfo->mtBootDriveType) {
        nMbResult = DisplayMessageBox (
            hwndDlg,
            NCDU_DEST_NOT_FLOPPY,
            0,
            MB_OKCANCEL_TASK_EXCL);
        switch (nMbResult) {
            case IDOK:
                break;

            case IDCANCEL:
                // they want to go back to the dialog so bail out
                SetFocus (GetDlgItem(hwndDlg, NCDU_TARGET_DRIVEPATH));
                return TRUE;
        }
    }

    if (IsDlgButtonChecked(hwndDlg, NCDU_USE_DHCP) == CHECKED) {
        pAppInfo->bUseDhcp = TRUE;
        pAppInfo->tiTcpIpInfo.IpAddr[0] = 0;
        pAppInfo->tiTcpIpInfo.IpAddr[1] = 0;
        pAppInfo->tiTcpIpInfo.IpAddr[2] = 0;
        pAppInfo->tiTcpIpInfo.IpAddr[3] = 0;
        pAppInfo->tiTcpIpInfo.SubNetMask[0] = 0;
        pAppInfo->tiTcpIpInfo.SubNetMask[1] = 0;
        pAppInfo->tiTcpIpInfo.SubNetMask[2] = 0;
        pAppInfo->tiTcpIpInfo.SubNetMask[3] = 0;
        PostMessage (GetParent(hwndDlg), NCDU_SHOW_CONFIRM_DLG, 0, 0);
    } else {
        pAppInfo->bUseDhcp = FALSE;
        GetDlgItemText (hwndDlg, NCDU_FLOPPY_IP_ADDR, szIp, (IP_CHARLIMIT *2));
        if (LoadIpAddrArray(szIp, &pAppInfo->tiTcpIpInfo.IpAddr[0])) {
            GetDlgItemText (hwndDlg, NCDU_FLOPPY_SUBNET_MASK, szIp, (IP_CHARLIMIT *2));
            if (LoadIpAddrArray(szIp, &pAppInfo->tiTcpIpInfo.SubNetMask[0])) {
                GetDlgItemText (hwndDlg, NCDU_DEFAULT_GATEWAY, szIp, (IP_CHARLIMIT *2));
                if (LoadIpAddrArray(szIp, &pAppInfo->tiTcpIpInfo.DefaultGateway[0])) {
                    PostMessage (GetParent(hwndDlg), NCDU_SHOW_CONFIRM_DLG, 0, 0);
                } else {
                    // bad Default Gateway
                    DisplayMessageBox (
                        hwndDlg,
                        NCDU_BAD_DEFAULT_GATEWAY,
                        0,
                        MB_OK_TASK_EXCL);
                    SetFocus (GetDlgItem (hwndDlg, NCDU_DEFAULT_GATEWAY));
                    SendDlgItemMessage (hwndDlg, NCDU_DEFAULT_GATEWAY, EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                }
            } else {
                // bad Subnet Mask
                DisplayMessageBox (
                    hwndDlg,
                    NCDU_BAD_SUBNET_MASK,
                    0,
                    MB_OK_TASK_EXCL);
                SetFocus (GetDlgItem (hwndDlg, NCDU_FLOPPY_SUBNET_MASK));
                SendDlgItemMessage (hwndDlg, NCDU_FLOPPY_SUBNET_MASK, EM_SETSEL, (WPARAM)0, (LPARAM)-1);
            }
        } else {
            // bad IP
            DisplayMessageBox (
                hwndDlg,
                NCDU_BAD_IP_ADDR,
                0,
                MB_OK_TASK_EXCL);
            SetFocus (GetDlgItem (hwndDlg, NCDU_FLOPPY_IP_ADDR));
            SendDlgItemMessage (hwndDlg, NCDU_FLOPPY_IP_ADDR, EM_SETSEL, (WPARAM)0, (LPARAM)-1);
        }
    }

    return FALSE;
}

static
BOOL
ServerConnDlg_WM_COMMAND (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Dispatches to the correct routine based on the user input.
        Enables/disables the TCP/IP address info fields when
            the Protocol is changed
        Ends the dialog box if Cancel is selected
        Dispatches to the IDOK function if OK selected.

Arguments:

    IN  HWND    hwndDlg
        Handle to dialog box window

    IN  WPARAM  wParam
        LOWORD  contains the ID of the control issuing the command

    IN  LPARAM  lParam
        Not used

Return Value:

    FALSE if processed
    TRUE if not processed

--*/
{
    switch (LOWORD(wParam)) {
        case NCDU_USE_DHCP:
        case NCDU_PROTOCOL_COMBO_BOX:
            SetTcpIpWindowState (hwndDlg);
            return TRUE;

        case NCDU_BROWSE:
            PostMessage (hwndDlg, NCDU_BROWSE_DEST_PATH, 0, 0);
            return TRUE;

        case IDCANCEL:
            PostMessage (GetParent(hwndDlg), NCDU_SHOW_TARGET_WS_DLG, 0, 0);
            return TRUE;

        case NCDU_DEFAULT_GATEWAY:
            if (HIWORD(wParam) == EN_SETFOCUS) {
                ComputeDefaultDefaultGateway (hwndDlg);
                return TRUE;
            } else {
                return FALSE;
            }

        case IDOK:  return ServerConnDlg_IDOK(hwndDlg);
        case NCDU_SERVER_CONN_CFG_HELP:
            switch (HIWORD(wParam)) {
                case BN_CLICKED:
//                    return ShowAppHelp (hwndDlg, LOWORD(wParam));
                    return PostMessage (GetParent(hwndDlg), WM_HOTKEY,
                        (WPARAM)NCDU_HELP_HOT_KEY, 0);

                default:
                    return FALSE;
            }

        default:    return FALSE;
    }
}

static
BOOL
ServerConnDlg_NCDU_BROWSE_DEST_PATH (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Displays the file /dir browser to enter the destination path entry

Arguments:

    IN  HWND    hwndDlg
        Handle to dialog box window

    IN  WPARAM  wParam
        Not Used

    IN  LPARAM  lParam
        Not Used

Return Value:

    FALSE

--*/
{
    DB_DATA BrowseInfo;
    TCHAR   szTempPath[MAX_PATH+1];

    GetDlgItemText (hwndDlg, NCDU_TARGET_DRIVEPATH, szTempPath, MAX_PATH);

    BrowseInfo.dwTitle = NCDU_BROWSE_COPY_DEST_PATH;
    BrowseInfo.szPath = szTempPath;
    BrowseInfo.Flags = PDB_FLAGS_NOCHECKDIR;

    if (DialogBoxParam (
        (HINSTANCE)GetWindowLongPtr(hwndDlg, GWLP_HINSTANCE),
        MAKEINTRESOURCE(NCDU_DIR_BROWSER),
        hwndDlg,
        DirBrowseDlgProc,
        (LPARAM)&BrowseInfo) == IDOK) {

        SetDlgItemText (hwndDlg, NCDU_TARGET_DRIVEPATH, szTempPath);

    }
    SetFocus( GetDlgItem(hwndDlg, NCDU_TARGET_DRIVEPATH));

    return TRUE;
}

static
BOOL
ServerConnDlg_NCDU_WM_NCDESTROY (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    return TRUE;
}

INT_PTR CALLBACK
ServerConnDlgProc (
    IN  HWND    hwndDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Dialog box procedure for the Server connection configuration dialog
        box. The following windows messages are processed by this
        function:

            WM_INITDIALOG:  Dialog box initialization
            WM_COMMAND:     user input
            WM_NCDESTROY:   to free memory before leaving

        all other messages are sent to the default dialog box proc.

Arguments:

    Standard WNDPROC arguments

Return Value:

    FALSE if message not processed by this module, otherwise the
        value returned by the dispatched routine.

--*/
{
    switch (message) {
        case WM_INITDIALOG: return (ServerConnDlg_WM_INITDIALOG (hwndDlg, wParam, lParam));
        case WM_COMMAND:    return (ServerConnDlg_WM_COMMAND (hwndDlg, wParam, lParam));
        case NCDU_BROWSE_DEST_PATH:
                                return (ServerConnDlg_NCDU_BROWSE_DEST_PATH (hwndDlg, wParam, lParam));
        case WM_PAINT:      return (Dlg_WM_PAINT (hwndDlg, wParam, lParam));
        case WM_MOVE:       return (Dlg_WM_MOVE (hwndDlg, wParam, lParam));
        case WM_SYSCOMMAND: return (Dlg_WM_SYSCOMMAND (hwndDlg, wParam, lParam));
        case WM_NCDESTROY:    return (ServerConnDlg_NCDU_WM_NCDESTROY (hwndDlg, wParam, lParam));
        default:            return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\clcreator\swconfig.c ===
/*++

    Copyright (c) 1994  Microsoft Corporation

Module Name:

    Swconfig.H

Abstract:

    Select Installation type Dialog Box Procedures

Author:

    Bob Watson (a-robw)

Revision History:

    17 Feb 94    Written

--*/
//
//  Windows Include Files
//

#include <windows.h>
#include <stdio.h>
#include <malloc.h>
#include <tchar.h>      // unicode macros
//
//  app include files
//
#include "otnboot.h"
#include "otnbtdlg.h"

#ifdef TERMSRV
extern TCHAR szCommandLineVal[MAX_PATH];
#endif // TERMSRV


static
BOOL
SwConfigDlg_WM_INITDIALOG (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Process the WM_INITDIALOG windows message. Initialized the
        values in the dialog box controls to reflect the current
        values of the Application data structure.

Arguments:

    IN  HWND    hwndDlg
        handle to dialog box window

    IN  WPARAM  wParam
        Not Used

    IN  LPARAM  lParam
        Not Used

Return Value:

    FALSE

--*/
{
    // configure window & initialize variables
    RemoveMaximizeFromSysMenu (hwndDlg);
    RegCloseKey (pAppInfo->hkeyMachine);
    pAppInfo->hkeyMachine = NULL;
    PositionWindow  (hwndDlg);

    // set default configuration button
    if (pAppInfo->itInstall == OverTheNetInstall) {
        CheckRadioButton (hwndDlg, NCDU_OVER_THE_NET, NCDU_REMOTEBOOT_INFO,
            NCDU_OVER_THE_NET);
    } else if (pAppInfo->itInstall == FloppyDiskInstall) {
        CheckRadioButton (hwndDlg, NCDU_OVER_THE_NET, NCDU_REMOTEBOOT_INFO,
            NCDU_FLOPPY_INSTALL);
    } else if (pAppInfo->itInstall == CopyNetAdminUtils) {
        CheckRadioButton (hwndDlg, NCDU_OVER_THE_NET, NCDU_REMOTEBOOT_INFO,
            NCDU_COPY_NET_ADMIN_UTILS);
    } else if (pAppInfo->itInstall == ShowRemoteBootInfo) {
        CheckRadioButton (hwndDlg, NCDU_OVER_THE_NET, NCDU_REMOTEBOOT_INFO,
            NCDU_REMOTEBOOT_INFO);
    }

    PostMessage (GetParent(hwndDlg), NCDU_CLEAR_DLG, (WPARAM)hwndDlg, IDOK);
    PostMessage (GetParent(hwndDlg), NCDU_REGISTER_DLG,
        NCDU_SW_CONFIG_DLG, (LPARAM)hwndDlg);

    SetCursor(LoadCursor(NULL, IDC_ARROW));
    SetFocus (GetDlgItem(hwndDlg, IDOK));

    return FALSE;
}

static
BOOL
SwConfigDlg_IDOK (
    IN  HWND    hwndDlg
)
/*++

Routine Description:

    Processes the IDOK button click. Validates the entries and looks up
        the distribution path to try and translate it to a UNC path.
        Then ends the dialog and calls the next dialog box.

Arguments:

    IN  HWND    hwndDlg
        handle to the dialog box window

Return Value:

    FALSE

--*/
{
    UINT    nNextMessage = 0;
    BOOL    bValidate = TRUE;
    UINT    nValidMsg = 0;

    if (IsDlgButtonChecked(hwndDlg,NCDU_OVER_THE_NET) == CHECKED) {
        pAppInfo->itInstall = OverTheNetInstall;
        nNextMessage = (int)NCDU_SHOW_SHARE_NET_SW_DLG;
    } else if (IsDlgButtonChecked(hwndDlg,NCDU_FLOPPY_INSTALL) == CHECKED) {
        pAppInfo->itInstall = FloppyDiskInstall;
        nNextMessage = (int)NCDU_SHOW_SHARE_NET_SW_DLG;
    } else if (IsDlgButtonChecked(hwndDlg,NCDU_COPY_NET_ADMIN_UTILS) == CHECKED) {
        pAppInfo->itInstall = CopyNetAdminUtils;
        nNextMessage = (int)NCDU_SHOW_COPY_ADMIN_UTILS;
    } else if (IsDlgButtonChecked(hwndDlg,NCDU_REMOTEBOOT_INFO) == CHECKED) {
        pAppInfo->itInstall = ShowRemoteBootInfo;
        DisplayMessageBox (
            hwndDlg,
            NCDU_LANMAN_MESSAGE,
            0,
            MB_OK_TASK_INFO);
        nNextMessage = (int)NCDU_SHOW_SW_CONFIG_DLG;
    }
    PostMessage (GetParent(hwndDlg), nNextMessage, 0, 0);
    SetCursor(LoadCursor(NULL, IDC_WAIT));
    return TRUE;
}

static
BOOL
SwConfigDlg_NCDU_EXIT (
    IN  HWND    hwndDlg
)
/*++

Routine Description:

    ends the dialog box (and ultimately the app)

Arguments:

    IN  HWND    hwndDlg

Return Value:

    FALSE

--*/
{
    PostMessage (GetParent(hwndDlg), (int)NCDU_SHOW_EXIT_MESSAGE_DLG, 0, 0);
    SetCursor(LoadCursor(NULL, IDC_WAIT));
    return TRUE;
}

static
BOOL
SwConfigDlg_WM_COMMAND (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Processes the WM_COMMAND windows message and dispatches to
        the routine that corresponds to the control issuing the
        message.

Arguments:

    IN  HWND    hwndDlg
        Handle to dialog box window

    IN  WPARAM  wParam
        LOWORD  has ID of control initiating the message

    IN  LPARAM  lParam
        Not Used

Return Value:

    TRUE if message not processed by this routine, otherwise the
        value of the dispatched routine .

--*/
{
    switch (LOWORD(wParam)) {
        case NCDU_EXIT:             return SwConfigDlg_NCDU_EXIT (hwndDlg);
        case IDOK:                  return SwConfigDlg_IDOK (hwndDlg);
        case NCDU_SW_CONFIG_HELP:
            switch (HIWORD(wParam)) {
                case BN_CLICKED:
//                    return ShowAppHelp (hwndDlg, LOWORD(wParam));
                    return PostMessage (GetParent(hwndDlg), WM_HOTKEY,
                        (WPARAM)NCDU_HELP_HOT_KEY, 0);

                default:
                    return FALSE;
            }

        default:                    return FALSE;
    }
}

INT_PTR CALLBACK
SwConfigDlgProc (
    IN  HWND    hwndDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Main Dialog Box Window Procedure for the Initial configuration screen
        Processes the following windows messages by dispatching the
        appropriate routine.

            WM_INITDIALOG:  dialog box initialization
            WM_COMMAND:     user input
            WM_PAINT:       for painting icon when minimized
            WM_MOVE:        for saving the new location of the window
            WM_SYSCOMMAND:  for processing menu messages

        All other windows messages are processed by the default dialog box
        procedure.

Arguments:

    Standard WNDPROC arguments

Return Value:

    FALSE if the message is not processed by this routine, otherwise the
        value returned by the dispatched routine.

--*/
{
    switch (message) {
#ifdef TERMSRV
        case WM_INITDIALOG: if ( szCommandLineVal[0] != 0x00 ) {
                               SwConfigDlg_WM_INITDIALOG (hwndDlg, wParam, lParam);
                               CheckRadioButton (hwndDlg, NCDU_OVER_THE_NET, NCDU_REMOTEBOOT_INFO,
                                   NCDU_FLOPPY_INSTALL);
                               SwConfigDlg_IDOK (hwndDlg);
                               return FALSE;
                            }
                            else
                               return (SwConfigDlg_WM_INITDIALOG (hwndDlg, wParam, lParam));
#else // TERMSRV
        case WM_INITDIALOG: return (SwConfigDlg_WM_INITDIALOG (hwndDlg, wParam, lParam));
#endif // TERMSRV
        case WM_COMMAND:    return (SwConfigDlg_WM_COMMAND (hwndDlg, wParam, lParam));
        case WM_PAINT:      return (Dlg_WM_PAINT (hwndDlg, wParam, lParam));
        case WM_MOVE:       return (Dlg_WM_MOVE (hwndDlg, wParam, lParam));
        case WM_SYSCOMMAND: return (Dlg_WM_SYSCOMMAND (hwndDlg, wParam, lParam));
        default:            return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\clcreator\strutils.c ===
/*++

    Copyright (c) 1994  Microsoft Corporation

Module Name:

    StrUtils.C

Abstract:

    String utility functions

Author:

    Bob Watson (a-robw)

Revision History:

    24 Jun 94    Written

--*/
//
//  Windows Include Files
//

#include <windows.h>
#include <stdio.h>
#include <malloc.h>
#include <tchar.h>      // unicode macros
#include <stdlib.h>     // string to number conversions
//
//  app include files
//
#include "otnboot.h"
#include "otnbtdlg.h"
//
//  Local constants
//
#define NUM_BUFS    8

BOOL
MatchFirst (
    IN LPCTSTR   szStringA,
    IN LPCTSTR   szStringB
)
/*++

Routine Description:

    performs a case in-sensitive comparison of the two strings to
        the extent of the shortest string. If, up to the length
        of the shortest string, the strings match then TRUE is
        returned otherwise FALSE is returned.


Arguments:

    IN LPCTSTR   szStringA,
        pointer to first string

    IN LPCTSTR   szStringB
        pointer to second string

Return Value:

    TRUE if match found
    FALSE if not

--*/
{
    LPTSTR  szAptr;     // pointer to char in szStringA to compare
    LPTSTR  szBptr;     // pointer to char in szStringB to compare

    if ((szStringA != NULL) && (szStringB != NULL)) {
        szAptr = (LPTSTR)szStringA;
        szBptr = (LPTSTR)szStringB;
        while ((*szBptr != 0) && (*szAptr != 0)) {
            if (_totlower(*szBptr) != _totlower(*szAptr)) break;
            szBptr++;
            szAptr++;
        }
        if (((*szAptr == 0) && ((*szBptr == 0) || (*szBptr == cBackslash))) ||
            ((*szBptr == 0) && ((*szAptr == 0) || (*szAptr == cBackslash)))) {
            // then a matched directoryto the end of the shortest string
            return TRUE;
        } else {
            return FALSE;
        }
    } else {
        return FALSE;
    }
}

DWORD
GetSizeFromInfString (
    IN  LPCTSTR  szString
)
/*++

Routine Description:

    Reads the estimated size of the directory tree as stored in the
        inf file. The format of the INF string is:

            key=entry
                where:
                    key = subdir name
                    entry = NumberOfFiles,TotalBytes

        value must be less than 2**32

Arguments:

    "entry" string read from INF file


Return Value:

    DWORD value of TotalBytes in entry

--*/
{
    LPTSTR  szSize;     // size string parsed from input string
    LPTSTR  szLastChar; // beginning of size value in string

    // size is second param in comma separated list
    // go to first comma
    szSize = (LPTSTR)szString;
    while ((*szSize != cComma) && (*szSize != 0)) szSize++;
    szSize++; // go to first char after comma
    return _tcstoul (szSize, &szLastChar, 10);
}

BOOL
SavePathToRegistry (
    LPCTSTR szPath,
    LPCTSTR szServerKey,
    LPCTSTR szShareKey
)
/*++

Routine Description:

    splits the path (which must be a UNC path) into server & sharepoint
        for loading into the system registry. The key used is the
        \HKEY_CURRENT_USER\Software\Microsoft\Windows NT\CurrentVersion\Network
        and the NCAdmin key is created (if it doesn't exist) under which the
        Server is stored in the szServerKey value and the share point is
        stored under the szShareKey value

Arguments:

    LPCTSTR szPath
        UNC path to store

    LPCTSTR szServerKey
        name of registry value to store server under

    LPCTSTR szShareKey
        name of registry value to store share under

Return Value:

    TRUE    values stored OK
    FALSE   values not stored

--*/
{
    TCHAR   szMachine[MAX_COMPUTERNAME_LENGTH+1];   // computer name buffer
    LPTSTR  szShare;                                // share name buffer
    HKEY    hkeyUserInfo;                           // registry key
    HKEY    hkeyAppInfo;                            // registry key

    LONG    lStatus;                                // local function status
    BOOL    bReturn;                                // return value of this fn
    DWORD   dwAppKeyDisp;                           // create/existing value

    szShare = GlobalAlloc (GPTR, MAX_PATH_BYTES);
    if (szShare == NULL) {
        // unable to alloc memory.
        return FALSE;
    }

    if (IsUncPath (szPath)) {
        // open registry key containing net apps

        lStatus = RegOpenKeyEx (
            HKEY_CURRENT_USER,
            cszUserInfoKey,
            0L,
            KEY_READ,
            &hkeyUserInfo);

        if (lStatus != ERROR_SUCCESS) {
            // unable to open key so return error
            bReturn = FALSE;
        } else {
            // open registry key containing this app's info
            lStatus = RegCreateKeyEx (
                hkeyUserInfo,
                szAppName,
                0L,
                (LPTSTR)cszEmptyString,
                REG_OPTION_NON_VOLATILE,
                KEY_WRITE,
                NULL,
                &hkeyAppInfo,
                &dwAppKeyDisp);

            if (lStatus != ERROR_SUCCESS) {
                // unable to open key so return false
                bReturn = FALSE;
            } else {
                if (!GetServerFromUnc (szPath, szMachine)) {
                    // unable to read share so clear value
                    szMachine[0] = 0;
                }
                // get server name from registry
                lStatus = RegSetValueEx (
                    hkeyAppInfo,
                    (LPTSTR)szServerKey,
                    0L,
                    REG_SZ,
                    (LPBYTE)&szMachine[0],
                    (DWORD)(lstrlen(szMachine)*sizeof(TCHAR)));

                if (lStatus == ERROR_SUCCESS) {
                    if (!GetShareFromUnc (szPath, szShare)) {
                        szShare[0] = 0;
                    }

                    lStatus = RegSetValueEx (
                        hkeyAppInfo,
                        (LPTSTR)szShareKey,
                        0L,
                        REG_SZ,
                        (LPBYTE)&szShare[0],
                        (DWORD)(lstrlen(szShare)*sizeof(TCHAR)));

                    if (lStatus == ERROR_SUCCESS) {
                        bReturn = TRUE;
                    } else {
                        bReturn = FALSE;
                    }
                } else {
                    bReturn = FALSE;
                }

                RegCloseKey (hkeyAppInfo);
            }
            RegCloseKey (hkeyUserInfo);
        }

        bReturn = TRUE;
    } else {
        // not a UNC path so return error
        bReturn = FALSE;
    }

    FREE_IF_ALLOC (szShare);
    return bReturn;

}

DWORD
QuietGetPrivateProfileString (
    IN  LPCTSTR lpszSection,    /* address of section name  */
    IN  LPCTSTR lpszKey,        /* address of key name  */
    IN  LPCTSTR lpszDefault,    /* address of default string    */
    OUT LPTSTR lpszReturnBuffer, /* address of destination buffer    */
    IN  DWORD cchReturnBuffer,  /* size of destination buffer   */
    IN  LPCTSTR lpszFile        /* address of initialization filename   */
)
/*++

Routine Description:

    Reads data from profile file without triggering OS error message if
        unable to access file.

Arguments:

    IN  LPCTSTR lpszSection
        address of section name
    IN  LPCTSTR lpszKey
        address of key name
    IN  LPCTSTR lpszDefault
        address of default string
    OUT LPTSTR lpszReturnBuffer
        address of destination buffer
    IN  DWORD cchReturnBuffer
        size of destination buffer (in characters)
    IN  LPCTSTR lpszFile
        address of initialization filename

    See HELP on GetPrivateProfileString for details on using these arguments.

Return Value:

    number of characters copied into lpszReturnBuffer.

--*/
{
    DWORD   dwReturn;
    UINT    nErrorMode;

    // disable windows error message popup
    nErrorMode = SetErrorMode  (SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

    // call function
    dwReturn = GetPrivateProfileString (
        lpszSection, lpszKey, lpszDefault, lpszReturnBuffer,
        cchReturnBuffer, lpszFile);

    SetErrorMode (nErrorMode);  // restore old error mode

    return dwReturn;
}

LPCTSTR
GetKeyFromEntry (
    IN  LPCTSTR  szEntry
)
/*++

Routine Description:

    copys the "key" from an INF string of the format:
        Key=Value. All text up to, but not including the "="
        is returned.

Arguments:

    IN  LPCTSTR szEntry
        line from INF file to process. must be in the format referenced
        above.

Return Value:

    pointer to a read only string that contains the resulting key string.

    NOTE: this is stored in a static variable and should be copied to a
    local variable for further processing OR before calling this routine
    again.

--*/
{
    static  TCHAR   szReturnBuffer[MAX_PATH];
    LPTSTR  szSource, szDest;

    szSource = (LPTSTR)szEntry;
    szDest = &szReturnBuffer[0];

    *szDest = 0;

    if (*szSource != 0) {
        // copy all chars from start to the equal sign
        //  (or the end of the string)
        while ((*szSource != cEqual) && (*szSource != 0)) {
            *szDest++ = *szSource++;
        }
        *szDest = 0; //terminate destination string (key)
    }
    return szReturnBuffer;
}

LPCTSTR
GetItemFromEntry (
    IN  LPCTSTR  szEntry,
    IN  DWORD   dwItem

)
/*++

Routine Description:

    returns nth item from comma separated list returned from
        inf file. leaves (double)quoted strings intact.

Arguments:

    IN  LPCTSTR szEntry
        entry string returned from INF file

    IN  DWORD   dwItem
        1-based index indicating which item to return. (i.e. 1= first item
        in list, 2= second, etc.)


Return Value:

    pointer to buffer containing desired entry in string. Note, this
        routine may only be called 4 times before the string
        buffer is re-used. (i.e. don't use this function more than
        4 times in another function call!!)

--*/
{
    static  TCHAR   szReturnBuffer[4][MAX_PATH];
    LPTSTR  szSource, szDest;
    DWORD   dwThisItem;
    static  DWORD   dwBuff;

    dwBuff = ++dwBuff % 4; // wrap buffer index

    szSource = (LPTSTR)szEntry;
    szDest = &szReturnBuffer[dwBuff][0];

    *szDest = 0;

    // go past ini key
    while ((*szSource != cEqual) && (*szSource != 0)) szSource++;
    if (*szSource == 0){
        // no equals found so start at beginning
        // presumably this is just the "value"
        szSource = (LPTSTR)szEntry;
    } else {
        szSource++;
    }
    dwThisItem = 1;
    while (dwThisItem < dwItem) {
        if (*szSource != 0) {
            while ((*szSource != cComma) && (*szSource != 0)) {
                if (*szSource == cDoubleQuote) {
                    // if this is a quote, then go to the close quote
                    szSource++;
                    while ((*szSource != cDoubleQuote) && (*szSource != 0)) szSource++;
                }
                if (*szSource != 0) szSource++;
            }
        }
        dwThisItem++;
        if (*szSource != 0) szSource++;
    }
    // copy this entry to the return buffer
    if (*szSource != 0) {
        while ((*szSource != cComma) && (*szSource != 0)) {
            if (*szSource == cDoubleQuote) {
                // if this is a quote, then go to the close quote
                // don't copy quotes!
                szSource++;
                while ((*szSource != cDoubleQuote) && (*szSource != 0)) {
                    *szDest++ = *szSource++;
                }
                if (*szSource != 0) szSource++;
            } else {
                *szDest++ = *szSource++;
            }
        }
        *szDest = 0;
    }

    return &szReturnBuffer[dwBuff][0];
}

LPCTSTR
GetFileNameFromEntry (
    IN  LPCTSTR szEntry
)
/*++

Routine Description:

    returns pointer into szEntry where file name is found.
        first character after the ":"

Arguments:

    string containing filename in format of:
        nn:filename.ext

Return Value:

    returns pointer into szEntry where file name is found.
        first character after the ":"
    returns an empty string if no ":" char was found.

--*/
{
    LPTSTR szReturn;
    szReturn = (LPTSTR)szEntry;
    // go to COLON character
    while ((*szReturn != cColon) && (*szReturn != 0)) szReturn++;
    // scoot to next char
    if (*szReturn != 0) szReturn++;
    return szReturn;
}

BOOL
TrimSpaces (
    IN  OUT LPTSTR  szString
)
/*++

Routine Description:

    Trims leading and trailing spaces from szString argument, modifying
        the buffer passed in

Arguments:

    IN  OUT LPTSTR  szString
        buffer to process

Return Value:

    TRUE if string was modified
    FALSE if not

--*/
{
    LPTSTR  szSource;
    LPTSTR  szDest;
    LPTSTR  szLast;
    BOOL    bChars;

    szLast = szSource = szDest = szString;
    bChars = FALSE;

    while (*szSource != 0) {
        // skip leading non-space chars
        if (*szSource > cSpace) {
            szLast = szDest;
            bChars = TRUE;
        }
        if (bChars) {
            // remember last non-space character
            // copy source to destination & increment both
            *szDest++ = *szSource++;
        } else {
            szSource++;
        }
    }

    if (bChars) {
        *++szLast = 0; // terminate after last non-space char
    } else {
        // string was all spaces so return an empty (0-len) string
        *szString = 0;
    }

    return (szLast != szSource);
}

BOOL
IsUncPath (
    IN  LPCTSTR  szPath
)
/*++

Routine Description:

    examines path as a string looking for "tell-tale" double
        backslash indicating the machine name syntax of a UNC path

Arguments:

    IN  LPCTSTR szPath
        path to examine

Return Value:

    TRUE if \\ found at start of string
    FALSE if not

--*/
{
    LPTSTR  szPtChar;

    szPtChar = (LPTSTR)szPath;
    if (*szPtChar == cBackslash) {
        if (*++szPtChar == cBackslash) {
            return TRUE;
        }
    }
    return FALSE;
}

LPCTSTR
GetEntryInMultiSz (
    IN  LPCTSTR   mszList,
    IN  DWORD   dwEntry

)
/*++

Routine Description:

    Searches for the specified element in the mszList and returns the pointer
        to that element in the list.

Arguments:

    IN  LPCTSTR   mszList       Multi-SZ list to search
    IN  DWORD   dwEntry         1-based index of entry to return

ReturnValue:

        !=cszEmptyString    pointer to matching element in list
        cszEmptyString      (pointer to 0-length string) entry is not in list
--*/
{
    LPCTSTR   szThisString;
    DWORD   dwIndex=0;

    if (mszList == NULL) return (LPCTSTR)cszEmptyString;   // no list to process
    if (dwEntry == 0) return (LPCTSTR)cszEmptyString;      // no string to find

    for (szThisString = mszList;
        *szThisString;
        szThisString += (lstrlen(szThisString)+ 1)) {
        dwIndex++;
        if (dwIndex == dwEntry) {
            return szThisString;
        }
    }

    return (LPCTSTR)cszEmptyString;
}

DWORD
AddStringToMultiSz (
    LPTSTR OUT   mszDest,
    LPCTSTR IN    szSource
)
/*++

Routine Description:

    appends the source string to the end of the destination MULTI_SZ
        string. Assumes that the destination is large enough!

Arguments:

    LPTSTR OUT   mszDest     multi-sz string to be appended
    LPTSTR IN    szSource    ASCIZ string to be added to the end of the dest
                            string

ReturnValue:

    1

--*/
{
    LPTSTR   szDestElem;

    // check function arguments

    if ((mszDest == NULL) || (szSource == NULL)) return 0; // invalid buffers
    if (*szSource == '\0') return 0; // no string to add

    // go to end of dest string
    //

    for (szDestElem = mszDest;
            *szDestElem;
            szDestElem += (lstrlen(szDestElem)+1));

    // if here, then add string
    // szDestElem is at end of list

    lstrcpy (szDestElem, szSource);
    szDestElem += (lstrlen(szDestElem) + 1);
    *szDestElem = '\0'; // add second NULL

    return 1;
}

DWORD
StringInMultiSz (
    IN  LPCTSTR   szString,
    IN  LPCTSTR   mszList
)
/*++

Routine Description:

    Searches each element in the mszList and does a case-insensitive
        comparison with the szString argument.

Arguments:

    IN  LPCTSTR   szString    string to find in list
    IN  LPCTSTR   mszList     list to search

ReturnValue:

        >0      szString was found in the list, # returned is the
                    index of the matching entry (1= first)
        0       szString was NOT found
--*/
{
    LPTSTR   szThisString;
    DWORD   dwIndex=0;

    // check input arguments

    if ((szString == NULL) || (mszList == NULL)) return 0;  // invalid buffer
    if (*szString == 0) return 0; // no string to find

    for (szThisString = (LPTSTR)mszList;
        *szThisString;
        szThisString += (lstrlen(szThisString)+ 1)) {
        dwIndex++;
        if (lstrcmpi(szThisString, szString) == 0) {
            return dwIndex;
        }
    }

    return 0;
}

LPCTSTR
GetStringResource (
    IN  UINT    nId
)
/*++

Routine Description:

    look up string resource and return string

Arguments:

    IN  UINT    nId
        Resource ID of string to look up

Return Value:

    pointer to string referenced by ID in arg list

--*/
{
    static  TCHAR   szBufArray[NUM_BUFS][SMALL_BUFFER_SIZE];
    static  DWORD   dwIndex;
    LPTSTR  szBuffer;
    DWORD   dwLength;

    dwIndex++;
    dwIndex %= NUM_BUFS;
    szBuffer = &szBufArray[dwIndex][0];

    dwLength = LoadString (
        GetModuleHandle (NULL),
        nId,
        szBuffer,
        SMALL_BUFFER_SIZE);

    return (LPCTSTR)szBuffer;
}

DWORD
GetMultiSzLen (
    IN  LPCTSTR     mszInString
)
/*++

Routine Description:

    Counts the number of characters in the multi-sz string (including
        NULL's between strings and terminating NULL char)

Arguments:

    IN  LPCTSTR mszInString
        multi-sz string to count

Return Value:

    number of characters in string

--*/
{
    LPCTSTR szEndChar = mszInString;
    BOOL    bEnd = FALSE;
    DWORD   dwCharsInString = 0;

    while (!bEnd) {
        if (*szEndChar == 0) {
            // this is the end of a line so adjust the count to
            // account for the crlf being 2 chars
            szEndChar++;
            dwCharsInString += 2;

            if (*szEndChar == 0) {
                // this is the end of the MSZ
                dwCharsInString++; // for the CTRL-Z
                bEnd = TRUE;
            }
        } else {
            szEndChar++;
            dwCharsInString++;
        }
    }

    return dwCharsInString;
}

DWORD
TranslateEscapeChars (
    IN  LPTSTR szNewString,
    IN  LPTSTR szString
)
/*++

    Translates the following escape sequences if found in the string.
    The translation is performed on szString and written to szNewString.

    The return value is the length of the resulting string in characters;

--*/
{
    LPTSTR szSource;
    LPTSTR szDest;

    szSource = szString;
    szDest = szNewString;

    while (*szSource != 0) {
        if (*szSource == '\\') {
            // this is an escape sequence so go to the next char
            // and see which one.
            szSource++;
            switch (*szSource) {
                case _T('b'):
                    *szDest = _T('\b');
                    break;

                case _T('f'):
                    *szDest = _T('\f');
                    break;

                case _T('n'):
                    *szDest = _T('\n');
                    break;

                case _T('r'):
                    *szDest = _T('\r');
                    break;

                case _T('t'):
                    *szDest = _T('\t');
                    break;

                case _T('v'):
                    *szDest = _T('\v');
                    break;

                case _T('?'):
                    *szDest = _T('\?');
                    break;

                case _T('\''):
                    *szDest = _T('\'');
                    break;

                case _T('\"'):
                    *szDest = _T('\"');
                    break;

                case _T('\\'):
                    *szDest = _T('\\');
                    break;

                default:
                    *szDest = *szSource;
                    break;
            }
            szDest++;
            szSource++;
        } else {
            // just a plain old character so copy it
            *szDest++ = *szSource++;
        }
    }
    return (DWORD)(szDest - szNewString);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\clcreator\sharpath.c ===
/*++

    Copyright (c) 1994  Microsoft Corporation

Module Name:

    Sharpath.H

Abstract:

    display message box and share path

Author:

    Bob Watson (a-robw)

Revision History:

    17 Feb 94    Written

--*/
//
//  Windows Include Files
//

#include <windows.h>
#include <stdio.h>
#include <malloc.h>
#include <tchar.h>      // unicode macros
#include <lmcons.h>     // lanman API constants
#include <lmerr.h>      // lanman error returns
#include <lmshare.h>    // sharing API prototypes
//
//  app include files
//
#include "otnboot.h"
#include "otnbtdlg.h"

#define     NCDU_MSG_SHARE_DIR  (WM_USER + 101)

static PSPS_DATA    pspData;        // path & share info passed in

PSECURITY_DESCRIPTOR
GetShareSecurityDescriptor (
    VOID
)
/*++

Routine Description:

    Allocates, and initializes a security descriptor for the
        share point created by the app. The security descriptor
        contains two ACE's
            Domain Admins:  Full Control
            Everyone:       Read only

Arguments:

    None

Return Value:

    Address of an initialized security descriptor of all went OK
    a Null pointer if an error occurred  (which gives everyone Full Control)

--*/
{
    PSECURITY_DESCRIPTOR    pSD = NULL;
    PSID                    psidAdmins = NULL;
    PSID                    psidWorld = NULL;
    PSID                    psidDomainAdmins = NULL;
    BOOL                    bValidSd = TRUE;
    PACL                    pACL = NULL;
    DWORD                   dwAclSize = 0;
    DWORD                   dwError = ERROR_SUCCESS;
    DWORD                   dwSidLength = 0;
    DWORD                   dwDomainNameLength = 0;
    SID_IDENTIFIER_AUTHORITY    siaAdmins = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    siaWorld = SECURITY_WORLD_SID_AUTHORITY;
    LPTSTR                  szDomainName;
    SID_NAME_USE            snu;

    // create an empty Security Descriptor
    pSD = GlobalAlloc (GPTR, SMALL_BUFFER_SIZE);
    if (pSD != NULL) {
        if (InitializeSecurityDescriptor (pSD, SECURITY_DESCRIPTOR_REVISION)) {
            // create the Admin SID
            if (AllocateAndInitializeSid (&siaAdmins,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0, &psidAdmins)) {
                // create the World SID
                if (AllocateAndInitializeSid(&siaWorld,
                    1,
                    SECURITY_WORLD_RID,
                    0, 0, 0, 0, 0, 0, 0, &psidWorld)) {

                    psidDomainAdmins = GlobalAlloc (GPTR, SMALL_BUFFER_SIZE);
                    if (psidDomainAdmins != NULL) {
                        dwSidLength = SMALL_BUFFER_SIZE;
                    }
                    szDomainName = GlobalAlloc (GPTR, MAX_PATH_BYTES);
                    if (szDomainName != NULL) {
                        dwDomainNameLength = MAX_PATH;
                    }

                    LookupAccountName (
                        pspData->szServer,
                        GetStringResource (CSZ_DOMAIN_ADMINS),
                        psidDomainAdmins,
                        &dwSidLength,
                        szDomainName,
                        &dwDomainNameLength,
                        &snu);

                    // allocate and initialize the ACL;
                    dwAclSize = sizeof(ACL) +
                        (3 * sizeof(ACCESS_ALLOWED_ACE)) +
                        GetLengthSid(psidAdmins) +
                        GetLengthSid(psidWorld) +
                        (psidDomainAdmins != NULL ? GetLengthSid(psidDomainAdmins) : 0) -
                        sizeof(DWORD);

                    pACL = GlobalAlloc (GPTR, dwAclSize);
                    if(pACL == NULL) {
                      // free local structures
                      FreeSid (psidAdmins);
                      FreeSid (psidWorld);

                      FREE_IF_ALLOC (pSD);
                      return NULL;
                    }
                    InitializeAcl (pACL, dwAclSize, ACL_REVISION);

                    if (psidDomainAdmins != NULL) {
                        // add the Domain Admin ACEs
                        AddAccessAllowedAce (pACL, ACL_REVISION,
                            GENERIC_ALL, psidDomainAdmins);
                    }

                    // add the Admin ACEs
                    AddAccessAllowedAce (pACL, ACL_REVISION,
                        GENERIC_ALL, psidAdmins);

                    // add the World ACE
                    AddAccessAllowedAce (pACL, ACL_REVISION,
                        (GENERIC_READ | GENERIC_EXECUTE), psidWorld);

                    // add a discretionary ACL to the Security Descriptor
                    SetSecurityDescriptorDacl (
                        pSD,
                        TRUE,
                        pACL,
                        FALSE);

                    // free local structures
                    FreeSid (psidAdmins);
                    FreeSid (psidWorld);
                    // return the completed SD
                } else {
                    // unable to allocate a World (everyone) SID
                    // free Admin SID and set not valid flag
                    FreeSid (psidAdmins);
                    bValidSd = FALSE;
                }
            } else {
                // unable to allocate an Admin SID
                bValidSd = FALSE;
            }
        } else {
            // unable to init. Security Descriptor
            bValidSd = FALSE;
        }
    }

    if ((pSD == NULL) || !bValidSd ) {
        // something happened, so the SD is not valid. Free it and return
        // NULL
        FREE_IF_ALLOC (pSD);
        pSD = NULL;
    } else {
        // make sure all was created OK
        if (!IsValidSecurityDescriptor(pSD)) {
            // an invalid sercurity descriptor was created so
            // get reason, then trash it.
            dwError = GetLastError();
            FREE_IF_ALLOC (pSD);
            pSD = NULL;
        }
    }

    return pSD;
}

static
BOOL
SharePathDlg_WM_INITDIALOG (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Process the WM_INITDIALOG windows message. Initialized the
        values in the dialog box controls to reflect the current
        values of the Application data structure.

Arguments:

    IN  HWND    hwndDlg
        handle to dialog box window

    IN  WPARAM  wParam
        Not Used

    IN  LPARAM  lParam
        address of SHARE_PATH_DLG_STRUCT that contains share information

Return Value:

    FALSE

--*/
{
    PositionWindow  (hwndDlg);

    if (lParam == 0) {
        pspData = NULL;
        EndDialog (hwndDlg, IDCANCEL);
    } else {
        pspData = (PSPS_DATA)lParam;
        SetDlgItemText (hwndDlg, NCDU_CTL_SHARING_PATH_NAME, pspData->szPath);
        SetDlgItemText (hwndDlg, NCDU_CTL_SHARING_PATH_ON,
                (pspData->szServer != NULL ? pspData->szServer :
                    GetStringResource (CSZ_LOCAL_MACHINE)));
        SetDlgItemText (hwndDlg, NCDU_CTL_SHARING_PATH_AS,
            pspData->szShareName);

        SetCursor (LoadCursor(NULL, IDC_WAIT));
        PostMessage (hwndDlg, NCDU_MSG_SHARE_DIR, 0, 0);
    }

//    SetActiveWindow (hwndDlg);

    return TRUE;
}

static
BOOL
SharePathDlg_SHARE_DIR (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam  // LPTSTR to sharename
)
/*++

Routine Description:

    Shares either the Distribution or the Destination dir depending on
        the wParam. Uses the share name entered in the display. If
        successful this message terminates the dialog box, otherwise
        an error message will be displayed.

Arguments:

    IN  HWND    hwndDlg
        Handle to dialog box window

    IN  WPARAM  wParam
        Not Used

    IN  LPARAM  lParam
        Not Used

Return Value:

    TRUE if shared
    FALSE if not (GetLastError for info)

--*/
{
    BOOL    bDist;
    NET_API_STATUS  naStatus;
    DWORD   dwParmErr;
    SHARE_INFO_502    si502;    // share info block
    LONG    lCount;

    bDist       = (BOOL)wParam;

    // initialize share data block

    si502.shi502_netname = pspData->szShareName;
    si502.shi502_type = STYPE_DISKTREE;
    si502.shi502_remark = (LPWSTR)pspData->szRemark;
    si502.shi502_permissions = PERM_FILE_READ;
    si502.shi502_max_uses = SHI_USES_UNLIMITED;
    si502.shi502_current_uses = 0;
    si502.shi502_path = pspData->szPath;
    si502.shi502_passwd = NULL;
    si502.shi502_reserved = 0L;
    si502.shi502_security_descriptor = GetShareSecurityDescriptor();

    naStatus = NetShareAdd (
        pspData->szServer, // machine
        502,            // level 502 request
        (LPBYTE)&si502, // data request buffer
        &dwParmErr);    // parameter buffer

    if (naStatus != NERR_Success) {
        // restore cursor
        SetCursor (LoadCursor(NULL, IDC_ARROW));

        // display error
        MessageBox (
            hwndDlg,
            GetNetErrorMsg (naStatus),
            0,
            MB_OK_TASK_EXCL);
        EndDialog (hwndDlg, IDCANCEL);
    } else {
        // successfully shared so wait til it registers or we get bored
        lCount = 200;   // wait 20 seconds then give up and leave
        while (!LookupLocalShare (pspData->szPath, TRUE,
            NULL, NULL )) {
            Sleep (100);     // wait until the new share registers
            if (--lCount == 0) break;
        }

        Sleep (1000);   // wait for shared dir to become available

        SetCursor (LoadCursor(NULL, IDC_ARROW));
        EndDialog (hwndDlg, IDOK);
    }

    FREE_IF_ALLOC (si502.shi502_security_descriptor);
    return TRUE;
}

INT_PTR CALLBACK
SharePathDlgProc (
    IN  HWND    hwndDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Main Dialog Box Window Procedure for the Initial configuration screen
        Processes the following windows messages by dispatching the
        appropriate routine.

            WM_INITDIALOG:  dialog box initialization
            WM_COMMAND:     user input

        All other windows messages are processed by the default dialog box
        procedure.

Arguments:

    Standard WNDPROC arguments

Return Value:

    FALSE if the message is not processed by this routine, otherwise the
        value returned by the dispatched routine.

--*/
{
    switch (message) {
        case WM_INITDIALOG: return (SharePathDlg_WM_INITDIALOG (hwndDlg, wParam, lParam));
        case NCDU_MSG_SHARE_DIR:    return (SharePathDlg_SHARE_DIR (hwndDlg, wParam, lParam));
        default:            return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\clcreator\targetws.c ===
/*++

    Copyright (c) 1994  Microsoft Corporation

Module Name:

    TARGETWS.H

Abstract:

    Show Target Workstation Configureation Dialog Box Procedures

Author:

    Bob Watson (a-robw)

Revision History:

    17 Feb 94    Written

--*/
//
//  Windows Include Files
//

#include <windows.h>
#include <stdio.h>
#include <malloc.h>
#include <tchar.h>      // unicode macros
//
//  app include files
//
#include "otnboot.h"
#include "otnbtdlg.h"
//
//  list of data items that correspond to entries in combo box
//  the combo box displays the text description and the entries in this
//  msz are the keys to refer to the selected item later.
//
static  TCHAR   mszNetcardKeyList[SMALL_BUFFER_SIZE];
static  TCHAR   mszDirNameList[SMALL_BUFFER_SIZE];

#ifdef JAPAN
//  fixed kkntbug #12382
//      NCAdmin:"[] Make Japanese startup disks" is not functioning.

//
//  indicator for making DOS/V boot disks
//

BOOL    bJpnDisk;
#endif

static
VOID
SetDialogState (
    IN  HWND    hwndDlg
)
/*++

Routine Description:

    Enables/Disables the target workstation configuration items based
        on the target configuration. If target is a remote boot client
        then the protocol/card, etc items are not necessary, if the
        target is to have the network software loaded over the net, then
        the netcard, protocol, etc fields are enabled.

Arguments:

    IN  HWND    hwndDlg
        Handle to the dialog box window

Return Value:

    None

--*/
{
    EnableWindow (GetDlgItem (hwndDlg, NCDU_CLIENT_SOFTWARE_LIST), TRUE);
    EnableWindow (GetDlgItem (hwndDlg, NCDU_CLIENT_SOFTWARE_LIST_LABEL), TRUE);
    EnableWindow (GetDlgItem (hwndDlg, NCDU_NETCARD_COMBO_BOX), TRUE);
    EnableWindow (GetDlgItem (hwndDlg, NCDU_NETCARD_COMBO_BOX_LABEL), TRUE);
}

static
LPCTSTR
GetNameFromEntry (
    IN  LPCTSTR  szEntry
)
/*++

Routine Description:

    Used to parse entries from the INF the format. returns the
        unquoted version of the first quoted string in the szEntry
        buffer

Arguments:

    IN  LPCTSTR  szEntry
        entry to examine

Return Value:

    pointer to entry or empty string if no matching items are found

--*/
{
    static  TCHAR   szReturnBuff[MAX_PATH];
    LPTSTR  szSource, szDest;

    szSource = (LPTSTR)szEntry;
    szDest = &szReturnBuff[0];

    // find "=", then find first " after equals. Copy all chars after
    // first quote up to but not including the next " char.

    while ((*szSource != cEqual) && (*szSource != 0)) szSource++;
    // szSource is at "=" (or end)
    while ((*szSource != cDoubleQuote) && (*szSource != 0)) szSource++;
    // szSource is at first double quote (or end)
    szSource++;
    while ((*szSource != cDoubleQuote) && (*szSource != 0)) {
        *szDest++ = *szSource++;
    }
    *szDest = 0;
    return &szReturnBuff[0];
}

static
VOID
LoadNetCardAdapterList (
    IN  HWND    hwndDlg
)
/*++

Routine Description:

    Loads the Network adapter card combo box using entries found in the
        inf file.

Arguments:

    IN  HWND    hwndDlg
        Handle to dialog box window

Return Value:

    none

--*/
{
    LPTSTR  mszKeyList;
    LPTSTR  szData;
    LPTSTR  szInfName;
    LPTSTR  szNetCardInf;
    LPTSTR  szThisItem;
    int     nEntry;
    int     nMszElem;
    UINT    nErrorMode;

    szInfName = (LPTSTR)GlobalAlloc(GPTR, MAX_PATH_BYTES);
    szNetCardInf = (LPTSTR)GlobalAlloc(GPTR, MAX_PATH_BYTES);

    if ((szInfName == NULL) || (szNetCardInf == NULL)) return;

    // clear dialog box contents
    SendDlgItemMessage (hwndDlg, NCDU_NETCARD_COMBO_BOX, CB_RESETCONTENT, 0, 0);

    szData = (LPTSTR)GlobalAlloc (GPTR, SMALL_BUFFER_SIZE * sizeof(TCHAR));
    mszKeyList = (LPTSTR)GlobalAlloc (GPTR, MEDIUM_BUFFER_SIZE * sizeof(TCHAR));

    if ((szData != NULL) && (mszKeyList != NULL)) {
        // disable windows error message popup
        nErrorMode = SetErrorMode  (SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);
        // make path to inf file
        lstrcpy (szInfName, pAppInfo->szDistPath);
        if (szInfName[lstrlen(szInfName)-1] != cBackslash) lstrcat (szInfName, cszBackslash);
        lstrcat (szInfName, cszOtnBootInf);

        // get location of inf that has net cards for floppy installation

        if (QuietGetPrivateProfileString (cszOtnInstall, cszClient, cszEmptyString,
            szData, SMALL_BUFFER_SIZE, szInfName) > 0) {

            lstrcpy (szNetCardInf, pAppInfo->szDistPath);
            if (szNetCardInf[lstrlen(szNetCardInf)-1] != cBackslash) lstrcat (szNetCardInf, cszBackslash);
            lstrcat (szNetCardInf, szData);
            if (szNetCardInf[lstrlen(szNetCardInf)-1] != cBackslash) lstrcat (szNetCardInf, cszBackslash);
            // save directory containing floppy net files
            lstrcpy(pAppInfo->piFloppyProtocol.szDir, szNetCardInf);
            if (QuietGetPrivateProfileString (cszOtnInstall, cszInf, cszEmptyString,
                szData, SMALL_BUFFER_SIZE, szInfName) > 0) {
                lstrcat (szNetCardInf, szData);
            }
            if (FileExists (szNetCardInf)) {
                // save the name of the file here
                lstrcpy (pAppInfo->niNetCard.szInf, szNetCardInf);
                // netcard inf file exists so fill up list box
                if (GetPrivateProfileSection (cszNetcard, mszKeyList,
                    MEDIUM_BUFFER_SIZE, szNetCardInf) > 0) {
                    nMszElem = 1;
                    for (szThisItem = mszKeyList;
                        *szThisItem != 0;
                        szThisItem += (lstrlen(szThisItem)+1)) {
                        // get name string from entry
                        // load into combo box
                        nEntry = (int)SendDlgItemMessage ( hwndDlg,
                            NCDU_NETCARD_COMBO_BOX,
                            CB_ADDSTRING, 0,
                            (LPARAM)GetNameFromEntry(szThisItem));
                        // get key from entry
                        // update item data
                        AddStringToMultiSz(mszNetcardKeyList,
                            GetKeyFromEntry (szThisItem));
                        SendDlgItemMessage (hwndDlg, NCDU_NETCARD_COMBO_BOX,
                            CB_SETITEMDATA, (WPARAM)nEntry, (LPARAM)nMszElem);
                        nMszElem++;
                    } // end section key loop
                    SendDlgItemMessage (hwndDlg, NCDU_NETCARD_COMBO_BOX,
                        CB_SETCURSEL, 0, 0);
                }// else unable to read section
            } // else no such inf file
        } // else unable to read OTN data
        SetErrorMode (nErrorMode);  // restore old error mode
    } // else unable to allocate memory
    // free memory
    FREE_IF_ALLOC (szData);
    FREE_IF_ALLOC (mszKeyList);
    FREE_IF_ALLOC (szInfName);
    FREE_IF_ALLOC (szNetCardInf);

    return;
}

static
BOOL
TargetWsDlg_WM_INITDIALOG (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    processes the WM_INITDIALOG windows message. Initializes the dialog
        box to the current values in the app data structure

Arguments:

    IN  HWND    hwndDlg
        Handle to the dialog box window

    IN  WPARAM  wParam
        Not Used

    IN  LPARAM  lParam
        Not Used

Return Value:

    FALSE

--*/
{
    LONG    lClientId;

    RemoveMaximizeFromSysMenu (hwndDlg);
    PositionWindow  (hwndDlg);

    if (pAppInfo->mtBootDriveType == F3_1Pt44_512) {
        CheckDlgButton (hwndDlg, NCDU_35HD_DISK, CHECKED);
    } else {
        CheckDlgButton (hwndDlg, NCDU_525HD_DISK, CHECKED);
    }

    *(PDWORD)mszNetcardKeyList = 0; // clear first 4 bytes of string

    LoadNetCardAdapterList (hwndDlg);

    // set to current net card if any

    SendDlgItemMessage (hwndDlg, NCDU_NETCARD_COMBO_BOX, CB_SELECTSTRING,
            (WPARAM)0, (LPARAM)pAppInfo->niNetCard.szName);

#ifdef JAPAN
//  fixed kkntbug #12382
//      NCAdmin:"[] Make Japanese startup disks" is not functioning.

    if (usLangID == LANG_JAPANESE) {
        bJpnDisk = TRUE;
        SendDlgItemMessage (hwndDlg, NCDU_DOSV_CHECK, BM_SETCHECK, (WPARAM)1, (LPARAM)0);
    } else {
        bJpnDisk = FALSE;
        ShowWindow(GetDlgItem(hwndDlg, NCDU_DOSV_CHECK), SW_HIDE);
    }
#endif

    LoadClientList (hwndDlg, NCDU_CLIENT_SOFTWARE_LIST,
        pAppInfo->szDistPath, CLT_OTNBOOT_FLOPPY, mszDirNameList);
    lClientId = (LONG)SendDlgItemMessage (hwndDlg, NCDU_CLIENT_SOFTWARE_LIST,
        LB_FINDSTRING, 0, (LPARAM)&(pAppInfo->piTargetProtocol.szName[0]));
    if (lClientId == LB_ERR) lClientId = 0;
    SendDlgItemMessage (hwndDlg, NCDU_CLIENT_SOFTWARE_LIST,
        LB_SETCURSEL,  (WPARAM)lClientId, 0);

    SetDialogState(hwndDlg);

    SetFocus (GetDlgItem(hwndDlg, IDOK));

    // clear old Dialog and register current
    PostMessage (GetParent(hwndDlg), NCDU_CLEAR_DLG, (WPARAM)hwndDlg, IDOK);
    PostMessage (GetParent(hwndDlg), NCDU_REGISTER_DLG,
        NCDU_TARGET_WS_DLG, (LPARAM)hwndDlg);
    SetCursor(LoadCursor(NULL, IDC_ARROW));

    return FALSE;
}

static
BOOL
TargetWsDlg_IDOK (
    IN  HWND    hwndDlg
)
/*++

Routine Description:

    Processes the OK button press. validates the data in the dialog and
        updates the application data structure with the information.
        If all data is valid, then the dialog box is closed, otherwise
        an error message is displayed and focus is set to the offending
        control.

Arguments:

    IN  HWND    hwndDlg
        Handle to the dialog box window

Return Value:

    FALSE

--*/
{
    int     nCancelResult;
    int     nCbSelIndex;
    int     nClientIndex;
    int     nWarningIndex;
    LPTSTR  szClientDir;
    LPTSTR  szWfwMessage;
    DWORD   dwKeyIndex;
    LPTSTR  szFromPath;
    LPTSTR  szClientDirKey;
    TCHAR   szClientDirName[MAX_PATH];
    TCHAR   szWarningText[MAX_PATH];
    TCHAR   szWarningCaption[MAX_PATH];
    LPTSTR  szNextMessage;

    TCHAR   szWfwDirName[32];
    TCHAR   szWin95DirName[32];
    TCHAR   szWinNtDirName[32];
#ifdef JAPAN
    TCHAR   szWinntus[MAX_PATH];
    TCHAR   szSetupCmdName[32];
    OFSTRUCT   OpenBuff;
#endif

    // save settings

    szFromPath = (LPTSTR)GlobalAlloc (GPTR, MAX_PATH_BYTES);

    if (szFromPath == NULL) {
        // mem alloc err.
        EndDialog (hwndDlg, IDCANCEL);
        return TRUE;
    }

    if (IsDlgButtonChecked(hwndDlg, NCDU_35HD_DISK) == CHECKED) {
        pAppInfo->mtBootDriveType = F3_1Pt44_512;
    } else {
        pAppInfo->mtBootDriveType = F5_1Pt2_512;
    }

    // MS Network client selected so save values
    //  configure server settings
    //
    // see if a client that needs a "guilt" message displayed
    //

    // get client to install
    nClientIndex = (int)SendDlgItemMessage (hwndDlg, NCDU_CLIENT_SOFTWARE_LIST,
        LB_GETCURSEL, 0, 0);

    if (nClientIndex == LB_ERR) return FALSE;

    // save setup command for OTN setup
    lstrcpy (szFromPath, pAppInfo->szDistPath);
    if (szFromPath[lstrlen(szFromPath)-1] != cBackslash) lstrcat (szFromPath, cszBackslash);
    lstrcat (szFromPath, cszAppInfName);

    // copy the client key from the list box name list
    lstrcpy (szClientDirName, (LPTSTR)GetEntryInMultiSz (mszDirNameList, nClientIndex+1));
    lstrcat (szClientDirName, TEXT("_"));
    szClientDirKey = szClientDirName + lstrlen(szClientDirName);

    // see if a guilt message for this client should be displayed.
    lstrcpy (szClientDirKey, cszCaption);
    if (QuietGetPrivateProfileString (cszWarningClients,
        szClientDirName,
        cszEmptyString, szWarningCaption,
        sizeof(szWarningCaption)/sizeof(TCHAR), szFromPath) > 0) {

        // then a caption was found indicating a warning message should be
        // displayed.

        szWfwMessage = GlobalAlloc (GPTR, SMALL_BUFFER_SIZE * sizeof(TCHAR));
        if (szWfwMessage != NULL) {
            *szWfwMessage = 0;
            // so now get all the strings from the file and build
            // the display string

            for (nWarningIndex = 1, szNextMessage = szWfwMessage;
                _stprintf (szClientDirKey, TEXT("%d"), nWarningIndex),
                (QuietGetPrivateProfileString (cszWarningClients,
                    szClientDirName,
                    cszEmptyString, szWarningText,
                    sizeof(szWarningText), szFromPath) > 0);
                nWarningIndex++) {

                szNextMessage += TranslateEscapeChars(szNextMessage, szWarningText);
            }

            nCancelResult = MessageBox (
                hwndDlg,
                szWfwMessage,
                szWarningCaption,
                MB_OKCANCEL_TASK_EXCL_DEF2);

            if (nCancelResult == IDCANCEL)  {
                // they don't really want to do this
                SetFocus (GetDlgItem (hwndDlg, NCDU_CLIENT_SOFTWARE_LIST));
                return FALSE;
            } // else continue

            GlobalFree (szWfwMessage);
        } // else unable to allocate string buffer so continue
    } // else no warning message is necessary

    pAppInfo->bRemoteBootReqd = FALSE;
    // get netcard name and other information
    nCbSelIndex = (int)SendDlgItemMessage(hwndDlg, NCDU_NETCARD_COMBO_BOX,
        CB_GETCURSEL, 0, 0);
    SendDlgItemMessage (hwndDlg, NCDU_NETCARD_COMBO_BOX, CB_GETLBTEXT,
        (WPARAM)nCbSelIndex, (LPARAM)pAppInfo->niNetCard.szName);

    dwKeyIndex = (DWORD)SendDlgItemMessage (hwndDlg, NCDU_NETCARD_COMBO_BOX, CB_GETITEMDATA,
        (WPARAM)nCbSelIndex, 0);

    lstrcpy (pAppInfo->niNetCard.szInfKey, GetEntryInMultiSz(mszNetcardKeyList, dwKeyIndex));

    // get the rest of the netcard information.

    QuietGetPrivateProfileString (cszNetcard,
        pAppInfo->niNetCard.szInfKey,
        cszEmptyString,
        szFromPath, MAX_PATH,
        pAppInfo->niNetCard.szInf);

    lstrcpy (pAppInfo->niNetCard.szDeviceKey, GetItemFromEntry (szFromPath, 6));
    lstrcpy (pAppInfo->niNetCard.szNifKey, GetItemFromEntry (szFromPath, 7));
    if (_tcsnicmp(GetItemFromEntry(szFromPath,4), cszTokenRing, lstrlen(cszTokenRing)) == 0) {
        pAppInfo->niNetCard.bTokenRing = TRUE;
    } else {
        pAppInfo->niNetCard.bTokenRing = FALSE;
    }

    SendDlgItemMessage (hwndDlg, NCDU_CLIENT_SOFTWARE_LIST,
        LB_GETTEXT, (WPARAM)nClientIndex, (LPARAM)&(pAppInfo->piTargetProtocol.szName[0]));

    // get root dir of dist tree
    lstrcpy (szFromPath, pAppInfo->szDistPath);
    if (szFromPath[lstrlen(szFromPath)-1] != cBackslash) lstrcat (szFromPath, cszBackslash);

    // append client sw subdir
    szClientDir = (LPTSTR)GetEntryInMultiSz (mszDirNameList, nClientIndex+1);
    lstrcat (szFromPath, szClientDir);
    if (szFromPath[lstrlen(szFromPath)-1] != cBackslash) lstrcat (szFromPath, cszBackslash);

    // append name of Over the Net distribution dir
    lstrcat (szFromPath, cszNetsetup);

    // save protocol file path for OTN setup
    lstrcpy (pAppInfo->piTargetProtocol.szDir, szFromPath);

    // save setup command for OTN setup
    lstrcpy (szFromPath, pAppInfo->szDistPath);
    if (szFromPath[lstrlen(szFromPath)-1] != cBackslash) lstrcat (szFromPath, cszBackslash);
        lstrcat (szFromPath, cszAppInfName);

#ifdef JAPAN
//  fixed kkntbug #12382
//      NCAdmin:"[] Make Japanese startup disks" is not functioning.

    lstrcpy(szSetupCmdName, szClientDir);

    if (!bJpnDisk)  {
        wsprintf(szWinntus, TEXT("%s%s%s%s"), pAppInfo->szDistPath, szClientDir, cszBackslash, fmtWinntUs);
        if (HFILE_ERROR != OpenFile((LPCSTR)szWinntus, &OpenBuff, OF_EXIST))
            wsprintf(szSetupCmdName, TEXT("%s%s"), szClientDir, fmtAppendUs);
    }

    if (!QuietGetPrivateProfileString (cszSetupCmd, szSetupCmdName, cszEmptyString,
        pAppInfo->szTargetSetupCmd, MAX_PATH, szFromPath))
#endif
    QuietGetPrivateProfileString (cszSetupCmd, szClientDir, cszEmptyString,
        pAppInfo->szTargetSetupCmd, MAX_PATH, szFromPath);


    PostMessage (GetParent(hwndDlg), NCDU_SHOW_SERVER_CFG_DLG, 0, 0);
    SetCursor(LoadCursor(NULL, IDC_WAIT));
    FREE_IF_ALLOC (szFromPath);

    return TRUE;
}

static
BOOL
TargetWsDlg_WM_COMMAND (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Processes WM_COMMAND windows message and dispatches the appropriate
        routine.

Arguments:

    IN  HWND    hwndDlg
        handle to the dialog box window

    IN  WPARAM  wParam
        LOWORD has the ID of the Control issuing the message

    IN  LPARAM  lParam
        Not Used

Return Value:

    TRUE if message is not processed by this routine otherwise
        FALSE or the value returned by the dispatched routine.

--*/
{
    switch (LOWORD(wParam)) {
        case IDCANCEL:
            PostMessage (GetParent(hwndDlg), NCDU_SHOW_SHARE_NET_SW_DLG, 0, 0);
            SetCursor(LoadCursor(NULL, IDC_WAIT));
            return TRUE;

        case IDOK:  return TargetWsDlg_IDOK (hwndDlg);
#ifdef JAPAN
//  fixed kkntbug #12382
//      NCAdmin:"[] Make Japanese startup disks" is not functioning.

        case NCDU_DOSV_CHECK:
            if (IsDlgButtonChecked(hwndDlg, NCDU_DOSV_CHECK) == 1)
                bJpnDisk = TRUE;
            else
                bJpnDisk = FALSE;

            return TRUE;
#endif
        case NCDU_TARGET_WS_HELP:
            switch (HIWORD(wParam)) {
                case BN_CLICKED:
//                    return ShowAppHelp (hwndDlg, LOWORD(wParam));
                    return PostMessage (GetParent(hwndDlg), WM_HOTKEY,
                        (WPARAM)NCDU_HELP_HOT_KEY, 0);

                default:
                    return FALSE;
            }

        default:    return FALSE;
    }
}

INT_PTR CALLBACK
TargetWsDlgProc (
    IN  HWND    hwndDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Processes windows messages to this dialog box. The following messages
        are processed by this module:

            WM_INITDIALOG:  dialog box initialization
            WM_COMMAND:     user action

        all other messages are processed by the default dialog proc.

Arguments:

    Standard WNDPROC args

Return Value:

    FALSE if message is not processed by this module, otherwise the
        value returned by the dispatched routine.

--*/
{
    switch (message) {
        case WM_INITDIALOG: return (TargetWsDlg_WM_INITDIALOG (hwndDlg, wParam, lParam));
        case WM_COMMAND:    return (TargetWsDlg_WM_COMMAND (hwndDlg, wParam, lParam));
        case WM_PAINT:      return (Dlg_WM_PAINT (hwndDlg, wParam, lParam));
        case WM_MOVE:       return (Dlg_WM_MOVE (hwndDlg, wParam, lParam));
        case WM_SYSCOMMAND: return (Dlg_WM_SYSCOMMAND (hwndDlg, wParam, lParam));
        default:            return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\clcreator\strings.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    strings.c

Abstract:

    String Constant definitions for the Net Client Disk Utility.

Author:

    Bob Watson (a-robw)

Revision History:

    17 Feb 94    Written


--*/
#include    <windows.h>
#include    "otnboot.h"
//
//  ncadmin.c strings
//
LPCTSTR szAppName = TEXT("NCAdmin"); // The name of this application
//
//  copyflop.c format strings
//
LPCTSTR cszNames = TEXT("_names");
LPCTSTR cszLabel = TEXT("_label");
//
//  makeflop.c format strings
//
LPCTSTR fmtNetcardDefEntry = TEXT("netcard=%s,1,%s,1");
LPCTSTR fmtTransportDefEntry = TEXT("transport=ms$ndishlp,MS$NDISHLP");
LPCTSTR fmtTransportItem = TEXT("transport=%s,%s");
LPCTSTR fmtLana0Entry = TEXT("lana0=%s,1,%s");
LPCTSTR fmtLana1Entry = TEXT("lana1=%s,1,ms$ndishlp");
LPCTSTR fmtIniSection = TEXT("[%s]");
LPCTSTR fmtIniKeyEntry = TEXT("%s=%s");
LPCTSTR fmtCmntIniKeyEntry = TEXT("; %s=%s");
LPCTSTR fmtProtmanSection = TEXT("[protman]");
LPCTSTR fmtBindingsEntry = TEXT("BINDINGS=%s");
LPCTSTR fmtXifEntry = TEXT("%s_xif");
LPCTSTR fmtLanabase0 = TEXT("LANABASE=0");
LPCTSTR fmtNoFilesharing = TEXT("filesharing=no");
LPCTSTR fmtNoPrintsharing = TEXT("printsharing=no");
LPCTSTR fmtYesAutologon = TEXT("autologon=yes");
LPCTSTR fmtComputernameEntry = TEXT("computername=%s");
LPCTSTR fmtLanaRootOnA = TEXT("lanroot=A:\\NET");
LPCTSTR fmtUsernameEntry = TEXT("username=%s");
LPCTSTR fmtWorkgroupEntry = TEXT("workgroup=%s");
LPCTSTR fmtNoReconnect = TEXT("reconnect=no");
LPCTSTR fmtNoDirectHost = TEXT("directhost=no");
LPCTSTR fmtNoDosPopHotKey = TEXT("dospophotkey=N");
LPCTSTR fmtLmLogon0 = TEXT("lmlogon=0");
LPCTSTR fmtLmLogon1 = TEXT("lmlogon=1");
LPCTSTR fmtLogonDomainEntry = TEXT("logondomain=%s");
LPCTSTR fmtPreferredRedirBasic = TEXT("preferredredir=basic");
LPCTSTR fmtAutostartBasic = TEXT("autostart=basic");
LPCTSTR fmtPreferredRedirFull = TEXT("preferredredir=full");
LPCTSTR fmtAutostartFull = TEXT("autostart=full");
LPCTSTR fmtMaxConnections = TEXT("maxconnections=8");
LPCTSTR fmtNetworkDriversSection = TEXT("[network drivers]");
LPCTSTR fmtNetcardEntry = TEXT("netcard=%s");
LPCTSTR fmtTcpTransportEntry = TEXT("transport=tcpdrv.dos,nemm.dos");
LPCTSTR fmtNdisTransportEntry = TEXT("transport=ndishlp.sys");
LPCTSTR fmtNetbeuiAddon = TEXT(",*netbeui");
LPCTSTR fmtDevdir = TEXT("devdir=A:\\NET");
LPCTSTR fmtLoadRmDrivers = TEXT("LoadRMDrivers=yes");
LPCTSTR fmtPasswordListSection = TEXT("[Password Lists]");
#ifdef JAPAN
LPCTSTR fmtPause = TEXT("@pause");
#endif
LPCTSTR fmtPathSpec = TEXT("path=a:\\net");
LPCTSTR fmtNetPrefix = TEXT("a:\\net\\");
LPCTSTR fmtNetUseDrive = TEXT("net use z: %s");
LPCTSTR fmtSetupCommand = TEXT("z:\\%s\\%s");
LPCTSTR fmtFilesParam = TEXT("files=30");
LPCTSTR fmtDeviceIfsHlpSys = TEXT("device=a:\\net\\ifshlp.sys");
LPCTSTR fmtLastDrive = TEXT("lastdrive=z");
LPCTSTR fmtEmptyParam = TEXT("%s=");
LPCTSTR fmtIpParam = TEXT("%s=%d %d %d %d");
LPCTSTR fmtAutoexec = TEXT("_autoexec");
LPCTSTR fmtNBSessions = TEXT("NBSessions=6");
LPCTSTR fmtLoadHiMem = TEXT("DEVICE=A:\\NET\\HIMEM.SYS");
LPCTSTR fmtLoadEMM386 = TEXT("DEVICE=A:\\NET\\EMM386.EXE NOEMS");
LPCTSTR fmtDosHigh = TEXT("DOS=HIGH,UMB");
#ifdef JAPAN
LPCTSTR fmtBilingual = TEXT("DEVICE=A:\\NET\\DOSV\\BILING.SYS");
LPCTSTR fmtFontSys = TEXT("DEVICE=A:\\NET\\DOSV\\JFONT.SYS /U=0 /P=A:\\NET\\DOSV");
LPCTSTR fmtDispSys = TEXT("DEVICE=A:\\NET\\DOSV\\JDISP.SYS /HS=LC");
LPCTSTR fmtKeyboard = TEXT("DEVICE=A:\\NET\\DOSV\\JKEYB.SYS A:\\NET\\DOSV\\JKEYBRD.SYS");
LPCTSTR fmtNlsFunc = TEXT("INSTALL=A:\\NET\\DOSV\\NLSFUNC.EXE A:\\NET\\DOSV\\COUNTRY.SYS");
#endif
//
//  servconn.c format strings
//
LPCTSTR fmtRandomName = TEXT("%4.4x%4.4x%4.4x");
LPCTSTR fmtIpAddr = TEXT("%d.%d.%d.%d");
LPCTSTR fmtIpAddrParse = TEXT(" %d.%d.%d.%d");
LPCTSTR cszZeroNetAddress = TEXT("000000000000");
#ifdef JAPAN
LPCTSTR fmtWinntUs = TEXT("winntus.exe");
LPCTSTR fmtAppendUs = TEXT("us");
#endif
//
//  findclnt.c
//
LPCTSTR cszToolsDir = TEXT("clients\\srvtools");
LPCTSTR cszSrvtoolsDir = TEXT("srvtools");
LPCTSTR cszClientsDir = TEXT("clients");
//
//  exitmess.c format strings
//
LPCTSTR fmtLeadingSpaces = TEXT("    ");
//
//  INF file strings
//
LPCTSTR cszOTNCommonFiles = TEXT("OTN Common Files");
#ifdef JAPAN
LPCTSTR cszOTNDOSVFiles = TEXT("OTN DOS/V Files");
LPCTSTR cszDOSV = TEXT("dosv");
LPCTSTR cszDOSVLabel1 = TEXT("OTN-DISK1");
LPCTSTR cszDOSVLabel2 = TEXT("OTN-DISK2");
LPCTSTR cszDOSVCommonFiles = TEXT("OTN DOS/V Common Files");
#endif
LPCTSTR cszNetworkSetup = TEXT("[network.setup]");
LPCTSTR cszInfVersion = TEXT("version=0x3110");
LPCTSTR cszNdis2 = TEXT("ndis2");
LPCTSTR cszDrivername = TEXT("drivername");
LPCTSTR cszProtmanInstall = TEXT("protman_install");
LPCTSTR cszNetdir = TEXT("netdir");
LPCTSTR cszProtman = TEXT("protman");
LPCTSTR cszMsNdisHlp = TEXT("[MS$NDISHLP]");
LPCTSTR cszMsNdisHlpXif = TEXT("MS$NDISHLP_XIF");
LPCTSTR cszNetworkSection = TEXT("[network]");
LPCTSTR cszDirs = TEXT("Dirs");
LPCTSTR cszDontShowDirs = TEXT("DontShowDirs");
LPCTSTR cszSizes = TEXT("Sizes");
LPCTSTR cszOtnInstall = TEXT("OTN Install");
LPCTSTR cszClient = TEXT("Client");
LPCTSTR cszInf = TEXT("Inf");
LPCTSTR cszNetcard = TEXT("netcard");
LPCTSTR cszOEMInfs = TEXT("OEMInfs");
LPCTSTR cszOTN = TEXT("OTN");
LPCTSTR cszDiskSet = TEXT("DiskSet");
LPCTSTR cszCopyClients = TEXT("CopyClients");
LPCTSTR csz_ClientTree_ = TEXT("_ClientTree_");
LPCTSTR csz_ToolsTree_ = TEXT("_ToolsTree_");
LPCTSTR csz_SystemFileSize_ = TEXT("_SystemFileSize_");
LPCTSTR cszWarningClients = TEXT("WarningClients");
LPCTSTR cszCaption = TEXT("caption");
LPCTSTR cszDiskOptions = TEXT("DiskOptions");
LPCTSTR cszUseCleanDisk = TEXT("UseCleanDisk");
LPCTSTR cszUseCleanDiskYes = TEXT("Yes");
//
//  "hardcoded" filenames
//
LPCTSTR cszAppInfName = TEXT ("ncadmin.inf");
LPCTSTR cszOtnBootInf = TEXT ("ncadmin.inf");
LPCTSTR cszSrvToolsInf = TEXT ("srvtools.inf");
LPCTSTR cszConfigSys = TEXT("config.sys");
LPCTSTR cszAutoexecBat = TEXT("autoexec.bat");
LPCTSTR cszSystemIni = TEXT("system.ini");
LPCTSTR cszProtocolIni = TEXT("protocol.ini");
LPCTSTR cszNetUtils = TEXT("netutils");
LPCTSTR cszSrvToolSigFile = TEXT("srvtools.inf");
LPCTSTR cszNetMsgDll = TEXT("netmsg.dll");
LPCTSTR fmtDiskNumber = TEXT("DISK%d");

// files to look for in order to tell if it's bootable floppy

const LPCTSTR    szBootIdFiles[] = {
    TEXT("MSDOS.SYS"),
    TEXT("IO.SYS"),
    TEXT("IBMIO.SYS"),
    TEXT("COMMAND.COM"),
    NULL
    };

//
// "hardcoded" registry entries
//
LPCTSTR cszSystemProductOptions = TEXT("SYSTEM\\CurrentControlSet\\Control\\ProductOptions");
LPCTSTR cszProductType = TEXT("ProductType");
LPCTSTR cszLanmanNt = TEXT("LanmanNT");
LPCTSTR cszWinNt = TEXT("WinNT");
LPCTSTR cszNetDriveListKeyName = TEXT("Network\\");
LPCTSTR cszRemotePathValue = TEXT("RemotePath");
LPCTSTR cszLanmanServerShares = TEXT("SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Shares");
LPCTSTR cszPath = TEXT("Path");
LPCTSTR cszSoftwareMicrosoft = TEXT("SOFTWARE\\Microsoft");
LPCTSTR cszCurrentVersion = TEXT("CurrentVersion");
LPCTSTR cszSoftwareType = TEXT ("SoftwareType");
LPCTSTR cszTransport = TEXT("transport");
LPCTSTR cszTitle = TEXT ("Title");
LPCTSTR cszProtocol = TEXT("Protocol");
LPCTSTR cszUserInfoKey = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Network");
LPCTSTR cszLastClientServer = TEXT("LastClientServer");
LPCTSTR cszLastClientSharepoint = TEXT("LastClientSharepoint");
LPCTSTR cszLastToolsServer = TEXT("LastToolsServer");
LPCTSTR cszLastToolsSharepoint = TEXT("LastToolsSharepoint");
//
//  miscellaneous strings
//
LPCTSTR cszNet = TEXT("NET");
LPCTSTR cszTCP = TEXT("TCP");
LPCTSTR cszNetbeui = TEXT("NETBEUI");
LPCTSTR cszBrowseFilterList = TEXT("Config files (*.inf)\0*.inf\0\0");
LPCTSTR cszTcpKey = TEXT("TCP");
LPCTSTR cszTcpIpEntry = TEXT("tcpip");
LPCTSTR cszNetbeuiKey = TEXT("NETBEUI");
LPCTSTR cszNetbeuiEntry = TEXT("ms$netbeui");
LPCTSTR cszIpxKey = TEXT("NWLink");
LPCTSTR cszIpxEntry = TEXT("ms$nwlink");
LPCTSTR cszNetsetup = TEXT("netsetup");
LPCTSTR cszDisks = TEXT("disks");
LPCTSTR cszDisk = TEXT(" Disk");
LPCTSTR cszSetupCmd = TEXT("SetupCmd");
LPCTSTR cszDefaultGateway = TEXT("DefaultGateway0");
LPCTSTR cszSubNetMask = TEXT("SubNetMask0");
LPCTSTR cszIPAddress = TEXT("IPAddress0");
LPCTSTR cszDisableDHCP = TEXT("DisableDHCP");
LPCTSTR cszTcpIpDriver = TEXT("DriverName=TCPIP$");
LPCTSTR cszBindings = TEXT("BINDINGS");
LPCTSTR cszHelpFile = TEXT("NCADMIN.HLP");
#ifdef TERMSRV
LPCTSTR cszHelpSession = TEXT("Help");
LPCTSTR cszHelpFileNameKey = TEXT("HelpFileName");
#endif // TERMSRV
LPCTSTR cszWfwDir = TEXT("wfw");
LPCTSTR cszWin95Dir = TEXT("win95");
LPCTSTR cszDebug = TEXT("Debug");
LPCTSTR cszDefaultLocalizer = TEXT("LOCALIZER'S NAME");
LPCTSTR cszFrame = TEXT("FRAME");
LPCTSTR cszTokenRing = TEXT("tokenring");
LPCTSTR cszTokenRingEntry = TEXT("TOKENRING");
//
//  characters
//
LPCTSTR cszEmptyString = TEXT("\0");
LPCTSTR cszCR = TEXT("\r");
LPCTSTR cszCrLf = TEXT("\r\n");
LPCTSTR cszComma = TEXT(",");
LPCTSTR csz1 = TEXT("1");
LPCTSTR csz0 = TEXT("0");
LPCTSTR csz2Spaces = TEXT("  ");
LPCTSTR cszPoundSign = TEXT("#");
//
// file related strings
//
LPCTSTR cszBackslash = TEXT("\\");
LPCTSTR cszWildcardFile = TEXT("\\*.*");
LPCTSTR cszWildcard = TEXT("*.*");
LPCTSTR cszAColon = TEXT("A:");
LPCTSTR cszBColon = TEXT("B:");
#ifdef JAPAN
// fixed kkntbug #11940
//    Network client administrator can not make install disks on PC with C drive as FD

LPCTSTR cszLastDrive = TEXT("Z");
LPCTSTR cszColon = TEXT(":");
#endif
LPCTSTR cszDisksSubDir = TEXT("disks\\");
LPCTSTR cszDot = TEXT(".");
LPCTSTR cszDotDot = TEXT("..");
LPCTSTR cszDoubleBackslash = TEXT("\\\\");
LPCTSTR cszADriveRoot = TEXT("A:\\");
LPCTSTR cszBDriveRoot = TEXT("B:\\");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\clcreator\winutils.c ===
/*++

    Copyright (c) 1994  Microsoft Corporation

Module Name:

    WinUtils.C

Abstract:

    Windows utility functions

Author:

    Bob Watson (a-robw)

Revision History:

    24 Jun 94    Written

--*/
//
//  Windows Include Files
//

#include <windows.h>
#include <stdio.h>
#include <malloc.h>
#include <tchar.h>      // unicode macros
#include <stdlib.h>     // string to number conversions
#include <shellapi.h>   // for common about box function
//
//  app include files
//
#include "otnboot.h"
#include "otnbtdlg.h"

BOOL
Dlg_WM_SYSCOMMAND (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    Processes system command (e.g. from system menu) messages sent to
        dialog boxes:
            SC_CLOSE:       closes the application
            SC_MINIMIZE:    saves the dlg caption, set's the window
                            caption to the app name, then minimizes the dlg.
            SC_RESTORE:     resets the dlg caption to the store name and
                            restores the dlg window
            NCDU_ID_ABOUT:  displays the appropriate about box


Arguments:

    Std. Window message args

Return Value:

    TRUE    if message is processed by this routine
    FALSE   if not

--*/
{
    LPTSTR  szWindowName;
    static  TCHAR   szLastDlgTitle[MAX_PATH];

    switch (wParam & 0x0000FFF0) {
        case SC_CLOSE:
            PostMessage (GetParent(hwndDlg), NCDU_SHOW_EXIT_MESSAGE_DLG, 0, 0);
            SetCursor(LoadCursor(NULL, IDC_WAIT));
            return TRUE;   // done

        case SC_MINIMIZE:
            SetSysMenuMinimizeEntryState (hwndDlg, FALSE);   // disable minimize
            // save dialog title for restoration
            GetWindowText (hwndDlg, szLastDlgTitle, MAX_PATH);
            // set title to app name
            szWindowName = (LPTSTR)GlobalAlloc(GPTR, MAX_PATH_BYTES);
            if (szWindowName != NULL) {
#ifdef TERMSRV
                if (_tcschr(GetCommandLine(),TEXT('/')) != NULL )
                {
                    if (LoadString (
                        (HINSTANCE)GetWindowLongPtr(hwndDlg, GWLP_HINSTANCE),
                        WFC_STRING_BASE,
                        szWindowName,
                        MAX_PATH) > 0) {
                        SetWindowText (hwndDlg, szWindowName);
                    }
                }
                else
                {
#endif // TERMSRV
                    if (LoadString (
                        (HINSTANCE)GetWindowLongPtr(hwndDlg, GWLP_HINSTANCE),
                        STRING_BASE,
                        szWindowName,
                        MAX_PATH) > 0) {
                        SetWindowText (hwndDlg, szWindowName);
                }
#ifdef TERMSRV
                }
#endif // TERMSRV
                FREE_IF_ALLOC (szWindowName);
            }
            // minimize window
            ShowWindow (hwndDlg, SW_MINIMIZE);
            return TRUE;

        case SC_RESTORE:
            SetSysMenuMinimizeEntryState (hwndDlg, TRUE);   // enable minimize
            if (szLastDlgTitle[0] != 0) SetWindowText (hwndDlg, szLastDlgTitle);
            szLastDlgTitle[0] = 0;   // clear buffer
            ShowWindow (hwndDlg, SW_RESTORE);
            return ERROR_SUCCESS;

        case NCDU_ID_ABOUT:
            lstrcpy (szLastDlgTitle, GetStringResource (CSZ_ABOUT_TITLE));
            lstrcat (szLastDlgTitle, cszPoundSign);
            ShellAbout (hwndDlg,
                szLastDlgTitle,
                GetStringResource (SZ_APP_TITLE),
                LoadIcon (
                    (HINSTANCE)GetWindowLongPtr(hwndDlg, GWLP_HINSTANCE),
                    MAKEINTRESOURCE (NCDU_APP_ICON)));
            szLastDlgTitle[0] = 0;
            return TRUE;

        default:
            return FALSE;
    }
}

LRESULT
Dlg_WM_MOVE (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    updates the current position of the window, whenever the window
        is moved so the next window (dialog) can be position in the same
        location.

Arguments:

    IN  HWND    hwndDlg
        Handle to dialog window

    IN  WPARAM  wParam
        Not used

    IN  LPARAM  lParam
        Not used

Return Value:

    ERROR_SUCCESS

--*/
{
    RECT    rWnd;
    GetWindowRect(hwndDlg, &rWnd);

    PostMessage (GetParent(hwndDlg), NCDU_UPDATE_WINDOW_POS,
        (WPARAM)rWnd.left, (LPARAM)rWnd.top);

    return (LRESULT)ERROR_SUCCESS;
}

BOOL
Dlg_WM_PAINT (
    IN  HWND    hwndDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
/*++

Routine Description:

    paints app icon in minimized dialog box window.

Arguments:

    Std. Window message arguments

Return Value:

    TRUE if message is processed by this routine
    FALSE if not.

--*/
{
    PAINTSTRUCT     ps;

    if (IsIconic(hwndDlg)) {

        HICON hIcon;

        hIcon =
            LoadIcon(
                (HINSTANCE)GetWindowLongPtr(GetParent(hwndDlg), GWLP_HINSTANCE),
                MAKEINTRESOURCE(NCDU_APP_ICON));

        if( hIcon != NULL ) {

            BOOL bDI;

            BeginPaint (hwndDlg, &ps);
            bDI = DrawIcon (ps.hdc, 0, 0, hIcon);
            EndPaint (hwndDlg, &ps);
            return bDI;
        }
    }

    return FALSE;
}

BOOL
CenterWindow (
   HWND hwndChild,
   HWND hwndParent
)
/*++

Routine Description:

    Centers the child window in the Parent window

Arguments:

   HWND hwndChild,
        handle of child window to center

   HWND hwndParent
        handle of parent window to center child window in

ReturnValue:

    Return value of SetWindowPos

--*/
{
        RECT    rChild, rParent;
        LONG    wChild, hChild, wParent, hParent;
        LONG    wScreen, hScreen, xNew, yNew;
        HDC     hdc;

        // Get the Height and Width of the child window
        GetWindowRect (hwndChild, &rChild);
        wChild = rChild.right - rChild.left;
        hChild = rChild.bottom - rChild.top;

        // Get the Height and Width of the parent window
        GetWindowRect (hwndParent, &rParent);
        wParent = rParent.right - rParent.left;
        hParent = rParent.bottom - rParent.top;

        // Get the display limits
        hdc = GetDC (hwndChild);

        if( hdc != NULL ) {
            wScreen = GetDeviceCaps (hdc, HORZRES);
            hScreen = GetDeviceCaps (hdc, VERTRES);
            ReleaseDC (hwndChild, hdc);

            // Calculate new X position, then adjust for screen
            xNew = rParent.left + ((wParent - wChild) /2);
            if (xNew < 0) {
                    xNew = 0;
            } else if ((xNew+wChild) > wScreen) {
                    xNew = wScreen - wChild;
            }

            // Calculate new Y position, then adjust for screen
            yNew = rParent.top  + ((hParent - hChild) /2);
            if (yNew < 0) {
                    yNew = 0;
            } else if ((yNew+hChild) > hScreen) {
                    yNew = hScreen - hChild;
            }
        }
        else {
            xNew = 0;
            yNew = 0;
        }

        // Set it, and return
        return SetWindowPos (hwndChild, NULL,
                (int)xNew, (int)yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\inc\serverenum.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

    #define API_FUNCTION API_RET_TYPE far pascal

#pragma pack(1)

 struct server_info_1 {
     char	    sv1_name[CNLEN + 1];
     unsigned char   sv1_version_major;		/* Major version # of net   */
     unsigned char   sv1_version_minor;		/* Minor version # of net   */
     unsigned long   sv1_type;	     		/* Server type 		    */
     char far *	    sv1_comment; 		/* Exported server comment  */
 };	 /* server_info_1 */

 struct wksta_info_10 {
    char far *	    wki10_computername;
    char far *	    wki10_username;
    char far *	    wki10_langroup;
    unsigned char   wki10_ver_major;
    unsigned char   wki10_ver_minor;
    char far *	    wki10_logon_domain;
    char far *	    wki10_oth_domains;
};	/* wksta_info_10 */

#pragma pack()


 extern API_FUNCTION
   NetServerEnum2 ( const char far *     pszServer,
                    short                sLevel,
                    char far *           pbBuffer,
                    unsigned short       cbBuffer,
                    unsigned short far * pcEntriesRead,
                    unsigned short far * pcTotalAvail,
                    unsigned long        flServerType,
                    char far *           pszDomain );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\win32com.inc ===
!IF 0

Copyright (c) 1989-98  Microsoft Corporation

Module Name:

    common.inc - Win32 specific (TShare Client) build definitions

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Madan Appiah - Sep. 5th 1997

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF


SDK_LIB_PATH = $(BASEDIR)\public\sdk\lib\*
CRT_LIB_PATH = $(BASEDIR)\public\sdk\lib\*
SDK_INC_PATH = $(BASEDIR)\public\sdk\inc
CRT_INC_PATH = $(SDK_INC_PATH)\crt

#
# Set common options
#

#
# Use Multi-threaded static library by default.
#
USE_LIBCMT = 1

#
# Insure that we will work on Win 95
#
#CHICAGO_PROJECT = 1
#CHICAGO_PRODUCT = 1

CBSTRING = -cbstring
P5_FDIV_FIX = /QIfdiv-
P5_0F_FIX = /QIf
C_INCREMENTAL_FLAG = /Gi- /Gm-
EH_FLAGS = /GX- /GR-
FRAME_PTR_ON = /Oy
FRAME_PTR_OFF = /Oy-
CL_TARGET_SPEC = /Yl$(TARGETNAME)

#
# Library files, referenced by <component>.inc file, eg client.inc
#
CLIENT_LIB_DLL = \
   $(SDK_LIB_PATH)\kernel32.lib \
   $(SDK_LIB_PATH)\advapi32.lib \
   $(SDK_LIB_PATH)\user32.lib   \
   $(SDK_LIB_PATH)\gdi32.lib    \
   $(SDK_LIB_PATH)\imagehlp.lib

CLIENT_LIB_EXE = \
    $(SDK_LIB_PATH)\wsock32.lib \
    $(SDK_LIB_PATH)\shell32.lib \
#    $(SDK_LIB_PATH)\netapi32.lib

#
# Additional compiler flags
#
WIN32_DEFINE = -DWIN32=200 -D_CHICAGO_=200 -D_WIN32_WINDOWS=0x040a -D_WIN32_WINNT=0x0400
CLIENT_SECURITY = -DISSP_LEVEL=32
C_DEFINES  = $(C_DEFINES) -DWIN32 -D_WIN32 -DWIN_95_32_BIT
C_DEFS_UNICODE  = -DUNICODE -D_UNICODE

!IF "$(_PERF)" == "1"
C_DEFINES = $(C_DEFINES) -DPERF
!ENDIF

#
# Additional linker flags
#

#LINKER_FLAGS = $(LINKER_FLAGS) -map

#
# File name prefix for 32-bit
#
PLATFORM_PREFIX = n

C_DEFINES=$(C_DEFINES) -DOS_WIN32 -DOS_WINNT -DSECURITY_WIN32

#
# Setup MSC_OPTIMIZATION for debug and retail
#
!if "$(FREEBUILD)" == "0"
MSC_OPTIMIZATION=/Odi
!else
MSC_OPTIMIZATION=/Oxs
!endif

386_WARNING_LEVEL=/W3

!ifdef ICACAP_BUILD

MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /Gh
PERFLIBS=$(SDK_LIB_PATH)\icap.lib
LINKLIBS=$(LINKLIBS) $(PERFLIBS)

!endif // ICACAP_BUILD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\clcreator\putingrp\putingrp.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    PutInGrp.C

Abstract:

    Reads the command line to find a file spec (or wildcard spec) and a
    program manager group name and then for each file in the current dir
    that matches the file spec, creates a program item in the specified
    group. If an error occurs and a program item cannot be created, then
    the app returns non-zero (DOS ERRORLEVEL 1) otherwise 0 is returned if
    all matching files are put into the group. The icon name used for the
    program item is the filename (minus extension) of the file found.

Author:

    Bob Watson (a-robw)

    
Revision History:

    12 Jun 1994     Created

--*/
//
//  System include files    
//
#include <windows.h>        // windows definitions
#include <tchar.h>          // unicode data and function definitions

#include <stdio.h>          // printf's etc.       
#include <stdlib.h>
#include <ddeml.h>          // DDEML interface definitions

#include "putingrp.h"       // application definitions

//
//  DDEML constants that depend on  UNICODE/ANSI data format
//
#if _UNICODE 
#define STRING_CODEPAGE CP_WINUNICODE
#define APP_TEXT_FORMAT CF_UNICODETEXT
#else
#define STRING_CODEPAGE CP_WINANSI
#define APP_TEXT_FORMAT CF_TEXT
#endif
//
//      other application constants
//
//  time to wait for a dde command to complete (10 sec.)
//
#define APP_DDE_TIMEOUT         10000
//
//  Small buffer size used for general purpose temporary buffers
//
#define SMALL_BUFFER_SIZE       1024
//
//  Large buffer size used for general purpose temporary buffers
//
#define BIG_BUFFER_SIZE         (16 * SMALL_BUFFER_SIZE)
//
//  number of times to retry a DDE command before giving up
//
#define APP_RETRY_COUNT         5
//
//  number of buffers in GetStringResource function. These buffers
//  are used sequentially to allow up to this many calls before a 
//  buffer is overwritten.
//
#define RES_STRING_BUFFER_COUNT 4
//
//  time delay between DDE EXECUTE calls
//      500 = .5 sec
//
#define PAUSE_TIME              500

LPCTSTR
GetFileName (
    IN  LPCTSTR  szFileName
)
/*++

Routine Description:
    
    returns a buffer that contains the filename without the
        period or extension. The filename returned has the
        first character upper-cased and all other characters are
        kept the same.

Arguments:

    IN  LPCTSTR szFileName
        pointer to a filename string. This is assumed to be just
        a filename with no path information.

Return Value:

    pointer to a buffer containing the filename.    

--*/
{
    static  TCHAR   szReturnBuffer[MAX_PATH];   // buffer for result
    LPCTSTR szSrc;                  // pointer into source string
    LPTSTR  szDest;                 // pointer into destination string
    BOOL    bFirst = TRUE;          // used to tell when 1st char has been UC'd

    szSrc = szFileName;
    szDest = &szReturnBuffer[0];
    *szDest = 0;    // clear old contents
    // go through source until end or "." whichever comes first.
    while ((*szSrc != TEXT('.')) && (*szSrc != 0)) {
        *szDest++ = *szSrc++;
        // uppercase first letter
        if (bFirst) {
            *szDest = 0;
            _tcsupr (&szReturnBuffer[0]);
            bFirst = FALSE;
        }
    }
    *szDest = 0;
    return (LPCTSTR)szReturnBuffer;
}

LPCTSTR
GetStringResource (
    IN  UINT    nId
)
/*++

Routine Description:
    
    Used to load a string resource for this app so it can be used as a
        string constant. NOTE the resulting string should be copied into
        a local buffer since the contents of the buffer returned by this
        routine may change in subsequent calls.

Arguments:

    IN  UINT    nId
        Resource ID to return.

Return Value:

    pointer to string referenced by Resource ID value.    

--*/
{
    static  TCHAR   szStringBuffer[RES_STRING_BUFFER_COUNT][SMALL_BUFFER_SIZE];
    static  DWORD   dwBufferNdx;    // current buffer in use    
    LPTSTR  szBuffer;               // pointer to current buffer
    int     nLength;                // length of string found

    // select new buffer
    dwBufferNdx++;                              // go to next index
    dwBufferNdx %= RES_STRING_BUFFER_COUNT;     // keep within bounds
    szBuffer = &szStringBuffer[dwBufferNdx][0]; // set pointer

    // get buffer
    nLength = LoadString (
        (HINSTANCE)GetModuleHandle(NULL),
        nId,
        szBuffer,
        SMALL_BUFFER_SIZE);

    // return pointer to buffer in use
    return (LPCTSTR)szBuffer; 
}

VOID
DisplayUsage (
    VOID
)
{
    UINT    nString;

    for (nString = APP_USAGE_START; nString <= APP_USAGE_END; nString++){
        _tprintf (GetStringResource(nString));
    }
}

BOOL
IsProgmanWindow (
    IN  HWND    hWnd,
    IN  LPARAM  lParam
)
/*++

Routine Description:
    
    Function called by EnumWindows function to tell if the
        Program Manger window has been found. A match is determined
        by comparing the window caption (so it's not fool proof).
        

Arguments:

    IN  HWND    hWnd
        handle of window to test

    IN  LPARAM  lParam
        address of window handle variable to be loaded when program
        manager window is found. set to NULL if this window is NOT
        the Program Manager

Return Value:

    TRUE if this is NOT the Program Manager window
    FALSE if this IS the Program Manager window
        (this is to accomodate the EnumWindows logic)

--*/
{
    static  TCHAR   szWindowName[MAX_PATH]; // buffer to write this window's title
    DWORD   dwProgmanTitleLen;              // length of "Program Manager"
    LPTSTR  szProgmanTitle;                 // pointer to title string
    HWND    *hwndReturn;                    // return window handle pointer

    hwndReturn = (HWND *)lParam;            // cast LPARAM to HWND *
    if (hwndReturn != NULL) {
        *hwndReturn = NULL;                 // initialize to NULL handle
    }

    if (IsWindow (hWnd)) {
        // only check windows
        //
        // get title string to match against
        szProgmanTitle = (LPTSTR)GetStringResource (APP_PROGMAN_TITLE);
        dwProgmanTitleLen = lstrlen(szProgmanTitle);
        //
        // get title of this window
        GetWindowText (hWnd, &szWindowName[0], MAX_PATH);

        // check the length
        if ((DWORD)lstrlen(&szWindowName[0]) < dwProgmanTitleLen) {
            // this is too short to match
            return TRUE; // not Program Manager, get next window
        } else {
            // make window name same length as program manager string
            szWindowName[dwProgmanTitleLen] = 0;
            // compare window name to match title string
            if (lstrcmpi(&szWindowName[0], szProgmanTitle) == 0) {
                // it's a match
                if (hwndReturn != NULL) {
                    *hwndReturn = hWnd;
                }
                return FALSE;   // found it so leave
            } else {
                return TRUE;    // not this one, so keep going
            }
        }
    } else {
        return TRUE;    // not this one, so keep going
    }
}

BOOL
RestoreProgmanWindow (
    VOID
)
/*++

Routine Description:
    
    Activates and Restores the Program Manager window and makes it the
        foreground app.

Arguments:

    None    

Return Value:

    TRUE if window restored
    FALSE if window not found

--*/
{
    HWND    hwndProgman;

    // find progman and restore it

    EnumWindows (IsProgmanWindow, (LPARAM)&hwndProgman);

    if (IsWindow (hwndProgman)) {
        // if iconic, then restore
        if (IsIconic(hwndProgman)) {
            ShowWindow (hwndProgman, SW_RESTORE);
        }
        // make the foreground app.
        SetForegroundWindow (hwndProgman);
        return TRUE;
    } else {
        return FALSE;
    }
}

HDDEDATA CALLBACK
DdeCallback (
    IN  UINT        wType,
    IN  UINT        wFmt,
    IN  HCONV       hConv,
    IN  HSZ         hsz1,
    IN  HSZ         hsz2,
    IN  HDDEDATA    hData,
    IN  DWORD       lData1,
    IN  DWORD       lData2
)
/*++

Routine Description:
    
    Generic Callback function required by DDEML calls    

Arguments:

    See WinHelp    

Return Value:

    See WinHelp    

--*/
{
    switch (wType) {
        case XTYP_REGISTER:
        case XTYP_UNREGISTER:
            return (HDDEDATA)NULL;

        case XTYP_ADVDATA:
            // received when new data is available
            return (HDDEDATA)DDE_FACK;

        case XTYP_XACT_COMPLETE:
            // received when an async transaction is complete
            return (HDDEDATA)NULL;

        case XTYP_DISCONNECT:
            // connection termination has been requested
            return (HDDEDATA)NULL;

        default:
            return (HDDEDATA)NULL;
    }
}

HCONV
ConnectToProgman (
    IN  DWORD   dwInst
)
/*++

Routine Description:
    
    Establishes a DDE connection to the program manager's DDE
        server.

Arguments:

    IN  DWORD   dwInst
        DDEML Instance as returned by DdeInitialize call

Return Value:

    Handle to conversation if successful,
    0 if not    

--*/
{
    HSZ     hszProgman1;
    HSZ     hszProgman2;
    HCONV   hConversation;
    CONVCONTEXT ccConversation;

    // init conversation context buffer
    ccConversation.cb = sizeof(CONVCONTEXT);
    ccConversation.wFlags = 0;
    ccConversation.wCountryID = 0;
    ccConversation.iCodePage = 0;
    ccConversation.dwLangID = 0L;
    ccConversation.dwSecurity = 0L;
    ccConversation.qos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    ccConversation.qos.ImpersonationLevel = SecurityImpersonation;
    ccConversation.qos.ContextTrackingMode = SECURITY_STATIC_TRACKING;
    ccConversation.qos.EffectiveOnly = TRUE;
    
    // get server name
    hszProgman1 = DdeCreateStringHandle (dwInst,
        (LPTSTR)GetStringResource (APP_SERVER),
        STRING_CODEPAGE);

    if (hszProgman1 != 0) {
        // get topic name
        hszProgman2 = DdeCreateStringHandle (dwInst,
            (LPTSTR)GetStringResource (APP_TOPIC),
            STRING_CODEPAGE);

        if (hszProgman2 != 0) {
            // connect to server
            hConversation = DdeConnect (
                dwInst,
                hszProgman1,
                hszProgman2,
                &ccConversation);

            // free string handle
            DdeFreeStringHandle (dwInst, hszProgman2);
        }
        // free string handle
        DdeFreeStringHandle (dwInst, hszProgman1);
    }
    
    return hConversation;        // return handle
}

BOOL
CreateAndShowGroup (
    IN  DWORD   dwInst,
    IN  HCONV   hConversation,
    IN  LPCTSTR szGroupName
)
/*++

Routine Description:
    
    creates and activates the program manager group specified
        in the argument  list

Arguments:

    IN  DWORD   dwInst
        Instance ID returned from DdeInitialize

    IN  HCONV   hConversation
        Handle to the current DDE conversation

    IN  LPCTSTR szGroupName
        Pointer to string containing name of program manager group to
        create and/or activate

Return Value:
    
    TRUE if operation succeeded
    FALSE if not

--*/
{
    LPTSTR  szCmdBuffer;        // DDE command string to send
    LPTSTR  szCmdFmt;           // DDE command format for sprintf
    DWORD   dwCmdLength;        // size of command string
    BOOL    bResult;            // result of function calls
    DWORD   dwTransactionResult; // result of Command 

    // allocate temporary memory buffers
    szCmdFmt = GlobalAlloc (GPTR, (SMALL_BUFFER_SIZE * sizeof(TCHAR)));
    szCmdBuffer = GlobalAlloc (GPTR, (SMALL_BUFFER_SIZE * sizeof(TCHAR)));

    if ((szCmdBuffer != NULL) &&
        (szCmdFmt != NULL)) {

        // get command format string
        lstrcpy (szCmdFmt, GetStringResource(APP_CREATE_AND_SHOW_FMT));

        // format command to include desired group name
        dwCmdLength = _stprintf (szCmdBuffer, szCmdFmt, szGroupName) + 1;
        dwCmdLength *= sizeof(TCHAR) ;

        // create group or activate group if it already exists
        // send command to server
        Sleep (PAUSE_TIME);
        bResult = DdeClientTransaction (
            (LPBYTE)szCmdBuffer,
            dwCmdLength,
            hConversation,
            0L,
            APP_TEXT_FORMAT,
            XTYP_EXECUTE,
            APP_DDE_TIMEOUT,
            &dwTransactionResult);

#if DEBUG_OUT
        if (!bResult) {
            _tprintf (GetStringResource (APP_DDE_EXECUTE_ERROR_FMT),
                DdeGetLastError(dwInst),
                szCmdBuffer);
        }
#endif

        // now activate the group
        // get the command format string
        lstrcpy (szCmdFmt, GetStringResource(APP_RESTORE_GROUP_FMT));

        // create the command that includes the group name
        dwCmdLength = _stprintf (szCmdBuffer, szCmdFmt, szGroupName) + 1;
        dwCmdLength *= sizeof(TCHAR);

        // send command to server
        Sleep (PAUSE_TIME);
        bResult = DdeClientTransaction (
            (LPBYTE)szCmdBuffer,
            dwCmdLength,
            hConversation,
            0L,
            APP_TEXT_FORMAT,
            XTYP_EXECUTE,
            APP_DDE_TIMEOUT,
            &dwTransactionResult);

#if DEBUG_OUT
        if (!bResult) {
            _tprintf (GetStringResource (APP_DDE_EXECUTE_ERROR_FMT),
                DdeGetLastError(dwInst),
                szCmdBuffer);
        }
#endif

        // free global memory buffers
        GlobalFree (szCmdBuffer);
        GlobalFree (szCmdFmt);
        return bResult;
    } else {
        // unable to allocate memory buffers so return error
        SetLastError (ERROR_OUTOFMEMORY);
        return FALSE;
    }
}

BOOL
LoadFilesToGroup (
    IN  DWORD   dwInst,
    IN  HCONV   hConversation,
    IN  LPCTSTR szFileSpec,
    IN  LPCTSTR szGroupName
)
/*++

Routine Description:
    
    Searches the current directory for the file(s) that match the
        fileSpec argument and creates program items the program
        manager group specified by szGroupName.

Arguments:

    IN  DWORD   dwInst
        DDEML instance handle returned by DdeInitialize

    IN  HCONV   hConversation
        Handle to current conversation with DDE Server

    IN  LPCTSTR szFileSpec
        file spec to look up for program items

    IN  LPCTSTR szGroupName
        program manager group to add items to

Return Value:

    TRUE if all items loaded successfully
    FALSE of one or more items did not get installed in Program Manager

--*/
{
    WIN32_FIND_DATA fdSearchData;   // search data struct for file search
    HANDLE          hFileSearch;    // file search handle
    BOOL            bSearchResult;  // results of current file lookup
    BOOL            bResult;        // function return
    BOOL            bReturn = TRUE; // value returned to calling fn.
    LPTSTR          szCmdBuffer;    // buffer for one command    
    LPTSTR          szCmdFmt;       // command format buffer for sprintf
    DWORD           dwCmdLength;    // length of command buffer
    DWORD           dwBufferUsed;   // chars in DdeCmd that have been used
    DWORD           dwTransaction;  // returned by DdeClientTransaction
    DWORD           dwTransactionResult;    // result code

    // Allocate global memory
    szCmdBuffer = GlobalAlloc (GPTR, (SMALL_BUFFER_SIZE * sizeof(TCHAR)));
    szCmdFmt = GlobalAlloc (GPTR, (SMALL_BUFFER_SIZE * sizeof(TCHAR)));

    if ((szCmdBuffer != NULL)  &&
        (szCmdFmt != NULL)) {
        // get single entry command format for sprintf
        lstrcpy (szCmdFmt, GetStringResource(APP_ADD_PROGRAM_FMT));

        // start file search
        hFileSearch = FindFirstFile (szFileSpec, &fdSearchData);

        if (hFileSearch != INVALID_HANDLE_VALUE) {
            // file search initialized OK so start processing files
            dwBufferUsed = 0;
            bSearchResult = TRUE;
            while (bSearchResult) {
                // make sure it's a real file and not a dir or a 
                // temporary file

                if (!((fdSearchData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ||
                      (fdSearchData.dwFileAttributes & FILE_ATTRIBUTE_TEMPORARY))) {

                    // make a command for this file
                    dwCmdLength = _stprintf (szCmdBuffer, szCmdFmt,
                        fdSearchData.cFileName,
                        GetFileName(fdSearchData.cFileName)) + 1;
                    dwCmdLength *= sizeof(TCHAR);
                    dwTransactionResult = 0;
                    Sleep (PAUSE_TIME);
                    dwTransaction = DdeClientTransaction (
                        (LPBYTE)szCmdBuffer,
                        dwCmdLength,
                        hConversation,
                        0L,
                        APP_TEXT_FORMAT,
                        XTYP_EXECUTE,
                        APP_DDE_TIMEOUT,
                        &dwTransactionResult);

                    if (dwTransaction > 0) {
                        _tprintf (GetStringResource (APP_ADD_SUCCESS_FMT),
                            fdSearchData.cFileName, szGroupName);
                        bResult = TRUE;
                    } else {
                        _tprintf (GetStringResource (APP_ADD_ERROR_FMT),
                            fdSearchData.cFileName, szGroupName);
                        bResult = FALSE;
                    }
                    if (!bResult) {
#if DEBUG_OUT
                        _tprintf (GetStringResource (APP_DDE_EXECUTE_ERROR_FMT),
                            DdeGetLastError(dwInst),
                            szDdeCmd);
#endif
                        // at least one entry didn't work so set return value
                        bReturn = FALSE;
                    }
                }
                // get next matching file
                bSearchResult = FindNextFile (hFileSearch, &fdSearchData);
            }
        }
        // free global memory
        GlobalFree (szCmdBuffer);
        GlobalFree (szCmdFmt);
        return bReturn;
    } else {
        SetLastError (ERROR_OUTOFMEMORY);
        return FALSE;
    }
}

BOOL
SaveNewGroup (
    IN  DWORD   dwInst,
    IN  HCONV   hConversation,
    IN  LPCTSTR szGroupName
)
/*++

Routine Description:
    
    Sends the Reload command to save and reload the new group. This will
        save the information.

Arguments:

    IN  DWORD   dwInst
        DDEML instance handle returned by DdeInitialize

    IN  HCONV   hConversation
        Handle to current conversation with DDE Server

    IN  LPCTSTR szGroupName
        program manager group to add items to

Return Value:

    TRUE if successful
    FALSE if not

--*/
{
    LPTSTR  szCmdBuffer;        // DDE command string to send
    LPTSTR  szCmdFmt;           // DDE command format for sprintf
    DWORD   dwCmdLength;        // size of command string
    BOOL    bResult;            // result of function calls
    DWORD   dwTransactionResult; // result of Command 

    // allocate temporary memory buffers
    szCmdFmt = GlobalAlloc (GPTR, (SMALL_BUFFER_SIZE * sizeof(TCHAR)));
    szCmdBuffer = GlobalAlloc (GPTR, (SMALL_BUFFER_SIZE * sizeof(TCHAR)));

    if ((szCmdBuffer != NULL) &&
        (szCmdFmt != NULL)) {

        // get command format string
        lstrcpy (szCmdFmt, GetStringResource(APP_RELOAD_GROUP_FMT));

        // format command to include desired group name
        dwCmdLength = _stprintf (szCmdBuffer, szCmdFmt, szGroupName) + 1;
        dwCmdLength *= sizeof(TCHAR);

        // create group or activate group if it already exists
        // send command to server
        Sleep (PAUSE_TIME);
        bResult = DdeClientTransaction (
            (LPBYTE)szCmdBuffer,
            dwCmdLength,
            hConversation,
            0L,
            APP_TEXT_FORMAT,
            XTYP_EXECUTE,
            APP_DDE_TIMEOUT,
            &dwTransactionResult);

        return bResult;
    } else {
        SetLastError (ERROR_OUTOFMEMORY);
        return FALSE;
    }
}

int
__cdecl main (
    int     argc,
    char    **argv
)
/*++

Routine Description:
    
    Main entry point for command line    

Arguments:

    IN  int argc
        count of arguments passed in from command line

    IN  char *argv[]
        array of pointers to each command line argument
            argv[0] = this program'e .exe path
            argv[1] = file(s) to put in group
            argv[2] = group to create/load

Return Value:

    0 if all files matching the path are successfully loaded into progman
    non-zero if one or more files did not have a progman item created

--*/
{
    DWORD   dwInstId = 0;   // DDEML Instance
    UINT    nReturn;        // return value
    BOOL    bResult;        // function return value
    HCONV   hConversation;  // handle to DDE conversation
    LPTSTR  szFiles;        // file path read from command line
    LPTSTR  szGroup;        // group name read from command line

    if (argc < 3) {
        // check for correct command line arg count
        DisplayUsage();
        return ERROR_BAD_COMMAND;
    }
    
    // allocate buffers for command line arguments
    szFiles = GlobalAlloc (GPTR, (strlen(argv[1]) + 1) * sizeof(TCHAR));
    szGroup = GlobalAlloc (GPTR, (strlen(argv[2]) + 1) * sizeof(TCHAR));

    if ((szFiles == NULL) || (szGroup == NULL)) {
        return ERROR_OUTOFMEMORY;
    }

    // read in command line arguments using appropriate function
#if _UNICODE
    mbstowcs (szFiles, argv[1], lstrlenA(argv[1]));
    mbstowcs (szGroup, argv[2], lstrlenA(argv[2]));
#else
    lstrcpyA (szFiles, argv[1]);
    lstrcpyA (szGroup, argv[2]);
#endif

    // make Program Manager window the foreground app and restore it's size
    RestoreProgmanWindow ();

    // begin DDEML session
    nReturn = DdeInitialize (&dwInstId,
        (PFNCALLBACK)DdeCallback,
        APPCMD_CLIENTONLY,
        0L);

    if (nReturn == DMLERR_NO_ERROR) {
        // connect to Program Manager DDE server
        hConversation = ConnectToProgman (dwInstId);

        if (hConversation != 0) {
            bResult = DdeEnableCallback (dwInstId, hConversation,
                EC_ENABLEALL);

            // create program group
            if (CreateAndShowGroup (dwInstId, hConversation, szGroup)) {
                // load selected files into group
                if (!LoadFilesToGroup (dwInstId, hConversation, szFiles, szGroup)) {
                    // 1 or more files did not get a program item
                    nReturn = ERROR_CAN_NOT_COMPLETE;
                } else {
                    SaveNewGroup (dwInstId, hConversation, szGroup);
                    // all files were loaded into program manager successfully
                    nReturn = ERROR_SUCCESS;
                }
                // that's it so close conversation handle
                DdeDisconnect (hConversation);
            } else {
                // unable to create program group
                nReturn = ERROR_CAN_NOT_COMPLETE;
            }
        } else {
            // unablet to establish conversation
            nReturn = ERROR_CAN_NOT_COMPLETE;
        }

        // terminate DDEML session    
        if (!DdeUninitialize (dwInstId)) {
            nReturn = ERROR_CAN_NOT_COMPLETE;
        }
    }

    // free global buffers
    GlobalFree (szFiles);
    GlobalFree (szGroup);

    // return value to command shell 
    return nReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\wincecom.inc ===
!IF 0

Copyright (c) 1989-98  Microsoft Corporation

Module Name:

    wincecom.inc - Win32 specific (TShare Client) build definitions

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Adam Overton- Oct. 24th 1997

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

!if ("$(WINCEDEBUG)" == "debug")
FREEBUILD=0
!else
FREEBUILD=1
!endif

BUILDINGFORCE=1

CDEFINES = $(CDEFINES) -DWINCE_GLOBAL_ALLOC_DEFINED

!if ("$(_TRACKER_ENABLE_)" != "")
CDEFINES = $(CDEFINES) -D_TRACKER_ENABLE_=$(_TRACKER_ENABLE_)
!endif

#
# Set common options
#


WINCEATL30=1
OS_WINCE=1

#
# Library files, referenced by <component>.inc file, eg client.inc
#
TARGETLIBS= $(TARGETLIBS) \
    $(SDK_LIB_PATH)\coredll.lib \
    ..\..\LIB\WINCE\$(_CPUINDPATH)\wsasync.lib \
    $(SDK_LIB_PATH)\winsock.lib

LIBPATH = $(LIBPATH);\
    $(SDKROOT)\public\common\sdk\lib\$(_TGTCPU)\$(WINCEDEBUG)\

#CLIENT_LIB_DLL = \
#   $(SDK_LIB_PATH)\kernel32.lib \
#   $(SDK_LIB_PATH)\advapi32.lib \
#   $(SDK_LIB_PATH)\user32.lib   \
#   $(SDK_LIB_PATH)\gdi32.lib    \
#   $(SDK_LIB_PATH)\imagehlp.lib

#CLIENT_LIB_EXE = \
#    $(SDK_LIB_PATH)\winsock.lib \
#    $(SDK_LIB_PATH)\shell32.lib

#
# Additional compiler flags
#
WIN32_DEFINE = -DWIN32=200 -D_CHICAGO_=200 -D_WIN32_WINDOWS=0x040a -D_WIN32_WINNT=0x0400
CLIENT_SECURITY = -DISSP_LEVEL=32
C_DEFINES  = $(C_DEFINES) -DWIN32 -D_WIN32 -DWIN_95_32_BIT
#C_DEFINES=$(C_DEFINES) -DUSE_LICENSE -DENFORCE_LICENSE
C_DEFS_UNICODE  = -DUNICODE -D_UNICODE

# DC_NO_UNALIGNED should be set for any processor which does not allow
# non-aligned memory access
!IF "$(_TGTCPUFAMILY)" != "x86"
C_DEFINES = $(C_DEFINES) -DDC_NO_UNALIGNED
!ENDIF

!IF "$(_PERF)" == "1"
C_DEFINES = $(C_DEFINES) -DPERF
!ENDIF

#
# Additional linker flags
#

#LINKER_FLAGS = $(LINKER_FLAGS) -map

#
# File name prefix for 32-bit
#
PLATFORM_PREFIX = n

C_DEFINES=$(C_DEFINES) -DOS_WIN32 -DSECURITY_WIN32 -DOS_WINCE

#
# RC flags
#
RDEFINES=$(RDEFINES) -DOS_WINCE
!if "$(FREEBUILD)" == "0"
RDEFINES=$(RDEFINES) -DDC_DEBUG
!endif

#
# Setup MSC_OPTIMIZATION for debug and retail
#
#!if "$(FREEBUILD)" == "0"
#MSC_OPTIMIZATION=/Od
#!else
#MSC_OPTIMIZATION=/Oxs
#!endif

#386_WARNING_LEVEL=/W3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\common.inc ===
!IF 0

Copyright (c) 1989-98  Microsoft Corporation

Module Name:

    common.inc - Generic (TShare Client) build definitions

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Madan Appiah - Sep. 5th 1997

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

#
# Disable perf by default.
# Set this to 1 to enable perf.
#
BUILD_PRF = 0

#
# Defining this allows windows.h to include other headers
#
NOT_LEAN_AND_MEAN = 1

UMTYPE = windows

#
# Additional compiler flags
#
!  if defined(USE_UNICODE)
C_DEFINES = $(C_DEFINES) -DUNICODE -D_UNICODE
!  endif

!if !$(FREEBUILD)
C_DEFINES = $(C_DEFINES) -D_DEBUG -DDEBUG
!endif

#
# Prevent bldnt pulling in various libraries
#
LIBC_LIB =
NO_NTDLL = 1

#
# include files.
#
INCLUDES= \
   ..; \
   $(TERMSRV_ROOT)\inc; \
   $(TERMSRV_ROOT)\common\inc; \
   $(TERMSRV_ROOT)\common\license\inc; \
   $(TERMSRV_ROOT)\client\inc; \
!ifdef WIN16_BUILD
   $(PUBLIC_DS_INC_PATH)\crypto
!else
   $(DS_INC_PATH)\crypto
!endif

#
# Common compiler flags
#
C_DEFINES = $(C_DEFINES) -DSTRICT $(CLIENT_SECURITY)

MSC_WARNING_LEVEL= $(C_WARNINGS)
# Use /WX to change warnings into errors

!if "$(FREEBUILD)" == "1"
CLIENT_TRC_LIB=
!if "$(BUILD_PRF)"=="1"
C_DEFINES=$(C_DEFINES) -DTRC_CL=5
!else
C_DEFINES=$(C_DEFINES) -DTRC_CL=5
!endif
!else
DEBUG_DEFINE=DC_DEBUG
C_DEFINES=$(C_DEFINES) -DTRC_CL=0 -DTRC_CP -D$(DEBUG_DEFINE)
!endif

!if "$(BUILD_HIPROF)"=="1"
C_DEFINES=$(C_DEFINES) -DHIPROF
!endif

# DC_NO_UNALIGNED should be set for any processor which does not allow
# non-aligned memory access
!IF "$(PROCESSOR_ARCHITECTURE)" != "x86"
C_DEFINES = $(C_DEFINES) -DDC_NO_UNALIGNED
!ENDIF

!if "$(BUILD_HIPROF)"=="1"
LINKER_FLAGS = $(LINKER_FLAGS) -FIXED:NO
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\clcreator\putingrp\putingrp.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    PutInGrp.H

Abstract:

    Application constants used by PutInGrp.C

Author:

    Bob Watson (a-robw)

    
Revision History:

    12 Jun 1994     Created

--*/
//
// Resource File Constants:
//
#define APP_ICON    0x0800
//
#define STRING_BASE 0x1000

#define     APP_SERVER              (STRING_BASE + 1)
#define     APP_TOPIC               (STRING_BASE + 2)
#define     APP_PROGMAN_TITLE       (STRING_BASE + 3)

#define FORMAT_BASE 0x2000

#define     APP_CREATE_AND_SHOW_FMT (FORMAT_BASE + 1)
#define     APP_RESTORE_GROUP_FMT   (FORMAT_BASE + 2)
#define     APP_ADD_PROGRAM_FMT     (FORMAT_BASE + 3)
#define     APP_RELOAD_GROUP_FMT    (FORMAT_BASE + 4)
#define     APP_ADD_SUCCESS_FMT     (FORMAT_BASE + 5)
#define     APP_ADD_ERROR_FMT       (FORMAT_BASE + 6)
#define     APP_DDE_EXECUTE_ERROR_FMT (FORMAT_BASE + 7)
#define     APP_CB_WAITING          (FORMAT_BASE + 8)

#define     APP_USAGE_START         0x3000
#define     APP_USAGE_0             (APP_USAGE_START + 0)
#define     APP_USAGE_1             (APP_USAGE_START + 1)
#define     APP_USAGE_2             (APP_USAGE_START + 2)
#define     APP_USAGE_3             (APP_USAGE_START + 3)
#define     APP_USAGE_4             (APP_USAGE_START + 4)
#define     APP_USAGE_5             (APP_USAGE_START + 5)
#define     APP_USAGE_6             (APP_USAGE_START + 6)
#define     APP_USAGE_7             (APP_USAGE_START + 7)
#define     APP_USAGE_8             (APP_USAGE_START + 8)
#define     APP_USAGE_END           APP_USAGE_8

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\newcommon.inc ===
!IF 0

Copyright (c) 1989-98  Microsoft Corporation

Module Name:

    common.inc - Generic (TShare Client) build definitions

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Madan Appiah - Sep. 5th 1997

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

#
# Disable perf by default.
# Set this to 1 to enable perf.
#
BUILD_PRF = 0

#
# Defining this allows windows.h to include other headers
#
NOT_LEAN_AND_MEAN = 1

UMTYPE = windows

#
# Additional compiler flags
#
!  if defined(USE_UNICODE)
C_DEFINES = $(C_DEFINES) -DUNICODE -D_UNICODE
!  endif

!if !$(FREEBUILD)
C_DEFINES = $(C_DEFINES) -D_DEBUG -DDEBUG
!endif

#
# Prevent bldnt pulling in various libraries
#
LIBC_LIB =
NO_NTDLL = 1

#
# include files.
#
INCLUDES= \
   ..; \
   $(TERMSRV_ROOT)\inc; \
   $(TERMSRV_ROOT)\common\inc; \
   $(TERMSRV_ROOT)\common\license\inc; \
   $(TERMSRV_ROOT)\newclient\inc; \
!ifdef WIN16_BUILD
   $(PUBLIC_DS_INC_PATH)\crypto
!else
   $(DS_INC_PATH)\crypto
!endif

#
# Common compiler flags
#
C_DEFINES = $(C_DEFINES) -DSTRICT $(CLIENT_SECURITY)

MSC_WARNING_LEVEL= $(C_WARNINGS)
# Use /WX to change warnings into errors

!if "$(FREEBUILD)" == "1"
CLIENT_TRC_LIB=
!if "$(BUILD_PRF)"=="1"
C_DEFINES=$(C_DEFINES) -DTRC_CL=5
!else
C_DEFINES=$(C_DEFINES) -DTRC_CL=5
!endif
!else
DEBUG_DEFINE=DC_DEBUG
C_DEFINES=$(C_DEFINES) -DTRC_CL=0 -DTRC_CP -D$(DEBUG_DEFINE)
!endif

!if "$(BUILD_HIPROF)"=="1"
C_DEFINES=$(C_DEFINES) -DHIPROF
!endif

# DC_NO_UNALIGNED should be set for any processor which does not allow
# non-aligned memory access
!IF "$(PROCESSOR_ARCHITECTURE)" != "x86"
C_DEFINES = $(C_DEFINES) -DDC_NO_UNALIGNED
!ENDIF

!if "$(BUILD_HIPROF)"=="1"
LINKER_FLAGS = $(LINKER_FLAGS) -FIXED:NO
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\asn1\asnobjct.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    asnobjct

Abstract:

    This module provides the methods of the top generic object for the ASN.1
    library.

Author:

    Doug Barlow (dbarlow) 10/8/1995

Environment:

    Win32

Notes:

    This module assumes that the width of an unsigned long int is 32 bits.

--*/

#include <windows.h>
#include "asnPriv.h"


//
//==============================================================================
//
//  CAsnObject
//

IMPLEMENT_NEW(CAsnObject)

/*++

CAsnObject:

    This is the construction routine for a CAsnObject.

Arguments:

    pasnParent supplies the parent of this object.

    dwType supplies the type of the object.

    dwFlags supplies any special flags for this object.  Options are:

        fOptional implies the object is optional.
        fDelete implies the object should be deleted when its parent destructs.

    dwTag is the tag of the object.  If this is zero, the tag is taken from the
        type.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

CAsnObject::CAsnObject(
    IN DWORD dwFlags,
    IN DWORD dwTag,
    IN DWORD dwType)
:   m_rgEntries(),
    m_bfDefault()
{
    ASSERT(0 == (dwFlags & (fPresent | fDefault | 0xffffffe0)));
    m_dwTag = (tag_Undefined == dwTag) ? (dwType % 100) : dwTag;
    m_dwType = dwType;
    m_dwFlags = dwFlags;
    m_State = fill_Empty;
    m_pasnParent = NULL;
    ASSERT((tag_Undefined != m_dwTag)
            || (type_Any == m_dwType)
            || (type_Choice == m_dwType));
}


/*++

~CAsnObject:

    This is the destructor for the object.  We go through the list of objects
    and delete any marked as fDelete.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

CAsnObject::~CAsnObject()
{
    CAsnObject *pasn;
    DWORD index;
    DWORD count = m_rgEntries.Count();

    for (index = 0; index < count; index += 1)
    {
        pasn = m_rgEntries[index];
        if ((NULL != pasn) && (this != pasn))
        {
            if (0 != (pasn->m_dwFlags & fDelete))
                delete pasn;
        }
    }
}


/*++

Adopt:

    This method causes this object to treat the given object as its parent for
    event notification.

Arguments:

    pasnParent supplies the address of the parent object.  Typically the caller
        provides the value 'this'.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/10/1995

--*/

void
CAsnObject::Adopt(
    CAsnObject *pasnObject)
{
    CAsnObject *pasn;
    DWORD index;
    DWORD count = m_rgEntries.Count();

    for (index = 0; index < count; index += 1)
    {
        pasn = m_rgEntries[index];
        if ((NULL != pasn) && (this != pasn))
            pasn->Adopt(this);
    }
    ASSERT(this != pasnObject);
    m_pasnParent = pasnObject;
}


/*++

Clear:

    This method purges any stored values from the object and any underlying
    objects.  It does not free any Default storage.  It does delete autoDelete
    objects.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

void
CAsnObject::Clear(
    void)
{
    CAsnObject *pasn;
    DWORD index;
    DWORD count = m_rgEntries.Count();

    for (index = 0; index < count; index += 1)
    {
        pasn = m_rgEntries[index];
        ASSERT(NULL != pasn);
        ASSERT(this != pasn);

        if (NULL == pasn)
            continue;

        pasn->Clear();
        if (0 != (pasn->m_dwFlags & fDelete))
        {
            delete pasn;
            m_rgEntries.Set(index, NULL);
        }
    }
}


/*++

Tag:

    This routine returns the tag value of the object.

Arguments:

    None

Return Value:

    The tag, if known, or zero if not.

Author:

    Doug Barlow (dbarlow) 10/6/1995

--*/

DWORD
CAsnObject::Tag(
    void)
const
{
    return m_dwTag;
}


/*++

DataLength:

    This routine returns the length of the local machine encoding of the data of
    an object.  This default implementation goes through all the subcomponents
    and adds up their lengths, but produces an ASN.1 encoding.

Arguments:

    None

Return Value:

    If >=0, the length of the data portion of this object.
    if < 0, an error occurred.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnObject::DataLength(
    void)
const
{
    LONG lTotal = 0;
    LONG lth;
    CAsnObject *pasn;
    DWORD index;
    DWORD count;


    if (!Complete())
    {
        TRACE("Incomplete structure")
        return -1;  // ?error? Incomplete structure.
    }
    count = m_rgEntries.Count();
    for (index = 0; index < count; index += 1)
    {
        pasn = m_rgEntries[index];
        ASSERT(NULL != pasn);
        ASSERT(pasn != this);

        if (NULL == pasn)
        {
            lth = -1;
            goto ErrorExit;
        }

        lth = pasn->_encLength();
        if (0 > lth)
            goto ErrorExit;
        lTotal += lth;
    }
    return lTotal;

ErrorExit:
    return lth;
}


/*++

Read:

    This default method constructs the value from the encoding of the underlying
    objects.

Arguments:

    bfDst receives the value.
    pbDst receives the value.  It is assumed to be long enough.

Return Value:

    If >=0, the length of the data portion of this object.
    if < 0, an error occurred.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnObject::Read(
    OUT CBuffer &bfDst)
const
{
    LONG lth = DataLength();
    if (0 < lth)
    {
        if (NULL == bfDst.Resize(lth))
            return -1;  // ?error? no memory
        return Read(bfDst.Access());
    }
    else
        return lth;
}

LONG
CAsnObject::Read(
    OUT LPBYTE pbDst)
const
{
    if (!Complete())
    {
        TRACE("Incomplete Structure")
        return -1;  // ?error? Incomplete structure.
    }
    return EncodeData(pbDst);
}


/*++

Write:

    This default implementation does an encoding operation on each of the
    components.

Arguments:

    bfSrc supplies the data to be written as a CBuffer object.
    pbSrc supplies the data as a BYTE array, with
    cbSrcLen supplies the length of the pbSrc Array.

Return Value:

    If >=0, the length of the data portion of this object.
    if < 0, an error occurred.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnObject::Write(
    IN const CBuffer &bfSrc)
{
    return Write(bfSrc.Access(), bfSrc.Length());
}

LONG
CAsnObject::Write(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrcLen)
{
    LONG lTotal = 0;
    LONG lth = -1;
    CAsnObject *pasn;
    DWORD index;
    DWORD count = m_rgEntries.Count();

    Clear();
    for (index = 0; index < count; index += 1)
    {
        pasn = m_rgEntries[index];
        ASSERT(NULL != pasn);
        ASSERT(pasn != this);

        if (NULL == pasn)
        {
            lth = -1;
            goto ErrorExit;
        }

        lth = pasn->_decode(&pbSrc[lTotal],cbSrcLen-lTotal);
        if (0 > lth)
            goto ErrorExit;
        lTotal += lth;
        if (cbSrcLen < (DWORD)lTotal)
        {
            TRACE("Data Encoding Error: Exceeded length while parsing")
            lth = -1;   // ?ErrorCode? Data Encoding Error
            goto ErrorExit;
        }
    }
    if ((DWORD)lTotal != cbSrcLen)
    {
        TRACE("Data Encoding Error: Length mismatch")
        lth = -1;   // ?ErrorCode? Data Encoding Error
        goto ErrorExit;
    }
    return lTotal;

ErrorExit:
    return lth;
}


/*++

EncodingLength:

    This method returns the length of the object in its ASN.1 encoding.

Arguments:

    None

Return Value:

    >= 0 is the length of the object's ASN.1 encoding.
    < 0 implies an error.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnObject::EncodingLength(
    void)
const
{
    if (!Complete())
    {
        TRACE("Incomplete Object")
        return -1;  // ?error? Incomplete object.
    }
    return _encLength();
}

LONG
CAsnObject::_encLength(
    void)
const
{
    BYTE rge[32];
    LONG lTotal = 0;
    LONG lth;
    CAsnObject *pasn;
    DWORD index;
    DWORD count = m_rgEntries.Count();

    switch (m_State)
    {
    case fill_Empty:
    case fill_Partial:
        lth = -1;
        goto ErrorExit;
        break;

    case fill_Optional:
    case fill_Defaulted:
        lTotal = 0;
        break;

    case fill_Present:
    case fill_NoElements:
        lth = EncodeTag(rge);
        if (0 > lth)
            goto ErrorExit;
        lTotal += lth;
        lth = EncodeLength(rge);
        if (0 > lth)
            goto ErrorExit;
        lTotal += lth;
        for (index = 0; index < count; index += 1)
        {
            pasn = m_rgEntries[index];
            ASSERT(NULL != pasn);
            ASSERT(pasn != this);

            if (NULL == pasn)
            {
                lth = -1;
                goto ErrorExit;
            }

            lth = pasn->_encLength();
            if (0 > lth)
                goto ErrorExit;
            lTotal += lth;
        }
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        goto ErrorExit;
        break;
    }
    return lTotal;

ErrorExit:
    return lth;
}


/*++

Encode:

    This method provides the ASN.1 encoding of the object.

Arguments:

    bfDst receives the encoding in a CBuffer format.

    pbDst receives the encoding in a LPBYTE format.  The buffer is assumed to be
        long enough.

Return Value:

    >= 0 is the length of the ASN.1 encoding.
    < 0 is an error indication.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnObject::Encode(
    OUT CBuffer &bfDst)
const
{
    LONG lth = EncodingLength();
    if (0 > lth)
        goto ErrorExit;
    if (NULL == bfDst.Resize(lth))
        goto ErrorExit;
    lth = _encode(bfDst.Access());
    if (0 > lth)
        goto ErrorExit;
    return lth;

ErrorExit:
    bfDst.Reset();
    return lth;
}

LONG
CAsnObject::Encode(
    OUT LPBYTE pbDst)
const
{
    if (!Complete())
    {
        TRACE("Incomplete Structure")
        return -1;  // ?error? Incomplete structure.
    }
    return _encode(pbDst);
}

LONG
CAsnObject::_encode(
    OUT LPBYTE pbDst)
const
{
    LONG lth;
    LONG lTotal = 0;

    lth = EncodeTag(&pbDst[lTotal]);
    if (0 > lth)
        goto ErrorExit;
    lTotal += lth;
    lth = EncodeLength(&pbDst[lTotal]);
    if (0 > lth)
        goto ErrorExit;
    lTotal += lth;
    lth = EncodeData(&pbDst[lTotal]);
    if (0 > lth)
        goto ErrorExit;
    lTotal += lth;
    return lTotal;

ErrorExit:
    return lth;
}


/*++

Decode:

    This method reads an ASN.1 encoding of the object, and loads the components
    with the data.

Arguments:

    pbSrc supplies the ASN.1 encoding in an LPBYTE format.
    bfSrc supplies the ASN.1 encoding in a CBuffer format.

Return Value:

    >= 0 is the number of bytes consumed by the decoding.
    < 0 implies an error occurred.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnObject::Decode(
    IN const CBuffer &bfSrc)
{
    LONG lth = Decode(bfSrc.Access(), bfSrc.Length());
    return lth;
}

LONG
CAsnObject::Decode(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrc)
{
    Clear();
    return _decode(pbSrc,cbSrc);
}

LONG
CAsnObject::_decode(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrc)
{
    LONG lth;
    LONG lTotal = 0;
    DWORD tag, length;
    BOOL fIndefinite, fConstr;


    //
    // Extract the Tag.
    //

    lth = ExtractTag(&pbSrc[lTotal], cbSrc, &tag, &fConstr);
    if (0 > lth)
        goto ErrorExit;
    if ((m_dwTag != tag)
        || (0 != (fConstr ^ (0 != (m_dwFlags & fConstructed)))))
    {
        if (0 != ((fOptional | fDefault) & m_dwFlags))
            return 0;
        else
        {
            TRACE("Invalid Tag Value")
            lth = -1;   // ?error? Invalid Tag Value
            goto ErrorExit;
        }
    }
    lTotal += lth;

    //
    // Extract the length.
    //

    lth = ExtractLength(&pbSrc[lTotal], cbSrc-lTotal, &length, &fIndefinite);
    if (0 > lth)
        goto ErrorExit;
    if (fIndefinite && !fConstr)
    {
        TRACE("Indefinite length on primitive object")
        lth = -1;   // ?error? - Indefinite length on primitive object
        goto ErrorExit;
    }
    lTotal += lth;

    //
    // Extract the data.
    //

    lth = DecodeData(&pbSrc[lTotal], cbSrc-lTotal, length);
    if (0 > lth)
        goto ErrorExit;
    ASSERT((DWORD)lth == length);
    lTotal += lth;

    //
    // Extract any trailing tag.
    //

    if (fIndefinite)
    {
        lth = ExtractTag(&pbSrc[lTotal], cbSrc-lTotal, &tag, &fConstr);
        if (0 > lth)
            goto ErrorExit;
        if ((0 != tag) || (fConstr))
        {
            TRACE("Bad indefinite length encoding")
            lth = -1;   // ?Error? Bad indefinite length encoding.
            goto ErrorExit;
        }
        lTotal += lth;
    }


    //
    // Return the status.
    //

    return lTotal;

ErrorExit:
    return lth;
}


/*++

ChildAction:

    This method receives notification of actions from children.  The default
    action is to just propagate the action up the tree.

Arguments:

    action supplies the action identifier.

    pasnChild supplies the child address.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/6/1995

--*/

void
CAsnObject::ChildAction(
    IN ChildActions action,
    IN CAsnObject *pasnChild)
{
    switch (action)
    {
    case act_Cleared:

        //
        // These actions are swallowed.
        //

        break;

    case act_Written:

        //
        // These actions are propagated.
        //

        if (NULL != m_pasnParent)
            m_pasnParent->ChildAction(action, this);
        break;

    default:
        ASSERT(FALSE);  // Don't propagate, but complain when debugging.
        break;
    }
}


/*++

SetDefault:

    This protected method is used to declare data that was just decoded to be
    the default data for the object.

Arguments:

    None

Return Value:

    >= 0 The length of the default data.
    < 0 implies an error.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnObject::SetDefault(
    void)
{
    LONG lth;

    ASSERT(Complete());
    lth = Read(m_bfDefault);
    if (0 > lth)
        goto ErrorExit;
    Clear();
    m_dwFlags &= ~(fPresent | fOptional);
    m_dwFlags |= fDefault;

ErrorExit:
    return lth;
}


/*++

State:

    This routine checks to see if a structure is completely filled in.

Arguments:

    None

Return Value:

    fill_Empty   - There is no added data anywhere in the structure.
    fill_Present - All the data is present in the structure.
    fill_Partial - Not all of the data is there, but some of it is.
    fill_Defauted - No data has been written, but a default value is available.
    fill_Optional - No data has been written, but the object is optional.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

CAsnObject::FillState
CAsnObject::State(
    void) const
{
    CAsnObject *pasn;
    DWORD index;
    DWORD count = m_rgEntries.Count();
    DWORD dwThereCount = 0,
          dwOptionalCount = 0;
    FillState result;

    for (index = 0; index < count; index += 1)
    {
        pasn = m_rgEntries[index];
        ASSERT(NULL != pasn);
        ASSERT(pasn != this);

        if (NULL == pasn)
            continue;

        result = pasn->State();
        switch (result)
        {
        case fill_NoElements:       // It's there if we want it to be.
            if (0 != ((fOptional | fDefault) & m_dwFlags))
                dwOptionalCount += 1;
            else
                dwThereCount += 1;
            break;

        case fill_Present:
            dwThereCount += 1;      // Count it as there.
            break;

        case fill_Partial:
            return fill_Partial;    // Some data under us is missing.
            break;

        case fill_Optional:
        case fill_Defaulted:
            dwOptionalCount += 1;   // Count it as conditionally there.
            break;

        case fill_Empty:
            break;                  // We have no data here.  Continue
        default:
            ASSERT(FALSE);
            break;
        }
    }

    if (0 == dwThereCount)
    {

        //
        // We're officially not here, either empty, defaulted, or optional.
        //

        if (0 != (fOptional & m_dwFlags))
            result = fill_Optional;     // We're optional.
        else if (0 != (fDefault & m_dwFlags))
            result = fill_Defaulted;    // We're defaulted.
        else if (0 == count)
            result = fill_NoElements;   // We just don't have children.
        else
            result = fill_Empty;        // We're empty.
    }
    else if (count == dwThereCount + dwOptionalCount)
    {

        //
        // Every element was filled in.  We can report that we're here.
        //

        result = fill_Present;
    }
    else
    {

        //
        // Not every element was filled in, but some of them were.  We're
        // partial.
        //

        result = fill_Partial;
    }
    ((CAsnObject *)this)->m_State = result;
    return result;
}


/*++

Complete:

    This routine determines if enough information exists within the ASN.1 Object
    for it to be generally useful.

Arguments:

    None

Return Value:

    TRUE - All data is filled in, either directly, or is optional or defaulted.
    FALSE - Not all fields have been filled in.

Author:

    Doug Barlow (dbarlow) 10/24/1995

--*/

BOOL
CAsnObject::Complete(
    void)
const
{
    BOOL fResult;

    switch (State())
    {
    case fill_Empty:
    case fill_Partial:
        fResult = FALSE;
        break;

    case fill_Optional:
    case fill_Defaulted:
    case fill_Present:
    case fill_NoElements:
        fResult = TRUE;
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        fResult = FALSE;
        break;
    }
    return fResult;
}


/*++

Exists:

    This routine determines if enough information exists within the ASN.1 Object
    for it to be specifically useful.

Arguments:

    None

Return Value:

    TRUE - All data is filled in, either directly, or is defaulted.
    FALSE - Not all fields have been filled in.  They may be optional.

Author:

    Doug Barlow (dbarlow) 10/24/1995

--*/

BOOL
CAsnObject::Exists(
    void)
const
{
    BOOL fResult;

    switch (State())
    {
    case fill_Empty:
    case fill_Partial:
    case fill_Optional:
        fResult = FALSE;
        break;

    case fill_Defaulted:
    case fill_Present:
    case fill_NoElements:
        fResult = TRUE;
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        fResult = FALSE;
        break;
    }
    return fResult;
}


/*++

Compare:

    This method compares this ASN.1 Object to another.

Arguments:

    asnObject supplies the other object for comparison.

Return Value:

    A value indicating a comparitive value:
    < 0 - This object is less than that object.
    = 0 - This object is the same as that object.
    > 0 - This object is more than that object.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnObject::Compare(
    const CAsnObject &asnObject)
const
{
    CAsnObject *pasn1, *pasn2;
    LONG lSame = 0x100; // Meaningless comparison
    LONG lCmp;
    DWORD index;
    DWORD count = asnObject.m_rgEntries.Count();

    if ((m_dwType == asnObject.m_dwType)
        && (m_rgEntries.Count() == count))
    {
        for (index = 0; index < count; index += 1)
        {
            pasn1 = m_rgEntries[index];
            ASSERT(NULL != pasn1);
            ASSERT(this != pasn1);

            if (NULL == pasn1)
                continue;

            pasn2 = asnObject.m_rgEntries[index];
            ASSERT(NULL != pasn2);
            ASSERT(&asnObject != pasn2);

            if (NULL == pasn2)
                continue;

            lCmp = pasn1->Compare(*pasn2);
            if (0 != lCmp)
                break;
        }
        if (index == count)
            lSame = 0;
        else
            lSame = lCmp;
    }
    return lSame;
}


/*++

Copy:

    This method replaces the contents of this ASN.1 Object with another.  The
    objects must be identical structures.  Tags and defaults are not duplicated.

Arguments:

    asnObject supplies the source object.

Return Value:

    >= 0 Is the number of bytes actually copied
    < 0 is an error.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnObject::Copy(
    const CAsnObject &asnObject)
{
    LONG lth;
    Clear();
    asnObject.State();
    lth = _copy(asnObject);  // ?Exception? on error?
    ASSERT(0 <= lth);
    return lth;
}

LONG
CAsnObject::_copy(
    const CAsnObject &asnObject)
{
    CAsnObject *pasn1;
    const CAsnObject *pasn2;
    LONG lTotal = 0, lth = -1;
    DWORD index;
    DWORD count = asnObject.m_rgEntries.Count();

    if ((m_dwType == asnObject.m_dwType) && (m_rgEntries.Count() == count))
    {
        for (index = 0; index < count; index += 1)
        {
            pasn1 = m_rgEntries[index];
            ASSERT(NULL != pasn1);
            ASSERT(pasn1 != this);
            pasn2 = asnObject.m_rgEntries[index];
            ASSERT(NULL != pasn2);
            ASSERT(pasn1 != &asnObject);

            if (NULL == pasn2)
                continue;

            switch (pasn2->m_State)
            {
            case fill_Empty:
            case fill_Partial:
                TRACE("Incomplete structure in copy")
                lth = -1;   // ?Error? Incomplete structure
                break;

            case fill_Present:
            case fill_NoElements:
                if (NULL == pasn1)
                    continue;
                lth = pasn1->_copy(*pasn2);
                break;

            case fill_Defaulted:
            case fill_Optional:
                lth = 0;
                break;

            default:
                ASSERT(FALSE);   // ?error? Internal consistency check.
                lth = -1;
            }
            if (0 > lth)
                goto ErrorExit;
            lTotal += lth;
        }
    }
    else
    {
        TRACE("Copy Structure Mismatch")
        lth = -1;   // ?error? data type mismatch.
        goto ErrorExit;
    }
    return lTotal;

ErrorExit:
    return lth;
}


/*++

EncodeTag:

    This method encodes the tag of the object into the supplied buffer.

Arguments:

    pbDst receives the ASN.1 encoding of the tag.

Return Value:

    >= 0 is the length of the tag.
    < 0 is an error.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnObject::EncodeTag(
    OUT LPBYTE pbDst)
const
{
    BYTE
        tagbuf[8],
        cls,
        cnstr;
    DWORD
        length,
        tag = Tag();
    LONG
        lth;

    switch (m_State)
    {
    case fill_Empty:
    case fill_Partial:
        TRACE("Incomplete Structure")
        return -1;       // ?error? Incomplete structure
        break;

    case fill_Optional:
    case fill_Defaulted:
        return 0;
        break;

    case fill_Present:
    case fill_NoElements:
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        return -1;
        break;
    }


    //
    // Break up the tag into its pieces.
    //

    cls = (BYTE)((tag & 0xc0000000) >> 24);
    tag &= 0x1fffffff;
    cnstr = (0 == (fConstructed & m_dwFlags)) ? 0 : 0x20;
    ASSERT((0 != tag) || (0 != cls));


    //
    //  Place a tag into the output buffer.
    //

    length = sizeof(tagbuf) - 1;
    if (31 > tag)
    {

        //
        //  Short form type encoding.
        //

        tagbuf[length] = (BYTE)tag;
    }
    else
    {

        //
        //  Long form type encoding.
        //

        tagbuf[length] = (BYTE)(tag & 0x7f);
        for (;;)
        {
            length -= 1;
            tag = (tag >> 7) & 0x01ffffff;
            if (0 == tag)
                break;
            tagbuf[length] = (BYTE)((tag & 0x7f) | 0x80);
        }
        tagbuf[length] = 31;
    }


    //
    // Place the tag type.
    //

    tagbuf[length] |= cls | cnstr;
    lth = sizeof(tagbuf) - length;
    memcpy(pbDst, &tagbuf[length], lth);
    return lth;
}


/*++

EncodeLength:

    This method encodes the definite length of the object into the supplied
    buffer.

Arguments:

    pbDst receives the ASN.1 encoding of the length.

    lSize supplies the size of the encoded data.

Return Value:

    >= 0 is the length of the resultant encoding
    < 0 is an error.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnObject::EncodeLength(
    OUT LPBYTE pbDst)
const
{
    LONG lth, lTotal = 0;
    DWORD count, index;
    CAsnObject *pasn;


    //
    // This default implementation just encodes the data.
    //


    switch (m_State)
    {
    case fill_Empty:
    case fill_Partial:
        TRACE("Incomplete Structure")
        lth = -1;       // ?error? Incomplete Structure
        goto ErrorExit;
        break;

    case fill_Optional:
    case fill_Defaulted:
        lth = 0;
        break;

    case fill_Present:
    case fill_NoElements:
        count = m_rgEntries.Count();
        for (index = 0; index < count; index += 1)
        {
            pasn = m_rgEntries[index];
            ASSERT(NULL != pasn);
            ASSERT(pasn != this);

            if (pasn == NULL)
                continue;

            lth = pasn->_encLength();
            if (0 > lth)
                goto ErrorExit;
            lTotal += lth;
        }
        lth = EncodeLength(pbDst, lTotal);
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;

ErrorExit:
    return lth;
}

LONG
CAsnObject::EncodeLength(
    OUT LPBYTE pbDst,
    IN LONG lSize)
const
{
    BYTE
        lenbuf[8];
    DWORD
        length = sizeof(lenbuf) - 1;
    LONG
        lth;

    switch (m_State)
    {
    case fill_Empty:
    case fill_Partial:
        TRACE("Incomplete Object")
        lth = -1;       // ?error? Incomplete structure
        break;

    case fill_Optional:
    case fill_Defaulted:
        lth = 0;
        break;

    case fill_Present:
    case fill_NoElements:
        if (0x80 > lSize)
        {
            lenbuf[length] = (BYTE)lSize;
            lth = 1;
        }
        else
        {
            while (0 < lSize)
            {
                lenbuf[length] = (BYTE)(lSize & 0xff);
                length -= 1;
                lSize = (lSize >> 8) & 0x00ffffff;
            }
            lth = sizeof(lenbuf) - length;
            lenbuf[length] = (BYTE)(0x80 | (lth - 1));
        }

        memcpy(pbDst, &lenbuf[length], lth);
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}


/*++

EncodeData:

    This method encodes the data into the supplied buffer.

Arguments:

    pbDst

Return Value:

    >= 0 is the length of the encoding.
    < 0 is an error

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnObject::EncodeData(
    OUT LPBYTE pbDst)
const
{
    LONG lTotal = 0;
    LONG lth;
    CAsnObject *pasn;
    DWORD index;
    DWORD count = m_rgEntries.Count();

    switch (m_State)
    {
    case fill_Empty:
    case fill_Partial:
        TRACE("Incomplete Structure")
        lth = -1;       // ?error? Incomplete structure
        goto ErrorExit;
        break;

    case fill_Optional:
    case fill_Defaulted:
    case fill_NoElements:
        break;

    case fill_Present:
        for (index = 0; index < count; index += 1)
        {
            pasn = m_rgEntries[index];
            ASSERT(NULL != pasn);
            ASSERT(pasn != this);

            if (NULL == pasn)
                continue;

            lth = pasn->_encode(&pbDst[lTotal]);
            if (0 > lth)
                goto ErrorExit;
            lTotal += lth;
        }
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        goto ErrorExit;
        break;
    }
    return lTotal;

ErrorExit:
    return lth;
}


/*++

DecodeData:

    This routine decodes the data portion of the ASN.1.  The tag and length have
    already been removed.

Arguments:

    pbSrc supplies the address of the ASN.1 encoding of the data.

    dwLength supplies the length of the data.


Return Value:

    >= 0 - The number of bytes removed from the input stream.
    <  0 - An error occurred.

Author:

    Doug Barlow (dbarlow) 10/6/1995

--*/

LONG
CAsnObject::DecodeData(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrc,
    IN DWORD dwLength)
{
    LONG lTotal = 0;
    LONG lth = -1;
    CAsnObject *pasn;
    DWORD index;
    DWORD count = m_rgEntries.Count();

    //
    // Decode the data.
    //

    for (index = 0; index < count; index += 1)
    {
        pasn = m_rgEntries[index];
        ASSERT(NULL != pasn);
        ASSERT(pasn != this);

        if (NULL == pasn)
            continue;

        if ((DWORD)lTotal < dwLength)
        {
            lth = pasn->_decode(&pbSrc[lTotal],cbSrc-lTotal);
            if (0 > lth)
                goto ErrorExit;
            lTotal += lth;

            if ((DWORD)lTotal > dwLength)
            {
                TRACE("Decoding Overrun")
                lth = -1;   // ?error? Decoding overrun.
                goto ErrorExit;
            }
        }
        else
        {
            if (0 == (pasn->m_dwFlags & (fOptional | fDefault)))
            {
                TRACE("Incomplete construction")
                lth = -1;   // ?error? Incomplete construction
                goto ErrorExit;
            }
        }
    }
    if ((DWORD)lTotal != dwLength)
    {
        TRACE("Decoding length mismatch")
        lth = -1;   // ?error? Decoding length mismatch.
        goto ErrorExit;
    }
    return lTotal;

ErrorExit:
    return lth;
}


/*++

TypeCompare:

    This routine compares the entire structure of an Object to another Object.

Arguments:

    asn - The other object.

Return Value:

    TRUE - They are identical
    FALSE - They differ

Author:

    Doug Barlow (dbarlow) 10/19/1995

--*/

BOOL
CAsnObject::TypeCompare(
    const CAsnObject &asnObject)
const
{
    CAsnObject *pasn1, *pasn2;
    DWORD index;
    DWORD count = m_rgEntries.Count();

    //
    // See if we really have anything to do.
    //

    if (m_dwType != asnObject.m_dwType)
        goto ErrorExit;
    if (count != asnObject.m_rgEntries.Count())
        goto ErrorExit;


    //
    // Recursively compare the types.
    //

    for (index = 0; index < count; index += 1)
    {
        pasn1 = m_rgEntries[index];
        ASSERT(NULL != pasn1);
        ASSERT(pasn1 != this);

        if (NULL == pasn1)
            continue;

        pasn2 = asnObject.m_rgEntries[index];
        ASSERT(NULL != pasn2);
        ASSERT(pasn1 != &asnObject);

        if (NULL == pasn2)
            continue;

        if (!pasn1->TypeCompare(*pasn2))
            goto ErrorExit;
    }
    return TRUE;

ErrorExit:
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\asn1\asnutils.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    asnUtils

Abstract:

    This module contains the utility routines used by the internal ASN.1
    Classes.

Author:

    Doug Barlow (dbarlow) 10/9/1995

Environment:

    Win32

Notes:

    Some of these routines assume that an unsigned long int is 32 bits wide.

--*/

#include <windows.h>
#include "asnPriv.h"


/*++

ExtractTag:

    This routine extracts a tag from an ASN.1 BER stream.

Arguments:

    pbSrc supplies the buffer containing the ASN.1 stream.

    pdwTag receives the tag.

Return Value:

    >= 0 - The number of bytes extracted from the stream.

    <  0 - An error occurred.

Author:

    Doug Barlow (dbarlow) 10/9/1995

--*/

LONG
ExtractTag(
    const BYTE FAR *pbSrc,
    DWORD cbSrc,
    LPDWORD pdwTag,
    LPBOOL pfConstr)
{
    LONG lth = 0;
    DWORD tagw;
    BYTE tagc, cls;

    if (cbSrc < sizeof(BYTE))
    {
        lth = -1;
        goto ErrorExit;
    }

    tagc = pbSrc[lth++];

    cls = tagc & 0xc0;  // Top 2 bits.
    if (NULL != pfConstr)
        *pfConstr = (0 != (tagc & 0x20));
    tagc &= 0x1f;       // Bottom 5 bits.

    if (31 > tagc)
        tagw = tagc;
    else
    {
        tagw = 0;
        do
        {
            if (0 != (tagw & 0xfe000000))
            {
                TRACE("Integer Overflow")
                lth = -1;   // ?error? Integer overflow
                goto ErrorExit;
            }

            if (cbSrc < (DWORD)(lth+1))
            {
                lth = -1;
                goto ErrorExit;
            }

            tagc = pbSrc[lth++];

            tagw <<= 7;
            tagw |= tagc & 0x7f;
        } while (0 != (tagc & 0x80));
    }

    *pdwTag = tagw | (cls << 24);
    return lth;

ErrorExit:
    return lth;
}


/*++

ExtractLength:

    This routine extracts a length from an ASN.1 BER stream.  If the length is
    indefinite, this routine recurses to figure out the real length.  A flag as
    to whether or not the encoding was indefinite is optionally returned.

Arguments:

    pbSrc supplies the buffer containing the ASN.1 stream.

    pdwLen receives the len.

    pfIndefinite, if not NULL, receives a flag indicating whether or not the
        encoding was indefinite.

Return Value:

    >= 0 - The number of bytes extracted from the stream.

    <  0 - An error occurred.

Author:

    Doug Barlow (dbarlow) 10/9/1995

--*/

LONG
ExtractLength(
    const BYTE FAR *pbSrc,
    DWORD cbSrc,
    LPDWORD pdwLen,
    LPBOOL pfIndefinite)
{
    DWORD ll, rslt;
    LONG lth, lTotal = 0;
    BOOL fInd = FALSE;


    //
    // Extract the Length.
    //

    if (cbSrc < sizeof(BYTE))
    {
        lth = -1;
        goto ErrorExit;
    }

    if (0 == (pbSrc[lTotal] & 0x80))
    {

        //
        // Short form encoding.
        //

        rslt = pbSrc[lTotal++];
    }
    else
    {
        rslt = 0;
        ll = pbSrc[lTotal++] & 0x7f;

        if (0 != ll)
        {

            //
            // Long form encoding.
            //

            for (; 0 < ll; ll -= 1)
            {
                if (0 != (rslt & 0xff000000))
                {
                    TRACE("Integer Overflow")
                    lth = -1;   // ?error? Integer overflow
                    goto ErrorExit;
                }
                else
                {
                    if (cbSrc < (DWORD)(lTotal+1))
                    {
                        lth = -1;
                        goto ErrorExit;
                    }

                    rslt = (rslt << 8) | pbSrc[lTotal];
                }

                lTotal += 1;
            }
        }
        else
        {
            DWORD ls = lTotal;

            //
            // Indefinite encoding.
            //

            fInd = TRUE;

            if (cbSrc < ls+2)
            {
                lth = -1;
                goto ErrorExit;
            }

            while ((0 != pbSrc[ls]) || (0 != pbSrc[ls + 1]))
            {

                // Skip over the Type.
                if (31 > (pbSrc[ls] & 0x1f))
                    ls += 1;
                else
                {
                    while (0 != (pbSrc[++ls] & 0x80))
                    {
                        if (cbSrc < ls+2)
                        {
                            lth = -1;
                            goto ErrorExit;
                        }
                    }
                }

                lth = ExtractLength(&pbSrc[ls], cbSrc-ls, &ll);
                ls += lth + ll;

                if (cbSrc < ls+2)
                {
                    lth = -1;
                    goto ErrorExit;
                }
            }
            rslt = ls - lTotal;
        }
    }

    //
    // Supply the caller with what we've learned.
    //

    *pdwLen = rslt;
    if (NULL != pfIndefinite)
        *pfIndefinite = fInd;
    return lTotal;


ErrorExit:
    return lth;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\asn1\msasnlib.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    msasnlib

Abstract:

    This module provides the primary services of the MS ASN.1 Library.

Author:

    Doug Barlow (dbarlow) 10/5/1995

Environment:

    Win32

Notes:

--*/

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>

#if !defined(OS_WINCE)
#include <basetsd.h>
#endif

#include "asnPriv.h"

#ifdef OS_WINCE
// We have a private version of strtoul() for CE since it's not supported
// there.
extern "C" unsigned long __cdecl strtoul(const char *nptr, char **endptr, int ibase);
#endif

//
//==============================================================================
//
//  CAsnBoolean
//

IMPLEMENT_NEW(CAsnBoolean)


CAsnBoolean::CAsnBoolean(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnPrimitive(dwFlags, dwTag, type_Boolean)
{ /* Force the type to type_Boolean */ }

LONG
CAsnBoolean::Write(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrcLen)
{
    BYTE rslt;
    if (1 != cbSrcLen)
    {
        TRACE("BOOLEAN Value longer than one byte")
        return -1;  // ?error? Invalid value
    }
    rslt = 0 != *pbSrc ? 0xff : 0;
    return CAsnPrimitive::Write(&rslt, 1);
}

CAsnBoolean::operator BOOL(void)
const
{
    BOOL result;

    switch (State())
    {
    case fill_Empty:
    case fill_Optional:
        TRACE("Incomplete BOOLEAN value")
        result = FALSE; // ?throw? error.
        break;

    case fill_Present:
        result = (0 != *m_bfData.Access());
        break;

    case fill_Defaulted:
        result = (0 != *m_bfDefault.Access());
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        result = FALSE;
        break;
    }
    return result;
}

BOOL
CAsnBoolean::operator =(
    BOOL fValue)
{
    BYTE rslt = 0 != fValue ? 0xff : 0;
    CAsnPrimitive::Write(&rslt, 1);
    return fValue;
}

CAsnObject *
CAsnBoolean::Clone(
    IN DWORD dwFlags)
const
{ return new CAsnBoolean(dwFlags, m_dwTag); }

LONG
CAsnBoolean::DecodeData(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrc,
    IN DWORD dwLength)
{
    if (1 != dwLength)
    {
        TRACE("Decoded BOOLEAN Value longer than one byte")
        return -1;  // ?error? Invalid value
    }
    return CAsnPrimitive::DecodeData(pbSrc, cbSrc, dwLength);
}


//
//==============================================================================
//
//  CAsnInteger
//

IMPLEMENT_NEW(CAsnInteger)


CAsnInteger::CAsnInteger(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnPrimitive(dwFlags, dwTag, type_Integer)
{ /* Force the type to type_Integer */ }

LONG
CAsnInteger::Write(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrcLen)
{
    if (0 < cbSrcLen)
    {
        if (NULL == m_bfData.Set(pbSrc, cbSrcLen))
            goto ErrorExit;  // ?error? Propagate No Memory
    }
    else
    {
        TRACE("Attempt to write a Zero Length integer")
        return -1;
    }
    m_dwFlags |= fPresent;
    if (NULL != m_pasnParent)
        m_pasnParent->ChildAction(act_Written, this);
    return m_bfData.Length();

ErrorExit:
    return -1;
}

LONG
CAsnInteger::Write(
    IN const DWORD *pdwSrc,
    IN DWORD cdwSrcLen)
{
#if defined(OS_WINCE)
    size_t length;
#else
    SIZE_T length;
#endif

    LPBYTE pbBegin = (LPBYTE)pdwSrc;
    LPBYTE pbEnd = (LPBYTE)(&pdwSrc[cdwSrcLen]);
    while (0 == *(--pbEnd));   // Note semi-colon here!
    length = pbEnd - pbBegin + 1;

    if (0 < cdwSrcLen)
    {
        if (0 != (*pbEnd & 0x80))
        {
            if (NULL == m_bfData.Resize((DWORD)length + 1))
                return -1;  // Propagate memory error.
            pbBegin = m_bfData.Access();
            *pbBegin++ = 0;
        }
        else
        {
            if (NULL == m_bfData.Resize((DWORD)length))
                return -1;  // Propagate memory error.
            pbBegin = m_bfData.Access();
        }
        while (0 < length--)
            *pbBegin++ = *pbEnd--;
        m_dwFlags |= fPresent;
        if (NULL != m_pasnParent)
            m_pasnParent->ChildAction(act_Written, this);
        return m_bfData.Length();
    }
    else
    {
        TRACE("Attempt to write a Zero Length integer")
        return -1;
    }
}

CAsnInteger::operator LONG(
    void)
const
{
    DWORD index;
    LPBYTE pbVal;
    LONG lResult;

    switch (State())
    {
    case fill_Empty:
    case fill_Optional:
        TRACE("Incomplete INTEGER")
        return -1;  // ?error? Undefined value

    case fill_Present:
        pbVal = m_bfData.Access();
        index = m_bfData.Length();
        break;

    case fill_Defaulted:
        pbVal = m_bfDefault.Access();
        index = m_bfDefault.Length();
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        return -1;
        break;
    }

    if (sizeof(LONG) < index)
    {
        TRACE("INTEGER Overflow")
        return -1;  // ?error? Integer overflow.
    }

    if (NULL == pbVal)
    {
        ASSERT(FALSE);  // ?error? invalid object
        return -1;
    }

    lResult = (0 != (0x80 & *pbVal)) ? -1 : 0;
    while (0 < index)
    {
        index -= 1;

        lResult <<= 8;

        lResult |= (ULONG)pbVal[index];
    }
    return lResult;
}

CAsnInteger::operator ULONG(
    void)
const
{
    DWORD index, len;
    LPBYTE pbVal;
    ULONG lResult = 0;

    switch (State())
    {
    case fill_Empty:
    case fill_Optional:
        TRACE("Incomplete INTEGER")
        return (ULONG)(-1);  // ?error? Undefined value

    case fill_Present:
        pbVal = m_bfData.Access();
        len = m_bfData.Length();
        break;

    case fill_Defaulted:
        pbVal = m_bfDefault.Access();
        len = m_bfDefault.Length();
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        return (ULONG)(-1);
        break;
    }

    if (sizeof(ULONG) < len)
    {
        TRACE("INTEGER Overflow")
        return (ULONG)(-1);  // ?error? Integer overflow.
    }

    for (index = 0; index < len; index += 1)
    {
        lResult <<= 8;
        lResult |= (ULONG)pbVal[index];
    }
    return lResult;
}

LONG
CAsnInteger::operator =(
    LONG lValue)
{
    BYTE nval[sizeof(LONG) + 2];
    DWORD index, nLength;
    LONG isSigned;


    index = sizeof(nval);

    for (DWORD i = 0; i < index; i++)
        nval[i] = (BYTE)0;

    if ((0 == lValue) || (-1 == lValue))
    {
        nval[--index] = (BYTE)(lValue & 0xff);
    }
    else
    {
        isSigned = lValue;

        while (0 != lValue)
        {
            nval[--index] = (BYTE)(lValue & 0xff);
            lValue >>= 8;
        }
        if (0 > isSigned)
        {
            while ((index < sizeof(nval) - 1) && (0xff == nval[index]) && (0 != (0x80 & nval[index + 1])))
                index += 1;
        }
        else
        {
            if (0 != (0x80 & nval[index]))
                nval[--index] = 0;
        }
    }

    nLength = sizeof(nval) - index;
    CAsnPrimitive::Write(&nval[index], nLength);
    return lValue;
}

ULONG
CAsnInteger::operator =(
    ULONG lValue)
{
    BYTE nval[sizeof(ULONG) + 2];
    DWORD index, nLength;
    ULONG lVal = lValue;


    index = sizeof(nval);
    if (0 == lVal)
    {
        nval[--index] = 0;
    }
    else
    {
        while (0 != lVal)
        {
            nval[--index] = (BYTE)(lVal & 0xff);
            lVal >>= 8;
        }
        if (0 != (0x80 & nval[index]))
            nval[--index] = 0;
    }

    nLength = sizeof(nval) - index;
    Write(&nval[index], nLength);
    return lValue;
}

CAsnObject *
CAsnInteger::Clone(
    IN DWORD dwFlags)
const
{ return new CAsnInteger(dwFlags, m_dwTag); }


//
//==============================================================================
//
//  CAsnBitstring
//

IMPLEMENT_NEW(CAsnBitstring)


CAsnBitstring::CAsnBitstring(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnPrimitive(dwFlags, dwTag, type_Bitstring)
{ /* Force the type to type_Bitstring */ }

LONG
CAsnBitstring::DataLength(
    void)
const
{
    LONG lth;

    switch (State())
    {
    case fill_Empty:
    case fill_Optional:
        TRACE("Incomplete BIT STRING")
        lth = -1;  // ?error? No value.
        break;

    case fill_Present:
        lth = m_bfData.Length() - 1;
        break;

    case fill_Defaulted:
        lth = m_bfDefault.Length() - 1;
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}

LONG
CAsnBitstring::Read(
    OUT CBuffer &bfDst,
    OUT int *offset)
const
{
    LONG lth;

    switch (State())
    {
    case fill_Empty:
    case fill_Optional:
        TRACE("Incomplete BIT STRING")
        lth = -1;  // ?error? No value.
        break;

    case fill_Present:
        if (NULL != offset)
            *offset = *m_bfData.Access();
        if (NULL == bfDst.Set(m_bfData.Access(1), m_bfData.Length() - 1))
            goto ErrorExit;

        lth = bfDst.Length();
        break;

    case fill_Defaulted:
        if (NULL != offset)
            *offset = *m_bfDefault.Access();
        if (NULL == bfDst.Set(m_bfDefault.Access(1), m_bfDefault.Length() - 1))
            goto ErrorExit;

        lth = bfDst.Length();
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;

ErrorExit:
    return -1;
}

LONG
CAsnBitstring::Read(
    OUT LPBYTE pbDst,
    OUT int *offset)
const
{
    LONG lth;

    switch (State())
    {
    case fill_Empty:
    case fill_Optional:
        TRACE("Incomplete BIT STRING")
        lth = -1;  // ?error? No value.
        break;

    case fill_Defaulted:
        if (NULL != offset)
            *offset = *m_bfDefault.Access();
        lth = m_bfDefault.Length() - 1;
        memcpy(pbDst, m_bfDefault.Access(1), lth);
        break;

    case fill_Present:
        if (NULL != offset)
            *offset = *m_bfData.Access();
        lth = m_bfData.Length() - 1;
        memcpy(pbDst, m_bfData.Access(1), lth);
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}

LONG
CAsnBitstring::Write(
    IN const CBuffer &bfSrc,
    IN int offset)
{
    return Write(bfSrc.Access(), bfSrc.Length(), offset);
}

LONG
CAsnBitstring::Write(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrcLen,
    IN int offset)
{
    BYTE val;
    if ((7 < offset) || (0 > offset))
    {
        TRACE("BIT STRING Unused bit count invalid")
        return -1;  // ?error? invalid parameter
    }
    val = (BYTE)offset;
    if (NULL == m_bfData.Presize(cbSrcLen + 1))
        goto ErrorExit;

    if (NULL == m_bfData.Set(&val, 1))
        goto ErrorExit;

    if (NULL == m_bfData.Append(pbSrc, cbSrcLen))
        goto ErrorExit;

    m_dwFlags |= fPresent;
    if (NULL != m_pasnParent)
        m_pasnParent->ChildAction(act_Written, this);
    return m_bfData.Length() - 1;

ErrorExit:
    return -1;
}

CAsnObject *
CAsnBitstring::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnBitstring(dwFlags, m_dwTag);
}


//
//==============================================================================
//
//  CAsnOctetstring
//

IMPLEMENT_NEW(CAsnOctetstring)


CAsnOctetstring::CAsnOctetstring(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnPrimitive(dwFlags, dwTag, type_Octetstring)
{ /* Force the type to type_Octetstring */ }

CAsnObject *
CAsnOctetstring::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnOctetstring(dwFlags, m_dwTag);
}


//
//==============================================================================
//
//  CAsnNull
//

IMPLEMENT_NEW(CAsnNull)


CAsnNull::CAsnNull(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnPrimitive(dwFlags, dwTag, type_Null)
{
    m_dwFlags |= fPresent;
}

void
CAsnNull::Clear(
    void)
{
    CAsnPrimitive::Clear();
    m_dwFlags |= fPresent;
}

LONG
CAsnNull::Write(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrcLen)
{
    if (0 == cbSrcLen)
    {
        if (NULL != m_pasnParent)
            m_pasnParent->ChildAction(act_Written, this);
        return 0;
    }
    else
    {
        TRACE("Attempt to write data to a NULL")
        return -1; // ?error? invalid length
    }
}

CAsnObject *
CAsnNull::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnNull(dwFlags, m_dwTag);
}

LONG
CAsnNull::DecodeData(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrc,
    IN DWORD dwLength)
{
    if (0 != dwLength)
    {
        TRACE("NULL datum has non-zero length")
        return -1;  // ?error? Invalid length.
    }
    return CAsnPrimitive::DecodeData(pbSrc, cbSrc, dwLength);
}


//
//==============================================================================
//
//  CAsnObjectIdentifier
//

IMPLEMENT_NEW(CAsnObjectIdentifier)


CAsnObjectIdentifier::CAsnObjectIdentifier(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnPrimitive(dwFlags, dwTag, type_ObjectIdentifier)
{ /* Force type type to type_ObjectIdentifier */ }

CAsnObjectIdentifier::operator LPCTSTR(
    void)
const
{
    TCHAR numbuf[36];
    DWORD dwVal, dwLength, index;
    BYTE c;
    LPBYTE pbValue;

    switch (State())
    {
    case fill_Empty:
    case fill_Optional:
        TRACE("Incomplete OBJECT IDENTIFIER")
        return NULL;    // ?error? Incomplete value.
        break;

    case fill_Defaulted:
        dwLength = m_bfDefault.Length();
        pbValue = m_bfDefault.Access();
        break;

    case fill_Present:
        dwLength = m_bfData.Length();
        pbValue = m_bfData.Access();
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        return NULL;
        break;
    }

    ASSERT(0 < dwLength);    // Invalid Object Id.

    if (NULL == pbValue)
    {
        ASSERT(FALSE);  // ?error? Invalid object
        return NULL;
    }

    dwVal = *pbValue / 40;
    _ultoa(dwVal, ( char * )numbuf, 10);
    if (NULL == ((CAsnObjectIdentifier *)this)->m_bfText.Set(
                                                             (LPBYTE)numbuf, strlen( ( char * )numbuf) * sizeof(CHAR)))
        goto ErrorExit;

    dwVal = *pbValue % 40;
    _ultoa(dwVal, ( char * )numbuf, 10);
    if (NULL == ((CAsnObjectIdentifier *)this)->m_bfText.Append(
                                                                (LPBYTE)".", sizeof(CHAR)))
        goto ErrorExit;

    if (NULL == ((CAsnObjectIdentifier *)this)->m_bfText.Append(
                                                                (LPBYTE)numbuf, strlen( ( char * )numbuf) * sizeof(CHAR)))
        goto ErrorExit;

    dwVal = 0;
    for (index = 1; index < dwLength; index += 1)
    {
        c = pbValue[index];
        dwVal = (dwVal << 7) + (c & 0x7f);
        if (0 == (c & 0x80))
        {
            _ultoa(dwVal, ( char * )numbuf, 10);
            if (NULL == ((CAsnObjectIdentifier *)this)->m_bfText.Append(
                                                                        (LPBYTE)".", sizeof(CHAR)))
                goto ErrorExit;

            if (NULL == ((CAsnObjectIdentifier *)this)->m_bfText.Append(
                                                                        (LPBYTE)numbuf, strlen( ( char * )numbuf) * sizeof(CHAR)))
                goto ErrorExit;

            dwVal = 0;
        }
    }
    if (NULL == ((CAsnObjectIdentifier *)this)->m_bfText.Append(
                                                                (LPBYTE)"", sizeof(CHAR)))
        goto ErrorExit;

    return (LPTSTR)m_bfText.Access();

ErrorExit:
    return NULL;
}



LPCTSTR
CAsnObjectIdentifier::operator =(
    IN LPCTSTR szValue)
{
    BYTE oidbuf[sizeof(DWORD) * 2];
    DWORD dwVal1, dwVal2;
    LPCTSTR sz1, sz2;
    CBuffer bf;

    if (NULL == bf.Presize(strlen( ( char * )szValue)))
        return NULL;    // ?error? No memory
    sz1 = szValue;
    dwVal1 = strtoul( ( char * )sz1, (LPSTR *)&sz2, 0);
    if (TEXT('.') != *sz2)
    {
        TRACE("OBJECT ID contains strange character '" << *sz2 << "'.")
        return NULL;    // ?error? invalid Object Id string.
    }
    sz1 = sz2 + 1;
    dwVal2 = strtoul( ( char * )sz1, (LPSTR *)&sz2, 0);
    if ((TEXT('.') != *sz2) && (0 != *sz2))
    {
        TRACE("OBJECT ID contains strange character '" << *sz2 << "'.")
        return NULL;    // ?error? invalid Object Id string.
    }
    dwVal1 *= 40;
    dwVal1 += dwVal2;
    if (127 < dwVal1)
    {
        TRACE("OBJECT ID Leading byte is too big")
        return NULL;    // ?error? invalid Object Id string.
    }
    *oidbuf = (BYTE)dwVal1;
    if (NULL == bf.Set(oidbuf, 1))
        goto ErrorExit;

    while (TEXT('.') == *sz2)
    {
        sz1 = sz2 + 1;
        dwVal1 = strtoul( ( char * )sz1, (LPSTR *)&sz2, 0);

        dwVal2 = sizeof(oidbuf);
        oidbuf[--dwVal2] = (BYTE)(dwVal1 & 0x7f);
        for (;;)
        {
            dwVal1 = (dwVal1 >> 7) & 0x01ffffff;
            if ((0 == dwVal1) || (0 == dwVal2))
                break;

            oidbuf[--dwVal2] = (BYTE)((dwVal1 & 0x7f) | 0x80);
        }

        if (NULL == bf.Append(&oidbuf[dwVal2], sizeof(oidbuf) - dwVal2))
            goto ErrorExit;
    }
    if (0 != *sz2)
    {
        TRACE("OBJECT ID contains strange character '" << *sz2 << "'.")
        return NULL;    // ?error? invalid Object Id string.
    }

    if (0 > Write(bf.Access(), bf.Length()))
        return NULL;    // ?error? forwarding underlying error.
    return szValue;

ErrorExit:
    return NULL;
}

CAsnObject *
CAsnObjectIdentifier::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnObjectIdentifier(dwFlags, m_dwTag);
}


//
//==============================================================================
//
//  CAsnReal
//

IMPLEMENT_NEW(CAsnReal)


CAsnReal::CAsnReal(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnPrimitive(dwFlags, dwTag, type_Real)
{ /* Force the type to type_Real */ }

CAsnReal::operator double(
    void)
const
{
    // ?todo?
    return 0.0;
}

double
CAsnReal::operator =(
    double rValue)
{
    // ?todo?
    return 0.0;
}

CAsnObject *
CAsnReal::Clone(              // Create an identical object type.
    IN DWORD dwFlags)
const
{
    return new CAsnReal(dwFlags, m_dwTag);
}


//
//==============================================================================
//
//  CAsnEnumerated
//

IMPLEMENT_NEW(CAsnEnumerated)


CAsnEnumerated::CAsnEnumerated(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnPrimitive(dwFlags, dwTag, type_Enumerated)
{ /* Force the type to type_Enumerated */ }

// ?todo?  What's this?

CAsnObject *
CAsnEnumerated::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnEnumerated(dwFlags, m_dwTag);
}


//
//==============================================================================
//
//  CAsnSequence
//

IMPLEMENT_NEW(CAsnSequence)


CAsnSequence::CAsnSequence(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnConstructed(dwFlags, dwTag, type_Sequence)
{ /* Force the type to type_Sequence */ }


//
//==============================================================================
//
//  CAsnSequenceOf
//

IMPLEMENT_NEW(CAsnSequenceOf)


CAsnSequenceOf::CAsnSequenceOf(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnSeqsetOf(dwFlags, dwTag, type_SequenceOf)
{ /* Force the type to type_SequenceOf */ }


//
//==============================================================================
//
//  CAsnSet
//

IMPLEMENT_NEW(CAsnSet)


CAsnSet::CAsnSet(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnConstructed(dwFlags, dwTag, type_Set)
{ /* Force the type to type_Set */ }


//
//==============================================================================
//
//  CAsnSetOf
//

IMPLEMENT_NEW(CAsnSetOf)


CAsnSetOf::CAsnSetOf(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnSeqsetOf(dwFlags, dwTag, type_SetOf)
{ /* Force the type to type_SetOf */ }


//
//==============================================================================
//
//  CAsnTag
//

IMPLEMENT_NEW(CAsnTag)


CAsnTag::CAsnTag(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnConstructed(dwFlags, dwTag, type_Tag)
{ /* Force the type to type_Tag */ }

void
CAsnTag::Reference(
    CAsnObject *pasn)
{
    ASSERT(0 == m_rgEntries.Count());
    m_rgEntries.Add(pasn);
}

CAsnObject *
CAsnTag::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnTag(dwFlags, m_dwTag);
}

LONG
CAsnTag::DataLength(
    void) const
{
    CAsnObject *pasn = m_rgEntries[0];
    ASSERT(NULL != pasn);

    if (pasn == NULL)
        return NULL;

    return pasn->DataLength();
}

LONG
CAsnTag::Read(
    OUT LPBYTE pbDst)
const
{
    CAsnObject *pasn = m_rgEntries[0];
    ASSERT(NULL != pasn);

    if (pasn == NULL)
        return NULL;

    return pasn->Read(pbDst);
}


LONG
CAsnTag::Write(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrcLen)
{
    CAsnObject *pasn = m_rgEntries[0];
    ASSERT(NULL != pasn);

    if (pasn == NULL)
        return NULL;

    return pasn->Write(pbSrc, cbSrcLen);
}


//
//==============================================================================
//
//  CAsnChoice
//

IMPLEMENT_NEW(CAsnChoice)


/*++

CAsnChoice:

    This is the construction routine for a CAsnChoice.

Arguments:

    dwFlags supplies any special flags for this object.  Options are:

        fOptional implies the object is optional.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

CAsnChoice::CAsnChoice(
        IN DWORD dwFlags)
:   CAsnObject(dwFlags, tag_Undefined, type_Choice)
{
    m_nActiveEntry = (DWORD)(-1);
    m_dwDefaultTag = tag_Undefined;
}


/*++

Tag:

    This routine returns the tag value of the object.

Arguments:

    None

Return Value:

    The tag, if known, or zero if not.

Author:

    Doug Barlow (dbarlow) 10/6/1995

--*/

DWORD
CAsnChoice::Tag(
    void)
const
{
    DWORD result;

    switch (State())
    {
    case fill_Empty:
    case fill_Optional:
        result = tag_Undefined; // ?error? Undefined tag
        break;

    case fill_Defaulted:
        result = m_dwDefaultTag;
        break;

    case fill_Partial:
    case fill_Present:
        result = m_rgEntries[m_nActiveEntry]->Tag();
        break;

    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        result = tag_Undefined;
        break;
    }
    return result;
}


/*++

DataLength:

    This routine returns the length of the local machine encoding of the data of
    an object.

Arguments:

    None

Return Value:

    If >=0, the length of the data portion of this object.
    if < 0, an error occurred.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnChoice::DataLength(
    void)
const
{
    LONG lth;

    switch (State())
    {
    case fill_Empty:
    case fill_Partial:
    case fill_Optional:
    case fill_NoElements:
        TRACE("Incomplete CHOICE")
        lth =  -1;  // ?error? incomplete structure.
        break;

    case fill_Defaulted:
        lth = m_bfDefault.Length();
        break;

    case fill_Present:
        lth = m_rgEntries[m_nActiveEntry]->DataLength();
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}


/*++

Read:

    Read the value of the object.

Arguments:

    bfDst receives the value.
    pbDst receives the value.  It is assumed to be long enough.

Return Value:

    If >=0, the length of the data portion of this object.
    if < 0, an error occurred.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnChoice::Read(
    OUT LPBYTE pbDst)
    const
{
    LONG lth;

    switch (State())
    {
    case fill_Empty:
    case fill_Partial:
    case fill_NoElements:
        TRACE("Incomplete CHOICE")
        lth =  -1;  // ?error? incomplete structure.
        break;

    case fill_Optional:
        lth = 0;
        break;

    case fill_Defaulted:
        lth = m_bfDefault.Length();
        memcpy(pbDst, m_bfDefault.Access(), lth);
        break;

    case fill_Present:
        lth = m_rgEntries[m_nActiveEntry]->Read(pbDst);
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}


/*++

Write:

    This method examines the tag of the presented data, and forwards it to the
    right choice.

Arguments:

    pbSrc supplies the data as a BYTE array, with
    cbSrcLen supplies the length of the pbSrc Array.

Return Value:

    If >=0, the length of the data portion of this object.
    if < 0, an error occurred.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnChoice::Write(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrcLen)
{
    LONG lth;
    Clear();
    lth = _decode(pbSrc,cbSrcLen);
    if ((0 < lth) && ((DWORD)lth == cbSrcLen))
        return lth;
    else
    {
        TRACE("CHOICE Buffer length error")
        return -1;  // ?error? Buffer mismatch.
    }
}


/*++

EncodingLength:

    This method returns the length of the object in its ASN.1 encoding.

Arguments:

    None

Return Value:

    >= 0 is the length of the object's ASN.1 encoding.
    < 0 implies an error.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnChoice::_encLength(
    void) const
{
    LONG lth;

    switch (m_State)
    {
    case fill_Partial:
    case fill_Empty:
    case fill_NoElements:
        lth = -1;       // ?error? Incomplete structure
        break;

    case fill_Optional:
    case fill_Defaulted:
        lth = 0;
        break;

    case fill_Present:
        lth = m_rgEntries[m_nActiveEntry]->_encLength();
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}


/*++

Decode:

    This method examines the tag of the presented data, and forwards it to the
    right choice.

Arguments:

    pbSrc supplies the ASN.1 encoding in an LPBYTE format.
    bfSrc supplies the ASN.1 encoding in a CBuffer format.

Return Value:

    >= 0 is the number of bytes consumed by the decoding.
    < 0 implies an error occurred.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnChoice::_decode(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrc)
{
    DWORD tag, length, index;
    LONG lth, lTotal = 0;
    BOOL fImplicit, fConstr;
    CAsnObject *pasn;
    DWORD count = m_rgEntries.Count();

    lth = ExtractTag(&pbSrc[lTotal], cbSrc - lTotal, &tag, &fConstr);
    if (0 > lth)
        goto ErrorExit;
    lTotal += lth;

    lth = ExtractLength(&pbSrc[lTotal], cbSrc - lTotal, &length, &fImplicit);
    if (0 > lth)
        goto ErrorExit;
    lTotal += lth;

    for (index = 0; index < count; index += 1)
    {
        pasn = m_rgEntries[index];
        if (NULL != pasn)
        {
            if ((tag == pasn->m_dwTag)
                && (fConstr == (0 != (pasn->m_dwFlags & fConstructed))))
            {
                lth = pasn->DecodeData(&pbSrc[lTotal], cbSrc - lTotal, length);
                if (0 > lth)
                    goto ErrorExit;
                lTotal += lth;
                break;
            }
        }
    }
    if (index == count)
    {
        TRACE("Unrecognized Tag in input stream")
        lth = -1;   // ?error? Unrecognized tag
        goto ErrorExit;
    }

    if (m_nActiveEntry != index)
    {
        // This may have been done already by the action callback.
        pasn = m_rgEntries[m_nActiveEntry];
        if (NULL != pasn)
            pasn->Clear();  // That may do a callback, too.
        m_nActiveEntry = index;
    }
    return lTotal;

ErrorExit:
    return lth;
}


/*++

ChildAction:

    This method receives notification of actions from children.

Arguments:

    action supplies the action identifier.

    pasnChild supplies the child address.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/6/1995

--*/

void
CAsnChoice::ChildAction(
    IN ChildActions action,
    IN CAsnObject *pasnChild)
{
    DWORD index, count;
    CAsnObject *pasn;

    if (act_Written == action)
    {

        //
        // When a child entry gets written, make sure it becomes the active
        // entry.
        //

        count = m_rgEntries.Count();
        for (index = 0; index < count; index += 1)
        {
            pasn = m_rgEntries[index];
            if (pasnChild == pasn)
                break;
        }
        ASSERT(index != count);

        if (m_nActiveEntry != index)
        {
            pasn = m_rgEntries[m_nActiveEntry];
            if (NULL != pasn)
                pasn->Clear();  // That may do a callback, too.
            m_nActiveEntry = index;
        }
    }
    CAsnObject::ChildAction(action, this);
}


/*++

SetDefault:

    This protected method is used to declare data that was just decoded to be
    the default data for the object.

Arguments:

    None

Return Value:

    >= 0 The length of the default data.
    < 0 implies an error.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnChoice::SetDefault(
    void)
{
    LONG lth;
    CAsnObject *pasn = m_rgEntries[m_nActiveEntry];
    ASSERT(NULL != pasn);

    if (pasn == NULL)
        return -1;

    m_dwDefaultTag = pasn->Tag();
    lth = CAsnObject::SetDefault();
    return lth;
}


/*++

State:

    This routine checks to see if a structure is completely filled in.

Arguments:

    None

Return Value:

    fill_Empty   - There is no added data anywhere in the structure.
    fill_Present - All the data is present in the structure (except maybe
                   defaulted or optional data).
    fill_Partial - Not all of the data is there, but some of it is.
    fill_Defauted - No data has been written, but a default value is available.
    fill_Optional - No data has been written, but the object is optional.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

CAsnObject::FillState
CAsnChoice::State(
    void) const
{
    FillState result;
    if (m_nActiveEntry >= m_rgEntries.Count())
    {
        if (0 != (fOptional & m_dwFlags))
            result = fill_Optional;
        else if (0 != (fDefault & m_dwFlags))
            result = fill_Defaulted;
        else
            result = fill_Empty;
    }
    else
        result = m_rgEntries[m_nActiveEntry]->State();
    ((CAsnChoice *)this)->m_State = result;
    return result;
}


/*++

Compare:

    This method compares this ASN.1 Object to another.

Arguments:

    asnObject supplies the other object for comparison.

Return Value:

    A value indicating a comparitive value:
    < 0 - This object is less than that object.
    = 0 - This object is the same as that object.
    > 0 - This object is more than that object.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnChoice::Compare(
    const CAsnObject &asnObject)
const
{
    LONG lth;

    switch (State())
    {
    case fill_Empty:
    case fill_Partial:
    case fill_Optional:
    case fill_NoElements:
    case fill_Defaulted:
        lth = 0x0100;   // ?error? Incapable of comparing.
        break;

    case fill_Present:
        lth = m_rgEntries[m_nActiveEntry]->Compare(asnObject);
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = 0x0100;
        break;
    }
    return lth;
}


/*++

Copy:

    This method replaces the contents of this ASN.1 Object with another.  The
    objects must be identical structures.  Tags and defaults are not duplicated.

Arguments:

    asnObject supplies the source object.

Return Value:

    >= 0 Is the number of bytes actually copied
    < 0 is an error.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnChoice::_copy(
    const CAsnObject &asnObject)
{
    LONG lth = -1;
    CAsnObject *pasn;
    DWORD tag, index;
    DWORD count = m_rgEntries.Count();

    tag = asnObject.Tag();
    for (index = 0; index < count; index += 1)
    {
        pasn = m_rgEntries[index];
        if (NULL != pasn)
        {
            if (tag == pasn->Tag())
            {
                lth = pasn->_copy(asnObject);
                if (0 > lth)
                    goto ErrorExit;
                break;
            }
        }
    }
    if (index == count)
    {
        TRACE("CHOICE's don't match in a Copy")
        lth = -1;   // ?error? Unrecognized tag
        goto ErrorExit;
    }

    m_nActiveEntry = index;
    return lth;

ErrorExit:
    return lth;
}


/*++

EncodeTag:

    This method encodes the tag of the object into the supplied buffer.

Arguments:

    pbDst receives the ASN.1 encoding of the tag.

Return Value:

    >= 0 is the length of the tag.
    < 0 is an error.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnChoice::EncodeTag(
    OUT LPBYTE pbDst)
const
{
    LONG lth;

    switch (m_State)
    {
    case fill_Empty:
    case fill_Partial:
        lth = -1;       // ?error? Incomplete structure
        break;

    case fill_Optional:
    case fill_Defaulted:
        lth = 0;
        break;

    case fill_Present:
    case fill_NoElements:
        lth = m_rgEntries[m_nActiveEntry]->EncodeTag(pbDst);
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}


/*++

EncodeLength:

    This method encodes the definite length of the object into the supplied
    buffer.

Arguments:

    pbDst receives the ASN.1 encoding of the length.

Return Value:

    >= 0 is the length of the resultant encoding
    < 0 is an error.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnChoice::EncodeLength(
    OUT LPBYTE pbDst)
const
{
    LONG lth;

    switch (m_State)
    {
    case fill_Empty:
    case fill_Partial:
        lth = -1;       // ?error? Incomplete Structure
        break;

    case fill_Optional:
    case fill_Defaulted:
    case fill_NoElements:
        lth = 0;
        break;

    case fill_Present:
        lth = m_rgEntries[m_nActiveEntry]->EncodeLength(pbDst);
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}


/*++

EncodeData:

    This method encodes the data into the supplied buffer.

Arguments:

    pbDst

Return Value:

    >= 0 is the length of the encoding.
    < 0 is an error

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnChoice::EncodeData(
    OUT LPBYTE pbDst)
const
{
    LONG lth;

    switch (m_State)
    {
    case fill_Empty:
    case fill_Partial:
        lth = -1;       // ?error? Incomplete structure
        break;

    case fill_Optional:
    case fill_Defaulted:
    case fill_NoElements:
        lth = 0;
        break;

    case fill_Present:
        lth = m_rgEntries[m_nActiveEntry]->EncodeData(pbDst);
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}


/*++

DecodeData:

    This routine decodes the data portion of the ASN.1.  The tag and length have
    already been removed.

Arguments:

    pbSrc supplies the address of the ASN.1 encoding of the data.

    dwLength supplies the length of the data.


Return Value:

    >= 0 - The number of bytes removed from the input stream.
    <  0 - An error occurred.

Author:

    Doug Barlow (dbarlow) 10/6/1995

--*/

LONG
CAsnChoice::DecodeData(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrc,
    IN DWORD dwLength)
{
    CAsnObject *pasn = m_rgEntries[m_nActiveEntry];
    ASSERT(NULL != pasn);

    if (NULL == pasn)
        return -1;

    return pasn->DecodeData(pbSrc, cbSrc, dwLength);
}


//
//==============================================================================
//
//  CAsnAny
//

IMPLEMENT_NEW(CAsnAny)


CAsnAny::CAsnAny(
    IN DWORD dwFlags)
:   CAsnObject(dwFlags, tag_Undefined, type_Any),
    m_bfData()
{
    m_rgEntries.Add(this);
}

void
CAsnAny::Clear(
    void)
{
    m_bfData.Reset();
    m_dwFlags &= ~fPresent;
    m_dwTag = m_dwDefaultTag = tag_Undefined;
    if (NULL != m_pasnParent)
        m_pasnParent->ChildAction(act_Cleared, this);
}

DWORD
CAsnAny::Tag(
    void)
const
{
    DWORD result;

    switch (State())
    {
    case fill_Present:
    case fill_NoElements:
        result = m_dwTag;
        break;
    case fill_Defaulted:
        result = m_dwDefaultTag;
        break;
    case fill_Optional:
        result = tag_Undefined;
        break;
    default:
        result = tag_Undefined; // ?error? Not complete.
        break;
    }
    return result;
}

LONG
CAsnAny::DataLength(
    void) const
{
    LONG lth;

    switch (State())
    {
    case fill_Present:
        lth = m_bfData.Length();
        break;
    case fill_Defaulted:
        lth = m_bfDefault.Length();
        break;
    case fill_Optional:
    case fill_NoElements:
        lth = 0;
        break;
    default:
        lth = -1;   // ?error? Not complete.
        break;
    }
    return lth;
}

LONG
CAsnAny::Read(
    OUT LPBYTE pbDst)
    const
{
    LONG lth;

    switch (State())
    {
    case fill_Empty:
    case fill_Partial:
    case fill_Optional:
        TRACE("Incomplete ANY")
        lth = -1;  // ?Error? Incomplete data
        break;

    case fill_Defaulted:
        lth = m_bfDefault.Length();
        memcpy(pbDst, m_bfDefault.Access(), lth);
        break;

    case fill_Present:
    case fill_NoElements:
        lth = m_bfData.Length();
        memcpy(pbDst, m_bfData.Access(), lth);
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}

LONG
CAsnAny::Write(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrcLen)
{
    TRACE("Writing to an ANY without specifying a Tag")
    return -1;  // ?error? No tag.
}

CAsnObject &
CAsnAny::operator =(
    IN const CAsnObject &asnValue)
{
    LONG lth;

    m_bfData.Reset();
    lth = asnValue.EncodingLength();
    if (0 < lth)
    {
        if (NULL == m_bfData.Resize(lth))
            goto ErrorExit;

        lth = asnValue.EncodeData(m_bfData.Access());
        ASSERT(0 <= lth);

        if (NULL == m_bfData.Resize(lth, TRUE))
            goto ErrorExit;
    }
    m_dwFlags |= fPresent | (asnValue.m_dwFlags & fConstructed);
    m_dwTag = asnValue.Tag();
    if (NULL != m_pasnParent)
        m_pasnParent->ChildAction(act_Written, this);
    return *this;

ErrorExit:
    ASSERT(FALSE);
    return *this;
}

LONG
CAsnAny::Cast(
    OUT CAsnObject &asnObj)
{
    LONG lth;

    asnObj.m_dwTag = m_dwTag;
    lth = asnObj.DecodeData(m_bfData.Access(), m_bfData.Length(), m_bfData.Length());
    return lth;
}

LONG
CAsnAny::_encLength(
    void) const
{
    BYTE rge[32];
    LONG lTotal = 0;
    LONG lth;

    switch (m_State)
    {
    case fill_Empty:
    case fill_Partial:
        lth = -1;       // ?error? Incomplete structure
        goto ErrorExit;
        break;

    case fill_Optional:
    case fill_Defaulted:
    case fill_NoElements:
        lTotal = 0;
        break;

    case fill_Present:
        lth = EncodeTag(rge);
        if (0 > lth)
            goto ErrorExit;
        lTotal += lth;
        lth = CAsnObject::EncodeLength(rge, m_bfData.Length());
        if (0 > lth)
            goto ErrorExit;
        lTotal += lth;
        lTotal += m_bfData.Length();
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        goto ErrorExit;
        break;
    }
    return lTotal;

ErrorExit:
    return lth;
}

LONG
CAsnAny::_decode(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrc)
{
    LONG lth;
    LONG lTotal = 0;
    DWORD length;
    BOOL fIndefinite, fConstr;
    DWORD tag;


    //
    // Extract the Tag.
    //

    lth = ExtractTag(&pbSrc[lTotal], cbSrc-lTotal, &tag, &fConstr);
    if (0 > lth)
        goto ErrorExit; // ?error? propagate error
    ASSERT(0 != tag);
    m_dwTag = tag;
    lTotal += lth;


    //
    // Extract the length.
    //

    lth = ExtractLength(&pbSrc[lTotal], cbSrc-lTotal, &length, &fIndefinite);
    if (0 > lth)
        goto ErrorExit;
    if (fIndefinite && !fConstr)
    {
        TRACE("Indefinite Length on Primitive Object")
        lth = -1;   // ?error? - Indefinite length on primitive object
        goto ErrorExit;
    }
    lTotal += lth;


    //
    // Extract the data.
    //

    lth = DecodeData(&pbSrc[lTotal], cbSrc-lTotal, length);
    if (0 > lth)
        goto ErrorExit;
    lTotal += lth;


    //
    // Extract any trailing tag.
    //

    if (fIndefinite)
    {
        lth = ExtractTag(&pbSrc[lTotal], cbSrc-lTotal, &tag);
        if (0 > lth)
            goto ErrorExit;
        if (0 != tag)
        {
            TRACE("NON-ZERO Tag on expected Indefinite Length Terminator")
            lth = -1;   // ?Error? Bad indefinite length encoding.
            goto ErrorExit;
        }
        lTotal += lth;
    }


    //
    // Return the status.
    //

    if (fConstr)
        m_dwFlags |= fConstructed;
    else
        m_dwFlags &= ~fConstructed;
    return lTotal;

ErrorExit:
    return lth;
}

CAsnObject *
CAsnAny::Clone(
    DWORD dwFlags)
const
{
    return new CAsnAny(dwFlags);
}

CAsnObject::FillState
CAsnAny::State(
    void) const
{
    FillState result;

    if (0 != (fPresent & m_dwFlags))
        result = fill_Present;
    else if (0 != (m_dwFlags & fOptional))
        result = fill_Optional;
    else if (0 != (m_dwFlags & fDefault))
        result = fill_Defaulted;
    else
        result = fill_Empty;
    ((CAsnAny *)this)->m_State = result;
    return result;
}

LONG
CAsnAny::Compare(
    const CAsnObject &asnObject)
const
{
    const CAsnAny *
        pasnAny;
    const CBuffer
        *pbfThis,
        *pbfThat;
    LONG
        result;


    if (type_Any != asnObject.m_dwType)
    {
        TRACE("No support for Non-ANY comparisons yet.")
        goto ErrorExit;
    }
    pasnAny = (CAsnAny *)&asnObject;

    switch (m_State)
    {
    case fill_Empty:
    case fill_Partial:
        TRACE("Incomplete Structure in Comparison")
        goto ErrorExit; // ?error? Incomplete structure
        break;

    case fill_Optional:
        pbfThis = NULL;
        break;

    case fill_Defaulted:
        pbfThis = &m_bfDefault;
        break;

    case fill_NoElements:
    case fill_Present:
        pbfThis = &m_bfData;
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        goto ErrorExit;
        break;
    }

    switch (pasnAny->m_State)
    {
    case fill_Empty:
    case fill_Partial:
        TRACE("Incomplete Structure in Comparison")
        goto ErrorExit; // ?error? Incomplete structure

    case fill_Optional:
        pbfThat = NULL;
        break;

    case fill_Defaulted:
        pbfThat = &pasnAny->m_bfDefault;
        break;

    case fill_NoElements:
    case fill_Present:
        pbfThat = &pasnAny->m_bfData;
        break;

    default:
        ASSERT(FALSE)   // ?error? Internal error
        goto ErrorExit;
        break;
    }

    if ((NULL == pbfThis) && (NULL == pbfThat))
        return 0;   // They're both optional and missing.
    else if (NULL == pbfThis)
        return -(*pbfThat->Access());
    else if (NULL == pbfThat)
        return *pbfThis->Access();

    if (Tag() != pasnAny->Tag())
    {
        TRACE("Tags don't match in ANY Comparison")
        goto ErrorExit;
    }

    if (pbfThis->Length() > pbfThat->Length())
        result = (*pbfThis)[pbfThat->Length()];
    else if (pbfThis->Length() < pbfThat->Length())
        result = -(*pbfThat)[pbfThis->Length()];
    else
        result = memcmp(pbfThis->Access(), pbfThat->Access(), pbfThis->Length());

    return result;

ErrorExit:
    return 0x100;
}

LONG
CAsnAny::_copy(
    const CAsnObject &asnObject)
{
    const CAsnAny *
        pasnAny;
    const CBuffer
        *pbfThat
            = NULL;
    LONG
        lth
            = 0;

    if (type_Any != asnObject.m_dwType)
    {
        TRACE("No support for Non-ANY copies yet.")
        goto ErrorExit;
    }
    pasnAny = (CAsnAny *)&asnObject;

    switch (pasnAny->m_State)
    {
    case fill_Empty:
    case fill_Partial:
        goto ErrorExit; // ?error? Incomplete structure
        break;

    case fill_Optional:
        if (0 == (m_dwFlags & fOptional))
            goto ErrorExit;     // ?error? Optionality mismatch
        break;

    case fill_Defaulted:
        if (0 == (m_dwFlags & fDefault))
            pbfThat = &pasnAny->m_bfDefault;
        break;

    case fill_NoElements:
    case fill_Present:
        pbfThat = &pasnAny->m_bfData;
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        goto ErrorExit;
        break;
    }

    if (NULL != pbfThat)
    {
        m_bfData = *pbfThat;
        if (m_bfData.Length() != pbfThat->Length())
            return -1;
        m_dwFlags |= fPresent | (pasnAny->m_dwFlags & fConstructed);
        m_dwTag = pasnAny->Tag();
        if (NULL != m_pasnParent)
            m_pasnParent->ChildAction(act_Written, this);
    }
    return lth;

ErrorExit:
    return -1;
}

LONG
CAsnAny::EncodeLength(
    OUT LPBYTE pbDst)
const
{
    LONG lth;

    switch (m_State)
    {
    case fill_Empty:
    case fill_Partial:
        lth = -1;   // ?error? Incomplete Structure
        break;

    case fill_Optional:
    case fill_Defaulted:
        lth = 0;
        break;

    case fill_NoElements:
    case fill_Present:
        lth = CAsnObject::EncodeLength(pbDst, m_bfData.Length());
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}

LONG
CAsnAny::EncodeData(
    OUT LPBYTE pbDst)
const
{
    LONG lth;

    switch (m_State)
    {
    case fill_Empty:
    case fill_Partial:
        lth = -1;       // ?error? Incomplete structure
        break;

    case fill_Optional:
    case fill_Defaulted:
    case fill_NoElements:
        lth = 0;
        break;

    case fill_Present:
        lth = m_bfData.Length();
        if( lth )
        {
            memcpy(pbDst, m_bfData.Access(), lth);
        }
        break;

    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}

LONG
CAsnAny::SetDefault(
    void)
{
    LONG lth;
    ASSERT(0 != (m_dwFlags & fPresent));
    ASSERT(tag_Undefined != m_dwTag);
    m_dwDefaultTag = m_dwTag;
    lth = CAsnObject::SetDefault();
    return lth;
}

LONG
CAsnAny::DecodeData(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrc,
    IN DWORD cbSrcLen)
{
    ASSERT(tag_Undefined != m_dwTag);
    if (0 < cbSrcLen)
    {
        if (cbSrc < cbSrcLen)
            return -1;

        if (NULL == m_bfData.Set(pbSrc, cbSrcLen))
            return -1;  // ?error? no memory.
    }
    else
        m_bfData.Reset();
    m_dwFlags |= fPresent;
    if (NULL != m_pasnParent)
        m_pasnParent->ChildAction(act_Written, this);
    return m_bfData.Length();
}


/*++

TypeCompare:

    This routine compares the entire structure of an Object to another Object.

Arguments:

    asn - The other object.

Return Value:

    TRUE - They are identical
    FALSE - They differ

Author:

    Doug Barlow (dbarlow) 10/19/1995

--*/

BOOL
CAsnAny::TypeCompare(
    const CAsnObject &asnObject)
const
{
    return (m_dwType == asnObject.m_dwType);
}


//
//==============================================================================
//
//  String Types
//

IMPLEMENT_NEW(CAsnNumericString)

CAsnNumericString::CAsnNumericString(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnTextString(dwFlags, dwTag, type_NumericString)
{
    // ?todo? Identify m_pbmValidChars
}

CAsnObject *
CAsnNumericString::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnNumericString(dwFlags, m_dwTag);
}


IMPLEMENT_NEW(CAsnPrintableString)

CAsnPrintableString::CAsnPrintableString(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnTextString(dwFlags, dwTag, type_PrintableString)
{
    // ?todo? Identify m_pbmValidChars
}

CAsnObject *
CAsnPrintableString::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnPrintableString(dwFlags, m_dwTag);
}


IMPLEMENT_NEW(CAsnTeletexString)

CAsnTeletexString::CAsnTeletexString(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnTextString(dwFlags, dwTag, type_TeletexString)
{
    // ?todo? Identify m_pbmValidChars
}

CAsnObject *
CAsnTeletexString::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnTeletexString(dwFlags, m_dwTag);
}


IMPLEMENT_NEW(CAsnVideotexString)

CAsnVideotexString::CAsnVideotexString(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnTextString(dwFlags, dwTag, type_VideotexString)
{
    // ?todo? Identify m_pbmValidChars
}

CAsnObject *
CAsnVideotexString::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnVideotexString(dwFlags, m_dwTag);
}


IMPLEMENT_NEW(CAsnVisibleString)

CAsnVisibleString::CAsnVisibleString(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnTextString(dwFlags, dwTag, type_VisibleString)
{
    // ?todo? Identify m_pbmValidChars
}

CAsnObject *
CAsnVisibleString::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnVisibleString(dwFlags, m_dwTag);
}


IMPLEMENT_NEW(CAsnIA5String)

CAsnIA5String::CAsnIA5String(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnTextString(dwFlags, dwTag, type_IA5String)
{
    // ?todo? Identify m_pbmValidChars
}

CAsnObject *
CAsnIA5String::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnIA5String(dwFlags, m_dwTag);
}


IMPLEMENT_NEW(CAsnGraphicString)

CAsnGraphicString::CAsnGraphicString(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnTextString(dwFlags, dwTag, type_GraphicString)
{
    // ?todo? Identify m_pbmValidChars
}

CAsnObject *
CAsnGraphicString::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnGraphicString(dwFlags, m_dwTag);
}


IMPLEMENT_NEW(CAsnGeneralString)

CAsnGeneralString::CAsnGeneralString(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnTextString(dwFlags, dwTag, type_GeneralString)
{
    // ?todo? Identify m_pbmValidChars
}

CAsnObject *
CAsnGeneralString::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnGeneralString(dwFlags, m_dwTag);
}


IMPLEMENT_NEW(CAsnUnicodeString)

CAsnUnicodeString::CAsnUnicodeString(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnTextString(dwFlags, dwTag, type_UnicodeString)
{
    // ?todo? Identify m_pbmValidChars
}

CAsnObject *
CAsnUnicodeString::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnUnicodeString(dwFlags, m_dwTag);
}


//
//==============================================================================
//
//  CAsnGeneralizedTime
//

IMPLEMENT_NEW(CAsnGeneralizedTime)

CAsnGeneralizedTime::CAsnGeneralizedTime(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnVisibleString(dwFlags, dwTag)
{
    m_dwType = type_GeneralizedTime;
}


CAsnGeneralizedTime::operator FILETIME(
    void)
{
    LPSTR pc, pcDiff;
    DWORD size, index;
#if defined(OS_WINCE)
    size_t len;
#else
    SIZE_T len;
#endif

    SYSTEMTIME stm, stmDiff;
    FILETIME ftmDiff;
    char cDiff = 'Z';

    switch (State())
    {
    case fill_Empty:
    case fill_Optional:
        TRACE("Incomplete GeneralizedTime")
        goto ErrorExit; // ?error? Incomplete structure
        break;

    case fill_Defaulted:
        pc = (LPSTR)m_bfDefault.Access();
        size = m_bfDefault.Length();
        break;

    case fill_Present:
        pc = (LPSTR)m_bfData.Access();
        size = m_bfData.Length();
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        goto ErrorExit;
        break;
    }

    memset(&stm, 0, sizeof(stm));
    memset(&stmDiff, 0, sizeof(stmDiff));

                    //   YYYY  MM  DD  hh  mm  ss
    if (7 != sscanf(pc, "%4hd%2hd%2hd%2hd%2hd%2hd",
                &stm.wYear,
                &stm.wMonth,
                &stm.wDay,
                &stm.wHour,
                &stm.wMinute,
                &stm.wSecond,
                &cDiff))
        goto ErrorExit;
    index = 14;
    if (index < size)
    {
        if (('.' == pc[index]) || (',' == pc[index]))
        {

            //
            // There are milliseconds specified.
            //

            index += 1;
            stm.wMilliseconds = (WORD)strtoul(&pc[index], &pcDiff, 10);
            len = pcDiff - &pc[index];
            if ((len == 0) || (len > 3))
            {
                TRACE("Milliseconds with more than 3 digits: " << &pc[index])
                goto ErrorExit; // ?error? invalid millisecond value.
            }
            index += (DWORD)len;
            while (3 > len++)
                stm.wMilliseconds *= 10;
        }
    }

    if (!SystemTimeToFileTime(&stm, &m_ftTime))
    {
        TRACE("Time Conversion Error")
        goto ErrorExit; // ?error? conversion error
    }

    if (index < size)
    {
        cDiff = pc[index++];
        switch (cDiff)
        {
        case 'Z':   // Zulu Time -- no changes.
            break;

        case '+':   // Add the difference.
            if (size - index != 4)
            {
                TRACE("Invalid Time differential")
                goto ErrorExit; // ?error? Invalid time differential
            }
            if (2 != sscanf(&pc[index], "%2hd%2hd",
                        &stmDiff.wHour,
                        &stmDiff.wMinute))
                goto ErrorExit;
            if (!SystemTimeToFileTime(&stmDiff, &ftmDiff))
            {
                TRACE("Time conversion error")
                goto ErrorExit; // ?error? conversion error
            }
            FTINT(m_ftTime) += FTINT(ftmDiff);
            break;

        case '-':   // Subtract the difference
            if (size - index != 4)
            {
                TRACE("Invalid Time differential")
                goto ErrorExit; // ?error? Invalid time differential
            }
            if (2 != sscanf(&pc[index], "%2hd%2hd",
                        &stmDiff.wHour,
                        &stmDiff.wMinute))
                goto ErrorExit;
            if (!SystemTimeToFileTime(&stmDiff, &ftmDiff))
            {
                TRACE("Time conversion Error")
                goto ErrorExit; // ?error? conversion error
            }
            FTINT(m_ftTime) -= FTINT(ftmDiff);
            break;

        default:
            TRACE("Invalid Time differential Indicator")
            goto ErrorExit; // ?error? Invalid time format
        }
    }
    return m_ftTime;

ErrorExit:
    memset(&m_ftTime, 0, sizeof(FILETIME));
    return m_ftTime;
}

const FILETIME &
CAsnGeneralizedTime::operator =(
    const FILETIME &ftValue)
{
    LONG lth;
    char szTime[24];
    SYSTEMTIME stm;

    if (!FileTimeToSystemTime(&ftValue, &stm))
    {
        TRACE("Invalid Incoming Time")
        goto ErrorExit;     // ?error? Invalid incoming time.
    }
    sprintf(szTime,
            "%04d%02d%02d%02d%02d%02d.%03d",
            stm.wYear,
            stm.wMonth,
            stm.wDay,
            stm.wHour,
            stm.wMinute,
            stm.wSecond,
            stm.wMilliseconds);
    lth = strlen(szTime);
    ASSERT(18 == lth);
    lth = Write((LPBYTE)szTime, lth);
    if (0 > lth)
        goto ErrorExit;    // ?error? Propagate write error.
    return ftValue;

ErrorExit:
    memset(&m_ftTime, 0, sizeof(FILETIME));
    return m_ftTime;
}

CAsnObject *
CAsnGeneralizedTime::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnGeneralizedTime(dwFlags, m_dwTag);
}


//
//==============================================================================
//
//  CAsnUniversalTime
//

IMPLEMENT_NEW(CAsnUniversalTime)

CAsnUniversalTime::CAsnUniversalTime(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnVisibleString(dwFlags, dwTag)
{
    m_dwType = type_UniversalTime;
}


CAsnUniversalTime::operator FILETIME(
    void)
{
    LPCSTR pc;
    DWORD size;
    SYSTEMTIME stm, stmDiff;
    FILETIME ftmDiff;
    char cDiff;

    ASSERT(FALSE);      // We never use this function, as it uses two-year dates

    switch (State())
    {
    case fill_Empty:
    case fill_Optional:
        TRACE("Incomplete UniversalTime")
        goto ErrorExit; // ?error? Incomplete structure
        break;

    case fill_Defaulted:
        pc = (LPSTR)m_bfDefault.Access();
        size = m_bfDefault.Length();
        break;

    case fill_Present:
        pc = (LPSTR)m_bfData.Access();
        size = m_bfData.Length();
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        goto ErrorExit;
        break;
    }

    memset(&stm, 0, sizeof(stm));
    memset(&stmDiff, 0, sizeof(stmDiff));

    switch (size)
    {
    case 11:                // YY  MM  DD  hh  mm   Z
        if (6 != sscanf(pc, "%2hd%2hd%2hd%2hd%2hd%1hc",
                    &stm.wYear,
                    &stm.wMonth,
                    &stm.wDay,
                    &stm.wHour,
                    &stm.wMinute,
                    &cDiff))
            goto ErrorExit;
        break;

    case 13:                // YY  MM  DD  hh  mm  ss   Z
        if (7 != sscanf(pc, "%2hd%2hd%2hd%2hd%2hd%2hd%1hc",
                    &stm.wYear,
                    &stm.wMonth,
                    &stm.wDay,
                    &stm.wHour,
                    &stm.wMinute,
                    &stm.wSecond,
                    &cDiff))
            goto ErrorExit;
        break;

    case 15:                // YY  MM  DD  hh  mm   +  hh  mm
        if (8 != sscanf(pc, "%2hd%2hd%2hd%2hd%2hd%1hc%2hd%2hd",
                    &stm.wYear,
                    &stm.wMonth,
                    &stm.wDay,
                    &stm.wHour,
                    &stm.wMinute,
                    &cDiff,
                    &stmDiff.wHour,
                    &stmDiff.wMinute))
            goto ErrorExit;
        break;

    case 17:                // YY  MM  DD  hh  mm  ss  +  hh  mm
        if (9 != sscanf(pc, "%2hd%2hd%2hd%2hd%2hd%2hd%1hc%2hd%2hd",
                    &stm.wYear,
                    &stm.wMonth,
                    &stm.wDay,
                    &stm.wHour,
                    &stm.wMinute,
                    &stm.wSecond,
                    &cDiff,
                    &stmDiff.wHour,
                    &stmDiff.wMinute))
            goto ErrorExit;
        break;

    default:
        TRACE("Invalid Time String")
        goto ErrorExit; // ?error? Invalid time
    }

    if (50 < stm.wYear)
        stm.wYear += 1900;  // NB: we don't use two-character years
    else
        stm.wYear += 2000;
    if (!SystemTimeToFileTime(&stm, &m_ftTime))
    {
        TRACE("Time Conversion Error")
        goto ErrorExit; // ?error? conversion error
    }
    switch (cDiff)
    {
    case 'Z':   // Already UTC.
        break;

    case '+':   // Add the difference.
        if (!SystemTimeToFileTime(&stmDiff, &ftmDiff))
        {
            TRACE("Time Conversion Error")
            goto ErrorExit; // ?error? conversion error
        }
        FTINT(m_ftTime) += FTINT(ftmDiff);
        break;

    case '-':   // Subtract the difference
        if (!SystemTimeToFileTime(&stmDiff, &ftmDiff))
        {
            TRACE("Time Conversion Error")
            goto ErrorExit; // ?error? conversion error
        }
        FTINT(m_ftTime) -= FTINT(ftmDiff);
        break;

    default:
        TRACE("Invalid Time Format")
        goto ErrorExit; // ?error? Invalid time format
    }
    return m_ftTime;

ErrorExit:
    memset(&m_ftTime, 0, sizeof(FILETIME));
    return m_ftTime;
}

const FILETIME &
CAsnUniversalTime::operator =(
    const FILETIME &ftValue)
{
    LONG lth;
    char szTime[24];
    SYSTEMTIME stm;

    if (!FileTimeToSystemTime(&ftValue, &stm))
    {
        TRACE("Invalid incoming time")
        goto ErrorExit;     // ?error? Invalid incoming time.
    }
    sprintf(szTime,
            "%02d%02d%02d%02d%02d%02dZ",
            stm.wYear % 100,
            stm.wMonth,
            stm.wDay,
            stm.wHour,
            stm.wMinute,
            stm.wSecond);
    lth = strlen(szTime);
    ASSERT(13 == lth);
    lth = Write((LPBYTE)szTime, lth);
    if (0 > lth)
        goto ErrorExit;    // ?error? Propagate write error.
    return ftValue;

ErrorExit:
    memset(&m_ftTime, 0, sizeof(FILETIME));
    return m_ftTime;
}

CAsnObject *
CAsnUniversalTime::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnUniversalTime(dwFlags, m_dwTag);
}

//
//==============================================================================
//
//  CAsnObjectDescriptor
//

IMPLEMENT_NEW(CAsnObjectDescriptor)

CAsnObjectDescriptor::CAsnObjectDescriptor(
    IN DWORD dwFlags,
    IN DWORD dwTag)
: CAsnGraphicString(dwFlags, dwTag)
{
    m_dwType = type_ObjectDescriptor;
}

CAsnObject *
CAsnObjectDescriptor::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnObjectDescriptor(dwFlags, m_dwTag);
}


//
//==============================================================================
//
//  CAsnExternal
//

IMPLEMENT_NEW(CAsnExternal_Encoding_singleASN1Type)

CAsnExternal_Encoding_singleASN1Type::CAsnExternal_Encoding_singleASN1Type(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnTag(dwFlags, dwTag),
    _entry1(0)
{
    m_rgEntries.Set(0, &_entry1);
}

CAsnObject *
CAsnExternal_Encoding_singleASN1Type::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnExternal_Encoding_singleASN1Type(dwFlags, m_dwTag);
}


IMPLEMENT_NEW(CAsnExternal_Encoding)

CAsnExternal_Encoding::CAsnExternal_Encoding(
    IN DWORD dwFlags)
:   CAsnChoice(dwFlags),
    singleASN1Type(0, TAG(0)),
    octetAligned(0, TAG(1)),
    arbitrary(0, TAG(2))
{
    m_rgEntries.Set(0, &singleASN1Type);
    m_rgEntries.Set(1, &octetAligned);
    m_rgEntries.Set(2, &arbitrary);
}

CAsnObject *
CAsnExternal_Encoding::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnExternal_Encoding(dwFlags);
}


IMPLEMENT_NEW(CAsnExternal)

CAsnExternal::CAsnExternal(
    IN DWORD dwFlags,
    IN DWORD dwTag)
:   CAsnSequence(dwFlags, dwTag),
    directReference(fOptional),
    indirectReference(fOptional),
    dataValueDescriptor(fOptional),
    encoding(0)
{
    m_dwType = type_External;
    m_rgEntries.Set(0, &directReference);
    m_rgEntries.Set(1, &indirectReference);
    m_rgEntries.Set(2, &dataValueDescriptor);
    m_rgEntries.Set(3, &encoding);
}

CAsnObject *
CAsnExternal::Clone(
    IN DWORD dwFlags)
const
{
    return new CAsnExternal(dwFlags, m_dwTag);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\asn1\asnprimt.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    asnprimt

Abstract:

    This module provides the implementation of the ASN.1 Primitive Object base
    class.

Author:

    Doug Barlow (dbarlow) 10/8/1995

Environment:

    Win32

Notes:



--*/

#include <windows.h>
#include "asnPriv.h"


//
//==============================================================================
//
//  CAsnPrimitive
//

IMPLEMENT_NEW(CAsnPrimitive)

/*++

CAsnPrimitive:

    This is the constructor for a Primitve type ASN.1 encoding.

Arguments:

    dwType is the type of the object.

    dwFlags supplies any special flags for this object.  Options are:

        fOptional implies the object is optional.

    dwTag is the tag of the object.  If this is zero, the tag is taken from the
        type.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/6/1995

--*/

CAsnPrimitive::CAsnPrimitive(
        IN DWORD dwFlags,
        IN DWORD dwTag,
        IN DWORD dwType)
:   CAsnObject(dwFlags, dwTag, dwType),
    m_bfData()
{
    ASSERT(0 == (dwFlags & (fConstructed)));
    m_rgEntries.Add(this);
}


/*++

Clear:

    This method sets the primitive object to it's default state.  It does not
    affect the default setting.

Arguments:

    None

Return Value:

    none

Author:

    Doug Barlow (dbarlow) 10/6/1995

--*/

void
CAsnPrimitive::Clear(
    void)
{
    m_bfData.Reset();
    m_dwFlags &= ~fPresent;
    if (NULL != m_pasnParent)
        m_pasnParent->ChildAction(act_Cleared, this);
}


/*++

DataLength:

    This method returns the length of the local machine encoding of the data.
    For this general object, the local machine encoding and ASN.1 encoding are
    identical.

Arguments:

    None

Return Value:

    >= 0 - The length of the local machine encoding.

Author:

    Doug Barlow (dbarlow) 10/6/1995

--*/

LONG
CAsnPrimitive::DataLength(
    void)
const
{
    LONG lth;

    switch (State())
    {
    case fill_Empty:
    case fill_Optional:
        lth = -1;       // ?error? Incomplete Structure
        break;

    case fill_Defaulted:
        lth = m_bfDefault.Length();
        break;

    case fill_Present:
        lth = m_bfData.Length();
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}


/*++

Read:

    This default method provides the stored data.

Arguments:

    pbDst receives the value.  It is assumed to be long enough.

Return Value:

    If >=0, the length of the data portion of this object.
    if < 0, an error occurred.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnPrimitive::Read(
    OUT LPBYTE pbDst)
const
{
    LONG lth;

    switch (State())
    {
    case fill_Empty:
    case fill_Optional:
        lth = -1;       // ?error? Incomplete structure.
        break;

    case fill_Defaulted:
        lth = m_bfDefault.Length();
        memcpy(pbDst, m_bfDefault.Access(), lth);
        break;

    case fill_Present:
        lth = m_bfData.Length();
        memcpy(pbDst, m_bfData.Access(), lth);
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}


/*++

Write:

    This default implementation copies the provided data to our data buffer.

Arguments:

    pbSrc supplies the data as a BYTE array, with
    cbSrcLen supplies the length of the pbSrc Array.

Return Value:

    If >=0, the length of the data portion of this object.
    if < 0, an error occurred.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnPrimitive::Write(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrcLen)
{
    if (0 < cbSrcLen)
    {
        if (NULL == m_bfData.Set(pbSrc, cbSrcLen))
            return -1;
    }
    else
        m_bfData.Reset();
    m_dwFlags |= fPresent;
    if (NULL != m_pasnParent)
        m_pasnParent->ChildAction(act_Written, this);
    return m_bfData.Length();
}


/*++

EncodingLength:

    This method returns the length of the object in its ASN.1 encoding.

Arguments:

    None

Return Value:

    >= 0 is the length of the object's ASN.1 encoding.
    < 0 implies an error.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnPrimitive::_encLength(
    void) const
{
    BYTE rge[32];
    LONG lTotal = 0;
    LONG lth;


    switch (m_State)
    {
    case fill_Empty:
        lth = -1;       // ?error? Incomplete structure
        goto ErrorExit;
        break;

    case fill_Optional:
    case fill_Defaulted:
        lTotal = 0;
        break;

    case fill_Present:
        lth = EncodeTag(rge);
        if (0 > lth)
            goto ErrorExit;
        lTotal += lth;
        lth = EncodeLength(rge);
        if (0 > lth)
            goto ErrorExit;
        lTotal += lth;
        lTotal += m_bfData.Length();
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lTotal;

ErrorExit:
    return lth;
}


/*++

State:

    This routine checks to see if a structure is completely filled in.

Arguments:

    None

Return Value:

    fill_Empty    - There is no added data anywhere in the structure.
    fill_Present  - All the data is present in the structure (except maybe
                    defaulted or optional data).
    fill_Partial  - Not all of the data is there, but some of it is.  (Not used
                    by this object type.)
    fill_Defauted - No data has been written, but a default value is available.
    fill_Optional - No data has been written, but the object is optional.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

CAsnObject::FillState
CAsnPrimitive::State(
    void) const
{
    FillState result;

    if (0 != (fPresent & m_dwFlags))
        result = fill_Present;
    else if (0 != (m_dwFlags & fOptional))
        result = fill_Optional;
    else if (0 != (m_dwFlags & fDefault))
        result = fill_Defaulted;
    else
        result = fill_Empty;
    ((CAsnPrimitive *)this)->m_State = result;
    return result;
}


/*++

Compare:

    This method compares this ASN.1 Object to another.

Arguments:

    asnObject supplies the other object for comparison.

Return Value:

    A value indicating a comparitive value:
    < 0 - This object is less than that object.
    = 0 - This object is the same as that object.
    > 0 - This object is more than that object.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnPrimitive::Compare(
    const CAsnObject &asnObject)
const
{
    const CAsnPrimitive *
        pasnPrim;
    const CBuffer
        *pbfThis,
        *pbfThat;
    LONG
        result;

    if (m_dwType != asnObject.m_dwType)
        return 0x100;   // They're incomparable.
    pasnPrim = (const CAsnPrimitive *)&asnObject;

    switch (m_State)
    {
    case fill_Empty:
    case fill_Optional:
        TRACE("Incomplete Primitive in Comparison")
        return 0x100;
        break;

    case fill_Defaulted:
        pbfThis = &m_bfDefault;
        break;

    case fill_Present:
        pbfThis = &m_bfData;
        break;

    case fill_NoElements:
    case fill_Partial:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        return 0x100;
        break;
    }
    switch (pasnPrim->m_State)
    {
    case fill_Empty:
    case fill_Optional:
        TRACE("Incomplete Primitive in Comparison")
        return 0x100;
        break;

    case fill_Defaulted:
        pbfThat = &pasnPrim->m_bfDefault;
        break;

    case fill_Present:
        pbfThat = &pasnPrim->m_bfData;
        break;

    case fill_NoElements:
    case fill_Partial:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        return 0x100;
        break;
    }

    if (pbfThis->Length() > pbfThat->Length())
        result = (*pbfThis)[pbfThat->Length()];
    else if (pbfThis->Length() < pbfThat->Length())
        result = (*pbfThat)[pbfThis->Length()];
    else
        result = memcmp(pbfThis->Access(), pbfThat->Access(), pbfThis->Length());

    return result;
}


/*++

_copy:

    This method replaces the contents of this ASN.1 Object with another.  The
    objects must be identical structures.  Tags and defaults are not duplicated.

Arguments:

    asnObject supplies the source object.

Return Value:

    >= 0 Is the number of bytes actually copied
    < 0 is an error.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnPrimitive::_copy(
    const CAsnObject &asnObject)
{
    const CAsnPrimitive *
        pasnPrim;
    LONG
        lth;

    if (m_dwType != asnObject.m_dwType)
    {
        TRACE("Type mismatch in _copy")
        lth = -1;   // ?error? Wrong type.
        goto ErrorExit;
    }
    pasnPrim = (const CAsnPrimitive *)&asnObject;

    switch (pasnPrim->m_State)
    {
    case fill_Empty:
        TRACE("Incomplete Structure in _copy")
        lth = -1;       // ?error? Incomplete structure
        goto ErrorExit;
        break;

    case fill_Optional:
        lth = 0;
        break;

    case fill_Defaulted:
        lth = Write(
                pasnPrim->m_bfDefault.Access(),
                pasnPrim->m_bfDefault.Length());
        break;

    case fill_Present:
        lth = Write(
                pasnPrim->m_bfData.Access(),
                pasnPrim->m_bfData.Length());
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;

ErrorExit:
    return lth;
}


/*++

EncodeLength:

    This method encodes the definite length of the object into the supplied
    buffer.

Arguments:

    pbDst receives the ASN.1 encoding of the length.

Return Value:

    >= 0 is the length of the resultant encoding
    < 0 is an error.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnPrimitive::EncodeLength(
    OUT LPBYTE pbDst)
const
{
    LONG lth;

    switch (m_State)
    {
    case fill_Empty:
        TRACE("Incomplete Structure")
        lth = -1;       // ?error? Incomplete Structure
        break;

    case fill_Optional:
    case fill_Defaulted:
        lth = 0;
        break;

    case fill_Present:
        lth = CAsnObject::EncodeLength(pbDst, m_bfData.Length());
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}


/*++

EncodeData:

    This method encodes the data into the supplied buffer.

Arguments:

    pbDst

Return Value:

    >= 0 is the length of the encoding.
    < 0 is an error

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnPrimitive::EncodeData(
    OUT LPBYTE pbDst)
const
{
    LONG lth;

    switch (m_State)
    {
    case fill_Empty:
        TRACE("Incomplete Structure")
        lth = -1;       // ?error? Incomplete Structure
        break;

    case fill_Optional:
    case fill_Defaulted:
        lth = 0;
        break;

    case fill_Present:
        lth = m_bfData.Length();
        if (0 != lth)
            memcpy(pbDst, m_bfData.Access(), lth);
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        lth = -1;
        break;
    }
    return lth;
}


/*++

DecodeData:

    This routine decodes the data portion of the ASN.1.  The tag and length have
    already been removed.

Arguments:

    pbSrc supplies the address of the ASN.1 encoding of the data.

    dwLength supplies the length of the data.


Return Value:

    >= 0 - The number of bytes removed from the input stream.
    <  0 - An error occurred.

Author:

    Doug Barlow (dbarlow) 10/6/1995

--*/

LONG
CAsnPrimitive::DecodeData(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrc,
    IN DWORD dwLength)
{
    if (0 < dwLength)
    {
        if (cbSrc < dwLength)
        {
            return -1;
        }

        if (NULL == m_bfData.Set(pbSrc, dwLength))
            return -1;  // ?error? no memory
    }
    else
        m_bfData.Reset();
    m_dwFlags |= fPresent;
    if (NULL != m_pasnParent)
        m_pasnParent->ChildAction(act_Written, this);
    return dwLength;
}


/*++

TypeCompare:

    This routine compares the entire structure of an Object to another Object.

Arguments:

    asn - The other object.

Return Value:

    TRUE - They are identical
    FALSE - They differ

Author:

    Doug Barlow (dbarlow) 10/19/1995

--*/

BOOL
CAsnPrimitive::TypeCompare(
    const CAsnObject &asnObject)
const
{
    return (m_dwType == asnObject.m_dwType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\asn1\asn1.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    asn1.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Frederick Chong - June. 23rd 1998

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

C_DEFINES = \
    $(C_DEFINES) \
    $(CLIENT_EXE_CDEFS)

#
# List of sources
#


CLIENT_SOURCES_RC = \

SOURCES_PLATFORM =
    

CLIENT_SOURCES_COMMON = \
    asncnstr.cpp \
    asnobjct.cpp \
    asnof.cpp \
    asnprimt.cpp \
    asntext.cpp \
    asnutils.cpp 
    

CLIENT_SOURCES_LAST  = \
    msasnlib.cpp

SOURCES = \
    $(CLIENT_SOURCES_RC) \
    $(SOURCES_PLATFORM) \
    $(CLIENT_SOURCES_COMMON) \
    $(CLIENT_SOURCES_LAST)

#
# Precompiled specs
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\asn1\asnof.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    asnof

Abstract:

    This module provides the implementation of the Base Class for ASN.1 SET OF
    and SEQUENCE OF.

Author:

    Doug Barlow (dbarlow) 10/8/1995

Environment:

    Win32

Notes:



--*/

#include <windows.h>
#include "asnPriv.h"


//
//==============================================================================
//
//  CAsnSeqsetOf
//

IMPLEMENT_NEW(CAsnSeqsetOf)

/*++

CAsnSeqsetOf:

    This is the construction routine for a CAsnSeqsetOf base class.

Arguments:

    dwType supplies the type of the object.

    dwFlags supplies any special flags for this object.  Options are:

        fOptional implies the object is optional.
        fDelete implies the object should be deleted when its parent destructs.

    dwTag is the tag of the object.  If this is zero, the tag is taken from the
        type.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

CAsnSeqsetOf::CAsnSeqsetOf(
    IN DWORD dwFlags,
    IN DWORD dwTag,
    IN DWORD dwType)
:   CAsnObject(dwFlags | fConstructed, dwTag, dwType)
{ /* Force constructed flag */ }


/*++

Clear:

    This method purges any stored values from the object and any underlying
    objects.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

void
CAsnSeqsetOf::Clear(
    void)
{
    CAsnObject::Clear();
    m_rgEntries.Empty();
}


LONG
CAsnSeqsetOf::Add(
    void)
{
    LONG count = m_rgEntries.Count();
    CAsnObject *pasn = m_pasnTemplate->Clone(fDelete);
    if (NULL == pasn)
        goto ErrorExit;
    if (NULL == m_rgEntries.Add(pasn))
        goto ErrorExit;
    return count;

ErrorExit:
    if (NULL != pasn)
        delete pasn;
    return -1;
}

LONG
CAsnSeqsetOf::Insert(
    DWORD dwIndex)
{
    DWORD index;
    DWORD count = m_rgEntries.Count();
    CAsnObject *pasn = m_pasnTemplate->Clone(fDelete);
    if (NULL == pasn)
        goto ErrorExit;

    if (count > dwIndex)
    {
        for (index = count; index > dwIndex; index -= 1)
            m_rgEntries.Set(index, m_rgEntries[index - 1]);
        m_rgEntries.Set(dwIndex, pasn);
    }
    else
    {
        TRACE("*OF Insert out of range")
        goto ErrorExit; // ?error? Index out of range.
    }
    return (LONG)dwIndex;

ErrorExit:
    if (NULL != pasn)
        delete pasn;
    return -1;
}


/*++

DecodeData:

    This routine decodes the data portion of the ASN.1.  The tag and length have
    already been removed.

Arguments:

    pbSrc supplies the address of the ASN.1 encoding of the data.

    dwLength supplies the length of the data.


Return Value:

    >= 0 - The number of bytes removed from the input stream.
    <  0 - An error occurred.

Author:

    Doug Barlow (dbarlow) 10/6/1995

--*/

LONG
CAsnSeqsetOf::DecodeData(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrc,
    IN DWORD dwLength)
{
    LONG lth = -1, lTotal = 0;
    CAsnObject *pasn = NULL;
    DWORD tag, length;
    BOOL fConstr;

    ASSERT(0 == m_rgEntries.Count())
    ASSERT(NULL != m_pasnTemplate)

    while ((DWORD)lTotal < dwLength)
    {
        lth = ExtractTag(&pbSrc[lTotal], cbSrc-lTotal, &tag, &fConstr);
        if (0 > lth)
            goto ErrorExit; // ?error? Propagate error
        if ((tag != m_pasnTemplate->Tag())
            || (0 != (fConstr ^ (0 !=
                        (m_pasnTemplate->m_dwFlags & fConstructed)))))
        {
            TRACE("Incoming tag doesn't match template")
            lth = -1;   // ?error? Tag mismatch
            goto ErrorExit;
        }
        if (0 != (fConstr ^ (0 != (m_dwFlags & fConstructed))))
        {
            TRACE("Incoming construction doesn't match template")
            lth = -1;   // ?error? Construction mismatch
            goto ErrorExit;
        }
        lTotal += lth;

        lth = ExtractLength(&pbSrc[lTotal], cbSrc - lTotal, &length);
        if (0 > lth)
            goto ErrorExit;
        lTotal += lth;
        pasn = m_pasnTemplate->Clone(fDelete);
        if (NULL == pasn)
        {
            lth = -1;   // ?error? No memory
            goto ErrorExit;
        }

        lth = pasn->DecodeData(&pbSrc[lTotal], cbSrc - lTotal, length);
        if (0 > lth)
            goto ErrorExit;
        lTotal += lth;

        if (NULL == m_rgEntries.Add(pasn))
        {
            lth = -1;   // ?error? No memory
            goto ErrorExit;
        }
        pasn = NULL;
    }
    if ((DWORD)lTotal != dwLength)
    {
        TRACE("Decoding buffer mismatch")
        goto ErrorExit; // ?error? Decoding Error
    }
    return lTotal;

ErrorExit:
    if (NULL != pasn)
        delete pasn;
    return lth;
}


/*++

TypeCompare:

    This routine compares the entire structure of an Object to another Object.

Arguments:

    asn - The other object.

Return Value:

    TRUE - They are identical
    FALSE - They differ

Author:

    Doug Barlow (dbarlow) 10/19/1995

--*/

BOOL
CAsnSeqsetOf::TypeCompare(
    const CAsnObject &asnObject)
const
{

    //
    // See if we really have anything to do.
    //

    if (m_dwType != asnObject.m_dwType)
        return FALSE;


    //
    // compare the templates.
    //

    ASSERT(NULL != m_pasnTemplate)
    return m_pasnTemplate->TypeCompare(
                *((CAsnSeqsetOf &)asnObject).m_pasnTemplate);
}


/*++

Copy:

    This method replaces the contents of this ASN.1 Object with another.  The
    objects must be identical structures.  Tags and defaults are not duplicated.

Arguments:

    asnObject supplies the source object.

Return Value:

    >= 0 Is the number of bytes actually copied
    < 0 is an error.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

LONG
CAsnSeqsetOf::_copy(
    const CAsnObject &asnObject)
{
    CAsnSeqsetOf *pasnOf;
    CAsnObject *pasn1 = NULL, *pasn2;
    LONG lTotal = 0, lth;
    DWORD index;
    DWORD count = asnObject.m_rgEntries.Count();

    if (m_dwType == asnObject.m_dwType)
    {
        pasnOf = (CAsnSeqsetOf *)&asnObject;
        if (m_pasnTemplate->m_dwType == pasnOf->m_pasnTemplate->m_dwType)
        {
            for (index = 0; index < count; index += 1)
            {
                pasn1 = m_pasnTemplate->Clone(fDelete);
                if (NULL == pasn1)
                {
                    lth = -1;   // ?error? No memory
                    goto ErrorExit;
                }
                pasn2 = asnObject.m_rgEntries[index];
                ASSERT(NULL != pasn2)
                ASSERT(pasn1 != &asnObject)
                lth = pasn1->_copy(*pasn2);
                if (0 > lth)
                    goto ErrorExit;
                if (NULL == m_rgEntries.Add(pasn1))
                {
                    lth = -1;   // ?error? No memory
                    goto ErrorExit;
                }
                pasn1 = NULL;
                lTotal += lth;
            }
        }
        else
        {
            TRACE("Copy Template Structure Mismatch")
            lth = -1;   // ?error? data type mismatch.
            goto ErrorExit;
        }
    }
    else
    {
        TRACE("Copy Structure Mismatch")
        lth = -1;   // ?error? data type mismatch.
        goto ErrorExit;
    }
    return lTotal;

ErrorExit:
    if (NULL != pasn1)
        delete pasn1;
    return lth;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\asn1\asncnstr.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    asncnstr

Abstract:

    This module provides the implementation of the ASN.1 Constructed Object base
    class.

Author:

    Doug Barlow (dbarlow) 10/8/1995

Environment:

    Win32

Notes:



--*/

#include <windows.h>
#include "asnPriv.h"


//
//==============================================================================
//
//  CAsnConstructed
//

IMPLEMENT_NEW(CAsnConstructed)


/*++

CAsnConstructed:

    This is the construction routine for a CAsnConstructed.

Arguments:

    dwType is the type of the object.

    dwFlags supplies any special flags for this object.  Options are:

        fOptional implies the object is optional.
        fDelete implies the object should be deleted when its parent destructs.

    dwTag is the tag of the object.  If this is zero, the tag is taken from the
        type.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

CAsnConstructed::CAsnConstructed(
    IN DWORD dwFlags,
    IN DWORD dwTag,
    IN DWORD dwType)
:   CAsnObject(dwFlags | fConstructed, dwTag, dwType)
{ /* Just make sure it's constructed. */ }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\asn1\asntext.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    asnText

Abstract:

    This module provides the implementation for the base class of Text based
    ASN.1 objects.

Author:

    Doug Barlow (dbarlow) 10/9/1995

Environment:

    Win32

Notes:

--*/

#include <windows.h>
#include "asnPriv.h"

IMPLEMENT_NEW(CAsnTextString)

BOOL
CAsnTextString::CheckString(
    const BYTE FAR *pch,
    DWORD cbString,
    DWORD length)
const
{
    DWORD idx, index, offset;

    if (NULL != m_pbmValidChars)
    {
        for (idx = 0; idx < length; idx += 1, cbString -= 1)
        {
            if (cbString < sizeof(BYTE))
            {
                return FALSE;
            }

            index = pch[idx] / 32;
            offset = pch[idx] % 32;
            if (0 == (((*m_pbmValidChars)[index] >> offset) & 1))
                return FALSE;
        }
    }
    return TRUE;
}

CAsnTextString::operator LPCSTR(
    void)
{
    LPCSTR sz = NULL;

    switch (State())
    {
    case fill_Empty:
    case fill_Optional:
        sz = NULL;      // ?error? Incomplete structure
        break;

    case fill_Defaulted:
        if (NULL == m_bfDefault.Append((LPBYTE)"\000", 1))
            goto ErrorExit;
        
        if (NULL == m_bfDefault.Resize(m_bfDefault.Length() - 1, TRUE))
            goto ErrorExit;

        sz = (LPCSTR)m_bfDefault.Access();
        break;

    case fill_Present:
        if (NULL == m_bfData.Append((LPBYTE)"\000", 1))
            goto ErrorExit;

        if (NULL == m_bfData.Resize(m_bfData.Length() - 1, TRUE))
            goto ErrorExit;

        sz = (LPCSTR)m_bfData.Access();
        break;

    case fill_Partial:
    case fill_NoElements:
    default:
        ASSERT(FALSE);   // ?error? Internal error
        sz = NULL;
        break;
    }

ErrorExit:
    return sz;
}

CAsnTextString &
CAsnTextString::operator =(
    LPCSTR szSrc)
{
    LONG lth = Write((LPBYTE)szSrc, strlen(szSrc));
    ASSERT(0 > lth); // ?error? Per return lth -- maybe a throw?
    return *this;
}

CAsnTextString::CAsnTextString(
    IN DWORD dwFlags,
    IN DWORD dwTag,
    IN DWORD dwType)
:   CAsnPrimitive(dwFlags, dwTag, dwType),
    m_pbmValidChars(NULL)
{ /* Init as Primitive */ }

LONG
CAsnTextString::Write(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrcLen)
{
    if (!CheckString(pbSrc, cbSrcLen, cbSrcLen))
    {
        TRACE("Invalid character for string type")
        goto ErrorExit; // ?error? Invalid Character in string.
    }
    if (NULL == m_bfData.Presize(cbSrcLen + 1))
        goto ErrorExit;

    CAsnPrimitive::Write(pbSrc, cbSrcLen);
    if (NULL == m_bfData.Append((LPBYTE)"\000", 1))
        goto ErrorExit;

    if (NULL == m_bfData.Resize(cbSrcLen, TRUE))
        goto ErrorExit;

    return cbSrcLen;

ErrorExit:
    return -1;
}

LONG
CAsnTextString::DecodeData(
    IN const BYTE FAR *pbSrc,
    IN DWORD cbSrc,
    IN DWORD dwLength)
{
    LONG lth;

    if (!CheckString(pbSrc, cbSrc, dwLength))
    {
        TRACE("Invalid character for string type in incoming stream")
        goto ErrorExit; // ?error? Invalid Character in string.
    }

    if (NULL == m_bfData.Presize(dwLength + 1))
        goto ErrorExit;

    lth = CAsnPrimitive::DecodeData(pbSrc, cbSrc, dwLength);
    if (NULL == m_bfData.Append((LPBYTE)TEXT("\000"), sizeof(TCHAR)))
        goto ErrorExit;

    if (NULL == m_bfData.Resize(dwLength))
        goto ErrorExit;

    return lth;

ErrorExit:
    Clear();
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\include\asncnstr.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    asncnstr

Abstract:

    This header file describes the ASN.1 Constructed Object.

Author:

    Doug Barlow (dbarlow) 10/8/1995

Environment:

    Win32

Notes:



--*/

#ifndef _ASNCNSTR_H_
#define _ASNCNSTR_H_

#include "asnpriv.h"


//
//==============================================================================
//
//  CAsnConstructed
//

class CAsnConstructed
:   public CAsnObject
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnConstructed(
        IN DWORD dwFlags,
        IN DWORD dwTag,
        IN DWORD dwType);


    //  Properties
    //  Methods
    //  Operators

// protected:
    //  Properties
    //  Methods
};

#endif // _ASNCNSTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\include\asnof.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    asnof

Abstract:

    This header file provides the description of the ASN.1 SEQUENCE OF / SET OF.

Author:

    Doug Barlow (dbarlow) 10/8/1995

Environment:

    Win32

Notes:



--*/

#ifndef _ASNOF_H_
#define _ASNOF_H_

#include "asnpriv.h"


//
//==============================================================================
//
//  CAsnSeqsetOf
//

class CAsnSeqsetOf
:   public CAsnObject
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnSeqsetOf(
        IN DWORD dwFlags,
        IN DWORD dwTag,
        IN DWORD dwType);


    //  Properties
    //  Methods

    virtual void
    Clear(              // Empty the object.
        void);

    virtual DWORD
    Count(void) const
    { return m_rgEntries.Count(); };

    virtual LONG
    Add(void);

    virtual LONG
    Insert(
        DWORD dwIndex);


    //  Operators

// protected:
    //  Properties

    CDynamicArray<CAsnObject> m_rgDefaults;

    CAsnObject *m_pasnTemplate;


    //  Methods

    virtual BOOL
    TypeCompare(        // Compare the types of objects.
        const CAsnObject &asnObject)
    const;

    virtual LONG
    _copy(              // Copy another object to this one.
        const CAsnObject &asnObject);

    virtual LONG
    DecodeData(         // Read data in encoding format.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrc,
        IN DWORD dwLength);
};

#endif // _ASNOF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\include\asntext.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    asntext

Abstract:

    This module provides the implementation for the ASN.1 Text Object base
    class.

Author:

    Doug Barlow (dbarlow) 10/8/1995

Environment:

    Win32

Notes:

    This code assumes that the width of an unsigned long integer is 32 bits.

--*/

#ifndef _ASNTEXT_H_
#define _ASNTEXT_H_

#include "asnPriv.h"


//
//==============================================================================
//
//  CAsnTextString
//

class CAsnTextString
:   public CAsnPrimitive
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnTextString(
        IN DWORD dwFlags,
        IN DWORD dwTag,
        IN DWORD dwType);


    //  Properties
    //  Methods

    virtual LONG
    Write(              // Set the value of the object.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrcLen);


    //  Operators

    operator LPCSTR(
        void);

    CAsnTextString &
    operator =(
        LPCSTR szSrc);

// protected:

    typedef DWORD CharMap[256 / sizeof(DWORD)];


    //  Properties

    CharMap *m_pbmValidChars;


    //  Methods

    virtual BOOL
    CheckString(
        const BYTE FAR *pch,
        DWORD cbString,
        DWORD length)
    const;


public:

    virtual LONG
    DecodeData(         // Read data in encoding format.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrc,
        IN DWORD dwLength);
};

#endif // _ASNTEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\include\asnprimt.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    asnprimt

Abstract:

    This header file provides the definitions for the ASN.1 Primitive Object.

Author:

    Doug Barlow (dbarlow) 10/8/1995

Environment:

    Win32

Notes:



--*/

#ifndef _ASNPRIMT_H_
#define _ASNPRIMT_H_

#include "asnpriv.h"


//
//==============================================================================
//
//  CAsnPrimitive
//

class CAsnPrimitive
:   public CAsnObject
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnPrimitive(
        IN DWORD dwFlags,
        IN DWORD dwTag,
        IN DWORD dwType);


    //  Properties
    //  Methods

    virtual void
    Clear(              // Empty the object.
        void);

    virtual LONG
    DataLength(         // Return the length of the object.
        void) const;

    virtual LONG
    Read(               // Return the value of the object.
        OUT LPBYTE pbDst)
        const;

    virtual LONG
    Write(              // Set the value of the object.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrcLen);


    //  Operators

// protected:
    //  Properties

    CBuffer m_bfData;


    //  Methods

    virtual LONG
    _encLength(         // Return the length of the encoded object.
        void) const;

    virtual FillState   // Current fill state.
    State(
        void) const;

    virtual BOOL
    TypeCompare(        // Compare the types of objects.
        const CAsnObject &asnObject)
    const;

    virtual LONG
    Compare(            // Return a comparison to another object.
        const CAsnObject &asnObject)
    const;

    virtual LONG
    _copy(               // Copy another object to this one.
        const CAsnObject &asnObject);

    virtual LONG
    EncodeLength(       // Place encoding of Length, return length of encoding
        OUT LPBYTE pbDest)
    const;

    virtual LONG
    EncodeData(         // Place encoding of Data, return length of encoding
        OUT LPBYTE pbDest)
    const;

    virtual LONG
    DecodeData(         // Read data in encoding format.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrc,
        IN DWORD dwLength);
};

#endif // _ASNPRIMT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\asn1\text.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    text

Abstract:

    This header file provides a text handling class.

Author:

    Doug Barlow (dbarlow) 10/5/1995

Environment:

    Win32

Notes:



--*/

#ifndef _TEXT_H_
#define _TEXT_H_

#include <string.h>
#include <mbstring.h>
#include "buffers.h"


//
//==============================================================================
//
//  CText
//

class CText
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CText()
    :   m_bfUnicode(),
        m_bfAnsi()
    { m_fFlags = fBothGood; };

    virtual ~CText() {};


    //  Properties
    //  Methods

    void
    Clear(
        void)
    {
        m_bfUnicode.Clear();
        m_bfAnsi.Clear();
        m_fFlags = fBothGood;
    };


    //  Operators

    CText &
    operator=(
        const CText &tz);
    LPCSTR
    operator=(
        LPCSTR sz);
    LPCWSTR
    operator=(
        LPCWSTR wsz);

    CText &
    operator+=(
        const CText &tz);
    LPCSTR
    operator+=(
        LPCSTR sz);
    LPCWSTR
    operator+=(
        LPCWSTR wsz);

    BOOL operator==(const CText &tz)
    { return (0 == Compare(tz)); };
    BOOL operator==(LPCSTR sz)
    { return (0 == Compare(sz)); };
    BOOL operator==(LPCWSTR wsz)
    { return (0 == Compare(wsz)); };

    BOOL operator!=(const CText &tz)
    { return (0 != Compare(tz)); };
    BOOL operator!=(LPCSTR sz)
    { return (0 != Compare(sz)); };
    BOOL operator!=(LPCWSTR wsz)
    { return (0 != Compare(wsz)); };

    BOOL operator<=(const CText &tz)
    { return (0 <= Compare(tz)); };
    BOOL operator<=(LPCSTR sz)
    { return (0 <= Compare(sz)); };
    BOOL operator<=(LPCWSTR wsz)
    { return (0 <= Compare(wsz)); };

    BOOL operator>=(const CText &tz)
    { return (0 >= Compare(tz)); };
    BOOL operator>=(LPCSTR sz)
    { return (0 >= Compare(sz)); };
    BOOL operator>=(LPCWSTR wsz)
    { return (0 >= Compare(wsz)); };

    BOOL operator<(const CText &tz)
    { return (0 < Compare(tz)); };
    BOOL operator<(LPCSTR sz)
    { return (0 < Compare(sz)); };
    BOOL operator<(LPCWSTR wsz)
    { return (0 < Compare(wsz)); };

    BOOL operator>(const CText &tz)
    { return (0 > Compare(tz)); };
    BOOL operator>(LPCSTR sz)
    { return (0 > Compare(sz)); };
    BOOL operator>(LPCWSTR wsz)
    { return (0 > Compare(wsz)); };

    operator LPCSTR(void)
    { return Ansi(); };

    operator LPCWSTR(void)
    { return Unicode(); };


protected:
    //  Properties

    enum {
        fNoneGood = 0,
        fAnsiGood = 1,
        fUnicodeGood = 2,
        fBothGood = 3
    } m_fFlags;

    CBuffer
        m_bfUnicode,
        m_bfAnsi;

    //  Methods

    LPCWSTR
    Unicode(        // Return the text as a Unicode string.
        void);

    LPCSTR
    Ansi(        // Return the text as an Ansi string.
        void);

    int
    Compare(
        const CText &tz);

    int
    Compare(
        LPCSTR sz);

    int
    Compare(
        LPCWSTR wsz);
};

IMPLEMENT_STATIC_NEW(CText)


/*++

CText::operator=:

    These methods set the CText object to the given value, properly adjusting
    the object to the type of text.

Arguments:

    tz supplies the new value as a CText object.
    sz supples the new value as an LPCSTR object (ANSI).
    wsz supplies the new value as an LPCWSTR object (Unicode).

Return Value:

    A reference to the CText object.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

CText &
CText::operator=(
    const CText &tz)
{

    //
    // See what the other CText object has that's good, and copy it over here.
    //

    switch (m_fFlags = tz.m_fFlags)
    {
    case fNoneGood:
        // Nothing's Good!?!  ?Error?
        TRACE("CText -- Nothing listed as valid.")
        goto ErrorExit;
        break;

    case fAnsiGood:
        // The ANSI buffer is good.
        m_bfAnsi = tz.m_bfAnsi;
        break;

    case fUnicodeGood:
        // The Unicode buffer is good.
        m_bfUnicode = tz.m_bfUnicode;
        break;

    case fBothGood:
        // Everything is good.
        m_bfAnsi = tz.m_bfAnsi;
        m_bfUnicode = tz.m_bfUnicode;
        break;

    default:
        // Internal error.
        goto ErrorExit;
    }
    return *this;

ErrorExit:
    return *this;
}

LPCSTR
CText::operator=(
    LPCSTR sz)
{
    DWORD length;

    //
    // Reset the ANSI buffer.
    //

    if (NULL != sz)
    {
        length = strlen(sz) + sizeof(CHAR); // ?str?
        if (NULL == m_bfAnsi.Set((LPBYTE)sz, length))
            goto ErrorExit;
    }
    else
        m_bfAnsi.Reset();
    m_fFlags = fAnsiGood;
    return *this;

ErrorExit:  // ?what? do we do?
    return *this;
}

LPCWSTR
CText::operator=(
    LPCWSTR wsz)
{
    DWORD length;


    //
    // Reset the Unicode Buffer.
    //

    if (NULL != wsz)
    {
        length = wcslen(wsz) + sizeof(WCHAR);
        if (NULL == m_bfUnicode.Set((LPBYTE)wsz, length))
            goto ErrorExit;
    }
    else
        m_bfUnicode.Reset();
    m_fFlags = fUnicodeGood;
    return *this;

ErrorExit:  // ?what? do we do?
    return *this;
}


/*++

CText::operator+=:

    These methods append the given data to the existing CText object value,
    properly adjusting the object to the type of text.

Arguments:

    tz supplies the new value as a CText object.
    sz supples the new value as an LPCSTR object (ANSI).
    wsz supplies the new value as an LPCWSTR object (Unicode).

Return Value:

    A reference to the CText object.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

CText &
CText::operator+=(
    const CText &tz)
{

    //
    // Append the other's value to our good value.
    //

    switch (m_fFlags = tz.m_fFlags)
    {
    case fNoneGood:
        goto ErrorExit;
        break;

    case fAnsiGood:
        if (NULL == m_bfAnsi.Resize(m_bfAnsi.Length() - sizeof(CHAR), TRUE))
            goto ErrorExit;
        m_bfAnsi += tz.m_bfAnsi;
        break;

    case fUnicodeGood:
        if (NULL == m_bfUnicode.Resize(
                        m_bfUnicode.Length() - sizeof(WCHAR), TRUE))
            goto ErrorExit;
        m_bfUnicode = tz.m_bfUnicode;
        break;

    case fBothGood:
        if (NULL == m_bfAnsi.Resize(m_bfAnsi.Length() - sizeof(CHAR), TRUE))
            goto ErrorExit;
        m_bfAnsi = tz.m_bfAnsi;
        if (NULL == m_bfUnicode.Resize(
                        m_bfUnicode.Length() - sizeof(WCHAR), TRUE))
            goto ErrorExit;
        m_bfUnicode = tz.m_bfUnicode;
        break;

    default:
        goto ErrorExit;
    }
    return *this;

ErrorExit:  // ?What?
    return *this;
}

LPCSTR
CText::operator+=(
    LPCSTR sz)
{
    DWORD length;


    //
    // Extend ourself as an ANSI string.
    //

    if (NULL != sz)
    {
        length = strlen(sz);    // ?str?
        if (0 < length)
        {
            length += 1;
            length *= sizeof(CHAR);
            if (NULL == Ansi())
                goto ErrorExit;
            m_bfAnsi.Resize(m_bfAnsi.Length() - sizeof(CHAR), TRUE);
            if (NULL == m_bfAnsi.Append((LPBYTE)sz, length))
                goto ErrorExit;
            m_fFlags = fAnsiGood;
        }
    }
    return *this;

ErrorExit:  // ?what? do we do?
    return *this;
}

LPCWSTR
CText::operator+=(
    LPCWSTR wsz)
{
    DWORD length;


    //
    // Extend ourself as a Unicode string.
    //

    if (NULL != wsz)
    {
        length = wcslen(wsz);
        if (0 < length)
        {
            length += 1;
            length *= sizeof(WCHAR);
            if (NULL == Unicode())
                goto ErrorExit;
            m_bfUnicode.Resize(m_bfUnicode.Length() - sizeof(WCHAR), TRUE);
            if (NULL == m_bfUnicode.Append((LPBYTE)wsz, length))
                goto ErrorExit;
            m_fFlags = fUnicodeGood;
        }
    }
    return *this;

ErrorExit:  // ?what? do we do?
    return *this;
}


/*++

Unicode:

    This method returns the CText object as a Unicode string.

Arguments:

    None

Return Value:

    The value of the object expressed in Unicode.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

inline LPCWSTR
CText::Unicode(
    void)
{
    int length;


    //
    // See what data we've got, and if any conversion is necessary.
    //

    switch (m_fFlags)
    {
    case fNoneGood:
        // No valid values.  Report an error.
        goto ErrorExit;
        break;

    case fAnsiGood:
        // The ANSI value is good.  Convert it to Unicode.
        if (0 < m_bfAnsi.Length())
        {
            length =
                MultiByteToWideChar(
                    CP_ACP,
                    MB_PRECOMPOSED,
                    (LPCSTR)m_bfAnsi.Access(),
                    m_bfAnsi.Length() - sizeof(CHAR),
                    NULL,
                    0);
            if ((0 == length)
                || (NULL == m_bfUnicode.Resize(
                                (length + 1) * sizeof(WCHAR))))
                goto ErrorExit;
            length =
                MultiByteToWideChar(
                    CP_ACP,
                    MB_PRECOMPOSED,
                    (LPCSTR)m_bfAnsi.Access(),
                    m_bfAnsi.Length() - sizeof(CHAR),
                    (LPWSTR)m_bfUnicode.Access(),
                    length);
            if (0 == length)
                goto ErrorExit;
            *(LPWSTR)m_bfUnicode.Access(length * sizeof(WCHAR)) = 0;
        }
        else
            m_bfUnicode.Reset();
        m_fFlags = fBothGood;
        break;

    case fUnicodeGood:
    case fBothGood:
        // The Unicode value is good.  Just return that.
        break;

    default:
        // Internal error.
        goto ErrorExit;
    }


    //
    // If we don't have any value, return a null string.
    //

    if (0 == m_bfUnicode.Length)
        return L"";
    else
        return (LPCWSTR)m_bfUnicode.Access();

ErrorExit:
    return NULL;
}


/*++

CText::Ansi:

    This method returns the value of the object expressed in an ANSI string.

Arguments:

    None

Return Value:

    The value of the object expressed as an ANSI string.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

inline LPCSTR
CText::Ansi(
    void)
{
    int length;


    //
    // See what data we've got, and if any conversion is necessary.
    //

    switch (m_fFlags)
    {
    case fNoneGood:
        // Nothing is good!?!  Return an error.
        goto ErrorExit;
        break;

    case fUnicodeGood:
        // The Unicode buffer is good.  Convert it to ANSI.
        if (0 < m_bfUnicode.Length())
        {
            length =
                WideCharToMultiByte(
                    CP_ACP,
                    0,
                    (LPCWSTR)m_bfUnicode.Access(),
                    (m_bfUnicode.Length() / sizeof(WCHAR)) - 1,
                    NULL,
                    0,
                    NULL,
                    NULL);
            if ((0 == length)
                || (NULL == m_bfAnsi.Resize(
                                (length + 1) * sizeof(CHAR))))
                goto ErrorExit;
            length =
                WideCharToMultiByte(
                    CP_ACP,
                    0,
                    (LPCWSTR)m_bfUnicode.Access(),
                    (m_bfUnicode.Length() / sizeof(WCHAR)) - 1,
                    (LPSTR)m_bfAnsi.Access(),
                    length,
                    NULL,
                    NULL);
            if (0 == length)
                goto ErrorExit;
            *(LPSTR)m_bfAnsi.Access(length * sizeof(CHAR)) = 0;
        }
        else
            m_bfAnsi.Reset();
        m_fFlags = fBothGood;
        break;

    case fAnsiGood:
    case fBothGood:
        // The ANSI buffer is good.  We'll return that.
        break;

    default:
        // An internal error.
        goto ErrorExit;
    }


    //
    // If there's nothing in the ANSI buffer, return a null string.
    //

    if (0 == m_bfAnsi.Length)
        return "";
    else
        return (LPCSTR)m_bfAnsi.Access();

ErrorExit:
    return NULL;
}


/*++

Compare:

    These methods compare the value of this object to another value, and return
    a comparative value.

Arguments:

    tz supplies the value to be compared as a CText object.
    sz supplies the value to be compared as an ANSI string.
    wsz supplies the value to be compared as a Unicode string.

Return Value:

    < 0 - The supplied value is less than this object.
    = 0 - The supplied value is equal to this object.
    > 0 - The supplies value is greater than this object.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

inline int
CText::Compare(
    const CText &tz)
{
    int nResult;


    //
    // See what we've got to compare.
    //

    switch (tz.m_fFlags)
    {
    case fNoneGood:
        // Nothing!?!  Complain.
        TRACE("CText - No format is valid.")
        goto ErrorExit;
        break;

    case fBothGood:
    case fAnsiGood:
        // Use the ANSI version for fastest comparison.
        if (NULL == Ansi())
            goto ErrorExit;
        nResult = strcmp((LPSTR)m_bfAnsi.Access(), (LPSTR)tz.m_bfAnsi.Access());  // ?str?
        break;

    case fUnicodeGood:
        // The Unicode version is good.
        if (NULL == Unicode())
            goto ErrorExit;
        nResult = wcscmp((LPWSTR)m_bfUnicode.Access(), (LPWSTR)tz.m_bfUnicode.Access());
        break;

    default:
        // Internal Error.
        goto ErrorExit;
    }
    return nResult;

ErrorExit:  // ?What?
    return 1;
}

inline int
CText::Compare(
    LPCSTR sz)
{

    //
    // Make sure our ANSI version is good.
    //

    if (NULL == Ansi())
        goto ErrorExit;

    //
    // Do an ANSI comparison.
    //

    return strcmp((LPCSTR)m_bfAnsi.Access(), sz);   // ?str?

ErrorExit:  // ?what?
    return 1;
}

inline int
CText::Compare(
    LPCWSTR wsz)
{

    //
    // Make sure our Unicode version is good.
    //

    if (NULL == Unicode())
        goto ErrorExit;


    //
    // Do the comparison using Unicode.
    //

    return wcscmp((LPCWSTR)m_bfUnicode.Access(), wsz);

ErrorExit:  // ?what?
    return 1;
}

#endif // _TEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\include\asnpriv.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    asnpriv

Abstract:

    This header file contains definitions and symbols that are private to the
    Microsoft ASN.1 Compiler Run-Time Library.

Author:

    Doug Barlow (dbarlow) 10/9/1995

Environment:

    Win32

Notes:



--*/

#ifndef _ASNPRIV_H_
#define _ASNPRIV_H_

#include <memcheck.h>
#include "MSAsnLib.h"

extern LONG
ExtractTag(
    const BYTE FAR *pbSrc,
    DWORD cbSrc,
    LPDWORD pdwTag,
    LPBOOL pfConstr = NULL);

extern LONG
ExtractLength(
    const BYTE FAR *pbSrc,
    DWORD cbSrc,
    LPDWORD pdwLen,
    LPBOOL pfIndefinite = NULL);

#define ErrorCheck if (0 != GetLastError()) goto ErrorExit

#endif // _ASNPRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\include\msasnlib.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    msasnlib

Abstract:

    This header file provides the definitions and symbols for access to the
Microsoft ASN.1 Support Library.

Author:

    Doug Barlow (dbarlow) 9/29/1995

Environment:

    Win32, C++

Notes:



--*/

#ifndef _MSASNLIB_H_
#define _MSASNLIB_H_

#include "Buffers.h"

//
// use template version of dynamic array for non-win16 compile
//

#include "DynArray.h"

#include "asnobjct.h"
#include "asnprimt.h"
#include "asncnstr.h"
#include "asnof.h"
#include "asntext.h"

#ifndef FTINT
#define FTINT(tm) (*(_int64 *)&(tm))
#endif

inline DWORD
UNIVERSAL(
    DWORD dwTag)
{
    return (CAsnObject::cls_Universal << 30) + dwTag;
}

inline DWORD
APPLICATION(
    DWORD dwTag)
{
    return (CAsnObject::cls_Application << 30) + dwTag;
}

inline DWORD
TAG(
    DWORD dwTag)
{
    return (CAsnObject::cls_ContextSpecific << 30) + dwTag;
}

inline DWORD
PRIVATE(
    DWORD dwTag)
{
    return (CAsnObject::cls_Private << 30) + dwTag;
}


//
//==============================================================================
//
//  CAsnBoolean
//

class CAsnBoolean
:   public CAsnPrimitive
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnBoolean(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_Boolean);


    //  Properties
    //  Methods

    virtual LONG
    Write(              // Set the value of the object.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrcLen);


    //  Operators

    operator BOOL(void)
    const;

    BOOL
    operator =(BOOL fValue);

// protected:
    //  Properties
    //  Methods

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;

    virtual LONG
    DecodeData(         // Read data in encoding format.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrc,
        IN DWORD dwLength);
};


//
//==============================================================================
//
//  CAsnInteger
//

class CAsnInteger
:   public CAsnPrimitive
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnInteger(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_Integer);


    //  Properties
    //  Methods

    virtual LONG
    Write(              // Set the value of the object as an array of DWORDs.
        IN const DWORD *pdwSrc,
        IN DWORD cdwSrcLen = 1);

    virtual LONG
    Write(              // Set the value of the object, clearing first.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrcLen);


    //  Operators

    operator LONG(void)
    const;

    operator ULONG(void)
    const;

    LONG
    operator =(LONG lValue);

    ULONG
    operator =(ULONG lValue);

// protected:
    //  Properties
    //  Methods

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  CAsnBitstring
//

class CAsnBitstring
:   public CAsnPrimitive
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnBitstring(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_Bitstring);


    //  Properties
    //  Methods

    virtual LONG
    DataLength(         // Return the length of the object.
        void) const;

    virtual LONG
    Read(               // Return the value of the object.
        OUT CBuffer &bfDst,
        OUT int *offset = NULL)
        const;

    virtual LONG
    Read(               // Return the value of the object.
        OUT LPBYTE pbDst,
        OUT int *offset)
        const;

    virtual LONG
    Write(              // Set the value of the object.
        IN const CBuffer &bfSrc,
        IN int offset = 0);

    virtual LONG
    Write(              // Set the value of the object.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrcLen,
        IN int offset = 0);


    //  Operators

// protected:
    //  Properties
    //  Methods

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  CAsnOctetstring
//

class CAsnOctetstring
:   public CAsnPrimitive
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnOctetstring(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_Octetstring);


    //  Properties
    //  Methods
    //  Operators

// protected:
    //  Properties
    //  Methods

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  CAsnNull
//

class CAsnNull
:   public CAsnPrimitive
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnNull(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_Null);


    //  Properties
    //  Methods

    virtual void
    Clear(void);

    virtual LONG
    Write(
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrcLen);


    //  Operators

// protected:
    //  Properties
    //  Methods

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;

    virtual LONG
    DecodeData(
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrc,
        IN DWORD dwLength);
};


//
//==============================================================================
//
//  CAsnObjectIdentifier
//

class CAsnObjectIdentifier
:   public CAsnPrimitive
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnObjectIdentifier(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_ObjectIdentifier);


    //  Properties
    //  Methods

    operator LPCTSTR(void) const;

    LPCTSTR
    operator =(
        LPCTSTR szValue);


    //  Operators

// protected:

    //  Properties

    CBuffer m_bfText;


    //  Methods

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  CAsnReal
//

class CAsnReal
:   public CAsnPrimitive
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnReal(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_Real);


    //  Properties
    //  Methods
    //  Operators

    operator double(void)
    const;

    double
    operator =(double rValue);


// protected:
    //  Properties
    //  Methods

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  CAsnEnumerated
//

class CAsnEnumerated
:   public CAsnPrimitive
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnEnumerated(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_Enumerated);


    //  Properties
    //  Methods     ?todo? - What is this?
    //  Operators

// protected:
    //  Properties
    //  Methods

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  CAsnSequence & CAsnSequenceOf
//

class CAsnSequence
:   public CAsnConstructed
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnSequence(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_Sequence);


    //  Properties
    //  Methods
    //  Operators

// protected:
    //  Properties
    //  Methods
};

class CAsnSequenceOf
:   public CAsnSeqsetOf
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnSequenceOf(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_Sequence);


    //  Properties
    //  Methods
    //  Operators

// protected:
    //  Properties
    //  Methods
};


//
//==============================================================================
//
//  CAsnSet & CAsnSetOf
//

class CAsnSet
:   public CAsnConstructed
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnSet(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_Set);


    //  Properties
    //  Methods
    //  Operators

// protected:
    //  Properties
    //  Methods
};

class CAsnSetOf
:   public CAsnSeqsetOf
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnSetOf(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_Set);


    //  Properties
    //  Methods
    //  Operators

// protected:
    //  Properties
    //  Methods
};


//
//==============================================================================
//
//  CAsnTag
//

class CAsnTag
:   public CAsnConstructed
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnTag(
        IN DWORD dwFlags,
        IN DWORD dwTag);


    //  Properties
    //  Methods

    virtual LONG
    DataLength(         // Return the length of the object.
        void) const;

    virtual LONG
    Read(               // Return the value of the object.
        OUT LPBYTE pbDst)
        const;

    virtual LONG
    Write(              // Set the value of the object.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrcLen);


    //  Operators


// protected:

    //  Properties
    //  Methods

    virtual void
    Reference(
        CAsnObject *pasn);

    virtual CAsnObject *
    Clone(
        IN DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  CAsnAny
//

class CAsnAny
:   public CAsnObject
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnAny(
        IN DWORD dwFlags);


    //  Properties
    //  Methods

    virtual void
    Clear(              // Empty the object.
        void);

    virtual DWORD
    Tag(                // Return the tag of the object.
        void) const;

    virtual LONG
    DataLength(         // Return the length of the object.
        void) const;

    virtual LONG
    Read(               // Return the value of the object.
        OUT LPBYTE pbDst)
        const;

    virtual LONG
    Write(              // Set the value of the object.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrcLen);

    virtual LONG
    Cast(               // Fill another ASN.1 structure from the ANY.
        OUT CAsnObject &asnObj);

    CAsnObject &
    operator =(         // Set the ANY value from another ASN.1 object
        IN const CAsnObject &asnValue);


    //  Operators


// protected:

    //  Properties

    CBuffer m_bfData;
    DWORD m_dwDefaultTag;


    //  Methods

    virtual LONG
    _decode(         // Load an encoding into the object.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrc);

    virtual LONG
    _encLength(         // Return the length of the encoded object.
        void) const;

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;

    virtual FillState   // Current fill state.
    State(
        void) const;

    virtual BOOL
    TypeCompare(        // Compare the types of objects.
        const CAsnObject &asnObject)
    const;

    virtual LONG
    Compare(            // Return a comparison to another object.
        const CAsnObject &asnObject)
    const;

    virtual LONG
    _copy(              // Copy another object to this one.
        const CAsnObject &asnObject);

    virtual LONG
    EncodeLength(       // Place encoding of Length, return length of encoding
        OUT LPBYTE pbDest)
    const;

    virtual LONG
    EncodeData(         // Place encoding of Data, return length of encoding
        OUT LPBYTE pbDest)
    const;

    virtual LONG
    SetDefault(         // Set the current value to be the default value.
        void);

    virtual LONG
    DecodeData(         // Read data in encoding format.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrc,
        IN DWORD dwLength);

};


//
//==============================================================================
//
//  CAsnChoice
//

class CAsnChoice
:   public CAsnObject
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnChoice(
        IN DWORD dwFlags);


    //  Properties
    //  Methods

    virtual DWORD
    Tag(                // Return the tag of the object.
        void) const;

    virtual LONG
    DataLength(         // Return the length of the object.
        void) const;

    virtual LONG
    Read(               // Return the value of the object.
        OUT LPBYTE pbDst)
        const;

    virtual LONG
    Write(              // Set the value of the object.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrcLen);


    //  Operators


// protected:
    //  Properties

    DWORD m_nActiveEntry;
    DWORD m_dwDefaultTag;


    //  Methods

    virtual LONG
    _decode(         // Load an encoding into the object.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrc);

    virtual LONG
    _encLength(         // Return the length of the encoded object.
        void) const;

    virtual LONG
    SetDefault(         // Set the current value to be the default value.
        void);

    virtual FillState   // Current fill state.
    State(
        void) const;

    virtual LONG
    Compare(            // Return a comparison to another object.
        const CAsnObject &asnObject)
    const;

    virtual LONG
    _copy(              // Copy another object to this one.
        const CAsnObject &asnObject);

    virtual LONG
    EncodeTag(          // Place encoding of Tag, return length of encoding
        OUT LPBYTE pbDest)
    const;

    virtual LONG
    EncodeLength(       // Place encoding of Length, return length of encoding
        OUT LPBYTE pbDest)
    const;

    virtual LONG
    EncodeData(         // Place encoding of Data, return length of encoding
        OUT LPBYTE pbDest)
    const;

    virtual LONG
    DecodeData(         // Read data in encoding format.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrc,
        IN DWORD dwLength);

    virtual void
    ChildAction(        // Child notification method.
        IN ChildActions action,
        IN CAsnObject *pasnChild);
};


//
//==============================================================================
//
//  String Types
//

class CAsnNumericString
:   public CAsnTextString
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnNumericString(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_NumericString);

// protected:

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};

class CAsnPrintableString
:   public CAsnTextString
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnPrintableString(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_PrintableString);

// protected:

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};

class CAsnTeletexString
:   public CAsnTextString
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnTeletexString(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_TeletexString);

// protected:

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};

class CAsnVideotexString
:   public CAsnTextString
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnVideotexString(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_VideotexString);

// protected:

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};

class CAsnVisibleString
:   public CAsnTextString
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnVisibleString(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_VisibleString);

// protected:

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};

class CAsnIA5String
:   public CAsnTextString
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnIA5String(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_IA5String);

// protected:

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};

class CAsnGraphicString
:   public CAsnTextString
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnGraphicString(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_GraphicString);

// protected:

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};

class CAsnGeneralString
:   public CAsnTextString
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnGeneralString(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_GeneralString);

// protected:

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};


class CAsnUnicodeString
:   public CAsnTextString
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnUnicodeString(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_UnicodeString);

// protected:

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};

//
//==============================================================================
//
//  CAsnGeneralizedTime
//

class CAsnGeneralizedTime
:   public CAsnVisibleString
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnGeneralizedTime(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_GeneralizedTime);


    operator FILETIME(
        void);

    const FILETIME &
    operator =(
        const FILETIME &ftValue);

// protected:


    FILETIME m_ftTime;

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  CAsnUniversalTime
//

class CAsnUniversalTime
:   public CAsnVisibleString
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnUniversalTime(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_UniversalTime);


    //
    // Win16 does not support file time operation
    //

    operator FILETIME(
        void);

    const FILETIME &
    operator =(
        const FILETIME &ftValue);

// protected:

    FILETIME m_ftTime;

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  CAsnObjectDescriptor
//

class CAsnObjectDescriptor
:   public CAsnGraphicString
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnObjectDescriptor(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_ObjectDescriptor);

// protected:

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  CAsnExternal
//

class CAsnExternal_Encoding_singleASN1Type
:   public CAsnTag
{
    friend class CAsnExternal_Encoding;

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnExternal_Encoding_singleASN1Type(
        IN DWORD dwFlags,
        IN DWORD dwTag);

    //  Properties

    CAsnAny _entry1;

// protected:

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};

class CAsnExternal_Encoding
:   public CAsnChoice
{
    friend class CAsnExternal;

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnExternal_Encoding(
        IN DWORD dwFlags);

    //  Properties

    CAsnExternal_Encoding_singleASN1Type singleASN1Type;
    CAsnOctetstring octetAligned;
    CAsnBitstring arbitrary;

// protected:

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};

class CAsnExternal
:   public CAsnSequence
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAsnExternal(
        IN DWORD dwFlags = 0,
        IN DWORD dwTag = tag_External);


    //  Properties

    CAsnObjectIdentifier directReference;
    CAsnInteger indirectReference;
    CAsnObjectDescriptor dataValueDescriptor;
    CAsnExternal_Encoding encoding;

// protected:

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const;
};

#endif // _MSASNLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\include\asnobjct.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    asnobjct

Abstract:

    This module provides the Generic ASN.1 Support Object definitions.

Author:

    Doug Barlow (dbarlow) 10/8/1995

Environment:

    Win32

Notes:

    This code assumes that the width of an unsigned long integer is 32 bits.

--*/

#ifndef _ASNOBJCT_H_
#define _ASNOBJCT_H_

#include "asnpriv.h"


//
//==============================================================================
//
//  CAsnObject
//

class CAsnObject
{
public:

    enum Flags {
        fOptional    = 0x01,
        fDelete      = 0x02,
        fDefault     = 0x04,
        fPresent     = 0x08,
        fConstructed = 0x10 };

    enum Tags {
        tag_Undefined        = 0,
        tag_Boolean          = 1,
        tag_Integer          = 2,
        tag_Bitstring        = 3,
        tag_Octetstring      = 4,
        tag_Null             = 5,
        tag_ObjectIdentifier = 6,
        tag_ObjectDescriptor = 7,
        tag_External         = 8,
        tag_Real             = 9,
        tag_Enumerated       = 10,
        tag_Sequence         = 16,
        tag_Set              = 17,
        tag_NumericString    = 18,
        tag_PrintableString  = 19,
        tag_TeletexString    = 20,
        tag_VideotexString   = 21,
        tag_IA5String        = 22,
        tag_UniversalTime    = 23,
        tag_GeneralizedTime  = 24,
        tag_GraphicString    = 25,
        tag_VisibleString    = 26,
        tag_GeneralString    = 27,
        tag_UnicodeString    = 30 };

    enum Classes {
        cls_Universal       = 0,
        cls_Application     = 1,
        cls_ContextSpecific = 2,
        cls_Private         = 3 };


    //  Constructors & Destructor

    DECLARE_NEW

    CAsnObject(
        IN DWORD dwFlags,
        IN DWORD dwTag,
        IN DWORD dwType);

    virtual ~CAsnObject();


    //  Properties
    //  Methods


    // Exposed methods.

    virtual LONG
    Read(               // Return the value, making sure it's there.
        OUT CBuffer &bfDst)
        const;

    virtual LONG
    Write(              // Set the value of the object, clearing first.
        IN const CBuffer &bfSrc);

    virtual LONG
    Encode(             // Return the encoding, ensuring it's there.
        OUT CBuffer &bfDst)
        const;

    virtual LONG
    Decode(             // Load an encoding into the object, clearing it first.
        IN const CBuffer &bfSrc);

    virtual LONG
    Read(               // Return the value of the object, ensuring it's there.
        OUT LPBYTE pbDst)
        const;

    virtual LONG
    Write(              // Set the value of the object, clearing first.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrcLen);

    virtual LONG
    Encode(             // Return the encoding of the object, making sure it's there.
        OUT LPBYTE pbDst)
        const;

    virtual LONG
    Decode(             // Load an encoding into the object, clearing it first.
        IN const BYTE FAR *pbSrc, IN DWORD cbSrc);

    virtual void
    Clear(              // Empty the object.
        void);

    virtual DWORD
    Tag(                // Return the tag of the object.
        void) const;

    virtual LONG
    DataLength(         // Return the length of the data, ensuring it's there.
        void) const;

    virtual LONG
    EncodingLength(     // Return the length of the encoded object if it's there
        void) const;


    //  Operators

    virtual int
    operator==(
        const CAsnObject &asnObject)
    const
    { State(); asnObject.State();
      return 0 == Compare(asnObject); };

    virtual int
    operator!=(
        const CAsnObject &asnObject)
    const
    { State(); asnObject.State();
      return 0 != Compare(asnObject); };

    virtual LONG
    Copy(
        const CAsnObject &asnObject);


// protected:

    enum Types {
        type_Undefined        = 0,
        type_Boolean          = 1,
        type_Integer          = 2,
        type_Bitstring        = 3,
        type_Octetstring      = 4,
        type_Null             = 5,
        type_ObjectIdentifier = 6,
        type_ObjectDescriptor = 7,
        type_External         = 8,
        type_Real             = 9,
        type_Enumerated       = 10,
        type_Sequence         = 16,
        type_Set              = 17,
        type_NumericString    = 18,
        type_PrintableString  = 19,
        type_TeletexString    = 20,
        type_VideotexString   = 21,
        type_IA5String        = 22,
        type_UniversalTime    = 23,
        type_GeneralizedTime  = 24,
        type_GraphicString    = 25,
        type_VisibleString    = 26,
        type_GeneralString    = 27,
        type_UnicodeString    = 30,
        type_Of               = 100,
        type_SequenceOf       = 116,    // Sequence + Of
        type_SetOf            = 117,    // Set + Of
        type_Tag              = 200,
        type_Choice           = 300,
        type_Any              = 400 };

    enum FillState {
        fill_Empty   = 0,
        fill_Present = 1,
        fill_Partial = 2,
        fill_Defaulted = 3,
        fill_Optional = 4,
        fill_NoElements = 5 };

    enum ChildActions {
        act_Cleared = 1,
        act_Written };


    //  Properties

    CAsnObject *m_pasnParent;

    CDynamicArray<CAsnObject> m_rgEntries;

    DWORD m_dwType;
    DWORD m_dwTag;
    DWORD m_dwFlags;
    FillState m_State;
    CBuffer m_bfDefault;


    //  Methods

    virtual LONG
    _decode(             // Load an encoding into the object
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrc);

    virtual LONG
    _encLength(         // Return the length of the encoded object if it's there
        void) const;

    virtual LONG
    _encode(            // Encode the object, no presence checking.
        OUT LPBYTE pbDst)
    const;

    virtual void
    Adopt(
        IN CAsnObject *pasnParent);

    virtual CAsnObject *
    Clone(              // Create an identical object type.
        IN DWORD dwFlags)
    const = 0;

    virtual void
    ChildAction(        // Child notification method.
        IN ChildActions action,
        IN CAsnObject *pasnChild);

    virtual BOOL
    Complete(           // Is all data accounted for?
        void) const;

    virtual BOOL
    Exists(             // Is all data available to be read?
        void) const;

    virtual FillState   // Current fill state.
    State(
        void) const;

    virtual BOOL
    TypeCompare(        // Compare the types of objects.
        const CAsnObject &asnObject)
    const;

    virtual LONG
    Compare(            // Return a comparison to another object.
        const CAsnObject &asnObject)
    const;

    virtual LONG
    _copy(              // Copy another object to this one.
        const CAsnObject &asnObject);

    LONG
    virtual EncodeTag(  // Place encoding of tag, return length of encoding
        OUT LPBYTE pbDst)
    const;

    virtual LONG
    EncodeLength(       // Place encoding of Length, return length of encoding
        OUT LPBYTE pbDest)
    const;

    virtual LONG
    EncodeData(         // Place encoding of Data, return length of encoding
        OUT LPBYTE pbDest)
    const;

    virtual LONG
    SetDefault(         // Set the current value to be the default value.
        void);

    virtual LONG
    DecodeData(         // Read data in encoding format.
        IN const BYTE FAR *pbSrc,
        IN DWORD cbSrc,
        IN DWORD dwLength);

    virtual LONG
    EncodeLength(       // Place encoding of given Length, return length of encoding
        OUT LPBYTE pbDest,
        IN LONG lSize)
    const;
};

#endif // _ASNOBJCT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\licecert\licecert.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    licecert.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Frederick Chong - June. 23rd 1998

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

C_DEFINES = \
    $(C_DEFINES) \
    $(CLIENT_EXE_CDEFS)

#
# List of sources
#

SOURCES_PLATFORM =

CLIENT_SOURCES_RC = \

CLIENT_SOURCES_COMMON = \
    certcate.cpp \
    ostring.cpp \
    pkcs_err.cpp \
    utility.cpp \
    x509.cpp \
    pkcs_1.cpp \
    crtstore.cpp \
    licecert.cpp \

CLIENT_SOURCES_LAST  = \
    names.cpp

SOURCES = \
    $(CLIENT_SOURCES_RC) \
    $(SOURCES_PLATFORM) \
    $(CLIENT_SOURCES_COMMON) \
    $(CLIENT_SOURCES_LAST)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\licecert\licecert.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    licecert.cpp

Abstract:

    This module contains the APIs for parsing and verifying X509 certificates

Author:

    Frederick Chong (fredch) 6/1/1998

Environment:

    Win32, WinCE, Win16

Notes:

--*/

#include <windows.h>

#include "license.h"
#include "certcate.h"
#include "licecert.h"

#define MAX_NUM_CERT_BLOBS 200

//+----------------------------------------------------------------------------
//
// Function:
//
//  VerifyCertChain
//
// Abstract:
//
//  Verifies a chain of X509 certificates
//
// Parameters:
//
//  pbCert - Points to the certificate chain
//  cbCert - Size of the certificate chain
//  pbPublicKey - The memory to store the public key of the subject on output.
//                If set to NULL on input, the API will return 
//                LICENSE_STATUS_INSUFFICIENT_BUFFER and the size of the 
//                required buffer set in pcbPublicKey.
//  pcbPublicKey - Size of the allocated memory on input.  On output, contains
//                 the actual size of the public key.
//  pfDates - How the API should check the validity dates in the cert chain.
//            This flag may be set to the following values:
//
//  CERT_DATE_ERROR_IF_INVALID - The API will return an error if the
//                               dates are invalid. When the API returns,
//                               this flag will be set to CERT_DATE_OK if the
//                               dates are OK or one of CERT_DATE_NOT_BEFORE_INVALID
//                               or CERT_DATE_NOT_AFTER_INVALID.
//  CERT_DATE_DONT_VALIDATE - Don't validate the dates in the cert chain.  The value
//                            in this flag is not changed when the API returns. 
//  CERT_DATE_WARN_IF_INVALID - Don't return an error for invalid cert dates.
//                              When the API returns, this flag will be set to
//                              CERT_DATE_OK if the dates are OK or one of
//                              CERT_DATE_NOT_BEFORE_INVALID or 
//                              CERT_DATE_NOT_AFTER_INVALID.
//
// Return:
//
//  LICENSE_STATUS_OK if the function is successful.
//
//+----------------------------------------------------------------------------
 
LICENSE_STATUS
VerifyCertChain( 
    LPBYTE  pbCert, 
    DWORD   cbCert,
    LPBYTE  pbPublicKey,
    LPDWORD pcbPublicKey,
    LPDWORD pfDates )
{
    PCert_Chain 
        pCertChain = ( PCert_Chain )pbCert;
    UNALIGNED Cert_Blob 
        *pCertificate;
    BYTE FAR * 
        abCertAligned;
    LPBYTE
        lpCertHandles = NULL;
    LPCERTIFICATEHANDLE phCert;

    LICENSE_STATUS
        dwRetCode = LICENSE_STATUS_OK;
    DWORD
        dwCertType = CERTYPE_X509, 
        dwIssuerLen, 
        i,
        cbCertHandles = 0;
    BOOL
        fRet;

    if( ( NULL == pCertChain ) || ( sizeof( Cert_Chain ) >= cbCert ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // check cert chain version
    //

    if( MAX_CERT_CHAIN_VERSION < GET_CERTIFICATE_VERSION( pCertChain->dwVersion ) )
    {
        return( LICENSE_STATUS_NOT_SUPPORTED );
    }

    //
    // allocate memory for the certificate handles
    //

    // arbitrary limit of blobs, so that cbCertHandles doesn't overflow
    if (pCertChain->dwNumCertBlobs > MAX_NUM_CERT_BLOBS)
    {
        return (LICENSE_STATUS_INVALID_INPUT);
    }

    //
    // Verify input data before actually allocate memory
    //
    pCertificate = (PCert_Blob)&(pCertChain->CertBlob[0]);
    for(i=0; i < pCertChain->dwNumCertBlobs; i++)
    {
        if (((PBYTE)pCertificate > (pbCert + (cbCert - sizeof(Cert_Blob)))) ||
            (pCertificate->cbCert == 0) ||
            (pCertificate->cbCert > (DWORD)((pbCert + cbCert) - pCertificate->abCert)))
        {
            return (LICENSE_STATUS_INVALID_INPUT);
        }

        pCertificate = (PCert_Blob)(pCertificate->abCert + pCertificate->cbCert);
    }

    cbCertHandles = sizeof( CERTIFICATEHANDLE ) * pCertChain->dwNumCertBlobs;
    lpCertHandles = new BYTE[ cbCertHandles ];
    
    if( NULL == lpCertHandles )
    {
        return( LICENSE_STATUS_OUT_OF_MEMORY );
    }

    memset( lpCertHandles, 0, cbCertHandles );

    //
    // Load all the certificates into memory.  The certificate chain always
    // start with the root issuer's certificate
    //

    for( i = 0, pCertificate = pCertChain->CertBlob, phCert = ( LPCERTIFICATEHANDLE )lpCertHandles; 
         i < pCertChain->dwNumCertBlobs; i++, phCert++ )
    {
        if (i != 0)
        {
            if (pCertificate->abCert == NULL)
            {
                abCertAligned = NULL;
            }
            else
            {
                abCertAligned = new BYTE[pCertificate->cbCert];
                if (NULL == abCertAligned)
                {
                    dwRetCode = LICENSE_STATUS_OUT_OF_MEMORY;
                    goto done;
                }

                memcpy(abCertAligned,pCertificate->abCert,pCertificate->cbCert);
            }
        }
        else
        {
            //
            // First item is always aligned
            //
            abCertAligned = pCertificate->abCert;
        }

        fRet = PkcsCertificateLoadAndVerify( phCert,
                                             abCertAligned,
                                             pCertificate->cbCert,
                                             &dwCertType,
                                             CERTSTORE_APPLICATION,
                                             CERTTRUST_NOONE,
                                             NULL,
                                             &dwIssuerLen,
                                             NULL,
                                             pfDates );

        if ((abCertAligned != NULL) && (abCertAligned != pCertificate->abCert))
        {
            delete [] abCertAligned;
        }

        if( !fRet )
        {
            dwRetCode = GetLastError();
            goto done;
        }

        pCertificate = (PCert_Blob )(pCertificate->abCert + pCertificate->cbCert);
    }

    //
    // Get the public key of the last certificate
    //

    if( !PkcsCertificateGetPublicKey( *( phCert - 1), pbPublicKey, pcbPublicKey ) )
    {
        dwRetCode = GetLastError();
    }

done:

    //
    // free all the certificate handles
    //

    if( lpCertHandles )
    {        
        for( i = 0, phCert = ( LPCERTIFICATEHANDLE )lpCertHandles;
             i < pCertChain->dwNumCertBlobs; i++, phCert++ )
        {
            if( *phCert )
            {
                PkcsCertificateCloseHandle( *phCert );
            }
        }

        delete [] lpCertHandles;
    }

    return( dwRetCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\licecert\certcate.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    certcate.cpp

Abstract:

    This module contains the implementation of routines for loading and
    verifying X509 certifcates.  It is adapted from Doug Barlow's
    PKCS library.

Author:

    Frederick Chong (fredch) 6/1/1998

Environment:

    Win32, WinCE, Win16

Notes:

--*/

#include <windows.h>

#include <objbase.h>

#include <math.h>
#ifndef OS_WINCE
#include <stddef.h>
#endif // ndef OS_WINCE
#include "certcate.h"
#include "crtStore.h"

#include "licecert.h"
#include "utility.h"
#include "pkcs_err.h"

#include "rsa.h"
#include "md5.h"
#include "sha.h"
#include "tssec.h"

//
//-----------------------------------------------------------------------------
// The number of padding bytes as recommended by PKCS #1
//

static const DWORD
    rgdwZeroes[2]
        = { 0, 0 };

//
//-----------------------------------------------------------------------------
//
// certificate handle management
//

static const BYTE
    HANDLE_CERTIFICATES     = 1;

static CHandleTable<CCertificate>
    grgCertificateHandles(
        HANDLE_CERTIFICATES);

static void
CvtOutString(
    IN const COctetString &osString,
    OUT LPBYTE pbBuffer,
    IN OUT LPDWORD pcbLength);


extern CCertificate *
MapCertificate(
    IN const BYTE FAR * pbCertificate,
    IN DWORD cbCertificate,
    IN DWORD dwTrust,
    IN OUT LPDWORD pdwType,
    IN OUT LPDWORD pfStore,
    OUT LPDWORD pdwWarnings,
    OUT COctetString &osIssuer,
    IN OUT LPDWORD pfDates,
    IN BOOL fRunOnce = FALSE );


/*++

MapCertificate:

    This routine tries to parse the given certificate until it can determine the
    actual type, creates that type, and returns it as a CCertificate object.

Arguments:

    pbCertificate - Supplies the certificate containing the key to be loaded.

    dwTrust - Supplies the level of trust to be used in certificate validation.

    pdwType - Supplies the type of the certificate, or CERTYPE_UNKNOWN if it is
        not known.  It receives the actual type of the certificate.

    pfStore - Supplies the minimum acceptable Certificate Store, and receives
        the store of the certifying root key.

    pdwWarnings - Receives any warning flags.  Warning flags can be any of the
        following, OR'ed together:

            CERTWARN_NO_CRL - At least one of the signing CAs didn't have an
                associated CRL.
            CERTWARN_EARLY_CRL - At least one of the signing CAs had an
                associated CRL who's issuing date was in the future.
            CERTWARN_LATE_CRL - At least one of the signing CAs had an expired
                CRL.
            CERTWARN_TOBEREVOKED - At least one of the signing CAs contained a
                revocation for a certificate, but its effective date has not yet
                been reached.

    osIssuer - Receives the name of the root authority, or on error, receives
        the name of the missing Issuer.

    fRunOnce - Used as an internal recursion control parameter.  Should be set to FALSE for
        a normal call, then is reset to true as we recurse to allow the dwTrust parameter
        to take effect.

Return Value:

    The correct CCertificate subclass.  Errors are thrown.

Author:

    Doug Barlow (dbarlow) 9/26/1995
    Frederick Chong (fredch) - modified 6/1/98

--*/

CCertificate *
MapCertificate(
    IN const BYTE FAR * pbCertificate,
    IN DWORD cbCertificate,
    IN DWORD dwTrust,
    IN OUT LPDWORD pdwType,
    IN OUT LPDWORD pfStore,
    OUT LPDWORD pdwWarnings,
    OUT COctetString &osIssuer,
    IN BOOL fRunOnce,
    IN OUT LPDWORD pfDates )
{
    CCertificate *pCert = NULL;
    LONG lth = -1;

    if( CERTYPE_UNKNOWN == *pdwType )
    {
        //
        // only support X509 certificate
        //

        Certificate * pAsnX509Cert;

        pAsnX509Cert = new Certificate;

        if( NULL == pAsnX509Cert )
        {
            ErrorThrow( PKCS_NO_MEMORY );
        }

        lth = pAsnX509Cert->Decode(pbCertificate,cbCertificate);

        delete pAsnX509Cert;

        if( 0 < lth )
        {
            ErrorThrow(PKCS_BAD_PARAMETER);
        }
    }
    else if( CERTYPE_X509 != *pdwType )
    {
        ErrorThrow(PKCS_BAD_PARAMETER);
    }

    //
    // create the X509 certificate object.
    //

    pCert = new CX509Certificate;

    if (NULL == pCert)
        ErrorThrow(PKCS_NO_MEMORY);

    pCert->Load(
        pbCertificate,
        cbCertificate,
        dwTrust,
        pfStore,
        pdwWarnings,
        osIssuer,
        pfDates,
        fRunOnce );

    ErrorCheck;

    *pdwType = pCert->Type();
    return pCert;

ErrorExit:

    if (NULL != pCert)
        delete pCert;

    return NULL;
}


/*++

CvtOutString:

    This routine converts an Octet String to an output buffer & length pair,
    taking into account that the output pair might be invalid or NULL.

Arguments:

    osString - Supplies the octet string to be copied out.
    pbBuffer - Receives the value of the octet string.
    pcbLength - Supplies the size of the pbBuffer, and receives the length of
        the ouput string.

Return Value:

    0 - Success.
    Anything else is an error, and represents the suggested value to throw.

Author:

    Doug Barlow (dbarlow) 8/23/1995

--*/

static void
CvtOutString(
    IN const COctetString &osString,
    OUT LPBYTE pbBuffer,
    IN OUT LPDWORD pcbLength)
{
    if (NULL != pcbLength)
    {
        DWORD len = *pcbLength;         // We can read pcbLength.
        *pcbLength = osString.Length(); // We can write pcbLength.
        if (NULL != pbBuffer)
        {
            if (len >= osString.Length())
            {
                if (0 < osString.Length())
                    memcpy(pbBuffer, osString.Access(), osString.Length());
            }
            else
            {
                if (NULL != pbBuffer)
                    ErrorThrow(PKCS_BAD_LENGTH);
            }
        }
    }
    return;

ErrorExit:
    return;
}


/*++

PkcsCertificateLoadAndVerify:

    This method loads and validates a given certificate for use.

Arguments:

    pbCert - Supplies a buffer containing the ASN.1 certificate.
    cbCert - Size of the certificate buffer
    pdwType - Supplies the type of the certificate, or CERTYPE_UNKNOWN if it is
        not known.  It receives the actual type of the certificate.
    dwStore - Supplies an identification of which certificate store this
        certificate should be loaded into.  Options are:

            CERTSTORE_APPLICATION - Store in application volatile memory
            CERTSTORE_CURRENT_USER - Store permanently in Registry under current
                user
            CERTSTORE_LOCAL_MACHINE - Store permanently in Registry under local
                machine

    dwTrust - Supplies the level of trust to be used in certificate validation.
    szIssuerName - Receives the name of the root issuer, or on error, receives
        the name of a missing issuer, if any.
    pcbIssuerLen - Supplies the length of the szIssuerName buffer, and receives
        the full length of the above issuer name, including trailing null byte.
    pdwWarnings - Receives a set of bits indicating certificate validation
        warnings that may occur.  Possible bit setting values are:

            CERTWARN_NO_CRL - At least one of the signing CAs didn't have an
                associated CRL.
            CERTWARN_EARLY_CRL - At least one of the signing CAs had an
                associated CRL who's issuing date was in the future.
            CERTWARN_LATE_CRL - At least one of the signing CAs had an expired
                CRL.
            CERTWARN_TOBEREVOKED - At least one of the signing CAs contained a
                revocation for a certificate, but its effective date has not yet
                been reached.

Return Value:

    TRUE - Successful validation, conditional to the pdwWarnings flags.
    FALSE - Couldn't be validated.  See LastError for details.

Author:

    Doug Barlow (dbarlow) 8/23/1995
    Frederick Chong (fredch) 6/1/1998 - remove unecessary function parameters

--*/

BOOL WINAPI
PkcsCertificateLoadAndVerify(
    OUT LPCERTIFICATEHANDLE phCert,
    IN const BYTE FAR * pbCert,
    IN DWORD cbCert,
    IN OUT LPDWORD pdwType,
    IN DWORD dwStore,
    IN DWORD dwTrust,
    OUT LPTSTR szIssuerName,
    IN OUT LPDWORD pcbIssuerLen,
    OUT LPDWORD pdwWarnings,
    IN OUT LPDWORD pfDates )
{
    const void *
        pvHandle
            = NULL;
    COctetString
        osIssuer,
        osSerialNum;
    CDistinguishedName
        dnName,
        dnIssuer;
    DWORD
        dwIssLen
            = *pcbIssuerLen,
        fStore
            = dwStore,
        dwWarnings
            = 0,
        dwType
            = CERTYPE_UNKNOWN;
    CCertificate *
        pSigner = NULL;
    BOOL
        fTmp;

    //
    // Initializations.
    //

    ErrorInitialize;

    if (NULL != pdwType)
        dwType = *pdwType;
    if (NULL != pdwWarnings)
        *pdwWarnings = 0;

    //
    // Validate the certificate by loading it into a CCertificate.
    //

    if (NULL != szIssuerName && *pcbIssuerLen > 0)
    {
        *pcbIssuerLen = 0;
        *szIssuerName = 0;
    }
    pSigner = MapCertificate(
                    pbCert,
                    cbCert,
                    dwTrust,
                    &dwType,
                    &fStore,
                    &dwWarnings,
                    osIssuer,
                    TRUE,
                    pfDates );
    CvtOutString(osIssuer, (LPBYTE)szIssuerName, &dwIssLen);
    *pcbIssuerLen = dwIssLen;
    ErrorCheck;
    pvHandle = grgCertificateHandles.Add(pSigner);
    ErrorCheck;

    //
    // Load the Certificate into the certificate store.
    //

    dnName.Import(pSigner->Subject());
    ErrorCheck;
    AddCertificate(dnName, pbCert, cbCert, dwType, dwStore);
    ErrorCheck;
    if (pSigner->HasParent())
    {
        dnIssuer.Import(pSigner->Issuer());
        ErrorCheck;
        pSigner->SerialNo(osSerialNum);
        ErrorCheck;
        AddReference(
            dnName,
            dnIssuer,
            osSerialNum.Access(),
            osSerialNum.Length(),
            dwStore);
        ErrorCheck;
    }


    //
    // Tell it all to the caller.
    //

    if (NULL != pdwType)
        *pdwType = dwType;
    if (NULL != pdwWarnings)
        *pdwWarnings = dwWarnings;

    *phCert = pvHandle;

    return MapError();

ErrorExit:

    if (NULL != pvHandle)
        grgCertificateHandles.Delete(pvHandle);

    return MapError();
}



/*++

PkcsGetPublicKey:

    This method retrieves the public key in an X509 certificate

Arguments:

    hCert - Handle to a certificate.
    lpPubKey - Memory to receive the public key
    lpcbPubKey - Size of the above memory

Return Value:

    TRUE - Successful validation, conditional to the pdwWarnings flags.
    FALSE - Couldn't be validated.  See LastError for details.

Author:

    Frederick Chong (fredch) 6/1/1998

--*/

BOOL WINAPI
PkcsCertificateGetPublicKey(
    CERTIFICATEHANDLE   hCert,
    LPBYTE              lpPubKey,
    LPDWORD             lpcbPubKey )
{
    CCertificate *pCert;

    ErrorInitialize;

    pCert = grgCertificateHandles.Lookup(hCert);
    ErrorCheck;

    pCert->GetPublicKey( lpPubKey, lpcbPubKey );
    ErrorCheck;

    return MapError();

ErrorExit:

    return MapError();
}


BOOL WINAPI
PkcsCertificateCloseHandle(
    CERTIFICATEHANDLE   hCert )
{
    CCertificate *pSigner;
    CDistinguishedName dnName;

    ErrorInitialize;
    pSigner = grgCertificateHandles.Lookup(hCert);
    ErrorCheck;
    dnName.Import(pSigner->Subject());
    ErrorCheck;
    DeleteCertificate(dnName);
    ErrorCheck;
    grgCertificateHandles.Delete(hCert);
    ErrorCheck;
    return TRUE;

ErrorExit:
    return MapError();

}


//
//==============================================================================
//
//  CCertificate
//


//
// Trivial Methods
//

IMPLEMENT_NEW(CCertificate)

CCertificate::CCertificate()
{ Init(); }

CCertificate::~CCertificate()
{ Clear(); }

void
CCertificate::Load(
    IN const BYTE FAR * pbCertificate,
    IN DWORD cbCertificate,
    IN DWORD dwTrust,
    IN OUT LPDWORD pfStore,
    OUT LPDWORD pdwWarnings,
    OUT COctetString &osIssuer,
    IN OUT LPDWORD pfDates,
    IN BOOL fRunOnce )
{
    ErrorThrow(PKCS_INTERNAL_ERROR);    // Should never be called.
ErrorExit:
    return;
}

const Name &
CCertificate::Subject(
    void)
const
{
    ErrorThrow(PKCS_INTERNAL_ERROR);    // Should never be called.
ErrorExit:
    return *(Name *)NULL;
}

DWORD
CCertificate::Type(
    void)
const
{
    ErrorThrow(PKCS_INTERNAL_ERROR);    // Should never be called.
ErrorExit:
    return 0;
}

BOOL
CCertificate::HasParent(
    void)
const
{
    return FALSE;
}

const Name &
CCertificate::Issuer(
    void)
const
{
    ErrorThrow(PKCS_INTERNAL_ERROR);    // Should never be called.
ErrorExit:
    return *(Name *)NULL;
}

void
CCertificate::SerialNo(
    COctetString &osSerialNo)
const
{
    ErrorThrow(PKCS_INTERNAL_ERROR);    // Should never be called.
ErrorExit:
    return;
}


/*++

Init:

    This method initializes the object to a default state.  It does not perform
    any deletion of allocated objects.  Use Clear for that.

Arguments:

    none

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 9/26/1995

--*/

void
CCertificate::Init(
    void)
{
}


/*++

Clear:

    This routine clears out all allocations of the object and returns it to its
    initial state.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 9/26/1995

--*/

void
CCertificate::Clear(
    void)
{
    Init();
}


/*++

Verify:

    This method uses the underlying Public Key from the certificate to validate
    a signature on a given block of data.

Arguments:

    pbSigned supplies the data that was signed.
    cbSignedLen supplies the length of that data, in bytes.
    algIdSignature supplies the signature type used to generate the signature.
    szDescription supplies a description string incorporated into the hash.
        This parameter may be NULL if no such string was used.
    pbSignature supplies the signature in DWORD format.
    cbSigLen supplies the length of the signature.

Return Value:

    None.  A DWORD is thrown on errors.

Author:

    Frederick Chong (fredch) 5/30/98

--*/

void
CCertificate::Verify(
    IN const BYTE FAR * pbSigned,
    IN DWORD cbSigned,
    IN DWORD cbSignedLen,
    IN ALGORITHM_ID algIdSignature,
    IN LPCTSTR szDescription,
    IN const BYTE FAR * pbSignature,
    IN DWORD cbSigLen)
    const
{
    DWORD
        dwHashAlg,
        dwHashLength;

    LPBSAFE_PUB_KEY
        pBsafePubKey = ( LPBSAFE_PUB_KEY  )m_osPublicKey.Access();
    MD5_CTX
        Md5Hash;
    A_SHA_CTX
        ShaHash;
    LPBYTE
        pbHashData;
    BYTE
        abShaHashValue[A_SHA_DIGEST_LEN];
    COctetString
        osSignedData,
        osSignature,
        osHashData;
    BOOL
        bResult = TRUE;

    //
    // Verify the signature.
    //

    dwHashAlg = GET_HASH_ALG(algIdSignature);


    //
    // only support RSA signing
    //

    if( SIGN_ALG_RSA != ( GET_SIGN_ALG(algIdSignature) ) )
    {
        ErrorThrow(PKCS_BAD_PARAMETER);
    }

    //
    // compute the hash
    //

    if( HASH_ALG_MD5 == dwHashAlg )
    {
        //
        // calculate MD5 hash
        //

        if (cbSigned < cbSignedLen)
        {
            ErrorThrow(PKCS_BAD_PARAMETER);
        }

        MD5Init( &Md5Hash );
        MD5Update( &Md5Hash, pbSigned, cbSignedLen );
        MD5Final( &Md5Hash );
        pbHashData = Md5Hash.digest,
        dwHashLength = MD5DIGESTLEN;
    }
    else if( ( HASH_ALG_SHA == dwHashAlg ) || ( HASH_ALG_SHA1 == dwHashAlg ) )
    {
        //
        // calculate SHA hash
        //

        if (cbSigned < cbSignedLen)
        {
            ErrorThrow(PKCS_BAD_PARAMETER);
        }

        A_SHAInit( &ShaHash );
        A_SHAUpdate( &ShaHash, ( LPBYTE )pbSigned, cbSignedLen );
        A_SHAFinal( &ShaHash, abShaHashValue );
        pbHashData = abShaHashValue;
        dwHashLength = A_SHA_DIGEST_LEN;
    }
    else
    {
        //
        // no support for other hash algorithm
        //

        ErrorThrow( PKCS_BAD_PARAMETER );
    }

    osSignature.Resize( cbSigLen + sizeof( rgdwZeroes ) );
    ErrorCheck;

    osSignature.Set(pbSignature, cbSigLen);
    ErrorCheck;

    osSignature.Append( ( const unsigned char * )rgdwZeroes, sizeof( rgdwZeroes ) );
    ErrorCheck;

    osSignedData.Resize( pBsafePubKey->keylen );
    ErrorCheck;
    memset( osSignedData.Access(), 0x00, osSignedData.Length() );

    if( !( bResult = BSafeEncPublic( pBsafePubKey, osSignature.Access(), osSignedData.Access() ) ) )
    {
        ErrorThrow( PKCS_CANT_VALIDATE );
    }
    else
    {
        ErrorInitialize;
    }

    PkcsToDword( osSignedData.Access(), osSignedData.Length() );

    GetHashData( osSignedData, osHashData );
    ErrorCheck;

    if( 0 != memcmp( osHashData.Access(), pbHashData,
                     osHashData.Length() > dwHashLength ?
                     dwHashLength : osHashData.Length() ) )
    {
        ErrorThrow( PKCS_CANT_VALIDATE );
    }

    return;

ErrorExit:

    return;
}


/*++

GetPublicKey

    This method retrieves the public key in a certificate

Arguments:

    pbPubKey Memory to copy the public key to
    lpcbPubKey Size of the memory

Return Value:

    None.  A DWORD is thrown on errors.

Author:

    Frederick Chong (fredch) 5/30/98

--*/

void
CCertificate::GetPublicKey(
    IN LPBYTE pbPubKey,
    IN OUT LPDWORD lpcbPubKey )
    const
{
    DWORD cbKeySize = m_osPublicKey.Length();

    if( 0 >= cbKeySize )
    {
        ErrorThrow( PKCS_INTERNAL_ERROR )
    }

    if( ( *lpcbPubKey < cbKeySize ) || ( NULL == pbPubKey ) )
    {
        ErrorThrow( PKCS_BAD_LENGTH );
    }

    memcpy( pbPubKey, m_osPublicKey.Access(), cbKeySize );
    *lpcbPubKey = cbKeySize;

    return;

ErrorExit:

    *lpcbPubKey = cbKeySize;

    return;
}


//
//==============================================================================
//
//  CX509Certificate
//

//
// Trivial Methods
//

IMPLEMENT_NEW(CX509Certificate)

CX509Certificate::CX509Certificate()
{
    Init();
}

CX509Certificate::~CX509Certificate()
{
    Clear();
}

const Name &
CX509Certificate::Subject(
    void)
const
{
    return m_asnCert.subject;
}

const CertificateToBeSigned &
CX509Certificate::Coding(
    void)
const
{
    return m_asnCert;
}

DWORD
CX509Certificate::Type(
    void)
const
{
    return CERTYPE_X509;
}

const Name &
CX509Certificate::Issuer(
    void)
const
{
    return m_asnCert.issuer;
}

void
CX509Certificate::SerialNo(
    COctetString &osSerialNo)
const
{
    LONG lth;
    lth = m_asnCert.serialNumber.DataLength();
    if (0 > lth)
        ErrorThrow(PKCS_ASN_ERROR);
    osSerialNo.Resize(lth);
    ErrorCheck;
    lth = m_asnCert.serialNumber.Read(osSerialNo.Access());
    if (0 > lth)
        ErrorThrow(PKCS_ASN_ERROR);
ErrorExit:
    return;
}


/*++

Init:

    This method initializes the object to a default state.  It does not perform
    any deletion of allocated objects.  Use Clear for that.

Arguments:

    none

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 9/26/1995

--*/

void
CX509Certificate::Init(
    void)
{
    CCertificate::Init();
}


/*++

Clear:

    This routine clears out all allocations of the object and returns it to its
    initial state.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 9/26/1995

--*/

void
CX509Certificate::Clear(
    void)
{
    m_asnCert.Clear();
    CCertificate::Clear();
    Init();
}


void
CX509Certificate::Load(
    IN const BYTE FAR * pbCertificate,
    IN DWORD cbCertificate,
    IN DWORD dwTrust,
    IN OUT LPDWORD pfStore,
    OUT LPDWORD pdwWarnings,
    OUT COctetString &osIssuer,
    IN OUT LPDWORD pfDates,
    IN BOOL fRunOnce )
{
    CCertificate *
        pcrtIssuer
            = NULL;

    Load2(
        pbCertificate,
        cbCertificate,
        dwTrust,
        pfStore,
        pdwWarnings,
        osIssuer,
        fRunOnce,
        &pcrtIssuer,
        pfDates );

    if ((NULL != pcrtIssuer) && (pcrtIssuer != this))
        delete pcrtIssuer;
}



void
CX509Certificate::Load2(
    IN const BYTE FAR * pbCertificate,
    IN DWORD cbCertificate,
    IN DWORD dwTrust,
    IN OUT LPDWORD pfStore,
    OUT LPDWORD pdwWarnings,
    OUT COctetString &osIssuer,
    IN BOOL fRunOnce,
    OUT CCertificate **ppcrtIssuer,
    IN OUT LPDWORD pfDates )
{
    Certificate *
        pAsnCert = NULL;
    CDistinguishedName
        dnIssuer;
    CCertificate *
        pcrtIssuer
            = NULL;
    COctetString
        osCert,
        osIssuerCRL;
    DWORD
        dwWarnings
            = 0,
        length,
        offset,
        dwType,
        count,
        index,
        version;
    BOOL
        fTmp,
        fRoot
            = FALSE;
    FILETIME
        tmNow,
        tmThen;
    SYSTEMTIME
        sysTime;

    pAsnCert = new Certificate;

    if( NULL == pAsnCert )
    {
        ErrorThrow( PKCS_NO_MEMORY );
    }

    //
    // Properly initialize the object.
    //

    Clear();
    if (NULL != pdwWarnings)
        *pdwWarnings = 0;
    osIssuer.Empty();

    if (0 > pAsnCert->Decode(pbCertificate, cbCertificate))
        ErrorThrow(PKCS_ASN_ERROR);

    if (0 > m_asnCert.Copy(pAsnCert->toBeSigned))
    {
        TRACE("Copy failure")
        ErrorThrow(PKCS_ASN_ERROR);
    }
    PKInfoToBlob(
        m_asnCert.subjectPublicKeyInfo,
        m_osPublicKey);
    ErrorCheck;

    //
    // First simple checks.
    //

    if (m_asnCert.version.Exists())
    {
        version = m_asnCert.version;
        if (X509_MAX_VERSION < version)
            ErrorThrow(PKCS_NO_SUPPORT);       // Version 3 maximum.
    }
    else
        version = X509_VERSION_1;


    if( CERT_DATE_DONT_VALIDATE != *pfDates )
    {
        //
        // Check the validity dates.
        //

        GetSystemTime( &sysTime );

        if( !SystemTimeToFileTime( &sysTime, &tmNow ) )
        {
            ErrorThrow( PKCS_CANT_VALIDATE );
        }

        tmThen = m_asnCert.validity.notBefore;
        if(1 == CompareFileTime(&tmThen, &tmNow))
        {
            if( CERT_DATE_ERROR_IF_INVALID == *pfDates )
            {
                //
                // invalid date results in cert validation error
                //

                *pfDates = CERT_DATE_NOT_BEFORE_INVALID;
                ErrorThrow(PKCS_CANT_VALIDATE);
            }
            else
            {
                //
                // Not an error, return the date validation result.
                //

                *pfDates = CERT_DATE_NOT_BEFORE_INVALID;
                goto next_check;
            }
        }

        tmThen = m_asnCert.validity.notAfter;
        if (1 == CompareFileTime(&tmNow, &tmThen))
        {
            if( CERT_DATE_ERROR_IF_INVALID == *pfDates )
            {
                //
                // invalid date results in cert validation error
                //

                *pfDates = CERT_DATE_NOT_AFTER_INVALID;
                ErrorThrow(PKCS_CANT_VALIDATE);
            }

            //
            // Not an error, return the date validation result.
            //

            *pfDates = CERT_DATE_NOT_AFTER_INVALID;
        }
        else
        {
            //
            // Both dates are OK
            //

            *pfDates = CERT_DATE_OK;
        }
    }

next_check:

    //
    // Do we have to validate this certificate?
    //

    if ((CERTTRUST_NOCHECKS != dwTrust)
        && (fRunOnce ? (dwTrust != *pfStore) : TRUE))
    {

        //
        // Find the signer.
        //

        dnIssuer.Import(m_asnCert.issuer);
        ErrorCheck;
        fTmp = NameCompare(m_asnCert.issuer, m_asnCert.subject);
        ErrorCheck;
        if (fTmp)
        {

            //
            // This is a root key.  We just assume it's good, and that we don't
            // have any outstanding CRL entries against ourself.
            //

            fRoot = TRUE;
            pcrtIssuer = this;
            dnIssuer.Export(osIssuer);
            ErrorCheck;
        }
        else
        {
            COctetString
                osIssuerCert;

            fTmp =
                FindCertificate(
                    dnIssuer,
                    pfStore,
                    osIssuerCert,
                    osIssuerCRL,
                    &dwType);
            ErrorCheck;
            if (!fTmp)
            {
                dnIssuer.Export(osIssuer);
                ErrorThrow(PKCS_CANT_VALIDATE);
            }

            //
            // map the issuer certificate to a known certificate type, but this time
            // don't verify the issuer certificate again.
            //

            pcrtIssuer =
                MapCertificate(
                osIssuerCert.Access(),
                osIssuerCert.Length(),
                CERTTRUST_NOCHECKS,
                &dwType,
                pfStore,
                &offset,
                osIssuer,
                FALSE,
                pfDates );
            ErrorCheck;
            dwWarnings |= offset;
        }


        //
        // Validate the certificate against the signer's key.
        //

        VerifySignedAsn(
            *pcrtIssuer,
            pbCertificate,
            cbCertificate,
            NULL);      // No description attributes here.
        ErrorCheck;


        //
        // Validate the certificate against the signer's CRL.
        //

        if (0 != osIssuerCRL.Length())
        {
            CertificateRevocationList
                asnIssuerCRL;

            //
            // Check the signature on the CRL.
            //

            if (0 > asnIssuerCRL.Decode(osIssuerCRL.Access(), osIssuerCRL.Length()))
                ErrorThrow(PKCS_ASN_ERROR);
            VerifySignedAsn(
                *pcrtIssuer,
                osIssuerCRL.Access(),
                osIssuerCRL.Length(),
                NULL);
            ErrorCheck;


            //
            // Check the trivial fields, issuer and algorithm.
            //

            fTmp = NameCompare(
                m_asnCert.issuer, asnIssuerCRL.toBeSigned.issuer);
            ErrorCheck;
            if (!fTmp)
                ErrorThrow(PKCS_CANT_VALIDATE);
            if (m_asnCert.subjectPublicKeyInfo.algorithm
                != asnIssuerCRL.toBeSigned.signature)
                ErrorThrow(PKCS_CANT_VALIDATE);


            //
            // Validate the CRL times.
            //

            tmThen = asnIssuerCRL.toBeSigned.lastUpdate;
            if (1 == CompareFileTime(&tmThen, &tmNow))
                dwWarnings |= CERTWARN_EARLYCRL;
            if (asnIssuerCRL.toBeSigned.nextUpdate.Exists())
            {
                tmThen = asnIssuerCRL.toBeSigned.nextUpdate;
                if (1 == CompareFileTime(&tmNow, &tmThen))
                    dwWarnings |= CERTWARN_LATECRL;
            }
            else
            {
                if (asnIssuerCRL.toBeSigned.version.Exists())
                {
                    version = asnIssuerCRL.toBeSigned.version;
                    if (X509_VERSION_1 >= version)
                        ErrorThrow(PKCS_ASN_ERROR);
                }
                else
                    version = X509_VERSION_1;
            }


            //
            // Look for revocations of this certificate.
            //

            if (asnIssuerCRL.toBeSigned.revokedCertificates.Exists())
            {
                length = asnIssuerCRL.toBeSigned.revokedCertificates.Count();
                for (offset = 0; offset < length; offset += 1)
                {
                    if (asnIssuerCRL.toBeSigned.revokedCertificates[(int)offset]
                            .userCertificate
                        == m_asnCert.serialNumber)
                    {
                        tmThen = asnIssuerCRL.toBeSigned
                                    .revokedCertificates[(int)offset].revocationDate;
                        if (0 == FTINT(tmThen))
                            ErrorThrow(PKCS_ASN_ERROR);
                        if (1 == CompareFileTime(&tmThen, &tmNow))
                            dwWarnings |= CERTWARN_TOBEREVOKED;
                        else
                            ErrorThrow(PKCS_CANT_VALIDATE);
                    }
                }
            }
        }
        else
        {
            if (!fRoot)
                dwWarnings |= CERTWARN_NOCRL;
        }
    }
    else
    {
        dnIssuer.Import(m_asnCert.subject);
        ErrorCheck;
        dnIssuer.Export(osIssuer);
        ErrorCheck;
        TRACE("Implicit trust invoked on subject "
              << (LPCTSTR)osIssuer.Access());
    }


    //
    // Check the extensions list for anything critical.
    //

    count = m_asnCert.extensions.Count();
    for (index = 0; index < count; index += 1)
    {
        if (m_asnCert.extensions[(int)index].critical.Exists())
            if (m_asnCert.extensions[(int)index].critical)
                dwWarnings |= CERTWARN_CRITICALEXT;
    }


    //
    // Everything checks out.  Load up the object.
    //

    *ppcrtIssuer = pcrtIssuer;
    pcrtIssuer = NULL;
    if (NULL != pdwWarnings)
        *pdwWarnings = dwWarnings;

    if( pAsnCert )
    {
        delete pAsnCert;
    }

    return;

ErrorExit:
    if ((NULL != pcrtIssuer) && (pcrtIssuer != this))
        delete pcrtIssuer;

    if( pAsnCert )
    {
        delete pAsnCert;
    }

    Clear();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\licecert\crtstore.cpp ===
/*++

Copyright (c) 1995 - 1998  Microsoft Corporation

Module Name:

    CrtStore

Abstract:

    This file provides the certificate store functionality.  This version uses
    the registry for certificate store maintenance.  We actually maintain 3
    stores:

    *   The application store.  This is the default.  Certificates in the
        application store are maintained locally an forgotten once the
        application exits.

    *   The user store.  Certificates in this store are persistent,
        and are maintained in the registry under HKEY_CURRENT_USER.  They are
        available to any application executed in the context of the current
        user.

    *   The system store.  Certificates in this store are persistent, and are
        maintained in the registry under HKEY_LOCAL_MACHINE.  They are available
        to all users on this system.

Author:

    Doug Barlow (dbarlow) 8/14/1995
    Frederick Chong (fredch) 6/5/1998 - Delete all code that uses user and system store

Environment:

    Win32, Crypto API

Notes:



--*/

#include <windows.h>
#include <stdlib.h>
#include <msasnlib.h>
#include "ostring.h"
#include "pkcs_err.h"
#include "utility.h"
#include <memcheck.h>

class CAppCert
{
public:
    DECLARE_NEW

    COctetString
        m_name,
        m_cert,
        m_crl;
    DWORD
        m_dwType;
};
IMPLEMENT_NEW(CAppCert)

class CAppCertRef
{
public:
    DECLARE_NEW

    COctetString
        m_osIssuerSn,
        m_osSubject;
};
IMPLEMENT_NEW(CAppCertRef)

#if 0
class CAppSName
{
public:
    DECLARE_NEW
    COctetString
        m_osSimpleName,
        m_osDistinguishedName,
        m_osKeySet,
        m_osProvider;
    DWORD
        m_dwKeyType,
        m_dwProvType;
};
IMPLEMENT_NEW(CAppSName)
#endif

#define CERT_ID 8
#define CERTREF_ID 9


static CHandleTable<CAppCert>
    rgAppCerts(CERT_ID);

static CHandleTable<CAppCertRef>
    rgAppCertRefs(CERTREF_ID);

static COctetString
    osAppDNamePrefix;

static void
AddSerial(
    IN const BYTE FAR *pbSerialNo,
    IN DWORD cbSNLen,
    IN OUT COctetString &osOut);


/*++

AddCertificate:

    This routine adds a given certificate to the Certificate Store.  No
    validation is done on the certificate.

Arguments:

    szCertName - Supplies the name of the certificate.
    pbCertificate - Supplies the certificate to save.
    pbCRL - Supplies the CRL for this certificate.
    dwType - Supplies the type of certificate.
    fStore - Supplies the identifier for the store to be used.

Return Value:

    None.  A DWORD status code is thrown on errors.

Author:

    Doug Barlow (dbarlow) 8/14/1995

--*/

void
AddCertificate(
    IN const CDistinguishedName &dnName,
    IN const BYTE FAR *pbCertificate,
    IN DWORD cbCertificate,
    IN DWORD dwType,
    IN DWORD fStore)
{
    DWORD
        length,
        count,
        idx;
    DWORD
        dwCertLength = 0,
        dwCrlLength = 0;
    CAppCert *
        appCert;
    COctetString
        osSubject;

    ErrorCheck;
    dnName.Export(osSubject);
    ErrorCheck;

    length = ASNlength(pbCertificate, cbCertificate, &idx);
    dwCertLength = length + idx;

    switch (fStore)
    {
    case CERTSTORE_NONE:
        return;     // Not to be stored at all.
        break;

    case CERTSTORE_APPLICATION:
        appCert = NULL;
        count = rgAppCerts.Count();
        for (idx = 0; idx < count; idx += 1)
        {
            appCert = rgAppCerts.Lookup(
                        MAKEHANDLE(CERT_ID, idx), FALSE);
            if (NULL != appCert)
            {
                if (appCert->m_name == osSubject)
                    break;
                appCert = NULL;
            }
        }
        if (NULL == appCert)
            appCert = rgAppCerts.Lookup(rgAppCerts.Create());
        ErrorCheck;

        if (NULL == appCert)
        {
            ErrorThrow(PKCS_INVALID_HANDLE);
        }

        appCert->m_name = osSubject;
        ErrorCheck;

        if (cbCertificate < dwCertLength)
        {
            ErrorThrow(PKCS_BAD_PARAMETER);
        }

        appCert->m_cert.Set(pbCertificate, dwCertLength);
        ErrorCheck;
        appCert->m_dwType = dwType;
        return;
        break;

    default:
        ErrorThrow(PKCS_BAD_PARAMETER);
    }

    return;


ErrorExit:

    return;
}


/*++

AddReference:

    This routine adds a reference to a certificate to the certificate store.  No
    validation is performed.

Arguments:

    dnSubject - Supplies the name of the subject of the certificate.
    dnIssuer - Supplies the name of the Issuer of the certificate.
    pbSerialNo - Supplies the serial number.
    cbSNLen - Supplies the length of the serial number, in bytes.
    fStore - Supplies the identifier for the store to be used.

Return Value:

    None.  A DWORD status code is thrown on errors.

Author:

    Doug Barlow (dbarlow) 2/15/1996

--*/

void
AddReference(
    IN const CDistinguishedName &dnSubject,
    IN const CDistinguishedName &dnIssuer,
    IN const BYTE FAR *pbSerialNo,
    IN DWORD cbSNLen,
    IN DWORD fStore)
{
    COctetString
        osSubject,
        osIssuer,
        osSNum;
    CAppCertRef *
        appCertRef;
    DWORD
        count,
        idx;

    ErrorCheck;
    dnIssuer.Export(osIssuer);
    ErrorCheck;
    AddSerial(pbSerialNo, cbSNLen, osSNum);
    ErrorCheck;

    dnSubject.Export(osSubject);
    ErrorCheck;

    switch (fStore)
    {
    case CERTSTORE_NONE:
        return;     // Not to be stored at all.
        break;

    case CERTSTORE_APPLICATION:
        osIssuer.Resize(osIssuer.Length() - 1);
        ErrorCheck;
        osIssuer.Append(osSNum);
        ErrorCheck;
        appCertRef = NULL;
        count = rgAppCertRefs.Count();
        for (idx = 0; idx < count; idx += 1)
        {
            appCertRef = rgAppCertRefs.Lookup(
                        MAKEHANDLE(CERTREF_ID, idx), FALSE);
            if (NULL != appCertRef)
            {
                if (appCertRef->m_osIssuerSn == osIssuer)
                    break;
                appCertRef = NULL;
            }
        }
        if (NULL == appCertRef)
            appCertRef = rgAppCertRefs.Lookup(rgAppCertRefs.Create());
        ErrorCheck;

        if (NULL == appCertRef)
        {
            ErrorThrow(PKCS_INVALID_HANDLE);
        }

        appCertRef->m_osIssuerSn = osIssuer;
        appCertRef->m_osSubject = osSubject;
        ErrorCheck;
        return;
        break;
    default:
        ErrorThrow(PKCS_BAD_PARAMETER);
    }

ErrorExit:

    return;
}



/*++

FindCertificate:

    This routine searches the various certificate stores, looking for a match.
    It does not validate what it finds.

Arguments:

    dnName - Supplies the name to search for.
    pfStore - Supplies the minimum store to search in, and receives the store it
        was found in.
    osCertificate - Receives the requested certificate.
    osCRL - Receives the CRL for the requested certificate, if any.
    pdwType - Receives the type of the certificate.

Return Value:

    TRUE - Such a certificate was found.
    FALSE - No such certificate was found.
    A DWORD status code is thrown on errors.

Author:

    Doug Barlow (dbarlow) 8/14/1995

--*/

BOOL
FindCertificate(
    IN const CDistinguishedName &dnName,
    OUT LPDWORD pfStore,
    OUT COctetString &osCertificate,
    OUT COctetString &osCRL,
    OUT LPDWORD pdwType)
{
    COctetString
        osName;
    DWORD
        index,
        idx,
        count;
    CAppCert *
        appCert;


    //
    // Build the key name.
    //

    ErrorCheck;
    osCertificate.Empty();
    osCRL.Empty();
    dnName.Export(osName);
    ErrorCheck;

    //
    // Search for the key name in the various stores.
    //

    for (index = *pfStore;
         index <= CERTSTORE_LOCAL_MACHINE;
         index += 1)
    {
        switch (index)
        {
        case CERTSTORE_APPLICATION:
            count = rgAppCerts.Count();
            for (idx = 0; idx < count; idx += 1)
            {
                appCert = rgAppCerts.Lookup(
                            MAKEHANDLE(CERT_ID, idx), FALSE);
                ErrorCheck;
                if (NULL != appCert)
                {
                    if (appCert->m_name == osName)
                    {
                        osCertificate = appCert->m_cert;
                        ErrorCheck;
                        osCRL = appCert->m_crl;
                        ErrorCheck;
                        *pdwType = appCert->m_dwType;
                        *pfStore = CERTSTORE_APPLICATION;
                        return TRUE;
                    }
                }
            }
            continue;
            break;

        default:
            continue;   // Skip unknown values
        }


        //
        // If found, extract the fields.
        //
    }

    return FALSE;

ErrorExit:
    osCertificate.Empty();
    osCRL.Empty();

    return FALSE;
}


/*++

AddSerial:

    This routine appends a serial number in text format to the end of a suppled
    octet string.

Arguments:

    pbSerialNo supplies the address of the binary serial number.

    cbSNLen supplies the length of the serial number, in bytes.

    osOut receives the extension.

Return Value:

    None.  A status DWORD is thrown on errors.

Author:

    Doug Barlow (dbarlow) 2/15/1996

--*/

static void
AddSerial(
    IN const BYTE FAR *pbSerialNo,
    IN DWORD cbSNLen,
    IN OUT COctetString &osOut)
{
    static TCHAR szPrefix[] = TEXT("\\SN#");
    static TCHAR digits[] = TEXT("0123456789abcdef");
    TCHAR buf[2];
    DWORD index;

    index = osOut.Length();
    index += cbSNLen * 2 + sizeof(szPrefix);
    osOut.Length(index);
    ErrorCheck;

    osOut.Append((LPBYTE)szPrefix, sizeof(szPrefix) - sizeof(TCHAR));
    ErrorCheck;

    for (index = 0; index < cbSNLen; index += 1)
    {
        buf[0] = digits[pbSerialNo[index] >> 4];
        buf[1] = digits[pbSerialNo[index] & 0x0f];
        osOut.Append((LPBYTE)buf, sizeof(buf));
        ErrorCheck;
    }
    buf[0] = 0;
    osOut.Append((LPBYTE)buf, sizeof(TCHAR));
ErrorExit:
    return;
}


/*++

DeleteCertificate:

    This routine removes all occurences of the named certificate from the
    system.

Arguments:

    dnName - Supplies the name of the subject of the certificate to delete.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 8/23/1995
    Frederick Chong (fredch) 6/5/98 - Get rid of stores other than application

--*/

void
DeleteCertificate(
    IN const CDistinguishedName &dnName)
{
    COctetString
        osName;
    CAppCert *
        appCert;
    DWORD
        count,
        idx;

    //
    // Build the key name.
    //

    dnName.Export(osName);
    ErrorCheck;

    count = rgAppCerts.Count();
    for (idx = 0; idx < count; idx += 1)
    {
        appCert = rgAppCerts.Lookup( MAKEHANDLE(CERT_ID, idx), FALSE);
        ErrorCheck;
        if (NULL != appCert)
        {
            if (appCert->m_name == osName)
                rgAppCerts.Delete(MAKEHANDLE(CERT_ID, idx));
            ErrorCheck;
        }
    }

    return;

ErrorExit:

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\licecert\crtstore.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    CrtStore

Abstract:

    This header file describes the Certificate Store service.

Author:

    Doug Barlow (dbarlow) 8/14/1995

Environment:

    Win32, Crypto API

Notes:



--*/

#ifndef _CRTSTORE_H_
#define _CRTSTORE_H_

#include <msasnlib.h>
#include "names.h"
#include "ostring.h"


extern void
AddCertificate(
    IN const CDistinguishedName &dnName,
    IN const BYTE FAR *pbCertificate,
    IN DWORD cbCertificate,
    IN DWORD dwType,
    IN DWORD fStore);

extern void
DeleteCertificate(
    IN const CDistinguishedName &dnName);

extern void
AddReference(
    IN const CDistinguishedName &dnSubject,
    IN const CDistinguishedName &dnIssuer,
    IN const BYTE FAR *pbSerialNo,
    IN DWORD cbSNLen,
    IN DWORD fStore);

extern BOOL
FindCertificate(
    IN const CDistinguishedName &dnName,
    IN OUT LPDWORD pfStore,
    OUT COctetString &osCertificate,
    OUT COctetString &osCRL,
    OUT LPDWORD pdwType);

#endif // _CRTSTORE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\licecert\names.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    names

Abstract:

    This class supports a common internal name format.  It exists so that names
    can be easily accessed and converted from one format to another.

    This Class provides translations among the various supported name formats:

        X.500 ASN.1 BER
        Character Delimited
        ?Moniker?

    A Character Delimited name is of the form, '<RDName>;...;<RDName>', where
    each <RDName> is of the form, '[<type>=]<string>[,<type>=string,...]'.
    <type> is any of 'CTN', 'LOC', 'ORG', or 'OUN', from F.500, or an Object
    Identifier in the form, 'n1.n2.n3...' (n1 - n3 representing integers).
    <string> is any string of characters, excluding ';', and '\\'.

Author:

    Doug Barlow (dbarlow) 7/12/1995

Environment:

    Win32

Notes:



--*/

//#ifndef _WIN32_WINNT
//#define _WIN32_WINNT 0x0400
//#endif
#include <windows.h>
//#include <wincrypt.h>
#include <string.h>

#include "names.h"
#include "pkcs_err.h"

#ifdef OS_WINCE
#include "wince.h"
#endif // OS_WINCE

static const struct atributeTable {
    LPCTSTR name;
    LPCTSTR objectId;
    unsigned int tag;
    unsigned int minLength;
    unsigned int maxLength;
} knownAttributes[]
    = { //  Name            Object Id           Tag Min Max
        {   TEXT("COM"),    TEXT("2.5.4.3"),    19, 1,  64    },    // commonName
        {   TEXT("SUR"),    TEXT("2.5.4.4"),    19, 1,  64    },    // surname
        {   TEXT("SN"),     TEXT("2.5.4.5"),    19, 1,  64    },    // serialNumber
        {   TEXT("CTN"),    TEXT("2.5.4.6"),    19, 2,  2     },    // countryName
        {   TEXT("LOC"),    TEXT("2.5.4.7"),    19, 1,  128   },    // localityName
        {   TEXT("STN"),    TEXT("2.5.4.8"),    19, 1,  128   },    // stateOrProvinceName
        {   TEXT("SADD"),   TEXT("2.5.4.9"),    19, 1,  128   },    // streetAddress
        {   TEXT("ORG"),    TEXT("2.5.4.10"),   19, 1,  64    },    // organizationName
        {   TEXT("OUN"),    TEXT("2.5.4.11"),   19, 1,  64    },    // organizationalUnitName
        {   TEXT("TIT"),    TEXT("2.5.4.12"),   19, 1,  64    },    // title
        {   TEXT("DES"),    TEXT("2.5.4.13"),   19, 1,  1024  },    // description
        {   TEXT("BCTG"),   TEXT("2.5.4.15"),   19, 1,  128   },    // businessCategory
        {   TEXT("PCOD"),   TEXT("2.5.4.17"),   19, 1,  40    },    // postalCode
        {   TEXT("POB"),    TEXT("2.5.4.18"),   19, 1,  40    },    // postOfficeBox
        {   TEXT("PDO"),    TEXT("2.5.4.19"),   19, 1,  128   },    // physicalDeliveryOfficeName
        {   TEXT("TEL"),    TEXT("2.5.4.20"),   19, 1,  32    },    // telephoneNumber
        {   TEXT("X.121"),  TEXT("2.5.4.24"),   18, 1,  15    },    // x121Address
        {   TEXT("ISDN"),   TEXT("2.5.4.25"),   18, 1,  16    },    // internationalISDNNumber
        {   TEXT("DI"),     TEXT("2.5.4.27"),   19, 1,  128   },    // destinationIndicator
        {   TEXT("???"),    TEXT("0.0"),        19, 1,  65535 } };  // <trailer>

//      {   TEXT("KI"),     TEXT("2.5.4.2"),    19, 1,  65535 },    // knowledgeInformation (obsolete)
//      {   TEXT("SG"),     TEXT("2.5.4.14"),   0,  0,  0     },    // searchGuide
//      {   TEXT("PADD"),   TEXT("2.5.4.16"),   0,  0,  0     },    // postalAddress
//      {   TEXT("TLX"),    TEXT("2.5.4.21"),   0,  0,  0     },    // telexNumber
//      {   TEXT("TTX"),    TEXT("2.5.4.22")    0,  0,  0     },    // teletexTerminalIdentifier
//      {   TEXT("FAX"),    TEXT("2.5.4.23"),   0,  0,  0     },    // facimilieTelephoneNumber
//      {   TEXT("RADD"),   TEXT("2.5.4.26"),   0,  0,  0     },    // registeredAddress
//      {   TEXT("DLM"),    TEXT("2.5.4.28"),   0,  0,  0     },    // preferredDeliveryMethod
//      {   TEXT("PRADD"),  TEXT("2.5.4.29"),   0,  0,  0     },    // presentationAddress
//      {   TEXT("SAC"),    TEXT("2.5.4.30"),   0,  0,  0     },    // supportedApplicationContext
//      {   TEXT("MEM"),    TEXT("2.5.4.31"),   0,  0,  0     },    // member
//      {   TEXT("OWN"),    TEXT("2.5.4.32"),   0,  0,  0     },    // owner
//      {   TEXT("RO"),     TEXT("2.5.4.33"),   0,  0,  0     },    // roleOccupant
//      {   TEXT("SEE"),    TEXT("2.5.4.34"),   0,  0,  0     },    // seeAlso
//      {   TEXT("CLASS"),  TEXT("?.?"),        0,  0,  0     },    // Object Class
//      {   TEXT("A/B"),    TEXT("?.?"),        0,  0,  0     },    // Telex answerback (not yet in X.520)
//      {   TEXT("UC"),     TEXT("?.?"),        0,  0,  0     },    // User Certificate
//      {   TEXT("UP"),     TEXT("?.?"),        0,  0,  0     },    // User Password
//      {   TEXT("VTX"),    TEXT("?.?"),        0,  0,  0     },    // Videotex user number (not yet in X.520)
//      {   TEXT("O/R"),    TEXT("?.?"),        0,  0,  0     },    // O/R address (MHS) (X.400)

//      {   TEXT("ATR50"),  TEXT("2.5.4.50"),   19, 1,  64    },    // dnQualifier
//      {   TEXT("ATR51"),  TEXT("2.5.4.51"),   0,  0,  0     },    // enhancedSearchGuide
//      {   TEXT("ATR52"),  TEXT("2.5.4.52"),   0,  0,  0     },    // protocolInformation
//      {   TEXT("ATR7.1"), TEXT("2.5.4.7.1"),  19, 1,  128   },    // collectiveLocalityName
//      {   TEXT("ATR8.1"), TEXT("2.5.4.8.1"),  19, 1,  128   },    // collectoveStateOrProvinceName
//      {   TEXT("ATR9.1"), TEXT("2.5.4.9.1"),  19, 1,  128   },    // collectiveStreetAddress
//      {   TEXT("AT10.1"), TEXT("2.5.4.10.1"), 19, 1,  64    },    // collectiveOrganizationName
//      {   TEXT("AT11.1"), TEXT("2.5.4.11.1"), 19, 1,  64    },    // collectiveOrganizationalUnitName
//      {   TEXT("AT17.1"), TEXT("2.5.4.17.1"), 19, 1,  40    },    // collectivePostalCode
//      {   TEXT("AT18.1"), TEXT("2.5.4.18.1"), 19, 1,  40    },    // collectivePostOfficeBox
//      {   TEXT("AT19.1"), TEXT("2.5.4.19.1"), 19, 1,  128   },    // collectivePhysicalDeliveryOfficeName
//      {   TEXT("AT20.1"), TEXT("2.5.4.20.1"), 19, 1,  32    },    // collectiveTelephoneNumber
//      {   TEXT("AT21.1"), TEXT("2.5.4.21.1"), 0,  0,  0     },    // collectiveTelexNumber
//      {   TEXT("AT22.1"), TEXT("2.5.4.22.1")  0,  0,  0     },    // collectiveTeletexTerminalIdentifier
//      {   TEXT("AT23.1"), TEXT("2.5.4.23.1"), 0,  0,  0     },    // collectiveFacimilieTelephoneNumber
//      {   TEXT("AT25.1"), TEXT("2.5.4.25.1"), 18, 1,  16    },    // collectiveInternationalISDNNumber


static const DWORD
    KNOWNATTRIBUTESCOUNT
        = (sizeof(knownAttributes) / sizeof(struct atributeTable)) - 1;

#define ATR_COMMONNAME              0
#define ATR_UNKNOWN                 KNOWNATTRIBUTESCOUNT


//
//==============================================================================
//
//  CAttribute
//

IMPLEMENT_NEW(CAttribute)


/*++

TypeCompare:

    This method compares the type of a given attribute to this attribute's type.
    It provides a simplistic ordering of types, so that Attribute Lists can sort
    their attributes for comparison and conversion consistencies.

Arguments:

    atr - Supplies the attribute whose type is to be compared.

Return Value:

    <0 - The given attribute type comes before this attribute's type in an
         arbitrary but consistent ordering scheme.
    =0 - The given attribute type is the same as this attribute's type.
    >0 - The given attribute type comes after this attribute's type in an
         arbitrary but consistent ordering scheme.

Author:

    Doug Barlow (dbarlow) 7/14/1995

--*/

int
CAttribute::TypeCompare(
    IN const CAttribute &atr)
    const
{
    if (m_nType == atr.m_nType)
    {
        if (KNOWNATTRIBUTESCOUNT == m_nType)
            return strcmp( ( LPCSTR )( ( LPCTSTR )m_osObjId ), ( LPCSTR )( ( LPCTSTR )atr.m_osObjId ) );
        else
            return 0;
    }
    else
        return (int)(m_nType - atr.m_nType);
}


/*++

Compare:

    This method compares a supplied attribute to this attribute.  They are equal
    if both the attribute type and value match.

Arguments:

    atr - This supplies the attribute to be compared to this one.

Return Value:

    -1 - The type or value is less than this attribute.
     0 - The attributes are identical.
     1 - The type or value is greater than this attribute.

Author:

    Doug Barlow (dbarlow) 7/14/1995

--*/

int
CAttribute::Compare(
    IN const CAttribute &atr)
    const
{
    int dif;

    dif = TypeCompare(atr);
    if (0 == dif)
        dif = GetValue().Compare(atr.GetValue());
    return dif;
}


/*++

Set:

    These methods are used to set the type and value of an attribute.

    ?TODO?  Validate the string contents.

Arguments:

    szType - Supplies the type of the attribute.  NULL implies commonName.
    szValue - Supplies the value of the attribute as a string.  The value is
        converted to ASN.1 PrintableString format.
    pbValue - Supplies the value of the attribute, already encoded in ASN.1
    cbValLen - Supplies the length of the pbValue buffer.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 7/14/1995

--*/

void
CAttribute::Set(
    IN LPCTSTR szType,
    IN const BYTE FAR *pbValue,
    IN DWORD cbValLen)
{
    DWORD index;
    if (NULL == szType ? TRUE : 0 == *szType)
    {
        index = ATR_COMMONNAME;
        szType = knownAttributes[index].objectId;
    }
    else
    {
        for (index = 0; index < KNOWNATTRIBUTESCOUNT; index += 1)
        {
            if (0 == strcmp( ( char * )szType, ( char * )knownAttributes[index].objectId))
                break;
            if (0 == _stricmp( ( char * )szType, ( char * )knownAttributes[index].name))
            {
                szType = knownAttributes[index].objectId;
                break;
            }
        }
    }
    m_nType = index;
    m_osObjId = szType;
    m_osValue.Set(pbValue, cbValLen);
}

void
CAttribute::Set(
    IN LPCTSTR szType,
    IN LPCTSTR szValue)
{
    CAsnPrintableString asnString;   // ?todo? Support other string types.
    DWORD cbValLen = strlen( ( char * )szValue);
    DWORD index;
    LONG lth;

    if (NULL == szType ? TRUE : 0 == *szType)
    {
        index = ATR_COMMONNAME;
        szType = knownAttributes[index].objectId;
    }
    else
    {
        for (index = 0; index < KNOWNATTRIBUTESCOUNT; index += 1)
        {
            if (0 == strcmp( ( char * )szType, ( char * )knownAttributes[index].objectId))
                break;
            if (0 == _stricmp( ( char * )szType, ( LPCSTR )knownAttributes[index].name))
            {
                szType = knownAttributes[index].objectId;
                break;
            }
        }
    }

    if (index < KNOWNATTRIBUTESCOUNT)
    {
        if ((knownAttributes[index].minLength > cbValLen)
            || knownAttributes[index].maxLength < cbValLen)
            ErrorThrow(PKCS_BAD_LENGTH);
    }
    m_nType = index;
    m_osObjId = szType;
    lth = asnString.Write((LPBYTE)szValue, cbValLen);
    if (0 > lth)
        ErrorThrow(PKCS_ASN_ERROR);
    lth = asnString.EncodingLength();
    if (0 > lth)
        ErrorThrow(PKCS_ASN_ERROR);
    m_osValue.Resize(lth);
    ErrorCheck;

    lth = asnString.Encode(m_osValue.Access());
    if (0 > lth)
        ErrorThrow(PKCS_ASN_ERROR);
    return;

ErrorExit:
    return;
}


//
//==============================================================================
//
//  CAttributeList
//

IMPLEMENT_NEW(CAttributeList)


/*++

Clear:

    This routine flushes the storage used for an RDN.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 7/14/1995

--*/

void
CAttributeList::Clear(
    void)
{
    DWORD count = Count();
    for (DWORD index = 0; index < count; index += 1)
    {
        CAttribute *patr = m_atrList[index];
        if (NULL != patr)
            delete patr;
    }
    m_atrList.Clear();
}


/*++

CAttributeList::Add:

    Add an attribute to the RDN.  Attributes must be unique, so if an existing
    attribute has the same type as the attribute being added, then the existing
    attribute is first deleted.  The entries are maintained in sorted order.

Arguments:

    atr - Supplies the attribute to add.  This attribute must have been created
        via a 'new' directive, and becomes the property of this object, to be
        deleted once this object goes away.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 7/14/1995

--*/

void
CAttributeList::Add(
    IN CAttribute &atr)
{
    int datr=0;
    DWORD index;
    DWORD count = Count();


    //
    // Look for the slot in which the attribute should go.
    //

    for (index = 0; index < count; index += 1)
    {
        datr = m_atrList[index]->TypeCompare(atr);
        ErrorCheck;
        if (0 <= datr)
            break;
    }

    if (index != count)
    {

        //
        // Some array shuffling is necessary.
        //

        if (0 == datr)
        {

            //
            // Replace this attribute in the array with the new one.
            //

            delete m_atrList[index];
        }
        else
        {

            //
            // Insert the new attribute here in the array.
            //

            for (DWORD idx = count; idx > index; idx -= 1)
            {
                m_atrList.Set(idx, m_atrList[idx - 1]);
                ErrorCheck;
            }
        }
    }


    //
    // We're ready -- add in the new attribute.
    //

    m_atrList.Set(index, &atr);
    ErrorCheck;
    return;

ErrorExit:
    return;
}


/*++

CAttributeList::Compare:

    This routine compares one RDName to another.  The RDNames are considered
    equal if they both contain the same attributes.

Arguments:

    rdn - Supplies the user-supplied RDN to be compared to this RDN.

Return Value:

    -1 - The supplied RDName is a proper subset of this RDName.
     0 - The two RDNames are identical
     1 - The supplied RDName contains an element not found in this RDName.

Author:

    Doug Barlow (dbarlow) 7/14/1995

--*/

int
CAttributeList::Compare(
    IN const CAttributeList &rdn)
    const
{
    DWORD
        cRdn = rdn.Count(),
        cThs = Count(),
        iRdn = 0,
        iThs = 0;
    DWORD
        dif,
        result = 0;     // Assume they're the same for now.

    for (;;)
    {

        //
        // Have we reached the end of either set?
        //

        if (iRdn >= cRdn)
        {

            //
            // If we've reached the end of the rdn list, then unless we've also
            // reached the end of this list, the rdn list is a subset of this
            // list.
            //

            if (iThs < cThs)
                result = -1;
            break;
        }
        if (iThs >= cThs)
        {

            //
            // If we've reached the end of this list, then the rdn list has more
            // elements.
            //

            result = 1;
            break;
        }


        //
        // There are still more elements to compare.  Make the comparison of the
        // two current elements.
        //

        dif = rdn[(int)iRdn]->Compare(*m_atrList[(int)iThs]);
        ErrorCheck;
        if (0 == dif)
        {

            //
            // If they're the same, continue with the next pair of elements.
            //

            iRdn += 1;
            iThs += 1;
        }
        else if (0 < dif)
        {
            //
            // If the rdn list element is less than this's element, then it's
            // got an element we don't have.  Declare it not a subset.
            //

            result = 1;
            break;
        }
        else    // 0 > dif
        {

            //
            // If the rdn list element is greater than this's element, then this
            // list has an element the rdn list doesn't have.  Note that we've
            // detected that it's a non-proper subset, and continue checking.
            //

            result = -1;
            iThs += 1;
        }
    }
    return (int)result;

ErrorExit:
    return 1;
}


/*++

operator=:

    This routine sets this Attribute list to the contents of the supplied
    attribute list.

Arguments:

    atl - Supplies the source attribute list.

Return Value:

    This.  A DWORD status code is thrown on errors.

Author:

    Doug Barlow (dbarlow) 8/21/1995

--*/

CAttributeList &
CAttributeList::operator=(
    IN const CAttributeList &atl)
{
    CAttribute *patr = NULL;
    DWORD count = atl.Count();
    Clear();
    for (DWORD index = 0; index < count; index += 1)
    {
        patr = new CAttribute;
        if (NULL == patr)
            ErrorThrow(PKCS_NO_MEMORY);
        *patr = *atl[(int)index];
        m_atrList.Set(index, patr);
        ErrorCheck;
        patr = NULL;
    }
    return *this;

ErrorExit:
    if (NULL != patr)
        delete patr;
    return *this;
}


/*++

CAttributeList::Import:

    These routines import attribute lists from other formats into our internal
    format.  The Import routines remove any existing attributes before bringing
    in the new ones.

Arguments:

    asnAtrLst - Supplies an ASN.1 X.509 Attributes structure to be imported
        into our internal format.

Return Value:

    None
    A DWORD containing an error code is thrown on errors.

Author:

    Doug Barlow (dbarlow) 7/20/1995

--*/

void
CAttributeList::Import(
    const Attributes &asnAtrLst)
{
    CAttribute *
        addMe
            = NULL;
    long int
        length;
    COctetString
        osValue,
        osType;
    LPCTSTR
        sz;
    int
        atrMax
            = (int)asnAtrLst.Count();


    Clear();
    for (int index = 0; index < atrMax; index += 1)
    {
        length = asnAtrLst[index].attributeValue.EncodingLength();
        if (0 > length)
            ErrorThrow(PKCS_ASN_ERROR);
        osValue.Resize(length);
        ErrorCheck;
        length =
            asnAtrLst[index].attributeValue.Encode(
                osValue.Access());
        if (0 > length)
            ErrorThrow(PKCS_ASN_ERROR);

        sz = asnAtrLst[index].attributeType;
        if (NULL == sz)
            ErrorThrow(PKCS_ASN_ERROR);
        osType.Set((LPBYTE)sz, strlen( ( char * ) sz) + 1);
        ErrorCheck;
        addMe = new CAttribute;
        if (NULL == addMe)
            ErrorThrow(PKCS_NO_MEMORY);
        addMe->Set(osType, osValue.Access(), osValue.Length());
        ErrorCheck;
        Add(*addMe);
        addMe = NULL;
    }
    return;

ErrorExit:
    if (NULL != addMe)
        delete addMe;
    Clear();
}


/*++

Export:

    These methods export an internal format attribute list into other external
    formats.

Arguments:

    asnAtrList - Receives the attribute list.

Return Value:

    None.  A DWORD containing an error code is thrown on errors.

Author:

    Doug Barlow (dbarlow) 7/25/1995

--*/

void
CAttributeList::Export(
    IN Attributes &asnAtrList)
    const
{
    DWORD
        index;
    CAttribute *
        patr;
    long int
        length;


    asnAtrList.Clear();
    for (index = 0; index < Count(); index += 1)
    {
        if (0 > asnAtrList.Add())
            ErrorThrow(PKCS_ASN_ERROR);
        patr = m_atrList[index];
        if (NULL ==
            (asnAtrList[(int)index].attributeType = (LPCTSTR)patr->GetType().Access()))
            ErrorThrow(PKCS_ASN_ERROR);
        length =
            asnAtrList[(int)index].attributeValue.Decode(
                            patr->GetValue().Access(),
                            patr->GetValue().Length());
        if (0 > length)
            ErrorThrow(PKCS_ASN_ERROR);
    }
    return;

ErrorExit:
    return;
}


/*++

AttributeValue:

    This routine returns the attribute value corresponding to the given object
    identifier.

Arguments:

    pszObjId - The object Identifier to search for.

Return Value:

    the Value of the attribute, or NULL if it's not in the list.

Author:

    Doug Barlow (dbarlow) 8/15/1995

--*/

CAttribute *
CAttributeList::operator[](
    IN LPCTSTR pszObjId)
    const
{
    DWORD
        count
            = m_atrList.Count(),
        index;

    for (index = 0; index < count; index += 1)
    {
        if (0 == strcmp(
                    ( char * )pszObjId,
                    ( LPCSTR )( ( LPCTSTR )m_atrList[index]->GetType())))
            return m_atrList[index];
    }
    return NULL;
}


//
//==============================================================================
//
//  CDistinguishedName
//

IMPLEMENT_NEW(CDistinguishedName)


/*++

Clear:

    This method cleans out a distinguished name.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 7/14/1995

--*/

void
CDistinguishedName::Clear(
    void)
{
    DWORD count = Count();
    for (DWORD index = 0; index < count; index += 1)
    {
        CAttributeList * patl = m_rdnList[index];
        if (NULL != patl)
        {
            patl->Clear();
            delete patl;
        }
    }
    m_rdnList.Clear();
}


/*++

Add:

    This method adds an RDN to the end of the Distinguished name.

Arguments:

    prdn - Supplies the address of the RDN to be added to the list.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 7/14/1995

--*/

void
CDistinguishedName::Add(
    IN CAttributeList &rdn)
{
    m_rdnList.Set(Count(), &rdn);
}


/*++

CDistinguishedName::Compare:

    This method compares a distingushed name for equivalence to this name.  A
    name is equivalent to this name if the lengths are the same, and the
    attributes of each RDN in the compared name is a subset of the corresponding
    RDN from this Name.

Arguments:

    pdn - Supplies the distingushed name to be compared to this name.

Return Value:

    -1 - The supplied name is a subset of this name.
     0 - The two names are identical.
     1 - The supplied name contains an RDN which contains an attribute not in
         the corresponding RDN of this name.

Author:

    Doug Barlow (dbarlow) 7/14/1995

--*/

int
CDistinguishedName::Compare(
    IN const CDistinguishedName &dn)
    const
{
    int
        dif,
        result = 0;
    DWORD
        iTs = 0,
        iDn = 0,
        cTs = Count(),
        cDn = dn.Count();


    for (;;)
    {

        //
        // Have we reached the end of either set?
        //

        if (iDn >= cDn)
        {

            //
            // If we've reached the end of the dn list, then unless we've also
            // reached the end of this list, the dn list is a subset of this
            // list.
            //

            if (iTs < cTs)
                result = -1;
            break;
        }
        if (iTs >= cTs)
        {

            //
            // If we've reached the end of this list, then the dn list has more
            // elements.
            //

            result = 1;
            break;
        }


        //
        // There are still more elements to compare.  Make the comparison of the
        // two current elements.
        //

        dif = m_rdnList[(int)iTs]->Compare(*dn[(int)iDn]);
        if (0 < dif)
        {
            //
            // If the dn list element is less than this's element, then this has
            // an element it don't have.  Note it's a subset.
            //

            result = -1;
        }
        else if (0 > dif)
        {

            //
            // If the dn list element is greater than this's element, then it
            // has an element that this list doesn't have.  report it as a
            // non-proper subset.
            //

            result = 1;
            break;
        }
        // else they're the same, maintain status quo.

        iDn += 1;
        iTs += 1;
    }
    return result;
}


/*++

Import:

    This routine imports a character delimited name into the internal format.

Arguments:

    pszName - Supplies the character delimited name

Return Value:

    None.  An error code is thrown if an error occurs.

Author:

    Doug Barlow (dbarlow) 7/17/1995

--*/

void
CDistinguishedName::Import(
    IN LPCTSTR pszName)
{
    COctetString
        osAtrType,
        osAtrValue;
    CAttribute *
        patr
            = NULL;
    CAttributeList *
        patl
            = NULL;
    const char
        *pchStart
            = ( const char * )pszName,
        *pchEnd
            = ( const char * )pszName;


    //
    // Initialize the state machine.
    //

    Clear();


    //
    // Find an attribute.
    //

    while (0 != *pchEnd)
    {
        pchEnd = strpbrk( pchStart, ";\\=");
        if (NULL == pchEnd)
            pchEnd = pchStart + strlen(pchStart);
        switch (*pchEnd)
        {
        case TEXT(';'):
        case TEXT('\000'):
        case TEXT('\\'):

            // Flush any existing value into a value string.
            if (pchStart != pchEnd)
            {
                osAtrValue.Length(osAtrValue.Length() + (ULONG)(pchEnd - pchStart) + 1);
                ErrorCheck;
                if (0 < osAtrValue.Length())
                    osAtrValue.Resize(strlen( ( LPCSTR )( ( LPCTSTR )osAtrValue ) ) );
                ErrorCheck;
                osAtrValue.Append((LPBYTE)pchStart, (ULONG)(pchEnd - pchStart));
                ErrorCheck;
                osAtrValue.Append((LPBYTE)"\000", 1);
                ErrorCheck;
            }

            // Flush any existing strings into an attribute.
            if (0 != osAtrValue.Length())
            {
                if (NULL == patr)
                {
                    patr = new CAttribute;
                    if (NULL == patr)
                        ErrorThrow(PKCS_NO_MEMORY);
                }
                else
                    ErrorThrow(PKCS_NAME_ERROR);
                patr->Set(osAtrType, osAtrValue);
                ErrorCheck;
                osAtrValue.Empty();
                osAtrType.Empty();
            }

            // Flush any existing attribute into the attribute list.
            if (NULL != patr)
            {
                if (NULL == patl)
                {
                    patl = new CAttributeList;
                    if (NULL == patl)
                        ErrorThrow(PKCS_NO_MEMORY);
                }
                patl->Add(*patr);
                ErrorCheck;
                patr = NULL;
            }

            if (TEXT(';') != *pchEnd)
            {
                // Flush any existing attribute list into the name.
                if (NULL != patl)
                {
                    Add(*patl);
                    ErrorCheck;
                    patl = NULL;
                }
            }
            break;

        case TEXT('='):
            // Flush any existing value into the type string.
            if (0 != osAtrType.Length())
            {
                osAtrValue.Length(osAtrValue.Length() + (ULONG)(pchEnd - pchStart) + 1);
                ErrorCheck;
                if (0 < osAtrValue.Length())
                    osAtrValue.Resize(strlen( ( LPCSTR )( ( LPCTSTR )osAtrValue ) ) );
                ErrorCheck;
                osAtrValue.Append((LPBYTE)TEXT("="), sizeof(TCHAR));
                ErrorCheck;
                osAtrValue.Append((LPBYTE)pchStart, (ULONG)(pchEnd - pchStart));
                ErrorCheck;
                osAtrValue.Append((LPBYTE)"\000", 1);
                ErrorCheck;
            }
            else
            {
                if (pchStart != pchEnd)
                {
                    osAtrType.Set((LPBYTE)pchStart, (ULONG)(pchEnd - pchStart));
                    ErrorCheck;
                    osAtrType.Append((LPBYTE)"\000", 1);
                    ErrorCheck;
                }
            }
            ErrorCheck;
            break;

        default:
            ErrorThrow(PKCS_INTERNAL_ERROR);
        }

        // Move forward to the next token.
        if (TEXT('\000') != *pchEnd)
            pchEnd += 1;
        pchStart = pchEnd;
    }
    return;

ErrorExit:
    if (NULL != patr)
        delete patr;
    if (NULL != patl)
        delete patl;
    Clear();
}


void
CDistinguishedName::Import(
    IN const Name &asnName)
{
    DWORD
        rdnIndex,
        rdnMax;
    CAttributeList *
        patl
           = NULL;


    Clear();
    rdnMax = (DWORD)asnName.Count();
    for (rdnIndex = 0;
        rdnIndex < rdnMax;
        rdnIndex += 1)
    {
        patl = new CAttributeList;
        if (NULL == patl)
            ErrorThrow(PKCS_NO_MEMORY);
        patl->Import(
                asnName[(int)rdnIndex]);
        ErrorCheck;

        // Add that RDN into the Name.
        Add(*patl);
        ErrorCheck;
        patl = NULL;
    }
    return;

ErrorExit:
    if (NULL != patl)
        delete patl;
    Clear();
}


/*++

Export:

    This routine exports a name as a character delimited string.  In the string
    version, Only interesting attributes from within each RDN are exported.

Arguments:

    osName - Receives the exported name as a string.
    asnName - Receives the exported name as an ASN.1 construction.

Return Value:

    None.  A DWORD error code is thrown on errors.

Author:

    Doug Barlow (dbarlow) 7/17/1995

--*/

void
CDistinguishedName::Export(
    OUT COctetString &osName)
const
{
    DWORD
        rdnIndex,
        atrIndex;
    CAttribute *
        patr
            = NULL;
    CAttributeList *
        patl
           = NULL;
    LPCTSTR
        pstr;
    CAsnPrintableString
        asnString;   // ?todo? Support other string types.
    CAsnUnicodeString
        asnUnicodeString;
    CAsnIA5String
        asnIA5String;
    COctetString
        osTmp;
    LONG
        lth;


    osName.Empty();
    for (rdnIndex = 0; rdnIndex < Count(); rdnIndex += 1)
    {
        patl = m_rdnList[rdnIndex];
        for (atrIndex = 0; atrIndex < patl->Count(); atrIndex += 1)
        {
            patr = (*patl)[(int)atrIndex];
            if (ATR_UNKNOWN >= patr->GetAtrType())
            {
                if (ATR_COMMONNAME != patr->GetAtrType())
                {
                    pstr = knownAttributes[patr->GetAtrType()].name;
                    osName.Append((LPBYTE)pstr, strlen( ( char * )pstr));
                    ErrorCheck;
                    osName.Append((LPBYTE)"=", 1);
                    ErrorCheck;
                }

                //
                // support printable and unicode string decoding
                //

                if(0 <= asnString.Decode(patr->GetValue().Access(),
                                         patr->GetValue().Length()))
                {
                    lth = asnString.DataLength();
                    if (0 > lth)
                        ErrorThrow(PKCS_ASN_ERROR);
                    osTmp.Resize(lth);
                    ErrorCheck;
                    lth = asnString.Read(osTmp.Access());
                    if (0 > lth)
                        ErrorThrow(PKCS_ASN_ERROR);
                }
                else if(0 <= asnUnicodeString.Decode(patr->GetValue().Access(),
                                                     patr->GetValue().Length()))
                {
                    lth = asnUnicodeString.DataLength();
                    if (0 > lth)
                        ErrorThrow(PKCS_ASN_ERROR);
                    osTmp.Resize(lth);
                    ErrorCheck;
                    lth = asnUnicodeString.Read(osTmp.Access());
                    if (0 > lth)
                        ErrorThrow(PKCS_ASN_ERROR);
                }
                else if(0 <= asnIA5String.Decode(patr->GetValue().Access(),
                                                 patr->GetValue().Length()))
                {
                    lth = asnIA5String.DataLength();
                    if (0 > lth)
                        ErrorThrow(PKCS_ASN_ERROR);
                    osTmp.Resize(lth);
                    ErrorCheck;
                    lth = asnIA5String.Read(osTmp.Access());
                    if (0 > lth)
                        ErrorThrow(PKCS_ASN_ERROR);
                }
                else
                {
                    ErrorThrow(PKCS_ASN_ERROR);
                }

                osName.Append(osTmp.Access(), lth);
                ErrorCheck;
            }
            // else, just ignore it.
            osName.Append((LPBYTE)";", 1);
            ErrorCheck;
        }

        if (0 < osName.Length())
            *(LPBYTE)(osName.Access(osName.Length() - 1)) = '\\';
    }
    if (0 < osName.Length())
        *(LPBYTE)(osName.Access(osName.Length() - 1)) = '\000';
    return;

ErrorExit:
    return;
}


void
CDistinguishedName::Export(
    OUT Name &asnName)
    const
{
    DWORD
        rdnIndex;
    CAttributeList *
        patl;


    asnName.Clear();
    for (rdnIndex = 0; rdnIndex < Count(); rdnIndex += 1)
    {
        patl = m_rdnList[rdnIndex];
        if (0 > asnName.Add())
            ErrorThrow(PKCS_ASN_ERROR);
        patl->Export(
            asnName[(int)rdnIndex]);
        ErrorCheck;
    }
    return;

ErrorExit:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\licecert\certcate.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    licecert.h

Abstract:

    Adapted from Doug Barlow's PKCS library

Author:

    Frederick Chong (dbarlow) 5/28/1998

Environment:

    

Notes:



--*/

#ifndef _CERTCATE_H_
#define _CERTCATE_H_

#include <msasnlib.h>
#include "names.h"
#include "x509.h"
#include "memcheck.h"


//
//==============================================================================
// Supported Certificate Types.
//

#define CERTYPE_UNKNOWN         0   // Unknown Certificate Type.
#define CERTYPE_LOCAL_CA        1   // A local CA pointer.
#define CERTYPE_X509            2   // An X.509 certificate.
#define CERTYPE_PKCS_X509       3   // A PKCS & imbedded X.509 Certificate.
#define CERTYPE_PKCS7_X509      4   // A PKCS7 & embedded X.509 Certificate
#define CERTYPE_PKCS_REQUEST    5   // A PKCS Certificate Request (internal use

//
//==============================================================================
// X.509 Certificate specifics
//

#define X509_VERSION_1 0            // This certificate is X.509 version 1
#define X509_VERSION_2 1            // This certificate is X.509 version 2
#define X509_VERSION_3 2            // This certificate is X.509 version 3
#define X509_MAX_VERSION X509_VERSION_3 // Max version supported.

#define X509CRL_VERSION_1 0         // This CRL is X.509 version 1
#define X509CRL_VERSION_2 1         // This CRL is X.509 version 2
#define X509CRL_MAX_VERSION X509CRL_VERSION_2 // Max version supported.

//
//==============================================================================
// Certificate Store Definitions
//

#define CERTSTORE_NONE          0   // No store to be used.
#define CERTSTORE_APPLICATION   1   // Store in application volatile memory
#define CERTSTORE_CURRENT_USER  3   // Store in Registry under current user
#define CERTSTORE_LOCAL_MACHINE 5   // Store in Registry under local machine

#define CERTTRUST_NOCHECKS      0   // Don't do any certificate checking
#define CERTTRUST_APPLICATION   1   // Trust the Application Store
#define CERTTRUST_NOONE         0xffff // Trust No One -- Validate everything

//
//==============================================================================
// Certificate Warning Definitions
//

#define CERTWARN_NOCRL       0x01   // At least one of the signing CAs didn't
                                    // have an associated CRL.
#define CERTWARN_EARLYCRL    0x02   // At least one of the signing CAs had an
                                    // associated CRL who's issuing date was
                                    // in the future.
#define CERTWARN_LATECRL     0x04   // At least one of the signing CAs had an
                                    // expired CRL.
#define CERTWARN_TOBEREVOKED 0x08   // At least one of the signing CAs contained
                                    // a revocation for a certificate, but its
                                    // effective date has not yet been reached.
#define CERTWARN_CRITICALEXT 0x10   // At least one of the signing CAs contained
                                    // an unrecognized critical extension.

//
//==============================================================================
// The supported signature and hashing algorithm
//

typedef DWORD ALGORITHM_ID;

#define SIGN_ALG_RSA            0x00010000

#define HASH_ALG_MD2            0x00000001
#define HASH_ALG_MD4            0x00000002
#define HASH_ALG_MD5            0x00000003
#define HASH_ALG_SHA            0x00000004
#define HASH_ALG_SHA1           0x00000005

#define GET_SIGN_ALG( _Alg )    _Alg & 0xFFFF0000
#define GET_HASH_ALG( _Alg )    _Alg & 0x0000FFFF


class CCertificate;

typedef const void FAR * CERTIFICATEHANDLE;
typedef CERTIFICATEHANDLE * PCERTIFICATEHANDLE, FAR * LPCERTIFICATEHANDLE;
            


BOOL WINAPI
PkcsCertificateLoadAndVerify(
    OUT LPCERTIFICATEHANDLE phCert,    
    IN const BYTE FAR * pbCert,
    IN DWORD cbCert,
    IN OUT LPDWORD pdwType,
    IN DWORD dwStore,
    IN DWORD dwTrust,
    OUT LPTSTR szIssuerName,
    IN OUT LPDWORD pcbIssuerLen,
    OUT LPDWORD pdwWarnings,
    IN OUT LPDWORD pfDates );


BOOL WINAPI
PkcsCertificateGetPublicKey(
    CERTIFICATEHANDLE   hCert,
    LPBYTE              lpPubKey,
    LPDWORD             lpcbPubKey );


BOOL WINAPI
PkcsCertificateCloseHandle(
    CERTIFICATEHANDLE   hCert );

//
//==============================================================================
//
//  CCertificate
//

class CCertificate
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CCertificate();
    virtual ~CCertificate();


    //  Properties
    //  Methods

    virtual void
    Load(
        //IN CProvider *pksProvider,
        IN const BYTE FAR * pbCertificate,
        IN DWORD cbCertificate,
        IN DWORD dwTrust,
        IN OUT LPDWORD pfStore,
        OUT LPDWORD pdwWarnings,
        OUT COctetString &osIssuer,
        //IN BOOL fOwnProvider,
        IN OUT LPDWORD pfDates,
        IN BOOL fRunOnce = FALSE );

    virtual void
    Verify(
        IN const BYTE FAR * pbSigned,
        IN DWORD cbSigned,
        IN DWORD cbSignedLen,
        IN ALGORITHM_ID algIdSignature,
        IN LPCTSTR szDescription,
        IN const BYTE FAR * pbSignature,
        IN DWORD cbSigLen)
        const;

    virtual void
    GetPublicKey(
        IN LPBYTE pbPubKey,
        IN OUT LPDWORD lpcbPubKey ) 
        const;

    virtual const Name &
    Subject(void) const;

    virtual BOOL
    HasParent(void) const;

    virtual const Name &
    Issuer(void) const;

    virtual void
    SerialNo(
        OUT COctetString &osSerialNo)
    const;

    virtual DWORD
    Type(void) const;


    //  Operators

protected:
    //  Properties

    COctetString m_osPublicKey;

    //  Methods

    virtual void
    Init(void);

    virtual void
    Clear(void);

};


//
//==============================================================================
//
//  CX509Certificate
//

class CX509Certificate
:   public CCertificate
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CX509Certificate();
    virtual ~CX509Certificate();


    //  Properties
    //  Methods

    virtual void
    Load(
        IN const BYTE FAR * pbCertificate,
        IN DWORD cbCertificate,
        IN DWORD dwTrust,
        IN OUT LPDWORD pfStore,
        OUT LPDWORD pdwWarnings,
        OUT COctetString &osIssuer,
        IN OUT LPDWORD pfDates,
        IN BOOL fRunOnce = FALSE );

    
    virtual const Name &
    Subject(void) const;

    virtual BOOL
    HasParent(void) const
    { return TRUE; };

    virtual const Name &
    Issuer(void) const;

    virtual void
    SerialNo(
        OUT COctetString &osSerialNo)
    const;

    virtual DWORD
    Type(void) const;

    virtual const CertificateToBeSigned &
    Coding(void) const;


    //  Operators

protected:
    //  Properties

    CertificateToBeSigned
        m_asnCert;

    //  Methods

    virtual void
    Init(void);

    virtual void
    Clear(void);

    virtual void
    Load2(  // Backdoor for derivative extensions.
        IN const BYTE FAR * pbCertificate,
        IN DWORD cbCertificate,
        IN DWORD dwTrust,
        IN OUT LPDWORD pfStore,
        OUT LPDWORD pdwWarnings,
        OUT COctetString &osIssuer,
        IN BOOL fRunOnce,
        OUT CCertificate **ppcrtIssuer,
        IN OUT LPDWORD pfDates );
        
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\licecert\pkcs_1.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    pkcs_1.cpp

Abstract:

    This module implements the PKCS 1 ASN.1 objects

Author:

    Frederick Chong (fredch) 6/1/1998

Notes:

--*/

#include <windows.h>
#include "pkcs_1.h"

RSAPublicKey::RSAPublicKey(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequence(dwFlags, dwTag),
    modulus(0),
    publicExponent(0)
{
    m_rgEntries.Set(0, &modulus);
    m_rgEntries.Set(1, &publicExponent);
}

CAsnObject *
RSAPublicKey::Clone(
    DWORD dwFlags)
const
{
    return new RSAPublicKey(dwFlags);
}


DigestInfo::DigestInfo(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequence(dwFlags, dwTag),
    DigestAlgorithmIdentifier(0),
    Digest(0)
{
    m_rgEntries.Add(&DigestAlgorithmIdentifier);
    m_rgEntries.Add(&Digest);
}


CAsnObject *
DigestInfo::Clone(
    DWORD dwFlags)
const
{
    return new DigestInfo(dwFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\licecert\ostring.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    OctetString.h

Abstract:

    This header file describes a class for the manipulation of binary data.

Author:

    Doug Barlow (dbarlow) 9/29/1994

Environment:

    Works anywhere.

Notes:



--*/

#ifndef _OCTETSTRING_H_
#define _OCTETSTRING_H_
#ifdef _DEBUG
#include <iostream.h>
#endif

#ifndef NO_EXCEPTS
#include "pkcs_err.h"
#endif
#include "memcheck.h"


//
//==============================================================================
//
//  COctetString
//

class
COctetString
{
public:

    DECLARE_NEW

    //  Constructors & Destructor

    COctetString();         //  Default constructor.

    COctetString(           //  Object assignment constructors.
        IN const COctetString &osSource);

    COctetString(
        IN const BYTE FAR *pvSource,
        IN DWORD nLength);

    COctetString(
        IN unsigned int nLength);

    virtual ~COctetString()
    { Clear(); };


    //  Properties


    //  Methods

    void
    Set(
        IN const BYTE FAR * const pvSource,
        IN DWORD nLength);

    void
    Set(
        IN LPCTSTR pstrSource,
        IN DWORD nLength = 0xffffffff)
    {
        if (0xffffffff == nLength)
            nLength = strlen( ( char * )pstrSource) + 1;
        Set((const BYTE FAR *)pstrSource, nLength);
    };

    void
    Append(
        IN const BYTE FAR * const pvSource,
        IN DWORD nLength);

    void
    Append(
        IN const COctetString &osSource)
    { Append(osSource.m_pvBuffer, osSource.m_nStringLength); };

    DWORD
    Length(
        void) const
    { return m_nStringLength; };

    void
    Resize(
        IN DWORD nLength)
    {
        ResetMinBufferLength(nLength);
#ifndef NO_EXCEPTS
        ErrorCheck;
#endif
        m_nStringLength = nLength;
#ifndef NO_EXCEPTS
    ErrorExit:
        return;
#endif
    };

    int
    Compare(
        IN const COctetString &ostr)
        const;

    DWORD
    Length(
        IN DWORD size)
    {
        ResetMinBufferLength(size);
        return m_nBufferLength;
    };

    BYTE FAR *
    Access(
        DWORD offset = 0)
        const
    {
        if (offset >= m_nStringLength)
        {
            return NULL;
        }
        return m_pvBuffer + offset;
    }

    DWORD
    Range(
        COctetString &target,
        DWORD offset,
        DWORD length)
        const;
    DWORD
    Range(
        LPBYTE target,
        DWORD offset,
        DWORD length)
        const;

    void
    Empty(
        void);

    void
    Clear(
        void);


    //  Operators

    COctetString &
    operator=(
        IN const COctetString &osSource);

    COctetString &
    operator=(
        IN LPCTSTR pszSource);

    COctetString &
    operator+=(
        IN const COctetString &osSource);

    BYTE
    operator[](
        int offset)
        const
    {
        if ((DWORD)offset >= m_nStringLength)
            return 0;
        return *Access(offset);
    }

    int
    operator==(
        IN const COctetString &ostr)
        const
    { return 0 == Compare(ostr); };

    int
    operator!=(
        IN const COctetString &ostr)
        const
    { return 0 != Compare(ostr); };

    operator LPCTSTR(void) const
    {
#ifdef _DEBUG
        DWORD length = strlen(( LPCSTR )m_pvBuffer);
        if (length > m_nBufferLength)
            cerr << "Buffer overrun!" << endl;
        if (length > m_nStringLength)
            cerr << "String overrun!" << endl;
#endif
        return (LPCTSTR)m_pvBuffer;
    };


protected:

    COctetString(           //  Object assignment constructors.
        IN const COctetString &osSourceOne,
        IN const COctetString &osSourceTwo);

    //  Properties

    DWORD m_nStringLength;
    DWORD m_nBufferLength;
    LPBYTE m_pvBuffer;


    //  Methods

    void
    Initialize(
        void);

    void
    SetMinBufferLength(
        IN DWORD nDesiredLength);

    void
    ResetMinBufferLength(
        IN DWORD nDesiredLength);

    friend
        COctetString 
        operator+(
            IN const COctetString &osSourceOne,
            IN const COctetString &osSourceTwo);

};

COctetString 
operator+(
    IN const COctetString &osSourceOne,
    IN const COctetString &osSourceTwo);

#endif // _OCTETSTRING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\licecert\pkcs_err.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pkcs_err

Abstract:

    This routine performs error collection and remapping for the PKCS
    Certificate library.  The exception code is translated into an error code,
    which is placed into LastError for reference by the calling application.

Author:

    Doug Barlow (dbarlow) 9/18/1995

Environment:

    Win32, Crypto API

Notes:

--*/

#include <windows.h>

#ifdef OS_WINCE
#include <wince.h>
#endif

#include "pkcs_err.h"

/*++

MapError:

    This routine returns an indication of error.

Arguments:

    None.

Return Value:

    TRUE - No error encountered.
    FALSE - An error was reported -- Details in LastError.

Author:

    Doug Barlow (dbarlow) 9/18/1995

--*/

BOOL
MapError(
    void)
{
    return (GetLastError() == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\licecert\ostring.cpp ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    OctetString.cpp

Abstract:

    This module implements the COctetString class, providing simple manipulation
    of binary data.

Author:

    Doug Barlow (dbarlow) 9/29/1994

Environment:



Notes:



--*/

#include <windows.h>
#include <memory.h>
#include "oString.h"


static const BYTE FAR * const
    v_pvNilString
        = (const BYTE *)"";


//
//==============================================================================
//
//  COctetString
//

IMPLEMENT_NEW(COctetString)


/*++

COctetString:

    This routine provides default initialization.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 9/29/1994

--*/

COctetString::COctetString()
{
    Initialize();
}

COctetString::COctetString(
    unsigned int nLength)
{
    Initialize();
    SetMinBufferLength(nLength);
}


/*++

COctetString:

    Construct an Octet String, copying data from a given octet string.

Arguments:

    osSource - Supplies the source octet string.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 9/29/1994

--*/

COctetString::COctetString(
    IN const COctetString &osSource)
{
    Initialize();
    Set(osSource.m_pvBuffer, osSource.m_nStringLength);
}

COctetString::COctetString(
    IN const COctetString &osSourceOne,
    IN const COctetString &osSourceTwo)
{
    Initialize();
    SetMinBufferLength(
        osSourceOne.m_nStringLength + osSourceTwo.m_nStringLength);
    ErrorCheck;
    Set(osSourceOne.m_pvBuffer, osSourceOne.m_nStringLength);
    ErrorCheck;
    Append(osSourceTwo.m_pvBuffer, osSourceTwo.m_nStringLength);
    return;

ErrorExit:
    Empty();
    return;
}


/*++

COctetString:

    Construct an Octet String given a data block to initialize it from.

Arguments:

    pvSource - Supplies the data with which to load the octet string.

    nLength - Supplies the length of the source, in bytes.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 9/29/1994

--*/

COctetString::COctetString(
    IN const BYTE FAR *pvSource,
    IN DWORD nLength)
{
    Initialize();
    Set(pvSource, nLength);
}


/*++

Initialize:

    This routine initializes a freshly created Octet String.  It doesn't
    reinitialize an old one!  Use Clear() for that.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 9/30/1994

--*/

void
COctetString::Initialize(
    void)
{
    m_nStringLength = m_nBufferLength = 0;
    m_pvBuffer = (LPBYTE)v_pvNilString;
}


/*++

Clear:

    This routine resets the octet string to an empty state.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 9/29/1994

--*/

void
COctetString::Clear(
    void)
{
    if ((v_pvNilString != m_pvBuffer) && (NULL != m_pvBuffer))
    {
        delete[] m_pvBuffer;
        Initialize();
    }
}


/*++

Empty:

    Empty is a friendlier form of Clear, that can be called publicly, and just
    makes sure things are consistent.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 8/22/1995

--*/

void
COctetString::Empty(
    void)
{
    m_nStringLength = 0;
    if (NULL == m_pvBuffer)
        m_pvBuffer = (LPBYTE)v_pvNilString;
    if ((LPBYTE)v_pvNilString != m_pvBuffer)
        *m_pvBuffer = 0;
}


/*++

SetMinBufferLength:

    This routine ensures that there are at least the given number of octets
    within the buffer.  This routine can and will destroy existing data!  Use
    ResetMinBufferLength to preserve the data.

Arguments:

    nDesiredLength - Supplies the minimum number of octets needed.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 9/29/1994

--*/

void
COctetString::SetMinBufferLength(
    IN DWORD nDesiredLength)
{
    if (m_nBufferLength < nDesiredLength)
    {
        Clear();
        NEWReason("COctetString Buffer")
        m_pvBuffer = new BYTE[nDesiredLength];
        if (NULL == m_pvBuffer)
        {
            Clear();
            ErrorThrow(PKCS_NO_MEMORY);
        }
        m_nBufferLength = nDesiredLength;
    }
    return;

ErrorExit:
    Empty();
}


/*++

ResetMinBufferLength:

    This routine ensures that the buffer has room for at least a given number of
    bytes, ensuring that any data is preserved should the buffer need enlarging.

Arguments:

    nDesiredLength - The number of bytes needed in the buffer.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 9/29/1994

--*/

void
COctetString::ResetMinBufferLength(
    IN DWORD nDesiredLength)
{
    if (m_nBufferLength < nDesiredLength)
    {
        if (0 == m_nStringLength)
        {
            SetMinBufferLength(nDesiredLength);
            ErrorCheck;
        }
        else
        {
            NEWReason("COctetString Buffer")
            LPBYTE pvNewBuffer = new BYTE[nDesiredLength];
            if (NULL == pvNewBuffer)
                ErrorThrow(PKCS_NO_MEMORY);
            memcpy(pvNewBuffer, m_pvBuffer, m_nStringLength);
            delete[] m_pvBuffer;
            m_pvBuffer = pvNewBuffer;
            m_nBufferLength = nDesiredLength;
        }
    }
    return;

ErrorExit:
    Empty();
}


/*++

Set:

    Set an Octet String to a given value.

Arguments:

    pbSource - The source string that this octetstring gets set to.

    nLength - The number of octets in the source.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 9/29/1994

--*/

void
COctetString::Set(
    IN const BYTE FAR * const pvSource,
    IN DWORD nLength)
{
    if (0 == nLength)
    {
        m_nStringLength = 0;
    }
    else
    {
        SetMinBufferLength(nLength);
        ErrorCheck;
        memcpy(m_pvBuffer, pvSource, nLength);
        m_nStringLength = nLength;
    }
    return;

ErrorExit:
    Empty();
}


/*++

Append:

    This routine appends a given string onto the end of an existing octet
    string.

Arguments:

    pvSource - Supplies the octet string to append onto this one.

    nLength - Supplies the length of the source.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 9/29/1994

--*/

void
COctetString::Append(
    IN const BYTE FAR * const pvSource,
    IN DWORD nLength)
{
    if (0 != nLength)
    {
        ResetMinBufferLength(m_nStringLength + nLength);
        ErrorCheck;
        memcpy(&((LPSTR)m_pvBuffer)[m_nStringLength], pvSource, nLength);
        m_nStringLength += nLength;
    }
    return;

ErrorExit:
    Empty();
}


/*++

Compare:

    This method compares an octet string to this octet string for equality.

Arguments:

    ostr - Supplies the octet string to compare

Return Value:

    0 - They match
    otherwise, they don't.

Author:

    Doug Barlow (dbarlow) 7/14/1995

--*/

int
COctetString::Compare(
    IN const COctetString &ostr)
    const
{
    int dif = (int)(ostr.m_nStringLength - m_nStringLength);
    if (0 == dif)
        dif = memcmp((LPSTR)m_pvBuffer, (LPSTR)ostr.m_pvBuffer, m_nStringLength);
    return dif;
}


/*++

operator=:

    This routine assigns the value of one octet string to another.

Arguments:

    Source - Supplies the source octet string.

Return Value:

    A reference to the resultant octet string.

Author:

    Doug Barlow (dbarlow) 9/29/1994

--*/

COctetString &
COctetString::operator=(
    IN const COctetString &osSource)
{
    Set(osSource.m_pvBuffer, osSource.m_nStringLength);
    return *this;
}

COctetString &
COctetString::operator=(
    IN LPCTSTR pszSource)
{
    Set(pszSource);
    return *this;
}


/*++

operator+=:

    This routine appends the value of one octet string to another.

Arguments:

    Source - Supplies the source octet string.

Return Value:

    A reference to the resultant octet string.

Author:

    Doug Barlow (dbarlow) 9/29/1994

--*/

COctetString &
COctetString::operator+=(
    IN const COctetString &osSource)
{
    Append(osSource.m_pvBuffer, osSource.m_nStringLength);
    return *this;
}


/*++

Range:

    This routine extracts a substring from the Octetstring, and places it into
    the given target octetstring.  Asking for an Offset that is greater than the
    size of the octetstring produces an empty string.  Asking for more bytes
    than exist in the octetstring produces just the bytes remaining.

Arguments:

    target - The octetstring to receive the substring.
    Offset - The number of bytes to move past the beginning of the source
             octetstring.  Zero implies start at the beginning.
    Length - The number of bytes to transfer.

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 5/17/1995

--*/

DWORD
COctetString::Range(
    COctetString &target,
    DWORD offset,
    DWORD length)
    const
{
    if (offset > m_nStringLength)
    {
        target.m_nStringLength = 0;
    }
    else
    {
        if (length > m_nStringLength - offset)
            length = m_nStringLength - offset;
        target.SetMinBufferLength(length);
        ErrorCheck;
        memcpy(target.m_pvBuffer, (char *)m_pvBuffer + offset, length);
        target.m_nStringLength = length;
    }
    return target.m_nStringLength;

ErrorExit:
    target.Empty();
    return 0;
}

DWORD
COctetString::Range(
    LPBYTE target,
    DWORD offset,
    DWORD length)
    const
{
    if (offset > m_nStringLength)
        length = 0;
    else if (length > m_nStringLength - offset)
        length = m_nStringLength - offset;
    if (0 < length)
        memcpy(target, (char *)m_pvBuffer + offset, length);
    return length;
}


/*++
//
//==============================================================================
//
//  COctetString Friends
//

operator+:

    This routine concatenates two octet strings into a third.

Arguments:

    SourceOne - Supplies the first string.

    SourceTwo - Supplies the second string.

Return Value:

    A reference to a new resultant string.

Author:

    Doug Barlow (dbarlow) 9/30/1994

--*/
COctetString
operator+(
    IN const COctetString &osSourceOne,
    IN const COctetString &osSourceTwo)
{
    return COctetString(osSourceOne, osSourceTwo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\licecert\pkcs_1.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    pkcs_1.h

Abstract:

    This module implements the PKCS 1 ASN.1 objects

Author:

    Frederick Chong (fredch) 6/1/1998

Notes:

--*/

#ifndef _PKCS_1_H_
#define _PKCS_1_H_

#include <MSAsnLib.h>
#include "x509.h"

class RSAPublicKey
:   public CAsnSequence
{
public:
    RSAPublicKey(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    CAsnInteger modulus;
    CAsnInteger publicExponent;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};


class DigestInfo
:   public CAsnSequence
{
public:
    DigestInfo(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    AlgorithmIdentifier DigestAlgorithmIdentifier;
    CAsnOctetstring     Digest;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\licecert\names.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    names

Abstract:

    This header file describes the class used for name translation.

Author:

    Doug Barlow (dbarlow) 7/12/1995

Environment:

    Win32, C++

Notes:



--*/

#ifndef _NAMES_H_
#define _NAMES_H_

#include "x509.h"
#include "ostring.h"
#include "memcheck.h"

class Name;


//
//==============================================================================
//
//  CCollection
//

template <class T>
class CCollection
{
public:

    //  Constructors & Destructor

    CCollection(void)
    { m_Max = m_Mac = 0; m_pvList = NULL; };

    virtual ~CCollection()
    { Clear(); };


    //  Properties
    //  Methods

    void
    Clear(void)
    {
        if (NULL != m_pvList)
        {
            delete[] m_pvList;
            m_pvList = NULL;
            m_Max = 0;
            m_Mac = 0;
        }
    };

    void
    Set(
        IN int nItem,
        IN T *pvItem);
    T * const
    Get(
        IN int nItem)
        const;
    DWORD
    Count(void) const
    { return m_Mac; };


    //  Operators
    T * const
    operator[](int nItem) const
    { return Get(nItem); };


protected:
    //  Properties

    DWORD
        m_Max,          // Number of element slots available.
        m_Mac;          // Number of element slots used.
    T **
        m_pvList;       // The elements.


    //  Methods
};


/*++

Set:

    This routine sets an item in the collection array.  If the array isn't that
    big, it is expanded will NULL elements to become that big.

Arguments:

    nItem - Supplies the index value to be set.
    pvItem - Supplies the value to be set into the given index.

Return Value:

    None.  A DWORD error code is thrown on errors.

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

template<class T>
inline void
CCollection<T>::Set(
    IN int nItem,
    IN T * pvItem)
{
    DWORD index;


    //
    // Make sure the array is big enough.
    //

    if ((DWORD)nItem >= m_Max)
    {
        int newSize = (0 == m_Max ? 16 : m_Max);
        while (nItem >= newSize)
            newSize *= 2;
        NEWReason("Collection array")
        T **newList = new T*[newSize];
        if (NULL == newList)
            ErrorThrow(PKCS_NO_MEMORY);
        for (index = 0; index < m_Mac; index += 1)
            newList[index] = m_pvList[index];
        if (NULL != m_pvList)
            delete[] m_pvList;
        m_pvList = newList;
        m_Max = newSize;
    }


    //
    // Make sure intermediate elements are filled in.
    //

    if ((DWORD)nItem >= m_Mac)
    {
        for (index = m_Mac; index < (DWORD)nItem; index += 1)
            m_pvList[index] = NULL;
        m_Mac = (DWORD)nItem + 1;
    }


    //
    // Fill in the list element.
    //

    m_pvList[(DWORD)nItem] = pvItem;
    return;

ErrorExit:
    return;
}


/*++

Get:

    This method returns the element at the given index.  If there is no element
    previously stored at that element, it returns NULL.  It does not expand the
    array.

Arguments:

    nItem - Supplies the index into the list.

Return Value:

    The value stored at that index in the list, or NULL if nothing has ever been
    stored there.

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

template <class T>
inline T * const
CCollection<T>::Get(
    int nItem)
    const
{
    if (m_Mac <= (DWORD)nItem)
        return NULL;
    else
        return m_pvList[nItem];
}


//
//==============================================================================
//
//  CAttribute
//

class CAttribute
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    CAttribute()
    :   m_osValue(),
        m_osObjId()
    { m_nType = 0; };

    virtual ~CAttribute() {};


    //  Properties
    //  Methods

    int
    TypeCompare(
        IN const CAttribute &atr)
        const;

    int
    Compare(
        IN const CAttribute &atr)
        const;

    void
    Set(
        IN LPCTSTR pszType,
        IN const BYTE FAR * pbValue,
        IN DWORD cbValLen);

    void
    Set(
        IN LPCTSTR szType,
        IN LPCTSTR szValue);

    const COctetString &
    GetValue(void) const
    { return m_osValue; };

    const COctetString &
    GetType(void) const
    { return m_osObjId; };

    DWORD
    GetAtrType(void) const
    { return m_nType; };


    //  Operators

    int
    operator==(
        IN const CAttribute &atr)
        const
    { return 0 == Compare(atr); };

    int
    operator!=(
        IN const CAttribute &atr)
        const
    { return 0 != Compare(atr); };

    CAttribute &
    operator=(
        IN const CAttribute &atr)
    { Set(atr.GetType(), atr.GetValue().Access(), atr.GetValue().Length());
      return *this; };


protected:
    //  Properties

    DWORD m_nType;
    COctetString m_osValue;
    COctetString m_osObjId;


    //  Methods
};


//
//==============================================================================
//
//  CAttributeList
//

class CAttributeList
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    ~CAttributeList()
    { Clear(); };


    //  Properties
    //  Methods

    void
    Clear(                          //  Remove all contents.
        void);

    void
    Add(
        IN CAttribute &atr);
    DWORD
    Count(void)
        const
    { return m_atrList.Count(); };
    void
    Import(
        const Attributes &asnAtrList);
    void
    Export(
        Attributes &asnAtrList)
        const;
    int
    Compare(
        IN const CAttributeList &rdn)
        const;


    //  Operators

    void
    operator+=(
        IN CAttribute &atr)
    { Add(atr); };

    int operator==(
        IN const CAttributeList &rdn)
        const
    { return 0 == Compare(rdn); };

    int operator!=(
        IN const CAttributeList &rdn)
        const
    { return 0 != Compare(rdn); };

    int operator<(
        IN const CAttributeList &rdn)
        const
    { return -1 == Compare(rdn); };

    int operator>(
        IN const CAttributeList &rdn)
        const
    { return 1 == Compare(rdn); };

    int operator<=(
        IN const CAttributeList &rdn)
        const
    { return 1 != Compare(rdn); };

    int operator>=(
        IN const CAttributeList &rdn)
        const
    { return -1 != Compare(rdn); };

    CAttribute *
    operator[](
        IN int nItem)
        const
    { return m_atrList[nItem]; };

    CAttribute *
    operator[](
        IN LPCTSTR pszObjId)
        const;

    CAttributeList &
    operator=(
        IN const CAttributeList &atl);


protected:
    //  Properties

    CCollection<CAttribute>
        m_atrList;

    //  Methods
};


//
//==============================================================================
//
//  CDistinguishedName
//

class CDistinguishedName
{
public:

    //  Constructors & Destructor

    DECLARE_NEW

    virtual ~CDistinguishedName()
    { Clear(); };


    //  Properties
    //  Methods

    void
    Clear(
        void);

    void
    Add(
        IN CAttributeList &prdn);
    int
    Compare(
        IN const CDistinguishedName &pdn)
        const;
    DWORD
    Count(void)
        const
    { return m_rdnList.Count(); };

    void
    Import(
        IN LPCTSTR pszName);
    void
    Import(
        IN const Name &asnName);

    void
    Export(
        OUT COctetString &osName)
        const;
    void
    Export(
        OUT Name &asnName)
        const;


    //  Operators

    void
    operator+=(
        IN CAttributeList &rdn)
    { Add(rdn); };

    int operator==(
        IN const CDistinguishedName &dn)
        const
    { return 0 == Compare(dn); };

    int operator!=(
        IN const CDistinguishedName &dn)
        const
    { return 0 != Compare(dn); };

    int operator<(
        IN const CDistinguishedName &dn)
        const
    { return -1 == Compare(dn); };

    int operator>(
        IN const CDistinguishedName &dn)
        const
    { return 1 == Compare(dn); };

    int operator<=(
        IN const CDistinguishedName &dn)
        const
    { return 1 != Compare(dn); };

    int operator>=(
        IN const CDistinguishedName &dn)
        const
    { return -1 != Compare(dn); };

    CAttributeList *
    operator[](
        IN int nItem)
        const
    { return m_rdnList[nItem]; };


protected:
    //  Properties

    CCollection<CAttributeList>
        m_rdnList;

    //  Methods
};

#endif // _NAMES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\licecert\utility.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    utility

Abstract:

    This module contains a collection of interesting utility routines useful to
    more than one other module.

Author:

    Frederick Chong (fredch) 6/1/1998 - Adapted code from Doug Barlow's PKCS library
    

Notes:



--*/

#include <windows.h>
#include <string.h>
#include <stdlib.h>

#if !defined(OS_WINCE)
#include <basetsd.h>
#endif

#include "utility.h"
#include "pkcs_1.h"
#include "x509.h"
#include "pkcs_err.h"
#include "names.h"

#include "rsa.h"

static const char
    md2[] =                  "1.2.840.113549.2.2",
    md4[] =                  "1.2.840.113549.2.4",
    md5[] =                  "1.2.840.113549.2.5",
    sha[] =                  "1.3.14.3.2.18",
    rsaEncryption[] =        "1.2.840.113549.1.1.1",
    md2WithRSAEncryption[] = "1.2.840.113549.1.1.2",
    md4WithRSAEncryption[] = "1.2.840.113549.1.1.3",
    md5WithRSAEncryption[] = "1.2.840.113549.1.1.4",
    shaWithRSAEncryption[] = "1.3.14.3.2.15",
    sha1WithRSASign[] =      "1.3.14.3.2.29";

static const MapStruct
    mapAlgIds[]
        = { { ( LPCTSTR )md2,                  HASH_ALG_MD2 },
            { ( LPCTSTR )md4,                  HASH_ALG_MD4 },
            { ( LPCTSTR )md5,                  HASH_ALG_MD5 },
            { ( LPCTSTR )sha,                  HASH_ALG_SHA },
            { ( LPCTSTR )rsaEncryption,        SIGN_ALG_RSA },
            { ( LPCTSTR )md2WithRSAEncryption, SIGN_ALG_RSA | HASH_ALG_MD2 },
            { ( LPCTSTR )md4WithRSAEncryption, SIGN_ALG_RSA | HASH_ALG_MD4 },
            { ( LPCTSTR )md5WithRSAEncryption, SIGN_ALG_RSA | HASH_ALG_MD5 },
            { ( LPCTSTR )shaWithRSAEncryption, SIGN_ALG_RSA | HASH_ALG_SHA },
            { ( LPCTSTR )sha1WithRSASign,      SIGN_ALG_RSA | HASH_ALG_SHA1 },
            { ( LPCTSTR )NULL, 0 } };


/*++

DwordToPkcs:

    This routine converts an LPDWORD little endian integer to a big endian
    integer in place, suitable for use with ASN.1 or PKCS.  The sign of the
    number is maintained.

Arguments:

    dwrd - Supplies and receives the integer in the appropriate formats.
    lth - length of the supplied array, in bytes.

Return Value:

    The size of the resulting array, with trailing zeroes stripped.

Author:

    Doug Barlow (dbarlow) 7/27/1995

--*/

DWORD
DwordToPkcs(
    IN OUT LPBYTE dwrd,
    IN DWORD lth)
{
    LPBYTE pbBegin = dwrd;
    LPBYTE pbEnd = &dwrd[lth];
    while (0 == *(--pbEnd));   // Note semi-colon here!
    if ((0 == (dwrd[lth - 1] & 0x80)) && (0 != (*pbEnd & 0x80)))
        pbEnd += 1;

#if defined(OS_WINCE)
    size_t length = pbEnd - pbBegin + 1;
#else
    SIZE_T length = pbEnd - pbBegin + 1;
#endif

    while (pbBegin < pbEnd)
    {
        BYTE tmp = *pbBegin;
        *pbBegin++ = *pbEnd;
        *pbEnd-- = tmp;
    }
    return (DWORD)length;
}


/*++

PkcsToDword:

    This routine reverses the effects of DwordToPkcs, so that a big endian
    byte stream integer is converted to a little endian DWORD stream integer in
    place.

Arguments:

    pbPkcs - Supplies and receives the integer in the appropriate formats.
    lth - length of the supplied array, in bytes.

Return Value:

    The size of the resultant array in bytes, with trailing zeroes stripped.

Author:

    Doug Barlow (dbarlow) 7/27/1995

--*/

DWORD
PkcsToDword(
    IN OUT LPBYTE pbPkcs,
    IN DWORD lth)
{
    LPBYTE pbBegin = pbPkcs;
    LPBYTE pbEnd = &pbPkcs[lth - 1];
    DWORD length = lth;
    while (pbBegin < pbEnd)
    {
        BYTE tmp = *pbBegin;
        *pbBegin++ = *pbEnd;
        *pbEnd-- = tmp;
    }
    for (pbEnd = &pbPkcs[lth - 1]; 0 == *pbEnd; pbEnd -= 1)
        length -= 1;
    return length;
}


/*++

ASNlength:

    This routine returns the length, in bytes, of the following ASN.1
    construction in the supplied buffer.  This routine recurses if necessary to
    always produce a length, even if the following construction uses indefinite
    endcoding.

Arguments:

    asnBuf - Supplies the ASN.1 buffer to parse.
    pdwData - Receives the number of bytes prior to the value of the
        construction (i.e., the length in bytes of the Type and Length
        encodings).  If this is NULL, no value is returned.

Return Value:

    The length of the construction.  A DWORD status code is thrown on errors.

Author:

    Doug Barlow (dbarlow) 7/27/1995

--*/

DWORD
ASNlength(
    IN const BYTE FAR *asnBuf,
    IN DWORD cbBuf,
    OUT LPDWORD pdwData)
{
    DWORD
        lth
            = 0,
        index
            = 0;


    //
    // Skip over the Type.
    //

    if (cbBuf < sizeof(BYTE))
    {
        ErrorThrow(PKCS_ASN_ERROR);
    }

    if (31 > (asnBuf[index] & 0x1f))
    {
        index += 1;
    }
    else
    {
        if (cbBuf < (index+2) * sizeof(BYTE))
        {
            ErrorThrow(PKCS_ASN_ERROR);
        }

        while (0 != (asnBuf[++index] & 0x80))
        {
            if (cbBuf < (index+2) * sizeof(BYTE))
            {
                ErrorThrow(PKCS_ASN_ERROR);
            }
        }
    }


    //
    // Extract the Length.
    //

    if (cbBuf < (index+1) * sizeof(BYTE))
    {
        ErrorThrow(PKCS_ASN_ERROR);
    }

    if (0 == (asnBuf[index] & 0x80))
    {

        //
        // Short form encoding.
        //

        lth = asnBuf[index++];
    }
    else
    {
        DWORD ll = asnBuf[index++] & 0x7f;

        if (0 != ll)
        {
            //
            // Long form encoding.
            //

            for (; 0 < ll; ll -= 1)
            {
                if (0 != (lth & 0xff000000))
                {
                    ErrorThrow(PKCS_ASN_ERROR);
                }
                else
                {
                    if (cbBuf < (index+1) * sizeof(BYTE))
                    {
                        ErrorThrow(PKCS_ASN_ERROR);
                    }

                    lth = (lth << 8) | asnBuf[index];
                }
                index += 1;
            }
        }
        else
        {

            //
            // Indefinite encoding.
            //

            DWORD offset;

            if (cbBuf < (index + 2) * sizeof(BYTE))
            {
                ErrorThrow(PKCS_ASN_ERROR);
            }

            while ((0 != asnBuf[index]) || (0 != asnBuf[index + 1]))
            {
                ll = ASNlength(&asnBuf[index], cbBuf - index, &offset);
                lth += ll;
                index += offset;

                if (cbBuf < (index + 2) * sizeof(BYTE))
                {
                    ErrorThrow(PKCS_ASN_ERROR);
                }
            }
            index += 2;
        }
    }

    //
    // Supply the caller with what we've learned.
    //

    if (NULL != pdwData)
        *pdwData = index;
    return lth;


ErrorExit:
    if (NULL != pdwData)
        *pdwData = 0;
    return 0;
}


/*++

PKInfoToBlob:

    This routine converts an ASN.1 PublicKeyInfo structure to a BSAFE Key
    Blob.

Arguments:

    asnPKInfo - Supplies the ASN.1 PublicKeyInfo structure.
    algType - Supplies the type of key (CALG_RSA_SIGN or CALG_RSA_KEYX)
    osBlob - Receves the Crypto API Key Blob.

Return Value:

    None.  A DWORD status code is thrown on errors.

Author:

    Frederick Chong (fredch) 6/1/1998

--*/

void
PKInfoToBlob(
    IN  SubjectPublicKeyInfo &asnPKInfo,
    OUT COctetString &osBlob)
{
    long int
        lth,
        origLth;
    LPCTSTR
        sz;
    COctetString
        osMiscString;
    CAsnNull
        asnNull;


    sz = (LPCTSTR)asnPKInfo.algorithm.algorithm;
    if (NULL == sz)
        ErrorThrow(PKCS_ASN_ERROR);     // Or memory out.
    asnPKInfo.algorithm.parameters = asnNull;


    //
    // Convert the key to a key blob.
    //

    if( ( 0 == strcmp( ( char * )sz, rsaEncryption ) ) ||
        ( 0 == strcmp( ( char * )sz, md5WithRSAEncryption ) ) ||
        ( 0 == strcmp( ( char * )sz, shaWithRSAEncryption ) ) )
    {

        //
        // It's an RSA public key & exponent structure.
        // Convert it to a Bsafe key structure
        //

        RSAPublicKey asnPubKey;
        LPBSAFE_PUB_KEY pBsafePubKey;

        LPBYTE modulus;
        int shift = 0;

        lth = asnPKInfo.subjectPublicKey.DataLength();
        if (0 > lth)
            ErrorThrow(PKCS_ASN_ERROR);
        osMiscString.Resize(lth);
        ErrorCheck;
        lth = asnPKInfo.subjectPublicKey.Read(
                osMiscString.Access(), &shift);
        if (0 > lth)
            ErrorThrow(PKCS_ASN_ERROR);
        if (0 > asnPubKey.Decode(osMiscString.Access(), osMiscString.Length()))
            ErrorThrow(PKCS_ASN_ERROR);
        lth = asnPubKey.modulus.DataLength();
        if (0 > lth)
            ErrorThrow(PKCS_ASN_ERROR);
        osMiscString.Resize(lth);
        ErrorCheck;
        lth = asnPubKey.modulus.Read(osMiscString.Access());
        if (0 > lth)
            ErrorThrow(PKCS_ASN_ERROR);

        // osBlob is fixed in place here.
        origLth = sizeof(BSAFE_PUB_KEY) + lth;
        osBlob.Resize(origLth);
        ErrorCheck;

        pBsafePubKey = ( LPBSAFE_PUB_KEY )osBlob.Access();
        modulus = (LPBYTE)osBlob.Access( sizeof( BSAFE_PUB_KEY ) );
        
        memcpy(modulus, osMiscString.Access(), osMiscString.Length());
        lth = PkcsToDword(modulus, osMiscString.Length());
        ErrorCheck;
        
        pBsafePubKey->magic = RSA1;
        pBsafePubKey->keylen = lth + sizeof( DWORD ) * 2; // meet PKCS #1 minimum padding size
        pBsafePubKey->bitlen = lth * 8;
        pBsafePubKey->datalen = lth - 1;
        pBsafePubKey->pubexp = asnPubKey.publicExponent;
        osBlob.Resize( sizeof( BSAFE_PUB_KEY ) + lth + sizeof( DWORD ) * 2 );
        ErrorCheck;
        
        //
        // zero out padding bytes
        //

        memset( osBlob.Access() + sizeof( BSAFE_PUB_KEY ) + lth, 0, sizeof( DWORD ) * 2 );

        ErrorCheck;
    }
    else
        ErrorThrow(PKCS_NO_SUPPORT);
    return;

ErrorExit:
    osBlob.Empty();
}


/*++

ObjIdToAlgId:

    This routine translates an Object Identifier to an Algorithm Identifier.

Arguments:

    asnAlgId - Supplies the AlgorithmIdentifier structure to be recognized.

Return Value:

    The Crypto API ALG_ID corresponding to the supplied AlgorithmIdentifier.  A
    DWORD status code is thrown on errors.

Author:

    Doug Barlow (dbarlow) 7/31/1995

--*/

ALGORITHM_ID
ObjIdToAlgId(
    const AlgorithmIdentifier &asnAlgId)
{
    DWORD
        dwAlgId;
    LPCTSTR
        sz;


    //
    // Extract the Object Identifier string.
    //

    sz = asnAlgId.algorithm;
    if (NULL == sz)
        ErrorThrow(PKCS_ASN_ERROR);
    // Ignore parameters ?fornow?


    //
    // Check it against known identifiers.
    //

    if (!MapFromName(mapAlgIds, sz, &dwAlgId))
        ErrorThrow(PKCS_NO_SUPPORT);
    return (ALGORITHM_ID)dwAlgId;

ErrorExit:
    return 0;
}


/*++

FindSignedData:

    This routine examines a block of ASN.1 that has been created by the SIGNED
    macro, and extracts the offset and length of that data.

Arguments:

    pbSignedData - Supplies the ASN.1 Encoded signed data.
    pdwOffset - Receives the number of bytes from the beginning of the signed
        data that the actual data begins.
    pcbLength - Receives the length of the actual data.

Return Value:

    None.  A DWORD status code is thrown on errors.

Author:

    Doug Barlow (dbarlow) 8/22/1995

--*/

void
FindSignedData(
    IN const BYTE FAR * pbSignedData,
    IN DWORD cbSignedData,
    OUT LPDWORD pdwOffset,
    OUT LPDWORD pcbLength)
{
    DWORD
        length,
        offset,
        inset;

    // Here we get the offset to the toBeSigned field.
    ASNlength(pbSignedData, cbSignedData, &offset);
    ErrorCheck;

    // Now find the length of the toBeSigned field.
    length = ASNlength(&pbSignedData[offset], cbSignedData - offset, &inset);
    ErrorCheck;
    length += inset;

    // Return our findings.
    *pdwOffset = offset;
    *pcbLength = length;
    return;

ErrorExit:
    return;
}


/*++

NameCompare:

    These routines compare various forms of Distinguished Names for Equality.

Arguments:

    szName1 supplies the first name as a string.
    asnName1 supplies the first name as an X.509 Name.
    szName2 supplies the second name as a string.
    asnName2 supplies the second name as an X.509 Name.

Return Value:

    TRUE - They are identical.
    FALSE - They are different.

Author:

    Doug Barlow (dbarlow) 9/12/1995

--*/

BOOL
NameCompare(
    IN LPCTSTR szName1,
    IN LPCTSTR szName2)
{
    int result;
    CDistinguishedName dnName1, dnName2;
    dnName1.Import(szName1);
    ErrorCheck;
    dnName2.Import(szName2);
    ErrorCheck;
    result = dnName1.Compare(dnName2);
    ErrorCheck;
    return (0 == result);

ErrorExit:
    return FALSE;
}

BOOL
NameCompare(
    IN const Name &asnName1,
    IN const Name &asnName2)
{
    int result;
    CDistinguishedName dnName1, dnName2;
    dnName1.Import(asnName1);
    ErrorCheck;
    dnName2.Import(asnName2);
    ErrorCheck;
    result = dnName1.Compare(dnName2);
    ErrorCheck;
    return (0 == result);

ErrorExit:
    return FALSE;
}

BOOL
NameCompare(
    IN LPCTSTR szName1,
    IN const Name &asnName2)
{
    int result;
    CDistinguishedName dnName1, dnName2;
    dnName1.Import(szName1);
    ErrorCheck;
    dnName2.Import(asnName2);
    ErrorCheck;
    result = dnName1.Compare(dnName2);
    ErrorCheck;
    return (0 == result);

ErrorExit:
    return FALSE;
}

BOOL
NameCompare(
    IN const Name &asnName1,
    IN LPCTSTR szName2)
{
    int result;
    CDistinguishedName dnName1, dnName2;
    dnName1.Import(asnName1);
    ErrorCheck;
    dnName2.Import(szName2);
    ErrorCheck;
    result = dnName1.Compare(dnName2);
    ErrorCheck;
    return (0 == result);

ErrorExit:
    return FALSE;
}

BOOL
NameCompare(
    IN const CDistinguishedName &dnName1,
    IN const Name &asnName2)
{
    int result;
    CDistinguishedName dnName2;
    dnName2.Import(asnName2);
    ErrorCheck;
    result = dnName1.Compare(dnName2);
    ErrorCheck;
    return (0 == result);

ErrorExit:
    return FALSE;
}


/*++

VerifySignedAsn:

    This method verifies a signature on a signed ASN.1 Structure.

Arguments:

    crt - Supplies the CCertificate object to use to validate the signature.
    pbAsnData - Supplies the buffer containing the signed ASN.1 structure.
    szDescription - Supplies a description incorporated into the signature, if
        any.

Return Value:

    None.  A DWORD status code is thrown on errors.

Author:

    Doug Barlow (dbarlow) 7/31/1995

--*/

void
VerifySignedAsn(
    IN const CCertificate &crt,
    IN const BYTE FAR * pbAsnData,
    IN DWORD cbAsnData,
    IN LPCTSTR szDescription)    
{
    AlgorithmIdentifier
        asnAlgId;
    CAsnBitstring
        asnSignature;
    COctetString
        osSignature;
    const BYTE FAR *
        pbData;
    DWORD
        length,
        offset;
    long int
        lth;
    int
        shift = 0;
    ALGORITHM_ID
        algIdSignature;
    
    //
    // Extract the fields.
    //

    FindSignedData(pbAsnData, cbAsnData, &offset, &length);
    ErrorCheck;
    pbData = &pbAsnData[offset];
    cbAsnData -= offset;

    lth = asnAlgId.Decode(pbData + length, cbAsnData - length);
    if (0 > lth)
        ErrorThrow(PKCS_ASN_ERROR);
    lth = asnSignature.Decode(pbData + length + lth, cbAsnData - length - lth);
    if (0 > lth)
        ErrorThrow(PKCS_ASN_ERROR);

    if (0 > (lth = asnSignature.DataLength()))
        ErrorThrow(PKCS_ASN_ERROR);
    offset = 0;
    osSignature.Resize(lth);
    ErrorCheck;
    if (0 > asnSignature.Read(osSignature.Access(), &shift))
        ErrorThrow(PKCS_ASN_ERROR);
    lth = PkcsToDword(osSignature.Access(), lth);
    ErrorCheck;
    algIdSignature = ObjIdToAlgId(asnAlgId);
    ErrorCheck;
    crt.Verify(
        pbData,
        cbAsnData,
        length,
        algIdSignature,
        szDescription,
        osSignature.Access(),
        osSignature.Length());
    ErrorCheck;
    return;

ErrorExit:
    return;
}


/*++

MapFromName:

    This routine translates a string value to a corresponding 32-bit integer
    value based on the supplied translation table.

Arguments:

    pMap supplies the mapping table address.

    szKey supplies the string value to translate from.

    pdwResult receives the translation.


  Return Value:

    TRUE - Successful Translation.
    FALSE - Translation Failure.

Author:

    Doug Barlow (dbarlow) 2/14/1996

--*/

BOOL
MapFromName(
    IN const MapStruct *pMap,
    IN LPCTSTR szKey,
    OUT LPDWORD pdwResult)
{
    const MapStruct *pMatch = pMap;

    if (NULL == szKey)
        return FALSE;
    while (NULL != pMatch->szKey)
    {
        if (0 == strcmp( ( char * )pMatch->szKey, ( char * )szKey))
        {
            *pdwResult = pMatch->dwValue;
            return TRUE;
        }
        pMatch += 1;
    }
    return FALSE;
}


/*++

GetHashData:

    This routine gets the hash data from a PKCS #1 encryption block.

Arguments:

    osEncryptionBlock The PKCS #1 encryption block.
    osHashData The hashed data

Return Value:

    TRUE if the function is successful or FALSE otherwise.

Author:

    Frederick Chong (fredch) 5/29/1998

--*/


BOOL
GetHashData( 
    COctetString &osEncryptionBlock, 
    COctetString &osHashData )
{
    DWORD
        i, numPaddings = 0, Length;
    LPBYTE
        pbEncryptionBlock;
    DigestInfo
        asnDigest;

    //
    // according to PKCS #1, the decrypted block should be of the following form
    // EB = 0x00 || BT || PS || 0x00 || D where
    //
    // EB = Encryption Block, 
    // BT = Block Type and can be 0x00, 0x01 or 0x02, 
    // PS = Padding String and must be 0xFF when BT = 0x01, 
    // D = data to be encrypted
    // || = concatenation.
    //
    // Furthermore, For RSA decryption, it is an error if BT != 0x01
    //

    //
    // Search for decryption block type since the encryption block
    // passed in may start off with a bunch of zeroed padding bytes
    //

    Length = osEncryptionBlock.Length();
    pbEncryptionBlock = osEncryptionBlock.Access();
        
    for( i = 0; i < Length; i++ )
    {
        if( 0x01 == *( pbEncryptionBlock + i ) )
        {
            break;
        }
    }

    if( i == Length )
    {
        ErrorThrow( PKCS_ASN_ERROR );
    }

    //
    // now look for the padding string.  Expects all padding string to be
    // 0xFF when BT = 0x01
    //
    
    i++;
    while( i < Length )
    {
        if( 0xFF == *( pbEncryptionBlock + i ) )
        {
            //
            // count the number of padding bytes
            //

            numPaddings++;
        }
        else
        {
            break;
        }

        i++;
    }

    //
    // PKCS #1 requires at least 8 padding bytes
    //

    if( numPaddings < 8 )
    {
        ErrorThrow( PKCS_ASN_ERROR );
    }

    if( ++i >= Length )
    {
        ErrorThrow( PKCS_ASN_ERROR );
    }

    //
    // Decode the data block which is an ASN.1 encoded DigestInfo object
    //

    asnDigest.Decode( pbEncryptionBlock + i, osEncryptionBlock.Length() - i );
    ErrorCheck;

    //
    // Get the hashed data
    //

    osHashData.Resize( asnDigest.Digest.DataLength() );
    ErrorCheck;

    asnDigest.Digest.Read( osHashData.Access() );
    ErrorCheck;

    return( TRUE );

ErrorExit:

    return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\licecert\pkcs_err.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pkcs_err

Abstract:

    This header file contains the definitions for the various error codes that
    can occur within the PKCS library.

Author:

    Doug Barlow (dbarlow) 8/4/1995

Environment:

    Win32, Crypto API

Notes:



--*/

#ifndef _PKCS_ERR_H_
#define _PKCS_ERR_H_

#include "license.h"
#include "memcheck.h"

#define PKCSERR_PREFIX 0

static const DWORD
    PKCS_NO_MEMORY =       (DWORD)LICENSE_STATUS_OUT_OF_MEMORY,         // Memory Allocation Error.
    PKCS_NAME_ERROR =      (DWORD)LICENSE_STATUS_INVALID_X509_NAME,     // X.509 name parsing error.
    PKCS_INTERNAL_ERROR =  (DWORD)LICENSE_STATUS_UNSPECIFIED_ERROR,     // Internal logic error.
    PKCS_NO_SUPPORT =      (DWORD)LICENSE_STATUS_NOT_SUPPORTED,         // Unsupported algorithm or attribute.
    PKCS_BAD_PARAMETER =   (DWORD)LICENSE_STATUS_INVALID_INPUT,         // Invalid Paramter.
    PKCS_CANT_VALIDATE =   (DWORD)LICENSE_STATUS_INVALID_CERTIFICATE,   // Can't validate signature.
    PKCS_NO_ATTRIBUTE =    (DWORD)LICENSE_STATUS_NO_ATTRIBUTES,         // No attribute to match id.
    PKCS_NO_EXTENSION =    (DWORD)LICENSE_STATUS_NO_EXTENSION,          // No extension to match id.
    PKCS_BAD_LENGTH =      (DWORD)LICENSE_STATUS_INSUFFICIENT_BUFFER,   // Insufficient buffer size.
    PKCS_ASN_ERROR =       (DWORD)LICENSE_STATUS_ASN_ERROR,             // ASN.1 Error from ASN_EZE Library.
    PKCS_INVALID_HANDLE =  (DWORD)LICENSE_STATUS_INVALID_HANDLE;        // Invalid handle

extern BOOL
MapError(
    void);


//
// Pseudo Exception Handling Macros.
//

#define ErrorInitialize SetLastError(0)
#define ErrorThrow(sts) \
    { if (0 == GetLastError()) SetLastError(sts); \
      goto ErrorExit; }
#define ErrorCheck if (0 != GetLastError()) goto ErrorExit
#define ErrorSet(sts) SetLastError(sts)

#endif // _PKCS_ERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\licecert\utility.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    utility

Abstract:

    This header file describes the utility routines available to the PKCS
    library.

Author:

    Frederick Chong (fredch) 6/1/1998, adapted from Doug Barlow's PKCS library
    code.

Notes:


--*/

#ifndef _UTILITY_H_
#define _UTILITY_H_

#include "certcate.h"
#include "ostring.h"
#include "x509.h"
#include "pkcs_err.h"

#ifdef OS_WINCE
#include <adcgbtyp.h>
#endif
#ifndef RSA1
#define RSA1 ((DWORD)'R'+((DWORD)'S'<<8)+((DWORD)'A'<<16)+((DWORD)'1'<<24))
#define RSA2 ((DWORD)'R'+((DWORD)'S'<<8)+((DWORD)'A'<<16)+((DWORD)'2'<<24))
#endif


typedef struct {
    LPCTSTR szKey;
    DWORD dwValue;
} MapStruct;

extern DWORD
DwordToPkcs(
    IN OUT LPBYTE dwrd,
    IN DWORD lth);

extern DWORD
PkcsToDword(
    IN OUT LPBYTE pbPkcs,
    IN DWORD lth);

extern DWORD
ASNlength(
    IN const BYTE FAR *asnBuf,
    IN DWORD cbBuf,
    OUT LPDWORD pdwData = NULL);

extern void
PKInfoToBlob(
    IN SubjectPublicKeyInfo &asnPKInfo,
    OUT COctetString &osBlob);

extern ALGORITHM_ID
ObjIdToAlgId(
    const AlgorithmIdentifier &asnAlgId);

extern void
FindSignedData(
    IN const BYTE FAR * pbSignedData,
    IN DWORD cbSignedData,
    OUT LPDWORD pdwOffset,
    OUT LPDWORD pcbLength);

extern BOOL
NameCompare(
    IN LPCTSTR szName1,
    IN LPCTSTR szName2);

extern BOOL
NameCompare(
    IN const Name &asnName1,
    IN const Name &asnName2);

extern BOOL
NameCompare(
    IN LPCTSTR szName1,
    IN const Name &asnName2);

extern BOOL
NameCompare(
    IN const Name &asnName1,
    IN LPCTSTR szName2);

extern BOOL
NameCompare(
    IN const CDistinguishedName &dnName1,
    IN const Name &asnName2);

extern void
VerifySignedAsn(
    IN const CCertificate &crt,
    IN const BYTE FAR * pbAsnData,
    IN DWORD cbAsnData,
    IN LPCTSTR szDescription);
    
extern BOOL
MapFromName(
    IN const MapStruct *pMap,
    IN LPCTSTR szKey,
    OUT LPDWORD pdwResult);

extern BOOL
GetHashData( 
    COctetString &osEncryptionBlock, 
    COctetString &osHashData );

//
//==============================================================================
//
//  CHandleTable
//

#ifdef OS_WINCE
#define ULongToPtr( ul ) ((VOID *)(ULONG_PTR)((unsigned long)ul))
#endif

#define BAD_HANDLE (DWORD)(-1)
#define MAKEHANDLE(id, ix) ULongToPtr(((id) << 24) + (ix))

#ifdef OS_WINCE
#define PARSEHANDLE(hdl) ((m_bIdentifier == ((DWORD)(hdl) >> 24)) \
                            ? (DWORD)(hdl) & 0x00ffffff \
                            : BAD_HANDLE)
#else
#define PARSEHANDLE(hdl) ((m_bIdentifier == (PtrToUlong(hdl) >> 24)) \
                            ? PtrToUlong(hdl) & 0x00ffffff \
                            : BAD_HANDLE)
#endif

template <class T>
class CHandleTable
{
public:

    //  Constructors & Destructor

    CHandleTable(BYTE bIdentifier)
    :   m_rghHandles()
    {
        m_bIdentifier = bIdentifier;
        __try {
            InitializeCriticalSection(&m_critSect);
            m_fValid = TRUE;
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            m_fValid = FALSE;
        }

    };

    virtual ~CHandleTable()
    {
        if (m_fValid)
        {
            Clear();
            DeleteCriticalSection(&m_critSect);
        }
    };


    //  Methods

    const void *
    Add(
        T *pT)
    {
        LPVOID pvHandle;

        if (!m_fValid)
            ErrorThrow(PKCS_NO_MEMORY);

        EnterCriticalSection(&m_critSect);
        __try
        {
            for (DWORD index = 0; NULL != m_rghHandles[index]; index += 1);
                // Null for loop body.
            m_rghHandles.Set(index, pT);
            pvHandle = MAKEHANDLE(m_bIdentifier, index);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            pvHandle = NULL;
        }
        LeaveCriticalSection(&m_critSect);
        ErrorCheck;
        if (NULL == pvHandle)
            ErrorThrow(PKCS_NO_MEMORY);
        return pvHandle;

    ErrorExit:
        return NULL;
    };

    const void *
    Create(void)
    {
        const void *pvHandle;
        T *pT = NULL;

        if (!m_fValid)
            ErrorThrow(PKCS_NO_MEMORY);

        NEWReason("Handle Table Entry")
        pT = new T;
        if (NULL == pT)
            ErrorThrow(PKCS_NO_MEMORY);
        pvHandle = Add(pT);
        ErrorCheck;
        return pvHandle;

    ErrorExit:
        if (NULL != pT)
            delete pT;
        return NULL;
    };

    T *
    Lookup(
        IN const void *hHandle,
        IN BOOL fThrowErr = TRUE)
    {
        T *pt = NULL;

        if (!m_fValid)
            ErrorThrow(PKCS_NO_MEMORY);
#ifndef OS_WINCE
        DWORD index = PARSEHANDLE(hHandle);
#else
        DWORD index;
		index = PARSEHANDLE(hHandle);
#endif
        if (BAD_HANDLE != index)
        {
            EnterCriticalSection(&m_critSect);
            __try
            {
                pt = m_rghHandles[index];
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                pt = NULL;
            }
            LeaveCriticalSection(&m_critSect);
        }
        if (NULL == pt && fThrowErr)
            ErrorThrow(PKCS_INVALID_HANDLE);
        return pt;

    ErrorExit:
        return NULL;
    };

    void
    Delete(
        IN const void *hHandle)
    {
        T *pt = NULL;

        if (!m_fValid)
            ErrorThrow(PKCS_NO_MEMORY);

#ifndef OS_WINCE
        DWORD index = PARSEHANDLE(hHandle);
#else
        DWORD index;
		index = PARSEHANDLE(hHandle);
#endif
        if (BAD_HANDLE != index)
        {
            EnterCriticalSection(&m_critSect);
            __try
            {
                pt = m_rghHandles[index];
                if (NULL != pt)
                {
                    m_rghHandles.Set(index, NULL);
                    delete pt;
                }
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {}
            LeaveCriticalSection(&m_critSect);
        }
        if (NULL == pt)
            ErrorThrow(PKCS_INVALID_HANDLE);

    ErrorExit:
        return;
    };

    DWORD
    Count(void) const
    { return m_fValid ? m_rghHandles.Count() : 0; };

    void
    Clear(void)
    {
        T *pt;

        if (!m_fValid)
            return;

        for (DWORD index = m_rghHandles.Count(); 0 < index;)
        {
            index -= 1;
            pt = m_rghHandles[index];
            if (NULL != pt)
                delete pt;
        }
        m_rghHandles.Clear();
    }

protected:
    //  Properties

    CRITICAL_SECTION
        m_critSect;
    BYTE
        m_bIdentifier;
    CCollection<T>
        m_rghHandles;
    BOOL m_fValid;


    // Methods
};

#endif // _UTILITY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certutil\ext.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        ext.c
//
// Contents:    Routine related to hydra certificate extension
//
// History:     03-18-98    HueiWang    Created
//
// Note:
//---------------------------------------------------------------------------
#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>
#include <tchar.h>
#include <shellapi.h>
#include <stddef.h>
#include <winnls.h>
#include "base64.h"
#include "license.h"
#include "cryptkey.h"
#include "certutil.h"

/*****************************************************************************

    LSConvertMsLicensedProductInfoToExtension();
    LSConvertExtensionToMsLicensedProductInfo();

*****************************************************************************/
DWORD 
LSExtensionToMsLicensedProductInfo(
    PBYTE      pbData,
    DWORD      cbData,
    PDWORD     pdwQuantity,
    PDWORD     pdwPlatformId,
    PDWORD     pdwLanguagId,
    PBYTE*     ppbOriginalProductId,
    PDWORD     pcbOriginalProductId,
    PBYTE*     ppbAdjustedProductId,
    PDWORD     pcbAdjustedProductId,
    LICENSED_VERSION_INFO** ppLicenseInfo,
    PDWORD     pdwNumberLicensedVersionInfo
    )
/*++
++*/
{
    // 
    // Need to consider structure version
    //
    UNALIGNED LICENSED_PRODUCT_INFO *ptr = (LICENSED_PRODUCT_INFO*)pbData;

    if(ptr->dwVersion != LICENSED_PRODUCT_INFO_VERSION)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if(pdwQuantity)
    {
        *pdwQuantity = ptr->dwQuantity;
    }

    if(pdwPlatformId)
    {
        *pdwPlatformId = ptr->dwPlatformID;
    }

    if(pdwLanguagId)
    {
        *pdwLanguagId = ptr->dwLanguageID;
    }

    //
    // Original request product ID
    //
    if(ppbOriginalProductId)
    {
        // allocate memory to prevent alignment fault
        *ppbOriginalProductId = (PBYTE)AllocMemory(ptr->wOrgProductIDSize + sizeof(TCHAR));
        if(!*ppbOriginalProductId)
        {
            return LICENSE_STATUS_OUT_OF_MEMORY;
        }

        memcpy(
            *ppbOriginalProductId, 
            pbData + ptr->wOrgProductIDOffset, 
            ptr->wOrgProductIDSize
        );
    }

    if(pcbOriginalProductId)
    {
        *pcbOriginalProductId = ptr->wOrgProductIDSize;
    }

    //
    // Adjusted product ID
    //
    if(ppbAdjustedProductId)
    {
        // allocate memory to prevent alignment fault
        *ppbAdjustedProductId = (PBYTE)AllocMemory(ptr->wAdjustedProductIdSize + sizeof(TCHAR));
        if(!*ppbAdjustedProductId)
        {
            return LICENSE_STATUS_OUT_OF_MEMORY;
        }

        memcpy(
            *ppbAdjustedProductId, 
            pbData + ptr->wAdjustedProductIdOffset, 
            ptr->wAdjustedProductIdSize
        );
    }

    if(pcbAdjustedProductId)
    {
        *pcbAdjustedProductId = ptr->wAdjustedProductIdSize;
    }


    //
    // alignment fix up
    //
    if(ppLicenseInfo)
    {
        *ppLicenseInfo = (LICENSED_VERSION_INFO *)AllocMemory(ptr->wNumberOfVersionInfo * sizeof(LICENSED_VERSION_INFO));
        if(!*ppLicenseInfo)
        {
            return LICENSE_STATUS_OUT_OF_MEMORY;
        }

        memcpy(
            *ppLicenseInfo, 
            pbData + ptr->wVersionInfoOffset, 
            ptr->wNumberOfVersionInfo * sizeof(LICENSED_VERSION_INFO)
        );
    }

    if(pdwNumberLicensedVersionInfo)
        *pdwNumberLicensedVersionInfo = ptr->wNumberOfVersionInfo;

    return LICENSE_STATUS_OK;
}

//----------------------------------------------------------------------------------------
DWORD 
LSLicensedProductInfoToExtension(
    IN DWORD dwQuantity,
    IN DWORD dwPlatformId,
    IN DWORD dwLangId,
    IN PBYTE pbOriginalProductId,
    IN DWORD cbOriginalProductId,
    IN PBYTE pbAdjustedProductId,
    IN DWORD cbAdjustedProductId,
    IN LICENSED_VERSION_INFO* pLicensedVersionInfo,
    IN DWORD dwNumLicensedVersionInfo,
    OUT PBYTE *pbData,
    OUT PDWORD cbData
    )
/*++
++*/
{
    LICENSED_PRODUCT_INFO* pLicensedInfo;

    *cbData=sizeof(LICENSED_PRODUCT_INFO) + cbAdjustedProductId + 
                cbOriginalProductId + dwNumLicensedVersionInfo * sizeof(LICENSED_VERSION_INFO);
    pLicensedInfo=(LICENSED_PRODUCT_INFO *)AllocMemory(*cbData);
    if(!pLicensedInfo)
    {
        return LICENSE_STATUS_OUT_OF_MEMORY;
    }

    pLicensedInfo->dwVersion = LICENSED_PRODUCT_INFO_VERSION;
    pLicensedInfo->dwQuantity = dwQuantity;
    pLicensedInfo->dwPlatformID = dwPlatformId;
    pLicensedInfo->dwLanguageID = dwLangId;

    //
    // First variable data is the original product request ID
    //
    pLicensedInfo->wOrgProductIDOffset = offsetof(LICENSED_PRODUCT_INFO, bVariableDataStart);
    pLicensedInfo->wOrgProductIDSize = (WORD)cbOriginalProductId;
    memcpy(
        &(pLicensedInfo->bVariableDataStart[0]), 
        pbOriginalProductId, 
        cbOriginalProductId
    );

    //
    // Second variable is the adjusted product id by policy module
    //
    pLicensedInfo->wAdjustedProductIdOffset = pLicensedInfo->wOrgProductIDOffset + pLicensedInfo->wOrgProductIDSize;
    pLicensedInfo->wAdjustedProductIdSize = (WORD)cbAdjustedProductId;
    memcpy(
        (PBYTE)pLicensedInfo + pLicensedInfo->wAdjustedProductIdOffset,
        pbAdjustedProductId,
        cbAdjustedProductId
    );

    //
    // Third variable is the product version array
    //
    pLicensedInfo->wVersionInfoOffset = pLicensedInfo->wAdjustedProductIdOffset + pLicensedInfo->wAdjustedProductIdSize;
    pLicensedInfo->wNumberOfVersionInfo = (WORD)dwNumLicensedVersionInfo;

    memcpy((PBYTE)pLicensedInfo + pLicensedInfo->wVersionInfoOffset, 
           pLicensedVersionInfo, 
           dwNumLicensedVersionInfo * sizeof(LICENSED_VERSION_INFO));

    *pbData=(PBYTE)pLicensedInfo;
    return LICENSE_STATUS_OK;
}
//----------------------------------------------------------------------------------------
LICENSE_STATUS
LSMsLicenseServerInfoToExtension(
    LPTSTR szIssuer,
    LPTSTR szIssuerId,
    LPTSTR szScope,
    PBYTE* pbData,
    PDWORD cbData
    )
/*++
++*/
{
    MS_LICENSE_SERVER_INFO* pLicenseServerInfo;

    *cbData=sizeof(MS_LICENSE_SERVER_INFO) + 
            (_tcslen(szIssuerId) + _tcslen(szIssuer) + _tcslen(szScope) + 3) * sizeof(TCHAR);

    pLicenseServerInfo = (MS_LICENSE_SERVER_INFO*)AllocMemory(*cbData);
    if(pLicenseServerInfo == NULL)
    {
        return LICENSE_STATUS_OUT_OF_MEMORY;
    }

    pLicenseServerInfo->dwVersion = MS_LICENSE_SERVER_INFO_VERSION2;
    pLicenseServerInfo->wIssuerOffset = 0;
    pLicenseServerInfo->wIssuerIdOffset = (_tcslen(szIssuer)+1) * sizeof(TCHAR);
    pLicenseServerInfo->wScopeOffset = pLicenseServerInfo->wIssuerIdOffset + (_tcslen(szIssuerId) + 1) * sizeof(TCHAR);

    memcpy(
            &(pLicenseServerInfo->bVariableDataStart[0]), 
            (PBYTE)szIssuer, 
            _tcslen(szIssuer) * sizeof(TCHAR)
        );

    memcpy(
            &(pLicenseServerInfo->bVariableDataStart[0]) + pLicenseServerInfo->wIssuerIdOffset,
            (PBYTE)szIssuerId, 
            _tcslen(szIssuerId) * sizeof(TCHAR)
        );

    memcpy(
            &(pLicenseServerInfo->bVariableDataStart[0]) + pLicenseServerInfo->wScopeOffset,
            szScope, 
            _tcslen(szScope) * sizeof(TCHAR)
        );

    *pbData = (PBYTE)pLicenseServerInfo;
    return LICENSE_STATUS_OK;
}
//---------------------------------------------------------------------------------------
#ifdef _WIN64
DWORD
UnalignedStrLenW(
    UNALIGNED WCHAR *pString
    )
{
    DWORD dwChar = 0;

    while(*pString != (WCHAR)NULL)
    {
        dwChar++;
        pString++;
    }

    return(dwChar);
}

#define STRLEN3264 UnalignedStrLenW
#else
#define STRLEN3264 wcslen
#endif

LICENSE_STATUS
LSExtensionToMsLicenseServerInfo(
    PBYTE   pbData,
    DWORD   cbData,
    LPTSTR* szIssuer,
    LPTSTR* szIssuerId,
    LPTSTR* szScope
    )
/*++
++*/
{
    UNALIGNED MS_LICENSE_SERVER_INFO *pLServerInfo =
        (MS_LICENSE_SERVER_INFO*)pbData;

    if(pLServerInfo->dwVersion == MS_LICENSE_SERVER_INFO_VERSION1)
    {
        DWORD cchIssuer, cchScope;
        MS_LICENSE_SERVER_INFO10 UNALIGNED * pLServerInfo1 =
            (MS_LICENSE_SERVER_INFO10 UNALIGNED *)pbData;

        *szIssuerId = NULL;

        cchIssuer = STRLEN3264((LPTSTR)(&(pLServerInfo1->bVariableDataStart[0]) +
            pLServerInfo1->wIssuerOffset));
        cchScope = STRLEN3264((LPTSTR)(&(pLServerInfo1->bVariableDataStart[0]) +
            pLServerInfo1->wScopeOffset));

        *szIssuer = (LPTSTR)AllocMemory((cchIssuer + 1) * sizeof(TCHAR));
        *szScope = (LPTSTR)AllocMemory((cchScope + 1) * sizeof(TCHAR));

        if ((*szIssuer == NULL) || (*szScope == NULL))
        {
            // FreeMemory checks for NULL before freeing

            FreeMemory(*szIssuer);
            *szIssuer = NULL;

            FreeMemory(*szScope);
            *szScope = NULL;
            return(LICENSE_STATUS_OUT_OF_MEMORY);
        }

        memcpy(
            (PBYTE)(*szIssuer),
            (PBYTE)(&(pLServerInfo1->bVariableDataStart[0]) +
                pLServerInfo1->wIssuerOffset),
            (cchIssuer + 1) * sizeof(TCHAR)
            );

        memcpy(
            (PBYTE)(*szScope),
            (PBYTE)(&(pLServerInfo1->bVariableDataStart[0]) +
                pLServerInfo1->wScopeOffset),
            (cchScope + 1) * sizeof(TCHAR)
            );
    }
    else
    {
        DWORD cchIssuer, cchIssuerId, cchScope;

        cchIssuer = STRLEN3264((LPTSTR)(&(pLServerInfo->bVariableDataStart[0]) +
            pLServerInfo->wIssuerOffset));
        cchIssuerId = STRLEN3264((LPTSTR)(&(pLServerInfo->bVariableDataStart[0]) +
            pLServerInfo->wIssuerIdOffset));
        cchScope = STRLEN3264((LPTSTR)(&(pLServerInfo->bVariableDataStart[0]) +
            pLServerInfo->wScopeOffset));

        *szIssuer = (LPTSTR)AllocMemory((cchIssuer + 1) * sizeof(TCHAR));
        *szIssuerId = (LPTSTR)AllocMemory((cchIssuerId + 1) * sizeof(TCHAR));
        *szScope = (LPTSTR)AllocMemory((cchScope + 1) * sizeof(TCHAR));

        if ((*szIssuer == NULL) || (*szIssuerId == NULL) || (*szScope == NULL))
        {
            // FreeMemory checks for NULL before freeing

            FreeMemory(*szIssuer);
            *szIssuer = NULL;

            FreeMemory(*szIssuerId);
            *szIssuerId = NULL;

            FreeMemory(*szScope);
            *szScope = NULL;
            return(LICENSE_STATUS_OUT_OF_MEMORY);
        }

        memcpy(
            (PBYTE)(*szIssuer),
            (PBYTE)(&(pLServerInfo->bVariableDataStart[0]) +
                pLServerInfo->wIssuerOffset),
            (cchIssuer + 1) * sizeof(TCHAR)
            );

        memcpy(
            (PBYTE)(*szIssuerId),
            (PBYTE)(&(pLServerInfo->bVariableDataStart[0]) +
                pLServerInfo->wIssuerIdOffset),
            (cchIssuerId + 1) * sizeof(TCHAR)
            );

        memcpy(
            (PBYTE)(*szScope),
            (PBYTE)(&(pLServerInfo->bVariableDataStart[0]) +
                pLServerInfo->wScopeOffset),
            (cchScope + 1) * sizeof(TCHAR)
            );
    }

    return LICENSE_STATUS_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certutil\decode.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        decode.c
//
// Contents:    Routine related to decoding client certificate
//
// History:     03-18-98    HueiWang    Created
//
// Note:
//---------------------------------------------------------------------------
#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <shellapi.h>
#include <stddef.h>
#include <winnls.h>
#include "base64.h"
#include "license.h"
#include "cryptkey.h"
#include "certutil.h"

extern HCRYPTPROV  g_hCertUtilCryptProv;

//
// Internal to this file only
//
typedef struct CertNameInfoEnumStruct10 {
    PBYTE   pbSecretKey;
    DWORD   cbSecretKey;
    HWID    hWid;
} CertNameInfoEnumStruct10, *PCertNameInfoEnumStruct10;


typedef struct CertNameInfoEnumStruct20 {
    PBYTE   pbSecretKey;
    DWORD   cbSecretKey;

    PLICENSEDPRODUCT pLicensedProduct;
} CertNameInfoEnumStruct20, *PCertNameInfoEnumStruct20;

///////////////////////////////////////////////////////////////////////////////

int __cdecl
SortLicensedProduct(
    const void* elem1,
    const void* elem2
    )
/*++

Abstract:

    Sort licensed product array in decending order

++*/
{
    PLICENSEDPRODUCT p1=(PLICENSEDPRODUCT) elem1;
    PLICENSEDPRODUCT p2=(PLICENSEDPRODUCT) elem2;

    if(p1->pLicensedVersion->wMajorVersion != p2->pLicensedVersion->wMinorVersion)
    {
        return p2->pLicensedVersion->wMajorVersion - p1->pLicensedVersion->wMinorVersion;
    }

    return p2->pLicensedVersion->wMinorVersion - p1->pLicensedVersion->wMinorVersion;
}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
LicenseGetSecretKey(
    PDWORD  pcbSecretKey,
    BYTE FAR *   pSecretKey )
{
    static BYTE bSecretKey[] = { 0xCF, 0x08, 0x75, 0x4E, 0x5F, 0xDC, 0x2A, 0x57, 
                                0x43, 0xEE, 0xE5, 0xA9, 0x8E, 0xD4, 0xF0, 0xD0 };

    if( sizeof( bSecretKey ) > *pcbSecretKey )
    {
        *pcbSecretKey = sizeof( bSecretKey );
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    memcpy( pSecretKey, bSecretKey, sizeof( bSecretKey ) );
    *pcbSecretKey = sizeof( bSecretKey );

    return( LICENSE_STATUS_OK );
}

/***************************************************************************************

    LSFreeLicensedProduct(PLICENSEDPRODUCT pLicensedProduct)

***************************************************************************************/
void 
LSFreeLicensedProduct(
    PLICENSEDPRODUCT pLicensedProduct
    )
/*++

++*/
{
    if(pLicensedProduct)
    {
        if(pLicensedProduct->pbOrgProductID)
        {
            FreeMemory(pLicensedProduct->pbOrgProductID);
            pLicensedProduct->pbOrgProductID = NULL;
        }

        if(pLicensedProduct->pbPolicyData)
        {
            FreeMemory(pLicensedProduct->pbPolicyData);
            pLicensedProduct->pbPolicyData = NULL;
        }

        if(pLicensedProduct->pLicensedVersion)
        {
            FreeMemory(pLicensedProduct->pLicensedVersion);
            pLicensedProduct->pLicensedVersion = NULL;
        }
    
        FreeMemory(pLicensedProduct->szLicensedClient);
        pLicensedProduct->szLicensedClient = NULL;

        FreeMemory(pLicensedProduct->szLicensedUser);
        pLicensedProduct->szLicensedUser = NULL;

        if(pLicensedProduct->LicensedProduct.pProductInfo)
        {
            FreeMemory(pLicensedProduct->LicensedProduct.pProductInfo->pbCompanyName);
            pLicensedProduct->LicensedProduct.pProductInfo->pbCompanyName = NULL;

            FreeMemory(pLicensedProduct->LicensedProduct.pProductInfo->pbProductID);
            pLicensedProduct->LicensedProduct.pProductInfo->pbProductID = NULL;

            FreeMemory(pLicensedProduct->LicensedProduct.pProductInfo);
            pLicensedProduct->LicensedProduct.pProductInfo = NULL;
        }

        FreeMemory(pLicensedProduct->szIssuer);
        pLicensedProduct->szIssuer = NULL;

        FreeMemory(pLicensedProduct->szIssuerId);
        pLicensedProduct->szIssuerId = NULL;

        FreeMemory(pLicensedProduct->szIssuerScope);
        pLicensedProduct->szIssuerScope = NULL;

        if(pLicensedProduct->LicensedProduct.pbEncryptedHwid)
        {
            FreeMemory(pLicensedProduct->LicensedProduct.pbEncryptedHwid);
            pLicensedProduct->LicensedProduct.pbEncryptedHwid = NULL;
        }

        if(pLicensedProduct->szIssuerDnsName)
        {
            FreeMemory(pLicensedProduct->szIssuerDnsName);
            pLicensedProduct->szIssuerDnsName = NULL;
        }

        //if(pLicensedProduct->pbEncodedHWID)
        //    FreeMemory(pLicensedProduct->pbEncodedHWID);
    } 
}

/***************************************************************************************

BOOL WINAPI CryptDecodeObject(  DWORD dwEncodingType,  // in
                                LPCSTR lpszStructType, // in  
                                const BYTE * pbEncoded,  // in
                                DWORD cbEncoded,       // in  
                                DWORD dwFlags,         // in
                                void * pvStructInfo,   // out  
                                DWORD * pcbStructInfo  // in/out); 

***************************************************************************************/
DWORD 
LSCryptDecodeObject(  
    IN DWORD dwEncodingType,
    IN LPCSTR lpszStructType,
    IN const BYTE * pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags,
    OUT void ** pvStructInfo,   
    IN OUT DWORD * pcbStructInfo
    )
/*++

++*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    if(!CryptDecodeObject(dwEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, NULL, pcbStructInfo) ||
       (*pvStructInfo=(PBYTE)AllocMemory(*pcbStructInfo)) == NULL ||
       !CryptDecodeObject(dwEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, *pvStructInfo, pcbStructInfo))
    {
        dwStatus=GetLastError();
    }

    return dwStatus;
}

/***************************************************************************************
Function:

    LSDecodeClientHWID(IN PBYTE pbData, 
                       IN DWORD cbData, 
                       IN PBYTE* pbSecretKey, 
                       IN DWORD cbSecretKey,       
                       IN OUT HWID* pHwid)

Abstract:

Parameters:

Returns:    

***************************************************************************************/
LICENSE_STATUS
LSDecodeClientHWID(
    PBYTE pbData, 
    DWORD cbData, 
    PBYTE pbSecretKey, 
    DWORD cbSecretKey, 
    HWID* pHwid
    )
/*++
++*/
{
    CHAR pbDecodedHwid[1024];
    DWORD cbDecodedHwid=sizeof(pbDecodedHwid);

    //
    // Client Encrypted HWID can't be more than 1K
    //
    if(cbData >= cbDecodedHwid)
    {
        return LICENSE_STATUS_INVALID_INPUT;
    }
        
    SetLastError(LICENSE_STATUS_OK);
    memset(pbDecodedHwid, 0, sizeof(pbDecodedHwid));

    __try {
        if(LSBase64Decode(CAST_PBYTE pbData, cbData, (UCHAR *)pbDecodedHwid, &cbDecodedHwid) != LICENSE_STATUS_OK ||
           LicenseDecryptHwid(pHwid, cbDecodedHwid, (UCHAR *)pbDecodedHwid, cbSecretKey, pbSecretKey) != 0)
        {
            SetLastError(LICENSE_STATUS_CANNOT_VERIFY_HWID);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(LICENSE_STATUS_UNSPECIFIED_ERROR);
    }

    return GetLastError();
}


LICENSE_STATUS
LSEncryptClientHWID(
    HWID* pHwid, 
    PBYTE pbData, 
    PDWORD cbData, 
    PBYTE pbSecretKey, 
    DWORD cbSecretKey
    )
/*++
++*/
{
    BYTE tmp_pbEncryptedHwid[sizeof(HWID)*2+2];
    DWORD tmp_cbEncryptedHwid=sizeof(tmp_pbEncryptedHwid);
    PBYTE pbKey=NULL;
    DWORD cbKey=0;
    DWORD status;

    if(pbSecretKey)
    {
        pbKey = pbSecretKey;
        cbKey = cbSecretKey;
    }
    else
    {
        LicenseGetSecretKey( &cbKey, NULL );
        if((pbKey = (PBYTE)AllocMemory(cbKey)) == NULL)
        {
            return LICENSE_STATUS_OUT_OF_MEMORY;
        }

        status=LicenseGetSecretKey( &cbKey, pbKey );
        if(status != LICENSE_STATUS_OK)
        {
            return status;
        }
    }

    memset(tmp_pbEncryptedHwid, 0, sizeof(tmp_pbEncryptedHwid));
    if((status=LicenseEncryptHwid(pHwid,
                                  &tmp_cbEncryptedHwid, 
                                  tmp_pbEncryptedHwid, 
                                  cbKey,
                                  pbKey) != LICENSE_STATUS_OK))
    {
        return status;
    }

    if(pbData && *cbData)
    {
        memcpy(pbData, tmp_pbEncryptedHwid, tmp_cbEncryptedHwid);
    }

    *cbData = tmp_cbEncryptedHwid;
    if(pbKey != pbSecretKey)
        FreeMemory(pbKey);

    return LICENSE_STATUS_OK;
}

/*************************************************************************************

    EnumDecodeHWID()

**************************************************************************************/
BOOL 
ConvertUnicodeOIDToAnsi(
    LPSTR szUnicodeOID, 
    LPSTR szAnsiOID, 
    DWORD cbAnsiOid
    )
/*++
++*/
{
    memset(szAnsiOID, 0, cbAnsiOid);
    if(HIWORD(szUnicodeOID) == 0)
    {
        return WideCharToMultiByte(GetACP(), 
                                  0, 
                                  (WCHAR *)szUnicodeOID, 
                                  -1, 
                                  szAnsiOID, 
                                  cbAnsiOid, 
                                  NULL, 
                                  NULL) == 0;
    }

    strncpy(
            szAnsiOID, 
            szUnicodeOID, 
            min(cbAnsiOid, strlen(szUnicodeOID))
        );
    return TRUE;
}

/*************************************************************************************

    EnumDecodeHWID()

*************************************************************************************/
BOOL 
EnumDecodeHWID(
    IN PCERT_RDN_ATTR pCertRdnAttr, 
    IN HANDLE dwParm
    )
/*++
++*/
{
    PCertNameInfoEnumStruct20 pEnumParm = (PCertNameInfoEnumStruct20)dwParm;
    BOOL bszOIDHwid=TRUE;
    DWORD status=LICENSE_STATUS_OK;
    int cmpResult;
    CHAR ansiOID[4096]; // hardcoded for now.

    if(!ConvertUnicodeOIDToAnsi(pCertRdnAttr->pszObjId, ansiOID, sizeof(ansiOID)/sizeof(ansiOID[0])))
        return FALSE;

    bszOIDHwid = (strcmp(ansiOID, szOID_COMMON_NAME) == 0);

    if(bszOIDHwid)
    {
        pEnumParm->pLicensedProduct->LicensedProduct.pbEncryptedHwid = (PBYTE)AllocMemory(pCertRdnAttr->Value.cbData);
        if(!pEnumParm->pLicensedProduct->LicensedProduct.pbEncryptedHwid)
        {
            status = LICENSE_STATUS_OUT_OF_MEMORY;
        }
        else
        {
            memcpy(pEnumParm->pLicensedProduct->LicensedProduct.pbEncryptedHwid,
                   pCertRdnAttr->Value.pbData,
                   pCertRdnAttr->Value.cbData);
    
            pEnumParm->pLicensedProduct->LicensedProduct.cbEncryptedHwid=pCertRdnAttr->Value.cbData;
        }

        if(pEnumParm->pbSecretKey)
        {
            status = LSDecodeClientHWID(pCertRdnAttr->Value.pbData, 
                                        pCertRdnAttr->Value.cbData/sizeof(TCHAR),
                                        pEnumParm->pbSecretKey,
                                        pEnumParm->cbSecretKey,
                                        &pEnumParm->pLicensedProduct->Hwid);
        }
    }

    // continue if this is not our subject field.
    return (status != LICENSE_STATUS_OK || !bszOIDHwid);
}
/*************************************************************************************

    EnumIssuerLicense20()

**************************************************************************************/
BOOL
EnumIssuerLicense20(
    IN PCERT_RDN_ATTR pCertRdnAttr, 
    IN HANDLE dwParm
    )
/*++
++*/
{
    PCertNameInfoEnumStruct20 pEnumParm=(PCertNameInfoEnumStruct20)dwParm;
    CHAR ansiOID[4096];
    DWORD status=LICENSE_STATUS_OK;

    if(!ConvertUnicodeOIDToAnsi(pCertRdnAttr->pszObjId, ansiOID, sizeof(ansiOID)/sizeof(ansiOID[0])))
    {
        status=GetLastError();
    }
    else
    {
        if(strcmp(ansiOID, OID_ISSUER_LICENSE_SERVER_NAME) == 0)
        {
            pEnumParm->pLicensedProduct->szIssuer = (LPTSTR)AllocMemory( pCertRdnAttr->Value.cbData + sizeof(TCHAR) );
            if(!pEnumParm->pLicensedProduct->szIssuer)
            {
                status = LICENSE_STATUS_OUT_OF_MEMORY;
            }
            else
            {
                memcpy(
                    pEnumParm->pLicensedProduct->szIssuer, 
                    pCertRdnAttr->Value.pbData,
                    pCertRdnAttr->Value.cbData
                );
            }
        }
        else if(strcmp(ansiOID, OID_ISSUER_LICENSE_SERVER_SCOPE) == 0)
        {
            pEnumParm->pLicensedProduct->szIssuerScope = (LPTSTR)AllocMemory( pCertRdnAttr->Value.cbData + sizeof(TCHAR) );
            if(!pEnumParm->pLicensedProduct->szIssuerScope)
            {
                status = LICENSE_STATUS_OUT_OF_MEMORY;
            }
            else
            {
                memcpy(
                        pEnumParm->pLicensedProduct->szIssuerScope, 
                        pCertRdnAttr->Value.pbData,
                        pCertRdnAttr->Value.cbData
                    );
            }
        }
    }

    return status != LICENSE_STATUS_OK;
}
/*************************************************************************************

    EnumSubjectLicense20()

**************************************************************************************/
BOOL
EnumSubjectLicense20(
    IN PCERT_RDN_ATTR pCertRdnAttr, 
    IN HANDLE dwParm
    )
/*++
++*/
{
    PCertNameInfoEnumStruct20 pEnumParm=(PCertNameInfoEnumStruct20)dwParm;
    CHAR ansiOID[4096];
    DWORD status=LICENSE_STATUS_OK;

    if(!ConvertUnicodeOIDToAnsi(pCertRdnAttr->pszObjId, ansiOID, sizeof(ansiOID)/sizeof(ansiOID[0])))
    {
       status=GetLastError();
    }
    else
    {
        DWORD cbData=pCertRdnAttr->Value.cbData;
        PBYTE pbData=pCertRdnAttr->Value.pbData;

        if(strcmp(ansiOID, OID_SUBJECT_CLIENT_COMPUTERNAME) == 0)
        {
            pEnumParm->pLicensedProduct->szLicensedClient=(LPTSTR)AllocMemory(cbData + sizeof(TCHAR));
            if(!pEnumParm->pLicensedProduct->szLicensedClient)
            {
                status = LICENSE_STATUS_OUT_OF_MEMORY;
            }
            else
            {
                memcpy(
                        pEnumParm->pLicensedProduct->szLicensedClient, 
                        pbData,
                        cbData
                    );
            }
        }
        else if(strcmp(ansiOID, OID_SUBJECT_CLIENT_USERNAME) == 0)
        {
            pEnumParm->pLicensedProduct->szLicensedUser=(LPTSTR)AllocMemory(cbData + sizeof(TCHAR));
            if(!pEnumParm->pLicensedProduct->szLicensedUser)
            {
                status = LICENSE_STATUS_OUT_OF_MEMORY;
            }
            else
            {
                memcpy(
                        pEnumParm->pLicensedProduct->szLicensedUser, 
                        pbData,
                        cbData
                    );
            }
        }
        else if(strcmp(ansiOID, OID_SUBJECT_CLIENT_HWID) == 0)
        {
            pEnumParm->pLicensedProduct->LicensedProduct.cbEncryptedHwid = 0;
            LSBase64Decode(
                    CAST_PBYTE pCertRdnAttr->Value.pbData, 
                    pCertRdnAttr->Value.cbData / sizeof(TCHAR), 
                    NULL, 
                    &(pEnumParm->pLicensedProduct->LicensedProduct.cbEncryptedHwid)
                );

            pEnumParm->pLicensedProduct->LicensedProduct.pbEncryptedHwid = (PBYTE)AllocMemory(
                                                                                    pEnumParm->pLicensedProduct->LicensedProduct.cbEncryptedHwid
                                                                                );
            if(!pEnumParm->pLicensedProduct->LicensedProduct.pbEncryptedHwid)
            {
                status = LICENSE_STATUS_OUT_OF_MEMORY;
                return status;
            }

            status = LSBase64Decode(
                            CAST_PBYTE pCertRdnAttr->Value.pbData, 
                            pCertRdnAttr->Value.cbData / sizeof(TCHAR), 
                            pEnumParm->pLicensedProduct->LicensedProduct.pbEncryptedHwid, 
                            &(pEnumParm->pLicensedProduct->LicensedProduct.cbEncryptedHwid)
                        );

            if(status != LICENSE_STATUS_OK)
            {
                return status;
            }

            if(pEnumParm->pbSecretKey)
            {
                status = LSDecodeClientHWID(
                                    pCertRdnAttr->Value.pbData, 
                                    pCertRdnAttr->Value.cbData / sizeof(TCHAR),
                                    pEnumParm->pbSecretKey,
                                    pEnumParm->cbSecretKey,
                                    &pEnumParm->pLicensedProduct->Hwid
                                );
            }
        }
    }

    return status != LICENSE_STATUS_OK;
}
/***************************************************************************************
Function:
    LSEnumerateCertNameInfo()

Description:
    Routine to enumerate all CERT_RDN_VALUE values in CERT_NAME_BLOB and pass it
    to callback function specified in parameter

Arguments:
    IN cbData - Count of bytes in the buffer pointed by pbData
    IN pbData - Pointer to a block of data
    IN EnumerateCertNameInfoCallBack - Enumeration call back routine, it is defined as

        typedef BOOL (*EnumerateCertNameInfoCallBack)(PCERT_RDN_ATTR pCertRdnAttr, 
                                                      DWORD dwUserData);
    IN dwUserData - See EnumerateCertNameInfoCallBack

Return:
    LICENSE_STATUS_OK
    WIN32 error codes           from CryptDecodeObject()
    HLS_E_INTERNAL
    Any error set by callback.
***************************************************************************************/
DWORD
LSEnumerateCertNameInfo(
    IN LPBYTE pbData, 
    IN DWORD cbData,
    IN EnumerateCertNameInfoCallBack func, 
    IN HANDLE dwUserData
    )
/*++

++*/
{
    BOOL bCryptSuccess=TRUE;
    BOOL bCallbackCancel=FALSE;
    DWORD status = LICENSE_STATUS_OK;
    CERT_NAME_INFO CertNameBlob;

    SetLastError(LICENSE_STATUS_OK);

    __try {
        memset(&CertNameBlob, 0, sizeof(CertNameBlob));
        do {
            bCryptSuccess=CryptDecodeObject( 
                                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                    X509_NAME,
                                    pbData,
                                    cbData,
                                    0,
                                    NULL, 
                                    &CertNameBlob.cRDN
                                );
            if(!bCryptSuccess)
            {
                status = LICENSE_STATUS_CANNOT_DECODE_LICENSE;
                break;
            }
                      
            CertNameBlob.rgRDN=(PCERT_RDN)AllocMemory(CertNameBlob.cRDN);
            if(!CertNameBlob.rgRDN)
            {
                SetLastError(status=LICENSE_STATUS_OUT_OF_MEMORY);
                break;
            }

            bCryptSuccess=CryptDecodeObject( 
                                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                    X509_NAME,
                                    pbData,
                                    cbData,
                                    CRYPT_DECODE_NOCOPY_FLAG,
                                    (LPBYTE)CertNameBlob.rgRDN, 
                                    &CertNameBlob.cRDN
                                );

            if(!bCryptSuccess)
            {
                status = LICENSE_STATUS_CANNOT_DECODE_LICENSE;
                break;
            }

            PCERT_RDN pCertRdn=CertNameBlob.rgRDN;
            int num_rdn=pCertRdn->cRDNAttr;
            pCertRdn++;

            for(int i=0; i < num_rdn && !bCallbackCancel; i++, pCertRdn++)
            {
                int num_attr=pCertRdn->cRDNAttr;
                PCERT_RDN_ATTR pCertRdnAttr=pCertRdn->rgRDNAttr;
                
                for(int j=0; j < num_attr && !bCallbackCancel; j++, pCertRdnAttr++)
                {
                    bCallbackCancel=(func)(pCertRdnAttr, dwUserData);
                }
            }
        } while(FALSE);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(LICENSE_STATUS_UNSPECIFIED_ERROR);
    }

    FreeMemory(CertNameBlob.rgRDN);
    return GetLastError();
}

/*****************************************************************************

    DecodeLicense20()

*****************************************************************************/
DWORD
DecodeGetIssuerDnsName(
    PBYTE pbData, 
    DWORD cbData, 
    LPTSTR* pszIssuerDnsName
    )
/*++
++*/
{
    DWORD dwStatus=LICENSE_STATUS_OK;
    PLSCERT_AUTHORITY_INFO_ACCESS pbAccessInfo=NULL;
    DWORD cbAccessInfo=0;

    *pszIssuerDnsName=NULL;
    dwStatus=LSCryptDecodeObject(  
                            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                            szOID_X509_AUTHORITY_ACCESS_INFO,
                            pbData,
                            cbData,
                            CRYPT_DECODE_NOCOPY_FLAG, 
                            (PVOID *)&pbAccessInfo,
                            &cbAccessInfo
                        );

    if(dwStatus != ERROR_SUCCESS)
        return dwStatus;

    for(DWORD i=0; i < pbAccessInfo->cAccDescr; i++)
    {
        // we only use these for our license
        if(strcmp(pbAccessInfo[i].rgAccDescr->pszAccessMethod, szOID_X509_ACCESS_PKIX_OCSP) == 0)
        {
            // our extension has only dns name entry...
            if(pbAccessInfo[i].rgAccDescr->AccessLocation.dwAltNameChoice == LSCERT_ALT_NAME_DNS_NAME)
            {
                *pszIssuerDnsName = (LPTSTR)AllocMemory(
                                                    (wcslen(pbAccessInfo[i].rgAccDescr->AccessLocation.pwszDNSName)+1) * sizeof(TCHAR)
                                                );
                if(*pszIssuerDnsName == NULL)
                {
                    dwStatus = LICENSE_STATUS_OUT_OF_MEMORY;
                }
                else
                {
                    wcscpy(*pszIssuerDnsName, pbAccessInfo[i].rgAccDescr->AccessLocation.pwszDNSName);
                }

                break;
            }
            else if(pbAccessInfo[i].rgAccDescr->AccessLocation.dwAltNameChoice == CERT_ALT_NAME_DIRECTORY_NAME)
            {
                *pszIssuerDnsName = (LPTSTR)AllocMemory(
                                                    pbAccessInfo[i].rgAccDescr->AccessLocation.DirectoryName.cbData + sizeof(TCHAR)
                                                );
                if(*pszIssuerDnsName == NULL)
                {
                    dwStatus = LICENSE_STATUS_OUT_OF_MEMORY;
                }
                else
                {
                    memcpy(
                            *pszIssuerDnsName, 
                            pbAccessInfo[i].rgAccDescr->AccessLocation.DirectoryName.pbData,
                            pbAccessInfo[i].rgAccDescr->AccessLocation.DirectoryName.cbData
                        );
                }
                break;
            }
        }
    }

    // always return success.
    FreeMemory(pbAccessInfo);
    return dwStatus;
}


/*****************************************************************************

    DecodeLicense20()

*****************************************************************************/
DWORD
GetClientLicenseVersion( 
    PCERT_EXTENSION pCertExtension, 
    DWORD dwNumExtension 
    )
/*++
++*/
{
    DWORD dwVersion = TERMSERV_CERT_VERSION_UNKNOWN;

    for(DWORD i=0; i < dwNumExtension; i++, pCertExtension++)
    {
        if(strcmp(pCertExtension->pszObjId, szOID_PKIX_HYDRA_CERT_VERSION) == 0)
        {
            if(pCertExtension->Value.cbData == sizeof(DWORD) && 
               *(DWORD UNALIGNED *)pCertExtension->Value.pbData <= TERMSERV_CERT_VERSION_CURRENT)
            {
                //
                // we don't support version 0x00020001, it never release
                //
                dwVersion = *(DWORD UNALIGNED *)pCertExtension->Value.pbData;
                break;
            }
        }
    }

    return dwVersion;
}

/*****************************************************************************

    DecodeLicense20()

*****************************************************************************/
LICENSE_STATUS
DecodeLicense20(
    IN PCERT_INFO     pCertInfo,                       
    IN PBYTE          pbSecretKey,
    IN DWORD          cbSecretKey,
    IN OUT PLICENSEDPRODUCT pLicensedInfo
    )
/*++

++*/
{
    LICENSE_STATUS dwStatus=LICENSE_STATUS_OK;
    PBYTE   pbCompanyName=NULL;
    DWORD   cbCompanyName=0;

    DWORD   dwCertVersion=0;

    LICENSED_PRODUCT_INFO* pLicensedProductInfo=NULL;
    DWORD   cbLicensedProductInfo=0;

    PBYTE   pbPolicyData=NULL;
    DWORD   cbPolicyData = 0;

    CertNameInfoEnumStruct20  enumStruct;
    ULARGE_INTEGER* pulSerialNumber;
    DWORD i;

    PCERT_EXTENSION pCertExtension=pCertInfo->rgExtension;


    dwCertVersion = GetClientLicenseVersion(
                                        pCertExtension, 
                                        pCertInfo->cExtension
                                    );

    if(dwCertVersion == TERMSERV_CERT_VERSION_UNKNOWN)
    {
        dwStatus = LICENSE_STATUS_INVALID_LICENSE;
        goto cleanup;
    }

    if(dwCertVersion == 0x00020001)
    {   
        dwStatus = LICENSE_STATUS_UNSUPPORTED_VERSION;
        goto cleanup;
    }

    for(i=0; i < pCertInfo->cExtension && dwStatus == LICENSE_STATUS_OK; i++, pCertExtension++)
    {
        if(strcmp(pCertExtension->pszObjId, szOID_PKIS_PRODUCT_SPECIFIC_OID) == 0)  
        {
            //
            // product specific extension 
            //
            pbPolicyData = pCertExtension->Value.pbData;
            cbPolicyData = pCertExtension->Value.cbData;
        }                
        else if(strcmp(pCertExtension->pszObjId, szOID_PKIX_MANUFACTURER) == 0)
        {
            //
            // manufacturer of product
            //
            pbCompanyName = pCertExtension->Value.pbData;
            cbCompanyName = pCertExtension->Value.cbData;
        }
        else if(strcmp(pCertExtension->pszObjId, szOID_PKIX_LICENSED_PRODUCT_INFO) == 0)
        {
            //
            // Licensed product info
            //
            pLicensedProductInfo = (LICENSED_PRODUCT_INFO*) pCertExtension->Value.pbData;
            cbLicensedProductInfo = pCertExtension->Value.cbData;
        }
        else if(strcmp(pCertExtension->pszObjId, szOID_X509_AUTHORITY_ACCESS_INFO) == 0)
        {
            //
            // License Server access info,
            //
            dwStatus = DecodeGetIssuerDnsName(
                                    pCertExtension->Value.pbData,
                                    pCertExtension->Value.cbData,
                                    &pLicensedInfo->szIssuerDnsName
                                );

        }
        else if(strcmp(pCertExtension->pszObjId, szOID_PKIX_MS_LICENSE_SERVER_INFO) == 0)
        {
            //
            // HYDRA_CERT_VERSION_CURRENT use extension to store license server name
            //
            // extract license server info from this extension
            //

            dwStatus = LSExtensionToMsLicenseServerInfo(
                                pCertExtension->Value.pbData,
                                pCertExtension->Value.cbData,
                                &pLicensedInfo->szIssuer,
                                &pLicensedInfo->szIssuerId,
                                &pLicensedInfo->szIssuerScope
                            );
        }
    }

    if(dwStatus != LICENSE_STATUS_OK)
    {
        //
        // invalid license
        //
        goto cleanup;
    }

    if(pCertInfo->SerialNumber.cbData > sizeof(ULARGE_INTEGER))
    {
        //
        // Our serial number if 64 bits
        //
        dwStatus = LICENSE_STATUS_NOT_HYDRA;
        goto cleanup;
    }

    if(pbCompanyName == NULL || pLicensedProductInfo == NULL)
    {
        //
        // not hydra certificate
        //
        dwStatus = LICENSE_STATUS_NOT_HYDRA;
        goto cleanup;
    }

    //
    // Serial Number - Decoded as a multiple byte integer. 
    // SerialNumber.pbData[0] is the least significant byte. 
    // SerialNumber.pbData[SerialNumber.cbData - 1] is the most significant byte.)
    //
    pulSerialNumber = &(pLicensedInfo->ulSerialNumber);
    memset(pulSerialNumber, 0, sizeof(ULARGE_INTEGER));
    for(i=0; i < pCertInfo->SerialNumber.cbData; i++)
    {
        ((PBYTE)pulSerialNumber)[i] = pCertInfo->SerialNumber.pbData[i];
    }

    //
    // Extract validity of certificate
    //
    pLicensedInfo->NotBefore = pCertInfo->NotBefore;
    pLicensedInfo->NotAfter = pCertInfo->NotAfter;


    //
    // Extract info from certificate.
    //
    enumStruct.pLicensedProduct=pLicensedInfo;

    enumStruct.pbSecretKey = pbSecretKey;
    enumStruct.cbSecretKey = cbSecretKey;

    pLicensedInfo->dwLicenseVersion = dwCertVersion;
    pLicensedInfo->LicensedProduct.pProductInfo=(PProduct_Info)AllocMemory(sizeof(Product_Info));
    if(pLicensedInfo->LicensedProduct.pProductInfo == NULL)
    {
        dwStatus = LICENSE_STATUS_OUT_OF_MEMORY;
        goto cleanup;
    }

    if(pbPolicyData != NULL)
    {
        //
        //  Policy Module specific data
        //
        pLicensedInfo->pbPolicyData = (PBYTE)AllocMemory(cbPolicyData);
        if(pLicensedInfo->pbPolicyData == NULL)
        {
            dwStatus = LICENSE_STATUS_OUT_OF_MEMORY;
            goto cleanup;
        }

        memcpy(pLicensedInfo->pbPolicyData, pbPolicyData, cbPolicyData);
        pLicensedInfo->cbPolicyData = cbPolicyData;
    }

    if(dwCertVersion == TERMSERV_CERT_VERSION_RC1)
    {
        //
        // HYDRA 4.0 RC1 - license server is stored in certificate's Issuer field
        //
        dwStatus=LSEnumerateCertNameInfo(
                                pCertInfo->Issuer.pbData, 
                                pCertInfo->Issuer.cbData,
                                EnumIssuerLicense20,
                                &enumStruct
                            );
        if(dwStatus != LICENSE_STATUS_OK)
        {
            goto cleanup;
        }
    }

    dwStatus=LSEnumerateCertNameInfo(
                            pCertInfo->Subject.pbData, 
                            pCertInfo->Subject.cbData,
                            EnumSubjectLicense20,
                            &enumStruct
                        );

    if(dwStatus != LICENSE_STATUS_OK)
    {
        goto cleanup;
    }

    pLicensedInfo->LicensedProduct.pProductInfo->cbCompanyName = cbCompanyName;
    pLicensedInfo->LicensedProduct.pProductInfo->pbCompanyName = (PBYTE)AllocMemory(cbCompanyName+sizeof(TCHAR));
    if(!pLicensedInfo->LicensedProduct.pProductInfo->pbCompanyName)
    {
        dwStatus = LICENSE_STATUS_OUT_OF_MEMORY;
        goto cleanup;
    }

    memcpy(
            pLicensedInfo->LicensedProduct.pProductInfo->pbCompanyName, 
            pbCompanyName, 
            cbCompanyName
        );

    dwStatus=LSExtensionToMsLicensedProductInfo(
                                (PBYTE)pLicensedProductInfo,
                                cbLicensedProductInfo,
                                &pLicensedInfo->dwQuantity,
                                &pLicensedInfo->LicensedProduct.dwPlatformID,
                                &pLicensedInfo->LicensedProduct.dwLanguageID, 
                                &pLicensedInfo->pbOrgProductID,
                                &pLicensedInfo->cbOrgProductID,
                                &pLicensedInfo->LicensedProduct.pProductInfo->pbProductID,  
                                &pLicensedInfo->LicensedProduct.pProductInfo->cbProductID,
                                &pLicensedInfo->pLicensedVersion,
                                &pLicensedInfo->dwNumLicensedVersion
                            );
    if(dwStatus != LICENSE_STATUS_OK)
    {
        goto cleanup;
    }

    pLicensedInfo->LicensedProduct.pProductInfo->dwVersion = MAKELONG(
                                                                    pLicensedInfo->pLicensedVersion[0].wMinorVersion, 
                                                                    pLicensedInfo->pLicensedVersion[0].wMajorVersion
                                                                );

    //
    // assign product version to PLICENSEREQUEST
    // backward ??? didn't bail out at 0.
    //
    for(i=1; i < pLicensedInfo->dwNumLicensedVersion; i++)
    {
        if(!(pLicensedInfo->pLicensedVersion[i].dwFlags & LICENSED_VERSION_TEMPORARY))
        {
            pLicensedInfo->LicensedProduct.pProductInfo->dwVersion = MAKELONG(
                                                                            pLicensedInfo->pLicensedVersion[i].wMinorVersion, 
                                                                            pLicensedInfo->pLicensedVersion[i].wMajorVersion
                                                                        );
        }
    }

    if(pLicensedInfo->szIssuerDnsName == NULL && pLicensedInfo->szIssuer)
    {
        pLicensedInfo->szIssuerDnsName = (LPTSTR)AllocMemory((wcslen(pLicensedInfo->szIssuer)+1) * sizeof(TCHAR));
        if(pLicensedInfo->szIssuerDnsName == NULL)
        {
            dwStatus = LICENSE_STATUS_OUT_OF_MEMORY;
        }
        else
        {
            wcscpy(pLicensedInfo->szIssuerDnsName, pLicensedInfo->szIssuer);
        }
    }

cleanup:    

    return dwStatus;
}

//------------------------------------------------------
DWORD
IsW2kLicenseIssuerNonEnforce(
    IN HCRYPTPROV hCryptProv,
    IN PCCERT_CONTEXT pCert, 
    IN HCERTSTORE hCertStore,
    OUT PBOOL pbStatus
    )
/*++

Abstract:

    Verify client license is issued by a non-enforce 
    license server

Parameters:

    hCryptProv - Crypo Provider.
    pCert - Certificate to be verify
    hCertStore - Certificate store that contains issuer's certificate

Returns:

    LICENSE_STATUS_OK or error code.

++*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwFlags;
    DWORD i;
    PCCERT_CONTEXT  pCertIssuer=NULL;

    //
    // There can only be one license server certificate.
    //
    dwFlags = CERT_STORE_SIGNATURE_FLAG;
    pCertIssuer = CertGetIssuerCertificateFromStore(
                                            hCertStore,
                                            pCert,
                                            NULL,
                                            &dwFlags
                                        );
    if(pCertIssuer == NULL)
    {
        dwStatus = LICENSE_STATUS_NO_CERTIFICATE;
        goto cleanup;
    }

    //
    // A CH registered license server has szOID_PKIX_HYDRA_CERT_ROOT extension
    // A telephone registered license server has szOID_PKIS_TLSERVER_SPK_OID extension
    //
    for(i=0; i < pCertIssuer->pCertInfo->cExtension; i++)
    {
        if(strcmp(pCertIssuer->pCertInfo->rgExtension[i].pszObjId, szOID_PKIX_HYDRA_CERT_ROOT) == 0 ||
           strcmp(pCertIssuer->pCertInfo->rgExtension[i].pszObjId, szOID_PKIS_TLSERVER_SPK_OID) == 0 )
        {
            break;
        }
    }

    *pbStatus = (i >= pCertIssuer->pCertInfo->cExtension) ? TRUE : FALSE;

    if(pCertIssuer != NULL)
    {
        CertFreeCertificateContext(pCertIssuer);
    }

cleanup:

    return dwStatus;
}


//------------------------------------------------------
LICENSE_STATUS
LSVerifyTlsCertificate(
    IN HCRYPTPROV hCryptProv,
    IN PCCERT_CONTEXT pCert, 
    IN HCERTSTORE hCertStore
    )
/*++

Abstract:

    Given a certifcate and certificate store, this routine
    verify that certificate chain up to root certificate.

Parameters:

    hCryptProv - Crypo Provider.
    pCert - Certificate to be verify
    hCertStore - Certificate store that contains issuer's certificate

Returns:

++*/
{
    PCCERT_CONTEXT  pCertContext = pCert;
    PCCERT_CONTEXT  pCertIssuer=NULL, pCertIssuerNew;
    DWORD           dwStatus=ERROR_SUCCESS;
    DWORD           dwLastVerification=0;

    pCertContext = CertDuplicateCertificateContext(pCert);
    if(pCertContext == NULL)
    {
        dwStatus = GetLastError();
    }

    while(pCertContext != NULL)
    {
        //
        // Verify against all issuer's certificate
        //
        DWORD dwFlags;
        BOOL  bVerify=FALSE;

        dwStatus=ERROR_SUCCESS;
        dwLastVerification=0;
        pCertIssuer=NULL;

        do {
            dwFlags = CERT_STORE_SIGNATURE_FLAG; // | CERT_STORE_TIME_VALIDITY_FLAG;

            pCertIssuerNew = CertGetIssuerCertificateFromStore(
                                                    hCertStore,
                                                    pCertContext,
                                                    pCertIssuer,
                                                    &dwFlags
                                                );

            if (NULL != pCertIssuer)
            {
                CertFreeCertificateContext(pCertIssuer);
            }

            // pass pCertIssuer back to CertGetIssuerCertificateFromStore() 
            // to prevent infinite loop.
            pCertIssuer = pCertIssuerNew;

            if(pCertIssuer == NULL)
            {
                dwStatus = GetLastError();
                break;
            }
            
            dwLastVerification=dwFlags;
            bVerify = (dwFlags == 0);

        } while(!bVerify);

        // 
        // Check against error return from CertGetIssuerCertificateFromStore()
        //
        if(dwStatus != ERROR_SUCCESS || dwLastVerification)
        {
            if(dwStatus == CRYPT_E_SELF_SIGNED)
            {
                // self-signed certificate
                if( CryptVerifyCertificateSignature(
                                            hCryptProv, 
                                            X509_ASN_ENCODING, 
                                            pCertContext->pbCertEncoded, 
                                            pCertContext->cbCertEncoded,
                                            &pCertContext->pCertInfo->SubjectPublicKeyInfo
                                        ) )
                {
                    dwStatus=ERROR_SUCCESS;
                }
            }
            else if(dwStatus == CRYPT_E_NOT_FOUND)
            {
                // can't find issuer's certificate
                dwStatus = LICENSE_STATUS_CANNOT_FIND_ISSUER_CERT;
            }
            else if(dwLastVerification & CERT_STORE_SIGNATURE_FLAG)
            {
                dwStatus=LICENSE_STATUS_INVALID_LICENSE;
            }
            else if(dwLastVerification & CERT_STORE_TIME_VALIDITY_FLAG)
            {
                dwStatus=LICENSE_STATUS_EXPIRED_LICENSE;
            }
            else
            {
                dwStatus=LICENSE_STATUS_UNSPECIFIED_ERROR;
            }

            break;
        }

        //
        // free cert. context ourself instead of relying on Crypto.
        if(pCertContext != NULL)
        {
            CertFreeCertificateContext(pCertContext);
        }

        pCertContext = pCertIssuer;

    } // while(pCertContext != NULL)

    if(pCertContext != NULL)
    {
        CertFreeCertificateContext(pCertContext);
    }

    return dwStatus;
}


//----------------------------------------------------------

LICENSE_STATUS
LSVerifyDecodeClientLicense(
    IN PBYTE                pbLicense,
    IN DWORD                cbLicense,
    IN PBYTE                pbSecretKey,
    IN DWORD                cbSecretKey,
    IN OUT PDWORD           pdwNumLicensedInfo,
    IN OUT PLICENSEDPRODUCT pLicensedInfo
    )
/*++


    Verify and decode client licenses.

++*/
{
    HCERTSTORE hCertStore=NULL;
    LICENSE_STATUS dwStatus=LICENSE_STATUS_OK;
    CRYPT_DATA_BLOB Serialized;
    PCCERT_CONTEXT pCertContext=NULL;
    PCCERT_CONTEXT pPrevCertContext=NULL;
    PCERT_INFO pCertInfo;
    DWORD dwCertVersion;

    DWORD dwLicensedInfoSize=*pdwNumLicensedInfo;
    *pdwNumLicensedInfo = 0;

    Serialized.pbData = pbLicense;
    Serialized.cbData = cbLicense;

    if(g_hCertUtilCryptProv == NULL)
    {
        SetLastError(dwStatus = ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    hCertStore = CertOpenStore(
                        szLICENSE_BLOB_SAVEAS_TYPE,
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        g_hCertUtilCryptProv,
                        CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                        &Serialized
                    );

    if(!hCertStore)
    {
        dwStatus=GetLastError();
        goto cleanup;
    }

    while( TRUE )
    {
        //
        // Loop thru all certificates in blob
        //
        pCertContext = CertEnumCertificatesInStore(
                                    hCertStore, 
                                    pPrevCertContext
                                );
        if(pCertContext == NULL)
        {
            //
            // end certificate in store or error
            //
            if((dwStatus=GetLastError()) == CRYPT_E_NOT_FOUND)
            {
                SetLastError(dwStatus = ERROR_SUCCESS);
            }

            break;
        }

        //
        // Calculate number of license in this blob
        //
        dwCertVersion = GetClientLicenseVersion(
                                        pCertContext->pCertInfo->rgExtension, 
                                        pCertContext->pCertInfo->cExtension
                                    );

        if(dwCertVersion == 0x00020001)
        {   
            //
            // This is internal test version, never got release 
            //
            dwStatus = LICENSE_STATUS_UNSUPPORTED_VERSION;
            break;
        }
        else if(dwCertVersion != TERMSERV_CERT_VERSION_UNKNOWN)
        {
            //
            // This certificate is issued by license server,
            // verify certificate chain.
            //
            dwStatus = LSVerifyTlsCertificate(
                                        g_hCertUtilCryptProv,
                                        pCertContext,
                                        hCertStore
                                    );

            if(dwStatus != LICENSE_STATUS_OK)
            {
                break;
            }

            if(pLicensedInfo != NULL && *pdwNumLicensedInfo < dwLicensedInfoSize)
            {
                //
                // Decode certificate
                //
                dwStatus=DecodeLicense20(
                                    pCertContext->pCertInfo, 
                                    pbSecretKey,
                                    cbSecretKey,
                                    pLicensedInfo + *pdwNumLicensedInfo
                                );

                if(dwStatus != LICENSE_STATUS_OK)
                {
                    break;
                }
            
                if(dwCertVersion == 0x00050001)
                {
                    DWORD dwFlags = (pLicensedInfo + *pdwNumLicensedInfo)->pLicensedVersion->dwFlags;

                    //
                    // License Server 5.2 or older does not set its enforce/noenforce so we need
                    // to figure out from its own certificate.
                    //
                    if( GET_LICENSE_ISSUER_MAJORVERSION(dwFlags) <= 5 &&
                        GET_LICENSE_ISSUER_MINORVERSION(dwFlags) <= 2 )
                    {
                        if( !(dwFlags & LICENSED_VERSION_TEMPORARY) )
                        {
                            BOOL bNonEnforce = FALSE;

                            dwStatus = IsW2kLicenseIssuerNonEnforce(
                                                        g_hCertUtilCryptProv,
                                                        pCertContext,
                                                        hCertStore,
                                                        &bNonEnforce
                                                    );

                            if(dwStatus != LICENSE_STATUS_OK)
                            {
                                break;
                            }

                            if(bNonEnforce == FALSE)
                            {
                                (pLicensedInfo + *pdwNumLicensedInfo)->pLicensedVersion->dwFlags |= LICENSE_ISSUER_ENFORCE_TYPE;
                            }
                        }
                    }
                }
            }

            (*pdwNumLicensedInfo)++;
        }

        pPrevCertContext = pCertContext;
    }

cleanup:

    if(hCertStore)
    {
        // Force close on all cert.
        if(CertCloseStore(
                        hCertStore, 
                        CERT_CLOSE_STORE_FORCE_FLAG) == FALSE)
        {
            dwStatus = GetLastError();
        }
    }

    if(dwStatus != LICENSE_STATUS_OK)
    {
        //
        // dwNumLicensedInfo is a DWORD.
        //
        int count = (int) *pdwNumLicensedInfo;

        for(;count >= 0 && pLicensedInfo != NULL; count--)
        {
            LSFreeLicensedProduct(pLicensedInfo + count);
        }
    }
    else if(pLicensedInfo != NULL)
    {
        qsort(
            pLicensedInfo,
            *pdwNumLicensedInfo,
            sizeof(LICENSEDPRODUCT),
            SortLicensedProduct
        );
    }                

    if(*pdwNumLicensedInfo == 0 && dwStatus == LICENSE_STATUS_OK)
    {
        dwStatus = LICENSE_STATUS_NO_LICENSE_ERROR;
    }

    //
    // Force re-issue of client licenses.
    //
    return (dwStatus != LICENSE_STATUS_OK) ? LICENSE_STATUS_CANNOT_DECODE_LICENSE : dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certutil\verify.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        verify.c
//
// Contents:    Routine related to certificate verification
//
// History:     03-18-98    HueiWang    Created
//
// Note:
//---------------------------------------------------------------------------

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <wincrypt.h>
#include <shellapi.h>
#include "license.h"
#include "certutil.h"

HCRYPTPROV  g_hCertUtilCryptProv=NULL;
BOOL        g_PrivateCryptProv = TRUE;

void
LSShutdownCertutilLib()
{
    if(g_hCertUtilCryptProv && g_PrivateCryptProv)
    {
        CryptReleaseContext(g_hCertUtilCryptProv, 0);
    }
    g_hCertUtilCryptProv = NULL;
}

BOOL
LSInitCertutilLib( HCRYPTPROV hProv )
{
    if(hProv)
    {
        g_hCertUtilCryptProv = hProv;
        g_PrivateCryptProv = FALSE;
    }
    else if(g_hCertUtilCryptProv == NULL)
    {
        if(!CryptAcquireContext(&g_hCertUtilCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
        {
            if(CryptAcquireContext(
                            &g_hCertUtilCryptProv, 
                            NULL, 
                            NULL, 
                            PROV_RSA_FULL, 
                            CRYPT_NEWKEYSET | CRYPT_MACHINE_KEYSET | CRYPT_VERIFYCONTEXT
                        ) == FALSE)
            {
                return FALSE;
            }
        }

        g_PrivateCryptProv = TRUE;
    }

    return TRUE;
}

/**************************************************************************
Function:

    LSVerifyCertificateChain(IN LPTSTR szFile)

Abstract:

    Verify Licenses in file store

Parameters:

    szFile - Name of file contain license

Returns:
    ERROR_SUCCESS
    LICENSE_STATUS_NO_LICENSE_ERROR
    LICENSE_STATUS_CANNOT_FIND_ISSUER_CERT  Can't find issuer's certificate.
    LICENSE_STATUS_UNSPECIFIED_ERROR        Unknown error.
    LICENSE_STATUS_INVALID_LICENSE          Invalid License
    LICENSE_STATUS_EXPIRED_LICENSE          Expired licenses

**************************************************************************/
LICENSE_STATUS
LSVerifyCertificateChain(
    HCRYPTPROV hCryptProv, 
    HCERTSTORE hCertStore
    )
/*++

++*/
{
    PCCERT_CONTEXT  pCertContext=NULL;
    PCCERT_CONTEXT  pCertIssuer=NULL;
    DWORD           dwStatus=ERROR_SUCCESS;
    DWORD           dwLastVerification=0;

    //
    // Get the first certificate
    //
    pCertContext=CertFindCertificateInStore(
                                        hCertStore,
                                        X509_ASN_ENCODING,
                                        0,
                                        CERT_FIND_ANY,
                                        NULL,  
                                        NULL
                                    );

    if(pCertContext == NULL)
    {
        #if DBG
        dwStatus=GetLastError();
        #endif

        return LICENSE_STATUS_NO_LICENSE_ERROR;
    }

    while(pCertContext != NULL)
    {
        //
        // Verify against all issuer's certificate
        //
        DWORD dwFlags;
        BOOL  bVerify=FALSE;

        dwStatus=ERROR_SUCCESS;
        dwLastVerification=0;
        pCertIssuer=NULL;

        do {
            dwFlags = CERT_STORE_SIGNATURE_FLAG; // | CERT_STORE_TIME_VALIDITY_FLAG;

            pCertIssuer = CertGetIssuerCertificateFromStore(
                                                    hCertStore,
                                                    pCertContext,
                                                    pCertIssuer,
                                                    &dwFlags
                                                );

            if(!pCertIssuer)
            {
                dwStatus = GetLastError();
                break;
            }
            
            dwLastVerification=dwFlags;
            bVerify = (dwFlags == 0);
        } while(!bVerify);

        // 
        // Check against error return from CertGetIssuerCertificateFromStore()
        //
        if(dwStatus != ERROR_SUCCESS || dwLastVerification)
        {
            if(dwStatus == CRYPT_E_SELF_SIGNED)
            {
                // self-signed certificate
                if( CryptVerifyCertificateSignature(
                                            hCryptProv, 
                                            X509_ASN_ENCODING, 
                                            pCertContext->pbCertEncoded, 
                                            pCertContext->cbCertEncoded,
                                            &pCertContext->pCertInfo->SubjectPublicKeyInfo
                                        ) )
                {
                    dwStatus=ERROR_SUCCESS;
                }
            }
            else if(dwStatus == CRYPT_E_NOT_FOUND)
            {
                // can't find issuer's certificate
                dwStatus = LICENSE_STATUS_CANNOT_FIND_ISSUER_CERT;
            }
            else if(dwLastVerification & CERT_STORE_SIGNATURE_FLAG)
            {
                dwStatus=LICENSE_STATUS_INVALID_LICENSE;
            }
            else if(dwLastVerification & CERT_STORE_TIME_VALIDITY_FLAG)
            {
                dwStatus=LICENSE_STATUS_EXPIRED_LICENSE;
            }
            else
            {
                dwStatus=LICENSE_STATUS_UNSPECIFIED_ERROR;
            }

            break;
        }

        // Success verifiy certificate, 
        // continue on verifying issuer's certificate
        CertFreeCertificateContext(pCertContext);
        pCertContext = pCertIssuer;
    } // while(pCertContext != NULL)

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\cryptkey\base64.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        base64.cpp
//
// Contents:    base64 encode/decode implementation
//
// History:     25-Jul-96       vich created
//              23-Jan-98       HueiWang    Copy from ISPU project
//                                          and modify function name
//---------------------------------------------------------------------------
# include <windows.h>
# include <assert.h>
# include "base64.h"
# undef LSBase64Encode
# undef LSBase64Decode

# define CSASSERT assert
# define TCHAR CHAR

//# define LSBase64Encode LSBase64EncodeA
//# define LSBase64Decode LSBase64DecodeA


// The following table translates an ascii subset to 6 bit values as follows
// (see rfc 1521):
//
//  input    hex (decimal)
//  'A' --> 0x00 (0)
//  'B' --> 0x01 (1)
//  ...
//  'Z' --> 0x19 (25)
//  'a' --> 0x1a (26)
//  'b' --> 0x1b (27)
//  ...
//  'z' --> 0x33 (51)
//  '0' --> 0x34 (52)
//  ...
//  '9' --> 0x3d (61)
//  '+' --> 0x3e (62)
//  '/' --> 0x3f (63)
//
// Encoded lines must be no longer than 76 characters.
// The final "quantum" is handled as follows:  The translation output shall
// always consist of 4 characters.  'x', below, means a translated character,
// and '=' means an equal sign.  0, 1 or 2 equal signs padding out a four byte
// translation quantum means decoding the four bytes would result in 3, 2 or 1
// unencoded bytes, respectively.
//
//  unencoded size    encoded data
//  --------------    ------------
//     1 byte		"xx=="
//     2 bytes		"xxx="
//     3 bytes		"xxxx"

#define CB_BASE64LINEMAX	64	// others use 64 -- could be up to 76

// Any other (invalid) input character value translates to 0x40 (64)

const BYTE abDecode[256] =
{
    /* 00: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 10: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 20: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 62, 64, 64, 64, 63,
    /* 30: */ 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 64, 64, 64, 64, 64, 64,
    /* 40: */ 64,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
    /* 50: */ 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 64, 64, 64, 64, 64,
    /* 60: */ 64, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
    /* 70: */ 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 64, 64, 64, 64, 64,
    /* 80: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 90: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* a0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* b0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* c0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* d0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* e0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* f0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
};


const UCHAR abEncode[] =
    /*  0 thru 25: */ "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    /* 26 thru 51: */ "abcdefghijklmnopqrstuvwxyz"
    /* 52 thru 61: */ "0123456789"
    /* 62 and 63: */  "+/";


DWORD			// ERROR_*
LSBase64DecodeA(
    IN TCHAR const *pchIn,
    IN DWORD cchIn,
    OUT BYTE *pbOut,
    OUT DWORD *pcbOut)
{
    DWORD err = ERROR_SUCCESS;
    DWORD cchInDecode, cbOutDecode;
    TCHAR const *pchInEnd;
    TCHAR const *pchInT;
    BYTE *pbOutT;

    // Count the translatable characters, skipping whitespace & CR-LF chars.

    cchInDecode = 0;
    pchInEnd = &pchIn[cchIn];
    for (pchInT = pchIn; pchInT < pchInEnd; pchInT++)
    {
	if (sizeof(abDecode) < (unsigned) *pchInT || abDecode[*pchInT] > 63)
	{
	    // skip all whitespace

	    if (*pchInT == ' ' ||
	        *pchInT == '\t' ||
	        *pchInT == '\r' ||
	        *pchInT == '\n')
	    {
		continue;
	    }

	    if (0 != cchInDecode)
	    {
		if ((cchInDecode % 4) == 0)
		{
		    break;			// ends on quantum boundary
		}

		// The length calculation may stop in the middle of the last
		// translation quantum, because the equal sign padding
		// characters are treated as invalid input.  If the last
		// translation quantum is not 4 bytes long, it must be 2 or 3
		// bytes long.

		if (*pchInT == '=' && (cchInDecode % 4) != 1)
		{
		    break;				// normal termination
		}
	    }
	    err = ERROR_INVALID_DATA;
	    goto error;
	}
	cchInDecode++;
    }
    CSASSERT(pchInT <= pchInEnd);
    pchInEnd = pchInT;		// don't process any trailing stuff again

    // We know how many translatable characters are in the input buffer, so now
    // set the output buffer size to three bytes for every four (or fraction of
    // four) input bytes.

    cbOutDecode = ((cchInDecode + 3) / 4) * 3;

    pbOutT = pbOut;

    if (NULL == pbOut)
    {
	pbOutT += cbOutDecode;
    }
    else
    {
	// Decode one quantum at a time: 4 bytes ==> 3 bytes

	CSASSERT(cbOutDecode <= *pcbOut);
	pchInT = pchIn;
	while (cchInDecode > 0)
	{
	    DWORD i;
	    BYTE ab4[4];

	    memset(ab4, 0, sizeof(ab4));
	    for (i = 0; i < min(sizeof(ab4)/sizeof(ab4[0]), cchInDecode); i++)
	    {
		while (
		    sizeof(abDecode) > (unsigned) *pchInT &&
		    63 < abDecode[*pchInT])
		{
		    pchInT++;
		}
		CSASSERT(pchInT < pchInEnd);
		ab4[i] = (BYTE) *pchInT++;
	    }

	    // Translate 4 input characters into 6 bits each, and deposit the
	    // resulting 24 bits into 3 output bytes by shifting as appropriate.

	    // out[0] = in[0]:in[1] 6:2
	    // out[1] = in[1]:in[2] 4:4
	    // out[2] = in[2]:in[3] 2:6

	    *pbOutT++ =
		(BYTE) ((abDecode[ab4[0]] << 2) | (abDecode[ab4[1]] >> 4));

	    if (i > 2)
	    {
		*pbOutT++ =
		  (BYTE) ((abDecode[ab4[1]] << 4) | (abDecode[ab4[2]] >> 2));
	    }
	    if (i > 3)
	    {
		*pbOutT++ = (BYTE) ((abDecode[ab4[2]] << 6) | abDecode[ab4[3]]);
	    }
	    cchInDecode -= i;
	}
	CSASSERT((DWORD) (pbOutT - pbOut) <= cbOutDecode);
    }
    *pcbOut = (DWORD)(pbOutT - pbOut);
error:
    return(err);
}


DWORD			// ERROR_*
LSBase64EncodeA(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT TCHAR *pchOut,
    OUT DWORD *pcchOut)
{
    TCHAR *pchOutT;
    DWORD cchOutEncode;

    // Allocate enough memory for full final translation quantum.

    cchOutEncode = ((cbIn + 2) / 3) * 4;

    // and enough for CR-LF pairs for every CB_BASE64LINEMAX character line.

    cchOutEncode +=
	2 * ((cchOutEncode + CB_BASE64LINEMAX - 1) / CB_BASE64LINEMAX);

    pchOutT = pchOut;
    if (NULL == pchOut)
    {
	pchOutT += cchOutEncode;
    }
    else
    {
	DWORD cCol;

	CSASSERT(cchOutEncode <= *pcchOut);
	cCol = 0;
	while ((long) cbIn > 0)	// signed comparison -- cbIn can wrap
	{
	    BYTE ab3[3];

	    if (cCol == CB_BASE64LINEMAX/4)
	    {
		cCol = 0;
		*pchOutT++ = '\r';
		*pchOutT++ = '\n';
	    }
	    cCol++;
	    memset(ab3, 0, sizeof(ab3));

	    ab3[0] = *pbIn++;
	    if (cbIn > 1)
	    {
		ab3[1] = *pbIn++;
		if (cbIn > 2)
		{
		    ab3[2] = *pbIn++;
		}
	    }

	    *pchOutT++ = abEncode[ab3[0] >> 2];
	    *pchOutT++ = abEncode[((ab3[0] << 4) | (ab3[1] >> 4)) & 0x3f];
	    *pchOutT++ = (cbIn > 1)?
			abEncode[((ab3[1] << 2) | (ab3[2] >> 6)) & 0x3f] : '=';
	    *pchOutT++ = (cbIn > 2)? abEncode[ab3[2] & 0x3f] : '=';

	    cbIn -= 3;
	}
	*pchOutT++ = '\r';
	*pchOutT++ = '\n';
	CSASSERT((DWORD) (pchOutT - pchOut) <= cchOutEncode);
    }
    *pcchOut = (DWORD)(pchOutT - pchOut);
    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\licecert\x509.cpp ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    x509.cpp

Abstract:

    This module implements the X509 certificate manipulation functions

Author:

    Doug Barlow (dbarlow) 9/29/1994

Environment:



Notes:



--*/

#include <windows.h>
#include "x509.h"


//
//==============================================================================
//
//  Attribute
//

Attribute::Attribute(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequence(dwFlags, dwTag),
    attributeType(0),
    attributeValue(0)
{
    m_rgEntries.Add(&attributeType);
    m_rgEntries.Add(&attributeValue);
}

CAsnObject *
Attribute::Clone(
    DWORD dwFlags)
const
{
    return new Attribute(dwFlags);
}


//
//==============================================================================
//
//  Attributes
//

Attributes::Attributes(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSetOf(dwFlags, dwTag),
    m_asnEntry1(0)
{
    m_pasnTemplate = &m_asnEntry1;
}

CAsnObject *
Attributes::Clone(
    DWORD dwFlags)
const
{
    return new Attributes(dwFlags);
}


//
//==============================================================================
//
//  UniqueIdentifier
//

UniqueIdentifier::UniqueIdentifier(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequence(dwFlags, dwTag),
    attributeType(0),
    attributeValue(0)
{
    m_rgEntries.Add(&attributeType);
    m_rgEntries.Add(&attributeValue);
}

CAsnObject *
UniqueIdentifier::Clone(
    DWORD dwFlags)
const
{
    return new UniqueIdentifier(dwFlags);
}


//
//==============================================================================
//
//  RelativeDistinguishedName
//

RelativeDistinguishedName::RelativeDistinguishedName(
    DWORD dwFlags,
    DWORD dwTag)
:   Attributes(dwFlags, dwTag)
{
}

CAsnObject *
RelativeDistinguishedName::Clone(
    DWORD dwFlags)
const
{
    return new RelativeDistinguishedName(dwFlags);
}


//
//==============================================================================
//
//  Name
//

Name::Name(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequenceOf(dwFlags, dwTag),
    m_asnEntry1(0)
{
    m_pasnTemplate = &m_asnEntry1;
}

CAsnObject *
Name::Clone(
    DWORD dwFlags)
const
{
    return new Name(dwFlags);
}


//
//==============================================================================
//
//  Validity
//

Validity::Validity(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequence(dwFlags, dwTag),
    notBefore(0),
    notAfter(0)
{
    m_rgEntries.Add(&notBefore);
    m_rgEntries.Add(&notAfter);
}

CAsnObject *
Validity::Clone(
    DWORD dwFlags)
const
{
    return new Validity(dwFlags);
}


//
//==============================================================================
//
//  AlgorithmIdentifier
//

AlgorithmIdentifier::AlgorithmIdentifier(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequence(dwFlags, dwTag),
    algorithm(0),
    parameters(fOptional)
{
    m_rgEntries.Add(&algorithm);
    m_rgEntries.Add(&parameters);
}

CAsnObject *
AlgorithmIdentifier::Clone(DWORD dwFlags)
const
{
    return new AlgorithmIdentifier(dwFlags);
}


//
//==============================================================================
//
//  SubjectPublicKeyInfo
//

SubjectPublicKeyInfo::SubjectPublicKeyInfo(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequence(dwFlags, dwTag),
    algorithm(0),
    subjectPublicKey(0)
{
    m_rgEntries.Add(&algorithm);
    m_rgEntries.Add(&subjectPublicKey);
}

CAsnObject *
SubjectPublicKeyInfo::Clone(
    DWORD dwFlags)
const
{
    return new SubjectPublicKeyInfo(dwFlags);
}


//
//==============================================================================
//
//  Extension
//

Extension::Extension(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequence(dwFlags, dwTag),
    extnid(0),
    critical(fOptional),    // DEFAULT FALSE
    extnValue(0)
{
    m_rgEntries.Add(&extnid);
//  critical.Write((LPBYTE)"\x00", 1);
//  critical.SetDefault();
    m_rgEntries.Add(&critical);
    m_rgEntries.Add(&extnValue);
}

CAsnObject *
Extension::Clone(
    DWORD dwFlags)
const
{
    return new Extension(dwFlags);
}


//
//==============================================================================
//
//  Extensions
//

Extensions::Extensions(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequenceOf(dwFlags, dwTag),
    m_asnEntry1(0)
{
    m_pasnTemplate = &m_asnEntry1;
}

CAsnObject *
Extensions::Clone(
    DWORD dwFlags)
const
{
    return new Extensions(dwFlags);
}


//
//==============================================================================
//
//  CertificateToBeSigned
//

CertificateToBeSigned::CertificateToBeSigned(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequence(dwFlags, dwTag),
    _tag1(fOptional, TAG(0)),   // DEFAULT 0
    version(0),
    serialNumber(0),
    signature(0),
    issuer(0),
    validity(0),
    subject(0),
    subjectPublicKeyInfo(0),
    issuerUniqueID(fOptional, TAG(1)),
    subjectUniqueID(fOptional, TAG(2)),
    _tag2(fOptional, TAG(3)),
    extensions(0)
{
    _tag1.Reference(&version);
//  _tag1.Write((LPBYTE)"\x02\x01\x00", 3);
//  _tag1.SetDefault();
    m_rgEntries.Add(&_tag1);
    m_rgEntries.Add(&serialNumber);
    m_rgEntries.Add(&signature);
    m_rgEntries.Add(&issuer);
    m_rgEntries.Add(&validity);
    m_rgEntries.Add(&subject);
    m_rgEntries.Add(&subjectPublicKeyInfo);
    m_rgEntries.Add(&issuerUniqueID);
    m_rgEntries.Add(&subjectUniqueID);
    _tag2.Reference(&extensions);
    m_rgEntries.Add(&_tag2);
}

CAsnObject *
CertificateToBeSigned::Clone(
    DWORD dwFlags)
const
{
    return new CertificateToBeSigned(dwFlags);
}


//
//==============================================================================
//
//  Certificate
//

Certificate::Certificate(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequence(dwFlags, dwTag),
    toBeSigned(0),
    algorithm(0),
    signature(0)
{
    m_rgEntries.Add(&toBeSigned);
    m_rgEntries.Add(&algorithm);
    m_rgEntries.Add(&signature);
}

CAsnObject *
Certificate::Clone(
    DWORD dwFlags)
const
{
    return new Certificate(dwFlags);
}


//
//==============================================================================
//
//  CRLEntry
//

CRLEntry::CRLEntry(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequence(dwFlags, dwTag),
    userCertificate(0),
    revocationDate(0),
    crlEntryExtensions(fOptional)
{
    m_rgEntries.Add(&userCertificate);
    m_rgEntries.Add(&revocationDate);
    m_rgEntries.Add(&crlEntryExtensions);
}

CAsnObject *
CRLEntry::Clone(
    DWORD dwFlags)
const
{
    return new CRLEntry(dwFlags);
}


//
//==============================================================================
//
//  RevokedCertificates
//

RevokedCertificates::RevokedCertificates(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequenceOf(dwFlags, dwTag),
    m_asnEntry1(0)
{
    m_pasnTemplate = &m_asnEntry1;
}

CAsnObject *
RevokedCertificates::Clone(
    DWORD dwFlags)
const
{
    return new RevokedCertificates(dwFlags);
}


//
//==============================================================================
//
//  CertificateRevocationListToBeSigned
//

CertificateRevocationListToBeSigned::CertificateRevocationListToBeSigned(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequence(dwFlags, dwTag),
    version(0),     // DEFAULT 0
    signature(0),
    issuer(0),
    lastUpdate(0),
    nextUpdate(fOptional),
    revokedCertificates(fOptional),
    _tag1(fOptional, TAG(0)),
    crlExtensions(0)
{
    m_rgEntries.Add(&version);
    m_rgEntries.Add(&signature);
    m_rgEntries.Add(&issuer);
    m_rgEntries.Add(&lastUpdate);
    m_rgEntries.Add(&nextUpdate);
    m_rgEntries.Add(&revokedCertificates);
    _tag1.Reference(&crlExtensions);
    m_rgEntries.Add(&_tag1);
}

CAsnObject *
CertificateRevocationListToBeSigned::Clone(
    DWORD dwFlags)
const
{
    return new CertificateRevocationListToBeSigned(dwFlags);
}


//
//==============================================================================
//
//  CertificateRevocationList
//

CertificateRevocationList::CertificateRevocationList(
    DWORD dwFlags,
    DWORD dwTag)
:   CAsnSequence(dwFlags, dwTag),
    toBeSigned(0),
    algorithm(0),
    signature(0)
{
    m_rgEntries.Add(&toBeSigned);
    m_rgEntries.Add(&algorithm);
    m_rgEntries.Add(&signature);
}

CAsnObject *
CertificateRevocationList::Clone(
    DWORD dwFlags)
const
{
    return new CertificateRevocationList(dwFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\cryptkey\cryptkey.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cryptkey.c
//
//  Contents:   Functions that are used to pack and unpack different messages
//
//  Classes:
//
//  Functions:
//
//  History:    12-19-97  v-sbhatt   Created
//
//----------------------------------------------------------------------------

//
// Include files
//

#include "windows.h"
#include "tchar.h"
#ifdef _DEBUG
#include "stdio.h"
#endif  //_DEBUG
#include "stdlib.h"
#include "malloc.h"

#ifdef OS_WINCE
#include <wincelic.h>
#include <ceconfig.h>
#endif  //OS_WINCE


#include "license.h"

#include "cryptkey.h"
#include "rsa.h"
#include "md5.h"
#include "sha.h"
#include "rc4.h"

#include <tssec.h>

#ifdef OS_WIN32
#include "des.h"
#include "tripldes.h"
#include "modes.h"
#include "sha_my.h"
#include "dh_key.h"
#include "dss_key.h"
#endif //

#ifndef OS_WINCE
#include "assert.h"
#endif // OS_WINCE

#include "rng.h"


LPBSAFE_PUB_KEY PUB;
unsigned char pubmodulus[] =
{
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x3d, 0x3a, 0x5e, 0xbd, 0x72, 0x43, 0x3e, 0xc9,
0x4d, 0xbb, 0xc1, 0x1e, 0x4a, 0xba, 0x5f, 0xcb,
0x3e, 0x88, 0x20, 0x87, 0xef, 0xf5, 0xc1, 0xe2,
0xd7, 0xb7, 0x6b, 0x9a, 0xf2, 0x52, 0x45, 0x95,
0xce, 0x63, 0x65, 0x6b, 0x58, 0x3a, 0xfe, 0xef,
0x7c, 0xe7, 0xbf, 0xfe, 0x3d, 0xf6, 0x5c, 0x7d,
0x6c, 0x5e, 0x06, 0x09, 0x1a, 0xf5, 0x61, 0xbb,
0x20, 0x93, 0x09, 0x5f, 0x05, 0x6d, 0xea, 0x87,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


BYTE    PAD_1[40] = {0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
                                     0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
                                     0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
                                     0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
                                     0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36};

BYTE    PAD_2[48] = {0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
                                         0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
                                         0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
                                         0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
                                         0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
                                         0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C};

//Initializes a pulic key
static BOOL initpubkey(void)
{
    PUB = (LPBSAFE_PUB_KEY)pubmodulus;

    PUB->magic = RSA1;
    PUB->keylen = 0x48;
    PUB->bitlen = 0x0200;
    PUB->datalen = 0x3f;
    PUB->pubexp = 0xc0887b5b;
        return TRUE;
}

/*****************************************************************************
*   Funtion :   LicenseMakeSessionKeys
*   Purpose :   Generates a session keys based on CryptSystem and puts the
                data in the rgbSessionKey data member of CryptSystem
*   Returns :   License_status
******************************************************************************/

LICENSE_STATUS
CALL_TYPE
LicenseSetPreMasterSecret(
                                                PCryptSystem    pCrypt,
                                                PUCHAR                  pPreMasterSecret
                                                )
{
        LICENSE_STATUS lsReturn = LICENSE_STATUS_OK;

        assert(pCrypt);
        assert(pPreMasterSecret);
        //check the state of the crypt system
        if(pCrypt->dwCryptState != CRYPT_SYSTEM_STATE_INITIALIZED)
        {
                lsReturn = LICENSE_STATUS_INVALID_CRYPT_STATE;
                return lsReturn;
        }

        memcpy(pCrypt->rgbPreMasterSecret, pPreMasterSecret, LICENSE_PRE_MASTER_SECRET);
        pCrypt->dwCryptState = CRYPT_SYSTEM_STATE_PRE_MASTER_SECRET;
        return lsReturn;

}

LICENSE_STATUS
CALL_TYPE
LicenseMakeSessionKeys(
                                PCryptSystem    pCrypt,
                                DWORD                   dwReserved
                            )
{
    LICENSE_STATUS      lsReturn = LICENSE_STATUS_OK;
    MD5_CTX             Md5Hash;
    A_SHA_CTX           ShaHash;
    BYTE                rgbShaHashValue[A_SHA_DIGEST_LEN];
    BYTE                rgbKeyBlock[3*LICENSE_SESSION_KEY];
    BYTE FAR *          sz[3] = { "A","BB","CCC" };
    BYTE                rgbWriteKey[LICENSE_SESSION_KEY];
    DWORD               ib;

        assert(pCrypt);

        if(pCrypt->dwCryptState != CRYPT_SYSTEM_STATE_MASTER_SECRET)
        {
                lsReturn = LICENSE_STATUS_INVALID_CRYPT_STATE;
                return lsReturn;
        }
    //At this point, rgbPreMasterSecret  should contain Master secret.
    //ie a call to BuildMasterSecret is required before this is called

    for(ib=0 ; ib<3 ; ib++)
        {
                // SHA(master_secret + ServerHello.random + ClientHello.random + 'foo')
                A_SHAInit  (&ShaHash);
                A_SHAUpdate(&ShaHash, sz[ib], (UINT)ib + 1);
                A_SHAUpdate(&ShaHash, pCrypt->rgbPreMasterSecret, LICENSE_PRE_MASTER_SECRET);
                A_SHAUpdate(&ShaHash, pCrypt->rgbServerRandom, LICENSE_RANDOM);
                A_SHAUpdate(&ShaHash, pCrypt->rgbClientRandom, LICENSE_RANDOM);
                A_SHAFinal (&ShaHash, rgbShaHashValue);

                // MD5(master_secret + SHA-hash)
                MD5Init  (&Md5Hash);
                MD5Update(&Md5Hash, pCrypt->rgbPreMasterSecret, LICENSE_PRE_MASTER_SECRET);
                MD5Update(&Md5Hash, rgbShaHashValue, A_SHA_DIGEST_LEN);
                MD5Final (&Md5Hash);
                memcpy(rgbKeyBlock + ib * MD5DIGESTLEN, Md5Hash.digest, MD5DIGESTLEN);
                //CopyMemory(rgbKeyBlock + ib * MD5DIGESTLEN, Md5Hash.digest, MD5DIGESTLEN);
    }

    //
    // extract keys from key block
    //

    ib = 0;
        memcpy(pCrypt->rgbMACSaltKey, rgbKeyBlock + ib, LICENSE_MAC_WRITE_KEY);
        ib+= LICENSE_MAC_WRITE_KEY;
        memcpy(rgbWriteKey, rgbKeyBlock + ib, LICENSE_SESSION_KEY);

    // final_client_write_key = MD5(client_write_key +
        //      ClientHello.random + ServerHello.random)
        MD5Init  (&Md5Hash);

    MD5Update(&Md5Hash, rgbWriteKey, LICENSE_SESSION_KEY);
        MD5Update(&Md5Hash, pCrypt->rgbClientRandom, LICENSE_RANDOM);
        MD5Update(&Md5Hash, pCrypt->rgbServerRandom, LICENSE_RANDOM);
        MD5Final (&Md5Hash);

    memcpy(pCrypt->rgbSessionKey, Md5Hash.digest, LICENSE_SESSION_KEY);
        pCrypt->dwCryptState = CRYPT_SYSTEM_STATE_SESSION_KEY;
    return lsReturn;

}

/*****************************************************************************
*   Funtion :   LicenseBuildMasterSecret
*   Purpose :   Generates the Master Secret based on ClientRandom, ServerRandom
*               and PreMasterSecret data members of CryptSystem and puts the
*               data in the rgbPreMasterSecret data member of CryptSystem
*               Note: A call to this function should preceed any call to
*               LicenseMakeSessionKeys
*   Returns :   License_status
******************************************************************************/

LICENSE_STATUS
CALL_TYPE
LicenseBuildMasterSecret(
                         PCryptSystem   pSystem
                         )
{
    LICENSE_STATUS  lsReturn = LICENSE_STATUS_OK;
    BYTE rgbRandom[2 * LICENSE_RANDOM];
    BYTE rgbT[LICENSE_PRE_MASTER_SECRET];
    BYTE FAR* sz[3] = { "A","BB","CCC" } ;
    MD5_CTX Md5Hash;
    A_SHA_CTX ShaHash;
    BYTE bShaHashValue[A_SHA_DIGEST_LEN];
    WORD i;

        assert(pSystem);

        if(pSystem->dwCryptState != CRYPT_SYSTEM_STATE_PRE_MASTER_SECRET)
        {
                lsReturn = LICENSE_STATUS_INVALID_CRYPT_STATE;
                return lsReturn;
        }

    //initialize all buffers with zero
    memset(rgbT, 0, LICENSE_PRE_MASTER_SECRET);
    memset(bShaHashValue, 0, A_SHA_DIGEST_LEN);


//      CopyMemory(rgbRandom,  pSystem->rgbClientRandom, LICENSE_RANDOM);
        memcpy(rgbRandom,  pSystem->rgbClientRandom, LICENSE_RANDOM);

        //CopyMemory(rgbRandom + LICENSE_RANDOM, pSystem->rgbServerRandom, LICENSE_RANDOM);
        memcpy(rgbRandom + LICENSE_RANDOM, pSystem->rgbServerRandom, LICENSE_RANDOM);
        for ( i = 0 ; i < 3 ; i++)
                {
            // SHA('A' or 'BB' or 'CCC' + pre_master_secret + ClientRandom + ServerRandom)
            A_SHAInit(&ShaHash);
                A_SHAUpdate(&ShaHash, sz[i], i + 1);
            A_SHAUpdate(&ShaHash, pSystem->rgbPreMasterSecret, LICENSE_PRE_MASTER_SECRET);
            A_SHAUpdate(&ShaHash, rgbRandom, LICENSE_RANDOM * 2);
            A_SHAFinal(&ShaHash, bShaHashValue);

            // MD5(pre_master_secret + SHA-hash)
            MD5Init(&Md5Hash);
            MD5Update(&Md5Hash, pSystem->rgbPreMasterSecret, LICENSE_PRE_MASTER_SECRET);
            MD5Update(&Md5Hash, bShaHashValue, A_SHA_DIGEST_LEN);
            MD5Final(&Md5Hash);
          //  CopyMemory(rgbT + (i * MD5DIGESTLEN), Md5Hash.digest, MD5DIGESTLEN);
                memcpy(rgbT + (i * MD5DIGESTLEN), Md5Hash.digest, MD5DIGESTLEN);
            }

    // Store MASTER_KEY on top of pre-master key
    //CopyMemory(pSystem->rgbPreMasterSecret, rgbT, LICENSE_PRE_MASTER_SECRET);
        memcpy(pSystem->rgbPreMasterSecret, rgbT, LICENSE_PRE_MASTER_SECRET);
        pSystem->dwCryptState = CRYPT_SYSTEM_STATE_MASTER_SECRET;
    return lsReturn;
}

/******************************************************************************
*       Function : LicenseVerifyServerCert
*       Purpose  : This function accepts a pointer to a Hydra Server Cert structure
*                          and verifies the signature on the certificatewith universal MS
*                          public key.
*       Return   : License_Status
*******************************************************************************/

LICENSE_STATUS
CALL_TYPE
LicenseVerifyServerCert(
                                                PHydra_Server_Cert      pCert
                                                )
{
        LICENSE_STATUS          lsResult = LICENSE_STATUS_OK;
        BYTE FAR *  pbTemp;
        BYTE FAR *  pbSignData = NULL;
        BYTE            SignHash[0x48];
        DWORD           cbSignData, dwTemp;
        MD5_CTX         HashState;

        if( NULL == pCert )
        {
                assert(pCert);
                return ( LICENSE_STATUS_INVALID_INPUT );
        }

        if( NULL == pCert->PublicKeyData.pBlob )
        {
                assert(pCert->PublicKeyData.pBlob);
                return ( LICENSE_STATUS_INVALID_INPUT );
        }

        if( NULL == pCert->SignatureBlob.pBlob )
        {
                assert(pCert->SignatureBlob.pBlob);
                return ( LICENSE_STATUS_INVALID_INPUT );
        }

        if( BB_RSA_SIGNATURE_BLOB == pCert->SignatureBlob.wBlobType )
        {
                //Generate the hash on the data
                if( ( pCert->dwSigAlgID != SIGNATURE_ALG_RSA ) ||
                        ( pCert->dwKeyAlgID != KEY_EXCHANGE_ALG_RSA ) ||
                        ( pCert->PublicKeyData.wBlobType != BB_RSA_KEY_BLOB ) )
                {
#if DBG
                        OutputDebugString(_T("Error Invalid Certificate.\n"));
#endif
                        lsResult = LICENSE_STATUS_INVALID_INPUT;
                        goto CommonReturn;
                }
        }
        else
        {
#if DBG
                OutputDebugString(_T("Error Invalid Public Key parameter.\n"));
#endif
                lsResult = LICENSE_STATUS_INVALID_INPUT;
                goto CommonReturn;
        }

        cbSignData = 3*sizeof(DWORD) + 2*sizeof(WORD) + pCert->PublicKeyData.wBlobLen;

        if( NULL == (pbSignData = (BYTE FAR *)malloc(cbSignData)) )
        {
#if DBG
                OutputDebugString(_T("Error allocating memory.\n"));
#endif
                lsResult = LICENSE_STATUS_OUT_OF_MEMORY;
                goto CommonReturn;
        }

        memset(pbSignData, 0x00, cbSignData);

        //Pack the certificate data into a byte blob excluding the signature info
        pbTemp = pbSignData;
        dwTemp = 0;

        memcpy(pbTemp, &pCert->dwVersion, sizeof(DWORD));
        pbTemp += sizeof(DWORD);
        dwTemp += sizeof(DWORD);

        memcpy(pbTemp, &pCert->dwSigAlgID, sizeof(DWORD));
        pbTemp += sizeof(DWORD);
        dwTemp += sizeof(DWORD);

        memcpy(pbTemp, &pCert->dwKeyAlgID, sizeof(DWORD));
        pbTemp += sizeof(DWORD);
        dwTemp += sizeof(DWORD);

        memcpy(pbTemp, &pCert->PublicKeyData.wBlobType, sizeof(WORD));
        pbTemp += sizeof(WORD);
        dwTemp += sizeof(WORD);

        memcpy(pbTemp, &pCert->PublicKeyData.wBlobLen, sizeof(WORD));
        pbTemp += sizeof(WORD);
        dwTemp += sizeof(WORD);

        memcpy(pbTemp, pCert->PublicKeyData.pBlob, pCert->PublicKeyData.wBlobLen);
        pbTemp += pCert->PublicKeyData.wBlobLen;
        dwTemp += pCert->PublicKeyData.wBlobLen;

                //Generate the hash on the data
        MD5Init(&HashState);
        MD5Update(&HashState, pbSignData, (UINT)cbSignData);
        MD5Final(&HashState);

        //Initialize the public key and Decrypt the signature
        if(!initpubkey())
        {
#if DBG
                OutputDebugString(_T("Error generating public key!\n"));
#endif
                lsResult = LICENSE_STATUS_INITIALIZATION_FAILED;
                goto CommonReturn;
        }
        memset(SignHash, 0x00, 0x48);
        if (!BSafeEncPublic(PUB, pCert->SignatureBlob.pBlob, SignHash))
        {
#if DBG
                OutputDebugString(_T("Error encrypting signature!\n"));
#endif
                lsResult = LICENSE_STATUS_INVALID_SIGNATURE;
                goto CommonReturn;
        }
        else
        {
            SetLastError(0);
        }


        if(memcmp(SignHash, HashState.digest, 16))
        {
#if DBG
                OutputDebugString(_T("Error Invalid signature.\n"));
#endif
                lsResult = LICENSE_STATUS_INVALID_SIGNATURE;
                goto CommonReturn;
        }
        else
        {
                lsResult = LICENSE_STATUS_OK;
                goto CommonReturn;
        }




CommonReturn:
        if(pbSignData)
        {
                free(pbSignData);
                pbSignData = NULL;
        }
        return lsResult;
}


LICENSE_STATUS
CALL_TYPE
LicenseGenerateMAC(
                                   PCryptSystem         pCrypt,
                                   BYTE FAR *           pbData,
                                   DWORD                        cbData,
                                   BYTE FAR *           pbMACData
                                   )
{
        LICENSE_STATUS          lsResult = LICENSE_STATUS_OK;
        A_SHA_CTX       SHAHash;
        MD5_CTX         MD5Hash;
        BYTE            rgbSHADigest[A_SHA_DIGEST_LEN];

        assert(pCrypt);
        assert(pbData);
        assert(pbMACData);


        if(pCrypt->dwCryptState != CRYPT_SYSTEM_STATE_SESSION_KEY)
        {
                lsResult = LICENSE_STATUS_INVALID_CRYPT_STATE;
                return lsResult;
        }
        //Do SHA(MACSalt + PAD_2 + Length + Content)
        A_SHAInit(&SHAHash);
        A_SHAUpdate(&SHAHash, pCrypt->rgbMACSaltKey, LICENSE_MAC_WRITE_KEY);
        A_SHAUpdate(&SHAHash, PAD_1, 40);
        A_SHAUpdate(&SHAHash, (BYTE FAR *)&cbData, sizeof(DWORD));
        A_SHAUpdate(&SHAHash, pbData, (UINT)cbData);
        A_SHAFinal(&SHAHash, rgbSHADigest);

        //Do MD5(MACSalt + PAD_2 + SHAHash)
        MD5Init(&MD5Hash);
        MD5Update(&MD5Hash, pCrypt->rgbMACSaltKey, LICENSE_MAC_WRITE_KEY);
        MD5Update(&MD5Hash, PAD_2, 48);
        MD5Update(&MD5Hash, rgbSHADigest, A_SHA_DIGEST_LEN);
        MD5Final(&MD5Hash);

        memcpy(pbMACData, MD5Hash.digest, 16);

        return lsResult;
}


//
// decrypt the enveloped data using the given private key.
//

LICENSE_STATUS
CALL_TYPE
LicenseDecryptEnvelopedData(
        BYTE FAR *              pbPrivateKey,
        DWORD                   cbPrivateKey,
        BYTE FAR *              pbEnvelopedData,
        DWORD                   cbEnvelopedData,
        BYTE FAR *              pbData,
        DWORD                   *pcbData
        )
{

        LICENSE_STATUS  lsReturn = LICENSE_STATUS_OK;
        LPBSAFE_PRV_KEY         Prv;
//      BYTE                            InputBuffer[500];

        assert(pbPrivateKey);
        assert(pbEnvelopedData);
        assert(pcbData);

        Prv = (LPBSAFE_PRV_KEY)pbPrivateKey;

        if(cbEnvelopedData != Prv->keylen)
        {
                lsReturn = LICENSE_STATUS_INVALID_INPUT;
                *pcbData = 0;
                return lsReturn;
        }

        if(pbData == NULL)
        {
                *pcbData = Prv->keylen;
                return lsReturn;
        }


        //Now memset the output buffer to 0
        memset(pbData, 0x00, *pcbData);

        if(!BSafeDecPrivate(Prv, pbEnvelopedData, pbData))
        {
                lsReturn = LICENSE_STATUS_INVALID_INPUT;
                *pcbData = 0;
                return lsReturn;
        }

        *pcbData = Prv->keylen;

        return lsReturn;
}


//
// Encrypt the data using the public key
//

LICENSE_STATUS
CALL_TYPE
LicenseEnvelopeData(
        BYTE FAR *                      pbPublicKey,
        DWORD                   cbPublicKey,
        BYTE FAR *                      pbData,
        DWORD                   cbData,
        BYTE FAR *                      pbEnvelopedData,
        DWORD                   *pcbEnvelopedData
        )
{
        LPBSAFE_PUB_KEY         Pub;
        LPBYTE                           InputBuffer = NULL;

        assert(pcbEnvelopedData);

        if(!pcbEnvelopedData)
        {
            return LICENSE_STATUS_INVALID_INPUT;
        }

        assert(pbPublicKey);

        if(!pbPublicKey)
        {
            *pcbEnvelopedData = 0;
            return LICENSE_STATUS_INVALID_INPUT;
        }
        
        
        
        Pub = (LPBSAFE_PUB_KEY)pbPublicKey;

        if(pbEnvelopedData == NULL)
        {
                *pcbEnvelopedData = Pub->keylen;
                return LICENSE_STATUS_OK;
        }
        
        assert(pbData);
        assert(cbData<=Pub->datalen);
        assert(Pub->datalen <= Pub->keylen);
        assert(*pcbEnvelopedData>=Pub->keylen);
        
        if(!pbData || cbData > Pub->datalen || 
            Pub->datalen > Pub->keylen || *pcbEnvelopedData < Pub->keylen)
        {
            *pcbEnvelopedData = 0;
            return LICENSE_STATUS_INVALID_INPUT;
        }

        *pcbEnvelopedData = 0;

        InputBuffer = malloc(Pub->keylen);
        if(!InputBuffer)
        {
            return LICENSE_STATUS_OUT_OF_MEMORY;
        }

        //Initialize input buffer with 0
        memset(InputBuffer, 0x00, Pub->keylen);

        //Copy the data to be encrypted to the input buffer
        memcpy(InputBuffer, pbData, cbData);

        memset(pbEnvelopedData, 0x00, Pub->keylen);

        if(!BSafeEncPublic(Pub, InputBuffer, pbEnvelopedData))
        {
                free(InputBuffer);
                return LICENSE_STATUS_INVALID_INPUT;
        }
        else        
        {
            SetLastError(0);
        }
        
        free(InputBuffer);
        *pcbEnvelopedData = Pub->keylen;
        return LICENSE_STATUS_OK;
}


//
// encrypt the session data using the session key
// pbData contains the data to be encrypted and cbData contains the size
// after the function returns, they represent the encrypted data and size
// respectively
//

LICENSE_STATUS
CALL_TYPE
LicenseEncryptSessionData(
    PCryptSystem    pCrypt,
        BYTE FAR *                      pbData,
        DWORD                   cbData
    )
{
    LICENSE_STATUS      lsReturn = LICENSE_STATUS_OK;
        struct RC4_KEYSTRUCT    Key;

        assert(pCrypt);
        assert(pbData);
        assert(cbData);

    if( ( NULL == pCrypt ) ||
        ( NULL == pbData ) ||
        ( 0 == cbData ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

        //Check the state of the CryptSystem
        assert(pCrypt->dwCryptState == CRYPT_SYSTEM_STATE_SESSION_KEY);

        memset(&Key, 0x00, sizeof(struct RC4_KEYSTRUCT));

        //Initialize the key
        rc4_key(&Key, LICENSE_SESSION_KEY, pCrypt->rgbSessionKey);

        //Now encrypt the data with the key
        rc4(&Key, (UINT)cbData, pbData);
    return lsReturn;

}


//
// decrypt the session data using the session key
// pbData contains the data to be decrypted and cbData contains the size
// after the function returns, they represent the decrypted data and size
// respectively


LICENSE_STATUS
CALL_TYPE
LicenseDecryptSessionData(
    PCryptSystem    pCrypt,
        BYTE FAR *                      pbData,
        DWORD                   cbData)
{
        LICENSE_STATUS  lsReturn = LICENSE_STATUS_OK;
        struct RC4_KEYSTRUCT    Key;

        assert(pCrypt);
        assert(pbData);
        assert(cbData);

    //
    // check input
    //

    if( ( NULL == pCrypt ) ||
        ( NULL == pbData ) ||
        ( 0 >= cbData ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

        //Check the state of the CryptSystem
        assert(pCrypt->dwCryptState == CRYPT_SYSTEM_STATE_SESSION_KEY);

        memset(&Key, 0x00, sizeof(struct RC4_KEYSTRUCT));

        //Initialize the key
        rc4_key(&Key, LICENSE_SESSION_KEY, pCrypt->rgbSessionKey);

        //Now encrypt the data with the key
        rc4(&Key, (UINT)cbData, pbData);
    return lsReturn;
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
CALL_TYPE
LicenseEncryptHwid(
    PHWID   pHwid,
    PDWORD  pcbEncryptedHwid,
    BYTE FAR *   pEncryptedHwid,
    DWORD   cbSecretKey,
    BYTE FAR *   pSecretKey )
{
    LICENSE_STATUS         Status = LICENSE_STATUS_OK;
    struct RC4_KEYSTRUCT   Key;

    assert( pHwid );
    assert( sizeof( HWID ) <= *pcbEncryptedHwid );
    assert( pEncryptedHwid );
    assert( LICENSE_SESSION_KEY == cbSecretKey );
    assert( pSecretKey );

    if( ( NULL == pHwid ) ||
        ( sizeof( HWID ) > *pcbEncryptedHwid ) ||
        ( NULL == pEncryptedHwid ) ||
        ( LICENSE_SESSION_KEY != cbSecretKey ) ||
        ( NULL == pSecretKey ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // Initialize the key
    //

    memset( &Key, 0x00, sizeof( struct RC4_KEYSTRUCT ) );
    rc4_key(&Key, LICENSE_SESSION_KEY, pSecretKey);

    //
    // Now encrypt the data with the key
    //

    memcpy( pEncryptedHwid, pHwid, sizeof( HWID ) );

    rc4( &Key, sizeof( HWID ), pEncryptedHwid );
    *pcbEncryptedHwid = sizeof( HWID );

    return( Status );
}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
CALL_TYPE
LicenseDecryptHwid(
    PHWID pHwid,
    DWORD cbEncryptedHwid,
    BYTE FAR * pEncryptedHwid,
    DWORD cbSecretKey,
    BYTE FAR * pSecretKey )
{
    LICENSE_STATUS              Status = LICENSE_STATUS_OK;
        struct RC4_KEYSTRUCT    Key;

    assert( pHwid );
    assert( cbEncryptedHwid );
    assert( pEncryptedHwid );
    assert( cbSecretKey );
    assert( pSecretKey );

    if( ( NULL == pHwid ) ||
        ( sizeof( HWID ) > cbEncryptedHwid ) ||
        ( NULL == pEncryptedHwid ) ||
        ( LICENSE_SESSION_KEY != cbSecretKey ) ||
        ( NULL == pSecretKey ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // Initialize the key
    //

    memset( &Key, 0x00, sizeof( struct RC4_KEYSTRUCT ) );
    rc4_key(&Key, LICENSE_SESSION_KEY, pSecretKey);

    //
    // Now decrypt the data with the key
    //

    memcpy( ( BYTE FAR * )pHwid, pEncryptedHwid, sizeof( HWID ) );
    rc4( &Key, sizeof( HWID ), ( BYTE FAR * )pHwid );

    return( Status );
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
CALL_TYPE
UnpackHydraServerCertificate(
    BYTE FAR *                          pbMessage,
        DWORD                           cbMessage,
        PHydra_Server_Cert      pCanonical )
{
        LICENSE_STATUS          lsReturn = LICENSE_STATUS_OK;
        BYTE FAR *      pbTemp = NULL;
        DWORD   dwTemp = 0;

        if( (pbMessage == NULL) || (pCanonical == NULL ) )
        {
                lsReturn = LICENSE_STATUS_INVALID_INPUT;
                goto ErrorReturn;
        }

        dwTemp = 3*sizeof(DWORD) + 4*sizeof(WORD);

        if(dwTemp > cbMessage)
        {
                lsReturn = LICENSE_STATUS_INVALID_INPUT;
                goto ErrorReturn;
        }

        pbTemp = pbMessage;
        dwTemp = cbMessage;

        //Assign dwVersion
        pCanonical->dwVersion = *( UNALIGNED DWORD* )pbTemp;
        pbTemp += sizeof(DWORD);
        dwTemp -= sizeof(DWORD);

        //Assign dwSigAlgID
        pCanonical->dwSigAlgID = *( UNALIGNED DWORD* )pbTemp;
        pbTemp += sizeof(DWORD);
        dwTemp -= sizeof(DWORD);

        //Assign dwSignID
        pCanonical->dwKeyAlgID  = *( UNALIGNED DWORD* )pbTemp;
        pbTemp += sizeof(DWORD);
        dwTemp -= sizeof(DWORD);

        //Assign PublicKeyData
        pCanonical->PublicKeyData.wBlobType = *( UNALIGNED WORD* )pbTemp;
        pbTemp += sizeof(WORD);
        dwTemp -= sizeof(WORD);

        if( pCanonical->PublicKeyData.wBlobType != BB_RSA_KEY_BLOB )
        {
                lsReturn = LICENSE_STATUS_INVALID_INPUT;
                goto ErrorReturn;
        }
        pCanonical->PublicKeyData.wBlobLen = *( UNALIGNED WORD* )pbTemp;
        pbTemp += sizeof(WORD);
        dwTemp -= sizeof(WORD);

        if(pCanonical->PublicKeyData.wBlobLen >0)
        {
                if( NULL ==(pCanonical->PublicKeyData.pBlob = (BYTE FAR *)malloc(pCanonical->PublicKeyData.wBlobLen)) )
                {
                        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
                        goto ErrorReturn;
                }
                memset(pCanonical->PublicKeyData.pBlob, 0x00, pCanonical->PublicKeyData.wBlobLen);
                memcpy(pCanonical->PublicKeyData.pBlob, pbTemp, pCanonical->PublicKeyData.wBlobLen);
                pbTemp += pCanonical->PublicKeyData.wBlobLen;
                dwTemp -= pCanonical->PublicKeyData.wBlobLen;
        }

        //Assign SignatureBlob
        pCanonical->SignatureBlob.wBlobType = *( UNALIGNED WORD* )pbTemp;
        pbTemp += sizeof(WORD);
        dwTemp -= sizeof(WORD);

        if( pCanonical->SignatureBlob.wBlobType != BB_RSA_SIGNATURE_BLOB )
        {
                lsReturn = LICENSE_STATUS_INVALID_INPUT;
                goto ErrorReturn;
        }
        pCanonical->SignatureBlob.wBlobLen = *( UNALIGNED WORD* )pbTemp;
        pbTemp += sizeof(WORD);
        dwTemp -= sizeof(WORD);

        if(pCanonical->SignatureBlob.wBlobLen >0)
        {
                if( NULL ==(pCanonical->SignatureBlob.pBlob = (BYTE FAR *)malloc(pCanonical->SignatureBlob.wBlobLen)) )
                {
                        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
                        goto ErrorReturn;
                }
                memset(pCanonical->SignatureBlob.pBlob, 0x00, pCanonical->SignatureBlob.wBlobLen);
                memcpy(pCanonical->SignatureBlob.pBlob, pbTemp, pCanonical->SignatureBlob.wBlobLen);
                pbTemp += pCanonical->SignatureBlob.wBlobLen;
                dwTemp -= pCanonical->SignatureBlob.wBlobLen;
        }
CommonReturn:
        return lsReturn;
ErrorReturn:
        if(pCanonical->PublicKeyData.pBlob)
        {
                free(pCanonical->PublicKeyData.pBlob);
                pCanonical->PublicKeyData.pBlob = NULL;
        }
        if(pCanonical->SignatureBlob.pBlob)
        {
                free(pCanonical->SignatureBlob.pBlob);
                pCanonical->SignatureBlob.pBlob = NULL;
        }
        memset(pCanonical, 0x00, sizeof(Hydra_Server_Cert));
        goto CommonReturn;
}


LICENSE_STATUS
CALL_TYPE
CreateHWID(
           PHWID phwid )
{
#ifdef OS_WINCE
    UUID    uuid;
#endif // OS_WINCE

    OSVERSIONINFO osvInfo;

    if( phwid == NULL )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    memset( phwid, 0x00, sizeof( HWID ) );

#ifdef OS_WINCE

    phwid->dwPlatformID = PLATFORM_WINCE_20;

    if (! OEMGetUUID(&uuid))
    {
        RETAILMSG( 1, ( TEXT( "Unable to get UUID from OEMGetUUID %d\r\n" ), GetLastError() ) );
        return ( LICENSE_STATUS_UNSPECIFIED_ERROR );
    }
    else
    {
        memcpy( &phwid->Data1, &uuid, sizeof(UUID) );

        return( LICENSE_STATUS_OK );
    }

#endif // OS_WINCE

    //
    // use Win32 platform ID
    //

    memset( &osvInfo, 0, sizeof( OSVERSIONINFO ) );
    osvInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
    GetVersionEx( &osvInfo );

    phwid->dwPlatformID = osvInfo.dwPlatformId;


    GenerateRandomBits( ( BYTE FAR * )&( phwid->Data1 ), sizeof( DWORD ) );
    GenerateRandomBits( ( BYTE FAR * )&( phwid->Data2 ), sizeof( DWORD ) );
    GenerateRandomBits( ( BYTE FAR * )&( phwid->Data3 ), sizeof( DWORD ) );
    GenerateRandomBits( ( BYTE FAR * )&( phwid->Data4 ), sizeof( DWORD ) );

    return ( LICENSE_STATUS_OK );
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
CALL_TYPE
GenerateClientHWID(
    PHWID   phwid )
{
    HKEY    hKey = NULL;
    LONG    lStatus = 0;
    DWORD   dwDisposition = 0;
    DWORD   dwValueType = 0;
    DWORD   cbHwid = sizeof(HWID);
    BOOL    fReadOnly = FALSE;
    LICENSE_STATUS LicStatus = LICENSE_STATUS_OK;

    if( phwid == NULL )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    memset( phwid, 0x00, sizeof( HWID ) );

    //
    // Try and open the HWID registry key.  If it doesn't already exist then create it.
    //

    lStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            TEXT( "Software\\Microsoft\\MSLicensing\\HardwareID" ),
                            0,
                            KEY_READ,
                            &hKey );

    if( ERROR_SUCCESS != lStatus )
    {
        lStatus = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                              TEXT( "Software\\Microsoft\\MSLicensing\\HardwareID" ),
                              0,
                              TEXT( "Client HWID" ),
                              REG_OPTION_NON_VOLATILE,
                              KEY_READ | KEY_WRITE,
                              NULL,
                              &hKey,
                              &dwDisposition );
    }
    else
    {
        //
        // Indicate that we have opened an existing key read-only
        //

        fReadOnly = TRUE;
        dwDisposition = REG_OPENED_EXISTING_KEY;
    }

    if( lStatus != ERROR_SUCCESS )
    {
        return( LICENSE_STATUS_OPEN_STORE_ERROR );
    }

    //
    // If the key exists, then first try to Read the value of ClientHWID
    //

    if ( dwDisposition == REG_OPENED_EXISTING_KEY )
    {

        lStatus = RegQueryValueEx( hKey, TEXT( "ClientHWID" ), 0, &dwValueType, (PVOID)phwid, &cbHwid );
    }

    if( ( dwDisposition == REG_CREATED_NEW_KEY) || (lStatus != ERROR_SUCCESS) || (cbHwid != sizeof(HWID)) )
    {
        //
        // error reading the HWID value, generate a new one.
        //

        if (fReadOnly)
        {
            //
            // Try to re-open the key read-write
            //

            RegCloseKey(hKey);

            lStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                    TEXT( "Software\\Microsoft\\MSLicensing\\HardwareID" ),
                                    0,
                                    KEY_READ | KEY_WRITE,
                                    &hKey );

            if (lStatus != ERROR_SUCCESS)
            {
                return( LICENSE_STATUS_OPEN_STORE_ERROR );
            }
        }

        LicStatus = CreateHWID(phwid);
        if (LicStatus != LICENSE_STATUS_OK)
        {
            goto cleanup;
        }

        lStatus = RegSetValueEx( hKey, TEXT( "ClientHWID" ), 0, REG_BINARY, ( BYTE FAR * )phwid, sizeof( HWID ) );

        if( lStatus != ERROR_SUCCESS )
        {
            LicStatus = LICENSE_STATUS_WRITE_STORE_ERROR;

            goto cleanup;
        }
    }

cleanup:

    if (NULL != hKey)
        RegCloseKey( hKey );

    return( LicStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\certlib\licecert\x509.h ===
/*++

Copyright (c) 1998-99  Microsoft Corporation

Module Name:

    x509.h

Abstract:


Author:

    Frederick Chong (dbarlow) 5/28/1998

Environment:



Notes:



--*/


#ifndef _X509_H_
#define _X509_H_
#include <MSAsnLib.h>


//
//==============================================================================
//
//  Attribute
//

class Attribute
:   public CAsnSequence
{
public:
    Attribute(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    CAsnObjectIdentifier attributeType;
    CAsnAny attributeValue;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  Attributes
//

class Attributes
:   public CAsnSetOf
{
public:
    Attributes(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    virtual Attribute &
    operator[](int index) const
    { return *(Attribute *)m_rgEntries[index]; };

    Attribute m_asnEntry1;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  UniqueIdentifier
//

class UniqueIdentifier
:   public CAsnSequence
{
public:
    UniqueIdentifier(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    CAsnObjectIdentifier attributeType;
    CAsnOctetstring attributeValue;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  RelativeDistinguishedName
//

class RelativeDistinguishedName
:   public Attributes
{
public:
    RelativeDistinguishedName(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  Name
//

class Name
:   public CAsnSequenceOf
{
public:
    Name(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    virtual RelativeDistinguishedName &
    operator[](int index) const
    { return *(RelativeDistinguishedName *)m_rgEntries[index]; };

    RelativeDistinguishedName m_asnEntry1;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  Validity
//

class Validity
:   public CAsnSequence
{
public:
    Validity(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    CAsnUniversalTime notBefore;
    CAsnUniversalTime notAfter;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  AlgorithmIdentifier
//

class AlgorithmIdentifier
:   public CAsnSequence
{
public:
    AlgorithmIdentifier(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    CAsnObjectIdentifier algorithm;
    CAsnAny parameters;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};

class SubjectPublicKeyInfo
:   public CAsnSequence
{
public:
    SubjectPublicKeyInfo(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    AlgorithmIdentifier algorithm;
    CAsnBitstring subjectPublicKey;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  Extension
//

class Extension
:   public CAsnSequence
{
public:
    Extension(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    CAsnObjectIdentifier extnid;
    CAsnBoolean critical;
    CAsnOctetstring extnValue;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  Extensions
//

class Extensions
:   public CAsnSequenceOf
{
public:
    Extensions(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    virtual Extension &
    operator[](int index) const
    { return *(Extension *)m_rgEntries[index]; };

    Extension m_asnEntry1;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  CertificateToBeSigned
//

class CertificateToBeSigned
:   public CAsnSequence
{
public:
    CertificateToBeSigned(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    CAsnTag _tag1;
    CAsnInteger version;
    CAsnInteger serialNumber;
    AlgorithmIdentifier signature;
    Name issuer;
    Validity validity;
    Name subject;
    SubjectPublicKeyInfo subjectPublicKeyInfo;
    UniqueIdentifier issuerUniqueID;
    UniqueIdentifier subjectUniqueID;
    CAsnTag _tag2;
    Extensions extensions;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  Certificate
//

class Certificate
:   public CAsnSequence
{
public:
    Certificate(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    CertificateToBeSigned toBeSigned;
    AlgorithmIdentifier algorithm;
    CAsnBitstring signature;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};



//
//==============================================================================
//
//  CRLEntry
//

class CRLEntry
:   public CAsnSequence
{
public:
    CRLEntry(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    CAsnInteger userCertificate;
    CAsnUniversalTime revocationDate;
    Extensions crlEntryExtensions;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  RevokedCertificates
//

class RevokedCertificates
:   public CAsnSequenceOf
{
public:
    RevokedCertificates(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    virtual CRLEntry &
    operator[](int index) const
    { return *(CRLEntry *)m_rgEntries[index]; };

    CRLEntry m_asnEntry1;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  CertificateRevocationListToBeSigned
//

class CertificateRevocationListToBeSigned
:   public CAsnSequence
{
public:
    CertificateRevocationListToBeSigned(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    CAsnInteger version;
    AlgorithmIdentifier signature;
    Name issuer;
    CAsnUniversalTime lastUpdate;
    CAsnUniversalTime nextUpdate;
    RevokedCertificates revokedCertificates;
    CAsnTag _tag1;
    Extensions crlExtensions;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};


//
//==============================================================================
//
//  CertificateRevocationList
//

class CertificateRevocationList
:   public CAsnSequence
{
public:
    CertificateRevocationList(
        DWORD dwFlags = 0,
        DWORD dwTag = tag_Undefined);

    CertificateRevocationListToBeSigned toBeSigned;
    AlgorithmIdentifier algorithm;
    CAsnBitstring signature;

// protected:
    virtual CAsnObject *
    Clone(
        DWORD dwFlags)
    const;
};

#endif  // _X509_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\cryptkey\cryptkey.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    core.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Madan Appiah - Sep. 5th 1997

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

C_DEFINES = \
    $(C_DEFINES) \
    $(CLIENT_EXE_CDEFS)

#
# List of sources
#

SOURCES_PLATFORM =

CLIENT_SOURCES_RC = \

CLIENT_SOURCES_COMMON = \
    cryptkey.c

CLIENT_SOURCES_LAST  = \

SOURCES = \
    $(CLIENT_SOURCES_RC) \
    $(SOURCES_PLATFORM) \
    $(CLIENT_SOURCES_COMMON) \
    $(CLIENT_SOURCES_LAST)

#
# Precompiled specs
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\licdebug\debuglib.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    core.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Madan Appiah - Sep. 5th 1997

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

C_DEFINES = \
    $(C_DEFINES) \
    $(CLIENT_EXE_CDEFS)

#
# List of sources
#

SOURCES_PLATFORM =

CLIENT_SOURCES_RC = \

CLIENT_SOURCES_COMMON = \
    licdbg.c

CLIENT_SOURCES_LAST  = \

SOURCES = \
    $(CLIENT_SOURCES_RC) \
    $(SOURCES_PLATFORM) \
    $(CLIENT_SOURCES_COMMON) \
    $(CLIENT_SOURCES_LAST)

#
# Precompiled specs
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\licdebug\licdbg.c ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1999
//
// File:        licdbg.c
//
// Contents:    
//
// History:     
//              
//              
//---------------------------------------------------------------------------

#if DBG         /* NOTE:  This file not compiled for retail builds */


#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <tchar.h>
#include "license.h"

#include "licdbg.h"


#ifndef min
#define min(x,y) ((x)<(y)?(x):(y))
#endif


DWORD   LicenseTraceIndent = 0;
DWORD   g_dwInfoLevel      = 0;


#define MAX_DEBUG_BUFFER 2048


// This function simply outputs information to the debugging log file handle.

void
//CALL_TYPE
LicenseDebugOutput(char *szOutString)
{
#ifndef NO_DEBUG
#ifndef OS_WINCE
    OutputDebugStringA(szOutString);
#else
    WCHAR szStr[MAX_DEBUG_BUFFER];
    if (MultiByteToWideChar(CP_ACP, 0, szOutString, -1, szStr, MAX_DEBUG_BUFFER) > 0)
        OutputDebugString(szStr);
#endif
#endif  //NO_DEBUG

}



void
//CALL_TYPE
DbgDumpHexString(const unsigned char *String, DWORD cbString)
{

#ifndef NO_DEBUG
    unsigned int i;

    for (i = 0; i < cbString; i++)
    {

    char *pch;
    char ach[9];

#ifndef OS_WINCE
    pch = &ach[wsprintf(ach,  "%2.2x", String[i])];
#else
    pch = &ach[sprintf(ach,  "%2.2x", String[i])];
#endif
//  LS_ASSERT(pch - ach <= sizeof(ach) - 4);


    if ((i & 1) == 1)
    {
        *pch++ = ' ';
    }
    if ((i & 7) == 7)
    {
        *pch++ = ' ';
    }
    if ((i & 15) == 15)
    {
        *pch++ = '\n';
    }
    *pch = '\0';
    LicenseDebugOutput(ach);
    }
#endif  //NO_DEBUG

}

#ifndef NO_DEBUG
char *aszLSDebugLevel[] = {
    "Error  ",
    "Warning",
    "Trace  ",
    "Mem    ",
    "Result "
};
#endif  //NO_DEBUG

void
//CALL_TYPE
LicenseDebugLog(long Mask, const char *Format, ...)
{
#ifndef NO_DEBUG
    va_list ArgList;
    int     Level = 0;
    int     PrefixSize = 0;
    int     iOut;
    char    szOutString[MAX_DEBUG_BUFFER];
    long    OriginalMask = Mask;

    if (Mask )//& g_dwInfoLevel)
    {
        while (!(Mask & 1))
        {
            Level++;
            Mask >>= 1;
        }
        if (Level >= sizeof(aszLSDebugLevel) / sizeof(char *))
        {
            Level = sizeof(aszLSDebugLevel) / sizeof(char *) - 1;
        }
        // Make the prefix first:  "Process.Thread> GINA-XXX"

#ifndef OS_WINCE
        iOut = wsprintf(
                szOutString,
                "%3d.%3d> %s: ",
                GetCurrentProcessId(),
                GetCurrentThreadId(),
                aszLSDebugLevel[Level]);
#else
        iOut = sprintf(
                szOutString,
                "%3d.%3d> %s: ",
                GetCurrentProcessId(),
                GetCurrentThreadId(),
                aszLSDebugLevel[Level]);
#endif

        PrefixSize = min(60, LicenseTraceIndent * 3);
#ifndef OS_WINCE
        FillMemory(szOutString+iOut, PrefixSize, ' ');
#else
        memset(szOutString+iOut, PrefixSize, ' ');
#endif
        PrefixSize += iOut;
        szOutString[PrefixSize] = '\0';

        va_start(ArgList, Format);

#ifndef OS_WINCE
        if (wvsprintf(&szOutString[PrefixSize], Format, ArgList) < 0)
#else
        if (vsprintf(&szOutString[PrefixSize], Format, ArgList) < 0)
#endif

        {
            static char szOverFlow[] = "\n<256 byte OVERFLOW!>\n";

            // Less than zero indicates that the string would not fit into the
            // buffer.  Output a special message indicating overflow.

#ifndef OS_WINCE
            lstrcpy(
            &szOutString[sizeof(szOutString) - sizeof(szOverFlow)],
            szOverFlow);
#else
            strcpy(
            &szOutString[sizeof(szOutString) - sizeof(szOverFlow)],
            szOverFlow);
#endif
        }
        va_end(ArgList);
        LicenseDebugOutput(szOutString);
    }
#endif  //NO_DEBUG
}


long
//CALL_TYPE    
LicenseLogErrorCode(
    long err, 
    const char *szFile, 
    long lLine)
{
#ifndef NO_DEBUG
    char *szName = "Unknown";

    switch(err)
    {
    case LICENSE_STATUS_OK: szName = "LICENSE_STATUS_OK"; break;
    case LICENSE_STATUS_OUT_OF_MEMORY: szName = "LICENSE_STATUS_OUT_OF_MEMORY"; break;
    case LICENSE_STATUS_INSUFFICIENT_BUFFER: szName = "LICENSE_STATUS_INSUFFICIENT_BUFFER"; break;
    case LICENSE_STATUS_INVALID_INPUT: szName = "LICENSE_STATUS_INVALID_INPUT"; break;
    case LICENSE_STATUS_INVALID_CLIENT_CONTEXT: szName = "LICENSE_STATUS_INVALID_CLIENT_CONTEXT"; break;
    case LICENSE_STATUS_INITIALIZATION_FAILED: szName = "LICENSE_STATUS_INITIALIZATION_FAILED"; break;
    case LICENSE_STATUS_INVALID_SIGNATURE: szName = "LICENSE_STATUS_INVALID_SIGNATURE"; break;
    case LICENSE_STATUS_INVALID_CRYPT_STATE: szName = "LICENSE_STATUS_INVALID_CRYPT_STATE"; break;

    case LICENSE_STATUS_CONTINUE: szName = "LICENSE_STATUS_CONTINUE"; break;
    case LICENSE_STATUS_ISSUED_LICENSE: szName = "LICENSE_STATUS_ISSUED_LICENSE"; break;
    case LICENSE_STATUS_CLIENT_ABORT: szName = "LICENSE_STATUS_CLIENT_ABORT"; break;
    case LICENSE_STATUS_SERVER_ABORT: szName = "LICENSE_STATUS_SERVER_ABORT"; break;
    case LICENSE_STATUS_NO_CERTIFICATE: szName = "LICENSE_STATUS_NO_CERTIFICATE"; break;
    case LICENSE_STATUS_NO_PRIVATE_KEY: szName = "LICENSE_STATUS_NO_PRIVATE_KEY"; break;
    case LICENSE_STATUS_SEND_ERROR: szName = "LICENSE_STATUS_SEND_ERROR"; break;
    case LICENSE_STATUS_INVALID_RESPONSE: szName = "LICENSE_STATUS_INVALID_RESPONSE"; break;
    case LICENSE_STATUS_CONTEXT_INITIALIZATION_ERROR: szName = "LICENSE_STATUS_CONTEXT_INITIALIZATION_ERROR"; break;
    case LICENSE_STATUS_NO_MESSAGE: szName = "LICENSE_STATUS_NO_MESSAGE"; break;
    case LICENSE_STATUS_INVALID_CLIENT_STATE: szName = "LICENSE_STATUS_INVALID_CLIENT_STATE"; break;
    case LICENSE_STATUS_OPEN_STORE_ERROR: szName = "LICENSE_STATUS_OPEN_STORE_ERROR"; break;
    case LICENSE_STATUS_CLOSE_STORE_ERROR: szName = "LICENSE_STATUS_CLOSE_STORE_ERROR"; break;
    case LICENSE_STATUS_NO_LICENSE_ERROR: szName = "LICENSE_STATUS_NO_LICENSE_ERROR"; break;
    case LICENSE_STATUS_INVALID_STORE_HANDLE: szName = "LICENSE_STATUS_INVALID_STORE_HANDLE"; break;
    case LICENSE_STATUS_DUPLICATE_LICENSE_ERROR: szName = "LICENSE_STATUS_DUPLICATE_LICENSE_ERROR"; break;
    case LICENSE_STATUS_INVALID_MAC_DATA: szName = "LICENSE_STATUS_INVALID_MAC_DATA"; break;
    case LICENSE_STATUS_INCOMPLETE_MESSAGE: szName = "LICENSE_STATUS_INCOMPLETE_MESSAGE"; break;
    case LICENSE_STATUS_RESTART_NEGOTIATION: szName = "LICENSE_STATUS_RESTART_NEGOTIATION"; break;
    }

    LicenseDebugLog(LS_LOG_RES, "Result: %s (0x%lx) - %s, Line %d\n", szName, err, szFile, lLine);

    return err;
#endif  //NO_DEBUG
    return 0;
}


void
//CALL_TYPE
LSAssert(
    void * FailedAssertion,
    void * FileName,
    unsigned long LineNumber,
    char * Message)
{
#ifndef NO_DEBUG
    LicenseDebugLog(LS_LOG_ERROR, 
               "Assertion FAILED, %s, %s : %d\n", 
               FailedAssertion,
               FileName,
               LineNumber);
#endif  //NO_DEBUG

}



#endif /* DEBUG */ /* NOTE:  This file not compiled for retail builds */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\hclient\liclient\cliprot.c ===
/*++

Copyright (c) 1998-99  Microsoft Corporation

Module Name:

    cliprot.c

Abstract:

Author:

    Frederick Chong (fredch) 6/1/1998

Environment:

    Win32, WinCE, Win16

Notes:

--*/

#include "windows.h"
#ifndef OS_WINCE
#include "stdio.h"
#endif // OS_WINCE
#include "stdlib.h"

#ifdef OS_WINCE
#include "wincelic.h"
#endif  //OS_WINCE

#include "tchar.h"

#include "lmcons.h"

#include "seccom.h"

#include "cryptkey.h"
#include "hccontxt.h"
#include "cliprot.h"
#include "hcpack.h"
#include "store.h"
#include "licdbg.h"
#include "platform.h"
#include "licecert.h"

#ifdef _WIN64

#define OFFSET_OF(type, field)    ((LONG)(LONG_PTR)&(((type *)0)->field))

#else

#define OFFSET_OF(type, field)    ((LONG)(LONG *)&(((type *)0)->field))

#endif

#define MAX_ALLOWABLE_LICENSE_SIZE (256 * 1024)
#define EXTENDED_ERROR_CAPABILITY 0x80


VOID
FreeProprietaryCertificate(
    PHydra_Server_Cert * ppCertificate );

static BOOL GeneratePseudoLicense(DWORD FAR * pcbData , PBYTE *ppbData);

static LICENSE_STATUS MapStoreError(LS_STATUS lsStatus)
{
    if(lsStatus == LSSTAT_SUCCESS)
        return LICENSE_STATUS_OK;
    if( (lsStatus == LSSTAT_ERROR) || (lsStatus == LSSTAT_INVALID_HANDLE) )
        return LICENSE_STATUS_INVALID_INPUT;
    if(lsStatus == LSSTAT_INSUFFICIENT_BUFFER)
        return LICENSE_STATUS_INSUFFICIENT_BUFFER;
    if(lsStatus == LSSTAT_LICENSE_NOT_FOUND)
        return LICENSE_STATUS_NO_LICENSE_ERROR;
    if(lsStatus == LSSTAT_OUT_OF_MEMORY)
        return LICENSE_STATUS_OUT_OF_MEMORY;
    if(lsStatus == LSSTAT_LICENSE_EXISTS)
        return LICENSE_STATUS_DUPLICATE_LICENSE_ERROR;

    return LICENSE_STATUS_INVALID_INPUT;
}


LICENSE_STATUS
CALL_TYPE
LicenseClientHandleServerMessage(
                     PLicense_Client_Context    pContext,
                     UINT32                     *puiExtendedErrorInfo,
                     BYTE FAR *                 pbInput,
                     DWORD                      cbInput,
                     BYTE FAR *                 pbOutput,
                     DWORD FAR *                pcbOutput
                     )
{
    LICENSE_STATUS      lsReturn = LICENSE_STATUS_OK;
    BYTE FAR            *pbTemp = NULL;
    DWORD               dwTemp = 0;
    Preamble            Header;
    BOOL                fNew = FALSE;
    BOOL                fSupportExtendedError = FALSE;

    if(NULL == pContext || NULL == pbInput || pcbOutput == NULL)
    {
        lsReturn = LICENSE_STATUS_INVALID_INPUT;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    pbTemp = pbInput;
    dwTemp = cbInput;
    
    Header = *( UNALIGNED Preamble*)pbTemp;

    //
    // check if we can support this preamble version
    //

    if( Header.bVersion > LICENSE_CURRENT_PREAMBLE_VERSION )
    {
        lsReturn = LICENSE_STATUS_NOT_SUPPORTED;
        goto CommonReturn;
    }

    //
    // Sets the preamble version to the version that the server is using
    //

   
    pContext->dwProtocolVersion |= Header.bVersion;

    if(pContext->dwProtocolVersion >= 2)
    {
        fSupportExtendedError = TRUE;
    }

    if( Header.wMsgSize != dwTemp)
    {
        License_Error_Message Error;
        memset(&Error, 0x00, sizeof(License_Error_Message));
        Error.dwErrorCode = GM_HS_ERR_INVALID_MESSAGE_LEN;
        Error.dwStateTransition = ST_RESEND_LAST_MESSAGE;
        Error.bbErrorInfo.wBlobType = BB_ERROR_BLOB;
        Error.bbErrorInfo.wBlobLen = 0;
        Error.bbErrorInfo.pBlob = NULL;
        
        DebugLog((DEB_TRACE, "Packing License Error Message from Client : %4d\n", *pcbOutput));
        PackLicenseErrorMessage(&Error, fSupportExtendedError, pbOutput, pcbOutput);
        
        lsReturn = LICENSE_STATUS_INVALID_INPUT;
        goto CommonReturn;
    }

    pbTemp += sizeof(Preamble);
    dwTemp -= sizeof(Preamble);

    switch(Header.bMsgType)
    {
    case GM_ERROR_ALERT:
        {
            License_Error_Message   Error;
            
            memset(&Error, 0x00, sizeof(License_Error_Message));
            
            DebugLog((DEB_TRACE, "Unpacking Hydra Server Error Message of size: %4d\n", dwTemp));
            if( LICENSE_STATUS_OK != (lsReturn = UnPackLicenseErrorMessage(pbTemp, 
                                                                           dwTemp,
                                                                           &Error)) )
            {
                LS_LOG_RESULT(lsReturn);
                goto ErrorReturn;
            }

            DebugLog((DEB_TRACE, "LicenseClientHandleServerError : %4d\n", *pcbOutput));
            lsReturn = LicenseClientHandleServerError(pContext, 
                                                      &Error,
                                                      puiExtendedErrorInfo,
                                                      pbOutput, 
                                                      pcbOutput);
            if(Error.bbErrorInfo.pBlob) 
            {
                free(Error.bbErrorInfo.pBlob);
                Error.bbErrorInfo.pBlob = NULL;
            }
#if DBG
            if(pbOutput)
                OutputDebugString(_T("Client response data : \n"));
            LS_DUMPSTRING(*pcbOutput, pbOutput);
#endif
                
            if( lsReturn == LICENSE_STATUS_OK ||
                lsReturn == LICENSE_STATUS_CONTINUE ||
                lsReturn == LICENSE_STATUS_CLIENT_ABORT ||
                lsReturn == LICENSE_STATUS_SERVER_ABORT )
                goto CommonReturn;
            else
            {
                LS_LOG_RESULT(lsReturn);
                goto ErrorReturn;
            }

            break;
        }
    case HS_LICENSE_REQUEST:
        {
            Hydra_Server_License_Request    LicRequest;
            DWORD                           dw;

            memset(&LicRequest, 0x00, sizeof(Hydra_Server_License_Request));
            
            DebugLog((DEB_TRACE, "Unpacking Hydra Server's License Request : %4d\n", dwTemp));
            if( LICENSE_STATUS_OK != (lsReturn = UnpackHydraServerLicenseRequest(pbTemp, 
                                                                                 dwTemp, 
                                                                                 &LicRequest)) )
            {
                LS_LOG_RESULT(lsReturn);
                goto ErrorReturn;
            }
            
            DebugLog((DEB_TRACE, "Client handles Server's license Request : %4d\n", *pcbOutput));
            
            lsReturn = LicenseClientHandleServerRequest(pContext, 
                                                        &LicRequest, 
                                                        TRUE, 
                                                        pbOutput, 
                                                        pcbOutput,
                                                        fSupportExtendedError);
#if DBG
            if(pbOutput)
                OutputDebugString(_T("Client response data : \n"));
            LS_DUMPSTRING(*pcbOutput, pbOutput);
#endif

            if(LicRequest.ProductInfo.pbCompanyName)
            {
                free(LicRequest.ProductInfo.pbCompanyName);
                LicRequest.ProductInfo.pbCompanyName = NULL;
            }
            if(LicRequest.ProductInfo.pbProductID)
            {
                free(LicRequest.ProductInfo.pbProductID);
                LicRequest.ProductInfo.pbProductID = NULL;
            }

            for(dw = 0; dw <LicRequest.ScopeList.dwScopeCount; dw++)
            {
                if(LicRequest.ScopeList.Scopes[dw].pBlob)
                {
                    free(LicRequest.ScopeList.Scopes[dw].pBlob);
                    LicRequest.ScopeList.Scopes[dw].pBlob = NULL;
                }
            }

            if(LicRequest.ScopeList.Scopes)
            {
                free(LicRequest.ScopeList.Scopes);
                LicRequest.ScopeList.Scopes = NULL;
            }

            if( LicRequest.KeyExchngList.pBlob )
            {
                free( LicRequest.KeyExchngList.pBlob );
            }

            if( LicRequest.ServerCert.pBlob )
            {
                free( LicRequest.ServerCert.pBlob );
            }

            if( lsReturn != LICENSE_STATUS_OK &&
                lsReturn != LICENSE_STATUS_CONTINUE &&
                lsReturn != LICENSE_STATUS_CLIENT_ABORT )
            {

                LS_LOG_RESULT(lsReturn);
                goto ErrorReturn;
            }
            break;
        }
    case HS_PLATFORM_CHALLENGE:
        {
            Hydra_Server_Platform_Challenge     PlatformCh;
            memset(&PlatformCh, 0x00, sizeof(Hydra_Server_Platform_Challenge));
            
            DebugLog((DEB_TRACE, "Unpacking Hydra Server's platform Challenge Request : %4d\n", dwTemp));
            if( LICENSE_STATUS_OK != (lsReturn = UnPackHydraServerPlatformChallenge(pbTemp, 
                                                                                    dwTemp, 
                                                                                    &PlatformCh)) )
            {
                LS_LOG_RESULT(lsReturn);
                goto ErrorReturn;
            }
            
            DebugLog((DEB_TRACE, "Client Handles Server's platform Challenge Response : %0d\n", *pcbOutput));
            lsReturn = LicenseClientHandleServerPlatformChallenge(pContext, 
                                                                 &PlatformCh, 
                                                                 pbOutput, 
                                                                 pcbOutput,
                                                                 fSupportExtendedError);
#if DBG
            if(pbOutput)
                OutputDebugString(_T("Client response data : \n"));
            LS_DUMPSTRING(*pcbOutput, pbOutput);
#endif

            if(PlatformCh.EncryptedPlatformChallenge.pBlob)
            {
                free(PlatformCh.EncryptedPlatformChallenge.pBlob);
                PlatformCh.EncryptedPlatformChallenge.pBlob = NULL;
            }
                
            if( lsReturn!=LICENSE_STATUS_CONTINUE )
            {
                LS_LOG_RESULT(lsReturn);
                goto ErrorReturn;
            }
            break;
        }
       
    case HS_NEW_LICENSE: 
            fNew = TRUE;
            DebugLog((DEB_TRACE, "New License received from Server.\n"));
    case HS_UPGRADE_LICENSE:
        {
            Hydra_Server_New_License    NewLicense;

            if (dwTemp > MAX_ALLOWABLE_LICENSE_SIZE)
            {
                //
                // SECURITY: Too much data to store in the registry
                // Reject the message
                //

                LS_LOG_RESULT(lsReturn = LICENSE_STATUS_INVALID_INPUT);
                goto ErrorReturn;
            }

            memset(&NewLicense, 0x00, sizeof(Hydra_Server_New_License));


            DebugLog((DEB_TRACE, "Unpacking Hydra Server's New License Message : %4d\n", dwTemp));

            if(LICENSE_STATUS_OK !=
                (lsReturn = UnPackHydraServerNewLicense(pbTemp, 
                                                        dwTemp, 
                                                        &NewLicense)) )
            {
                LS_LOG_RESULT(lsReturn);
                goto ErrorReturn;
            }

            DebugLog((DEB_TRACE, "License Client handles New License : %4d\n", *pcbOutput));
            lsReturn = LicenseClientHandleNewLicense(pContext, 
                                                     &NewLicense,
                                                     fNew,
                                                     pbOutput, 
                                                     pcbOutput);


            if(NewLicense.EncryptedNewLicenseInfo.pBlob)
            {
                free(NewLicense.EncryptedNewLicenseInfo.pBlob);
                NewLicense.EncryptedNewLicenseInfo.pBlob = NULL;
            }

#if DBG
            if(pbOutput)
                OutputDebugString(_T("Client response data : \n"));
            LS_DUMPSTRING(*pcbOutput, pbOutput);
#endif

            if( lsReturn != LICENSE_STATUS_OK )
            {
                LS_LOG_RESULT(lsReturn);
                goto ErrorReturn;
            }
            break;
        }
    default:
        //
        // Invalid message type
        //

        lsReturn = LICENSE_STATUS_INVALID_INPUT;
        goto ErrorReturn;
        break;
    }
    LS_LOG_RESULT(lsReturn);

CommonReturn:
    
    return lsReturn;
    LS_RETURN(lsReturn);

ErrorReturn:
    *pcbOutput = 0;

    goto CommonReturn;
}

LICENSE_STATUS
CALL_TYPE
LicenseClientHandleServerError(
                               PLicense_Client_Context  pContext,
                               PLicense_Error_Message   pCanonical,
                               UINT32                   *puiExtendedErrorInfo,
                               BYTE FAR *               pbMessage,
                               DWORD FAR *              pcbMessage
                               )
{
    LICENSE_STATUS      lsReturn = LICENSE_STATUS_OK;
    LS_BEGIN(TEXT("LicenseClientHandleServerError"));

    if(NULL == pContext || NULL == pCanonical || NULL == pcbMessage || NULL == puiExtendedErrorInfo)
    {
        lsReturn = LICENSE_STATUS_INVALID_INPUT;
        LS_LOG_RESULT(lsReturn);
        return lsReturn;        
    }
    
    // Switch on the StateTransition as this dictates the next state
    // client has to take!

    switch(pCanonical->dwStateTransition)
    {
    
    case ST_TOTAL_ABORT: //Server has asked for a total abort
        *pcbMessage = 0;
        if( pCanonical->dwErrorCode == GM_HS_ERR_INVALID_CLIENT ||
            pCanonical->dwErrorCode == GM_HS_ERR_INVALID_SCOPE  ||
            pCanonical->dwErrorCode == GM_HS_ERR_INVALID_PRODUCTID ||
            pCanonical->dwErrorCode == GM_HS_ERR_INVALID_CLIENT )
        {
            lsReturn = LICENSE_STATUS_SERVER_ABORT;
        }
        else
            lsReturn = LICENSE_STATUS_CLIENT_ABORT;

        pContext->dwState = LICENSE_CLIENT_STATE_ABORT;
        pContext->cbLastMessage = 0;
        break;
    
    case ST_NO_TRANSITION:
        lsReturn = LICENSE_STATUS_OK;
        *pcbMessage = 0;
        break;
    
    case ST_RESEND_LAST_MESSAGE:
        // Server has asked to send the last send message again!
        // treat as error (fall through)

    case ST_RESET_PHASE_TO_START:
        // Server has asked to restart the negotiation
        // treat as error (fall through)

    default:
        // Server sent unknown dwStateTransition

        lsReturn = LICENSE_STATUS_CLIENT_ABORT;
        pContext->dwState = LICENSE_CLIENT_STATE_ABORT;
        pContext->cbLastMessage = 0;
        break;

    }

    if ((lsReturn != LICENSE_STATUS_OK) && (pCanonical->bbErrorInfo.wBlobLen > 0) && (pCanonical->bbErrorInfo.pBlob != NULL))
    {
        // ignore any errors

        UnPackExtendedErrorInfo(puiExtendedErrorInfo,&(pCanonical->bbErrorInfo));
    }

    LS_LOG_RESULT(lsReturn);
    return lsReturn;
}

LICENSE_STATUS
CALL_TYPE
LicenseClientHandleServerRequest(
                               PLicense_Client_Context          pContext,
                               PHydra_Server_License_Request    pCanonical,
                               BOOL                             fNewLicense,
                               BYTE FAR *                       pbMessage,
                               DWORD FAR *                      pcbMessage,
                               BOOL                             fExtendedError
                               )
{
    LICENSE_STATUS      lsReturn = LICENSE_STATUS_OK;
    UCHAR               Random[LICENSE_RANDOM];
    UCHAR               PreMasterSecret[LICENSE_PRE_MASTER_SECRET];
    HANDLE      hStore = NULL;
    LSINDEX     lsIndex;
    DWORD       dwCount = 0;
    BYTE FAR *      pbData = NULL;
    DWORD       cbData = 0;

    LS_BEGIN(TEXT("LicenseClientHandleServerRequest"));

    memset(&lsIndex, 0x00, sizeof(LSINDEX));


    if( (pContext == NULL) || (pCanonical == NULL)  )
    {
        lsReturn = LICENSE_STATUS_INVALID_INPUT;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    if(pContext->dwState != LICENSE_CLIENT_STATE_WAIT_SERVER_HELLO)
    {
        lsReturn = LICENSE_STATUS_INVALID_CLIENT_STATE;
        goto ErrorReturn;
    }

    if( pContext->dwContextFlags & LICENSE_CONTEXT_NO_SERVER_AUTHENTICATION )
    {
        //
        // No server authentication required, make sure that we have the
        // public key or the certificate of the server so that we can use it to 
        // encrypt the pre-master secret during the next phase of the licensing protocol.
        // 
    
        if( ( NULL == pContext->pbServerPubKey ) && ( NULL == pContext->pServerCert ) )
        {
            lsReturn = LICENSE_STATUS_CONTEXT_INITIALIZATION_ERROR;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }
        
    }
    else
    {
        //
        // Do Hydra server authentication by validating the server certificate
        //
        
        DWORD
            dwCertVersion;

        if( ( 0 >= pCanonical->ServerCert.wBlobLen ) ||
            ( NULL == pCanonical->ServerCert.pBlob ) )
        {
            //
            // make sure that we have received a certificate from the server
            //

            lsReturn = LICENSE_STATUS_NO_CERTIFICATE;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }

        //
        // Determine the version of the certificate so that we can decode and
        // validate it correctly.
        //

        memcpy( ( char * )&dwCertVersion, pCanonical->ServerCert.pBlob, sizeof( DWORD ) );      
        
        if( CERT_CHAIN_VERSION_2 > dwCertVersion )
        {
            Hydra_Server_Cert ServerCert;

            //
            // Validate a proprietory certificate
            //

            memset( &ServerCert, 0, sizeof( ServerCert ) );

            if( !UnpackServerCert(pCanonical->ServerCert.pBlob,
                                  (DWORD)pCanonical->ServerCert.wBlobLen,
                                  &ServerCert) )
            {
                lsReturn = LICENSE_STATUS_UNSPECIFIED_ERROR;
                LS_LOG_RESULT(lsReturn);
                goto ErrorReturn;
            }
        
            //Now verify the signature on the server certificate

            if(!ValidateServerCert(&ServerCert) )
            {
                lsReturn = LICENSE_STATUS_UNSPECIFIED_ERROR;
                LS_LOG_RESULT(lsReturn);
                goto ErrorReturn;
            }
            else
            {
                //
                // free any old certificate and remember the new one.
                //

                if( pContext->pServerCert )
                {
                    FreeProprietaryCertificate( &pContext->pServerCert );
                }
            
                lsReturn = LicenseSetCertificate( 
                                        ( HANDLE )pContext,
                                        &ServerCert );

                if( LICENSE_STATUS_OK != lsReturn )
                {
                    LS_LOG_RESULT( lsReturn );
                    goto ErrorReturn;
                }
            }
        }
        else
        {
            DWORD
                fDates =  CERT_DATE_DONT_VALIDATE;

            //
            // X509 certificate
            //

            //
            // this first call finds out the memory required for the public key
            //

            lsReturn = VerifyCertChain( pCanonical->ServerCert.pBlob, 
                                        ( DWORD )pCanonical->ServerCert.wBlobLen,
                                        NULL, 
                                        &pContext->cbServerPubKey,
                                        &fDates );

            if( LICENSE_STATUS_INSUFFICIENT_BUFFER == lsReturn )
            {
                if( pContext->pbServerPubKey )
                {
                    free( pContext->pbServerPubKey );
                }

                pContext->pbServerPubKey = malloc( pContext->cbServerPubKey );

                if( NULL == pContext->pbServerPubKey )
                {
                    lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
                    LS_LOG_RESULT(lsReturn);
                    goto ErrorReturn;
                }

                lsReturn = VerifyCertChain( pCanonical->ServerCert.pBlob, 
                                            ( DWORD )pCanonical->ServerCert.wBlobLen,
                                            pContext->pbServerPubKey, 
                                            &pContext->cbServerPubKey,
                                            &fDates );
            }

            if( LICENSE_STATUS_OK != lsReturn )
            {
                LS_LOG_RESULT(lsReturn);
                goto ErrorReturn;
            }
        }
    }

    if(pContext->pCryptParam == NULL)
    {
        lsReturn = LICENSE_STATUS_INITIALIZATION_FAILED;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    
    //Copy Server Random to pCryptSystem->rgbServerRandom
    memcpy(pContext->pCryptParam->rgbServerRandom, pCanonical->ServerRandom, LICENSE_RANDOM);
    
    LicenseDebugOutput("Server Random : \n");
    LS_DUMPSTRING(LICENSE_RANDOM, pContext->pCryptParam->rgbServerRandom);

    //Generate 32 byte Client Random
    if (!TSRNG_GenerateRandomBits(Random, LICENSE_RANDOM))
    {
        lsReturn = LICENSE_STATUS_CONTEXT_INITIALIZATION_ERROR;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    //Copy ClientRandom to pContext->pCryptParam
    memcpy(pContext->pCryptParam->rgbClientRandom, Random, LICENSE_RANDOM);
    
    LicenseDebugOutput("Client Random : \n");
    LS_DUMPSTRING(LICENSE_RANDOM, pContext->pCryptParam->rgbClientRandom);
    
    //Generate 48 byte long PreMasterSecret
    if (!TSRNG_GenerateRandomBits(PreMasterSecret, LICENSE_PRE_MASTER_SECRET))
    {
        lsReturn = LICENSE_STATUS_CONTEXT_INITIALIZATION_ERROR;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    LicenseDebugOutput("Pre Master Secret : \n");
    LS_DUMPSTRING(LICENSE_PRE_MASTER_SECRET, PreMasterSecret);

    //Copy Premastersecret to pCryptParam
    lsReturn = LicenseSetPreMasterSecret(pContext->pCryptParam, PreMasterSecret);
    
    
    //Search in the store to find an appropriate License

    //To do that, first open the system store.
    if( LICENSE_STATUS_OK != (lsReturn = MapStoreError(LSOpenLicenseStore(&hStore, NULL, TRUE))) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    
    //Initialize lsIndex structure with the values sent by the Server
    lsIndex.dwVersion = pCanonical->ProductInfo.dwVersion;
    lsIndex.cbCompany = pCanonical->ProductInfo.cbCompanyName;

    if( NULL == (lsIndex.pbCompany = (LPSTR)malloc(lsIndex.cbCompany)) )
    {
        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    memset(lsIndex.pbCompany, 0x00, lsIndex.cbCompany); 
    memcpy(lsIndex.pbCompany, pCanonical->ProductInfo.pbCompanyName, lsIndex.cbCompany); 
    
    lsIndex.cbProductID = pCanonical->ProductInfo.cbProductID;

    if( NULL == (lsIndex.pbProductID = (LPSTR)malloc(lsIndex.cbProductID)) )
    {
        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    
    memset(lsIndex.pbProductID, 0x00, lsIndex.cbProductID); 
    memcpy(lsIndex.pbProductID, pCanonical->ProductInfo.pbProductID, lsIndex.cbProductID ); 
    
    for(dwCount=0; dwCount<pCanonical->ScopeList.dwScopeCount; dwCount ++)
    {
        DWORD dwProtVer = PREAMBLE_VERSION_1_0;
        lsIndex.cbScope = pCanonical->ScopeList.Scopes[dwCount].wBlobLen;
        if( NULL == (lsIndex.pbScope = (LPSTR)malloc(lsIndex.cbScope)) )
        {
            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            continue;
        }
        
        //Initialize pszScope member of the lsIndex with the ith element in the scopelist
        memset(lsIndex.pbScope, 0x00, lsIndex.cbScope);
        memcpy(lsIndex.pbScope, pCanonical->ScopeList.Scopes[dwCount].pBlob, lsIndex.cbScope);
                
        if( LICENSE_STATUS_OK != (lsReturn = MapStoreError(LSFindLicenseInStore(hStore, 
                                                                                &lsIndex, 
                                                                                &cbData, 
                                                                                NULL))) )
        {
            if(lsIndex.pbScope) 
            {
                free(lsIndex.pbScope);
                lsIndex.pbScope = NULL;
            }
            continue;
        }

        //
        // NOTE:  this line was previously
        // if(pContext->dwProtocolVersion != PREAMBLE_VERSION_2_0) for
        // Hydra 4.0 clients, which means that a pseudo license will be
        // generated for licensing protocol later than 2.0 as well!
        // To overcome this problem, Hydra 5.0 server will use the 
        // PREAMBLE_VERSION_2_0 for Hydra 4.0 clients.
        //

        if( GET_PREAMBLE_VERSION( pContext->dwProtocolVersion ) < PREAMBLE_VERSION_2_0)
        {
            if( !GeneratePseudoLicense(&cbData, &pbData) )
            {
                lsReturn = LICENSE_STATUS_UNSPECIFIED_ERROR;
                if(lsIndex.pbScope)
                {
                    free(lsIndex.pbScope);
                    lsIndex.pbScope = NULL;
                }
                goto ErrorReturn;
            }
            lsReturn = LICENSE_STATUS_OK;
            if(lsIndex.pbScope)
            {
                free(lsIndex.pbScope);
                lsIndex.pbScope = NULL;
            }
            break;
        }
        if(cbData == 0)
        {
            if(lsIndex.pbScope)
            {
                free(lsIndex.pbScope);
                lsIndex.pbScope = NULL;
            }
            continue;
        }   
        if( NULL == (pbData=(BYTE FAR *)malloc(cbData)) )
        {   
            if(lsIndex.pbScope)
            {
                free(lsIndex.pbScope);
                lsIndex.pbScope = NULL;
            }
            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            continue;
        }
        if( LICENSE_STATUS_OK != (lsReturn = MapStoreError(LSFindLicenseInStore(hStore, 
                                                                                &lsIndex, 
                                                                                &cbData, 
                                                                                pbData))) )
        {
            if(lsIndex.pbScope)
            {
                free(lsIndex.pbScope);
                lsIndex.pbScope = NULL;
            }
            continue;
        }
        
        LicenseDebugOutput("License Info Data : \n");
        LS_DUMPSTRING(cbData, pbData);

        lsReturn = LICENSE_STATUS_OK;
        if(lsIndex.pbScope)
        {
            free(lsIndex.pbScope);
            lsIndex.pbScope = NULL;
        }
        break;
    }

    //If a license is found in the store, then Continue with Hydra_Client_License_Info message
    if( LICENSE_STATUS_OK == lsReturn )
    {
        if( LICENSE_STATUS_CONTINUE != (lsReturn = ClientConstructLicenseInfo(pContext, 
                                                                        pbData, 
                                                                        cbData, 
                                                                        pbMessage, 
                                                                        pcbMessage,
                                                                        fExtendedError)) )
        {
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }
        goto CommonReturn;
    }

    //Else if no license if found, then depending on fNewLicense, either Request for a new license
    //or, abort connection

    else if(lsReturn == LICENSE_STATUS_NO_LICENSE_ERROR)
    {
        if(fNewLicense)
        {
            if( LICENSE_STATUS_CONTINUE != (lsReturn = ClientConstructNewLicenseRequest(pContext, 
                                                                                  pbMessage, 
                                                                                  pcbMessage,
                                                                                  fExtendedError)) )
            {
                LS_LOG_RESULT(lsReturn);
                goto ErrorReturn;
            }
            goto CommonReturn;
        }
        else    //Generate an error message and close connection
        {
            if( LICENSE_STATUS_CLIENT_ABORT != (lsReturn = ClientConstructErrorAlert(pContext, 
                                                                           GM_HC_ERR_NO_LICENSE, 
                                                                           ST_TOTAL_ABORT,
                                                                           NULL,
                                                                           0,
                                                                           pbMessage,
                                                                           pcbMessage,
                                                                           fExtendedError
                                                                           )) )
            {
                LS_LOG_RESULT(lsReturn);
                goto ErrorReturn;
            }
        }
    }

    LS_LOG_RESULT(lsReturn);

CommonReturn:

    //
    // close license store
    //
    
    if( hStore )
    {
        LSCloseLicenseStore(hStore);
        hStore = NULL;
    }
    
    if(pbData)
    {
        free(pbData);
        pbData = NULL;
    }
    if(lsIndex.pbCompany)
    {
        free(lsIndex.pbCompany);
        lsIndex.pbCompany = NULL;
    }
    if(lsIndex.pbProductID)
    {
        free(lsIndex.pbProductID);
        lsIndex.pbProductID = NULL;
    }
    if(lsIndex.pbScope)
    {
        free(lsIndex.pbScope);
        lsIndex.pbScope = NULL;
    }
    return lsReturn;
    //LS_RETURN(lsReturn);
ErrorReturn:
    *pcbMessage = 0;

    if( pContext != NULL)
    {
        if(pContext->pServerCert)
        {
            free(pContext->pServerCert);
            pContext->pServerCert = NULL;
        }

        if( pContext->pbServerPubKey )
        {
            free( pContext->pbServerPubKey );
            pContext->pbServerPubKey = NULL;
        }
    }

    goto CommonReturn;
}


LICENSE_STATUS
CALL_TYPE
LicenseClientHandleServerPlatformChallenge(
                               PLicense_Client_Context          pContext,
                               PHydra_Server_Platform_Challenge pCanonical,
                               BYTE FAR *                       pbMessage,
                               DWORD FAR *                      pcbMessage,
                               BOOL                             fExtendedError
                               )
{
    LICENSE_STATUS      lsReturn = LICENSE_STATUS_OK;
    Hydra_Client_Platform_Challenge_Response    Response;
    
    BYTE                MACData[LICENSE_MAC_DATA];
    HWID                hwid;
    BYTE FAR *          pbData = NULL;
    UCHAR *             LocalBuf = NULL;
    DWORD               cbData = 0;

    LS_BEGIN(TEXT("LicenseClientHandleServerPlatformChallenge"));


    if( (pContext == NULL) || (pCanonical == NULL) || (pcbMessage == NULL) )
    {
        lsReturn = LICENSE_STATUS_INVALID_INPUT;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }


    memset(&Response, 0x00, sizeof(Hydra_Client_Platform_Challenge_Response));

    
    if( (pContext->dwState != LICENSE_CLIENT_STATE_LICENSE_RESPONSE) &&
        (pContext->dwState != LICENSE_CLIENT_STATE_NEW_LICENSE_REQUEST) )
    {
        lsReturn = LICENSE_STATUS_INVALID_CLIENT_STATE;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    //First decrypt the encrypted platform challenge
    if( LICENSE_STATUS_OK != (lsReturn = LicenseDecryptSessionData(pContext->pCryptParam,
                                                                  pCanonical->EncryptedPlatformChallenge.pBlob,
                                                                  (DWORD)pCanonical->EncryptedPlatformChallenge.wBlobLen)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    
    //Generate the MAC with the decrypted platform Challenge
    if( LICENSE_STATUS_OK != (lsReturn = LicenseGenerateMAC(pContext->pCryptParam,
                                                            pCanonical->EncryptedPlatformChallenge.pBlob,
                                                            (DWORD)pCanonical->EncryptedPlatformChallenge.wBlobLen,
                                                           MACData
                                                           )) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    LicenseDebugOutput(" Client generated MAC data to verify Server's message Authenticity : \n");
    LS_DUMPSTRING(LICENSE_MAC_DATA, MACData);
    

    //Compare the generated MAC with the one sent by the server
    if( memcmp(MACData, pCanonical->MACData, LICENSE_MAC_DATA) )
    {
        lsReturn = LICENSE_STATUS_INVALID_MAC_DATA;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    //Generate Platform Challenge Response
    if( LICENSE_STATUS_OK != (lsReturn = ClientGenerateChallengeResponse(pContext,
                                                                         &pCanonical->EncryptedPlatformChallenge,
                                                                         &Response.EncryptedChallengeResponse)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;

    }

    //Generate HWID, Encrypt it using the Session key and put it in the Response
    memset(&hwid, 0x00, sizeof(HWID));
    if( LICENSE_STATUS_OK != (lsReturn = GenerateClientHWID(&hwid)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }


    //GenerateClientHWID(&hwid);
    LicenseDebugOutput("HWID in byte : \n");

    LS_DUMPSTRING(sizeof(HWID), (BYTE FAR *)&hwid);


    Response.EncryptedHWID.wBlobType = BB_DATA_BLOB;
    Response.EncryptedHWID.wBlobLen = sizeof(HWID);
    if( NULL == (Response.EncryptedHWID.pBlob = (BYTE FAR *)malloc(Response.EncryptedHWID.wBlobLen)) )
    {
        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    
    memset(Response.EncryptedHWID.pBlob, 0x00, Response.EncryptedHWID.wBlobLen);
    memcpy(Response.EncryptedHWID.pBlob, &hwid, Response.EncryptedHWID.wBlobLen);
    
    if( NULL == (LocalBuf = (UCHAR *)malloc(Response.EncryptedChallengeResponse.wBlobLen + 
        Response.EncryptedHWID.wBlobLen)) )
    {
        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    cbData += Response.EncryptedChallengeResponse.wBlobLen;
    memcpy(LocalBuf, Response.EncryptedChallengeResponse.pBlob, Response.EncryptedChallengeResponse.wBlobLen);
    memcpy(LocalBuf + cbData, Response.EncryptedHWID.pBlob, Response.EncryptedHWID.wBlobLen);
    cbData += Response.EncryptedHWID.wBlobLen;
    
    //Generate MACData and put it in the Response
    if( LICENSE_STATUS_OK != (lsReturn = LicenseGenerateMAC(pContext->pCryptParam,
                                                            LocalBuf,
                                                            cbData,
                                                            Response.MACData)) )
    {
        free(LocalBuf);
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    
    free(LocalBuf);

    //Now encrypt the platform challenge response using the negotiated session key
    if( LICENSE_STATUS_OK != (lsReturn = LicenseEncryptSessionData(pContext->pCryptParam,
                                                                   Response.EncryptedChallengeResponse.pBlob,
                                                                   Response.EncryptedChallengeResponse.wBlobLen
                                                                   )) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    //Encrypt the HWID with generated session key
    if( LICENSE_STATUS_OK != (lsReturn = LicenseEncryptSessionData(pContext->pCryptParam, 
                                                                   Response.EncryptedHWID.pBlob,
                                                                   (DWORD)Response.EncryptedHWID.wBlobLen)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    //Now we have our Platform challenge Response Ready. Pack the data in a byte stream
    if( LICENSE_STATUS_OK != (lsReturn = PackHydraClientPlatformChallengeResponse(&Response,
                                                                                  fExtendedError,
                                                                                  pbMessage,
                                                                                  pcbMessage)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    // Set appropriate state and data in proper places
    
    //Set the MACData in the CryptSystem MAC buffer.
    memcpy(pContext->rgbMACData, Response.MACData, LICENSE_MAC_DATA);
    
    //Set the state of the context to LICENSE_CLIENT_STATE_PLATFORM_CHALLENGE_RESPONSE
    //provided data was written in the  output. i.e pbMessage is not NULL

    if(pbMessage)
        pContext->dwState = LICENSE_CLIENT_STATE_PLATFORM_CHALLENGE_RESPONSE;

    //Copy the whole message to the context
    pContext->cbLastMessage = *pcbMessage;
    if(pbMessage)
    {
        if( pContext->pbLastMessage )
        {
            free( pContext->pbLastMessage );
        }

        if( NULL == (pContext->pbLastMessage = (BYTE FAR *)malloc(pContext->cbLastMessage)) )
        {
            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }
        memset(pContext->pbLastMessage, 0x00, pContext->cbLastMessage);
        memcpy(pContext->pbLastMessage, pbMessage, pContext->cbLastMessage);
    }

    lsReturn = LICENSE_STATUS_CONTINUE;

    LS_LOG_RESULT(lsReturn);                                                                         
CommonReturn:
    //LICENSE_LOG_RESULT(lsReturn);

    if(Response.EncryptedChallengeResponse.pBlob)
    {
        free(Response.EncryptedChallengeResponse.pBlob);
        Response.EncryptedChallengeResponse.pBlob = NULL;
    }
    if(Response.EncryptedHWID.pBlob)
    {
        free(Response.EncryptedHWID.pBlob);
        Response.EncryptedHWID.pBlob = NULL;
    }
    return lsReturn;
    //LS_RETURN(lsReturn);
ErrorReturn:
    *pcbMessage = 0;
    goto CommonReturn;
}

LICENSE_STATUS
CALL_TYPE
LicenseClientHandleNewLicense(
                               PLicense_Client_Context      pContext,
                               PHydra_Server_New_License    pCanonical,
                               BOOL                         fNew,
                               BYTE FAR *                   pbMessage,
                               DWORD FAR *                  pcbMessage
                               )
{
    LICENSE_STATUS      lsReturn = LICENSE_STATUS_OK;
    New_License_Info    NewLicense;
    BYTE                MACData[LICENSE_MAC_DATA];
    Binary_Blob         bbData;
    LSINDEX             lsIndex;
    HANDLE              hStore = NULL;

    LS_BEGIN(TEXT("LicenseClientHandleNewLicense"));

    if(NULL == pContext || NULL == pCanonical )
    {
        lsReturn = LICENSE_STATUS_INVALID_INPUT;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    memset(&bbData, 0x00, sizeof(Binary_Blob));
    memset(&NewLicense, 0x00, sizeof(New_License_Info));
    memset(&lsIndex, 0x00, sizeof(LSINDEX));

    //First decrypt the encrypted license info
    if( LICENSE_STATUS_OK != (lsReturn = LicenseDecryptSessionData(pContext->pCryptParam,
                                                                   pCanonical->EncryptedNewLicenseInfo.pBlob,
                                                                   ( DWORD )( pCanonical->EncryptedNewLicenseInfo.wBlobLen ))) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    //Generate the MAC data with the decrypted data
    if( LICENSE_STATUS_OK != (lsReturn = LicenseGenerateMAC(pContext->pCryptParam,
                                                            pCanonical->EncryptedNewLicenseInfo.pBlob,
                                                            (DWORD)pCanonical->EncryptedNewLicenseInfo.wBlobLen,
                                                            MACData)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    //Compare this MAC with the one sent by the Server.
    if(memcmp(MACData, pCanonical->MACData, LICENSE_MAC_DATA))
    {
        lsReturn = LICENSE_STATUS_INVALID_MAC_DATA;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    if( LICENSE_STATUS_OK != (lsReturn = UnpackNewLicenseInfo(pCanonical->EncryptedNewLicenseInfo.pBlob,
                                                             (DWORD)pCanonical->EncryptedNewLicenseInfo.wBlobLen,
                                                              &NewLicense)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    
    //Try to open the system license store
    if( LICENSE_STATUS_OK != (lsReturn = MapStoreError(LSOpenLicenseStore(&hStore, NULL, FALSE))) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }   
    
    //Initialize the LSINDEX structure. This structure will be used to add/replace a license in the store

    //To do that, first initialize version info
    lsIndex.dwVersion = NewLicense.dwVersion;

    //Initialize Scope info
    lsIndex.cbScope = NewLicense.cbScope;
    if( NULL == (lsIndex.pbScope = (LPSTR)malloc(lsIndex.cbScope)) )
    {
        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    memset(lsIndex.pbScope, 0x00, lsIndex.cbScope);
    memcpy(lsIndex.pbScope, NewLicense.pbScope, lsIndex.cbScope);
    

    //Initialize CompanyName info
    lsIndex.cbCompany = NewLicense.cbCompanyName;
    if( NULL == (lsIndex.pbCompany = (LPSTR)malloc(lsIndex.cbCompany)) )
    {
        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    memset(lsIndex.pbCompany, 0x00, lsIndex.cbCompany);
    memcpy(lsIndex.pbCompany, NewLicense.pbCompanyName, lsIndex.cbCompany);
    

    //Initialize ProductID info
    lsIndex.cbProductID = NewLicense.cbProductID;
    if( NULL == (lsIndex.pbProductID = (LPSTR)malloc(lsIndex.cbProductID)) )
    {
        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    memset(lsIndex.pbProductID, 0x00, lsIndex.cbProductID);
    memcpy(lsIndex.pbProductID, NewLicense.pbProductID, lsIndex.cbProductID);
    
    
    LS_LOG_RESULT(lsReturn);
    
    if( LICENSE_STATUS_OK != (lsReturn = LSAddLicenseToStore(hStore,
                                                             LS_REPLACE_LICENSE_OK,
                                                             &lsIndex,
                                                             NewLicense.pbLicenseInfo,
                                                             NewLicense.cbLicenseInfo
                                                             )) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    
    //Update state info and inform that the License Verification is over and the client can carry on 
    //with further connection!
    pContext->dwState = LICENSE_CLIENT_STATE_DONE;

    memset(pContext->rgbMACData, 0x00, LICENSE_MAC_DATA);

    //Reset the last send message to 0;
    if(pContext->pbLastMessage)
    {
        memset(pContext->pbLastMessage, 0x00, pContext->cbLastMessage);
        free(pContext->pbLastMessage);
        pContext->pbLastMessage = NULL;
    }
    pContext->cbLastMessage = 0;
    
    lsReturn = LICENSE_STATUS_OK;

CommonReturn:
    
    if( hStore )
    {
        LSCloseLicenseStore( hStore );
    }

    if(NewLicense.pbScope)
    {
        free(NewLicense.pbScope);
        NewLicense.pbScope = NULL;
    }
    
    if(NewLicense.pbCompanyName)
    {
        free(NewLicense.pbCompanyName);
        NewLicense.pbCompanyName = NULL;
    }

    if(NewLicense.pbProductID)
    {
        free(NewLicense.pbProductID);
        NewLicense.pbProductID = NULL;
    }

    if(NewLicense.pbLicenseInfo)
    {
        free(NewLicense.pbLicenseInfo);
        NewLicense.pbLicenseInfo = NULL;
    }

    if(lsIndex.pbScope)
    {
        free(lsIndex.pbScope);
        lsIndex.pbScope = NULL;
    }

    if(lsIndex.pbCompany)
    {
        free(lsIndex.pbCompany);
        lsIndex.pbCompany = NULL;
    }
    if(lsIndex.pbProductID)
    {
        free(lsIndex.pbProductID);
        lsIndex.pbProductID = NULL;
    }

    if(bbData.pBlob)
    {
        free(bbData.pBlob);
        bbData.pBlob = NULL;
    }

    return lsReturn;

ErrorReturn:
    goto CommonReturn;
}


LICENSE_STATUS 
CALL_TYPE
ClientConstructLicenseInfo(
                           PLicense_Client_Context  pContext,
                           BYTE FAR *               pbInput,
                           DWORD                    cbInput,
                           BYTE FAR *               pbOutput,
                           DWORD    FAR *           pcbOutput,
                           BOOL                     fExtendedError
                           )
{
    LICENSE_STATUS      lsReturn = LICENSE_STATUS_OK;
    Hydra_Client_License_Info   Canonical;
    HWID                        hwid;
    Binary_Blob                 bbPreMasterSecret;
    DWORD                       dwSize = 0;
    DWORD                       dwState = 0;
    PBYTE                       pbServerPubKey;
    DWORD                       cbServerPubKey;

    LS_BEGIN(TEXT("ClientContstructLicenseInfo"));

    if(NULL == pContext || NULL == pcbOutput)
    {
        lsReturn = LICENSE_STATUS_INVALID_INPUT;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }    
    
    //Construct the messages
    bbPreMasterSecret.wBlobType = BB_RANDOM_BLOB;
    bbPreMasterSecret.wBlobLen = LICENSE_PRE_MASTER_SECRET;
    if( NULL == (bbPreMasterSecret.pBlob = (BYTE FAR *)malloc(LICENSE_PRE_MASTER_SECRET)) )
    {
    
        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    memcpy(bbPreMasterSecret.pBlob, pContext->pCryptParam->rgbPreMasterSecret, LICENSE_PRE_MASTER_SECRET);
    memset(&Canonical, 0x00, sizeof(Hydra_Client_License_Info));

    //RSA is hardcoded for the time being
    Canonical.dwPrefKeyExchangeAlg = pContext->pCryptParam->dwKeyExchAlg;
    
#ifdef OS_WINCE
    Canonical.dwPlatformID =  CLIENT_OS_ID_OTHER | CLIENT_IMAGE_ID_MICROSOFT;
#else   // WinNT or Win9x
    {
        DWORD dwVersion = GetVersion();

        if (dwVersion & 0x80000000) {
            // Win95
            Canonical.dwPlatformID = CLIENT_OS_ID_OTHER | CLIENT_IMAGE_ID_MICROSOFT;
        } else {

            OSVERSIONINFOEX ovix;
            BOOL b;       
            ovix.dwOSVersionInfoSize = sizeof(ovix);
            b = GetVersionEx((LPOSVERSIONINFO) &ovix);            
            if(b && ((ovix.wSuiteMask & VER_SUITE_EMBEDDEDNT) || (ovix.wSuiteMask & VER_SUITE_PERSONAL)))
            {
                Canonical.dwPlatformID = CLIENT_OS_ID_WINNT_40 | CLIENT_IMAGE_ID_MICROSOFT;
            }            
            else
            {

                // WinNT
                Canonical.dwPlatformID = CLIENT_IMAGE_ID_MICROSOFT |
                    ((((DWORD)(LOBYTE(LOWORD(dwVersion)))) - 2) << 24);
			    
			    Canonical.dwPlatformID |= (DWORD)(HIBYTE(LOWORD(dwVersion)));
            }
		
        }
    }
#endif

    //ClientRandom
    memcpy(Canonical.ClientRandom, pContext->pCryptParam->rgbClientRandom, LICENSE_RANDOM);
    
    if( pContext->pServerCert )
    {
        //
        // This public key is used for pre-Hydra 5.0 servers that are using proprietory
        // server certificates.
        //

        pbServerPubKey = pContext->pServerCert->PublicKeyData.pBlob;
        cbServerPubKey = pContext->pServerCert->PublicKeyData.wBlobLen;
    }
    else
    {
        pbServerPubKey = pContext->pbServerPubKey;
        cbServerPubKey = pContext->cbServerPubKey;
    }

    //We have to switch here depending on the key exchange algorithm to be used -Shubho
    if( LICENSE_STATUS_OK != (lsReturn = LicenseEnvelopeData(pbServerPubKey,
                                                             cbServerPubKey,
                                                             bbPreMasterSecret.pBlob,
                                                             bbPreMasterSecret.wBlobLen,
                                                             NULL,
                                                             &dwSize)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    
    if( NULL == (Canonical.EncryptedPreMasterSecret.pBlob = (BYTE FAR *)malloc(dwSize)) )
    {
        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    
    memset(Canonical.EncryptedPreMasterSecret.pBlob, 0x00, dwSize);
    
    if( LICENSE_STATUS_OK != (lsReturn = LicenseEnvelopeData(pbServerPubKey,
                                                             cbServerPubKey,
                                                             bbPreMasterSecret.pBlob,
                                                             bbPreMasterSecret.wBlobLen,
                                                             Canonical.EncryptedPreMasterSecret.pBlob,
                                                             &dwSize)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    Canonical.EncryptedPreMasterSecret.wBlobLen = (WORD)dwSize;

    //Fill up LicenseInfo buffer
    Canonical.LicenseInfo.wBlobType = BB_DATA_BLOB;
    Canonical.LicenseInfo.wBlobLen = (WORD)cbInput;
    if( NULL == (Canonical.LicenseInfo.pBlob = (BYTE FAR *)malloc(Canonical.LicenseInfo.wBlobLen)) )
    {
        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    
    memset(Canonical.LicenseInfo.pBlob, 0x00, Canonical.LicenseInfo.wBlobLen);
    memcpy(Canonical.LicenseInfo.pBlob, pbInput, Canonical.LicenseInfo.wBlobLen);
    

    //Generate HWID and put the data in a binary_blob to encrypt
    memset(&hwid, 0x00, sizeof(HWID));
    
    if( LICENSE_STATUS_OK != (lsReturn = GenerateClientHWID(&hwid)) )
    {   
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    Canonical.EncryptedHWID.wBlobType = BB_DATA_BLOB;
    Canonical.EncryptedHWID.wBlobLen = sizeof(HWID);
    if( NULL == (Canonical.EncryptedHWID.pBlob = (BYTE FAR *)malloc(Canonical.EncryptedHWID.wBlobLen)) )
    {
        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    
    memset(Canonical.EncryptedHWID.pBlob, 0x00, Canonical.EncryptedHWID.wBlobLen);
    memcpy(Canonical.EncryptedHWID.pBlob, &hwid, Canonical.EncryptedHWID.wBlobLen);

    dwState = pContext->pCryptParam->dwCryptState;
    //Generate the session key and MACsalt
    if( LICENSE_STATUS_OK != (lsReturn = LicenseBuildMasterSecret(pContext->pCryptParam)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    if( LICENSE_STATUS_OK != (lsReturn = LicenseMakeSessionKeys(pContext->pCryptParam, 0)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    //Encrypt the HWID with generated session key
    if( LICENSE_STATUS_OK != (lsReturn = LicenseEncryptSessionData(pContext->pCryptParam, 
                                                                   Canonical.EncryptedHWID.pBlob,
                                                                   (DWORD)Canonical.EncryptedHWID.wBlobLen)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    //Generate the MAC with original HWID
    LicenseGenerateMAC(pContext->pCryptParam, ( BYTE FAR * )&hwid, sizeof(hwid), Canonical.MACData);
    
    //Now everything is ready, so pack the data 
    if( LICENSE_STATUS_OK != (lsReturn = PackHydraClientLicenseInfo(&Canonical, fExtendedError, pbOutput, pcbOutput)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    
    //Set the MACData in the CryptSystem MAC buffer.
    memcpy(pContext->rgbMACData, Canonical.MACData, LICENSE_MAC_DATA);
    
    //Set the state of the context to LICENSE_CLIENT_STATE_LICENSE_RESPONSE
    //if any output data is written. i.e. pbOutput is not null. Also revert back
    //the crypparam state as this will also be called twice and we change the state
    //only when we have written something in the output!!!!! - bad!!!!!
    if(pbOutput)
    {
        pContext->dwState = LICENSE_CLIENT_STATE_LICENSE_RESPONSE;
    }
    
    else    //Restore earlier CryptSystem States
    {
        pContext->pCryptParam->dwCryptState = dwState;
        memcpy(pContext->pCryptParam->rgbPreMasterSecret, bbPreMasterSecret.pBlob, LICENSE_PRE_MASTER_SECRET);
        memset(pContext->pCryptParam->rgbSessionKey, 0x00, LICENSE_SESSION_KEY);
        memset(pContext->pCryptParam->rgbMACSaltKey, 0x00, LICENSE_MAC_WRITE_KEY);
    }

    //Copy the whole message to the context
    pContext->cbLastMessage = *pcbOutput;
    if(pbOutput)
    {
        if( pContext->pbLastMessage )
        {
            free( pContext->pbLastMessage );
        }

        if( NULL == (pContext->pbLastMessage = (BYTE FAR *)malloc(pContext->cbLastMessage)) )
        {
            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            goto ErrorReturn;
        }
        memset(pContext->pbLastMessage, 0x00, pContext->cbLastMessage);
        memcpy(pContext->pbLastMessage, pbOutput, pContext->cbLastMessage);
    }

    lsReturn = LICENSE_STATUS_CONTINUE;
    LS_LOG_RESULT(lsReturn);
CommonReturn:
    
    if(Canonical.EncryptedPreMasterSecret.pBlob)
    {
        free(Canonical.EncryptedPreMasterSecret.pBlob);
        Canonical.EncryptedPreMasterSecret.pBlob = NULL;
    }

    if(Canonical.LicenseInfo.pBlob)
    {
        free(Canonical.LicenseInfo.pBlob);
        Canonical.LicenseInfo.pBlob = NULL;
    }

    if(Canonical.EncryptedHWID.pBlob)
    {
        free(Canonical.EncryptedHWID.pBlob);
        Canonical.EncryptedHWID.pBlob = NULL;
    }
    
    if(bbPreMasterSecret.pBlob)
    {
        free(bbPreMasterSecret.pBlob);
        bbPreMasterSecret.pBlob = NULL;
    }

    return  lsReturn;
//  LS_RETURN(lsReturn);
ErrorReturn:
    *pcbOutput = 0;
    goto CommonReturn;
}

LICENSE_STATUS 
CALL_TYPE
ClientConstructNewLicenseRequest(
                           PLicense_Client_Context  pContext,
                           BYTE FAR *               pbOutput,
                           DWORD FAR *              pcbOutput,
                           BOOL                     fExtendedError
                           )
{
    LICENSE_STATUS      lsReturn = LICENSE_STATUS_OK;
    Hydra_Client_New_License_Request    Request;
    Binary_Blob                         bbPreMasterSecret;
    DWORD                               dwSize = 0;
    DWORD                               dwState = 0;

#ifdef OS_WINCE

#define LS_MAX(a,b) ((a) > (b) ? (a) : (b))

    BYTE                                szUserName[LS_MAX((UNLEN + 1),HWID_STR_LEN)];
    DWORD                               cbUserName = sizeof(szUserName);
    BYTE                                szMachineName[LS_MAX(MAX_COMPUTERNAME_LENGTH + 1,HWID_STR_LEN)];
    DWORD                               cbMachineName = sizeof(szMachineName);

#else

    BYTE                                szUserName[(UNLEN + 1) * sizeof(TCHAR)];
    DWORD                               cbUserName = UNLEN + 1;
    BYTE                                szMachineName[(MAX_COMPUTERNAME_LENGTH + 1) * sizeof(TCHAR)];
    DWORD                               cbMachineName = (MAX_COMPUTERNAME_LENGTH + 1) * sizeof(TCHAR);

#endif

    PBYTE                               pbServerPubKey;
    DWORD                               cbServerPubKey;

    LS_BEGIN(TEXT("ClientConstructNewLicenseRequest"));

    if(NULL == pContext)
    {
        lsReturn = LICENSE_STATUS_INVALID_INPUT;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    } 

    memset(szUserName,0,sizeof(szUserName));
    memset(szMachineName,0,sizeof(szMachineName));


    dwState = pContext->pCryptParam->dwCryptState;

    bbPreMasterSecret.wBlobType = BB_RANDOM_BLOB;
    bbPreMasterSecret.wBlobLen = LICENSE_PRE_MASTER_SECRET;
    if( NULL == (bbPreMasterSecret.pBlob = (BYTE FAR *)malloc(LICENSE_PRE_MASTER_SECRET)) )
    {
        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    memcpy(bbPreMasterSecret.pBlob, pContext->pCryptParam->rgbPreMasterSecret, LICENSE_PRE_MASTER_SECRET);

    //Initialize the message
    memset(&Request, 0x00, sizeof(Hydra_Client_New_License_Request));

    //RSA is hardcoded for the time being
    Request.dwPrefKeyExchangeAlg = pContext->pCryptParam->dwKeyExchAlg;
    
    //PlatformID
#ifdef OS_WINCE
    Request.dwPlatformID =  CLIENT_OS_ID_OTHER | CLIENT_IMAGE_ID_MICROSOFT;
#else   // WinNT or Win9x
    {
        DWORD dwVersion = GetVersion();

        if (dwVersion & 0x80000000) {
            // Win95
            Request.dwPlatformID = CLIENT_OS_ID_OTHER | CLIENT_IMAGE_ID_MICROSOFT;
        } else {

            OSVERSIONINFOEX ovix;
            BOOL b;       
            ovix.dwOSVersionInfoSize = sizeof(ovix);
            b = GetVersionEx((LPOSVERSIONINFO) &ovix);            
            if(b && ((ovix.wSuiteMask & VER_SUITE_EMBEDDEDNT) || (ovix.wSuiteMask & VER_SUITE_PERSONAL)))
            {
                Request.dwPlatformID = CLIENT_OS_ID_WINNT_40 | CLIENT_IMAGE_ID_MICROSOFT;
            }            
            else
            {

                // WinNT
                Request.dwPlatformID = CLIENT_IMAGE_ID_MICROSOFT |
                ((((DWORD)(LOBYTE(LOWORD(dwVersion)))) - 2) << 24);
            }            
        }
    }
#endif

    //Copy ClientRandom
    memcpy(Request.ClientRandom, pContext->pCryptParam->rgbClientRandom, LICENSE_RANDOM);
    
    //Encrypt the Premastersecret using Server's Public key
    //We have to switch here depending on the key exchange algorithm to be used -Shubho

    if( pContext->pServerCert )
    {
        //
        // This public key is used for pre-Hydra 5.0 servers that are using proprietory
        // server certificates.
        //

        pbServerPubKey = pContext->pServerCert->PublicKeyData.pBlob;
        cbServerPubKey = pContext->pServerCert->PublicKeyData.wBlobLen;
    }
    else
    {
        pbServerPubKey = pContext->pbServerPubKey;
        cbServerPubKey = pContext->cbServerPubKey;
    }

    if( LICENSE_STATUS_OK != (lsReturn = LicenseEnvelopeData(pbServerPubKey,
                                                             cbServerPubKey,
                                                             bbPreMasterSecret.pBlob,
                                                             bbPreMasterSecret.wBlobLen,
                                                             NULL,
                                                             &dwSize)) )
    {
#if DBG
        OutputDebugString(_T("LicenseEnvelopeData failed"));
        LS_LOG_RESULT(lsReturn);
#endif
        goto ErrorReturn;
    }
    
    if( NULL == (Request.EncryptedPreMasterSecret.pBlob = (BYTE FAR *)malloc(dwSize)) )
    {
        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    
    memset(Request.EncryptedPreMasterSecret.pBlob, 0x00, dwSize);
    
    if( LICENSE_STATUS_OK != (lsReturn = LicenseEnvelopeData(pbServerPubKey,
                                                             cbServerPubKey,
                                                             bbPreMasterSecret.pBlob,
                                                             bbPreMasterSecret.wBlobLen,
                                                             Request.EncryptedPreMasterSecret.pBlob,
                                                             &dwSize)) )
    {
#if DBG
        OutputDebugString(_T("LicenseEnvelopeData failed"));
        LS_LOG_RESULT(lsReturn);
#endif
        goto ErrorReturn;
    }

    Request.EncryptedPreMasterSecret.wBlobLen = (WORD)dwSize;

    //
    // initialize the user name binary blob
    //
#if !defined(OS_WINCE)
    GetUserName( (LPTSTR)szUserName, &cbUserName );
#elif defined(OS_WINCE)
    GetUserName( (LPSTR)szUserName, &cbUserName );
#endif  //OS_WINCE

    Request.ClientUserName.wBlobType = BB_CLIENT_USER_NAME_BLOB;
    Request.ClientUserName.wBlobLen = ( WORD )cbUserName;
    Request.ClientUserName.pBlob = szUserName;

    //
    // initialize the machine name binary blob
    //

#if defined(OS_WINCE)
    GetComputerName( (LPSTR)szMachineName, &cbMachineName );
#else
    GetComputerName( (LPTSTR)szMachineName, &cbMachineName );
#endif

    Request.ClientMachineName.wBlobType = BB_CLIENT_MACHINE_NAME_BLOB;
    Request.ClientMachineName.wBlobLen = ( WORD )cbMachineName + 1;
    Request.ClientMachineName.pBlob = szMachineName;
        
    //New License Request is ready. Now pack the data,
    if( LICENSE_STATUS_OK != (lsReturn = PackHydraClientNewLicenseRequest(&Request,
                                                                          fExtendedError,
                                                                          pbOutput, 
                                                                          pcbOutput)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    //Anyway Generate the session key and MACsalt for future use
    if( LICENSE_STATUS_OK != (lsReturn = LicenseBuildMasterSecret(pContext->pCryptParam)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    if( LICENSE_STATUS_OK != (lsReturn = LicenseMakeSessionKeys(pContext->pCryptParam, 0)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    //Set the MACData in the CryptSystem MAC buffer.
    memset(pContext->rgbMACData, 0x00, LICENSE_MAC_DATA);

    //Set the state of the context to LICENSE_CLIENT_STATE_NEW_LICENSE_REQUEST
    //if something is written on the output. i.e. pbOutput is not NULL
    if(pbOutput)
    {
        pContext->dwState = LICENSE_CLIENT_STATE_LICENSE_RESPONSE;
    }
    
    else    //Restore earlier CryptSystem States
    {
        pContext->pCryptParam->dwCryptState = dwState;
        memcpy(pContext->pCryptParam->rgbPreMasterSecret, bbPreMasterSecret.pBlob, LICENSE_PRE_MASTER_SECRET);
        memset(pContext->pCryptParam->rgbSessionKey, 0x00, LICENSE_SESSION_KEY);
        memset(pContext->pCryptParam->rgbMACSaltKey, 0x00, LICENSE_MAC_WRITE_KEY);
    }

    //Copy the whole message to the context
    pContext->cbLastMessage = *pcbOutput;
    if(pbOutput)
    {
        if( pContext->pbLastMessage )
        {
            free( pContext->pbLastMessage );
        }

        if( NULL == (pContext->pbLastMessage = (BYTE FAR *)malloc(pContext->cbLastMessage)) )
        {
            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }
        memset(pContext->pbLastMessage, 0x00, pContext->cbLastMessage);
        memcpy(pContext->pbLastMessage, pbOutput, pContext->cbLastMessage);
    }

    lsReturn = LICENSE_STATUS_CONTINUE;
    LS_LOG_RESULT(lsReturn);
CommonReturn:
    
    if(bbPreMasterSecret.pBlob)
    {
        free(bbPreMasterSecret.pBlob);
        bbPreMasterSecret.pBlob = NULL;
    }

    if( Request.EncryptedPreMasterSecret.pBlob )
    {
        free( Request.EncryptedPreMasterSecret.pBlob );
    }

    return  lsReturn;
    //LS_RETURN(lsReturn);
ErrorReturn:
    *pcbOutput = 0;
    goto CommonReturn;
}

LICENSE_STATUS
CALL_TYPE
ClientConstructErrorAlert(
                         PLicense_Client_Context    pContext,
                         DWORD                      dwErrorCode,
                         DWORD                      dwStateTransition,
                         BYTE FAR *                 pbErrorInfo,
                         DWORD                      cbErrorInfo,
                         BYTE FAR *                 pbOutput,
                         DWORD  FAR *               pcbOutput,
                         BOOL                       fExtendedError
                         )
{
    LICENSE_STATUS  lsReturn = LICENSE_STATUS_OK;
    License_Error_Message  Error;    
    
    LS_BEGIN(TEXT("ClientConstructErrorAlert\n"));

    if(NULL == pContext)
    {
        lsReturn = LICENSE_STATUS_INVALID_INPUT;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    } 
    
    memset(&Error, 0x00, sizeof(License_Error_Message));
    Error.dwErrorCode = dwErrorCode;    
    Error.dwStateTransition = dwStateTransition;
    Error.bbErrorInfo.wBlobType = BB_ERROR_BLOB;
    Error.bbErrorInfo.wBlobLen = (WORD)cbErrorInfo;
    if(Error.bbErrorInfo.wBlobLen>0)
    {
        if( NULL == (Error.bbErrorInfo.pBlob = (BYTE FAR *)malloc(Error.bbErrorInfo.wBlobLen)) )
        {
            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }
        memset(Error.bbErrorInfo.pBlob, 0x00, Error.bbErrorInfo.wBlobLen);
        memcpy(Error.bbErrorInfo.pBlob, pbErrorInfo, Error.bbErrorInfo.wBlobLen);
    }
    else
        Error.bbErrorInfo.pBlob = NULL;
    
    if( LICENSE_STATUS_OK != (lsReturn = PackLicenseErrorMessage(&Error, 
                                                                 fExtendedError,
                                                                 pbOutput, 
                                                                 pcbOutput)) )
    {
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;       
    }
    
    //Set the MACData in the CryptSystem MAC buffer.
    memset(pContext->rgbMACData, 0x00, LICENSE_MAC_DATA);

    //Set the state of the context to LICENSE_CLIENT_STATE_ABORT;
    switch(dwStateTransition)
    {
    case ST_TOTAL_ABORT:
        pContext->dwState = LICENSE_CLIENT_STATE_ABORT;
        lsReturn = LICENSE_STATUS_CLIENT_ABORT;
        pContext->cbLastMessage = 0;
        break;
    case ST_NO_TRANSITION:
        lsReturn = LICENSE_STATUS_CONTINUE;
        pContext->cbLastMessage = *pcbOutput;
        if(pbOutput)
        {
            if( pContext->pbLastMessage )
            {
                free( pContext->pbLastMessage );
            }

            if( NULL == (pContext->pbLastMessage = (BYTE FAR *)malloc(pContext->cbLastMessage)) )
            {
                lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
                LS_LOG_RESULT(lsReturn);
                goto ErrorReturn;
            }
            memset(pContext->pbLastMessage, 0x00, pContext->cbLastMessage);
            memcpy(pContext->pbLastMessage, pbOutput, pContext->cbLastMessage);
        }
        break;
    case ST_RESET_PHASE_TO_START:
        lsReturn = LICENSE_STATUS_CONTINUE;
        if( (pContext->dwState == LICENSE_CLIENT_STATE_LICENSE_RESPONSE) ||
            (pContext->dwState == LICENSE_CLIENT_STATE_NEW_LICENSE_REQUEST) )
        {
            pContext->dwState = LICENSE_CLIENT_STATE_WAIT_SERVER_HELLO;
        }
        else if(pContext->dwState == LICENSE_CLIENT_STATE_PLATFORM_CHALLENGE_RESPONSE)
        {
            pContext->dwState = LICENSE_CLIENT_STATE_NEW_LICENSE_REQUEST;
        }
        break;
    case ST_RESEND_LAST_MESSAGE:
        lsReturn = LICENSE_STATUS_CONTINUE;
        break;
    }
    
    LS_LOG_RESULT(lsReturn);    
CommonReturn:
    
    if(Error.bbErrorInfo.pBlob)
    {
        free(Error.bbErrorInfo.pBlob);
        Error.bbErrorInfo.pBlob = NULL;
    }
    return lsReturn;
    //LS_RETURN(lsReturn);
ErrorReturn:
    *pcbOutput = 0;
    goto CommonReturn;
}


LICENSE_STATUS
CALL_TYPE
ClientGenerateChallengeResponse(
                                PLicense_Client_Context     pContext,
                                PBinary_Blob                pChallengeData,
                                PBinary_Blob                pResponseData
                                )
{
    LICENSE_STATUS  lsReturn = LICENSE_STATUS_OK;
    PPlatformChallengeResponseData pbChallengeResponse = NULL;
    WORD cbChallengeResponse;


    LS_BEGIN(TEXT("ClientGenerateChallengeResponse"));

    //For the time being we will send back the same data. But we have to finalize on the challenge
    //response generation algorithm as soon as possible - Shubho
    if( (pContext == NULL) || (pChallengeData == NULL) || (pResponseData == NULL) )
    {
        lsReturn = LICENSE_STATUS_INVALID_INPUT;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }
    
    pResponseData->wBlobType = BB_DATA_BLOB;
    
    //
    // Determine how much memory we need to allocate, PlatformChallenge* is a variable length
    // structure.
    //
    cbChallengeResponse = (WORD)OFFSET_OF(PlatformChallengeResponseData, pbChallenge) + pChallengeData->wBlobLen;

    ASSERT(cbChallengeResponse <= PLATFORM_CHALLENGE_LENGTH);
    if(cbChallengeResponse > PLATFORM_CHALLENGE_LENGTH)
    {
        lsReturn = LICENSE_STATUS_INVALID_INPUT;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    pbChallengeResponse = (PPlatformChallengeResponseData)malloc(cbChallengeResponse);
    if( NULL == pbChallengeResponse )
    {
        // can't allocate memory
        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    //
    // Setup challenge response data, 
    //

    pbChallengeResponse->wVersion = CURRENT_PLATFORMCHALLENGE_VERSION;

 
#ifdef OS_WINCE

    pbChallengeResponse->wClientType = WINCE_PLATFORMCHALLENGE_TYPE;
    pbChallengeResponse->wLicenseDetailLevel = LICENSE_DETAIL_DETAIL;

#else

    //
    // We only need one Win32 type since we already have dwPlatformID to differentiate Win98/NT
    // Note, we set license detail level in #define just in case platform can't handle amount
    // of data set back by license server
    //
    pbChallengeResponse->wClientType = WIN32_PLATFORMCHALLENGE_TYPE;
    pbChallengeResponse->wLicenseDetailLevel = LICENSE_DETAIL_DETAIL;

#endif

    if( (pChallengeData->pBlob != NULL) && (pChallengeData->wBlobLen >0) )
    {
        pbChallengeResponse->cbChallenge = pChallengeData->wBlobLen;
        memcpy(
                (PBYTE)pbChallengeResponse + OFFSET_OF(PlatformChallengeResponseData, pbChallenge),
                pChallengeData->pBlob,
                pChallengeData->wBlobLen
            );
    }
    else
    {
        // server didn't send us any challenge data.
        pbChallengeResponse->cbChallenge = 0;
    }

    pResponseData->wBlobLen = cbChallengeResponse;
    pResponseData->pBlob = (BYTE FAR *)pbChallengeResponse;
    
    lsReturn = LICENSE_STATUS_OK;
    LS_LOG_RESULT(lsReturn);

CommonReturn:
    //LS_RETURN(lsReturn);
    return lsReturn;
ErrorReturn:
    goto CommonReturn;
}

static BOOL GeneratePseudoLicense(
                                  DWORD FAR * pcbNewLicense, 
                                  LPBYTE FAR *ppNewLicense)
{
    TCHAR g_LicenseString[] = TEXT("Licensed To Kill");

#define REPEAT_LICENSE_STRING   15
#define LICENSE_STRING_LEN      sizeof(TCHAR) * lstrlen(g_LicenseString) 

#define LICENSE_SIZE         ( LICENSE_STRING_LEN * REPEAT_LICENSE_STRING ) + 1 * sizeof(TCHAR)

    UINT i;
    BYTE FAR *pbLicenseData = NULL;
    DWORD cbLicenseData = LICENSE_SIZE;
        
    if( NULL == ( *ppNewLicense = malloc(cbLicenseData) ) )
    {   
        return FALSE;
    }

    memset(*ppNewLicense, 0x00, cbLicenseData);
    //
    // fill the memory with this license string
    //
    pbLicenseData = *ppNewLicense;
    for( i = 0; i < REPEAT_LICENSE_STRING; i++ )
    {
        memcpy( pbLicenseData, g_LicenseString, LICENSE_STRING_LEN  );
        pbLicenseData += LICENSE_STRING_LEN;
    }

    *pcbNewLicense = cbLicenseData;

    return TRUE;
}


VOID
FreeProprietaryCertificate(
    PHydra_Server_Cert * ppCertificate )
{    
    if( NULL == *ppCertificate )
    {
        return;
    }

    if( ( *ppCertificate )->PublicKeyData.pBlob )
    {
        free( ( *ppCertificate )->PublicKeyData.pBlob );
    }

    if( ( *ppCertificate )->SignatureBlob.pBlob )
    {
        free( ( *ppCertificate )->SignatureBlob.pBlob );
    }

    free( *ppCertificate );

    *ppCertificate = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\cryptkey\ubase64.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1999
//
// File:        ubase64.cpp
//
// Contents:    
//
// History:     
//              
//              
//---------------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <assert.h>
// #include "crtem.h"
#include "base64.h"

DWORD LSBase64EncodeW(
    BYTE const *pbIn,
    DWORD cbIn,
    WCHAR *wszOut,
    DWORD *pcchOut)

{

    DWORD   cchOut;
    char   *pch = NULL;
    DWORD   cch;
    DWORD   err;

    assert(pcchOut != NULL);

    // only want to know how much to allocate
    // we know all base64 char map 1-1 with unicode

    __try
    {
        if( wszOut == NULL ) {

            // get the number of characters
            *pcchOut = 0;
            err = LSBase64EncodeA(
                    pbIn,
                    cbIn,
                    NULL,
                    pcchOut);
        }

        // otherwise we have an output buffer
        else {

            // char count is the same be it ascii or unicode,
            cchOut = *pcchOut;
            cch = 0;
            err = ERROR_OUTOFMEMORY;
            if( (pch = (char *) LocalAlloc(LPTR, cchOut)) != NULL  &&
        
                (err = LSBase64EncodeA(
                    pbIn,
                    cbIn,
                    pch,
                    &cchOut)) == ERROR_SUCCESS      ) {

                // should not fail!
                cch = MultiByteToWideChar(0, 
                                0, 
                                pch, 
                                cchOut, 
                                wszOut, 
                                *pcchOut);

                // check to make sure we did not fail                            
                assert(*pcchOut == 0 || cch != 0);                            
            }
        }
    }
    __except(  EXCEPTION_EXECUTE_HANDLER )
    {
        //
        // log the exception in the future
        //
        
        err = ERROR_EXCEPTION_IN_SERVICE;
    }

    if(pch != NULL)
    {
        LocalFree(pch);
    }

    return(err);
}

DWORD LSBase64DecodeW(
    const WCHAR * wszIn,
    DWORD cch,
    BYTE *pbOut,
    DWORD *pcbOut)
{

    char *pch = NULL;
    DWORD err = ERROR_SUCCESS;

    __try
    {

        // in all cases we need to convert to an ascii string
        // we know the ascii string is less

        if( (pch = (char *) LocalAlloc(LPTR, cch)) == NULL ) {
            err = ERROR_OUTOFMEMORY;
        }

        // we know no base64 wide char map to more than 1 ascii char
        else if( WideCharToMultiByte(0, 
                            0, 
                            wszIn, 
                            cch, 
                            pch, 
                            cch, 
                            NULL, 
                            NULL) == 0 ) {
            err = ERROR_NO_DATA;
        }
        
        // get the length of the buffer
        else if( pbOut == NULL ) {

            *pcbOut = 0;
            err = LSBase64Decode(
                            pch,
                            cch,
                            NULL,
                            pcbOut);
        }

        // otherwise fill in the buffer
        else {

            err = LSBase64Decode(
                            pch,
                            cch,
                            pbOut,
                            pcbOut);
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        //
        // log the exception in the future
        //
        
        err = ERROR_EXCEPTION_IN_SERVICE;
    }

    if(pch != NULL)
    {
        LocalFree(pch);
    }

    return(err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\common\cryptkey\rng.c ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1999
//
// File:        rng.c
//
// Contents:
//
// History:
//
//
//---------------------------------------------------------------------------

//This file and the functions are copied from Schannel project and included in
//this project without modification.


#ifndef _WIN32_WINNT
#define _WIN32_WINNT    0x0400
#endif

//#include <spbase.h>
#include <windows.h>
#include "rng.h"
#include <rc4.h>
#include <sha.h>


unsigned char g_rgbStaticBits[A_SHA_DIGEST_LEN];
static DWORD         g_dwRC4BytesUsed = RC4_REKEY_PARAM;     // initially force rekey
static struct RC4_KEYSTRUCT g_rc4key;

static BOOL RandomFillBuffer(BYTE *pbBuffer, DWORD *pdwLength);
static void AppendRand(PRAND_CONTEXT prandContext, void* pv, DWORD dwSize);


/*****************************************************************************/
VOID TSInitializeRNG2(VOID)
{


    ZeroMemory( g_rgbStaticBits, sizeof( g_rgbStaticBits ) );
    g_dwRC4BytesUsed = RC4_REKEY_PARAM;

    return;
}

#ifndef NOGENRANDOM
/*****************************************************************************/
int GenRandom(PVOID Reserved,
              UCHAR *pbBuffer,
              size_t dwLength)
{
    GenerateRandomBits(pbBuffer, dwLength);
    return TRUE;
}
#endif

/************************************************************************/
/* GenerateRandomBits generates a specified number of random bytes and        */
/* places them into the specified buffer.                                */
/************************************************************************/
/*                                                                      */
/* Pseudocode logic flow:                                               */
/*                                                                      */
/* if (bits streamed > threshold)                                       */
/* {                                                                    */
/*  Gather_Bits()                                                       */
/*  SHAMix_Bits(User, Gathered, Static -> Static)                       */
/*  RC4Key(Static -> newRC4Key)                                         */
/*  SHABits(Static -> Static)      // hash after RC4 key generation     */
/* }                                                                    */
/* else                                                                 */
/* {                                                                    */
/*  SHAMix_Bits(User, Static -> Static)                                 */
/* }                                                                    */
/*                                                                      */
/* RC4(newRC4Key -> outbuf)                                             */
/* bits streamed += sizeof(outbuf)                                      */
/*                                                                      */
/************************************************************************/
VOID GenerateRandomBits(PUCHAR pbBuffer,
                        ULONG  dwLength)
{
    DWORD dwBytesThisPass;
    DWORD dwFilledBytes = 0;

    // break request into chunks that we rekey between


    while(dwFilledBytes < dwLength)
    {
        dwBytesThisPass = dwLength - dwFilledBytes;

        RandomFillBuffer(pbBuffer + dwFilledBytes, &dwBytesThisPass);
        dwFilledBytes += dwBytesThisPass;
    }

}

/*****************************************************************************/
static BOOL RandomFillBuffer(BYTE *pbBuffer, DWORD *pdwLength)
{
    // Variables from loading and storing the registry...
    DWORD   cbDataLen;
    RAND_CONTEXT randContext;
    randContext.dwBitsFilled = 0;

    cbDataLen = A_SHA_DIGEST_LEN;
    GatherRandomBits(&randContext);

    if(g_dwRC4BytesUsed >= RC4_REKEY_PARAM) {
        // if we need to rekey



        // Mix all bits
        {
            A_SHA_CTX SHACtx;
            A_SHAInit(&SHACtx);

            // SHA the static bits
            A_SHAUpdate(&SHACtx, g_rgbStaticBits, A_SHA_DIGEST_LEN);

            // SHA the gathered bits
            A_SHAUpdate(&SHACtx, randContext.rgbBitBuffer, randContext.dwBitsFilled);

            // SHA the user-supplied bits
            A_SHAUpdate(&SHACtx, pbBuffer, *pdwLength);

            // output back out to static bits
            A_SHAFinal(&SHACtx, g_rgbStaticBits);
        }

        // Create RC4 key
        g_dwRC4BytesUsed = 0;
        rc4_key(&g_rc4key, A_SHA_DIGEST_LEN, g_rgbStaticBits);

        // Mix RC4 key bits around
        {
            A_SHA_CTX SHACtx;
            A_SHAInit(&SHACtx);

            // SHA the static bits
            A_SHAUpdate(&SHACtx, g_rgbStaticBits, A_SHA_DIGEST_LEN);

            // output back out to static bits
            A_SHAFinal(&SHACtx, g_rgbStaticBits);
        }

    } else {
        // Use current RC4 key, but capture any user-supplied bits.

        // Mix input bits
        {
            A_SHA_CTX SHACtx;
            A_SHAInit(&SHACtx);

            // SHA the static bits
            A_SHAUpdate(&SHACtx, g_rgbStaticBits, A_SHA_DIGEST_LEN);

            // SHA the user-supplied bits
            A_SHAUpdate(&SHACtx, pbBuffer, *pdwLength);

            // output back out to static bits
            A_SHAFinal(&SHACtx, g_rgbStaticBits);
        }
    }

    // only use RC4_REKEY_PARAM bytes from each RC4 key
    {
        DWORD dwMaxPossibleBytes = RC4_REKEY_PARAM - g_dwRC4BytesUsed;
        if(*pdwLength > dwMaxPossibleBytes) {
                *pdwLength = dwMaxPossibleBytes;
        }
    }

    FillMemory(pbBuffer, *pdwLength, 0);
    rc4(&g_rc4key, *pdwLength, pbBuffer);

    g_dwRC4BytesUsed += *pdwLength;

    return TRUE;
}

/*****************************************************************************/
void GatherRandomBits(PRAND_CONTEXT prandContext)
{
    DWORD   dwTmp;
    WORD    wTmp;
    BYTE    bTmp;

    // ** indicates US DoD's specific recommendations for password generation

    // proc id
    dwTmp = GetCurrentProcessId();
    AppendRand(prandContext, &dwTmp, sizeof(dwTmp));

    // thread id
    dwTmp = GetCurrentThreadId();
    AppendRand(prandContext, &dwTmp, sizeof(dwTmp));

    // ** ticks since boot (system clock)
    dwTmp = GetTickCount();
    AppendRand(prandContext, &dwTmp, sizeof(dwTmp));

    // cursor position
    {
        POINT                        point;
        GetCursorPos(&point);
        bTmp = LOBYTE(point.x) ^ HIBYTE(point.x);
        AppendRand(prandContext, &bTmp, sizeof(BYTE));
        bTmp = LOBYTE(point.y) ^ HIBYTE(point.y);
        AppendRand(prandContext, &bTmp, sizeof(BYTE));
    }

    // ** system time, in ms, sec, min (date & time)
    {
        SYSTEMTIME                sysTime;
        GetLocalTime(&sysTime);
        AppendRand(prandContext, &sysTime.wMilliseconds, sizeof(sysTime.wMilliseconds));
        bTmp = LOBYTE(sysTime.wSecond) ^ LOBYTE(sysTime.wMinute);
        AppendRand(prandContext, &bTmp, sizeof(BYTE));
    }

    // ** hi-res performance counter (system counters)
    {
        LARGE_INTEGER        liPerfCount;
        if(QueryPerformanceCounter(&liPerfCount)) {
            bTmp = LOBYTE(LOWORD(liPerfCount.LowPart)) ^ LOBYTE(LOWORD(liPerfCount.HighPart));
            AppendRand(prandContext, &bTmp, sizeof(BYTE));
            bTmp = HIBYTE(LOWORD(liPerfCount.LowPart)) ^ LOBYTE(LOWORD(liPerfCount.HighPart));
            AppendRand(prandContext, &bTmp, sizeof(BYTE));
            bTmp = LOBYTE(HIWORD(liPerfCount.LowPart)) ^ LOBYTE(LOWORD(liPerfCount.HighPart));
            AppendRand(prandContext, &bTmp, sizeof(BYTE));
            bTmp = HIBYTE(HIWORD(liPerfCount.LowPart)) ^ LOBYTE(LOWORD(liPerfCount.HighPart));
            AppendRand(prandContext, &bTmp, sizeof(BYTE));
        }
    }

    // memory status
    {
        MEMORYSTATUS        mstMemStat;
        mstMemStat.dwLength = sizeof(MEMORYSTATUS);     // must-do
        GlobalMemoryStatus(&mstMemStat);
        wTmp = HIWORD(mstMemStat.dwAvailPhys);          // low words seem to be always zero
        AppendRand(prandContext, &wTmp, sizeof(WORD));
        wTmp = HIWORD(mstMemStat.dwAvailPageFile);
        AppendRand(prandContext, &wTmp, sizeof(WORD));
        bTmp = LOBYTE(HIWORD(mstMemStat.dwAvailVirtual));
        AppendRand(prandContext, &bTmp, sizeof(BYTE));
    }

    // free disk clusters
    {
        DWORD dwSectorsPerCluster, dwBytesPerSector, dwNumberOfFreeClusters, dwTotalNumberOfClusters;
        if(GetDiskFreeSpace(NULL, &dwSectorsPerCluster, &dwBytesPerSector,     &dwNumberOfFreeClusters, &dwTotalNumberOfClusters)) {
            AppendRand(prandContext, &dwNumberOfFreeClusters, sizeof(dwNumberOfFreeClusters));
            AppendRand(prandContext, &dwTotalNumberOfClusters, sizeof(dwTotalNumberOfClusters));
            AppendRand(prandContext, &dwBytesPerSector, sizeof(dwBytesPerSector));
        }
    }

    // last messages' timestamp
    {
        LONG lTime;
        lTime = GetMessageTime();
        AppendRand(prandContext, &lTime, sizeof(lTime));
    }

    {
        // **SystemID
        DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;
        char lpBuf [MAX_COMPUTERNAME_LENGTH + 1];

        if(GetComputerNameA(lpBuf, &dwSize)) {
            // dwSize = len not including null termination
            AppendRand(prandContext, lpBuf, dwSize);
        }

        dwSize = MAX_COMPUTERNAME_LENGTH + 1;

        // **UserID
        if(GetUserNameA(lpBuf, &dwSize)) {
            // dwSize = len including null termination
            dwSize -= 1;
            AppendRand(prandContext, lpBuf, dwSize);
        }
    }
}

/*****************************************************************************/
static void AppendRand(PRAND_CONTEXT prandContext, void* pv, DWORD dwSize)
{
    DWORD dwBitsLeft = (RAND_CTXT_LEN - prandContext->dwBitsFilled);

    if(dwBitsLeft > 0) {
        if(dwSize > dwBitsLeft) {
            dwSize = dwBitsLeft;
        }

        CopyMemory(prandContext->rgbBitBuffer + prandContext->dwBitsFilled, pv, dwSize);
        prandContext->dwBitsFilled += dwSize;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\hclient\liclient\hccontxt.c ===
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       HCContxt.c
//
//  Contents:   Functions that are used to pack and unpack different messages
//
//  Classes:
//
//  Functions:  
//
//  History:    12-23-97  v-sbhatt   Created
//              07-22-98  fredch     Added LicenseSetPublicKey() function
//----------------------------------------------------------------------------


#include "windows.h"

#include "stdlib.h"
#include <tchar.h>

#ifdef OS_WINCE
#include <wincelic.h>
#endif  //OS_WINCE


#include "license.h"
#include "cryptkey.h"
#include "hccontxt.h"
#include "cliprot.h"
#ifndef OS_WINCE
#include "assert.h"
#endif // OS_WINCE

VOID
FreeProprietaryCertificate(
    PHydra_Server_Cert * ppCertificate );

#ifdef __cplusplus
extern "C" {
#endif

/******************************************************************
*   Funtion : PLicense_Client_Context LicenseCreateContext(VOID)
*   Purpose : Creates a New License_Client_Context and initializes 
*             it with 0
*   Returns : Returns a pointer to created License_Client_Context
*******************************************************************/


PLicense_Client_Context 
LicenseCreateContext( VOID)
{
    PLicense_Client_Context     pContext;
    
    //Allocate approptiate memory!
    pContext = (PLicense_Client_Context)malloc(sizeof(License_Client_Context));
    if(pContext == NULL)
        return NULL;
    
    memset(pContext, 0, sizeof(License_Client_Context));

    //
    // allocate memory for the crypto context
    //

    pContext->pCryptParam = ( PCryptSystem )malloc( sizeof( CryptSystem ) );

    if( NULL == pContext->pCryptParam )
    {
        free( pContext );
        pContext = NULL;
        return( NULL );
    }

    return pContext;
}

/**********************************************************************************
*   Funtion : LICENSE_STATUS LicenseDeleteContext(PLicense_Client_Context pContext)
*   Purpose : Deletes an existing context and overwrites the memory with 0
*   Returns : Returns LICENSE_STATUS
*******************************************************************/


LICENSE_STATUS CALL_TYPE
LicenseDeleteContext(
                     HANDLE hContext
                     )//PLicense_Client_Context pContext)
{
    LICENSE_STATUS  lsReturn = LICENSE_STATUS_OK;
    PLicense_Client_Context     pContext = (PLicense_Client_Context)hContext;
    if(pContext == NULL)
    { 
        lsReturn = LICENSE_STATUS_INVALID_CLIENT_CONTEXT;
#if DBG
        OutputDebugString(_T("The context handle passed is invalid"));
#endif
        return lsReturn;
    }
    
    //free pServerCert
    if(pContext->pServerCert)
    {
        FreeProprietaryCertificate( &pContext->pServerCert );       
    }

    //
    // Free the public key
    //
    
    if( pContext->pbServerPubKey )
    {
        memset( pContext->pbServerPubKey, 0x00, pContext->cbServerPubKey );
        free( pContext->pbServerPubKey );
        pContext->pbServerPubKey = NULL;
    }
        
    //Free pCryptSystem
    if(pContext->pCryptParam)
    {
        memset(pContext->pCryptParam, 0x00, sizeof(CryptSystem));
        free(pContext->pCryptParam);
        pContext->pCryptParam = NULL;
    }

    //Free the last message

    if(pContext->pbLastMessage)
    {
        memset(pContext->pbLastMessage, 0x00, pContext->cbLastMessage);
        free(pContext->pbLastMessage);
        pContext->pbLastMessage = NULL;
    }
    if(pContext)
    {
        //Zeroise the memory
        memset(pContext, 0, sizeof(License_Client_Context));
        //Now free the context;
        free(pContext);
        pContext = NULL;
    }
    
    hContext = NULL;
    return lsReturn;
}


/**********************************************************************************
*   Funtion : LICENSE_STATUS 
*             LicenseInitializeContext(
*                                      PLicense_Client_Context pContext,
*                                      DWORD       dwFlags
*                                       );
*   Purpose : Initializes an existing context
*   Returns : Returns LICENSE_STATUS
*******************************************************************/

LICENSE_STATUS CALL_TYPE
LicenseInitializeContext(
                         HANDLE     *phContext,
                         DWORD       dwFlags
                         )
{
    LICENSE_STATUS  lsReturn = LICENSE_STATUS_OK;
    PLicense_Client_Context pContext;

    assert(phContext);
    
    pContext = LicenseCreateContext();
    
    if(pContext == NULL)
    {
#if DBG
        OutputDebugString(_T("\nUnable to allocate memory for the context.\n"));
#endif
        *phContext = NULL;
        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        return lsReturn;
    }
    //Now initialize different members of the context structure
    pContext->dwProtocolVersion = LICENSE_HIGHEST_PROTOCOL_VERSION;
    pContext->dwState = LICENSE_CLIENT_STATE_WAIT_SERVER_HELLO;
    pContext->pCryptParam->dwCryptState = CRYPT_SYSTEM_STATE_INITIALIZED;
    pContext->pCryptParam->dwSignatureAlg = SIGNATURE_ALG_RSA;
    pContext->pCryptParam->dwKeyExchAlg = KEY_EXCHANGE_ALG_RSA;
    pContext->pCryptParam->dwSessKeyAlg = BASIC_RC4_128;
    pContext->pCryptParam->dwMACAlg = MAC_MD5_SHA;
    memset(pContext->pCryptParam->rgbClientRandom, 0x00, LICENSE_RANDOM);
    memset(pContext->pCryptParam->rgbServerRandom, 0x00, LICENSE_RANDOM);
    memset(pContext->pCryptParam->rgbPreMasterSecret, 0x00, LICENSE_PRE_MASTER_SECRET);
    memset(pContext->pCryptParam->rgbMACSaltKey, 0x00, LICENSE_MAC_WRITE_KEY);
    memset(pContext->pCryptParam->rgbSessionKey, 0x00, LICENSE_SESSION_KEY);
    memset(pContext->rgbMACData, 0x00, LICENSE_MAC_DATA);
    pContext->cbLastMessage = 0;
    pContext->pbLastMessage = NULL;
    pContext->pServerCert = NULL;   
    pContext->dwContextFlags = dwFlags;

    *phContext = (HANDLE)pContext;
    return lsReturn;
}


/******************************************************************
*   Funtion : LICENSE_STATUS
*             LicenseAcceptContext(
*                   HANDLE      hContext,
*                   UINT32      puiExtendedErrorInfo,
*                   BYTE FAR *  pbInput,
*                   DWORD       cbInput,
*                   BYTE FAR *  pbOutput,
*                   DWORD FAR * pcbOutput )
*
*   Purpose : Process and construct licensing protocol data.
*
*   Returns : Returns a LICENSE_STATUS return code.
*******************************************************************/

LICENSE_STATUS  CALL_TYPE
LicenseAcceptContext(
                      HANDLE    hContext,
                      UINT32    *puiExtendedErrorInfo,
                      BYTE FAR *pbInput,
                      DWORD     cbInput,
                      BYTE FAR *pbOutput,
                      DWORD FAR*pcbOutput
                      )
{
    PLicense_Client_Context     pContext = (PLicense_Client_Context)hContext;
    return LicenseClientHandleServerMessage(pContext, 
                                            puiExtendedErrorInfo,
                                            pbInput,
                                            cbInput,
                                            pbOutput,
                                            pcbOutput);
}


/******************************************************************
*   Funtion : LICENSE_STATUS
*             LicenseSetPublicKey(
*                   HANDLE          hContext,
*                   DWORD           cbPubKey,
*                   BYTE FAR *      pbPubKey )
*
*   Purpose : Sets the public key to use.
*
*   Returns : Returns a LICENSE_STATUS return code.
*******************************************************************/

LICENSE_STATUS CALL_TYPE
LicenseSetPublicKey(
    HANDLE          hContext,
    DWORD           cbPubKey,
    BYTE FAR *      pbPubKey )
{
    PLicense_Client_Context
        pContext = ( PLicense_Client_Context )hContext;
    PBYTE
        pbOldPubKey = NULL;

    if( ( NULL == pbPubKey ) || ( 0 >= cbPubKey ) || ( NULL == pContext ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // remember the old public key so that we can restore it if this
    // function call doesn't complete successfully.
    //
    
    pbOldPubKey = pContext->pbServerPubKey;
    
    //
    // allocate memory for the new public key
    //

    pContext->pbServerPubKey = malloc( cbPubKey );

    if( NULL == pContext->pbServerPubKey )
    {
        //
        // no memory, restore the old public key and return an error
        //

        pContext->pbServerPubKey = pbOldPubKey;
        return( LICENSE_STATUS_OUT_OF_MEMORY );
    }

    //
    // copy the new public key
    //

    memcpy( pContext->pbServerPubKey, pbPubKey, cbPubKey );
    pContext->cbServerPubKey = cbPubKey;

    if( pbOldPubKey )
    {
        free( pbOldPubKey );
    }

    return( LICENSE_STATUS_OK );
}


/******************************************************************
*   Funtion : LICENSE_STATUS
*             LicenseSetCertificate(
*                   HANDLE              hContext,
*                   PHydra_Server_Cert  pCertificate )
*
*   Purpose : Sets the certificate to use.
*
*   Returns : Returns a LICENSE_STATUS return code.
*******************************************************************/

LICENSE_STATUS CALL_TYPE
LicenseSetCertificate(
    HANDLE              hContext,
    PHydra_Server_Cert  pCertificate )
{
    PLicense_Client_Context
        pContext = ( PLicense_Client_Context )hContext;
    PHydra_Server_Cert
        pNewCert = NULL;
    LICENSE_STATUS
        Status = LICENSE_STATUS_OK;

    if( ( NULL == pCertificate ) || ( NULL == pContext ) ||
        ( NULL == pCertificate->PublicKeyData.pBlob) ||
        ( NULL == pCertificate->SignatureBlob.pBlob ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // allocate memory for the new certificate
    //

    pNewCert = ( PHydra_Server_Cert )malloc( sizeof( Hydra_Server_Cert ) );

    if( NULL == pNewCert )
    {
        return( LICENSE_STATUS_OUT_OF_MEMORY );
    }

    memset( ( char * )pNewCert, 0, sizeof( Hydra_Server_Cert ) );

    pNewCert->PublicKeyData.pBlob = ( LPBYTE )malloc( pCertificate->PublicKeyData.wBlobLen );

    if( NULL == pNewCert->PublicKeyData.pBlob )
    {
        Status = LICENSE_STATUS_OUT_OF_MEMORY;
        goto ErrorExit;
    }

    pNewCert->SignatureBlob.pBlob = ( LPBYTE )malloc( pCertificate->SignatureBlob.wBlobLen );

    if( NULL == pNewCert->SignatureBlob.pBlob )
    {
        Status = LICENSE_STATUS_OUT_OF_MEMORY;
        goto ErrorExit;
    }

    //
    // copy the certificate info
    //

    pNewCert->dwVersion = pCertificate->dwVersion;
    pNewCert->dwSigAlgID = pCertificate->dwSigAlgID;
    pNewCert->dwKeyAlgID = pCertificate->dwKeyAlgID;

    pNewCert->PublicKeyData.wBlobType = pCertificate->PublicKeyData.wBlobType;
    pNewCert->PublicKeyData.wBlobLen = pCertificate->PublicKeyData.wBlobLen;
    memcpy( pNewCert->PublicKeyData.pBlob, 
            pCertificate->PublicKeyData.pBlob,
            pNewCert->PublicKeyData.wBlobLen );

    pNewCert->SignatureBlob.wBlobType = pCertificate->SignatureBlob.wBlobType;
    pNewCert->SignatureBlob.wBlobLen = pCertificate->SignatureBlob.wBlobLen;
    memcpy( pNewCert->SignatureBlob.pBlob, 
            pCertificate->SignatureBlob.pBlob,
            pNewCert->SignatureBlob.wBlobLen );

    //
    // free the old certificate and reset the pointer.
    //

    if( pContext->pServerCert )
    {
        FreeProprietaryCertificate( &pContext->pServerCert );
    }
    
    pContext->pServerCert = pNewCert;

    return( Status );

ErrorExit:

    if( pNewCert->PublicKeyData.pBlob )
    {
        free( pNewCert->PublicKeyData.pBlob );
    }

    if( pNewCert->SignatureBlob.pBlob )
    {
        free( pNewCert->SignatureBlob.pBlob );
    }

    free( pNewCert );

    return( Status );
}

#ifdef __cpluscplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\hclient\liclient\hcpack.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       hcpack.c
//
//  Contents:   Functions that are used to pack and unpack different messages
//
//  Classes:
//
//  Functions:  PackHydraClientNewLicenseRequest
//              PackHydraClientKeyExchangeInfo
//              PackHydraClientLicenseInfo
//              PackHydraClientPlatformInfo
//              PackHydraClientPlatformChallengeResponse
//              PackLicenseErrorMessage
//              UnPackLicenseErrorMessage
//              UnpackHydraServerLicenseRequest
//              UnPackHydraServerPlatformChallenge
//              UnPackHydraServerNewLicense
//              UnPackHydraServerUpgradeLicense
//              UnpackHydraServerCertificate
//
//  History:    12-19-97  v-sbhatt   Created
//
//----------------------------------------------------------------------------

//
//Includes
//

#include "windows.h"
#ifndef OS_WINCE
#include "stdio.h"
#endif // OS_WINCE
#include "stdlib.h"

#include <tchar.h>

#ifdef OS_WINCE
#include <wincelic.h>
#endif  //OS_WINCE

#include "license.h"
#include "hcpack.h"
#include "licdbg.h"

#define INVALID_INPUT_RETURN lsReturn = LICENSE_STATUS_INVALID_INPUT; LS_LOG_RESULT(lsReturn); goto ErrorReturn

#define EXTENDED_ERROR_CAPABILITY 0x80

//Copies a binary blob into a byte buffer. Does not check for any abnormal
//condition. After copying buffer points to the end of the blob
static VOID CopyBinaryBlob(
                           BYTE FAR *   pbBuffer,
                           PBinary_Blob pbbBlob,
                           DWORD FAR *  pdwCount
                           )
{
    *pdwCount = 0;

    //First copy the wBlobType data;
    memcpy(pbBuffer, &pbbBlob->wBlobType, sizeof(WORD));
    pbBuffer += sizeof(WORD);
    *pdwCount += sizeof(WORD);

    //Copy the wBlobLen data
    memcpy(pbBuffer, &pbbBlob->wBlobLen, sizeof(WORD));
    pbBuffer += sizeof(WORD);
    *pdwCount += sizeof(WORD);

    if( (pbbBlob->wBlobLen >0) && (pbbBlob->pBlob != NULL) )
    {
        //Copy the actual data
        memcpy(pbBuffer, pbbBlob->pBlob, pbbBlob->wBlobLen);
        pbBuffer += pbbBlob->wBlobLen;
        *pdwCount += pbbBlob->wBlobLen;
    }
}


//Function implementation

/***************************************************************************************
*   Function    : PackHydraClientNewLicenseRequest
*   Purpose     : This function takes a pointer to a Hydra_Client_New_License_Request
*                 structure and copies the data to the buffer pointed by pbBuffer.
*                 pcbBuffer should point the size of the buffer pointed by pbBuffer.
*                 After the function returns, pcbBuffer contains the no. of bytes copied
*                 in the buffer. If pbBuffer is NULL, the fucntion returns the size of
*                 the pbBuffer to be allocated.
*   Returns     : LICENSE_STATUS
****************************************************************************************/


LICENSE_STATUS
PackHydraClientNewLicenseRequest(
            IN      PHydra_Client_New_License_Request   pCanonical,
            IN      BOOL                                fExtendedError,
            OUT     BYTE FAR *                          pbBuffer,
            IN OUT  DWORD FAR *                         pcbBuffer
            )
{
    LICENSE_STATUS  lsReturn = LICENSE_STATUS_OK;
    BYTE FAR *      pbTemp = NULL;
    DWORD       dwCount = 0;
    Preamble    Header;

    LS_BEGIN(TEXT("PackHydraClientNewLicenseRequest"));
    //Check if the inputs are valid or not!
    if(pCanonical == NULL)
    {
        INVALID_INPUT_RETURN;;
    }

    if( pbBuffer == NULL && pcbBuffer == NULL )
    {
        INVALID_INPUT_RETURN;;
    }

    //Initialize Message Header
    Header.bMsgType = HC_NEW_LICENSE_REQUEST;
    Header.bVersion = PREAMBLE_VERSION_3_0;
    if( fExtendedError == TRUE)
    {
        Header.bVersion |= EXTENDED_ERROR_CAPABILITY;
    }
    Header.wMsgSize = 0;

    //Calculate the size of the message and place the data in Header.wMsgSize.
    //Start with Preamble size
    Header.wMsgSize += sizeof(Preamble);

    //dwPrefKeyExchangeAlg
    Header.wMsgSize += sizeof(pCanonical->dwPrefKeyExchangeAlg);

    //dwPlatformID
    Header.wMsgSize += sizeof(pCanonical->dwPlatformID);

    //Client Random
    Header.wMsgSize += LICENSE_RANDOM;

    //EncryptedPreMasterSecret
    Header.wMsgSize += sizeof(pCanonical->EncryptedPreMasterSecret.wBlobType) +
                       sizeof(pCanonical->EncryptedPreMasterSecret.wBlobLen) +
                       pCanonical->EncryptedPreMasterSecret.wBlobLen;

    //
    // client user name and machine name
    //

    Header.wMsgSize += sizeof(pCanonical->ClientUserName.wBlobType) +
                       sizeof(pCanonical->ClientUserName.wBlobLen) +
                       pCanonical->ClientUserName.wBlobLen;

    Header.wMsgSize += sizeof(pCanonical->ClientMachineName.wBlobType) +
                       sizeof(pCanonical->ClientMachineName.wBlobLen) +
                       pCanonical->ClientMachineName.wBlobLen;

    if(pbBuffer == NULL)
    {
        *pcbBuffer = (DWORD)Header.wMsgSize;
        LS_RETURN(lsReturn);
        goto CommonReturn;
    }
    else if(*pcbBuffer < (DWORD)Header.wMsgSize)
    {
        lsReturn = LICENSE_STATUS_INSUFFICIENT_BUFFER;
        LS_RETURN(lsReturn);
        goto ErrorReturn;
    }
    pbTemp = pbBuffer;
    *pcbBuffer = 0;

    //Now start copying different members of the New License structure to the
    //buffer specified by the caller

    //first copy the Header into the buffer
    memcpy(pbTemp, &Header, sizeof(Preamble));
    pbTemp += sizeof(Preamble);
    *pcbBuffer += sizeof(Preamble);

    //Copy the dwPrefKeyExchangeAlg parameter
    memcpy(pbTemp, &pCanonical->dwPrefKeyExchangeAlg, sizeof(pCanonical->dwPrefKeyExchangeAlg));
    pbTemp += sizeof(pCanonical->dwPrefKeyExchangeAlg);
    *pcbBuffer += sizeof(pCanonical->dwPrefKeyExchangeAlg);

    //Copy PlatformID;
    memcpy(pbTemp, &pCanonical->dwPlatformID, sizeof(pCanonical->dwPlatformID));
    pbTemp += sizeof(pCanonical->dwPlatformID);
    *pcbBuffer += sizeof(pCanonical->dwPlatformID);


    //Copy ClientRandom
    memcpy(pbTemp, pCanonical->ClientRandom, LICENSE_RANDOM);
    pbTemp += LICENSE_RANDOM;
    *pcbBuffer += LICENSE_RANDOM;

    //Copy EncryptedPreMasterSecret Blob
    CopyBinaryBlob(pbTemp, &pCanonical->EncryptedPreMasterSecret, &dwCount);
    pbTemp += dwCount;
    *pcbBuffer += dwCount;

    //
    // copy client user name
    //

    CopyBinaryBlob(pbTemp, &pCanonical->ClientUserName, &dwCount);
    pbTemp += dwCount;
    *pcbBuffer += dwCount;

    //
    // copy client machine name
    //

    CopyBinaryBlob(pbTemp, &pCanonical->ClientMachineName, &dwCount);
    pbTemp += dwCount;
    *pcbBuffer += dwCount;

    LS_LOG_RESULT(lsReturn);
CommonReturn:
    //return    lsReturn;
    LS_RETURN(lsReturn);

ErrorReturn:
    goto CommonReturn;
}


/***************************************************************************************
*   Function    : PackHydraClientLicenseInfo
*   Purpose     : This function takes a pointer to a Hydra_Client_License_Info structure
*                 and copies the data to the buffer pointed by pbBuffer. pcbBuffer
*                 should point the size of the buffer pointed by pbBuffer. After the
*                 function returns, pcbBuffer contains the no. of bytes copied in the
*                 buffer. If pbBuffer is NULL, the fucntion returns the size of the
*                 pbBuffer to be allocated
*   Returns     : LICENSE_STATUS
****************************************************************************************/

LICENSE_STATUS
PackHydraClientLicenseInfo(
            IN      PHydra_Client_License_Info      pCanonical,
            IN      BOOL                            fExtendedError,
            OUT     BYTE FAR *                      pbBuffer,
            IN OUT  DWORD FAR *                     pcbBuffer
            )
{
    LICENSE_STATUS      lsReturn = LICENSE_STATUS_OK;
    BYTE FAR *          pbTemp; //To be used while copying the data
    Preamble        Header;
    DWORD           dwCount = 0;
    //Check if the inputs are valid or not!

    LS_BEGIN(TEXT("PackHydraClientLicenseInfo\n"));
    if(pCanonical == NULL)
    {
        INVALID_INPUT_RETURN;
    }

    if( pbBuffer == NULL && pcbBuffer == NULL )
    {
        INVALID_INPUT_RETURN;
    }

    //Initialize Message Header
    Header.bMsgType = HC_LICENSE_INFO;
    Header.bVersion = PREAMBLE_VERSION_3_0;
    if(fExtendedError == TRUE)
    {
        Header.bVersion |= EXTENDED_ERROR_CAPABILITY;
    }
    Header.wMsgSize = 0;

    //Calculate the size of the message and place the data in Header.wMsgSize.
    //Start with Preamble size
    Header.wMsgSize += sizeof(Preamble);

    //dwPrefKeyExchangeAlg
    Header.wMsgSize += sizeof(pCanonical->dwPrefKeyExchangeAlg);

    //dwPlatformID
    Header.wMsgSize += sizeof(pCanonical->dwPlatformID);

    //ClientRandom
    Header.wMsgSize += LICENSE_RANDOM;

    //EncryptedPreMasterSecret
    Header.wMsgSize += sizeof(pCanonical->EncryptedPreMasterSecret.wBlobType) +
                       sizeof(pCanonical->EncryptedPreMasterSecret.wBlobLen) +
                       pCanonical->EncryptedPreMasterSecret.wBlobLen;


    //Add the license Info
    Header.wMsgSize += sizeof(pCanonical->LicenseInfo.wBlobType) +
                       sizeof(pCanonical->LicenseInfo.wBlobLen) +
                       pCanonical->LicenseInfo.wBlobLen;

    //Encrypted HWID
    Header.wMsgSize += sizeof(pCanonical->EncryptedHWID.wBlobType) +
                       sizeof(pCanonical->EncryptedHWID.wBlobLen) +
                       pCanonical->EncryptedHWID.wBlobLen;

    //MACData
    Header.wMsgSize += LICENSE_MAC_DATA;

    //If the input buffer is null, inform the user to allocate a buffer of size
    //*pcbBuffer!
    if(pbBuffer == NULL)
    {
        *pcbBuffer = (DWORD)Header.wMsgSize;
        LS_LOG_RESULT(lsReturn);
        goto CommonReturn;
    }
    //else, check if the allocated buffer size is more than the required!
    else if(*pcbBuffer < (DWORD)Header.wMsgSize)
    {
        lsReturn = LICENSE_STATUS_INSUFFICIENT_BUFFER;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    pbTemp = pbBuffer;
    *pcbBuffer = 0;

    //Now start copying different members of the New License structure to the
    //buffer specified by the caller

    //first copy the Header into the buffer
    memcpy(pbTemp, &Header, sizeof(Preamble));
    pbTemp += sizeof(Preamble);
    *pcbBuffer += sizeof(Preamble);

    //Copy the dwPrefKeyExchangeAlg parameter
    memcpy(pbTemp, &pCanonical->dwPrefKeyExchangeAlg, sizeof(pCanonical->dwPrefKeyExchangeAlg));
    pbTemp += sizeof(pCanonical->dwPrefKeyExchangeAlg);
    *pcbBuffer += sizeof(pCanonical->dwPrefKeyExchangeAlg);

    //Copy the dwPlatformID
    memcpy(pbTemp, &pCanonical->dwPlatformID, sizeof(pCanonical->dwPlatformID));
    pbTemp += sizeof(pCanonical->dwPlatformID);
    *pcbBuffer += sizeof(pCanonical->dwPlatformID);

    //Copy ClientRandom
    memcpy(pbTemp, pCanonical->ClientRandom, LICENSE_RANDOM);
    pbTemp += LICENSE_RANDOM;
    *pcbBuffer += LICENSE_RANDOM;

    //Copy EncryptedPreMasterSecret Blob
    CopyBinaryBlob(pbTemp, &pCanonical->EncryptedPreMasterSecret, &dwCount);
    pbTemp += dwCount;
    *pcbBuffer += dwCount;

    //Copy LicenseInfo
    CopyBinaryBlob(pbTemp, &pCanonical->LicenseInfo, &dwCount);
    pbTemp += dwCount;
    *pcbBuffer += dwCount;

    //Copy EncryptedHWID
    CopyBinaryBlob(pbTemp, &pCanonical->EncryptedHWID, &dwCount);
    pbTemp += dwCount;
    *pcbBuffer += dwCount;

    //Copy MACData
    memcpy(pbTemp, pCanonical->MACData, LICENSE_MAC_DATA);
    pbTemp += LICENSE_MAC_DATA;
    *pcbBuffer += LICENSE_MAC_DATA;

    LS_LOG_RESULT(lsReturn);
CommonReturn:
    //return lsReturn;
    LS_RETURN(lsReturn);
ErrorReturn:
    goto CommonReturn;
}


/****************************************************************************************
*   Function    : PackHydraClientPlatformChallengeResponse
*   Purpose     : This function takes a pointer to a Hydra_Client_Platform_Info structure
*                 and copies the data to the buffer pointed by pbBuffer. pcbBuffer should
*                 point the size of the buffer pointed by pbBuffer. After the function
*                 returns, pcbBuffer contains the no. of bytes copied in the buffer.
*                 If pbBuffer is NULL, the fucntion returns the size of the pbBuffer to
*                 be allocated
*   Returns     : LICENSE_STATUS
******************************************************************************************/


LICENSE_STATUS
PackHydraClientPlatformChallengeResponse(
            IN      PHydra_Client_Platform_Challenge_Response   pCanonical,
            IN      BOOL                                        fExtendedError,
            OUT     BYTE FAR *                                  pbBuffer,
            IN OUT  DWORD FAR *                                 pcbBuffer
            )
{
    LICENSE_STATUS      lsReturn = LICENSE_STATUS_OK;
    BYTE FAR *          pbTemp; //To be used while copying the data
    Preamble        Header;
    DWORD           dwCount = 0;
    //Check if the inputs are valid or not!

    LS_BEGIN(TEXT("PackHydraClientPlatformChallengeResponse\n"));

    if(pCanonical == NULL)
    {
        INVALID_INPUT_RETURN;
    }

    if( pbBuffer == NULL && pcbBuffer == NULL )
    {
        INVALID_INPUT_RETURN;
    }

    //Initialize Message Header
    Header.bMsgType = HC_PLATFORM_CHALENGE_RESPONSE;
    Header.bVersion = PREAMBLE_VERSION_3_0;
    if(fExtendedError == TRUE)
    {
        Header.bVersion |= EXTENDED_ERROR_CAPABILITY;
    }
    Header.wMsgSize = 0;

    //Calculate the size of the message and place the data in Header.wMsgSize.
    //Start with Preamble size
    Header.wMsgSize += sizeof(Preamble);

    //EncryptedChallengeResponse
    Header.wMsgSize += sizeof(pCanonical->EncryptedChallengeResponse.wBlobType) +
                       sizeof(pCanonical->EncryptedChallengeResponse.wBlobLen) +
                       pCanonical->EncryptedChallengeResponse.wBlobLen;

    //Encrypted HWID
    Header.wMsgSize += sizeof(pCanonical->EncryptedHWID.wBlobType) +
                       sizeof(pCanonical->EncryptedHWID.wBlobLen) +
                       pCanonical->EncryptedHWID.wBlobLen;

    //MACData
    Header.wMsgSize += LICENSE_MAC_DATA;

    if(pbBuffer == NULL)
    {
        *pcbBuffer = (DWORD)Header.wMsgSize;
        LS_LOG_RESULT(lsReturn);
        goto CommonReturn;
    }
    else if(*pcbBuffer < (DWORD)Header.wMsgSize)
    {
        lsReturn = LICENSE_STATUS_INSUFFICIENT_BUFFER;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    pbTemp = pbBuffer;
    *pcbBuffer = 0;

    //Now start copying different members of the New License structure to the
    //buffer specified by the caller

    //first copy the Header into the buffer
    memcpy(pbTemp, &Header, sizeof(Preamble));
    pbTemp += sizeof(Preamble);
    *pcbBuffer += sizeof(Preamble);

    //Copy LicenseInfo
    CopyBinaryBlob(pbTemp, &pCanonical->EncryptedChallengeResponse, &dwCount);
    pbTemp += dwCount;
    *pcbBuffer += dwCount;

    //Copy EncryptedHWID
    CopyBinaryBlob(pbTemp, &pCanonical->EncryptedHWID, &dwCount);
    pbTemp += dwCount;
    *pcbBuffer += dwCount;

    //Copy MACData
    memcpy(pbTemp, pCanonical->MACData, LICENSE_MAC_DATA);
    pbTemp += LICENSE_MAC_DATA;
    //CopyBinaryBlob(pbTemp, &pCanonical->MACData, &dwCount);
    *pcbBuffer += LICENSE_MAC_DATA;

    LS_LOG_RESULT(lsReturn);
CommonReturn:
    //return lsReturn;
    LS_RETURN(lsReturn);
ErrorReturn:
    goto CommonReturn;
}

/****************************************************************************************
*   Funtion     : PackLicenseErrorMessage
*   Purpose     : This function takes a pointer to a License_Error_Message structure
*                 and copies the data to the buffer pointed by pbBuffer. pcbBuffer should
*                 point the size of the buffer pointed by pbBuffer. After the function
*                 returns, pcbBuffer contains the no. of bytes copied in the buffer.
*                 If pbBuffer is NULL, the fucntion returns the size of the pbBuffer to
*                 be allocated
*   Return      : LICENSE_STATUS
*****************************************************************************************/

LICENSE_STATUS
PackLicenseErrorMessage(
            IN      PLicense_Error_Message          pCanonical,
            IN      BOOL                            fExtendedError,
            OUT     BYTE FAR *                      pbBuffer,
            IN OUT  DWORD FAR *                     pcbBuffer
            )
{
    LICENSE_STATUS      lsReturn = LICENSE_STATUS_OK;
    BYTE FAR *          pbTemp; //To be used while copying the data
    Preamble        Header;
    DWORD           dwCount = 0;

    LS_BEGIN(TEXT("PackLicenseErrorMessage\n"));

    //Check if the inputs are valid or not!
    if(pCanonical == NULL)
    {
        INVALID_INPUT_RETURN;
    }

    if( pbBuffer == NULL && pcbBuffer == NULL )
    {
        INVALID_INPUT_RETURN;
    }

    //Initialize Message Header
    Header.bMsgType = GM_ERROR_ALERT;
    Header.bVersion = PREAMBLE_VERSION_3_0;
    if(fExtendedError == TRUE)
    {
        Header.bVersion |= EXTENDED_ERROR_CAPABILITY;
    }
    Header.wMsgSize = 0;

    //Calculate the size of the message and place the data in Header.wMsgSize.
    //Start with Preamble size
    Header.wMsgSize += sizeof(Preamble);

    //dwErrorCode
    Header.wMsgSize += sizeof(pCanonical->dwErrorCode);

    //dwStateTransition
    Header.wMsgSize += sizeof(pCanonical->dwStateTransition);

    //bbErrorInfo
    Header.wMsgSize += sizeof(pCanonical->bbErrorInfo.wBlobType) +
                       sizeof(pCanonical->bbErrorInfo.wBlobLen) +
                       pCanonical->bbErrorInfo.wBlobLen;

    if(pbBuffer == NULL)
    {
        *pcbBuffer = (DWORD)Header.wMsgSize;
        LS_LOG_RESULT(lsReturn);
        goto CommonReturn;
    }
    else if(*pcbBuffer < (DWORD)Header.wMsgSize)
    {
        lsReturn = LICENSE_STATUS_INSUFFICIENT_BUFFER;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    pbTemp = pbBuffer;
    *pcbBuffer = 0;

    //Now start copying different members of the New License structure to the
    //buffer specified by the caller

    //first copy the Header into the buffer
    memcpy(pbTemp, &Header, sizeof(Preamble));
    pbTemp += sizeof(Preamble);
    *pcbBuffer += sizeof(Preamble);

    //Copy dwErrorCode
    memcpy(pbTemp, &pCanonical->dwErrorCode, sizeof(pCanonical->dwErrorCode));
    pbTemp += sizeof(pCanonical->dwErrorCode);
    *pcbBuffer += sizeof(pCanonical->dwErrorCode);

    //Copy dwStateTransition
    memcpy(pbTemp, &pCanonical->dwStateTransition, sizeof(pCanonical->dwStateTransition));
    pbTemp += sizeof(pCanonical->dwStateTransition);
    *pcbBuffer += sizeof(pCanonical->dwStateTransition);

    //Copy bbErrorInfo
    CopyBinaryBlob(pbTemp, &pCanonical->bbErrorInfo, &dwCount);
    pbTemp += dwCount;
    *pcbBuffer += dwCount;

    LS_LOG_RESULT(lsReturn);
CommonReturn:
    LS_RETURN(lsReturn);
    //return lsReturn;
ErrorReturn:
    goto CommonReturn;
}

/****************************************************************************************
*   Function : UnpackLicenseErrorMessage
*   Purpose  : To unpack a binary blob into a License_Error_Message structure.
*   Note     : The caller should initialize the pointer. All the necessary allocation is
*              done by the function itself.
*              The caller should free all the memory components once it is no longer needed.
*   Return   : License_Status
*****************************************************************************************/

LICENSE_STATUS
UnPackLicenseErrorMessage(
            IN      BYTE FAR *                      pbMessage,
            IN      DWORD                           cbMessage,
            OUT     PLicense_Error_Message          pCanonical
            )
{
    LICENSE_STATUS      lsReturn = LICENSE_STATUS_OK;
    BYTE FAR *          pbTemp;
    DWORD           dwTemp;
    DWORD           dwSize;

    LS_BEGIN(TEXT("UnpackLicenseErrorMessage\n"));

    if(pbMessage == NULL)
    {
        INVALID_INPUT_RETURN;
    }

    if(pCanonical == NULL)
    {
        INVALID_INPUT_RETURN;
    }

	//Memset pCanonical structure to zero    
    memset(pCanonical, 0x00, sizeof(License_Error_Message));

    LS_DUMPSTRING(cbMessage, pbMessage);

    pbTemp = pbMessage;
    dwTemp = cbMessage;

    if (dwTemp < 2 * sizeof(DWORD))
    {
        INVALID_INPUT_RETURN;
    }

    //Assign dwErrorCode

    pCanonical->dwErrorCode = *( UNALIGNED DWORD* )pbTemp;

    pbTemp += sizeof(DWORD);
    dwTemp -= sizeof(DWORD);

    //Assign dwStateTransition
    pCanonical->dwStateTransition = *( UNALIGNED DWORD* )pbTemp;

    pbTemp += sizeof(DWORD);
    dwTemp -= sizeof(DWORD);

    if (dwTemp < 2 * sizeof(WORD))
    {
        INVALID_INPUT_RETURN;
    }

    pCanonical->bbErrorInfo.wBlobType = *( UNALIGNED WORD* )pbTemp;

    pbTemp += sizeof(WORD);
    dwTemp -= sizeof(WORD);

    pCanonical->bbErrorInfo.wBlobLen = *( UNALIGNED WORD* )pbTemp;

    pbTemp += sizeof(WORD);
    dwTemp -= sizeof(WORD);

    dwSize = pCanonical->bbErrorInfo.wBlobLen;

    if(dwSize > dwTemp)
    {
        INVALID_INPUT_RETURN;
    }

    if(pCanonical->bbErrorInfo.wBlobLen>0)
    {
        if( NULL == (pCanonical->bbErrorInfo.pBlob = (BYTE FAR *)malloc(pCanonical->bbErrorInfo.wBlobLen)) )
        {
            pCanonical->bbErrorInfo.wBlobLen = 0;

            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }
        memset(pCanonical->bbErrorInfo.pBlob, 0x00, pCanonical->bbErrorInfo.wBlobLen);
        memcpy(pCanonical->bbErrorInfo.pBlob, pbTemp, pCanonical->bbErrorInfo.wBlobLen);
    }
    else
    {
        pCanonical->bbErrorInfo.pBlob = NULL;
    }


    LS_LOG_RESULT(lsReturn);

ErrorReturn:

    LS_RETURN(lsReturn);
}


/****************************************************************************************
*   Function : UnpackHydraServerLicenseRequest
*   Purpose  : To unpack a binary blob into a Hydra_Server_License_Request structure.
*   Note     : The caller should initialize the output pointer. All the necessary
*              allocation for different structure components is done by the function itself.
*              The caller should free all the memory components once it is no longer needed.
*   Return   : License_Status
*****************************************************************************************/


LICENSE_STATUS
UnpackHydraServerLicenseRequest(
            IN      BYTE FAR *                      pbMessage,
            IN      DWORD                           cbMessage,
            OUT     PHydra_Server_License_Request   pCanonical
            )
{
    LICENSE_STATUS  lsReturn = LICENSE_STATUS_OK;
    BYTE FAR *pbTemp = NULL;
    DWORD       dwTemp = 0;
    DWORD       i = 0;

    LS_BEGIN(TEXT("UnpackHydraServerLicenseRequest\n"));

    if(pbMessage == NULL)
    {
        INVALID_INPUT_RETURN;
    }

    if(pCanonical == NULL)
    {
        INVALID_INPUT_RETURN;
    }

    LS_DUMPSTRING(cbMessage, pbMessage);

    pbTemp = pbMessage;
    dwTemp = cbMessage;

    if (dwTemp < LICENSE_RANDOM)
    {
        INVALID_INPUT_RETURN;
    }

    //Copy Server Random
    memcpy(pCanonical->ServerRandom, pbTemp, LICENSE_RANDOM);
    pbTemp += LICENSE_RANDOM;
    dwTemp -= LICENSE_RANDOM;

    if (dwTemp < 2 * sizeof(DWORD))
    {
        INVALID_INPUT_RETURN;
    }

    //Copy the ProductInfo structure
    pCanonical->ProductInfo.dwVersion = *( UNALIGNED  DWORD* )pbTemp;

    pbTemp += sizeof(DWORD);
    dwTemp -= sizeof(DWORD);

    pCanonical->ProductInfo.cbCompanyName = *( UNALIGNED DWORD* )pbTemp;

    pbTemp += sizeof(DWORD);
    dwTemp -= sizeof(DWORD);

    if(pCanonical->ProductInfo.cbCompanyName>0)
    {
        if(dwTemp < pCanonical->ProductInfo.cbCompanyName)
        {
            INVALID_INPUT_RETURN;
        }

        if( NULL == (pCanonical->ProductInfo.pbCompanyName = (BYTE FAR *)malloc(pCanonical->ProductInfo.cbCompanyName)) )
        {
            pCanonical->ProductInfo.cbCompanyName = 0;

            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }

        memcpy(pCanonical->ProductInfo.pbCompanyName, pbTemp, pCanonical->ProductInfo.cbCompanyName);
        pbTemp += pCanonical->ProductInfo.cbCompanyName;
        dwTemp -= pCanonical->ProductInfo.cbCompanyName;
    }
    
    if(dwTemp < sizeof(DWORD))
    {
        INVALID_INPUT_RETURN;
    }

    pCanonical->ProductInfo.cbProductID = *( UNALIGNED DWORD* )pbTemp;

    pbTemp += sizeof(DWORD);
    dwTemp -= sizeof(DWORD);

    if(pCanonical->ProductInfo.cbProductID>0)
    {
        if(dwTemp < pCanonical->ProductInfo.cbProductID)
        {
            INVALID_INPUT_RETURN;
        }

        if( NULL == (pCanonical->ProductInfo.pbProductID = (BYTE FAR *)malloc(pCanonical->ProductInfo.cbProductID)) )
        {
            pCanonical->ProductInfo.cbProductID = 0;

            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }

        memcpy(pCanonical->ProductInfo.pbProductID, pbTemp, pCanonical->ProductInfo.cbProductID);

        pbTemp += pCanonical->ProductInfo.cbProductID;
        dwTemp -= pCanonical->ProductInfo.cbProductID;
    }
    
    if(dwTemp < sizeof(WORD)*2)
    {
        INVALID_INPUT_RETURN;
    }

    //Copy KeyExchngList
    pCanonical->KeyExchngList.wBlobType = *( UNALIGNED WORD* )pbTemp;

    pbTemp += sizeof(WORD);
    dwTemp -= sizeof(WORD);

    pCanonical->KeyExchngList.wBlobLen = *( UNALIGNED WORD* )pbTemp;

    pbTemp += sizeof(WORD);
    dwTemp -= sizeof(WORD);

    if( pCanonical->KeyExchngList.wBlobLen > 0 )
    {
        if(dwTemp < pCanonical->KeyExchngList.wBlobLen)
        {
            INVALID_INPUT_RETURN;
        }

        if( NULL == (pCanonical->KeyExchngList.pBlob = (BYTE FAR *)malloc(pCanonical->KeyExchngList.wBlobLen)) )
        {
            pCanonical->KeyExchngList.wBlobLen = 0;

            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }

        memcpy(pCanonical->KeyExchngList.pBlob, pbTemp, pCanonical->KeyExchngList.wBlobLen);

        pbTemp += pCanonical->KeyExchngList.wBlobLen;
        dwTemp -= pCanonical->KeyExchngList.wBlobLen;
    }
    
    if(dwTemp < sizeof(WORD)*2)
    {
        INVALID_INPUT_RETURN;
    }

    //Copy ServerCert
    pCanonical->ServerCert.wBlobType = *( UNALIGNED WORD* )pbTemp;

    pbTemp += sizeof(WORD);
    dwTemp -= sizeof(WORD);

    pCanonical->ServerCert.wBlobLen = *( UNALIGNED WORD* )pbTemp;

    pbTemp += sizeof(WORD);
    dwTemp -= sizeof(WORD);

    if(pCanonical->ServerCert.wBlobLen >0)
    {
        if(dwTemp < pCanonical->ServerCert.wBlobLen)
        {
            INVALID_INPUT_RETURN;
        }

        if( NULL == (pCanonical->ServerCert.pBlob = (BYTE FAR *)malloc(pCanonical->ServerCert.wBlobLen)) )
        {
            pCanonical->ServerCert.wBlobLen = 0;

            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }

        memcpy(pCanonical->ServerCert.pBlob, pbTemp, pCanonical->ServerCert.wBlobLen);

        pbTemp += pCanonical->ServerCert.wBlobLen;
        dwTemp -= pCanonical->ServerCert.wBlobLen;
    }
    
    if(dwTemp < sizeof(DWORD))
    {
        INVALID_INPUT_RETURN;
    }

    //Copy the scopelist
    pCanonical->ScopeList.dwScopeCount = *( UNALIGNED DWORD* )pbTemp;

    pbTemp += sizeof( DWORD );
    dwTemp -= sizeof( DWORD );
    
    if(dwTemp < pCanonical->ScopeList.dwScopeCount*sizeof(Binary_Blob))
    {
        pCanonical->ScopeList.dwScopeCount = 0;
        INVALID_INPUT_RETURN;
    }

    if( NULL == (pCanonical->ScopeList.Scopes = (PBinary_Blob)malloc(pCanonical->ScopeList.dwScopeCount*sizeof(Binary_Blob))) )
    {
        pCanonical->ScopeList.dwScopeCount = 0;

        lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
        LS_LOG_RESULT(lsReturn);
        goto ErrorReturn;
    }

    memset(pCanonical->ScopeList.Scopes, 0x00, pCanonical->ScopeList.dwScopeCount*sizeof(Binary_Blob));

    for(i = 0; i<pCanonical->ScopeList.dwScopeCount; i++ )
    {
        if(dwTemp < sizeof(WORD)*2)
        {
            pCanonical->ScopeList.dwScopeCount = i;
            INVALID_INPUT_RETURN;
        }

        pCanonical->ScopeList.Scopes[i].wBlobType = *( UNALIGNED WORD* )pbTemp;

        pbTemp += sizeof(WORD);
        dwTemp -= sizeof(WORD);

        pCanonical->ScopeList.Scopes[i].wBlobLen = *( UNALIGNED WORD* )pbTemp;

        pbTemp += sizeof(WORD);
        dwTemp -= sizeof(WORD);
        
        if(dwTemp < pCanonical->ScopeList.Scopes[i].wBlobLen)
        {
            pCanonical->ScopeList.dwScopeCount = i;
            INVALID_INPUT_RETURN;
        }

        if( NULL ==(pCanonical->ScopeList.Scopes[i].pBlob = (BYTE FAR *)malloc(pCanonical->ScopeList.Scopes[i].wBlobLen)) )
        {
            pCanonical->ScopeList.Scopes[i].wBlobLen = 0;

            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }

        memcpy(pCanonical->ScopeList.Scopes[i].pBlob, pbTemp, pCanonical->ScopeList.Scopes[i].wBlobLen);

        pbTemp += pCanonical->ScopeList.Scopes[i].wBlobLen;
        dwTemp -= pCanonical->ScopeList.Scopes[i].wBlobLen;

    }

    LS_LOG_RESULT(lsReturn);
    LS_RETURN(lsReturn);

ErrorReturn:

    if (pCanonical)
    {
        if(pCanonical->ProductInfo.pbCompanyName)
        {
            free(pCanonical->ProductInfo.pbCompanyName);
            pCanonical->ProductInfo.pbCompanyName = NULL;
        }

        if(pCanonical->ProductInfo.pbProductID)
        {
            free(pCanonical->ProductInfo.pbProductID);
            pCanonical->ProductInfo.pbProductID = NULL;
        }

        if(pCanonical->KeyExchngList.pBlob)
        {
            free(pCanonical->KeyExchngList.pBlob);
            pCanonical->KeyExchngList.pBlob = NULL;
        }

        if(pCanonical->ServerCert.pBlob)
        {
            free(pCanonical->ServerCert.pBlob);
            pCanonical->ServerCert.pBlob = NULL;
        }

        for(i = 0; i<pCanonical->ScopeList.dwScopeCount; i++ )
        {
            if(pCanonical->ScopeList.Scopes[i].pBlob)
            {
                free(pCanonical->ScopeList.Scopes[i].pBlob);
                pCanonical->ScopeList.Scopes[i].pBlob = NULL;
            }
        }
        if(pCanonical->ScopeList.Scopes)
        {
            free(pCanonical->ScopeList.Scopes);
            pCanonical->ScopeList.Scopes = NULL;
        }
    }

    LS_RETURN(lsReturn);
}

/****************************************************************************************
*   Function : UnpackHydraPlatformChallenge
*   Purpose  : To unpack a binary blob into a Hydra_Server_Platform_Challenge structure.
*   Note     : The caller should initialize the output pointer. All the necessary
*              allocation for different structure components is done by the function itself.
*              The caller should free all the memory components once it is no longer needed.
*   Return   : License_Status
*****************************************************************************************/




LICENSE_STATUS
UnPackHydraServerPlatformChallenge(
            IN      BYTE FAR *                          pbMessage,
            IN      DWORD                               cbMessage,
            OUT     PHydra_Server_Platform_Challenge    pCanonical
            )
{
    LICENSE_STATUS      lsReturn = LICENSE_STATUS_OK;
    BYTE FAR *      pbTemp = NULL;
    DWORD       dwTemp = 0;

    LS_BEGIN(TEXT("UnpackHydraServerPlatformChallenge\n"));

    if(pbMessage == NULL)
    {
        INVALID_INPUT_RETURN;
    }
    if(pCanonical == NULL)
    {
        INVALID_INPUT_RETURN;
    }

    LS_DUMPSTRING(cbMessage, pbMessage);

    pbTemp = pbMessage;
    dwTemp = cbMessage;

    if (dwTemp < sizeof(DWORD))
    {
        INVALID_INPUT_RETURN;
    }

    //Assign dwConnectFlags
    pCanonical->dwConnectFlags = *( UNALIGNED DWORD* )pbTemp;

    pbTemp += sizeof(DWORD);
    dwTemp -= sizeof(DWORD);

    if (dwTemp < 2 * sizeof(WORD))
    {
        INVALID_INPUT_RETURN;
    }

    //Assign EncryptedPlatformChallenge
    pCanonical->EncryptedPlatformChallenge.wBlobType = *( UNALIGNED WORD* )pbTemp;

    pbTemp += sizeof(WORD);
    dwTemp -= sizeof(WORD);

    pCanonical->EncryptedPlatformChallenge.wBlobLen = *( UNALIGNED WORD* )pbTemp;

    pbTemp += sizeof(WORD);
    dwTemp -= sizeof(WORD);

    if(pCanonical->EncryptedPlatformChallenge.wBlobLen >0)
    {
        if (dwTemp < pCanonical->EncryptedPlatformChallenge.wBlobLen)
        {
            INVALID_INPUT_RETURN;
        }

        if( NULL == (pCanonical->EncryptedPlatformChallenge.pBlob = (BYTE FAR *)malloc(pCanonical->EncryptedPlatformChallenge.wBlobLen)) )
        {
            pCanonical->EncryptedPlatformChallenge.wBlobLen = 0;

            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }

        memcpy(pCanonical->EncryptedPlatformChallenge.pBlob, pbTemp, pCanonical->EncryptedPlatformChallenge.wBlobLen);

        pbTemp += pCanonical->EncryptedPlatformChallenge.wBlobLen;
        dwTemp -= pCanonical->EncryptedPlatformChallenge.wBlobLen;
    }

    if(dwTemp < LICENSE_MAC_DATA)
    {
        INVALID_INPUT_RETURN;
    }

    //Assign MACData
    memcpy(pCanonical->MACData, pbTemp, LICENSE_MAC_DATA);
    pbTemp += LICENSE_MAC_DATA;
    dwTemp -= LICENSE_MAC_DATA;

    LS_LOG_RESULT(lsReturn);
    LS_RETURN(lsReturn);

ErrorReturn:
    if (pCanonical)
    {
        if(pCanonical->EncryptedPlatformChallenge.pBlob)
        {
            free(pCanonical->EncryptedPlatformChallenge.pBlob);
            pCanonical->EncryptedPlatformChallenge.pBlob = NULL;
        }
    }

    LS_RETURN(lsReturn);
}

/****************************************************************************************
*   Function : UnpackHydraServerNewLicense
*   Purpose  : To unpack a binary blob into a Hydra_Server_New_License structure.
*   Note     : The caller should initialize the output pointer. All the necessary
*              allocation for different structure components is done by the function itself.
*              The caller should free all the memory components once it is no longer needed.
*   Return   : License_Status
*****************************************************************************************/


LICENSE_STATUS
UnPackHydraServerNewLicense(
            IN      BYTE FAR *                      pbMessage,
            IN      DWORD                           cbMessage,
            OUT     PHydra_Server_New_License       pCanonical
            )
{
    LICENSE_STATUS  lsReturn = LICENSE_STATUS_OK;
    BYTE FAR *  pbTemp = NULL;
    DWORD   dwTemp = 0;

    LS_BEGIN(TEXT("UnpackHydraServerNewLicense\n"));

    if( (pbMessage == NULL) || (pCanonical == NULL ) )
    {
        INVALID_INPUT_RETURN;
    }

    memset(pCanonical, 0x00, sizeof(Hydra_Server_New_License));

    LS_DUMPSTRING(cbMessage, pbMessage);

    pbTemp = pbMessage;
    dwTemp = cbMessage;

    if (dwTemp < 2 * sizeof(WORD))
    {
        INVALID_INPUT_RETURN;
    }

    //Assign EncryptedNewLicenseInfo
    pCanonical->EncryptedNewLicenseInfo.wBlobType = *( UNALIGNED WORD* )pbTemp;

    pbTemp += sizeof(WORD);
    dwTemp -= sizeof(WORD);

    pCanonical->EncryptedNewLicenseInfo.wBlobLen = *( UNALIGNED WORD* )pbTemp;

    pbTemp += sizeof(WORD);
    dwTemp -= sizeof(WORD);

    if(pCanonical->EncryptedNewLicenseInfo.wBlobLen > 0)
    {
        if (dwTemp < pCanonical->EncryptedNewLicenseInfo.wBlobLen)
        {
            INVALID_INPUT_RETURN;
        }

        if( NULL == (pCanonical->EncryptedNewLicenseInfo.pBlob = (BYTE FAR *)malloc(pCanonical->EncryptedNewLicenseInfo.wBlobLen)) )
        {
            pCanonical->EncryptedNewLicenseInfo.wBlobLen = 0;

            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }

        memcpy(pCanonical->EncryptedNewLicenseInfo.pBlob, pbTemp, pCanonical->EncryptedNewLicenseInfo.wBlobLen);

        pbTemp += pCanonical->EncryptedNewLicenseInfo.wBlobLen;
        dwTemp -= pCanonical->EncryptedNewLicenseInfo.wBlobLen;
    }

    if(dwTemp < LICENSE_MAC_DATA)
    {
        INVALID_INPUT_RETURN;
    }

    //Copy MACData
    memcpy(pCanonical->MACData, pbTemp, LICENSE_MAC_DATA);
    pbTemp += LICENSE_MAC_DATA;
    dwTemp -= LICENSE_MAC_DATA;

    LS_LOG_RESULT(lsReturn);
    LS_RETURN(lsReturn);

ErrorReturn:
    if (pCanonical)
    {
        if(pCanonical->EncryptedNewLicenseInfo.pBlob)
        {
            free(pCanonical->EncryptedNewLicenseInfo.pBlob);
            pCanonical->EncryptedNewLicenseInfo.pBlob = NULL;
        }
    }

    LS_RETURN(lsReturn);
}


/****************************************************************************************
*   Function : UnpackHydraServerUpgradeLicense
*   Purpose  : To unpack a binary blob into a Hydra_Server_Upgrade_License structure.
*   Note     : The caller should initialize the output pointer. All the necessary
*              allocation for different structure components is done by the function itself.
*              The caller should free all the memory components once it is no longer needed.
*              Internally this function calls UnpackHydraServerUpgradeLicense.
*   Return   : License_Status
*****************************************************************************************/


LICENSE_STATUS
UnPackHydraServerUpgradeLicense(
            IN      BYTE FAR *                      pbMessage,
            IN      DWORD                           cbMessage,
            OUT     PHydra_Server_Upgrade_License   pCanonical
            )
{
    //Call UnpackHydraServerNewLicense as both the messages are same
    LS_BEGIN(TEXT("UnpackHydraServerUpgradeLicense\n"));
    return UnPackHydraServerNewLicense(pbMessage, cbMessage, pCanonical);
}

#if 0

//
// moved to cryptkey.c
//

/****************************************************************************************
*   Function : UnpackHydraServerCertificate
*   Purpose  : To unpack a binary blob into a Hydra_Server_Cert structure.
*   Note     : The caller should initialize the output pointer. All the necessary
*              allocation for different structure components is done by the function itself.
*              The caller should free all the memory components once it is no longer needed.
*   Return   : License_Status
*****************************************************************************************/


LICENSE_STATUS
UnpackHydraServerCertificate(
                             IN     BYTE FAR *          pbMessage,
                             IN     DWORD               cbMessage,
                             OUT    PHydra_Server_Cert  pCanonical
                             )
{
    LICENSE_STATUS      lsReturn = LICENSE_STATUS_OK;
    BYTE FAR *  pbTemp = NULL;
    DWORD   dwTemp = 0;

    LS_BEGIN(TEXT("UnpackHydraServerCertificate\n"));

    if( (pbMessage == NULL) || (pCanonical == NULL ) )
    {
        INVALID_INPUT_RETURN;
    }

    dwTemp = 3*sizeof(DWORD) + 4*sizeof(WORD);

    if(dwTemp > cbMessage)
    {
        INVALID_INPUT_RETURN;
    }

    memset(pCanonical, 0x00, sizeof(Hydra_Server_Cert));

    LS_DUMPSTRING(cbMessage, pbMessage);

    pbTemp = pbMessage;
    dwTemp = cbMessage;

    //Assign dwVersion

    pCanonical->dwVersion = *( UNALIGNED DWORD* )pbTemp;

    pbTemp += sizeof(DWORD);
    dwTemp -= sizeof(DWORD);

    //Assign dwSigAlgID
    pCanonical->dwSigAlgID = *( UNALIGNED DWORD* )pbTemp;

    pbTemp += sizeof(DWORD);
    dwTemp -= sizeof(DWORD);

    //Assign dwSignID
    pCanonical->dwKeyAlgID  = *( UNALIGNED DWORD* )pbTemp;

    pbTemp += sizeof(DWORD);
    dwTemp -= sizeof(DWORD);

    //Assign PublicKeyData
    pCanonical->PublicKeyData.wBlobType = *( UNALIGNED WORD* )pbTemp;

    pbTemp += sizeof(WORD);
    dwTemp -= sizeof(WORD);

    if( pCanonical->PublicKeyData.wBlobType != BB_RSA_KEY_BLOB )
    {
        INVALID_INPUT_RETURN;
    }
    pCanonical->PublicKeyData.wBlobLen = *( UNALIGNED WORD* )pbTemp;

    pbTemp += sizeof(WORD);
    dwTemp -= sizeof(WORD);

    if(pCanonical->PublicKeyData.wBlobLen >0)
    {
        if( NULL ==(pCanonical->PublicKeyData.pBlob = (BYTE FAR *)malloc(pCanonical->PublicKeyData.wBlobLen)) )
        {
            pCanonical->PublicKeyData.wBlobLen = 0;

            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }
        memset(pCanonical->PublicKeyData.pBlob, 0x00, pCanonical->PublicKeyData.wBlobLen);
        memcpy(pCanonical->PublicKeyData.pBlob, pbTemp, pCanonical->PublicKeyData.wBlobLen);
        pbTemp += pCanonical->PublicKeyData.wBlobLen;
        dwTemp -= pCanonical->PublicKeyData.wBlobLen;
    }

    //Assign SignatureBlob
    pCanonical->SignatureBlob.wBlobType = *( UNALIGNED WORD* )pbTemp;

    pbTemp += sizeof(WORD);
    dwTemp -= sizeof(WORD);

    if( pCanonical->SignatureBlob.wBlobType != BB_RSA_SIGNATURE_BLOB )
    {
        INVALID_INPUT_RETURN;
    }
    pCanonical->SignatureBlob.wBlobLen = *( UNALIGNED WORD* )pbTemp;

    pbTemp += sizeof(WORD);
    dwTemp -= sizeof(WORD);

    if(pCanonical->SignatureBlob.wBlobLen >0)
    {
        if( NULL ==(pCanonical->SignatureBlob.pBlob = (BYTE FAR *)malloc(pCanonical->SignatureBlob.wBlobLen)) )
        {
            pCanonical->SignatureBlob.wBlobLen = 0;

            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }
        memset(pCanonical->SignatureBlob.pBlob, 0x00, pCanonical->SignatureBlob.wBlobLen);
        memcpy(pCanonical->SignatureBlob.pBlob, pbTemp, pCanonical->SignatureBlob.wBlobLen);
        pbTemp += pCanonical->SignatureBlob.wBlobLen;
        dwTemp -= pCanonical->SignatureBlob.wBlobLen;
    }

    LS_LOG_RESULT(lsReturn);

    LS_RETURN(lsReturn);

ErrorReturn:
    if (pCanonical)
    {
        if(pCanonical->PublicKeyData.pBlob)
        {
            free(pCanonical->PublicKeyData.pBlob);
            pCanonical->PublicKeyData.pBlob = NULL;
        }
        
        if(pCanonical->SignatureBlob.pBlob)
        {
            free(pCanonical->SignatureBlob.pBlob);
            pCanonical->SignatureBlob.pBlob = NULL;
        }

        memset(pCanonical, 0x00, sizeof(Hydra_Server_Cert));
    }

    LS_RETURN(lsReturn);
}

#endif


/****************************************************************************************
*   Function : UnpackNewLicenseInfo
*   Purpose  : To unpack a binary blob into a New_license_Info structure
*   Note     : The caller should initialize the output pointer. All the necessary
*              allocation for different structure components is done by the function itself.
*              The caller should free all the memory components once it is no longer needed.
*   Return   : License_Status
*****************************************************************************************/

LICENSE_STATUS
UnpackNewLicenseInfo(
                     BYTE FAR *         pbMessage,
                     DWORD              cbMessage,
                     PNew_License_Info  pCanonical
                     )
{
    LICENSE_STATUS lsReturn = LICENSE_STATUS_OK;
    BYTE FAR *      pbTemp = NULL;
    DWORD       dwTemp = 0, dw = 0;

    LS_BEGIN(TEXT("UnpackNewLicenseInfo\n"));

    //Check for the validity of the inputs
    if( (pbMessage == NULL) || (pCanonical == 0) )
    {
        INVALID_INPUT_RETURN;
    }

    dwTemp = 5*sizeof(DWORD);

    if(dwTemp > cbMessage)
    {
        INVALID_INPUT_RETURN;
    }

    memset(pCanonical, 0x00, sizeof(New_License_Info));

    LS_DUMPSTRING(cbMessage, pbMessage);

    dwTemp = cbMessage;
    pbTemp = pbMessage;

    //Assign version
    pCanonical->dwVersion = *( UNALIGNED DWORD* )pbTemp;

    pbTemp += sizeof(DWORD);
    dwTemp -= sizeof(DWORD);

    //Assign Scope Data
    pCanonical->cbScope = *( UNALIGNED DWORD* )pbTemp;

    pbTemp += sizeof(DWORD);
    dwTemp -= sizeof(DWORD);

    dw = pCanonical->cbScope + 3*sizeof(DWORD);

    if( dw>dwTemp )
    {
        INVALID_INPUT_RETURN;
    }

    if( pCanonical->cbScope>0 )
    {
        if( NULL == (pCanonical->pbScope = (BYTE FAR *)malloc(pCanonical->cbScope)) )
        {
            pCanonical->cbScope = 0;

            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }
        memset(pCanonical->pbScope, 0x00, pCanonical->cbScope);
        memcpy(pCanonical->pbScope, pbTemp, pCanonical->cbScope);

        pbTemp += pCanonical->cbScope;
        dwTemp -= pCanonical->cbScope;
    }

    //Assign CompanyName Data
    pCanonical->cbCompanyName = *( UNALIGNED DWORD* )pbTemp;

    pbTemp += sizeof(DWORD);
    dwTemp -= sizeof(DWORD);

    dw = pCanonical->cbCompanyName + 2*sizeof(DWORD);
    if( dw>dwTemp)
    {
        INVALID_INPUT_RETURN;
    }
    if( pCanonical->cbCompanyName>0 )
    {
        if( NULL == (pCanonical->pbCompanyName = (BYTE FAR *)malloc(pCanonical->cbCompanyName)) )
        {
            pCanonical->cbCompanyName = 0;

            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }
        memset(pCanonical->pbCompanyName, 0x00, pCanonical->cbCompanyName);
        memcpy(pCanonical->pbCompanyName, pbTemp, pCanonical->cbCompanyName);

        pbTemp += pCanonical->cbCompanyName;
        dwTemp -= pCanonical->cbCompanyName;
    }

    //Assign ProductID data

    pCanonical->cbProductID = *( UNALIGNED DWORD* )pbTemp;

    pbTemp += sizeof(DWORD);
    dwTemp -= sizeof(DWORD);

    dw = pCanonical->cbProductID + sizeof(DWORD);
    if(dw>dwTemp)
    {
        INVALID_INPUT_RETURN;
    }
    if( pCanonical->cbProductID>0 )
    {
        if( NULL == (pCanonical->pbProductID = (BYTE FAR *)malloc(pCanonical->cbProductID)) )
        {
            pCanonical->cbProductID = 0;

            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            goto ErrorReturn;
        }
        memset(pCanonical->pbProductID, 0x00, pCanonical->cbProductID);
        memcpy(pCanonical->pbProductID, pbTemp, pCanonical->cbProductID);

        pbTemp += pCanonical->cbProductID;
        dwTemp -= pCanonical->cbProductID;
    }

    //Assign LicenseInfo data
    pCanonical->cbLicenseInfo = *( UNALIGNED DWORD* )pbTemp;

    pbTemp += sizeof(DWORD);
    dwTemp -= sizeof(DWORD);

    dw = pCanonical->cbLicenseInfo;

    if( dw>dwTemp )
    {
        INVALID_INPUT_RETURN;
    }
    if( pCanonical->cbLicenseInfo>0 )
    {
        if( NULL == (pCanonical->pbLicenseInfo = (BYTE FAR *)malloc(pCanonical->cbLicenseInfo)) )
        {
            pCanonical->cbLicenseInfo = 0;

            lsReturn = LICENSE_STATUS_OUT_OF_MEMORY;
            LS_LOG_RESULT(lsReturn);
            goto ErrorReturn;
        }
        memset(pCanonical->pbLicenseInfo, 0x00, pCanonical->cbLicenseInfo);
        memcpy(pCanonical->pbLicenseInfo, pbTemp, pCanonical->cbLicenseInfo);

        pbTemp += pCanonical->cbLicenseInfo;
        dwTemp -= pCanonical->cbLicenseInfo;
    }

    LS_LOG_RESULT(lsReturn);

    LS_RETURN(lsReturn);

ErrorReturn:
    if (pCanonical)
    {
        if(pCanonical->pbScope)
        {
            free(pCanonical->pbScope);
            pCanonical->pbScope = NULL;
        }

        if(pCanonical->pbCompanyName)
        {
            free(pCanonical->pbCompanyName);
            pCanonical->pbCompanyName = NULL;
        }

        if(pCanonical->pbProductID)
        {
            free(pCanonical->pbProductID);
            pCanonical->pbProductID = NULL;
        }

        if(pCanonical->pbLicenseInfo)
        {
            free(pCanonical->pbLicenseInfo);
            pCanonical->pbLicenseInfo = NULL;
        }
    }

    LS_RETURN(lsReturn);
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
UnPackExtendedErrorInfo( 
                   UINT32       *puiExtendedErrorInfo,
                   Binary_Blob  *pbbErrorInfo)
{
    LICENSE_STATUS lsReturn = LICENSE_STATUS_OK;
    BYTE FAR *     pbTemp = NULL;
    DWORD          dwTemp = 0;
    WORD           wVersion;

    LS_BEGIN(TEXT("UnpackExtendedErrorInfo\n"));

    //Check for the validity of the inputs
    if( (puiExtendedErrorInfo == NULL) || (pbbErrorInfo == NULL) )
    {
        INVALID_INPUT_RETURN;
    }

    dwTemp = sizeof(WORD) + sizeof(WORD) + sizeof(UINT32);

    if(dwTemp > pbbErrorInfo->wBlobLen)
    {
        INVALID_INPUT_RETURN;
    }

    pbTemp = pbbErrorInfo->pBlob;

    wVersion = *(UNALIGNED WORD*)pbTemp;

    pbTemp += sizeof(WORD);

    if (wVersion < BB_ERROR_BLOB_VERSION)
    {
        //
        // Old version
        //

        INVALID_INPUT_RETURN;
    }

    //
    // skip reserved field
    //

    pbTemp += sizeof(WORD);

    *puiExtendedErrorInfo = *(UNALIGNED UINT32*)pbTemp;

    LS_LOG_RESULT(lsReturn);

    LS_RETURN(lsReturn);

ErrorReturn:

    LS_RETURN(lsReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\hclient\lstore\lstore.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    lstore.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Shubho Bhattacharya - Feb. 20th 1998

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

C_DEFINES = \
    $(C_DEFINES) \
    $(CLIENT_EXE_CDEFS)

#
# List of sources
#

SOURCES_PLATFORM =

CLIENT_SOURCES_RC = \

CLIENT_SOURCES_COMMON = \
    store.c

CLIENT_SOURCES_LAST  = \

SOURCES = \
    $(CLIENT_SOURCES_RC) \
    $(SOURCES_PLATFORM) \
    $(CLIENT_SOURCES_COMMON) \
    $(CLIENT_SOURCES_LAST)

#
# Precompiled specs
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\hclient\liclient\liclient.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    core.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Madan Appiah - Sep. 5th 1997

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

C_DEFINES = \
    $(C_DEFINES) \
    $(CLIENT_EXE_CDEFS)

#
# List of sources
#

SOURCES_PLATFORM =

CLIENT_SOURCES_RC = \

CLIENT_SOURCES_COMMON = \
    cliprot.c \
    hccontxt.c

CLIENT_SOURCES_LAST  = \
    hcpack.c

SOURCES = \
    $(CLIENT_SOURCES_RC) \
    $(SOURCES_PLATFORM) \
    $(CLIENT_SOURCES_COMMON) \
    $(CLIENT_SOURCES_LAST)

#
# Precompiled specs
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\inc\base64.h ===
/*++

Copyright (c) 1998-99  Microsoft Corporation

Module Name:

    base64.h

Abstract:


Author:

    Fred Chong (FredCh) 7/1/1998

Environment:

Notes:

--*/

#ifndef __BASE64_H__
#define __BASE64_H__

#ifdef __cplusplus
extern "C" {
#endif


#ifdef UNICODE
#define LSBase64Decode  LSBase64DecodeW
#else
#define LSBase64Decode  LSBase64DecodeA
#endif // !UNICODE

DWORD			// ERROR_*
LSBase64DecodeA(
    IN CHAR const *pchIn,
    IN DWORD cchIn,
    OUT BYTE *pbOut,
    OUT DWORD *pcbOut);

DWORD			// ERROR_*
LSBase64DecodeW(
    IN WCHAR const *pchIn,
    IN DWORD cchIn,
    OUT BYTE *pbOut,
    OUT DWORD *pcbOut);

    
#ifdef UNICODE
#define LSBase64Encode  LSBase64EncodeW
#else
#define LSBase64Encode  LSBase64EncodeA
#endif // !UNICODE

DWORD			// ERROR_*
LSBase64EncodeA(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT CHAR *pchOut,
    OUT DWORD *pcchOut);

DWORD			// ERROR_*
LSBase64EncodeW(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT WCHAR *pchOut,
    OUT DWORD *pcchOut);

    
#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // BASE64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\hclient\lstore\store.c ===
/*++

Copyright (c) 1998-99 Microsoft Corporation

Module Name:

    store.c

Abstract:



Revision History:



--*/

#include <windows.h>
#ifndef OS_WINCE
#include <stdio.h>
#endif // OS_WINCE
#include <stdlib.h>

#ifndef OS_WINCE
#include <reglic.h>
#endif

#ifdef OS_WINCE
#include "ceconfig.h"
#endif

#include "store.h"

#define		MAX_LEN			256
#define		BASE_STORE		TEXT("Software\\Microsoft\\MSLicensing\\")
#define		STORE			TEXT("Store")
#define		COMMON_STORE	TEXT("Software\\Microsoft\\MSLicensing\\Store")

#define     MAX_SIZE_LICENSESTORE   2048
#define     MAX_NUM_LICENSESTORE    20
#define     MAX_LICENSESTORE_NAME   25

#ifdef OS_WINCE

typedef HANDLE STORE_HANDLE;

#ifdef OS_WINCE
//If gbFlushHKLM true, RegFlushKey is called in CCC::CC_OnDisconnected
//Since the penalty for RegFlushKey is high on CE, we dont do it immediately
BOOL gbFlushHKLM = FALSE;
#endif

//
// WriteLiceneToStore() and ReadLicenseFromStore is only used by WINCE
//
DWORD
CALL_TYPE
WriteLicenseToStore( 
    IN STORE_HANDLE hStore,
    IN BYTE	FAR * pbLicense,
    IN DWORD cbLicense
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwIndex;
    TCHAR szValueName[MAX_LICENSESTORE_NAME];  
    DWORD dwCount;

    dwIndex = 0;

    while( cbLicense > 0 )
    {
        if( dwIndex > 0 )
        {
            wsprintf(
                    szValueName, 
                    TEXT("ClientLicense%03d"), 
                    dwIndex
                );
        }
        else
        {
            lstrcpy(
                    szValueName,
                    TEXT("ClientLicense")
                ); 
        }

        dwIndex++;

        // must have a reason for this
        RegDeleteValue(
                    (HKEY)hStore,
                    szValueName
                );

        dwCount = (cbLicense > MAX_SIZE_LICENSESTORE) ? MAX_SIZE_LICENSESTORE : cbLicense;

        dwStatus = RegSetValueEx(
                                (HKEY)hStore,
                                szValueName,
                                0,
                                REG_BINARY,
                                pbLicense,
                                dwCount
                            );

        if( ERROR_SUCCESS != dwStatus )
        {
            break;
        }

        cbLicense -= dwCount;
        pbLicense += dwCount;
    }

    if( ERROR_SUCCESS == dwStatus )
    {
        //
        // Delete next store
   
        wsprintf(
                szValueName, 
                TEXT("ClientLicense%03d"), 
                dwIndex
            );

        RegDeleteValue(
                (HKEY)hStore,
                szValueName
            );
#ifdef OS_WINCE
        gbFlushHKLM = TRUE;
#endif
    }
#ifdef OS_WINCE
	else
    {
        DWORD cbValName;

        cbValName = MAX_LICENSESTORE_NAME;
        while ( (ERROR_SUCCESS == RegEnumValue(
                                    (HKEY)hStore,
                                    0, 
                                    szValueName, 
                                    &cbValName, 
                                    NULL, 
                                    NULL,
                                    NULL, 
                                    NULL
                                    ) ) && 
                (cbValName < MAX_LICENSESTORE_NAME)
                )
        {
            RegDeleteValue(
                 (HKEY) hStore,
                 szValueName
                );
            cbValName = MAX_LICENSESTORE_NAME;
        }
    }
#endif

    return dwStatus;
}


DWORD
CALL_TYPE
ReadLicenseFromStore( 
    IN STORE_HANDLE hStore,
    IN BYTE FAR * pbLicense,
    IN DWORD FAR * pcbLicense
    )
/*++

--*/
{
    DWORD dwStatus;
    DWORD dwIndex;
    TCHAR szValueName[MAX_LICENSESTORE_NAME];
    BYTE FAR * pbReadStart;
    DWORD cbReadSize;
    LONG dwSize;

    dwIndex = 0;
    dwSize = (LONG)*pcbLicense;
    *pcbLicense = 0;
    pbReadStart = pbLicense;

    
    for(;;)
    {
        if( pbLicense != NULL )
        {
            if( dwSize < 0 )
            {
                // don't continue on reading,
                // size of buffer is too small, should
                // query size first.
                dwStatus = ERROR_INSUFFICIENT_BUFFER;
                break;
            }
        }
        else if( dwIndex >= MAX_NUM_LICENSESTORE )
        {
            // License is way to big, treat it as error
            dwStatus = LSSTAT_ERROR;
            break;
        }

        if( dwIndex > 0 )
        {
            wsprintf(
                    szValueName, 
                    TEXT("ClientLicense%03d"), 
                    dwIndex
                );
        }
        else
        {
            lstrcpy(
                    szValueName,
                    TEXT("ClientLicense")
                ); 
        }

        dwIndex++;
        cbReadSize = ( pbLicense ) ? dwSize : 0;

	    dwStatus = RegQueryValueEx(
                                (HKEY)hStore,
							    szValueName,
							    NULL,
                                NULL,
							    ( pbLicense ) ? pbReadStart : NULL,
                                &cbReadSize
                            );

        if( ERROR_SUCCESS != dwStatus )
	    {
            if( dwIndex != 0 )
            {
                // 
                // Ignore error if can't read from next store
                //
                dwStatus = ERROR_SUCCESS;
            }
            
            break;
        }

        (*pcbLicense) += cbReadSize;
        if( pbLicense )
        {
            pbReadStart += cbReadSize;
            dwSize -= cbReadSize;
        }
    }
   
    return dwStatus;
}

#endif // OS_WINCE


LS_STATUS
CALL_TYPE
LSOpenLicenseStore(
				 OUT HANDLE			*phStore,	 //The handle of the store
				 IN  LPCTSTR		szStoreName, //Optional store Name
				 IN  BOOL 			fReadOnly    //whether to open read-only
				 )
{
	LS_STATUS	lsResult = LSSTAT_ERROR;
	LPTSTR		szKey = NULL;
	HKEY		hKey;
	DWORD		dwDisposition = 0, dwRetCode;

	if (phStore==NULL)
		return LSSTAT_INVALID_HANDLE;

	//If any store name is provided, try opening the store
	if(szStoreName)
	{
		if( NULL == (szKey = (LPTSTR)malloc( 2*( lstrlen(BASE_STORE) + lstrlen(szStoreName) + 1 ) ) ) )
		{
			lsResult = LSSTAT_OUT_OF_MEMORY;
			goto ErrorReturn;
		}
		lstrcpy(szKey, BASE_STORE);
		lstrcat(szKey, szStoreName);
	}
	//Open standard store
	else
	{
        szKey = COMMON_STORE;
	}
    
    //
    // try and open the key.  If we cannot open the key, then create the key
    //

    dwRetCode = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                              szKey,
                              0,  
                              fReadOnly ? KEY_READ : KEY_READ | KEY_WRITE,
                              &hKey );

    if( ERROR_SUCCESS != dwRetCode )
    {
        HKEY hKeyBase;

        dwRetCode = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
#ifndef OS_WINCE
                                    BASE_STORE,
#else
                                    szKey,
#endif
                                    0,
                                    TEXT("License Store"),
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_READ | KEY_WRITE,
                                    NULL,
                                    &hKeyBase,
                                    &dwDisposition );

        if (ERROR_SUCCESS == dwRetCode)
        {
#ifndef OS_WINCE

            // Set the proper ACL on the key; ignore errors

            SetupMSLicensingKey();

#endif

            dwRetCode = RegCreateKeyEx( hKeyBase,
                                        (szStoreName != NULL) ? szStoreName : STORE,
                                        0,
                                        TEXT("License Store"),
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_ALL_ACCESS,
                                        NULL,
                                        &hKey,
                                        &dwDisposition );

            RegCloseKey(hKeyBase);
        }
    }

    if( ERROR_SUCCESS == dwRetCode )
    {

        *phStore = ( HANDLE )hKey;

        lsResult = LSSTAT_SUCCESS;
    }
    else
    {
		*phStore = NULL;
    }
    
CommonReturn:	

    if (szKey)
    {
        // We only allocate memory for szKey if szStoreName wasn't NULL
        if (szStoreName)
            free(szKey);
    }

    return lsResult;

ErrorReturn:

    *phStore = NULL;
    goto CommonReturn;		
}	


//Closes an open store
LS_STATUS
CALL_TYPE
LSCloseLicenseStore(
				  IN HANDLE		hStore	//Handle of the store to be closed!
				  )

{	
	LS_STATUS	lsResult = LSSTAT_ERROR;
	HKEY	hKey = NULL;

	if(hStore==NULL)
		return lsResult;

	 hKey = (HKEY)hStore;

	if(hKey)
	{
		RegCloseKey(hKey);
		hKey = NULL;
		lsResult = LSSTAT_SUCCESS;
	}

	return lsResult;
}

/*
	Here we do not check any value. We do not even check if a license with same attributes present
	or not. This is to make the store functionality simpler. We assume, the higher level protocol 
	will take care of that
*/

//Add or updates/replaces license against a given LSINDEX in an open store 
//pointed by hStore
LS_STATUS
CALL_TYPE
LSAddLicenseToStore(
					IN HANDLE		hStore,	//Handle of a open store
					IN DWORD		dwFlags,//Flags either add or replace
					IN PLSINDEX		plsiName,	//Index against which License is added 
					IN BYTE	 FAR *	pbLicenseInfo,	//License info to be added
					IN DWORD		cbLicenseInfo	// size of the License info blob
					)

{
	
	LS_STATUS	lsResult = LSSTAT_ERROR;
	HANDLE		hLicense = NULL;	
    HKEY	hTempKey = NULL;
    DWORD dwRetCode;

	if( (hStore == NULL) ||
		(plsiName == NULL) ||
		(plsiName->pbScope == NULL) ||
		(plsiName->pbCompany == NULL) ||
		(plsiName->pbProductID == NULL) ||
		(pbLicenseInfo == NULL) ||
		(cbLicenseInfo == 0) )
		return LSSTAT_INVALID_HANDLE;

	lsResult = LSOpenLicenseHandle(hStore, FALSE, plsiName, &hLicense);
	switch(lsResult)
	{
		case LSSTAT_SUCCESS:
			if(dwFlags == LS_REPLACE_LICENSE_OK)
			{

#ifndef OS_WINCE
				RegDeleteValue((HKEY)hLicense, TEXT("ClientLicense"));
				//Set the License Info value
				if( ERROR_SUCCESS != RegSetValueEx(
							(HKEY)hLicense,
							TEXT("ClientLicense"),
							0,
							REG_BINARY,
							pbLicenseInfo,
							cbLicenseInfo
							) )
				{
					lsResult = LSSTAT_ERROR;
					goto ErrorReturn;
				}
#else

                if( ERROR_SUCCESS != WriteLicenseToStore( 
                                                (STORE_HANDLE)hLicense, 
                                                pbLicenseInfo, 
                                                cbLicenseInfo ) )
                {
                    lsResult = LSSTAT_ERROR;
                    goto ErrorReturn;
                }

#endif

			}
			else
			{
				lsResult = LSSTAT_LICENSE_EXISTS;
				goto ErrorReturn;
			}
				
			break;
		case LSSTAT_LICENSE_NOT_FOUND:
			{
				DWORD	dwIndex, dwDisposition = 0;
				TCHAR	szAddKey[MAX_LEN];

				for(dwIndex = 0; ; dwIndex ++)
				{
                    // Open iterative license names until we fail to 
                    // determine a free spot

					wsprintf(szAddKey, TEXT("LICENSE%03d"), dwIndex);
#ifdef OS_WINCE
					if( ERROR_SUCCESS != RegOpenKeyEx((HKEY)hStore, szAddKey, 0, 0, &hTempKey) )
#else // !OS_WINCE
					if( ERROR_SUCCESS != RegOpenKeyEx((HKEY)hStore, szAddKey, 0, KEY_READ | KEY_WRITE, &hTempKey) )
#endif // OS_WINCE
						break;
					else if(hTempKey)
					{
						RegCloseKey(hTempKey);
						hTempKey = NULL;
					}
				}
    
                //
                // try and open the key.  If we cannot open the key, then create the key
                //

                dwRetCode = RegOpenKeyEx( ( HKEY )hStore,
                                           szAddKey,
                                           0,
                                           KEY_READ | KEY_WRITE,
                                           &hTempKey );

                if( ERROR_SUCCESS != dwRetCode )
                {

                    dwRetCode = RegCreateKeyEx( ( HKEY )hStore, 
                                                szAddKey, 
                                                0,
                                                NULL,
                                                REG_OPTION_NON_VOLATILE,
                                                KEY_READ | KEY_WRITE,
                                                NULL,
                                                &hTempKey,
                                                &dwDisposition );
				
                }
                else
                {
                    //
                    // Indicate that we have opened an existing key successfully
                    //

                    dwDisposition = REG_OPENED_EXISTING_KEY;
                }

                if( ERROR_SUCCESS == dwRetCode )
				{
					if(dwDisposition == REG_CREATED_NEW_KEY)
					{

                        //Set the Scope Value in binary format
						if( ERROR_SUCCESS != RegSetValueEx(
									hTempKey,
									TEXT("LicenseScope"),
									0,
									REG_BINARY,
									plsiName->pbScope,
									plsiName->cbScope
									) )
						{
							lsResult = LSSTAT_ERROR;
							goto ErrorReturn;
						}

						//Set Company Name Value
						if( ERROR_SUCCESS != RegSetValueEx(
									hTempKey,
									TEXT("CompanyName"),
									0,
									REG_BINARY,
									plsiName->pbCompany,
									plsiName->cbCompany
									) )
						{
							lsResult = LSSTAT_ERROR;
							goto ErrorReturn;
						}
						
						//Set  Product Info
						if( ERROR_SUCCESS != RegSetValueEx(
									hTempKey,
									TEXT("ProductID"),
									0,
									REG_BINARY,
									plsiName->pbProductID,
									plsiName->cbProductID
									) )
						{
							lsResult = LSSTAT_ERROR;
							goto ErrorReturn;
						}


#ifndef OS_WINCE
						//Set the License Info value
						if( ERROR_SUCCESS != RegSetValueEx(
									hTempKey,
									TEXT("ClientLicense"),
									0,
									REG_BINARY,
									pbLicenseInfo,
									cbLicenseInfo
									) )
						{
							lsResult = LSSTAT_ERROR;
							goto ErrorReturn;
						}

#else

                        if( ERROR_SUCCESS != WriteLicenseToStore( 
                                                        (STORE_HANDLE)hTempKey, 
                                                        pbLicenseInfo, 
                                                        cbLicenseInfo ) )
                        {
                            lsResult = LSSTAT_ERROR;
                            goto ErrorReturn;
                        }

#endif

					}
					else // so ERROR_SUCCESS != RegCreateKeyEx
					{
						lsResult = LSSTAT_ERROR;
						goto ErrorReturn;
					}
							
				}
				else
				{
					lsResult = LSSTAT_ERROR;
					goto ErrorReturn;
				}
				lsResult = LSSTAT_SUCCESS;
			}
			break;
		default:
			goto ErrorReturn;
	}

	
CommonReturn:

	if(hLicense)
	{
		LSCloseLicenseHandle(hLicense, 0);
		hLicense = NULL;
	}
	if(hTempKey)
	{
		RegCloseKey(hTempKey);
		hTempKey = NULL;
	}
	return lsResult;

ErrorReturn:

	goto CommonReturn;
}

LS_STATUS
CALL_TYPE
LSDeleteLicenseFromStore(
						 IN HANDLE		hStore,	//Handle of a open store
						 IN PLSINDEX	plsiName	//Index of the license to be deleted
						 )
{
	LS_STATUS	lsResult = LSSTAT_ERROR;
	TCHAR		szKeyName[MAX_LEN];
	DWORD		dwKeyNameLen = MAX_LEN;
	DWORD		dwSubKeys = 0;
	DWORD		dwIndex = 0;
	DWORD		cbValueData = 0;
	BYTE FAR *	pbValueData = NULL;
	LONG		err = ERROR_SUCCESS;
	HKEY		hTempKey = NULL;
	FILETIME	ft;
    HKEY        hkeyStore = NULL;

	if( (hStore == NULL) ||
		(plsiName == NULL) ||
		(plsiName->pbScope == NULL) ||
		(plsiName->pbCompany == NULL) ||
		(plsiName->pbProductID == NULL) )
		return LSSTAT_INVALID_HANDLE;

    hkeyStore = (HKEY)hStore;

	if( ERROR_SUCCESS != RegQueryInfoKey(hkeyStore,
										NULL,
										NULL,
										NULL,
										&dwSubKeys, 
										NULL,
										NULL,
										NULL,
										NULL,
										NULL,
										NULL,
										NULL) )
										goto ErrorReturn;
		
	for(dwIndex = 0; dwIndex <dwSubKeys; dwIndex ++)
	{
		if( ERROR_SUCCESS != RegEnumKeyEx(
										hkeyStore,
										dwIndex,
										szKeyName,
										&dwKeyNameLen,
										NULL,
										NULL,
										NULL,
										&ft
										) )
		{
			continue;
		}
		
		err = RegOpenKeyEx(hkeyStore, szKeyName, 0, KEY_READ | KEY_WRITE | DELETE, &hTempKey);

		if(err != ERROR_SUCCESS)
			continue;
		err = RegQueryValueEx(hTempKey, 
							  TEXT("LicenseScope"),
							  NULL,
							  NULL,
							  NULL,
							  &cbValueData);

		if( (err!=ERROR_SUCCESS)||
			(cbValueData != plsiName->cbScope) )
			continue;
		
		if( NULL == (pbValueData = (BYTE FAR *)malloc(cbValueData)) )
		{
			lsResult = LSSTAT_OUT_OF_MEMORY;
			goto ErrorReturn;
		}
		
		memset(pbValueData, 0x00, cbValueData);

		err = RegQueryValueEx(hTempKey, 
							  TEXT("LicenseScope"),
							  NULL,
							  NULL,
							  pbValueData,
							  &cbValueData);
		
		if( (err!=ERROR_SUCCESS) ||
			(memcmp(pbValueData, plsiName->pbScope, cbValueData)) )
		{
			if(pbValueData)
			{
				free(pbValueData);
				pbValueData = NULL;
			}
			continue;
		}
		
		if(pbValueData)
		{
			free(pbValueData);
			pbValueData = NULL;
		}
		
		err = RegQueryValueEx(hTempKey, 
							  TEXT("CompanyName"),
							  NULL,
							  NULL,
							  NULL,
							  &cbValueData);
		
		if( (err!=ERROR_SUCCESS) ||
			(cbValueData != plsiName->cbCompany) )
			continue;
		
		if( NULL == (pbValueData = (BYTE FAR *)malloc(cbValueData)) )
		{
			lsResult = LSSTAT_OUT_OF_MEMORY;
			goto ErrorReturn;
		}
		
		memset(pbValueData, 0x00, cbValueData);

		err = RegQueryValueEx(hTempKey, 
							  TEXT("CompanyName"),
							  NULL,
							  NULL,
							  pbValueData,
							  &cbValueData);
		
		if( (err!=ERROR_SUCCESS) ||
			(memcmp(pbValueData, plsiName->pbCompany, cbValueData)) )
		{
			if(pbValueData)
			{
				free(pbValueData);
				pbValueData = NULL;
			}
			continue;
		}

		if(pbValueData)
		{
			free(pbValueData);
			pbValueData = NULL;
		}

		err = RegQueryValueEx(hTempKey, 
							  TEXT("ProductID"),
							  NULL,
							  NULL,
							  NULL,
							  &cbValueData);
		
		if( (err!=ERROR_SUCCESS) ||
			(cbValueData != plsiName->cbProductID) )
			continue;
		
		
		if( NULL == (pbValueData = (BYTE FAR *)malloc(cbValueData)) )
		{
			lsResult = LSSTAT_OUT_OF_MEMORY;
			goto ErrorReturn;
		}
		
		memset(pbValueData, 0x00, cbValueData);
		
		err = RegQueryValueEx(hTempKey, 
							  TEXT("ProductID"),
							  NULL,
							  NULL,
							  pbValueData,
							  &cbValueData);
		
		if( (err!=ERROR_SUCCESS) ||
			(memcmp(pbValueData, plsiName->pbProductID, cbValueData)) )
		{
			if(pbValueData)
			{
				free(pbValueData);
				pbValueData = NULL;
			}
			continue;
		}
		
		if(pbValueData)
		{
			free(pbValueData);
			pbValueData = NULL;
		}
		
		if(hTempKey)
		{
			RegCloseKey(hTempKey);
			hTempKey = NULL;
		}

		if( ERROR_SUCCESS == RegDeleteKey(hkeyStore, szKeyName) )
		{
			lsResult = LSSTAT_SUCCESS;
			break;
		}
		lsResult = LSSTAT_LICENSE_NOT_FOUND;
	}

CommonReturn:
	return lsResult;
ErrorReturn:
	goto CommonReturn;
}


//Finds a license in an open store against a particular store Index
LS_STATUS
CALL_TYPE
LSFindLicenseInStore(
					 IN HANDLE		hStore,	//Handle of a open store
					 IN		PLSINDEX	plsiName,	//LSIndex against which store is searched
					 IN OUT	DWORD FAR   *pdwLicenseInfoLen,	//Size of the license found
					 OUT	BYTE FAR	*pbLicenseInfo	//License Data
					 )
{
	LS_STATUS	lsResult = LSSTAT_ERROR;
	HANDLE		hLicense = NULL;
    HKEY hkeyLicense = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    
	if( LSSTAT_SUCCESS != (lsResult = LSOpenLicenseHandle( hStore, TRUE, plsiName, &hLicense)) )
		goto ErrorReturn;

    hkeyLicense = (HKEY)hLicense;

#ifndef OS_WINCE

	if( ERROR_SUCCESS == (dwStatus = RegQueryValueEx((HKEY)hkeyLicense,
										 TEXT("ClientLicense"),
										 NULL,
										 NULL,
										 pbLicenseInfo,
										 pdwLicenseInfoLen)) )
	{
            lsResult = LSSTAT_SUCCESS;
            goto CommonReturn;
	}


#else

    if( ERROR_SUCCESS == (dwStatus = ReadLicenseFromStore(
                                        (STORE_HANDLE)hkeyLicense,
                                        pbLicenseInfo,
										pdwLicenseInfoLen)) )
    {
        lsResult = LSSTAT_SUCCESS;
        goto CommonReturn;
    }

#endif

    if( dwStatus != ERROR_SUCCESS)
    {
        lsResult = LSSTAT_ERROR;
    }

    if(lsResult != LSSTAT_SUCCESS)
    {
			goto ErrorReturn;
	}
	else if(*pdwLicenseInfoLen == 0)
	{
		lsResult = LSSTAT_LICENSE_NOT_FOUND;
		goto ErrorReturn;
	}
	
CommonReturn:
	if(hLicense)
	{
		LSCloseLicenseHandle(hLicense, 0);
		hLicense = NULL;
	}
	return lsResult;
ErrorReturn:
	goto CommonReturn;
}


LS_STATUS
CALL_TYPE
LSEnumLicenses(
			   IN HANDLE		hStore,	//Handle of a open store
			   IN	DWORD		dwIndex, //numeric Index of the license to query
			   OUT	PLSINDEX	plsiName //The LSIndex structure corresponding to dwIndex
			   )
{	
	LS_STATUS	lsResult = LSSTAT_ERROR;
	TCHAR		szKeyName[MAX_LEN];
	DWORD		dwKeyLen = MAX_LEN;
	FILETIME	ft;
	LONG		err = 0;
	HKEY		hTempKey = NULL;
    HKEY        hkeyStore = NULL;

	if( (hStore == NULL) ||
		(plsiName == NULL) )
		return LSSTAT_INVALID_HANDLE;

	plsiName->dwVersion = 0x01;

    hkeyStore = (HKEY)hStore;
	
	if( ERROR_SUCCESS != RegEnumKeyEx(
									(HKEY)hkeyStore,
									dwIndex,
									szKeyName,
									&dwKeyLen,
									NULL,
									NULL,
									NULL,
									&ft
									) )
		goto ErrorReturn;
	
	if( ERROR_SUCCESS != RegOpenKeyEx((HKEY)hkeyStore, szKeyName, 0, KEY_ALL_ACCESS, &hTempKey) )
		goto ErrorReturn;

	err = RegQueryValueEx(hTempKey, 
						  TEXT("LicenseScope"),
						  NULL,
						  NULL,
						  NULL,
						  &plsiName->cbScope);

	if(err!=ERROR_SUCCESS)
		goto ErrorReturn;
	
	if( NULL == (plsiName->pbScope = (BYTE FAR *)malloc(plsiName->cbScope)) )
	{
		lsResult = LSSTAT_OUT_OF_MEMORY;
		goto ErrorReturn;
	}
	
	memset(plsiName->pbScope, 0x00, plsiName->cbScope);

	err = RegQueryValueEx(hTempKey, 
						  TEXT("LicenseScope"),
						  NULL,
						  NULL,
						  plsiName->pbScope,
						  &plsiName->cbScope);
	if(err!=ERROR_SUCCESS)
		goto ErrorReturn;

	err = RegQueryValueEx(hTempKey, 
						  TEXT("CompanyName"),
						  NULL,
						  NULL,
						  NULL,
						  &plsiName->cbCompany);
	if(err!=ERROR_SUCCESS)
		goto ErrorReturn;
	
	if( NULL == (plsiName->pbCompany = (BYTE FAR *)malloc(plsiName->cbCompany)) )
	{
		lsResult = LSSTAT_OUT_OF_MEMORY;;
		goto ErrorReturn;
	}
	
	memset(plsiName->pbCompany, 0x00, plsiName->cbCompany);

	err = RegQueryValueEx(hTempKey, 
						  TEXT("CompanyName"),
						  NULL,
						  NULL,
						  (BYTE FAR *)plsiName->pbCompany,
						  &plsiName->cbCompany);
	if(err!=ERROR_SUCCESS)
		goto ErrorReturn;


	err = RegQueryValueEx(hTempKey, 
						  TEXT("ProductID"),
						  NULL,
						  NULL,
						  NULL,
						  &plsiName->cbProductID);
	if(err!=ERROR_SUCCESS)
		goto ErrorReturn;
	
	if( NULL == (plsiName->pbProductID = (BYTE FAR *)malloc(plsiName->cbProductID)) )
	{
		lsResult = LSSTAT_OUT_OF_MEMORY;
		goto ErrorReturn;
	}
	memset(plsiName->pbProductID, 0x00, plsiName->cbProductID);

	err = RegQueryValueEx(hTempKey, 
						  TEXT("ProductID"),
						  NULL,
						  NULL,
						  plsiName->pbProductID,
						  &plsiName->cbProductID);
	if(err!=ERROR_SUCCESS)
	{
		goto ErrorReturn;
	}
	
	
	lsResult = LSSTAT_SUCCESS;
CommonReturn:
	if(hTempKey)
	{
		RegCloseKey(hTempKey);
		hTempKey = NULL;
	}
	return lsResult;
ErrorReturn:
	if(plsiName->pbScope)
	{
		free(plsiName->pbScope);
		plsiName->pbScope = NULL;
	}
	if(plsiName->pbCompany)
	{
		free(plsiName->pbCompany);
		plsiName->pbCompany = NULL;
	}
	if(plsiName->pbProductID)
	{
		free(plsiName->pbProductID);
		plsiName->pbProductID = NULL;
	}
	lsResult = LSSTAT_ERROR;
	goto CommonReturn;


}

LS_STATUS
CALL_TYPE
LSQueryInfoLicense(
				   IN HANDLE		hStore,	//Handle of a open store
				   OUT	DWORD	FAR *pdwLicenses, //Total no. of licenses available
				   OUT	DWORD	FAR *pdwMaxCompanyNameLen,	//Maximum length of the company length
				   OUT	DWORD	FAR *pdwMaxScopeLen,	//Maximum length of the company length
				   OUT	DWORD	FAR *pdwMaxProductIDLen	//Maximum length of the company length
				   )
{
	LS_STATUS	lsResult = LSSTAT_ERROR;
	FILETIME	ft;
	HKEY		hTempKey = NULL;
	TCHAR		szKey[MAX_LEN];
	DWORD		dwKeyLen = MAX_LEN;
	DWORD		dwSize = 0, dwIndex;
    HKEY        hkeyStore = NULL;
	
	if(pdwLicenses == NULL)
		return LSSTAT_ERROR;

	if(pdwMaxCompanyNameLen)
		*pdwMaxCompanyNameLen = 0;
	if(pdwMaxScopeLen)
		*pdwMaxScopeLen = 0;
	if(pdwMaxProductIDLen)
		*pdwMaxProductIDLen = 0;
	
    hkeyStore = (HKEY)hStore;

	if(ERROR_SUCCESS != RegQueryInfoKey((HKEY)hkeyStore,
										 NULL,
										 NULL,
										 NULL,
										 pdwLicenses,
										 NULL,
										 NULL,
										 NULL,
										 NULL,
										 NULL,
										 NULL,
										 &ft
										 ) )
		goto ErrorReturn;

	for (dwIndex = 0; dwIndex<*pdwLicenses; dwIndex++)
	{
			if( ERROR_SUCCESS != RegEnumKeyEx((HKEY)hkeyStore,
											 dwIndex,
											 szKey,
											 &dwKeyLen,
											 NULL,
											 NULL,
											 NULL,
											 &ft) )
				goto ErrorReturn;
			if( ERROR_SUCCESS != RegOpenKeyEx((HKEY)hkeyStore,
											  szKey,
											  0,
											  KEY_READ,
											  &hTempKey) )
				goto ErrorReturn;

			if(pdwMaxCompanyNameLen)
			{
				if( ERROR_SUCCESS != RegQueryValueEx( hTempKey,
													  TEXT("CompanyName"),
													  NULL,
													  NULL,
													  NULL,
													  &dwSize) )
					goto ErrorReturn;
				if(dwSize >= *pdwMaxCompanyNameLen)
					*pdwMaxCompanyNameLen = dwSize;
			}

			if(pdwMaxScopeLen)
			{
				if( ERROR_SUCCESS != RegQueryValueEx( hTempKey,
													  TEXT("LicenseScope"),
													  NULL,
													  NULL,
													  NULL,
													  &dwSize) )
					goto ErrorReturn;
				if(dwSize >= *pdwMaxScopeLen)
					*pdwMaxScopeLen = dwSize;
			}
			if(pdwMaxProductIDLen)
			{
				if( ERROR_SUCCESS != RegQueryValueEx( hTempKey,
													  TEXT("ProductID"),
													  NULL,
													  NULL,
													  NULL,
													  &dwSize) )
					goto ErrorReturn;
				if(dwSize >= *pdwMaxProductIDLen)
					*pdwMaxProductIDLen = dwSize;
			}
	}
	
	lsResult = LSSTAT_SUCCESS;
CommonReturn:
	if(hTempKey)
	{
		RegCloseKey(hTempKey);
		hTempKey = NULL;
	}
	return lsResult;
ErrorReturn:
	goto CommonReturn;

}


LS_STATUS	
CALL_TYPE
LSOpenLicenseHandle(
				   IN HANDLE		hStore,	//Handle of a open store
				   IN  BOOL         fReadOnly,
				   IN  PLSINDEX		plsiName,
				   OUT HANDLE		*phLicense	
				   )
{
	LS_STATUS		lsReturn = LSSTAT_LICENSE_NOT_FOUND;
	TCHAR	szKeyName[MAX_LEN];
	DWORD	dwKeyNameLen = MAX_LEN;
	DWORD	dwSubKeys = 0;
	DWORD	dwIndex = 0;
	DWORD	cbValueData = 0;
	BYTE FAR *pbValueData = NULL;
	LONG	err = ERROR_SUCCESS;
	HKEY	hTempKey = NULL;
	FILETIME	ft;
    HKEY        hkeyStore = NULL;

	if( (phLicense == NULL) ||
		(hStore == NULL) ||
		(plsiName == NULL) ||
		(plsiName->pbScope == NULL) ||
		(plsiName->pbCompany == NULL) ||
		(plsiName->pbProductID == NULL) )
	{
		return LSSTAT_INVALID_HANDLE;
	}

    hkeyStore = (HKEY)hStore;

	//Get the number of Licenses available
	if( ERROR_SUCCESS != RegQueryInfoKey((HKEY)hkeyStore, 
										NULL,
										NULL,
										NULL,
										&dwSubKeys, 
										NULL,
										NULL,
										NULL,
										NULL,
										NULL,
										NULL,
										NULL) )
										goto ErrorReturn;
	
	//Start searching from the first license until a match is obtained
	for(dwIndex = 0; dwIndex <dwSubKeys; dwIndex ++)
	{
		dwKeyNameLen = MAX_LEN;
		if( ERROR_SUCCESS != RegEnumKeyEx(
										(HKEY)hkeyStore,
										dwIndex,
										szKeyName,
										&dwKeyNameLen,
										NULL,
										NULL,
										NULL,
										&ft
										) )
		{
			continue;
		}
		
		err = RegOpenKeyEx((HKEY)hkeyStore,
                           szKeyName,
                           0,
                           fReadOnly ? KEY_READ : KEY_READ | KEY_WRITE,
                           &hTempKey);

		if(err != ERROR_SUCCESS)
			continue;
		
		err = RegQueryValueEx(hTempKey, 
							  TEXT("LicenseScope"),
							  NULL,
							  NULL,
							  NULL,
							  &cbValueData);

		if( (err != ERROR_SUCCESS) ||
			(cbValueData != plsiName->cbScope) )
		{
			if(hTempKey)
			{
				RegCloseKey(hTempKey);
				hTempKey = NULL;
			}
			continue;
		}
		
		if( NULL == (pbValueData = (BYTE FAR *)malloc(cbValueData)) )
		{
			if(hTempKey)
			{
				RegCloseKey(hTempKey);
				hTempKey = NULL;
			}
			lsReturn = LSSTAT_OUT_OF_MEMORY;
			goto ErrorReturn;
		}
		
		memset(pbValueData, 0x00, cbValueData);

		err = RegQueryValueEx(hTempKey, 
							  TEXT("LicenseScope"),
							  NULL,
							  NULL,
							  pbValueData,
							  &cbValueData);
		
		if( (err!=ERROR_SUCCESS) ||
			(memcmp(pbValueData, plsiName->pbScope, cbValueData)) )
		{
			if(hTempKey)
			{
				RegCloseKey(hTempKey);
				hTempKey = NULL;
			}
			if(pbValueData)
			{
				free(pbValueData);
				pbValueData = NULL;
				cbValueData = 0;
			}
			continue;
		}
	
		if(pbValueData)
		{
			free(pbValueData);
			pbValueData = NULL;
			cbValueData = 0;
		}
		

		err = RegQueryValueEx(hTempKey, 
							  TEXT("CompanyName"),
							  NULL,
							  NULL,
							  NULL,
							  &cbValueData);
		
		if( (err != ERROR_SUCCESS) ||
			(cbValueData != plsiName->cbCompany) )
		{
			if(hTempKey)
			{
				RegCloseKey(hTempKey);
				hTempKey = NULL;
			}
			continue;
		}
		
		if( NULL == (pbValueData = (BYTE FAR *)malloc(cbValueData)) )
		{
			if(hTempKey)
			{
				RegCloseKey(hTempKey);
				hTempKey = NULL;
			}
			lsReturn = LSSTAT_OUT_OF_MEMORY;
			goto ErrorReturn;
		}
		
		memset(pbValueData, 0x00, cbValueData);

		err = RegQueryValueEx(hTempKey, 
							  TEXT("CompanyName"),
							  NULL,
							  NULL,
							  pbValueData,
							  &cbValueData);
		
		if( (err!=ERROR_SUCCESS) ||
			(memcmp(pbValueData, plsiName->pbCompany, cbValueData)) )
		{
			if(hTempKey)
			{
				RegCloseKey(hTempKey);
				hTempKey = NULL;
			}
			if(pbValueData)
			{
				free(pbValueData);
				pbValueData = NULL;
				cbValueData = 0;
			}
			continue;
		}

		if(pbValueData)
		{
			free(pbValueData);
			pbValueData = NULL;
			cbValueData = 0;
		}
		
		err = RegQueryValueEx(hTempKey, 
							  TEXT("ProductID"),
							  NULL,
							  NULL,
							  NULL,
							  &cbValueData);
		if( (err != ERROR_SUCCESS) ||
			( cbValueData != plsiName->cbProductID ) )
		{
			if(hTempKey)
			{
				RegCloseKey(hTempKey);
				hTempKey = NULL;
			}
			continue;
		}
		
		if( NULL == (pbValueData = (BYTE FAR *)malloc(cbValueData)) )
		{
			if(hTempKey)
			{
				RegCloseKey(hTempKey);
				hTempKey = NULL;
			}
			lsReturn = LSSTAT_OUT_OF_MEMORY;
			goto ErrorReturn;
		}
		
		memset(pbValueData, 0x00, cbValueData);

		err = RegQueryValueEx(hTempKey, 
							  TEXT("ProductID"),
							  NULL,
							  NULL,
							  pbValueData,
							  &cbValueData);
		
		if( (err!=ERROR_SUCCESS) ||
			(memcmp(pbValueData, plsiName->pbProductID, cbValueData)) )
		{
			if(hTempKey)
			{
				RegCloseKey(hTempKey);
				hTempKey = NULL;
			}
			if(pbValueData)
			{
				free(pbValueData);
				pbValueData = NULL;
			}
			continue;
		}
		
		lsReturn = LSSTAT_SUCCESS;
		if(pbValueData)
		{
			free(pbValueData);
			pbValueData = NULL;
			cbValueData = 0;
		}
		break;
	}

    if (dwIndex == dwSubKeys)
    {
        // nothing found
        goto ErrorReturn;
    }

	
	*phLicense = (HANDLE)hTempKey;	
		
CommonReturn:
		return lsReturn;
ErrorReturn:
		if(pbValueData)
		{
			free(pbValueData);
			pbValueData = NULL;
		}
		*phLicense = NULL;
		pbValueData = NULL;
		cbValueData = 0;
		goto CommonReturn;
}

LS_STATUS
CALL_TYPE
LSCloseLicenseHandle(
					 IN HANDLE		hLicense,	//Handle of a open store
					 IN DWORD	dwFlags		//For future Use
					 )
{
	LS_STATUS	lsResult = LSSTAT_ERROR;
	HKEY	hKey = (HKEY)hLicense;
	if(hKey)
	{
		RegCloseKey(hKey);
		hKey = NULL;
		lsResult = LSSTAT_SUCCESS;
	}
	return lsResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\inc\certutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       certutil.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    03-18-97   HueiWang     Created
//
//----------------------------------------------------------------------------
#ifndef __LICENSE_VERIFY_H__
#define __LICENSE_VERIFY_H__

#include <windows.h>
#include <wincrypt.h>

typedef BOOL (*EnumerateCertNameInfoCallBack)(PCERT_RDN_ATTR pCertRdnAttr, HANDLE dwUserData);

#ifndef AllocateMemory
    #define AllocMemory(size) LocalAlloc(LPTR, size)
    #define FreeMemory(ptr) if(ptr) LocalFree(ptr)
#endif

//
//  SP3 build environment problem.
//
#define LSCERT_ALT_NAME_OTHER_NAME         1
#define LSCERT_ALT_NAME_RFC822_NAME        2
#define LSCERT_ALT_NAME_DNS_NAME           3
#define LSCERT_ALT_NAME_X400_ADDRESS       4
#define LSCERT_ALT_NAME_DIRECTORY_NAME     5
#define LSCERT_ALT_NAME_EDI_PARTY_NAME     6
#define LSCERT_ALT_NAME_URL                7
#define LSCERT_ALT_NAME_IP_ADDRESS         8
#define LSCERT_ALT_NAME_REGISTERED_ID      9

typedef struct _LSCERT_ALT_NAME_ENTRY {
    DWORD    dwAltNameChoice;
    union {
      CRYPT_ATTRIBUTE_TYPE_VALUE    OtherName;
      LPWSTR                        pwszRfc822Name;
      LPWSTR                        pwszDNSName;
      CRYPT_ATTRIBUTE_TYPE_VALUE    x400Address;
      CERT_NAME_BLOB                DirectoryName;
      LPWSTR                        pwszEdiPartyName;
      LPWSTR                        pszURL;
      CRYPT_DATA_BLOB               IPAddress;
      LPSTR                         pszRegisteredID;
    }; 
} LSCERT_ALT_NAME_ENTRY,   *PLSCERT_ALT_NAME_ENTRY;

typedef struct _LSCERT_ALT_NAME_INFO {
    DWORD                   cAltEntry;
    PLSCERT_ALT_NAME_ENTRY    rgAltEntry;
} LSCERT_ALT_NAME_INFO, *PLSCERT_ALT_NAME_INFO;

typedef struct _LSCERT_AUTHORITY_KEY_ID2_INFO {    
    CRYPT_DATA_BLOB     KeyId;
    LSCERT_ALT_NAME_INFO  AuthorityCertIssuer;
    CRYPT_INTEGER_BLOB  AuthorityCertSerialNumber;
} LSCERT_AUTHORITY_KEY_ID2_INFO, *PLSCERT_AUTHORITY_KEY_ID2_INFO; 

#define szOID_X509_AUTHORITY_KEY_ID2        "2.5.29.35"
#define szOID_X509_AUTHORITY_ACCESS_INFO    "1.3.6.1.5.5.7.1.1"
#define szOID_X509_ACCESS_PKIX_OCSP         "1.3.6.1.5.5.7.48.1" 

typedef struct _LSCERT_ACCESS_DESCRIPTION {
    LPSTR               pszAccessMethod;        // pszObjId
    LSCERT_ALT_NAME_ENTRY AccessLocation;
} LSCERT_ACCESS_DESCRIPTION, *PLSCERT_ACCESS_DESCRIPTION;
 
typedef struct _LSCERT_AUTHORITY_INFO_ACCESS {
    DWORD                       cAccDescr;
    PLSCERT_ACCESS_DESCRIPTION    rgAccDescr;
} LSCERT_AUTHORITY_INFO_ACCESS, *PLSCERT_AUTHORITY_INFO_ACCESS;


#if UNICODE
#define CAST_PBYTE (USHORT *)
#else
#define CAST_PBYTE
#endif

#define CERT_X509_MULTI_BYTE_INTEGER             ((LPCSTR) 28)

#ifdef __cplusplus
extern "C" {
#endif


void
LSShutdownCertutilLib();

BOOL
LSInitCertutilLib( 
    HCRYPTPROV hProv 
);

void
LSFreeLicensedProduct(
    PLICENSEDPRODUCT pLicensedProduct
);

LICENSE_STATUS
LSVerifyDecodeClientLicense(
    IN PBYTE                pbLicense,
    IN DWORD                cbLicense,
    IN PBYTE                pbSecretKey,
    IN DWORD                cbSecretKey,
    IN OUT PDWORD           pdwNumLicensedInfo,
    IN OUT PLICENSEDPRODUCT pLicensedInfo
);

LICENSE_STATUS
LSVerifyCertificateChain(
    HCRYPTPROV hCryptProv, 
    HCERTSTORE hCertStore
);

DWORD 
LSCryptDecodeObject(  
    IN DWORD dwEncodingType,
    IN LPCSTR lpszStructType,
    IN const BYTE * pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags,
    OUT void ** pvStructInfo,   
    IN OUT DWORD * pcbStructInfo
);

DWORD 
LSLicensedProductInfoToExtension(
    DWORD dwQuantity,
    DWORD dwPlatformId,
    DWORD dwLangId,
    PBYTE pbOriginalProductId,
    DWORD cbOriginalProductId,
    PBYTE pbAdjustedProductId,
    DWORD cbAdjustedProductId,
    LICENSED_VERSION_INFO* pLicensedVersionInfo,
    DWORD dwNumLicensedVersionInfo,
    PBYTE *pbData,
    PDWORD cbData
);

DWORD 
LSExtensionToMsLicensedProductInfo(
    PBYTE      pbData,
    DWORD      cbData,
    PDWORD     pdwQuantity,
    PDWORD     pdwPlatformId,
    PDWORD     pdwLanguagId,
    PBYTE*     ppbOriginalProductId,
    PDWORD     pcbOriginalProductId,
    PBYTE*     ppbAdjustedProductId,
    PDWORD     pcbAdjustedProductId,
    LICENSED_VERSION_INFO** ppLicenseInfo,
    PDWORD     pdwNumberLicensedVersionInfo
);

DWORD
LSEnumerateCertNameInfo(
    LPBYTE pbData,
    DWORD cbData,
    EnumerateCertNameInfoCallBack func,
    HANDLE dwUserData
);

LICENSE_STATUS
LSEncryptClientHWID(HWID* pHwid, 
                    PBYTE pbData, 
                    PDWORD cbData, 
                    PBYTE pbSecretKey, 
                    DWORD cbSecretKey);

LICENSE_STATUS
LSDecodeClientHWID( PBYTE pbData, 
                    DWORD cbData, 
                    PBYTE pbSecretKey, 
                    DWORD cbSecretKey,
                    HWID* pHwid);

LICENSE_STATUS
LicenseGetSecretKey(
    PDWORD  pcbSecretKey,
    BYTE FAR *   pSecretKey 
);

LICENSE_STATUS
LSExtensionToMsLicenseServerInfo(
    PBYTE   pbData,
    DWORD   cbData,
    LPTSTR* szIssuer,
    LPTSTR* szIssuerId,
    LPTSTR* szScope
);

LICENSE_STATUS
LSMsLicenseServerInfoToExtension(
    LPTSTR szIssuer,
    LPTSTR szIssuerId,
    LPTSTR szScope,
    PBYTE* pbData,
    PDWORD cbData
);

LICENSE_STATUS
DecodeLicense20(
    IN PCERT_INFO     pCertInfo,
    IN PBYTE          pbSecretKey,
    IN DWORD          cbSecretKey,
    IN OUT PLICENSEDPRODUCT pLicensedInfo,
    IN OUT ULARGE_INTEGER*  ulSerialNumber
);

#ifdef __cplusplus
};
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\inc\buffers.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    buffers

Abstract:

    This header file provides dynamic buffer and string classes for general use.

Author:

    Doug Barlow (dbarlow) 10/5/1995

Environment:

    Win32

Notes:



--*/

#ifndef _BUFFERS_H_
#define _BUFFERS_H_

#include <string.h>
#include "memCheck.h"


//
//==============================================================================
//
//  CBuffer
//

class CBuffer
{
public:

    //  Constructors & Destructor

    CBuffer()           // Default Initializer
    { Initialize(); };

    CBuffer(            // Initialize with starting length.
        IN DWORD cbLength)
    { Initialize();
      Presize(cbLength, FALSE); };

    CBuffer(            // Initialize with starting data.
        IN const BYTE * const pbSource,
        IN DWORD cbLength)
    { Initialize();
      Set(pbSource, cbLength); };

    virtual ~CBuffer()  // Tear down.
    { Clear(); };


    //  Properties
    //  Methods

    void
    Clear(void);        // Free up any allocated memory.

    LPBYTE
    Reset(void);        // Return to default state (don't loose memory.)

    LPBYTE
    Presize(            // Make sure the buffer is big enough.
        IN DWORD cbLength,
        IN BOOL fPreserve = FALSE);

    LPBYTE
    Resize(         // Make sure the buffer & length are the right size.
        DWORD cbLength,
        BOOL fPreserve = FALSE);

    LPBYTE
    Set(            // Load a value.
        IN const BYTE * const pbSource,
        IN DWORD cbLength);

    LPBYTE
    Append(         // Append more data to the existing data.
        IN const BYTE * const pbSource,
        IN DWORD cbLength);

    DWORD
    Length(         // Return the length of the data.
        void) const
    { return m_cbDataLength; };

    LPBYTE
    Access(         // Return the data, starting at an offset.
        DWORD offset = 0)
    const
    { if (m_cbDataLength <= offset) return NULL;
      else return &m_pbBuffer[offset]; };

    int
    Compare(
        const CBuffer &bfSource)
    const;


    //  Operators

    CBuffer &
    operator=(
        IN const CBuffer &bfSource)
    { Set(bfSource.m_pbBuffer, bfSource.m_cbDataLength);
      return *this; };

    CBuffer &
    operator+=(
        IN const CBuffer &bfSource)
    { Append(bfSource.m_pbBuffer, bfSource.m_cbDataLength);
      return *this; };

    BYTE &
    operator[](
        DWORD offset)
        const
    { return *Access(offset); };

    int
    operator==(
        IN const CBuffer &bfSource)
        const
    { return 0 == Compare(bfSource); };

    int
    operator!=(
        IN const CBuffer &bfSource)
        const
    { return 0 != Compare(bfSource); };


protected:

    //  Properties

    LPBYTE m_pbBuffer;
    DWORD m_cbDataLength;
    DWORD m_cbBufferLength;


    //  Methods

    void
    Initialize(void)
    {
        m_pbBuffer = NULL;
        m_cbDataLength = 0;
        m_cbBufferLength = 0;
    };

    CBuffer(           //  Object assignment constructor.
        IN const CBuffer &bfSourceOne,
        IN const CBuffer &bfSourceTwo)
    {
        Initialize();
        Presize(bfSourceOne.m_cbDataLength + bfSourceTwo.m_cbDataLength);
        Set(bfSourceOne.m_pbBuffer, bfSourceOne.m_cbDataLength);
        Append(bfSourceTwo.m_pbBuffer, bfSourceTwo.m_cbDataLength);
    };

    friend
        CBuffer 
        operator+(
            IN const CBuffer &bfSourceOne,
            IN const CBuffer &bfSourceTwo);
};


/*++

Clear:

    This routine resets a CBuffer to it's initial state, freeing any allocated
    memory.

Arguments:

    None

Return Value:

    None

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

inline void
CBuffer::Clear(
    void)
{
    if (NULL != m_pbBuffer)
        delete[] m_pbBuffer;
    Initialize();
}


/*++

Reset:

    This routine logically empties the CBuffer without actually deallocating
    memory.  It's data lengh goes to zero.

Arguments:

    None

Return Value:

    The address of the buffer.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

inline LPBYTE
CBuffer::Reset(
    void)
{
    m_cbDataLength = 0;
    return m_pbBuffer;
}


/*++

Presize:

    This is the primary workhorse of the CBuffer class.  It ensures that the
    size of the buffer is of the proper size.  Data in the buffer may optionally
    be preserved, in which case the data length doesn't change.  If the buffer
    is not preserved, then the data length is reset to zero.

Arguments:

    cbLength supplies the desired length of the buffer.

    fPreserve supplies a flag indicating whether or not to preserve the current
        contents of the buffer.

Return Value:

    The address of the properly sized buffer.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

inline LPBYTE
CBuffer::Presize(
    IN DWORD cbLength,
    IN BOOL fPreserve)
{
    LPBYTE pbNewBuf = NULL;
    if (fPreserve && (0 < m_cbDataLength))
    {

        //
        // Increase the buffer length, and preserve the existing data.
        //

        if (m_cbBufferLength < cbLength)
        {
            NEWReason("Buffer contents")
            pbNewBuf = new BYTE[cbLength];
            if (NULL == pbNewBuf)
                goto ErrorExit;
            memcpy(pbNewBuf, m_pbBuffer, m_cbDataLength);
            delete[] m_pbBuffer;
            m_pbBuffer = pbNewBuf;
            pbNewBuf = NULL;
            m_cbBufferLength = cbLength;
        }
    }
    else
    {

        //
        // Increase the buffer length, but lose any existing data.
        //

        if (m_cbBufferLength < cbLength)
        {
            NEWReason("Buffer contents")
            pbNewBuf = new BYTE[cbLength];
            if (NULL == pbNewBuf)
                goto ErrorExit;
            if (NULL != m_pbBuffer)
                delete[] m_pbBuffer;
            m_pbBuffer = pbNewBuf;
            pbNewBuf = NULL;
            m_cbBufferLength = cbLength;
        }
        m_cbDataLength = 0;
    }
    return m_pbBuffer;

ErrorExit:
    if (NULL != pbNewBuf)
        delete[] pbNewBuf;
    return NULL;
}


/*++

Resize:

    This method sets the length of the data to the given size.  If the buffer
    isn't big enough to support that data length, it is enlarged.

Arguments:

    cbLength supplies the new length of the data.

    fPreserve supplies a flag indicating whether or not to preserve existing
        data.

Return Value:

    The address of the buffer.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

inline LPBYTE
CBuffer::Resize(
    DWORD cbLength,
    BOOL fPreserve)
{
    LPBYTE pb = Presize(cbLength, fPreserve);
    if (NULL != pb)
        m_cbDataLength = cbLength;
    return pb;
}


/*++

Set:

    This method sets the contents of the data to the given value.  If the buffer
    isn't big enough to hold the given data, it is enlarged.

Arguments:

    pbSource supplies the data to place in the data buffer.

    cbLength supplies the length of that data, in bytes.

Return Value:

    The address of the buffer.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

inline LPBYTE
CBuffer::Set(
    IN const BYTE * const pbSource,
    IN DWORD cbLength)
{
    LPBYTE pb = Presize(cbLength, FALSE);
    if (NULL != pb)
    {
        if (0 < cbLength)
            memcpy(pb, pbSource, cbLength);
        m_cbDataLength = cbLength;
    }
    return pb;
}


/*++

CBuffer::Append:

    This method appends the supplied data onto the end of the existing data,
    enlarging the buffer if necessary.

Arguments:

    pbSource supplies the data to be appended.

    cbLength supplies the length of the data to be appended, in bytes.

Return Value:

    The address of the buffer.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

inline LPBYTE
CBuffer::Append(
    IN const BYTE * const pbSource,
    IN DWORD cbLength)
{
    LPBYTE pb = m_pbBuffer;
    if (0 < cbLength)
    {
        pb = Presize(m_cbDataLength + cbLength, TRUE);
        if (NULL != pb)
        {
            memcpy(&pb[m_cbDataLength], pbSource, cbLength);
            m_cbDataLength += cbLength;
        }
    }
    return pb;
}


/*++

CBuffer::Compare:

    This method compares the contents of another CBuffer to this one, and
    returns a value indicating a comparative value.

Arguments:

    bfSource supplies the other buffer.

Return Value:

    < 0 - The other buffer is less than this one.
    = 0 - The other buffer is identical to this one.
    > 0 - The other buffer is greater than this one.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

inline int
CBuffer::Compare(
    const CBuffer &bfSource)
const
{
    if (m_cbDataLength < bfSource.m_cbDataLength)
        return *(bfSource.m_pbBuffer + m_cbDataLength);
    else if (m_cbDataLength > bfSource.m_cbDataLength)
        return *(m_pbBuffer + bfSource.m_cbDataLength);
    else if (0 < m_cbDataLength)
        return memcmp(m_pbBuffer, bfSource.m_pbBuffer, m_cbDataLength);
    else
        return 0;
}


/*++

operator+:

    This routine is a special operator that allows addition of two CBuffers to
    produce a third, a la bfThree = bfOne + bfTwo.  It calls the special
    protected constructor of CBuffer.

Arguments:

    bfSourceOne supplies the first buffer
    bfSourceTwo supplies the second buffer

Return Value:

    A reference to a temporary CBuffer that is the concatenation of the two
    provided buffers.

Author:

    Doug Barlow (dbarlow) 10/5/1995

--*/

inline CBuffer 
operator+(
    IN const CBuffer &bfSourceOne,
    IN const CBuffer &bfSourceTwo)
{
    return CBuffer(bfSourceOne, bfSourceTwo);
}

#endif // _BUFFERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\inc\cryptkey.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cryptkey.h
//
//  Contents:	Functions that are used to pack and unpack different messages
//
//  Classes:
//
//  Functions:	
//
//  History:    12-23-97  v-sbhatt   Created
//
//----------------------------------------------------------------------------

#ifndef _CRYPTKEY_H_
#define _CRYPTKEY_H_

//
//  Generic CryptSystem structure to be used for all cryptographic operations
//    
typedef struct _CryptSystem
{
	DWORD					dwCryptState;							//State in which the system is in
    DWORD		            dwSignatureAlg;							//Signature AlgID	
	DWORD		            dwKeyExchAlg;							//KeyExchAlgID	
	DWORD		            dwSessKeyAlg;							//Symmetric Key ALg
	DWORD		            dwMACAlg;								//MAC algID
	UCHAR		            rgbClientRandom[LICENSE_RANDOM];		//Client Random
	UCHAR		            rgbServerRandom[LICENSE_RANDOM];		//ServerRandom
    UCHAR                   rgbPreMasterSecret[LICENSE_PRE_MASTER_SECRET];   //Place for pms and ms
    UCHAR                   rgbMACSaltKey[LICENSE_MAC_WRITE_KEY];
    UCHAR                   rgbSessionKey[LICENSE_SESSION_KEY];
}CryptSystem, *PCryptSystem;

#define CRYPT_SYSTEM_STATE_INITIALIZED			0x00000000
#define CRYPT_SYSTEM_STATE_PRE_MASTER_SECRET	0x00000001
#define CRYPT_SYSTEM_STATE_MASTER_SECRET		0x00000002
#define CRYPT_SYSTEM_STATE_SESSION_KEY			0x00000003
#define CRYPT_SYSTEM_STATE_MAC_DONE				0x00000004

#ifdef __cplusplus
extern "C" {
#endif

LICENSE_STATUS
CALL_TYPE
LicenseSetPreMasterSecret(
						PCryptSystem	pCrypt,
						PUCHAR			pPreMasterSecret
						);

LICENSE_STATUS
CALL_TYPE
LicenseBuildMasterSecret(
                PCryptSystem   pSystem
                );

LICENSE_STATUS
CALL_TYPE
LicenseMakeSessionKeys(
				PCryptSystem	pCrypt,
				DWORD			dwReserved
			    );

LICENSE_STATUS
CALL_TYPE
LicenseVerifyServerCert(
				PHydra_Server_Cert	pCert
				);

LICENSE_STATUS
CALL_TYPE
LicenseGenerateMAC(
				   PCryptSystem		pCrypt,
				   PBYTE			pbData,
				   DWORD			cbData,
				   PBYTE			pbMACData
				   );

LICENSE_STATUS
CALL_TYPE
LicenseEnvelopeData(
	PBYTE			pbPublicKey,
	DWORD			cbPublicKey,
	PBYTE			pbData,
	DWORD			cbData,
	PBYTE			pbEnvelopedData,
	DWORD			*cbEnvelopedData
	);


LICENSE_STATUS
CALL_TYPE
LicenseDecryptEnvelopedData( 
	PBYTE			pbPrivateKey,
	DWORD			cbPrivateKey,
	PBYTE			pbEnvelopedData,
	DWORD			cbEnvelopedData,
	PBYTE			pbData,
	DWORD			*pcbData );


LICENSE_STATUS    
CALL_TYPE
LicenseEncryptSessionData( 
    PCryptSystem    pCrypt,
	PBYTE			pbData,
	DWORD			cbData
	);


LICENSE_STATUS
CALL_TYPE
LicenseDecryptSessionData(
	PCryptSystem    pCrypt,
    PBYTE			pbData,
	DWORD			cbData
	);

//Temporarily declared and defined in Cryptkey.h and .c

LICENSE_STATUS
CALL_TYPE
GenerateClientHWID(
				   PHWID	phwid
				  );

LICENSE_STATUS
CALL_TYPE
LicenseEncryptHwid(
    PHWID   pHwid,
    PDWORD  pcbEncryptedHwid,
    PBYTE   pEncryptedHwid,
    DWORD   cbSecretKey,
    PBYTE   pSecretKey );


LICENSE_STATUS
CALL_TYPE
LicenseDecryptHwid(
    PHWID pHwid,
    DWORD cbEncryptedHwid,
    PBYTE pEncryptedHwid,
    DWORD cbSecretKey,
    PBYTE pSecretKey );


LICENSE_STATUS
CALL_TYPE
UnpackHydraServerCertificate(
    PBYTE				pbMessage,
	DWORD				cbMessage,
	PHydra_Server_Cert	pCanonical );


#ifdef __cplusplus
}
#endif

#endif //_CRYPTKEY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\inc\cliprot.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cliprot.h
//
//  Contents:   Contains different client states and client protocol
//              related definitions        
//
//  Classes:
//
//  Functions:
//
//  History:    12-23-97   v-sbhatt   Created
//
//----------------------------------------------------------------------------

#ifndef _CLIPROT_H_
#define _CLIPROT_H



#ifdef __cplusplus
extern "C" {
#endif

//Different states for client state machine
#define LICENSE_CLIENT_STATE_WAIT_SERVER_HELLO              0x00    //Initial state of the machine
#define LICENSE_CLIENT_STATE_KEY_EXCHANGE_INFO              0x01    //Client key exchange info
#define LICENSE_CLIENT_STATE_LICENSE_RESPONSE               0x02    //License info
#define LICENSE_CLIENT_STATE_NEW_LICENSE_REQUEST            0x03    //Client asked for a new license
#define LICENSE_CLIENT_STATE_PLATFORM_INFO                  0x04    //Platform info
#define LICENSE_CLIENT_STATE_PLATFORM_CHALLENGE_RESPONSE    0x05    //Platform challenge response
#define LICENSE_CLIENT_STATE_ERROR                          0x06    //Error state
#define LICENSE_CLIENT_STATE_ABORT                          0x07    //Total abort;
#define LICENSE_CLIENT_STATE_DONE                           0x08

LICENSE_STATUS
CALL_TYPE
LicenseClientHandleServerMessage(
                     PLicense_Client_Context    pContext,
                     UINT32                     *puiExtendedErrorInfo,
                     BYTE FAR *                 pbInput,
                     DWORD                      cbInput,
                     BYTE FAR *                 pbOutput,
                     DWORD FAR *                pcbOutput
                     );
LICENSE_STATUS
CALL_TYPE
LicenseClientHandleServerError(
                               PLicense_Client_Context  pContext,
                               PLicense_Error_Message   pCanonical,
                               UINT32                   *puiExtendedErrorInfo,
                               BYTE FAR *               pbMessage,
                               DWORD FAR *              pcbMessage
                               );

LICENSE_STATUS
CALL_TYPE
LicenseClientHandleServerRequest(
                               PLicense_Client_Context          pContext,
                               PHydra_Server_License_Request    pCanonical,
                               BOOL                             fNewLicense,
                               BYTE FAR *                       pbMessage,
                               DWORD FAR *                      pcbMessage,
                               BOOL                             fSupportExtendedError
                               );

LICENSE_STATUS
CALL_TYPE
LicenseClientHandleServerPlatformChallenge(
                               PLicense_Client_Context          pContext,
                               PHydra_Server_Platform_Challenge pCanonical,
                               BYTE FAR *                       pbMessage,
                               DWORD FAR *                      pcbMessage,
                               BOOL                             fSupportExtendedError
                               );

LICENSE_STATUS
CALL_TYPE
LicenseClientHandleNewLicense(
                               PLicense_Client_Context      pContext,
                               PHydra_Server_New_License    pCanonical,
                               BOOL                         fNew,
                               BYTE FAR *                   pbMessage,
                               DWORD FAR *                      pcbMessage
                               );

LICENSE_STATUS 
CALL_TYPE
ClientConstructLicenseInfo(
                           PLicense_Client_Context  pContext,
                           BYTE FAR *               pbInput,
                           DWORD                    cbInput,
                           BYTE FAR *               pbOutput,
                           DWORD FAR *              pcbOutput,
                           BOOL                     fExtendedError
                           );

LICENSE_STATUS 
CALL_TYPE
ClientConstructNewLicenseRequest(
                           PLicense_Client_Context  pContext,
                           BYTE FAR *               pbOutput,
                           DWORD FAR *              pcbOutput,
                           BOOL                     fExtendedError
                           );

LICENSE_STATUS
CALL_TYPE
ClientConstructErrorAlert(
                         PLicense_Client_Context    pContext,
                         DWORD                      dwErrorCode,
                         DWORD                      dwStateTransition,
                         BYTE FAR *                 pbErrorInfo,
                         DWORD                      cbErrorInfo,
                         BYTE FAR *                 pbOutput,
                         DWORD FAR *                pcbOutput,
                         BOOL                       fExtendedError
                         );

LICENSE_STATUS
CALL_TYPE
ClientGenerateChallengeResponse(
                                PLicense_Client_Context     pContext,
                                PBinary_Blob                pChallengeData,
                                PBinary_Blob                pResponseData
                                );



#ifdef __cplusplus
}
#endif
#endif  //_CLIPROT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\inc\dynarray.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dynarray

Abstract:

    This header file implements a Dynamic Array.

Author:

    Doug Barlow (dbarlow) 10/5/1995

Environment:

    Win32

Notes:



--*/

#ifndef _DYNARRAY_H_
#define _DYNARRAY_H_


//
//==============================================================================
//
//  CDynamicArray
//

template <class T>
class CDynamicArray
{
public:

    //  Constructors & Destructor

    CDynamicArray(void)
    { m_Max = m_Mac = 0; m_pvList = NULL; };

    virtual ~CDynamicArray()
    { Clear(); };


    //  Properties
    //  Methods

    void
    Clear(void)
    {
        if (NULL != m_pvList)
        {
            delete[] m_pvList;
            m_pvList = NULL;
            m_Max = 0;
            m_Mac = 0;
        }
    };

    void
    Empty(void)
    { m_Mac = 0; };

    T *
    Set(
        IN int nItem,
        IN T *pvItem);

    T *
    Insert(
        IN int nItem,
        IN T *pvItem);

    T *
    Add(
        IN T *pvItem);

    T * const
    Get(
        IN int nItem)
    const;

    DWORD
    Count(void) const
    { return m_Mac; };


    //  Operators
    T * const
    operator[](int nItem) const
    { return Get(nItem); };


protected:
    //  Properties

    DWORD
        m_Max,          // Number of element slots available.
        m_Mac;          // Number of element slots used.
    T **
        m_pvList;       // The elements.


    //  Methods
};


/*++

Set:

    This routine sets an item in the collection array.  If the array isn't that
    big, it is expanded with NULL elements to become that big.

Arguments:

    nItem - Supplies the index value to be set.
    pvItem - Supplies the value to be set into the given index.

Return Value:

    The value of the inserted value, or NULL on errors.

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

template<class T>
inline T *
CDynamicArray<T>::Set(
    IN int nItem,
    IN T * pvItem)
{
    DWORD index;


    //
    // Make sure the array is big enough.
    //

    if ((DWORD)nItem >= m_Max)
    {
        int newSize = (0 == m_Max ? 4 : m_Max);
        while (nItem >= newSize)
            newSize *= 2;
        NEWReason("Dynamic Array")
        T **newList = new T*[newSize];
        if (NULL == newList)
            goto ErrorExit;
        for (index = 0; index < m_Mac; index += 1)
            newList[index] = m_pvList[index];
        if (NULL != m_pvList)
            delete[] m_pvList;
        m_pvList = newList;
        m_Max = newSize;
    }


    //
    // Make sure intermediate elements are filled in.
    //

    if ((DWORD)nItem >= m_Mac)
    {
        for (index = m_Mac; index < (DWORD)nItem; index += 1)
            m_pvList[index] = NULL;
        m_Mac = (DWORD)nItem + 1;
    }


    //
    // Fill in the list element.
    //

    m_pvList[(DWORD)nItem] = pvItem;
    return pvItem;

ErrorExit:
    return NULL;
}


/*++

Insert:

    This routine inserts an element in the array by moving all elements above it
    up one, then inserting the new element.

Arguments:

    nItem - Supplies the index value to be inserted.
    pvItem - Supplies the value to be set into the given index.

Return Value:

    The value of the inserted value, or NULL on errors.

Author:

    Doug Barlow (dbarlow) 10/10/1995

--*/

template<class T>
inline T *
CDynamicArray<T>::Insert(
    IN int nItem,
    IN T * pvItem)
{
    DWORD index;
    for (index = nItem; index < m_Mac; index += 1)
        if (NULL == Set(index + 1, Get(index)))
            return NULL;    // Only the first one can fail, so no change
                            // happens on errors.
    return Set(nItem, pvItem);
}


/*++

Add:

    This method adds an element to the end of the dynamic array.

Arguments:

    pvItem - Supplies the value to be added to the list.

Return Value:

    The value of the added value, or NULL on errors.

Author:

    Doug Barlow (dbarlow) 10/10/1995

--*/

template<class T>
inline T *
CDynamicArray<T>::Add(
    IN T *pvItem)
{
    return Set(Count(), pvItem);
}


/*++

Get:

    This method returns the element at the given index.  If there is no element
    previously stored at that element, it returns NULL.  It does not expand the
    array.

Arguments:

    nItem - Supplies the index into the list.

Return Value:

    The value stored at that index in the list, or NULL if nothing has ever been
    stored there.

Author:

    Doug Barlow (dbarlow) 7/13/1995

--*/

template <class T>
inline T * const
CDynamicArray<T>::Get(
    int nItem)
    const
{
    if (m_Mac <= (DWORD)nItem)
        return NULL;
    else
        return m_pvList[nItem];
}

#endif // _DYNARRAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\inc\hcpack.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       Hcpack.h
//
//  Contents:	Functions that are used to pack and unpack different messages
//				coming in to and going out from Hydra Client
//  Classes:
//
//  Functions:
//
//  History:    12-20-97  v-sbhatt   Created
//
//----------------------------------------------------------------------------

#ifndef	_HCPACK_H_
#define _HCPACK_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// Functions for Packing different Client Messages from the corresponding
// structures to simple binary blob
//

LICENSE_STATUS
PackHydraClientNewLicenseRequest(
			IN		PHydra_Client_New_License_Request	pCanonical,
            IN      BOOL                                fExtendedError,
			OUT		BYTE FAR *							pbBuffer,
			IN OUT	DWORD FAR *							pcbBuffer
			);

LICENSE_STATUS
PackHydraClientLicenseInfo(
			IN		PHydra_Client_License_Info      pCanonical,
            IN      BOOL                            fExtendedError,
			OUT		BYTE FAR *						pbBuffer,
			IN OUT	DWORD FAR *                     pcbBuffer            
			);


LICENSE_STATUS
PackHydraClientPlatformChallengeResponse(
			IN		PHydra_Client_Platform_Challenge_Response	pCanonical,
            IN      BOOL                                        fExtendedError,
			OUT 	BYTE FAR *									pbBuffer,
			IN OUT	DWORD FAR *									pcbBuffer
			);

LICENSE_STATUS
PackLicenseErrorMessage(
			IN  	PLicense_Error_Message			pCanonical,
            IN      BOOL                            fExtendedError,
			OUT 	BYTE FAR *						pbBuffer,
			IN OUT	DWORD FAR *						pcbBuffer
			);

//
// Functions for unpacking different Hydra Server Messages from 
// simple binary blobs to corresponding structure
//	
LICENSE_STATUS
UnPackLicenseErrorMessage(
			IN  	BYTE FAR *						pbMessage,
			IN  	DWORD							cbMessage,
			OUT 	PLicense_Error_Message			pCanonical
			);

LICENSE_STATUS
UnpackHydraServerLicenseRequest(
			IN  	BYTE FAR *						pbMessage,
			IN  	DWORD							cbMessage,
			OUT 	PHydra_Server_License_Request   pCanonical 
			);


LICENSE_STATUS
UnPackHydraServerPlatformChallenge(
			IN  	BYTE FAR *							pbMessage,
			IN  	DWORD								cbMessage,
			OUT 	PHydra_Server_Platform_Challenge	pCanonical
			);



LICENSE_STATUS
UnPackHydraServerNewLicense(
			IN  	BYTE FAR *						pbMessage,
			IN  	DWORD							cbMessage,
			OUT 	PHydra_Server_New_License		pCanonical
			);

LICENSE_STATUS
UnPackHydraServerUpgradeLicense(
			IN  	BYTE FAR *						pbMessage,
			IN  	DWORD							cbMessage,
			OUT 	PHydra_Server_Upgrade_License	pCanonical
			);

#if 0
LICENSE_STATUS
UnpackHydraServerCertificate(
							 IN		BYTE FAR *			pbMessage,
							 IN		DWORD				cbMessage,
							 OUT	PHydra_Server_Cert	pCaonical
							 );
#endif

LICENSE_STATUS
UnpackNewLicenseInfo(
					 BYTE FAR *			pbMessage,
					 DWORD				cbMessage,
					 PNew_License_Info	pCanonical
					 );


LICENSE_STATUS
UnPackExtendedErrorInfo( 
                   UINT32       *puiExtendedErrorInfo,
                   Binary_Blob  *pbbErrorInfo
                   );

#ifdef __cplusplus
}
#endif

#endif	//_HCPACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\inc\hccontxt.h ===
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       HCContxt.h
//
//  Contents:	Functions that are used to pack and unpack different messages
//
//  Classes:
//
//  Functions:	
//
//  History:    12-22-97  v-sbhatt   Created
//
//----------------------------------------------------------------------------


typedef struct _License_Client_Context
{
    DWORD                   dwProtocolVersion;  // Version of licensing protocol
    DWORD                   dwState;            // State at which the connection is in
    DWORD                   dwContextFlags;
    PCryptSystem            pCryptParam;
    UCHAR                   rgbMACData[LICENSE_MAC_DATA];
    DWORD                   cbLastMessage;
    BYTE FAR *              pbLastMessage;
    PHydra_Server_Cert      pServerCert;        // used only for preamble version older than 3.0
    DWORD                   cbServerPubKey;     // used for preamble version 3.0 and later.
    BYTE FAR *              pbServerPubKey;

}License_Client_Context, *PLicense_Client_Context;


PLicense_Client_Context 
LicenseCreateContext(
    VOID );


LICENSE_STATUS CALL_TYPE 
LicenseDeleteContext(
    HANDLE	 hContext
                     );


LICENSE_STATUS CALL_TYPE
LicenseInitializeContext(
    HANDLE *        phContext,
    DWORD           dwFlags );


LICENSE_STATUS CALL_TYPE
LicenseSetPublicKey(
    HANDLE          hContext,
    DWORD           cbPubKey,
    BYTE FAR *      pbPubKey );


LICENSE_STATUS CALL_TYPE
LicenseSetCertificate(
    HANDLE              hContext,
    PHydra_Server_Cert  pCertificate );


LICENSE_STATUS CALL_TYPE
LicenseAcceptContext(
    HANDLE      hContext,
    UINT32    * puiExtendedErrorInfo,
    BYTE FAR  * pbInput,
    DWORD       cbInput,
    BYTE FAR  * pbOutput,
    DWORD FAR * pcbOutput );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\inc\hydrakey.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows Terminal Server
//  Copyright (C) Microsoft Corporation, 1989-1998.
//
//  File:       HydraKey.h
//
//  Contents:   Hydra Server "Root" Public Key
//
//--------------------------------------------------------------------

#ifndef __HYDRAKEY__
#define __HYDRAKEY__

//
// This is the public key used to verify a
// hydra server's certificate
//
#define HYDRA_ROOT_PUBLIC_KEY \
     {                                                      \
     0x00, 0x00, 0x00, 0x00,                                \
     0x00, 0x00, 0x00, 0x00,                                \
     0x00, 0x00, 0x00, 0x00,                                \
     0x00, 0x00, 0x00, 0x00,                                \
     0x00, 0x00, 0x00, 0x00,                                \
     0x3d, 0x3a, 0x5e, 0xbd, 0x72, 0x43, 0x3e, 0xc9,        \
     0x4d, 0xbb, 0xc1, 0x1e, 0x4a, 0xba, 0x5f, 0xcb,        \
     0x3e, 0x88, 0x20, 0x87, 0xef, 0xf5, 0xc1, 0xe2,        \
     0xd7, 0xb7, 0x6b, 0x9a, 0xf2, 0x52, 0x45, 0x95,        \
     0xce, 0x63, 0x65, 0x6b, 0x58, 0x3a, 0xfe, 0xef,        \
     0x7c, 0xe7, 0xbf, 0xfe, 0x3d, 0xf6, 0x5c, 0x7d,        \
     0x6c, 0x5e, 0x06, 0x09, 0x1a, 0xf5, 0x61, 0xbb,        \
     0x20, 0x93, 0x09, 0x5f, 0x05, 0x6d, 0xea, 0x87,        \
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00         \
     }


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\inc\hslice.h ===
//+----------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        hslice.h
//
// Contents:    Hydra Server License Protocol API
//
// History:     01-07-98    FredCh  Created
//
//-----------------------------------------------------------------------------


#ifndef _HSLICENSE_H_
#define _HSLICENSE_H_

#include <license.h>


///////////////////////////////////////////////////////////////////////////////
// Context flags
//

#define LICENSE_CONTEXT_PER_SEAT     0x00000001
#define LICENSE_CONTEXT_CONCURRENT   0x00000002
#define LICENSE_CONTEXT_INTERNET     0x00000003
#define LICENSE_CONTEXT_REMOTE_ADMIN 0x00000004
#define LICENSE_CONTEXT_CON_QUEUE    0x00000005

///////////////////////////////////////////////////////////////////////////////
// These are the different responses that can be constructed by the 
// ConstructLicenseResponse API
//

#define LICENSE_RESPONSE_VALID_CLIENT       0x00000001
#define LICENSE_RESPONSE_INVALID_CLIENT     0x00000002

//-----------------------------------------------------------------------------
//
// Terminal server's license server discovery mechanism may log these
// events:
//
// LICENSING_EVENT_NO_LICENSE_SERVER - it cannot find any license server.
//
// LICENSING_EVENT_TEMP_LICENSE_EXPIRED - A client has been disconnected
// because its temporary license has expired.
//
// LICENSING_EVENT_NO_LICENSE_GRANTED - No license could be granted, and
// we're past the grace period
//
// LICENSING_EVENT_NO_CONCURRENT_LICENSE - No more remote admin or internet
// connector logons allowed.
//
//-----------------------------------------------------------------------------

#define LICENSING_EVENT_NO_LICENSE_SERVER                   0x00000001
#define LICENSING_EVENT_TEMP_LICENSE_EXPIRED                0x00000002
#define LICENSING_EVENT_NO_LICENSE_GRANTED                  0x00000003
#define LICENSING_EVENT_NO_CONCURRENT_LICENSE               0x00000004

///////////////////////////////////////////////////////////////////////////////
// Hydra server licensing API
//

#ifdef __cplusplus
extern "C" {
#endif


LICENSE_STATUS
InitializeLicenseLib(
    BOOL fUseLicenseServer );


LICENSE_STATUS
ShutdownLicenseLib();


LICENSE_STATUS
CreateLicenseContext(
    HANDLE * phContext,
    DWORD    dwFlag );


LICENSE_STATUS
InitializeLicenseContext(
    HANDLE                  hContext,
    DWORD                   dwFlags,
    LPLICENSE_CAPABILITIES  pLicenseCap );


LICENSE_STATUS
AcceptLicenseContext(
    HANDLE  hContext,
    DWORD   cbInBuf,
    PBYTE   pInBuf,
    DWORD * pcbOutBuf,
    PBYTE * ppOutBuf );


LICENSE_STATUS
DeleteLicenseContext(
    HANDLE hContext );


LICENSE_STATUS
GetConcurrentLicense(
    HANDLE  hContext,
    PLONG   pLicenseCount );
    

LICENSE_STATUS
ReturnConcurrentLicense(
    HANDLE  hContext,
    LONG    LicenseCount );


LICENSE_STATUS
GetConcurrentLicenseCount(
    HANDLE  hContext,
    PLONG   pLicenseCount );


LICENSE_STATUS
ConstructLicenseResponse(
    HANDLE      hLicense,
    DWORD       dwResponse,
    PDWORD      pcbOutBuf,
    PBYTE *     ppOutBuf );


LICENSE_STATUS
InitializeLicensingTimeBomb();

VOID
ReceivedPermanentLicense();

LICENSE_STATUS
SetInternetConnectorStatus(
    BOOL    *   pfStatus );


LICENSE_STATUS
GetInternetConnectorStatus(
    BOOL    * pfStatus );


VOID
CheckLicensingTimeBombExpiration();


VOID
LogLicensingEvent( 
    HANDLE  hLicense,
    DWORD   dwEventId );


LICENSE_STATUS
QueryLicenseInfo(
    HANDLE                  hLicense,
    PTS_LICENSE_INFO        pTsLicenseInfo );


VOID
FreeLicenseInfo(
    PTS_LICENSE_INFO        pTsLicenseInfo );

    
#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\inc\licdbg.h ===
/*++

Copyright (c) 1998-99  Microsoft Corporation

Module Name:

    licdbg.h

Abstract:


Author:

    Fred Chong (FredCh) 7/1/1998

Environment:

Notes:

--*/

#ifndef __LICDBG_H__
#define __LICDBG_H__

#define LS_LOG_ERROR                0x0001
#define LS_LOG_WARNING              0x0002
#define LS_LOG_TRACE                0x0004
#define LS_LOG_ALLOC                0x0008
#define LS_LOG_RES                  0x0010
#define DEB_ERROR					LS_LOG_ERROR
#define DEB_WARN					LS_LOG_WARNING
#define DEB_TRACE					LS_LOG_TRACE

#if DBG

extern DWORD   LicenseTraceIndent;

#define LS_ASSERT(x) \
	    if (!(x)) \
		LSAssert(#x, __FILE__, __LINE__, NULL); else


#define DebugLog(x) LicenseDebugLog x
#ifndef OS_WINCE
#define LS_BEGIN(x) LicenseDebugLog(DEB_TRACE,"BEGIN:" x "\n"); LicenseTraceIndent++;
#else
#define LS_BEGIN(x) LicenseDebugLog(DEB_TRACE,"BEGIN:", x, "\n"); LicenseTraceIndent++;
#endif
#define LS_RETURN(x) { LicenseTraceIndent--; LicenseDebugLog(DEB_TRACE, "END  Line %d\n", __LINE__); return (x); }
#define LS_LOG_RESULT(x) LicenseLogErrorCode((x), __FILE__, __LINE__)
#define LS_END(x)   { LicenseTraceIndent--; LicenseDebugLog(DEB_TRACE, "END:Line %d\n",  __LINE__); }
#define LS_BREAK()  { LicenseDebugLog(DEB_TRACE, "BREAK  Line %d\n",  __LINE__); }
#define LS_DUMPSTRING(size, data)  \
		if ((data)) \
		DbgDumpHexString((data), (size)); 

void 
LicenseDebugOutput(char *szOutString);


long
//CALL_TYPE
LicenseLogErrorCode(long, const char *, long);
void
//CALL_TYPE
//_cdecl
LicenseDebugLog(long, const char *, ...);

void    
//CALL_TYPE
DbgDumpHexString(const unsigned char*, DWORD);

void 
//CALL_TYPE
LSAssert( void *, void *, unsigned long, char *);

#else

#define LS_ASSERT(x)
#define DebugLog(x)
#define LS_BEGIN(x) 
#define LS_RETURN(x) return (x)
#define LS_LOG_RESULT(x) x
#define LS_END(x)
#define LS_BREAK()
#define LS_DUMPSTRING(size, data)
#define LicenseDebugOutput(x)
#define LicenseDebugLog
#define DbgDumpHexString(x, y)
#define LicenseTraceIndent
#define LicenseLogErrorCode
#endif	//_DEBUG



#endif /* __LICDBG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\inc\licekpak.h ===
/*++

Copyright (c) 1998-99  Microsoft Corporation

Module Name:

    licekpak.h

Abstract:


Author:

    Fred Chong (FredCh) 7/1/1998

Environment:

Notes:

--*/

#ifndef _LICE_KEYPACK_H_
#define _LICE_KEYPACK_H_

#include <windows.h>
#include <wincrypt.h>

///////////////////////////////////////////////////////////////////////////////
// keypack description
//

typedef struct _KeyPack_Description
{
    LCID    Locale;             // Locale ID

    DWORD   cbProductName;      // product name

    PBYTE   pbProductName;      // product name

    DWORD   cbDescription;      // Number of bytes in the description string

    PBYTE   pDescription;       // Pointer to the description string    

} KeyPack_Description, * PKeyPack_Description;


///////////////////////////////////////////////////////////////////////////////
// License keypack content
///////////////////////////////////////////////////////////////////////////////

//
// License keypack version
//

#define LICENSE_KEYPACK_VERSION_1_0                     0x00010000

//
// License keypack type
//

#define LICENSE_KEYPACK_TYPE_SELECT                     0x00000001
#define LICENSE_KEYPACK_TYPE_MOLP                       0x00000002
#define LICENSE_KEYPACK_TYPE_RETAIL                     0x00000003

//
// License keypack distribution channel identifiers
//

#define LICENSE_DISTRIBUTION_CHANNEL_OEM                0x00000001
#define LICENSE_DISTRIBUTION_CHANNEL_RETAIL             0x00000002

//
// License Keypack encryption information.
//

#define LICENSE_KEYPACK_ENCRYPT_CRYPTO                  0x00000000
#define LICENSE_KEYPACK_ENCRYPT_ALWAYSCRYPTO            0x00000001
#define LICENSE_KEYPACK_ENCRYPT_ALWAYSFRENCH            0x00000002
#define LICENSE_KEYPACK_ENCRYPT_NONE                    0x00000003
#define LICENSE_KEYPACK_ENCRYPT_PRIVATE                 0x00000004

#define LICENSE_KEYPACK_ENCRYPT_MIN                     LICENSE_KEYPACK_ENCRYPT_CRYPTO
#define LICENSE_KEYPACK_ENCRYPT_MAX                     LICENSE_KEYPACK_ENCRYPT_PRIVATE

typedef struct __LicensePackEncodeParm {
    DWORD dwEncodeType;
    HCRYPTPROV hCryptProv;

    PBYTE pbEncryptParm;    // depends on dwEncodeType
    DWORD cbEncryptParm;
} LicensePackEncodeParm, *PLicensePackEncodeParm;

typedef struct __LicensePackDecodeParm {
    HCRYPTPROV hCryptProv;

    //
    // Private binaries to generate encryption key to decrypt 
    // license key pack blob.  

    //
    // Private binaries to generate encryption key, this field is
    // ignore if key pack blob is encrypted using certificates.
    //
    PBYTE pbDecryptParm;
    DWORD cbDecryptParm;
    
    //
    // Certificate to generate encryption key, these fields are
    // require even data is encryped using private binaries.
    //
    DWORD cbClearingHouseCert;
    PBYTE pbClearingHouseCert;

    DWORD cbRootCertificate;
    PBYTE pbRootCertificate;

} LicensePackDecodeParm, *PLicensePackDecodeParm;

///////////////////////////////////////////////////////////////////////////////
// Content of license keypack 
//

typedef struct _License_KeyPack_
{
    DWORD                   dwVersion;          // version of this structure

    DWORD                   dwKeypackType;      // Select, MOLP, Retail

    DWORD                   dwDistChannel;      // Distribution channel: OEM/Retail

    GUID                    KeypackSerialNum;   // CH assigned serial number for this key pack
    
    FILETIME                IssueDate;          // Keypack issue date

    FILETIME                ActiveDate;         // License active date

    FILETIME                ExpireDate;         // License expiration date

    DWORD                   dwBeginSerialNum;   // beginning serial number for the licenses in the keypack

    DWORD                   dwQuantity;         // Number of licenses in the key pack

    DWORD                   cbProductId;        // product ID

    PBYTE                   pbProductId;        // product ID

    DWORD                   dwProductVersion;   // product version

    DWORD                   dwPlatformId;       // platform ID: Windows, Mac, UNIX etc...

    DWORD                   dwLicenseType;      // new, upgrade, competitive upgrade etc...

    DWORD                   dwDescriptionCount; // The number of human language descriptions

    PKeyPack_Description    pDescription;       // pointer to an array of keypack description

    DWORD                   cbManufacturer;     // The number of bytes in the manufacturer string

    PBYTE                   pbManufacturer;     // The manufacturer string

    DWORD                   cbManufacturerData; // The number of bytes in the manufacturer-specific data

    PBYTE                   pbManufacturerData; // Points to the manufacturer specific data
    
} License_KeyPack, * PLicense_KeyPack;


#define LICENSEPACKENCODE_VERSION           LICENSE_KEYPACK_VERSION_1_0
#define LICENSEPACKENCODE_CURRENTVERSION    LICENSEPACKENCODE_VERSION
#define LICENSEPACKENCODE_SIGNATURE         0xF0F0F0F0

typedef struct __EncodedLicenseKeyPack {
    DWORD dwSignature;      // old encoding puts size of encryption key.
    DWORD dwStructVersion;
    DWORD dwEncodeType;
    DWORD cbData;
    BYTE  pbData[1];
} EncodedLicenseKeyPack, *PEncodedLicenseKeyPack;


#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////////////
//
// Exported functions
//

DWORD WINAPI 
DecodeLicenseKeyPack(
    PLicense_KeyPack        pLicenseKeyPack,
    HCRYPTPROV              hCryptProv,
    DWORD                   cbClearingHouseCert,
    PBYTE                   pbClearingHouseCert,
    DWORD                   cbRootCertificate,
    PBYTE                   pbRootCertificate,
    DWORD                   cbKeyPackBlob,
    PBYTE                   pbKeyPackBlob );


DWORD WINAPI
DecodeLicenseKeyPackEx(
    OUT PLicense_KeyPack pLicenseKeyPack,
    IN PLicensePackDecodeParm pDecodeParm,
    IN DWORD cbKeyPackBlob,
    IN PBYTE pbKeyPackBlob 
);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\inc\licprot.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       licprot.h
//
//  Contents:   Licensing Protocol APIs
//
//  Classes:
//
//  Functions:
//
//  History:    02-15-00   RobLeit     Created
//
//----------------------------------------------------------------------------

#ifndef __LICPROT_H__
#define __LICPROT_H__

#ifdef __cplusplus
extern "C" {
#endif

LICENSE_STATUS CreateProtocolContext(LPLICENSE_CAPABILITIES pLicenseCap,HANDLE *phContext);

LICENSE_STATUS DeleteProtocolContext(HANDLE hContext);

LICENSE_STATUS InitializeProtocolLib();

LICENSE_STATUS ShutdownProtocolLib();

LICENSE_STATUS AcceptProtocolContext(HANDLE hContext,DWORD cbInBuf,PBYTE pInBuf,DWORD * pcbOutBuf,PBYTE * ppOutBuf);

LICENSE_STATUS ConstructProtocolResponse(HANDLE hLicense,DWORD dwResponse,PDWORD pcbOutBuf,PBYTE * ppOutBuf);

LICENSE_STATUS QueryLicenseInfo(HANDLE pLicenseContext,PTS_LICENSE_INFO pTsLicenseInfo);

LICENSE_STATUS RequestNewLicense(HANDLE hContext,TCHAR *tszLicenseServerName,LICENSEREQUEST *pLicenseRequest,TCHAR *tszComputerName,TCHAR *tszUserName,BOOL fAcceptTempLicense,BOOL fAcceptFewerLicenses,DWORD *pdwQuantity, DWORD *pcbLicense,PBYTE *ppbLicense);

LICENSE_STATUS InitProductInfo(PProduct_Info pProductInfo,LPTSTR lptszProductSku);

LICENSE_STATUS ReturnInternetLicense(HANDLE hContext,TCHAR *tszLicenseServer,LICENSEREQUEST *pLicenseRequest,ULARGE_INTEGER ulSerialNumber,DWORD dwQuantity);

BOOL AllowLicensingGracePeriodConnection();

DWORD StartCheckingGracePeriod();

DWORD StopCheckingGracePeriod();

LICENSE_STATUS DaysToExpiration(HANDLE hContext,DWORD *pdwDaysLeft,BOOL *pfTemporary);

LICENSE_STATUS
MarkLicenseFlags(HANDLE hContext, UCHAR ucFlags);
    
void LicenseLogEvent(WORD wEventType,DWORD dwEventId,WORD cStrings,PWCHAR *apwszStrings);


#ifdef __cplusplus
};
#endif

#endif // __LICPROT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\inc\rng.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       rng.h
//
//  Contents:	Functions that are used to generate rnadom numbers
//
//  Classes:
//
//  Functions:	GenerateRandomBits
//				GatherRandomBits
//
//
//  History:    12-19-97  v-sbhatt   Created
//
//----------------------------------------------------------------------------

#ifndef _RNG_H_
#define _RNG_H_


#define A_SHA_DIGEST_LEN    20
#define RAND_CTXT_LEN       60
#define RC4_REKEY_PARAM     500     // rekey every 500 bytes

typedef struct tagRandContext
{
    DWORD dwBitsFilled;
    BYTE  rgbBitBuffer[RAND_CTXT_LEN];
} RAND_CONTEXT, *PRAND_CONTEXT;

VOID GenerateRandomBits(PUCHAR pbBuffer, ULONG  dwLength);
void GatherRandomBits(PRAND_CONTEXT prandContext);

#endif	//_RNG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\inc\licecert.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    licecert.h

Abstract:

    The header file for the X509 certificates parsing and verification API

Author:

    Frederick Chong (fredch) 6/1/1998

Environment:

    Win32, WinCE, Win16

Notes:

--*/

#ifndef _LICE_CERT_H_
#define _LICE_CERT_H_

//-----------------------------------------------------------------------------
//
// Flags to indicate to VerifyCertChain on how should the validity dates in the
// certificate chain be handled.
//
//-----------------------------------------------------------------------------

#define CERT_DATE_ERROR_IF_INVALID      0x00000001
#define CERT_DATE_WARN_IF_INVALID       0x00000002
#define CERT_DATE_DONT_VALIDATE         0x00000003

#define CERT_DATE_OK                    0x00000004
#define CERT_DATE_NOT_BEFORE_INVALID    0x00000005
#define CERT_DATE_NOT_AFTER_INVALID     0x00000006

#ifdef __cplusplus
extern "C" {
#endif

//+----------------------------------------------------------------------------
//
// Function:
//
//  VerifyCertChain
//
// Abstract:
//
//  Verifies a chain of X509 certificates
//
// Parameters:
//
//  pbCert - The certificate chain to verify
//  cbCert - Size of the certificate chain
//  pbPublicKey - The memory to store the public key of the subject on output.
//                If set to NULL on input, the API will return 
//                LICENSE_STATUS_INSUFFICIENT_BUFFER and the size of the 
//                required buffer set in pcbPublicKey.
//  pcbPublicKey - Size of the allocated memory on input.  On output, contains
//                 the actual size of the public key.
//  pfDates - How the API should check the validity dates in the cert chain.
//            This flag may be set to the following values:
//
//  CERT_DATE_ERROR_IF_INVALID - The API will return an error if the
//                               dates are invalid. When the API returns,
//                               this flag will be set to CERT_DATE_OK if the
//                               dates are OK or one of CERT_DATE_NOT_BEFORE_INVALID
//                               or CERT_DATE_NOT_AFTER_INVALID.
//  CERT_DATE_DONT_VALIDATE - Don't validate the dates in the cert chain.  The value
//                            in this flag is not changed when the API returns. 
//  CERT_DATE_WARN_IF_INVALID - Don't return an error for invalid cert dates.
//                              When the API returns, this flag will be set to
//                              CERT_DATE_OK if the dates are OK or one of
//                              CERT_DATE_NOT_BEFORE_INVALID or 
//                              CERT_DATE_NOT_AFTER_INVALID.
//
// Return:
//
//  LICENSE_STATUS_OK if the function is successful.
//
//+----------------------------------------------------------------------------
 
LICENSE_STATUS
VerifyCertChain( 
    LPBYTE  pbCert, 
    DWORD   cbCert,
    LPBYTE  pbPublicKey,
    LPDWORD pcbPublicKey,
    LPDWORD pfDate );


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\inc\memcheck.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    memcheck

Abstract:

    This header file provides access to the memory allocation debugging
    utilities.

Author:

    Doug Barlow (dbarlow) 9/29/1995

Environment:

    Win32

Notes:

--*/

#ifndef _MEMCHECK_H_
#define _MEMCHECK_H_

#if DBG


#if ((!defined (OS_WINCE)) || (_WIN32_WCE > 300))
#ifdef __cplusplus
#include <iostream.h>                   //  Just in case it's not anywhere else.
extern "C" {
#else   // __cplusplus
#include <stdio.h>                      //  Just in case it's not anywhere else.
#endif  //  __cplusplus

#else
#include <stdio.h>
#endif



//-----------------------------------------------------------------------------
//
// Function prototype
//
//-----------------------------------------------------------------------------

extern BOOL
    debugGbl;                           //  Whether or not to print breakpoint status.

extern void
Breakpoint(                             //  A convienient spot for a breakpoint.
    void);

extern LPVOID
AllocateMemory(                         //  Memory manipulation routines.
    DWORD bytes,
    LPCTSTR allocator);

extern LPVOID
ReallocateMemory(
    LPVOID mem,
    DWORD bytes);

extern LPVOID
FreeMemory(
    LPVOID mem);

LPCTSTR
typeMemory(                             //  Show the reason for allocation.
    LPVOID mem);

extern void
DisplayMemory(                          //  Report statistics on allocated memory.
    void);

BOOL
ValidateMemory(                         // Check out the allocations
    void);

#if ((!defined (OS_WINCE)) || (_WIN32_WCE > 300))
#ifdef __cplusplus
}

#ifdef _MSVC
extern void
SetReason(
    LPCTSTR szWhy);

extern void *
::operator new(
    size_t size);

extern void
::operator delete(
    void *obj);
#endif

#endif __cplusplus
#endif
#else   //  _DEBUG
#ifdef __cplusplus
extern "C" {
#endif  //  __cplusplus

extern LPVOID
AllocateMemory(
    DWORD bytes);

extern LPVOID
ReallocateMemory(
    LPVOID mem,
    DWORD bytes);

extern LPVOID
FreeMemory(
    LPVOID mem);

#ifdef __cplusplus
    }
#endif  // __cplusplus
#endif  //  _DEBUG


#ifdef TRACE
#undef TRACE                            //  Get rid of any conflicting definitions.
#endif
#ifdef ASSERT
#undef ASSERT
#endif

#if defined(_DEBUG) && defined (_MSVC)

#define breakpoint Breakpoint()
#ifdef __cplusplus
#define TRACE(aMessage) cout << aMessage << endl;
#define ASSERT(aTruism) if (!(aTruism)) { \
    TRACE("Assertion failed:\n  " << #aTruism << "\n  module " << __FILE__ << "  line " << __LINE__) \
    breakpoint; }
#define NEWReason(x) SetReason(x);
#define DECLARE_NEW \
    void *operator new(size_t size); \
    void operator delete(void *obj);
#define IMPLEMENT_NEW(cls) \
    void * cls::operator new(size_t size) { \
        return (cls *)AllocateMemory(size, #cls " Object"); } \
    void cls::operator delete(void *obj) { \
        FreeMemory(obj); }
#define IMPLEMENT_INLINE_NEW(cls) \
    inline void * cls::operator new(size_t size) { \
        return (cls *)AllocateMemory(size, #cls " Object"); } \
    inline void cls::operator delete(void *obj) { \
        FreeMemory(obj); }
#else
#define TRACE(aMessage) (void)printf aMessage, fflush(stdout);
#define ASSERT(aTruism) if (!(aTruism)) { \
    TRACE(("Assertion failed:\n  %s\n  module %s, line %d\n", #aTruism, __FILE__, __LINE__)) \
    breakpoint; }
#endif
#define allocateMemory(aLocation, aType, aSize, aReason) \
    aLocation = (aType)AllocateMemory(aSize, aReason)
#define reallocateMemory(aLocation, aType, aSize) \
    aLocation = (aType)ReallocateMemory(aLocation, aSize)
#define freeMemory(aLocation, aType) \
    aLocation = (aType)FreeMemory(aLocation)
#define displayMemory DisplayMemory()

#else

#define breakpoint
#define TRACE(aMessage)
#define ASSERT(aTruism)
#ifdef __cplusplus
#define NEWReason(x)
#define DECLARE_NEW
#define IMPLEMENT_NEW(cls)
#endif

#define allocateMemory(aLocation, aType, aSize, aReason) \
    aLocation = (aType)GlobalAlloc(GMEM_FIXED, aSize)
#define reallocateMemory(aLocation, aType, aSize) \
    aLocation = (aType)GlobalReAlloc(aLocation, aSize, 0)
#define freeMemory(aLocation, aType) \
    aLocation = (aType)GlobalFree(aLocation)

#define displayMemory

#endif  //  _DEBUG

#endif  // _MEMCHECK_H_
// End memcheck.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\inc\tlsapi.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        tlsapi.h
//
// Contents:    
//
// History:     12-09-97    HueiWang    Created
//
//---------------------------------------------------------------------------
#ifndef __TLSAPI_H__
#define __TLSAPI_H__

#include "tlsdef.h"

#ifndef WINAPI
#define WINAPI      __stdcall
#endif

typedef BYTE*   PBYTE;
typedef DWORD*  PDWORD;
typedef PBYTE   LPBYTE;
typedef PDWORD  LPDWORD;
typedef UCHAR*  PUCHAR;

//----------------------------------------------------------------------------------
// IssuedLicense related structure
//
typedef struct __LSLicense {
    DWORD       dwVersion;
    DWORD       dwLicenseId;             // internal tracking number
    DWORD       dwKeyPackId;             // join with License Pack

    TCHAR       szHWID[GUID_MAX_SIZE];
    TCHAR       szMachineName[MAXCOMPUTERNAMELENGTH];
    TCHAR       szUserName[MAXUSERNAMELENGTH];

    DWORD       dwCertSerialLicense;
    DWORD       dwLicenseSerialNumber;
    DWORD       ftIssueDate;
    DWORD       ftExpireDate;
    UCHAR       ucLicenseStatus;
} LSLicense, *LPLSLicense;

typedef LSLicense LSLicenseSearchParm;
typedef LSLicenseSearchParm* LPLSLicenseSearchParm;

typedef struct __LSLicenseEx {
    DWORD       dwVersion;
    DWORD       dwLicenseId;             // internal tracking number
    DWORD       dwKeyPackId;             // join with License Pack

    TCHAR       szHWID[GUID_MAX_SIZE];
    TCHAR       szMachineName[MAXCOMPUTERNAMELENGTH];
    TCHAR       szUserName[MAXUSERNAMELENGTH];

    DWORD       dwCertSerialLicense;
    DWORD       dwLicenseSerialNumber;
    DWORD       ftIssueDate;
    DWORD       ftExpireDate;
    UCHAR       ucLicenseStatus;
    DWORD       dwQuantity;
} LSLicenseEx, *LPLSLicenseEx;

//----------------------------------------------------------------------------------
// Table License Key Pack related structure
//
typedef struct __LSKeyPack {
    DWORD       dwVersion;

    UCHAR       ucKeyPackType;
    
    TCHAR       szCompanyName[LSERVER_MAX_STRING_SIZE+1];
    TCHAR       szKeyPackId[LSERVER_MAX_STRING_SIZE+1];
    TCHAR       szProductName[LSERVER_MAX_STRING_SIZE+1];
    TCHAR       szProductId[LSERVER_MAX_STRING_SIZE+1];
    TCHAR       szProductDesc[LSERVER_MAX_STRING_SIZE+1];

    WORD        wMajorVersion;
    WORD        wMinorVersion;
    DWORD       dwPlatformType;
    UCHAR       ucLicenseType;
    DWORD       dwLanguageId;
    UCHAR       ucChannelOfPurchase;

    TCHAR       szBeginSerialNumber[LSERVER_MAX_STRING_SIZE+1];

    DWORD       dwTotalLicenseInKeyPack;
    DWORD       dwProductFlags;

    DWORD       dwKeyPackId;
    UCHAR       ucKeyPackStatus;
    DWORD       dwActivateDate;
    DWORD       dwExpirationDate;
    DWORD       dwNumberOfLicenses;
} LSKeyPack, *LPLSKeyPack;

typedef LSKeyPack LSKeyPackSearchParm;
typedef LSKeyPackSearchParm* LPLSKeyPackSearchParm;

//---------------------------------------------------------------------------
typedef struct {
    DWORD   dwLow;
    DWORD   dwHigh;
} LSRange, *LPLSRange, *PLSRange;

    
typedef HANDLE                  TLS_HANDLE;
typedef DWORD                   CHALLENGE_CONTEXT;
typedef CHALLENGE_CONTEXT*      PCHALLENGE_CONTEXT;

typedef BOOL (* TLSENUMERATECALLBACK)(TLS_HANDLE hBinding, LPCTSTR pszServer, HANDLE dwUserData);

#ifdef __cplusplus
extern "C" {
#endif

HRESULT FindEnterpriseServer(TLS_HANDLE *phBinding);

HRESULT GetAllEnterpriseServers(WCHAR ***ppszServers, DWORD *pdwCount);

// void *MIDL_user_allocate(DWORD size);
// void MIDL_user_free(void *pointer); 
// void *  __stdcall MIDL_user_allocate(DWORD);
// void  __stdcall MIDL_user_free( void * );

DWORD WINAPI
EnumerateTlsServer(  
    TLSENUMERATECALLBACK fCallBack, 
    HANDLE dwUserData,
    DWORD dwTimeOut,
    BOOL fRegOnly
);

TLS_HANDLE WINAPI
TLSConnectToAnyLsServer(
    DWORD dwTimeout
);

TLS_HANDLE WINAPI 
TLSConnectToLsServer( 
    LPTSTR szLsServer 
);

void WINAPI 
TLSDisconnectFromServer( 
    TLS_HANDLE hHandle 
);

DWORD WINAPI
TLSGetVersion (
    TLS_HANDLE hHandle,
    PDWORD pdwVersion
);

DWORD WINAPI 
TLSSendServerCertificate( 
     TLS_HANDLE hHandle,
     DWORD cbCert,
     PBYTE pbCert,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSGetServerName( 
     TLS_HANDLE hHandle,
     LPTSTR pszMachineName,
     PDWORD pcbSize,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSGetServerScope( 
     TLS_HANDLE hHandle,
     LPTSTR pszScopeName,
     PDWORD pcbSize,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSGetInfo( 
     TLS_HANDLE hHandle,
     DWORD  cbHSCert,
     PBYTE  pHSCert,
     PDWORD pcbLSCert,
     PBYTE* ppbLSCert,
     DWORD* pcbLSSecretKey,
     PBYTE* ppbLSSecretKey,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSIssuePlatformChallenge( 
     TLS_HANDLE hHandle,
     DWORD dwClientInfo,
     PCHALLENGE_CONTEXT pChallengeContext,
     PDWORD pcbChallengeData,
     PBYTE* pChallengeData,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSIssueNewLicense( 
     TLS_HANDLE hHandle,
     CHALLENGE_CONTEXT ChallengeContext,
     LICENSEREQUEST* pRequest,
     LPTSTR pszMachineName,
     LPTSTR pszUserName,
     DWORD cbChallengeResponse,
     PBYTE pbChallengeResponse,
     BOOL bAcceptTemporaryLicense,
     PDWORD pcbLicense,
     PBYTE* ppbLicense,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSIssueNewLicenseEx( 
     TLS_HANDLE hHandle,
     PDWORD pSupportFlags,
     CHALLENGE_CONTEXT ChallengeContext,
     LICENSEREQUEST  *pRequest,
     LPTSTR pMachineName,
     LPTSTR pUserName,
     DWORD cbChallengeResponse,
     PBYTE pbChallengeResponse,
     BOOL bAcceptTemporaryLicense,
     DWORD dwQuantity,
     PDWORD pcbLicense,
     PBYTE* ppbLicense,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSIssueNewLicenseExEx( 
     TLS_HANDLE hHandle,
     PDWORD pSupportFlags,
     CHALLENGE_CONTEXT ChallengeContext,
     LICENSEREQUEST  *pRequest,
     LPTSTR pMachineName,
     LPTSTR pUserName,
     DWORD cbChallengeResponse,
     PBYTE pbChallengeResponse,
     BOOL bAcceptTemporaryLicense,
     BOOL bAcceptFewerLicenses,
     DWORD *pdwQuantity,
     PDWORD pcbLicense,
     PBYTE* ppbLicense,
     PDWORD pdwErrCode
);

DWORD WINAPI
TLSUpgradeLicense(
     TLS_HANDLE hHandle,
     LICENSEREQUEST* pRequest,
     CHALLENGE_CONTEXT ChallengeContext,
     DWORD cbChallengeResponse,
     PBYTE pbChallengeResponse,
     DWORD cbOldLicense,
     PBYTE pbOldLicense,
     PDWORD pcbNewLicense,
     PBYTE* ppbNewLicense,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSUpgradeLicenseEx( 
     TLS_HANDLE hHandle,
     PDWORD pSupportFlags,
     LICENSEREQUEST *pRequest,
     CHALLENGE_CONTEXT ChallengeContext,
     DWORD cbChallengeResponse,
     PBYTE pbChallengeResponse,
     DWORD cbOldLicense,
     PBYTE pbOldLicense,
     DWORD dwQuantity,
     PDWORD pcbNewLicense,
     PBYTE* ppbNewLicense,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSAllocateConcurrentLicense( 
     TLS_HANDLE hHandle,
     LPTSTR pszHydraServer,
     LICENSEREQUEST* pRequest,
     LONG*  dwQuantity,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSGetLastError( 
     TLS_HANDLE hHandle,
     DWORD cbBufferSize,
     LPTSTR pszBuffer,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSKeyPackEnumBegin( 
     TLS_HANDLE hHandle,
     DWORD dwSearchParm,
     BOOL bMatchAll,
     LPLSKeyPackSearchParm lpSearchParm,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSKeyPackEnumNext( 
     TLS_HANDLE hHandle,
     LPLSKeyPack lpKeyPack,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSKeyPackEnumEnd( 
     TLS_HANDLE hHandle,
     PDWORD pdwErrCode
);


DWORD WINAPI 
TLSLicenseEnumBegin( 
     TLS_HANDLE hHandle,
     DWORD dwSearchParm,
     BOOL bMatchAll,
     LPLSLicenseSearchParm lpSearchParm,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSLicenseEnumNext( 
     TLS_HANDLE hHandle,
     LPLSLicense lpLicense,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSLicenseEnumNextEx( 
     TLS_HANDLE hHandle,
     LPLSLicenseEx lpLicense,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSLicenseEnumEnd( 
     TLS_HANDLE hHandle,
     PDWORD pdwErrCode
);


DWORD WINAPI 
TLSGetAvailableLicenses( 
     TLS_HANDLE hHandle,
     DWORD dwSearchParm,
     LPLSKeyPack lplsKeyPack,
     LPDWORD lpdwAvail,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSGetRevokeKeyPackList( 
     TLS_HANDLE hHandle,
     PDWORD pcbNumberOfRange,
     LPLSRange* ppRevokeRange,
     PDWORD pdwErrCode
);

DWORD WINAPI 
TLSGetRevokeLicenseList( 
     TLS_HANDLE hHandle,
     PDWORD pcbNumberOfRange,
     LPLSRange* ppRevokeRange,
     PDWORD pdwErrCode
);

LICENSE_STATUS
TLSGetTSCertificate(
    CERT_TYPE       CertType,
    LPBYTE          *ppbCertificate,
    LPDWORD         pcbCertificate);

LICENSE_STATUS
TLSFreeTSCertificate(
    LPBYTE          pbCertificate);

DWORD WINAPI
TLSInit();

DWORD WINAPI
TLSStartDiscovery();

DWORD WINAPI
TLSStopDiscovery();

void WINAPI
TLSShutdown();

DWORD WINAPI
TLSInDomain(
     BOOL *pfInDomain,
     LPWSTR *szDomain);

DWORD WINAPI
TLSMarkLicense(
    TLS_HANDLE hHandle,
    UCHAR ucFlags,
    DWORD cbLicense,
    PBYTE pLicense,
    PDWORD pdwErrCode
);

DWORD WINAPI
TLSCheckLicenseMark(
    TLS_HANDLE hHandle,
    DWORD cbLicense,
    PBYTE pLicense,
    PUCHAR pucFlags,
    PDWORD pdwErrCode
);

DWORD WINAPI
TLSGetSupportFlags(
    TLS_HANDLE hHandle,
    DWORD *pdwSupportFlags
);

DWORD WINAPI 
TLSGetServerNameEx( 
     TLS_HANDLE hHandle,
     LPTSTR pszMachineName,
     PDWORD pcbSize,
     PDWORD pdwErrCode
);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\inc\store.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       context.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-12-97  v-sbhatt   Created
//              12-18-97  v-sbhatt   Modified
//
//----------------------------------------------------------------------------


#ifndef _STORE_H_
#define _STORE_H_

#ifdef CALL_TYPE
#undef CALL_TYPE
#endif	//CALL_TYPE

#ifndef OS_WINCE
#define CALL_TYPE	_stdcall
#else
#define CALL_TYPE
#endif

#ifndef OUT
#define OUT
#endif	//OUT

#ifndef IN
#define IN
#endif	//IN

typedef DWORD LS_STATUS;

#define LSSTAT_SUCCESS					0x00
#define	LSSTAT_ERROR					0x01
#define LSSTAT_INSUFFICIENT_BUFFER		0x02
#define LSSTAT_LICENSE_NOT_FOUND		0x03
#define LSSTAT_OUT_OF_MEMORY			0x04
#define LSSTAT_INVALID_HANDLE			0x05
#define LSSTAT_LICENSE_EXISTS			0x06

//Adding or replacing flags, to be used in LSAddLicenseToStore

#define		LS_REPLACE_LICENSE_OK	0x00000001
#define		LS_REPLACE_LICENSE_ERR	0x00000000


//This is the License Store index structure. Licenses are queried against this index
typedef struct	tagLSINDEX
{
	DWORD		dwVersion;	//Uper two bytes major version and lower two bytes Minor version
	DWORD		cbScope;
	BYTE	FAR *pbScope;	//Scope for the license
	DWORD		cbCompany;
	BYTE	FAR *pbCompany;	//Manufacturer
	DWORD		cbProductID;
	BYTE	FAR *pbProductID;//Product ID of the product for which the License is intended to be
}LSINDEX, FAR * PLSINDEX;

#ifdef OS_WIN32
//Might not be necessay at all!!!!
typedef	LS_STATUS	(*PLSENUMPROC)(
								   IN HANDLE	hLicense,
								   IN PLSINDEX	plsiName,	//License Index Name
								   IN DWORD	dwUIParam	//User Parameter
								   );

#endif	//OS_WIN32

//Open a specified store. If the szStoreName is NULL, it will open default store
//Otherwise it will open the store specified by szStoreName parameter

LS_STATUS
CALL_TYPE
LSOpenLicenseStore(
				 OUT HANDLE			*hStore,	 //The handle of the store
				 IN  LPCTSTR		szStoreName, //Optional store Name
				 IN  BOOL 			fReadOnly    //whether to open read-only
				 );

//Closes an open store
LS_STATUS
CALL_TYPE
LSCloseLicenseStore(
				  IN HANDLE		hStore	//Handle of the store to be closed!
				  );

//Add or updates/replaces license against a given LSINDEX in an open store 
//pointed by hStore
LS_STATUS
CALL_TYPE
LSAddLicenseToStore(
					IN HANDLE		hStore,	//Handle of a open store
					IN DWORD		dwFlags,//Flags either add or replace
					IN PLSINDEX		plsiName,	//Index against which License is added 
					IN BYTE	 FAR   *pbLicenseInfo,	//License info to be added
					IN DWORD		cbLicenseInfo	// size of the License info blob
					);

//Deletes a license from the store refered by hStore and against the given LSINDEX
LS_STATUS
CALL_TYPE
LSDeleteLicenseFromStore(
						 IN HANDLE		hStore,	//Handle of a open store
						 IN PLSINDEX	plsiName	//Index of the license to be deleted
						 );

//Finds a license in an open store against a particular store Index
LS_STATUS
CALL_TYPE
LSFindLicenseInStore(
					 IN HANDLE		hStore,	//Handle of a open store
					 IN	PLSINDEX	plsiName,	//LSIndex against which store is searched
					 IN OUT	DWORD	FAR *pdwLicenseInfoLen,	//Size of the license found
					 OUT	BYTE	FAR *pbLicenseInfo	//License Data
					 );

LS_STATUS
CALL_TYPE
LSEnumLicenses(
			   IN HANDLE		hStore,	//Handle of a open store
			   IN	DWORD		dwIndex, //numeric Index of the license to query
			   OUT	PLSINDEX	plsindex //The LSIndex structure corresponding to dwIndex
			   );

LS_STATUS
CALL_TYPE
LSQueryInfoLicense(
				   IN HANDLE		hStore,	//Handle of a open store
				   OUT	DWORD	FAR *pdwLicenses, //Total no. of licenses available
				   OUT	DWORD	FAR *pdwMaxCompanyNameLen,	//Maximum length of the company length
				   OUT	DWORD	FAR *pdwMaxScopeLen,	//Maximum length of the company length
				   OUT	DWORD	FAR *pdwMaxProductIdLen	//Maximum length of the company length
				   );


LS_STATUS	
CALL_TYPE
LSOpenLicenseHandle(
				   IN HANDLE		hStore,	//Handle of a open store
				   IN  BOOL         fReadOnly,
				   IN  PLSINDEX		plsiName,
				   OUT HANDLE		*phStore	//Handle of a open store
				   );
LS_STATUS
CALL_TYPE
LSCloseLicenseHandle(
					 IN HANDLE		hStore,	//Handle of a open store
					 IN DWORD	dwFlags		//For future Use
					 );

#endif	//_STORE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\inc\lscsp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows Terminal Server
//  Copyright (C) Microsoft Corporation, 1989 - 1998.
//
//  File:       lscsp.h
//
//  Contents:   Header file for License Server CSP routine
//
//----------------------------------------------------------------------------

#ifndef __LSCSP__
#define __LSCSP__

#include "license.h"

//-----------------------------------------------------------------------------
//
// The types of CSP data that can be retrieved and stored
//
// LsCspInfo_Certificate - The proprietory certificate
// LsCspInfo_X509Certificate - The X509 certificate
// LsCspInfo_PublicKey - The public key in the proprietory certificate
// LsCspInfo_PrivateKey - The private key corresponding to the proprietory certificate
// LsCspInfo_X509CertPrivateKey - The private key corresponding to the X509 certificate
// LsCspInfo_X509CertID - The X509 certificate ID
//
//-----------------------------------------------------------------------------

typedef enum {
    
    LsCspInfo_Certificate,
    LsCspInfo_X509Certificate,
    LsCspInfo_PublicKey,
    LsCspInfo_PrivateKey,
    LsCspInfo_X509CertPrivateKey,
    LsCspInfo_X509CertID

} LSCSPINFO, FAR *LPLSCSPINFO;

//-----------------------------------------------------------------------------
//
// Terminal server registry keys and values
//
//-----------------------------------------------------------------------------

#define HYDRA_CERT_REG_KEY \
    "System\\CurrentControlSet\\Services\\TermService\\Parameters"

#define HYDRA_CERTIFICATE_VALUE "Certificate"
#define HYDRA_X509_CERTIFICATE  "X509 Certificate"
#define HYDRA_X509_CERT_ID      "X509 Certificate ID"

// L$ means only readable from the local machine

#define PUBLIC_KEY_NAME \
    L"L$HYDRAENCKEY_3a6c88f4-80a7-4b9e-971b-c81aeaa4f943"

#define PRIVATE_KEY_NAME \
    L"L$HYDRAENCKEY_28ada6da-d622-11d1-9cb9-00c04fb16e75"

#define X509_CERT_PRIVATE_KEY_NAME \
    L"L$HYDRAENCKEY_dd2d98db-2316-11d2-b414-00c04fa30cc4"

#define X509_CERT_PUBLIC_KEY_NAME   \
    L"L$HYDRAENCPUBLICKEY_dd2d98db-2316-11d2-b414-00c04fa30cc4"



//-----------------------------------------------------------------------------
//
// Function Prototypes
//
//-----------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

LICENSE_STATUS
LsCsp_GetServerData(
    LSCSPINFO   Info,
    LPBYTE      pBlob,
    LPDWORD     pdwBlobLen
    );

LICENSE_STATUS
LsCsp_SetServerData(
    LSCSPINFO   Info,
    LPBYTE      pBlob,
    DWORD       dwBlobLen 
    );

LICENSE_STATUS
LsCsp_NukeServerData(
    LSCSPINFO   Info );

BOOL
LsCsp_DecryptEnvelopedData(
    CERT_TYPE   CertType,
    LPBYTE      pbEnvelopeData,
    DWORD       cbEnvelopeData,
    LPBYTE      pbData,
    LPDWORD     pcbData
    );

BOOL
LsCsp_EncryptEnvelopedData(
    LPBYTE  pbData,
    DWORD   cbData,
    LPBYTE  pbEnvelopedData,
    LPDWORD pcbEnvelopedData);


LICENSE_STATUS
LsCsp_Initialize( void );


VOID 
LsCsp_Exit( void );


BOOL 
LsCsp_UseBuiltInCert( void );


LICENSE_STATUS
LsCsp_InstallX509Certificate( LPVOID lpParam );


LICENSE_STATUS
LsCsp_EncryptHwid(
    PHWID       pHwid,
    LPBYTE      pbEncryptedHwid,
    LPDWORD     pcbEncryptedHwid );


LICENSE_STATUS
LsCsp_StoreSecret(
    TCHAR * ptszKeyName,
    BYTE *  pbKey,
    DWORD   cbKey );


LICENSE_STATUS
LsCsp_RetrieveSecret(
    TCHAR *     ptszKeyName,
    PBYTE       pbKey,
    DWORD *     pcbKey );


#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\trace\adcg.h ===
/**INC+**********************************************************************/
/* Header:    adcg.h                                                        */
/*                                                                          */
/* Purpose:   Precompiled header file                                       */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/trc/adcg.h_v  $
// 
//    Rev 1.2   07 Jul 1997 14:56:56   AK
// SFR0000: Initial development completed
**/
/**INC-**********************************************************************/

#include <adcgbase.h>
#include <strsafe.h>
//Redirect win32 'W' calls to wrappers

#ifdef UNIWRAP
#include "uwrap.h"
#endif //UNIWRAP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\trace\atrcapi.c ===
/**MOD+**********************************************************************/
/* Module:    atrcapi.c                                                     */
/*                                                                          */
/* Purpose:   External tracing functions                                    */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1996-7                                */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/trc/atrcapi.c_v  $
 *
 *    Rev 1.12   22 Sep 1997 15:14:38   KH
 * SFR1293: Fix Zippy16 file write errors when zippy starts before Ducati
 *
 *    Rev 1.11   05 Sep 1997 10:34:54   SJ
 * SFR1334: Zippy enhancements
 *
 *    Rev 1.10   12 Aug 1997 09:45:28   MD
 * SFR1002: Remove kernel tracing code
 *
 *    Rev 1.9   04 Aug 1997 15:03:26   KH
 * SFR1022: Cast file name length on sprintf call
 *
 *    Rev 1.8   31 Jul 1997 19:39:30   SJ
 * SFR1041: Port zippy to Win16
 *
 *    Rev 1.7   16 Jul 1997 14:00:48   KH
 * SFR1022: ALL functions are DCEXPORT
 *
 *    Rev 1.6   11 Jul 1997 12:44:24   KH
 * SFR1022: Add DCEXPORT to TRC_GetBuffer
 *
 *    Rev 1.4   09 Jul 1997 17:59:12   AK
 * SFR1016: Initial changes to support Unicode
 *
 *    Rev 1.3   03 Jul 1997 13:27:24   AK
 * SFR0000: Initial development completed
**/
/**MOD-**********************************************************************/

/****************************************************************************/
/*                                                                          */
/* CONTENTS                                                                 */
/*                                                                          */
/* This file contains the DC-Groupware/NT tracing API.                      */
/*                                                                          */
/****************************************************************************/
/*                                                                          */
/* TRC_GetBuffer                                                            */
/* TRC_TraceBuffer                                                          */
/* TRC_GetConfig                                                            */
/* TRC_SetConfig                                                            */
/* TRC_TraceData                                                            */
/* TRC_GetTraceLevel                                                        */
/* TRC_ProfileTraceEnabled                                                  */
/* TRC_ResetTraceFiles                                                      */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* Standard includes.                                                       */
/****************************************************************************/
#include <adcg.h>

/****************************************************************************/
/* Define TRC_FILE and TRC_GROUP.                                           */
/****************************************************************************/
#define TRC_FILE    "atrcapi"
#define TRC_GROUP   TRC_GROUP_TRACE

/****************************************************************************/
/* Trace specific includes.                                                 */
/****************************************************************************/
#include <atrcapi.h>
#include <atrcint.h>

/****************************************************************************/
/*                                                                          */
/* DATA                                                                     */
/*                                                                          */
/****************************************************************************/
#define DC_INCLUDE_DATA
#include <atrcdata.c>
#undef DC_INCLUDE_DATA

/****************************************************************************/
/*                                                                          */
/* FUNCTIONS                                                                */
/*                                                                          */
/****************************************************************************/

/**PROC+*********************************************************************/
/* TRC_GetBuffer(...)                                                       */
/*                                                                          */
/* See atrcapi.h for description.                                           */
/**PROC-*********************************************************************/
PDCTCHAR DCAPI DCEXPORT TRC_GetBuffer(DCVOID)
{
    /************************************************************************/
    /* Get the mutex.  Note that we do not need to check that we are        */
    /* initialized in this function as this should have already been done.  */
    /************************************************************************/
    TRCGrabMutex();

    //
    // Ensure null termination
    //
    trcpOutputBuffer[TRC_LINE_BUFFER_SIZE*sizeof(TCHAR) -1] = 0;

    /************************************************************************/
    /* Return a pointer to the trace buffer in the shared data memory       */
    /* mapped file.                                                         */
    /************************************************************************/
    return(trcpOutputBuffer);

} /* TRC_GetBuffer */


/**PROC+*********************************************************************/
/* TRC_TraceBuffer(...)                                                     */
/*                                                                          */
/* See atrcapi.h for description.                                           */
/**PROC-*********************************************************************/
DCVOID DCAPI DCEXPORT TRC_TraceBuffer(DCUINT   traceLevel,
                                      DCUINT   traceComponent,
                                      DCUINT   lineNumber,
                                      PDCTCHAR funcName,
                                      PDCTCHAR fileName)
{
    DCTCHAR  fieldSeperator;
    DCTCHAR  frmtString[TRC_FRMT_BUFFER_SIZE] = {0};
    DCTCHAR  tempString[TRC_FRMT_BUFFER_SIZE] = {0};
    DCUINT32 processId;
    DCUINT32 threadId;
    DCUINT   length;
    DC_TIME  theTime;
    HRESULT  hr;

    /************************************************************************/
    /* First of all we need to decide if we are going to trace this line.   */
    /*                                                                      */
    /* Note that the decision to trace a line based on its level is taken   */
    /* in the TRACEX macro.                                                 */
    /************************************************************************/
    if (!TRCShouldTraceThis(traceComponent, traceLevel, fileName, lineNumber))
    {
        /********************************************************************/
        /* Don't bother tracing this line.                                  */
        /********************************************************************/
        DC_QUIT;
    }

    /************************************************************************/
    /* We need to trace this line.  First of all create the formatted       */
    /* output text string.  Determine the field seperator for the trace     */
    /* line.  Errors use a star (*), alerts a plus (+), asserts an          */
    /* exclamation mark (!) while normal and debug trace lines both use a   */
    /* space ( ).                                                           */
    /************************************************************************/
    switch(traceLevel)
    {
        case TRC_LEVEL_ASSERT:
        {
            fieldSeperator = '!';
        }
        break;

        case TRC_LEVEL_ERR:
        {
            fieldSeperator = '*';
        }
        break;

        case TRC_LEVEL_ALT:
        {
            fieldSeperator = '+';
        }
        break;

        case TRC_LEVEL_NRM:
        {
            fieldSeperator = ' ';
        }
        break;

        case TRC_LEVEL_DBG:
        {
            fieldSeperator = ' ';
        }
        break;

        case TRC_PROFILE_TRACE:
        {
            fieldSeperator = ' ';
        }
        break;

        default:
        {
            fieldSeperator = '?';
        }
        break;
    }

    /************************************************************************/
    /* Get the current process and thread Ids.                              */
    /************************************************************************/
    processId = TRCGetCurrentProcessId();
    threadId  = TRCGetCurrentThreadId();

    /************************************************************************/
    /* Build the string to be printed out.  First of all get the current    */
    /* time.                                                                */
    /************************************************************************/
    TRCGetCurrentTime(&theTime);

    /************************************************************************/
    /* Now format the string.  Note that the function name is of variable   */
    /* length and given by <trcpConfig->funcNameLength>.                    */
    /************************************************************************/

    /************************************************************************/
    /* Go through each optional field and decide whether to add it to the   */
    /* string or not.  They are:                                            */
    /* TRC_OPT_PROCESS_ID                                                   */
    /* TRC_OPT_THREAD_ID                                                    */
    /* TRC_OPT_TIME_STAMP                                                   */
    /* TRC_OPT_RELATIVE_TIME_STAMP                                          */
    /************************************************************************/
    if (TEST_FLAG(trcpConfig->flags, TRC_OPT_TIME_STAMP))
    {
        hr = StringCchPrintf(
            tempString,
            SIZE_TCHARS(tempString),
            TRC_TIME_FMT _T("%c"),
            theTime.hour,
            theTime.min,
            theTime.sec,
            theTime.hundredths,
            fieldSeperator
            );
        if (SUCCEEDED(hr)) {
            hr = StringCchCat(frmtString, SIZE_TCHARS(frmtString), tempString);
            if (FAILED(hr)) {
                DC_QUIT;
            }
        }
        else {
            DC_QUIT;
        }
    }

    if (TEST_FLAG(trcpConfig->flags, TRC_OPT_PROCESS_ID))
    {
        hr = StringCchPrintf(tempString,
                             SIZE_TCHARS(tempString),
                             TRC_PROC_FMT,
                             processId);
        if (SUCCEEDED(hr)) {
            hr = StringCchCat(frmtString, SIZE_TCHARS(frmtString), tempString);
            if (FAILED(hr)) {
                DC_QUIT;
            }
        }
        else {
            DC_QUIT;
        }
    }

#ifdef OS_WIN32
    if (TEST_FLAG(trcpConfig->flags, TRC_OPT_THREAD_ID))
    {
        /********************************************************************/
        /* Always put the colon before the thread ID so that, when only one */
        /* of the IDs is present, it is clear which it is.                  */
        /********************************************************************/
        hr = StringCchPrintf(tempString,
                             SIZE_TCHARS(tempString),
                             _T(":") TRC_THRD_FMT,
                             threadId);
        if (SUCCEEDED(hr)) {
            hr = StringCchCat(frmtString, SIZE_TCHARS(frmtString), tempString);
            if (FAILED(hr)) {
                DC_QUIT;
            }
        }
        else {
            DC_QUIT;
        }
    }
#endif

#ifdef DC_OMIT
    if (TEST_FLAG(trcpConfig->flags, TRC_OPT_RELATIVE_TIME_STAMP))
    {
        /********************************************************************/
        /* @@@ SJ - 090297                                                  */
        /* The idea is to show some low-order portion of the timestamp      */
        /* relative to the start time, in order to track timing issues.     */
        /********************************************************************/
    }
#endif

    hr = StringCchPrintf(tempString,
                         SIZE_TCHARS(tempString),
                         _T("%c") TRC_FUNC_FMT _T("%c") TRC_LINE_FMT _T("%c%s"),
                         fieldSeperator,
                         (DCINT)trcpConfig->funcNameLength,
                         (DCINT)trcpConfig->funcNameLength,
                         funcName,
                         fieldSeperator,
                         lineNumber,
                         fieldSeperator,
                         trcpOutputBuffer);
    if (SUCCEEDED(hr)) {
        hr = StringCchCat(frmtString, SIZE_TCHARS(frmtString), tempString);
        if (FAILED(hr)) {
            DC_QUIT;
        }
    }
    else {
        DC_QUIT;
    }

    /************************************************************************/
    /* Add CR:LF to the end and update the length of the string.            */
    /************************************************************************/
    hr = StringCchCat(frmtString, SIZE_TCHARS(frmtString), TRC_CRLF);
    if (FAILED(hr)) {
        DC_QUIT;
    }

    length = DC_TSTRLEN(frmtString) * sizeof(DCTCHAR);

    /************************************************************************/
    /* Now that we have got the trace string, we need to write it out.      */
    /************************************************************************/
    TRCOutput(frmtString, length, traceLevel);

    /************************************************************************/
    /* If this is an assert trace then we need to reformat the string for   */
    /* use in the assert box.  We must do this before we release the        */
    /* mutex.                                                               */
    /************************************************************************/
    hr = StringCchPrintf(frmtString,
                         SIZE_TCHARS(frmtString),
                         TRC_ASSERT_TEXT,
                         trcpOutputBuffer,
                         funcName,
                         fileName,
                         lineNumber);
    if (FAILED(hr)) {
        DC_QUIT;
    }

    /************************************************************************/
    /* Decide if we need to do a stack trace.  We must do this after        */
    /* reformating the string as we use the shared trace buffer - if we     */
    /* don't then we'll overwrite the original trace string!                */
    /************************************************************************/
    if ((traceLevel >= TRC_LEVEL_ERR) && (traceLevel != TRC_PROFILE_TRACE))
    {
        TRCStackTrace(traceLevel);
    }

DC_EXIT_POINT:

    /************************************************************************/
    /* Release the mutex.                                                   */
    /************************************************************************/
    TRCReleaseMutex();

    /************************************************************************/
    /* Now display the assert box - if an assert is already displayed then  */
    /* <TRCDisplayAssertBox> will just return.                              */
    /************************************************************************/
    if (TRC_LEVEL_ASSERT == traceLevel)
    {
        if (TEST_FLAG(trcpConfig->flags, TRC_OPT_BREAK_ON_ASSERT))
        {
            //
            // Break on assert so that we can actually get to see the assert
            // in situations like stress where the user may not be
            // watching for popups.
            //
            DebugBreak();
        }
        else
        {
            TRCDisplayAssertBox(frmtString);
        }
    }

    /************************************************************************/
    /* If this was an error level trace then we need to decide if we        */
    /* should beep, and then if we should break into the debugger.          */
    /************************************************************************/
    if (TRC_LEVEL_ERR == traceLevel)
    {
        /********************************************************************/
        /* Test if we should beep.                                          */
        /********************************************************************/
        if (TEST_FLAG(trcpConfig->flags, TRC_OPT_BEEP_ON_ERROR))
        {
            TRCBeep();
        }

        /********************************************************************/
        /* Test if we should break into the debugger.  Note that we have    */
        /* released the mutex, so other processes can continue to trace.    */
        /********************************************************************/
        if (TEST_FLAG(trcpConfig->flags, TRC_OPT_BREAK_ON_ERROR))
        {
            TRCDebugBreak();
        }
    }

} /* TRC_TraceBuffer */


/**PROC+*********************************************************************/
/* TRC_GetConfig(...)                                                       */
/*                                                                          */
/* See atrcapi.h for description.                                           */
/**PROC-*********************************************************************/
DCBOOL DCAPI DCEXPORT TRC_GetConfig(PTRC_CONFIG pTraceConfig,
                                    DCUINT length)
{
    DCBOOL rc                = TRUE;

    /************************************************************************/
    /* Check to ensure that the current state is valid.  If it is not then  */
    /* just quit.                                                           */
    /************************************************************************/
    if ( trcpConfig == NULL )
    {
        TRCOpenSharedData();
    }
    else
    {
        TRCReadSharedDataConfig();
    }

    /************************************************************************/
    /* Copy information from fixed structure to callers structure.          */
    /************************************************************************/
    DC_MEMCPY(pTraceConfig,
              trcpConfig,
              DC_MIN(length, sizeof(TRC_CONFIG)));

DC_EXIT_POINT:
    return(rc);

} /* TRC_GetConfig */


/**PROC+*********************************************************************/
/* TRC_SetConfig(...)                                                       */
/*                                                                          */
/* See atrcapi.h for description.                                           */
/**PROC-*********************************************************************/
DCBOOL DCAPI DCEXPORT TRC_SetConfig(PTRC_CONFIG pTraceConfig,
                                    DCUINT length)
{
    DCBOOL   rc              = TRUE;
    DCUINT   i;
    DCUINT32 maxFileSize;
    DCTCHAR  fileNames[TRC_NUM_FILES][TRC_FILE_NAME_SIZE];
    HRESULT  hr;

    /************************************************************************/
    /* Check to ensure that the current state is valid.  If it is not then  */
    /* just quit.                                                           */
    /************************************************************************/
    if ( trcpConfig == NULL )
    {
        TRCOpenSharedData();
    }
    else
    {
        TRCReadSharedDataConfig();
    }

    /************************************************************************/
    /* We do not support dynamic modification of the maximum trace file     */
    /* size or of the trace file names.  Therefore we store these before a  */
    /* change and overwrite the new values to ensure that they do not       */
    /* change.                                                              */
    /************************************************************************/
    maxFileSize = trcpConfig->maxFileSize;
    for (i = 0; i < TRC_NUM_FILES; i++)
    {
        StringCchCopy(fileNames[i], TRC_FILE_NAME_SIZE,
                      trcpConfig->fileNames[i]);
    }

    /************************************************************************/
    /* Copy information from fixed structure to callers structure.          */
    /************************************************************************/
    DC_MEMCPY(trcpConfig,
              pTraceConfig,
              DC_MIN(length, sizeof(TRC_CONFIG)));

    /************************************************************************/
    /* Now restore the maximum trace file size and the trace file names.    */
    /************************************************************************/
    trcpConfig->maxFileSize = maxFileSize;
    for (i = 0; i < TRC_NUM_FILES; i++)
    {
        StringCchCopy(trcpConfig->fileNames[i],
                      SIZE_TCHARS(trcpConfig->fileNames[i]),
                      fileNames[i]);
    }

    /************************************************************************/
    /* Split the prefix list.                                               */
    /************************************************************************/
    TRCSplitPrefixes();

    /************************************************************************/
    /* Store the new configuration data.                                    */
    /************************************************************************/
    TRCWriteSharedDataConfig();

DC_EXIT_POINT:
    return(rc);

} /* TRC_SetConfig */


/**PROC+*********************************************************************/
/* TRC_TraceData(...)                                                       */
/*                                                                          */
/* See atrcapi.h for description.                                           */
/**PROC-*********************************************************************/
DCVOID DCAPI DCEXPORT TRC_TraceData(DCUINT   traceLevel,
                                    DCUINT   traceComponent,
                                    DCUINT   lineNumber,
                                    PDCTCHAR funcName,
                                    PDCTCHAR fileName,
                                    PDCUINT8 buffer,
                                    DCUINT   bufLength)
{
    DCUINT i;

    /************************************************************************/
    /* If the trace checks fail then exit immediately.                      */
    /************************************************************************/
    if (!TRCShouldTraceThis(traceComponent, traceLevel, fileName, lineNumber))
    {
        /********************************************************************/
        /* Don't bother tracing this data.                                  */
        /********************************************************************/
        DC_QUIT;
    }

    /************************************************************************/
    /* Truncate the length, if necessary.                                   */
    /************************************************************************/
    if (bufLength > trcpConfig->dataTruncSize)
    {
        bufLength = (DCUINT)trcpConfig->dataTruncSize;
    }

    /************************************************************************/
    /* TRC_TraceBuffer will decrement the mutex usage count for us - so we  */
    /* need to pre-increment it before calling TRC_BufferTrace.  This       */
    /* ensures that we still have the mutex when we come to trace the data  */
    /* out.                                                                 */
    /************************************************************************/
    TRCGrabMutex();

    /************************************************************************/
    /* Now trace out the description string.                                */
    /************************************************************************/
    TRC_TraceBuffer(traceLevel,
                    traceComponent,
                    lineNumber,
                    funcName,
                    fileName);

    /************************************************************************/
    /* Now trace the data portion.                                          */
    /************************************************************************/
    for (i = 0; (i + 15) < bufLength; i += 16)
    {
        TRCDumpLine(buffer, 16, i, traceLevel);
        buffer += 16;
    }

    /************************************************************************/
    /* Check to see if we have a partial line to output.                    */
    /************************************************************************/
    if ((bufLength%16) > 0)
    {
        /********************************************************************/
        /* Do partial line last.                                            */
        /********************************************************************/
        TRCDumpLine(buffer, (bufLength%16), i, (DCUINT)traceLevel);
    }

DC_EXIT_POINT:

    /************************************************************************/
    /* Finally free the mutex.                                              */
    /************************************************************************/
    TRCReleaseMutex();

    return;

} /* TRC_TraceData */


/**PROC+*********************************************************************/
/* TRC_GetTraceLevel(...)                                                   */
/*                                                                          */
/* See atrcapi.h for description.                                           */
/**PROC-*********************************************************************/
DCUINT DCAPI DCEXPORT TRC_GetTraceLevel(DCVOID)
{
    DCUINT32 rc = TRC_LEVEL_DIS;

    /************************************************************************/
    /* Check to ensure that the current state is valid.  If it is not then  */
    /* just quit.                                                           */
    /************************************************************************/
    if (!TRCCheckState())
    {
        DC_QUIT;
    }

    /************************************************************************/
    /* Get the current trace level.                                         */
    /************************************************************************/
    rc = trcpConfig->traceLevel;

DC_EXIT_POINT:
    return((DCUINT)rc);

} /* TRC_GetTraceLevel */


/**PROC+*********************************************************************/
/* TRC_ProfileTraceEnabled                                                  */
/*                                                                          */
/* See atrcapi.h for description.                                           */
/**PROC-*********************************************************************/
DCBOOL DCAPI DCEXPORT TRC_ProfileTraceEnabled(DCVOID)
{
    DCBOOL prfTrace = FALSE;

    /************************************************************************/
    /* Check to ensure that the current state is valid.  If it is not then  */
    /* just quit.                                                           */
    /************************************************************************/
    if (!TRCCheckState())
    {
        DC_QUIT;
    }

    /************************************************************************/
    /* Get the setting of the flag and return TRUE if function profile      */
    /* tracing is supported.                                                */
    /************************************************************************/
    prfTrace = TEST_FLAG(trcpConfig->flags, TRC_OPT_PROFILE_TRACING);

DC_EXIT_POINT:
    return(prfTrace);

} /* TRC_ProfileTraceEnabled */


/**PROC+*********************************************************************/
/* TRC_ResetTraceFiles                                                      */
/*                                                                          */
/* See atrcapi.h for description.                                           */
/**PROC-*********************************************************************/
DCBOOL DCAPI DCEXPORT TRC_ResetTraceFiles(DCVOID)
{
    DCBOOL rc = TRUE;

    /************************************************************************/
    /* Check to ensure that the current state is valid.  If it is not then  */
    /* just quit.                                                           */
    /************************************************************************/
    if (!TRCCheckState())
    {
        rc = FALSE;
        DC_QUIT;
    }

    /************************************************************************/
    /* Grab the mutex.                                                      */
    /************************************************************************/
    TRCGrabMutex();

    /************************************************************************/
    /* Call the OS specific function to reset the trace files.              */
    /************************************************************************/
    TRCResetTraceFiles();

    /************************************************************************/
    /* Release the mutex.                                                   */
    /************************************************************************/
    TRCReleaseMutex();

DC_EXIT_POINT:
    return(rc);

} /* TRC_ResetTraceFiles */

//
// Sprintf that will take care of truncating to the trace buffer size
//
#ifndef TRC_SAFER_SPRINTF
#define TRC_SAFER_SPRINTF
VOID TRCSaferSprintf(PDCTCHAR outBuf, UINT cchLen, const PDCTCHAR format,...)
{
    HRESULT hr;
    va_list vaArgs;

    va_start(vaArgs, format);

    hr = StringCchVPrintf(outBuf,
                          cchLen,
                          format,
                          vaArgs);
    va_end(vaArgs);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\trace\atrcdata.c ===
/**MOD+**********************************************************************/
/* Module:    atrcdata.c                                                    */
/*                                                                          */
/* Purpose:   Internal trace data                                           */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/trc/atrcdata.c_v  $
 *
 *    Rev 1.5   09 Jul 1997 17:59:34   AK
 * SFR1016: Initial changes to support Unicode
 *
 *    Rev 1.4   07 Jul 1997 17:49:24   KH
 * SFR1022: Change trcState to DCUINT
 *
 *    Rev 1.3   03 Jul 1997 13:27:34   AK
 * SFR0000: Initial development completed
**/
/**MOD-**********************************************************************/

#include <adcg.h>

/****************************************************************************/
/* Define TRC_FILE and TRC_GROUP if this file is being compiled - but do    */
/* not define if it is being included.                                      */
/****************************************************************************/
#ifndef DC_INCLUDE_DATA
#define TRC_FILE    "atrcdata"
#define TRC_GROUP   TRC_GROUP_TRACE
#endif

/****************************************************************************/
/* Data header.                                                             */
/****************************************************************************/
#include <adcgdata.h>

/****************************************************************************/
/* Trace specific includes.                                                 */
/****************************************************************************/
#include <atrcapi.h>
#include <atrcint.h>

/****************************************************************************/
/* Pointers to shared data structures.                                      */
/****************************************************************************/
DC_DATA(PTRC_CONFIG,        trcpConfig,              0);
DC_DATA(PTRC_FILTER,        trcpFilter,              0);
DC_DATA(PDCTCHAR,           trcpOutputBuffer,        0);

/****************************************************************************/
/* Flag to indicate if tracing is fully initialized yet.                    */
/****************************************************************************/
DC_DATA(DCUINT,           trcState,            TRC_STATE_UNINITIALIZED);

/****************************************************************************/
/*                                                                          */
/* OPERATING SYSTEM SPECIFIC INCLUDES                                       */
/*                                                                          */
/****************************************************************************/
#include <wtrcdata.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\trace\atrcint.c ===
/****************************************************************************/
/* atrcint.c                                                                */
/*                                                                          */
/* Internal trace functions                                                 */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1998                             */
/****************************************************************************/

#include <adcg.h>
/****************************************************************************/
/* Define TRC_FILE and TRC_GROUP.                                           */
/****************************************************************************/
#define TRC_FILE    "atrcint"
#define TRC_GROUP   TRC_GROUP_TRACE

/****************************************************************************/
/* Common and trace specific includes.                                      */
/****************************************************************************/
#include <atrcapi.h>
#include <atrcint.h>

/****************************************************************************/
/*                                                                          */
/* DATA                                                                     */
/*                                                                          */
/****************************************************************************/
#define DC_INCLUDE_DATA
#include <atrcdata.c>
#undef DC_INCLUDE_DATA

/****************************************************************************/
/*                                                                          */
/* FUNCTIONS                                                                */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* FUNCTION: TRCCheckState(...)                                             */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function checks the current internal trace state.  It does the      */
/* following depending on the trace state:                                  */
/*                                                                          */
/* TRC_STATE_UNINITIALIZED : calls TRC_Initialize to initialize trace.  If  */
/*                           this succeeds it returns TRUE.                 */
/* TRC_STATE_INITIALIZED   : returns TRUE.                                  */
/* TRC_STATE_TERMINATED    : returns FALSE.                                 */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* See above.                                                               */
/*                                                                          */
/****************************************************************************/
DCBOOL32 DCINTERNAL TRCCheckState(DCVOID)
{
    DCBOOL32 rc              = FALSE;

    /************************************************************************/
    /* Now switch on the current trace state.                               */
    /************************************************************************/
    switch (trcState)
    {
        case TRC_STATE_UNINITIALIZED:
        {
            /****************************************************************/
            /* Trace is uninitialized so attempt to initialize it.          */
            /****************************************************************/
            rc = (0 == TRC_Initialize(FALSE));
        }
        break;

        case TRC_STATE_INITIALIZED:
        {
            /****************************************************************/
            /* Trace is initialized and tracing is permitted in this state  */
            /* so return TRUE.                                              */
            /****************************************************************/
            rc = TRUE;
        }
        break;

        case TRC_STATE_TERMINATED:
        {
            /****************************************************************/
            /* Trace has been terminated.  Tracing is no longer permitted   */
            /* so return FALSE.                                             */
            /****************************************************************/
            rc = FALSE;
        }
        break;

        default:
        {
            TRCDebugOutput(_T("Unknown trace state!\n"));
        }
        break;
    }

    return(rc);

} /* TRCCheckState */


/****************************************************************************/
/* FUNCTION: TRCDumpLine(...)                                               */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function takes a block of data and formats it into a string         */
/* containing raw hex plus ASCII equivalent data.                           */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* buffer        : the buffer to trace.                                     */
/* length        : the length.                                              */
/* offset        : the offset of the buffer.                                */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCDumpLine(PDCUINT8 buffer,
                              DCUINT   length,
                              DCUINT32 offset,
                              DCUINT   traceLevel)
{
    DCUINT   i, limDataSize;
    DCUINT   pos;
    TRC_LINE traceLine;
    HRESULT hr;

    /************************************************************************/
    /* Write the offset into the start of the TRC_LINE structure.           */
    /************************************************************************/
    hr = StringCchPrintf(traceLine.address,
                         SIZE_TCHARS(traceLine.address),
                         _T("    %05X "), offset);
    if (FAILED(hr)) {
        DC_QUIT;
    }

    /************************************************************************/
    /* Format the binary portion of the data.  First of all blank out the   */
    /* hexData portion of the TRC_LINE structure.                           */
    /************************************************************************/
    limDataSize = sizeof(traceLine.hexData) / sizeof(traceLine.hexData[0]);
    for (i = 0; i < limDataSize; i++) 
    {
        traceLine.hexData[i] = _T(' ');
    }

    /************************************************************************/
    /* Now write the data into the hexData block.  <pos> stores the current */
    /* position in the output buffer (which is an array of 36 characters).  */
    /* On each loop through we write two characters into the array (which   */
    /* represent one byte) and so we increment <pos> by 2 each time.        */
    /* However at the end of a block of eight characters we add an extra    */
    /* blank - thus we need to increment <pos> again.                       */
    /************************************************************************/
    pos = 0;
    for (i = 0; i < length; i++)
    {
        hr = StringCchPrintf(&(traceLine.hexData[pos]),
                             3, //we write 2 characters at most (+1 for null)
                             _T("%02X"),
                             (DCUINT8)*(buffer+i));
        if (FAILED(hr)) {
            DC_QUIT;
        }


        /********************************************************************/
        /* Increment character position by 2.                               */
        /********************************************************************/
        pos += 2;

        /********************************************************************/
        /* If this is the end of a group of four characters then add a      */
        /* spacing character.  We need to overwrite the terminating NULL    */
        /* written by DC_TSPRINTF.                                          */
        /********************************************************************/
        traceLine.hexData[pos] = _T(' ');
        if (0 == ((i + 1) % 4))
        {
            pos++;
        }
    }

    /************************************************************************/
    /* Copy in the binary data for display in ascii form. First of all      */ 
    /* blank out the asciiData portion of the TRC_LINE structure.           */
    /************************************************************************/
    limDataSize = sizeof(traceLine.asciiData) / sizeof(traceLine.asciiData[0]);
    for (i = 0; i < limDataSize; i++) 
    {
        traceLine.asciiData[i] = _T(' ');
    }
#ifdef UNICODE
    for (i = 0; i < length; i++)
    {
        traceLine.asciiData[i] = buffer[i];
    }
#else
    DC_MEMCPY(traceLine.asciiData, buffer, length);
#endif

    /************************************************************************/
    /* Now translate non-printable characters to '.'.                       */
    /************************************************************************/
    for (i = 0; i < length; i++)
    {
        if ((traceLine.asciiData[i] < 0x20) ||
            (traceLine.asciiData[i] > 0x7E))
        {
            traceLine.asciiData[i] = _T('.');
        }
    }

    /************************************************************************/
    /* Add the terminating newline.                                         */
    /************************************************************************/
    DC_MEMSET(traceLine.end, '\0', sizeof(traceLine.end));
    StringCchCopy(traceLine.end, SIZE_TCHARS(traceLine.end), TRC_CRLF);

    /************************************************************************/
    /* Finally trace this buffer out.                                       */
    /************************************************************************/
    TRCOutput((PDCTCHAR)&traceLine,
              DC_TSTRLEN((PDCTCHAR)&traceLine) * sizeof(DCTCHAR),
              traceLevel);

DC_EXIT_POINT:

    return;
} /* TRCDumpLine */


/****************************************************************************/
/* FUNCTION: TRCReadFlag(...)                                               */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function reads a flag setting from the configuration data.          */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* entryName     : the profile entry name.                                  */
/* flag          : the flag to set or clear.                                */
/* pSetting      : a pointer to the variable containing the flag.           */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCReadFlag(PDCTCHAR  entryName,
                              DCUINT32  flag,
                              PDCUINT32 pSetting)
{
    DCUINT   rc = 0;
    DCUINT32 entryValue;

    /************************************************************************/
    /* Test the flag and set entryValue to a boolean, rather than the       */
    /* entire flag array.                                                   */
    /************************************************************************/
    entryValue = (TEST_FLAG(*pSetting, flag) ? 1UL : 0UL);

    /************************************************************************/
    /* Call <TRCReadProfInt> to get the setting of an integer.              */
    /************************************************************************/
    rc = TRCReadProfInt(entryName, &entryValue);

    /************************************************************************/
    /* Check the return code - if it is non-zero then just leave this       */
    /* flag at its default setting.                                         */
    /************************************************************************/
    if (0 != rc)
    {
        DC_QUIT;
    }

    /************************************************************************/
    /* Now set or clear the flag depending on <value>.                      */
    /************************************************************************/
    if (0UL == entryValue)
    {
        CLEAR_FLAG(*pSetting, flag);
    }
    else
    {
        SET_FLAG(*pSetting, flag);
    }

DC_EXIT_POINT:
    return;

} /* TRCReadFlag */


/****************************************************************************/
/* FUNCTION: TRCSetDefaults(...)                                            */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function sets the trace defaults.                                   */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCSetDefaults(DCVOID)
{
    /************************************************************************/
    /* Set the default values for the trace configuration.  The subsequent  */
    /* calls to TRCReadProfInt will only modify the default value if the    */
    /* appropriate entry exists in the configuration data.                  */
    /*                                                                      */
    /* We set the following things:                                         */
    /*                                                                      */
    /* - trace level to Alert.                                              */
    /* - enable all component groups.                                       */
    /* - remove all prefixes.                                               */
    /* - set the maximum trace file size to the default value.              */
    /* - set the data truncation size to the default value.                 */
    /* - set the function name size to the default value.                   */
    /* - enable the beep and file flags.                                    */
    /* - set the first trace file name to TRC1.TXT                          */
    /* - set the second trace file name to TRC2.TXT                         */
    /* In Win32, additionally                                               */
    /* - set time stamp                                                     */
    /* - set process ID                                                     */
    /* - set thread ID                                                      */
    /*                                                                      */
    /************************************************************************/
    trcpConfig->traceLevel                 = TRC_DEFAULT_TRACE_LEVEL;
    trcpConfig->components                 = TRC_DEFAULT_COMPONENTS;
    trcpConfig->prefixList[0]              = TRC_DEFAULT_PREFIX_LIST;
    trcpConfig->maxFileSize                = TRC_DEFAULT_MAX_FILE_SIZE;
    trcpConfig->dataTruncSize              = TRC_DEFAULT_DATA_TRUNC_SIZE;
    trcpConfig->funcNameLength             = TRC_DEFAULT_FUNC_NAME_LENGTH;
    trcpConfig->flags                      = 0UL;

    SET_FLAG(trcpConfig->flags, TRC_DEFAULT_FLAGS);

    
    StringCchCopy(trcpConfig->fileNames[0],
                  SIZE_TCHARS(trcpConfig->fileNames[0]),
                  TRC_DEFAULT_FILE_NAME0);
    StringCchCopy(trcpConfig->fileNames[1],
                  SIZE_TCHARS(trcpConfig->fileNames[1]),
                  TRC_DEFAULT_FILE_NAME1);
    return;

} /* TRCSetDefaults */


/****************************************************************************/
/* FUNCTION: TRCReadSharedDataConfig(...)                                   */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function reads configuration data into the shared data area.        */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCReadSharedDataConfig(DCVOID)
{
    /************************************************************************/
    /* Call routine to set up trace defaults.                               */
    /************************************************************************/
    TRCSetDefaults();

    /************************************************************************/
    /* Determine the trace level.                                           */
    /************************************************************************/
    TRCReadProfInt(_T("TraceLevel"), &(trcpConfig->traceLevel));
    if (trcpConfig->traceLevel > TRC_LEVEL_DIS )
    {
        /********************************************************************/
        /* Bad trace level.  Set to default.                                */
        /********************************************************************/
        trcpConfig->traceLevel = TRC_DEFAULT_TRACE_LEVEL;
    }

    /************************************************************************/
    /* Determine the maximum size of each trace file.                       */
    /************************************************************************/
    TRCReadProfInt(_T("TraceFileSize"), &(trcpConfig->maxFileSize));
    if ((trcpConfig->maxFileSize < TRC_MIN_TRC_FILE_SIZE) ||
        (trcpConfig->maxFileSize > TRC_MAX_TRC_FILE_SIZE))
    {
        /********************************************************************/
        /* Trace file setting in registry/ini file is out of bounds.        */
        /********************************************************************/
        (trcpConfig->maxFileSize) = TRC_DEFAULT_MAX_FILE_SIZE;
    }

    /************************************************************************/
    /* Determine the data truncation size.                                  */
    /************************************************************************/
    TRCReadProfInt(_T("DataTruncSize"), &(trcpConfig->dataTruncSize));
    if ( trcpConfig->dataTruncSize > TRC_MAX_TRC_FILE_SIZE )
    {
        /********************************************************************/
        /* Data trunc size is out of bounds.                                */
        /********************************************************************/
        trcpConfig->dataTruncSize = TRC_DEFAULT_DATA_TRUNC_SIZE;
    }

    /************************************************************************/
    /* Determine the function name size.                                    */
    /************************************************************************/
    TRCReadProfInt(_T("FuncNameLength"), &(trcpConfig->funcNameLength));
    if ( trcpConfig->funcNameLength >
         (TRC_FRMT_BUFFER_SIZE - TRC_LINE_BUFFER_SIZE) )

    {
        /********************************************************************/
        /* Func name length is out of bounds.                               */
        /********************************************************************/
        trcpConfig->funcNameLength = TRC_DEFAULT_FUNC_NAME_LENGTH;
    }

    /************************************************************************/
    /* Read the prefix list in.  This is in the form <COMP>=L where <COMP>  */
    /* is the component name and L is the desired trace level.  For example */
    /* TRCAPI=2,TRCINT=0 enables alert level tracing for module TRCAPI and  */
    /* debug level tracing for module TRCINT.                               */
    /************************************************************************/
    TRCReadProfString(_T("Prefixes"),
                      trcpConfig->prefixList,
                      TRC_PREFIX_LIST_SIZE);

    /************************************************************************/
    /* Read in the trace file names.                                        */
    /************************************************************************/
    TRCReadProfString(_T("FileName1"),
                      trcpConfig->fileNames[0],
                      TRC_FILE_NAME_SIZE);
    TRCReadProfString(_T("FileName2"),
                      trcpConfig->fileNames[1],
                      TRC_FILE_NAME_SIZE);

    /************************************************************************/
    /* Component groups.                                                    */
    /************************************************************************/
    TRCReadFlag(_T("NETWORK"),  TRC_GROUP_NETWORK,   &trcpConfig->components);
    TRCReadFlag(_T("SECURITY"), TRC_GROUP_SECURITY,  &trcpConfig->components);
    TRCReadFlag(_T("CORE"),     TRC_GROUP_CORE,      &trcpConfig->components);
    TRCReadFlag(_T("UI"),       TRC_GROUP_UI,        &trcpConfig->components);
    TRCReadFlag(_T("UTILITIES"),TRC_GROUP_UTILITIES, &trcpConfig->components);

    /************************************************************************/
    /* The following groups should be permanently off, as they're disused.  */
    /************************************************************************/
#ifdef DC_OMIT
    TRCReadFlag(_T("UNUSED1"),  TRC_GROUP_UNUSED1,   &trcpConfig->components);
    TRCReadFlag(_T("UNUSED2"),  TRC_GROUP_UNUSED2,   &trcpConfig->components);
    TRCReadFlag(_T("UNUSED3"),  TRC_GROUP_UNUSED3,   &trcpConfig->components);
    TRCReadFlag(_T("UNUSED4"),  TRC_GROUP_UNUSED4,   &trcpConfig->components);
    TRCReadFlag(_T("UNUSED5"),  TRC_GROUP_UNUSED5,   &trcpConfig->components);
#endif

    /************************************************************************/
    /* @@@ SJ Aug 97                                                        */
    /* Remove this as the components become used.                           */
    /************************************************************************/
    CLEAR_FLAG(trcpConfig->components, TRC_GROUP_UNUSED1);
    CLEAR_FLAG(trcpConfig->components, TRC_GROUP_UNUSED2);
    CLEAR_FLAG(trcpConfig->components, TRC_GROUP_UNUSED3);
    CLEAR_FLAG(trcpConfig->components, TRC_GROUP_UNUSED4);
    CLEAR_FLAG(trcpConfig->components, TRC_GROUP_UNUSED5);

    /************************************************************************/
    /* Trace flags.                                                         */
    /************************************************************************/
    TRCReadFlag(_T("BreakOnError"), TRC_OPT_BREAK_ON_ERROR,  &trcpConfig->flags);
    TRCReadFlag(_T("BeepOnError"),  TRC_OPT_BEEP_ON_ERROR,   &trcpConfig->flags);
    TRCReadFlag(_T("FileOutput"),   TRC_OPT_FILE_OUTPUT,     &trcpConfig->flags);
    TRCReadFlag(_T("DebugOutput"),  TRC_OPT_DEBUGGER_OUTPUT, &trcpConfig->flags);
    TRCReadFlag(_T("FlushOnTrace"), TRC_OPT_FLUSH_ON_TRACE,  &trcpConfig->flags);
    TRCReadFlag(_T("ProfileTrace"), TRC_OPT_PROFILE_TRACING, &trcpConfig->flags);
    TRCReadFlag(_T("StackTracing"), TRC_OPT_STACK_TRACING,   &trcpConfig->flags);
    TRCReadFlag(_T("ProcessID"),    TRC_OPT_PROCESS_ID,      &trcpConfig->flags);
    TRCReadFlag(_T("ThreadID"),     TRC_OPT_THREAD_ID,       &trcpConfig->flags);
    TRCReadFlag(_T("TimeStamp"),    TRC_OPT_TIME_STAMP,      &trcpConfig->flags);
    TRCReadFlag(_T("BreakOnAssert"),TRC_OPT_BREAK_ON_ASSERT, &trcpConfig->flags);

#ifdef DC_OMIT
/****************************************************************************/
/* Not implemented yet.                                                     */
/****************************************************************************/
    TRCReadFlag(_T("RelativeTimeStamp"), TRC_OPT_RELATIVE_TIME_STAMP,
                                                          &trcpConfig->flags);
#endif

    return;

} /* TRCReadSharedDataConfig */


/****************************************************************************/
/* FUNCTION: TRCShouldTraceThis(...)                                        */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function decides whether this trace line should be traced based     */
/* on the currently selected components and prefixes.  Note that this       */
/* function is not called if the trace level of the line is lower than      */
/* the currently selected trace level.                                      */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* traceComponent : the component group producing this trace.               */
/* pFileName      : the name of the file producing this trace.              */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* TRUE if the line should be traced and FALSE otherwise.                   */
/*                                                                          */
/****************************************************************************/
DCBOOL DCINTERNAL TRCShouldTraceThis(DCUINT32 traceComponent,
                                     DCUINT32 traceLevel,
                                     PDCTCHAR pFileName,
                                     DCUINT32 lineNumber)
{
    DCBOOL   rc              = FALSE;
    PDCTCHAR pName;
    PDCTCHAR pTemp;
    DCUINT32 pfxLength;
    DCUINT   pfxArrayNum;
    DCUINT32 pfxTraceLevel;
    DCBOOL32 pfxFnTrcLevel;

    /************************************************************************/
    /* First of all check the trace level.  If the trace level is error or  */
    /* above then we trace regardless.                                      */
    /************************************************************************/
    if ((traceLevel >= TRC_LEVEL_ERR) && (traceLevel != TRC_PROFILE_TRACE))
    {
        rc = TRUE;
        DC_QUIT;
    }

    /************************************************************************/
    /* If this component is suppressed then just quit.                      */
    /************************************************************************/
    if (0 == (traceComponent & trcpConfig->components))
    {
        DC_QUIT;
    }

    /************************************************************************/
    /* If prefix checking requested then do it now.                         */
    /************************************************************************/
    if (_T('\0') == trcpConfig->prefixList[0])
    {
        /********************************************************************/
        /* The prefix list is empty so just quit.                           */
        /********************************************************************/
        rc = TRUE;
        DC_QUIT;
    }

    /************************************************************************/
    /* First we have to move past any explicit directory names in the file  */
    /* name.                                                                */
    /************************************************************************/
    pName = pFileName;
    pTemp = DC_TSTRCHR(pName, _T('\\'));
    while (NULL != pTemp)
    {
        pName = &(pTemp[1]);
        pTemp = DC_TSTRCHR(pName, _T('\\'));
    }

    /************************************************************************/
    /* We now have a pointer to the actual file prefix.  We need to compare */
    /* this with the list of prefixes that have been set (These have the    */
    /* format:                                                              */
    /*                                                                      */
    /* MODNAM=n,MODAPI=m,MODINT=o                                           */
    /*                                                                      */
    /* where MODNAM is the module name and m is the trace level).           */
    /*                                                                      */
    /* Set the prefix array number indicator <prefixArrayNumber> to 0 and   */
    /* null the temporary pointer.                                          */
    /************************************************************************/

    /************************************************************************/
    /* Try to find the current module name in the prefix list.              */
    /************************************************************************/
    for (pfxArrayNum = 0; pfxArrayNum < TRC_NUM_PREFIXES; pfxArrayNum++)
    {
        /********************************************************************/
        /* If the first character of the prefix name is a zero then ignore  */
        /* and break as we have reached the end of the prefix list.         */
        /********************************************************************/
        if (_T('\0') == trcpFilter->trcPfxNameArray[pfxArrayNum][0])
        {
            rc = FALSE;
            DC_QUIT;
        }

        /********************************************************************/
        /* Determine the length of the current prefix string.               */
        /********************************************************************/
        pfxLength = DC_TSTRLEN(trcpFilter->trcPfxNameArray[pfxArrayNum]);

        /********************************************************************/
        /* Now perform a case insensitive comparison between the prefix     */
        /* array and the file name.                                         */
        /********************************************************************/
        if (0 == TRCStrnicmp(pName,
                             trcpFilter->trcPfxNameArray[pfxArrayNum],
                             pfxLength))
        {
            /****************************************************************/
            /* If no line number range is specified or the line number of   */
            /* this piece of trace is within the range then consider it as  */
            /* a candidate for tracing out.                                 */
            /****************************************************************/
            if ((0 == trcpFilter->trcPfxStartArray[pfxArrayNum]) ||
                ((lineNumber < trcpFilter->trcPfxEndArray[pfxArrayNum]) &&
                 (lineNumber > trcpFilter->trcPfxStartArray[pfxArrayNum])))
            {
                /************************************************************/
                /* Now determine the prefix trace level.                    */
                /************************************************************/
                pfxTraceLevel = trcpFilter->trcPfxLevelArray[pfxArrayNum];
                pfxFnTrcLevel = trcpFilter->trcPfxFnLvlArray[pfxArrayNum];

                /************************************************************/
                /* Finally compare the trace level to the level specified   */
                /* in the prefix string.  If the statement trace level is   */
                /* lower than prefix level then we don't trace.             */
                /************************************************************/
                if (((traceLevel == TRC_PROFILE_TRACE) && pfxFnTrcLevel) ||
                    (traceLevel >= pfxTraceLevel))
                {
                    rc = TRUE;
                    DC_QUIT;
                }
            }
        }
    }

DC_EXIT_POINT:
    return(rc);

} /* TRCShouldTraceThis */


/****************************************************************************/
/* FUNCTION: TRCSplitPrefixes(...)                                          */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function takes a comma seperated array of prefixes and converts     */
/* them into an array.  Each member of this array is a seperate prefix.     */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCSplitPrefixes(DCVOID)
{
    PDCTCHAR pStart;
    PDCTCHAR pEnd;
    DCUINT   numChars;
    DCUINT   currentArrayNumber;
    DCUINT   i;
    DCUINT32 startLine;
    DCUINT32 endLine;

    /************************************************************************/
    /* First of all we blank out the old prefix name array.                 */
    /************************************************************************/
    DC_MEMSET(trcpFilter->trcPfxNameArray,
              '\0',
              sizeof(trcpFilter->trcPfxNameArray));

    /************************************************************************/
    /* Now blank out the old prefix level array.                            */
    /************************************************************************/
    for (i = 0; i < TRC_NUM_PREFIXES; i++)
    {
        trcpFilter->trcPfxLevelArray[i] = 0;
        trcpFilter->trcPfxFnLvlArray[i] = FALSE;
        trcpFilter->trcPfxStartArray[i] = 0;
        trcpFilter->trcPfxEndArray[i] = 0;
    }

    /************************************************************************/
    /* Set the current prefix array number to zero (i.e. ready to index the */
    /* first element of the prefix array).                                  */
    /************************************************************************/
    currentArrayNumber = 0;

    /************************************************************************/
    /* Split the prefix string into an array of seperate elements.          */
    /************************************************************************/
    pStart = trcpConfig->prefixList;

    /************************************************************************/
    /* Ignore any spaces at the start of the string.                        */
    /************************************************************************/
    while (_T(' ') == *pStart)
    {
        pStart++;
    }

    /************************************************************************/
    /* Now set <pEnd> to point to the same point as <pStart>.               */
    /************************************************************************/
    pEnd = pStart;

    while (_T('\0') != *pEnd)
    {
        /********************************************************************/
        /* Now run along the string looking for a comma, an equals sign,    */
        /* the end, a space or a bracket.                                   */
        /********************************************************************/
        while ((_T('\0') != *pEnd) &&
               (_T('=')  != *pEnd) &&
               (_T(' ')  != *pEnd) &&
               (_T('(')  != *pEnd) &&
               (_T(',')  != *pEnd))
        {
            pEnd = CharNext(pEnd);
        }

        /********************************************************************/
        /* We now have a valid string to write to the trace buffer so get   */
        /* its length.                                                      */
        /********************************************************************/
        numChars = (DCUINT)(pEnd - pStart);

        /********************************************************************/
        /* The maximum allowable length of the string is 7 characters (a 7  */
        /* character prefix).  If the length is greater than 7 characters   */
        /* then we truncate it.                                             */
        /********************************************************************/
        if (numChars > 7)
        {
            numChars = 7;
        }

        /********************************************************************/
        /* Now use <DC_MEMCPY> to copy the characters from the prefix       */
        /* string into the prefix array.  Note that as we zeroed the array  */
        /* out at the start we don't need to add a terminating NULL to the  */
        /* prefix array string.                                             */
        /********************************************************************/
        DC_MEMCPY(trcpFilter->trcPfxNameArray[currentArrayNumber],
                  pStart,
                  numChars * sizeof(TCHAR));

        /********************************************************************/
        /* Skip any spaces after this word, which may precede an '='.       */
        /********************************************************************/
        while (_T(' ') == *pEnd)
        {
            pEnd++;
        }

        /********************************************************************/
        /* Now split the trace level out and store it in the level array.   */
        /* If <pEnd> is currently pointing to an equals sign then we need   */
        /* to copy the trace level which follows to the level array.        */
        /* Otherwise we do nothing as the default level is set to           */
        /* TRC_LEVEL_DBG.                                                   */
        /********************************************************************/
        if (_T('=') == *pEnd)
        {
            /****************************************************************/
            /* Increment past the equals sign.                              */
            /****************************************************************/
            pEnd++;

            /****************************************************************/
            /* Skip any spaces after the '='.                               */
            /****************************************************************/
            while (_T(' ') == *pEnd)
            {
                pEnd++;
            }

            /****************************************************************/
            /* Check that we have not reached the end of the string or a    */
            /* comma.  This will happen if we have a prefix list such as    */
            /* 'trcint='.  In this case we just ignore the equals sign.     */
            /* Also check that the level specified is valid - otherwise     */
            /* ignore it.                                                   */
            /****************************************************************/
            if ((_T('\0') != *pEnd) &&
                (_T(',')  != *pEnd) &&
                (*pEnd >= TRC_LEVEL_MIN_CHAR) &&
                (*pEnd <= TRC_LEVEL_MAX_CHAR))
            {
                trcpFilter->trcPfxLevelArray[currentArrayNumber] =
                    (DCUINT32) (*pEnd - _T('0'));

                /************************************************************/
                /* Skip past the number.                                    */
                /************************************************************/
                pEnd++;
            }

            /****************************************************************/
            /* Check for a the function entry/exit trace flag.              */
            /****************************************************************/
            if (DC_TOUPPER(*pEnd) == TRC_LEVEL_PRF_CHAR)
            {
                trcpFilter->trcPfxFnLvlArray[currentArrayNumber] = TRUE;
                pEnd++;
            }
        }

        /********************************************************************/
        /* Skip any spaces after this word, which may precede an '('.       */
        /********************************************************************/
        while (_T(' ') == *pEnd)
        {
            pEnd++;
        }

        /********************************************************************/
        /* Now split out the (optional) line number range.                  */
        /*                                                                  */
        /* Syntax is (aaa-bbb), where aaa is the start line number and bbb  */
        /* is the end line number.                                          */
        /*                                                                  */
        /* Spaces are allowed - e.g.  ( aaa - bbb )                         */
        /********************************************************************/
        if (_T('(') == *pEnd)
        {
            pEnd++;                     /* skip past the open bracket       */
            startLine = 0;
            endLine = 0;

            /****************************************************************/
            /* Skip past blanks                                             */
            /****************************************************************/
            while (_T(' ') == *pEnd)
            {
                pEnd++;
            }

            /****************************************************************/
            /* Extract the start line number                                */
            /****************************************************************/
            while ((_T('0') <= *pEnd) &&
                   (_T('9') >= *pEnd))
            {
                startLine = (startLine * 10) + (*pEnd - _T('0'));
                pEnd++;
            }

            /****************************************************************/
            /* Look for the next delimiter: '-' or ')'                      */
            /****************************************************************/
            while ((_T('-') != *pEnd) &&
                   (_T(')') != *pEnd) &&
                   (_T('\0') != *pEnd))
            {
                pEnd = CharNext(pEnd);
            }

            /****************************************************************/
            /* Stop now if we've reached the end of the line                */
            /****************************************************************/
            if (_T('\0') == *pEnd)
            {
                TRCDebugOutput(_T("Unexpected end of line in prefixes"));
                DC_QUIT;
            }

            /****************************************************************/
            /* Extract the end line number (if any)                         */
            /****************************************************************/
            if (_T('-') == *pEnd)
            {
                pEnd++;                 /* skip past '-'                    */
                while (_T(' ') == *pEnd)
                {
                    pEnd++;
                }

                while ((_T('0') <= *pEnd) &&
                       (_T('9') >= *pEnd))
                {
                    endLine = (endLine * 10) + (*pEnd - _T('0'));
                    pEnd++;
                }

            }

            /****************************************************************/
            /* Look for the closing delimiter: ')'                          */
            /****************************************************************/
            while ((_T('\0') != *pEnd) &&
                   (_T(')') != *pEnd))
            {
                pEnd = CharNext(pEnd);
            }

            /****************************************************************/
            /* Stop now if we've reached the end of the line                */
            /****************************************************************/
            if (_T('\0') == *pEnd)
            {
                TRCDebugOutput(_T("Unexpected end of line in prefixes"));
                DC_QUIT;
            }

            pEnd++;                     /* Jump past close bracket          */

            /****************************************************************/
            /* Store the start and end line numbers if they make sense      */
            /****************************************************************/
            if (endLine > startLine)
            {
                trcpFilter->trcPfxStartArray[currentArrayNumber] = startLine;
                trcpFilter->trcPfxEndArray[currentArrayNumber] = endLine;

            }

        }

        /********************************************************************/
        /* Now increment the currentArrayNumber.                            */
        /********************************************************************/
        currentArrayNumber++;

        /********************************************************************/
        /* Check that we have not overrun the array.                        */
        /********************************************************************/
        if (currentArrayNumber >= TRC_NUM_PREFIXES)
        {
            /****************************************************************/
            /* We've overrun the prefix list - so send some trace to the    */
            /* debug console and then quit.                                 */
            /****************************************************************/
            TRCDebugOutput(_T("The prefix arrays are full!"));
            DC_QUIT;
        }

        /********************************************************************/
        /* If the character at the end of the string is a comma or a space  */
        /* then skip past it.                                               */
        /********************************************************************/
        while ((_T(',') == *pEnd) ||
               (_T(' ') == *pEnd))
        {
            pEnd++;
        }

        /********************************************************************/
        /* Set pStart to the same position as pEnd.                         */
        /********************************************************************/
        pStart = pEnd;
    }

    /************************************************************************/
    /* We're through so just return.                                        */
    /************************************************************************/
DC_EXIT_POINT:
    return;

} /* TRCSplitPrefixes */


/****************************************************************************/
/* FUNCTION: TRCStrnicmp(...)                                               */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* Code to implement a strnicmp (length-limited, case-insensitive string    */
/* comparison) because it is otherwise unavailable (see SFR0636).           */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* source  - source string                                                  */
/* target  - target string                                                  */
/* count   - maximum length to compare                                      */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* 0     - strings match up to specified point                              */
/* other - strings do not match up to specified point                       */
/*                                                                          */
/****************************************************************************/
DCINT32 DCINTERNAL TRCStrnicmp(PDCTCHAR pSource,
                               PDCTCHAR pTarget,
                               DCUINT32 count)
{
    DCUINT sourcechar;
    DCUINT targetchar;
    DCINT32 rc=0;

    if (count == 0)
    {
        DC_QUIT;
    }

    do
    {
        /********************************************************************/
        /* Make sure that we extend characters in an unsigned fashion.      */
        /********************************************************************/
        sourcechar = (DCUINT)(DCUINT8)*pSource++;
        targetchar = (DCUINT)(DCUINT8)*pTarget++;

        /********************************************************************/
        /* Convert to lower case if char is an upper case letter.           */
        /********************************************************************/
        if ( (sourcechar >= _T('A')) && (sourcechar <= _T('Z')) )
        {
            sourcechar += _T('a') - _T('A');
        }

        if ( (targetchar >= _T('A')) && (targetchar <= _T('Z')) )
        {
            targetchar += _T('a') - _T('A');
        }

    } while ( (0 != (--count)) && sourcechar && (sourcechar == targetchar) );

    rc = (DCINT32)(sourcechar - targetchar);

DC_EXIT_POINT:

    return(rc);

} /* TRCStrnicmp  */


/****************************************************************************/
/* FUNCTION: TRCWriteFlag(...)                                              */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function writes a configuration flag setting.                       */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* entryName    - the profile entry name.                                   */
/* flag         - the flag to set or clear.                                 */
/* pSetting     - a pointer to the variable containing the flag.            */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCWriteFlag(PDCTCHAR entryName,
                               DCUINT32 flag,
                               DCUINT32 setting)
{
    DCUINT32 entryValue      = 0;

    /************************************************************************/
    /* If the flag is set then change the entryValue to 1.                  */
    /************************************************************************/
    if (TEST_FLAG(setting, flag))
    {
        entryValue = 1;
    }

    /************************************************************************/
    /* Call <TRCWriteProfInt> to write the flag settin.                     */
    /************************************************************************/
    TRCWriteProfInt(entryName, &entryValue);

    return;

} /* TRCWriteFlag */


/****************************************************************************/
/* FUNCTION: TRCWriteSharedDataConfig(...)                                  */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function saves configuration data from the shared data area.        */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCWriteSharedDataConfig(DCVOID)
{
    /************************************************************************/
    /* Save the trace level.                                                */
    /************************************************************************/
    TRCWriteProfInt(_T("TraceLevel"), &(trcpConfig->traceLevel));

    /************************************************************************/
    /* Save the maximum size of each trace file.                            */
    /************************************************************************/
    TRCWriteProfInt(_T("TraceFileSize"), &(trcpConfig->maxFileSize));

    /************************************************************************/
    /* Save the data truncation size.                                       */
    /************************************************************************/
    TRCWriteProfInt(_T("DataTruncSize"), &(trcpConfig->dataTruncSize));

    /************************************************************************/
    /* Save the function name size.                                         */
    /************************************************************************/
    TRCWriteProfInt(_T("FuncNameLength"), &(trcpConfig->funcNameLength));

    /************************************************************************/
    /* Write the prefix list out.  This is in the form <COMP>=L where       */
    /* <COMP> is the component name and L is the desired trace level.  For  */
    /* example CMDATA=2,CMINT=0 enables alert level tracing for module      */
    /* CMDATA and debug level tracing for module CMINT.                     */
    /************************************************************************/
    TRCWriteProfString(_T("Prefixes"), trcpConfig->prefixList);

    /************************************************************************/
    /* Save the trace file names.                                           */
    /************************************************************************/
    TRCWriteProfString(_T("FileName1"), trcpConfig->fileNames[0]);
    TRCWriteProfString(_T("FileName2"), trcpConfig->fileNames[1]);

    /************************************************************************/
    /* Component groups.                                                    */
    /************************************************************************/
    TRCWriteFlag(_T("NETWORK"),  TRC_GROUP_NETWORK,   trcpConfig->components);
    TRCWriteFlag(_T("SECURITY"), TRC_GROUP_SECURITY,  trcpConfig->components);
    TRCWriteFlag(_T("CORE"),     TRC_GROUP_CORE,      trcpConfig->components);
    TRCWriteFlag(_T("UI"),       TRC_GROUP_UI,        trcpConfig->components);
    TRCWriteFlag(_T("UTILITIES"),TRC_GROUP_UTILITIES, trcpConfig->components);
#ifdef DC_OMIT
/****************************************************************************/
/* These groups are reserved.                                               */
/****************************************************************************/
    TRCWriteFlag(_T("UNUSED1"),  TRC_GROUP_UNUSED1,   trcpConfig->components);
    TRCWriteFlag(_T("UNUSED2"),  TRC_GROUP_UNUSED2,   trcpConfig->components);
    TRCWriteFlag(_T("UNUSED3"),  TRC_GROUP_UNUSED3,   trcpConfig->components);
    TRCWriteFlag(_T("UNUSED4"),  TRC_GROUP_UNUSED4,   trcpConfig->components);
    TRCWriteFlag(_T("UNUSED5"),  TRC_GROUP_UNUSED5,   trcpConfig->components);
#endif

    /************************************************************************/
    /* Trace flags.                                                         */
    /************************************************************************/
    TRCWriteFlag(_T("BreakOnError"), TRC_OPT_BREAK_ON_ERROR,  trcpConfig->flags);
    TRCWriteFlag(_T("BeepOnError"),  TRC_OPT_BEEP_ON_ERROR,   trcpConfig->flags);
    TRCWriteFlag(_T("FileOutput"),   TRC_OPT_FILE_OUTPUT,     trcpConfig->flags);
    TRCWriteFlag(_T("DebugOutput"),  TRC_OPT_DEBUGGER_OUTPUT, trcpConfig->flags);
    TRCWriteFlag(_T("FlushOnTrace"), TRC_OPT_FLUSH_ON_TRACE,  trcpConfig->flags);
    TRCWriteFlag(_T("ProfileTrace"), TRC_OPT_PROFILE_TRACING, trcpConfig->flags);
    TRCWriteFlag(_T("StackTracing"), TRC_OPT_STACK_TRACING,   trcpConfig->flags);
    TRCWriteFlag(_T("ProcessID"),    TRC_OPT_PROCESS_ID,      trcpConfig->flags);
    TRCWriteFlag(_T("ThreadID"),     TRC_OPT_THREAD_ID,       trcpConfig->flags);
    TRCWriteFlag(_T("TimeStamp"),    TRC_OPT_TIME_STAMP,      trcpConfig->flags);
    TRCWriteFlag(_T("BreakOnAssert"),TRC_OPT_BREAK_ON_ASSERT, trcpConfig->flags);

#ifdef DC_OMIT
/****************************************************************************/
/* Not implemented yet.                                                     */
/****************************************************************************/
    TRCWriteFlag(_T("RelativeTimeStamp"), TRC_OPT_RELATIVE_TIME_STAMP,
                                                          &trcpConfig->flags);
#endif

    return;

} /* TRCWriteSharedDataConfig */


/****************************************************************************/
/* FUNCTION: TRCCloseAllFiles(...)                                          */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* Closes all the trace memory mapped files.                                */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCCloseAllFiles(DCVOID)
{
    /************************************************************************/
    /* Close all the trace output files.  We close the one that the trace   */
    /* indicator is pointing at last - this is because we use the time      */
    /* stamp of the trace file to set the trace indicator at the start of   */
    /* day (we choose the most recent file).                                */
    /************************************************************************/
    TRCCloseSingleFile((trcpSharedData->trcIndicator + 1) % TRC_NUM_FILES, 0);

    /************************************************************************/
    /* Now close the other trace file.                                      */
    /************************************************************************/
    TRCCloseSingleFile(trcpSharedData->trcIndicator, 30);

    return;

} /* TRCCloseAllFiles */


/****************************************************************************/
/* FUNCTION: TRCOutput(...)                                                 */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function outputs the passed string to the trace file and/or the     */
/* debugger depending on the options selected.                              */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* pText         : a pointer to the string.                                 */
/* length        : the length of the string.                                */
/* traceLevel    : the trace level.                                         */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCOutput(PDCTCHAR pText,
                            DCINT    length,
                            DCINT    traceLevel)
{
    /************************************************************************/
    /* Decide if we should output to file.                                  */
    /************************************************************************/
    if (TEST_FLAG(trcpConfig->flags, TRC_OPT_FILE_OUTPUT))
    {
        TRCOutputToFile(pText, length, traceLevel);
    }

    /************************************************************************/
    /* Decide if we should output to the debugger.                          */
    /************************************************************************/
    if (TEST_FLAG(trcpConfig->flags, TRC_OPT_DEBUGGER_OUTPUT))
    {
        TRCDebugOutput(pText);
    }

    return;

} /* TRCOutput */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\inc\wincelic.h ===
/*++

Copyright (c) 1998-99  Microsoft Corporation

Module Name:

    wincelic.h

Abstract:


Author:

    Fred Chong (FredCh) 7/1/1998

Environment:

Notes:

--*/

#include <dbgapi.h>
#define assert(x) ASSERT(x)

#define MAX_COMPUTERNAME_LENGTH 15

#ifdef HARDCODED_USER_NAME

#define WBT_USER_NAME "Windows Term"
#define WBT_USER_NAME_LEN   (sizeof(WBT_USER_NAME))

#else

#include <winsock.h>
#include <license.h>
#include <cryptkey.h>

// Two hex characters for each byte, plus null terminator

#define HWID_STR_LEN (sizeof(HWID) * 2 + 1)

#define BAD_HARDCODED_NAME1 "WBT"
#define BAD_HARDCODED_NAME2 "WinCE"

#endif

static BOOL GetUserName(
  LPSTR lpBuffer,  // address of name buffer
  LPDWORD nSize     // address of size of name buffer
)
{

#ifdef HARDCODED_USER_NAME
    if (*nSize < WBT_USER_NAME_LEN) {
        *nSize = WBT_USER_NAME_LEN;
        return FALSE;
    }

    *nSize = WBT_USER_NAME_LEN;
    strcpy(lpBuffer, WBT_USER_NAME);

    return TRUE;

#else

    CHAR achHostName[MAX_PATH+1];
    BOOL fReturn = FALSE;
    HWID hwid;
    DWORD cchName;

    // get the host name of the device
    if (0 == gethostname( achHostName, sizeof(achHostName) ))
    {
        // Check for bad hardcoded values
        if ((0 == strcmp(achHostName,BAD_HARDCODED_NAME1))
            || (0 == strcmp(achHostName,BAD_HARDCODED_NAME2)))
        {
            goto use_uuid;
        }

        // gethostname success

        cchName = strlen(achHostName);

        if (*nSize <= cchName)
        {
            *nSize = (cchName + 1);
            return FALSE;
        }

        strcpy(lpBuffer,achHostName);
        return TRUE;
    }
    
use_uuid:

    // Can't get hostname

    if (*nSize >= HWID_STR_LEN)
    {
        // Use UUID instead

        if (LICENSE_STATUS_OK == GenerateClientHWID(&hwid))
        {
            
            sprintf(lpBuffer,
                    "%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x",
                    (hwid.dwPlatformID & 0xFF000000) >> 24,
                    (hwid.dwPlatformID & 0x00FF0000) >> 16,
                    (hwid.dwPlatformID & 0x0000FF00) >> 8,
                     hwid.dwPlatformID & 0x000000FF,
                    (hwid.Data1 & 0xFF000000) >> 24,
                    (hwid.Data1 & 0x00FF0000) >> 16,
                    (hwid.Data1 & 0x0000FF00) >> 8,
                     hwid.Data1 & 0x000000FF,
                    (hwid.Data2 & 0xFF000000) >> 24,
                    (hwid.Data2 & 0x00FF0000) >> 16,
                    (hwid.Data2 & 0x0000FF00) >> 8,
                     hwid.Data2 & 0x000000FF,
                    (hwid.Data3 & 0xFF000000) >> 24,
                    (hwid.Data3 & 0x00FF0000) >> 16,
                    (hwid.Data3 & 0x0000FF00) >> 8,
                     hwid.Data3 & 0x000000FF,
                    (hwid.Data4 & 0xFF000000) >> 24,
                    (hwid.Data4 & 0x00FF0000) >> 16,
                    (hwid.Data4 & 0x0000FF00) >> 8,
                     hwid.Data4 & 0x000000FF
                     );

            fReturn = TRUE;
        }
    }

    *nSize = HWID_STR_LEN;

    return fReturn;

#endif

}

#define GetComputerName GetUserName
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\inc\tlsdef.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        tlsdef.h
//
// Contents:    
//
// History:     12-09-97    HueiWang    Created
//
//---------------------------------------------------------------------------
#ifndef __TLSDEF_H__
#define __TLSDEF_H__

//---------------------------------------------------------------------------
// Xenroll specific 
//#define CERTIFICATE_CA_TYPE     1
//#define CERTITICATE_MF_TYPE     2
//#define CERTIFICATE_CH_TYPE     3

//#define CERTIFICATE_LEVEL_ROOT  0


//---------------------------------------------------------------------------
// KeyPack related code
//
#define LSKEYPACKTYPE_UNKNOWN       0x0
#define LSKEYPACKTYPE_RETAIL        0x1
#define LSKEYPACKTYPE_SELECT        0x2
#define LSKEYPACKTYPE_CONCURRENT    0x3
#define LSKEYPACKTYPE_TEMPORARY     0x4
#define LSKEYPACKTYPE_OPEN          0x5
#define LSKEYPACKTYPE_FREE          0x6

#define LSKEYPACKTYPE_FIRST         LSKEYPACKTYPE_UNKNOWN
#define LSKEYPACKTYPE_LAST          LSKEYPACKTYPE_FREE

#define LSKEYPACKSTATUS_UNKNOWN     0x0
#define LSKEYPACKSTATUS_ACTIVE      0x1
#define LSKEYPACKSTATUS_PENDING     0x2
#define LSKEYPACKSTATUS_RETURNED    0x3
#define LSKEYPACKSTATUS_REVOKED     0x4
#define LSKEYPACKSTATUS_TEMPORARY   0x5
#define LSKEYPACKSTATUS_OTHERS      0x6
#define LSKEYPACKSTATUS_ADD_LICENSE 0x7
#define LSKEYPACKSTATUS_REMOVE_LICENSE 0x8
#define LSKEYPACKSTATUS_ADD_DESC    0x9
#define LSKEYPACKSTATUS_REMOVE_DESC 0x10
#define LSKEYPACKSTATUS_FIRST       LSKEYPACKSTATUS_UNKNOWN
#define LSKEYPACKSTATUS_LAST        LSKEYPACKSTATUS_REMOVE_DESC

#define LSKEYPACKLICENSETYPE_UNKNOWN        0x0
#define LSKEYPACKLICENSETYPE_NEW            0x1
#define LSKEYPACKLICENSETYPE_UPGRADE        0x2
#define LSKEYPACKLICENSETYPE_COMPETITIVE    0x3
#define LSKEYPACKLICENSETYPE_TEMPORARY      0x4

#define LSKEYPACKLICENSETYPE_FIRST          LSKEYPACKLICENSETYPE_UNKNOWN
#define LSKEYPACKLICENSETYPE_LAST           LSKEYPACKLICENSETYPE_TEMPORARY

#define LSKEYPACKCHANNELOFPURCHASE_UNKNOWN  0x0      
#define LSKEYPACKCHANNELOFPURCHASE_OEM      0x1
#define LSKEYPACKCHANNELOFPURCHASE_RETAIL   0x2

#define LSKEYPACKCHANNELOFPURCHASE_FIRST    LSKEYPACKCHANNELOFPURCHASE_UNKNOWN
#define LSKEYPACKCHANNELOFPURCHASE_LAST     LSKEYPACKCHANNELOFPURCHASE_RETAIL

#define LSKEYPACKPRODUCTFLAG_UNKNOWN        0x0000

#define LSKEYPACKPLATFORMTYPE_UNKNOWN       0x0000
#define LSKEYPACKPLATFORMTYPE_FREE          0x0002
#define LSKEYPACKPLATFORMTYPE_OTHERS        0x00FF

#define LSLICENSE_STATUS_UNKNOWN            0x0
#define LSLICENSE_STATUS_TEMPORARY          0x1
#define LSLICENSE_STATUS_ACTIVE             0x2
#define LSLICENSE_STATUS_UPGRADED           0x3
#define LSLICENSE_STATUS_REVOKE             0x4
#define LSLICENSE_STATUS_PENDING            0x5
#define LSLICENSE_STATUS_CONCURRENT         0x6

#define LSLICENSE_STATUS_FIRST              LSLICENSE_STATUS_UNKNOWN
#define LSLICENSE_STATUS_LAST               LSLICENSE_STATUS_CONCURRENT

//---------------------------------------------------------------------------
/// Key Pack Search Parameters

// Basic KeyPack Search Parameter
#define LSKEYPACK_SEARCH_INFO_ALL           0x0000FFFF
#define LSKEYPACK_SEARCH_KEYPACKID          0x00000001
#define LSKEYPACK_SEARCH_KEYPACKTYPE        0x00000002
#define LSKEYPACK_SEARCH_PRODUCTID          0x00000004
#define LSKEYPACK_SEARCH_MAJORVERSION       0x00000008
#define LSKEYPACK_SEARCH_MINORVERSION       0x00000010
#define LSKEYPACK_SEARCH_PLATFORMTYPE       0x00000020
#define LSKEYPACK_SEARCH_LICENSETYPE        0x00000040
#define LSKEYPACK_SEARCH_LANGID             0x00000080
#define LSKEYPACK_SEARCH_COP                0x00000100
#define LSKEYPACK_SEARCH_BSERIALNUMBER      0x00000200
#define LSKEYPACK_SEARCH_TOTALLICENSES      0x00000400
#define LSKEYPACK_SEARCH_PRODUCTFLAGS       0x00000800
#define LSKEYPACK_SEARCH_COMPANYNAME        0x00001000
#define LSKEYPACK_SEARCH_PRODUCTNAME        0x00002000
#define LSKEYPACK_SEARCH_PRODUCTDESC        0x00004000
#define LSKEYPACK_SEARCH_DUPLICATE \
    (LSKEYPACK_SEARCH_KEYPACKID | LSKEYPACK_SEARCH_COMPANYNAME | \
     LSKEYPACK_SEARCH_PRODUCTID | LSKEYPACK_SEARCH_MAJORVERSION | \
     LSKEYPACK_SEARCH_MINORVERSION | LSKEYPACK_SEARCH_PLATFORMTYPE)

// Extended KeyPack Search Parameters
#define LSKEYPACK_EXSEARCH_ALL              0xFFFF0000
#define LSKEYPACK_EXSEARCH_DWINTERNAL       0x00010000
#define LSKEYPACK_EXSEARCH_KEYPACKSTATUS    0x00020000
#define LSKEYPACK_EXSEARCH_ACTIVATEDATE     0x00040000
#define LSKEYPACK_EXSEARCH_EXPIREDATE       0x00080000
#define LSKEYPACK_EXSEARCH_AVAILABLE        0x00100000
#define LSKEYPACK_EXSEARCH_ALLVERSION       0x10000000

#define LSKEYPACK_SEARCH_ALL (LSKEYPACK_SEARCH_INFO_ALL | LSKEYPACK_EXSEARCH_ALL)
#define LSKEYPACK_SEARCH_NONE               0x00000000

#define LSKEYPACK_SET_KEYPACKSTATUS         LSKEYPACK_EXSEARCH_KEYPACKSTATUS
#define LSKEYPACK_SET_ACTIVATEDATE          LSKEYPACK_EXSEARCH_ACTIVATEDATE
#define LSKEYPACK_SET_EXPIREDATE            LSKEYPACK_EXSEARCH_EXPIREDATE
#define LSKEYPACK_SET_AVAILABLE             LSKEYPACK_EXSEARCH_AVAILABLE
#define LSKEYPACK_SET_ALLSTATUS             (LSKEYPACK_SET_KEYPACKSTATUS | LSKEYPACK_SET_ACTIVATEDATE | LSKEYPACK_SET_EXPIREDATE)

//-----------------------------------------------------------------------------
// License Search parameters
//
#define LSLICENSE_SEARCH_LICENSEID          0x00000001
#define LSLICENSE_SEARCH_KEYPACKID          0x00000002
#define LSLICENSE_SEARCH_MACHINENAME        0x00000008
#define LSLICENSE_SEARCH_USERNAME           0x00000010
#define LSLICENSE_SEARCH_ISSUEDATE          0x00000080
#define LSLICENSE_SEARCH_EXPIREDATE         0x00000100
#define LSLICENSE_SEARCH_NUMLICENSES        0x00000200
#define LSLICENSE_SEARCH_ENTRY_STATUS       0x20000000
#define LSLICENSE_SEARCH_MARK_FLAGS         LSLICENSE_SEARCH_ENTRY_STATUS
#define LSLICENSE_EXSEARCH_LICENSESTATUS    0x00100000
#define LSLICENSE_SEARCH_ALL \
    (LSLICENSE_SEARCH_LICENSEID | LSLICENSE_SEARCH_KEYPACKID | \
     LSLICENSE_SEARCH_MACHINENAME | \
     LSLICENSE_SEARCH_USERNAME | \
     LSLICENSE_SEARCH_ISSUEDATE | LSLICENSE_SEARCH_NUMLICENSES | \
     LSLICENSE_SEARCH_EXPIREDATE | LSLICENSE_EXSEARCH_LICENSESTATUS | \
     LSLICENSE_SEARCH_ENTRY_STATUS)

#define LSLICENSE_SEARCH_NONE               0x00000000

//-----------------------------------------------------------------------------
// General Define
#define LSERVER_MAX_STRING_SIZE     255
#define GUID_MAX_SIZE               37

#define MAXCOMPUTERNAMELENGTH   32   // from MAX_COMPUTERNAME_LENGTH in winbase.h
#define MAXUSERNAMELENGTH       256  // UNLEN in lmcons.h 

// HueiWang - temporary, need to define this
#define HLS_MAX_SCOPE_NAME_LENGTH   MAX_COMPUTERNAME_LENGTH

//-------------------------------------------------------------
// Hydra License Server Return Code
#define LSERVER_S_SUCCESS               ERROR_SUCCESS
#define LSERVER_SUCCESS_BASE            4000
#define LSERVER_ERROR_BASE              5000

#define LSERVER_I_NO_MORE_DATA            (LSERVER_SUCCESS_BASE + 1)
#define LSERVER_I_PROXIMATE_LICENSE       (LSERVER_SUCCESS_BASE + 2)
#define LSERVER_I_TEMPORARY_LICENSE       (LSERVER_SUCCESS_BASE + 3)
#define LSERVER_I_LICENSE_UPGRADED        (LSERVER_SUCCESS_BASE + 4)
#define LSERVER_I_CERTIFICATE_OVERWRITE   (LSERVER_SUCCESS_BASE + 5)
#define LSERVER_I_REMOVE_TOOMANY          (LSERVER_SUCCESS_BASE + 6)
#define LSERVER_I_SELFSIGN_CERTIFICATE    (LSERVER_SUCCESS_BASE + 7)
#define LSERVER_I_NOT_LSERVER_CERTIFICATE (LSERVER_SUCCESS_BASE + 8)
#define LSERVER_I_TEMP_SELFSIGN_CERT      (LSERVER_SUCCESS_BASE + 9)
#define LSERVER_I_SERVICE_SHUTDOWN        (LSERVER_SUCCESS_BASE + 10)

#define LSERVER_E_INTERNAL_ERROR        (LSERVER_ERROR_BASE + 1)
#define LSERVER_E_ERROR_GENERAL         (LSERVER_ERROR_BASE + 2)
#define LSERVER_E_ACCESS_DENIED         (LSERVER_ERROR_BASE + 3)
#define LSERVER_E_DUPLICATE             (LSERVER_ERROR_BASE + 4)
#define LSERVER_E_INVALID_HANDLE        (LSERVER_ERROR_BASE + 5)
#define LSERVER_E_INVALID_SEQUENCE      (LSERVER_ERROR_BASE + 6)
#define LSERVER_E_SERVER_BUSY           (LSERVER_ERROR_BASE + 7)
#define LSERVER_E_OUTOFMEMORY           (LSERVER_ERROR_BASE + 8)
#define LSERVER_E_INVALID_DATA          (LSERVER_ERROR_BASE + 9)
#define LSERVER_E_DATANOTFOUND          (LSERVER_ERROR_BASE + 10)
#define LSERVER_E_NO_LICENSE            (LSERVER_ERROR_BASE + 11)
#define LSERVER_E_NO_PRODUCT            (LSERVER_ERROR_BASE + 12)
#define LSERVER_E_LICENSE_REJECTED      (LSERVER_ERROR_BASE + 13)
#define LSERVER_E_LICENSE_REVOKED       (LSERVER_ERROR_BASE + 14)
#define LSERVER_E_LICENSE_EXPIRED       (LSERVER_ERROR_BASE + 15)
#define LSERVER_E_CORRUPT_DATABASE      (LSERVER_ERROR_BASE + 16)
#define LSERVER_E_NOTSUPPORTED          (LSERVER_ERROR_BASE + 17)
#define LSERVER_E_INVALID_NT_VERSION    (LSERVER_ERROR_BASE + 18)
#define LSERVER_E_NOT_NTSERVER          (LSERVER_ERROR_BASE + 19)
#define LSERVER_E_LS_NOTPRESENT         (LSERVER_ERROR_BASE + 20)
#define LSERVER_E_LS_NOTRUNNING         (LSERVER_ERROR_BASE + 21)
#define LSERVER_E_NO_CERTIFICATE        (LSERVER_ERROR_BASE + 22)
#define LSERVER_E_NOT_LSCERTIFICATE     (LSERVER_ERROR_BASE + 23)
#define LSERVER_E_POLICYMODULEERROR     (LSERVER_ERROR_BASE + 24)   // error in policy module return data
#define LSERVER_E_INVALID_RETURN        (LSERVER_ERROR_BASE + 25)
#define LSERVER_E_INCOMPATIBLE          (LSERVER_ERROR_BASE + 26)
#define LSERVER_E_INVALID_SPK           (LSERVER_ERROR_BASE + 27)
#define LSERVER_E_INVALID_LKP           (LSERVER_ERROR_BASE + 28)
#define LSERVER_E_INVALID_SIGN          (LSERVER_ERROR_BASE + 29)
#define LSERVER_E_POLICYDENYREQUEST     (LSERVER_ERROR_BASE + 30)
#define LSERVER_E_NOPOLICYMODULE        (LSERVER_ERROR_BASE + 31)
#define ISPOLICYMODULECODE(x) (0x08000000 & x)

#define LSERVER_E_LASTERROR              LSERVER_E_NOPOLICYMODULE
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\license\inc\tlspol.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        tlspol.h
//
// Contents:    
//
// History:     08-26-98    HueiWang    Created
//
//---------------------------------------------------------------------------
#ifndef __TLSPOLICY_H__
#define __TLSPOLICY_H__
#include "tlsapi.h"

#ifndef WINAPI
#define WINAPI      __stdcall
#endif


//
// Return Code from Policy Module
//
typedef enum {
    POLICY_SUCCESS = 0,                 // Success in processing request.
    POLICY_ERROR,                       // Fail to process request.
    POLICY_NOT_SUPPORTED,               // Unsupported function.
    POLICY_CRITICAL_ERROR               // Critical error.
} POLICYSTATUS;

typedef HANDLE PMHANDLE;

//
// Request progress type
//
#define REQUEST_UPGRADE         1
#define REQUEST_NEW             2
#define REQUEST_KEYPACKTYPE     3
#define REQUEST_TEMPORARY       4
#define REQUEST_KEYPACKDESC     5
#define REQUEST_GENLICENSE      6
#define REQUEST_COMPLETE        7

//
// License Return Code
//
#define LICENSE_RETURN_ERROR        0       // Can't decide what to do
#define LICENSE_RETURN_DELETE       1       // delete the old license and return license to license pack
#define LICENSE_RETURN_KEEP         2       // keep the old license.

//
// Client request license type.
//
#define LICENSETYPE_LICENSE         1       // normal license type
#define LICENSETYPE_CONCURRENT      2       // concurrent license


//
// Keypack Registration.
//
#define REGISTER_PROGRESS_NEW                   1
#define REGISTER_PROGRESS_END                   2

typedef struct __PMREGISTERLKPDESC {
    LCID   Locale;                         // Description locale
    TCHAR  szProductName[LSERVER_MAX_STRING_SIZE+1];  // Product Name
    TCHAR  szProductDesc[LSERVER_MAX_STRING_SIZE+1];  // Product Desc.
} PMREGISTERLKPDESC, *PPMREGISTERLKPDESC, *LPPMREGISTERLKPDESC;

typedef enum {
    REGISTER_SOURCE_INTERNET = 1,           // Internet registration
    REGISTER_SOURCE_PHONE,                  // Phone registration
    REGISTER_SOURCE_DISK                    // Disk registration
} LICENSEPACKREGISTERSOURCE_TYPE;

typedef struct __PMREGISTERLICENSEPACK {
    LICENSEPACKREGISTERSOURCE_TYPE SourceType;  // type of registration source

    DWORD   dwKeyPackType;                  // Type of keypack
    DWORD   dwDistChannel;                  // distribution channel
    FILETIME IssueDate;                     // Issue Date
    FILETIME ActiveDate;                    // Active Date
    FILETIME ExpireDate;                    // Expiration Date
    DWORD   dwBeginSerialNum;               // Begin license serial number
    DWORD   dwQuantity;                     // Quantity of Licenses in KeyPack
    TCHAR   szProductId[LSERVER_MAX_STRING_SIZE+1]; // Product Code
    TCHAR   szCompanyName[LSERVER_MAX_STRING_SIZE+1]; // Company Name
    DWORD   dwProductVersion;               // Product Version
    DWORD   dwPlatformId;                   // Platform ID
    DWORD   dwLicenseType;                  // License Type
    DWORD   dwDescriptionCount;             // Number of Product Description 
    PPMREGISTERLKPDESC pDescription;          // Array of product description

    // KeyPackSerialNum is set only on internet
    GUID    KeypackSerialNum;               // KeyPack serial number

    // pbLKP is only set on PHONE
    PBYTE   pbLKP;                        
    DWORD   cbLKP;
} PMREGISTERLICENSEPACK, *PPMREGISTERLICENSEPACK, *LPPMREGISTERLICENSEPACK;

typedef struct __PMLSKEYPACK {
    FILETIME    IssueDate;
    FILETIME    ActiveDate;
    FILETIME    ExpireDate;
    LSKeyPack   keypack;
    DWORD       dwDescriptionCount;
    PPMREGISTERLKPDESC pDescription;
} PMLSKEYPACK, *PPMLSKEYPACK, *LPPMLSKEYPACK;

typedef struct __PMLICENSEREQUEST {
    DWORD dwLicenseType;    // License Type defined in tlsdef.h
    DWORD dwProductVersion;  // request product version.
    LPTSTR pszProductId;    // product product id.
    LPTSTR pszCompanyName;  // product company name.
    DWORD dwLanguageId;      // unused.
    DWORD dwPlatformId;     // request platform type.
    LPTSTR pszMachineName;  // client machine name.
    LPTSTR pszUserName;     // client user name.
    BOOL fTemporary;        // Whether the issued license must be temporary (can't be permanent)
    DWORD dwSupportFlags;   // Which new features are supported by TS
} PMLICENSEREQUEST, *PPMLICENSEREQUEST, *LPPMLICENSEREQUEST;

typedef struct __PMGENERATELICENSE {
    PPMLICENSEREQUEST pLicenseRequest; // return from REQUEST_NEW
    DWORD dwKeyPackType;          // License Pack Type
    DWORD dwKeyPackId;            // License Pack Id that license is allocated from
    DWORD dwKeyPackLicenseId;	    // License ID in the keypack.
    ULARGE_INTEGER ClientLicenseSerialNumber;  // License Serial Number.
    FILETIME ftNotBefore;
    FILETIME ftNotAfter;
} PMGENERATELICENSE, *PPMGENERATELICENSE, *LPPMGENERATELICENSE;

typedef struct __PMCERTEXTENSION {
    DWORD cbData;  // policy specific extension data
    PBYTE pbData;  // size of extension data
    FILETIME ftNotBefore; // license validity period
    FILETIME ftNotAfter;
} PMCERTEXTENSION, *PPMCERTEXTENSION, *LPPMCERTEXTENSION;

typedef struct __PMLICENSEDPRODUCT {
    PMLICENSEREQUEST LicensedProduct;    // licensed product
    PBYTE  pbData;      // policy specific extension data
    DWORD  cbData;      // size of extension data
    BOOL bTemporary;    // temporary license
    UCHAR ucMarked;     // mark flags, including whether user was authenticated
} PMLICENSEDPRODUCT, *PPMLICENSEDPRODUCT, *LPPMLICENSEDPRODUCT;

typedef struct __PMUPGRADEREQUEST {
    PBYTE pbOldLicense;
    DWORD cbOldLicense;
    DWORD dwNumProduct;                 // number of licensed product 
                                        //      contained in the client license
    PPMLICENSEDPRODUCT pProduct;        // array of licensed product in the client license
    PPMLICENSEREQUEST pUpgradeRequest;  // new license upgrade request
} PMUPGRADEREQUEST, *PPMUPGRADEREQUEST, *LPPMUPGRADEREQUEST;

typedef struct __PMKEYPACKDESCREQ {
    LPTSTR pszProductId;
    DWORD dwLangId;
    DWORD dwVersion;
} PMKEYPACKDESCREQ, *PPMKEYPACKDESCREQ, *LPPMKEYPACKDESCREQ;
 
typedef struct __PMKEYPACKDESC {
    TCHAR szCompanyName[LSERVER_MAX_STRING_SIZE+1];
    TCHAR szProductName[LSERVER_MAX_STRING_SIZE+1];
    TCHAR szProductDesc[LSERVER_MAX_STRING_SIZE+1];
} PMKEYPACKDESC, *PPMKEYPACKDESC, *LPPMKEYPACKDESC;

typedef struct __PMSupportedProduct {
    TCHAR szCHSetupCode[LSERVER_MAX_STRING_SIZE+1];
    TCHAR szTLSProductCode[LSERVER_MAX_STRING_SIZE+1];
} PMSUPPORTEDPRODUCT, *PPMSUPPORTEDPRODUCT, *LPPMSUPPORTEDPRODUCT;

typedef struct __PMLICENSETOBERETURN {
    DWORD dwQuantity;
    DWORD dwProductVersion;
    LPTSTR pszOrgProductId;
    LPTSTR pszCompanyName;
    LPTSTR pszProductId;
    LPTSTR pszUserName;
    LPTSTR pszMachineName;
    DWORD dwPlatformID;
    BOOL bTemp;
} PMLICENSETOBERETURN, *PPMLICENSETOBERETURN, *LPPMLICENSETOBERETURN;

#ifdef __cplusplus
class SE_Exception 
{
private:
    unsigned int nSE;
public:
    SE_Exception() {}
    SE_Exception(unsigned int n) : nSE(n) {}
    ~SE_Exception() {}

    //-------------------------------
    unsigned int 
    getSeNumber() 
    { 
        return nSE; 
    }
};
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Following API must be exported by policy module
//

POLICYSTATUS WINAPI
PMReturnLicense(
    PMHANDLE hClient,
    ULARGE_INTEGER* pLicenseSerialNumber,
    PPMLICENSETOBERETURN pLicenseTobeReturn,
    PDWORD pdwLicenseStatus,
    PDWORD pdwPolicyErrCode
);


POLICYSTATUS WINAPI
PMLicenseUpgrade(
    PMHANDLE hClient,
    DWORD dwProgressCode,
    PVOID pbProgressData,
    PVOID *ppbReturnData,
    PDWORD pdwPolicyErrCode
);

POLICYSTATUS WINAPI
PMLicenseRequest(
    PMHANDLE client,
    DWORD dwProgressCode, 
    PVOID pbProgressData, 
    PVOID* pbNewProgressData,
    PDWORD pdwPolicyErrCode
);

void WINAPI
PMTerminate();

POLICYSTATUS WINAPI
PMInitialize(
    DWORD dwLicenseServerVersion,    // HIWORD is major, LOWORD is minor
    LPCTSTR pszCompanyName,
    LPCTSTR pszProductFamilyCode,
    PDWORD pdwNumProduct,
    PMSUPPORTEDPRODUCT** ppszSupportedProduct,
    PDWORD pdwPolicyErrCode
);

POLICYSTATUS WINAPI
PMInitializeProduct(
    LPCTSTR pszCompanyName,
    LPCTSTR pszCHProductCode,
    LPCTSTR pszTLSProductCode,
    PDWORD pdwPolicyErrCode
);

POLICYSTATUS WINAPI
PMUnloadProduct(
    LPCTSTR pszCompanyName,
    LPCTSTR pszCHProductCode,
    LPCTSTR pszTLSProductCode,
    PDWORD pdwPolicyErrCode
);

POLICYSTATUS WINAPI
PMRegisterLicensePack(
    PMHANDLE client,
    DWORD dwProgressCode, 
    PVOID pbProgressData, 
    PVOID pbNewProgressData,
    PDWORD pdwPolicyErrCode
);    


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\trace\ntrcdata.c ===
/**MOD+**********************************************************************/
/* Module:    ntrcdata.c                                                    */
/*                                                                          */
/* Purpose:   Internal tracing data - Windows NT specific                   */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 *  $Log:   Y:/logs/trc/ntrcdata.c_v  $
 *
 *    Rev 1.2   03 Jul 1997 13:28:22   AK
 * SFR0000: Initial development completed
 *
 *    Rev 1.1   20 Jun 1997 10:40:38   KH
 * Win16Port: Contains 32 bit specifics only
**/
/**MOD-**********************************************************************/

/****************************************************************************/
/* The following data is only required for the Win32 tracing.               */
/****************************************************************************/
#ifdef DLL_DISP

/****************************************************************************/
/* The following data is required for the NT kernel tracing.                */
/****************************************************************************/
DC_DATA(DCUINT32,        trcLinesLost,     0);

DC_DATA(DCUINT32,        trcStorageUsed,   0);

DC_DATA_NULL(TRC_SHARED_DATA, trcSharedData,    {0});

#else

/****************************************************************************/
/* For Windows CE, do not use shared memory for trace configuration data    */
/****************************************************************************/
#ifdef OS_WINCE
DC_DATA_NULL(TRC_SHARED_DATA, trcSharedData,    {0});
#endif

/****************************************************************************/
/* Handle to the trace DLL shared data.                                     */
/****************************************************************************/
DC_DATA(HANDLE,             trchSharedDataObject,    0);

/****************************************************************************/
/* Trace file handle array.                                                 */
/****************************************************************************/
DC_DATA_ARRAY_NULL(HANDLE,  trchFileObjects,    TRC_NUM_FILES, DC_STRUCT1(0));
DC_DATA_ARRAY_NULL(HANDLE,  trchMappingObjects, TRC_NUM_FILES, DC_STRUCT1(0));

/****************************************************************************/
/* Trace DLL module handle.                                                 */
/****************************************************************************/
DC_DATA(HANDLE, trchModule, 0);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\trace\trc.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    trc.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Madan Appiah - Sep. 5th 1997

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

DLLDEF=..\trc.def
DLLENTRY = _DllMainCRTStartup

#
# List of sources
#

CLIENT_SOURCES_RC = \
    ..\wtrc.rc

CLIENT_SOURCES_COMMON = \
    ..\atrcapi.c  \
    ..\atrcdata.c \
    ..\atrcint.c  \
    ..\wtrcapi.c

CLIENT_SOURCES_LAST = \
    ..\wtrcint.c

SOURCES = \
    $(CLIENT_SOURCES_COMMON) \
    $(CLIENT_SOURCES_RC) \
    $(CLIENT_SOURCES_LAST)

#
# Precompiled specs
#

PRECOMPILED_INCLUDE = ..\adcg.h
PRECOMPILED_PCH = adcg.pch
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\trace\ntrcint.c ===
/****************************************************************************/
/* ntrcint.c                                                                */
/*                                                                          */
/* Internal tracing functions - Windows NT specific                         */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997-1998                             */
/****************************************************************************/

#include <adcg.h>

/****************************************************************************/
/* Define TRC_FILE and TRC_GROUP.                                           */
/****************************************************************************/
#undef TRC_FILE
#define TRC_FILE    "ntrcint"
#define TRC_GROUP   TRC_GROUP_TRACE

/****************************************************************************/
/* Trace specific includes.                                                 */
/****************************************************************************/
#include <atrcapi.h>
#include <atrcint.h>
#ifndef OS_WINCE
#include <imagehlp.h>
#endif

#include <ndcgver.h>

/****************************************************************************/
/*                                                                          */
/* DATA                                                                     */
/*                                                                          */
/****************************************************************************/
#define DC_INCLUDE_DATA
#include <atrcdata.c>
#undef DC_INCLUDE_DATA

/****************************************************************************/
/*                                                                          */
/* FUNCTIONS                                                                */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* FUNCTION: DllMain(...)                                                   */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* Entry/exit point for the trace DLL.  This function is called whenever a  */
/* process or thread attaches or detaches from this DLL.                    */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* hModule         : a module handle.                                       */
/* reasonForCall   : an enumerated type that indicates which of the four    */
/*                   reasons the DLLMain function is being called: process  */
/*                   attach, thread attach, thread detach or process        */
/*                   detach.                                                */
/* lpReserved      : unused.                                                */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* TRUE if the attachment succeeds and FALSE otherwise.                     */
/*                                                                          */
/****************************************************************************/
#ifndef STATICONLY
int APIENTRY DllMain(HANDLE hModule,
                     DWORD  reasonForCall,
                     LPVOID lpReserved)
{
    DCBOOL  retValue         = TRUE;
    DCUINT  rc               = 0;

    DC_IGNORE_PARAMETER(lpReserved);
#ifdef OS_WINCE
    DC_IGNORE_PARAMETER(hModule);
#endif // OS_WINCE

    /************************************************************************/
    /* Determine the reason for the call.  Note that anything we do in here */
    /* is thread safe as we implicitly have the process critical section.   */
    /************************************************************************/

    switch (reasonForCall)
    {
#ifndef OS_WINCE
        /********************************************************************/
        /* A process is attaching to this DLL.                              */
        /********************************************************************/
        case DLL_PROCESS_ATTACH:
        {
            /****************************************************************/
            /* Call the internal function to initialize the trace DLL.      */
            /* This function sets up the memory mapped shared data, and     */
            /* opens and initializes the trace files.  It may be called     */
            /* either via a process attach or by the first person to call   */
            /* the trace DLL.  The latter case can only occur if another    */
            /* DLL performs trace calls in its <DllMain> function and that  */
            /* DLLs <DllMain> function is called before the trace DLLs      */
            /* <DllMain> function (i.e. this function!).                    */
            /****************************************************************/
            rc = TRC_Initialize(TRUE);

            if (0 != rc)
            {
                retValue = FALSE;
                DC_QUIT;
            }

            /****************************************************************/
            /* Save the module handle.                                      */
            /****************************************************************/
            trchModule = hModule;

            /****************************************************************/
            /* Get the trace DLL module file name.  We use this later when  */
            /* we get a stack trace.                                        */
            /****************************************************************/
            if ( TRCGetModuleFileName(
                        trcpSharedData->trcpModuleFileName,
                        SIZE_TCHARS(trcpSharedData->trcpModuleFileName)) !=
                        DC_RC_OK )
            {
                retValue = FALSE;
                DC_QUIT;
            }

            /****************************************************************/
            /* A process is attaching so trace this fact out.               */
            /****************************************************************/
            TRCInternalTrace(TRC_PROCESS_ATTACH_NOTIFY);
        }
        break;

        /********************************************************************/
        /* A process is detaching from this DLL.                            */
        /********************************************************************/
        case DLL_PROCESS_DETACH:
        {
            /****************************************************************/
            /* Write out the process detach trace line.                     */
            /****************************************************************/
            TRCInternalTrace(TRC_PROCESS_DETACH_NOTIFY);

            /****************************************************************/
            /* Call the trace DLL termination function.  This will close    */
            /* all files, free the shared data and then close the mutex     */
            /* handle.                                                      */
            /****************************************************************/
            TRC_Terminate(TRUE);
        }
        break;

        /********************************************************************/
        /* A thread is attaching to this DLL.                               */
        /********************************************************************/
        case DLL_THREAD_ATTACH:
        {
            /****************************************************************/
            /* Write out the thread attach trace line.                      */
            /****************************************************************/
            TRCInternalTrace(TRC_THREAD_ATTACH_NOTIFY);
        }
        break;

        /********************************************************************/
        /* A thread is detaching from this DLL.                             */
        /********************************************************************/
        case DLL_THREAD_DETACH:
        {
            /****************************************************************/
            /* Write out the thread detach trace line.                      */
            /****************************************************************/
            TRCInternalTrace(TRC_THREAD_DETACH_NOTIFY);
        }
        break;
#endif // OS_WINCE
    }

    /************************************************************************/
    /* Now return the appropriate return value.  NT currently only checks   */
    /* the value for the DLL_PROCESS_ATTACH case - if it is false then the  */
    /* app will fail to initialize.                                         */
    /************************************************************************/
DC_EXIT_POINT:
    return(retValue);

} /* DllMain */
#endif


/****************************************************************************/
/* FUNCTION: TRCBlankFile(...)                                              */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function fills the specified trace file with spaces.                */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* fileNumber      : which file to blank.                                   */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCBlankFile(DCUINT fileNumber)
{
    /************************************************************************/
    /* Use DC_MEMSET to fill the file with spaces.                          */
    /************************************************************************/
    DC_MEMSET(trcpFiles[fileNumber], '\0', trcpConfig->maxFileSize);

    /************************************************************************/
    /* Finally flush this change to disk.  Setting the second parameter to  */
    /* zero flushes the whole file to disk.                                 */
    /************************************************************************/
    FlushViewOfFile(trcpFiles[fileNumber], 0);

    return;

} /* TRC_BlankFile */


/****************************************************************************/
/* FUNCTION: TRCCloseSharedData(...)                                        */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function closes the shared data memory mapped file.                 */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCCloseSharedData(DCVOID)
{
    /************************************************************************/
    /* Now we need to unmap our view of the file.                           */
    /************************************************************************/
    UnmapViewOfFile(trcpSharedData);
    trcpSharedData = NULL;

    /************************************************************************/
    /* Now close the handle to the file mapping object.                     */
    /************************************************************************/
    CloseHandle(trchSharedDataObject);
    trchSharedDataObject = NULL;

    /************************************************************************/
    /* NULL our static pointer to the shared configuration data.            */
    /************************************************************************/
    trcpConfig = NULL;

    /************************************************************************/
    /* That's it so just return.                                            */
    /************************************************************************/
    return;

} /* TRCCloseSharedData */


/****************************************************************************/
/* FUNCTION: TRCCloseSingleFile(...)                                        */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* Closes a single trace memory mapped file.                                */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* fileNumber    : which file to close.                                     */
/* seconds       : value to set the seconds time stamp of the file to.      */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCCloseSingleFile(DCUINT fileNumber, DCUINT seconds)
{
    FILETIME   fileTime;
    SYSTEMTIME systemTime;
    DCUINT32   offset;

    /************************************************************************/
    /* We need to reset the size of this file - we do this by determining   */
    /* the trace file offset.  Make sure that we do this before we unmap    */
    /* the file.                                                            */
    /************************************************************************/
    offset = TRCDetermineOffset(fileNumber);

    /************************************************************************/
    /* Unmap the view of the file.                                          */
    /************************************************************************/
    UnmapViewOfFile(trcpFiles[fileNumber]);
    trcpFiles[fileNumber] = NULL;

    /************************************************************************/
    /* Free up the handle to the file mapping object.                       */
    /************************************************************************/
    CloseHandle(trchMappingObjects[fileNumber]);
    trchMappingObjects[fileNumber] = NULL;

    /************************************************************************/
    /* Now set the file pointer to the end of all the trace text and then   */
    /* set the end of the file to this position.                            */
    /************************************************************************/
    SetFilePointer(trchFileObjects[fileNumber],
                   offset,
                   NULL,
                   FILE_BEGIN);

    SetEndOfFile(trchFileObjects[fileNumber]);

    /************************************************************************/
    /* Now we have to do something a little messy - the file time is not    */
    /* properly updated when the memory mapped file is closed and we rely   */
    /* on the file time to decide which file to start tracing to at the     */
    /* start of day.  Therefore we need to force the system to update the   */
    /* file times using SetFileTime (we set the created, modified and       */
    /* accessed times).  On NT4.0 this does not guarantee that the times    */
    /* are the same - one file had a created time of 16:35:16 and a         */
    /* modified time of 16:35:18 after a call to SetFileTime!  Files only   */
    /* have a time resolution of two seconds if they are stored on a FAT    */
    /* partition by NT.                                                     */
    /************************************************************************/
    GetSystemTime(&systemTime);

    /************************************************************************/
    /* Set the number of seconds of the file.                               */
    /************************************************************************/
    systemTime.wSecond = (WORD) seconds;

    /************************************************************************/
    /* Now convert the system time to a file time and update the file time. */
    /************************************************************************/
    SystemTimeToFileTime(&systemTime, &fileTime);
    SetFileTime(trchFileObjects[fileNumber], &fileTime, &fileTime, &fileTime);

    /************************************************************************/
    /* Close the file handle.                                               */
    /************************************************************************/
    CloseHandle(trchFileObjects[fileNumber]);
    trchFileObjects[fileNumber] = NULL;

    return;

} /* TRCCloseSingleFile */


/****************************************************************************/
/* FUNCTION: TRCDetermineIndicator(...)                                     */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function sets the trace file indicator as follows:                  */
/*                                                                          */
/* - No trace files exist    : indicator set to 0                           */
/* - One trace file exists   : indicator set to the existing file (0 or 1)  */
/* - Both trace files exist  : indicator set to the newer file.             */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCDetermineIndicator(DCVOID)
{
    DCINT    i;
    DCBOOL   rc[TRC_NUM_FILES];
    DCINT32  tdRC;
    FILETIME fileTime[TRC_NUM_FILES];

    /************************************************************************/
    /* We also need to set up the trace file indicator.  By default we use  */
    /* trace file 0.                                                        */
    /************************************************************************/
    trcpSharedData->trcIndicator = 0;

    /************************************************************************/
    /* Determine the most recent trace file.  Use GetFileTime to get the    */
    /* date and time of this file.                                          */
    /************************************************************************/
    for (i = 0; i < TRC_NUM_FILES; i++)
    {
        rc[i] = TRCGetFileTime(i, &(fileTime[i]));
    }

    /************************************************************************/
    /* Now check to see which file we should return based on the following  */
    /* options:                                                             */
    /*                                                                      */
    /*                         */
    /*  File 0 exists   File 1 exists   return                          */
    /*                         */
    /*      No              No          file 0                          */
    /*      No              Yes         file 1                          */
    /*      Yes             Yes         compare                         */
    /*      Yes             No          file 0                          */
    /*                         */
    /************************************************************************/
    /************************************************************************/
    /* If file 1 does not exist then we return file 0 regardless.           */
    /************************************************************************/
    if (FALSE == rc[1])
    {
        DC_QUIT;
    }

    /************************************************************************/
    /* If file 0 does not exist and file 1 does, then return file 1.        */
    /************************************************************************/
    if ((FALSE == rc[0]) && (TRUE == rc[1]))
    {
        trcpSharedData->trcIndicator = 1;
        DC_QUIT;
    }

    /************************************************************************/
    /* If we have got this far then both trace files exist so we need to    */
    /* make a decision based on their ages.  User the Win32 CompareFileTime */
    /* function to do this.                                                 */
    /************************************************************************/
    tdRC = CompareFileTime(&(fileTime[0]), &(fileTime[1]));

    /************************************************************************/
    /* If the file times are equal or the first file is newer than the      */
    /* second then select file 0 (i.e.  just quit).                         */
    /************************************************************************/
    if (tdRC >= 0)
    {
        DC_QUIT;
    }

    /************************************************************************/
    /* If we get here then file 1 is newer than file 0 so set the indicator */
    /* to file 1.                                                           */
    /************************************************************************/
    trcpSharedData->trcIndicator = 1;

DC_EXIT_POINT:
    return;

} /* TRCDetermineIndicator */


/****************************************************************************/
/* FUNCTION: TRCDetermineOffset(...)                                        */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function determines the end-of-file offset in the selected trace    */
/* file.                                                                    */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* fileNum       : the number of the file to determine the offset for.      */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* The offset in that file.                                                 */
/*                                                                          */
/****************************************************************************/
DCUINT32 DCINTERNAL TRCDetermineOffset(DCUINT32 fileNum)
{
    DCUINT32 retVal;
    PDCTCHAR pTemp;
    PDCUINT8 pWork;

    /************************************************************************/
    /* Set the temporary pointer to point at the end of the trace file.     */
    /************************************************************************/
    pWork = (PDCUINT8)(trcpFiles[fileNum]);
    if(NULL == pWork)
    {
        return 0;
    }
    pWork += trcpConfig->maxFileSize - sizeof(DCTCHAR);
    pTemp = (PDCTCHAR)pWork;

    /************************************************************************/
    /* Now run back through the trace file looking for the first non-space  */
    /* character.                                                           */
    /************************************************************************/
    while ((pTemp >= trcpFiles[fileNum]) &&
           (_T('\0') == *pTemp))
    {
        pTemp--;
    }

    /************************************************************************/
    /* Increment forward to the next blank character.  It does not matter   */
    /* if we increment past the end of the file as we check whether we need */
    /* to flip the trace files everytime we write a trace line.             */
    /************************************************************************/
    pTemp++;

    /************************************************************************/
    /* Now set the offset correctly.                                        */
    /************************************************************************/
    retVal = (DCUINT32)(pTemp - trcpFiles[fileNum]);

    return(retVal);

} /* TRCDetermineOffset */


/****************************************************************************/
/* FUNCTION: TRCExitProcess(...)                                            */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function kills the current process.                                 */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* exitCode        : exit code for the terminating process                  */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCExitProcess(DCUINT32 exitCode)
{
#ifndef OS_WINCE
    ExitProcess(exitCode);
#else
    //BUGBUG this is broken if not called from the main
    //thread.
    ExitThread(exitCode);
#endif
}


/****************************************************************************/
/* FUNCTION: TRCGetCurrentDate(...)                                         */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function gets the current local date and returns it in a DC_DATE    */
/* structure.                                                               */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* pDate           : a pointer to a DC_DATE structure.                      */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCGetCurrentDate(PDC_DATE pDate)
{
    SYSTEMTIME systemTime;

    /************************************************************************/
    /* Call the Win32 API function to get the current time.                 */
    /************************************************************************/
    GetLocalTime(&systemTime);

    /************************************************************************/
    /* Reformat the date into a DC_DATE structure.                          */
    /************************************************************************/
    pDate->day   = (DCUINT8)  systemTime.wDay;
    pDate->month = (DCUINT8)  systemTime.wMonth;
    pDate->year  = (DCUINT16) systemTime.wYear;

} /* TRCGetCurrentDate */


/****************************************************************************/
/* FUNCTION: TRCGetCurrentTime(...)                                         */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function gets the current local time and returns it in a DC_TIME    */
/* structure.                                                               */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* pTime           : a pointer to a DC_TIME structure.                      */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCGetCurrentTime(PDC_TIME pTime)
{
    SYSTEMTIME systemTime;

    /************************************************************************/
    /* Call the Win32 API function to get the current time.                 */
    /************************************************************************/
    GetLocalTime(&systemTime);

    /************************************************************************/
    /* Reformat the time into a DC_TIME structure.                          */
    /************************************************************************/
    pTime->hour       = (DCUINT8)systemTime.wHour;
    pTime->min        = (DCUINT8)systemTime.wMinute;
    pTime->sec        = (DCUINT8)systemTime.wSecond;
    pTime->hundredths = (DCUINT8)(systemTime.wMilliseconds / 10);

} /* TRCGetCurrentTime */


/****************************************************************************/
/* FUNCTION: TRCGetFileTime(...)                                            */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function tests if the specified file exists - if it does it         */
/* returns TRUE and fills in pFileTime with a FILETIME structure.  If the   */
/* file does not exist it returns FALSE.                                    */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* fileNumber      : number of file to query.                               */
/* pFileTime       : a pointer to a FILETIME structure.                     */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCBOOL DCINTERNAL TRCGetFileTime(DCUINT      fileNumber,
                                 PDCFILETIME pFileTime)
{
    DCBOOL        rc           = FALSE;
    HANDLE        hFile;

    /************************************************************************/
    /* Attempt to open the file.  By specifying OPEN_EXISITING, we only try */
    /* to open an existing file - the call will fail if the file doesn't    */
    /* already exist.                                                       */
    /************************************************************************/
    hFile = CreateFile(trcpConfig->fileNames[fileNumber],
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    /************************************************************************/
    /* Now check to see if the file exists - if it is invalid then the file */
    /* doesn't exist.                                                       */
    /************************************************************************/
    if (INVALID_HANDLE_VALUE == hFile)
    {
        /********************************************************************/
        /* The file doesn't exist so return FALSE.                          */
        /********************************************************************/
        DC_QUIT;
    }

    /************************************************************************/
    /* Determine the most recent trace file.  Use GetFileTime to get the    */
    /* date and time of this file.                                          */
    /************************************************************************/
    rc = GetFileTime(hFile, NULL, NULL, pFileTime);

    /************************************************************************/
    /* Finally close the file handle.                                       */
    /************************************************************************/
    CloseHandle(hFile);

DC_EXIT_POINT:
    return(rc);

} /* TRCGetFileTime */


/****************************************************************************/
/* FUNCTION: TRCSystemError(...)                                            */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function obtains the value of the system error flag and outputs it  */
/* to the trace file as an alert level trace.                               */
/*                                                                          */
/* Note that NT maintains the last system error on a per-thread basis and   */
/* that most Win32 API function calls set it if they fail.                  */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* traceComponent : the trace component.                                    */
/* lineNumber     : the line number.                                        */
/* funcName       : the function name.                                      */
/* fileName       : the file name.                                          */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCSystemError(DCUINT   traceComponent,
                                 DCUINT   lineNumber,
                                 PDCTCHAR funcName,
                                 PDCTCHAR fileName,
                                 PDCTCHAR string)
{
    DCUINT32 length;
    DWORD    lastError;
    DWORD    rc;
    HRESULT  hr;

    /************************************************************************/
    /* Get the last system error for this thread.  We will restore this at  */
    /* the end of this function.                                            */
    /************************************************************************/
    lastError = GetLastError();

    /************************************************************************/
    /* Grab the mutex.                                                      */
    /************************************************************************/
    TRCGrabMutex();

    /************************************************************************/
    /* The output string will be of the format:                             */
    /*                                                                      */
    /* SYSTEM ERROR in <System Call>, <id of error> , <associated string>   */
    /*                                                                      */
    /* So create the first entry in the string.                             */
    /************************************************************************/
    hr = StringCchPrintf(trcpOutputBuffer,
                         TRC_LINE_BUFFER_SIZE,
                         _T("SYSTEM ERROR in %s, %d, "),
                         string,
                         lastError);
    if (SUCCEEDED(hr)) {
        length = DC_TSTRLEN(trcpOutputBuffer);
        rc = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                           NULL,
                           lastError,
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                           &(trcpOutputBuffer[length]),
                           TRC_LINE_BUFFER_SIZE - length * sizeof(DCTCHAR),
                           NULL);
    }
    else {
        DC_QUIT;
    }


    /************************************************************************/
    /* Check the return code.                                               */
    /************************************************************************/
    if (0 == rc)
    {
        hr = StringCchPrintf(trcpOutputBuffer + length,
                             TRC_LINE_BUFFER_SIZE - length -1,
                            _T("<FormatMessage> failed with rc %#hx"),
                            GetLastError());
        if (FAILED(hr)) {
            DC_QUIT;
        }
    }
    else
    {
        /********************************************************************/
        /* <FormatMessage> adds an additional '\r\n' to the end of the      */
        /* message string - however we don't need this so we strip it off.  */
        /********************************************************************/
        length = DC_TSTRLEN(trcpOutputBuffer);
        trcpOutputBuffer[length - 2] = _T('\0');
    }

    /************************************************************************/
    /* Now call our internal trace buffer function to trace this message    */
    /* out.  Note that we don't need to worry about freeing the mutex -     */
    /* <TRC_TraceBuffer> will do that for us.                               */
    /************************************************************************/
    TRC_TraceBuffer(TRC_LEVEL_ALT,
                    traceComponent,
                    lineNumber,
                    funcName,
                    fileName);

DC_EXIT_POINT:

    /************************************************************************/
    /* Finally we will restore the original value of last error.            */
    /************************************************************************/
    SetLastError(lastError);
    

    return;

} /* TRCSystemError */


/****************************************************************************/
/* FUNCTION: TRCOpenAllFiles(...)                                           */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* Opens all the trace files.                                               */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* 0             : Function succeeded.                                      */
/*                                                                          */
/****************************************************************************/
DCUINT DCINTERNAL TRCOpenAllFiles(DCVOID)
{
    DCUINT rc                = 0;
    DCUINT i;
    DCUINT j;

    /************************************************************************/
    /* Now if we are the first process to attach then set up the trace      */
    /* indicator.  This tells us which file is currently active (i.e.       */
    /* being used for trace output).  We need to do this before we open the */
    /* files as if they both exist already, they will both be created.      */
    /* File 2 will be created after file 1 and as we trace to the most      */
    /* recent file we will end up tracing to file 2 - and you don't want to */
    /* do that!                                                             */
    /************************************************************************/
    if (trcCreatedTraceFiles)
    {
        TRCDetermineIndicator();
    }

    /************************************************************************/
    /* Open all the trace output files.                                     */
    /************************************************************************/
    for (i = 0; i < TRC_NUM_FILES; i++)
    {
        /********************************************************************/
        /* Call TRCOpenSingleFile to open a single trace file.              */
        /********************************************************************/
        rc = TRCOpenSingleFile(i);

        if (0 != rc)
        {
            DC_QUIT;
        }
    }

    /************************************************************************/
    /* Finally, if we are the first process to attach, then set up the      */
    /* trace offset.  This is the offset within the currently active trace  */
    /* file.                                                                */
    /************************************************************************/
    if (trcCreatedTraceFiles)
    {
        trcpSharedData->trcOffset =
                             TRCDetermineOffset(trcpSharedData->trcIndicator);
    }

DC_EXIT_POINT:

    if (0 != rc)
    {
        /********************************************************************/
        /* Close any files that we may already have opened.  We do not need */
        /* to call TRCCloseSingleFile for the file which failed to open     */
        /* correctly as TRCOpenSingleFile will tidy up that file for us.    */
        /********************************************************************/
        for (j = i; j > 0; j--)
        {
            TRCCloseSingleFile(j - 1, 0);
        }

        /********************************************************************/
        /* Clear the trace-to-file flag - we can't do it.                   */
        /********************************************************************/
        CLEAR_FLAG(trcpConfig->flags, TRC_OPT_FILE_OUTPUT);
    }

    /************************************************************************/
    /* Always return 0 to allow tracing to continue to the debugger.        */
    /************************************************************************/
    return(0);

} /* TRCOpenAllFiles */


/****************************************************************************/
/* FUNCTION: TRCOpenSharedData(...)                                         */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function opens the shared data memory mapped file.                  */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* 0                            : Function succeeded                        */
/* TRC_RC_CREATE_MAPPING_FAILED : Failed to create the file mapping         */
/* TRC_RC_MAP_VIEW_FAILED       : MapViewOfFile failed.                     */
/*                                                                          */
/****************************************************************************/
DCUINT DCINTERNAL TRCOpenSharedData(DCVOID)
{
    DCUINT rc                = 0;
#ifdef RUN_ON_WINNT
    DWORD  dwrc;
#endif

#ifndef OS_WINCE
    OSVERSIONINFO ver;
    SECURITY_ATTRIBUTES sa;
    SECURITY_DESCRIPTOR sd;
    PSID psidEveryone = NULL;
    SID_IDENTIFIER_AUTHORITY sidEveryoneAuthority = SECURITY_WORLD_SID_AUTHORITY;
    DCUINT32 dwDaclLength;
    PACL pDacl = NULL;
#endif
    /************************************************************************/
    /* Attempt to create the shared data memory mapped file.  If this has   */
    /* already been created by another instance of this DLL then            */
    /* CreateFileMapping will simply return the handle of the existing      */
    /* object.  Passing 0xFFFFFFFF creates a shared data memory mapped      */
    /* file.                                                                */
    /************************************************************************/

#ifdef OS_WINCE
    /************************************************************************/
    /* For Windows CE, just use global data; always reset it.  Note that    */
    /* this prevents shared use of the Trace DLL.                           */
    /************************************************************************/
    trchSharedDataObject = NULL;
    trcpSharedData = &trcSharedData;
    trcCreatedTraceFiles = TRUE;
#else
    
    ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&ver);
    if (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) {

        /************************************************************************/
        /* Get the SID for the Everyone group                                   */
        /************************************************************************/
        if (!AllocateAndInitializeSid (
                &sidEveryoneAuthority,          // pIdentifierAuthority
                1,                              // count of subauthorities
                SECURITY_WORLD_RID,             // subauthority 0
                0, 0, 0, 0, 0, 0, 0,            // subauthorities n
                &psidEveryone)) {               // pointer to pointer to SID
            rc = TRC_RC_MAP_VIEW_FAILED;
            OutputDebugString(_T("AllocateAndInitializeSid failed.\n"));
            DC_QUIT;
        }

        /************************************************************************/
        /* Allocate the Dacl                                                    */
        /************************************************************************/
        dwDaclLength = sizeof(ACL);
        dwDaclLength += (sizeof(ACCESS_DENIED_ACE) - sizeof(DWORD)) +
                           GetLengthSid(psidEveryone);
        dwDaclLength += (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                           GetLengthSid(psidEveryone);
        pDacl = (PACL)LocalAlloc(LMEM_FIXED, dwDaclLength);
        if (pDacl == NULL) {
            OutputDebugString(_T("Can't allocate Dacl.\n"));
            rc = TRC_RC_MAP_VIEW_FAILED;
            DC_QUIT;
        }

        /************************************************************************/
        /* Initialize it.                                                       */
        /************************************************************************/
        if (!InitializeAcl(pDacl, dwDaclLength, ACL_REVISION)) {
            rc = TRC_RC_MAP_VIEW_FAILED;
            OutputDebugString(_T("InitializeAcl failed.\n"));
            DC_QUIT;
        }

        /************************************************************************/
        /* Allow all access                                                     */
        /************************************************************************/
        if (!AddAccessAllowedAce(
                        pDacl,
                        ACL_REVISION,
                        GENERIC_ALL,
                        psidEveryone)) {
            rc = TRC_RC_MAP_VIEW_FAILED;
            OutputDebugString(_T("AddAccessAllowedAce failed.\n"));
            DC_QUIT;
        }

        /************************************************************************/
        /* Block Write-DACL Access                                              */
        /************************************************************************/
        if (!AddAccessDeniedAce(
                        pDacl,
                        ACL_REVISION,
                        WRITE_DAC,
                        psidEveryone)) {
            rc = TRC_RC_MAP_VIEW_FAILED;
            OutputDebugString(_T("AddAccessDeniedAceEx failed.\n"));
            DC_QUIT;
        }

        /************************************************************************/
        /* Create the File Mapping                                              */
        /************************************************************************/
        InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
        SetSecurityDescriptorDacl(&sd, TRUE, pDacl, FALSE);
        sa.lpSecurityDescriptor = &sd;

        trchSharedDataObject = CreateFileMapping(INVALID_HANDLE_VALUE,
                                                 &sa,
                                                 PAGE_READWRITE,
                                                 0,
                                                 sizeof(TRC_SHARED_DATA),
                                                 TRC_SHARED_DATA_NAME);
    }
    else {
        trchSharedDataObject = CreateFileMapping(INVALID_HANDLE_VALUE,
                                                 NULL,
                                                 PAGE_READWRITE,
                                                 0,
                                                 sizeof(TRC_SHARED_DATA),
                                                 TRC_SHARED_DATA_NAME);
    }

    /************************************************************************/
    /* Check that we succeeded in creating the file mapping.                */
    /************************************************************************/
    if (NULL == trchSharedDataObject)
    {
        TRCDebugOutput(_T("NULL trchSharedDataObject.\n"));
        rc = TRC_RC_CREATE_MAPPING_FAILED;
        DC_QUIT;
    }

    /************************************************************************/
    /* Determine if the file mapping already exists - if it does then we    */
    /* won't bother reading the registry data in or setting up the file     */
    /* offset and indicator values.  Note that up to this point             */
    /* <trcCreatedTraceFiles> has been set to TRUE.                         */
    /************************************************************************/
    if (ERROR_ALREADY_EXISTS == GetLastError())
    {
        trcCreatedTraceFiles = FALSE;
    }

    /************************************************************************/
    /* We now have a handle to the shared data MMF which now needs to be    */
    /* mapped into our address space.  Setting the third, fourth and fifth  */
    /* parameters of MapViewOfFile to zero maps the whole file into our     */
    /* address space starting with the first byte of the file.              */
    /************************************************************************/
    trcpSharedData = (PTRC_SHARED_DATA) MapViewOfFile(trchSharedDataObject,
                                                      FILE_MAP_ALL_ACCESS,
                                                      0,
                                                      0,
                                                      0);
    if (NULL == trcpSharedData)
    {
        /********************************************************************/
        /* Free up the handle to the file mapping object.                   */
        /********************************************************************/
        CloseHandle(trchSharedDataObject);
        trchSharedDataObject = NULL;

        /********************************************************************/
        /* Output a debug string and then quit.                             */
        /********************************************************************/
        TRCDebugOutput(_T("NULL trcpSharedData.\n"));
        rc = TRC_RC_MAP_VIEW_FAILED;
        DC_QUIT;
    }
#endif /* OS_WINCE */

    /************************************************************************/
    /* Set up our static pointer to the shared configuration data and to    */
    /* the filter data.                                                     */
    /************************************************************************/
    trcpConfig       = &(trcpSharedData->trcConfig);
    trcpFilter       = &(trcpSharedData->trcFilter);
    trcpOutputBuffer = trcpSharedData->trcpOutputBuffer;

    /************************************************************************/
    /* Finally initialize the shared data block and then read in the        */
    /* configuration data - but only if we are the first to open the file   */
    /* mapping.                                                             */
    /************************************************************************/
    if (trcCreatedTraceFiles)
    {
        /********************************************************************/
        /* Initialize the shared data memory mapped file.                   */
        /********************************************************************/
        DC_MEMSET(trcpSharedData, 0, sizeof(TRC_SHARED_DATA));

        /********************************************************************/
        /* Initialize the internal status flags.  The following flags apply */
        /* to all the processes.                                            */
        /********************************************************************/
        CLEAR_FLAG(trcpFilter->trcStatus, TRC_STATUS_ASSERT_DISPLAYED);

        /********************************************************************/
        /* The following flags are maintained on a per-process basis.       */
        /********************************************************************/
        CLEAR_FLAG(trcProcessStatus, TRC_STATUS_SYMBOLS_LOADED);

        /********************************************************************/
        /* Read in the configuration data.                                  */
        /********************************************************************/
        TRCReadSharedDataConfig();

        /********************************************************************/
        /* Now split the prefix list.                                       */
        /********************************************************************/
        TRCSplitPrefixes();
    }

DC_EXIT_POINT:

#ifndef OS_WINCE
    if (trchSharedDataObject == NULL) {
        if (pDacl) LocalFree(pDacl);
        if (psidEveryone) FreeSid(psidEveryone);
    }
#endif

    return(rc);

} /* TRCOpenSharedData */


/****************************************************************************/
/* FUNCTION: TRCOpenSingleFile(...)                                         */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* Opens a single trace memory mapped file.                                 */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* fileNum       : which file to open.                                      */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* 0                            : Function succeeded                        */
/* TRC_RC_CREATE_FILE_FAILED    : CreateFile call failed                    */
/* TRC_RC_MAP_VIEW_FAILED       : MapViewOfFile failed                      */
/* TRC_RC_CREATE_MAPPING_FAILED : Failed to create the file mapping         */
/*                                                                          */
/****************************************************************************/
DCUINT DCINTERNAL TRCOpenSingleFile(DCUINT fileNum)
{
    DCUINT rc                = 0;
    DCBOOL blankFile         = FALSE;
#ifndef OS_WINCE
    DCTCHAR objectName[30];
    SECURITY_ATTRIBUTES sa;
    SECURITY_DESCRIPTOR sd;
    PSID psidEveryone = NULL;
    SID_IDENTIFIER_AUTHORITY sidEveryoneAuthority = SECURITY_WORLD_SID_AUTHORITY;
    DCUINT32 dwDaclLength;
    PACL pDacl = NULL;
    OSVERSIONINFO ver;
    HRESULT hr;
#endif
    /************************************************************************/
    /* Open a single trace file.  First of all we attempt to open the file  */
    /* with read and write access, and shared read and write access.  The   */
    /* OPEN_ALWAYS flag ensures that the file is created if it does not     */
    /* already exist.  We pass NULL for the security attributes and         */
    /* template parameters (4 and 7).                                       */
    /************************************************************************/
    trchFileObjects[fileNum] = CreateFile(trcpConfig->fileNames[fileNum],
                                          GENERIC_READ | GENERIC_WRITE,
                                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                                          NULL,
#ifndef OS_WINCE
                                          OPEN_ALWAYS,
#else
                                          CREATE_ALWAYS,
#endif
                                          FILE_ATTRIBUTE_NORMAL,
                                          NULL);

    /************************************************************************/
    /* Check that the handle returned by CreateFile is valid.  For some     */
    /* peculiar reason it does return NULL if it fails - instead it returns */
    /* -1 (INVALID_HANDLE_VALUE).                                           */
    /************************************************************************/
    if (INVALID_HANDLE_VALUE == trchFileObjects[fileNum])
    {
        TRCDebugOutput(_T("Failed to open trace file.\n"));
        rc = TRC_RC_CREATE_FILE_FAILED;
        DC_QUIT;
    }

    /************************************************************************/
    /* Now check whether the file existed before the call to CreateFile.    */
    /* If it did then GetLastError returns ERROR_ALREADY_EXISTS (even       */
    /* though the function has succeeded).                                  */
    /************************************************************************/
    if (0 == GetLastError())
    {
        /********************************************************************/
        /* If the file did not exist before the call, GetLastError returns  */
        /* zero.  In this case we want to fill the file with spaces.        */
        /********************************************************************/
        blankFile = TRUE;

        /********************************************************************/
        /* We have just created the file - so would expect to need to set   */
        /* the security info to allow all accesses.  However, a) all works  */
        /* just fine without it, b) the attempt to set the security stuff   */
        /* fails if inserted here.  So we'll just go along happily without. */
        /********************************************************************/
    }

#ifdef OS_WINCE
    SetFilePointer(trchFileObjects[fileNum],
                   0,
                   NULL,
                   FILE_END);
#else
    /************************************************************************/
    /* Make sure that the end of the file is correctly set.  The file may   */
    /* be of any size when we open it, but we need it to be                 */
    /* <trcpConfig->maxFileSize> bytes long.                                */
    /************************************************************************/
    SetFilePointer(trchFileObjects[fileNum],
                   trcpConfig->maxFileSize,
                   NULL,
                   FILE_BEGIN);
    SetEndOfFile(trchFileObjects[fileNum]);

    /************************************************************************/
    /* Generate the file mapping object name.  This is used in              */
    /* CreateFileMapping.                                                   */
    /************************************************************************/
    hr = StringCchPrintf(objectName,
                         SIZE_TCHARS(objectName),
                         TRC_TRACE_FILE_NAME _T("%hu"), fileNum);
    if (FAILED(hr)) {
        DC_QUIT;
    }


    /************************************************************************/
    /* Now create the file mapping object.  Again ignore security           */
    /* attributes (parameter 2) and set the high order 32 bits of the       */
    /* object size to 0 (see Win32 SDK for more information).               */
    /*                                                                      */
    /* Create the file mapping object using a NULL Dacl so it works for all */
    /* contexts.                                                            */
    /************************************************************************/
    ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&ver);
    if (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) {

        /************************************************************************/
        /* Get the SID for the Everyone group                                   */
        /************************************************************************/
        if (!AllocateAndInitializeSid (
                &sidEveryoneAuthority,          // pIdentifierAuthority
                1,                              // count of subauthorities
                SECURITY_WORLD_RID,             // subauthority 0
                0, 0, 0, 0, 0, 0, 0,            // subauthorities n
                &psidEveryone)) {               // pointer to pointer to SID
            rc = TRC_RC_MAP_VIEW_FAILED;
            OutputDebugString(_T("AllocateAndInitializeSid failed.\n"));
            DC_QUIT;
        }

        /************************************************************************/
        /* Allocate the Dacl                                                    */
        /************************************************************************/
        dwDaclLength = sizeof(ACL);
        dwDaclLength += (sizeof(ACCESS_DENIED_ACE) - sizeof(DWORD)) +
                           GetLengthSid(psidEveryone);
        dwDaclLength += (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                           GetLengthSid(psidEveryone);
        pDacl = (PACL)LocalAlloc(LMEM_FIXED, dwDaclLength);
        if (pDacl == NULL) {
            OutputDebugString(_T("Can't allocate Dacl.\n"));
            rc = TRC_RC_MAP_VIEW_FAILED;
            DC_QUIT;
        }

        /************************************************************************/
        /* Initialize it.                                                       */
        /************************************************************************/
        if (!InitializeAcl(pDacl, dwDaclLength, ACL_REVISION)) {
            rc = TRC_RC_MAP_VIEW_FAILED;
            OutputDebugString(_T("InitializeAcl failed.\n"));
            DC_QUIT;
        }

        /************************************************************************/
        /* Allow all access                                                     */
        /************************************************************************/
        if (!AddAccessAllowedAce(
                        pDacl,
                        ACL_REVISION,
                        GENERIC_ALL,
                        psidEveryone)) {
            rc = TRC_RC_MAP_VIEW_FAILED;
            OutputDebugString(_T("AddAccessAllowedAce failed.\n"));
            DC_QUIT;
        }

        /************************************************************************/
        /* Block Write-DACL Access                                              */
        /************************************************************************/
        if (!AddAccessDeniedAce(
                        pDacl,
                        ACL_REVISION,
                        WRITE_DAC,
                        psidEveryone)) {
            rc = TRC_RC_MAP_VIEW_FAILED;
            OutputDebugString(_T("AddAccessDeniedAceEx failed.\n"));
            DC_QUIT;
        }

        /************************************************************************/
        /* Create the File Mapping
        /************************************************************************/
        InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
        SetSecurityDescriptorDacl(&sd, TRUE, pDacl, FALSE);
        sa.lpSecurityDescriptor = &sd;

        trchMappingObjects[fileNum] = CreateFileMapping(trchFileObjects[fileNum],
                                                        &sa,
                                                        PAGE_READWRITE,
                                                        0,
                                                        trcpConfig->maxFileSize,
                                                        objectName);

    }
    else {
        trchMappingObjects[fileNum] = CreateFileMapping(trchFileObjects[fileNum],
                                                        NULL,
                                                        PAGE_READWRITE,
                                                        0,
                                                        trcpConfig->maxFileSize,
                                                        objectName);
    }

    /************************************************************************/
    /* Check that we succeeded in creating the file mapping object.         */
    /* CreateFileMapping returns NULL if it fails.                          */
    /************************************************************************/
    if (NULL == trchMappingObjects[fileNum])
    {
        TRCDebugOutput(_T("Failed to map trace file.\n"));
        rc = TRC_RC_CREATE_MAPPING_FAILED;
        DC_QUIT;    
    }

    /************************************************************************/
    /* Now map a view of the file.  Set the low and high order offsets to   */
    /* zero (parameters 3 and 4).                                           */
    /************************************************************************/
    trcpFiles[fileNum] = (PDCTCHAR)MapViewOfFile(trchMappingObjects[fileNum],
                                                 FILE_MAP_ALL_ACCESS,
                                                 0,
                                                 0,
                                                 trcpConfig->maxFileSize);

    /************************************************************************/
    /* Check that we mapped a view of the file.                             */
    /************************************************************************/
    if (NULL == trcpFiles[fileNum])
    {
        TRCDebugOutput(_T("Failed to map view of trace file.\n"));
        rc = TRC_RC_MAP_VIEW_FAILED;
        DC_QUIT;
    }

    /************************************************************************/
    /* Finally check to see if we need to blank this file.                  */
    /************************************************************************/
    if (blankFile)
    {
        TRCBlankFile(fileNum);
    }
#endif

DC_EXIT_POINT:

    /************************************************************************/
    /* If the return code is non-zero then we need to perform some tidying  */
    /* up.                                                                  */
    /************************************************************************/
    if (0 != rc)
    {
#ifndef OS_WINCE
        /********************************************************************/
        /* Check whether we need to free the handle to the file mapping     */
        /* object.                                                          */
        /********************************************************************/
        if (NULL != trchMappingObjects[fileNum])
        {
            CloseHandle(trchMappingObjects[fileNum]);
            trchMappingObjects[fileNum] = NULL;
        }

#endif
        /********************************************************************/
        /* Check whether we need to free the handle to the file object.     */
        /********************************************************************/
        if (NULL != trchFileObjects[fileNum])
        {
            CloseHandle(trchFileObjects[fileNum]);
            trchFileObjects[fileNum] = NULL;
        }
    }

    return(rc);

} /* TRCOpenSingleFile */


/****************************************************************************/
/* FUNCTION: TRCOutputToFile(...)                                           */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function writes a string to the trace file.  It is used to trace    */
/* both normal trace lines and stack trace lines.                           */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* pText           : a pointer to the trace text string.                    */
/* length          : length of the string.                                  */
/* traceLevel      : the current trace level.                               */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCOutputToFile(PDCTCHAR pText,
                                  DCUINT   length,
                                  DCUINT   traceLevel)
{
#ifndef OS_WINCE
    PDCUINT8 pFilePos;

    /************************************************************************/
    /* Make sure we have a trace file with enough free space.               */
    /************************************************************************/
    TRCMaybeSwapFile(length);

    /************************************************************************/
    /* We can now write out the trace line.                                 */
    /************************************************************************/
    pFilePos = (PDCUINT8)trcpFiles[trcpSharedData->trcIndicator] +
               trcpSharedData->trcOffset;
    DC_MEMCPY(pFilePos, pText, length);

    /************************************************************************/
    /* Check if we should flush this line to disk immediately.  If this is  */
    /* an error or higher level trace then flush to disk regardless.        */
    /************************************************************************/
    if ((TRUE == TEST_FLAG(trcpConfig->flags, TRC_OPT_FLUSH_ON_TRACE)) ||
        (traceLevel >= TRC_LEVEL_ERR))
    {
        FlushViewOfFile(pFilePos, length);
    }

    /************************************************************************/
    /* Finally update the offset.                                           */
    /************************************************************************/
    trcpSharedData->trcOffset += length;
#else
    DWORD dwRet;
    WriteFile(trchFileObjects[0], pText, length, &dwRet, NULL);
#endif

DC_EXIT_POINT:
    return;

} /* TRCOutputToFile */


/****************************************************************************/
/* FUNCTION: TRCReadEntry(...)                                              */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* Read an entry from the given section of the registry.                    */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* topLevelKey      : one of:                                               */
/*                      - HKEY_CURRENT_USER                                 */
/*                      - HKEY_LOCAL_MACHINE                                */
/* pSection         : the section name to read from.  The DC_REG_PREFIX     */
/*                    string is prepended to give the full name.            */
/* pEntry           : the entry name to read.                               */
/* pBuffer          : a buffer to read the entry to.                        */
/* bufferSize       : the size of the buffer.                               */
/* expectedDataType : the type of data stored in the entry.                 */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCUINT DCINTERNAL TRCReadEntry(HKEY     topLevelKey,
                               PDCTCHAR pEntry,
                               PDCTCHAR pBuffer,
                               DCINT    bufferSize,
                               DCINT32  expectedDataType)
{
    LONG     sysrc;
    HKEY     key;
    DCINT32  dataType;
    DCINT32  dataSize;
    DCTCHAR  subKey[TRC_MAX_SUBKEY];
    DCBOOL   keyOpen         = FALSE;
    DCUINT   rc              = 0;
    HRESULT  hr;

    /************************************************************************/
    /* Get a subkey for the value.                                          */
    /************************************************************************/
    hr = StringCchCopy(subKey,
                       SIZE_TCHARS(subKey),
                       TRC_SUBKEY_NAME);
    if (FAILED(hr)) {
        DC_QUIT;
    }

    /************************************************************************/
    /* Try to open the key.  If the entry does not exist, RegOpenKeyEx will */
    /* fail.                                                                */
    /************************************************************************/
    sysrc = RegOpenKeyEx(topLevelKey,
                         subKey,
                         0,                   /* reserved                 */
                         KEY_ALL_ACCESS,
                         &key);

    if (ERROR_SUCCESS != sysrc)
    {
        /********************************************************************/
        /* Don't trace an error here since the subkey may not exist...      */
        /********************************************************************/
        rc = TRC_RC_IO_ERROR;
        DC_QUIT;
    }
    keyOpen = TRUE;

    /************************************************************************/
    /* We successfully opened the key so now try to read the value.  Again  */
    /* it may not exist.                                                    */
    /************************************************************************/
    dataSize = (DCINT32)bufferSize;
    sysrc    = RegQueryValueEx(key,
                               pEntry,
                               0,          /* reserved */
                               (LPDWORD) &dataType,
                               (LPBYTE)  pBuffer,
                               (LPDWORD) &dataSize);

    if (sysrc != ERROR_SUCCESS)
    {
        rc = TRC_RC_IO_ERROR;
        DC_QUIT;
    }

    /************************************************************************/
    /* Check that the type is correct.  Special case: allow REG_BINARY      */
    /* instead of REG_DWORD, as long as the length is 32 bits.              */
    /************************************************************************/
    if ((dataType != expectedDataType) &&
        ((dataType != REG_BINARY) ||
         (expectedDataType != REG_DWORD) ||
         (dataSize != 4)))
    {
        rc = TRC_RC_IO_ERROR;
        DC_QUIT;
    }

DC_EXIT_POINT:

    /************************************************************************/
    /* Close the key (if required).                                         */
    /************************************************************************/
    if (keyOpen)
    {
        sysrc = RegCloseKey(key);
        if (ERROR_SUCCESS != sysrc)
        {
            TRCDebugOutput(_T("Failed to close key.\n"));
        }
    }

    return(rc);

} /* TRCReadEntry */


/****************************************************************************/
/* FUNCTION: TRCStackTrace(...)                                             */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* traceLevel      : the current trace level which is used to determine     */
/*                   whether this line should be flushed to disk            */
/*                   immediately.                                           */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCStackTrace(DCUINT traceLevel)
{
    DC_IGNORE_PARAMETER(traceLevel);
#ifdef DO_STACK_TRACE
    HANDLE           hProcess;
    HANDLE           hThread;
    DCBOOL           sysrc;
    STACKFRAME       stackFrame;
    DWORD            machineType;
    IMAGEHLP_MODULE  moduleInfo;
    DCINT            i;
    DCTCHAR          formatString[TRC_FRMT_BUFFER_SIZE];
    CONTEXT          threadContext;
    CHAR             symBuffer[sizeof(IMAGEHLP_SYMBOL)+TRC_MAX_SYMNAME_SIZE];
    PIMAGEHLP_SYMBOL pSymbol;
    PCHAR            pFuncName;
    DWORD            displacement   = 0;
    DCBOOL           foundTrace     = FALSE;

    /************************************************************************/
    /* First of all ensure that stack tracing is enabled - if it is not     */
    /* then just return.                                                    */
    /************************************************************************/
    /************************************************************************/
    /* The stack trace code doesn't work for Alpha so don't bother trying.  */
    /************************************************************************/
#ifndef _M_ALPHA
    if (!TEST_FLAG(trcpConfig->flags, TRC_OPT_STACK_TRACING))
#endif
    {
        DC_QUIT;
    }

    /************************************************************************/
    /* Set <pSymbol> to point to the symbol buffer.                         */
    /************************************************************************/
    pSymbol = (PIMAGEHLP_SYMBOL) symBuffer;

    /************************************************************************/
    /* Zero memory structures.                                              */
    /************************************************************************/
    ZeroMemory(&stackFrame, sizeof(stackFrame));
    ZeroMemory(pSymbol, sizeof(IMAGEHLP_SYMBOL));
    ZeroMemory(&threadContext, sizeof(CONTEXT));

    /************************************************************************/
    /* Initialize the symbol buffer.                                        */
    /************************************************************************/
    pSymbol->SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL);
    pSymbol->MaxNameLength = 1024;

    /************************************************************************/
    /* Get handles to the current process and thread.                       */
    /************************************************************************/
    hProcess = GetCurrentProcess();
    hThread  = GetCurrentThread();

    /************************************************************************/
    /* We need to get the values of the base pointer, stack pointer and the */
    /* instruction pointer.  We can use <GetContextThread> to return this   */
    /* information - but first of all we need to set the <ContextFlags>     */
    /* member of the <threadContext> struture to return the control         */
    /* registers.                                                           */
    /************************************************************************/
    threadContext.ContextFlags = CONTEXT_CONTROL;

    /************************************************************************/
    /* Now attempt to get the thread context.                               */
    /************************************************************************/
    if (!GetThreadContext(hThread, &threadContext))
    {
        /********************************************************************/
        /* If <GetThreadContext> failed then there is not a lot we can do   */
        /* so just quit.                                                    */
        /********************************************************************/
        TRCInternalError(_T("GetThreadContext failed.\n"));
        DC_QUIT;
    }

    /************************************************************************/
    /* Store the instruction pointer in the <stackFrame> structure.         */
    /************************************************************************/
    stackFrame.AddrPC.Mode   = AddrModeFlat;

    /************************************************************************/
    /* Processor dependant section.  We set the image file type here and if */
    /* we are running on Intel hardware we also store the stack pointer and */
    /* base pointer.                                                        */
    /************************************************************************/
#if defined(_M_IX86)
        machineType = IMAGE_FILE_MACHINE_I386;

        stackFrame.AddrPC.Offset    = threadContext.Eip;
        stackFrame.AddrFrame.Offset = threadContext.Ebp;
        stackFrame.AddrFrame.Mode   = AddrModeFlat;
        stackFrame.AddrStack.Offset = threadContext.Esp;
        stackFrame.AddrStack.Mode   = AddrModeFlat;

#elif defined (_M_MRX000)
        machineType = IMAGE_FILE_MACHINE_R4000;
#elif defined (_M_ALPHA)
        machineType = IMAGE_FILE_MACHINE_ALPHA;
#elif defined (_M_PPC)
        machineType = IMAGE_FILE_MACHINE_POWERPC;
#else
#error("Unknown machine type.");
#endif

    /************************************************************************/
    /* Now run down the stack.                                              */
    /************************************************************************/
    for (i = 1; i < TRC_MAX_SIZE_STACK_TRACE; i++)
    {
        /********************************************************************/
        /* Call <StackWalk> to start walking the stack.                     */
        /********************************************************************/
        sysrc = StackWalk(machineType,
                          hProcess,
                          hThread,
                          &stackFrame,
                          &threadContext,
                          NULL,
                          SymFunctionTableAccess,
                          SymGetModuleBase,
                          NULL);

        /********************************************************************/
        /* Check the return code.                                           */
        /********************************************************************/
        if (FALSE == sysrc)
        {
            /****************************************************************/
            /* Don't trace anything here as we enter here when we reach     */
            /* the end of the stack.                                        */
            /****************************************************************/
            DC_QUIT;
        }

        /********************************************************************/
        /* Get the module name.                                             */
        /********************************************************************/
        sysrc = SymGetModuleInfo(hProcess,
                                 stackFrame.AddrPC.Offset,
                                 &moduleInfo);

        /********************************************************************/
        /* Check the return code.                                           */
        /********************************************************************/
        if (FALSE == sysrc)
        {
            /****************************************************************/
            /* Don't trace anything as we enter here when we reach the end  */
            /* of the stack.                                                */
            /****************************************************************/
            DC_QUIT;
        }

        /********************************************************************/
        /* When we start we are somewhere in the midst of                   */
        /* <GetThreadContext>.  Since we're only interested in the stack    */
        /* above the trace module then we need to skip everything until we  */
        /* pass the trace module.                                           */
        /*                                                                  */
        /* Look for the trace module name.                                  */
        /********************************************************************/
        if (DC_TSTRCMPI(trcpSharedData->trcpModuleFileName,
                        moduleInfo.ModuleName) == 0)
        {
            /****************************************************************/
            /* They match so set the <foundTrace> flag and the continue.    */
            /****************************************************************/
            foundTrace = TRUE;
            continue;
        }

        /********************************************************************/
        /* We've not found the trace module yet so just continue.           */
        /********************************************************************/
        if (!foundTrace)
        {
            continue;
        }

        /********************************************************************/
        /* Now get the symbol name.                                         */
        /********************************************************************/
        sysrc = SymGetSymFromAddr(hProcess,
                                  stackFrame.AddrPC.Offset,
                                  &displacement,
                                  pSymbol);

        /********************************************************************/
        /* Check the return code.                                           */
        /********************************************************************/
        if (sysrc)
        {
            /****************************************************************/
            /* We've found some symbols so use them.                        */
            /****************************************************************/
            pFuncName = pSymbol->Name;
        }
        else
        {
            /****************************************************************/
            /* No symbols available.                                        */
            /****************************************************************/
            pFuncName = _T("<nosymbols>");
        }

        /********************************************************************/
        /* Finally format the string.                                       */
        /********************************************************************/
        hr = StringCchPrintf(
                    formatString,
                    SIZE_TCHARS(formatString),
                    _T("    ") TRC_MODL_FMT _T("!") TRC_FUNC_FMT _T(" : ") TRC_STCK_FMT_T("\r\n"),
                    moduleInfo.ModuleName,
                    trcpConfig->funcNameLength,
                    trcpConfig->funcNameLength,
                    pFuncName,
                    displacement,
                    stackFrame.AddrFrame.Offset,
                    stackFrame.AddrReturn.Offset,
                    stackFrame.Params[0],
                    stackFrame.Params[1],
                    stackFrame.Params[2],
                    stackFrame.Params[3]
                    );

        if (SUCCEEDED(hr)) {
            /********************************************************************/
            /* Output this line of the <formatString>.                          */
            /********************************************************************/
            TRCOutput(formatString, DC_TSTRLEN(formatString), traceLevel);
        }
    }

DC_EXIT_POINT:

    return;
#endif /* DO_STACK_TRACE */

} /* TRCStackTrace */


/****************************************************************************/
/* FUNCTION: TRCSymbolsLoad(...)                                            */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* Function to load symbolic debugging information.  This function should   */
/* only be called if the trace mutex has been obtained.                     */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* 0                      : success.                                        */
/* TRC_SYMBOL_LOAD_FAILED : failed to load symbols.                         */
/*                                                                          */
/****************************************************************************/
DCUINT DCINTERNAL TRCSymbolsLoad(DCVOID)
{
    DCUINT rc              = 0;
    HANDLE hProcess;
#ifdef DO_STACK_TRACE
    DWORD  options;
#endif

    /************************************************************************/
    /* Get the current process handle.                                      */
    /************************************************************************/
    hProcess = GetCurrentProcess();

    /************************************************************************/
    /* We're about to load symbols - so trace a line out.                   */
    /************************************************************************/
    TRCInternalTrace(TRC_SYMBOLS_LOADING_NOTIFY);

#ifdef DO_STACK_TRACE
    /************************************************************************/
    /* Now set the deferred symbol load option.  For some peculiar reason   */
    /* this is not set by default.                                          */
    /************************************************************************/
    options = SymGetOptions();
    SymSetOptions(options | SYMOPT_DEFERRED_LOADS);

    /************************************************************************/
    /* Initialize the symbol handler for this process.  By setting param 2  */
    /* to NULL the search path for the symbols is as follows:               */
    /*                                                                      */
    /* - Current directory                                                  */
    /* - Env variable _NT_SYMBOL_PATH                                       */
    /* - Env variable _NT_ALTERNATE_SYMBOL_PATH                             */
    /* - Env variable SYSTEMROOT                                            */
    /*                                                                      */
    /* By setting the third parameter to TRUE we tell IMAGEHLP to enumerate */
    /* the loaded modules for this process (this effectively calls          */
    /* <SymLoadModule> for each module).                                    */
    /************************************************************************/

    /************************************************************************/
    /* LAURABU:                                                             */
    /* SymInitialize returns FALSE on Win95.  Moreover, it makes no sense   */
    /* to fail to start up on either NT or Win95 just because this dll      */
    /* couldn't load debug symbols.  Therefore don't fail.                  */
    /************************************************************************/
    if (!(SymInitialize(hProcess, NULL, TRUE)))
    {
#ifdef DC_OMIT
        rc = TRC_RC_SYMBOL_LOAD_FAILED;
#endif
        TRCDebugOutput(_T("SymInitialize failed.\n"));
#ifdef DC_OMIT
        DC_QUIT;
#endif
    }
#endif

    /************************************************************************/
    /* Set the flag to indicate the symbols have been loaded.               */
    /************************************************************************/
    SET_FLAG(trcProcessStatus, TRC_STATUS_SYMBOLS_LOADED);

    /************************************************************************/
    /* Write a status line.  The assumption here is that this is done under */
    /* the mutex.                                                           */
    /************************************************************************/
    TRCInternalTrace(TRC_SYMBOLS_LOADED_NOTIFY);

DC_EXIT_POINT:

    return(rc);

} /* TRCSymbolsLoad */


/****************************************************************************/
/* FUNCTION: TRCSymbolsUnload(...)                                          */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* TRUE if successful and FALSE otherwise.                                  */
/*                                                                          */
/****************************************************************************/
DCBOOL DCINTERNAL TRCSymbolsUnload(DCVOID)
{
    DCBOOL    rc = TRUE;
#ifdef DO_STACK_TRACE
    HANDLE    hProcess;

    /************************************************************************/
    /* Get the current process handle.                                      */
    /************************************************************************/
    hProcess = GetCurrentProcess();

    /************************************************************************/
    /* Cleanup the symbols.                                                 */
    /************************************************************************/
    rc = SymCleanup(hProcess);

    /************************************************************************/
    /* Check the return code.                                               */
    /************************************************************************/
    if (FALSE == rc)
    {
        TRCDebugOutput(_T("SymCleanup failed.\n"));
        DC_QUIT;
    }
#endif

    /************************************************************************/
    /* Clear the symbols loaded flag.                                       */
    /************************************************************************/
    CLEAR_FLAG(trcProcessStatus, TRC_STATUS_SYMBOLS_LOADED);

    /************************************************************************/
    /* Write a status line to the trace file.  The assumption here is that  */
    /* this is done under the mutex.                                        */
    /************************************************************************/
    TRCInternalTrace(TRC_SYMBOLS_UNLOAD_NOTIFY);

DC_EXIT_POINT:

    return(rc);

} /* TRCSymbolsLoad */


/****************************************************************************/
/* FUNCTION: TRCWriteEntry(...)                                             */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* Write an entry to the given section of the registry.                     */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* topLevelKey     : one of:                                                */
/*                     - HKEY_CURRENT_USER                                  */
/*                     - HKEY_LOCAL_MACHINE                                 */
/* pEntry          : the entry name to write.                               */
/* pData           : a pointer to the data to be written.                   */
/* dataSize        : the size of the data to be written.  For strings, this */
/*                   should include the NULL terminator.                    */
/* dataType        : the type of the data to be written.                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* 0               : success                                                */
/* TRC_RC_IO_ERROR : I/O error.                                             */
/*                                                                          */
/****************************************************************************/
DCUINT DCINTERNAL TRCWriteEntry(HKEY     topLevelKey,
                                PDCTCHAR pEntry,
                                PDCTCHAR pData,
                                DCINT    dataSize,
                                DCINT32  dataType)
{
    LONG        sysrc;
    HKEY        key;
    DCTCHAR     subKey[TRC_MAX_SUBKEY];
    DWORD       disposition;
    DCBOOL      keyOpen = FALSE;
    DCUINT      rc      = 0;
    HRESULT     hr;

    /************************************************************************/
    /* Get a subkey for the value.                                          */
    /************************************************************************/
    hr = StringCchCopy(subKey,
                       SIZE_TCHARS(subKey),
                       TRC_SUBKEY_NAME);
    if (FAILED(hr)) {
        DC_QUIT;
    }

    /************************************************************************/
    /* Try to create the key.  If the entry already exists, RegCreateKeyEx  */
    /* will open the existing entry.                                        */
    /************************************************************************/
    sysrc = RegCreateKeyEx(topLevelKey,
                           subKey,
                           0,                   /* reserved             */
                           NULL,                /* class                */
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,
                           NULL,                /* security attributes  */
                           &key,
                           &disposition);

    if (ERROR_SUCCESS != sysrc)
    {
        DCTCHAR output[12];

        TRCDebugOutput(_T("Failed to create key failed with error "));

        hr = StringCchPrintf(output, SIZE_TCHARS(output),
                             _T("%#lx"), GetLastError());
        if (SUCCEEDED(hr)) {
            TRCDebugOutput(output);
        }

        DC_QUIT;
    }

    keyOpen = TRUE;

    /************************************************************************/
    /* We've got the key, so set the value.                                 */
    /************************************************************************/
    sysrc = RegSetValueEx(key,
                          pEntry,
                          0,                                /* reserved     */
                          dataType,
                          (LPBYTE) pData,
                          (DCINT32) dataSize);

    if (ERROR_SUCCESS != sysrc)
    {
        DCTCHAR output[12];

        TRCDebugOutput(_T("Failed to set value failed with error "));

        hr = StringCchPrintf(output, SIZE_TCHARS(output),
                             _T("%#lx"), GetLastError());
        if (SUCCEEDED(hr)) {
            TRCDebugOutput(output);
        }

        DC_QUIT;
    }

DC_EXIT_POINT:

    /************************************************************************/
    /* Close the key (if required)                                          */
    /************************************************************************/
    if (keyOpen)
    {
        sysrc = RegCloseKey(key);
        if (ERROR_SUCCESS != sysrc)
        {
            TRCDebugOutput(_T("Failed to close key.\n"));
        }
    }

    return(rc);

} /* TRCWriteEntry */

/****************************************************************************/
/* We have our own implementation of DebugBreak that on NT checks if a      */
/* debugger is present first before calling DebugBreak().  Otherwise the    */
/* app will just get terminated due to an unhandled exception.              */
/****************************************************************************/

typedef BOOL (WINAPI * PFN_ISDEBUGGERPRESENT)(void);

DCVOID DCINTERNAL TRCDebugBreak(DCVOID)
{
    static PFN_ISDEBUGGERPRESENT    s_pfnIsDebuggerPresent = NULL;
    static BOOL                     s_fHaveWeTriedToFindIt = FALSE;

    if (! s_pfnIsDebuggerPresent)
    {
        if (!InterlockedExchange((long *)&s_fHaveWeTriedToFindIt, TRUE))
        {
            /****************************************************************/
            /* Try to get the proc address of "IsDebuggerPresent".  Note we */
            /* can just write into this variable without Interlocked stuff  */
            /* since dwords get written to and read from atomically.        */
            /****************************************************************/
#ifndef OS_WINCE
            s_pfnIsDebuggerPresent = (PFN_ISDEBUGGERPRESENT)
                          GetProcAddress(GetModuleHandle(_T("kernel32.dll")),
                                         "IsDebuggerPresent");
#else // OS_WINCE
            HMODULE hmod;
            hmod = LoadLibrary(_T("kernel32.dll"));
            s_pfnIsDebuggerPresent = (PFN_ISDEBUGGERPRESENT)
                           GetProcAddress(hmod,
                                          _T("IsDebuggerPresent"));
            FreeLibrary(hmod);
#endif
        }
    }

    /************************************************************************/
    /* If this api doesn't exist, we are on Win95, so go ahead and call     */
    /* DebugBreak().  If it does, we are on NT 4, so find out if a debugger */
    /* is around.  If a debugger isn't there, then don't break for now      */
    /* since we don't have debuggers attached to most of our NT machines    */
    /* yet.                                                                 */
    /************************************************************************/
    if (!s_pfnIsDebuggerPresent || (s_pfnIsDebuggerPresent()))
        DebugBreak();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\trace\wtrcdata.c ===
/**MOD+**********************************************************************/
/* Module:    wtrcdata.c                                                    */
/*                                                                          */
/* Purpose:   Internal tracing data - Windows specific.                     */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/trc/wtrcdata.c_v  $
 *
 *    Rev 1.4   09 Jul 1997 18:03:10   AK
 * SFR1016: Initial changes to support Unicode
 *
 *    Rev 1.3   03 Jul 1997 13:28:56   AK
 * SFR0000: Initial development completed
**/
/**MOD-**********************************************************************/

#ifndef DLL_DISP
/****************************************************************************/
/* Handle to the trace DLL mutex object.                                    */
/****************************************************************************/
DC_DATA(HANDLE,             trchMutex,               0);

/****************************************************************************/
/* Handle and pointer to the trace DLL shared data.                         */
/****************************************************************************/
DC_DATA(PTRC_SHARED_DATA,   trcpSharedData,          0);

/****************************************************************************/
/* Trace file name array.                                                   */
/****************************************************************************/
DC_DATA_ARRAY_NULL(PDCTCHAR, trcpFiles,         TRC_NUM_FILES, DC_STRUCT1(0));

/****************************************************************************/
/* Per-process status flag.                                                 */
/****************************************************************************/
DC_DATA(DCINT32,            trcProcessStatus,        0);

/****************************************************************************/
/* Flag to indicate if we created the shared data MMF, opened/created the   */
/* trace files.  We assume that we have created them.                       */
/****************************************************************************/
DC_DATA(DCBOOL,           trcCreatedTraceFiles,    TRUE);

#endif

#include <ntrcdata.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\trace\wtrcapi.c ===
/**MOD+**********************************************************************/
/* Module:    wtrcapi.c                                                     */
/*                                                                          */
/* Purpose:   External tracing functions - Windows specific                 */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/trc/wtrcapi.c_v  $
 *
 *    Rev 1.7   29 Aug 1997 09:42:02   ENH
 * SFR1259: Changed SystemError
 *
 *    Rev 1.6   12 Aug 1997 09:50:52   MD
 * SFR1002: Remove kernel tracing code
 *
 *    Rev 1.5   10 Jul 1997 18:04:26   AK
 * SFR1016: Initial changes to support Unicode
 *
 *    Rev 1.4   10 Jul 1997 17:34:10   KH
 * SFR1022: Get 16-bit trace working
 *
 *    Rev 1.3   03 Jul 1997 13:28:50   AK
 * SFR0000: Initial development completed
**/
/**MOD-**********************************************************************/

/****************************************************************************/
/*                                                                          */
/* CONTENTS                                                                 */
/* ========                                                                 */
/* TRC_SystemError                                                          */
/* TRC_Initialize                                                           */
/* TRC_Terminate                                                            */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* Standard includes.                                                       */
/****************************************************************************/
#include <adcg.h>

/****************************************************************************/
/* Define TRC_FILE and TRC_GROUP.                                           */
/****************************************************************************/
#define TRC_FILE    "wtrcapi"
#define TRC_GROUP   TRC_GROUP_TRACE

/****************************************************************************/
/* Trace specific includes.                                                 */
/****************************************************************************/
#include <atrcapi.h>
#include <atrcint.h>

/****************************************************************************/
/*                                                                          */
/* DATA                                                                     */
/*                                                                          */
/****************************************************************************/
#define DC_INCLUDE_DATA
#include <atrcdata.c>
#undef DC_INCLUDE_DATA

/****************************************************************************/
/*                                                                          */
/* FUNCTIONS                                                                */
/*                                                                          */
/****************************************************************************/

/**PROC+*********************************************************************/
/* TRC_SystemError(...)                                                     */
/*                                                                          */
/* See wtrcapi.h for description.                                           */
/**PROC-*********************************************************************/
DCVOID DCAPI DCEXPORT TRC_SystemError(DCUINT   traceComponent,
                                      DCUINT   lineNumber,
                                      PDCTCHAR funcName,
                                      PDCTCHAR fileName,
                                      PDCTCHAR string)

{
    /************************************************************************/
    /* The process of getting the system error is clearly platform specific */
    /* so we call the platform specific function.                           */
    /************************************************************************/
    TRCSystemError(traceComponent,
                   lineNumber,
                   funcName,
                   fileName,
                   string);

    return;

} /* TRC_SystemError */

/**PROC+*********************************************************************/
/* TRC_Initialize(...)                                                      */
/*                                                                          */
/* See atrcapi.h for description.                                           */
/**PROC-*********************************************************************/
DCUINT32 DCAPI DCEXPORT TRC_Initialize(DCBOOL initShared)
{
    DCUINT rc                = 0;
#ifndef OS_WINCE
    SECURITY_ATTRIBUTES sa;
    SECURITY_DESCRIPTOR sd;
    OSVERSIONINFO ver;
    PSID psidEveryone = NULL;
    SID_IDENTIFIER_AUTHORITY sidEveryoneAuthority = SECURITY_WORLD_SID_AUTHORITY;
    DCUINT32 dwDaclLength;
    PACL pDacl = NULL;
#endif

    BOOL releaseMutex = FALSE;

    DC_IGNORE_PARAMETER(initShared);

    /************************************************************************/
    /* Create the mutex object which protects the shared memory mapped      */
    /* file.  If the mutex has already been created then CreateMutex simply */
    /* returns a handle to the existing mutex.                              */
    /*                                                                      */
    /* The mutex will be created with a NULL Dacl so processes running it in*/ 
    /* any context can have access.                                         */
    /************************************************************************/
#ifndef OS_WINCE
    ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&ver);
    if (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) {

        /************************************************************************/
        /* Get the SID for the Everyone group                                   */
        /************************************************************************/
        if (!AllocateAndInitializeSid (
                &sidEveryoneAuthority,          // pIdentifierAuthority
                1,                              // count of subauthorities
                SECURITY_WORLD_RID,             // subauthority 0
                0, 0, 0, 0, 0, 0, 0,            // subauthorities n
                &psidEveryone)) {               // pointer to pointer to SID
            rc = TRC_RC_CREATE_MUTEX_FAILED;
            OutputDebugString(_T("AllocateAndInitializeSid failed.\n"));
            DC_QUIT;
        }

        /************************************************************************/
        /* Allocate the Dacl                                                    */
        /************************************************************************/
        dwDaclLength = sizeof(ACL);
        dwDaclLength += (sizeof(ACCESS_DENIED_ACE) - sizeof(DWORD)) +
                           GetLengthSid(psidEveryone);
        dwDaclLength += (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                           GetLengthSid(psidEveryone);
        pDacl = (PACL)LocalAlloc(LMEM_FIXED, dwDaclLength);
        if (pDacl == NULL) {
            rc = TRC_RC_CREATE_MUTEX_FAILED;
            OutputDebugString(_T("Can't allocate Dacl.\n"));
            DC_QUIT;
        }

        /************************************************************************/
        /* Initialize it.                                                       */
        /************************************************************************/
        if (!InitializeAcl(pDacl, dwDaclLength, ACL_REVISION)) {
            rc = TRC_RC_CREATE_MUTEX_FAILED;
            OutputDebugString(_T("InitializeAcl failed.\n"));
            DC_QUIT;
        }

        /************************************************************************/
        /* Allow all access                                                     */
        /************************************************************************/
        if (!AddAccessAllowedAce(
                        pDacl,
                        ACL_REVISION,
                        GENERIC_ALL,
                        psidEveryone)) {
            rc = TRC_RC_CREATE_MUTEX_FAILED;
            OutputDebugString(_T("AddAccessAllowedAce failed.\n"));
            DC_QUIT;
        }

        /************************************************************************/
        /* Block Write-DACL Access                                              */
        /************************************************************************/
        if (!AddAccessDeniedAce(
                        pDacl,
                        ACL_REVISION,
                        WRITE_DAC,
                        psidEveryone)) {
            rc = TRC_RC_CREATE_MUTEX_FAILED;
            OutputDebugString(_T("AddAccessDeniedAce failed.\n"));
            DC_QUIT;
        }

        /************************************************************************/
        /* Create the Mutex                                                     */
        /************************************************************************/
        InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
        SetSecurityDescriptorDacl(&sd, TRUE, pDacl, FALSE);
        sa.lpSecurityDescriptor = &sd;
        trchMutex = TRCCreateMutex(&sa,
                                   FALSE,
                                   TRC_MUTEX_NAME);

    }
    else {
#endif
        trchMutex = TRCCreateMutex(NULL,
                                   FALSE,
                                   TRC_MUTEX_NAME);
#ifndef OS_WINCE
    }
#endif

    /************************************************************************/
    /* Check that we created the mutex successfully.                        */
    /************************************************************************/
    if (NULL == trchMutex)
    {
        DWORD lastError = GetLastError();
        OutputDebugString(_T("Failed to create mutex.\n"));
        rc = TRC_RC_CREATE_MUTEX_FAILED;
        DC_QUIT;
    }

    /************************************************************************/
    /* Now that we've created the mutex, grab it.                           */
    /************************************************************************/
    TRCGrabMutex();
    releaseMutex = TRUE;

    /************************************************************************/
    /* Check the current trace DLL state.  Another thread may have          */
    /* concurrently called TRC_Initialize - if it has then we should exit   */
    /* as it will perform the initialization.                               */
    /************************************************************************/
    if (TRC_STATE_UNINITIALIZED != trcState)
    {
        TRCDebugOutput(_T("Trace DLL already initialized!\n"));
        DC_QUIT;
    }

    /************************************************************************/
    /* We need to open the shared data memory mapped file.                  */
    /************************************************************************/
    rc = TRCOpenSharedData();

    /************************************************************************/
    /* Check that the shared data MMF was created and opened successfully.  */
    /************************************************************************/
    if (0 != rc)
    {
        DC_QUIT;
    }

    /************************************************************************/
    /* Now open the memory mapped trace files.                              */
    /************************************************************************/
    rc = TRCOpenAllFiles();

    /************************************************************************/
    /* Check that the trace MMFs were opened successfully.                  */
    /************************************************************************/
    if (0 != rc)
    {
        DC_QUIT;
    }

    /************************************************************************/
    /* Write out the trace DLL initialized trace line.                      */
    /************************************************************************/
    TRCInternalTrace(TRC_TRACE_DLL_INITIALIZE);

    /************************************************************************/
    /* Update our internal state.                                           */
    /************************************************************************/
    trcState = TRC_STATE_INITIALIZED;

    /************************************************************************/
    /* Load the debug symbols.                                              */
    /************************************************************************/
    rc = TRCSymbolsLoad();

    if (0 != rc)
    {
        DC_QUIT;
    }


DC_EXIT_POINT:

    /************************************************************************/
    /* Release the mutex.                                                   */
    /************************************************************************/
    if( releaseMutex )
    {
        TRCReleaseMutex();
    }

#ifndef OS_WINCE
    if (trchMutex == NULL) {
        if (pDacl) LocalFree(pDacl);
        if (psidEveryone) FreeSid(psidEveryone);
    }
#endif
    return(rc);

} /* TRC_Initialize */

/**PROC+*********************************************************************/
/* TRC_Terminate(...)                                                       */
/*                                                                          */
/* See atrcapi.h for description.                                           */
/**PROC-*********************************************************************/
DCVOID DCAPI DCEXPORT TRC_Terminate(DCBOOL termShared)
{
    DC_IGNORE_PARAMETER(termShared);

    /************************************************************************/
    /* Grab the mutex.  Note that this function is only called from the     */
    /* process detach case in the <DllMain> function - therefore we can be  */
    /* sure that this function gets called only once per process.           */
    /************************************************************************/
    TRCGrabMutex();

    /************************************************************************/
    /* Unload the symbols if we've loaded them.                             */
    /************************************************************************/
    if (TEST_FLAG(trcProcessStatus, TRC_STATUS_SYMBOLS_LOADED))
    {
        TRCSymbolsUnload();
    }

    /************************************************************************/
    /* Write out the trace DLL terminated trace line.                       */
    /************************************************************************/
    TRCInternalTrace(TRC_TRACE_DLL_TERMINATE);

    /************************************************************************/
    /* Close the trace files.                                               */
    /************************************************************************/
    TRCCloseAllFiles();

    /************************************************************************/
    /* Now we need to close the shared data area.                           */
    /************************************************************************/
    TRCCloseSharedData();

    /************************************************************************/
    /* We're no longer initialized so update our per-process flags.         */
    /************************************************************************/
    trcState = TRC_STATE_TERMINATED;

    /************************************************************************/
    /* Release the mutex.                                                   */
    /************************************************************************/
    TRCReleaseMutex();

    /************************************************************************/
    /* Close the mutex handle.  The mutex object is automatically destroyed */
    /* when the last handle is closed.                                      */
    /************************************************************************/
    TRCCloseHandle(trchMutex);
    trchMutex = NULL;

    return;

} /* TRC_Terminate */

#if defined(OS_WINCE) || defined(TRC_CONVERTOANSI)
/**PROC+*********************************************************************/
/* Name:      TRC_ConvertAndSprintf                                         */
/*                                                                          */
/* Purpose:   Convert ANSI trace format string to Unicode and do sprintf    */
/*            Windows CE only                                               */
/*                                                                          */
/* Returns:   None                                                          */
/*                                                                          */
/* Params:    OUT    outBuf - output buffer                                 */
/*            IN     format - ANSI format string                            */
/*            IN     ...    - parameters                                    */
/*                                                                          */
/**PROC-*********************************************************************/
DCVOID DCAPI TRC_ConvertAndSprintf(PDCTCHAR outBuf, const PDCACHAR format,...)
{
    va_list vaArgs;
    DCINT   count;
    static DCTCHAR stackBuffer[TRC_LINE_BUFFER_SIZE];

    count = DC_MIN(mbstowcs(NULL, format, 0), TRC_LINE_BUFFER_SIZE);
    va_start(vaArgs, format);

    mbstowcs(stackBuffer, format, count);
    vswprintf(outBuf,  stackBuffer, vaArgs);
    va_end(vaArgs);

    return;
}
#else
/****************************************************************************/
/* Dummy stub function, to enable a common DEF file to be used.             */
/****************************************************************************/
DCVOID DCAPI TRC_ConvertAndSprintf(DCVOID)
{
    return;
}
#endif // OS_WINCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\trace\ztrcdata.c ===
/**MOD+**********************************************************************/
/* Module:    ztrcdata.c                                                    */
/*                                                                          */
/* Purpose:   Internal tracing data proxy file                              */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/trc/ztrcdata.c_v  $
 *
 *    Rev 1.2   03 Jul 1997 13:29:10   AK
 * SFR0000: Initial development completed
**/
/**MOD-**********************************************************************/

#include <adcg.h>

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Determine our target OS and include the appropriate header file.         */
/* Currently we support:                                                    */
/*                                                                          */
/* Windows NT : wtrcdata.c                                                  */
/* UNIX       : xtrcdata.c                                                  */
/* MacOS 7    : mtrcdata.c                                                  */
/*                                                                          */
/****************************************************************************/
#ifdef OS_WIN32
#include <wtrcdata.c>
#elif defined( OS_UNIX )
#include <xtrcdata.c>
#elif defined( OS_MAC7 )
#include <mtrcdata.c>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\trace\ntrcint.h ===
/**INC+**********************************************************************/
/* Header:    ntrcint.h                                                     */
/*                                                                          */
/* Purpose:   Internal tracing functions header - Windows NT specific       */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/trc/ntrcint.h_v  $
 *
 *    Rev 1.6   28 Aug 1997 14:52:26   ENH
 * SFR1189: Added TRACE_REG_PREFIX
 *
 *    Rev 1.5   22 Aug 1997 10:22:04   SJ
 * SFR1316: Trace options in wrong place in the registry.
 *
 *    Rev 1.4   12 Aug 1997 09:52:14   MD
 * SFR1002: Remove kernel tracing code
 *
 *    Rev 1.3   09 Jul 1997 18:02:46   AK
 * SFR1016: Initial changes to support Unicode
 *
 *    Rev 1.2   03 Jul 1997 13:28:40   AK
 * SFR0000: Initial development completed
 *
 *    Rev 1.1   20 Jun 1997 10:25:50   KH
 * Win16Port: Contains 32 bit specifics only
**/
/**INC-**********************************************************************/

#ifndef _H_NTRCINT
#define _H_NTRCINT

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/*                                                                          */
/* MACROS                                                                   */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Macro to create the mutex which protects the shared data memory mapped   */
/* file.                                                                    */
/****************************************************************************/
#define TRCCreateMutex(a,b,c) (CreateMutex(a,b,c))

/****************************************************************************/
/* Macro to get the mutex which protects the shared data memory mapped      */
/* file.  By getting this semaphore we are serializing access to the trace  */
/* buffer and the trace configuration (e.g.  trace level, prefix list).     */
/*                                                                          */
/* We use the standard Win32 WaitForSingleObject function to wait for the   */
/* mutex.  The wait function requests ownership of the mutex for us.  If    */
/* the mutex is nonsignaled then we enter an efficient wait state which     */
/* consumes very little processor time while waiting for the mutex to       */
/* become signaled.                                                         */
/****************************************************************************/
#define TRCGrabMutex()             WaitForSingleObject(trchMutex, INFINITE)

/****************************************************************************/
/* Macro to free the mutex.  Use the standard Win32 ReleaseMutex function.  */
/****************************************************************************/
#define TRCReleaseMutex()          ReleaseMutex(trchMutex)

/****************************************************************************/
/* Trace a string out to the debugger.                                      */
/****************************************************************************/
#define TRCDebugOutput(pText)                                                \
{                                                                            \
    OutputDebugString(pText);                                                \
}

/****************************************************************************/
/* Get the current process Id using the Win32 GetCurrentProcessId function. */
/****************************************************************************/
#define TRCGetCurrentProcessId()   GetCurrentProcessId()

/****************************************************************************/
/* Get the thread process Id using the Win32 GetCurrentThreadId function.   */
/****************************************************************************/
#define TRCGetCurrentThreadId()    GetCurrentThreadId()

/****************************************************************************/
/* Define our own beep macro.                                               */
/****************************************************************************/
#define TRCBeep()                  MessageBeep(0)

/****************************************************************************/
/* Define our debug break macro.                                            */
/****************************************************************************/
DCVOID DCINTERNAL TRCDebugBreak(DCVOID);

/****************************************************************************/
/* Ducati registry prefix.                                                  */
/****************************************************************************/
#define TRACE_REG_PREFIX      _T("SOFTWARE\\Microsoft\\Terminal Server Client\\")

#define TRC_SUBKEY_NAME  (TRACE_REG_PREFIX TRC_INI_SECTION_NAME)       

/****************************************************************************/
/* Macro to close the mutex object.                                         */
/****************************************************************************/
#define TRCCloseHandle(handle) CloseHandle(handle)

#endif /* _H_NTRCINT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\trace\wtrcrc.h ===
/**INC+**********************************************************************/
/* Header:    wtrcrc.h                                                      */
/*                                                                          */
/* Purpose:   Trace DLL resource header file                                */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log$
**/
/**INC-**********************************************************************/

#define TRC_IDD_ASSERT   1000
#define TRC_ID_TEXT      1001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\trace\ezippy\ezippy.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    eZippy Main

Abstract:

    Entrypoint for eZippy.

Author:

    Marc Reyhner 8/28/00

--*/

#include "stdafx.h"
#include "eZippy.h"
#include "ZippyWindow.h"
#include "TraceManager.h"
#include "resource.h"

// instantiation of the g_hInstance variable
HINSTANCE g_hInstance = NULL;

int
WINAPI WinMain(
	IN HINSTANCE hInstance, 
	IN HINSTANCE hPrevInstance, 
	IN LPSTR lpCmdLine,
	IN int nCmdShow
	)

/*++

Routine Description:

    This sets up the trace manager and the zippy window then does
    the event loop.

Arguments:

    See win32 WinMain docs

Return value:
    
    0 - Success

    Non zero - some error

--*/
{
	INITCOMMONCONTROLSEX controlStruct;
    MSG msg;
    DWORD dwResult;
	CZippyWindow mainWindow;
    CTraceManager tracer;
    LPTSTR lpstrCmdLine;
    HACCEL hAccel;

    g_hInstance = hInstance;

    
    controlStruct.dwSize = sizeof(controlStruct);
    controlStruct.dwICC = ICC_BAR_CLASSES;
    
    InitCommonControlsEx(&controlStruct);

    CTraceManager::_InitTraceManager();
    
	dwResult = mainWindow.Create(&tracer);
    if (lpCmdLine && lpCmdLine[0]) {
        // kill any leading and trailing " marks
        lpstrCmdLine = GetCommandLine();
        if (lpstrCmdLine[0] == '"') {
            lpstrCmdLine++;
            lpstrCmdLine[_tcslen(lpstrCmdLine)-1] = 0;
        }
        mainWindow.LoadConfFile(lpstrCmdLine);
    }

    tracer.StartListenThread(&mainWindow);

    if (dwResult) {
        return dwResult;
    }

    hAccel = LoadAccelerators(hInstance,MAKEINTRESOURCE(IDR_ACCELERATOR));

    while (0 < GetMessage(&msg,NULL,0,0)) {
        if (mainWindow.IsDialogMessage(&msg)) {
            // if it is a dialog message we are done
            // processing this message
            continue;
        }
        if (!mainWindow.TranslateAccelerator(hAccel,&msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    CTraceManager::_CleanupTraceManager();
    return 0;
}

INT
LoadStringSimple(
    IN UINT uID,
    OUT LPTSTR lpBuffer
    )

/*++

Routine Description:

    This will load the given string from the applications string table.  If
    it is longer than MAX_STR_LEN it is truncated.  lpBuffer should be at least
    MAX_STR_LEN characters long.  If the string does not exist we return 0
    and set the buffer to IDS_STRINGMISSING, if that failes then we set it to the
    hard coded STR_RES_MISSING.

Arguments:

    uID - Id of the resource to load.

    lpBuffer - Buffer of MAX_STR_LEN to hold the string

Return value:
    
    0 - String resource could not be loaded.

    postive integer - length of the string loaded.

--*/
{
    INT length;
    
    length = LoadString(g_hInstance,uID,lpBuffer,MAX_STR_LEN);
    if (length == 0) {
        length = LoadString(g_hInstance,IDS_STRINGMISSING,lpBuffer,MAX_STR_LEN);
        if (length == 0) {
            _tcscpy(lpBuffer,_T(""));
        }
        length = 0;
    }

    return length;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\trace\wtrcint.c ===
/**MOD+**********************************************************************/
/* Module:    wtrcint.c                                                     */
/*                                                                          */
/* Purpose:   Internal tracing functions - Windows specific.                */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/trc/wtrcint.c_v  $
 *
 *    Rev 1.10   22 Aug 1997 15:11:48   SJ
 * SFR1291: Win16 Trace DLL doesn't write integers to ini file properly
 *
 *    Rev 1.9   09 Jul 1997 18:03:42   AK
 * SFR1016: Initial changes to support Unicode
 *
 *    Rev 1.8   03 Jul 1997 13:29:04   AK
 * SFR0000: Initial development completed
**/
/**MOD-**********************************************************************/

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/
#include <adcg.h>

/****************************************************************************/
/* Define TRC_FILE and TRC_GROUP.                                           */
/****************************************************************************/
#define TRC_FILE    "wtrcint"
#define TRC_GROUP   TRC_GROUP_TRACE

/****************************************************************************/
/* Trace specific includes.                                                 */
/*                                                                          */
/* Note that including atrcapi.h automatically includes wtrcapi.h for us.   */
/****************************************************************************/
#include <atrcapi.h>
#include <atrcint.h>
#include <wtrcrc.h>

#include <ndcgver.h>

/****************************************************************************/
/*                                                                          */
/* DATA                                                                     */
/*                                                                          */
/****************************************************************************/
#define DC_INCLUDE_DATA
#include <atrcdata.c>
#undef DC_INCLUDE_DATA

/****************************************************************************/
/*                                                                          */
/* FUNCTIONS                                                                */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* FUNCTION: TRCGetModuleFileName(...)                                      */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function gets the DLL module file name, without path or extension.  */
/* Global trchModule must contain the library module handle (WIN32) or      */
/* instance handle (WIN16).                                                 */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* pModuleName  : address of buffer into which the module name is written.  */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* DC_RC_OK is successful, error code otherwise.                            */
/*                                                                          */
/****************************************************************************/
DCUINT DCINTERNAL TRCGetModuleFileName(PDCTCHAR pModuleName,
                                       UINT cchModuleName)
{
    DCINT rc = DC_RC_OK;
    PDCTCHAR pTemp;
    PDCTCHAR pName;
    DCTCHAR  pModuleFileName[TRC_FILE_NAME_SIZE];
    HRESULT hr;

    /************************************************************************/
    /* Get the trace DLL module file name.  We use this later when we get a */
    /* stack trace.                                                         */
    /************************************************************************/
    if ( GetModuleFileName(trchModule,
                           pModuleFileName,
                           TRC_FILE_NAME_SIZE) != 0 )
    {
        /********************************************************************/
        /* The module file name is currently in the form of a complete      */
        /* path - however we only want the actual module name.              */
        /********************************************************************/
        pName = pModuleFileName;
        pTemp = DC_TSTRCHR(pName, _T('\\'));
        while (NULL != pTemp)
        {
            pName = pTemp + 1;
            pTemp = DC_TSTRCHR(pName, _T('\\'));
        }

        /********************************************************************/
        /* Now remove the file name extension - we do this by replacing     */
        /* the decimal point with a null.                                   */
        /********************************************************************/
        pTemp = DC_TSTRCHR(pName, _T('.'));
        if (NULL != pTemp)
        {
            *pTemp = _T('\0');
        }

        /********************************************************************/
        /* Finally copy what remains into the caller's buffer               */
        /********************************************************************/
        hr = StringCchCopy(pModuleName, cchModuleName, pName);
        if (FAILED(hr)) {
            rc = TRC_RC_IO_ERROR;
        }
    }
    else
    {
        rc = TRC_RC_IO_ERROR;
    }

    return(rc);
}

/**PROC+*********************************************************************/
/* Name:      TRCAssertDlgProc                                              */
/*                                                                          */
/* Purpose:   Dialog Proc for assert box                                    */
/*                                                                          */
/* Returns:   TRUE / FALSE                                                  */
/*                                                                          */
/* Params:    IN  usual Windows parameters                                  */
/*                                                                          */
/**PROC-*********************************************************************/
INT_PTR CALLBACK TRCAssertDlgProc(HWND hwndDlg,
                                  UINT msg,
                                  WPARAM wParam,
                                  LPARAM lParam)
{
    INT_PTR rc = FALSE;
    RECT rect;
    DCINT xPos;
    DCINT yPos;
    PDCTCHAR pText;

    switch (msg)
    {
        case WM_INITDIALOG:
        {
            /****************************************************************/
            /* Set the text                                                 */
            /****************************************************************/
            pText = (PDCTCHAR)lParam;
            SetDlgItemText(hwndDlg, TRC_ID_TEXT, pText);
            SetWindowText(hwndDlg, TRC_ASSERT_TITLE);

            /****************************************************************/
            /* Center on the screen, and set to topmost.                    */
            /****************************************************************/
            GetWindowRect(hwndDlg, &rect);

            xPos = ( GetSystemMetrics(SM_CXSCREEN) -
                     (rect.right - rect.left)) / 2;
            yPos = ( GetSystemMetrics(SM_CYSCREEN) -
                     (rect.bottom - rect.top)) / 2;

            SetWindowPos(hwndDlg,
                         HWND_TOPMOST,
                         xPos, yPos,
                         rect.right - rect.left,
                         rect.bottom - rect.top,
                         SWP_NOACTIVATE);
            rc = TRUE;
        }
        break;

        case WM_COMMAND:
        {
            switch(DC_GET_WM_COMMAND_ID(wParam))
            {
                case IDABORT:
                case IDRETRY:
                case IDIGNORE:
                {
                    PostMessage(hwndDlg,
                                WM_USER + DC_GET_WM_COMMAND_ID(wParam),
                                0, 0);
                    rc = TRUE;
                }
                break;

                default:
                {
                    /********************************************************/
                    /* Ignore other messages                                */
                    /********************************************************/
                }
                break;
            }
        }

        case WM_CLOSE:
        {
            /****************************************************************/
            /* If 'x' selected, treat as 'Ignore'                           */
            /****************************************************************/
            PostMessage(hwndDlg, WM_USER + IDIGNORE, 0, 0);
        }
        break;

        default:
        {
            /****************************************************************/
            /* Ignore                                                       */
            /****************************************************************/
        }
        break;
    }

    return(rc);

} /* TRCAssertDlgProc */


/****************************************************************************/
/* FUNCTION: TRCDisplayAssertBox(...)                                       */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function displays an assert box and then decides (based on the user */
/* action) whether to kill the thread, jump into a debugger or just ignore  */
/* the assert.                                                              */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* pText           : a pointer to the null-terminated assert text string.   */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCDisplayAssertBox(PDCTCHAR pText)
{
    HWND  hwndDlg;
    MSG   msg;
    DCINT rc;
    HRESULT hr;
    TCHAR szFormattedText[TRC_FRMT_BUFFER_SIZE];

    /************************************************************************/
    /* If we are not currently displaying an assert dialog box then display */
    /* one.  This function will display an assert box and then handle the   */
    /* user action (i.e.  whether we kill the thread, jump into the         */
    /* debugger or just ignore (!) the assert).                             */
    /*                                                                      */
    /* Note that the testing and setting of the flag is not done under a    */
    /* mutex and therefore can potentially be preempted.  There is          */
    /* therefore the possibility that multiple threads can assert           */
    /* simulataneously (a rare occurance) and thus we end up with multiple  */
    /* assert dialogs on the screen.  However we avoid the cascading assert */
    /* problem.                                                             */
    /************************************************************************/
    if (TEST_FLAG(trcpFilter->trcStatus, TRC_STATUS_ASSERT_DISPLAYED))
    {
        DC_QUIT;
    }

    /************************************************************************/
    /* Set the flag to indicate that an assert is currently displayed,      */
    /* display the assert and then clear the flag.                          */
    /************************************************************************/
    SET_FLAG(trcpFilter->trcStatus, TRC_STATUS_ASSERT_DISPLAYED);

    /************************************************************************/
    /* To prevent re-entrancy, do not use MessageBox.  Create a dialog and  */
    /* use a message loop to handle this until it has been dismissed.  Note */
    /* that this will block the thread which issued the assert.             */
    /* Pass the assert text to the dialog's WM_INITDDIALOG callback.        */
    /************************************************************************/
    hwndDlg = CreateDialogParam(trchModule,
                                MAKEINTRESOURCE(TRC_IDD_ASSERT),
                                NULL,
                                TRCAssertDlgProc,
                                (LPARAM)(pText));

    if (hwndDlg == NULL)
    {
        /********************************************************************/
        /* Use Message Box - but note that this will give reentrancy        */
        /* problems.  Since the choice on this dialog is                    */
        /* Abort/Retry/Ignore, we add an explanatory message to the effect  */
        /* that 'Retry' is really 'Debug'.                                  */
        /********************************************************************/
        
        hr = StringCchPrintf(szFormattedText,
                             SIZE_TCHARS(szFormattedText),
                             _T("%s %s"),
                             pText,
                             TRC_ASSERT_TEXT2);

        if (SUCCEEDED(hr)) {
            rc = MessageBox(NULL,
                            pText,
                            TRC_ASSERT_TITLE,
                            MB_ABORTRETRYIGNORE | MB_ICONSTOP |
                            MB_SETFOREGROUND);
        }
        else {
            DC_QUIT;
        }
    }
    else
    {
        /********************************************************************/
        /* Show the dialog.                                                 */
        /********************************************************************/
        ShowWindow(hwndDlg, SW_SHOW);

        /********************************************************************/
        /* Only pull off messages for this dialog.                          */
        /********************************************************************/
        while (GetMessage (&msg, hwndDlg, 0, 0))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);

            /****************************************************************/
            /* WM_USER + ID??? is used to terminate processing.             */
            /****************************************************************/
            if (msg.message >= WM_USER)
            {
                /************************************************************/
                /* finished                                                 */
                /************************************************************/
                EndDialog(hwndDlg, IDOK);
                break;
            }
        }

        /********************************************************************/
        /* Get the return code from the message ID                          */
        /********************************************************************/
        if (msg.message >= WM_USER)
        {
            rc = msg.message - WM_USER;
        }
        else
        {
            /****************************************************************/
            /* WM_QUIT - treat as an Abort.                                 */
            /****************************************************************/
            rc = IDABORT;
        }
    }

    /************************************************************************/
    /* Now that the assert box is no more, clear the flag.                  */
    /************************************************************************/
    CLEAR_FLAG(trcpFilter->trcStatus, TRC_STATUS_ASSERT_DISPLAYED);

    /************************************************************************/
    /* Switch on the return code from MessageBox.                           */
    /************************************************************************/
    switch (rc)
    {
        case IDABORT:
        {
            /****************************************************************/
            /* Abort selected - so exit the current thread.                 */
            /****************************************************************/
            TRCExitProcess(TRC_THREAD_EXIT);
        }
        break;

        case IDRETRY:
        {
            /****************************************************************/
            /* Retry selected - jump into the debugger if JIT (Just In      */
            /* Time) debugging is enabled.                                  */
            /****************************************************************/
            DebugBreak();
        }
        break;

        case IDIGNORE:
        {
            /****************************************************************/
            /* Ignore selected - just blindly carry on...                   */
            /****************************************************************/
        }
        break;
    }

DC_EXIT_POINT:
    return;

} /* TRCDisplayAssertBox */

/****************************************************************************/
/* FUNCTION: TRCInternalTrace(...)                                          */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function writes a string to the debugger on every process attach    */
/* detach.  Note that in general the mutex will not have been obtained      */
/* when this function is called.                                            */
/*                                                                          */
/* The problem with this function is that DllMain will call this function   */
/* every time a thread attaches / detaches at which point it has the        */
/* process critical section.  However we may be in the middle of a stack    */
/* trace on another thread and holding the trace mutex.  Stack tracing      */
/* requires the process critical section while holding the trace mutex      */
/* which deadlocks if DllMain is waiting on the trace mutex.                */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* type            : is this an process/thread attach/detach or a symbols   */
/*                   loading/loaded/unloaded.                               */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCInternalTrace(DCUINT32 type)
{
    PDCTCHAR  pStatus;
    DC_DATE  theDate;
    DC_TIME  theTime;
    DCUINT32 processId;
    DCUINT32 threadId;
    DCUINT32 length;
    DCTCHAR   szOutputBuffer[TRC_FRMT_BUFFER_SIZE];
    HRESULT  hr;

    /************************************************************************/
    /* Determine whether this is an attach or a detach.                     */
    /************************************************************************/
    switch (type)
    {
        case TRC_TRACE_DLL_INITIALIZE:
        {
            pStatus = _T("Trace initialized");
        }
        break;

        case TRC_TRACE_DLL_TERMINATE:
        {
            pStatus = _T("Trace terminated ");
        }
        break;

        case TRC_PROCESS_ATTACH_NOTIFY:
        {
            pStatus = _T("Process attached ");
        }
        break;

        case TRC_PROCESS_DETACH_NOTIFY:
        {
            pStatus = _T("Process detached ");
        }
        break;

        case TRC_THREAD_ATTACH_NOTIFY:
        {
            pStatus = _T("Thread attached  ");
        }
        break;

        case TRC_THREAD_DETACH_NOTIFY:
        {
            pStatus = _T("Thread detached  ");
        }
        break;

        case TRC_SYMBOLS_LOADING_NOTIFY:
        {
            pStatus = _T("Loading symbols  ");
        }
        break;

        case TRC_SYMBOLS_LOADED_NOTIFY:
        {
            pStatus = _T("Symbols loaded   ");
        }
        break;

        case TRC_SYMBOLS_UNLOAD_NOTIFY:
        {
            pStatus = _T("Symbols freed    ");
        }
        break;

        case TRC_FILES_RESET:
        {
            pStatus = _T("Trace files reset");
        }
        break;

        default:
        {
            pStatus = _T("Undefined       ");
        }
        break;
    }

    /************************************************************************/
    /* Get the current date and time.                                       */
    /************************************************************************/
    TRCGetCurrentDate(&theDate);
    TRCGetCurrentTime(&theTime);

    /************************************************************************/
    /* Get our process and thread IDs.                                      */
    /************************************************************************/
    processId = TRCGetCurrentProcessId();
    threadId  = TRCGetCurrentThreadId();

    /************************************************************************/
    /* Format the attach/detach string.                                     */
    /************************************************************************/
    hr = StringCchPrintf(
                    szOutputBuffer,
                    SIZE_TCHARS(szOutputBuffer),
                    _T("### %s (") TRC_PROC_FMT _T(":") TRC_THRD_FMT _T(") at ")
                    _T("") TRC_TIME_FMT _T(" ") TRC_DATE_FMT _T(" ###\r\n"),
                    pStatus,
                    processId,
                    threadId,
                    theTime.hour,
                    theTime.min,
                    theTime.sec,
                    theTime.hundredths,
                    theDate.day,
                    theDate.month,
                    theDate.year
                    );

    if (SUCCEEDED(hr)) {
        /************************************************************************/
        /* Now output this string to the debugger.  We can't output this to     */
        /* file as we need to have the trace mutex to do that and we may not    */
        /* have the mutex.  To avoid confusion we only write to the debugger.   */
        /************************************************************************/
        length = DC_TSTRLEN(szOutputBuffer);
        OutputDebugString(szOutputBuffer);
    }

    return;

} /* TRCInternalTrace */

/****************************************************************************/
/* FUNCTION: TRCMaybeSwapFile(...)                                          */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function checks if the current trace file has enough space to       */
/* accomodate a string of the supplied length and, if not, makes the other  */
/* trace file current.                                                      */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* length          : length of the string.                                  */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCMaybeSwapFile(DCUINT length)
{
    /************************************************************************/
    /* If the length of the string plus the offset is greater than the      */
    /* length of the trace file then we need to swap trace files.           */
    /************************************************************************/
    if ((trcpSharedData->trcOffset + length) > trcpConfig->maxFileSize)
    {
        /********************************************************************/
        /* We need to swap trace files so set the offset to 0 and then      */
        /* flip the trace file.                                             */
        /********************************************************************/
        trcpSharedData->trcOffset = 0;
        trcpSharedData->trcIndicator++;
        trcpSharedData->trcIndicator %= TRC_NUM_FILES;

        /********************************************************************/
        /* Now we need to reset the new trace file by blanking it out.      */
        /********************************************************************/
        TRCBlankFile(trcpSharedData->trcIndicator);
    }

DC_EXIT_POINT:
    return;

} /* TRCOutputToFile */

/****************************************************************************/
/* FUNCTION: TRCReadProfInt(...)                                            */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This reads a private profile integer from the registry.                  */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* pSection        : section containing the entry to read                   */
/* pEntry          : entry name of integer to retrieve                      */
/* pValue          : buffer to return the entry in                          */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* 0               : success                                                */
/* TRC_RC_IO_ERROR : I/O error.                                             */
/*                                                                          */
/****************************************************************************/
DCUINT DCINTERNAL TRCReadProfInt(PDCTCHAR  pEntry,
                                 PDCUINT32 pValue)
{
    DCUINT rc = 0;

    /************************************************************************/
    /* First try to read the value from the current user section            */
    /************************************************************************/
    rc = TRCReadEntry(HKEY_CURRENT_USER,
                      pEntry,
                      (PDCTCHAR)pValue,
                      sizeof(*pValue),
                      REG_DWORD);
    if (0 != rc)
    {
        /********************************************************************/
        /* Couldn't read the value from the current user section.  Try to   */
        /* pick up a default value from the local machine section.          */
        /********************************************************************/
        rc = TRCReadEntry(HKEY_LOCAL_MACHINE,
                          pEntry,
                          (PDCTCHAR)pValue,
                          sizeof(*pValue),
                          REG_DWORD);
        if (0 != rc)
        {
            /****************************************************************/
            /* There is nothing we can do so just fall through.             */
            /****************************************************************/
        }
    }

    return(rc);

} /* TRCReadProfInt */

/****************************************************************************/
/* FUNCTION: TRCReadProfString(...)                                         */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This reads a private profile string from registry.                       */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* pSection        : section containing the entry to read.                  */
/* pEntry          : entry name of string to retrieve (if NULL all entries  */
/*                   in the section are returned).                          */
/* pBuffer         : buffer to return the entry in.                         */
/* bufferSize      : size of the buffer in bytes.                           */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* 0               : success.                                               */
/* TRC_RC_IO_ERROR : I/O error.                                             */
/*                                                                          */
/****************************************************************************/
DCUINT DCINTERNAL TRCReadProfString(PDCTCHAR pEntry,
                                    PDCTCHAR pBuffer,
                                    DCINT16 bufferSize)
{
    DCUINT rc                = 0;

    /************************************************************************/
    /* First try to read the value from the current user section.           */
    /************************************************************************/
    rc = TRCReadEntry(HKEY_CURRENT_USER,
                      pEntry,
                      pBuffer,
                      bufferSize,
                      REG_SZ);
    if (0 != rc)
    {
        /********************************************************************/
        /* Couldn't read the value from the current user section.  Try to   */
        /* pick up a default value from the local machine section.          */
        /********************************************************************/
        rc = TRCReadEntry(HKEY_LOCAL_MACHINE,
                          pEntry,
                          pBuffer,
                          bufferSize,
                          REG_SZ);
        if (0 != rc)
        {
            /****************************************************************/
            /* There is nothing we can do so just fall through.             */
            /****************************************************************/
        }
    }

    return(rc);

} /* TRCReadProfString */

/****************************************************************************/
/* FUNCTION: TRCResetTraceFiles(...)                                        */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function resets the trace files.  It nulls out both trace files     */
/* and then resets the file offset to 0 and the file indicator to file 0.   */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCResetTraceFiles(DCVOID)
{
    DCUINT i;

    /************************************************************************/
    /* Blank out the trace files.  Note that we must have the mutex at this */
    /* point.                                                               */
    /************************************************************************/
    for (i = 0; i < TRC_NUM_FILES; i++)
    {
        TRCBlankFile(i);
    }

    /************************************************************************/
    /* Set the trace file indicator to file 0 and set the file offset to 0. */
    /************************************************************************/
    trcpSharedData->trcIndicator = 0;
    trcpSharedData->trcOffset    = 0;

    /************************************************************************/
    /* Output a debug string.                                               */
    /************************************************************************/
    TRCInternalTrace(TRC_FILES_RESET);

} /* TRCResetTraceFiles */

/****************************************************************************/
/* FUNCTION: TRCWriteProfInt(...)                                           */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This writes a private profile integer to the registry.                   */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* pSection        : section containing the entry written                   */
/* pEntry          : entry name of integer to write.  If the entry does not */
/*                   exist it is created and if it is NULL the entire       */
/*                   section is deleted.                                    */
/* pValue          : pointer to the integer to be written.  If the pointer  */
/*                   is NULL the entry is deleted.                          */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* 0               : success                                                */
/* TRC_RC_IO_ERROR : I/O error.                                             */
/*                                                                          */
/****************************************************************************/
DCUINT DCINTERNAL TRCWriteProfInt(PDCTCHAR  pEntry,
                                  PDCUINT32 pValue)
{
    DCUINT rc = 0;

    /************************************************************************/
    /* Write the entry to the current user section.                         */
    /************************************************************************/
    rc = TRCWriteEntry(HKEY_CURRENT_USER,
                       pEntry,
                       (PDCTCHAR)pValue,
                       sizeof(DCINT),
                       REG_DWORD);
    if (0 != rc)
    {
        TRCDebugOutput(_T("Failed to write int"));
    }

    return(rc);

} /* TRCWriteProfInt */

/****************************************************************************/
/* FUNCTION: TRCWriteProfString(...)                                        */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This writes a private profile string to the registry.                    */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* pSection        : section containing the entry written                   */
/* pEntry          : entry name of string to write.  If the entry does not  */
/*                   exist it is created and if it is NULL the entire       */
/*                   section is deleted.                                    */
/* pBuffer         : buffer containing the entry.  If the buffer is NULL    */
/*                   the entry is deleted.                                  */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* 0               : success                                                */
/* TRC_RC_IO_ERROR : I/O error.                                             */
/*                                                                          */
/****************************************************************************/
DCUINT DCINTERNAL TRCWriteProfString(PDCTCHAR pEntry,
                                     PDCTCHAR pBuffer)
{
    DCUINT rc = 0;

    /************************************************************************/
    /* Write the entry to the current user section                          */
    /************************************************************************/
    rc = TRCWriteEntry(HKEY_CURRENT_USER,
                       pEntry,
                       pBuffer,
                       DC_TSTRBYTELEN(pBuffer),
                       REG_SZ);
    if (0 != rc)
    {
        TRCDebugOutput(_T("Failed to write string"));
    }

    return(rc);

} /* TRCWriteProfString */

#include <ntrcint.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\trace\ezippy\ezippy.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    eZippy Main

Abstract:

    Global variables and functions for zippy.

Author:

    Marc Reyhner 8/28/2000

--*/

#ifndef __EZIPPY_H__
#define __EZIPPY_H__

#define MAX_STR_LEN 2048

#define ZIPPY_FONT                      _T("Courier New")
#define ZIPPY_FONT_SIZE                 8
#define ZIPPY_REG_KEY                   _T("SOFTWARE\\Microsoft\\eZippy")


extern HINSTANCE g_hInstance;


INT LoadStringSimple(UINT uID,LPTSTR lpBuffer);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\trace\ezippy\modaldialog.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Modal Dialog

Abstract:

    This contains the abstract class CModalDialog and the trivial sub class
    CModalOkDialog which does a simple ok dialog.

Author:

    Marc Reyhner 8/28/2000

--*/

#ifndef __MODALDIALOG_H__
#define __MODALDIALOG_H__



class CModalDialog  
{
public:
	INT_PTR DoModal(LPCTSTR lpTemplate, HWND hWndParent);
	
protected:
    virtual INT_PTR CALLBACK DialogProc(HWND hwndDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)=0;
	virtual INT_PTR OnCreate(HWND hWnd);

private:

    static INT_PTR CALLBACK _DialogProc(HWND hwndDlg,UINT uMsg,WPARAM wParam,LPARAM lParam);

};

class CModalOkDialog : public CModalDialog {

protected:
    
    virtual INT_PTR CALLBACK DialogProc(HWND hwndDlg,UINT uMsg,WPARAM wParam,LPARAM lParam);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\trace\ezippy\modaldialog.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Modal Dialog

Abstract:

    This contains the abstract class CModalDialog and the trivial sub class
    CModalOkDialog which does a simple ok dialog.

Author:

    Marc Reyhner 8/28/2000

--*/

#include "stdafx.h"
#include "ModalDialog.h"
#include "eZippy.h"

INT_PTR
CModalDialog::DoModal(
    IN LPCTSTR lpTemplate,
    IN HWND hWndParent
    )

/*++

Routine Description:

    This does a modal dialog from the given template.

Arguments:

    lpTemplate - Template to use see docs on DialogBoxParam

    hWndParent - Parent window for the dialog

Return value:
    
    Dialog return code see docs on DialogBoxParam

--*/
{
    return DialogBoxParam(g_hInstance,lpTemplate,hWndParent,_DialogProc,(LPARAM)this);
}

INT_PTR CALLBACK 
CModalDialog::_DialogProc(
    IN HWND hwndDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    If this is a WM_INITDIALOG OnCreate is called.  Otherwise the non-static
    DialogProc function is called.

Arguments:

    See win32 DialogProc docs

Return value:
    
    TRUE - Message was handles

    FALSE - We did not handle the message

--*/
{
    CModalDialog *rDialog;

    if (uMsg == WM_INITDIALOG) {
        rDialog = (CModalDialog*)lParam;
        SetWindowLongPtr(hwndDlg,DWLP_USER,lParam);
        return rDialog->OnCreate(hwndDlg);
    }
    rDialog = (CModalDialog*)GetWindowLongPtr(hwndDlg,DWLP_USER);
    if (!rDialog) {
        return FALSE;
    }
    return rDialog->DialogProc(hwndDlg,uMsg,wParam,lParam);
}

INT_PTR
CModalDialog::OnCreate(
    IN HWND hWnd
    )

/*++

Routine Description:

    Empty OnCreate handler for subclasses which don't want to overide this.
    There is no need for a subclass to call this function if it does something
    in OnCreate

Arguments:

    hWnd - the dialog window.

Return value:
    
    TRUE - Always return success (sets keyboard focus).

--*/
{
    return TRUE;
}

INT_PTR CALLBACK
CModalOkDialog::DialogProc(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    The one override for CModalOkDialog simply terminates
    the dialog when an IDOK or IDCANCEL command is received

Arguments:

    See win32 DialogProc docs

Return value:
    
    TRUE - We handled the message

    FALSE - We didn't handle the message

--*/
{
    WORD command;

    if (uMsg == WM_COMMAND) {
        command = LOWORD(wParam);
        if (command == IDOK||command==IDCANCEL) {
            EndDialog(hwndDlg,command);
            return TRUE;
        }

    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\trace\ezippy\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by eZippy.rc
//
#define IDS_ZIPPYWINDOWTITLE            1
#define IDS_STRINGMISSING               2
#define IDS_ZIPPYALREADYEXISTS          3
#define IDS_FILEOPENERROR               4
#define IDS_FILESAVEERROR               5
#define IDS_SAVEFILEPROMPT              6
#define IDS_SEARCHFAILURE               7
#define IDS_CLEARCONFIRMTITLE           8
#define IDS_CLEARCONFIRMMESSAGE         9
#define IDS_CONFIRMRESETTRACETITLE      10
#define IDS_CONFIRMRESETTRACEMESSAGE    11
#define IDS_ABOUTAPPTITLE               12
#define IDS_ABOUTOTHERSTUFF             13
#define IDS_TRACELEVELDETAILED          14
#define IDS_TRACELEVELNRM               15
#define IDS_TRACELEVELALERT             16
#define IDS_TRACELEVELERROR             17
#define IDS_TRACELEVELASSERT            18
#define IDS_TRACELEVELNONE              19
#define IDS_SETTINGSNOTNUMBER           20
#define IDS_STATUSBARREADY              21
#define IDS_FILELOADERROR               22
#define IDS_FILELOADOPENERROR           23
#define IDS_PREFERENCESDLGTITLE         24
#define IDI_MAINFRAME                   101
#define IDR_MAINMENU                    103
#define IDR_ACCELERATOR                 106
#define IDD_PROPPAGETRACE               106
#define IDD_TRACEOPTIONS                107
#define IDD_FILTEROPTIONS               109
#define IDD_RECORDTRACE                 112
#define IDD_PROPPAGEFILTER              113
#define IDD_PROPPAGE_MEDIUM             114
#define IDD_PROPPAGE_LARGE              115
#define IDC_FILTERLEVEL                 1002
#define IDC_FILTERLEVELDESC             1003
#define IDC_GROUPNETWORK                1005
#define IDC_GROUPSECURITY               1006
#define IDC_GROUPCORE                   1007
#define IDC_GROUPUI                     1008
#define IDC_GROUPUTILITIES              1009
#define IDC_COMBO1                      1010
#define IDC_UNUSED1                     1011
#define IDC_GROUPUNUSED1                1011
#define IDC_UNUSED2                     1012
#define IDC_GROUPUNUSED2                1012
#define IDC_UNUSED3                     1013
#define IDC_GROUPUNUSED3                1013
#define IDC_UNUSED4                     1014
#define IDC_GROUPUNUSED4                1014
#define IDC_UNUSED5                     1015
#define IDC_GROUPUNUSED5                1015
#define IDC_SELECTALL                   1016
#define IDC_CLEARALL                    1017
#define IDC_OUTPUT_FILE                 1019
#define IDC_OUTPUT_DEBUGGER             1020
#define IDC_ERROR_BEEP                  1021
#define IDC_ERROR_BREAK                 1022
#define IDC_OPTION_PROFILE              1023
#define IDC_OPTION_FLUSH                1024
#define IDC_OPTION_STACK                1025
#define IDC_OPTION_STAMP                1026
#define IDC_OPTION_PROCID               1027
#define IDC_OPTION_THREAID              1028
#define IDC_FUNCTION_LENGTH             1029
#define IDC_TRUNCATION_LENGTH           1030
#define IDC_FILTERPREFIX                1031
#define ID_HELP_ABOUTEZIPPY             40001
#define ID_FILE_SAVEAS                  40003
#define ID_FILE_EXIT                    40004
#define ID_MONITORING_START             40005
#define ID_MONITORING_STOP              40006
#define ID_VIEW_STATUSBAR               40008
#define ID_EDIT_SELECTALL               40013
#define ID_MONITORING_CLEARSCREEN       40018
#define ID_MONITORING_RESETTRACEFILES   40019
#define ID_EDIT_FINDNEXT                40021
#define ID_OPTIONS_FILTEROPTIONS        40025
#define ID_OPTIONS_FILTER               40026
#define ID_OPTIONS_TRACE                40027
#define ID_FILE_LOADCONF                40028
#define ID_FILE_SAVECONF                40029
#define ID_FILE_SAVECONFAS              40030
#define ID_MONITORING_RECORD            40031
#define ID_MONITORING_PREFERENCES       40037

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        119
#define _APS_NEXT_COMMAND_VALUE         40038
#define _APS_NEXT_CONTROL_VALUE         1033
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\trace\ezippy\stdafx.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    StdAfx

Abstract:

    Precompiled headers module.

Author:

    Marc Reyhner 7/5/2000

--*/

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <windows.h>
#include <tchar.h>
#include <CommCtrl.h>
#include <RichEdit.h>
#include <RichOle.h>

// We include this to get things like ID_EDIT_COPY
#include <AfxRes.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\trace\ezippy\stdafx.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    StdAfx

Abstract:

    Precompiled headers module.

Author:

    Marc Reyhner 7/5/2000

--*/

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\trace\ezippy\optionsdialog.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Options Dialog

Abstract:

    This class implements the options dialog which sets the
    tracing properties

Author:

    Marc Reyhner 9/12/2000

--*/

#ifndef __OPTIONSDIALOG_H__
#define __OPTIONSDIALOG_H__

class CTraceManager;

class COptionsDialog  
{
public:
	COptionsDialog(CTraceManager *rTracer);
	
    virtual VOID DoDialog(HWND hWndParent);

private:

    HWND m_hFilterDlg;
    HWND m_hTraceDlg;
    HWND m_hFilterSliderControl;
    CTraceManager *m_rTracer;

    static INT_PTR CALLBACK _FilterDialogProc(HWND hwndDlg,UINT uMsg,WPARAM wParam,LPARAM lParam);
    static INT_PTR CALLBACK _TraceDialogProc(HWND hwndDlg,UINT uMsg,WPARAM wParam,LPARAM lParam);

    INT_PTR CALLBACK FilterDialogProc(HWND hwndDlg,UINT uMsg,WPARAM wParam,LPARAM lParam);
    INT_PTR CALLBACK TraceDialogProc(HWND hwndDlg,UINT uMsg,WPARAM wParam,LPARAM lParam);
    INT_PTR OnCreateFilter(HWND hWnd);
    INT_PTR OnCreateTrace(HWND hWnd);
    BOOL TraceVerifyParameters();
	BOOL OnTraceOk();
	VOID OnFilterOk();
	VOID OnFilterSliderMove();
    VOID OnFilterClearAll();
	VOID OnFilterSelectAll();
    BOOL VerifyNumberFormat(LPCTSTR numberFormat);
    VOID LoadPrefixMRU(LPCTSTR currentPrefix);
    VOID StorePrefixMRU(LPCTSTR currentPrefix);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\trace\ezippy\optionsdialog.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Options Dialog

Abstract:

    This class implements the options dialog which sets the
    tracing properties

Author:

    Marc Reyhner 9/12/2000

--*/

#include "stdafx.h"
#include "OptionsDialog.h"
#include "eZippy.h"
#include "TraceManager.h"
#include "windows.h"
#include "resource.h"

#define MAX_MRU                 10
#define MRU_STR_PREFIX          _T("PrefixMru")
#define MRU_STR_BUFFER_SIZE     12

COptionsDialog::COptionsDialog(
    IN CTraceManager *rTracer
    )

/*++

Routine Description:

    This just sets the pointer to the trace manager.

Arguments:

    rTracer - Pointer to the trace manager class

Return value:
    
    None

--*/
{
    m_rTracer = rTracer;
}


VOID
COptionsDialog::DoDialog(
    IN HWND hWndParent
    )

/*++

Routine Description:

    This does the dialog modally. We fill in the fields for the two property
    sheet pages and then do the property sheet.  When the user hits OK
    the pages themselves take care of applying the settings.

Arguments:

    hWndParent - Parent window for the dialog

Return value:
    
    None - Since we handle applying the settings within the class
           as well as error UI there is no need for a return value.

--*/
{
    PROPSHEETPAGE pages[2];
    PROPSHEETHEADER psh;
    TCHAR caption[MAX_STR_LEN];

    // filter tab
    pages[0].dwSize = sizeof(PROPSHEETPAGE);
    pages[0].dwFlags = PSP_DEFAULT;
    pages[0].hInstance = g_hInstance;
    pages[0].pszTemplate = MAKEINTRESOURCE(IDD_PROPPAGEFILTER);
    pages[0].pfnDlgProc = _FilterDialogProc;
    pages[0].lParam = (LPARAM)this;

    // trace tab
    pages[1].dwSize = sizeof(PROPSHEETPAGE);
    pages[1].dwFlags = PSP_DEFAULT;
    pages[1].hInstance = g_hInstance;
    pages[1].pszTemplate = MAKEINTRESOURCE(IDD_PROPPAGETRACE);
    pages[1].pfnDlgProc = _TraceDialogProc;
    pages[1].lParam = (LPARAM)this;

    // header

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_NOCONTEXTHELP|PSH_PROPSHEETPAGE|PSH_NOAPPLYNOW;
    psh.hwndParent = hWndParent;
    psh.hInstance = g_hInstance;
    LoadStringSimple(IDS_PREFERENCESDLGTITLE,caption);
    psh.pszCaption = caption;
    psh.nPages = 2;
    psh.nStartPage = 0;
    psh.ppsp = pages;

    PropertySheet(&psh);
}

INT_PTR CALLBACK
COptionsDialog::_FilterDialogProc(
    IN HWND hwndDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    If this is a WM_INITDIALOG OnCreate is called.  Otherwise the non-static
    DialogProc function is called.

Arguments:

    See win32 DialogProc docs

Return value:
    
    TRUE - Message was handles

    FALSE - We did not handle the message

--*/
{
    COptionsDialog *rDialog;

    if (uMsg == WM_INITDIALOG) {
        rDialog = (COptionsDialog*)((LPPROPSHEETPAGE)lParam)->lParam;
        SetWindowLongPtr(hwndDlg,GWLP_USERDATA,(LPARAM)rDialog);
        return rDialog->OnCreateFilter(hwndDlg);
    }
    rDialog = (COptionsDialog*)GetWindowLongPtr(hwndDlg,GWLP_USERDATA);
    if (!rDialog) {
        return FALSE;
    }
    return rDialog->FilterDialogProc(hwndDlg,uMsg,wParam,lParam);
}

INT_PTR CALLBACK
COptionsDialog::_TraceDialogProc(
    IN HWND hwndDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    If this is a WM_INITDIALOG OnCreate is called.  Otherwise the non-static
    DialogProc function is called.

Arguments:

    See win32 DialogProc docs

Return value:
    
    TRUE - Message was handles

    FALSE - We did not handle the message

--*/
{
    COptionsDialog *rDialog;

    if (uMsg == WM_INITDIALOG) {
        rDialog = (COptionsDialog*)((LPPROPSHEETPAGE)lParam)->lParam;
        SetWindowLongPtr(hwndDlg,GWLP_USERDATA,(LPARAM)rDialog);
        return rDialog->OnCreateTrace(hwndDlg);
    }
    rDialog = (COptionsDialog*)GetWindowLongPtr(hwndDlg,GWLP_USERDATA);
    if (!rDialog) {
        return FALSE;
    }
    return rDialog->TraceDialogProc(hwndDlg,uMsg,wParam,lParam);
}

INT_PTR
COptionsDialog::OnCreateFilter(
    IN HWND hWnd
    )

/*++

Routine Description:

    We populate all the filter dialog fields here.

Arguments:

    hWnd - Dialog window

Return value:
    
    FALSE - An error occured.  DestroyWindow was called. This should never
            happen unless someone hosed the template

    TRUE - success in creating everything

--*/
{
    TCHAR traceLevelString[MAX_STR_LEN];
    UINT traceLevelStringId;
    TRC_CONFIG trcConfig;

    m_hFilterDlg = hWnd;

    if (!m_rTracer->GetCurrentConfig(&trcConfig)) {
        DestroyWindow(hWnd);
        return FALSE;
    }

    // Now we set all the fields in the dialog.
    
    
    // Do the slider
    traceLevelStringId = IDS_TRACELEVELDETAILED + trcConfig.traceLevel;
    LoadStringSimple(traceLevelStringId,traceLevelString);
    SetDlgItemText(hWnd,IDC_FILTERLEVELDESC,traceLevelString);
    
    m_hFilterSliderControl = GetDlgItem(hWnd,IDC_FILTERLEVEL);
    if (!m_hFilterSliderControl) {
        DestroyWindow(hWnd);
        return FALSE;
    }

    SendDlgItemMessage(hWnd,IDC_FILTERLEVEL,TBM_SETRANGE,TRUE,MAKELONG(TRC_LEVEL_DBG,TRC_LEVEL_DIS));
    SendDlgItemMessage(hWnd,IDC_FILTERLEVEL,TBM_SETPOS,TRUE,trcConfig.traceLevel);
    
    // Set the first item of the combo box to the prefix string and then
    // select it.
    SendDlgItemMessage(m_hFilterDlg,IDC_FILTERPREFIX,CB_ADDSTRING,0,
            (LPARAM)trcConfig.prefixList);

    SendDlgItemMessage(m_hFilterDlg,IDC_FILTERPREFIX,CB_SETCURSEL,0,0);
    
    // Limit the amount you can enter to the size of the prefix buffer.
    SendDlgItemMessage(hWnd,IDC_FILTERPREFIX,EM_LIMITTEXT,TRC_PREFIX_LIST_SIZE-1,0); 
    
    // Now set the other items to be the prefix MRU.
    LoadPrefixMRU(trcConfig.prefixList);
    
    // The group control stuff
    
    if (trcConfig.components & TRC_GROUP_NETWORK) {
        SendDlgItemMessage(hWnd,IDC_GROUPNETWORK,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.components & TRC_GROUP_SECURITY) {
        SendDlgItemMessage(hWnd,IDC_GROUPSECURITY,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.components & TRC_GROUP_CORE) {
        SendDlgItemMessage(hWnd,IDC_GROUPCORE,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.components & TRC_GROUP_UI) {
        SendDlgItemMessage(hWnd,IDC_GROUPUI,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.components & TRC_GROUP_UTILITIES) {
        SendDlgItemMessage(hWnd,IDC_GROUPUTILITIES,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.components & TRC_GROUP_UNUSED1) {
        SendDlgItemMessage(hWnd,IDC_GROUPUNUSED1,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.components & TRC_GROUP_UNUSED2) {
        SendDlgItemMessage(hWnd,IDC_GROUPUNUSED2,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.components & TRC_GROUP_UNUSED3) {
        SendDlgItemMessage(hWnd,IDC_GROUPUNUSED3,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.components & TRC_GROUP_UNUSED4) {
        SendDlgItemMessage(hWnd,IDC_GROUPUNUSED4,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.components & TRC_GROUP_UNUSED5) {
        SendDlgItemMessage(hWnd,IDC_GROUPUNUSED5,BM_SETCHECK,BST_CHECKED,0);
    }

    return 0;
}

INT_PTR
COptionsDialog::OnCreateTrace(
    IN HWND hWnd
    )

/*++

Routine Description:

    We populate all the trace dialog fields here.

Arguments:

    hWnd - Dialog window

Return value:
    
    FALSE - An error occured.  DestroyWindow was called. This should never
            happen unless someone hosed the template

    TRUE - success in creating everything

--*/
{
    TRC_CONFIG trcConfig;
    // Since the numbers we are outputing are 32bit ints.  They can't go over 4 billion
    // meaning eleven characters is enough to print a UINT plus a null terminator.
    TCHAR numberFormat[11];

    // save the window handle
    m_hTraceDlg = hWnd;

    m_rTracer->GetCurrentConfig(&trcConfig);

    if (trcConfig.flags & TRC_OPT_FILE_OUTPUT) {
        SendDlgItemMessage(hWnd,IDC_OUTPUT_FILE,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.flags & TRC_OPT_DEBUGGER_OUTPUT) {
        SendDlgItemMessage(hWnd,IDC_OUTPUT_DEBUGGER,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.flags & TRC_OPT_BEEP_ON_ERROR) {
        SendDlgItemMessage(hWnd,IDC_ERROR_BEEP,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.flags & TRC_OPT_BREAK_ON_ERROR) {
        SendDlgItemMessage(hWnd,IDC_ERROR_BREAK,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.flags & TRC_OPT_TIME_STAMP) {
        SendDlgItemMessage(hWnd,IDC_OPTION_STAMP,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.flags & TRC_OPT_PROCESS_ID) {
        SendDlgItemMessage(hWnd,IDC_OPTION_PROCID,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.flags & TRC_OPT_THREAD_ID) {
        SendDlgItemMessage(hWnd,IDC_OPTION_THREAID,BM_SETCHECK,BST_CHECKED,0);
    }
  
    // DCUINT32s are defined as u longs hence use %lu for the wsprintf
    wsprintf(numberFormat,_T("%lu"),trcConfig.funcNameLength);

    SetDlgItemText(hWnd,IDC_FUNCTION_LENGTH,numberFormat);
    // Limit the amount you can enter to the size of a ulong
    SendDlgItemMessage(hWnd,IDC_FUNCTION_LENGTH,EM_LIMITTEXT,10,0); 

    wsprintf(numberFormat,_T("%lu"),trcConfig.dataTruncSize);

    SetDlgItemText(hWnd,IDC_TRUNCATION_LENGTH,numberFormat);
    SendDlgItemMessage(hWnd,IDC_TRUNCATION_LENGTH,EM_LIMITTEXT,10,0); 
    
    if (trcConfig.flags & TRC_OPT_PROFILE_TRACING) {
        SendDlgItemMessage(hWnd,IDC_OPTION_PROFILE,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.flags & TRC_OPT_FLUSH_ON_TRACE) {
        SendDlgItemMessage(hWnd,IDC_OPTION_FLUSH,BM_SETCHECK,BST_CHECKED,0);
    }

    if (trcConfig.flags & TRC_OPT_STACK_TRACING) {
        SendDlgItemMessage(hWnd,IDC_OPTION_STACK,BM_SETCHECK,BST_CHECKED,0);
    }

    return TRUE;
}

INT_PTR CALLBACK
COptionsDialog::FilterDialogProc(
    IN HWND hwndDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    The FilterDialogProc forwards messages to the appropriate
    handlers.  See the handlers comments for what they do,

Arguments:

    See win32 docs for a DialogProc

Return value:
    
    TRUE - We handled the message

    FALSE - We didn't handle the message.

--*/
{
    WORD command;
    BOOL retValue;

    retValue = FALSE;

    switch (uMsg) {
    case WM_COMMAND:
        command = LOWORD(wParam);
        switch (command) {
        case IDC_SELECTALL:
            OnFilterSelectAll();
            retValue = TRUE;
            break;
        case IDC_CLEARALL:
            OnFilterClearAll();
            retValue = TRUE;
            break;
        }
        break;
    case WM_NOTIFY:
        if (((LPNMHDR)lParam)->code == PSN_APPLY) {
            OnFilterOk();
            retValue = TRUE;
        }
        break;
    case WM_HSCROLL:
        if ((HWND)lParam == m_hFilterSliderControl) {
            OnFilterSliderMove();
            retValue = TRUE;
        }
        break;
    }

    return retValue; 
}

INT_PTR CALLBACK
COptionsDialog::TraceDialogProc(
    IN HWND hwndDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    The TraceDialogProc forwards messages to the appropriate
    handlers.  See the handlers comments for what they do,

Arguments:

    See win32 docs for a DialogProc

Return value:
    
    TRUE - We handled the message

    FALSE - We didn't handle the message.

--*/
{
    if (uMsg == WM_NOTIFY) {
        if (((LPNMHDR)lParam)->code == PSN_APPLY) {
            if (!OnTraceOk()) {
                // invalid fields from the user
                SetWindowLong(hwndDlg,DWLP_MSGRESULT,PSNRET_INVALID); 
            }
            return TRUE;
        } else if (((LPNMHDR)lParam)->code == PSN_KILLACTIVE) {
            if (!TraceVerifyParameters()) {
                SetWindowLong(hwndDlg,DWLP_MSGRESULT,TRUE); 
            }
            return TRUE;
        }
    }
    

    return FALSE;
    
}

VOID
COptionsDialog::OnFilterSelectAll(
    )

/*++

Routine Description:

    This is called when we need to make all the component boxes be checked.

Arguments:

    None

Return value:
    
    None

--*/
{
    // It might not be perfect coding style but harcoding each set is a lot easier
    // than some complicated system constructing an array with the ID of all the buttons.
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPNETWORK,BM_SETCHECK,BST_CHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPSECURITY,BM_SETCHECK,BST_CHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPCORE,BM_SETCHECK,BST_CHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUI,BM_SETCHECK,BST_CHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUTILITIES,BM_SETCHECK,BST_CHECKED,0);

    // If you ever make these groups do something just add the correct items
    // in. It looks weird to have the disabled boxes checked so we don't
    // do it.
/*  
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUNUSED1,BM_SETCHECK,BST_CHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUNUSED2,BM_SETCHECK,BST_CHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUNUSED3,BM_SETCHECK,BST_CHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUNUSED4,BM_SETCHECK,BST_CHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUNUSED5,BM_SETCHECK,BST_CHECKED,0);
*/
}

VOID
COptionsDialog::OnFilterSliderMove(
    )

/*++

Routine Description:

    This is called whenever the slider is moved.  We update the
    text to the right of the slider to show the new descriptive
    name for the tracing level.

Arguments:

    None

Return value:
    
    None

--*/
{
    UINT sliderPos;
    TCHAR traceLevelString[MAX_STR_LEN];

    sliderPos = (UINT)SendMessage(m_hFilterSliderControl,TBM_GETPOS,0,0);

    // Set the slider description
    LoadStringSimple(IDS_TRACELEVELDETAILED+sliderPos,traceLevelString);
    SetDlgItemText(m_hFilterDlg,IDC_FILTERLEVELDESC,traceLevelString);
}

VOID
COptionsDialog::OnFilterClearAll(
    )

/*++

Routine Description:

    This clears all the component check boxes.

Arguments:

    None

Return value:
    
    None

--*/
{
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPNETWORK,BM_SETCHECK,BST_UNCHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPSECURITY,BM_SETCHECK,BST_UNCHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPCORE,BM_SETCHECK,BST_UNCHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUI,BM_SETCHECK,BST_UNCHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUTILITIES,BM_SETCHECK,BST_UNCHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUNUSED1,BM_SETCHECK,BST_UNCHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUNUSED2,BM_SETCHECK,BST_UNCHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUNUSED3,BM_SETCHECK,BST_UNCHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUNUSED4,BM_SETCHECK,BST_UNCHECKED,0);
    SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUNUSED5,BM_SETCHECK,BST_UNCHECKED,0);
}

VOID COptionsDialog::OnFilterOk(
    )

/*++

Routine Description:

    This reads in all the dialog parameters and then sets the trace
    filtering parameters accordingly.

Arguments:

    None

Return value:
    
    None

--*/
{
    TRC_CONFIG trcConfig;

    m_rTracer->GetCurrentConfig(&trcConfig);

    // set the trace level.
    trcConfig.traceLevel = (DCUINT32)SendDlgItemMessage(m_hFilterDlg,IDC_FILTERLEVEL,TBM_GETPOS,
        0,0);

    // Get the prefix string

    GetDlgItemText(m_hFilterDlg,IDC_FILTERPREFIX,trcConfig.prefixList,TRC_PREFIX_LIST_SIZE-1);

    // Save the prefix MRU

    StorePrefixMRU(trcConfig.prefixList);

    // Construct the components variable.

    if (BST_CHECKED == SendDlgItemMessage(m_hFilterDlg,IDC_GROUPNETWORK,BM_GETCHECK,0,0)) {
        trcConfig.components |= TRC_GROUP_NETWORK;
    } else {
        trcConfig.components &= ~TRC_GROUP_NETWORK;
    }

    if (BST_CHECKED == SendDlgItemMessage(m_hFilterDlg,IDC_GROUPSECURITY,BM_GETCHECK,0,0)) {
        trcConfig.components |= TRC_GROUP_SECURITY;
    } else {
        trcConfig.components &= ~TRC_GROUP_SECURITY;
    }

    if (BST_CHECKED == SendDlgItemMessage(m_hFilterDlg,IDC_GROUPCORE,BM_GETCHECK,0,0)) {
        trcConfig.components |= TRC_GROUP_CORE;
    } else {
        trcConfig.components &= ~TRC_GROUP_CORE;
    }

    if (BST_CHECKED == SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUI,BM_GETCHECK,0,0)) {
        trcConfig.components |= TRC_GROUP_UI;
    } else {
        trcConfig.components &= ~TRC_GROUP_UI;
    }

    if (BST_CHECKED == SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUTILITIES,BM_GETCHECK,0,0)) {
        trcConfig.components |= TRC_GROUP_UTILITIES;
    } else {
        trcConfig.components &= ~TRC_GROUP_UTILITIES;
    }

    if (BST_CHECKED == SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUNUSED1,BM_GETCHECK,0,0)) {
        trcConfig.components |= TRC_GROUP_UNUSED1;
    } else {
        trcConfig.components &= ~TRC_GROUP_UNUSED1;
    }

    if (BST_CHECKED == SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUNUSED2,BM_GETCHECK,0,0)) {
        trcConfig.components |= TRC_GROUP_UNUSED2;
    } else {
        trcConfig.components &= ~TRC_GROUP_UNUSED2;
    }

    if (BST_CHECKED == SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUNUSED3,BM_GETCHECK,0,0)) {
        trcConfig.components |= TRC_GROUP_UNUSED3;
    } else {
        trcConfig.components &= ~TRC_GROUP_UNUSED3;
    }

    if (BST_CHECKED == SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUNUSED4,BM_GETCHECK,0,0)) {
        trcConfig.components |= TRC_GROUP_UNUSED4;
    } else {
        trcConfig.components &= ~TRC_GROUP_UNUSED4;
    }

    if (BST_CHECKED == SendDlgItemMessage(m_hFilterDlg,IDC_GROUPUNUSED5,BM_GETCHECK,0,0)) {
        trcConfig.components |= TRC_GROUP_UNUSED5;
    } else {
        trcConfig.components &= ~TRC_GROUP_UNUSED5;
    }

    m_rTracer->SetCurrentConfig(&trcConfig);
}


BOOL COptionsDialog::OnTraceOk(
    )

/*++

Routine Description:

    This reads in all the dialog parameters and then sets the trace
    parameters accordingly.

Arguments:

    None

Return value:
    
    TRUE - Success in setting the conf.

    FALSE - The user entered invalid data so the dialog should not be closed.

--*/
{
    TRC_CONFIG trcConfig;
    // again enough to hold a string representing a ulong.
    TCHAR numberFormat[11];

    m_rTracer->GetCurrentConfig(&trcConfig);

    if (BST_CHECKED == SendDlgItemMessage(m_hTraceDlg,IDC_OUTPUT_FILE,BM_GETCHECK,0,0)) {
        trcConfig.flags |= TRC_OPT_FILE_OUTPUT;
    } else {
        trcConfig.flags &= ~TRC_OPT_FILE_OUTPUT;
    }

    if (BST_CHECKED == SendDlgItemMessage(m_hTraceDlg,IDC_OUTPUT_DEBUGGER,BM_GETCHECK,0,0)) {
        trcConfig.flags |= TRC_OPT_DEBUGGER_OUTPUT;
    } else {
        trcConfig.flags &= ~TRC_OPT_DEBUGGER_OUTPUT;
    }

    if (BST_CHECKED == SendDlgItemMessage(m_hTraceDlg,IDC_ERROR_BEEP,BM_GETCHECK,0,0)) {
        trcConfig.flags |= TRC_OPT_BEEP_ON_ERROR;
    } else {
        trcConfig.flags &= ~TRC_OPT_BEEP_ON_ERROR;
    }

    if (BST_CHECKED == SendDlgItemMessage(m_hTraceDlg,IDC_ERROR_BREAK,BM_GETCHECK,0,0)) {
        trcConfig.flags |= TRC_OPT_BREAK_ON_ERROR;
    } else {
        trcConfig.flags &= ~TRC_OPT_BREAK_ON_ERROR;
    }

    if (BST_CHECKED == SendDlgItemMessage(m_hTraceDlg,IDC_OPTION_STAMP,BM_GETCHECK,0,0)) {
        trcConfig.flags |= TRC_OPT_TIME_STAMP;
    } else {
        trcConfig.flags &= ~TRC_OPT_TIME_STAMP;
    }

    if (BST_CHECKED == SendDlgItemMessage(m_hTraceDlg,IDC_OPTION_PROCID,BM_GETCHECK,0,0)) {
        trcConfig.flags |= TRC_OPT_PROCESS_ID;
    } else {
        trcConfig.flags &= ~TRC_OPT_PROCESS_ID;
    }

    if (BST_CHECKED == SendDlgItemMessage(m_hTraceDlg,IDC_OPTION_THREAID,BM_GETCHECK,0,0)) {
        trcConfig.flags |= TRC_OPT_THREAD_ID;
    } else {
        trcConfig.flags &= ~TRC_OPT_THREAD_ID;
    }

    GetDlgItemText(m_hTraceDlg,IDC_FUNCTION_LENGTH,numberFormat,10);

    if (!VerifyNumberFormat(numberFormat)) {
        return FALSE;
    }
    trcConfig.funcNameLength = _ttol(numberFormat);

    GetDlgItemText(m_hTraceDlg,IDC_TRUNCATION_LENGTH,numberFormat,10);
    if (!VerifyNumberFormat(numberFormat)) {
        return FALSE;
    }

    trcConfig.dataTruncSize = _ttol(numberFormat);

    if (BST_CHECKED == SendDlgItemMessage(m_hTraceDlg,IDC_OPTION_PROFILE,BM_GETCHECK,0,0)) {
        trcConfig.flags |= TRC_OPT_PROFILE_TRACING;
    } else {
        trcConfig.flags &= ~TRC_OPT_PROFILE_TRACING;
    }
    if (BST_CHECKED == SendDlgItemMessage(m_hTraceDlg,IDC_OPTION_FLUSH,BM_GETCHECK,0,0)) {
        trcConfig.flags |= TRC_OPT_FLUSH_ON_TRACE;
    } else {
        trcConfig.flags &= ~TRC_OPT_FLUSH_ON_TRACE;
    }
    if (BST_CHECKED == SendDlgItemMessage(m_hTraceDlg,IDC_OPTION_STACK,BM_GETCHECK,0,0)) {
        trcConfig.flags |= TRC_OPT_STACK_TRACING;
    } else {
        trcConfig.flags &= ~TRC_OPT_STACK_TRACING;
    }

    m_rTracer->SetCurrentConfig(&trcConfig);

    return TRUE;
}

BOOL
COptionsDialog::VerifyNumberFormat(
    IN LPCTSTR numberFormat
    )

/*++

Routine Description:

    This checks to make sure the passed in string is in the form
    /^\d*$/.  If not a dialog box is popped up telling the user
    that the string must be a valid postive number.

Arguments:

    numberFormat - String to check if it is a number string

Return value:
    
    TRUE - The string only containts the characters 0-9

    FALSE - The string has illegal characters.

--*/
{
    WCHAR current;
    TCHAR dlgTitle[MAX_STR_LEN];
    TCHAR dlgMessage[MAX_STR_LEN];
    
    while (current = *(numberFormat++)) {
        if (!_istdigit(current)) {
            LoadStringSimple(IDS_SETTINGSNOTNUMBER,dlgMessage);
            LoadStringSimple(IDS_ZIPPYWINDOWTITLE,dlgTitle);
            MessageBox(m_hTraceDlg,dlgMessage,dlgTitle,MB_OK|MB_ICONWARNING);
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
COptionsDialog::TraceVerifyParameters(
    )

/*++

Routine Description:

    Makes sure the trace parameters are valid

Arguments:

    None

Return value:
    
    TRUE - Trace parameters are valid.

    FALSE - Trace parameters are invalid.

--*/
{
    TCHAR numberFormat[11];
    
    GetDlgItemText(m_hTraceDlg,IDC_FUNCTION_LENGTH,numberFormat,10);

    if (!VerifyNumberFormat(numberFormat)) {
        return FALSE;
    }
    
    GetDlgItemText(m_hTraceDlg,IDC_TRUNCATION_LENGTH,numberFormat,10);
    if (!VerifyNumberFormat(numberFormat)) {
        return FALSE;
    }

    return TRUE;
}

VOID
COptionsDialog::LoadPrefixMRU(
    IN LPCTSTR currentPrefix
    )

/*++

Routine Description:

    This loads the prefix MRU list into the prefix
    combo box.

Arguments:

    currentPrefix - The current selected prefix

Return value:
    
    None

--*/
{
    TCHAR prefix[TRC_PREFIX_LIST_SIZE];
    TCHAR valueName[MRU_STR_BUFFER_SIZE];
    HKEY hKey;
    INT i;
    DWORD dwSize;
    DWORD dwType;
    DWORD dwResult;

    dwResult = RegOpenKeyEx(HKEY_CURRENT_USER,ZIPPY_REG_KEY,0,KEY_QUERY_VALUE,
        &hKey);
    if (dwResult) {
        // error opening reg key return
        return;
    }

    for (i=0;i<MAX_MRU;i++) {
        wsprintf(valueName,_T("%s%d"),MRU_STR_PREFIX,i);
        dwSize = sizeof(TCHAR)*TRC_PREFIX_LIST_SIZE;
        dwResult = RegQueryValueEx(hKey,valueName,NULL,&dwType,(LPBYTE)prefix,
            &dwSize);
        if (dwResult) {
            // if there is an error loading a value then quit
            break;
        } else if (0 == _tcsicmp(prefix,currentPrefix)) {
            // if the MRU item is the same as the current don't display it
            continue;
        }
        SendDlgItemMessage(m_hFilterDlg,IDC_FILTERPREFIX,CB_ADDSTRING,0,
            (LPARAM)prefix);
    }

    RegCloseKey(hKey);

}

VOID
COptionsDialog::StorePrefixMRU(
    IN LPCTSTR currentPrefix
    )

/*++

Routine Description:

    This updates the registry MRU list to put
    the new prefix at the head of the list.

Arguments:

    currentPrefix - The current selected prefix

Return value:
    
    None

--*/
{
    HKEY hKey;
    TCHAR savedMruPrefix[TRC_PREFIX_LIST_SIZE];
    TCHAR newMruPrefix[TRC_PREFIX_LIST_SIZE];
    TCHAR currentLoadName[MRU_STR_BUFFER_SIZE];
    TCHAR currentSaveName[MRU_STR_BUFFER_SIZE];
    INT loadIndex;
    INT saveIndex;
    DWORD dwSize;
    DWORD dwType;
    DWORD dwResult;


    dwResult = RegOpenKeyEx(HKEY_CURRENT_USER,ZIPPY_REG_KEY,0,
        KEY_QUERY_VALUE|KEY_SET_VALUE,&hKey);
    if (dwResult) {
        // error opening reg key return
        return;
    }

    // The new currentPrefix is the first item in the MRU list
    _tcscpy(newMruPrefix,currentPrefix);

    for (loadIndex=0,saveIndex=0;loadIndex<MAX_MRU;loadIndex++) {
        wsprintf(currentLoadName,_T("%s%d"),MRU_STR_PREFIX,loadIndex);
        wsprintf(currentSaveName,_T("%s%d"),MRU_STR_PREFIX,saveIndex);
        
        dwSize = sizeof(TCHAR)*TRC_PREFIX_LIST_SIZE;
        dwResult = RegQueryValueEx(hKey,currentLoadName,NULL,&dwType,
            (LPBYTE)savedMruPrefix,&dwSize);
        if (dwResult) {
            // no more valid keys.  Write out the current and exit.
            RegSetValueEx(hKey,currentLoadName,0,REG_SZ,(LPBYTE)newMruPrefix,sizeof(TCHAR) * 
            (_tcslen(newMruPrefix)+1));
            break;
        } else if (0 == _tcsicmp(savedMruPrefix,currentPrefix)) {
            // if this MRU is the same as the currentPrefix we already have saved it.
            // so we will advance i and leave the currentMru the same
            
            if (loadIndex == MAX_MRU-1) {
                // If this is the last MRU to load then we need to save
                RegSetValueEx(hKey,currentSaveName,0,REG_SZ,(LPBYTE)newMruPrefix,sizeof(TCHAR) * 
                    (_tcslen(newMruPrefix)+1));
            }
            continue;
        } else {
            // we are going to save in this position so advance the index
            saveIndex++;
        }
        RegSetValueEx(hKey,currentSaveName,0,REG_SZ,(LPBYTE)newMruPrefix,sizeof(TCHAR) * 
            (_tcslen(newMruPrefix)+1));

        _tcscpy(newMruPrefix,savedMruPrefix);
    }

    RegCloseKey(hKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\trace\ezippy\tracemanager.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Trace Manager

Abstract:

    This does all the interfacing with the tracing code.

Author:

    Marc Reyhner 8/28/2000

--*/

#ifndef __TRACEMANAGER_H__
#define __TRACEMANAGER_H__


// We aren't tracing in this app so we only define tracegroup so that
// we can include atrcapi.h
#define TRC_GROUP junk
#define OS_WIN32
#include <adcgbase.h>
#include <atrcapi.h>
#undef TRC_GROUP

class CZippyWindow;

class CTraceManager  
{
public:
	static DWORD _InitTraceManager();
    static VOID _CleanupTraceManager();
    
    CTraceManager();
    virtual ~CTraceManager();
    VOID TRC_ResetTraceFiles();
	BOOL SetCurrentConfig(PTRC_CONFIG lpNewConfig);
	BOOL GetCurrentConfig(PTRC_CONFIG lpConfig);
	DWORD StartListenThread(CZippyWindow *rZippyWindow);
    DWORD StopListenThread();

private:
	
    static HANDLE gm_hDBWinSharedDataHandle;
    static LPVOID gm_hDBWinSharedData;
    static HANDLE gm_hDBWinDataReady;
    static HANDLE gm_hDBWinDataAck;

    CZippyWindow *m_rZippyWindow;
    HANDLE m_hThread;
    BOOL m_bThreadStop;

    static DWORD WINAPI _ThreadProc(LPVOID lpParameter);
    
    DWORD ThreadProc();
    VOID OnNewData();
    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\trace\ezippy\tracemanager.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Trace Manager

Abstract:

    This does all the interfacing with the tracing code.

Author:

    Marc Reyhner 8/28/2000

--*/

#include "stdafx.h"
#include "ZippyWindow.h"
#include "TraceManager.h"
#include "eZippy.h"
#include "resource.h"

// Instantions of all the static class members.
HANDLE CTraceManager::gm_hDBWinSharedDataHandle = NULL;
LPVOID CTraceManager::gm_hDBWinSharedData = NULL;
HANDLE CTraceManager::gm_hDBWinDataReady = NULL;
HANDLE CTraceManager::gm_hDBWinDataAck = NULL;

// Our various defines for dbwin.
#define DBWIN_BUFFER_READY  _T("DBWIN_BUFFER_READY")
#define DBWIN_DATA_READY    _T("DBWIN_DATA_READY")
#define DBWIN_BUFFER_NAME   _T("DBWIN_BUFFER")
#define DBWIN_BUFFER_SIZE   4096



CTraceManager::CTraceManager(
    )

/*++

Routine Description:

    The constructor simply initializes the class variables.

Arguments:

    None

Return value:
    
    None

--*/
{
    m_hThread = NULL;
    m_bThreadStop = FALSE;
}

CTraceManager::~CTraceManager(
    )

/*++

Routine Description:

    The destructor does nothing now.  Don't call this before the 
    listen thread exits or bad things may happen.

Arguments:

    None

Return value:
    
    None

--*/
{

}

DWORD
CTraceManager::StartListenThread(
    IN CZippyWindow *rZippyWindow
    )

/*++

Routine Description:

    This starts a new thread listening for trace output.

Arguments:

    rZippyWindow - The main zippy window which will have data sent
                   to it.

Return value:
    
    0 - Success

    Non zero - a win32 error code

--*/
{
    DWORD dwResult;
    DWORD threadId;

    dwResult = 0;

    m_rZippyWindow = rZippyWindow;

    m_hThread = CreateThread(NULL,0,_ThreadProc,this,0,&threadId);
    if (!m_hThread) {
        dwResult = GetLastError();
    }

    return dwResult;
}

DWORD
CTraceManager::_InitTraceManager(
    )

/*++

Routine Description:

    This initializes all the mutexes and shared memory
    for dbwin.  It also call TRC_Initialize

Arguments:

    None

Return value:
    
    0 - Success

    Non zero - a win32 error code

--*/
{
    DWORD dwResult;
    BOOL bResult;

    dwResult = 0;
    
    TRC_Initialize(TRUE);

    gm_hDBWinDataAck = CreateEvent(NULL,FALSE,FALSE,DBWIN_BUFFER_READY);
    if (!gm_hDBWinDataAck) {
        dwResult = GetLastError();
        goto CLEANUP_AND_EXIT;
    }

    if (ERROR_ALREADY_EXISTS == GetLastError()) {
        TCHAR dlgTitle[MAX_STR_LEN];
        TCHAR dlgMessage[MAX_STR_LEN];

        LoadStringSimple(IDS_ZIPPYWINDOWTITLE,dlgTitle);
        LoadStringSimple(IDS_ZIPPYALREADYEXISTS,dlgMessage);

        MessageBox(NULL,dlgMessage,dlgTitle,MB_OK|MB_ICONERROR);

        ExitProcess(1);
    }

    gm_hDBWinDataReady = CreateEvent(NULL,FALSE,FALSE,DBWIN_DATA_READY);
    if (!gm_hDBWinDataReady) {
        dwResult = GetLastError();
        goto CLEANUP_AND_EXIT;
    }

    gm_hDBWinSharedDataHandle = CreateFileMapping(INVALID_HANDLE_VALUE,NULL,PAGE_READWRITE,
        0,DBWIN_BUFFER_SIZE,DBWIN_BUFFER_NAME);
    if (!gm_hDBWinSharedDataHandle) {
        dwResult = GetLastError();
        goto CLEANUP_AND_EXIT;
    }

    gm_hDBWinSharedData = MapViewOfFile(gm_hDBWinSharedDataHandle,
        FILE_MAP_READ,0,0,0);
    if (!gm_hDBWinSharedData) {
        dwResult = GetLastError();
        goto CLEANUP_AND_EXIT;
    }

CLEANUP_AND_EXIT:
  
    if (dwResult) {
        if (gm_hDBWinSharedData) {
            UnmapViewOfFile(gm_hDBWinSharedData);
            gm_hDBWinSharedData = NULL;
        }
        if (gm_hDBWinSharedDataHandle) {
            CloseHandle(gm_hDBWinSharedDataHandle);
            gm_hDBWinSharedDataHandle = NULL;
        }
        if (gm_hDBWinDataReady) {
            CloseHandle(gm_hDBWinDataReady);
            gm_hDBWinDataReady = NULL;
        }
        if (gm_hDBWinDataAck) {
            CloseHandle(gm_hDBWinDataAck);
            gm_hDBWinDataAck = NULL;
        }

    }

    return dwResult;
}

VOID
CTraceManager::_CleanupTraceManager(
    )

/*++

Routine Description:

    Cleans up all the dbwin stuff.

Arguments:

    None

Return value:
    
    None

--*/
{
    if (gm_hDBWinSharedData) {
        UnmapViewOfFile(gm_hDBWinSharedData);
        gm_hDBWinSharedData = NULL;
    }
    if (gm_hDBWinSharedDataHandle) {
        CloseHandle(gm_hDBWinSharedDataHandle);
        gm_hDBWinSharedDataHandle = NULL;
    }
    if (gm_hDBWinDataReady) {
        CloseHandle(gm_hDBWinDataReady);
        gm_hDBWinDataReady = NULL;
    }
    if (gm_hDBWinDataAck) {
        CloseHandle(gm_hDBWinDataAck);
        gm_hDBWinDataAck = NULL;
    }
}

VOID
CTraceManager::OnNewData(
    )

/*++

Routine Description:

    This is called whenever new data shows up for the trace.  The data
    is then forwarded to the zippy window

Arguments:

    None

Return value:
    
    None

--*/
{
    LPTSTR debugStr;
    LPSTR asciiDebugStr;
    DWORD processID;
    UINT debugStrLen;
#ifdef UNICODE
    INT result;
    TCHAR debugWStr[DBWIN_BUFFER_SIZE];
#endif
    
    debugStr = NULL;
    processID = *(LPDWORD)gm_hDBWinSharedData;
    asciiDebugStr = (LPSTR)((PBYTE)(gm_hDBWinSharedData) + sizeof(DWORD));
    debugStrLen = strlen(asciiDebugStr);
    
#ifdef UNICODE
    debugStr = debugWStr;
    result = MultiByteToWideChar(CP_ACP,0,asciiDebugStr,debugStrLen+1,
        debugStr,DBWIN_BUFFER_SIZE);
    if (!result) {
        // error
        goto CLEANUP_AND_EXIT;
    }
#else
    debugStr = asciiDebugStr;
#endif

    m_rZippyWindow->AppendTextToWindow(processID,debugStr,debugStrLen);

CLEANUP_AND_EXIT:

    return;
}

DWORD WINAPI
CTraceManager::_ThreadProc(
    IN LPVOID lpParameter
    )

/*++

Routine Description:

    Simply calls the non static version of the thread procedure.

Arguments:

    lpParameter - Thread start information

Return value:
    
    See ThreadProc for return values

--*/
{
    return ((CTraceManager*)lpParameter)->ThreadProc();
}

DWORD
CTraceManager::ThreadProc(
    )

/*++

Routine Description:

    This loops catching debug data and then forwarding it to the zippy window.

Arguments:

    None

Return value:
    
    0 - Success

    Non zero - Win32 error code

--*/
{
    DWORD dwResult;

    dwResult = 0;

    SetEvent(gm_hDBWinDataAck);
    while (!m_bThreadStop) {
        dwResult = WaitForSingleObject(gm_hDBWinDataReady,INFINITE);
        if (dwResult != WAIT_OBJECT_0) {
            break;
        }
        OnNewData();
        SetEvent(gm_hDBWinDataAck);

    }

    return dwResult;
}

BOOL
CTraceManager::GetCurrentConfig(
    IN PTRC_CONFIG lpConfig
    )

/*++

Routine Description:

    Returns the current trace configuration

Arguments:

    lpConfig - Pointer to a TRC_CONFIG struct which will receive the configuation.

Return value:
    
    TRUE - config was successfully retrieved.

    FALSE - There was an error getting the config.

--*/
{
    return TRC_GetConfig(lpConfig,sizeof(TRC_CONFIG));
}

BOOL
CTraceManager::SetCurrentConfig(
    IN PTRC_CONFIG lpNewConfig
    )

/*++

Routine Description:

    Sets the trace configuration

Arguments:

    lpConfig - Pointer to the new configuration

Return value:
    
    TRUE - config was successfully set.

    FALSE - There was an error setting the config.

--*/
{
    return TRC_SetConfig(lpNewConfig,sizeof(TRC_CONFIG));
}

VOID
CTraceManager::TRC_ResetTraceFiles(
    )

/*++

Routine Description:

    Just a straight wrapper to the global TRC_ResetTraceFiles function,

Arguments:

    None

Return value:
    
    None

--*/
{
    // The :: is necessary to get the C version of the func.
    ::TRC_ResetTraceFiles();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\trace\ezippy\zippywindow.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Zippy Main Window

Abstract:

    This class implements the main window for zippy as well as controlling
    its child windows.

Author:

    Marc Reyhner 8/28/2000

--*/

#include "stdafx.h"
#include "ZippyWindow.h"
#include "resource.h"
#include "eZippy.h"
#include "richedit.h"
#include "ModalDialog.h"
#include "TraceManager.h"
#include "OptionsDialog.h"


BOOL CZippyWindow::gm_Inited = FALSE;
ATOM CZippyWindow::gm_Atom = NULL;
UINT CZippyWindow::gm_FindMessageStringMsg = 0;

static DWORD CALLBACK SaveCallback(DWORD_PTR dwCookie,LPBYTE pbBuff,LONG cb,LONG *pcb);


#define TRC_PROC_FMT                    _T("%04.4lx")
#define SAVE_FILE_TYPE                  _T("Text Files (*.txt)\0*.txt\0")
#define SAVE_FILE_EXTENSION             _T("txt")
#define SAVE_CONF_FILE_TYPE             _T("Trace Configuration Files (*.tcf)\0*.tcf\0")
#define SAVE_CONF_FILE_EXTENSION        _T("tcf")
#define NUM_COLORS                      15
#define APPENDMUTEXNAME                 _T("Local\\MicrosoftTerminalServerTraceViewerAppendMutex")
#define ZIPPY_WINDOW_POS_VALUE          _T("WindowPosition")
#define WINDOW_DEF_TOP                  50
#define WINDOW_DEF_BOTTOM               530
#define WINDOW_DEF_RIGHT                690
#define WINDOW_DEF_LEFT                 50

// We use an 80 character buffer for find
// and replace operations.
#define FIND_REPLACE_BUFFER_SIZE        80

// This list of colors we cycle through.  Note if you change this
// list you need to update NUM_COLORS to the new count.
static COLORREF colors[NUM_COLORS] = {
    RGB(153,51,0),  /* Brown */
    RGB(0,51,102),  /* Dark Teal */
    RGB(51,51,153), /* Indigo */
    RGB(128,0,0),   /* Dark Red */
    RGB(255,102,0), /* Orange */
    RGB(0,128,0),   /* Green */
    RGB(0,0,255),   /* Blue */
    RGB(255,0,0),   /* Red */
    RGB(51,204,204),/* Acqua */
    RGB(128,0,128), /* Violet */
    RGB(255,0,255), /* Pink */
    RGB(255,255,0), /* Yellow */
    RGB(0,255,0),   /* Bright Green */
    RGB(0,255,255), /* Turquoise */
    RGB(204,153,255)/* Lavender */
    };

//
//  *** Public Class Members ***
//

CZippyWindow::CZippyWindow(
    )

/*++

Routine Description:

    The constructor simply initializes the class variables.

Arguments:

    None

Return value:
    
    None

--*/
{
    m_bIsTracing = TRUE;
    m_bIsStoringTraceData = FALSE;
    ZeroMemory(m_threadHistory,sizeof(m_threadHistory));
    m_nextThreadIndex = 0;
    m_nextThreadColor = 0;
    m_lastProcessId = 0;
    m_LastLogEndedInNewLine = TRUE;
    m_hWnd = NULL;
    m_hStatusWnd = NULL;
    m_hControlWnd = NULL;
    m_hWndFindReplace = NULL;
    m_lpSavedOutputStart = NULL;
    m_lpSavedOutputTail = NULL;
    ZeroMemory(&m_FindReplace,sizeof(m_FindReplace));
    ZeroMemory(m_SaveFile,sizeof(m_SaveFile));
    ZeroMemory(m_SaveConfFile,sizeof(m_SaveConfFile));
    ZeroMemory(m_LoadConfFile,sizeof(m_LoadConfFile));
}

CZippyWindow::~CZippyWindow(
    )

/*++

Routine Description:

    Cleans up any dynamicly allocated memory,

Arguments:

    None

Return value:
    
    None

--*/
{
    if (m_FindReplace.lpstrFindWhat) {
        HeapFree(GetProcessHeap(),0,m_FindReplace.lpstrFindWhat);
    }
    if (m_FindReplace.lpstrReplaceWith) {
        HeapFree(GetProcessHeap(),0,m_FindReplace.lpstrReplaceWith);
    }
}



DWORD CZippyWindow::Create(
    IN CTraceManager *rTracer
    )

/*++

Routine Description:

    Actually creates the zippy window.

Arguments:

    rTracer - A pointer to the trace manager

Return value:
    
    0 - Success

    Non zero - An error occurred creating the window

--*/
{
	DWORD dwResult;
    DWORD dwWindowStyleEx;
    DWORD dwWindowStyle;
    TCHAR wndTitle[MAX_STR_LEN];
    RECT wndRect;

    m_rTracer = rTracer;
	if (!gm_Inited) {
		dwResult = _InitClassStaticMembers();
		if (dwResult != ERROR_SUCCESS) {
			return dwResult;
		}
	}
    
    m_hAppendMutex = CreateMutex(NULL,FALSE,APPENDMUTEXNAME);

    m_FindReplace.lStructSize = sizeof(m_FindReplace);

    m_FindReplace.lpstrFindWhat = (LPTSTR)HeapAlloc(GetProcessHeap(),
        HEAP_ZERO_MEMORY,FIND_REPLACE_BUFFER_SIZE*sizeof(TCHAR));
    if (!m_FindReplace.lpstrFindWhat) {
        return GetLastError();
    }

    m_FindReplace.lpstrReplaceWith = (LPTSTR)HeapAlloc(GetProcessHeap(),
        HEAP_ZERO_MEMORY,FIND_REPLACE_BUFFER_SIZE*sizeof(TCHAR));
    if (!m_FindReplace.lpstrReplaceWith) {
        return GetLastError();
    }

    LoadStringSimple(IDS_ZIPPYWINDOWTITLE,wndTitle);
    
    GetSavedWindowPos(&wndRect);

    dwWindowStyleEx = WS_EX_WINDOWEDGE;
    dwWindowStyle = WS_OVERLAPPEDWINDOW|WS_CLIPSIBLINGS|WS_VISIBLE;
    m_hWnd = CreateWindowEx(dwWindowStyleEx, (LPTSTR)gm_Atom, wndTitle,
        dwWindowStyle, wndRect.left, wndRect.top, wndRect.right,
        wndRect.bottom,NULL,NULL,g_hInstance,this);
    if (!m_hWnd) {
        return GetLastError();
    }

	return ERROR_SUCCESS;
}

VOID
CZippyWindow::AppendTextToWindow(
    IN DWORD processID,
    IN LPCTSTR text,
    IN UINT len
    )

/*++

Routine Description:

    Appends new trace data to the end of the rich edit contrl

Arguments:

    processID - Process ID of the process sending the debug string

    text - The data sent via OutputDebugString

    len - Length of the data

Return value:
    
    None

--*/
{
    UINT controlTextLength;
    CHARRANGE newSel;
    BOOL computeColor;
    BOOL setNewColor;
    CHARFORMAT newFormat;
    LPSAVEDOUTPUT lpSave;

    if (!m_bIsTracing) {
        return;
    }

    WaitForSingleObject(m_hAppendMutex,INFINITE);

    if (m_bIsStoringTraceData) {
        // This is kinda sketchy but what we do is to allocate room for the string
        // at the end of the structure. There shouldn't be any alignment problems
        // since we need to align on a short and the structure has no items
        // to get that off.
        lpSave = (LPSAVEDOUTPUT)HeapAlloc(GetProcessHeap(),0,sizeof(SAVEDOUTPUT) + 
            (sizeof(TCHAR) * (len+1)));
        if (!lpSave) {
            // eom error?
            goto CLEANUP_AND_EXIT;
        }
        lpSave->procID = processID;
        lpSave->text = (LPTSTR)((BYTE)lpSave + sizeof(SAVEDOUTPUT));
        _tcscpy(lpSave->text,text);
        lpSave->len = len;
        lpSave->next = NULL;

        if (!m_lpSavedOutputTail) {
            m_lpSavedOutputStart = lpSave;
        } else {
            m_lpSavedOutputTail->next = lpSave;
        }
        m_lpSavedOutputTail = lpSave;
        goto CLEANUP_AND_EXIT;
    }

    if (m_lastProcessId != processID ||
        m_LastLogEndedInNewLine) {
        computeColor = TRUE;
    } else {
        computeColor = FALSE;
    }

    setNewColor = ComputeNewColor(processID,text,len,&newFormat);

    m_LastLogEndedInNewLine = (text[len-1] == '\n') ? TRUE : FALSE;
    m_lastProcessId = processID;

    controlTextLength = (UINT)SendMessage(m_hControlWnd,WM_GETTEXTLENGTH,0,0);
    newSel.cpMin = controlTextLength;
    newSel.cpMax = controlTextLength+1;

    
    // set the new text
    SendMessage(m_hControlWnd,EM_EXSETSEL,0,(LPARAM)&newSel);
    if (setNewColor) {
        SendMessage(m_hControlWnd,EM_SETCHARFORMAT,SCF_SELECTION,(LPARAM)&newFormat);
    }
    SendMessage(m_hControlWnd,EM_REPLACESEL,0,(LPARAM)text);
    
CLEANUP_AND_EXIT:

    ReleaseMutex(m_hAppendMutex);
}

VOID
CZippyWindow::LoadConfFile(
    IN LPTSTR confFile
    )

/*++

Routine Description:

    This sets the tracing configuration using the given file

Arguments:

    confFile - File containing the tracing configuration

Return value:
    
    None

--*/
{
    _tcscpy(m_LoadConfFile,confFile);
    DoLoadConfInternal();
}

BOOL
CZippyWindow::IsDialogMessage(
    IN LPMSG lpMsg
    )

/*++

Routine Description:

    This calls IsDialogMessage on any non modal dialogs that this window
    is hosting to see if the message is for them

Arguments:

    lpMsg - Message to check if it is a dialog message

Return value:
    
    TRUE - The message did belong to a dialog

    FALSE - The message did not belong to a dialog

--*/
{
    if (IsWindow(m_hWndFindReplace)) {
        // The :: below is necessary to make it use the Win32 function
        // not our method
        return ::IsDialogMessage(m_hWndFindReplace,lpMsg);
    }
    return FALSE;
}

INT WINAPI
CZippyWindow::TranslateAccelerator(
    IN HACCEL hAccTable,
    IN LPMSG lpMsg
    )

/*++

Routine Description:

    This calls the win32 TranslateAccelerator to determine
    if the given message is an accelerator for this window

Arguments:

    hAccTable - Accelerator table to use

    lpMsg - Message to check

Return value:
    
    See Win32 TranslateAccelerator documentation

--*/
{
    // :: Necessary to get the win32 call.
    return ::TranslateAccelerator(m_hWnd,hAccTable,lpMsg);
}


//
//  *** Private Class Members ***
//

// static members


DWORD
CZippyWindow::_InitClassStaticMembers(
	)

/*++

Routine Description:

    Creates the window class for zippy and registers
    for the FINDMSGSTRING windows message

Arguments:

    None

Return value:
    
    0 - Success

    Non zero - Win32 error code

--*/
{
	WNDCLASS wndClass;
    HMODULE hLibrary;

    // We want to load RichEdit for the lifetime of our app.
    hLibrary = LoadLibrary(_T("Riched20.dll"));
    if (!hLibrary) {
        return GetLastError();
    }

    ZeroMemory(&wndClass,sizeof(wndClass));

	wndClass.style = CS_PARENTDC;
	wndClass.lpfnWndProc = _WindowProc;
    wndClass.hInstance = g_hInstance;
    wndClass.hIcon = (HICON)LoadImage(g_hInstance,MAKEINTRESOURCE(IDI_MAINFRAME),
        IMAGE_ICON,0,0,LR_SHARED);
    wndClass.hbrBackground = (HBRUSH)COLOR_WINDOWFRAME;
    wndClass.lpszMenuName = MAKEINTRESOURCE(IDR_MAINMENU);
	wndClass.lpszClassName = _T("ZippyWindowClass");

    gm_Atom = RegisterClass(&wndClass);
    if (!gm_Atom) {
        return GetLastError();
    }

    gm_FindMessageStringMsg = RegisterWindowMessage(FINDMSGSTRING);
    if (!gm_FindMessageStringMsg) {
        return GetLastError();
    }

    gm_Inited = TRUE;

    return ERROR_SUCCESS;
}

LRESULT CALLBACK
CZippyWindow::_WindowProc(
    IN HWND hWnd,
    IN UINT uMsg,
    IN WPARAM wParam, 
    IN LPARAM lParam)

/*++

Routine Description:

    Static version of the window proc.  On WM_CREATE it calls OnCreate,
    otherwise it calls the non-static window proc

Arguments:

    See Win32 Window Proc docs

Return value:
    
    Message specific.  See individual handlers for detail.

--*/
{
    CZippyWindow *theClass;

    if (uMsg == WM_CREATE) {
        SetLastError(0);
        theClass = (CZippyWindow *)((LPCREATESTRUCT)lParam)->lpCreateParams;
        SetWindowLongPtr(hWnd,GWLP_USERDATA,(LONG_PTR)theClass);
        if (GetLastError()) {
            return -1;
        }
        return theClass->OnCreate(hWnd);
    }
    theClass = (CZippyWindow*)GetWindowLongPtr(hWnd,GWLP_USERDATA);
    if (theClass) {
        return theClass->WindowProc(hWnd,uMsg,wParam,lParam);
    } else {
        return DefWindowProc(hWnd,uMsg,wParam,lParam);
    }
}

LRESULT CALLBACK
CZippyWindow::WindowProc(
    IN HWND hWnd,
    IN UINT uMsg,
    IN WPARAM wParam, 
    IN LPARAM lParam)

/*++

Routine Description:

    Non-static window proc.  Either calls the default window proc or
    refers to the individual message handlers

Arguments:

    See Win32 Window Proc docs

Return value:
    
    Message specific.  See individual handlers for detail.

--*/
{
    
    LRESULT retCode = 0;

    switch (uMsg) {
    case WM_COMMAND:
        OnCommand(wParam,lParam);
        break;
    case WM_SETFOCUS:
        OnSetFocus();
        break;
    case WM_SIZE:
        OnSize(LOWORD(lParam),HIWORD(lParam));
        break;
    case WM_INITMENUPOPUP:
        OnInitMenuPopup(wParam,lParam);
        break;
    case WM_MENUSELECT:
        OnMenuSelect(wParam,lParam);
        break;
    case WM_CLOSE:
        OnClose();
        break;
    case WM_DESTROY:
        OnDestroy();
        break;
    default:
        if (uMsg == gm_FindMessageStringMsg) {
            OnFindMessageString(lParam);
        } else {
            retCode = DefWindowProc(hWnd,uMsg,wParam,lParam);
        }
        break;
    }

    return retCode;
}


LRESULT
CZippyWindow::OnCreate(
    IN HWND hWnd
    )

/*++

Routine Description:

    Creates the child windows and sets their initial parameters

Arguments:

    hWnd - Pointer to the new main window

Return value:
    
    0 - Window was created

    -1 - Error occurred

--*/
{
    DWORD dwStyle;
    CHARFORMAT charFormat;
    TCHAR readyString[MAX_STR_LEN];

    dwStyle = WS_CHILD|WS_VISIBLE|WS_VSCROLL|WS_HSCROLL|ES_SUNKEN|
        ES_MULTILINE|ES_LEFT|ES_AUTOHSCROLL|ES_AUTOVSCROLL|ES_NOHIDESEL;
    m_hControlWnd = CreateWindow(RICHEDIT_CLASS,_T(""),
        dwStyle,0,0,0,0,hWnd,NULL,g_hInstance,NULL);
    if (!m_hControlWnd) {
        return -1;
    }
    
    dwStyle = SBARS_SIZEGRIP|WS_CHILD|WS_VISIBLE;

    m_hStatusWnd = CreateWindow(STATUSCLASSNAME,NULL,dwStyle,0,0,0,0,hWnd,NULL,
        g_hInstance,NULL);
    if (!m_hStatusWnd) {
        return -1;
    }

    LoadStringSimple(IDS_STATUSBARREADY,readyString);
    SendMessage(m_hStatusWnd,SB_SETTEXT,0|SBT_NOBORDERS,(LPARAM)readyString);


    charFormat.cbSize = sizeof(charFormat);
    charFormat.dwMask = CFM_FACE|CFM_SIZE;
    charFormat.yHeight = ZIPPY_FONT_SIZE*20;
    _tcscpy(charFormat.szFaceName,ZIPPY_FONT);

    // 4 billion characters should be a large enough limit...
    SendMessage(m_hControlWnd,EM_EXLIMITTEXT,0,0xFFFFFFFF);

    SendMessage(m_hControlWnd,EM_SETCHARFORMAT,SCF_ALL,(LPARAM)&charFormat);

    SendMessage(m_hControlWnd,EM_SETMODIFY,FALSE,0);

    SendMessage(m_hControlWnd,EM_EMPTYUNDOBUFFER,0,0);


    return 0;
}

VOID
CZippyWindow::OnMenuSelect(
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Sets the help string in the status bar for the selected menu.

Arguments:

    wParam - menu itemid (LOWORD) and flags (HIWORD)

    lParam - menu handle

Return value:
    
    None

--*/
{
    UINT item;
    UINT flags;
    HMENU hMenu;
    TCHAR statusMessage[MAX_STR_LEN];

    item = LOWORD(wParam);
    flags = HIWORD(wParam);
    hMenu = (HMENU)lParam;

    if (!item && flags == 0xFFFF) {
        // the menu was closed.  Go back to the ready string.
        LoadStringSimple(IDS_STATUSBARREADY,statusMessage);
        SendMessage(m_hStatusWnd,SB_SETTEXT,0|SBT_NOBORDERS,(LPARAM)statusMessage);
        return;
    }
    if (flags & MF_POPUP) {
        statusMessage[0] = 0;
    } else if (!LoadStringSimple(item,statusMessage)) {
        // if we can't find the help string use the empty string.
        statusMessage[0] = 0;
    }
    SendMessage(m_hStatusWnd,SB_SETTEXT,0|SBT_NOBORDERS,(LPARAM)statusMessage);

}

VOID
CZippyWindow::OnSize(
    IN INT width,
    IN INT height
    )

/*++

Routine Description:

    Resizes client windows to reflect the new size of the main window

Arguments:

    width - New width of the client area

    height - New height of the client area

Return value:
    
    None

--*/
{
    RECT statusBarArea;
    UINT statusBarHeight;
    RECT wndRect;

    if (!(width==0&&height==0)) {
        if (GetWindowRect(m_hWnd,&wndRect)) {
            SaveWindowPos(&wndRect);
        }
    }
    if (IsWindowVisible(m_hStatusWnd)) {
        GetWindowRect(m_hStatusWnd,&statusBarArea);
        statusBarHeight = statusBarArea.bottom - statusBarArea.top;

        SetWindowPos(m_hControlWnd,NULL,0,0,width,height-statusBarHeight,SWP_NOZORDER);
        
        // the status bar autosizes.  We just need to tell it that it should
        SetWindowPos(m_hStatusWnd,NULL,0,0,0,0,SWP_NOZORDER);
    } else {
        SetWindowPos(m_hControlWnd,NULL,0,0,width,height,SWP_NOZORDER);
    }
}

VOID
CZippyWindow::OnSetFocus(
    )

/*++

Routine Description:

    When we get focus we kick it down to the rich edit control

Arguments:

    None

Return value:
    
    None

--*/
{
    SetFocus(m_hControlWnd);
}

VOID
CZippyWindow::OnInitMenuPopup(
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    When the user opens the menus we need to specify
    which are disabled and which are checked. Note that
    the menu id's are hard coded.  I've commented which
    corespond to which for the switch statement

Arguments:

    wParam - The menu handle

    lParam - (loword) the menu item id

Return value:
    
    None

--*/
{
    HMENU hMenu;
    WORD item;
    
    item = LOWORD(lParam);
    hMenu = (HMENU)wParam;

    switch (item) {
        case 1: // Edit Menu
            UINT canUndo;
            UINT canRedo;
            UINT cutCopyEnabled;
            UINT pasteEnabled;
            UINT selectAllEnabled;
            UINT findEnabled;
            UINT findNextEnabled;
            UINT replaceEnabled;
            LRESULT textLength;
            CHARRANGE selRegion;

            if (SendMessage(m_hControlWnd,EM_CANUNDO,0,0)) {
                canUndo = MF_ENABLED;
            } else {
                canUndo = MF_GRAYED;
            }
            if (SendMessage(m_hControlWnd,EM_CANREDO,0,0)) {
                canRedo = MF_ENABLED;
            } else {
                canRedo = MF_GRAYED;
            }

            textLength = SendMessage(m_hControlWnd,WM_GETTEXTLENGTH,0,0);
            if (textLength == 0) {
                selectAllEnabled = MF_GRAYED;
                findEnabled = MF_GRAYED;
                findNextEnabled = MF_GRAYED;
                replaceEnabled = MF_GRAYED;
            } else {
                selectAllEnabled = MF_ENABLED;
                findEnabled = MF_ENABLED;
                replaceEnabled = MF_ENABLED;
                if (m_FindReplace.lpstrFindWhat[0] != 0) {
                    findNextEnabled = MF_ENABLED;
                } else {
                    findNextEnabled = MF_GRAYED;
                }
            }
                            
            SendMessage(m_hControlWnd,EM_EXGETSEL,0,(LPARAM)&selRegion);
            if (selRegion.cpMax == selRegion.cpMin) {
                cutCopyEnabled = MF_GRAYED;
            } else {
                cutCopyEnabled = MF_ENABLED;
                // override select all since they selected the next character
                // to be typed
                selectAllEnabled = MF_ENABLED;
            }

            if (SendMessage(m_hControlWnd,EM_CANPASTE,0,0)) {
                pasteEnabled = MF_ENABLED;
            } else {
                pasteEnabled = MF_GRAYED;
            }
            
            EnableMenuItem(hMenu,ID_EDIT_UNDO,MF_BYCOMMAND|canUndo);
            EnableMenuItem(hMenu,ID_EDIT_REDO,MF_BYCOMMAND|canRedo);
            EnableMenuItem(hMenu,ID_EDIT_CUT,MF_BYCOMMAND|cutCopyEnabled);
            EnableMenuItem(hMenu,ID_EDIT_COPY,MF_BYCOMMAND|cutCopyEnabled);
            EnableMenuItem(hMenu,ID_EDIT_PASTE,MF_BYCOMMAND|pasteEnabled);
            EnableMenuItem(hMenu,ID_EDIT_SELECTALL,MF_BYCOMMAND|selectAllEnabled);
            EnableMenuItem(hMenu,ID_EDIT_FIND,MF_BYCOMMAND|findEnabled);
            EnableMenuItem(hMenu,ID_EDIT_FINDNEXT,MF_BYCOMMAND|findNextEnabled);
            EnableMenuItem(hMenu,ID_EDIT_REPLACE,MF_BYCOMMAND|replaceEnabled);
            break;
        case 2: // View Menu
            UINT statusBarChecked;

            if (IsWindowVisible(m_hStatusWnd)) {
                statusBarChecked = MF_CHECKED;
            } else {
                statusBarChecked = MF_UNCHECKED;
            }
            CheckMenuItem(hMenu,ID_VIEW_STATUSBAR,MF_BYCOMMAND|statusBarChecked);
            
            break;
        case 3: // Monitoring Menu
            UINT startActivated;
            UINT stopActivated;

            if (m_bIsTracing) {
                startActivated = MF_GRAYED;
                stopActivated = MF_ENABLED;
            } else {
                startActivated = MF_ENABLED;
                stopActivated = MF_GRAYED;
            }

            EnableMenuItem(hMenu,ID_MONITORING_START,MF_BYCOMMAND|startActivated);
            EnableMenuItem(hMenu,ID_MONITORING_STOP,MF_BYCOMMAND|stopActivated);
            // record is activated when stop is.
            EnableMenuItem(hMenu,ID_MONITORING_RECORD,MF_BYCOMMAND|stopActivated);
            break;
    }
}

VOID
CZippyWindow::OnFindMessageString(
    IN LPARAM lParam
    )

/*++

Routine Description:

    This handles a message from the find/replace
    dialog when a user hits a button

Arguments:

    lParam - LPFINDREPLACE struct for the dialog

Return value:
    
    None

--*/
{
    LPFINDREPLACE lpFindReplace;
    
    lpFindReplace = (LPFINDREPLACE)lParam;

    if (lpFindReplace->Flags & FR_DIALOGTERM) {
        // the dialog is closing
        m_hWndFindReplace = NULL;
    } else if (lpFindReplace->Flags & FR_FINDNEXT) {
        // the user selected find
        DoFindNext(lpFindReplace);
    } else if (lpFindReplace->Flags & FR_REPLACE) {
        DoReplace(lpFindReplace);
    } else if (lpFindReplace->Flags & FR_REPLACEALL) {
        DoReplaceAll(lpFindReplace);
    }
}

VOID
CZippyWindow::OnClose(
    )

/*++

Routine Description:

    When we receive a close window request we prompt
    the user to sace the trace if they have changed it.

Arguments:

    None

Return value:
    
    None

--*/
{
    INT result;
    TCHAR dlgMessage[MAX_STR_LEN];
    TCHAR dlgTitle[MAX_STR_LEN];

    if (SendMessage(m_hControlWnd,EM_GETMODIFY,0,0)) {
        LoadStringSimple(IDS_SAVEFILEPROMPT,dlgMessage);
        LoadStringSimple(IDS_ZIPPYWINDOWTITLE,dlgTitle);

        result = MessageBox(m_hWnd,dlgMessage,dlgTitle,MB_YESNOCANCEL|MB_ICONQUESTION);
        switch (result) {
        case IDYES:
            OnSave();
            if (SendMessage(m_hControlWnd,EM_GETMODIFY,0,0)) {
                // if there was an error saving we will try again.
                PostMessage(m_hWnd,WM_CLOSE,0,0);
                return;
            }
        case IDNO:
            DestroyWindow(m_hWnd);
            break;
        }
    } else {
        DestroyWindow(m_hWnd);
    }
}

VOID
CZippyWindow::OnDestroy(
    )

/*++

Routine Description:

    When the main window exits we halt the message loop

Arguments:

    None

Return value:
    
    None

--*/
{
    // If we don't clean up the tracing stuff here. There is a long
    // delay exiting for some reason.
    CTraceManager::_CleanupTraceManager();
    PostQuitMessage(0);
}



VOID
CZippyWindow::OnCommand(
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Below is WM_COMMAND and all the handler functions.
    The individual handler funcitons are not
    that interesting so I didn't individually comment them.

Arguments:

    wParam - (loword) command the user selected

    lParam - not used but it is the control

Return value:
    
    None

--*/
{
    WORD command;

    command = LOWORD(wParam);

    switch (command) {
    case ID_FILE_SAVE:
        OnSave();
        break;
    case ID_FILE_SAVEAS:
        OnSaveAs();
        break;
    case ID_FILE_LOADCONF:
        OnLoadConfiguration();
        break;
    case ID_FILE_SAVECONF:
        OnSaveConfiguration();
        break;
    case ID_FILE_SAVECONFAS:
        OnSaveConfigurationAs();
        break;
    case ID_FILE_EXIT:
        OnExit();
        break;
    case ID_EDIT_UNDO:
        OnUndo();
        break;
    case ID_EDIT_REDO:
        OnRedo();
        break;
    case ID_EDIT_CUT:
        OnCut();
        break;
    case ID_EDIT_COPY:
        OnCopy();
        break;
    case ID_EDIT_PASTE:
        OnPaste();
        break;
    case ID_EDIT_FIND:
        OnFind();
        break;
    case ID_EDIT_FINDNEXT:
        OnFindNext();
        break;
    case ID_EDIT_REPLACE:
        OnReplace();
        break;
    case ID_EDIT_SELECTALL:
        OnSelectAll();
        break;
    case ID_VIEW_STATUSBAR:
        OnChangeStatusBar();
        break;
    case ID_MONITORING_START:
        OnStartTracing();
        break;
    case ID_MONITORING_STOP:
        OnStopTracing();
        break;
    case ID_MONITORING_RECORD:
        OnRecordTracing();
        break;
    case ID_MONITORING_CLEARSCREEN:
        OnClearScreen();
        break;
    case ID_MONITORING_RESETTRACEFILES:
        OnResetTraceFiles();
        break;
    case ID_MONITORING_PREFERENCES:
        OnPreferences();
        break;
    case ID_HELP_ABOUTEZIPPY:
        OnAbout();
        break;
    }
}

VOID CZippyWindow::OnSave()
{
    if (m_SaveFile[0] == 0) {
        // if we don't have a file name do the
        // Save As version
        OnSaveAs();
    } else {
        DoSaveInternal();
    }
}

VOID CZippyWindow::OnSaveAs()
{
    OPENFILENAME fileInfo;
    BOOL bResult;

    ZeroMemory(&fileInfo,sizeof(fileInfo));

    fileInfo.lStructSize = sizeof(fileInfo);
    fileInfo.hwndOwner = m_hWnd;
    fileInfo.hInstance = g_hInstance;
    fileInfo.lpstrFilter = SAVE_FILE_TYPE;
    fileInfo.lpstrFile = m_SaveFile;
    fileInfo.nMaxFile = MAX_STR_LEN;
    fileInfo.Flags = OFN_OVERWRITEPROMPT;
    fileInfo.lpstrDefExt = SAVE_FILE_EXTENSION;

    bResult = GetSaveFileName(&fileInfo);
    if (!bResult) {
        return;
    }

    DoSaveInternal();
}

VOID CZippyWindow::OnLoadConfiguration()
{
    OPENFILENAME fileInfo;
    BOOL bResult;

    ZeroMemory(&fileInfo,sizeof(fileInfo));

    fileInfo.lStructSize = sizeof(fileInfo);
    fileInfo.hwndOwner = m_hWnd;
    fileInfo.hInstance = g_hInstance;
    fileInfo.lpstrFilter = SAVE_CONF_FILE_TYPE;
    fileInfo.lpstrFile = m_LoadConfFile;
    fileInfo.nMaxFile = MAX_STR_LEN;
    fileInfo.Flags = OFN_FILEMUSTEXIST;
    fileInfo.lpstrDefExt = SAVE_CONF_FILE_EXTENSION;

    bResult = GetOpenFileName(&fileInfo); 
    if (!bResult) {
        return;
    }

    DoLoadConfInternal();
}

VOID CZippyWindow::OnSaveConfiguration()
{
    if (m_SaveConfFile[0] == 0) {
        // if we don't have a file name do the
        // Save As version
        OnSaveConfigurationAs();
    } else {
        DoSaveConfInternal();
    }
}

VOID CZippyWindow::OnSaveConfigurationAs()
{
    OPENFILENAME fileInfo;
    BOOL bResult;

    ZeroMemory(&fileInfo,sizeof(fileInfo));

    fileInfo.lStructSize = sizeof(fileInfo);
    fileInfo.hwndOwner = m_hWnd;
    fileInfo.hInstance = g_hInstance;
    fileInfo.lpstrFilter = SAVE_CONF_FILE_TYPE;
    fileInfo.lpstrFile = m_SaveConfFile;
    fileInfo.nMaxFile = MAX_STR_LEN;
    fileInfo.Flags = OFN_OVERWRITEPROMPT;
    fileInfo.lpstrDefExt = SAVE_CONF_FILE_EXTENSION;

    bResult = GetSaveFileName(&fileInfo);
    if (!bResult) {
        return;
    }

    DoSaveConfInternal();
    
}

VOID CZippyWindow::OnExit()
{
    PostMessage(m_hWnd,WM_CLOSE,0,0);
}

// All the edit menu commands.  Except for select all they just call the
// corresponding message in the rich edit control. Select all has to
// manually set the selection

VOID CZippyWindow::OnUndo()
{
    SendMessage(m_hControlWnd,WM_UNDO,0,0);
}

VOID CZippyWindow::OnRedo()
{
    SendMessage(m_hControlWnd,EM_REDO,0,0);
}

VOID CZippyWindow::OnCut()
{
    SendMessage(m_hControlWnd,WM_CUT,0,0);
}

VOID CZippyWindow::OnCopy()
{
    SendMessage(m_hControlWnd,WM_COPY,0,0);
}

VOID CZippyWindow::OnPaste()
{
    SendMessage(m_hControlWnd,WM_PASTE,0,0);
}

VOID CZippyWindow::OnSelectAll()
{
    CHARRANGE selection;
    
    selection.cpMin = 0;
    selection.cpMax = -1;

    SendMessage(m_hControlWnd,EM_EXSETSEL,0,(LPARAM)&selection);
}

VOID CZippyWindow::OnFind()
{
    CHARRANGE currentSel;
    TEXTRANGE textRange;

    if (IsWindow(m_hWndFindReplace) && !m_bIsFindNotReplace) {
        // If they were in a replace dialog we destroy it and then
        // start over with a find dialog
        DestroyWindow(m_hWndFindReplace);
        m_hWndFindReplace = NULL;
    }
    if (!IsWindow(m_hWndFindReplace)) {
        SendMessage(m_hControlWnd,EM_EXGETSEL,0,(LPARAM)&currentSel);
    
        textRange.chrg.cpMin = currentSel.cpMin;
        if (currentSel.cpMax - currentSel.cpMin >=  FIND_REPLACE_BUFFER_SIZE) {
            textRange.chrg.cpMax = currentSel.cpMin + FIND_REPLACE_BUFFER_SIZE-1;
        } else {
            textRange.chrg.cpMax = currentSel.cpMax;
        }
        textRange.lpstrText = m_FindReplace.lpstrFindWhat;

        SendMessage(m_hControlWnd,EM_GETTEXTRANGE,0,(LPARAM)&textRange);

        m_bIsFindNotReplace = TRUE;
        m_FindReplace.hwndOwner = m_hWnd;
        m_FindReplace.hInstance = g_hInstance;
        m_FindReplace.Flags = FR_DOWN|FR_HIDEUPDOWN;
        m_FindReplace.wFindWhatLen = FIND_REPLACE_BUFFER_SIZE;
        m_hWndFindReplace = FindText(&m_FindReplace);
    } else {
        SetActiveWindow(m_hWndFindReplace);
    }

}

VOID CZippyWindow::OnFindNext()
{
    DoFindNext(&m_FindReplace);
}

VOID CZippyWindow::OnReplace()
{
    CHARRANGE currentSel;
    TEXTRANGE textRange;

    if (IsWindow(m_hWndFindReplace) && m_bIsFindNotReplace) {
        // If they were in a replace dialog we destroy it and then
        // start over with a find dialog
        DestroyWindow(m_hWndFindReplace);
        m_hWndFindReplace = NULL;
    }
    if (!IsWindow(m_hWndFindReplace)) {
        SendMessage(m_hControlWnd,EM_EXGETSEL,0,(LPARAM)&currentSel);
    
        textRange.chrg.cpMin = currentSel.cpMin;
        if (currentSel.cpMax - currentSel.cpMin >=  FIND_REPLACE_BUFFER_SIZE) {
            textRange.chrg.cpMax = currentSel.cpMin + FIND_REPLACE_BUFFER_SIZE-1;
        } else {
            textRange.chrg.cpMax = currentSel.cpMax;
        }
        textRange.lpstrText = m_FindReplace.lpstrFindWhat;
        SendMessage(m_hControlWnd,EM_GETTEXTRANGE,0,(LPARAM)&textRange);
        
        m_bIsFindNotReplace = FALSE;
        m_FindReplace.hwndOwner = m_hWnd;
        m_FindReplace.hInstance = g_hInstance;
        m_FindReplace.Flags = FR_DOWN;
        m_FindReplace.wFindWhatLen = FIND_REPLACE_BUFFER_SIZE;
        m_FindReplace.wReplaceWithLen = FIND_REPLACE_BUFFER_SIZE;
        m_hWndFindReplace = ReplaceText(&m_FindReplace);
    } else {
        SetActiveWindow(m_hWndFindReplace);
    }
}

VOID CZippyWindow::OnChangeStatusBar()
{
    RECT clientRect;
    
    if (IsWindowVisible(m_hStatusWnd)) {
        ShowWindow(m_hStatusWnd,SW_HIDE);
    } else {
        ShowWindow(m_hStatusWnd,SW_SHOW);
    }
    // we do this to make the client windows resize themselves
    // around the status bar

    GetClientRect(m_hWnd,&clientRect);
    OnSize(clientRect.right,clientRect.bottom);
}

VOID CZippyWindow::OnStartTracing()
{
    m_bIsTracing = TRUE;
}

VOID CZippyWindow::OnStopTracing()
{
    m_bIsTracing = FALSE;
}

VOID CZippyWindow::OnRecordTracing()
{
    CModalOkDialog recordDialog;
    LPSAVEDOUTPUT lpTemp;

    m_bIsStoringTraceData = TRUE;
    recordDialog.DoModal(MAKEINTRESOURCE(IDD_RECORDTRACE),m_hWnd);

    WaitForSingleObject(m_hAppendMutex,INFINITE);

    m_bIsStoringTraceData = FALSE;
    while (m_lpSavedOutputStart) {
        AppendTextToWindow(m_lpSavedOutputStart->procID,
            m_lpSavedOutputStart->text,m_lpSavedOutputStart->len);
        lpTemp = m_lpSavedOutputStart;
        m_lpSavedOutputStart = m_lpSavedOutputStart->next;
        HeapFree(GetProcessHeap(),0,lpTemp);
    }
    m_lpSavedOutputTail = NULL;

    ReleaseMutex(m_hAppendMutex);
}

VOID CZippyWindow::OnClearScreen()
{
    TCHAR dlgTitle[MAX_STR_LEN];
    TCHAR dlgMessage[MAX_STR_LEN];

    LoadStringSimple(IDS_CLEARCONFIRMTITLE,dlgTitle);
    LoadStringSimple(IDS_CLEARCONFIRMMESSAGE,dlgMessage);

    if (IDYES != MessageBox(m_hWnd,dlgMessage,dlgTitle,MB_YESNO)) {
        return;
    }

    OnSelectAll();
    SendMessage(m_hControlWnd, EM_REPLACESEL,FALSE,(LPARAM)_T(""));
}

VOID CZippyWindow::OnResetTraceFiles()
{
    TCHAR dlgTitle[MAX_STR_LEN];
    TCHAR dlgMessage[MAX_STR_LEN];

    LoadStringSimple(IDS_CONFIRMRESETTRACETITLE,dlgTitle);
    LoadStringSimple(IDS_CONFIRMRESETTRACEMESSAGE,dlgMessage);

    if (IDYES != MessageBox(m_hWnd,dlgMessage,dlgTitle,MB_YESNO)) {
        return;
    }

    m_rTracer->TRC_ResetTraceFiles();
}

VOID CZippyWindow::OnPreferences()
{
    COptionsDialog optionsDialog(m_rTracer);

    optionsDialog.DoDialog(m_hWnd);
}

VOID CZippyWindow::OnAbout()
{
    HICON appIcon;
    TCHAR appTitle[MAX_STR_LEN];
    TCHAR appOtherStuff[MAX_STR_LEN];

    LoadStringSimple(IDS_ABOUTAPPTITLE,appTitle);
    LoadStringSimple(IDS_ABOUTOTHERSTUFF,appOtherStuff);
    appIcon = (HICON)LoadImage(g_hInstance,MAKEINTRESOURCE(IDI_MAINFRAME),
        IMAGE_ICON,0,0,LR_SHARED);
    
    if( NULL != appIcon )
    {
      ShellAbout(m_hWnd,appTitle,appOtherStuff,appIcon);
    
    // even though the icon is shared we should destroy it to keep the reference
    // count somewhat sane.
      DestroyIcon(appIcon);
    }
}

//
//  *** Private Helper Functions ***
//

//
// Computes the color for the given debut output.  It parses the text to dtermine
// what the thread id is and then either retrieves the color for that thread or
// picks a new color
//
BOOL CZippyWindow::ComputeNewColor(DWORD processID, LPCTSTR text, UINT len, CHARFORMAT *lpFormat)
{
    LPTSTR procIdStr;
    DWORD threadId;
    LPCTSTR procBase;
    UINT maxStrLen;
    BOOL bSuccess;
    UINT threadLen;
    LPTHREADCOLOR newColor;

    procIdStr = NULL;
    bSuccess = TRUE;

    // first we will just make sure the format struct is in a safe state.
    lpFormat->cbSize = sizeof(CHARFORMAT);
    lpFormat->dwMask = 0;

    maxStrLen = sizeof(DWORD) * 2;
    
    procIdStr = (LPTSTR)HeapAlloc(GetProcessHeap(),0,sizeof(TCHAR) * (maxStrLen+1));
    if (!procIdStr) {
        bSuccess = FALSE;
        goto CLEANUP_AND_EXIT;
    }

    wsprintf(procIdStr,TRC_PROC_FMT,processID);

    procBase = _tcsstr(text,procIdStr);
    if (!procBase) {
        bSuccess = FALSE;
        goto CLEANUP_AND_EXIT;
    }

    procBase += _tcslen(procIdStr);

    if (*procBase != ':') {
        bSuccess = FALSE;
        goto CLEANUP_AND_EXIT;
    }
    procBase++;

    threadLen = 0;
    while (_istxdigit(*(procBase + threadLen))) {
        threadLen++;
    }
    if (!threadLen) {
        bSuccess = FALSE;
        goto CLEANUP_AND_EXIT;
    }
   
    threadId = ConvertHexStrToDword(procBase,threadLen);
    
    newColor = FindColorForThread(processID,threadId);

    lpFormat->crTextColor = newColor->color;
    lpFormat->dwEffects = 0;
    lpFormat->dwMask = CFM_COLOR;

CLEANUP_AND_EXIT:
    
    if (procIdStr) {
        HeapFree(GetProcessHeap(),0,procIdStr);
    }

    return bSuccess;
}

//
// This converts a hex string to the equivalent DWORD value for example
// the string "FF" would cause the function to return 0xFF (255)
//
DWORD CZippyWindow::ConvertHexStrToDword(LPCTSTR str, UINT strLen)
{
    DWORD total;
    TCHAR current;
    INT currentValue;

    total = 0;
    if (strLen == 0) {
        strLen = _tcslen(str);
    }

    while (strLen-- > 0) {
        current = *(str++);
        if (_istdigit(current)) {
            currentValue = current - '0';
        } else {
            current = (TCHAR)tolower((INT)current);
            currentValue = 10 + (current - 'a');
        }
        total = (total * 16) + currentValue;
    }

    return total;
}

// This looks up the color for the given thread.  If the thread has not been
// seen before a new color is picked and the color for the thread is saved.
LPTHREADCOLOR CZippyWindow::FindColorForThread(DWORD processId, DWORD threadId)
{
    int i = 0;
    LPTHREADCOLOR lpThreadColor;

    for (i=0;i<COLOR_HISTORY_COUNT;i++) {
        if (m_threadHistory[i].threadId == threadId &&
            m_threadHistory[i].processId == processId) {
            return &m_threadHistory[i];
        }
    }
    // else this is the first time we saw the thread

    lpThreadColor = &m_threadHistory[m_nextThreadIndex++];
    if (m_nextThreadIndex == COLOR_HISTORY_COUNT) {
        m_nextThreadIndex = 0;
    }
    lpThreadColor->processId = processId;
    lpThreadColor->threadId = threadId;
    lpThreadColor->color = colors[m_nextThreadColor++];
    if (m_nextThreadColor == NUM_COLORS) {
        m_nextThreadColor = 0;
    }

    return lpThreadColor;
}

// This handles actually saving the document.
VOID CZippyWindow::DoSaveInternal()
{
    HANDLE saveFile;
    EDITSTREAM saveStream;
    LRESULT bytesSaved;
    TCHAR dlgTitle[MAX_STR_LEN];
    TCHAR dlgMessage[MAX_STR_LEN];

    saveFile = CreateFile(m_SaveFile,GENERIC_WRITE,0,NULL,CREATE_ALWAYS,
        0,NULL);
    if (saveFile==INVALID_HANDLE_VALUE) {
        LoadStringSimple(IDS_FILEOPENERROR,dlgMessage);
        LoadStringSimple(IDS_ZIPPYWINDOWTITLE,dlgTitle);

        MessageBox(m_hWnd,dlgMessage,dlgTitle,MB_OK|MB_ICONERROR);
        return;
    }

    saveStream.dwCookie = (DWORD_PTR)saveFile;
    saveStream.dwError = 0;
    saveStream.pfnCallback = SaveCallback;

    bytesSaved = SendMessage(m_hControlWnd,EM_STREAMOUT,SF_TEXT,(LPARAM)&saveStream);

    CloseHandle(saveFile);

    if (saveStream.dwError != 0) {
        LoadStringSimple(IDS_FILESAVEERROR,dlgMessage);
        LoadStringSimple(IDS_ZIPPYWINDOWTITLE,dlgTitle);

        MessageBox(m_hWnd,dlgMessage,dlgTitle,MB_OK|MB_ICONERROR);
    } else {
        SendMessage(m_hControlWnd,EM_SETMODIFY,FALSE,0);
    }


}

// This is a private callback function which rich edit calls when
// saving out the document
static DWORD CALLBACK
SaveCallback(DWORD_PTR dwCookie,LPBYTE pbBuff,LONG cb,LONG *pcb)
{
    HANDLE fileHandle;

    fileHandle = (HANDLE)dwCookie;

    if (!WriteFile(fileHandle,pbBuff,cb,(PULONG)pcb,NULL)) {
        return GetLastError();
    }
    return 0;
}

// As the function name says this does a find next operation
// on the rich edit control
BOOL CZippyWindow::DoFindNext(LPFINDREPLACE lpFindReplace)
{
    FINDTEXTEX findText;
    WPARAM searchOptions;
    CHARRANGE currentSel;
    TCHAR dlgTitle[MAX_STR_LEN];
    TCHAR dlgMessage[MAX_STR_LEN];

    SendMessage(m_hControlWnd,EM_EXGETSEL,0,(LPARAM)&currentSel);
    findText.chrg.cpMin = currentSel.cpMax;
    findText.chrg.cpMax = -1;
    
    findText.lpstrText = lpFindReplace->lpstrFindWhat;

    searchOptions = FR_DOWN;
    if (lpFindReplace->Flags & FR_MATCHCASE) {
        searchOptions |= FR_MATCHCASE;
    }
    if (lpFindReplace->Flags & FR_WHOLEWORD) {
        searchOptions |= FR_WHOLEWORD;
    }
    
    if (0 <= SendMessage(m_hControlWnd, EM_FINDTEXTEX,searchOptions,
        (LPARAM)&findText)) {
        SendMessage(m_hControlWnd, EM_EXSETSEL,0,(LPARAM)&findText.chrgText);
    } else {
        LoadStringSimple(IDS_SEARCHFAILURE,dlgMessage);
        LoadStringSimple(IDS_ZIPPYWINDOWTITLE,dlgTitle);

        MessageBox(m_hWndFindReplace,dlgMessage,dlgTitle,MB_OK);

        return FALSE;
    }

    return TRUE;
    
}

// This does a replace operation on the control
BOOL CZippyWindow::DoReplace(LPFINDREPLACE lpFindReplace)
{
    FINDTEXTEX findText;
    WPARAM searchOptions;
    CHARRANGE currentSel;
    TCHAR dlgTitle[MAX_STR_LEN];
    TCHAR dlgMessage[MAX_STR_LEN];

    SendMessage(m_hControlWnd,EM_EXGETSEL,0,(LPARAM)&currentSel);
    findText.chrg.cpMin = currentSel.cpMin;
    findText.chrg.cpMax = -1;
    
    findText.lpstrText = lpFindReplace->lpstrFindWhat;

    searchOptions = FR_DOWN;
    if (lpFindReplace->Flags & FR_MATCHCASE) {
        searchOptions |= FR_MATCHCASE;
    }
    if (lpFindReplace->Flags & FR_WHOLEWORD) {
        searchOptions |= FR_WHOLEWORD;
    }
    
    if (-1 == SendMessage(m_hControlWnd, EM_FINDTEXTEX,searchOptions,
        (LPARAM)&findText)) {
        // if we can't find what they were looking for just give up.
        LoadStringSimple(IDS_SEARCHFAILURE,dlgMessage);
        LoadStringSimple(IDS_ZIPPYWINDOWTITLE,dlgTitle);
        
        MessageBox(m_hWndFindReplace,dlgMessage,dlgTitle,MB_OK);
        return FALSE;
    }

    if (currentSel.cpMin == findText.chrgText.cpMin && 
        currentSel.cpMax == findText.chrgText.cpMax) {
        SendMessage(m_hControlWnd,EM_REPLACESEL,0,(LPARAM)lpFindReplace->lpstrReplaceWith);
        // Now select the next occurrence
        return DoFindNext(lpFindReplace);
    } else {
        // They weren't on what they were searching for so select it.
        SendMessage(m_hControlWnd, EM_EXSETSEL,0,(LPARAM)&findText.chrgText);
    }

    return TRUE;

}

// This loops on DoReplace until DoReplace returns FALSE
VOID CZippyWindow::DoReplaceAll(LPFINDREPLACE lpFindReplace)
{
    while (DoReplace(lpFindReplace));
}

// This actually saves the traceconfiguration.  We just write
// out the binary config structure to the file
VOID CZippyWindow::DoSaveConfInternal()
{
    HANDLE saveFile;
    TRC_CONFIG trcConfig;
    TCHAR dlgTitle[MAX_STR_LEN];
    TCHAR dlgMessage[MAX_STR_LEN];
    DWORD bytesWritten;

    saveFile = CreateFile(m_SaveConfFile,GENERIC_WRITE,0,NULL,CREATE_ALWAYS,
        0,NULL);
    if (saveFile==INVALID_HANDLE_VALUE) {
        LoadStringSimple(IDS_FILEOPENERROR,dlgMessage);
        LoadStringSimple(IDS_ZIPPYWINDOWTITLE,dlgTitle);

        MessageBox(m_hWnd,dlgMessage,dlgTitle,MB_OK|MB_ICONERROR);
        return;
    }

    m_rTracer->GetCurrentConfig(&trcConfig);

    if (!WriteFile(saveFile,&trcConfig,sizeof(trcConfig),&bytesWritten,NULL) ||
        bytesWritten != sizeof(trcConfig)) {
        
        LoadStringSimple(IDS_FILESAVEERROR,dlgMessage);
        LoadStringSimple(IDS_ZIPPYWINDOWTITLE,dlgTitle);

        MessageBox(m_hWnd,dlgMessage,dlgTitle,MB_OK|MB_ICONERROR);
    }
   
    CloseHandle(saveFile);

}

// This reads in the binary configuration structure and then
// sets it as the current tracing config
VOID CZippyWindow::DoLoadConfInternal()
{
    HANDLE openFile;
    DWORD bytesRead;
    TRC_CONFIG trcConfig;
    TCHAR dlgTitle[MAX_STR_LEN];
    TCHAR dlgMessage[MAX_STR_LEN];
    

    openFile = CreateFile(m_LoadConfFile,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,
        0,NULL);
    if (openFile==INVALID_HANDLE_VALUE) {
        LoadStringSimple(IDS_FILELOADOPENERROR,dlgMessage);
        LoadStringSimple(IDS_ZIPPYWINDOWTITLE,dlgTitle);

        MessageBox(m_hWnd,dlgMessage,dlgTitle,MB_OK|MB_ICONERROR);
        return;
    }

    if (!ReadFile(openFile,&trcConfig,sizeof(trcConfig),&bytesRead,NULL)||
        bytesRead != sizeof(trcConfig)) {
        LoadStringSimple(IDS_FILELOADERROR,dlgMessage);
        LoadStringSimple(IDS_ZIPPYWINDOWTITLE,dlgTitle);

        MessageBox(m_hWnd,dlgMessage,dlgTitle,MB_OK|MB_ICONERROR);
    }
    
    m_rTracer->SetCurrentConfig(&trcConfig);

}

// Reads the saved window position in from the registry.
VOID CZippyWindow::GetSavedWindowPos(LPRECT savedPos)
{
    DWORD dwResult;
    DWORD dwSize;
    DWORD dwType;
    RECT rect;
    HKEY hKey;
    
    savedPos->top = WINDOW_DEF_TOP;
    savedPos->bottom = WINDOW_DEF_BOTTOM;
    savedPos->left = WINDOW_DEF_LEFT;
    savedPos->right = WINDOW_DEF_RIGHT;

    dwResult = RegOpenKeyEx(HKEY_CURRENT_USER,ZIPPY_REG_KEY,0,
        KEY_QUERY_VALUE,&hKey);
    if (dwResult) {
        return;
    }
    dwSize = sizeof(RECT);
    dwResult = RegQueryValueEx(hKey,ZIPPY_WINDOW_POS_VALUE,NULL,&dwType,
        (LPBYTE)&rect,&dwSize);
    RegCloseKey(hKey);
    if (dwResult||dwSize != sizeof(RECT)||dwType!=REG_BINARY) {
        return;
    }

    *savedPos = rect;
}

// Saves the window position out to the registry
VOID CZippyWindow::SaveWindowPos(LPRECT newPos)
{
    DWORD dwResult;
    HKEY hKey;

    dwResult = RegCreateKeyEx(HKEY_CURRENT_USER,ZIPPY_REG_KEY,0,_T(""),0,
        KEY_SET_VALUE,NULL,&hKey,NULL);
    if (dwResult) {
        return;
    }

    RegSetValueEx(hKey,ZIPPY_WINDOW_POS_VALUE,0,REG_BINARY,
        (LPBYTE)newPos,sizeof(RECT));
    
    RegCloseKey(hKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\tssec\clicert.c ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    clicert.c

Abstract:

    Contains code related to the tshare certificate validation and data
    encryption using server public key.

Author:

    Madan Appiah (madana)  24-Jan-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#include <seccom.h>
BOOL
UnpackServerCert(
    LPBYTE pbCert,
    DWORD dwCertLen,
    PHydra_Server_Cert pServerCert
    )
/*++

Routine Description:

    This function unpacks the blob of server certicate to server certificate
    structure.

Arguments:

    pbCert - pointer to the server public key blob.

    dwCertLen - length of the above server public key.

    pServerCert - pointer to a server certificate structure.

Return Value:

    TRUE - if successfully unpacked.
    FALSE - otherwise.

--*/
{
    LPBYTE pbScan;
    DWORD cbScan;
    //
    // return if the pointer are invalid.
    // return if the certificate is insufficient length.
    //

    if( (pbCert == NULL) ||
        (dwCertLen < (3 * sizeof(DWORD) + 4 * sizeof(WORD))) ||
        (pServerCert == NULL) ) {

        return( FALSE );
    }

    pbScan = pbCert;
    cbScan = dwCertLen;
    //
    // Assign dwVersion
    //

    pServerCert->dwVersion = *(DWORD UNALIGNED FAR *)pbScan;
    pbScan += sizeof(DWORD);
    cbScan -= sizeof(DWORD);
    //
    // Assign dwSigAlgID
    //

    pServerCert->dwSigAlgID = *(DWORD UNALIGNED FAR *)pbScan;
    pbScan += sizeof(DWORD);
    cbScan -= sizeof(DWORD);
    //
    // Assign dwSignID
    //

    pServerCert->dwKeyAlgID  = *(DWORD UNALIGNED FAR *)pbScan;
    pbScan += sizeof(DWORD);
    cbScan -= sizeof(DWORD);
    //
    //Assign PublicKeyData
    //

    pServerCert->PublicKeyData.wBlobType = *(WORD UNALIGNED FAR *)pbScan;
    pbScan += sizeof(WORD);
    cbScan -= sizeof(WORD);

    if( pServerCert->PublicKeyData.wBlobType != BB_RSA_KEY_BLOB ) {
        return( FALSE );
    }

    pServerCert->PublicKeyData.wBlobLen = *(WORD UNALIGNED FAR *)pbScan;
    pbScan += sizeof(WORD);
    cbScan -= sizeof(WORD);
    
    if( pServerCert->PublicKeyData.wBlobLen > 0 ) {
        
        if(cbScan < pServerCert->PublicKeyData.wBlobLen) {
            return ( FALSE );
        }
        pServerCert->PublicKeyData.pBlob = pbScan;
        pbScan += pServerCert->PublicKeyData.wBlobLen;
        cbScan -= pServerCert->PublicKeyData.wBlobLen;
    }
    else {

        pServerCert->PublicKeyData.pBlob = NULL;
    }

    //
    // Assign SignatureBlob
    //
    
    if(cbScan < sizeof(WORD)) {
        return ( FALSE );
    }
    pServerCert->SignatureBlob.wBlobType = *(WORD UNALIGNED *)pbScan;
    pbScan += sizeof(WORD);
    cbScan -= sizeof(WORD);

    if( pServerCert->SignatureBlob.wBlobType != BB_RSA_SIGNATURE_BLOB ) {
        return( FALSE );
    }
    
    if(cbScan < sizeof(WORD)) {
        return ( FALSE );
    }
    pServerCert->SignatureBlob.wBlobLen = *(WORD UNALIGNED FAR *)pbScan;
    pbScan += sizeof(WORD);
    cbScan -= sizeof(WORD);

    if( pServerCert->SignatureBlob.wBlobLen > 0 ) {
        
        if(cbScan < pServerCert->SignatureBlob.wBlobLen) {
            return ( FALSE );
        }
        pServerCert->SignatureBlob.pBlob = pbScan;
    }
    else {

        pServerCert->SignatureBlob.pBlob = NULL;
    }

    return( TRUE );
}

BOOL
ValidateServerCert(
    PHydra_Server_Cert pServerCert
    )
/*++

Routine Description:

    This function validate the server public key.

Arguments:

    pSserverCert - pointer to a server certificate.

Return Value:

    TRUE - if the server public key is valid.
    FALSE - otherwise.

--*/
{

    DWORD dwLen;
    LPBYTE pbSignature;
    MD5_CTX HashState;
    BYTE SignHash[0x48];
    LPBYTE pbScan;

    //
    // pack the certificate data into a byte blob excluding the signature info.
    //

    dwLen =
        3 * sizeof(DWORD) +
        2 * sizeof(WORD) +
        pServerCert->PublicKeyData.wBlobLen;

    //
    // allocated space for the binary blob.
    //

    pbSignature = malloc( (UINT)dwLen );

    if( pbSignature == NULL ) {
        return( FALSE );
    }

    pbScan = pbSignature;

    memcpy( pbScan, &pServerCert->dwVersion, sizeof(DWORD));
    pbScan += sizeof(DWORD);

    memcpy( pbScan, &pServerCert->dwSigAlgID, sizeof(DWORD));
    pbScan += sizeof(DWORD);

    memcpy( pbScan, &pServerCert->dwKeyAlgID, sizeof(DWORD));
    pbScan += sizeof(DWORD);

    memcpy( pbScan, &pServerCert->PublicKeyData.wBlobType, sizeof(WORD));
    pbScan += sizeof(WORD);

    memcpy( pbScan, &pServerCert->PublicKeyData.wBlobLen, sizeof(WORD));
    pbScan += sizeof(WORD);

    memcpy(
        pbScan,
        pServerCert->PublicKeyData.pBlob,
        pServerCert->PublicKeyData.wBlobLen);

    //
    // generate the hash on the data.
    //

    MD5Init( &HashState );
    MD5Update( &HashState, pbSignature, dwLen );
    MD5Final( &HashState );

    //
    // free the signature blob, we don't need it anymore.
    //

    free( pbSignature );

    //
    // initialize the pulic key.
    //

    g_pPublicKey = (LPBSAFE_PUB_KEY)g_abPublicKeyModulus;

    g_pPublicKey->magic = RSA1;
    g_pPublicKey->keylen = 0x48;
    g_pPublicKey->bitlen = 0x0200;
    g_pPublicKey->datalen = 0x3f;
    g_pPublicKey->pubexp = 0xc0887b5b;

    //
    // decrypt the signature.
    //

    memset(SignHash, 0x00, 0x48);
    BSafeEncPublic( g_pPublicKey, pServerCert->SignatureBlob.pBlob, SignHash);

    //
    // compare the hash value.
    //

    if( memcmp( SignHash, HashState.digest, 16 )) {
        return( FALSE );
    }

    //
    // successfully validated the signature.
    //

    return( TRUE );
}


BOOL
EncryptClientRandom(
    LPBYTE pbSrvPublicKey,
    DWORD dwSrvPublicKey,
    LPBYTE pbRandomKey,
    DWORD dwRandomKeyLen,
    LPBYTE pbEncRandomKey,
    LPDWORD pdwEncRandomKey
    )
/*++

Routine Description:

    Encrypt the client random using server's public key.

Arguments:

    pbSrvPublicKey - pointer to the server public key.

    dwSrvPublicKey - length of the server public key.

    pbRandomKey - pointer to a buffer where the client random key.

    dwRandomKeyLen - length of the random key passed in.

    pbEncRandomKey - pointer to a buffer where the encrypted client random is
        returned.

    pdwEncRandomKey - pointer to a place where the length of the above buffer is
        passed in and length of the buffer used/required is returned.

Return Value:

    TRUE - if the key is encrypted successfully.
    FALSE - otherwise.

--*/
{
    LPBSAFE_PUB_KEY pSrvPublicKey;
    BYTE abInputBuffer[512];

    ASSERT( pbSrvPublicKey != NULL );
    pSrvPublicKey = (LPBSAFE_PUB_KEY)pbSrvPublicKey;

    //
    // check to see buffer length pointer is valid.
    //

    if( pdwEncRandomKey == NULL ) {
        return( FALSE );
    }

    //
    // check to see a output buffer is specified and
    // the encrypt buffer length is sufficient.
    //

    if( (pbEncRandomKey == NULL) ||
        (*pdwEncRandomKey < pSrvPublicKey->keylen) ) {

        *pdwEncRandomKey = pSrvPublicKey->keylen;
        return( FALSE );
    }

    //
    // make sure the random key data and its length are valid.
    //

    ASSERT( pbRandomKey != NULL );
    ASSERT( dwRandomKeyLen <= pSrvPublicKey->datalen );
    ASSERT( pSrvPublicKey->datalen < pSrvPublicKey->keylen );
    ASSERT( pSrvPublicKey->keylen <= sizeof(abInputBuffer) );

    //
    // init the input buffer.
    //

    memset( abInputBuffer, 0x0, (UINT)pSrvPublicKey->keylen );

    //
    // copy data to be encrypted in the input buffer.
    //

    memcpy( abInputBuffer, pbRandomKey, (UINT)dwRandomKeyLen );

    //
    // initialize the output buffer.
    //

    memset( pbEncRandomKey, 0x0, (UINT)pSrvPublicKey->keylen );

    //
    // encrypt data now.
    //

    if( !BSafeEncPublic(
            pSrvPublicKey,
            (LPBYTE)abInputBuffer,
            pbEncRandomKey ) ) {

        *pdwEncRandomKey = 0;
        return( FALSE );
    }

    //
    // successfully encrypted the client random,
    // return the encrypted data length.
    //

    *pdwEncRandomKey = pSrvPublicKey->keylen;
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\tssec\hydrakey.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows Terminal Server
//  Copyright (C) Microsoft Corporation, 1989-1998.
//
//  File:       HydraKey.h
//
//  Contents:   Hydra Server "Root" Public Key
//
//--------------------------------------------------------------------

#ifndef __HYDRAKEY__
#define __HYDRAKEY__

//
// This is the public key used to verify a
// hydra server's certificate
//
#define HYDRA_ROOT_PUBLIC_KEY \
     {                                                      \
     0x00, 0x00, 0x00, 0x00,                                \
     0x00, 0x00, 0x00, 0x00,                                \
     0x00, 0x00, 0x00, 0x00,                                \
     0x00, 0x00, 0x00, 0x00,                                \
     0x00, 0x00, 0x00, 0x00,                                \
     0x3d, 0x3a, 0x5e, 0xbd, 0x72, 0x43, 0x3e, 0xc9,        \
     0x4d, 0xbb, 0xc1, 0x1e, 0x4a, 0xba, 0x5f, 0xcb,        \
     0x3e, 0x88, 0x20, 0x87, 0xef, 0xf5, 0xc1, 0xe2,        \
     0xd7, 0xb7, 0x6b, 0x9a, 0xf2, 0x52, 0x45, 0x95,        \
     0xce, 0x63, 0x65, 0x6b, 0x58, 0x3a, 0xfe, 0xef,        \
     0x7c, 0xe7, 0xbf, 0xfe, 0x3d, 0xf6, 0x5c, 0x7d,        \
     0x6c, 0x5e, 0x06, 0x09, 0x1a, 0xf5, 0x61, 0xbb,        \
     0x20, 0x93, 0x09, 0x5f, 0x05, 0x6d, 0xea, 0x87,        \
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00         \
     }


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\trace\ezippy\zippywindow.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Zippy Main Window

Abstract:

    This class implements the main window for zippy as well as controlling
    its child windows.

Author:

    Marc Reyhner 8/28/2000

--*/

#ifndef __ZIPPYWINDOW_H__
#define __ZIPPYWINDOW_H__

#include "eZippy.h"

//  The number of colors we remember
#define COLOR_HISTORY_COUNT     100

// Struct representing a remembered thread color
typedef struct _THREADCOLOR {
    DWORD processId;
    DWORD threadId;
    COLORREF color;
} THREADCOLOR, FAR *LPTHREADCOLOR;

typedef struct _SAVEDOUTPUT {
    DWORD procID;
    LPTSTR text;
    UINT len;
    struct _SAVEDOUTPUT *next;
} SAVEDOUTPUT, FAR *LPSAVEDOUTPUT;

class CTraceManager;

class CZippyWindow  
{
public:
	CZippyWindow();
	virtual ~CZippyWindow();
    DWORD Create(CTraceManager *rTracer);
    VOID AppendTextToWindow(DWORD processID, LPCTSTR text,UINT len);
    VOID LoadConfFile(LPTSTR confFile);
    BOOL IsDialogMessage(LPMSG lpMsg);
    INT WINAPI TranslateAccelerator(HACCEL hAccTable,LPMSG lpMsg);

private:

	static BOOL gm_Inited;
	static ATOM gm_Atom;
    static UINT gm_FindMessageStringMsg;
    
    HWND m_hWnd;
    HWND m_hControlWnd;
    HWND m_hStatusWnd;
    HWND m_hWndFindReplace;
    BOOL m_bIsTracing;
    BOOL m_bIsStoringTraceData;
    BOOL m_bIsFindNotReplace;
    UINT m_nextThreadIndex;
    UINT m_nextThreadColor;
    DWORD m_lastProcessId;
    DWORD m_LastLogEndedInNewLine;
    HANDLE m_hAppendMutex;
    TCHAR m_SaveFile[MAX_STR_LEN];
    TCHAR m_SaveConfFile[MAX_STR_LEN];
    TCHAR m_LoadConfFile[MAX_STR_LEN];
	FINDREPLACE m_FindReplace;
    THREADCOLOR m_threadHistory[COLOR_HISTORY_COUNT];
    LPSAVEDOUTPUT m_lpSavedOutputStart;
    LPSAVEDOUTPUT m_lpSavedOutputTail;
    CTraceManager *m_rTracer;

    static DWORD _InitClassStaticMembers();
    static LRESULT CALLBACK _WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, 
        LPARAM lParam);
    
    LRESULT CALLBACK WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, 
        LPARAM lParam);
    
    // Window message handlers
    LRESULT OnCreate(HWND hWnd);
    VOID OnMenuSelect(WPARAM wParam, LPARAM lParam);
	VOID OnSize(INT width, INT height);
	VOID OnSetFocus();
    VOID OnInitMenuPopup(WPARAM wParam, LPARAM lParam);
	VOID OnFindMessageString(LPARAM lParam);
    VOID OnClose();
    VOID OnDestroy();
    
    //
    //  WM_COMMAND handler and all the helper functions for the various
    //  command.
    //
    VOID OnCommand(WPARAM wParam, LPARAM lParam);
	VOID OnSave();
    VOID OnSaveAs();
    VOID OnLoadConfiguration();
	VOID OnSaveConfiguration();
	VOID OnSaveConfigurationAs();
	VOID OnExit();
	VOID OnUndo();
	VOID OnRedo();
	VOID OnCut();
	VOID OnCopy();
	VOID OnPaste();
	VOID OnSelectAll();
	VOID OnFind();
	VOID OnFindNext();
	VOID OnReplace();
	VOID OnChangeStatusBar();
	VOID OnStartTracing();
	VOID OnStopTracing();
    VOID OnRecordTracing();
	VOID OnClearScreen();
	VOID OnResetTraceFiles();
	VOID OnPreferences();
    VOID OnAbout();
	
	// Internal helper functions
    VOID DoLoadConfInternal();
	VOID DoSaveConfInternal();
    VOID DoReplaceAll(LPFINDREPLACE lpFindReplace);
	BOOL DoReplace(LPFINDREPLACE lpFindReplace);
	BOOL DoFindNext(LPFINDREPLACE lpFindReplace);
	VOID DoSaveInternal();
    LPTHREADCOLOR FindColorForThread(DWORD processId, DWORD threadId);
	DWORD ConvertHexStrToDword(LPCTSTR str, UINT strLen);
	BOOL ComputeNewColor(DWORD processID, LPCTSTR text, UINT len, CHARFORMAT *lpFormat);
	
    VOID GetSavedWindowPos(LPRECT savedPos);
    VOID SaveWindowPos(LPRECT newPos);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\tssec\genrand.c ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    tssec.c

Abstract:

    Contains code that generates random keys.

Author:

    Madan Appiah (madana)  1-Jan-1998
    Modified by Nadim Abdo 31-Aug-2001 to use system RNG

Environment:

    User Mode - Win32

Revision History:

--*/

#include <seccom.h>
#include <stdlib.h>

#include <rng.h>

#ifndef OS_WINCE
#include <randlib.h>
#endif

VOID
TSRNG_Initialize(
    )
{
#ifndef OS_WINCE
    InitializeRNG(NULL);
#else
    TSInitializeRNG();
#endif
}


VOID
TSRNG_Shutdown(
    )
{
#ifndef OS_WINCE
    ShutdownRNG(NULL);
#endif
}



//
// function definitions
//

BOOL
TSRNG_GenerateRandomBits(
    LPBYTE pbRandomBits,
    DWORD  cbLen
    )
/*++

Routine Description:

    This function returns random bits

Arguments:

    pbRandomBits - pointer to a buffer where a random key is returned.

    cbLen - length of the random key required.

Return Value:

    TRUE - if a random key is generated successfully.
    FALSE - otherwise.

--*/
{
#ifndef OS_WINCE
    BOOL fRet;
    
    fRet = NewGenRandom(NULL, NULL, pbRandomBits, cbLen);

    return fRet;
#else
    GenerateRandomBits(pbRandomBits, cbLen);
    return( TRUE );
#endif
}



// Legacy RNG's
VOID
InitRandomGenerator(
    VOID
    )
{
    //
    // initialize the random generator first.
    //

    TSInitializeRNG();
}

//
// function definitions
//
BOOL
GenerateRandomKey(
    LPBYTE pbRandomKey,
    DWORD dwRandomKeyLen
    )
/*++

Routine Description:

    This function makes and return the microsoft terminal server certificate
    blob of data.

Arguments:

    pbRandomKey - pointer to a buffer where a random key is returned.

    dwRandomKeyLen - length of the random key required.

Return Value:

    TRUE - if a random key is generated successfully.
    FALSE - otherwise.

--*/
{
    //
    // generate random bits now.
    //

    legacyGenerateRandomBits( pbRandomKey, dwRandomKeyLen );
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\tssec\glodata.c ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    glodata.c

Abstract:

    Global data definitions for tshare security.

Author:

    Madan Appiah (madana)  24-Jan-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#include <seccom.h>

//
// global data definitions.
//

const BYTE g_abPad1[40] = {
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36
};

const BYTE g_abPad2[48] = {
    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C
};

LPBSAFE_PUB_KEY g_pPublicKey;

BYTE g_abPublicKeyModulus[] = HYDRA_ROOT_PUBLIC_KEY;
BOOL g_128bitEncryptionEnabled = TRUE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\tssec\global.h ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    global.h

Abstract:

    Global data definitions for tshare security.

Author:

    Madan Appiah (madana)  24-Jan-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _GLOBAL_H_
#define _GLOBAL_H_


//
// global data definitions.
//

extern const BYTE g_abPad1[40];

extern const BYTE g_abPad2[48];

extern LPBSAFE_PUB_KEY g_pPublicKey;

extern BYTE g_abPublicKeyModulus[92];

extern BYTE g_abServerCertificate[184];

extern BYTE g_abServerPrivateKey[380];

extern BOOL g_128bitEncryptionEnabled;

#endif // _GLOBAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\tssec\encrypt.c ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    encrypt.c

Abstract:

    Contains functions that encrypt and decrypt data sent accross client and
    server.

Author:

    Madan Appiah (madana)  24-Jan-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#include <seccom.h>

VOID
GenerateMACSignature(
    LPBYTE pbData,
    DWORD dwDataLen,
    LPBYTE pbMACSaltKey,
    DWORD dwMACSaltKey,
    LPBYTE pbSignature,
    BOOL   fIncludeEncryptionCount,
    DWORD  dwEncryptionCount
    )
/*++

Routine Description:

    This function generates a message authentication signature.

Arguments:

    pbData - pointer to a data buffer.

    dwDataLen - length of the above data.

    pbMACSaltKey - pointer to a MAC salt key.

    pbSignature - pointer a signature buffer.
    
    fIncludeEncryptionCount - TRUE to salt in the encryption count
    
    dwEncryptionCount - total encryption count

Return Value:

    None.

--*/
{
    A_SHA_CTX       SHAHash;
    MD5_CTX         MD5Hash;
    BYTE            abSHADigest[A_SHA_DIGEST_LEN];

    //
    // make a SHA(MACSalt + g_abPad1 + Length + Content) hash.
    //

    A_SHAInit(&SHAHash);
    A_SHAUpdate(&SHAHash, pbMACSaltKey, dwMACSaltKey);
    A_SHAUpdate(&SHAHash, (unsigned char *)g_abPad1, 40);
    A_SHAUpdate(&SHAHash, (LPBYTE)&dwDataLen, sizeof(DWORD));
    A_SHAUpdate(&SHAHash, pbData, dwDataLen);
    if (fIncludeEncryptionCount) {
        A_SHAUpdate(&SHAHash, (LPBYTE)&dwEncryptionCount, sizeof(DWORD));
    }
    A_SHAFinal(&SHAHash, abSHADigest);

    //
    // make a MD5(MACSalt + g_abPad2 + SHAHash) hash.
    //

    MD5Init(&MD5Hash);
    MD5Update(&MD5Hash, pbMACSaltKey, dwMACSaltKey);
    MD5Update(&MD5Hash, g_abPad2, 48);
    MD5Update(&MD5Hash, abSHADigest, A_SHA_DIGEST_LEN);
    MD5Final(&MD5Hash);

    ASSERT( DATA_SIGNATURE_SIZE <= MD5DIGESTLEN );
    memcpy(pbSignature, MD5Hash.digest, DATA_SIGNATURE_SIZE);

    return;
}

BOOL
EncryptData(
    DWORD dwEncryptionLevel,
    LPBYTE pSessionKey,
    struct RC4_KEYSTRUCT FAR *prc4EncryptKey,
    DWORD dwKeyLength,
    LPBYTE pbData,
    DWORD dwDataLen,
    LPBYTE pbMACSaltKey,
    LPBYTE pbSignature,
    BOOL   fSecureChecksum,
    DWORD  dwEncryptionCount
    )
/*++

Routine Description:

    Encrypt the given data buffer in place.

Arguments:

    dwEncryptionLevel - encryption level, used to select the encryption
        algorithm.

    pSessionKey - pointer to the session key.

    prc4EncryptKey - pointer to a RC4 key.

    dwKeyLength - length of the session key.

    pbData - pointer to the data buffer being encrypted, encrypted data is
        returned in the same buffer.

    dwDataLen - length of the data buffer.

    pbMACSaltKey - pointer to a message authentication key buffer.

    pbSignature - pointer to a signature buffer where the data signature is
        returned.

    fSecureChecksum - TRUE if the checksum is to be salted with the encryption
                      count
                             
    dwDecryptionCount - running counter of all encryptions

Return Value:

    TRUE - if successfully encrypted the data.

    FALSE - otherwise.

--*/
{
    //
    // generate the MAC signature first.
    //

    GenerateMACSignature (
        pbData,
        dwDataLen,
        pbMACSaltKey,
        dwKeyLength,
        pbSignature,
        fSecureChecksum,
        dwEncryptionCount
        );


    //
    // encrypt data.
    //

    //
    // use microsoft version of rc4 algorithm (super fast!) for level 1 and
    // level 2 encryption, for level 3 use RSA rc4 algorithm.
    //

    if( dwEncryptionLevel <= 2 ) {

        msrc4(prc4EncryptKey, (UINT)dwDataLen, pbData );
    }
    else {

        rc4(prc4EncryptKey, (UINT)dwDataLen, pbData );
    }


    return( TRUE );
}

BOOL
DecryptData(
    DWORD dwEncryptionLevel,
    LPBYTE pSessionKey,
    struct RC4_KEYSTRUCT FAR *prc4DecryptKey,
    DWORD dwKeyLength,
    LPBYTE pbData,
    DWORD dwDataLen,
    LPBYTE pbMACSaltKey,
    LPBYTE pbSignature,
    BOOL   fSecureChecksum,
    DWORD  dwDecryptionCount
    )
/*++

Routine Description:

    Decrypt the given data buffer in place.

Arguments:

    dwEncryptionLevel - encryption level, used to select the encryption
        algorithm.

    pSessionKey - pointer to the session key.

    prc4DecryptKey - pointer to a RC4 key.

    dwKeyLength - length of the session key.

    pbData - pointer to the data buffer being decrypted, decrypted data is
        returned in the same buffer.

    dwDataLen - length of the data buffer.

    pbMACSaltKey - pointer to a message authentication key buffer.

    pbSignature - pointer to a signature buffer where the data signature is
        returned.
        
    fSecureChecksum - TRUE if the checksum is to be salted with the encryption
                      count
                             
    dwDecryptionCount - running counter of all encryptions

Return Value:

    TRUE - if successfully encrypted the data.

    FALSE - otherwise.

--*/
{
    BYTE abSignature[DATA_SIGNATURE_SIZE];

    //
    // decrypt data.
    //

    //
    // use microsoft version of rc4 algorithm (super fast!) for level 1 and
    // level 2 encryption, for level 3 use RSA rc4 algorithm.
    //

    if( dwEncryptionLevel <= 2 ) {
        msrc4(prc4DecryptKey, (UINT)dwDataLen, pbData );
    }
    else {
        rc4(prc4DecryptKey, (UINT)dwDataLen, pbData );
    }

    GenerateMACSignature (
        pbData,
        dwDataLen,
        pbMACSaltKey,
        dwKeyLength,
        (LPBYTE)abSignature,
        fSecureChecksum,
        dwDecryptionCount
        );

    //
    // check to see the sigature match.
    //

    if( memcmp(
            (LPBYTE)abSignature,
            pbSignature,
            sizeof(abSignature) ) ) {
        return( FALSE );
    }

    return( TRUE );
}

#ifdef USE_MSRC4

VOID
msrc4_key(
    struct RC4_KEYSTRUCT FAR *pKS,
    DWORD dwLen,
    LPBYTE pbKey
    )
/*++

Routine Description:

    Generate the key control structure.  Key can be any size.

    Assumes pKS is locked against simultaneous use.

Arguments:

    pKS - pointer to a KEYSTRUCT structure that will be initialized.

    dwLen - Size of the key, in bytes.

    pbKey - Pointer to the key.

Return Value:

    NONE.

--*/
{

#define SWAP(_x_, _y_) { BYTE _t_; _t_ = (_x_); (_x_) = (_y_); (_y_) = _t_; }

    BYTE index1;
    BYTE index2;
    UINT counter;
    BYTE bLen;

    ASSERT( dwLen < 256 );

    bLen = ( dwLen >= 256 ) ? 255 : (BYTE)dwLen;

    for (counter = 0; counter < 256; counter++) {
        pKS->S[counter] = (BYTE) counter;
    }

    pKS->i = 0;
    pKS->j = 0;

    index1 = 0;
    index2 = 0;

    for (counter = 0; counter < 256; counter++) {
        index2 = (pbKey[index1] + pKS->S[counter] + index2);
        SWAP(pKS->S[counter], pKS->S[index2]);
        index1 = (index1 + 1) % bLen;
    }
}

VOID
msrc4(
    struct RC4_KEYSTRUCT FAR *pKS,
    DWORD dwLen,
    LPBYTE pbuf
    )
/*++

Routine Description:

    Performs the actual encryption or decryption.

    Assumes pKS is locked against simultaneous use.

Arguments:

    pKS - Pointer to the KEYSTRUCT created using msrc4_key().

    dwLen - Size of buffer, in bytes.

    pbuf - Buffer to be encrypted.

Return Value:

    NONE.

--*/
{

    BYTE FAR *const s = pKS->S;
    BYTE a, b;

    while(dwLen--) {

        a = s[++(pKS->i)];
        pKS->j += a;
        b = s[pKS->j];
        s[pKS->j] = a;
        a += b;
        s[pKS->i] = b;
        *pbuf++ ^= s[a];
    }
}

#endif // USE_MSRC4


/****************************************************************************/
/* PortableEncode and PortableEncode50 are functions used to                */
/* encrypt/decrypt data on different machines.                              */
/****************************************************************************/
#define PE_RANDOM_CONSTANT "d72775a4-c832-11d1-9685-00c04fb15601"
void PortableEncode(LPBYTE pbData, DWORD dwDataLen)
{
    A_SHA_CTX       SHAHash;
    BYTE            abSHADigest[A_SHA_DIGEST_LEN];
    struct RC4_KEYSTRUCT rc4Key;

    A_SHAInit(&SHAHash);
    A_SHAUpdate(&SHAHash, (LPBYTE)PE_RANDOM_CONSTANT,
            sizeof(PE_RANDOM_CONSTANT));
    A_SHAFinal(&SHAHash, abSHADigest);
    msrc4_key(&rc4Key, MAX_SESSION_KEY_SIZE, abSHADigest);
    msrc4(&rc4Key, (UINT)dwDataLen, pbData);
}

void PortableEncode50(LPBYTE pbData,
                      DWORD dwDataLen,
                      LPBYTE pbSalt,
                      DWORD dwSaltLength)
{
    A_SHA_CTX       SHAHash;
    BYTE            abSHADigest[A_SHA_DIGEST_LEN];
    DWORD           dw;
    struct RC4_KEYSTRUCT rc4Key;

    A_SHAInit(&SHAHash);
    A_SHAUpdate(&SHAHash, (LPBYTE)PE_RANDOM_CONSTANT,
                sizeof(PE_RANDOM_CONSTANT));
    A_SHAFinal(&SHAHash, abSHADigest);

    for (dw = 0; dw < 256; dw++) {
        A_SHAInit(&SHAHash);
        A_SHAUpdate(&SHAHash, pbSalt, dwSaltLength);
        A_SHAUpdate(&SHAHash, abSHADigest, A_SHA_DIGEST_LEN);
        A_SHAFinal(&SHAHash, abSHADigest);
    }
    msrc4_key(&rc4Key, MAX_SESSION_KEY_SIZE, abSHADigest);
    msrc4(&rc4Key, (UINT)dwDataLen, pbData);
}
#undef PE_RANDOM_CONSTANT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\tssec\fencrypt.c ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    encrypt.c

Abstract:

    Contains functions that detect the run system is french locale.

Author:

    Madan Appiah (madana)  16-May-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#include <seccom.h>

#ifdef OS_WIN32

BOOL
IsFrenchSystem(
    VOID
    )
/*++

Routine Description:

    French laws are strict with respect to the import of software products which
    contain cryptography. Therefore many Microsoft products must check for a locale
    of France and disable cryptographic services if this is the case. There is the
    possibility that forms of cryptography currently restricted may eventually be
    allowed in France. For this reason it is valuable to implement a check for a
    crypto approval indicator which could easily be installed on a Windows system in
    the future. The indicator tells the software that it is OK to enable specific
    cryptographic services which may not have been approved for import to France
    when the software was released, but have been subsequently allowed. Below are
    two code fragments, the first indicates how to check for the locale of France.
    The second code fragment is a simple example of how a check for a cryptographic
    approval indicator might be implemented.


    This function implements France Locale detection.

Arguments:

    None.

Return Value:

    TURE - if the system is French.

    FALSE - if not.

--*/
{
#define MAX_INT_SIZE 16

    LCID dwDefaultSystemLCID;
    LANGID wCurrentLangID;
    DWORD dwLen;
    TCHAR achCountryCode[MAX_INT_SIZE];
    DWORD dwCountryCode;

    //
    // Get system default locale ID.
    //

    dwDefaultSystemLCID = GetSystemDefaultLCID();

    //
    // get language ID from locale ID.
    //

    wCurrentLangID = LANGIDFROMLCID(dwDefaultSystemLCID);

    //
    // check to see the system is running with french locale.
    //

    if( ( PRIMARYLANGID(wCurrentLangID) == LANG_FRENCH) &&
        ( SUBLANGID(wCurrentLangID) == SUBLANG_FRENCH) ) {
        return( TRUE );
    }

    //
    // check to see the user's country code is set to CTRY_FRENCH.
    //

    dwLen =
        GetLocaleInfo(
            dwDefaultSystemLCID,
            LOCALE_ICOUNTRY,
            achCountryCode,
            sizeof(achCountryCode) / sizeof(TCHAR));

    if( dwLen == 0 ) {

        //
        // we could not read the country code ..
        //

        return( FALSE );
    }

    //
    // convert the country code string to integer.
    //

    dwCountryCode = (DWORD)_ttol(achCountryCode);

    if( dwCountryCode != CTRY_FRANCE ) {
        return( FALSE );
    }

    //
    // if we are here, then the system is french locale system.
    //

    return( TRUE );
}

#else // OS_WIN32

BOOL
IsFrenchSystem(
    VOID
    )
/*++

Routine Description:

    This function implements France Locale detection for win3.1.

Arguments:

    None.

Return Value:

    TURE - if the system is French.

    FALSE - if not.

--*/
{
#define MAX_LANG_STRING_SIZE 16

    DWORD dwLen;
    CHAR achLangStr[MAX_LANG_STRING_SIZE];

    //
    // read [intl] section in the win.ini to determine the
    // system locale.
    //

    dwLen =
        GetProfileString(
            "intl",
            "sLanguage",
            "",
            achLangStr,
            sizeof(achLangStr));

    if( (dwLen == 3) &&
        (_stricmp(achLangStr, "fra") == 0) ) {

        //
        // french system.
        //

        return( TRUE );
    }

    //
    // now read country code.
    //


    dwLen =
        GetProfileString(
            "intl",
            "iCountry",
            "",
            achLangStr,
            sizeof(achLangStr));

    if( (dwLen == 2) &&
        (_stricmp(achLangStr, "33") == 0) ) {

        //
        // french system.
        //

        return( TRUE );
    }

    //
    // not a french system.
    //

    return( FALSE );
}

#endif // OS_WIN32

BOOL
FindIsFrenchSystem(
    VOID
    )
/*++

Routine Description:

    The function implements a check for the locale of France.

    Note : it makes system calls to determine the system locale once
    and remembers it for later calls.

Arguments:

    None.

Return Value:

    TURE - if the system is French.

    FALSE - if not.

--*/
{
typedef enum {
    Uninitialized   = 0,
    FrenchSystem    = 1,
    NotFrenchSystem = 2
} FrenchSystemType;

    static FrenchSystemType g_dwIsFrenchSystem = Uninitialized;

    if( g_dwIsFrenchSystem == Uninitialized ) {


        if( IsFrenchSystem() ) {
            g_dwIsFrenchSystem = FrenchSystem;
        }
        else {
            g_dwIsFrenchSystem = NotFrenchSystem;
        }
    }

    if( g_dwIsFrenchSystem == FrenchSystem ) {
        return( TRUE );
    }

    return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\tssec\rng.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       rng.h
//
//  Contents:   Functions that are used to generate rnadom numbers
//
//  Classes:
//
//  Functions:  GenerateRandomBits
//                              GatherRandomBits
//
//
//  History:    12-19-97  v-sbhatt   Created
//
//----------------------------------------------------------------------------

#ifndef _RNG_H_
#define _RNG_H_


#define A_SHA_DIGEST_LEN    20
#define RAND_CTXT_LEN       60
#define RC4_REKEY_PARAM     500     // rekey every 500 bytes

typedef struct tagRandContext
{
    DWORD dwBitsFilled;
    BYTE  rgbBitBuffer[RAND_CTXT_LEN];
} RAND_CONTEXT, *PRAND_CONTEXT;

VOID TSInitializeRNG(VOID);
VOID legacyGenerateRandomBits(PUCHAR pbBuffer, ULONG  dwLength);
void legacyGatherRandomBits(PRAND_CONTEXT prandContext);

#endif  //_RNG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\tssec\seccom.h ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    seccom.h

Abstract:

    Common include file for tshare security security module.

Author:

    Madan Appiah (madana)  24-Jan-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _SECCOM_H_
#define _SECCOM_H_

#include <windows.h>
#include <tchar.h>

#include <license.h>
#include <tssec.h>
#include <hydrakey.h>

#include <sha.h>
#include <md5.h>
#include <rsa.h>

#include <secdbg.h>
#include <global.h>

#endif // _SECCOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\tssec\rng.c ===
//This file and the functions are copied from Schannel project and included in
//this project without modification.

#ifndef _WIN32_WINNT
#define _WIN32_WINNT    0x0400
#endif

//#include <spbase.h>
#include <windows.h>
#include "rng.h"
#include <rc4.h>
#include <sha.h>


unsigned char g_rgbStaticBits[A_SHA_DIGEST_LEN];
static DWORD         g_dwRC4BytesUsed = RC4_REKEY_PARAM;     // initially force rekey
static struct RC4_KEYSTRUCT g_rc4key;

static BOOL RandomFillBuffer(BYTE *pbBuffer, DWORD *pdwLength);
static void AppendRand(PRAND_CONTEXT prandContext, void* pv, DWORD dwSize);

#if defined(OS_WINCE) && !defined (WINCE_GLOBAL_ALLOC_DEFINED)

#define ZeroMemory( _p_, _s_ )          memset( (_p_), 0, (_s_) )
#define FillMemory( _p_, _s_, _c_ )     memset( (_p_), (_c_), (_s_) )
#define CopyMemory( _d_, _s_, _c_ )     memcpy( (_d_), (_s_), (_c_) )

#endif // OS_WINCE


/*****************************************************************************/
VOID TSInitializeRNG(VOID)
{


    ZeroMemory( g_rgbStaticBits, sizeof( g_rgbStaticBits ) );
    g_dwRC4BytesUsed = RC4_REKEY_PARAM;

    return;
}

/*****************************************************************************/
VOID legacyInitializeRNG(VOID)
{


    ZeroMemory( g_rgbStaticBits, sizeof( g_rgbStaticBits ) );
    g_dwRC4BytesUsed = RC4_REKEY_PARAM;

    return;
}

/*****************************************************************************/
#ifndef NOGENRANDOM
int GenRandom(PVOID Reserved,
              UCHAR *pbBuffer,
              size_t dwLength)
{
    GenerateRandomBits(pbBuffer, dwLength);
    return TRUE;
}
#endif

/************************************************************************/
/* GenerateRandomBits generates a specified number of random bytes and        */
/* places them into the specified buffer.                                */
/************************************************************************/
/*                                                                      */
/* Pseudocode logic flow:                                               */
/*                                                                      */
/* if (bits streamed > threshold)                                       */
/* {                                                                    */
/*  Gather_Bits()                                                       */
/*  SHAMix_Bits(User, Gathered, Static -> Static)                       */
/*  RC4Key(Static -> newRC4Key)                                         */
/*  SHABits(Static -> Static)      // hash after RC4 key generation     */
/* }                                                                    */
/* else                                                                 */
/* {                                                                    */
/*  SHAMix_Bits(User, Static -> Static)                                 */
/* }                                                                    */
/*                                                                      */
/* RC4(newRC4Key -> outbuf)                                             */
/* bits streamed += sizeof(outbuf)                                      */
/*                                                                      */
/************************************************************************/
VOID legacyGenerateRandomBits(PUCHAR pbBuffer,
                        ULONG  dwLength)
{
    DWORD dwBytesThisPass;
    DWORD dwFilledBytes = 0;

    // break request into chunks that we rekey between


    while(dwFilledBytes < dwLength)
    {
        dwBytesThisPass = dwLength - dwFilledBytes;

        RandomFillBuffer(pbBuffer + dwFilledBytes, &dwBytesThisPass);
        dwFilledBytes += dwBytesThisPass;
    }

}

/*****************************************************************************/
static BOOL RandomFillBuffer(BYTE *pbBuffer, DWORD *pdwLength)
{
    // Variables from loading and storing the registry...
    DWORD   cbDataLen;
    RAND_CONTEXT randContext;
    randContext.dwBitsFilled = 0;

    cbDataLen = A_SHA_DIGEST_LEN;
    legacyGatherRandomBits(&randContext);

    if(g_dwRC4BytesUsed >= RC4_REKEY_PARAM) {
        // if we need to rekey



        // Mix all bits
        {
            A_SHA_CTX SHACtx;
            A_SHAInit(&SHACtx);

            // SHA the static bits
            A_SHAUpdate(&SHACtx, g_rgbStaticBits, A_SHA_DIGEST_LEN);

            // SHA the gathered bits
            A_SHAUpdate(&SHACtx, randContext.rgbBitBuffer, randContext.dwBitsFilled);

            // SHA the user-supplied bits
            A_SHAUpdate(&SHACtx, pbBuffer, *pdwLength);

            // output back out to static bits
            A_SHAFinal(&SHACtx, g_rgbStaticBits);
        }

        // Create RC4 key
        g_dwRC4BytesUsed = 0;
        rc4_key(&g_rc4key, A_SHA_DIGEST_LEN, g_rgbStaticBits);

        // Mix RC4 key bits around
        {
            A_SHA_CTX SHACtx;
            A_SHAInit(&SHACtx);

            // SHA the static bits
            A_SHAUpdate(&SHACtx, g_rgbStaticBits, A_SHA_DIGEST_LEN);

            // output back out to static bits
            A_SHAFinal(&SHACtx, g_rgbStaticBits);
        }

    } else {
        // Use current RC4 key, but capture any user-supplied bits.

        // Mix input bits
        {
            A_SHA_CTX SHACtx;
            A_SHAInit(&SHACtx);

            // SHA the static bits
            A_SHAUpdate(&SHACtx, g_rgbStaticBits, A_SHA_DIGEST_LEN);

            // SHA the user-supplied bits
            A_SHAUpdate(&SHACtx, pbBuffer, *pdwLength);

            // output back out to static bits
            A_SHAFinal(&SHACtx, g_rgbStaticBits);
        }
    }

    // only use RC4_REKEY_PARAM bytes from each RC4 key
    {
        DWORD dwMaxPossibleBytes = RC4_REKEY_PARAM - g_dwRC4BytesUsed;
        if(*pdwLength > dwMaxPossibleBytes) {
                *pdwLength = dwMaxPossibleBytes;
        }
    }

    FillMemory(pbBuffer, *pdwLength, 0);
    rc4(&g_rc4key, *pdwLength, pbBuffer);

    g_dwRC4BytesUsed += *pdwLength;

    return TRUE;
}

/*****************************************************************************/
void legacyGatherRandomBits(PRAND_CONTEXT prandContext)
{
    DWORD   dwTmp;
    WORD    wTmp;
    BYTE    bTmp;

    // ** indicates US DoD's specific recommendations for password generation

    // proc id
    dwTmp = GetCurrentProcessId();
    AppendRand(prandContext, &dwTmp, sizeof(dwTmp));

    // thread id
    dwTmp = GetCurrentThreadId();
    AppendRand(prandContext, &dwTmp, sizeof(dwTmp));

    // ** ticks since boot (system clock)
    dwTmp = GetTickCount();
    AppendRand(prandContext, &dwTmp, sizeof(dwTmp));

    // cursor position
    {
        POINT                        point;
        GetCursorPos(&point);
        bTmp = LOBYTE(point.x) ^ HIBYTE(point.x);
        AppendRand(prandContext, &bTmp, sizeof(BYTE));
        bTmp = LOBYTE(point.y) ^ HIBYTE(point.y);
        AppendRand(prandContext, &bTmp, sizeof(BYTE));
    }

    // ** system time, in ms, sec, min (date & time)
    {
        SYSTEMTIME                sysTime;
        GetLocalTime(&sysTime);
        AppendRand(prandContext, &sysTime.wMilliseconds, sizeof(sysTime.wMilliseconds));
        bTmp = LOBYTE(sysTime.wSecond) ^ LOBYTE(sysTime.wMinute);
        AppendRand(prandContext, &bTmp, sizeof(BYTE));
    }

    // ** hi-res performance counter (system counters)
    {
        LARGE_INTEGER        liPerfCount;
        if(QueryPerformanceCounter(&liPerfCount)) {
            bTmp = LOBYTE(LOWORD(liPerfCount.LowPart)) ^ LOBYTE(LOWORD(liPerfCount.HighPart));
            AppendRand(prandContext, &bTmp, sizeof(BYTE));
            bTmp = HIBYTE(LOWORD(liPerfCount.LowPart)) ^ LOBYTE(LOWORD(liPerfCount.HighPart));
            AppendRand(prandContext, &bTmp, sizeof(BYTE));
            bTmp = LOBYTE(HIWORD(liPerfCount.LowPart)) ^ LOBYTE(LOWORD(liPerfCount.HighPart));
            AppendRand(prandContext, &bTmp, sizeof(BYTE));
            bTmp = HIBYTE(HIWORD(liPerfCount.LowPart)) ^ LOBYTE(LOWORD(liPerfCount.HighPart));
            AppendRand(prandContext, &bTmp, sizeof(BYTE));
        }
    }

    // memory status
    {
        MEMORYSTATUS        mstMemStat;
        mstMemStat.dwLength = sizeof(MEMORYSTATUS);     // must-do
        GlobalMemoryStatus(&mstMemStat);
        wTmp = HIWORD(mstMemStat.dwAvailPhys);          // low words seem to be always zero
        AppendRand(prandContext, &wTmp, sizeof(WORD));
        wTmp = HIWORD(mstMemStat.dwAvailPageFile);
        AppendRand(prandContext, &wTmp, sizeof(WORD));
        bTmp = LOBYTE(HIWORD(mstMemStat.dwAvailVirtual));
        AppendRand(prandContext, &bTmp, sizeof(BYTE));
    }

#ifndef OS_WINCE

    // free disk clusters
    {
        DWORD dwSectorsPerCluster, dwBytesPerSector, dwNumberOfFreeClusters, dwTotalNumberOfClusters;
        if(GetDiskFreeSpace(NULL, &dwSectorsPerCluster, &dwBytesPerSector,     &dwNumberOfFreeClusters, &dwTotalNumberOfClusters)) {
            AppendRand(prandContext, &dwNumberOfFreeClusters, sizeof(dwNumberOfFreeClusters));
            AppendRand(prandContext, &dwTotalNumberOfClusters, sizeof(dwTotalNumberOfClusters));
            AppendRand(prandContext, &dwBytesPerSector, sizeof(dwBytesPerSector));
        }
    }


    // last messages' timestamp
    {
        LONG lTime;
        lTime = GetMessageTime();
        AppendRand(prandContext, &lTime, sizeof(lTime));
    }

    {
        // **SystemID
        DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;
        char lpBuf [MAX_COMPUTERNAME_LENGTH + 1];

        if(GetComputerNameA(lpBuf, &dwSize)) {
            // dwSize = len not including null termination
            AppendRand(prandContext, lpBuf, dwSize);
        }

        //
        // GetUserName can go and add a terminating NULL past the size
        // specified so send it a size one less than the buffer.
        //
        //
        dwSize = MAX_COMPUTERNAME_LENGTH;

        // **UserID
        if(GetUserNameA(lpBuf, &dwSize)) {
            // dwSize = len including null termination
            dwSize -= 1;
            AppendRand(prandContext, lpBuf, dwSize);
        }
    }

#endif // OS_WINCE

}

/*****************************************************************************/
static void AppendRand(PRAND_CONTEXT prandContext, void* pv, DWORD dwSize)
{
    DWORD dwBitsLeft = (RAND_CTXT_LEN - prandContext->dwBitsFilled);

    if(dwBitsLeft > 0) {
        if(dwSize > dwBitsLeft) {
            dwSize = dwBitsLeft;
        }

        CopyMemory(prandContext->rgbBitBuffer + prandContext->dwBitsFilled, pv, dwSize);
        prandContext->dwBitsFilled += dwSize;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\tssec\local.c ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    local.c

Abstract:

    Contains functions that encrypt and decrypt data to be stored locally

Author:

    Adam Overton (adamo)  08-Feb-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#include <seccom.h>
#include <tchar.h>
#include <extypes.h>

#include <license.h>
#include <cryptkey.h>

#if defined(OS_WINCE)
BOOL GetUserName(
  LPTSTR lpBuffer,  // address of name buffer
  LPDWORD pdwSize    // address of size of name buffer
)
/*++

Routine Description:

    Provides the GetUserName API on platforms that don't have it

Arguments:

    lpBuffer - pointer to a buffer for the username
    nSize - size of name buffer

Return Value:

    TRUE - successfully retrieved UserName

    FALSE - otherwise

--*/
{
    DWORD dwT;

    memset(lpBuffer, 0, *pdwSize);

    //
    // There doesn't appear to be user name available, just
    // use a default and rely on the machine UUID for security
    //

    dwT = *pdwSize;
#define USER_RANDOM "eefdbcf0001255b4009c9e1800f73774"
    if (dwT > sizeof(USER_RANDOM))
        dwT = sizeof(USER_RANDOM);
    memcpy(lpBuffer, USER_RANDOM, (size_t)dwT);
    return TRUE;
}
#endif // defined(OS_WINCE)


BOOL GetLocalKey(
    struct RC4_KEYSTRUCT *prc4Key
    )
/*++

Routine Description:

    This function creates and caches a rc4 key which can be used to store
    private information locally

Arguments:

    prc4Key - pointer to a buffer to hold the RC4 key

Return Value:

    TRUE - successfully generated key

    FALSE - otherwise

--*/
{
    A_SHA_CTX       SHAHash;
    BYTE            abSHADigest[A_SHA_DIGEST_LEN];
    static BOOL fCreatedKey = FALSE;
    static struct RC4_KEYSTRUCT rc4Key;
    TCHAR   szUserName[SEC_MAX_USERNAME];
    DWORD   dwSize;
    HWID    hwid;

    if (!fCreatedKey) {
        A_SHAInit(&SHAHash);

        //
        // Get the user name
        //

        dwSize = (DWORD)sizeof(szUserName);
        memset(szUserName, 0, (size_t)dwSize);
        if (!GetUserName(szUserName, &dwSize))
            return FALSE;

        A_SHAUpdate(&SHAHash, (unsigned char *)szUserName, dwSize);

        //
        // Get unique machine identifier
        //

        if (LICENSE_STATUS_OK == GenerateClientHWID(&hwid)) {
            A_SHAUpdate(&SHAHash, (unsigned char *)&hwid, sizeof(HWID));
        }

        //
        // Update the Hash with something less guessable
        // but known to our apps
        //

#define RANDOM_CONSTANT "deed047e-a3cb-11d1-b96c-00c04fb15601"
        A_SHAUpdate(&SHAHash, RANDOM_CONSTANT, sizeof(RANDOM_CONSTANT));

        //
        // Finalize the hash
        //

        A_SHAFinal(&SHAHash, abSHADigest);

        //
        // Generate a key based on this hash
        //

        msrc4_key(&rc4Key, (UINT)MAX_SESSION_KEY_SIZE, abSHADigest);

        fCreatedKey = TRUE;
    }

    memcpy(prc4Key, &rc4Key, sizeof(rc4Key));

    return TRUE;
}

BOOL GetLocalKey50(
    struct RC4_KEYSTRUCT *prc4Key,
    LPBYTE pbSalt,
    DWORD dwSaltLength
    )
/*++

Routine Description:

    This function creates and caches a rc4 key which can be used to store
    private information locally

Arguments:

    prc4Key - pointer to a buffer to hold the RC4 key

Return Value:

    TRUE - successfully generated key

    FALSE - otherwise

--*/
{
    A_SHA_CTX       SHAHash;
    BYTE            abSHADigest[A_SHA_DIGEST_LEN];
    struct RC4_KEYSTRUCT rc4Key;
    TCHAR   szUserName[SEC_MAX_USERNAME];
    DWORD   dwSize;
    HWID    hwid;
    DWORD   dw;

    A_SHAInit(&SHAHash);

    //
    // Get the user name
    //

    dwSize = (DWORD)sizeof(szUserName);
    memset(szUserName, 0, (size_t)dwSize);
    if (!GetUserName(szUserName, &dwSize))
        return FALSE;

    A_SHAUpdate(&SHAHash, (unsigned char *)szUserName, dwSize);

    //
    // Get unique machine identifier
    //

    if (LICENSE_STATUS_OK == GenerateClientHWID(&hwid)) {
        A_SHAUpdate(&SHAHash, (unsigned char *)&hwid, sizeof(HWID));
    }

    //
    // Update the Hash with something less guessable
    // but known to our apps
    //

#define RANDOM_CONSTANT "deed047e-a3cb-11d1-b96c-00c04fb15601"
    A_SHAUpdate(&SHAHash, RANDOM_CONSTANT, sizeof(RANDOM_CONSTANT));

    //
    // Finalize the hash
    //

    A_SHAFinal(&SHAHash, abSHADigest);

    //
    // Add salt and stir gently
    //

    for (dw = 0; dw < 256; dw++) {
        A_SHAInit(&SHAHash);
        A_SHAUpdate(&SHAHash, pbSalt, dwSaltLength);
        A_SHAUpdate(&SHAHash, abSHADigest, A_SHA_DIGEST_LEN);
        A_SHAFinal(&SHAHash, abSHADigest);
    }

    //
    // Generate a key based on this hash
    //

    msrc4_key(&rc4Key, (UINT)MAX_SESSION_KEY_SIZE, abSHADigest);

    memcpy(prc4Key, &rc4Key, sizeof(rc4Key));

    return TRUE;
}

BOOL EncryptDecryptLocalData(
    LPBYTE pbData,
    DWORD dwDataLen
    )
/*++

Routine Description:

    This function encrypts/decrypts data to be stored locally, but usable
    only by the current user on the this machine

Arguments:

    pbData - pointer to a data buffer.

    dwDataLen - length of the above data.

Return Value:

    TRUE - successfully encrypted data

    FALSE - otherwise

--*/
{
    struct RC4_KEYSTRUCT rc4Key;

    if (!GetLocalKey(&rc4Key))
        return FALSE;

    msrc4(&rc4Key, (UINT)dwDataLen, pbData);

    return TRUE;
}

BOOL EncryptDecryptLocalData50(
    LPBYTE pbData,
    DWORD dwDataLen,
    LPBYTE pbSalt,
    DWORD dwSaltLen
    )
/*++

Routine Description:

    This function encrypts/decrypts data to be stored locally, but usable
    only by the current user on the this machine

Arguments:

    pbData - pointer to a data buffer.

    dwDataLen - length of the above data.

Return Value:

    TRUE - successfully encrypted data

    FALSE - otherwise

--*/
{
    struct RC4_KEYSTRUCT rc4Key;

    if (!GetLocalKey50(&rc4Key, pbSalt, dwSaltLen))
        return FALSE;

    msrc4(&rc4Key, (UINT)dwDataLen, pbData);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\tssec\tssec.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    core.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Madan Appiah - Jan. 14th 1998.

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

C_DEFINES = $(C_DEFINES) -DMSWIN16

#
# List of sources
#

SOURCES_PLATFORM =

CLIENT_SOURCES_RC = \

CLIENT_SOURCES_COMMON = \
    ..\clicert.c \
    ..\encrypt.c \
    ..\fencrypt.c \
    ..\local.c \
    ..\genrand.c \
    ..\glodata.c \
    ..\sesskey.c \
    ..\rng.c

CLIENT_SOURCES_LAST  = \

SOURCES = \
    $(CLIENT_SOURCES_RC) \
    $(SOURCES_PLATFORM) \
    $(CLIENT_SOURCES_COMMON) \
    $(CLIENT_SOURCES_LAST)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\tssec\secdbg.h ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    secdbg.h

Abstract:

    Debug macro definition file.

Author:

    Madan Appiah (madana)  24-Jan-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _SECDBG_H_
#define _SECDBG_H_

//
// assert macros.
//

NTSYSAPI
VOID
NTAPI
RtlAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    DWORD LineNumber,
    PCHAR Message
    );

#define RTLASSERT( msg, exp)
//        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#define RTLASSERTMSG( msg, exp)
//        RtlAssert( #exp, __FILE__, __LINE__, msg )


#ifdef ASSERT
#undef ASSERT
#endif // ASSERT
#ifdef ASSERTMSG
#undef ASSERTMSG
#endif // ASSERTMSG

#if DBG

#define ASSERT( exp ) \
    if (!(exp)) { \
        RTLASSERT( msg, exp); \
    } \

#define ASSERTMSG( msg, exp ) \
    if (!(exp)) { \
        RTLASSERT( msg, exp); \
    } \

#else

#define ASSERT( exp )
#define ASSERTMSG( msg, exp )

#endif // DBG

#endif // _SECDBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\common\tssec\sesskey.c ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    sesskey.c

Abstract:

    Contains common client/server code that generate session key.

Author:

    Madan Appiah (madana)  24-Jan-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#include <seccom.h>

VOID
Salt8ByteKey(
    LPBYTE pbKey,
    DWORD dwSaltBytes
    )
/*++

Routine Description:

    This macro function salts the first 1 or 3 bytes of the 8 bytes key to a
    known value in order to make it a 40-bit key.

Arguments:

    pbKey - pointer to a 8 bytes key buffer.
    dwSaltBytes - this value should be either 1 or 3

Return Value:

    None.

--*/
{
    ASSERT( (dwSaltBytes == 1) || (dwSaltBytes == 3) );

    if( dwSaltBytes == 1 ) {

        //
        // for 56-bit encryption, salt first byte only.
        //

        *pbKey++ = 0xD1 ;
    }
    else if (dwSaltBytes == 3) {

        //
        // for 40-bit encryption, salt first 3 bytes.
        //

        *pbKey++ = 0xD1 ;
        *pbKey++ = 0x26 ;
        *pbKey  = 0x9E ;
    }

    return;
}

VOID
FinalHash(
    LPRANDOM_KEYS_PAIR pKeyPair,
    LPBYTE pbKey
    )
/*++

Routine Description:

    This macro function hashes the final key with the client and server randoms.

Arguments:

    pKeyPair - pointer a random key pair structure.

    pbKey - pointer to a key buffer, the final key is returned back in the same
        buffer.

Return Value:

    None.

--*/
{
    MD5_CTX Md5Hash;

    //
    // final_key = MD5(key + clientRandom + serverRandom)
    //

    MD5Init  (&Md5Hash);

    MD5Update(&Md5Hash, pbKey, MAX_SESSION_KEY_SIZE);
    MD5Update(&Md5Hash, pKeyPair->clientRandom, RANDOM_KEY_LENGTH);
    MD5Update(&Md5Hash, pKeyPair->serverRandom, RANDOM_KEY_LENGTH);
    MD5Final (&Md5Hash);

    //
    // copy the final key back to the input buffer.
    //

    ASSERT( MD5DIGESTLEN >= MAX_SESSION_KEY_SIZE );
    memcpy(pbKey, Md5Hash.digest, MAX_SESSION_KEY_SIZE);

    return;
}

VOID
MakeMasterKey(
    LPRANDOM_KEYS_PAIR pKeyPair,
    LPSTR FAR *ppszSalts,
    LPBYTE pbPreMaster,
    LPBYTE pbMaster
    )
/*++

Routine Description:

    This macro function makes a master secret using a pre-master secret.

Arguments:

    pKeyPair - pointer a key pair structure.

    ppszSalts - pointer to a salt key strings array.

    pbPreMaster - pointer to a pre-master secret key buffer.

    pbMaster - pointer to a master secret key buffer.

Return Value:

    None.

--*/
{
    DWORD i;

    MD5_CTX Md5Hash;
    A_SHA_CTX ShaHash;
    BYTE bShaHashValue[A_SHA_DIGEST_LEN];

    //
    //initialize all buffers with zero
    //

    memset( pbMaster, 0, PRE_MASTER_SECRET_LEN);
    memset( bShaHashValue, 0, A_SHA_DIGEST_LEN);

    for ( i = 0 ; i < 3 ; i++) {

        //
        // SHA(ppszSalts[i] + pre-master + clientRandom +  serverRandom)
        //

        A_SHAInit(&ShaHash);
        A_SHAUpdate(&ShaHash, ppszSalts[i], strlen(ppszSalts[i]));
        A_SHAUpdate(&ShaHash, pbPreMaster, PRE_MASTER_SECRET_LEN );
        A_SHAUpdate(
            &ShaHash,
            pKeyPair->clientRandom,
            sizeof(pKeyPair->clientRandom) );
        A_SHAUpdate(
            &ShaHash,
            pKeyPair->serverRandom,
            sizeof(pKeyPair->serverRandom) );
        A_SHAFinal(&ShaHash, bShaHashValue);

        //
        // MD5(pre_master + SHA-hash)
        //

        MD5Init(&Md5Hash);
        MD5Update(&Md5Hash, pbPreMaster, PRE_MASTER_SECRET_LEN );
        MD5Update(&Md5Hash, bShaHashValue, A_SHA_DIGEST_LEN);
        MD5Final(&Md5Hash);

        //
        // copy part of the master secret.
        //

        memcpy(
            pbMaster + (i * MD5DIGESTLEN),
            Md5Hash.digest,
            MD5DIGESTLEN);
    }

    return;
}

VOID
MakePreMasterSecret(
    LPRANDOM_KEYS_PAIR pKeyPair,
    LPBYTE pbPreMasterSecret
    )
/*++

Routine Description:

    This function makes a pre-master secret for the initial session key.

Arguments:

    pKeyPair - pointer a key pair structure.

    pbPreMasterSecret - pointer to a pre-master secret key buffer, it is
        PRE_MASTER_SECRET_LEN bytes long.

Return Value:

    None.

--*/
{
    //
    // copy PRE_MASTER_SECRET_LEN/2 bytes from clientRandom first.
    //

    memcpy(
        pbPreMasterSecret,
        pKeyPair->clientRandom,
        PRE_MASTER_SECRET_LEN/2 );

    //
    // copy PRE_MASTER_SECRET_LEN/2 bytes from serverRandom next.
    //

    memcpy(
        pbPreMasterSecret + PRE_MASTER_SECRET_LEN/2,
        pKeyPair->serverRandom,
        PRE_MASTER_SECRET_LEN/2 );

    return;
}

VOID
GenerateMasterSecret(
    LPRANDOM_KEYS_PAIR pKeyPair,
    LPBYTE pbPreMasterSecret
    )
/*++

Routine Description:

    This function creates a master secret key using the pre-master key and
    random key pair.

Arguments:

    pKeyPair - pointer a key pair structure.

    pbPreMasterSecret - pointer to a pre-master secret key buffer, it is
        PRE_MASTER_SECRET_LEN bytes long.


Return Value:

    None.

--*/
{
    BYTE abMasterSecret[PRE_MASTER_SECRET_LEN];
    LPSTR apszSalts[3] = { "A","BB","CCC" } ;

    ASSERT( PRE_MASTER_SECRET_LEN == 3 * MD5DIGESTLEN );

    //
    // make master secret.
    //

    MakeMasterKey(
        pKeyPair,
        (LPSTR FAR *)apszSalts,
        pbPreMasterSecret,
        (LPBYTE)abMasterSecret );

    //
    // copy master secret in the return buffer.
    //

    memcpy( pbPreMasterSecret, abMasterSecret, PRE_MASTER_SECRET_LEN);

    return;
}

VOID
UpdateKey(
    LPBYTE pbStartKey,
    LPBYTE pbCurrentKey,
    DWORD dwKeyLength
    )
/*++

Routine Description:

    This function updates a key.

Arguments:

    pbStartKey - pointer to the start session key buffer.

    pbCurrentKey - pointer to the current session key buffer, new session key is
        copied to this buffer on return.

    dwKeyLength - length of the key.

Return Value:

    None.

--*/
{
    A_SHA_CTX       SHAHash;
    MD5_CTX         MD5Hash;
    BYTE            abSHADigest[A_SHA_DIGEST_LEN];

    //
    // make a SHA(pbStartKey + g_abPad1 + pbCurrentKey) hash.
    //

    A_SHAInit(&SHAHash);
    A_SHAUpdate(&SHAHash, pbStartKey, dwKeyLength);
    A_SHAUpdate(&SHAHash, (unsigned char *)g_abPad1, 40);
    A_SHAUpdate(&SHAHash, pbCurrentKey, dwKeyLength);
    A_SHAFinal(&SHAHash, abSHADigest);

    //
    // make a MD5(pbStartKey + g_abPad2 + SHAHash) hash.
    //

    MD5Init(&MD5Hash);
    MD5Update(&MD5Hash, pbStartKey, dwKeyLength);
    MD5Update(&MD5Hash, g_abPad2, 48);
    MD5Update(&MD5Hash, abSHADigest, A_SHA_DIGEST_LEN);
    MD5Final(&MD5Hash);

    ASSERT( dwKeyLength <= MD5DIGESTLEN );
    memcpy(pbCurrentKey, MD5Hash.digest, (UINT)dwKeyLength);

    return;
}

BOOL
MakeSessionKeys(
    LPRANDOM_KEYS_PAIR pKeyPair,
    LPBYTE pbEncryptKey,
    struct RC4_KEYSTRUCT FAR *prc4EncryptKey,
    LPBYTE pbDecryptKey,
    struct RC4_KEYSTRUCT FAR *prc4DecryptKey,
    LPBYTE pbMACSaltKey,
    DWORD dwKeyStrength,
    LPDWORD pdwKeyLength,
    DWORD dwEncryptionLevel
    )
/*++

Routine Description:

    Make the server session key using the client and server random keys.

    Assume : the encrypt and decrypt buffer presented are
        atleast MAX_SESSION_KEY_SIZE (16) bytes long.

Arguments:

    pKeyPair - pointer a key pair structure.

    pbEncryptKey - pointer to a buffer where the encryption key is stored.

    prc4EncryptKey - pointer to a RC4 encrypt key structure.

    pbDecryptKey - pointer to a buffer where the decryption key is stored.

    prc4DecryptKey - pointer to a RC4 decrypt key structure.

    pbMACSaltKey - pointer to a buffer where the message authentication key is
        stored.

    dwKeyStrength - specify key strength to use.

    pdwKeyLength - pointer to a location where the length of the above
        encryption/decryption key is returned.

    dwEncryptionLevel - encryption level, used to select the encryption
        algorithm.

Return Value:

    TRUE - if successfully created the session key.

    FALSE - otherwise.

--*/
{
    BYTE abPreMasterSecret[PRE_MASTER_SECRET_LEN];
    BYTE abMasterSessionKey[PRE_MASTER_SECRET_LEN];
    LPSTR apszSalts[3] = { "X","YY","ZZZ" } ;
    DWORD dwSaltLen;

    //
    // make a pre-master secret.
    //

    MakePreMasterSecret( pKeyPair, (LPBYTE)abPreMasterSecret );

    //
    // generate master secret.
    //

    GenerateMasterSecret( pKeyPair, (LPBYTE)abPreMasterSecret );

    //
    // make a master session key for all three session keys (encrypt, decrypt
    // and MACSalt).
    //

    MakeMasterKey(
        pKeyPair,
        (LPSTR FAR *)apszSalts,
        (LPBYTE)abPreMasterSecret,
        (LPBYTE)abMasterSessionKey );

    ASSERT( PRE_MASTER_SECRET_LEN == 3 * MAX_SESSION_KEY_SIZE );

    //
    // copy first part of the master key as MAC salt key.
    //

    memcpy(
        pbMACSaltKey,
        (LPBYTE)abMasterSessionKey,
        MAX_SESSION_KEY_SIZE );

    //
    // copy second part of the master key as encrypt key and final hash it.
    //

    memcpy(
        pbEncryptKey,
        (LPBYTE)abMasterSessionKey + MAX_SESSION_KEY_SIZE,
        MAX_SESSION_KEY_SIZE );

    FinalHash( pKeyPair, pbEncryptKey );

    //
    // copy second part of the master key as decrypt key and final hash it.
    //

    memcpy(
        pbDecryptKey,
        (LPBYTE)abMasterSessionKey + MAX_SESSION_KEY_SIZE * 2,
        MAX_SESSION_KEY_SIZE );

    FinalHash( pKeyPair, pbDecryptKey );


    //
    // finally select the key length.
    //

    ASSERT( MAX_SESSION_KEY_SIZE == 16 );

    dwSaltLen = 0;
    switch ( dwKeyStrength ) {

        case SM_40BIT_ENCRYPTION_FLAG:
            *pdwKeyLength = MAX_SESSION_KEY_SIZE/2;
            dwSaltLen = 3;
            break;

        case SM_56BIT_ENCRYPTION_FLAG:
            *pdwKeyLength = MAX_SESSION_KEY_SIZE/2;
            dwSaltLen = 1;
            break;

        case SM_128BIT_ENCRYPTION_FLAG:
            ASSERT( g_128bitEncryptionEnabled );
            *pdwKeyLength = MAX_SESSION_KEY_SIZE;
            break;

        default:

            //
            // we shouldn't reach here.
            //

            ASSERT( FALSE );
            *pdwKeyLength = MAX_SESSION_KEY_SIZE/2;
            dwSaltLen = 1;
            break;
    }

    if( dwSaltLen ) {

        Salt8ByteKey( pbMACSaltKey, dwSaltLen );
        Salt8ByteKey( pbEncryptKey, dwSaltLen );
        Salt8ByteKey( pbDecryptKey, dwSaltLen );
    }

    //
    // finally make rc4 keys.
    //
    // use microsoft version of rc4 algorithm (super fast!) for level 1 and
    // level 2 encryption, for level 3 use RSA rc4 algorithm.
    //

    if( dwEncryptionLevel <= 2 ) {
        msrc4_key( prc4EncryptKey, (UINT)*pdwKeyLength, pbEncryptKey );
        msrc4_key( prc4DecryptKey, (UINT)*pdwKeyLength, pbDecryptKey );
    }
    else {
        rc4_key( prc4EncryptKey, (UINT)*pdwKeyLength, pbEncryptKey );
        rc4_key( prc4DecryptKey, (UINT)*pdwKeyLength, pbDecryptKey );
    }

    return( TRUE );
}

BOOL
UpdateSessionKey(
    LPBYTE pbStartKey,
    LPBYTE pbCurrentKey,
    DWORD dwKeyStrength,
    DWORD dwKeyLength,
    struct RC4_KEYSTRUCT FAR *prc4Key,
    DWORD dwEncryptionLevel
    )
/*++

Routine Description:

    Update the session key using the current and start session keys.

Arguments:

    pbStartKey - pointer to the start session key buffer.

    pbCurrentKey - pointer to the current session key buffer, new session key is
        copied to this buffer on return.

    dwKeyStrength - specify key strength to use.

    dwKeyLength - length of the key.

    prc4Key - pointer to a RC4 key structure.

    dwEncryptionLevel - encryption level, used to select the encryption
        algorithm.

Return Value:

    TRUE - if the successfully update the key.

    FALSE - otherwise.

--*/
{
    DWORD dwSaltLen;

    //
    // update current key first.
    //

    UpdateKey( pbStartKey, pbCurrentKey, dwKeyLength );

    //
    // use microsoft version of rc4 algorithm (super fast!) for level 1 and
    // level 2 encryption, for level 3 use RSA rc4 algorithm.
    //

    if( dwEncryptionLevel <= 2 ) {

        //
        // re-initialized RC4 table.
        //

        msrc4_key( prc4Key, (UINT)dwKeyLength, pbCurrentKey );

        //
        // scramble the current key.
        //

        msrc4( prc4Key, (UINT)dwKeyLength, pbCurrentKey );
    }
    else {

        //
        // re-initialized RC4 table.
        //

        rc4_key( prc4Key, (UINT)dwKeyLength, pbCurrentKey );

        //
        // scramble the current key.
        //

        rc4( prc4Key, (UINT)dwKeyLength, pbCurrentKey );
    }

    //
    // salt the key appropriately.
    //

    dwSaltLen = 0;
    switch ( dwKeyStrength ) {

        case SM_40BIT_ENCRYPTION_FLAG:
            ASSERT( dwKeyLength = MAX_SESSION_KEY_SIZE/2 );
            dwSaltLen = 3;
            break;

        case SM_56BIT_ENCRYPTION_FLAG:
            ASSERT( dwKeyLength = MAX_SESSION_KEY_SIZE/2 );
            dwSaltLen = 1;
            break;

        case SM_128BIT_ENCRYPTION_FLAG:
            ASSERT( g_128bitEncryptionEnabled );
            ASSERT( dwKeyLength = MAX_SESSION_KEY_SIZE );
            break;

        default:

            //
            // we shouldn't reach here.
            //

            ASSERT( FALSE );
            ASSERT( dwKeyLength = MAX_SESSION_KEY_SIZE/2 );
            dwSaltLen = 1;
            break;
    }

    if( dwSaltLen ) {
        Salt8ByteKey( pbCurrentKey, dwSaltLen );
    }

    //
    // re-initialized RC4 table again.
    //

    if( dwEncryptionLevel <= 2 ) {

        msrc4_key( prc4Key, (UINT)dwKeyLength, pbCurrentKey );
    }
    else {

        rc4_key( prc4Key, (UINT)dwKeyLength, pbCurrentKey );
    }

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\dload\termsrvpch.h ===
#pragma once

#include <dloadexcept.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\dload\regapi.c ===
#include "termsrvpch.h"
#pragma hdrstop

#include <winsta.h>

static
LONG WINAPI
RegConsoleShadowQueryW( 
    HANDLE hServer,
    PWINSTATIONNAMEW pWinStationName,
    PWDPREFIXW pWdPrefixName,
    PWINSTATIONCONFIG2W pWinStationConfig,
    ULONG WinStationConfigLength,
    PULONG pReturnLength
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
LONG WINAPI
RegDefaultUserConfigQueryW(
    WCHAR * pServerName,
    PUSERCONFIGW pUserConfig,
    ULONG UserConfigLength,
    PULONG pReturnLength
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
BOOLEAN     
RegDenyTSConnectionsPolicy(
    void
    )
{
    return FALSE; 
}

static
BOOLEAN
RegGetMachinePolicyEx( 
    BOOLEAN forcePolicyRead,
    FILETIME *pTime ,    
    PPOLICY_TS_MACHINE pPolicy
    )
{
    return FALSE;
}

static
BOOLEAN    
RegGetUserPolicy( 
    LPWSTR userSID,
    PPOLICY_TS_USER pPolicy,
    PUSERCONFIGW pUser
    )
{
    return FALSE;
}

static
BOOLEAN
RegIsMachinePolicyAllowHelp(
    void
    )
{
    return FALSE;
}

static
LONG WINAPI
RegPdEnumerateW(
    HANDLE hServer,
    PWDNAMEW pWdName,
    BOOLEAN bTd,
    PULONG pIndex,
    PULONG pEntries,
    PPDNAMEW pPdName,
    PULONG pByteCount
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
LONG WINAPI
RegUserConfigQuery(
    WCHAR * pServerName,
    WCHAR * pUserName,
    PUSERCONFIGW pUserConfig,
    ULONG UserConfigLength,
    PULONG pReturnLength
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
LONG WINAPI
RegUserConfigSet(
    WCHAR * pServerName,
    WCHAR * pUserName,
    PUSERCONFIGW pUserConfig,
    ULONG UserConfigLength
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
LONG
WINAPI
RegWinStationQueryEx(
    HANDLE hServer,
    PPOLICY_TS_MACHINE pMachinePolicy,
    PWINSTATIONNAMEW pWinStationName,
    PWINSTATIONCONFIG2W pWinStationConfig,
    ULONG WinStationConfigLength,
    PULONG pReturnLength,
    BOOLEAN bPerformMerger
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
LONG WINAPI
RegWinStationQueryNumValueW(
    HANDLE hServer,
    PWINSTATIONNAMEW pWinStationName,
    LPWSTR pValueName,
    PULONG pValueData
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
LONG WINAPI
RegWinStationQueryValueW(
    HANDLE hServer,
    PWINSTATIONNAMEW pWinStationName,
    LPWSTR pValueName,
    PVOID  pValueData,
    ULONG  ValueSize,
    PULONG pValueSize
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
DWORD
WaitForTSConnectionsPolicyChanges( BOOLEAN bWaitForAccept, HANDLE hEvent )
{
    return ERROR_PROC_NOT_FOUND; 
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(regapi)
{
    DLPENTRY(RegConsoleShadowQueryW)
    DLPENTRY(RegDefaultUserConfigQueryW)
    DLPENTRY(RegDenyTSConnectionsPolicy)
    DLPENTRY(RegGetMachinePolicyEx)
    DLPENTRY(RegGetUserPolicy)
    DLPENTRY(RegIsMachinePolicyAllowHelp)
    DLPENTRY(RegPdEnumerateW)
    DLPENTRY(RegUserConfigQuery)
    DLPENTRY(RegUserConfigSet)
    DLPENTRY(RegWinStationQueryEx)
    DLPENTRY(RegWinStationQueryNumValueW)
    DLPENTRY(RegWinStationQueryValueW)
    DLPENTRY(WaitForTSConnectionsPolicyChanges)
};

DEFINE_PROCNAME_MAP(regapi)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\dload\utildll.c ===
#include "termsrvpch.h"
#pragma hdrstop

static
void
WINAPI
CachedGetUserFromSid(
    PSID pSid, PWCHAR pUserName, PULONG cbUserName
    )
{
    // We should properly return the string "(unknown)" but that's
    // kept in utildll.dll, and we're here because utildll failed to load...
    //
    // Original function assumes that *cbUserName > 0 too
    pUserName[*cbUserName-1] = L'\0';
}

static
void
WINAPI
CurrentDateTimeString(
    LPWSTR pString
    )
{
    // original function doesn't check for NULL pointer either
    pString[0] = L'\0';
}

static
LPWSTR
WINAPI
EnumerateMultiUserServers(
    LPWSTR pDomain
    )
{
    return NULL;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(utildll)
{
    DLPENTRY(CachedGetUserFromSid)
    DLPENTRY(CurrentDateTimeString)
    DLPENTRY(EnumerateMultiUserServers)
};

DEFINE_PROCNAME_MAP(utildll)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\dload\winsta.c ===
#include "termsrvpch.h"
#pragma hdrstop

#include <winsta.h>

static
BOOLEAN
WINAPI
_WinStationNotifyLogoff(
    VOID
    )
{
    return FALSE;
}

static
HANDLE
WINAPI
WinStationOpenServerW(
    LPWSTR  pServerName
    )
{
    return INVALID_HANDLE_VALUE;
}

static
BOOLEAN
WINAPI
WinStationCloseServer(
    HANDLE  hServer
    )
{
    return FALSE;
}

static
BOOLEAN
WINAPI
WinStationConnectW(
    HANDLE hServer,
    ULONG LogonId,
    ULONG TargetLogonId,
    PWCHAR pPassword,
    BOOLEAN bWait
)
{
    return FALSE;
}

static
BOOLEAN
WINAPI
WinStationGetProcessSid(
        HANDLE   hServer,
        DWORD    ProcessId,
        FILETIME ProcessStartTime,
        PBYTE    pProcessUserSid,
        DWORD    *pdwSidSize
)
{
   *pdwSidSize = 0; // an OUT parameter even on failure
   SetLastError(ERROR_PROC_NOT_FOUND); // callers expect LastError to be set
    return FALSE;
}

static
BOOLEAN
WINAPI
WinStationQueryInformationA(
    HANDLE hServer,
    ULONG LogonId,
    WINSTATIONINFOCLASS WinStationInformationClass,
    PVOID  pWinStationInformation,
    ULONG WinStationInformationLength,
    PULONG  pReturnLength
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLEAN
WINAPI
WinStationQueryInformationW(
    HANDLE hServer,
    ULONG LogonId,
    WINSTATIONINFOCLASS WinStationInformationClass,
    PVOID  pWinStationInformation,
    ULONG WinStationInformationLength,
    PULONG  pReturnLength
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
BOOL
WINAPI
WinStationRegisterConsoleNotification(
    HANDLE  hServer,
    HWND    hWnd,
    DWORD   dwFlags
    )
{
    return FALSE;
}

BOOLEAN WINAPI
WinStationSendMessageW(
    HANDLE hServer,
    ULONG LogonId,
    LPWSTR  pTitle,
    ULONG TitleLength,
    LPWSTR  pMessage,
    ULONG MessageLength,
    ULONG Style,
    ULONG Timeout,
    PULONG pResponse,
    BOOLEAN DoNotWait
    )
{
    return FALSE;
}

static
BOOLEAN
WINAPI
WinStationSetInformationW(
    HANDLE hServer,
    ULONG LogonId,
    WINSTATIONINFOCLASS WinStationInformationClass,
    PVOID  pWinStationInformation,
    ULONG WinStationInformationLength
    )
{
    return FALSE;
}

static
BOOLEAN
WINAPI
WinStationShadow(
    HANDLE hServer,
    PWSTR pTargetServerName,
    ULONG TargetLogonId,
    BYTE HotkeyVk,
    USHORT HotkeyModifiers
    )
{
    return FALSE;
}



static
BOOL
WINAPI
WinStationUnRegisterConsoleNotification(
    HANDLE  hServer,
    HWND    hWnd
    )
{
    return FALSE;
}


static
NTSTATUS
WINAPI
_WinStationShadowTarget(
    HANDLE hServer,
    ULONG LogonId,
    PWINSTATIONCONFIG2 pConfig,
    PICA_STACK_ADDRESS pAddress,
    PVOID pModuleData,
    ULONG ModuleDataLength,
    PVOID pThinwireData,
    ULONG ThinwireDataLength,
    PVOID pClientName,
    ULONG ClientNameLength
    )
{
    return STATUS_PROCEDURE_NOT_FOUND;
}


static
BOOLEAN
WINAPI
_WinStationShadowTargetSetup(
    HANDLE hServer,
    ULONG LogonId
    )
{
    return FALSE;
}

static
BOOLEAN
WINAPI
WinStationFreeMemory(
    PVOID  pBuffer
    )
{
    return FALSE;
}

static
BOOLEAN
WINAPI
WinStationEnumerateW(
    HANDLE  hServer,
    PLOGONIDW *ppLogonId,
    PULONG  pEntries
    )
{
    return FALSE;
}

static
BOOLEAN
WINAPI
WinStationEnumerate_IndexedW(
    HANDLE  hServer,
    PULONG  pEntries,
    PLOGONIDW pLogonId,
    PULONG  pByteCount,
    PULONG  pIndex
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOLEAN
WINAPI
WinStationGetTermSrvCountersValue(
    HANDLE hServer,
    ULONG  dwEntries,
    PVOID  pCounter
    )
{
    return FALSE;
}

static
BOOLEAN 
WinStationIsHelpAssistantSession(
    HANDLE   hServer,
    ULONG    LogonId
    )
{
    return FALSE;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(winsta)
{
    DLPENTRY(WinStationCloseServer)
    DLPENTRY(WinStationConnectW)
    DLPENTRY(WinStationEnumerateW)
    DLPENTRY(WinStationEnumerate_IndexedW)
    DLPENTRY(WinStationFreeMemory)
    DLPENTRY(WinStationGetProcessSid)
    DLPENTRY(WinStationGetTermSrvCountersValue)
    DLPENTRY(WinStationIsHelpAssistantSession)
    DLPENTRY(WinStationOpenServerW)
    DLPENTRY(WinStationQueryInformationA)
    DLPENTRY(WinStationQueryInformationW)
    DLPENTRY(WinStationRegisterConsoleNotification)
    DLPENTRY(WinStationSendMessageW)
    DLPENTRY(WinStationSetInformationW)
    DLPENTRY(WinStationShadow)
    DLPENTRY(WinStationUnRegisterConsoleNotification)
    DLPENTRY(_WinStationNotifyLogoff)
    DLPENTRY(_WinStationShadowTarget)
    DLPENTRY(_WinStationShadowTargetSetup)
};

DEFINE_PROCNAME_MAP(winsta)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\ctxdd\muio.c ===
/****************************************************************************/
// io.c
//
// Kernel file I/O utility functions.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <ntddk.h>
#include <ctxdd.h>


//
// External references
//
VOID IoQueueThreadIrp(IN PIRP);


/*=============================================================================
==   Internal Functions Defined
=============================================================================*/

NTSTATUS
_CtxDoFileIo(
    IN ULONG MajorFunction,
    IN PFILE_OBJECT fileObject,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PKEVENT pEvent,
    OUT PIO_STATUS_BLOCK pIosb,
    OUT PIRP *ppIrp 
    );

NTSTATUS
_CtxDeviceControlComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


/*******************************************************************************
 *  CtxReadFile
 *
 *    Kernel read file routine.
 *
 * ENTRY:
 *    fileObject (input)
 *       pointer to file object for I/O
 *    Buffer (input)
 *       pointer to read buffer
 *    Length (input)
 *       length of read buffer
 *    pEvent (input)
 *       pointer to I/O event (optional)
 *    pIosb (output)
 *       pointer to IoStatus block (optional)
 ******************************************************************************/
NTSTATUS CtxReadFile(
        IN PFILE_OBJECT fileObject,
        IN PVOID Buffer,
        IN ULONG Length,
        IN PKEVENT pEvent OPTIONAL,
        OUT PIO_STATUS_BLOCK pIosb OPTIONAL,
        OUT PIRP *ppIrp OPTIONAL)
{
    return _CtxDoFileIo(IRP_MJ_READ, fileObject, Buffer, Length, pEvent, pIosb, ppIrp);
}


/*******************************************************************************
 *  CtxWriteFile
 *
 *    Kernel write file routine.
 *
 * ENTRY:
 *    fileObject (input)
 *       pointer to file object for I/O
 *    Buffer (input)
 *       pointer to write buffer
 *    Length (input)
 *       length of write buffer
 *    pEvent (input) 
 *       pointer to I/O event (optional)
 *    pIosb (output)
 *       pointer to IoStatus block (optional)
 ******************************************************************************/
NTSTATUS CtxWriteFile(
        IN PFILE_OBJECT fileObject,
        IN PVOID Buffer,
        IN ULONG Length,
        IN PKEVENT pEvent OPTIONAL,
        OUT PIO_STATUS_BLOCK pIosb OPTIONAL,
        OUT PIRP *ppIrp OPTIONAL)
{
    return _CtxDoFileIo(IRP_MJ_WRITE, fileObject, Buffer, Length, pEvent, pIosb, ppIrp);
}


NTSTATUS _CtxDoFileIo(
        IN ULONG MajorFunction,
        IN PFILE_OBJECT fileObject,
        IN PVOID Buffer,
        IN ULONG Length,
        IN PKEVENT pEvent,
        OUT PIO_STATUS_BLOCK pIosb,
        OUT PIRP *ppIrp)
{
    PDEVICE_OBJECT deviceObject;
    LARGE_INTEGER Offset;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    KIRQL irql;
    static IO_STATUS_BLOCK Iosb;

    /*
     * We don't support synchronous (i.e. locked) file I/O.
     */
    ASSERT( !(fileObject->Flags & FO_SYNCHRONOUS_IO) );
    if ((fileObject->Flags & FO_SYNCHRONOUS_IO)) {
        return STATUS_INVALID_PARAMETER_MIX;
    }

    /*
     * If caller specified an event, clear it before we begin.
     */
    if (pEvent) {
        KeClearEvent(pEvent);
    }

    /*
     * If the caller does not supply an IOSB, supply
     * a static one to avoid the overhead of the exception
     * handler in the IO completion APC. Since the caller(s)
     * do not care about the result, we can point all such
     * callers to the same one.
     */
    if (pIosb == NULL) {
        pIosb = &Iosb;
    }

    /*
     * Get the DeviceObject for this file
     */
    deviceObject = IoGetRelatedDeviceObject(fileObject);

    /*
     * Build the IRP for this request
     */
    Offset.LowPart = FILE_WRITE_TO_END_OF_FILE;
    Offset.HighPart = -1;
    irp = IoBuildAsynchronousFsdRequest(MajorFunction, deviceObject,
            Buffer, Length, &Offset, pIosb);
    if (irp == NULL)
        return STATUS_INSUFFICIENT_RESOURCES;
   
    /*
     * Save callers event pointer.
     * Also, we must set IRP_SYNCHRONOUS_API in the IRP flags so that
     * the I/O completion code will NOT attempt to dereference the
     * event object, since it is not a real object manager object.
     */
    irp->UserEvent = pEvent;
    irp->Flags |= IRP_SYNCHRONOUS_API;

    /*
     * Reference the file object since it will be dereferenced in the
     * I/O completion code, and save a pointer to it in the IRP.
     */
    ObReferenceObject(fileObject);
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->FileObject = fileObject;

    /*
     * Set the address of the current thread in the packet so the
     * completion code will have a context to execute in.
     */
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Queue the IRP to the current thread
    //
    IoQueueThreadIrp(irp);

    //
    // Call driver
    //
    status = IoCallDriver( deviceObject, irp );

    //
    // If irp->UserEvent == NULL, IO completion will set the file
    // object event and status.
    //
    if (pEvent == NULL) {
        if (status == STATUS_PENDING) {
            status = KeWaitForSingleObject(&fileObject->Event,
                    Executive,
                    KernelMode, // Prevent KSTACK from paging
                    FALSE,      // Non-alertable
                    (PLARGE_INTEGER)NULL);

            ASSERT(status != STATUS_ALERTED);
            ASSERT(status != STATUS_USER_APC);

            status = fileObject->FinalStatus;
        }
    }

    // This crappy function interface is broken -- returning the IRP
    // pointer could corrupt the system, since it could be completed
    // and deallocated before the return completes and the caller
    // attempts to use the pointer. To get the IRP back the caller
    // would have had to set a completion routine, but we use
    // IoBuildAsynchronousFsdRequest() which does not allow that.
    // Want to change the interface to get rid of the OPTIONAL
    // junk -- TermDD only uses the write() interface and always
    // passes NULL for everything -- but who knows whether Citrix
    // uses this internally?
    // Set the return pointer to NULL to cause the caller to fault.
    if (pEvent != NULL && ppIrp != NULL)
        *ppIrp = NULL;

    return status;
}


/*******************************************************************************
 *  CtxDeviceIoControlFile
 *
 *    Kernel DeviceIoControl routine
 *
 * ENTRY:
 *    fileObject (input)
 *       pointer to file object for I/O
 *    IoControlCode (input)
 *       Io control code
 *    InputBuffer (input)
 *       pointer to input buffer (optional)
 *    InputBufferLength (input)
 *       length of input buffer
 *    OutputBuffer (input)
 *       pointer to output buffer (optional)
 *    OutputBufferLength (input)
 *       length of output buffer
 *    InternalDeviceIoControl (input)
 *       if TRUE, use IOCTL_INTERNAL_DEVICE_IO_CONTROL
 *    pEvent (input)
 *       pointer to I/O event (optional)
 *    pIosb (output)
 *       pointer to IoStatus block (optional)
 ******************************************************************************/
NTSTATUS CtxDeviceIoControlFile(
        IN PFILE_OBJECT fileObject,
        IN ULONG IoControlCode,
        IN PVOID InputBuffer OPTIONAL,
        IN ULONG InputBufferLength,
        OUT PVOID OutputBuffer OPTIONAL,
        IN ULONG OutputBufferLength,
        IN BOOLEAN InternalDeviceIoControl,
        IN PKEVENT pEvent OPTIONAL,
        OUT PIO_STATUS_BLOCK pIosb,
        OUT PIRP *ppIrp OPTIONAL)
{
    PDEVICE_OBJECT deviceObject;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    /*
     * We don't support synchronous (i.e. locked) file I/O.
     */
    ASSERT( !(fileObject->Flags & FO_SYNCHRONOUS_IO) );
    if ( (fileObject->Flags & FO_SYNCHRONOUS_IO) ) {
        return( STATUS_INVALID_PARAMETER_MIX );
    }

    /*
     * If caller specified an event, clear it before we begin.
     */
    if (pEvent) {
        KeClearEvent(pEvent);
    }

    /*
     * Get the DeviceObject for this file
     */
    deviceObject = IoGetRelatedDeviceObject( fileObject );

    /*
     * Build the IRP for this request
     */
    irp = IoBuildDeviceIoControlRequest( IoControlCode, deviceObject,
                                         InputBuffer, InputBufferLength,
                                         OutputBuffer, OutputBufferLength,
                                         InternalDeviceIoControl,
                                         pEvent, pIosb );
    if ( irp == NULL )
        return( STATUS_INSUFFICIENT_RESOURCES );

    /*
     * Reference the file object since it will be dereferenced in the
     * I/O completion code, and save a pointer to it in the IRP.
     * Also, we must set IRP_SYNCHRONOUS_API in the IRP flags so that
     * the I/O completion code will NOT attempt to dereference the
     * event object, since it is not a real object manager object.
     */
    ObReferenceObject( fileObject );
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->FileObject = fileObject;
    irp->Flags |= IRP_SYNCHRONOUS_API;

    /*
     * Call the driver
     */
    status = IoCallDriver(deviceObject, irp);

    /*
     * If the caller did not specify a wait event and the I/O is pending,
     * then we must wait for the I/O to complete before we return.
     */
    if (pEvent == NULL) {
        if (status == STATUS_PENDING) {
            status = KeWaitForSingleObject(&fileObject->Event, UserRequest,
                    KernelMode, FALSE, NULL);
            if (status == STATUS_SUCCESS)
                status = fileObject->FinalStatus;
        }

    /*
     * Caller specified a wait event.
     * Return the Irp pointer if the caller specified a return pointer.
     */
    } else {
        if (ppIrp)
            *ppIrp = irp;
    }

    return status;
}


/*******************************************************************************
 *  CtxInternalDeviceIoControlFile
 *
 *    Kernel DeviceIoControl routine
 *
 * ENTRY:
 *    fileObject (input)
 *       pointer to file object for I/O
 *    IrpParameters (input)
 *       information to write to the parameters section of the
 *       stack location of the IRP.
 *    IrpParametersLength (input)
 *       length of the parameter information.  Cannot be greater than 16.
 *    MdlBuffer (input)
 *       if non-NULL, a buffer of nonpaged pool to be mapped
 *       into an MDL and placed in the MdlAddress field of the IRP.
 *    MdlBufferLength (input)
 *       the size of the buffer pointed to by MdlBuffer.
 *    MinorFunction (input)
 *       the minor function code for the request.
 *    pEvent (input)
 *       pointer to I/O event (optional)
 *    pIosb (output)
 *       pointer to IoStatus block (optional)
 ******************************************************************************/
NTSTATUS CtxInternalDeviceIoControlFile(
        IN PFILE_OBJECT fileObject,
        IN PVOID IrpParameters,
        IN ULONG IrpParametersLength,
        IN PVOID MdlBuffer OPTIONAL,
        IN ULONG MdlBufferLength,
        IN UCHAR MinorFunction,
        IN PKEVENT pEvent OPTIONAL,
        OUT PIO_STATUS_BLOCK pIosb OPTIONAL,
        OUT PIRP *ppIrp OPTIONAL)
{
    PDEVICE_OBJECT deviceObject;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PMDL mdl;
    NTSTATUS status;

    /*
     * We don't support synchronous (i.e. locked) file I/O.
     */
    ASSERT( !(fileObject->Flags & FO_SYNCHRONOUS_IO) );
    if ( (fileObject->Flags & FO_SYNCHRONOUS_IO) ) {
        return( STATUS_INVALID_PARAMETER_MIX );
    }

    /*
     * If caller specified an event, clear it before we begin.
     */
    if ( pEvent ) {
        KeClearEvent( pEvent );
    }

    /*
     * Get the DeviceObject for this file
     */
    deviceObject = IoGetRelatedDeviceObject( fileObject );

    /*
     * Build the IRP for this request
     */
    irp = IoBuildDeviceIoControlRequest( 0, deviceObject,
                                         NULL, 0,
                                         NULL, 0,
                                         TRUE,
                                         pEvent, pIosb );
    if ( irp == NULL )
        return( STATUS_INSUFFICIENT_RESOURCES );

    /*
     * If an MDL buffer was specified, get an MDL, map the buffer,
     * and place the MDL pointer in the IRP.
     */
    if ( MdlBuffer != NULL ) {
        mdl = IoAllocateMdl(
                  MdlBuffer,
                  MdlBufferLength,
                  FALSE,
                  FALSE,
                  irp
                  );
        if ( mdl == NULL ) {
            IoFreeIrp( irp );
            ObDereferenceObject( fileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        MmBuildMdlForNonPagedPool( mdl );
    } else {
        irp->MdlAddress = NULL;
    }

    /*
     * Reference the file object since it will be dereferenced in the
     * I/O completion code, and save a pointer to it in the IRP.
     * Also, we must set IRP_SYNCHRONOUS_API in the IRP flags so that
     * the I/O completion code will NOT attempt to dereference the
     * event object, since it is not a real object manager object.
     */
    ObReferenceObject( fileObject );
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->FileObject = fileObject;
    irp->Flags |= IRP_SYNCHRONOUS_API;

    /*
     * Fill in the service-dependent parameters for the request.
     */
    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    irpSp->MinorFunction = MinorFunction;

    ASSERT( IrpParametersLength <= sizeof(irpSp->Parameters) );
    RtlCopyMemory( &irpSp->Parameters, IrpParameters, IrpParametersLength );

    /*
     * Set up a completion routine which we'll use to free the MDL
     * allocated previously.
     */
    IoSetCompletionRoutine( irp, _CtxDeviceControlComplete, NULL, TRUE, TRUE, TRUE );

    /*
     * Call the driver
     */
    status = IoCallDriver( deviceObject, irp );

    /*
     * If the caller did not specify a wait event and the I/O is pending,
     * then we must wait for the I/O to complete before we return.
     */
    if ( pEvent == NULL ) {
        if ( status == STATUS_PENDING ) {
            status = KeWaitForSingleObject( &fileObject->Event, UserRequest, KernelMode, FALSE, NULL );
            if ( status == STATUS_SUCCESS )
                status = fileObject->FinalStatus;
        }

    /*
     * Caller specified a wait event.
     * Return the Irp pointer if the caller specified a return pointer.
     */
    } else {
        if ( ppIrp )
            *ppIrp = irp;
    }

    return( status );
}


NTSTATUS _CtxDeviceControlComplete(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp,
        IN PVOID Context)
{
    //
    // If there was an MDL in the IRP, free it and reset the pointer to
    // NULL.  The IO system can't handle a nonpaged pool MDL being freed
    // in an IRP, which is why we do it here.
    //
    if ( Irp->MdlAddress != NULL ) {
        IoFreeMdl( Irp->MdlAddress );
        Irp->MdlAddress = NULL;
    }

    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\inc\sdapi.h ===
/****************************************************************************/
// sdapi.h
//
// TS protocol stack driver common definitions.
//
// Copyright (C) 1998-2000 Microsoft Corporation
/****************************************************************************/
#ifndef __SDAPI_H
#define __SDAPI_H


/*
 *  TRACE defines
 */
#if DBG
#define TRACE(_arg)     IcaStackTrace _arg
#define TRACEBUF(_arg)  IcaStackTraceBuffer _arg
#else
#define TRACE(_arg)
#define TRACEBUF(_arg)
#endif


/*
 * Input buffer data structure
 */
typedef struct _INBUF {

    LIST_ENTRY Links;           // Pointer to previous/next buffer
    PUCHAR pBuffer;             // Pointer to current location in Buffer
    ULONG ByteCount;            // Number of bytes in Buffer
    ULONG MaxByteCount;         // Max size of Buffer

    PIRP pIrp;                  // pointer to Irp to use for I/O
    PMDL pMdl;                  // pointer to MDL to use for I/O
    PVOID pPrivate;             // pointer to private data
} INBUF, *PINBUF;


/*
 *  Outpuf Buffer data structure
 */
typedef struct _OUTBUF {
    /*
     *  Non-inherited fields
     */
    ULONG OutBufLength;         // length of allocated memory for outbuf
    int PoolIndex;              // Stores the buffer pool this buffer goes to.
    LIST_ENTRY Links;           // pointer to previous/next outbuf
    PUCHAR pBuffer;             // pointer within buffer memory
    ULONG ByteCount;            // byte count pointed to by pBuffer
    ULONG MaxByteCount;         // maximum byte count possible (static)
    PETHREAD ThreadId;          // thread id which issued i/o reqst for this buf

    PIRP pIrp;                  // pointer to Irp to use for I/O
    PMDL pMdl;                  // pointer to MDL to use for I/O
    PVOID pPrivate;             // pointer to private data

    /*
     *  Inherited fields (when pd allocates new outbuf and copies the data)
     */
    ULONG StartTime;            // pdreli - transmit time (used to measure roundtrip)
    UCHAR Sequence;             // pdreli - output sequence number
    UCHAR Fragment;             // pdreli - outbuf fragment number
    ULONG fWait : 1;            // pdreli - waits allowed on this outbuf
    ULONG fControl : 1;         // pdreli - control buffer (ack/nak)
    ULONG fRetransmit : 1;      // pdreli - buffer has been retransmited
    ULONG fCompress : 1;        // pdcomp - buffer should be compressed

    // Other flags.
    ULONG fIrpCompleted : 1;    // Used on completion to prevent canceling.
} OUTBUF, * POUTBUF;


/*
 * Typedefs for Stack Driver callup routines
 */
typedef NTSTATUS (*PSDBUFFERALLOC)(
        IN PVOID pContext,
        IN BOOLEAN bWait,
        IN BOOLEAN bControl,
        ULONG ByteCount,
        PVOID pBufferOrig,
        PVOID *pBuffer);

typedef VOID (*PSDBUFFERFREE)(IN PVOID pContext, PVOID pBuffer);

typedef NTSTATUS (*PSDRAWINPUT)(
        IN PVOID pContext,
        IN PINBUF pInBuf OPTIONAL,
        IN PUCHAR pBuffer OPTIONAL,
        IN ULONG ByteCount);

typedef NTSTATUS (*PSDCHANNELINPUT)(
        IN PVOID pContext,
        IN CHANNELCLASS ChannelClass,
        IN VIRTUALCHANNELCLASS VirtualClass,
        IN PINBUF pInBuf OPTIONAL,
        IN PUCHAR pBuffer OPTIONAL,
        IN ULONG ByteCount);


/*
 * Stack Driver callup table
 */
typedef struct _SDCALLUP {
    PSDBUFFERALLOC  pSdBufferAlloc;
    PSDBUFFERFREE   pSdBufferFree;
    PSDBUFFERFREE   pSdBufferError;
    PSDRAWINPUT     pSdRawInput;
    PSDCHANNELINPUT pSdChannelInput;
} SDCALLUP, *PSDCALLUP;


/*
 * Stack Driver Context structure
 * This is filled in by the SD at load time, and is passed
 * as an argument to most ICA driver helper routines.
 */
typedef struct _SDCONTEXT {
    PVOID       pProcedures;    // Pointer to proc table for this driver
    PSDCALLUP   pCallup;        // Pointer to callup table for this driver
    PVOID       pContext;       // Context value passed on calls to driver
} SDCONTEXT, *PSDCONTEXT;


/*
 * Stack Driver Load/Unload procedure prototype
 */
typedef NTSTATUS (_stdcall *PSDLOADPROC)(
        IN OUT PSDCONTEXT pSdContext,
        IN BOOLEAN bLoad);

/*
 * Stack Driver procedure prototype
 */
typedef NTSTATUS (_stdcall *PSDPROCEDURE)(
        IN PVOID pContext,
        IN PVOID pParms);


/*=============================================================================
==   Stack Driver interface
=============================================================================*/

/*
 * Stack Driver (WD/PD/TD) APIs
 */
#define SD$OPEN         0
#define SD$CLOSE        1
#define SD$RAWWRITE     2
#define SD$CHANNELWRITE 3
#define SD$SYNCWRITE    4
#define SD$IOCTL        5
#define SD$COUNT        6


/*
 * SdOpen structure
 */
typedef struct _SD_OPEN {
    STACKCLASS StackClass;          // IN: stack type
    PPROTOCOLSTATUS pStatus;        // IN:
    PCLIENTMODULES pClient;         // IN:
    WDCONFIG WdConfig;              // IN: WD configuration data 
    PDCONFIG PdConfig;              // IN: PD configuration data 
    char  OEMId[4];                 // IN: WinFrame Server OEM Id from registry
    WINSTATIONNAME WinStationRegName; // IN: WinStation registry name
    PDEVICE_OBJECT DeviceObject;    // IN: pointer to device object to use with the unload safe completion routine
    ULONG OutBufHeader;             // IN: number of header bytes to reserve
    ULONG OutBufTrailer;            // IN: number of trailer bytes to reserve
    ULONG SdOutBufHeader;           // OUT: returned by sd
    ULONG SdOutBufTrailer;          // OUT: returned by sd   
} SD_OPEN, *PSD_OPEN;


/*
 * SdClose structure
 */
typedef struct _SD_CLOSE {
    ULONG SdOutBufHeader;           // OUT: returned by sd
    ULONG SdOutBufTrailer;          // OUT: returned by sd   
} SD_CLOSE, *PSD_CLOSE;


/*
 * SdRawWrite structure
 */
typedef struct _SD_RAWWRITE {
    POUTBUF pOutBuf;
    PUCHAR pBuffer;
    ULONG ByteCount;
} SD_RAWWRITE, *PSD_RAWWRITE;

/*
 * SdChannelWrite fFlags Values
 */
 #define SD_CHANNELWRITE_LOWPRIO    0x00000001  // Write can block behind
                                                //  default priority writes.

/*
 * SdChannelWrite structure
 *
 * The flags field is passed to termdd.sys via an IRP_MJ_WRITE 
 * Irp, as a ULONG pointer in the Irp->Tail.Overlay.DriverContext[0] field.
 */
typedef struct _SD_CHANNELWRITE {
    CHANNELCLASS ChannelClass;
    VIRTUALCHANNELCLASS VirtualClass;
    BOOLEAN fScreenData;
    POUTBUF pOutBuf;
    PUCHAR pBuffer;
    ULONG ByteCount;
    ULONG fFlags;
} SD_CHANNELWRITE, *PSD_CHANNELWRITE;

/*
 * SdIoctl structure
 */
typedef struct _SD_IOCTL {
    ULONG IoControlCode;           // IN
    PVOID InputBuffer;             // IN OPTIONAL
    ULONG InputBufferLength;       // IN
    PVOID OutputBuffer;            // OUT OPTIONAL
    ULONG OutputBufferLength;      // OUT
    ULONG BytesReturned;           // OUT
} SD_IOCTL, *PSD_IOCTL;


/*
 * SdSyncWrite structure
 */
typedef struct _SD_SYNCWRITE {
    ULONG notused;
} SD_SYNCWRITE, *PSD_SYNCWRITE;


/*=============================================================================
==   Stack Drivers helper routines
=============================================================================*/

#define ICALOCK_IO      0x00000001
#define ICALOCK_DRIVER  0x00000002

NTSTATUS IcaBufferAlloc(PSDCONTEXT, BOOLEAN, BOOLEAN, ULONG, PVOID, PVOID *);
void IcaBufferFree(PSDCONTEXT, PVOID);
void IcaBufferError(PSDCONTEXT, PVOID);
unsigned IcaBufferGetUsableSpace(unsigned);

NTSTATUS IcaRawInput(PSDCONTEXT, PINBUF, PUCHAR, ULONG);
NTSTATUS IcaChannelInput(PSDCONTEXT, CHANNELCLASS, VIRTUALCHANNELCLASS,
        PINBUF, PUCHAR, ULONG);
NTSTATUS IcaCreateThread(PSDCONTEXT, PVOID, PVOID, ULONG, PHANDLE);
NTSTATUS IcaCallNextDriver(PSDCONTEXT, ULONG, PVOID);

NTSTATUS IcaTimerCreate(PSDCONTEXT, PVOID *);
BOOLEAN IcaTimerStart(PVOID, PVOID, PVOID, ULONG, ULONG);
BOOLEAN IcaTimerCancel(PVOID);
BOOLEAN IcaTimerClose(PVOID);

NTSTATUS IcaQueueWorkItem(PSDCONTEXT, PVOID, PVOID, ULONG);
NTSTATUS IcaSleep(PSDCONTEXT, ULONG);
NTSTATUS IcaWaitForSingleObject(PSDCONTEXT, PVOID, LONG);
NTSTATUS IcaFlowControlSleep(PSDCONTEXT, ULONG);
NTSTATUS IcaFlowControlWait(PSDCONTEXT, PVOID, LONG);
NTSTATUS IcaWaitForMultipleObjects(PSDCONTEXT, ULONG, PVOID [], WAIT_TYPE,
        LONG);

NTSTATUS IcaLogError(PSDCONTEXT, NTSTATUS, LPWSTR *, ULONG, PVOID, ULONG);
VOID _cdecl IcaStackTrace(PSDCONTEXT, ULONG, ULONG, CHAR *, ...);
VOID IcaStackTraceBuffer(PSDCONTEXT, ULONG, ULONG, PVOID, ULONG);


NTSTATUS
IcaQueueWorkItemEx(
    IN PSDCONTEXT pContext,
    IN PVOID pFunc, 
    IN PVOID pParam, 
    IN ULONG LockFlags,
    IN PVOID pIcaWorkItem 
    );

NTSTATUS
IcaAllocateWorkItem(
    OUT PVOID *pParam 
    );

NTSTATUS
IcaCreateHandle(
    PVOID Context,
    ULONG ContextSize,
    PVOID *ppHandle
    );

NTSTATUS
IcaReturnHandle(
    PVOID  Handle,
    PVOID  *ppContext,
    PULONG pContextSize
    );

NTSTATUS
IcaCloseHandle(
    PVOID  Handle,
    PVOID  *ppContext,
    PULONG pContextSize
    );

PVOID IcaStackAllocatePoolWithTag(
        IN POOL_TYPE PoolType,
        IN SIZE_T NumberOfBytes,
        IN ULONG Tag );

PVOID IcaStackAllocatePool(
        IN POOL_TYPE PoolType,
        IN SIZE_T NumberOfBytes);

void IcaStackFreePool(IN PVOID Pointer);

ULONG IcaGetLowWaterMark(IN PSDCONTEXT pContext);

ULONG IcaGetSizeForNoLowWaterMark(IN PSDCONTEXT pContext);
#endif  // __SDAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\td\common\memory.c ===
/*******************************************************************************
*
*   MEMORY.C
*
*   Memory allocation routines
*
*
*   Copyright Microsoft. 1998
*
*
******************************************************************************/

/*
 *  Includes
 */
#include <ntddk.h>
#include <ntddvdeo.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <ntddbeep.h>

#include <winstaw.h>
#include <icadd.h>
#include <sdapi.h>
#include <td.h>



/*=============================================================================
==   External Functions Defined
=============================================================================*/

NTSTATUS MemoryAllocate( ULONG, PVOID * );
VOID MemoryFree( PVOID );


/*=============================================================================
==   Internal Functions Defined
=============================================================================*/


/*******************************************************************************
 *
 *  MemoryAllocate
 *
 *  This routine allocate a block of memory
 *
 *  ENTRY:
 *     Length (input)
 *        length of memory to allocate
 *     ppMemory (output)
 *        address to return pointer to memory
 *
 *  EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
MemoryAllocate( ULONG Length, PVOID * ppMemory )
{
    ASSERT( Length > 0 );

    *ppMemory = IcaStackAllocatePoolWithTag( NonPagedPool, Length, '  DT' );
    if ( *ppMemory == NULL )
        return( STATUS_NO_MEMORY );

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  MemoryFree
 *
 *  This routine frees a block of memory allocated by "MemoryAllocate"
 *
 *  ENTRY:
 *     pMemory (output)
 *        pointer to memory to free
 *
 *  EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
MemoryFree( PVOID pMemory )
{
    IcaStackFreePool( pMemory );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\td\common\buffer.c ===
/*************************************************************************
*
* buffer.c 
*
* Common buffering code for all transport drivers
*
* Copyright 1998, Microsoft
*
*  
*************************************************************************/

/*
 *  Includes
 */
#include <ntddk.h>
#include <ntddvdeo.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <ntddbeep.h>

#include <winstaw.h>
#include <icadd.h>
#include <sdapi.h>
#include <td.h>

/*=============================================================================
==   External Functions Defined
=============================================================================*/

VOID OutBufError( PTD, POUTBUF );
VOID OutBufFree( PTD, POUTBUF );

/*=============================================================================
==   Functions used
=============================================================================*/


/*******************************************************************************
 *
 *  OutBufError
 *
 *  This routine is used to return an output buffer to the ICA driver
 *  free pool on an unsuccessful write or other error. 
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *    pOutBuf (input)
 *       pointer to output buffer
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
OutBufError( PTD pTd, POUTBUF pOutBuf )
{
    ASSERT( pOutBuf->Links.Flink == pOutBuf->Links.Blink );

    IcaBufferError( pTd->pContext, pOutBuf );
}


/*******************************************************************************
 *
 *  OutBufFree
 *
 *  This routine is used to return an output buffer to the up stream
 *  stack driver.  This routine should only be used when the data contained
 *  in the output buffer was successfully written to the transport.
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *    pOutBuf (input)
 *       pointer to output buffer
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
OutBufFree( PTD pTd, POUTBUF pOutBuf )
{
    ASSERT( pOutBuf->Links.Flink == pOutBuf->Links.Blink );

    IcaBufferFree( pTd->pContext, pOutBuf );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\td\common\input.c ===
/*************************************************************************
*
* input.c 
*
* Common input code for all transport drivers
*
* Copyright 1998, Microsoft
*
*************************************************************************/

/*
 *  Includes
 */
#include <ntddk.h>
#include <ntddvdeo.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <ntddbeep.h>

#include <winstaw.h>
#include <icadd.h>
#include <sdapi.h>
#include <td.h>

#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif


/*=============================================================================
==   External Functions Defined
=============================================================================*/

NTSTATUS TdInputThread( PTD );


/*=============================================================================
==   Internal Functions Defined
=============================================================================*/

NTSTATUS _TdInBufAlloc( PTD, PINBUF * );
VOID     _TdInBufFree( PTD, PINBUF );
NTSTATUS _TdInitializeRead( PTD, PINBUF );
NTSTATUS _TdReadComplete( PTD, PINBUF );
NTSTATUS _TdReadCompleteRoutine( PDEVICE_OBJECT, PIRP, PVOID );


/*=============================================================================
==   Functions used
=============================================================================*/

NTSTATUS DeviceInitializeRead( PTD, PINBUF );
NTSTATUS DeviceWaitForRead( PTD );
NTSTATUS DeviceReadComplete( PTD, PUCHAR, PULONG );
NTSTATUS StackCancelIo( PTD, PSD_IOCTL );
NTSTATUS NtSetInformationThread( HANDLE, THREADINFOCLASS, PVOID, ULONG );
NTSTATUS DeviceSubmitRead( PTD, PINBUF );
NTSTATUS MemoryAllocate( ULONG, PVOID * );
VOID     MemoryFree( PVOID );


/*******************************************************************************
 *
 *  TdInputThread
 *
 *   This private TD thread waits for input data.  This thread is created
 *   when a client connection is established and is terminated when 
 *   StackCancelIo is called.
 *
 *   All received data is sent to the up stream stack driver.
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

NTSTATUS 
TdInputThread( PTD pTd )
{
    ICA_CHANNEL_COMMAND Command;
    KPRIORITY Priority;
    PFILE_OBJECT pFileObject;
    PINBUF pInBuf;
    PLIST_ENTRY Head, Next;
    KIRQL oldIrql;
    ULONG InputByteCount;
    int i;
    NTSTATUS Status;

    TRACE(( pTd->pContext, TC_TD, TT_API2, "TdInputThread (entry)\n" ));

    /*
     *  Check if driver is being closed or endpoint has been closed
     */
    if ( pTd->fClosing || pTd->pDeviceObject == NULL ) {
        TRACE(( pTd->pContext, TC_TD, TT_API2, "TdInputThread (exit) on init\n" ));
        return( STATUS_CTX_CLOSE_PENDING );
    }

    /*
     *  Set the priority of this thread to lowest realtime (16).
     */
    Priority = LOW_REALTIME_PRIORITY;
    NtSetInformationThread( NtCurrentThread(), ThreadPriority, 
                            &Priority, sizeof(KPRIORITY) );

    /*
     * Initialize the input wait event
     */
    KeInitializeEvent( &pTd->InputEvent, NotificationEvent, FALSE );

    /*
     * Allocate and pre-submit one less than the total number
     * of input buffers that we will use.  The final buffer will
     * be allocated/submitted within the input loop.
     */
    for ( i = 1; i < pTd->InBufCount; i++ ) {

        /*
         * Allocate an input buffer
         */
        Status = _TdInBufAlloc( pTd, &pInBuf );
        if ( !NT_SUCCESS( Status ) )
            return( Status );
    
        /*
         * Initialize the read IRP
         */
        Status = _TdInitializeRead( pTd, pInBuf );
        if ( !NT_SUCCESS(Status) )
            return( Status );
    
        /*
         * Let the device level code complete the IRP initialization
         */
        Status = DeviceInitializeRead( pTd, pInBuf );
        if ( !NT_SUCCESS(Status) )
            return( Status );
    
        /*
         * Place the INBUF on the busy list and call the device submit routine.
         * (TDI based drivers use receive indications, so we let
         * the TD specific code call the driver.)
         */
        ExInterlockedInsertTailList( &pTd->InBufBusyHead, &pInBuf->Links,
                                     &pTd->InBufListLock );
        Status = DeviceSubmitRead( pTd, pInBuf );
    }

    /*
     * Allocate an input buffer
     */
    Status = _TdInBufAlloc( pTd, &pInBuf );
    if ( !NT_SUCCESS( Status ) )
        return( Status );

    /*
     * Reference the file object and keep a local pointer to it.
     * This is done so that when the endpoint object gets closed,
     * and pTd->pFileObject gets dereferenced and cleared, the file
     * object will not get deleted before all of the pending input IRPs
     * (which reference the file object) get cancelled.
     */
    ObReferenceObject( (pFileObject = pTd->pFileObject) );

    /*
     * Loop reading input data until cancelled or we get an error.
     */
    for (;;) {

        /*
         * Initialize the read IRP
         */
        Status = _TdInitializeRead( pTd, pInBuf );
        if ( !NT_SUCCESS(Status) )
            break;
    
        /*
         * Let the device level code complete the IRP initialization
         */
        Status = DeviceInitializeRead( pTd, pInBuf );
        if ( !NT_SUCCESS(Status) )
            break;
    
        /*
         * Place the INBUF on the busy list and call the device submit routine.
         * (TDI based drivers use receive indications, so we let
         * the TD specific code call the driver.)
         */
        ExInterlockedInsertTailList( &pTd->InBufBusyHead, &pInBuf->Links,
                                     &pTd->InBufListLock );
        Status = DeviceSubmitRead( pTd, pInBuf );
        /*
         * Indicate we no longer have an INBUF referenced
         */
        pInBuf = NULL;

        if ( !NT_SUCCESS(Status) ) {
            TRACE(( pTd->pContext, TC_TD, TT_ERROR, "TdInputThread: IoCallDriver Status=0x%x\n", Status ));
            TRACE0(("TdInputThread: IoCallDriver Status=0x%x, Context 0x%x\n", Status, pTd->pAfd ));
            pTd->ReadErrorCount++;
            pTd->pStatus->Input.TdErrors++;
            if ( pTd->ReadErrorCount >= pTd->ReadErrorThreshold ) {
                // Submit failed, set the event since no IRP's are queued
                KeSetEvent( &pTd->InputEvent, 1, FALSE );
                break;
            }
        }

        /*
         * If the INBUF completed list is empty,
         * then wait for one to be available.
         */
waitforread:
        ExAcquireSpinLock( &pTd->InBufListLock, &oldIrql );
        if ( IsListEmpty( &pTd->InBufDoneHead ) ) {

            KeClearEvent( &pTd->InputEvent );

            ExReleaseSpinLock( &pTd->InBufListLock, oldIrql );
            Status = DeviceWaitForRead( pTd );

            /*
             *  Check for broken connection
             */
            if ( pTd->fClosing ) {
                TRACE(( pTd->pContext, TC_TD, TT_IN1, "TdInputThread: fClosing set\n" ));
                TRACE0(("TdInputThread: fClosing set Context 0x%x\n",pTd->pAfd ));
                break;
            } else if ( Status != STATUS_SUCCESS) {
                TRACE(( pTd->pContext, TC_TD, TT_ERROR, "TdInputThread: DeviceWaitForRead Status=0x%x\n", Status ));
                TRACE0(( "TdInputThread: DeviceWaitForRead Status=0x%x, Context 0x%x\n", Status, pTd->pAfd ));
                pTd->ReadErrorCount++;
                pTd->pStatus->Input.TdErrors++;
                if ( pTd->ReadErrorCount < pTd->ReadErrorThreshold )
                    goto waitforread;
                break;
            }
            ExAcquireSpinLock( &pTd->InBufListLock, &oldIrql );

        /*
         *  Check for broken connection
         */
        } else if ( pTd->fClosing ) {
            ExReleaseSpinLock( &pTd->InBufListLock, oldIrql );
            TRACE(( pTd->pContext, TC_TD, TT_IN1, "TdInputThread: fClosing set\n" ));
            TRACE0(("TdInputThread: fClosing set Context 0x%x\n",pTd->pAfd ));
            break;
        }
    
        /*
         *  If the list is empty as this point, we will just bail.
         */
        if (!IsListEmpty( &pTd->InBufDoneHead )) {
            
            /*
             * Take the first INBUF off the completed list.
             */
            Head = RemoveHeadList( &pTd->InBufDoneHead );
            ExReleaseSpinLock( &pTd->InBufListLock, oldIrql );
            pInBuf = CONTAINING_RECORD( Head, INBUF, Links );
    
            /*
             * Do any preliminary read complete processing
             */
            (VOID) _TdReadComplete( pTd, pInBuf );
    
            /*
             * Get status from IRP.  Note that we allow warning and informational
             * status codes as they can also return valid data.
             */
            Status = pInBuf->pIrp->IoStatus.Status;
            InputByteCount = (ULONG)pInBuf->pIrp->IoStatus.Information;
            if (NT_ERROR(Status)) {
                TRACE(( pTd->pContext, TC_TD, TT_ERROR, "TdInputThread: IRP Status=0x%x\n", Status ));
                TRACE0(("TdInputThread: IRP Status=0x%x, Context 0x%x\n", Status, pTd->pAfd ));
                pTd->ReadErrorCount++;
                pTd->pStatus->Input.TdErrors++;
                if ( pTd->ReadErrorCount < pTd->ReadErrorThreshold )
                    continue;
                break;
            }
            if ( Status == STATUS_TIMEOUT )
                Status = STATUS_SUCCESS;
    
            /*
             *  Make sure we got some data
             */
            TRACE(( pTd->pContext, TC_TD, TT_IN1, "TdInputThread: read cnt=%04u, Status=0x%x\n", 
                    InputByteCount, Status ));
    
            /*
             *  Check for consecutive zero byte reads
             *  -- the client may have dropped the connection and ReadFile does
             *     not always return an error.
             *  -- some tcp networks return zero byte reads now and then 
             */
            if ( InputByteCount == 0 ) {
                TRACE(( pTd->pContext, TC_TD, TT_ERROR, "recv warning: zero byte count\n" ));
                TRACE0(("recv warning: zero byte count, Context 0x%x\n",pTd->pAfd ));
                if ( ++pTd->ZeroByteReadCount > MAXIMUM_ZERO_BYTE_READS ) {
                    TRACE(( pTd->pContext, TC_TD, TT_ERROR, "recv failed: %u zero bytes\n", MAXIMUM_ZERO_BYTE_READS ));
                    TRACE0(("recv failed: %u zero bytes Context 0x%x\n", MAXIMUM_ZERO_BYTE_READS, pTd->pAfd ));
                    Status = STATUS_CTX_TD_ERROR;
                    break;
                }
                continue;
            }
    
            /*
             * Clear count of consecutive zero byte reads
             */
            pTd->ZeroByteReadCount = 0;
        
            TRACEBUF(( pTd->pContext, TC_TD, TT_IRAW, pInBuf->pBuffer, InputByteCount ));
    
            /*
             * Do device specific read completion processing.
             * If the byte count returned is 0, then the device routine
             * processed all input data so there is nothing for us to do.
             */
            Status = DeviceReadComplete( pTd, pInBuf->pBuffer, &InputByteCount );
            if ( !NT_SUCCESS(Status) ) {
                TRACE(( pTd->pContext, TC_TD, TT_ERROR, "TdInputThread: DeviceReadComplete Status=0x%x\n", Status ));
                TRACE0(("TdInputThread: DeviceReadComplete Status=0x%x, Context 0x%x\n", Status, pTd->pAfd ));
                pTd->ReadErrorCount++;
                pTd->pStatus->Input.TdErrors++;
                if ( pTd->ReadErrorCount < pTd->ReadErrorThreshold )
                    continue;
                break;
            }
            if ( InputByteCount == 0 )
                continue;
    
            /*
             * Clear count of consecutive read errors
             */
            pTd->ReadErrorCount = 0;
    
            /*
             *  Update input byte counter
             */
            pTd->pStatus->Input.Bytes += (InputByteCount - pTd->InBufHeader);
            if ( pTd->PdFlag & PD_FRAME )
                pTd->pStatus->Input.Frames++;
        
            /*
             *  Send input data to upstream stack driver
             */
            Status = IcaRawInput( pTd->pContext, 
                                  NULL, 
                                  (pInBuf->pBuffer + pTd->InBufHeader),
                                  (InputByteCount - pTd->InBufHeader) );
            if ( !NT_SUCCESS(Status) ) 
                break;
        }
        else {
            ExReleaseSpinLock( &pTd->InBufListLock, oldIrql );
            TRACE(( pTd->pContext, TC_TD, TT_IN1, "TdInputThread: InBuf is empty\n" ));
            ASSERT(FALSE);
            pTd->ReadErrorCount++;  
            pTd->pStatus->Input.TdErrors++;
            if ( pTd->ReadErrorCount < pTd->ReadErrorThreshold )
                goto waitforread;
            else
                break;
        }
    }

    TRACE0(("TdInputThread: Breaking Connection Context 0x%x\n",pTd->pAfd));

    /*
     * Free current INBUF if we have one
     */
    if ( pInBuf )
        _TdInBufFree( pTd, pInBuf );

    /*
     *  Cancel all i/o 
     */
    (VOID) StackCancelIo( pTd, NULL );

    /*
     * Wait for pending read (if any) to be cancelled
     */
    (VOID) IcaWaitForSingleObject( pTd->pContext, &pTd->InputEvent, -1 );

    /*
     * Free all remaining INBUFs
     */
    ExAcquireSpinLock( &pTd->InBufListLock, &oldIrql );
    while ( !IsListEmpty( &pTd->InBufBusyHead ) ||
            !IsListEmpty( &pTd->InBufDoneHead ) ) {

        if ( !IsListEmpty( &pTd->InBufBusyHead ) ) {
            BOOLEAN rc;

            Head = RemoveHeadList( &pTd->InBufBusyHead );
            Head->Flink = NULL;
            ExReleaseSpinLock( &pTd->InBufListLock, oldIrql );
            pInBuf = CONTAINING_RECORD( Head, INBUF, Links );
            rc = IoCancelIrp( pInBuf->pIrp );
#if DBG
            if ( !rc ) {
                DbgPrint("TDCOMMON: StackCancelIo: Could not cancel IRP 0x%x\n",pInBuf->pIrp);
            }
#endif
            ExAcquireSpinLock( &pTd->InBufListLock, &oldIrql );
        }

        if ( IsListEmpty( &pTd->InBufDoneHead ) ) {
            KeClearEvent( &pTd->InputEvent );
            ExReleaseSpinLock( &pTd->InBufListLock, oldIrql );
            Status = DeviceWaitForRead( pTd );
            ExAcquireSpinLock( &pTd->InBufListLock, &oldIrql );
        }

        if ( !IsListEmpty( &pTd->InBufDoneHead ) ) {
            Head = RemoveHeadList( &pTd->InBufDoneHead );
            ExReleaseSpinLock( &pTd->InBufListLock, oldIrql );
            pInBuf = CONTAINING_RECORD( Head, INBUF, Links );
            _TdInBufFree( pTd, pInBuf );
            ExAcquireSpinLock( &pTd->InBufListLock, &oldIrql );
        }
    }
    ASSERT( IsListEmpty( &pTd->InBufBusyHead ) );
    ASSERT( IsListEmpty( &pTd->InBufDoneHead ) );
    ExReleaseSpinLock( &pTd->InBufListLock, oldIrql );

    /*
     * Release our reference on the underlying file object
     */
    ObDereferenceObject( pFileObject );

    /*
     *  Report broken connection if no modem callback in progress
     */
    if ( !pTd->fCallbackInProgress ) {
        Command.Header.Command          = ICA_COMMAND_BROKEN_CONNECTION;

        //
        // If it's not an unexpected disconnection then set the reason
        // to disconnect. This prevents problems where termsrv resets the
        // session if it receives the wrong type of notification.
        //
        if (pTd->UserBrokenReason == TD_USER_BROKENREASON_UNEXPECTED) {
            Command.BrokenConnection.Reason = Broken_Unexpected;
            //
            // We don't know better so pick server as the source
            //
            Command.BrokenConnection.Source = BrokenSource_Server;
        }
        else
        {
            Command.BrokenConnection.Reason = Broken_Disconnect;
            Command.BrokenConnection.Source = BrokenSource_User;
        }

        (void) IcaChannelInput( pTd->pContext, 
                                Channel_Command, 
                                0, 
                                NULL, 
                                (PCHAR) &Command, 
                                sizeof(Command) );
    }

    TRACE(( pTd->pContext, TC_TD, TT_API2, "TdInputThread (exit), Status=0x%x\n", Status ));
    TRACE0(("TdInputThread (exit), Status=0x%x, Context 0x%x\n", Status, pTd->pAfd ));

    return( Status );
}


/*******************************************************************************
 *
 *  _TdInBufAlloc
 *
 *    Routine to allocate an INBUF and related objects.
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_TdInBufAlloc(
    PTD pTd,
    PINBUF *ppInBuf
    )
{
    ULONG InBufLength;
    ULONG irpSize;
    ULONG mdlSize;
    ULONG AllocationSize;
    KIRQL oldIrql;
    PINBUF pInBuf;
    NTSTATUS Status;

#define INBUF_STACK_SIZE 4

    /*
     * Determine size of input buffer
     */
    InBufLength = pTd->OutBufLength + pTd->InBufHeader;

    /*
     * Determine the sizes of the various components of an INBUF.
     * Note that these are all worst-case calculations--
     * actual size of the MDL may be smaller.
     */
    irpSize = IoSizeOfIrp( INBUF_STACK_SIZE ) + 8;
    mdlSize = (ULONG)MmSizeOfMdl( (PVOID)(PAGE_SIZE-1), InBufLength );

    /*
     * Add up the component sizes of an INBUF to determine
     * the total size that is needed to allocate.
     */
    AllocationSize = (((sizeof(INBUF) + InBufLength + 
                     irpSize + mdlSize) + 3) & ~3);

    Status = MemoryAllocate( AllocationSize, &pInBuf );
    if ( !NT_SUCCESS( Status ) )
        return( STATUS_NO_MEMORY );

    /*
     * Initialize the IRP pointer and the IRP itself.
     */
    if ( irpSize ) {
        pInBuf->pIrp = (PIRP)(( ((ULONG_PTR)(pInBuf + 1)) + 7) & ~7);
        IoInitializeIrp( pInBuf->pIrp, (USHORT)irpSize, INBUF_STACK_SIZE );
    }

    /*
     * Set up the MDL pointer but don't build it yet.
     * It will be built by the TD write code if needed.
     */
    if ( mdlSize ) {
        pInBuf->pMdl = (PMDL)((PCHAR)pInBuf->pIrp + irpSize);
    }

    /*
     * Set up the address buffer pointer.
     */
    pInBuf->pBuffer = (PUCHAR)pInBuf + sizeof(INBUF) + irpSize + mdlSize;

    /*
     *  Initialize the rest of InBuf
     */
    InitializeListHead( &pInBuf->Links );
    pInBuf->MaxByteCount = InBufLength;
    pInBuf->ByteCount = 0;
    pInBuf->pPrivate = pTd;

    /*
     *  Return buffer to caller
     */
#if DBG
    DbgPrint( "TdInBufAlloc: pInBuf=0x%x\n", pInBuf );
#endif  // DBG
    *ppInBuf = pInBuf;

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  _TdInBufFree
 *
 *    Routine to free an INBUF and related objects.
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

VOID
_TdInBufFree(
    PTD pTd,
    PINBUF pInBuf
    )
{
    MemoryFree( pInBuf );
}


/*******************************************************************************
 *
 *  _TdInitializeRead
 *
 *    Routine to allocate and initialize the input IRP and related objects.
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_TdInitializeRead(
    PTD pTd,
    PINBUF pInBuf
    )
{
    PIRP irp = pInBuf->pIrp;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS Status;

    /*
     *  Check if driver is being closed or endpoint has been closed
     */
    if ( pTd->fClosing || pTd->pDeviceObject == NULL ) {
        TRACE(( pTd->pContext, TC_TD, TT_API2, "_TdInitializeRead: closing\n" ));
        return( STATUS_CTX_CLOSE_PENDING );
    }

    /*
     * Set current thread for IoSetHardErrorOrVerifyDevice.
     */
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    /*
     * Get a pointer to the stack location of the first driver which will be
     * invoked.  This is where the function codes and the parameters are set.
     */
    irpSp = IoGetNextIrpStackLocation( irp );

    /*
     * Set the file/device objects and anything not specific to
     * the TD. and read parameters.
     */
    irpSp->FileObject = pTd->pFileObject;
    irpSp->DeviceObject = pTd->pDeviceObject;

    irp->MdlAddress = NULL;

    irp->Flags = IRP_READ_OPERATION;

    /*
     * Register the I/O completion routine
     */
    if ( pTd->pSelfDeviceObject ) {
        IoSetCompletionRoutineEx( pTd->pSelfDeviceObject, irp, _TdReadCompleteRoutine, pInBuf,
                                TRUE, TRUE, TRUE );
    } else {
        IoSetCompletionRoutine( irp, _TdReadCompleteRoutine, pInBuf,
                                TRUE, TRUE, TRUE );
    }

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  _TdReadCompleteRoutine
 *
 *    This routine is called at DPC level by the lower level device
 *    driver when an input IRP is completed.
 *
 * ENTRY:
 *    DeviceObject (input)
 *       not used
 *    pIrp (input)
 *       pointer to IRP that is complete
 *    Context (input)
 *       Context pointer setup when IRP was initialized.
 *       This is a pointer to the corresponding INBUF.
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_TdReadCompleteRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    KIRQL oldIrql;
    PINBUF pInBuf = (PINBUF)Context;
    PTD pTd = (PTD)pInBuf->pPrivate;

    /*
     * Unlink inbuf from busy list and place on completed list
     */
    ExAcquireSpinLock( &pTd->InBufListLock, &oldIrql );

    if ( pInBuf->Links.Flink )
        RemoveEntryList( &pInBuf->Links );
    InsertTailList( &pTd->InBufDoneHead, &pInBuf->Links );

    /*
     * Check the auxiliary buffer pointer in the packet and if a buffer was
     * allocated, deallocate it now.  Note that this buffer must be freed
     * here since the pointer is overlayed with the APC that will be used
     * to get to the requesting thread's context.
     */
    if (Irp->Tail.Overlay.AuxiliaryBuffer) {
        IcaStackFreePool( Irp->Tail.Overlay.AuxiliaryBuffer );
        Irp->Tail.Overlay.AuxiliaryBuffer = NULL;
    }

    //
    // Check to see whether any pages need to be unlocked.
    //
    if (Irp->MdlAddress != NULL) {
        PMDL mdl, thisMdl;

        //
        // Unlock any pages that may be described by MDLs.
        //
        mdl = Irp->MdlAddress;
        while (mdl != NULL) {
            thisMdl = mdl;
            mdl = mdl->Next;
            if (thisMdl == pInBuf->pMdl)
                continue;

            MmUnlockPages( thisMdl );
            IoFreeMdl( thisMdl );
        }
    }

    /*
     * Indicate an INBUF was completed
     */
    KeSetEvent( &pTd->InputEvent, 1, FALSE );

    // WARNING!: At this point, we may context switch back to the input thread
    //           and unload the darn driver!!!  This has been temporarily hacked
    //           for TDPipe by remoing the unload entry point ;-(
    ExReleaseSpinLock( &pTd->InBufListLock, oldIrql );

    /*
     * We return STATUS_MORE_PROCESS_REQUIRED so that no further
     * processing for this IRP is done by the I/O completion routine.
     */
    return( STATUS_MORE_PROCESSING_REQUIRED );
}


/*******************************************************************************
 *
 *  _TdReadComplete
 *
 *    This routine is called at program level after an input IRP
 *    has been completed.
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_TdReadComplete(
    IN PTD pTd,
    IN PINBUF pInBuf
    )
{
    PIRP irp = pInBuf->pIrp;

    /*
     * Handle the buffered I/O case
     */
    if (irp->Flags & IRP_BUFFERED_IO) {

        //
        // Copy the data if this was an input operation.  Note that no copy
        // is performed if the status indicates that a verify operation is
        // required, or if the final status was an error-level severity.
        //

        if (irp->Flags & IRP_INPUT_OPERATION  &&
            irp->IoStatus.Status != STATUS_VERIFY_REQUIRED &&
            !NT_ERROR( irp->IoStatus.Status )) {

            //
            // Copy the information from the system buffer to the caller's
            // buffer.  This is done with an exception handler in case
            // the operation fails because the caller's address space
            // has gone away, or it's protection has been changed while
            // the service was executing.
            //
            try {
                RtlCopyMemory( irp->UserBuffer,
                               irp->AssociatedIrp.SystemBuffer,
                               irp->IoStatus.Information );
            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception occurred while attempting to copy the
                // system buffer contents to the caller's buffer.  Set
                // a new I/O completion status.
                //

                irp->IoStatus.Status = GetExceptionCode();
            }
        }

        //
        // Free the buffer if needed.
        //

        if (irp->Flags & IRP_DEALLOCATE_BUFFER) {
            IcaStackFreePool( irp->AssociatedIrp.SystemBuffer );
        }
    }

    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\dload\wtsapi32.c ===
#include "termsrvpch.h"
#pragma hdrstop

#include <wtsapi32.h>

//
//  Caution!  Many of these functions must perform a SetLastError() because
//  the callers will call GetLastError() and try to recover based on the
//  error code.  Even more interesting, Taskmgr will sometimes pass the
//  error code to FormatMessage and display it to the end user.  So
//  we can't use ERROR_PROC_NOT_FOUND = "The specified procedure could not be
//  found", because it is meaningless to the end user.
//
//  I have chosen to use ERROR_FUNCTION_NOT_CALLED = "Function could not be
//  executed".
//

static
BOOL
WINAPI
WTSDisconnectSession(
    IN HANDLE hServer,
    IN DWORD SessionId,
    IN BOOL bWait
    )
{
    // Taskmgr needs an error code here
    SetLastError(ERROR_FUNCTION_NOT_CALLED);
    return FALSE;
}

BOOL
WINAPI
WTSEnumerateSessionsW(
    IN HANDLE hServer,
    IN DWORD Reserved,
    IN DWORD Version,
    OUT PWTS_SESSION_INFOW * ppSessionInfo,
    OUT DWORD * pCount
    )
{
    //  Windows Update needs an error code here
    SetLastError(ERROR_FUNCTION_NOT_CALLED);
    return FALSE;
}

VOID
WINAPI
WTSFreeMemory(
    IN PVOID pMemory
)
{
    // May as well just implement it directly since we're in kernel32 already.
    // Though theoretically nobody should call us since the only time you
    // WTSFreeMemory is after a successful WTSQuerySessionInformation.
    LocalFree( pMemory );
}

BOOL
WINAPI
WTSLogoffSession(
    IN HANDLE hServer,
    IN DWORD SessionId,
    IN BOOL bWait
    )
{
    // Taskmgr needs an error code here
    SetLastError(ERROR_FUNCTION_NOT_CALLED);
    return FALSE;
}

BOOL
WINAPI
WTSQuerySessionInformationW(
    IN HANDLE hServer,
    IN DWORD SessionId,
    IN WTS_INFO_CLASS WTSInfoClass,
    OUT LPWSTR * ppBuffer,
    OUT DWORD * pBytesReturned
    )
{
    // SessMgr.exe needs an error code here
    SetLastError(ERROR_FUNCTION_NOT_CALLED);
    return FALSE;
}

BOOL
WINAPI
WTSSendMessageW(
    IN HANDLE hServer,
    IN DWORD SessionId,
    IN LPWSTR pTitle,
    IN DWORD TitleLength,
    IN LPWSTR pMessage,
    IN DWORD MessageLength,
    IN DWORD Style,
    IN DWORD Timeout,
    OUT DWORD * pResponse,
    IN BOOL bWait
    )
{
    // Taskmgr needs an error code here
    SetLastError(ERROR_FUNCTION_NOT_CALLED);
    return FALSE;
}

//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(wtsapi32)
{
    DLPENTRY(WTSDisconnectSession)
    DLPENTRY(WTSEnumerateSessionsW)
    DLPENTRY(WTSFreeMemory)
    DLPENTRY(WTSLogoffSession)
    DLPENTRY(WTSQuerySessionInformationW)
    DLPENTRY(WTSSendMessageW)
};

DEFINE_PROCNAME_MAP(wtsapi32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\td\common\ntdd.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

   ntdd.c

Abstract:

    This module contains support for standard NT driver initialization.

    This module is intended to be included in each WD/TD/PD on a Hydra
    system.

Author:

Revision History:

--*/

/*
 *  Includes
 */
#include <ntddk.h>
#include <ntddvdeo.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <ntddbeep.h>

#include <winstaw.h>
#include <icadd.h>
#include <sdapi.h>
#include <td.h>

#define DEVICE_NAME_PREFIX L"\\Device\\"

//
// Global data
//
PDEVICE_OBJECT DrvDeviceObject;

//
// External references
//

// This is the name of the WD/TD/PD module we are initializing as.
extern PWCHAR ModuleName;

// This is the stack driver module entry point defined in ntos\citrix\inc\sdapi.h
NTSTATUS
_stdcall
ModuleEntry(
    IN OUT PSDCONTEXT pSdContext,
    IN BOOLEAN bLoad
    );

//
// Forward refrences
//
VOID DrvUnload( PDRIVER_OBJECT );

NTSTATUS
DrvDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Standard NT driver entry routine.

Arguments:

    DriverObject - NT passed driver object
    RegistryPath - Path to driver specific registry entry

Return Value:

    NTSTATUS code.

Environment:

    Kernel mode, DDK
--*/

{
    ULONG i;
    NTSTATUS Status;
    UNICODE_STRING DeviceName;
    PWCHAR NameBuffer;
    ULONG  NameSize;

    PAGED_CODE( );

    NameSize = sizeof(DEVICE_NAME_PREFIX) + sizeof(WCHAR);
    NameSize += (wcslen(ModuleName) * sizeof(WCHAR));

    NameBuffer = IcaStackAllocatePool( NonPagedPool, NameSize );
    if( NameBuffer == NULL ) {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    wcscpy( NameBuffer, DEVICE_NAME_PREFIX );
    wcscat( NameBuffer, ModuleName );

    RtlInitUnicodeString( &DeviceName, NameBuffer );


    Status = IoCreateDevice(
                 DriverObject,
                 0,       // No DeviceExtension
                 &DeviceName,
                 FILE_DEVICE_TERMSRV,
                 0,
                 FALSE,
                 &DrvDeviceObject
                 );

    if( !NT_SUCCESS(Status) ) {
#if DBG
        DbgPrint("TD DriverEntry: Could not create Device %wZ, Status 0x%x\n",&DeviceName,Status);
        DbgBreakPoint();
#endif
        IcaStackFreePool( NameBuffer );
        return( Status );
    }

    DriverObject->DriverUnload = DrvUnload;
    DriverObject->FastIoDispatch = NULL;

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = DrvDispatch;
    }

    DrvDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    IcaStackFreePool( NameBuffer );

    return( Status );
}

VOID
DrvUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    Driver unload routine.

Arguments:

    DriverObject - Driver object being unloaded.

Return Value:

    None.

Environment:

    Kernel mode, DDK
--*/

{
    PAGED_CODE( );

    IoDeleteDevice( DrvDeviceObject );

    return;
}

NTSTATUS
DrvDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for the driver.

Arguments:

    DeviceObject - Pointer to device object for target device

    Irp - Pointer to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

Environment:

    Kernel mode, DDK
--*/

{
    PIO_STACK_LOCATION irpSp;
    KIRQL saveIrql;
    NTSTATUS Status;
    PSD_MODULE_INIT pmi;

    DeviceObject;   // prevent compiler warnings

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    switch ( irpSp->MajorFunction ) {

        case IRP_MJ_CREATE:

            if( Irp->RequestorMode != KernelMode ) {
                Status = STATUS_ACCESS_DENIED;
                Irp->IoStatus.Status = Status;
                IoCompleteRequest( Irp, 0 );
                return( Status );
            }

            Status = STATUS_SUCCESS;

            Irp->IoStatus.Status = Status;
            IoCompleteRequest( Irp, 0 );

            return Status;

        case IRP_MJ_INTERNAL_DEVICE_CONTROL:

            if( Irp->RequestorMode != KernelMode ) {
                Status = STATUS_NOT_IMPLEMENTED;
                Irp->IoStatus.Status = Status;
                IoCompleteRequest( Irp, 0 );
                return( Status );
            }

            if( irpSp->Parameters.DeviceIoControl.IoControlCode !=
                    IOCTL_SD_MODULE_INIT ) {
                Status = STATUS_NOT_IMPLEMENTED;
                Irp->IoStatus.Status = Status;
                IoCompleteRequest( Irp, 0 );
                return( Status );
            }

            if( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                    sizeof(SD_MODULE_INIT) ) {
                Status = STATUS_BUFFER_TOO_SMALL;
                Irp->IoStatus.Status = Status;
                IoCompleteRequest( Irp, 0 );
                return( Status );
            }

            // Return the SD module entry point.
            pmi = (PSD_MODULE_INIT)Irp->UserBuffer;
            pmi->SdLoadProc = ModuleEntry;

            Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = sizeof(SD_MODULE_INIT);
            Irp->IoStatus.Status = Status;
            IoCompleteRequest( Irp, 0 );

            return Status;

        case IRP_MJ_CLEANUP:

            Status = STATUS_SUCCESS;

            Irp->IoStatus.Status = Status;
            IoCompleteRequest( Irp, 0 );

            return Status;

        case IRP_MJ_CLOSE:

            Status = STATUS_SUCCESS;

            Irp->IoStatus.Status = Status;
            IoCompleteRequest( Irp, 0 );

            return Status;

        default:
            Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
            IoCompleteRequest( Irp, 0 );

            return STATUS_NOT_IMPLEMENTED;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\td\common\stack.c ===
/*************************************************************************
*
* stack.c
*
* ICA STACK IOCTLS
*
* Copyright Microsoft, 1998
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <ntddk.h>
#include <ntddvdeo.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <ntddbeep.h>

#include <winstaw.h>
#include <icadd.h>
#include <sdapi.h>
#include <td.h>



/*=============================================================================
==   External procedures defined
=============================================================================*/

NTSTATUS StackCreateEndpoint( PTD, PSD_IOCTL );
NTSTATUS StackCdCreateEndpoint( PTD, PSD_IOCTL );
NTSTATUS StackCallbackInitiate( PTD, PSD_IOCTL );
NTSTATUS StackCallbackComplete( PTD, PSD_IOCTL );
NTSTATUS StackOpenEndpoint( PTD, PSD_IOCTL );
NTSTATUS StackCloseEndpoint( PTD, PSD_IOCTL );
NTSTATUS StackConnectionWait( PTD, PSD_IOCTL );
NTSTATUS StackConnectionSend( PTD, PSD_IOCTL );
NTSTATUS StackConnectionRequest( PTD, PSD_IOCTL );
NTSTATUS StackQueryParams( PTD, PSD_IOCTL );
NTSTATUS StackSetParams( PTD, PSD_IOCTL );
NTSTATUS StackQueryLastError( PTD, PSD_IOCTL );
NTSTATUS StackWaitForStatus( PTD, PSD_IOCTL );
NTSTATUS StackCancelIo( PTD, PSD_IOCTL );
NTSTATUS StackQueryRemoteAddress( PTD, PSD_IOCTL );


/*=============================================================================
==   Internal procedures defined
=============================================================================*/

NTSTATUS _TdCreateInputThread( PTD );


/*=============================================================================
==   Procedures used
=============================================================================*/

NTSTATUS DeviceCreateEndpoint( PTD, PICA_STACK_ADDRESS, PICA_STACK_ADDRESS );
NTSTATUS DeviceOpenEndpoint( PTD, PVOID, ULONG );
NTSTATUS DeviceCloseEndpoint( PTD );
NTSTATUS DeviceConnectionWait( PTD, PVOID, ULONG, PULONG );
NTSTATUS DeviceConnectionSend( PTD );
NTSTATUS DeviceConnectionRequest( PTD, PICA_STACK_ADDRESS, PVOID, ULONG, PULONG );
NTSTATUS DeviceGetLastError( PTD, PICA_STACK_LAST_ERROR );
NTSTATUS DeviceWaitForStatus( PTD );
NTSTATUS DeviceCancelIo( PTD );
NTSTATUS DeviceSetParams( PTD );
NTSTATUS DeviceIoctl( PTD, PSD_IOCTL );
NTSTATUS DeviceQueryRemoteAddress( PTD, PVOID, ULONG, PVOID, ULONG, PULONG );

NTSTATUS TdInputThread( PTD );
NTSTATUS TdSyncWrite( PTD, PSD_SYNCWRITE );


/*******************************************************************************
 *
 *  StackCreateEndpoint                         IOCTL_ICA_STACK_CREATE_ENDPOINT
 *
 *  Create new transport endpoint
 *
 *  The endpoint structure contains everything necessary to preserve
 *  a client connection across a transport driver unload and reload.
 *
 *  This routine creates a new endpoint, using the optional local address.
 *  In the case of a network connection, the actual endpoint cannot be
 *  created until the client connection is established.  What this routine
 *  creates is an endpoint to listen on.  
 *
 *  DeviceConnectionWait and DeviceConnectionRequest return the endpoint.
 *
 *  NOTE: The endpoint structure is an opaque, variable length data 
 *        structure whose length and contents are determined by the 
 *        transport driver.
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - ICA_STACK_ADDRESS (or NULL)
 *       output - nothing
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
StackCreateEndpoint( PTD pTd, PSD_IOCTL pSdIoctl )
{
    PICA_STACK_ADDRESS pAddressIn;
    PICA_STACK_ADDRESS pAddressOut;
    NTSTATUS Status;

    if ( pSdIoctl->InputBufferLength < sizeof(ICA_STACK_ADDRESS) ) {

        /*
         *  No address specified 
         */
        pAddressIn = NULL;

    } else {

        /* 
         *  Get local address to use, if any
         */
        pAddressIn = pSdIoctl->InputBuffer;
    }

    if ( pSdIoctl->OutputBufferLength < sizeof(ICA_STACK_ADDRESS) ) {

        /*
         *  No address specified 
         */
        pAddressOut = NULL;

    } else {

        /* 
         *  Get local address to use, if any
         */
        pAddressOut = pSdIoctl->OutputBuffer;
    }

    /*
     *  Initialize transport driver endpoint
     */
    Status = DeviceCreateEndpoint( pTd, pAddressIn, pAddressOut );
    if ( !NT_SUCCESS(Status) ) 
        goto badcreate;

    TRACE(( pTd->pContext, TC_TD, TT_API1, "TD: StackCreateEndpoint: %x, success\n", pAddressIn ));
    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     *  endpoint create failed
     */
badcreate:
    TRACE(( pTd->pContext, TC_TD, TT_ERROR, "TD: StackCreateEndpoint: %x, Status=0x%x\n", pAddressIn, Status ));
    return( Status );

}


/*******************************************************************************
 *
 *  StackCdCreateEndpoint                    IOCTL_ICA_STACK_CD_CREATE_ENDPOINT
 *
 *  Create an endpoint based on a data provided by a connection driver.
 *
 *  NOTE: The endpoint structure is an opaque, variable length data 
 *        structure whose length and contents are determined by the 
 *        transport driver.
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - <endpoint data)
 *       output - <endpoint data>
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
StackCdCreateEndpoint( PTD pTd, PSD_IOCTL pSdIoctl )
{
    NTSTATUS Status;

    TRACE(( pTd->pContext, TC_TD, TT_API1,
            "TD: StackCdCreateEndpoint: entry\n" ));

    pTd->fClosing = FALSE;

    /*
     *  Initialize transport driver endpoint
     */
    Status = DeviceIoctl( pTd, pSdIoctl );
    if ( !NT_SUCCESS(Status) ) 
        goto badopen;

    TRACE(( pTd->pContext, TC_TD, TT_API1,
            "TD: StackCdCreateEndpoint: success\n" ));

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     *  endpoint open failed
     */
badopen:
    TRACE(( pTd->pContext, TC_TD, TT_ERROR,
            "TD: StackCdCreateEndpoint: Status=0x%x\n",
            Status ));
    return( Status );
}


/*******************************************************************************
 *
 *  StackCallbackInitiate                     IOCTL_ICA_STACK_CALLBACK_INITIATE
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - ICA_STACK_CALLBACK
 *       output - nothing
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
StackCallbackInitiate( PTD pTd, PSD_IOCTL pSdIoctl )
{
    NTSTATUS Status;

    TRACE(( pTd->pContext, TC_TD, TT_API1,
            "TD: StackCallbackInitiate: entry\n" ));

    pTd->fCallbackInProgress = TRUE;

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  StackCallbackComplete                     IOCTL_ICA_STACK_CALLBACK_COMPLETE
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - nothing
 *       output - nothing
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
StackCallbackComplete( PTD pTd, PSD_IOCTL pSdIoctl )
{
    NTSTATUS Status;

    TRACE(( pTd->pContext, TC_TD, TT_API1,
            "TD: StackCallbackComplete: entry\n" ));

    pTd->fCallbackInProgress = FALSE;

    /*
     *  Create the input thread if one is not running.
     */
    if ( pTd->pInputThread ) {
        Status = IcaWaitForSingleObject( pTd->pContext,
                                         pTd->pInputThread, 0 );
        if ( Status != STATUS_TIMEOUT) {    // if input thread not running
            /* 
             * The old input thread has gone away, but hasn't
             * been cleaned up.  Clean it up now.
             */
            ObDereferenceObject( pTd->pInputThread );
            pTd->pInputThread = NULL;
        }
    }
    if ( !pTd->pInputThread ) {
        Status = _TdCreateInputThread( pTd );
        if ( !NT_SUCCESS(Status) ) 
            goto badthreadcreate;
    }
    return( STATUS_SUCCESS );

badthreadcreate:
    return( Status );
}

/*******************************************************************************
 *
 *  StackOpenEndpoint                             IOCTL_ICA_STACK_OPEN_ENDPOINT
 *
 *  Open an existing transport endpoint
 *
 *  The endpoint structure contains everything necessary to preserve
 *  a client connection across a transport driver unload and reload.
 *
 *  This routine will bind to an existing endpoint which is passed as
 *  the input parameter.
 *  
 *  NOTE: The endpoint structure is an opaque, variable length data 
 *        structure whose length and contents are determined by the 
 *        transport driver.
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - <endpoint data>
 *       output - nothing
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
StackOpenEndpoint( PTD pTd, PSD_IOCTL pSdIoctl )
{
    NTSTATUS Status;

    /*
     *  Initialize transport driver endpoint
     */
    Status = DeviceOpenEndpoint( pTd, 
                                 pSdIoctl->InputBuffer,
                                 pSdIoctl->InputBufferLength );
    if ( !NT_SUCCESS(Status) ) 
        goto badopen;

    /*
     * Create the input thread now.
     */    
    Status = _TdCreateInputThread( pTd );
    if ( !NT_SUCCESS(Status) ) 
        goto badthreadcreate;
        
    TRACE(( pTd->pContext, TC_TD, TT_API1, "TD: StackOpenEndpoint, success\n" ));
    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     *  thread create failed - we used to close the endpoint, however TermSrv
     *  does not expect this and would do a double free.  Now we just rely on
     *  TermSrv to turn around and close the endpoint.
     */
badthreadcreate:
//  (void) DeviceCloseEndpoint( pTd );  

    /*
     *  endpoint open failed
     */
badopen:
    TRACE(( pTd->pContext, TC_TD, TT_ERROR, "TD: StackOpenEndpoint, Status=0x%x\n", Status ));
    return( Status );

}


/*******************************************************************************
 *
 *  StackCloseEndpoint                           IOCTL_ICA_STACK_CLOSE_ENDPOINT
 *
 *  Close transport endpoint
 *
 *  This will terminate any client connection
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - nothing
 *       output - nothing
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
StackCloseEndpoint( PTD pTd, PSD_IOCTL pSdIoctl )
{
    NTSTATUS Status;

    /*
     *  Close transport driver endpoint
     */
    Status = DeviceCloseEndpoint( pTd );  
    if ( !NT_SUCCESS(Status) ) 
        goto badclose;

    TRACE(( pTd->pContext, TC_TD, TT_API1, "TD: StackCloseEndpoint: success\n" ));
    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     *  endpoint close failed
     */
badclose:
    TRACE(( pTd->pContext, TC_TD, TT_ERROR, "TD: StackCloseEndpoint: 0x%x\n", Status ));
    return( Status );

}


/*******************************************************************************
 *
 *  StackConnectionWait                         IOCTL_ICA_STACK_CONNECTION_WAIT
 *
 *  Waits for a new client connection
 *
 *  After the transport driver is loaded and StackCreateEndpoint is called 
 *  this routine is called to wait for a new client connection.
 *
 *  If an endpoint does not yet exist, DeviceConnectionWait will create one
 *  when the client connects.
 *
 * Changed 02/18/97 JohnR:
 *
 *  This routine returns an opaque 32 bit handle to a data structure that
 *  is maintained by ICADD.SYS. This data structure allows the transport
 *  driver to maintain specific state information in a secure manner.
 *
 *  This state information is only known to the transport driver.
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - nothing
 *       output - <endpoint data>
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
StackConnectionWait( PTD pTd, PSD_IOCTL pSdIoctl )
{
    NTSTATUS Status;

    TRACE(( pTd->pContext, TC_TD, TT_API1, "TD: StackConnectionWait: enter\n" ));

    /*
     *  Initialize return byte count 
     *  - size of returned endpoint structure
     */
    pSdIoctl->BytesReturned = 0;

    /*
     *  Wait for physical connection
     *
     *  - DeviceConnectionWait should check OutputBufferLength to make
     *    sure it's long enough to return an endpoint structure before
     *    blocking.
     */
    Status = DeviceConnectionWait( pTd, 
                                   pSdIoctl->OutputBuffer,
                                   pSdIoctl->OutputBufferLength,
                                   &pSdIoctl->BytesReturned );
    if ( !NT_SUCCESS(Status) ) 
        goto badwait;

    TRACE(( pTd->pContext, TC_TD, TT_API1, "TD: StackConnectionWait: success\n" ));
    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     *  thread create failed
     *  Wait failed
     */
badwait:
    TRACE(( pTd->pContext, TC_TD, TT_ERROR, "TD: StackConnectionWait: Status=0x%x\n", Status ));
    return( Status );
}


/*******************************************************************************
 *
 *  StackConnectionSend                         IOCTL_ICA_STACK_CONNECTION_SEND
 *
 *  Initialize transport driver module data to send to the client
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - nothing
 *       output - nothing
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
StackConnectionSend( PTD pTd, PSD_IOCTL pSdIoctl )  
{
    return( DeviceConnectionSend( pTd ) );
}


/*******************************************************************************
 *
 *  StackConnectionRequest                   IOCTL_ICA_STACK_CONNECTION_REQUEST
 *
 *  Initiate a connection to the specified remote address
 *
 *  - this routine is only used by shadow 
 *
 *  DeviceConnectionRequest will create a new endpoint after establishing
 *  a connection.
 *
 *  This routine returns the endpoint data structure.  The endpoint structure
 *  contains everything necessary to preserve a connection across a transport
 *  driver unload and reload.
 *
 *  NOTE: The endpoint structure is an opaque, variable length data 
 *        structure whose length and contents are determined by the 
 *        transport driver.
 *
 *
 *  typedef struct _ICA_STACK_ADDRESS {
 *      BYTE Address[MAX_BR_ADDRESS];   // bytes 0,1 family, 2-n address
 *  } ICA_STACK_ADDRESS, *PICA_STACK_ADDRESS;
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - ICA_STACK_ADDRESS (remote address)
 *       output - <endpoint data>
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
StackConnectionRequest( PTD pTd, PSD_IOCTL pSdIoctl ) 
{
    NTSTATUS Status;

    if ( pSdIoctl->InputBufferLength < sizeof(ICA_STACK_ADDRESS) ) {
        Status = STATUS_BUFFER_TOO_SMALL;
        goto badbuffer;
    }

    /*
     *  Establish physical connection
     *
     *  - DeviceConnectionRequest should check OutputBufferLength to make
     *    sure it is long enough to return an endpoint structure before
     *    making a connection.
     */
    Status = DeviceConnectionRequest( pTd, 
                                      pSdIoctl->InputBuffer,
                                      pSdIoctl->OutputBuffer,
                                      pSdIoctl->OutputBufferLength,
                                      &pSdIoctl->BytesReturned );
    if ( !NT_SUCCESS(Status) ) 
        goto badrequest;

    /*
     *  Create input thread
     */
    Status = _TdCreateInputThread( pTd );
    if ( !NT_SUCCESS(Status) ) 
        goto badthreadcreate;

    TRACE(( pTd->pContext, TC_TD, TT_API1, "TD: StackConnectionRequest: success\n" ));
    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     *  thread create failed
     *  connection request failed
     *  buffer too small
     */
badthreadcreate:
badrequest:
badbuffer:
    TRACE(( pTd->pContext, TC_TD, TT_ERROR, "TD: StackConnectionRequest: Status=0x%x\n", Status ));
    return( Status );
}


/*******************************************************************************
 *
 *  StackQueryParams                               IOCTL_ICA_STACK_QUERY_PARAMS
 *
 *  query transport driver parameters
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - SDCLASS
 *       output - PDPARAMS
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
StackQueryParams( PTD pTd, PSD_IOCTL pSdIoctl ) 
{
    PPDPARAMS pParams;

    if ( pSdIoctl->InputBufferLength < sizeof(SDCLASS) ||
         pSdIoctl->OutputBufferLength < sizeof(PDPARAMS) ) {
        return( STATUS_BUFFER_TOO_SMALL );
    }

    pParams = pSdIoctl->OutputBuffer;

    *pParams = pTd->Params;
    pSdIoctl->BytesReturned = sizeof(PDPARAMS);

    return( STATUS_SUCCESS );
}

/*******************************************************************************
 *
 *  StackQueryRemoteAddress                   IOCTL_TS_STACK_QUERY_REMOTEADDRESS
 *
 *  query for the remote address
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - endpoint data
 *       output - sockaddr
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/
NTSTATUS
StackQueryRemoteAddress( PTD pTd, PSD_IOCTL pSdIoctl )
{
    NTSTATUS Status;

    Status = DeviceQueryRemoteAddress( pTd,
                                       pSdIoctl->InputBuffer,
                                       pSdIoctl->InputBufferLength,
                                       pSdIoctl->OutputBuffer,
                                       pSdIoctl->OutputBufferLength,
                                       &pSdIoctl->BytesReturned );

    if ( !NT_SUCCESS(Status) )
    {
        TRACE(( pTd->pContext, TC_TD, TT_ERROR, "TD: StackQueryRemoteAddress: 0x%\n", Status ));
    }

    return Status;
}

/*******************************************************************************
 *
 *  StackSetParams                                   IOCTL_ICA_STACK_SET_PARAMS
 *
 *  set transport driver parameters
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - PDPARAMS
 *       output - nothing
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
StackSetParams( PTD pTd, PSD_IOCTL pSdIoctl )  
{
    PPDPARAMS pParams;

    if ( pSdIoctl->InputBufferLength < sizeof(PDPARAMS) ) {
        return( STATUS_BUFFER_TOO_SMALL );
    }

    pParams = pSdIoctl->InputBuffer;

    pTd->Params = *pParams;

    return( DeviceSetParams( pTd ) );
}


/*******************************************************************************
 *
 *  StackQueryLastError                        IOCTL_ICA_STACK_QUERY_LAST_ERROR
 *
 *  Query transport driver error code and message
 *
 *  typedef struct _ICA_STACK_LAST_ERROR {
 *      ULONG Error;
 *      CHAR Message[ MAX_ERRORMESSAGE ];
 *  } ICA_STACK_LAST_ERROR, *PICA_STACK_LAST_ERROR;
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - nothing
 *       output - ICA_STACK_LAST_ERROR
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
StackQueryLastError( PTD pTd, PSD_IOCTL pSdIoctl ) 
{
    if ( pSdIoctl->OutputBufferLength < sizeof(ICA_STACK_LAST_ERROR) ) {
        return( STATUS_BUFFER_TOO_SMALL );
    }

    pSdIoctl->BytesReturned = sizeof(ICA_STACK_LAST_ERROR);

    return( DeviceGetLastError( pTd, pSdIoctl->OutputBuffer ) );
}


/*******************************************************************************
 *
 *  StackWaitForStatus                          IOCTL_ICA_STACK_WAIT_FOR_STATUS
 *
 *  Wait for transport driver status to change
 *  - only supported by async transport driver to wait for rs232 signal change
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - nothing
 *       output - nothing
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
StackWaitForStatus( PTD pTd, PSD_IOCTL pSdIoctl )
{
    /*
     *  Check if driver is being closed
     */
    if ( pTd->fClosing ) 
        return( STATUS_CTX_CLOSE_PENDING );

    return( DeviceWaitForStatus( pTd ) );
}


/*******************************************************************************
 *
 *  StackCancelIo                                    IOCTL_ICA_STACK_CANCEL_IO
 *
 *  cancel all current and future transport driver i/o
 *
 *  NOTE: no more i/o can be done after StackCancelIo is called.
 *        The transport driver must be unloaded and reloaded to
 *        re-enable i/o.
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - nothing
 *       output - nothing
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
StackCancelIo( PTD pTd, PSD_IOCTL pSdIoctl )
{
    PLIST_ENTRY Head, Next;
    NTSTATUS Status;

    TRACE(( pTd->pContext, TC_TD, TT_API1, "TD: StackCancelIo (enter)\n" ));

    /*
     *  Set stack closing flag
     */
    pTd->fClosing = TRUE;

    /*
     *  Clear error thresholds now
     */
    pTd->ReadErrorThreshold = 0;
    pTd->WriteErrorThreshold = 0;

    /*
     * Call device specific cancel I/O routine
     */
    Status = DeviceCancelIo( pTd );
    ASSERT( Status == STATUS_SUCCESS );

    /*
     * Wait for all writes to complete
     */
    Status = TdSyncWrite( pTd, NULL );
    ASSERT( Status == STATUS_SUCCESS );

    TRACE(( pTd->pContext, TC_TD, TT_API1, "TD: StackCancelIo, %u (exit)\n", Status ));

    return( Status );
}

/*******************************************************************************
 *
 *  StackSetBrokenReason                       IOCTL_ICA_STACK_SET_BROKENREASON
 *
 *  Store a broken reason for later use (when reporting back up the stack)
 *
 *  NOTE: Does not break the connection
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       input  - ICA_STACK_BROKENREASON
 *       output - nothing
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/
NTSTATUS
StackSetBrokenReason( PTD pTd, PSD_IOCTL pSdIoctl )
{
    PICA_STACK_BROKENREASON pBrkReason;

    TRACE(( pTd->pContext, TC_TD, TT_API1,
            "TD: StackSetBrokenReason (enter)\n" ));

    if ( pSdIoctl->InputBufferLength < sizeof(ICA_STACK_BROKENREASON) ) {
        return( STATUS_BUFFER_TOO_SMALL );
    }

    pBrkReason = pSdIoctl->InputBuffer;
    pTd->UserBrokenReason = pBrkReason->BrokenReason;

    TRACE(( pTd->pContext, TC_TD, TT_API1,
            "TD: StackSetBrokenReason, %u (exit)\n", STATUS_SUCCESS ));
    return STATUS_SUCCESS;
}

/*******************************************************************************
 *
 *  _TdCreateInputThread
 *
 *  Start the input thread running.
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_TdCreateInputThread( PTD pTd )
{
    HANDLE hInputThread;
    NTSTATUS Status;

    /*
     *  Create input thread
     */
    Status = IcaCreateThread( pTd->pContext,
                              TdInputThread,
                              pTd,
                              ICALOCK_DRIVER,
                              &hInputThread );
    if ( !NT_SUCCESS(Status) ) 
        return( Status );

    /*
     * Convert thread handle to pointer reference
     */
    Status = ObReferenceObjectByHandle( hInputThread,
                                        THREAD_ALL_ACCESS,
                                        NULL,
                                        KernelMode,
                                        &pTd->pInputThread,
                                        NULL );
    (VOID) ZwClose( hInputThread );
    if ( !NT_SUCCESS( Status ) ) {
        (VOID) StackCancelIo( pTd, NULL );
    }

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\td\inc\td.h ===
/***************************************************************************
*
*  TD.H
*
*  This module contains Transport Driver defines and structures 
*
*  Copyright Microsoft, 1998
*
*  
****************************************************************************/

/*
 *  Maximum number of zero byte reads before we will drop the client connection
 */
#define MAXIMUM_ZERO_BYTE_READS 100

/*
 *  TD error message structure
 */
typedef struct _TDERRORMESSAGE {
    ULONG Error;
    char * pMessage;
} TDERRORMESSAGE, * PTDERRORMESSAGE;

/*
 *  TD structure
 */
typedef struct _TD {

    PSDCONTEXT pContext;      

    ULONG PdFlag;               // pd flags (PD_?)
    SDCLASS SdClass;            // class of sd (PdAsync, PdReli, ...)
    PDPARAMS Params;            // pd parameters
    PCLIENTMODULES pClient;     // pointer to winstation client data structure
    PPROTOCOLSTATUS pStatus;    // pointer to winstation status structure

    PFILE_OBJECT pFileObject;   // file object for transport I/O
    PDEVICE_OBJECT pDeviceObject; // device object for transport I/O

    ULONG LastError;            // error code of last protocol error
    ULONG ReadErrorCount;       // count of consecutive read errors
    ULONG ReadErrorThreshold;   // max allowed consecutive read errors
    ULONG WriteErrorCount;      // count of consecutive write errors
    ULONG WriteErrorThreshold;  // max allowed consecutive write errors
    ULONG ZeroByteReadCount;    // count of consecutive zero byte reads

    ULONG PortNumber;           // network listen port number 

    ULONG OutBufHeader;         // number of reserved header bytes for this td
    ULONG OutBufTrailer;        // number of reserved trailer bytes for this td
    ULONG OutBufLength;         // length of input/output buffers

    LIST_ENTRY IoBusyOutBuf;    // pointer to i/o busy outbufs
    KEVENT SyncWriteEvent;      // event waited on by SyncWrite

    PKTHREAD pInputThread;      // input thread pointer
    LONG InBufCount;            // count of INBUFs to allocate
    KSPIN_LOCK InBufListLock;   // spinlock to protect INBUF Busy/Done lists
    LIST_ENTRY InBufBusyHead;   // list of busy INBUFs (waiting for input)
    LIST_ENTRY InBufDoneHead;   // list of completed INBUFs (with input data)
    ULONG InBufHeader;          // number of reserved header bytes for this td
    KEVENT InputEvent;          // input event

    ULONG fClosing: 1;          // stack driver is closing
    ULONG fCallbackInProgress: 1; // modem callback in progress
    ULONG fSyncWriteWaiter: 1;  // there is a waiter in SyncWrite

    PVOID pPrivate;             // pointer to private pd data 
    PVOID pAfd;                 // pointer to private afd data 
    LIST_ENTRY WorkItemHead;    // preallocated workitem list.

    PDEVICE_OBJECT pSelfDeviceObject;// device object for this driver

    ULONG UserBrokenReason;     // broken reason sent down from the user

} TD, * PTD;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\td\tdasync\tdasync.h ===
/***************************************************************************
*
*  TDASYNC.H
*
*  This module contains private TDASYNC defines and structures 
*
* Copyright 1998, Microsoft
*  
****************************************************************************/

//
// Miscellaneous defines... (original files noted)
//

#define EVENT_MODIFY_STATE      0x0002  // winnt.h
#define EVENT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3) // winnt.h
#define INFINITE 0xffffffff // winbase.w
#define WAIT_FAILED (ULONG)0xFFFFFFFF
#define WAIT_ABANDONED         ((STATUS_ABANDONED_WAIT_0 ) + 0 )
#define WAIT_ABANDONED_0       ((STATUS_ABANDONED_WAIT_0 ) + 0 )
#define WAIT_TIMEOUT                        STATUS_TIMEOUT
#define WAIT_IO_COMPLETION                  STATUS_USER_APC

/*
 *  Modem Status Flags  (Copied from \nt\public\sdk\inc\winbase.h)
 */
#define MS_CTS_ON           ((ULONG)0x0010)
#define MS_DSR_ON           ((ULONG)0x0020)
#define MS_RING_ON          ((ULONG)0x0040)
#define MS_RLSD_ON          ((ULONG)0x0080)

//
// Events  (Copied from \nt\public\sdk\inc\winbase.h)
//

#define EV_RXCHAR           0x0001  // Any Character received
#define EV_RXFLAG           0x0002  // Received certain character
#define EV_TXEMPTY          0x0004  // Transmitt Queue Empty
#define EV_CTS              0x0008  // CTS changed state
#define EV_DSR              0x0010  // DSR changed state
#define EV_RLSD             0x0020  // RLSD changed state
#define EV_BREAK            0x0040  // BREAK received
#define EV_ERR              0x0080  // Line status error occurred
#define EV_RING             0x0100  // Ring signal detected
#define EV_PERR             0x0200  // Printer error occured
#define EV_RX80FULL         0x0400  // Receive buffer is 80 percent full
#define EV_EVENT1           0x0800  // Provider specific event 1
#define EV_EVENT2           0x1000  // Provider specific event 2

//
// File Structures - _OVERLAPPED
//
// Used by ZwDeviceIoControlFile
//

typedef struct _TDIOSTATUS {
    ULONG   Internal;			// InternalHigh must follow immediately
    ULONG   InternalHigh;
    ULONG   Offset;			// OffsetHigh must follow immediately
    ULONG   OffsetHigh;
    HANDLE  hEvent;
    PKEVENT pEventObject;		// pointer to hEvent's object
} TDIOSTATUS, *PTDIOSTATUS;

/*
 *  Async endpoint structure
 */
typedef struct _TDASYNC_ENDPOINT {
    HANDLE hDevice;			// handle for input and output
    PFILE_OBJECT pFileObject;		// Pointer to hDevice's File Object
    PDEVICE_OBJECT pDeviceObject;	// Pointer to hDevice's Device Object
    PEPROCESS InitProcess;              // process which opened endpoint
    TDIOSTATUS SignalIoStatus;          // TD- or CD-created status event
} TDASYNC_ENDPOINT, * PTDASYNC_ENDPOINT;

/*
 *  ASYNC TD structure
 */
typedef struct _TDASYNC {
    TDASYNC_ENDPOINT Endpoint;

    HANDLE hStatusEvent;            // handle for status wait
    PKEVENT pStatusEventObject;     // points to hStatusEvent's object
    ULONG EventMask;                // input - RS-232 signal mask
    ULONG fCommEventIoctl : 1;      // Comm Event Ioctl Pending
    ULONG fCloseEndpoint : 1;       // if set, close endpoint on device close

} TDASYNC, * PTDASYNC;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\td\tdasync\zwprotos.h ===
/*
 * These prototypes were lifted from ntos\inc\ntsrv.h
 * 
 * They are here because ntsrv.h could not be included without
 * error in tdasync.c.
 *
 * If at a later date, ntsrv.h can be included without error,
 * this file and any references to it can be removed.  
 *
 * Copyright (C) 1997-1999 Microsoft Corp.
 */
#ifndef _ZWPROTOS_
#define _ZWPROTOS_

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN EVENT_TYPE EventType,
    IN BOOLEAN InitialState
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwDeviceIoControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwReadFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwWriteFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwClose(
    IN HANDLE Handle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwMakeTemporaryObject(
    IN HANDLE Handle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG TitleIndex,
    IN PUNICODE_STRING Class OPTIONAL,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteKey(
    IN HANDLE KeyHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateValueKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwFlushKey(
    IN HANDLE KeyHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryKey(
    IN HANDLE KeyHandle,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    OUT PVOID KeyInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryValueKey(
    IN HANDLE KeyHandle,
    OUT PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwSetValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN ULONG TitleIndex OPTIONAL,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSection(
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwMapViewOfSection(
    IN HANDLE SectionHandle,
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG ZeroBits,
    IN ULONG CommitSize,
    IN OUT PLARGE_INTEGER SectionOffset OPTIONAL,
    IN OUT PSIZE_T ViewSize,
    IN SECTION_INHERIT InheritDisposition,
    IN ULONG AllocationType,
    IN ULONG Protect
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwUnmapViewOfSection(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateSection (
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN PLARGE_INTEGER MaximumSize OPTIONAL,
    IN ULONG SectionPageProtection,
    IN ULONG AllocationAttributes,
    IN HANDLE FileHandle OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationThread(
    IN HANDLE ThreadHandle,
    IN THREADINFOCLASS ThreadInformationClass,
    IN PVOID ThreadInformation,
    IN ULONG ThreadInformationLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwAllocateVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG ZeroBits,
    IN OUT PULONG RegionSize,
    IN ULONG AllocationType,
    IN ULONG Protect
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwFreeVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PULONG RegionSize,
    IN ULONG FreeType
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwWaitForSingleObject(
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwSetEvent (
    IN HANDLE Handle,
    OUT PLONG PreviousState OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwDuplicateObject(
    IN HANDLE SourceProcessHandle,
    IN HANDLE SourceHandle,
    IN HANDLE TargetProcessHandle OPTIONAL,
    OUT PHANDLE TargetHandle OPTIONAL,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Options
    );

#endif // _ZWPROTOS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\td\common\tdapi.c ===
/****************************************************************************/
// tdapi.c
//
// Common code for all Transport Drivers
//
// Typical connection sequence:
//
//  TdLoad                load driver
//  TdOpen                open driver (parameters)
//  StackCreateEndpoint   create new endpoint
//  StackConnectionWait   establish client connection (endpoint)
//  TdClose               close driver (does not close endpoint)
//  TdUnload              unload driver
//
//  TdLoad                load driver
//  TdOpen                open driver
//  StackOpenEndpoint     bind to an existing endpoint
//  StackConnectionSend   initialize host module data sent to client
//
//  (connected session)
//
//  StackCloseEndpoint    disconnect client connection
//  TdClose               close driver
//  TdUnload              unload driver
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <ntddk.h>
#include <ntddvdeo.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <ntddbeep.h>

#include <winstaw.h>
#include <icadd.h>
#include <sdapi.h>
#include <td.h>

#define REG_GUID_TABLE  L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Terminal Server\\lanatable"

#define LANA_ID      L"LanaId"


/*=============================================================================
==   External Functions Defined
=============================================================================*/
NTSTATUS ModuleEntry( PSDCONTEXT, BOOLEAN );
NTSTATUS TdLoad( PSDCONTEXT );
NTSTATUS TdUnload( PSDCONTEXT );
NTSTATUS TdOpen( PTD, PSD_OPEN );
NTSTATUS TdClose( PTD, PSD_CLOSE );
NTSTATUS TdRawWrite( PTD, PSD_RAWWRITE );
NTSTATUS TdChannelWrite( PTD, PSD_CHANNELWRITE );
NTSTATUS TdSyncWrite( PTD, PSD_SYNCWRITE );
NTSTATUS TdIoctl( PTD, PSD_IOCTL );


/*=============================================================================
==   Internal Functions Defined
=============================================================================*/
NTSTATUS _TdInitializeWrite( PTD, POUTBUF );
NTSTATUS _TdWriteCompleteRoutine( PDEVICE_OBJECT, PIRP, PVOID );
VOID     _TdWriteCompleteWorker( PTD, PVOID );


/*=============================================================================
==   Functions used
=============================================================================*/
NTSTATUS DeviceOpen( PTD, PSD_OPEN );
NTSTATUS DeviceClose( PTD, PSD_CLOSE );
NTSTATUS DeviceInitializeWrite( PTD, POUTBUF );
NTSTATUS DeviceIoctl( PTD, PSD_IOCTL );

NTSTATUS StackCreateEndpoint( PTD, PSD_IOCTL );
NTSTATUS StackCdCreateEndpoint( PTD, PSD_IOCTL );
NTSTATUS StackCallbackInitiate( PTD, PSD_IOCTL );
NTSTATUS StackCallbackComplete( PTD, PSD_IOCTL );
NTSTATUS StackOpenEndpoint( PTD, PSD_IOCTL );
NTSTATUS StackCloseEndpoint( PTD, PSD_IOCTL );
NTSTATUS StackConnectionWait( PTD, PSD_IOCTL );
NTSTATUS StackConnectionSend( PTD, PSD_IOCTL );
NTSTATUS StackConnectionRequest( PTD, PSD_IOCTL );
NTSTATUS StackQueryParams( PTD, PSD_IOCTL );
NTSTATUS StackSetParams( PTD, PSD_IOCTL );
NTSTATUS StackQueryLastError( PTD, PSD_IOCTL );
NTSTATUS StackWaitForStatus( PTD, PSD_IOCTL );
NTSTATUS StackCancelIo( PTD, PSD_IOCTL );
NTSTATUS StackSetBrokenReason( PTD, PSD_IOCTL );
NTSTATUS StackQueryRemoteAddress( PTD, PSD_IOCTL );

VOID     OutBufFree( PTD, POUTBUF );
VOID     OutBufError( PTD, POUTBUF );
NTSTATUS MemoryAllocate( ULONG, PVOID * );
VOID     MemoryFree( PVOID );


/*=============================================================================
==   Static global data
=============================================================================*/

/*
 *  Transport driver procedures
 */
PSDPROCEDURE G_pTdProcedures[] =
{
    TdOpen,
    TdClose,
    TdRawWrite,
    TdChannelWrite,
    TdSyncWrite,
    TdIoctl,
};


/*******************************************************************************
 *  ModuleEntry
 *
 *  ICA driver entry point.
 *
 *    pContext (input/output)
 *       pointer to the SD context structure
 *    fLoad (input)
 *       TRUE - load driver
 *       FALSE - unload driver
 ******************************************************************************/
NTSTATUS ModuleEntry(PSDCONTEXT pContext, BOOLEAN fLoad)
{
    if (fLoad)
        return TdLoad(pContext);
    else
        return TdUnload(pContext);
}


/*******************************************************************************
 *  TdLoad
 *
 *    The ICA driver directly calls this routine immediately after loading
 *    this transport driver.
 *
 *    1) initialize procedure dispatch table
 *    2) allocate transport driver data structure
 ******************************************************************************/
NTSTATUS TdLoad(PSDCONTEXT pContext)
{
    NTSTATUS Status;
    PTD pTd;

    /*
     *  Initialize td procedures
     */
    pContext->pProcedures = G_pTdProcedures;

    /*
     *  Since this is the last stack driver there are no callup procedures
     */
    pContext->pCallup = NULL;

    /*
     *  Allocate TD data structure
     */
    Status = MemoryAllocate( sizeof(TD), &pTd );
    if (Status == STATUS_SUCCESS) {
        RtlZeroMemory(pTd, sizeof(TD));
        pTd->pContext = pContext;
        pContext->pContext = pTd;
    }
    else {
        TRACE((pContext, TC_TD, TT_ERROR, "TdLoad: Failed alloc TD\n"));
    }

    return Status;
}


/*******************************************************************************
 *  TdUnload
 *
 *    The ICA driver directly calls this routine immediately after closing
 *    this transport driver.
 *
 *    1) free all transport driver data structures
 ******************************************************************************/
NTSTATUS TdUnload(PSDCONTEXT pContext)
{
    PTD pTd;

    /*
     *  Get pointers to TD data structures
     */
    pTd = pContext->pContext;

    /*
     *  Free TD private data structures
     */
    if (pTd->pPrivate)
        MemoryFree(pTd->pPrivate);

    if (pTd->pAfd)
        MemoryFree(pTd->pAfd);

    /* 
     *  Free TD data structure
     */
    MemoryFree(pTd);

    /*
     *  Clear context structure
     */
    pContext->pContext = NULL;
    pContext->pProcedures = NULL;
    pContext->pCallup = NULL;

    return STATUS_SUCCESS;
}


/*******************************************************************************
 *  TdOpen
 *
 *    The ICA driver directly calls this routine immediately after loading
 *    this transport driver.
 *
 *    1) initialize transport driver parameters
 *    2) call device specfic open
 *    3) allocate data buffers
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure 
 *    pSdOpen (input/output)
 *       Points to the parameter structure SD_OPEN.
 ******************************************************************************/
NTSTATUS TdOpen(PTD pTd, PSD_OPEN pSdOpen)
{
    SD_CLOSE SdClose;
    NTSTATUS Status;

    /*
     *  Initialize TD data structure
     */
    InitializeListHead( &pTd->IoBusyOutBuf );
    pTd->InBufCount = 1;
    KeInitializeSpinLock( &pTd->InBufListLock );
    InitializeListHead( &pTd->InBufBusyHead );
    InitializeListHead( &pTd->InBufDoneHead );
    InitializeListHead( &pTd->WorkItemHead );
    pTd->pClient          = pSdOpen->pClient;
    pTd->pStatus          = pSdOpen->pStatus;
    pTd->PdFlag           = pSdOpen->PdConfig.Create.PdFlag;
    pTd->OutBufLength     = pSdOpen->PdConfig.Create.OutBufLength;
    pTd->PortNumber       = pSdOpen->PdConfig.Create.PortNumber;
    pTd->Params           = pSdOpen->PdConfig.Params;
    pTd->UserBrokenReason = TD_USER_BROKENREASON_UNEXPECTED;

    /*
     *  Open device
     */
    Status = DeviceOpen(pTd, pSdOpen);
    if (NT_SUCCESS(Status)) {
        /*
         *  Save size of header and trailer for td
         */
        pTd->OutBufHeader  = pSdOpen->SdOutBufHeader;
        pTd->OutBufTrailer = pSdOpen->SdOutBufTrailer;
        KeInitializeEvent(&pTd->SyncWriteEvent, NotificationEvent, FALSE);
        TRACE((pTd->pContext, TC_TD, TT_API1, "TdOpen: success\n"));
    }
    else {
        DeviceClose(pTd, &SdClose);
        TRACE((pTd->pContext, TC_TD, TT_ERROR, "TdOpen, Status=0x%x\n", Status));
    }

    return Status;
}


/*******************************************************************************
 *  TdClose
 *
 *    The ICA driver directly calls this routine immediately before unloading
 *    this transport driver.
 *
 *    NOTE: This does NOT terminate the client connection
 *
 *    1) cancel all i/o (returns all OUTBUFs)
 *    2) terminate read thread 
 *    3) free data buffers
 *    4) call device specific close
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pSdClose (input/output)
 *       Points to the parameter structure SD_CLOSE.
 ******************************************************************************/
NTSTATUS TdClose(PTD pTd, PSD_CLOSE pSdClose)
{
    NTSTATUS Status;

    TRACE((pTd->pContext, TC_TD, TT_API1, "TdClose: (enter)\n"));

    /*
     *  Cancel all pending i/o (read thread)
     */
    (VOID)StackCancelIo(pTd, NULL);

    /*
     *  Return size of header and trailer for pd
     */
    pSdClose->SdOutBufHeader  = pTd->OutBufHeader;
    pSdClose->SdOutBufTrailer = pTd->OutBufTrailer;

    /*
     *  All reads and writes should have previously been canceled
     */
    ASSERT( pTd->fClosing );
    ASSERT( IsListEmpty( &pTd->IoBusyOutBuf ) );

    /*
     *  Wait for input thread to exit
     */
    if (pTd->pInputThread) {
        Status = IcaWaitForSingleObject(pTd->pContext, pTd->pInputThread, 60000);

        if ( !NT_SUCCESS(Status) && (Status!=STATUS_CTX_CLOSE_PENDING) ) {
            DbgPrint("TdClose: wait for the input thread to exit failed: status=%x pTd=%p\n", Status, pTd);
            ASSERT( NT_SUCCESS(Status) || (Status==STATUS_CTX_CLOSE_PENDING) );
        }

        /*
         * Dereference input thread if it hasn't been already
         * (it may have been done in StackCallbackComplete while we waited).
         */
        if (pTd->pInputThread) {
            ObDereferenceObject(pTd->pInputThread);
            pTd->pInputThread = NULL;
        }
    }

    /*
     *  Close device
     */
    Status = DeviceClose(pTd, pSdClose);

    TRACE((pTd->pContext, TC_TD, TT_API1, "TdClose: Status=0x%x\n", Status));
    return Status;
}


/*******************************************************************************
 *  _TdInitializeWrite
 *
 *    Initialize the supplied OutBuf and corresponding IRP for writing.
 *
 *    pTd (input)
 *       Pointer to td data structure
 *    pOutBuf (input/output)
 *       Points to the OutBuf to be initialized for writing
 ******************************************************************************/
__inline NTSTATUS _TdInitializeWrite(PTD pTd, POUTBUF pOutBuf)
{
    PIRP irp = pOutBuf->pIrp;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS Status;

    /*
     *  Make sure endpoint is open
     */
    if (pTd->pDeviceObject != NULL) {
        // Set current thread for IoSetHardErrorOrVerifyDevice.
        irp->Tail.Overlay.Thread = PsGetCurrentThread();

        // Get a pointer to the stack location of the first driver which will be
        // invoked. This is where the function codes and the parameters are set.
        irpSp = IoGetNextIrpStackLocation(irp);

        // Set the major function code, file/device objects, and write
        // parameters.
        irpSp->FileObject = pTd->pFileObject;
        irpSp->DeviceObject = pTd->pDeviceObject;

        irp->Flags = 0;
        return STATUS_SUCCESS;
    }
    else {
        return STATUS_CTX_CLOSE_PENDING;
    }
}


/*******************************************************************************
 *  TdRawWrite
 *
 *    The up stream stack driver calls this routine when it has data
 *    to write to the transport.  This data has all the necessary
 *    headers and trailers already appended.  
 *
 *    The OUTBUF pointed to by this write request must always be
 *    returned to the up stream stack driver after the write completes
 *    successfully or unsuccessfully.
 *   
 *    1) call device specific write
 *    2) return OUTBUF after write completes (OutBufFree)
 *       return OUTBUF after an error (OutBufError)
 *
 *    pTd (input)
 *       Pointer to td data structure 
 *    pSdRawWrite (input)
 *       Points to the parameter structure SD_RAWWRITE
 ******************************************************************************/
NTSTATUS TdRawWrite(PTD pTd, PSD_RAWWRITE pSdRawWrite)
{
    POUTBUF pOutBuf;
    NTSTATUS Status;
    PLIST_ENTRY pWorkItem = NULL;
    KIRQL oldIrql;


    pOutBuf = pSdRawWrite->pOutBuf;
    ASSERT(pOutBuf);

    // Check if driver is being closed
    if (!pTd->fClosing) {
        // See if we have had too many consecutive write errors
        if (pTd->WriteErrorCount <= pTd->WriteErrorThreshold) {
            // Initialize the IRP contained in the outbuf.
            Status = _TdInitializeWrite(pTd, pOutBuf);
            if (NT_SUCCESS(Status)) {
                // Let the device level code complete the IRP initialization.
                Status = DeviceInitializeWrite(pTd, pOutBuf);
                if (NT_SUCCESS(Status)) {
                    // Update the MDL byte count to reflect the exact number
                    // of bytes to send.
                    pOutBuf->pMdl->ByteCount = pOutBuf->ByteCount;

                    // Save our TD structure pointer in the OUTBUF
                    // so the I/O completion routine can get it.
                    pOutBuf->pPrivate = pTd;

                    // Insert outbuf on busy list
                    InsertTailList(&pTd->IoBusyOutBuf, &pOutBuf->Links);

                    // Preallocate a completion workitem now and chain it to list of workitems.
                    Status = IcaAllocateWorkItem(&pWorkItem);
                    if (!NT_SUCCESS(Status)) {
                        //
                        //we inserted the outbuf into the list. In badwrite below,
                        //we reinitialize this entry and we free it (or return to the pool)
                        //so, we need to remove this outbuf entry from the list
                        //
                        TRACE((pTd->pContext, TC_TD, TT_OUT1,
                                "TdRawWrite : No memory to allocate WorkItem. Removing Outbuf from the list %04u, %p\n",
                                pOutBuf->ByteCount, pOutBuf));
                        RemoveEntryList( &pOutBuf->Links );
                        goto badwrite;
                    }
                    ExAcquireSpinLock( &pTd->InBufListLock, &oldIrql );
                    InsertTailList( &pTd->WorkItemHead, pWorkItem );
                    ExReleaseSpinLock( &pTd->InBufListLock, oldIrql );
    
                    // Register I/O completion routine
                    if ( pTd->pSelfDeviceObject == NULL ) {
                        IoSetCompletionRoutine(pOutBuf->pIrp,
                                _TdWriteCompleteRoutine, pOutBuf, TRUE, TRUE,
                                TRUE);
                    } else {
                        IoSetCompletionRoutineEx(pTd->pSelfDeviceObject,
                                pOutBuf->pIrp,
                                _TdWriteCompleteRoutine, pOutBuf, TRUE, TRUE,
                                TRUE);
                    }

                    // Call the device driver
                    // From this point on we must NOT free the outbuf.
                    // It will be free'd by the write complete routine.
                    Status = IoCallDriver(pTd->pDeviceObject, pOutBuf->pIrp);
                    if (NT_SUCCESS(Status)) {
                        // Update output counters
                        pTd->pStatus->Output.Bytes += pOutBuf->ByteCount;
                        pTd->pStatus->Output.Frames++;

                        TRACE((pTd->pContext, TC_TD, TT_OUT1,
                                "TdRawWrite %04u, %08x\n",
                                pOutBuf->ByteCount, pOutBuf));
                        TRACEBUF((pTd->pContext, TC_TD, TT_ORAW,
                                pOutBuf->pBuffer, pOutBuf->ByteCount));

                        Status = STATUS_SUCCESS;
                    }
                    else {
                        //
                        //for some reason, IoCallDriver failed (probably a out of memory?)
                        //in this case, we are leaking the WorkItem and Outbuf because 
                        //we may never a get a call into our completion routine?
                        //do we need to remove the workitem and outbuf from the list here and free it?
                        //
                        goto badcalldriver;
                    }
                }
                else {
                    goto badwrite;
                }
            }
            else {
                goto badwrite;
            }
        }
        else {
            OutBufError(pTd, pOutBuf);
            TRACE((pTd->pContext, TC_TD, TT_API2,
                    "TdRawWrite: WriteErrorThreshold exceeded\n"));
            Status = pTd->LastError;
        }
    }
    else {
        OutBufError(pTd, pOutBuf);
        TRACE((pTd->pContext, TC_TD, TT_API2, "TdRawWrite: closing\n"));
        Status = STATUS_CTX_CLOSE_PENDING;
    }

    return Status;

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     *  write completed with an error
     */
badwrite:
    InitializeListHead( &pOutBuf->Links );
    OutBufError(pTd, pOutBuf);

    /*
     * IoCallDriver returned an error
     * NOTE: We must NOT free the outbuf here.
     *       It will be free'd by the write complete routine.
     */
badcalldriver:
    TRACE(( pTd->pContext, TC_TD, TT_OUT1, "TdRawWrite, Status=0x%x\n", Status ));
    pTd->LastError = Status;
    pTd->WriteErrorCount++;
    pTd->pStatus->Output.TdErrors++;
    if (pTd->WriteErrorCount < pTd->WriteErrorThreshold)
        Status = STATUS_SUCCESS;
    return Status;
}


/*******************************************************************************
 *  TdChannelWrite - channel write
 *
 *    This routine should never be called
 *
 *    pTd (input)
 *       Pointer to td data structure 
 *    pSdChannelWrite (input)
 *       Points to the parameter structure SD_CHANNELWRITE
 ******************************************************************************/
NTSTATUS TdChannelWrite(PTD pTd, PSD_CHANNELWRITE pSdChannelWrite)
{
    return STATUS_INVALID_DEVICE_REQUEST;
}


/*******************************************************************************
 *  TdSyncWrite
 *
 *    This routine is called by the up stream stack driver to wait
 *    for all pending writes to complete.
 *
 *    1) wait for all writes to complete
 *    2) return all OUTBUFs
 *
 *    pTd (input)
 *       Pointer to td data structure 
 *    pSdFlush (input)
 *       Points to the parameter structure SD_FLUSH
 ******************************************************************************/
NTSTATUS TdSyncWrite(PTD pTd, PSD_SYNCWRITE pSdSyncWrite)
{
    NTSTATUS Status;

    TRACE(( pTd->pContext, TC_TD, TT_OUT1, "TdSyncWrite (enter)\n" ));

    /*
     *  Return if there are no writes pending
     */
    if (IsListEmpty(&pTd->IoBusyOutBuf))
        return STATUS_SUCCESS;

    /*
     * Reset sync event and indicate we are waiting
     */
    if (!pTd->fSyncWriteWaiter) {
        pTd->fSyncWriteWaiter = TRUE;
        KeResetEvent(&pTd->SyncWriteEvent);
    }

    /*
     * Wait for event to be triggered
     */
    Status = IcaWaitForSingleObject(pTd->pContext, &pTd->SyncWriteEvent, -1);
    if (Status == STATUS_CTX_CLOSE_PENDING)
        Status = STATUS_SUCCESS;

    TRACE((pTd->pContext, TC_TD, TT_OUT1, "TdSyncWrite (exit)\n"));
    return Status;
}


/*******************************************************************************
 *  TdIoctl
 *
 *    This routine is called by the up stream stack driver.  These
 *    ioctls are used to connect, disconnect, query parameters, and
 *    set parameters.
 *
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       Points to the parameter structure SD_IOCTL
 ******************************************************************************/
NTSTATUS TdIoctl(PTD pTd, PSD_IOCTL pSdIoctl)
{
    NTSTATUS Status;

    switch (pSdIoctl->IoControlCode) {
        case IOCTL_ICA_STACK_CREATE_ENDPOINT:
            Status = StackCreateEndpoint(pTd, pSdIoctl);
            break;

        case IOCTL_ICA_STACK_OPEN_ENDPOINT:
            Status = StackOpenEndpoint(pTd, pSdIoctl);
            break;

        case IOCTL_ICA_STACK_CLOSE_ENDPOINT:
            StackCancelIo(pTd, pSdIoctl);
            Status = StackCloseEndpoint(pTd, pSdIoctl);
            break;

        case IOCTL_ICA_STACK_CONNECTION_WAIT :
            Status = StackConnectionWait(pTd, pSdIoctl);
            break;

        case IOCTL_ICA_STACK_CONNECTION_SEND :
            Status = StackConnectionSend(pTd, pSdIoctl);
            break;

        case IOCTL_ICA_STACK_CONNECTION_REQUEST :
            Status = StackConnectionRequest(pTd, pSdIoctl);
            break;

        case IOCTL_ICA_STACK_QUERY_PARAMS :
            Status = StackQueryParams(pTd, pSdIoctl);
            break;

        case IOCTL_ICA_STACK_SET_PARAMS :
            Status = StackSetParams(pTd, pSdIoctl);
            break;

        case IOCTL_ICA_STACK_QUERY_LAST_ERROR :
            Status = StackQueryLastError(pTd, pSdIoctl);
            break;

        case IOCTL_ICA_STACK_WAIT_FOR_STATUS :
            Status = StackWaitForStatus(pTd, pSdIoctl);
            break;

        case IOCTL_ICA_STACK_CANCEL_IO :
            Status = StackCancelIo(pTd, pSdIoctl);
            break;

        case IOCTL_ICA_STACK_CD_CREATE_ENDPOINT :
            Status = StackCdCreateEndpoint(pTd, pSdIoctl);
            break;

        case IOCTL_ICA_STACK_CALLBACK_INITIATE :
            Status = StackCallbackInitiate(pTd, pSdIoctl);
            break;

        case IOCTL_ICA_STACK_CALLBACK_COMPLETE :
            Status = StackCallbackComplete(pTd, pSdIoctl);
            break;

        case IOCTL_TS_STACK_QUERY_REMOTEADDRESS:
            Status = StackQueryRemoteAddress( pTd, pSdIoctl);
            break;

        case IOCTL_ICA_STACK_QUERY_STATE :
        case IOCTL_ICA_STACK_SET_STATE :
        case IOCTL_ICA_STACK_ENABLE_DRIVER :
        case IOCTL_ICA_STACK_CONNECTION_QUERY :
            Status = STATUS_SUCCESS;
            break;

        case IOCTL_ICA_STACK_SET_BROKENREASON:
            Status = StackSetBrokenReason(pTd, pSdIoctl);
            break;

        default:
            Status = DeviceIoctl(pTd, pSdIoctl);
            break;
    }

    TRACE((pTd->pContext, TC_TD, TT_API1, "TdIoctl(0x%08x): Status=0x%08x\n",
            pSdIoctl->IoControlCode, Status));

    return Status;
}


/*******************************************************************************
 *  _TdWriteCompleteRoutine
 *
 *    This routine is called at DPC level by the lower level device
 *    driver when an IRP corresponding to an outbuf is completed.
 *
 *    DeviceObject (input)
 *       not used
 *    pIrp (input)
 *       pointer to IRP that is complete
 *    Context (input)
 *       Context pointer setup when IRP was initialized.
 *       This is a pointer to the corresponding outbuf.
 ******************************************************************************/
NTSTATUS _TdWriteCompleteRoutine(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp,
        IN PVOID Context)
{
    POUTBUF pOutBuf = (POUTBUF)Context;
    PTD pTd = (PTD)pOutBuf->pPrivate;
    PLIST_ENTRY pWorkItem;
    KIRQL oldIrql;

    // To prevent the OutBuf associated IRP from being canceled by
    // DeviceCancelIo between queuing the PASSIVE_LEVEL work item below
    // and the actual processing, set the completed flag.
    pOutBuf->fIrpCompleted = TRUE;

    /*
     * Unqueue one of the pre-allocated workitems and use it
     * to queue the completion worker.
     */

    ExAcquireSpinLock( &pTd->InBufListLock, &oldIrql );
    ASSERT(!IsListEmpty(&pTd->WorkItemHead));
    pWorkItem = pTd->WorkItemHead.Flink;
    RemoveEntryList(pWorkItem);
    ExReleaseSpinLock( &pTd->InBufListLock, oldIrql );

    /*
     * Queue the outbuf completion processing to a worker thread
     * since we are not in the correct context to do it here.
     */
    IcaQueueWorkItemEx( pTd->pContext, _TdWriteCompleteWorker, Context,
                      ICALOCK_DRIVER, pWorkItem );

    /*
     * We return STATUS_MORE_PROCESS_REQUIRED so that no further
     * processing for this IRP is done by the I/O completion routine.
     */
    return STATUS_MORE_PROCESSING_REQUIRED;
}


/*******************************************************************************
 *  _TdWriteCompleteWorker
 *
 *    This routine is called by an ExWorker thread to complete processing
 *    on an outbuf.  We will release the outbuf and trigger the syncwrite
 *    event if anyone is waiting.
 *
 *    pTd (input)
 *       Pointer to td data structure
 *    Context (input)
 *       Context pointer setup when IRP was initialized.
 *       This is a pointer to the corresponding outbuf.
 ******************************************************************************/
void _TdWriteCompleteWorker(IN PTD pTd, IN PVOID Context)
{
    POUTBUF pOutBuf = (POUTBUF)Context;
    PIRP pIrp = pOutBuf->pIrp;
    NTSTATUS Status;
    
    TRACE(( pTd->pContext, TC_TD, TT_API3, "_TdWriteCompleteWorker: %08x\n", pOutBuf ));

    /*
     * Unlink outbuf from busy list
     */
    RemoveEntryList( &pOutBuf->Links );
    InitializeListHead( &pOutBuf->Links );

    //
    // Check to see whether any pages need to be unlocked.
    //
    if (pIrp->MdlAddress != NULL) {
        PMDL mdl, thisMdl;

        // Unlock any pages that may be described by MDLs.
        mdl = pIrp->MdlAddress;
        while (mdl != NULL) {
            thisMdl = mdl;
            mdl = mdl->Next;
            if (thisMdl == pOutBuf->pMdl)
                continue;

            MmUnlockPages( thisMdl );
            IoFreeMdl( thisMdl );
        }
    }

    /*
     * Any MDL we set in DeviceInitializeWrite() is part of the OUTBUF.
     */
    pIrp->MdlAddress = NULL;

    // Check for IRP cancellation and success.
    if (!pIrp->Cancel && NT_SUCCESS(pIrp->IoStatus.Status)) {
        // Clear the consecutive error count and complete the outbuf by
        // calling OutBufFree.
        pTd->WriteErrorCount = 0;
        OutBufFree(pTd, pOutBuf);
    }
    else {
        // If IRP was cancelled or completed with a failure status,
        // then increment the error counts and call OutBufError.
        if (pIrp->Cancel)
            pTd->LastError = (ULONG)STATUS_CANCELLED;
        else
            pTd->LastError = pIrp->IoStatus.Status;
        pTd->WriteErrorCount++;
        pTd->pStatus->Output.TdErrors++;
        OutBufError(pTd, pOutBuf);
    }

    /*
     * If there is a waiter in TdSyncWrite and the outbuf busy list
     * is now empty, then satisfy the wait now.
     */
    if (pTd->fSyncWriteWaiter && IsListEmpty(&pTd->IoBusyOutBuf)) {
        pTd->fSyncWriteWaiter = FALSE;
        KeSetEvent(&pTd->SyncWriteEvent, 1, FALSE);
    }
}


NTSTATUS _OpenRegKey(PHANDLE HandlePtr, PWCHAR KeyName)
/*++
    Opens a Registry key and returns a handle to it.

Arguments:
    HandlePtr - The varible into which to write the opened handle.
    KeyName   - The name of the Registry key to open.
--*/
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING    UKeyName;

    PAGED_CODE();

    RtlInitUnicodeString(&UKeyName, KeyName);
    memset(&ObjectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));
    InitializeObjectAttributes(&ObjectAttributes, &UKeyName,
            OBJ_CASE_INSENSITIVE, NULL, NULL);
    return ZwOpenKey(HandlePtr, KEY_READ, &ObjectAttributes);
}


NTSTATUS _GetRegDWORDValue(HANDLE KeyHandle, PWCHAR ValueName, PULONG ValueData)
/*++
    Reads a REG_DWORD value from the registry into the supplied variable.

Arguments:
    KeyHandle  - Open handle to the parent key of the value to read.
    ValueName  - The name of the value to read.
    ValueData  - The variable into which to read the data.
--*/
{
    NTSTATUS                    status;
    ULONG                       resultLength;
    PKEY_VALUE_FULL_INFORMATION keyValueFullInformation;
#define WORK_BUFFER_SIZE 512
    UCHAR                       keybuf[WORK_BUFFER_SIZE];
    UNICODE_STRING              UValueName;

    RtlInitUnicodeString(&UValueName, ValueName);

    keyValueFullInformation = (PKEY_VALUE_FULL_INFORMATION)keybuf;
    RtlZeroMemory(keyValueFullInformation, sizeof(keyValueFullInformation));

    status = ZwQueryValueKey(KeyHandle,
                             &UValueName,
                             KeyValueFullInformation,
                             keyValueFullInformation,
                             WORK_BUFFER_SIZE,
                             &resultLength);
    if (NT_SUCCESS(status)) {
        if (keyValueFullInformation->Type != REG_DWORD) {
            status = STATUS_INVALID_PARAMETER_MIX;
        } else {
            *ValueData = *((ULONG UNALIGNED *)((PCHAR)keyValueFullInformation +
                             keyValueFullInformation->DataOffset));
        }
    }

    return status;
}


NTSTATUS _GetRegStringValue(
        HANDLE                         KeyHandle,
        PWCHAR                         ValueName,
        PKEY_VALUE_PARTIAL_INFORMATION *ValueData,
        PUSHORT                        ValueSize)
/*++
    Reads a REG_*_SZ string value from the Registry into the supplied
    key value buffer. If the buffer string buffer is not large enough,
    it is reallocated.

Arguments:
    KeyHandle  - Open handle to the parent key of the value to read.
    ValueName  - The name of the value to read.
    ValueData  - Destination for the read data.
    ValueSize  - Size of the ValueData buffer. Updated on output.
--*/
{
    NTSTATUS status;
    ULONG resultLength;
    UNICODE_STRING UValueName;

    PAGED_CODE();

    RtlInitUnicodeString(&UValueName, ValueName);

    status = ZwQueryValueKey(
                 KeyHandle,
                 &UValueName,
                 KeyValuePartialInformation,
                 *ValueData,
                 (ULONG) *ValueSize,
                 &resultLength);
    if (status == STATUS_BUFFER_OVERFLOW || status == STATUS_BUFFER_TOO_SMALL) {
        PVOID temp;

        // Free the old buffer and allocate a new one of the
        // appropriate size.
        ASSERT(resultLength > (ULONG) *ValueSize);

        if (resultLength <= 0xFFFF) {
            status = MemoryAllocate(resultLength, &temp);
            if (status != STATUS_SUCCESS)
                return status;

            if (*ValueData != NULL)
                MemoryFree(*ValueData);

            *ValueData = temp;
            *ValueSize = (USHORT) resultLength;

            status = ZwQueryValueKey(KeyHandle,
                                     &UValueName,
                                     KeyValuePartialInformation,
                                     *ValueData,
                                     *ValueSize,
                                     &resultLength);

            ASSERT((status != STATUS_BUFFER_OVERFLOW) &&
                    (status != STATUS_BUFFER_TOO_SMALL));
        }
        else {
            status = STATUS_BUFFER_TOO_SMALL;
        }
    }

    return status;
}


NTSTATUS _GetRegMultiSZValue(
        HANDLE           KeyHandle,
        PWCHAR           ValueName,
        PUNICODE_STRING  ValueData)

/*++
    Reads a REG_MULTI_SZ string value from the Registry into the supplied
    Unicode string. If the Unicode string buffer is not large enough,
    it is reallocated.

Arguments:
    KeyHandle  - Open handle to the parent key of the value to read.
    ValueName  - The name of the value to read.
    ValueData  - Destination Unicode string for the value data.
--*/

{
    NTSTATUS                       status;
    ULONG                          resultLength;
    PKEY_VALUE_PARTIAL_INFORMATION keyValuePartialInformation;
    UNICODE_STRING                 UValueName;

    PAGED_CODE();

    ValueData->Length = 0;

    status = _GetRegStringValue(
                 KeyHandle,
                 ValueName,
                 (PKEY_VALUE_PARTIAL_INFORMATION *) &(ValueData->Buffer),
                 &(ValueData->MaximumLength));

    if (NT_SUCCESS(status)) {
        keyValuePartialInformation =
                (PKEY_VALUE_PARTIAL_INFORMATION)ValueData->Buffer;
        if (keyValuePartialInformation->Type == REG_MULTI_SZ) {
            ValueData->Length = (USHORT)
                    keyValuePartialInformation->DataLength;
            RtlCopyMemory(
                    ValueData->Buffer,
                    &(keyValuePartialInformation->Data),
                    ValueData->Length);
        }
        else {
            status = STATUS_INVALID_PARAMETER_MIX;
        }
    }

    return status;
}


NTSTATUS _GetRegSZValue(
        HANDLE           KeyHandle,
        PWCHAR           ValueName,
        PUNICODE_STRING  ValueData,
        PULONG           ValueType)

/*++
    Reads a REG_SZ string value from the Registry into the supplied
    Unicode string. If the Unicode string buffer is not large enough,
    it is reallocated.

Arguments:
    KeyHandle  - Open handle to the parent key of the value to read.
    ValueName  - The name of the value to read.
    ValueData  - Destination Unicode string for the value data.
    ValueType  - On return, contains the Registry type of the value read.
--*/

{
    NTSTATUS                       status;
    ULONG                          resultLength;
    PKEY_VALUE_PARTIAL_INFORMATION keyValuePartialInformation;
    UNICODE_STRING                 UValueName;

    PAGED_CODE();

    ValueData->Length = 0;

    status = _GetRegStringValue(
            KeyHandle,
            ValueName,
            (PKEY_VALUE_PARTIAL_INFORMATION *) &(ValueData->Buffer),
            &(ValueData->MaximumLength));
    if (NT_SUCCESS(status)) {
        keyValuePartialInformation =
                (PKEY_VALUE_PARTIAL_INFORMATION)ValueData->Buffer;
        if ((keyValuePartialInformation->Type == REG_SZ) ||
                (keyValuePartialInformation->Type == REG_EXPAND_SZ)) {
            WCHAR *src;
            WCHAR *dst;
            ULONG dataLength;

            *ValueType = keyValuePartialInformation->Type;
            dataLength = keyValuePartialInformation->DataLength;

            ASSERT(dataLength <= ValueData->MaximumLength);

            dst = ValueData->Buffer;
            src = (PWCHAR) &(keyValuePartialInformation->Data);

            while (ValueData->Length <= dataLength) {
                if ((*dst++ = *src++) == UNICODE_NULL)
                    break;
                ValueData->Length += sizeof(WCHAR);
            }

            if (ValueData->Length < (ValueData->MaximumLength - 1)) {
                ValueData->Buffer[ValueData->Length / sizeof(WCHAR)] =
                        UNICODE_NULL;
            }
        }
        else {
            status = STATUS_INVALID_PARAMETER_MIX;
        }
    }

    return status;
}


PWCHAR _EnumRegMultiSz(
        IN PWCHAR   MszString,
        IN ULONG    MszStringLength,
        IN ULONG    StringIndex)
/*++
     Parses a REG_MULTI_SZ string and returns the specified substring.

 Arguments:
    MszString        - A pointer to the REG_MULTI_SZ string.
    MszStringLength  - The length of the REG_MULTI_SZ string, including the
                       terminating null character.
    StringIndex      - Index number of the substring to return. Specifiying
                       index 0 retrieves the first substring.

 Return Value:
    A pointer to the specified substring.

 Notes:
    This code is called at raised IRQL. It is not pageable.

--*/
{
    PWCHAR string = MszString;

    if (MszStringLength < (2 * sizeof(WCHAR)))
        return NULL;

    // Find the start of the desired string.
    while (StringIndex) {
        while (MszStringLength >= sizeof(WCHAR)) {
            MszStringLength -= sizeof(WCHAR);

            if (*string++ == UNICODE_NULL)
                break;
        }

        // Check for index out of range.
        if (MszStringLength < (2 * sizeof(UNICODE_NULL)))
            return NULL;

        StringIndex--;
    }

    if (MszStringLength < (2 * sizeof(UNICODE_NULL)))
        return NULL;

    return string;
}


VOID GetGUID(
        OUT PUNICODE_STRING szGuid,
        IN  int Lana)
/*++
    Enumerates through the guid table setup from TSConfig tool
    
Arguments:
    szGuid - This is an out param containing the guid in this format '{ ... }'
    Lana   - The id to confirm the one to one association

Return Value:
    VOID -- _TcpGetTransportAddress will fail if szGuid is invalid
--*/
{
    // open guidtable key
    HANDLE hKey;
    UNICODE_STRING TempString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS status;

    status = _OpenRegKey(&hKey, REG_GUID_TABLE);
    if (NT_SUCCESS(status)) {
        // enumerate this key
        ULONG ulByteRead = 0;
        ULONG Index = 0;
        ULONG ulLana = 0;
        HANDLE hSubKey;
        PKEY_BASIC_INFORMATION pKeyBasicInformation = NULL;
        BYTE buffer[ 512 ]; // work space

        pKeyBasicInformation = (PKEY_BASIC_INFORMATION)buffer;
        RtlZeroMemory(pKeyBasicInformation, sizeof(buffer));
        do {
            status = ZwEnumerateKey( 
                    hKey,
                    Index,
                    KeyBasicInformation,
                    (PVOID)pKeyBasicInformation,
                    sizeof(buffer),
                    &ulByteRead);
            KdPrint(("TDTCP: GetGUID ZwEnumerateKey returned 0x%x\n", status));

            if (status != STATUS_SUCCESS)
                break;

            // extract unicode name            
            TempString.Length = (USHORT) pKeyBasicInformation->NameLength;
            TempString.MaximumLength = (USHORT) pKeyBasicInformation->NameLength;
            TempString.Buffer = pKeyBasicInformation->Name;
            RtlZeroMemory( &ObjectAttributes , sizeof( OBJECT_ATTRIBUTES ) );
            InitializeObjectAttributes(
                    &ObjectAttributes,
                    &TempString,
                    OBJ_CASE_INSENSITIVE,
                    hKey,
                    NULL);
            
            status = ZwOpenKey(&hSubKey, KEY_READ, &ObjectAttributes);
            if (NT_SUCCESS(status)) {
                status = _GetRegDWORDValue(hSubKey, LANA_ID, &ulLana);
                ZwClose(hSubKey);
                if (NT_SUCCESS(status)) {
                    if (Lana == (int)ulLana) {
                        KdPrint(("TDTCP:GetGUID We've found a Lana %d\n", ulLana));

                        status = MemoryAllocate(TempString.Length +
                                sizeof(WCHAR), &szGuid->Buffer);
                        if (NT_SUCCESS(status)) {
                            szGuid->MaximumLength = TempString.Length +
                                    sizeof(WCHAR);
                            RtlZeroMemory(szGuid->Buffer, szGuid->MaximumLength);
                            RtlCopyUnicodeString(szGuid, &TempString);
                            break;
                        }
                    }
                }
            }

            Index++;            

        } while (TRUE);

        ZwClose(hKey);
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\td\tdicom\tdilib.c ===
/*************************************************************************
* tdlib.c
*
* TDI library functions.
*
* Copyright 1998 Microsoft
*************************************************************************/

/*
 *  Includes
 */
#include <ntddk.h>
#include <tdi.h>
#include <tdikrnl.h>

#include "tdtdi.h"

#include <winstaw.h>
#define _DEFCHARINFO_
#include <icadd.h>
#include <ctxdd.h>
#include <sdapi.h>

#include <td.h>


#define _TDI_POLL_TIMEOUT       (30 * 1000) // 30 seconds
#define _TDI_CONNECT_TIMEOUT    45
#define _TDI_DISCONNECT_TIMEOUT 60

#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif

/*
 * To use TDI:
 *
 * To connect to a remote server:
 *
 *    Create Address EndPoint
 *
 *    Create Connection Object
 *
 *    Associate the Address EndPoint with the Connection Object
 *
 *    Do a Connect
 *
 * To receive connections:
 *
 *    Create Address EndPoint
 *
 *    Create Connection Object
 *
 *    Associate the Address EndPoint with the Connection Object
 *
 *    Listen for a connection.
 *
 *    Return connection
 */



/*
 * Global data
 */

//
//  Wait for xx seconds before polling on thread deletion.
//

ULONG
_TdiPollTimeout = _TDI_POLL_TIMEOUT;

/*
 * Forward references
 */

PIRP
_TdiAllocateIrp(
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL
    );

NTSTATUS
_TdiRequestComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Ctx
    );

NTSTATUS
_TdiSetEventHandler (
    IN PTD pTd,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN ULONG EventType,
    IN PVOID EventHandler,
    IN PVOID EventContext
    );

NTSTATUS
_TdiSubmitRequest (
    IN PTD pTd,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN BOOLEAN bKeepLock
    );

/*
 * External references
 */
NTSTATUS MemoryAllocate( ULONG, PVOID * );
VOID     MemoryFree( PVOID );

BOOLEAN
PsIsThreadTerminating(
    IN PETHREAD Thread
    );


/*
 * Functions
 */

NTSTATUS
_TdiCreateAddress (
    IN PUNICODE_STRING pTransportName,
    IN PVOID           TdiAddress,
    IN ULONG           TdiAddressLength,
    OUT PHANDLE        pHandle,
    OUT PFILE_OBJECT   *ppFileObject,
    OUT PDEVICE_OBJECT *ppDeviceObject
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES AddressAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_FULL_EA_INFORMATION EABuffer;
    PDEVICE_OBJECT DeviceObject;
    HANDLE         TdiHandle  = NULL;
    PFILE_OBJECT   FileObject = NULL;

    /*
     * The TDI interfaces uses an EA of name "TdiTransportName"
     * to specify the structure TA_ADDRESS.
     */
    Status = MemoryAllocate( (sizeof(FILE_FULL_EA_INFORMATION)-1 +
                                    TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                                    TdiAddressLength), &EABuffer);

    if ( !NT_SUCCESS(Status) ) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    EABuffer->NextEntryOffset = 0;
    EABuffer->Flags = 0;
    EABuffer->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
    EABuffer->EaValueLength = (USHORT)TdiAddressLength;

    // Copy in the EA name
    RtlCopyMemory(EABuffer->EaName, TdiTransportAddress, EABuffer->EaNameLength+1);

    // Copy the TA_ADDRESS parameter
    RtlCopyMemory(&EABuffer->EaName[TDI_TRANSPORT_ADDRESS_LENGTH+1], TdiAddress,
                                    EABuffer->EaValueLength);

    TRACE0(("TdiCreateAddress Create endpoint of %wZ\n",pTransportName));

    InitializeObjectAttributes (
        &AddressAttributes,
        pTransportName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE ,
        NULL,           // RootDirectory
        NULL            // SecurityDescriptor
        );

    Status = ZwCreateFile(
                 &TdiHandle, // Handle
                 GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                 &AddressAttributes, // Object Attributes
                 &IoStatusBlock, // Final I/O status block
                 NULL,           // Allocation Size
                 FILE_ATTRIBUTE_NORMAL, // Normal attributes
                 0,             // Sharing attributes
                 FILE_OPEN_IF,  // Create disposition
                 0,             // CreateOptions
                 EABuffer,      // EA Buffer
                 FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName) +
                 TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                 TdiAddressLength // EA length
                 );

    MemoryFree(EABuffer);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("TdiCreateAddress: Error Status 0x%x from function\n",Status));
        return( Status );
    }

    if (!NT_SUCCESS(Status = IoStatusBlock.Status)) {
        DBGPRINT(("TdiCreateAddress: Error Status 0x%x from Iosb\n",Status));
        return( Status );
    }

    //
    //  Obtain a referenced pointer to the file object.
    //
    Status = ObReferenceObjectByHandle (
                                TdiHandle,
                                0,
                                *IoFileObjectType,
                                KernelMode,
                                (PVOID *)&FileObject,
                                NULL
                                );

    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("TdiCreateAddress: Error Status 0x%x Referencing FileObject\n",Status));
        goto error_cleanup;

    }


    //
    //  Get the address of the device object for the endpoint.
    //

    DeviceObject = IoGetRelatedDeviceObject(FileObject);

    // Copy the out parameters
    *pHandle = TdiHandle;
    *ppFileObject = FileObject;
    *ppDeviceObject = DeviceObject;

    return STATUS_SUCCESS;

error_cleanup:

    if ( FileObject != NULL ) {
        ObDereferenceObject( FileObject );
    }

    if ( TdiHandle != NULL ) {
        ZwClose( TdiHandle );
    }

    return Status;
}

NTSTATUS
_TdiOpenConnection (
    IN PUNICODE_STRING pTransportName,
    IN PVOID           ConnectionContext,
    OUT PHANDLE        pHandle,
    OUT PFILE_OBJECT   *ppFileObject,
    OUT PDEVICE_OBJECT *ppDeviceObject
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES AddressAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_FULL_EA_INFORMATION EABuffer;
    CONNECTION_CONTEXT UNALIGNED *ContextPointer;
    PDEVICE_OBJECT DeviceObject;
    HANDLE ConnHandle = NULL;
    PFILE_OBJECT FileObject = NULL;

    Status = MemoryAllocate( (sizeof(FILE_FULL_EA_INFORMATION)-1 +
                              TDI_CONNECTION_CONTEXT_LENGTH+1 +
                              sizeof(CONNECTION_CONTEXT)), &EABuffer);

    if( !NT_SUCCESS(Status) ) {
        return( Status );
    }

    EABuffer->NextEntryOffset = 0;
    EABuffer->Flags = 0;
    EABuffer->EaNameLength = TDI_CONNECTION_CONTEXT_LENGTH;
    EABuffer->EaValueLength = sizeof(CONNECTION_CONTEXT);

    // Copy in the EA name
    RtlCopyMemory(EABuffer->EaName, TdiConnectionContext, TDI_CONNECTION_CONTEXT_LENGTH+1);

    // Copy in the EA data
    ContextPointer =
        (CONNECTION_CONTEXT UNALIGNED *)&EABuffer->EaName[TDI_CONNECTION_CONTEXT_LENGTH+1];
    *ContextPointer = ConnectionContext;

    TRACE0(("_TdiOpenConnection: Create connection object on transport %wZ\n",pTransportName));

    InitializeObjectAttributes (&AddressAttributes,
                                    pTransportName, // Name
                                    OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE ,   // Attributes
                                    NULL,                   // RootDirectory
                                    NULL);                  // SecurityDescriptor

    Status = ZwCreateFile(&ConnHandle,               // Handle
                          GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                          &AddressAttributes, // Object Attributes
                          &IoStatusBlock, // Final I/O status block
                          NULL,           // Allocation Size
                          FILE_ATTRIBUTE_NORMAL, // Normal attributes
                          FILE_SHARE_READ | FILE_SHARE_WRITE, // Sharing attributes
                          FILE_OPEN_IF,   // Create disposition
                          0,              // CreateOptions
                          EABuffer,       // EA Buffer
                          sizeof(FILE_FULL_EA_INFORMATION) +
                            TDI_CONNECTION_CONTEXT_LENGTH + 1 +
                            sizeof(CONNECTION_CONTEXT));


    MemoryFree(EABuffer);

    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("_TdiOpenConnection: Error 0x%x Creating Connection object\n",Status));
        return(Status);
    }

    Status = IoStatusBlock.Status;
    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("_TdiOpenConnection: Error 0x%x Creating Connection object in Iosb\n",Status));
        return(Status);
    }

    TRACE0(("_TdiOpenConnection: Returning connection handle %lx\n", ConnHandle));


    //
    //  Obtain a referenced pointer to the file object.
    //
    Status = ObReferenceObjectByHandle (
                                ConnHandle,
                                0,
                                *IoFileObjectType,
                                KernelMode,
                                (PVOID *)&FileObject,
                                NULL
                                );

    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("_TdiOpenConnection: Error Status 0x%x Referencing FileObject\n",Status));
        ZwClose( ConnHandle );
        return(Status);
    }



    //
    //  Get the address of the device object for the endpoint.
    //

    DeviceObject = IoGetRelatedDeviceObject(FileObject);

    // Copy the out parameters
    *pHandle        = ConnHandle;
    *ppFileObject   = FileObject;
    *ppDeviceObject = DeviceObject;

    return(Status);
}

NTSTATUS
_TdiListen(
    IN PTD pTd,
    IN PIRP Irp OPTIONAL,
    IN PFILE_OBJECT   ConnectionFileObject,
    IN PDEVICE_OBJECT ConnectionDeviceObject
    )
{
    NTSTATUS Status;
    BOOLEAN  IrpAllocated = FALSE;
    TDI_CONNECTION_INFORMATION RequestInfo;
    TDI_CONNECTION_INFORMATION ReturnInfo;

    if (!ARGUMENT_PRESENT(Irp)) {

        Irp = _TdiAllocateIrp( ConnectionFileObject, ConnectionDeviceObject );
        if (Irp == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return Status;
        }

        IrpAllocated = TRUE;
    }

    RtlZeroMemory( &RequestInfo, sizeof(RequestInfo) );
    RtlZeroMemory( &ReturnInfo,  sizeof(ReturnInfo) );

    TdiBuildListen(
        Irp,
        ConnectionDeviceObject,
        ConnectionFileObject,
        NULL,        // Completion routine
        NULL,        // Context
        0,           // Flags
        &RequestInfo,
        &ReturnInfo
        );

    Status = _TdiSubmitRequest(pTd, ConnectionDeviceObject, Irp, FALSE);

    TRACE0(("_TdiListen: Status 0x%x\n",Status));

    if (IrpAllocated) {
        IoFreeIrp( Irp );
    }

    return(Status);
}

NTSTATUS
_TdiAccept(
    IN PTD pTd,
    IN PIRP Irp OPTIONAL,
    IN PFILE_OBJECT   ConnectionFileObject,
    IN PDEVICE_OBJECT ConnectionDeviceObject
    )
{
    NTSTATUS Status;
    BOOLEAN  IrpAllocated = FALSE;
    TDI_CONNECTION_INFORMATION RequestInfo;
    TDI_CONNECTION_INFORMATION ReturnInfo;

    if (!ARGUMENT_PRESENT(Irp)) {

        Irp = _TdiAllocateIrp( ConnectionFileObject, ConnectionDeviceObject );
        if (Irp == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return Status;
        }

        IrpAllocated = TRUE;
    }

    RtlZeroMemory( &RequestInfo, sizeof(RequestInfo) );
    RtlZeroMemory( &ReturnInfo,  sizeof(ReturnInfo) );

    TdiBuildAccept(
        Irp,
        ConnectionDeviceObject,
        ConnectionFileObject,
        NULL,        // Completion routine
        NULL,        // Context
        &RequestInfo,
        &ReturnInfo
        );

    Status = _TdiSubmitRequest(pTd, ConnectionDeviceObject, Irp, FALSE);

    if (IrpAllocated) {
        IoFreeIrp( Irp );
    }

    return(Status);
}


NTSTATUS
_TdiConnect(
    IN PTD pTd,
    IN PIRP Irp OPTIONAL,
    IN PLARGE_INTEGER pTimeout OPTIONAL,
    IN PFILE_OBJECT   ConnectionFileObject,
    IN PDEVICE_OBJECT ConnectionDeviceObject,
    IN ULONG              RemoteTransportAddressLength,
    IN PTRANSPORT_ADDRESS pRemoteTransportAddress
    )
{
    NTSTATUS Status;
    BOOLEAN  IrpAllocated = FALSE;
    TDI_CONNECTION_INFORMATION RequestInfo;
    TDI_CONNECTION_INFORMATION ReturnInfo;


    if (!ARGUMENT_PRESENT(Irp)) {

        Irp = _TdiAllocateIrp( ConnectionFileObject, ConnectionDeviceObject );
        if (Irp == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return Status;
        }

        IrpAllocated = TRUE;
    }

    RtlZeroMemory( &RequestInfo, sizeof(RequestInfo) );
    RtlZeroMemory( &ReturnInfo,  sizeof(ReturnInfo) );

    RequestInfo.RemoteAddressLength = RemoteTransportAddressLength;
    RequestInfo.RemoteAddress = pRemoteTransportAddress;


    TdiBuildConnect(
        Irp,
        ConnectionDeviceObject,
        ConnectionFileObject,
        NULL,        // Completion routine
        NULL,        // Context
        pTimeout,
        &RequestInfo,
        &ReturnInfo
        );

    Status = _TdiSubmitRequest(pTd, ConnectionDeviceObject, Irp, TRUE);

    if (IrpAllocated) {
        IoFreeIrp( Irp );
    }

    return(Status);
}


NTSTATUS
_TdiAssociateAddress(
    IN PTD pTd,
    IN PIRP Irp OPTIONAL,
    IN PFILE_OBJECT   ConnectionFileObject,
    IN HANDLE         AddressHandle,
    IN PDEVICE_OBJECT AddressDeviceObject
    )
{
    NTSTATUS Status;
    BOOLEAN  IrpAllocated = FALSE;

    if (!ARGUMENT_PRESENT(Irp)) {

        Irp = _TdiAllocateIrp( ConnectionFileObject, AddressDeviceObject );
        if (Irp == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return Status;
        }

        IrpAllocated = TRUE;
    }

    TdiBuildAssociateAddress(
        Irp,
        AddressDeviceObject,
        ConnectionFileObject,
        NULL,        // Completion routine
        NULL,        // Context
        AddressHandle
        );

    Status = _TdiSubmitRequest(pTd, AddressDeviceObject, Irp, FALSE);

    if (IrpAllocated) {
        IoFreeIrp( Irp );
    }

    return(Status);
}

NTSTATUS
_TdiDisconnect(
    IN PTD pTd,
    IN PFILE_OBJECT   ConnectionFileObject,
    IN PDEVICE_OBJECT ConnectionDeviceObject
    )
{
    PIRP Irp;
    NTSTATUS Status;
    BOOLEAN  IrpAllocated = FALSE;

    Irp = _TdiAllocateIrp( ConnectionFileObject, ConnectionDeviceObject );
    if (Irp == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        return Status;
    }

    TdiBuildDisconnect(
        Irp,
        ConnectionDeviceObject,
        ConnectionFileObject,
        NULL,        // Completion routine
        NULL,        // Context
        0,
        TDI_DISCONNECT_ABORT,
        NULL,
        NULL
        );

    Status = _TdiSubmitRequest(pTd, ConnectionDeviceObject, Irp, TRUE);

    IoFreeIrp( Irp );

    return(Status);
}

NTSTATUS
_TdiSetEventHandler (
    IN PTD pTd,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN ULONG EventType,
    IN PVOID EventHandler,
    IN PVOID EventContext
    )
/*++

Routine Description:

    This routine registers an event handler with a TDI transport provider.

Arguments:

    IN PDEVICE_OBJECT DeviceObject - Supplies the device object of the transport provider.
    IN PFILE_OBJECT FileObject - Supplies the address object's file object.
    IN ULONG EventType, - Supplies the type of event.
    IN PVOID EventHandler - Supplies the event handler.
    IN PVOID EventContext - Supplies the context for the event handler.

Return Value:

    NTSTATUS - Final status of the set event operation

--*/

{
    NTSTATUS Status;
    PIRP Irp;

    Irp = _TdiAllocateIrp( FileObject, NULL );

    if (Irp == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    TdiBuildSetEventHandler(Irp, DeviceObject, FileObject,
                            NULL, NULL,
                            EventType, EventHandler, EventContext);

    Status = _TdiSubmitRequest(pTd, DeviceObject, Irp, FALSE);

    IoFreeIrp( Irp );

    return Status;
}

NTSTATUS
_TdiSubmitRequest (
    IN PTD pTd,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN BOOLEAN bKeepLock
    )

/*++

Routine Description:

    This routine submits a request to TDI and waits for it to complete.

Arguments:

    IN PFILE_OBJECT FileObject - Connection or Address handle for TDI request
    IN PIRP Irp - TDI request to submit.

Return Value:

    NTSTATUS - Final status of request.

--*/

{
    NTSTATUS Status;
    PKEVENT  Event;

    Status = MemoryAllocate( sizeof(KEVENT), &Event );
    if( !NT_SUCCESS(Status) ) {
        return( Status );
    }

    KeInitializeEvent (Event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(Irp, _TdiRequestComplete, Event, TRUE, TRUE, TRUE);

    //
    //  Submit the request
    //

    Status = IoCallDriver(DeviceObject, Irp);

    //
    //  If it failed immediately, return now, otherwise wait.
    //

    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("_TdiSubmitRequest: submit request.  Status = %X", Status));
        MemoryFree( Event );
        return Status;
    }

    if (Status == STATUS_PENDING) {

        TRACE0(("TDI request issued, waiting..."));

        do {

            //
            //  Wait for a couple of seconds for the request to complete
            //
            //  If it times out, and the thread is terminating, cancel the
            //  request and unwind that way.
            //

            if ( !bKeepLock ) {
                Status = IcaWaitForSingleObject(
                             pTd->pContext,
                             Event,
                             _TdiPollTimeout
                             );
            } else {
                LARGE_INTEGER WaitTimeout;
                PLARGE_INTEGER pWaitTimeout = NULL;

                WaitTimeout = RtlEnlargedIntegerMultiply( _TdiPollTimeout, -10000 );
                pWaitTimeout = &WaitTimeout;
                
                Status = KeWaitForSingleObject(
                             Event,
                             UserRequest,
                             UserMode,
                             FALSE,
                             pWaitTimeout 
                             );
            }

            TRACE0(("_TdiSubmitRequest: Status 0x%x from IcaWaitForSingleObject\n",Status));

            //
            //  If we timed out the wait, and the thread is terminating,
            //  give up and cancel the IRP.
            //

            if ( (Status == STATUS_TIMEOUT)

                   &&

                 ARGUMENT_PRESENT(Irp)

                   &&

                 PsIsThreadTerminating( Irp->Tail.Overlay.Thread ) ) {

                //
                //  Ask the I/O system to cancel this IRP.  This will cause
                //  everything to unwind properly.
                //
                DBGPRINT(("_TdiSubmitRequest: Irp being canceled\n"));

                IoCancelIrp(Irp);
            }

        } while (  Status == STATUS_TIMEOUT );

        if (!NT_SUCCESS(Status)) {
            DBGPRINT(("Could not wait for connection to complete\n"));
            MemoryFree( Event );
            return Status;
        }

        Status = Irp->IoStatus.Status;
    }

    TRACE0(("TDI request complete Status 0x%x\n",Status));

    MemoryFree( Event );

    return(Status);
}

NTSTATUS
_TdiRequestComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Ctx
    )

/*++

Routine Description:

    Completion routine for _TdiRequestSubmit operation.

Arguments:

    IN PDEVICE_OBJECT DeviceObject, - Supplies a pointer to the device object
    IN PIRP Irp, - Supplies the IRP submitted
    IN PVOID Context - Supplies a pointer to the kernel event to release

Return Value:

    NTSTATUS - Status of KeSetEvent


    We return STATUS_MORE_PROCESSING_REQUIRED to prevent the IRP completion
    code from processing this puppy any more.

--*/

{
    UNREFERENCED_PARAMETER(Irp);
    UNREFERENCED_PARAMETER(DeviceObject);

    TRACE0(("_TdiRequestComplete: Context %lx\n", Ctx));

    //
    //  Set the event to the Signalled state with 0 priority increment and
    //  indicate that we will not be blocking soon.
    //

    KeSetEvent((PKEVENT) Ctx, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;

}

PIRP
_TdiAllocateIrp(
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL
    )
/*++

Routine Description:

    This function allocates and builds an I/O request packet.

Arguments:

    FileObject - Supplies a pointer to the file object for which this
        request is directed.  This pointer is copied into the IRP, so
        that the called driver can find its file-based context.  NOTE
        THAT THIS IS NOT A REFERENCED POINTER.  The caller must ensure
        that the file object is not deleted while the I/O operation is
        in progress.  The redir accomplishes this by incrementing a
        reference count in a local block to account for the I/O; the
        local block in turn references the file object.

    DeviceObject - Supplies a pointer to a device object to direct this
        request to.  If this is not supplied, it uses the file object to
        determine the device object.

Return Value:

    PIRP - Returns a pointer to the constructed IRP.

--*/

{
    PIRP Irp;

    if (ARGUMENT_PRESENT(DeviceObject)) {
        Irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);
    } else {
        Irp = IoAllocateIrp(IoGetRelatedDeviceObject(FileObject)->StackSize, FALSE);
    }

    if (Irp == NULL) {
        return(NULL);
    }

    Irp->Tail.Overlay.OriginalFileObject = FileObject;

    Irp->Tail.Overlay.Thread = PsGetCurrentThread();

    Irp->RequestorMode = KernelMode;

    return Irp;
}

NTSTATUS
_TdiReceiveDatagram(
    IN PTD pTd,
    IN PIRP Irp OPTIONAL,
    IN PFILE_OBJECT   FileObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PTRANSPORT_ADDRESS pRemoteAddress,
    IN ULONG RemoteAddressLength,
    IN ULONG RecvFlags,
    IN PVOID pBuffer,
    IN ULONG BufferLength,
    OUT PULONG pReturnLength
    )
{
    PMDL     pMdl;
    NTSTATUS Status;
    BOOLEAN  IrpAllocated = FALSE;
    TDI_CONNECTION_INFORMATION RequestInfo;
    TDI_CONNECTION_INFORMATION ReturnInfo;

    if (!ARGUMENT_PRESENT(Irp)) {

        Irp = _TdiAllocateIrp( FileObject, DeviceObject );
        if (Irp == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return Status;
        }

        IrpAllocated = TRUE;
    }

    RtlZeroMemory( &RequestInfo, sizeof(RequestInfo) );
    RtlZeroMemory( &ReturnInfo,  sizeof(ReturnInfo) );

    // Copy in info to return remote address
    ReturnInfo.RemoteAddress = pRemoteAddress;
    ReturnInfo.RemoteAddressLength = RemoteAddressLength;

    // Build MDL for buffer
    pMdl = IoAllocateMdl(
               pBuffer,
               BufferLength,
               FALSE,
               FALSE,
               (PIRP)NULL
               );

    if( pMdl == NULL ) {
        if (IrpAllocated) {
            IoFreeIrp( Irp );
        }
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    MmBuildMdlForNonPagedPool ( pMdl );

    TdiBuildReceiveDatagram(
        Irp,
        DeviceObject,
        FileObject,
        NULL,        // Completion routine
        NULL,        // Context
        pMdl,        // Mdl address
        BufferLength,
        &RequestInfo,
        &ReturnInfo,
        RecvFlags    // InFlags
        );

    Status = _TdiSubmitRequest(pTd, DeviceObject, Irp, FALSE);

    IoFreeMdl( pMdl );

    if ( NT_SUCCESS(Status) ) {
        // Packet length returned is in the Iosb
        *pReturnLength = (ULONG)Irp->IoStatus.Information;
        TRACE0(("_TdiReceiveDatagram: Irp DataLength 0x%x UserDataLength 0x%x, "
        "OptionsLength 0x%x, RemoteAddressLength 0x%x\n", *pReturnLength,
        ReturnInfo.UserDataLength, ReturnInfo.OptionsLength,
        ReturnInfo.RemoteAddressLength));
    }

    if (IrpAllocated) {
        IoFreeIrp( Irp );
    }

    return(Status);
}


NTSTATUS
_TdiSendDatagram(
    IN PTD pTd,
    IN PIRP Irp OPTIONAL,
    IN PFILE_OBJECT   FileObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PTRANSPORT_ADDRESS pRemoteAddress,
    IN ULONG RemoteAddressLength,
    IN PVOID pBuffer,
    IN ULONG BufferLength
    )
{
    PMDL     pMdl;
    NTSTATUS Status;
    BOOLEAN  IrpAllocated = FALSE;
    TDI_CONNECTION_INFORMATION SendInfo;

    if (!ARGUMENT_PRESENT(Irp)) {

        Irp = _TdiAllocateIrp( FileObject, DeviceObject );
        if (Irp == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return Status;
        }

        IrpAllocated = TRUE;
    }

    RtlZeroMemory( &SendInfo, sizeof(SendInfo) );

    // We must fill in our destination address
    SendInfo.RemoteAddress = pRemoteAddress;
    SendInfo.RemoteAddressLength = RemoteAddressLength;

    // Build MDL for buffer
    pMdl = IoAllocateMdl(
               pBuffer,
               BufferLength,
               FALSE,
               FALSE,
               (PIRP)NULL
               );

    if( pMdl == NULL ) {
        if (IrpAllocated) {
            IoFreeIrp( Irp );
        }
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    MmBuildMdlForNonPagedPool ( pMdl );

    TdiBuildSendDatagram(
        Irp,
        DeviceObject,
        FileObject,
        NULL,        // Completion routine
        NULL,        // Context
        pMdl,        // Mdl address
        BufferLength,
        &SendInfo
        );

    Status = _TdiSubmitRequest(pTd, DeviceObject, Irp, FALSE);

    IoFreeMdl( pMdl );

    if (IrpAllocated) {
        IoFreeIrp( Irp );
    }

    return(Status);
}

NTSTATUS
_TdiQueryAddressInfo(
    IN PTD pTd,
    IN PIRP Irp OPTIONAL,
    IN PFILE_OBJECT   FileObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PTDI_ADDRESS_INFO pAddressInfo,
    IN ULONG AddressInfoLength
    )
{
    PMDL     pMdl;
    NTSTATUS Status;
    BOOLEAN  IrpAllocated = FALSE;

    if (!ARGUMENT_PRESENT(Irp)) {

        Irp = _TdiAllocateIrp( FileObject, DeviceObject );
        if (Irp == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return Status;
        }

        IrpAllocated = TRUE;
    }

    // Build MDL for buffer
    pMdl = IoAllocateMdl(
               pAddressInfo,
               AddressInfoLength,
               FALSE,
               FALSE,
               (PIRP)NULL
               );

    if( pMdl == NULL ) {
        if (IrpAllocated) {
            IoFreeIrp( Irp );
        }
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    MmBuildMdlForNonPagedPool ( pMdl );

    TdiBuildQueryInformation(
        Irp,
        DeviceObject,
        FileObject,
        NULL,        // Completion routine
        NULL,        // Context
        TDI_QUERY_ADDRESS_INFO,
        pMdl
        );

    Status = _TdiSubmitRequest(pTd, DeviceObject, Irp, FALSE);

    IoFreeMdl( pMdl );

    if (IrpAllocated) {
        IoFreeIrp( Irp );
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\td\tdasync\tdasync.c ===
/****************************************************************************/
// tdasync.c
//
// Serial Transport Driver
//
// Copyright (C) 1998-2000 Microsoft Corporation
/****************************************************************************/

#include <ntddk.h>
#include <ntddvdeo.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <ntddbeep.h>
#include <ntddser.h>

#include <winstaw.h>
#include <icadd.h>
#include <cdtapi.h>
#include <sdapi.h>
#include <td.h>

#include "tdasync.h"
#include "zwprotos.h"


#ifdef _HYDRA_
// This becomes the device name
PWCHAR ModuleName = L"tdasync";
#endif
 

/*=============================================================================
==   External Functions Defined
=============================================================================*/

NTSTATUS DeviceOpen( PTD, PSD_OPEN );
NTSTATUS DeviceClose( PTD, PSD_CLOSE );
NTSTATUS DeviceCreateEndpoint( PTD, PICA_STACK_ADDRESS, PICA_STACK_ADDRESS );
NTSTATUS DeviceOpenEndpoint( PTD, PVOID, ULONG );
NTSTATUS DeviceCloseEndpoint( PTD );
NTSTATUS DeviceInitializeWrite( PTD, POUTBUF );
NTSTATUS DeviceIoctl( PTD, PSD_IOCTL );
NTSTATUS DeviceConnectionWait( PTD, PVOID, ULONG, PULONG );
NTSTATUS DeviceConnectionSend( PTD );
NTSTATUS DeviceConnectionRequest( PTD, PVOID,
                                  PVOID, ULONG, PULONG );
NTSTATUS DeviceSetParams( PTD );
NTSTATUS DeviceWaitForStatus( PTD );
NTSTATUS DeviceInitializeRead( PTD, PINBUF );
NTSTATUS DeviceSubmitRead( PTD, PINBUF );
NTSTATUS DeviceWaitForRead( PTD );
NTSTATUS DeviceReadComplete( PTD, PUCHAR, PULONG );
NTSTATUS DeviceCancelIo( PTD );
NTSTATUS DeviceSetLastError( PTD, ULONG );
NTSTATUS DeviceGetLastError( PTD, PICA_STACK_LAST_ERROR );


/*=============================================================================
==   Local Functions Defined
=============================================================================*/

BOOLEAN  _CheckForConnect( PTD, ULONG, ULONG );
BOOLEAN  _CheckForDisconnect( PTD, ULONG, ULONG );
VOID     _UpdateAsyncStatus( PTD, PTDASYNC, ULONG, ULONG );
NTSTATUS _SetupComm( PTD, HANDLE, ULONG, ULONG );
NTSTATUS _SetCommTimeouts( PTD, HANDLE, PSERIAL_TIMEOUTS );
NTSTATUS _GetCommModemStatus( PTD, HANDLE, PULONG );
NTSTATUS _GetCommProperties( PTD, HANDLE, PSERIAL_COMMPROP);
NTSTATUS _GetCommState( PTD, HANDLE, PSERIAL_BAUD_RATE, PSERIAL_LINE_CONTROL,
                        PSERIAL_CHARS, PSERIAL_HANDFLOW );
NTSTATUS _SetCommState( PTD, HANDLE, PSERIAL_BAUD_RATE, PSERIAL_LINE_CONTROL,
                        PSERIAL_CHARS, PSERIAL_HANDFLOW );
NTSTATUS _ClearCommError( PTD, HANDLE, PSERIAL_STATUS );
NTSTATUS _PurgeComm( PTD, HANDLE, ULONG );
NTSTATUS _WaitCommEvent( PTD, HANDLE, PULONG, PTDIOSTATUS );
NTSTATUS _SetCommMask( PTD, HANDLE, ULONG );
NTSTATUS _IoControl( PTD, HANDLE, ULONG, PVOID, ULONG, PVOID, ULONG, PULONG );
NTSTATUS _OpenDevice( PTD );
NTSTATUS _PrepareDevice( PTD );
NTSTATUS _FillInEndpoint( PTD, PVOID, ULONG, PULONG );


/*=============================================================================
==   Functions used
=============================================================================*/

VOID     OutBufFree( PTD, POUTBUF );
NTSTATUS MemoryAllocate( ULONG, PVOID * );
VOID     MemoryFree( PVOID );


/*******************************************************************************
 *
 *  DeviceOpen
 *
 *  Allocate and initialize private data structures
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdOpen (output)
 *       pointer to td open parameter block
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
DeviceOpen( PTD pTd, PSD_OPEN pSdOpen )
{
    PTDASYNC pTdAsync;
    PASYNCCONFIG pAsync;
    NTSTATUS Status;

    /*
     *  Set protocol driver class
     */
    pTd->SdClass = SdAsync;
    pAsync = &pTd->Params.Async;

    TRACE(( pTd->pContext, TC_TD, TT_API1, 
            "TDASYNC: DeviceOpen entry\n"
         ));

    /*
     *  Return size of header and parameters
     */
    pSdOpen->SdOutBufHeader  = 0;
    pSdOpen->SdOutBufTrailer = 0;

    /*
     *  Allocate ASYNC TD data structure
     */
    Status = MemoryAllocate( sizeof(*pTdAsync), &pTdAsync );
    if ( !NT_SUCCESS(Status) ) 
        goto badalloc;

    pTd->pPrivate = pTdAsync;

    TRACE(( pTd->pContext, TC_TD, TT_API1, 
          "TDASYNC: DeviceOpen, pTd 0x%x, pPrivate 0x%x, &pTd->pPrivate 0x%x\n",
            pTd, pTd->pPrivate, &pTd->pPrivate
         ));

    /*
     *  Initialize TDASYNC data structure
     */
    RtlZeroMemory( pTdAsync, sizeof(*pTdAsync) );

    /*
     *  Create event for status wait
     */
    Status = ZwCreateEvent( &pTdAsync->hStatusEvent,
                            EVENT_ALL_ACCESS,
                            NULL,
                            SynchronizationEvent,
                            FALSE );
    if ( !NT_SUCCESS( Status ) ) {
        TRACE(( pTd->pContext, TC_TD, TT_ERROR, 
                "TDASYNC: DeviceOpen, Create StatusEvent failed (0x%x)\n",
                Status ));
        goto badstatusevent;
    }
    Status = ObReferenceObjectByHandle( pTdAsync->hStatusEvent,
                                        EVENT_MODIFY_STATE,
                                        NULL,
                                        KernelMode,
                                        (PVOID *) &pTdAsync->pStatusEventObject,
                                        NULL );
    if ( !NT_SUCCESS( Status ) ) {
        TRACE(( pTd->pContext, TC_TD, TT_ERROR, 
                "TDASYNC: DeviceOpen, Create StatusEventObject failed (0x%x)\n",
                Status ));
        goto badstatuseventobj;
    }

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     * create of status event object pointer failed
     */
badstatuseventobj:
    (VOID) ZwClose( pTdAsync->hStatusEvent );
    pTdAsync->hStatusEvent = 0;

    /*
     * create of status event failed
     */
badstatusevent:
    MemoryFree( pTd->pPrivate );
    pTd->pPrivate = NULL;

    /*
     *  allocate failed
     */
badalloc:
    return( Status );
}


/*******************************************************************************
 *
 *  DeviceClose
 *
 *  Close transport driver
 *
 *  NOTE: this must not close the serial device
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdClose (input)
 *       pointer to td close parameter block
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
DeviceClose( PTD pTd, PSD_CLOSE pSdClose )
{
    PTDASYNC pTdAsync;
    PASYNCCONFIG pAsync;

    pTdAsync = (PTDASYNC) pTd->pPrivate;
    pAsync = &pTd->Params.Async;

    TRACE(( pTd->pContext, TC_TD, TT_API1, "TDASYNC: DeviceClose entry\n" ));

    /*
     * If necessary, close the endpoint now.
     */
    if ( pTdAsync->fCloseEndpoint ) {
        DeviceCloseEndpoint( pTd );
    }

    ObDereferenceObject( pTdAsync->pStatusEventObject );
    (VOID) ZwClose( pTdAsync->hStatusEvent );
    pTdAsync->pStatusEventObject = NULL;
    pTdAsync->hStatusEvent = 0;

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  DeviceCreateEndpoint
 *
 *  Open and initialize serial device
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pLocalAddress (input)
 *       Pointer to local address (not used)
 *    pReturnedAddress (input)
 *       Pointer to location to save returned (created) address (not used)
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS 
DeviceCreateEndpoint(
    PTD pTd,
    PICA_STACK_ADDRESS pLocalAddress,
    PICA_STACK_ADDRESS pReturnedAddress
    )
{
    PTDASYNC pTdAsync;
    PASYNCCONFIG pAsync;
    SERIAL_TIMEOUTS SerialTo;
    NTSTATUS Status;

    /*
     *  Get pointer to async parameters
     */
    pTdAsync = (PTDASYNC) pTd->pPrivate;
    pAsync = &pTd->Params.Async;

    Status = _OpenDevice( pTd );
    if ( !NT_SUCCESS( Status ) ) {
        TRACE(( pTd->pContext, TC_TD, TT_ERROR, 
            "TDASYNC: DeviceCreateEndpoint, _OpenDevice failed 0x%x\n",
            Status ));
        goto badopen;
    }

    Status = _PrepareDevice( pTd );
    if ( !NT_SUCCESS( Status ) ) {
        TRACE(( pTd->pContext, TC_TD, TT_ERROR, 
            "TDASYNC: DeviceCreateEndpoint, _PrepareDevice failed 0x%x\n",
            Status ));
        goto badprepare;
    }

    /*
     * Copy pointers for use by the common TD routines.
     */
    pTd->pFileObject = pTdAsync->Endpoint.pFileObject;
    pTd->pDeviceObject = pTdAsync->Endpoint.pDeviceObject;

    /*
     * If DeviceClose is called before a successful ConnectionWait,
     * then we must close the endpoint during the DeviceClose.
     */
    pTdAsync->fCloseEndpoint = TRUE;

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     * PrepareDevice failed
     */
badprepare:
    ZwClose( pTdAsync->Endpoint.SignalIoStatus.hEvent );
    pTdAsync->Endpoint.SignalIoStatus.hEvent = NULL;

    /*
     * open failed
     */
badopen:
    pTdAsync->Endpoint.hDevice = 0;
    return( Status );
}


/*******************************************************************************
 *
 *  DeviceOpenEndpoint
 *
 *  Open an existing endpoint
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pEndpoint (input)
 *       Pointer to endpoint structure
 *    EndpointLength (input)
 *       length of endpoint data
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS 
DeviceOpenEndpoint(
    PTD pTd,
    PVOID pEndpoint,
    ULONG EndpointLength
    )
{
    PTDASYNC pTdAsync;
    PASYNCCONFIG pAsync;
    ULONG Mask;
    PTDASYNC_ENDPOINT pEp;
    NTSTATUS Status;

    pEp = (PTDASYNC_ENDPOINT) pEndpoint;

    /*
     *  Get pointer to async parameters
     */
    pTdAsync = (PTDASYNC) pTd->pPrivate;
    pAsync = &pTd->Params.Async;

    TRACE(( pTd->pContext, TC_TD, TT_API2, 
       "TDASYNC: DeviceOpenEndpoint, old endpoint h 0x%x, f 0x%x, d 0x%x\n",
	    pEp->hDevice,
	    pEp->pFileObject,
	    pEp->pDeviceObject
	 ));

    /*
     * copy disconnected Endpoint structure
     */
    pTdAsync->Endpoint.hDevice       = pEp->hDevice;
    pTdAsync->Endpoint.pFileObject   = pEp->pFileObject;
    pTdAsync->Endpoint.pDeviceObject = pEp->pDeviceObject;
    pTdAsync->Endpoint.SignalIoStatus.pEventObject = 
        pEp->SignalIoStatus.pEventObject;
    pTdAsync->Endpoint.SignalIoStatus.hEvent =
        pEp->SignalIoStatus.hEvent;

    /*
     * Copy pointers for use by the common TD routines.
     */
    pTd->pFileObject   = pTdAsync->Endpoint.pFileObject;
    pTd->pDeviceObject = pTdAsync->Endpoint.pDeviceObject;

    if ( !pAsync->fConnectionDriver ) {
	/*
	 *  Set the comm event mask for status changes
	 */
	Mask = EV_CTS | EV_DSR | EV_ERR | EV_RING | EV_RLSD;
	if ( pAsync->Connect.fEnableBreakDisconnect )
	    Mask |= EV_BREAK;

	Status = _SetCommMask( pTd, pTdAsync->Endpoint.hDevice, Mask );
	if ( !NT_SUCCESS( Status ) ) {
	    goto badsetcomm;
	}
    }

    pTd->pFileObject = pTdAsync->Endpoint.pFileObject;
    pTd->pDeviceObject = pTdAsync->Endpoint.pDeviceObject;

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

badsetcomm:
    return( Status );
}


/*******************************************************************************
 *
 *  DeviceCloseEndpoint
 *
 *  Close Serial device
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS 
DeviceCloseEndpoint( PTD pTd )
{
    PTDASYNC pTdAsync;
    PASYNCCONFIG pAsync;

    pTdAsync = (PTDASYNC) pTd->pPrivate;
    pAsync = &pTd->Params.Async;

    TRACE(( pTd->pContext, TC_TD, TT_API1, 
            "TDASYNC: DeviceCloseEndpoint \"%S\"\n",
            pTd->Params.Async.DeviceName  ));

    /*
     * Dereference our pointer to the file object,
     * and "forget" about the device object pointer as well.
     */
    if ( pTdAsync->Endpoint.pFileObject ) {
	ObDereferenceObject( pTdAsync->Endpoint.pFileObject );
    }
    pTd->pFileObject = pTdAsync->Endpoint.pFileObject = NULL;

    pTd->pDeviceObject = pTdAsync->Endpoint.pDeviceObject = NULL;

    /*
     * Close the device handle
     */
    if ( pTdAsync->Endpoint.hDevice ) {
	TRACE(( pTd->pContext, TC_TD, TT_API1, 
		"TDASYNC: DeviceCloseEndpoint Closing Device handle 0x%x\n",
		pTdAsync->Endpoint.hDevice ));
	ZwClose( pTdAsync->Endpoint.hDevice );
    }
    pTdAsync->Endpoint.hDevice = NULL;

    /*
     *  Dereference the SignalIoStatus event
     */
    if ( pTdAsync->Endpoint.SignalIoStatus.pEventObject ) {
        ObDereferenceObject( pTdAsync->Endpoint.SignalIoStatus.pEventObject );
    }
    pTdAsync->Endpoint.SignalIoStatus.pEventObject = NULL;

    /*
     *  Close the SignalIoStatus event handle
     */
    if ( pTdAsync->Endpoint.SignalIoStatus.hEvent  ) {
        (VOID) ZwClose( pTdAsync->Endpoint.SignalIoStatus.hEvent );
    }
    pTdAsync->Endpoint.SignalIoStatus.hEvent = 0;


    TRACE(( pTd->pContext, TC_TD, TT_API1, 
            "TDASYNC: DeviceCloseEndpoint success\n"
         ));
    return( STATUS_SUCCESS );
}

/*******************************************************************************
 *
 *  DeviceInitializeWrite
 *
 *  Initialize a write operation for this device.
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pOutBuf
 *       Pointer to the OutBuf for this operation.
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
DeviceInitializeWrite(
    PTD pTd,
    POUTBUF pOutBuf
    )
{
    PIRP Irp;
    PIO_STACK_LOCATION _IRPSP;

    TRACE(( pTd->pContext, TC_TD, TT_API1, 
            "TDASYNC: DeviceInitializeWrite Entry\n"
         ));

    Irp = pOutBuf->pIrp;
    _IRPSP = IoGetNextIrpStackLocation( Irp );
    
    /*
     * Setup a WRITE IRP
     */
    _IRPSP->MajorFunction = IRP_MJ_WRITE;
    _IRPSP->Parameters.Write.Length = pOutBuf->ByteCount;

    ASSERT( Irp->MdlAddress == NULL );

    /*
     * Determine whether the target device performs direct or buffered I/O.
     */
    if ( pTd->pDeviceObject->Flags & DO_BUFFERED_IO ) {

        /*
         * The target device supports buffered I/O operations.  Since our
         * output buffer is allocated from NonPagedPool memory, we can just
         * point the SystemBuffer to the output buffer.  No buffer copying
         * will be required.
         */
        Irp->AssociatedIrp.SystemBuffer = pOutBuf->pBuffer;
        Irp->UserBuffer = pOutBuf->pBuffer;
        Irp->Flags |= IRP_BUFFERED_IO;

    } else if ( pTd->pDeviceObject->Flags & DO_DIRECT_IO ) {

        /*
         * The target device supports direct I/O operations.
         * Initialize the MDL and point to it from the IRP.
         *
	 * This MDL is allocated for every OUTBUF, and free'd with it.
	 */
        MmInitializeMdl( pOutBuf->pMdl, pOutBuf->pBuffer, pOutBuf->ByteCount );
        MmBuildMdlForNonPagedPool( pOutBuf->pMdl );
        Irp->MdlAddress = pOutBuf->pMdl;

    } else {

        /*
         * The operation is neither buffered nor direct.  Simply pass the
         * address of the buffer in the packet to the driver.
         */
        Irp->UserBuffer = pOutBuf->pBuffer;
    }

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  DeviceIoctl
 *
 *   Query/Set configuration information for the td.
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pSdIoctl (input/output)
 *       Points to the parameter structure SD_IOCTL
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
DeviceIoctl( PTD pTd, PSD_IOCTL pSdIoctl )
{
    NTSTATUS Status;
    PTDASYNC pTdAsync;
    SERIAL_TIMEOUTS SerialTo;
    PICA_STACK_TAPI_ENDPOINT pTe;

    pTdAsync = (PTDASYNC) pTd->pPrivate;

    TRACE(( pTd->pContext, TC_TD, TT_API2,
            "TDASYNC: DeviceIoctl, entry (0x%x)\n", pSdIoctl->IoControlCode ));

    switch ( pSdIoctl->IoControlCode ) {

        /*
         * Special IOCTL called when there is a connection driver
         * handling this device (i.e. a TAPI device).
         */
        case IOCTL_ICA_STACK_CD_CREATE_ENDPOINT :
	    
	    ASSERT( pSdIoctl->InputBuffer );
	    ASSERT( pSdIoctl->InputBufferLength ==
	           sizeof(ICA_STACK_TAPI_ENDPOINT) );
            ASSERT(pTd->Params.Async.fConnectionDriver);

	    pTe = (PICA_STACK_TAPI_ENDPOINT) pSdIoctl->InputBuffer;

	    /*
	     * Dup the connection driver's handles
             * We do this instead of using the same handle since it
             * has been found possible for TAPI to close the device
             * handle out from under us BEFORE we process a disconnect.
             * Therefore, we dup our own handle here.
	     */
            Status = ZwDuplicateObject( NtCurrentProcess(),
                                        pTe->hDevice,
                                        NtCurrentProcess(),
                                        &pTdAsync->Endpoint.hDevice,
                                        0,
                                        0,
                                        DUPLICATE_SAME_ACCESS |
                                        DUPLICATE_SAME_ATTRIBUTES );
            if ( !NT_SUCCESS( Status ) ) {
		TRACE(( pTd->pContext, TC_TD, TT_ERROR, 
		    "TDASYNC: DeviceIoctl, Dup device handle failed 0x%x\n",
		    Status ));
                goto baddup1;
            }

            Status = ZwDuplicateObject( NtCurrentProcess(),
                                        pTe->hDiscEvent,
                                        NtCurrentProcess(),
                                        &pTdAsync->Endpoint.SignalIoStatus.hEvent,
                                        0,
                                        0,
                                        DUPLICATE_SAME_ACCESS |
                                        DUPLICATE_SAME_ATTRIBUTES );
            if ( !NT_SUCCESS( Status ) ) {
		TRACE(( pTd->pContext, TC_TD, TT_ERROR, 
		    "TDASYNC: DeviceIoctl, Dup event handle failed 0x%x\n",
		    Status ));
                goto baddup2;
            }

	    /*
	     * The application opened the device.  One instance of this is a
	     * modem that has been configured by TAPI.  Note, that only the
             * handle is provided, all other driver-based initialization is
             * still required.
	     */
	    TRACE(( pTd->pContext, TC_TD, TT_API2, 
		"TDASYNC: DeviceIoctl, duping TAPI handle (0x%x -> 0x%x)\n",
		pTe->hDevice, pTdAsync->Endpoint.hDevice ));

	    /*
	     * Using the supplied handle, prepare this driver and the device.
	     */
	    Status = _PrepareDevice( pTd );
	    if ( !NT_SUCCESS( Status ) ) {
		TRACE(( pTd->pContext, TC_TD, TT_ERROR, 
		    "TDASYNC: DeviceIoctl, _PrepareDevice failed 0x%x\n",
		    Status ));
		goto badprepare;
	    }

	    /*
	     * Copy pointers for use by the common TD routines.
	     */
	    pTd->pFileObject   = pTdAsync->Endpoint.pFileObject;
	    pTd->pDeviceObject = pTdAsync->Endpoint.pDeviceObject;

	    _FillInEndpoint( pTd,
	                     pSdIoctl->OutputBuffer,
	  		     pSdIoctl->OutputBufferLength,
			     &pSdIoctl->BytesReturned );
	    break;

        default :
            return( STATUS_NOT_SUPPORTED );
    }

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

badprepare:
    ZwClose( pTdAsync->Endpoint.SignalIoStatus.hEvent );
    pTdAsync->Endpoint.SignalIoStatus.hEvent = NULL;

baddup2:
    ZwClose( pTdAsync->Endpoint.hDevice );
    pTdAsync->Endpoint.hDevice = NULL;

baddup1:
    return( Status );
}


/*******************************************************************************
 *
 *  DeviceConnectionWait
 *
 *  Wait for serial device to be powered on
 *  -- (i.e. wait for DSR signal)
 *
 *  NOTE: The endpoint structure is an opaque, variable length data 
 *        structure whose length and contents are determined by the 
 *        transport driver.
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pEndpoint (output)
 *       pointer to buffer to return copy of endpoint structure
 *    Length (input)
 *       length of endpoint buffer
 *    pEndpointLength (output)
 *       pointer to address to return actual length of Endpoint
 *
 * EXIT:
 *    STATUS_SUCCESS          - no error
 *    STATUS_BUFFER_TOO_SMALL - endpoint buffer is too small
 *
 ******************************************************************************/

NTSTATUS 
DeviceConnectionWait(
    PTD pTd, 
    PVOID pEndpoint,
    ULONG Length,
    PULONG pEndpointLength
    )
{
    PTDASYNC pTdAsync;
    PASYNCCONFIG pAsync;
    ULONG ModemStatus;
    ULONG Error;
    ULONG Mask;
    NTSTATUS Status;
    ULONG ActualEndpointLength = sizeof(TDASYNC_ENDPOINT);
    PTDASYNC_ENDPOINT pEp = (PTDASYNC_ENDPOINT) pEndpoint;

    ASSERT( pEndpoint );

    TRACE(( pTd->pContext, TC_TD, TT_API1, 
            "TDASYNC: DeviceConnectionWait, pTd 0x%x, pPrivate 0x%x\n",
            pTd, pTd->pPrivate
         ));

    _FillInEndpoint( pTd, pEndpoint, Length, pEndpointLength );

    /*
     *  Get pointer to async parameters
     */
    pTdAsync = (PTDASYNC) pTd->pPrivate;
    pAsync = &pTd->Params.Async;

    if ( pAsync->fConnectionDriver ) {
	/*
	 *  If a connection Driver is handling this connection,
	 *  assume the connection has been established.
	 */
    	goto complete;
    }

    /*
     *  Set the comm event mask for connect wait
     */
    Mask = EV_CTS | EV_DSR | EV_ERR | EV_RING | EV_RLSD;
    if ( pAsync->Connect.Type == Connect_FirstChar )
        Mask |= EV_RXCHAR;
    if ( pAsync->Connect.fEnableBreakDisconnect )
        Mask |= EV_BREAK;

    Status = _SetCommMask( pTd, pTdAsync->Endpoint.hDevice, Mask );
    if ( !NT_SUCCESS( Status ) ) {
        goto badsetcomm;
    }

    for(;;) {

        /*
         *  Post read for modem signal event
         */
        if ( !pTdAsync->fCommEventIoctl ) {
            TRACE(( pTd->pContext, TC_TD, TT_API2, 
               "TDASYNC: DeviceConnectionWait, hD 0x%x, hE 0x%x\n",
                    pEp->hDevice,
                    pTdAsync->Endpoint.SignalIoStatus.hEvent
                 ));
            pTdAsync->EventMask = 0;
            Status = _WaitCommEvent( pTd,
                                     pTdAsync->Endpoint.hDevice,
                                     &pTdAsync->EventMask,
                                     &pTdAsync->Endpoint.SignalIoStatus );
            if ( !NT_SUCCESS( Status ) ) {
                if ( Status != STATUS_PENDING ) {
                    goto badwaitcomm;
                }
            }
            pTdAsync->fCommEventIoctl = TRUE;
        }

        /*
         *  Get the current modem status
         */
        Status = _GetCommModemStatus( pTd,
                                      pTdAsync->Endpoint.hDevice,
                                      &ModemStatus );
        if ( !NT_SUCCESS( Status ) ) {
            goto badstatus;
        }

        /*
         *  Update protocol status
         */
        _UpdateAsyncStatus( pTd, pTdAsync, ModemStatus, pTdAsync->EventMask );

        /*
         *  Check for connect
         */
        if ( _CheckForConnect( pTd, ModemStatus, pTdAsync->EventMask ) ) {
            break;
        }

        /*
         *  Wait for modem status to change
         */
        Status = IcaWaitForSingleObject( pTd->pContext,
                                         pTdAsync->Endpoint.SignalIoStatus.pEventObject,
                                         INFINITE );
        pTdAsync->fCommEventIoctl = FALSE;

        /*
         *  Check error code
         */
        if ( Status != STATUS_WAIT_0 ) {
            goto waiterror;
        }

    } /* forever */

    if ( !pAsync->fConnectionDriver ) {
	/*
	 *  Update comm event mask
	 */
	if ( pAsync->Connect.Type == Connect_FirstChar ) {
	    Mask &= ~EV_RXCHAR;
	    Status = _SetCommMask( pTd, pTdAsync->Endpoint.hDevice, Mask );
	    if ( !NT_SUCCESS( Status ) ) {
		goto badsetcomm;
	    }
	}
    }

complete:
    /*
     * After a successful return from ConnectionWait, we no longer
     * have to close the endpoint on a DeviceClose call.
     */
    pTdAsync->fCloseEndpoint = FALSE;

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     * wait for object failed
     * get comm modem status failed
     * wait comm event failed
     * set comm mask failed
     */
waiterror:
badstatus:
badwaitcomm:
badsetcomm:

    return( Status );
}


/*******************************************************************************
 *
 *  DeviceConnectionRequest
 *
 *  Initiate a connection to the specified address
 *  - this is not supported by the serial transport driver
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pRemoteAddress (input)
 *       pointer to remote address to connect to
 *    pEndpoint (output)
 *       pointer to buffer to return copy of endpoint structure
 *    Length (input)
 *       length of endpoint buffer
 *    pEndpointLength (output)
 *       pointer to address to return actual length of Endpoint
 *
 * EXIT:
 *    STATUS_SUCCESS          - no error
 *    STATUS_BUFFER_TOO_SMALL - endpoint buffer is too small
 *
 ******************************************************************************/

NTSTATUS 
DeviceConnectionRequest(
    PTD pTd,
    PVOID pRemoteAddress,
    PVOID pEndpoint,
    ULONG Length,
    PULONG pEndpointLength
    )
{
    return( STATUS_INVALID_DEVICE_REQUEST );
}



/*******************************************************************************
 *
 *  DeviceConnectionSend
 *
 *  Initialize host module data structure
 *  -- this structure gets sent to the client
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS 
DeviceConnectionSend( PTD pTd )
{
    PCLIENTMODULES pClient;

    /*
     *  Get pointer to client structure
     */
    pClient = pTd->pClient;

    /*
     *  Initialize Td host module structure
     */
     pClient->TdVersionL = VERSION_HOSTL_TDASYNC;
     pClient->TdVersionH = VERSION_HOSTH_TDASYNC;
     pClient->TdVersion  = VERSION_HOSTH_TDASYNC;

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  DeviceSetParams
 *
 *  set serial device pararameters
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to Td data structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS 
DeviceSetParams( PTD pTd )
{
    PTDASYNC pTdAsync;
    PASYNCCONFIG pAsync;
    PFLOWCONTROLCONFIG pFlow;
    NTSTATUS Status;
    SERIAL_COMMPROP CommProp; 
    SERIAL_BAUD_RATE Baud;
    SERIAL_LINE_CONTROL LineControl;
    SERIAL_CHARS Chars;
    SERIAL_HANDFLOW HandFlow;

    /*
     *  Get pointer to async parameters
     */
    pTdAsync = (PTDASYNC) pTd->pPrivate;
    pAsync = &pTd->Params.Async;

    /*
     *  Get current State
     */
    Status = _GetCommState( pTd,
                            pTdAsync->Endpoint.hDevice,
                            &Baud,
                            &LineControl,
                            &Chars,
                            &HandFlow );
    if ( !NT_SUCCESS( Status ) ) {
        goto badgetstate;
    }

    /*
     *  Set defaults
     */
    if (pAsync->fEnableDsrSensitivity)
        HandFlow.ControlHandShake = SERIAL_DSR_SENSITIVITY;
    else
        HandFlow.ControlHandShake = 0;

    HandFlow.FlowReplace = SERIAL_XOFF_CONTINUE;

    if ( !pAsync->fConnectionDriver ) {
	/*
	 *  Set Communication parameters
	 */
	Baud.BaudRate          = pAsync->BaudRate;
	LineControl.Parity     = (BYTE) pAsync->Parity;
	LineControl.StopBits   = (BYTE) pAsync->StopBits;
	LineControl.WordLength = (BYTE) pAsync->ByteSize;
    }

    /*
     * The following was taken from terminal code
     */
    
    /*
     * sep92 on low mem rx buffer can be < 1024
     * set rx buffer to nice 4096 bytes size
     * driver will do its best and set the Rx buffer to this size
     * if it fails then dwCurrentRxQueue will be the one we have
     * so do getcommprop again to fetch this value, which can
     * be used to set xoff and xon lims
     */

    TRACE(( pTd->pContext, TC_TD, TT_API2, 
            "TDASYNC: DeviceSetParams Old State: XonLim %u, XoffLim %u\n",
            HandFlow.XonLimit, HandFlow.XoffLimit ));

    _GetCommProperties( pTd, pTdAsync->Endpoint.hDevice, &CommProp );

    TRACE(( pTd->pContext, TC_TD, TT_API2, 
            "TDASYNC: DeviceSetParams Old Queues: RxQueue %u, TxQueue %u\n",
            CommProp.CurrentRxQueue, CommProp.CurrentTxQueue ));

    _SetupComm( pTd, pTdAsync->Endpoint.hDevice, 4096, 4096 );

    CommProp.CurrentRxQueue = 0; // dirty it so that we
                                 // can use this only if !=0
    _GetCommProperties( pTd, pTdAsync->Endpoint.hDevice, &CommProp );

    TRACE(( pTd->pContext, TC_TD, TT_API2, 
            "TDASYNC: DeviceSetParams New Queues: RxQueue %u, TxQueue %u\n",
            CommProp.CurrentRxQueue, CommProp.CurrentTxQueue ));

    /*
     * if for some wierd reason CurrentRxQueue is not
     * filled in by the driver, then let xon xoff lims
     * be the default which the driver has.
     * (CurrentRxQueue was set to 0 before calling Get again)
     */

    if (CommProp.CurrentRxQueue != 0) {
        HandFlow.XonLimit  = (LONG)(CommProp.CurrentRxQueue / 4);
        HandFlow.XoffLimit = (LONG)(CommProp.CurrentRxQueue / 4);
    }

    pFlow = &pAsync->FlowControl;

    /*
     *  Initialize default DTR state
     */
    HandFlow.ControlHandShake &= ~SERIAL_DTR_MASK;
    if ( pFlow->fEnableDTR )
        HandFlow.ControlHandShake |= SERIAL_DTR_CONTROL;

    /*
     *  Initialize default RTS state
     */
    HandFlow.FlowReplace &= ~SERIAL_RTS_MASK;
    if ( pFlow->fEnableRTS )
        HandFlow.FlowReplace |= SERIAL_RTS_CONTROL;

    /*
     *  Initialize flow control
     */
    switch ( pFlow->Type ) {

        /*
         *  Initialize hardware flow control
         */
        case FlowControl_Hardware :

            switch ( pFlow->HardwareReceive ) {
                case ReceiveFlowControl_RTS :
                    HandFlow.FlowReplace =
                        (HandFlow.FlowReplace & ~SERIAL_RTS_MASK) |
                        SERIAL_RTS_HANDSHAKE;
                    break;
                case ReceiveFlowControl_DTR :
                    HandFlow.ControlHandShake =
                        (HandFlow.ControlHandShake & ~SERIAL_DTR_MASK) |
                        SERIAL_DTR_HANDSHAKE;
                    break;
            }
            switch ( pFlow->HardwareTransmit ) {
                case TransmitFlowControl_CTS :
                    HandFlow.ControlHandShake |= SERIAL_CTS_HANDSHAKE;
                    break;
                case TransmitFlowControl_DSR :
                    HandFlow.ControlHandShake |= SERIAL_DSR_HANDSHAKE;
                    break;
            }
            break;

        /*
         *  Initialize software flow control
         */
        case FlowControl_Software :
            if (pFlow->fEnableSoftwareTx)
                HandFlow.FlowReplace |= SERIAL_AUTO_TRANSMIT;
            if (pFlow->fEnableSoftwareRx)
                HandFlow.FlowReplace |= SERIAL_AUTO_RECEIVE;
            Chars.XonChar  = (char) pFlow->XonChar;
            Chars.XoffChar = (char) pFlow->XoffChar;
            break;

        case FlowControl_None :
            break;

        default :
            ASSERT( FALSE );
            break;
    }

    TRACE(( pTd->pContext, TC_TD, TT_API2, 
        "TDASYNC: DeviceSetParams: baud %u, par %u, stop %u, data %u, dtr %u, rts %u\n",
        Baud.BaudRate, LineControl.Parity, LineControl.StopBits,
        LineControl.WordLength,
        HandFlow.ControlHandShake & SERIAL_DTR_MASK,
        HandFlow.FlowReplace & SERIAL_RTS_MASK ));

    TRACE(( pTd->pContext, TC_TD, TT_API2, 
        "TDASYNC: DeviceSetParams: fOutX %u, fInX %u, xon %x, xoff %x, cts %u, dsr %u\n",
        (HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT) != 0,
        (HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE)  != 0,
        Chars.XonChar,
        Chars.XoffChar,
        (HandFlow.ControlHandShake & SERIAL_CTS_HANDSHAKE) != 0,
        (HandFlow.ControlHandShake & SERIAL_DSR_HANDSHAKE) != 0 ));
    
    TRACE(( pTd->pContext, TC_TD, TT_API2, 
        "TDASYNC: DeviceSetParams: XonLimit %u, XoffLimit %u\n",
        HandFlow.XonLimit, HandFlow.XoffLimit ));

    /*
     *  Set new State
     */
    Status = _SetCommState( pTd,
                            pTdAsync->Endpoint.hDevice,
                            &Baud,
                            &LineControl,
                            &Chars,
                            &HandFlow );
    if ( !NT_SUCCESS( Status ) ) {
        goto badsetstate;
    }
    
    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     *  State set failed
     *  State query failed
     */
badsetstate:
badgetstate:
    return( Status );
}

/*******************************************************************************
 *
 *  DeviceInitializeRead
 *
 *   This routine is called for each read, it also starts the "read" for
 *   serial device status changes.
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
DeviceInitializeRead(
    PTD pTd,
    PINBUF pInBuf
    )
{
    PTDASYNC pTdAsync;
    PASYNCCONFIG pAsync;
    NTSTATUS Status;
    ULONG ModemStatus;
    PIRP Irp;
    PIO_STACK_LOCATION _IRPSP;

    pTdAsync = (PTDASYNC) pTd->pPrivate;
    pAsync = &pTd->Params.Async;

    TRACE(( pTd->pContext, TC_TD, TT_API2,
            "TDASYNC: DeviceInitializeRead entry\n"
         ));

    /*
     * Initialize the IRP for a READ
     */
    Irp = pInBuf->pIrp;
    _IRPSP = IoGetNextIrpStackLocation( Irp );
    _IRPSP->Parameters.Read.Length = pTd->InBufHeader + pTd->OutBufLength;
    _IRPSP->MajorFunction = IRP_MJ_READ;

    ASSERT( Irp->MdlAddress == NULL );

    /*
     * Determine whether the target device performs direct or buffered I/O.
     */
    if ( pTd->pDeviceObject->Flags & DO_BUFFERED_IO ) {

        /*
         * The target device supports buffered I/O operations.  Since our
         * input buffer is allocated from NonPagedPool memory, we can just
         * point the SystemBuffer to our input buffer.  No buffer copying
         * will be required.
         */
        Irp->AssociatedIrp.SystemBuffer = pInBuf->pBuffer;
        Irp->UserBuffer = pInBuf->pBuffer;
        Irp->Flags |= IRP_BUFFERED_IO;

    } else if ( pTd->pDeviceObject->Flags & DO_DIRECT_IO ) {

        /*
         * The target device supports direct I/O operations.
         * If we haven't already done so, allocate an MDL large enough
         * to map the input buffer and indicate it is contained in
         * NonPagedPool memory.
         *
	 * The MDL is preallocated in the PTD and never freed by the Device leve
	 * TD.
	 */
        MmInitializeMdl( pInBuf->pMdl, pInBuf->pBuffer, pTd->InBufHeader+pTd->OutBufLength );
        MmBuildMdlForNonPagedPool( pInBuf->pMdl );
        Irp->MdlAddress = pInBuf->pMdl;

    } else {

        /*
         * The operation is neither buffered nor direct.  Simply pass the
         * address of the buffer in the packet to the driver.
         */
        Irp->UserBuffer = pInBuf->pBuffer;
    }

    /*
     * If there is not already an Ioctl pending for serial
     * device status, then initiate one now.  DeviceWaitForRead
     * uses the event within the SignalIoStatus structure.
     * If a Connection Driver is handling this connection, the connection
     * driver created an event, and passed it down in the Endpoint.
     * The connection driver will take care of the signaling mechanism,
     * so no operations other than waiting on the event are required.
     * NOTE: The connection driver event will only be signaled on
     * Disconnects.
     */
    if ( !pTdAsync->fCommEventIoctl && !pAsync->fConnectionDriver ) {
        /*
         *  Get the current modem status
         */
        Status = _GetCommModemStatus( pTd,
                                      pTdAsync->Endpoint.hDevice,
                                      &ModemStatus );
        if ( !NT_SUCCESS( Status ) ) {
	    goto badgetcomm;
        }

        /*
         *  Update protocol status
         */
        _UpdateAsyncStatus( pTd, pTdAsync, ModemStatus, pTdAsync->EventMask );

	/*
	 *  Check for a disconnect
	 */
	if ( _CheckForDisconnect( pTd, ModemStatus, pTdAsync->EventMask )) {
	    Status = STATUS_CTX_CLOSE_PENDING;
	    goto disconnect;
	}

        pTdAsync->EventMask = 0;
        Status = _WaitCommEvent( pTd,
                                 pTdAsync->Endpoint.hDevice,
                                 &pTdAsync->EventMask,
                                 &pTdAsync->Endpoint.SignalIoStatus );
        if ( !NT_SUCCESS( Status ) ) {
            if ( Status != STATUS_PENDING ) {
                goto badwaitcomm;
            }
        }
        pTdAsync->fCommEventIoctl = TRUE;
    }

    TRACE(( pTd->pContext, TC_TD, TT_API2,
            "TDASYNC: DeviceInitializeRead success\n"
         ));
    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

badgetcomm:
disconnect:
badwaitcomm:
    TRACE(( pTd->pContext, TC_TD, TT_API2,
            "TDASYNC: DeviceInitializeRead status (0x%x)\n",
	    Status
         ));
    return( Status );
}


/*******************************************************************************
 *
 * DeviceSubmitRead
 *
 * Submit the read IRP to the driver.
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
DeviceSubmitRead(
    PTD pTd,
    PINBUF pInBuf
    )
{
    PIRP Irp;
    NTSTATUS Status;

    Irp = pInBuf->pIrp;

    Status = IoCallDriver( pTd->pDeviceObject, Irp );

    return( Status );
}

/*******************************************************************************
 *
 *  DeviceWaitForRead
 *
 *   This routine waits for input data and detects broken connections.
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *    -1 - disconnected
 *
 ******************************************************************************/

NTSTATUS
DeviceWaitForRead(
    PTD pTd
    )
{
    PTDASYNC pTdAsync;
    PASYNCCONFIG pAsync;
    PKEVENT pWait[2];
    ULONG ModemStatus;
    NTSTATUS Status;
    ULONG WaitCount;

    pTdAsync = (PTDASYNC) pTd->pPrivate;
    pAsync = &pTd->Params.Async;

    /*
     *  Setup wait for input data, and a communication event
     *  if a Connection Driver isn't handling this connection.
     */
    WaitCount = 0;
    pWait[WaitCount++] = &pTd->InputEvent; 
    pWait[WaitCount++] = pTdAsync->Endpoint.SignalIoStatus.pEventObject;

    /*
     *  Loop until input data or broken connection
     */
    for(;;) {

        TRACE(( pTd->pContext, TC_TD, TT_API1, 
                "TDASYNC: DeviceWaitForRead Loop\n"
             ));

        Status = IcaWaitForMultipleObjects( pTd->pContext, WaitCount, pWait,
                                            WaitAny, INFINITE );
    
        TRACE(( pTd->pContext, TC_TD, TT_API2, 
                "TDASYNC: DeviceWaitForRead: WaitForMultiple status 0x%x\n",
                Status
             ));
        /*
         *  Check if input data is available
         */
        if ( Status == STATUS_WAIT_0 ) {
            if ( pAsync->fConnectionDriver ) {
                /*
                 *  Since the connection driver has control over this port,
                 *  the event-mask method of waiting for modem signal status 
                 *  changes can't be used, since setting our mask will destroy
                 *  the one TAPI has established.  This makes TAPI very unhappy.
                 *
                 *  Now, you might be thinking - why not just wait for status
                 *  changes that TAPI has established, and update status then.
                 *  Well, that's possible, but there's something else which must
                 *  be considered.  When we want to shut down the IOCTL that is
                 *  waiting for status changes, a change of the event mask is
                 *  required.  Hence, this would alter what TAPI has set.
                 */
                /*
                 *  Get the current modem status
                 */
                Status = _GetCommModemStatus( pTd,
                                              pTdAsync->Endpoint.hDevice,
                                              &ModemStatus );
                if ( Status != STATUS_SUCCESS ) {
                    return( Status );
                }

                /*
                 *  Update protocol status
                 */
                _UpdateAsyncStatus( pTd, pTdAsync, ModemStatus, pTdAsync->EventMask );
            }
            break;
        } else if ( pAsync->fConnectionDriver && Status == STATUS_WAIT_1 ) {
            /*
             *  If a Connection Driver is handling this connection, this
             *  event was signaled because a disconnect was detected by
             *  the connection driver.
             */
             if ( pTd->fCallbackInProgress ) {
                 /*
                  * During callback the client will disconnect, but
                  * in this case we don't want the error going back up
                  * the stack.
                  */
                 continue;
             } else {
                 return( STATUS_CTX_CLOSE_PENDING );
             }
        }

        /*
         *  If modem status event was not signaled, return error
         */
        if ( Status != STATUS_WAIT_1 ) {
            return( Status );
        }
        pTdAsync->fCommEventIoctl = FALSE;

        /*
         *  Get the current modem status
         */
        Status = _GetCommModemStatus( pTd,
                                      pTdAsync->Endpoint.hDevice,
                                      &ModemStatus );
        if ( !NT_SUCCESS( Status ) ) {
            return( Status );
        }

        /*
         *  Update protocol status
         */
        _UpdateAsyncStatus( pTd, pTdAsync, ModemStatus, pTdAsync->EventMask );

        /*
         *  Check for a disconnect
         */
        if ( _CheckForDisconnect( pTd, ModemStatus, pTdAsync->EventMask ) ) {
            return( STATUS_CTX_CLOSE_PENDING );
        }

        /*
         *  Signal event wait semaphore
         */
        ZwSetEvent( pTdAsync->hStatusEvent, NULL );

        /*
         *  Post another read for a modem signal event
         */
        pTdAsync->EventMask = 0;
        Status = _WaitCommEvent( pTd,
                                 pTdAsync->Endpoint.hDevice,
                                 &pTdAsync->EventMask,
                                 &pTdAsync->Endpoint.SignalIoStatus );
        if ( !NT_SUCCESS( Status ) ) {
            return( Status );
        }
        pTdAsync->fCommEventIoctl = TRUE;
    }

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  DeviceReadComplete
 *
 *  Do any read complete processing
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pBuffer (input)
 *       Pointer to input buffer
 *    pByteCount (input/output)
 *       Pointer to location containing byte count read
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS 
DeviceReadComplete( PTD pTd, PUCHAR pBuffer, PULONG pByteCount )
{
    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  DeviceWaitForStatus
 *
 *   This routine waits for RS232 signal status to change
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
DeviceWaitForStatus( PTD pTd )
{
    PTDASYNC pTdAsync;
    NTSTATUS Status;

    pTdAsync = (PTDASYNC) pTd->pPrivate;

    TRACE(( pTd->pContext, TC_TD, TT_API1, 
            "TDASYNC: DeviceWaitForStatus: Entry\n"
         ));

    ASSERT(!pTd->Params.Async.fConnectionDriver);

    /*
     * Wait for status to change
     */
    Status = IcaWaitForSingleObject( pTd->pContext,
                                     pTdAsync->pStatusEventObject,
                                     INFINITE );
    return( Status );
}


/*******************************************************************************
 *  DeviceCancelIo
 *
 *   cancel all current and future i/o
 ******************************************************************************/
NTSTATUS DeviceCancelIo(PTD pTd)
{
    PTDASYNC pTdAsync;
    PASYNCCONFIG pAsync;

    TRACE(( pTd->pContext, TC_TD, TT_API1,
            "TDASYNC: DeviceCancelIo Entry\n" ));

    pTdAsync = (PTDASYNC) pTd->pPrivate;
    pAsync = &pTd->Params.Async;

    /*
     *  Signal event wait semaphore
     */
    ZwSetEvent(pTdAsync->hStatusEvent, NULL);
    if (!pAsync->fConnectionDriver) {
        /*
         * Clear comm mask.  This will cause the _WaitCommEvent event
         * to be set which will then cause the input thread to wakeup.
         */
        (VOID) _SetCommMask( pTd, pTdAsync->Endpoint.hDevice, 0 );
    }

    /*
     *  Cancel all outstanding writes
     */
    (VOID) _PurgeComm( pTd,
                       pTdAsync->Endpoint.hDevice,
                       SERIAL_PURGE_TXABORT | SERIAL_PURGE_TXCLEAR );

    /*
     * Purge the recieve buffer and any pending read.
     */
    (VOID) _PurgeComm( pTd,
                       pTdAsync->Endpoint.hDevice,
                       SERIAL_PURGE_RXABORT | SERIAL_PURGE_RXCLEAR );

    return STATUS_SUCCESS;
}

/*******************************************************************************
 *  DeviceQueryRemoteAddress
 *
 *   not supported for Async transport
 ******************************************************************************/
NTSTATUS 
DeviceQueryRemoteAddress(
    PTD pTd,
    PVOID pIcaEndpoint,
    ULONG EndpointSize,
    PVOID pOutputAddress,
    ULONG OutputAddressSize,
    PULONG BytesReturned)
{
    //
    //  unsupported for Async
    //
    return STATUS_NOT_SUPPORTED;
}

/*******************************************************************************
 *
 *  DeviceSetLastError
 *
 *   save serial error code 
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    Error (input)
 *       serial error code
 *
 * EXIT:
 *     NT error code
 *
 ******************************************************************************/

NTSTATUS
DeviceSetLastError( PTD pTd, ULONG Error )
{
    if ( Error == 0 )
        return( STATUS_SUCCESS );

    pTd->LastError = Error;

    (void) IcaLogError( pTd->pContext,
                        Error,
                        NULL, 
                        0,
                        &pTd->Params.Async,
                        sizeof(pTd->Params.Async) );

    return( STATUS_CTX_TD_ERROR );
}


/*******************************************************************************
 *
 *  DeviceGetLastError
 *
 *   This routine returns the last serial error code and message
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pLastError (output)
 *       address to return information on last protocol error
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS 
DeviceGetLastError( PTD pTd, PICA_STACK_LAST_ERROR pLastError )
{
    pLastError->Error = pTd->LastError;
    RtlZeroMemory( pLastError->Message, sizeof(pLastError->Message) );

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  _CheckForConnect
 *
 *   check for a connect signal
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    ModemStatus (input)
 *       modem status flags (MS_?)
 *    EventMask (input)
 *       event mask (EV_?)
 *
 * EXIT:
 *    TRUE if connected, FALSE otherwise
 *
 ******************************************************************************/

BOOLEAN
_CheckForConnect( PTD pTd, ULONG ModemStatus, ULONG EventMask )
{
    TRACE(( pTd->pContext, TC_TD, TT_API2,
            "TDASYNC: _CheckForConnect: modem 0x%x, event 0x%x, connect 0x%x\n",
            ModemStatus, EventMask, pTd->Params.Async.Connect.Type
         ));

    switch( pTd->Params.Async.Connect.Type ) {

        case Connect_CTS :
            if ( ModemStatus & MS_CTS_ON )
                return( TRUE );
            break;

        case Connect_DSR :
            if ( ModemStatus & MS_DSR_ON )
                return( TRUE );
            break;

        case Connect_RI :
            if ( ModemStatus & MS_RING_ON )
                return( TRUE );
            break;

        case Connect_DCD :
            if ( ModemStatus & MS_RLSD_ON )
                return( TRUE );
            break;

        case Connect_FirstChar :
            if ( EventMask & EV_RXCHAR )
                return( TRUE );
            break;

        case Connect_Perm :
            return( TRUE );
    }

    return( FALSE );
}


/*******************************************************************************
 *
 *  _CheckForDisconnect
 *
 *   check for a disconnect signal
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    ModemStatus (input)
 *       modem status flags (MS_?)
 *    EventMask (input)
 *       event mask (EV_?)
 *
 * EXIT:
 *    TRUE if disconnected, FALSE otherwise
 *
 ******************************************************************************/

BOOLEAN
_CheckForDisconnect( PTD pTd, ULONG ModemStatus, ULONG EventMask )
{
    TRACE(( pTd->pContext,
         TC_TD, TT_API2,
         "TDASYNC: _CheckForDisconnect: modem 0x%x, event 0x%x, connect 0x%x\n",
         ModemStatus, EventMask, pTd->Params.Async.Connect.Type
         ));

    switch( pTd->Params.Async.Connect.Type ) {

        case Connect_CTS :
            if ( !(ModemStatus & MS_CTS_ON) )
                return( TRUE );
            break;

        case Connect_DSR :
            if ( !(ModemStatus & MS_DSR_ON) )
                return( TRUE );
            break;

        case Connect_RI :
            if ( !(ModemStatus & MS_RING_ON) )
                return( TRUE );
            break;

        case Connect_DCD :
            if ( !(ModemStatus & MS_RLSD_ON) )
                return( TRUE );
            break;

        case Connect_FirstChar :
            if ( EventMask & EV_BREAK )
                return( TRUE );
            break;

        case Connect_Perm :
            return( FALSE );
    }
    return( FALSE );
}


/*******************************************************************************
 *
 *  _UpdateAsyncStatus
 *
 *   update async signal status
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pTdAsync (input)
 *       Pointer to td async data structure
 *    ModemStatus (input)
 *       modem status flags (MS_?)
 *    EventMask (input)
 *       event mask (EV_?)
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
_UpdateAsyncStatus(
    PTD pTd,
    PTDASYNC pTdAsync,
    ULONG ModemStatus,
    ULONG EventMask
    )
{
    PPROTOCOLSTATUS pStatus;
    PFLOWCONTROLCONFIG pFlow;
    SERIAL_STATUS SerialStat;

    pStatus = pTd->pStatus;

    TRACE(( pTd->pContext, TC_TD, TT_API2,
            "TDASYNC: _UpdateAsyncStatus: modem %x, event %x\n", 
            ModemStatus, EventMask
         ));

    /*
     *  Update modem status
     */
    pStatus->AsyncSignal = ModemStatus;

    /* 
     *  Or in status of DTR and RTS
     */
    pFlow = &pTd->Params.Async.FlowControl;
    if ( pFlow->fEnableDTR )
        pStatus->AsyncSignal |= MS_DTR_ON;
    if ( pFlow->fEnableRTS )
        pStatus->AsyncSignal |= MS_RTS_ON;

    /*
     *  OR in new event mask
     *  -- EventMask get cleared when user program reads info
     */
    pStatus->AsyncSignalMask |= EventMask;

    /*
     *  Update async error counters
     */
    if ( EventMask & EV_ERR ) {
        (VOID) _ClearCommError( pTd, pTdAsync->Endpoint.hDevice, &SerialStat );
        if ( SerialStat.Errors & SERIAL_ERROR_OVERRUN ) {
            TRACE(( pTd->pContext, TC_TD, TT_API2,
                    "TDASYNC: _UpdateAsyncStatus: SERIAL_ERROR_OVERRUN\n"
                 ));
            pStatus->Output.AsyncOverrunError++;
        }
        if ( SerialStat.Errors & SERIAL_ERROR_FRAMING ) {
            TRACE(( pTd->pContext, TC_TD, TT_API2,
                    "TDASYNC: _UpdateAsyncStatus: SERIAL_ERROR_FRAMING\n"
                 ));
            pStatus->Input.AsyncFramingError++;
        }
        if ( SerialStat.Errors & SERIAL_ERROR_QUEUEOVERRUN ) {
            TRACE(( pTd->pContext, TC_TD, TT_API2,
                    "TDASYNC: _UpdateAsyncStatus: SERIAL_ERROR_QUEUEOVERRUN\n"
                 ));
            pStatus->Input.AsyncOverflowError++;
        }
        if ( SerialStat.Errors & SERIAL_ERROR_PARITY ) {
            TRACE(( pTd->pContext, TC_TD, TT_API2,
                    "TDASYNC: _UpdateAsyncStatus: SERIAL_ERROR_PARITY\n"
                 ));
            pStatus->Input.AsyncParityError++;
        }
    }
}


/*******************************************************************************
 *
 *  _SetCommTimeouts
 *
 *   This function establishes the timeout characteristics for all
 *   read and write operations on the handle specified by hFile.
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    hFile (input)
 *       Specifies the communication device to receive the settings.
 *       The CreateFile function returns this value.
 *    pTo (input)
 *       Points to a structure containing timeout parameters.
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_SetCommTimeouts(
    PTD pTd,
    HANDLE hFile,
    PSERIAL_TIMEOUTS pTo
    )
{
    NTSTATUS Status;

    TRACE(( pTd->pContext, TC_TD, TT_API2,
            "TDASYNC: _SetCommTimeouts: ReadIntervalTimeout %d\n", 
            pTo->ReadIntervalTimeout
         ));

    Status = _IoControl( pTd,
                         hFile,
                         IOCTL_SERIAL_SET_TIMEOUTS,
                         pTo,
                         sizeof(*pTo),
                         NULL,
                         0,
                         NULL );
    return Status;
}


/*******************************************************************************
 *
 *  _GetCommModemStatus
 *   This routine returns the most current value of the modem
 *   status register's non-delta values.
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    hFile (input)
 *       Specifies the communication device to be examined.
 *    pModemStat (output)
 *       Points to a ULONG which is to receive the mask of
 *       non-delta values in the modem status register.
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_GetCommModemStatus(
    PTD pTd,
    HANDLE hFile,
    PULONG pModemStat
    )
{
    NTSTATUS Status;

    Status = _IoControl( pTd,
                         hFile,
                         IOCTL_SERIAL_GET_MODEMSTATUS,
                         NULL,
                         0,
                         pModemStat,
                         sizeof(*pModemStat),
                         NULL );
    return Status;
}


/*******************************************************************************
 *
 *  _WaitCommEvent
 *   This function will wait until any of the events occur that were
 *   provided in the EvtMask parameter to _SetCommMask.  If while waiting
 *   the event mask is changed (via another call to SetCommMask), the
 *   function will return immediately.  The function will fill the EvtMask
 *   pointed to by the pEvtMask parameter with the reasons that the
 *   wait was satisfied.
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    hFile (input)
 *       Specifies the communication device to be waited on.
 *       The CreateFile function returns this value.
 *    pEvtMask (output)
 *       Points to a mask that will receive the reason that
 *       the wait was satisfied.
 *    pOverLapped (input)
 *       An optional overlapped handle.
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_WaitCommEvent(
    PTD pTd,
    HANDLE hFile,
    PULONG pEvtMask,
    PTDIOSTATUS pIoStatus
    )
{
    NTSTATUS Status;

    TRACE(( pTd->pContext, TC_TD, TT_API2,
            "TDASYNC: _WaitCommEvent: entry\n"
         ));

    ASSERT(!pTd->Params.Async.fConnectionDriver);

    if (ARGUMENT_PRESENT(pIoStatus)) {
        pIoStatus->Internal = (ULONG)STATUS_PENDING;

        Status = ZwDeviceIoControlFile(
                     hFile,
                     pIoStatus->hEvent,
                     NULL,
                     NULL,
                     (PIO_STATUS_BLOCK)&pIoStatus->Internal,
                     IOCTL_SERIAL_WAIT_ON_MASK,
                     NULL,
                     0,
                     pEvtMask,
                     sizeof(*pEvtMask) );
    } else {
        Status = _IoControl( pTd,
                             hFile,
                             IOCTL_SERIAL_WAIT_ON_MASK,
                             NULL,
                             0,
                             pEvtMask,
                             sizeof(*pEvtMask),
                             NULL );
    }
    return( Status );
}


/*******************************************************************************
 *
 *  _SetupComm
 *   The communication device is not initialized until SetupComm is
 *   called.  This function allocates space for receive and transmit
 *   queues.  These queues are used by the interrupt-driven transmit/
 *   receive software and are internal to the provider.
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    hFile (input)
 *       Specifies the communication device to receive the settings.
 *    InQueue (input)
 *       Specifies the recommended size of the provider's
 *       internal receive queue in bytes.  This value must be
 *       even.  A value of -1 indicates that the default should
 *       be used.
 *    OutQueue (input)
 *       Specifies the recommended size of the provider's
 *       internal transmit queue in bytes.  This value must be
 *       even.  A value of -1 indicates that the default should be used.
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_SetupComm(
    PTD pTd,
    HANDLE hFile,
    ULONG InQueue,
    ULONG OutQueue
    )
{
    NTSTATUS Status;
    SERIAL_QUEUE_SIZE NewSizes = {0};

    TRACE(( pTd->pContext, TC_TD, TT_API2,
            "TDASYNC: _SetupComm: InQueue %d, OutQueue %d\n", 
            InQueue, OutQueue
         ));

    /*
     * Make sure that the sizes are even.
     */

    if (OutQueue != ((ULONG)-1)) {
        if (((OutQueue/2)*2) != OutQueue) {
            return( STATUS_INVALID_PARAMETER );
        }
    }

    if (InQueue != ((ULONG)-1)) {
        if (((InQueue/2)*2) != InQueue) {
            return( STATUS_INVALID_PARAMETER );
        }
    }

    NewSizes.InSize = InQueue;
    NewSizes.OutSize = OutQueue;


    Status = _IoControl( pTd,
                         hFile,
                         IOCTL_SERIAL_SET_QUEUE_SIZE,
                         &NewSizes,
                         sizeof(NewSizes),
                         NULL,
                         0,
                         NULL );
    return Status;
}


/*******************************************************************************
 *
 *  _SetCommMask
 *
 *   The function enables the event mask of the communication device
 *   specified by the hFile parameter.  The bits of the EvtMask parameter
 *   define which events are to be enabled.
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    hFile (input)
 *       Specifies the communication device to receive the settings.
 *    EvtMask (input)
 *       Specifies which events are to enabled.
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_SetCommMask(
    PTD pTd,
    HANDLE hFile,
    ULONG EvtMask
    )
{
    ULONG LocalMask = EvtMask;
    NTSTATUS Status;

    TRACE(( pTd->pContext, TC_TD, TT_API2,
            "TDASYNC: _SetCommMask: EventMask 0x%x\n", 
            EvtMask
         ));

    /*
     * Make sure that the users mask doesn't contain any values
     * we don't support.
     */

    if (EvtMask & (~(EV_RXCHAR   |
                     EV_RXFLAG   |
                     EV_TXEMPTY  |
                     EV_CTS      |
                     EV_DSR      |
                     EV_RLSD     |
                     EV_BREAK    |
                     EV_ERR      |
                     EV_RING     |
                     EV_PERR     |
                     EV_RX80FULL |
                     EV_EVENT1   |
                     EV_EVENT2))) {

        return( STATUS_INVALID_PARAMETER );
    }

    Status = _IoControl( pTd,
                         hFile,
                         IOCTL_SERIAL_SET_WAIT_MASK,
                         &LocalMask,
                         sizeof(LocalMask),
                         NULL,
                         0,
                         NULL );
    return Status;
}


/*******************************************************************************
 *
 *  _GetCommProperties
 *
 *   This function fills the ubffer pointed to by pCommProp with the
 *   communications properties associated with the communications device
 *   specified by the hFile.
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    hFile (input)
 *       Specifies the communication device to be examined.
 *    pCommProp (output)
 *       Points to the PSERIAL_COMMPROP data structure that is to
 *       receive the communications properties structure.  This
 *       structure defines certain properties of the communications
 *       device.
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_GetCommProperties(
    PTD pTd,
    HANDLE hFile,
    PSERIAL_COMMPROP pCommProp
    )
{
    NTSTATUS Status;
    ULONG bufferLength;

    TRACE(( pTd->pContext, TC_TD, TT_API2,
            "TDASYNC: _GetCommProperties: Entry\n"
         ));

    /*
     * Get the total length of what to pass down.  If the
     * application indicates that there is provider specific data
     * (by setting dwProvSpec1 to COMMPROP_INITIAILIZED) then
     * use what's at the start of the commprop.
     */

    bufferLength = sizeof(pCommProp);

    /*
     * Zero out the commprop.  This might create an access violation
     * if it isn't big enough.  Which is ok, since we would rather
     * get it before we create the sync event.
     */

    RtlZeroMemory(pCommProp, bufferLength);

    Status = _IoControl( pTd,
                         hFile,
                         IOCTL_SERIAL_GET_PROPERTIES,
                         NULL,
                         0,
                         pCommProp,
                         bufferLength,
                         NULL );
    return( Status );
}


/*******************************************************************************
 *
 *  _GetCommState
 *
 *   This function returns the stae of the communication device specified by
 *   hFile parameter.
 *
 * ENTRY::
 *    pTd (input)
 *       Pointer to td data structure
 *    hFile (input)
 *       Specifies the communication device to be examined.
 *    pBuad (output)
 *       Pointer to a SERIAL_BAUD_RATE structure
 *    pLineControl (output)
 *       Pointer to a SERIAL_LINE_CONTROL structure
 *    pChars (ouptut)
 *       Pointer to a SERIAL_CHARS structure
 *    pHandFlow (ouptut)
 *       Pointer to a SERIAL_HANDFLOW structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/
 
NTSTATUS
_GetCommState(
    PTD pTd,
    HANDLE hFile,
    PSERIAL_BAUD_RATE pBaud,
    PSERIAL_LINE_CONTROL pLineControl,
    PSERIAL_CHARS pChars,
    PSERIAL_HANDFLOW pHandFlow
    )
{
    NTSTATUS Status;

    if ( ARGUMENT_PRESENT( pBaud ) ) {
        Status = _IoControl( pTd,
                             hFile,
                             IOCTL_SERIAL_GET_BAUD_RATE,
                             NULL,
                             0,
                             pBaud,
                             sizeof(*pBaud),
                             NULL );

        if ( !NT_SUCCESS(Status)) {
            return( Status );
        }
    }


    if ( ARGUMENT_PRESENT( pLineControl ) ) {
        Status = _IoControl( pTd,
                             hFile,
                             IOCTL_SERIAL_GET_LINE_CONTROL,
                             NULL,
                             0,
                             pLineControl,
                             sizeof(*pLineControl),
                             NULL );

        if ( !NT_SUCCESS(Status)) {
            return( Status );
        }
    }
    TRACE(( pTd->pContext, TC_TD, TT_API2,
            "TDASYNC: _GetCommState: Baud 0x%x, Sbits 0x%x, Par 0x%x, WLen 0x%x\n",
            pBaud->BaudRate,
            pLineControl->StopBits,
            pLineControl->Parity,
            pLineControl->WordLength
         ));

    if ( ARGUMENT_PRESENT( pChars ) ) {
        Status = _IoControl( pTd,
                             hFile,
                             IOCTL_SERIAL_GET_CHARS,
                             NULL,
                             0,
                             pChars,
                             sizeof(*pChars),
                             NULL ); 
        if ( !NT_SUCCESS(Status)) {
            return( Status );
        }
    }

    if ( ARGUMENT_PRESENT( pHandFlow ) ) {
        Status = _IoControl( pTd,
                             hFile,
                             IOCTL_SERIAL_GET_HANDFLOW,
                             NULL,
                             0,
                             pHandFlow,
                             sizeof(*pHandFlow),
                             NULL ); 
        if ( !NT_SUCCESS(Status)) {
            return( Status );
        }
    }
    TRACE(( pTd->pContext, TC_TD, TT_API2,
            "TDASYNC: _GetCommState: EOF 0x%x,ERR 0x%x,BRK 0x%x,EVT 0x%x,XON 0x%x,XOF 0x%x\n",
            pChars->EofChar,
            pChars->ErrorChar,
            pChars->BreakChar,
            pChars->EventChar,
            pChars->XonChar,
            pChars->XoffChar
         ));
    TRACE(( pTd->pContext, TC_TD, TT_API2,
            "TDASYNC: _GetCommState: CtrlHandS 0x%x,FlwRep 0x%x,XonL 0x%x,XoffL 0x%x\n",
            pHandFlow->ControlHandShake,
            pHandFlow->FlowReplace,
            pHandFlow->XonLimit,
            pHandFlow->XoffLimit
         ));

    return( STATUS_SUCCESS );
}

/*******************************************************************************
 *
 *  TdSetComState
 *
 *   The _SetCommState function sets the communication device specified by
 *   hfile parameter.  This function reinitializes all hardwae and controls
 *   as specified, but does not empty the transmit or receive queues.
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    hFile (input)
 *       Specifies the communication device to be examined.
 *    pBuad (input)
 *       Pointer to a SERIAL_BAUD_RATE structure
 *    pLineControl (input)
 *       Pointer to a SERIAL_LINE_CONTROL structure
 *    pChars (input)
 *       Pointer to a SERIAL_CHARS structure
 *    pHandFlow (input)
 *       Pointer to a SERIAL_HANDFLOW structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_SetCommState(
    PTD pTd,
    HANDLE hFile,
    PSERIAL_BAUD_RATE pBaud,
    PSERIAL_LINE_CONTROL pLineControl,
    PSERIAL_CHARS pChars,
    PSERIAL_HANDFLOW pHandFlow
    )
{
    NTSTATUS Status;
    SERIAL_BAUD_RATE LocalBaud;
    SERIAL_LINE_CONTROL LocalLineControl;
    SERIAL_CHARS LocalChars;
    SERIAL_HANDFLOW LocalHandFlow;

    /*
     * Get the current state before any changes are made, so that
     * in the case of an error, the original state be restored.
     */
    Status = _GetCommState( pTd,
                            hFile,
                            &LocalBaud,
                            &LocalLineControl,
                            &LocalChars,
                            &LocalHandFlow );

    TRACE(( pTd->pContext, TC_TD, TT_API2,
            "TDASYNC: _SetCommState: Baud 0x%x, Sbits 0x%x, Par 0x%x, WLen 0x%x\n",
            pBaud->BaudRate,
            pLineControl->StopBits,
            pLineControl->Parity,
            pLineControl->WordLength
         ));
    TRACE(( pTd->pContext, TC_TD, TT_API2,
            "TDASYNC: _SetCommState: EOF 0x%x,ERR 0x%x,BRK 0x%x,EVT 0x%x,XON 0x%x,XOF 0x%x\n",
            pChars->EofChar,
            pChars->ErrorChar,
            pChars->BreakChar,
            pChars->EventChar,
            pChars->XonChar,
            pChars->XoffChar
         ));
    TRACE(( pTd->pContext, TC_TD, TT_API2,
            "TDASYNC: _SetCommState: CtrlHandS 0x%x,FlwRep 0x%x,XonL 0x%x,XoffL 0x%x\n",
            pHandFlow->ControlHandShake,
            pHandFlow->FlowReplace,
            pHandFlow->XonLimit,
            pHandFlow->XoffLimit
         ));

    if ( NT_SUCCESS( Status ) ) {

        /*
         * Try to set the baud rate.  If we fail here, we just return
         * because we never actually got to set anything.
         */

        Status = _IoControl( pTd,
                             hFile,
                             IOCTL_SERIAL_SET_BAUD_RATE,
                             pBaud,
                             sizeof(*pBaud),
                             NULL, 
                             0, 
                             NULL );
        if ( !NT_SUCCESS( Status ) )
            goto badsetnorestore;

        Status = _IoControl( pTd,
                             hFile,
                             IOCTL_SERIAL_SET_LINE_CONTROL,
                             pLineControl,
                             sizeof(*pLineControl),
                             NULL, 
                             0, 
                             NULL );
        if ( !NT_SUCCESS( Status ) )
            goto badset;

        Status = _IoControl( pTd,
                             hFile,
                             IOCTL_SERIAL_SET_CHARS,
                             pChars,
                             sizeof(*pChars),
                             NULL, 
                             0, 
                             NULL );
        if ( !NT_SUCCESS( Status ) )
            goto badset;


        Status = _IoControl( pTd,
                             hFile,
                             IOCTL_SERIAL_SET_HANDFLOW,
                             pHandFlow,
                             sizeof(*pHandFlow),
                             NULL, 
                             0, 
                             NULL );
        if ( !NT_SUCCESS( Status ) )
            goto badset;

        return( STATUS_SUCCESS );
    }

    /*
     * Error Encountered, Restore previous state.
     */
badset:
    _SetCommState( pTd,
                   hFile,
                   &LocalBaud,
                   &LocalLineControl,
                   &LocalChars,
                   &LocalHandFlow );

badsetnorestore:
    return( Status );
}


/*******************************************************************************
 * 
 *  _PurgeComm
 *
 *   This function is used to purge all characters from the transmit
 *   or receive queues of the communication device specified by the
 *   hFile parameter.  The Flags parameter specifies what function
 *   is to be performed.
 * 
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    hFile (input)
 *       Specifies the communication device to be purged.
 *    Flags (input)
 *       Bit mask defining actions to be taken.
 * 
 * EXIT:
 *    STATUS_SUCCESS - no error
 * 
 ******************************************************************************/

NTSTATUS
_PurgeComm(
    PTD pTd,
    HANDLE hFile,
    ULONG Flags
    )
{
    NTSTATUS Status;

    Status = _IoControl( pTd,
                         hFile,
                         IOCTL_SERIAL_PURGE,
                         &Flags,
                         sizeof(Flags),
                         NULL, 
                         0, 
                         NULL );
    return( Status );
}


/*******************************************************************************
 *
 *
 *  _ClearCommError
 *
 *   In case of a communications error, such as a buffer overrun or
 *   framing error, the communications software will abort all
 *   read and write operations on the communication port.  No further
 *   read or write operations will be accepted until this function
 *   is called.
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    hFile (input)
 *       Specifies the communication device to be adjusted.
 *    pStat (output)
 *       Points to the SERIAL_STATUS structure that is to receive
 *       the device status.  The structure contains information
 *       about the communications device.
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_ClearCommError(
    PTD pTd,
    HANDLE hFile,
    PSERIAL_STATUS pStat
    )
{
    NTSTATUS Status;

    TRACE(( pTd->pContext, TC_TD, TT_API2,
            "TDASYNC: _ClearCommError: Entry\n"
         ));

    RtlZeroMemory( pStat, sizeof(*pStat) );

    Status = _IoControl( pTd,
                         hFile,
                         IOCTL_SERIAL_GET_COMMSTATUS,
                         NULL,
                         0,
                         pStat,
                         sizeof(*pStat),
                         NULL );
    return( Status );
}


/*******************************************************************************
 *
 *
 * _IoControl
 *
 *  The _IoControl function performs a specified I/O control function.
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    hFile (input)
 *       Supplies the open handle to the file that the overlapped structure.
 *    IoControlCode (input)
 *       Value of the I/O control command
 *    pIn (input)
 *       Pointer to the I/O control command's input buffer.
 *    InSize (input)
 *       Size (in bytes) of input buffer.
 *    pOut (output)
 *       Pointer to the I/O control command's output buffer.
 *    OutSize (input)
 *       Size (in bytes) of output buffer.
 *    pBytesWritten (output)
 *       Size (in bytes) of data actually written to the output buffer.
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_IoControl(
    PTD pTd,
    HANDLE hFile,
    ULONG IoControlCode,
    PVOID pIn,
    ULONG InSize,
    PVOID pOut,
    ULONG OutSize,
    PULONG pBytesWritten
    )
{
    IO_STATUS_BLOCK Iosb;
    HANDLE hEvent;
    NTSTATUS Status;

    TRACE(( pTd->pContext, TC_TD, TT_API2, "TDASYNC: _IoControl: Entry\n" ));

    Status = ZwCreateEvent(
                            &hEvent,
                            EVENT_ALL_ACCESS,
                            NULL,
                            NotificationEvent,
                            FALSE );
    if ( !NT_SUCCESS( Status ) ) {
        return Status;
    }

    Status = ZwDeviceIoControlFile( hFile,
                                    hEvent,
                                    NULL,
                                    NULL,
                                    &Iosb,
                                    IoControlCode,
                                    pIn,
                                    InSize,
                                    pOut,
                                    OutSize );

    if ( Status == STATUS_PENDING ) {
        PKEVENT pEventObject;

        // Operation must complete before return & IoStatusBlock destroyed

        Status = ObReferenceObjectByHandle( hEvent,
                                            EVENT_MODIFY_STATE,
                                            NULL,
                                            KernelMode,
                                            (PVOID *) &pEventObject,
                                            NULL );
        if ( NT_SUCCESS( Status ) ) {
            Status = IcaWaitForSingleObject( pTd->pContext,
                                             pEventObject,
                                             INFINITE );
            ObDereferenceObject( pEventObject );
            if ( NT_SUCCESS( Status ) ) {
                Status = Iosb.Status;
            }
        }
    }
    if ( ARGUMENT_PRESENT( pBytesWritten ) ) {
        *pBytesWritten = (ULONG)Iosb.Information;
    }
    ZwClose( hEvent );
    return Status;
}

/*******************************************************************************
 * 
 *  _OpenDevice
 *
 *  Open the communications device.
 * 
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 * 
 * EXIT:
 *    STATUS_SUCCESS - no error
 * 
 ******************************************************************************/

NTSTATUS
_OpenDevice(
	PTD pTd )
{

    PTDASYNC pTdAsync;
    PASYNCCONFIG pAsync;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING DeviceName;
    DEVICENAMEW TempDeviceName;
    NTSTATUS Status;

    /*
     *  Get pointer to async parameters
     */
    pTdAsync = (PTDASYNC) pTd->pPrivate;
    pAsync = &pTd->Params.Async;

    /*
     *  Open device
     */

    wcscpy( TempDeviceName, L"\\DosDevices\\" );
    wcscat( TempDeviceName, pAsync->DeviceName );

    TRACE(( pTd->pContext, TC_TD, TT_API2, 
        "TDASYNC: _OpenDevice, Opening \"%S\"\n",
        TempDeviceName ));

    RtlInitUnicodeString( &DeviceName, TempDeviceName);

    InitializeObjectAttributes( &Obja,
                                &DeviceName, 
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );
                                
    Status = ZwOpenFile( &pTdAsync->Endpoint.hDevice,
                         GENERIC_READ | GENERIC_WRITE |
                         SYNCHRONIZE | FILE_READ_ATTRIBUTES, 
                         &Obja,
                         &ioStatusBlock,
                         0, // ShareAccess
                         FILE_NON_DIRECTORY_FILE );

    if ( !NT_SUCCESS( Status ) ) {
        if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
            Status = STATUS_NO_SUCH_DEVICE;
        }
        goto badopen;
    }

    /*
     *  Create event for I/O status
     */
    Status = ZwCreateEvent( &pTdAsync->Endpoint.SignalIoStatus.hEvent,
                            EVENT_ALL_ACCESS,
                            NULL,
                            NotificationEvent,
                            FALSE );
    if ( !NT_SUCCESS( Status ) ) {
        TRACE(( pTd->pContext, TC_TD, TT_ERROR, 
                "TDASYNC: _OpenDevice, Create SignalEvent failed (0x%x)\n",
                Status ));
        goto badcreateevent;
    }

    TRACE(( pTd->pContext, TC_TD, TT_API2, 
            "TDASYNC: _OpenDevice, SignalIoStatus event handle 0x%x\n",
            pTdAsync->Endpoint.SignalIoStatus.hEvent ));
 
    return( Status );

/*=============================================================================
==   Error returns
=============================================================================*/
/*
 * Create of SignalIoStatus event failed.
 */
badcreateevent:
    ZwClose( pTdAsync->Endpoint.hDevice );
    pTdAsync->Endpoint.hDevice = NULL;

/*
 *  OpenFile failed
 */
badopen:
    return( Status );
}

/*******************************************************************************
 * 
 *  _PrepareDevice
 *
 *  Prepare the communications device for ICA use.
 * 
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 * 
 * EXIT:
 *    STATUS_SUCCESS - no error
 * 
 ******************************************************************************/

NTSTATUS
_PrepareDevice(
    PTD pTd )
{
    PTDASYNC pTdAsync;
    PASYNCCONFIG pAsync;
    SERIAL_TIMEOUTS SerialTo;
    NTSTATUS Status;

    /*
     *  Get pointer to async parameters
     */
    pTdAsync = (PTDASYNC) pTd->pPrivate;
    pAsync = &pTd->Params.Async;

    /*
     *  Obtain a referenced pointer to the file object.
     */
    Status = ObReferenceObjectByHandle (
                            pTdAsync->Endpoint.hDevice,
                            0,
                            *IoFileObjectType,
                            KernelMode,
                            (PVOID *)&pTdAsync->Endpoint.pFileObject,
                            NULL );

    if ( !NT_SUCCESS( Status ) ) {
        TRACE(( pTd->pContext, TC_TD, TT_ERROR, 
                "TDASYNC: _PrepareDevice, ObReferenceObjectByHandle Device failed (0x%x)\n",
                Status ));
        goto badhandleobj;
    }

    pTdAsync->Endpoint.pDeviceObject = IoGetRelatedDeviceObject(
                                        pTdAsync->Endpoint.pFileObject);

    /*
     *  Obtain a reference pointer to the SignalIoStatus Event
     */
    Status = ObReferenceObjectByHandle( pTdAsync->Endpoint.SignalIoStatus.hEvent,
                                        EVENT_MODIFY_STATE,
                                        NULL,
                                        KernelMode,
                                        (PVOID *)
                                         &pTdAsync->Endpoint.SignalIoStatus.pEventObject,
                                        NULL );
    if ( !NT_SUCCESS( Status ) ) {
        TRACE(( pTd->pContext, TC_TD, TT_ERROR, 
                "TDASYNC: _PrepareDevice, ObReferenceObjectByHandle SignalEventObject failed (0x%x)\n",
                Status ));
        goto badsigeventobj;
    }

    /*
     *  Set timeout parameters
     */
    RtlZeroMemory( &SerialTo, sizeof(SerialTo) );
    SerialTo.ReadIntervalTimeout = 1; // msec
    Status = _SetCommTimeouts( pTd, pTdAsync->Endpoint.hDevice, &SerialTo);
    if ( !NT_SUCCESS( Status ) ) {
	TRACE(( pTd->pContext, TC_TD, TT_ERROR, 
	    "TDASYNC: _SetCommTimeouts failed 0x%x\n",
	    Status ));
	goto badsetmode;
    } 

    /*
     *  Set communication parameters
     */
    Status = DeviceSetParams( pTd );
    if ( !NT_SUCCESS( Status ) ) {
	TRACE(( pTd->pContext, TC_TD, TT_ERROR, 
	    "TDASYNC: DeviceSetParams failed 0x%x\n",
	    Status ));
	goto badparams;
    }

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     * set of communication parameters failed
     * set of timeout mode failed
     */
badparams:
badsetmode:
    ObDereferenceObject( pTdAsync->Endpoint.SignalIoStatus.pEventObject );
    pTdAsync->Endpoint.SignalIoStatus.pEventObject = NULL;
    
badsigeventobj:
    ObDereferenceObject( pTdAsync->Endpoint.pFileObject );
    pTdAsync->Endpoint.pFileObject = NULL;

badhandleobj:
    return( Status );
}

/*******************************************************************************
 * 
 *  _FillInEndpoint
 *
 *  Fill in the endpoint to be returned via the ioctl's output buffer
 * 
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pEndpoint (output)
 *       pointer to buffer to return copy of endpoint structure
 *    Length (input)
 *       length of endpoint buffer
 *    pEndpointLength (output)
 *       pointer to address to return actual length of Endpoint
 * 
 * EXIT:
 *    STATUS_SUCCESS - no error
 *    STATUS_BUFFER_TOO_SMALL - endpoint buffer is too small
 * 
 ******************************************************************************/

NTSTATUS
_FillInEndpoint(
    PTD pTd, 
    PVOID pEndpoint,
    ULONG Length,
    PULONG pEndpointLength
    )
{
    PTDASYNC pTdAsync;
    ULONG ActualEndpointLength = sizeof(TDASYNC_ENDPOINT);
    PTDASYNC_ENDPOINT pEp = (PTDASYNC_ENDPOINT) pEndpoint;

    /*
     *  Always return actual size of Endpoint.
     */
    if ( ARGUMENT_PRESENT( pEndpointLength ) ) {
        *pEndpointLength = ActualEndpointLength;
    }

    /*
     *  Make sure endpoint buffer is large enough 
     */
    if ( ARGUMENT_PRESENT( pEndpoint ) && Length < ActualEndpointLength ) {
        TRACE(( pTd->pContext, TC_TD, TT_ERROR,
               "TDASYNC: DeviceConnectionWait, Buffer too small %d, %d req'd\n",
               Length, ActualEndpointLength ));
        return( STATUS_BUFFER_TOO_SMALL );
    }

    /*
     *  Get pointer to async parameters
     */
    pTdAsync = (PTDASYNC) pTd->pPrivate;

    /*
     * copy Endpoint structure
     */
    if ( ARGUMENT_PRESENT( pEndpoint ) ) {
        pEp->hDevice       = pTdAsync->Endpoint.hDevice;
        pEp->pFileObject   = pTdAsync->Endpoint.pFileObject;
        pEp->pDeviceObject = pTdAsync->Endpoint.pDeviceObject;
        pEp->SignalIoStatus.pEventObject =
            pTdAsync->Endpoint.SignalIoStatus.pEventObject;
        pEp->SignalIoStatus.hEvent = 
            pTdAsync->Endpoint.SignalIoStatus.hEvent;
    }

    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\td\tdicom\tdtdi.c ===
/****************************************************************************/
// tdtdi.c
//
// Common code for all TDI based Transport Drivers
//
// Copyright (C) 1998-2000 Microsoft Corporation
/****************************************************************************/

#include <ntddk.h>
#include <tdi.h>
#include <tdikrnl.h>

#include "tdtdi.h"

#include <winstaw.h>
#define _DEFCHARINFO_
#include <icadd.h>
#include <ctxdd.h>
#include <sdapi.h>

#include <td.h>
#include <tdi.h>


#define TDTDI_LISTEN_QUEUE_DEPTH 5  // This was hardcoded in afdcom

#ifndef min
#define min(a,b)    (((a) < (b)) ? (a) : (b))
#endif

#if DBG
ULONG DbgPrint(PCH Format, ...);
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define DBGENTER(x) DbgPrint x
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)
#else
#define DBGENTER(x)
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define DBGENTER(x)
#define TRACE0(x)
#define TRACE1(x)
#endif


/*

   DOCUMENT THIS INTERFACE FINALLY! 

   This is the best I can dig out of these existing interfaces.

   Common Sequences:

   Startup and Listen - DeviceOpen, DeviceCreateEndpoint, DeviceConnectionWait

    DeviceConnectionWait returns an internal handle to represent the connection
    it has listened for, accepted, and returned. This handle is useless for any
    operations, and is only good for feeding to DeviceOpenEndpoint to get
    an endpoint that can be used for communications.

   Connect - DeviceOpen, DeviceOpenEndpoint

    A DeviceOpen is done to create a new endpoint, then its handle
    from DeviceConnecti